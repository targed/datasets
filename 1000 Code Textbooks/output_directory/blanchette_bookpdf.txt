C++GUI Programming
with Qt 3
BRUCE
 PERENS
’ OPEN
 SOURCE
 SERIES
◆
C++ GUI Programming with Qt 3
Jasmin Blanchette, Mark Summerﬁeld
◆
Managing Linux Systems with Webmin: System 
Administration and Module Development
Jamie Cameron
◆
Understanding the Linux Virtual Memory Manager
Mel Gorman
◆
Implementing CIFS: The Common Internet File System
Christopher R. Hertel
◆
Embedded Software Development with eCos
Anthony J. Massa
◆
Rapid Application Development with Mozilla
Nigel McFarlane 
◆
The Linux Development Platform: Conﬁguring, Using, and Maintaining a Complete Programming Environment
Rafeeq Ur Rehman, Christopher Paul
◆
Intrusion Detection Systems with Snort: Advanced IDS Techniques with Snort, Apache, MySQL, PHP, and ACID
Rafeeq Ur Rehman
◆
The Ofﬁcial Samba-3 HOWTO and Reference Guide
 John H. Terpstra, Jelmer R. Vernooij, Editors
C++GUI Programming
with Qt 3
Jasmin Blanchette
Mark Summerﬁeld
Prentice Hall in association with Trolltech Press
Library of Congress Cataloging-in-Publication Data
ACIP catalog record for this book can be obtained from the Library of Congress
Editorial/Production Supervision: Kathleen M.Caren
Cover Design Director: Jerry VottaArt Director: Gail Cocker-BoguszManufacturing Buyer: Maura ZaldivarAcquisitions Editor: Jill HarryEditorial Assistant: Brenda MulliganMarketing Manager: Dan Depasquale
Copyright 2004 Trolltech AS
Published by Pearson Education, Inc.Publishing as Prentice Hall Professional Technical ReferenceUpper Saddle River, New Jersey 07458
This material may only be distributed subject to the terms and conditions set forth in the
Open Publication License, v1.0 or later (the latest version is available at
http://www.open-
content.org/openpub/ ).
Prentice Hall PTR offers excellent discounts on this book when ordered in quanti-
ty for bulk purchases or special sales. For more information, please contact: U.S.Corporate and Government Sales, 1-800-382-3419, corpsales@pearsontechgroup.com. For sales outside of the U.S., please contact: International Sales, 1-317-581-3793, international@pearsontechgroup.com.
Trolltech
,Q t,and the Trolltech logo are registered trademarks of Trolltech. OpenGL 
is a trademark of Silicon Graphics, Inc. in the United States and other countries. All
other company and product names mentioned herein are the trademarks or registeredtrademarks of their respective owners.
The authors,copyright holder,and publisher have taken care in the preparation of this book,
but make no expressed or implied warranty of any kind and assume no responsibility forerrors or omissions. The information in this book is furnished for informational use only, issubject to change without notice, and does not represent a commitment on the part of thecopyright holder or the publisher. No liability is assumed for incidental or consequentialdamages in connection with or arising out of the use of the information or programscontained herein.
The software described in this book is furnished under a license agreement or non-disclosure
agreement. The software may be used or copied only in accordance with the terms of theagreement.
Printed in the United States of America
First Printing
ISBN 0-13-124072-2Pearson Education Ltd.
Pearson Education Australia Pty., Limited
Pearson Education Singapore, Pte. Ltd.
Pearson Education North Asia Ltd.
Pearson Education Canada, Ltd.
Pearson Educación de Mexico, S.A. de C.V.
Pearson Education-Japan
Pearson Education Malaysia, Pte. Ltd.
Contents
Foreword ......................................................... i x
Preface ........................................................... x i
Acknowledgments ............................................... xiii
ABrief History of Qt ............................................ x v
Part I: Basic Qt
1.Getting Started ............................................... 3
Hello Qt ..................................................... 3
Making Connections ......................................... 5
Using the Reference Documentation .......................... 8
2.Creating Dialogs .............................................. 1 1
Subclassing QDialog ......................................... 1 1
Signals and Slots in Depth ................................... 1 8
Rapid Dialog Design ......................................... 2 1
Shape-Changing Dialogs ..................................... 2 8
Dynamic Dialogs ............................................ 3 3
Built-in Widget and Dialog Classes ........................... 3 3
3.Creating Main Windows ...................................... 3 9
Subclassing QMainWindow .................................. 4 0
Creating Menus and Toolbars ................................ 4 4
Implementing the File Menu ................................. 4 9
Setting Up the Status Bar .................................... 5 6
Using Dialogs ............................................... 5 8
Storing Settings ............................................. 6 3
Multiple Documents ......................................... 6 4
Splash Screens .............................................. 6 7
v
4.Implementing Application Functionality .................... 6 9
The Central Widget .......................................... 6 9
Subclassing QTable .......................................... 7 0
Loading and Saving ......................................... 7 7
Implementing the Edit Menu ................................. 8 0
Implementing the Other Menus .............................. 8 4
Subclassing QTableItem ..................................... 8 8
5.Creating Custom Widgets ..................................... 9 7
Customizing Qt Widgets ..................................... 9 7
Subclassing QWidget ........................................ 9 9
Integrating Custom Widgets with Qt Designer ................ 1 0 8
Double Buffering ............................................ 1 1 2
Part II: Intermediate Qt
6.Layout Management .......................................... 1 3 5
Basic Layouts ............................................... 1 3 5
Splitters .................................................... 1 4 0
Widget Stacks ............................................... 1 4 4
Scroll Views ................................................. 1 4 5
Dock Windows ............................................... 1 5 0
Multiple Document Interface ................................. 1 5 2
7.Event Processing ............................................. 1 6 3
Reimplementing Event Handlers ............................. 1 6 3
Installing Event Filters ...................................... 1 6 8
Staying Responsive During Intensive Processing .............. 1 7 1
8.2D and 3D Graphics ........................................... 1 7 5
Painting with QPainter ...................................... 1 7 5
Graphics with QCanvas ...................................... 1 8 5
Printing ..................................................... 1 9 8
Graphics with OpenGL ...................................... 2 0 9
9.Drag and Drop ................................................ 2 1 5
Enabling Drag and Drop ..................................... 2 1 5
Supporting Custom Drag Types .............................. 2 2 0
Advanced Clipboard Handling ................................ 2 2 4
vi
10.Input/Output ................................................. 2 2 7
Reading and Writing Binary Data ............................ 2 2 7
Reading and Writing Text .................................... 2 3 4
Handling Files and Directories ............................... 2 3 7
Inter-Process Communication ................................ 2 3 9
11.Container Classes ............................................ 2 4 3
Vectors ...................................................... 2 4 3
Lists ........................................................ 2 4 7
Maps ........................................................ 2 4 9
Pointer-Based Containers .................................... 2 5 1
QString and QVariant ....................................... 2 5 4
12.Databases .................................................... 2 6 1
Connecting and Querying .................................... 2 6 1
Presenting Data in Tabular Form ............................ 2 6 6
Creating Data-Aware Forms ................................. 2 7 5
13.Networking .................................................. 2 8 3
Using QFtp ................................................. 2 8 3
Using QHttp ................................................ 2 8 9
TCP Networking with QSocket ............................... 2 9 1
UDP Networking with QSocketDevice ........................ 3 0 1
14.XML .......................................................... 3 0 7
Reading XML with SAX ...................................... 3 0 7
Reading XML with DOM ..................................... 3 1 2
Writing XML ................................................ 3 1 6
15.Internationalization ......................................... 3 1 9
Working with Unicode ....................................... 3 1 9
Making Applications Translation-Aware ...................... 3 2 3
Dynamic Language Switching ................................ 3 2 9
Translating Applications ..................................... 3 3 4
16.Providing Online Help ....................................... 3 3 9
Tooltips, Status Tips, and “What’s This?” Help ................. 3 3 9
Using QTextBrowser as a Simple Help Engine ................ 3 4 2
Using Qt Assistant for Powerful Online Help .................. 3 4 6
vii
17.Multithreading .............................................. 3 4 9
Working with Threads ....................................... 3 4 9
Communicating with the GUI Thread ........................ 3 5 9
Using Qt’s Classes in Non-GUI Threads ....................... 3 6 3
18.Platform-Speciﬁc Features .................................. 3 6 7
Interfacing with Native APIs ................................. 3 6 7
Using ActiveX ............................................... 3 7 1
Session Management ........................................ 3 8 4
Appendices
A.Installing Qt .................................................. 3 9 3
ANote on Licensing ......................................... 3 9 3
Installing Qt/Windows ....................................... 3 9 4
Installing Qt/Mac ............................................ 3 9 5
Installing Qt/X11 ............................................ 3 9 7
B.Qt’s Class Hierarchy .......................................... 3 9 9
Index ............................................................. 4 0 3
viii
Foreword
Why Qt? Why do programmers like us choose Qt? Sure, there are the obvious
answers: Qt’s single-source compatibility, its feature richness, its C ++perfor-
mance, the availability of the source code, its documentation, the high-qualitytechnical support, and all the other items mentioned in Trolltech’s glossy mar-keting materials. This is all very well, but it misses the most important point:Qt is successful because programmers likeit.
How come programmers like one technology, but dislike another? Personally,
Ibelieve software engineers enjoy technology that feels right, but dislike ev-
erything that doesn’t. How else can we explain that some of the brightest pro-grammers need help to program a VCR, or that most engineers seem to havetrouble operating the company’s phone system? I for one am perfectly capa-ble of memorizing sequences of random numbers and commands, but if theseare required to control my answering machine, I’d prefer not to have one. AtTrolltech, our phone system forces us to hold the ‘ ∗’key pressed down for two
seconds before we are allowed to type in the other person’s extension number.If you forget to do this but start typing the extension immediately, you haveto dial the entire number again. Why ‘ ∗’? Why not ‘#’, or ‘1’, or ‘5’, or any of
the other twenty keys on the phone? Why two seconds and not one, or three,or one and a half? Why anything at all? I ﬁnd the phone so irritating that Iavoid using it whenever I can. Nobody likes having to do random things, espe-
cially when those random things apparently depend on some equally randomcontext you wish you didn’t have to know about in the ﬁrst place.
Programming can be a lot like using our phone system, only worse. And this
is where Qt comes to the rescue. Qt is different. For one thing,Qt makes sense.And for another, Qt is fun. Qt lets you concentrate on your tasks. When Qt’soriginal architects faced a problem, they didn’t just look for a good solution, oraquick solution, or the simplest solution. They looked for the right solution,
and then they documented it. Granted they made mistakes,and granted someof their design decisions didn’t pass the test of time, but they still got a lot ofthings right, and what wasn’t right could and can be corrected. You can seethis by the fact that a system originally designed to bridge Windows 95 andUnix/Motif now uniﬁes modern desktop systems as diverse as Windows XP,Mac OS X, and GNU/Linux with KDE.
Long before Qt became so popular and so widely used, the dedication of Qt’s
developers to ﬁnding the right solutions made Qt special. That dedication isjust as strong today and affects everyone who maintains and develops Qt. Forus, working on Qt is a responsibility and a privilege. We are proud of helpingto make your professional and open source lives easier and more enjoyable.
ix
One of the things that makes Qt a pleasure to use is its online documentation.
But the documentation’s focus is primarily on individual classes, with littlesaid about how to build sophisticated real-world applications. This excellentbook ﬁlls that gap. It shows you what Qt has to offer, how to program Qtthe “Qt way”, and how to get the best from Qt. The book will teach a C ++
programmer how to program Qt, and provides enough advanced material to
satisfy experienced Qt programmers. The book is packed with good examples,advice, and explanations, and will be the text that we use to induct all newprogrammers who join Trolltech.
Nowadays, there are a vast number of commercial and free Qt applications
available for purchase or download. Some are specialized for particular
vertical markets, while others are aimed at the mass-market. Seeing so manyapplications built with Qt ﬁlls us with pride and inspires us to make Qt evenbetter. And with the help of this book, there will be more and higher qualityQt applications than ever before.
Matthias Ettrich
Oslo, Norway
November 2003
x
Preface
The Qt toolkit is a C ++class library and a set of tools for building multiplat-
form GUI programs using a “write once, compile anywhere” approach. Qt letsprogrammers use a single source tree for applications that will run on Win-dows 95 to XP, Mac OS X, Linux, Solaris, HP-UX, and many other versions ofUnix with X11. A version of Qt is also available for Embedded Linux, with thesame API.
The purpose of this book is to teach you how to write GUI programs using Qt 3.
The book starts with “Hello Qt” and quickly moves on to more advanced topics,such as creating custom widgets and providing drag and drop. The text iscomplemented by a CD that contains the source code of the example programs.The CD also provides Qt and Borland C ++for Windows, Qt for Unix, and Qt
for Mac OS X. Appendix A explains how to install the software.
The book focuses on explaining good idiomatic Qt 3 programming techniques
rather than simply rehashing or summarizing Qt’s extensive online documen-tation. And because we are involved in the development of Qt 4, we have triedto ensure that most of what we teach here will still be valid and sensible forQt 4.
It is assumed that you have a basic knowledge of C ++.The code examples use
asubset of C ++,avoiding many C ++features that are rarely needed when
programming Qt. In the few places where a more advanced C ++construct is
unavoidable, it is explained as it is used.
Qt made its reputation as a multiplatform toolkit, but because of its intuitive
and powerful API, many organizations use Qt for single-platform develop-ment. Adobe Photoshop Album is just one example of a mass-market Windowsapplication written in Qt. Many sophisticated software systems in verticalmarkets, such as 3D animation tools, digital ﬁlm processing, electronic designautomation (for chip design), oil and gas exploration, ﬁnancial services, andmedical imaging, are built with Qt. If you are making a living with a success-ful Windows product written in Qt, you can easily create new markets in theMac OS X and Linux worlds simply by recompiling.
Qt is available under various licenses. If you want to build commercial
applications, you must buy a commercial license; if you want to build opensource programs,you can use a non-commercial Qt edition. (The editions of Qton the CD are non-commercial.) Qt is the foundation on which the K DesktopEnvironment (KDE) and the many open source applications that go with itare built.
xi
In addition to Qt’s hundreds of classes, there are add-ons that extend Qt’s
scope and power. Some of these products,like the Qt/Motif integration moduleand Qt Script for Applications (QSA), are supplied by Trolltech, while othersare provided by companies and by the open source community. See
http://
www.trolltech.com/products/3rdparty/ for information on Qt add-ons. Qt also
has a well-established and thriving user community that uses the qt-interest
mailing list; see http://lists.trolltech.com/ for details.
The book is divided into two parts. Part I covers all the concepts and practices
necessary for programming GUI applications using Qt. Knowledge of thispart alone is sufﬁcient to write useful GUI applications. Part II covers centralQt topics in more depth and provides more specialized and advanced material.The chapters of Part II can be read in any order, but they assume familiaritywith the contents of Part I.
If you spot errors in the book, have suggestions for the next edition, or want
to give us feedback, we would be delighted to hear from you. You can reach usat
jasmin.blanchette@trolltech.com andmark.summerfield@trolltech.com .The
errata will be placed on http://vig.prenhall.com/catalog/academic/product/
0,4096,0131240722,00.html .
xii
Acknowledgments
Our ﬁrst acknowledgment goes to Eirik Chambe-Eng, Trolltech’s president.
Eirik not only enthusiastically encouraged us to write the book, he alsoallowed us to spend a considerable amount of our work time writing it. Eirikand Trolltech CEO Haavard Nord both read the manuscript and providedvaluable feedback. Their generosity and foresight was aided and abetted byMatthias Ettrich,Trolltech’s lead developer and our boss. Matthias cheerfullyaccepted our neglect of duty as we obsessed over the writing of this book andgave us a lot of advice on good Qt programming style.
Weasked two Qt customers, Paul Curtis and Klaus Schmidinger, to be our
external reviewers. Both are Qt experts with an amazing attention to tech-nical detail, which they proved by spotting some very subtle errors in ourmanuscript and suggesting numerous improvements.
Within Trolltech, alongside Matthias, our most stalwart reviewer was Regi-
nald Stadlbauer.
#His technical insight was invaluable, and he taught us how
to do some things in Qt that we didn’t even know were possible.
Our other key reviewers within Trolltech were Trenton Schulz, Andy Shaw,
and Andreas Aardal Hanssen. Trenton and Andy gave feedback on all aspectsof the book and were especially helpful regarding Qt/Mac and Qt/Windows.Andreas gave us invaluable help reﬁning Part I.
In addition to the reviewers mentioned above, we received expert help from
Warwick Allison (2D graphics), Eirik Chambe-Eng (Qt’s history), Matthias
Ettrich (event processing and custom widgets), Harald Fernengel (databas-es), Volker Hilsheimer (ActiveX), Bradley Hughes (multithreading), TrondKjernåsen (3D graphics and databases), Lars Knoll (2D graphics), Sam Mag-nuson (
qmake ), Dimitri Papadopoulos (Qt/X11), Paul Olav Tvete (custom wid-
gets and Qt/Embedded), Rainer Schmid (networking and XML), and GunnarSletta (event processing).
Extra thanks are due to Trolltech’s support team for helping to keep our
support load under control while the book consumed so much of our time, andto Trolltech’s system administrators for keeping our machines running andour networks communicating throughout the project.
Weare also grateful to Troy Kitch from Borland for giving us permission to
include Borland C ++compilers on the accompanying CD, and to the SQLite
developers for putting their database into the public domain.
#Reginald has now moved to Germany, where he co-founded froglogic, a software consultancy.
xiii
On the production side, Rainer Schmid led the team that created the accom-
panying CD, ably supported by Harald Fernengel and Andy Shaw. Troll-tech’s Cathrine Bore handled the contracts and legalities on our behalf. JeffKingston,author of the Lout typesetting tool,gave us advice and enhanced thetool in the light of our feedback. Jill Harry of Prentice Hall had faith in theproject from the start and ensured that all the practical matters were smooth-ly handled, leaving us free to concentrate on the writing. And Lisa Iarkowskiturned our camera-ready manuscript into the beautiful volume you now holdin your hands.
xiv
ABrief History of Qt
The Qt toolkit ﬁrst became publicly available in May 1995. It was initially
developed by Haavard Nord (Trolltech’s CEO) and Eirik Chambe-Eng (Troll-tech’s president). Haavard and Eirik met each other at the Norwegian Insti-tute of Technology in Trondheim, Norway, where they both graduated withmaster’s degrees in computer science.
Haavard’s interest in C ++GUI development began in 1988 when he was com-
missioned by a Swedish company to design and implement a C ++GUI toolk-
it. A couple of years later, in the summer of 1990, Haavard and Eirik wereworking together on a C ++database application for ultrasound images. The
system needed to be able to run with a GUI on Unix, Macintosh, and Windows.One day that summer, Haavard and Eirik went outside to enjoy the sunshine,and as they sat on a park bench, Haavard said, “We need an object-orienteddisplay system.” The resulting discussion laid the intellectual foundation forthe object-oriented multiplatform GUI toolkit they would soon go on to build.
In 1991, Haavard started writing the classes that eventually became Qt, col-
laborating with Eirik on the design. The following year,Eirik came up the ideafor “signals and slots”, a simple but powerful GUI programming paradigm.Haavard took the idea and produced a hand-coded implementation. By 1993,Haavard and Eirik had developed Qt’s ﬁrst graphics kernel and were able toimplement their own widgets. At the end of the year, Haavard suggested thatthey go into business together to build “the world’s best C ++GUI toolkit”.
The year 1994 began inauspiciously with the two young programmerswanting
to enter a well established market, with no customers, an unﬁnished product,and no money. Fortunately,both their wives had work and were willing to sup-port their husbands for the two years Eirik and Haavard expected to need todevelop the product and start earning an income.
They chose ‘Q’ as the class preﬁx because the letter looked beautiful in Haa-
vard’s Emacs font. The ‘t’ was added to stand for “toolkit”, inspired by “Xt”,the X Toolkit. The company was incorporated on 4 March 1994, originally as“Quasar Technologies”, then as “Troll Tech”, and today as “Trolltech”.
In April 1995, thanks to a contact made through one of Haavard’s University
professors, the Norwegian company Metis gave them a contract to developsoftware based on Qt. Around this time, Trolltech hired Arnt Gulbrandsen,
#
who devised and implemented an ingenious documentation system as well ascontributing to Qt’s code.
#Arnt left the company a few years ago to pursue his career in Germany.
xv
On 20 May 1995, Qt 0.90 was uploaded to sunsite.unc.edu .Six days later, the
release was announced on comp.os.linux.announce .This was Qt’s ﬁrst public
release. Qt could be used for both Windows and Unix development, offeringthe same API on both platforms. Qt was available under two licenses fromday one: A commercial license was required for commercial developmentand a free software edition was available for open source development. TheMetis contract kept Trolltech aﬂoat, while for ten long months no one boughtacommercial Qt license.
In March 1996, the European Space Agency became the second Qt customer,
with a purchase of ten commercial licenses. With unwavering faith, Eirikand Haavard hired another developer. Qt 0.97 was released at the end of May,and on 24 September 1996, Qt 1.0 came out. By the end of the year, Qt hadreached version 1.1; eight customers, each in a different country, had bought18 licenses between them. This year also saw the founding of the KDE project,led by Matthias Ettrich.
Qt 1.2 was released in April 1997.Matthias Ettrich’s decision to use Qt to build
KDE helped Qt become the de-facto standard for C ++GUI development on
Linux. Qt 1.3 was released in September 1997.
Matthias joined Trolltech in 1998, and the last major Qt 1 release, 1.40, was
made in September of that year. Qt 2.0 was released in June 1999. Qt 2 hadmany major architectural changes and was a much stronger and more matureproduct than its predecessor. It also featured forty new classes and Unicodesupport. Qt 2 had a new open source license, the Q Public License (QPL),which complied to the Open Source Deﬁnition. In August 1999, Qt won theLinuxWorld award for best library/tool. Around this time, Trolltech Pty Ltd(Australia) was established.
Trolltech released Qt/Embedded in 2000. It was designed to run on Embedded
Linux devices and provided is own window system as a lightweight replace-ment for X11. Both Qt/Embedded and Qt/X11 were now offered under thewidely used GNU General Public License (GPL) as well as under commerciallicenses. By the end of 2000, Trolltech had established Trolltech Inc. (USA)and had released the ﬁrst version of Qtopia, an environment for handhelddevices. Qt/Embedded won the LinuxWorld “Best Embedded Linux Solution”award in both 2001 and 2002.
Qt 3.0 was released in 2001. Qt was now available on Windows, Unix, Linux,
Embedded Linux, and Mac OS X. Qt 3.0 provided 42 new classes and the codesurpassed 500,000 lines. Qt 3.0 won the Software Development Times “JoltProductivity Award” in 2002.
Trolltech’s sales have doubled year on year since the company’s birth. This
success is a reﬂection both of the quality of Qt and of how enjoyable it is touse. For most of the company’s existence, sales and marketing were handledby just a couple of people. Yet, in less than a decade, Qt has gone from beinga“secret” product, known only to a select group of professionals, to having
thousands of customers and tens of thousands of open source developers allaround the world.
xvi
Part I
Basic Qt

11
Getting Started•Hello Qt
•Making Connections
•Using the Reference
Documentation
This chapter shows how to combine basic C ++with the functionality provided
by Qt to create a few small graphical user interface (GUI) applications. Thischapter also introduces two key Qt ideas: “signals and slots” and layouts. InChapter 2, we will go into more depth, and in Chapter 3, we will start buildingarealistic application.
Hello Qt
Here’s a very simple Qt program:
001#include <qapplication.h>
002#include <qlabel.h>
003int main(int argc, char *argv[])
004{
005    QApplication app(argc, argv);
006    QLabel *label = new QLabel("Hello Qt!", 0);
007    app.setMainWidget(label);
008    label->show();
009    return app.exec();
010}
Wewill ﬁrst study it line by line, then we will see how to compile and run it.
Lines 1 and 2 include the deﬁnitions of the QApplication andQLabel classes.
Line 5 creates a QApplication object to manage application-wide resources.
TheQApplication constructor requires argc andargv because Qt supports a
few command-line arguments of its own.
Line 6 creates a QLabel widget that displays “Hello Qt!”. In Qt terminology, a
widget is a visual element in a user interface. Buttons, menus, scroll bars, and
frames are all examples of widgets. Widgets can contain other widgets; for
3
4 1. Getting Started
example, an application window is usually a widget that contains a QMenuBar ,a
QToolBar ,aQStatusBar ,and some other widgets. The 0 argument to the QLabel
constructor (a null pointer) means that the widget is a window in its own right,
not a widget inside another window.
Line 7 makes the label the application’smain widget. When the user closes the
main widget (by clicking Xin the window’s title bar, for example), the program
terminates. Without a main widget, the program would keep running in thebackground even after the user has closed the window.
Line 8 makes the label visible. Widgets are always created hidden, so that we
can customize them before showing them, thereby avoiding ﬂicker.
Line 9 passes control of the application on to Qt. At this point, the program
enters a kind of stand-by mode, where it waits for user actions such as mouseclicks and key presses.
User actions generate events (also called “messages”) to which the program
can respond, usually by executing one or more functions. In this respect, GUIapplications differ drastically from conventional batch programs, which typi-cally process input, produce results, and terminate without human interven-tion.
Figure 1.1. Hello on Windows XP
It is now time to test the program on your machine. First, you will need to in-
stall Qt 3.2 (or a later Qt 3 release), a process that is explained in Appendix A.From now on, we will assume that you have a correctly installed copy of Qt 3.2
and that Qt’s
bindirectory is in your PATH environment variable. (On Windows,
this is done automatically by the Qt installation program, so you don’t need toworry about it.)
Youwill also need the Hello program’s source code in a ﬁle called
hello.cpp in
adirectory called hello .You can type in hello.cpp yourself, or copy it from the
CD provided with this book, where it is available as \examples\chap01\hello\
hello.cpp .
From a command prompt, change directory to hello ,then type
qmake -project
to create a platform-independent project ﬁle ( hello.pro ), then type
qmake hello.pro
to create a platform-speciﬁc makeﬁle from the project ﬁle. Run make to build
the program, and run the program by typing hello on Windows, ./hello on
Unix, and open hello.app on Mac OS X. If you are using Microsoft Visual C ++,
Hello Qt 5
you will need to run nmake instead of make.Alternatively, you can create a
Visual Studio project ﬁle from hello.pro by typing
qmake -tp vc hello.pro
and then build the program in Visual Studio.
Figure 1.2. Alabel with basic HTML formatting
Now let’s have some fun: We will brighten up the label by using some simple
HTML-style formatting. This can be done by replacing the line
QLabel *label = new QLabel("Hello Qt!", 0);
with
QLabel *label = new QLabel("<h2><i>Hello</i> "
                           "<font color=red>Qt!</font></h2>", 0);
and rebuilding the application.
Making Connections
The next example illustrates how to respond to user actions. The application
consists of a button that the user can click to quit. The source code is verysimilar to Hello, except that we are using a
QPushButton instead of a QLabel as
our main widget, and we are connecting a user action (clicking a button) to apiece of code.
This application’s source code is on the CD in the ﬁle
\examples\chap01\quit\
quit.cpp .
Figure 1.3. The Quit application
001#include <qapplication.h>
002#include <qpushbutton.h>
003int main(int argc, char *argv[])
004{
005    QApplication app(argc, argv);
006    QPushButton *button = new QPushButton("Quit", 0);
6 1. Getting Started
007    QObject::connect(button, SIGNAL(clicked()),
008                     &app, SLOT(quit()));
009    app.setMainWidget(button);
010    button->show();
011    return app.exec();
012}
Qt’s widgets emit signals to indicate that a user action or a change of state has
occurred.#Forinstance, QPushButton emits a clicked() signal when the user
clicks the button. A signal can be connected to a function (called a slotin that
context), so that when the signal is emitted, the slot is automatically executed.In our example, we connect the button’s
clicked() signal to the QApplication
object’s quit() slot. The SIGNAL() andSLOT() macros are part of the syntax;
they are explained in more detail in the next chapter.
Wewill now build the application. We assume that you have created a direc-
tory called quit containing quit.cpp .Runqmake in thequit directory to gener-
ate the project ﬁle, then run it again to generate a makeﬁle:
qmake -project
qmake quit.pro
Now build the application, and run it. If you click Quit,orpress Space (which
presses the button), the application will terminate.
The next example demonstrates how to use signals and slots to synchronize
two widgets. The application asks for the user’s age, which the user can enterby manipulating either a spin box or a slider.
Figure 1.4. The Age application
The application consists of three widgets: a QSpinBox ,aQSlider ,and aQHBox
(horizontal layout box). The QHBox is the application’s main widget. The
QSpinBox and the QSlider are rendered inside the QHBox ;they are children of
theQHBox .
Caption 
QHBox
QSpinBox QSlider
Figure 1.5. The Age application’s widgets
#Qt signals are unrelated to Unix signals. In this book, we are only concerned with Qt signals.
Making Connections 7
001#include <qapplication.h>
002#include <qhbox.h>
003#include <qslider.h>
004#include <qspinbox.h>
005int main(int argc, char *argv[])
006{
007    QApplication app(argc, argv);
008    QHBox *hbox = new QHBox(0);
009    hbox->setCaption("Enter Your Age");
010    hbox->setMargin(6);
011    hbox->setSpacing(6);
012    QSpinBox *spinBox = new QSpinBox(hbox);
013    QSlider *slider = new QSlider(Qt::Horizontal, hbox);
014    spinBox->setRange(0, 130);
015    slider->setRange(0, 130);
016    QObject::connect(spinBox, SIGNAL(valueChanged(int)),
017                     slider, SLOT(setValue(int)));
018    QObject::connect(slider, SIGNAL(valueChanged(int)),
019                     spinBox, SLOT(setValue(int)));
020    spinBox->setValue(35);
021    app.setMainWidget(hbox);
022    hbox->show();
023    return app.exec();
024}
Lines 8 to 11 set up the QHBox .#WecallsetCaption() to set the text displayed
in the window’s title bar. Then we put some space (6 pixels) around and inbetween the child widgets.
Lines 12 and 13 create a
QSpinBox and aQSlider with the QHBox as the parent.
Even though we didn’t set the position or size of any widget explicitly, the
QSpinBox andQSlider appear nicely laid out side by side inside the QHBox .This
is because QHBox automatically assigns reasonable positions and sizes to its
children based on their needs. Qt provides many classes like QHBox to free us
from the chore of hard-coding screen positions in our applications.
Lines 14 and 15 set the valid range for the spin box and the slider. (We can
safely assume that the user is at most 130 years old.) The two connect() calls
shown in lines 16 to 19 ensure that the spin box and the slider are synchro-nized so that they always show the same value. Whenever the value of onewidget changes, its
valueChanged(int) signal is emitted, and the setValue(int)
slot of the other widget is called with the new value.
Line 20 sets the spin box value to 35. When this happens, the QSpinBox emits
thevalueChanged(int) signal with an intargument of 35. This argument is
#If you get a compiler error on the QHBox constructor, it means that you are using an older version
of Qt. Make sure that you are using Qt 3.2.0 or a later Qt 3 release.
8 1. Getting Started
passed to the QSlider ’ssetValue(int) slot,which sets the slider value to 35.The
slider then emits the valueChanged(int) signal, because its own value changed,
triggering the spin box’s setValue(int) slot. But at this point, setValue(int)
doesn’t emit any signal, since the spin box value is already 35. This preventsinﬁnite recursion. Figure 1.6 summarizes the situation.
1. 00¤ SSSSSSSSSSSSSS
setValue(35)
2. 35¤ SSSSSSSSSSSSSS
valueChanged(35)
setValue(35)
3. 35¤ SSSSSSSSSSSSSS
valueChanged(35)
setValue(35)
4. 35¤ SSSSSSSSSSSSSS
Figure 1.6. Changing one value changes both
Line 22 shows the QHBox and its two child widgets.
Qt’s approach to building user interfacesis simple to understand and very ﬂex-
ible. The most common pattern that Qt programmers use is to instantiate therequired widgetsand then set their propertiesas necessary. Programmersaddthe widgetsto layouts,which automatically take care of sizing and positioning.User interface behavior is managed by connecting widgets together using Qt’ssignals and slots mechanism.
Using the Reference Documentation
Qt’s reference documentation is an essential tool for any Qt developer, sinceit covers every class and function in Qt. (Qt 3.2 includes over 400 publicclasses and over 6000 functions.) This book makes use of many Qt classes andfunctions, but it doesn’t mention them all, nor does it provide all the details ofthose it does mention. To get the most beneﬁt from Qt, you should familiarizeyourself with the Qt reference documentation.
Using the Reference Documentation 9
Widget Styles
The screenshots we have seen so far have been taken on Windows XP,
but Qt applications look native on every supported platform. Qt achievesthis by emulating the platform’s look and feel, rather than wrapping aparticular platform or toolkit’s widget set.
Windows Motif
MotifPlus CDE
Platinum SGI
Figure 1.7. Styles available everywhere
Qt application users can override the default style by using the -style
command-line option. For example, to launch the Age application with
Platinum style on Unix, simply type
./age -style=Platinum
on the command line.
Windows XP Mac
Figure 1.8. Platform-speciﬁc styles
Unlike the other styles, the Windows XP and Mac styles are only available
on their native platforms, since they rely on the platforms’ theme engines.
The documentation is available in HTML format in Qt’s doc\html directo-
ry and can be read using any web browser. You can also use Qt Assistant ,
the Qt help browser, whose powerful search and indexing features make itquicker and easier to use than a web browser. To launch Qt Assistant ,click
Qt 3.2.x|Qt Assistant in the Start menu on Windows, type assistant on the com-
mand line on Unix, or double-click assistant in the Mac OS X Finder.
10 1. Getting Started
Figure 1.9. Qt’s documentation in Qt Assistant
The links in the “API Reference” section on the home page provide different
ways of navigating Qt’s classes. The “All Classes” page lists every class in Qt’s
API. The “Main Classes” page lists only the most commonly used Qt classes.As an exercise, you might want to look up the classes and functions that wehave used in this chapter. Note that inherited functions are documented inthe base class; for example,
QPushButton has noshow() function of its own, but
it inherits one from its ancestor QWidget .Figure 1.10 shows how the classes we
have seen so far relate to each other.
Qt
QObject
QApplication QWidget
QButton QFrame QSlider QSpinBox
QPushButton QHBox QLabel
Figure 1.10. Inheritance tree for the Qt classes seen so far
The reference documentation for the current version of Qt and for some
earlier versions is available online at http://doc.trolltech.com/ .This site also
hosts selected articles from Qt Quarterly ,the Qt programmers’ newsletter sent
to all commercial licensees.
22
Creating Dialogs•Subclassing QDialog
•Signals and Slots in Depth
•Rapid Dialog Design
•Shape-Changing Dialogs
•Dynamic Dialogs
•Built-in Widget and Dialog
Classes
This chapter will teach you how to create dialog boxes using Qt. They are
called dialog boxes, or simply “dialogs”, because they provide a means bywhich users and applications can “talk to” each other.
Dialogs present users with options and choices, and allow them to set the op-
tions to their preferred values and to make their choice. Most GUI applica-tions consist of a main window with a menu bar and toolbar,along with dozensof dialogs that complement the main window. It is also possible to create dia-log applications that respond directly to the user’s choices by performing theappropriate actions (for example, a calculator application).
Wewill create our ﬁrst dialog purely by writing code to show how it is done.
Then we will see how to build dialogs using Qt Designer ,Qt’s visual design
tool. Using Qt Designer is a lot faster than hand-coding and makes it simple
to test different designs and to change designs later.
Subclassing QDialog
Our ﬁrst example is a Find dialog written entirely in C ++.Wewill implement
the dialog as a class in its own right. By doing so, we make it an independent,self-contained component, with its own signals and slots.
Figure 2.1. Find dialog on Linux (KDE)
11
12 2. Creating Dialogs
The source code is spread across two ﬁles: finddialog.h andfinddialog.cpp .W e
will start with finddialog.h .
001#ifndef FINDDIALOG_H
002#define FINDDIALOG_H
003#include <qdialog.h>
004class QCheckBox;
005class QLabel;
006class QLineEdit;
007class QPushButton;
Lines 1 and 2 (and 27) prevent the header ﬁle from multiple inclusions.
Line 3 includes the deﬁnition of QDialog ,the base class for dialogs in Qt.
QDialog inherits QWidget .
Lines 4 to 7 are forward declarations of the Qt classes that we will use to im-
plement the dialog. A forward declaration tells the C ++compiler that a class
exists, without giving all the detail that a class deﬁnition (usually located in aheader ﬁle of its own) provides. We will say more about this shortly.
Wethen deﬁne
FindDialog as a subclass of QDialog :
008class FindDialog : public QDialog
009{
010    Q_OBJECT
011public:
012    FindDialog(QWidget *parent = 0, const char *name = 0);
TheQ_OBJECT macro at the beginning of the class deﬁnition is necessary for all
classes that deﬁne signals or slots.
TheFindDialog constructor is typical of Qt widget classes. The parent param-
eter speciﬁes the parent widget, and the name parameter gives the widget a
name. The name is optional; it is primarily used for debugging and testing.
013signals:
014    void findNext(const QString &str, bool caseSensitive);
015    void findPrev(const QString &str, bool caseSensitive);
Thesignals section declares two signals that the dialog emits when the user
clicks the Findbutton. If the Search backward option is enabled, the dialog emits
findPrev() ;otherwise, it emits findNext() .
Thesignals keyword is actually a macro. The C ++preprocessor converts it
into standard C ++before the compiler sees it.
016private slots:
017    void findClicked();
018    void enableFindButton(const QString &text);
019private:
020    QLabel *label;
021    QLineEdit *lineEdit;
022    QCheckBox *caseCheckBox;
Subclassing QDialog 13
023    QCheckBox *backwardCheckBox;
024    QPushButton *findButton;
025    QPushButton *closeButton;
026};
027#endif
In the class’s private section, we declare two slots. To implement the slots, we
will need to access most of the dialog’s child widgets, so we keep pointers tothem as well. The
slots keyword is, like signals ,amacro that expands into a
construct that the C ++compiler can digest.
Since all the variables are pointers and we don’t use them in the header ﬁle,
the compiler doesn’t need the full class deﬁnitions; forward declarations aresufﬁcient. We could have included the relevant header ﬁles (
<qcheckbox.h> ,
<qlabel.h> ,etc.) instead, but using forward declarations when it is possible
makes compiling somewhat faster.
Wewill now look at finddialog.cpp ,which contains the implementation of the
FindDialog class:
001#include <qcheckbox.h>
002#include <qlabel.h>
003#include <qlayout.h>
004#include <qlineedit.h>
005#include <qpushbutton.h>
006#include "finddialog.h"
First, we include the header ﬁles for all the Qt classes we use, in addition to
finddialog.h .For most Qt classes, the header ﬁle is a lower-case version of the
class name with a .hextension.
007FindDialog::FindDialog(QWidget *parent, const char *name)
008    : QDialog(parent, name)
009{
010    setCaption(tr("Find"));
011    label = new QLabel(tr("Find &what:"), this);
012    lineEdit = new QLineEdit(this);
013    label->setBuddy(lineEdit);
014    caseCheckBox = new QCheckBox(tr("Match &case"), this);
015    backwardCheckBox = new QCheckBox(tr("Search &backward"), this);
016    findButton = new QPushButton(tr("&Find"), this);
017    findButton->setDefault(true);
018    findButton->setEnabled(false);
019    closeButton = new QPushButton(tr("Close"), this);
On line 8, we pass on the parent andname parameters to the base class con-
structor.
On line 10, we set the window’s caption to “Find”.The tr() function around the
string marks it for translation to other languages. It is declared in QObject and
every subclass that contains the Q_OBJECT macro. It’s a good habit to surround
14 2. Creating Dialogs
every user-visible string with a tr(),even if you don’t have immediate plans
for translating your applications to other languages. Translating Qt applica-tions is covered in Chapter 15.
Then we create the child widgets. We use ampersands (‘&’) to indicate ac-
celerator keys. For example, line 16 creates a
Findbutton, which the user can
activate by pressing Alt+F .Ampersands can also be used to control focus: On
line 11 we create a label with an accelerator key ( Alt+W ), and on line 13 we set
the label’s buddy to be the line editor. A buddy is a widget that accepts the fo-
cus when the label’s accelerator key is pressed. So when the user presses Alt+W
(the label’s accelerator), the focus goes to the line editor (the buddy).
On line 17, we make the Find button the dialog’s default button by calling
setDefault(true) .#The default button is the button that is pressed when
the user hits Enter .Online 18, we disable the Findbutton. When a widget is
disabled, it is usually shown grayed out and will not interact with the user.
020    connect(lineEdit, SIGNAL(textChanged(const QString &)),
021            this, SLOT(enableFindButton(const QString &)));
022    connect(findButton, SIGNAL(clicked()),
023            this, SLOT(findClicked()));
024    connect(closeButton, SIGNAL(clicked()),
025            this, SLOT(close()));
The private slot enableFindButton(const QString &) is called whenever the
text in the line editor changes. The private slot findClicked() is called when
the user clicks the Findbutton. The dialog closes itself when the user clicks
Close .Theclose() slot is inherited from QWidget ,and its default behavior is
to hide the widget. We will look at the code for the enableFindButton() and
findClicked() slots later on.
SinceQObject is one of FindDialog ’sancestors, we can omit the QObject:: preﬁx
in front of the connect() calls.
026    QHBoxLayout *topLeftLayout = new QHBoxLayout;
027    topLeftLayout->addWidget(label);
028    topLeftLayout->addWidget(lineEdit);
029    QVBoxLayout *leftLayout = new QVBoxLayout;
030    leftLayout->addLayout(topLeftLayout);
031    leftLayout->addWidget(caseCheckBox);
032    leftLayout->addWidget(backwardCheckBox);
033    QVBoxLayout *rightLayout = new QVBoxLayout;
034    rightLayout->addWidget(findButton);
035    rightLayout->addWidget(closeButton);
036    rightLayout->addStretch(1);
037    QHBoxLayout *mainLayout = new QHBoxLayout(this);
038    mainLayout->setMargin(11);
#Qt provides TRUE andFALSE for all platforms and uses them throughout as synonyms for the
standard true andfalse .Nevertheless, there is no reason to use the upper-case versions in your
own code unless you need to use an old compiler that doesn’t support true andfalse .
Subclassing QDialog 15
039    mainLayout->setSpacing(6);
040    mainLayout->addLayout(leftLayout);
041    mainLayout->addLayout(rightLayout);
042}
Finally, we lay out the child widgets using layout managers .Alayout manager
is an object that manages the size and position of widgets. Qt provides threelayout managers:
QHBoxLayout lays out widgets horizontally from left to right
(right to left for some cultures), QVBoxLayout lays out widgets vertically from
top to bottom, and QGridLayout lays out widgets in a grid.
Layouts can contain both widgets and other layouts. By nesting QHBoxLayout s,
QVBoxLayout s,andQGridLayout sinvarious combinations, it is possible to build
very sophisticated dialogs.
Caption 
QLabel QLineEdit
QCheckBox
QCheckBoxQPushButton
QPushButton
εεεεεεεleftLayout
topLeftLayoutrightLayout
mainLayout
spacer
Figure 2.2. The Find dialog’s layouts
Forthe Find dialog, we use two QHBoxLayout sand two QVBoxLayout s,as shown
in Figure 2.2. The outer layout is the main layout; it is constructed with the
FindDialog object (this)asits parent and is responsible for the dialog’s entire
area. The other three layouts are sub-layouts.The little “spring” at the bottomright of Figure 2.2 is a spacer item (or “stretch”). It uses up the empty spacebelow the
Findand Close buttons, ensuring that these buttons occupy the top
of their layout.
One subtle aspect of the layout manager classes is that they are not widgets.
Instead,they inherit QLayout ,which in turn inherits QObject .Inthe ﬁgure, wid-
gets are represented by solid outlines and layouts are represented by dashedoutlines to highlight the difference between them. In a running application,layouts are invisible.
Although layout managers are not widgets, they can have a parent (and chil-
dren). The meaning of “parent” is slightly different for layouts than for wid-gets. If a layout is constructed with a widget as its parent (as we did for
main-
Layout ), the layout automatically installs itself on the widget. If a layout is
constructed with no parent (as we did for topLeftLayout ,leftLayout ,andright-
Layout ), the layout must be inserted into another layout using addLayout() .
16 2. Creating Dialogs
Qt’s parent–child mechanism is implemented in QObject ,the base class of both
QWidget andQLayout .When we create an object (a widget, layout, or other kind)
with a parent, the parent adds the object to the list of its children. When theparent is deleted, it walks through its list of children and deletes each child.The children themselves then delete all of their children,and so on recursivelyuntil none remain.
The parent–child mechanism simpliﬁes memory management a lot, reducing
the risk of memory leaks. The only objects we must delete explicitly are theobjects we create with
newand that have no parent. And if we delete a child
object before its parent, Qt will automatically remove that object from theparent’s list of children.
Forwidgets, the parent has an additional meaning: Child widgets are shown
within the parent’s area. When we delete the parent widget, not only does thechild vanish from memory, it also vanishes from the screen.
When we insert a layout into another using
addLayout() ,the inner layout is
automatically made a child of the outer layout, to simplify memory manage-ment. In contrast, when we insert a widget into a layout using
addWidget() ,
the widget doesn’t change parent.
Figure 2.3 shows the parentage of the widgets and layouts. The parentage can
easily be deduced from the FindDialog constructor code by looking at the lines
that contain a newor anaddLayout() call. The important thing to remember is
that the layout managers are not parents of the widgets they manage.
FindDialog
QLabel (label)
QLineEdit (lineEdit)QCheckBox (caseCheckBox)QCheckBox (backwardCheckBox)QPushButton (ﬁndButton)QPushButton (closeButton)
QHBoxLayout (mainLayout)
QVBoxLayout (leftLayout)
QHBoxLayout (topLeftLayout)
QVBoxLayout (rightLayout)
Figure 2.3. The Find dialog’s parent–child relationships
In addition to the layout managers, Qt provides some layout widgets :QHBox
(which we used in Chapter 1), QVBox ,andQGrid .These classes serve both as
parents and as layout managers for their child widgets. The layout widgetsare more convenient to use than layout managers for small examples,but theyare less ﬂexible and require more resources.
Subclassing QDialog 17
This completes the review of FindDialog ’sconstructor. Since we used newto
create the dialog’s widgets and layouts, it would seem that we need to writeadestructor that calls
delete on each of the widgets and layouts we created.
But this isn’t necessary, since Qt automatically deletes child objects when theparent is destroyed, and the objects we allocated with
neware all descendants
of theFindDialog .
Now we will look at the dialog’s slots:
043void FindDialog::findClicked()
044{
045    QString text = lineEdit->text();
046    bool caseSensitive = caseCheckBox->isOn();
047    if (backwardCheckBox->isOn())
048        emit findPrev(text, caseSensitive);
049    else
050        emit findNext(text, caseSensitive);
051}
052void FindDialog::enableFindButton(const QString &text)
053{
054    findButton->setEnabled(!text.isEmpty());
055}
ThefindClicked() slot is called when the user clicks the Findbutton. It emits
thefindPrev() or thefindNext() signal, depending on the Search backward op-
tion. The emit keyword is speciﬁc to Qt;like other Qt extensions,it is converted
into standard C ++by the C ++preprocessor.
TheenableFindButton() slot is called whenever the user changes the text in
the line editor. It enables the button if there is some text in the editor, anddisables it otherwise.
These two slots complete the dialog. We can now create a
main.cpp ﬁle to test
ourFindDialog widget:
001#include <qapplication.h>
002#include "finddialog.h"
003int main(int argc, char *argv[])
004{
005    QApplication app(argc, argv);
006    FindDialog *dialog = new FindDialog;
007    app.setMainWidget(dialog);
008    dialog->show();
009    return app.exec();
010}
Tocompile the program, run qmake as usual. Since the FindDialog class
deﬁnition contains the Q_OBJECT macro, the makeﬁle generated by qmake will
include special rules to run moc,Qt’s meta-object compiler.
Formocto work correctly, we must put the class deﬁnition in a header ﬁle,
separate from the implementation ﬁle. The code generated by mocincludes
18 2. Creating Dialogs
this header ﬁle and adds some magic of its own.
Classes that use the Q_OBJECT macro must have mocrun on them. This isn’t a
problem because qmake automatically adds the necessary rules to the makeﬁle.
But if you forget to regenerate your makeﬁle using qmake andmocisn’t run, the
linker will complain that some functions are declared but not implemented.The messages can be fairly obscure. GCC produces warnings like this one:
finddialog.o(.text+0x28): undefined reference to
‘FindDialog::QPaintDevice virtual table’
Visual C ++’soutput starts like this:
finddialog.obj : error LNK2001: unresolved external symbol
"public:~virtual bool __thiscall FindDialog::qt_property(int,int,class QVariant *)"
If this ever happens to you, run qmake again to update the makeﬁle, then
rebuild the application.
Now run the program. Verify that the accelerator keys Alt+W ,Alt+C ,Alt+B ,and
Alt+F trigger the correct behavior. Press Tabto navigate through the widgets
with the keyboard. The default tab order is the order in which the widgetswere created. This can be changed by calling
QWidget::setTabOrder() .
Providing a sensible tab order and keyboard accelerators ensures that users
who don’t want to (or cannot) use a mouse are able to make full use of theapplication. Full keyboard control is also appreciated by fast typists.
In Chapter 3, we will use the Find dialog inside a real application, and we will
connect the
findPrev() andfindNext() signals to some slots.
Signals and Slots in Depth
The signals and slots mechanism is fundamental to Qt programming. Itenables the application programmer to bind objects together without theobjects knowing anything about each other. We have already connected somesignals and slots together, declared our own signals and slots, implementedour own slots, and emitted our own signals. Let’s take a moment to look at themechanism more closely.
Slots are almost identical to ordinary C ++member functions. They can be
virtual, they can be overloaded, they can be public, protected, or private,and they can be directly invoked like any other C ++member functions. The
difference is that a slot can also be connected to a signal, in which case it isautomatically called each time the signal is emitted.
The
connect() statement looks like this:
connect( sender, SIGNAL( signal), receiver , SLOT( slot));
where sender and receiver are pointers to QObject sand where signal and slot
Signals and Slots in Depth 19
are function signatures without parameter names. The SIGNAL() andSLOT()
macros essentially convert their argument to a string.
In the examples we have seen so far, we have always connected different
signals to different slots. There are more possibilities to explore:
•One signal can be connected to many slots:
connect(slider, SIGNAL(valueChanged(int)),
        spinBox, SLOT(setValue(int)));connect(slider, SIGNAL(valueChanged(int)),        this, SLOT(updateStatusBarIndicator(int)));
When the signal is emitted, the slots are called one after the other, in an
arbitrary order.
•Many signals can be connected to the same slot:
connect(lcd, SIGNAL(overflow()),
        this, SLOT(handleMathError()));connect(calculator, SIGNAL(divisionByZero()),        this, SLOT(handleMathError()));
When either signal is emitted, the slot is called.
•Asignal can be connected to another signal:
connect(lineEdit, SIGNAL(textChanged(const QString &)),
        this, SIGNAL(updateRecord(const QString &)));
When the ﬁrst signal is emitted, the second signal is emitted as well.
Apart from that, signal–signal connections are indistinguishable fromsignal–slot connections.
•Connections can be removed:
disconnect(lcd, SIGNAL(overflow()),
           this, SLOT(handleMathError()));
This is rarely needed, because Qt automatically removes all connections
involving an object when that object is deleted.
When connecting a signal to a slot (or to another signal), they must both have
the same parameter types in the same order:
connect(ftp, SIGNAL(rawCommandReply(int, const QString &)),
        this, SLOT(processReply(int, const QString &)));
Exceptionally, if a signal has more parameters than the slot it is connected to,
the additional parameters are simply ignored:
connect(ftp, SIGNAL(rawCommandReply(int, const QString &)),
        this, SLOT(checkErrorCode(int)));
If the parameter types are incompatible, or if the signal or the slot doesn’t
exist, Qt will issue a warning at run-time. Similarly, Qt will give a warning ifparameter names are included in the signal or slot signatures.
20 2. Creating Dialogs
Qt’s Meta-Object System
One of Qt’s major achievements has been the extension of C ++with a
mechanism for creating independent software components that can bebound together without any component knowing anything about the othercomponents it is connected to.
The mechanism is called the meta-object system ,and it provides two key
services: signals and slots, and introspection. The introspection functional-ity is necessary for implementing signals and slots, and allows applicationprogrammersto obtain “meta-information”about
QObject subclassesat run-
time, including the list of signals and slots supported by the object and itsclass name. The mechanism also supports properties (for Qt Designer )and
text translation (for internationalization).
Standard C ++doesn’t provide support for the dynamic meta-information
needed by Qt’s meta-object system. Qt solves this problem by providingaseparate tool,
moc,that parses Q_OBJECT class deﬁnitions and makes the
information available through C ++functions. Since mocimplements all
its functionality using pure C ++,Qt’s meta-object system works with any
C++compiler.
The mechanism works as follows:
•TheQ_OBJECT macro declares some introspection functions that must be
implemented in every QObject subclass: metaObject() ,className() ,tr(),
and a few more.
•Qt’smoctool generates implementations for the functions declared by
Q_OBJECT and for all the signals.
•QObject member functions such as connect() anddisconnect() use the
introspection functions to do their work.
All of this is handled automatically by qmake ,moc,andQObject ,soyou rarely
need to think about it. But if you are curious, you can look at the C ++
source ﬁles generated by mocto see how the implementation works.
So far, we have only used signals and slots with widgets. But the mechanism
itself is implemented in QObject ,and isn’t limited to GUI programming. The
mechanism can be used by any QObject subclass:
class Employee : public QObject
{    Q_OBJECTpublic:    Employee() { mySalary = 0; }
    int salary() const { return mySalary; }public slots:
    void setSalary(int newSalary);
signals:
Signals and Slots in Depth 21
    void salaryChanged(int newSalary);
private:
    int mySalary;};
void Employee::setSalary(int newSalary)
{    if (newSalary != mySalary) {        mySalary = newSalary;        emit salaryChanged(mySalary);    }}
Notice how the setSalary() slot is implemented. We only emit the salary-
Changed() signal if newSalary != mySalary .This ensures that cyclic connections
don’t lead to inﬁnite loops.
Rapid Dialog Design
Qt is designed to be pleasant and intuitive to hand-code, and it is perfectlypossible to develop Qt applications purely by writing C ++source code. Qt
Designer expands the options available to programmers, allowing them to
combine visually designed forms with their source code.
In this section, we will use Qt Designer to create the Go-to-Cell dialog shown
in Figure 2.4. Whether we do it in code or in Qt Designer ,creating a dialog
always involves the same fundamental steps:
•Create and initialize the child widgets.
•Put the child widgets in layouts.
•Set the tab order.
•Establish signal–slot connections.
•Implement the dialog’s custom slots.
Figure 2.4. Go-to-Cell dialog
Tolaunch Qt Designer ,click Qt 3.2.x|Qt Designer in the Start menu on Windows,
typedesigner on the command line on Unix, or double-click designer in the
Mac OS X Finder. When Qt Designer starts, it will pop up a list of templates.
Click the “Dialog” template, then click OK.You should now have a window
called “Form1”.
22 2. Creating Dialogs
Figure 2.5. Qt Designer with an empty form
The ﬁrst step is to create the child widgets and place them on the form. Create
one text label, one line editor, one (horizontal) spacer, and two push buttons.Foreach item, click its name or icon in the “toolbox” at the left of Qt Designer ’s
main window and then click the form roughly where the item should go. Nowdrag the bottom of the form up to make it shorter. This should produce a formthat is similar to Figure 2.6. Don’t spend too much time positioning the itemson the form; Qt’s layout managers will lay them out precisely later on.
The spacer item is shown in Qt Designer as a blue spring. It is invisible in the
ﬁnal form.
Figure 2.6. The form with some widgets
Set each widget’s properties using the property editor on the right of Qt
Designer ’smain window:
1. Click the text label. Set its name property to “label” and its text property
to “&Cell Location:”.
2. Click the line editor. Set its name property to “lineEdit”.
3. Click the spacer. Make sure that the spacer’s orientation property is set
to “Horizontal”.
Rapid Dialog Design 23
4. Click the ﬁrst button. Set its name property to “okButton”, its enabled
property to “False”, its default property to “True”, and its text property
to “OK”.
5. Click the second button. Set its name property to “cancelButton” and its
text property to “Cancel”.
6. Click the background of the form to select the form itself. Set its name
property to “GoToCellDialog” and its caption property to “Go to Cell”.
All the widgets look ﬁne now, except the text label, which shows &Cell Location .
Click Tools|Set Buddy .Click the label and drag the rubber band to the line
editor, then release. The label should now show Cell Location and have the
line editor as its buddy. You can verify this by checking that the label’s buddy
property is set to “lineEdit”.
Figure 2.7. The form with properties set
The next step is to lay out the widgets on the form:
1. Click the Cell Location label and press Shiftas you click the line editor next
to it so that they are both selected. Click Layout|Lay Out Horizontally .
2. Click the spacer, then hold Shift as you click the form’s OKand Cancel
buttons. Click Layout|Lay Out Horizontally .
3. Click the background of the form to deselect any selected items, then click
Layout|Lay Out Vertically .
4. Click Layout|Adjust Size to resize the form to its optimal size.
The red lines that appear on the form show the layouts that have been created.
They never appear when the form is run.
Figure 2.8. The form with the layouts
24 2. Creating Dialogs
Now click Tools|Tab Order .Anumber in a blue circle will appear next to every
widget that can accept focus. Click each widget in turn in the order you wantthem to accept focus, then press
Esc.
Figure 2.9. Setting the form’s tab order
Now that the form has been designed, we are ready to make it functional by
setting up some signal–slot connections and by implementing some customslots. Click
Edit|Connections to invoke the connection editor.
Figure 2.10. Qt Designer ’sconnection editor (after making the connections)
Figure 2.11. Qt Designer ’sslot editor
Weneed to establish three connections. To create a connection, click Newand
set the Sender ,Signal ,Receiver ,and Slotﬁelds using the drop-down comboboxes.
Rapid Dialog Design 25
Connect the okButton ’sclicked() signal to the GoToCellDialog ’saccept() slot.
Connect the cancelButton ’sclicked() signal to the GoToCellDialog ’sreject()
slot. Click Edit Slots to invoke Qt Designer ’sslot editor (shown in Figure 2.11),
and create an enableOkButton() private slot. Finally, connect the lineEdit ’s
textChanged(const QString &) signal to the GoToCellDialog ’snewenableOkBut-
ton() slot.
Topreview the dialog, click the Preview|Preview Form menu option. Check the
tab order by pressing Tabrepeatedly. Press Alt+C to move the focus to the line
editor. Click Cancel to close the dialog.
Save the dialog as gotocelldialog.ui in a directory called gotocell ,and create
amain.cpp ﬁle in the same directory using a plain text editor:
#include <qapplication.h>
#include "gotocelldialog.h"int main(int argc, char *argv[])
{    QApplication app(argc, argv);    GoToCellDialog *dialog = new GoToCellDialog;    app.setMainWidget(dialog);    dialog->show();    return app.exec();}
Now run qmake to create a .pro ﬁle and a makeﬁle ( qmake -project ;qmake
gotocell.pro ). Theqmake tool is smart enough to detect the user interface ﬁle
gotocelldialog.ui and to generate the appropriate makeﬁle rules to create
gotocelldialog.h andgotocelldialog.cpp .The.uiﬁle is converted to C ++by
uic,Qt’s user interface compiler.
One of the beauties of using Qt Designer is that it allows programmers great
freedom to modify their form designs without disturbing their source code.When you develop a form purely by writing C ++code, changes to the design
can be quite time-consuming. With Qt Designer ,notime is lost since
uic
simply regenerates the source code for any forms that have changed.
If you run the program now, the dialog will work, but it doesn’t function
exactly as we want:
•The OKbutton is always disabled.
•The line editor accepts any text, instead of only accepting valid cell lo-
cations.
Wemust write some code to solve these problems.
Double-click the background of the form to invoke Qt Designer ’scode editor.
In the editor window, enter the following code:
#include <qvalidator.h>
void GoToCellDialog::init()
26 2. Creating Dialogs
{
    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");    lineEdit->setValidator(new QRegExpValidator(regExp, this));}
void GoToCellDialog::enableOkButton()
{    okButton->setEnabled(lineEdit->hasAcceptableInput());}
Theinit() function is automatically called at the end of the form’s constructor
(generated by uic). We set up a validator to restrict the range of the input. Qt
provides three built-in validator classes: QIntValidator ,QDoubleValidator ,and
QRegExpValidator .Here we use a QRegExpValidator with the regular expression
“[A-Za-z][1-9][0-9]{0,2}”, which means: Allow one upper- or lower-case letter,followed by one digit in the range 1 to 9, followed by up to two digits each inthe range 0 to 9. (For an introduction to regular expressions, see the
QRegExp
class documentation.)
By passing this to theQRegExpValidator constructor, we make it a child of
theGoToCellDialog object. By doing so, we don’t have to worry about deleting
theQRegExpValidator later; it will be deleted automatically when its parent
is deleted.
TheenableOkButton() slot enables or disables the OKbutton, according to
whether the line edit contains a valid cell location. QLineEdit::hasAcceptable-
Input() uses the validator we set in the init() function.
Figure 2.12. Qt Designer ’scode editor
After typing the code, save the dialog again. This will effectively save two
ﬁles: the user interface ﬁle gotocelldialog.ui ,and the C ++source ﬁle goto-
celldialog.ui.h .Make the application once more and run it again. Type “A12”
in the line edit, and notice that the OKbutton becomes enabled. Try typing
some random text to see how the validator does its job. Click Cancel to close
the dialog.
Rapid Dialog Design 27
In this example, we edited the dialog in Qt Designer ,then we added some code
using Qt Designer ’scode editor. The dialog’s user interface is saved in a .ui
ﬁle (an XML-based ﬁle format), while the code is saved in a .ui.h ﬁle (a C ++
source ﬁle). This split is very convenient for developers who want to edit the
.ui.h ﬁle in their favorite text editor.
An alternative to the .ui.h approach is to create a .uiﬁle with Qt Designer
as usual, then create an additional class that inherits the uic-generated
class and adds the extra functionality there. For example, for the Go-to-Celldialog, this would mean creating a
GoToCellDialogImpl class that inherits
GoToCellDialog and that implements what’s missing. It is straightforward to
convert the .ui.h code to use this approach. The result is this header ﬁle:
#ifndef GOTOCELLDIALOGIMPL_H
#define GOTOCELLDIALOGIMPL_H
#include "gotocelldialog.h"class GoToCellDialogImpl : public GoToCellDialog
{    Q_OBJECTpublic:    GoToCellDialogImpl(QWidget *parent = 0, const char *name = 0);
private slots:
    void enableOkButton();};
#endif
And this source ﬁle:
#include <qlineedit.h>
#include <qpushbutton.h>#include <qvalidator.h>
#include "gotocelldialogimpl.h"GoToCellDialogImpl::GoToCellDialogImpl(QWidget *parent,
                                       const char *name)    : GoToCellDialog(parent, name){    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");    lineEdit->setValidator(new QRegExpValidator(regExp, this));}
void GoToCellDialogImpl::enableOkButton()
{    okButton->setEnabled(lineEdit->hasAcceptableInput());}
Developers who prefer the subclassing approach would probably call the base
classGoToCellDialogBase and the derived class GoToCellDialog ,keeping the
better name for the class that contains all the functionality.
28 2. Creating Dialogs
Theuictool provides command-line options to simplify the creation of sub-
classes based on forms created with Qt Designer .Use-subdecl to generate a
skeleton header ﬁle, and use -subimpl to generate the matching implementa-
tion ﬁle.
In this book, we use the .ui.h approach since this is the most common practice,
and since it is easy to convert .ui.h ﬁles into subclasses. You might want to
read the “Designer Approach” chapter in Qt Designer ’smanual for a technical
appreciation of the differences between subclassing and using .ui.h ﬁles. An-
other chapter in the manual, “Creating Dialogs”, demonstrates how to use Qt
Designer ’sMembers tab to declare member variables in uic-generated classes.
Shape-Changing Dialogs
Wehave seen how to create dialogs that always show the same widgets when-
ever they are used. In some cases, it is desirable to provide dialogs that canchange shape. The two most common kinds of shape-changing dialogs are ex-
tension dialogs andmulti-page dialogs .Both types of dialog can be implement-
ed in Qt, either purely in code or using Qt Designer .
Extension dialogs usually present a simple appearance but have a toggle but-
ton that allows the user to switch between the dialog’s simple and extendedappearances. Extension dialogs are commonly used for applications that aretrying to cater for both casual and power users, hiding the advanced optionsunless the user explicitly asks to see them. In this section, we will use Qt De-
signer to create the extension dialog shown in Figure 2.13.
¯
Figure 2.13. Sort dialog with simple and extended appearances
The dialog is a Sort dialog in a spreadsheet application, where the user can
select one or several columns to sort on. The dialog’s simple appearance allowsthe user to enter a single sort key, and its extended appearance provides for
Shape-Changing Dialogs 29
two extra sort keys. A More button lets the user switch between the simple and
extended appearances.
Wewill create the widget with its extended appearance in Qt Designer ,and
hide the secondary and tertiary keys at run-time as needed. The widget lookscomplicated, but it’s fairly easy to do in Qt Designer .The trick is to do the
primary key part ﬁrst, then copy and paste it twice to obtain the secondaryand tertiary keys:
1. Create a group box, two text labels, two comboboxes, and one horizontal
spacer.
2. Drag the bottom right corner of the group box to make it larger.
3. Move the other widgets into the group box and position them approxi-
mately as shown in Figure 2.14 (a).
4. Drag the right edge of the second combobox to make it about twice as wide
as the ﬁrst combobox.
5. Set the group box’s
title property to “&Primary Key”, the ﬁrst label’s text
property to “Column:”, and the second label’s text property to “Order:”.
6. Double-click the ﬁrst combobox to pop up Qt Designer ’slist box editor, and
create one item with the text “None”.
7. Double-click the second combobox and create an “Ascending” item and a
“Descending” item.
8. Click the group box, then click Layout|Lay Out in a Grid .This will produce the
layout shown in Figure 2.14 (b).
(a) Without layout (b) With layout
Figure 2.14. Laying out the group box’s children in a grid
If a layout doesn’t turn out quite right or if you make a mistake, you can
always click Edit|Undo ,then roughly reposition the widgets being laid out and
try again.
Wewill now add the Secondary Key and Tertiary Key group boxes:
1. Make the dialog window tall enough for the extra parts. Select the group
box, click Edit|Copy ,then click Edit|Paste twice to obtain two additional
group boxes. Drag the two new group boxes to the approximate positionsthat they should occupy. Change their
title property to “&Secondary
Key” and “&Tertiary Key”.
30 2. Creating Dialogs
2. Create the OK,Cancel ,and More buttons.
3. Set the OKbutton’s default property to “True” and the More button’s
toggle property to “True”.
4. Create two vertical spacers.
5. Arrange the OK,Cancel ,and More buttons vertically, with a vertical spacer
between the Cancel and More buttons. Then select all four items and click
Layout|Lay Out Vertically .
6. Place the second vertical spacer between the primary key group box and
the secondary key group box.
7. Set the two vertical spacer items’ sizeHint property to (20, 10).
8. Arrange the widgets in the grid-like pattern shown in Figure 2.15 (a).9. Click
Layout|Lay Out in a Grid .The form should now match Figure 2.15 (b).
(a) Without layout (b) With layout
Figure 2.15. Laying out the form’s children in a grid
The resulting grid layout has two columns and four rows, giving a total of
eight cells. The Primary Key group box, the leftmost vertical spacer item, the
Secondary Key group box, and the Tertiary Key group box each occupy a single cell.
The vertical layout that contains the OK,Cancel ,and More buttons occupies two
cells. That leaves two empty cells in the bottom-right of the dialog. If this isn’twhat you have, undo the layout, reposition the widgets, and try again.
Change the form’s
resizeMode property from “Auto” to “Fixed”, making the dia-
log non-resizable by the user. The layout then takes over the responsibility forresizing,and resizes the dialog automatically when child widgets are shown orhidden, ensuring that the dialog is always displayed at its optimal size.
Shape-Changing Dialogs 31
Rename the form “SortDialog” and change its caption to “Sort”. Set the names
of the child widgets to those shown in Figure 2.16.
primaryGroupBox
primaryColumnCombo
primaryOrderCombo
secondaryGroupBox
secondaryColumnCombo
secondaryOrderCombo
tertiaryGroupBox
tertiaryColumnCombo
tertiaryOrderCombookButton
cancelButton
moreButton
Figure 2.16. Naming the form’s widgets
Finally, set up the connections:
1. Connect the okButton ’sclicked() signal to the form’s accept() slot.
2. Connect the cancelButton ’sclicked() signal to the form’s reject() slot.
3. Connect the moreButton ’stoggled(bool) signal to the secondaryGroupBox ’s
setShown(bool) slot.
4. Connect the moreButton ’stoggled(bool) signal to the tertiaryGroupBox ’s
setShown(bool) slot.
Double-click the form to launch Qt Designer ’s C++code editor and type in the
following code:
001void SortDialog::init()
002{
003    secondaryGroupBox->hide();
004    tertiaryGroupBox->hide();
005    setColumnRange(’A’, ’Z’);
006}
007void SortDialog::setColumnRange(QChar first, QChar last)
008{
009    primaryColumnCombo->clear();
010    secondaryColumnCombo->clear();
011    tertiaryColumnCombo->clear();
012    secondaryColumnCombo->insertItem(tr("None"));
013    tertiaryColumnCombo->insertItem(tr("None"));
014    primaryColumnCombo->setMinimumSize(
015            secondaryColumnCombo->sizeHint());
32 2. Creating Dialogs
016    QChar ch = first;
017    while (ch <= last) {
018        primaryColumnCombo->insertItem(ch);
019        secondaryColumnCombo->insertItem(ch);
020        tertiaryColumnCombo->insertItem(ch);
021        ch = ch.unicode() + 1;
022    }
023}
Theinit() function hides the secondary and tertiary key parts of the dialog.
ThesetColumnRange() slot initializes the contents of the comboboxes based
on the selected columns in the spreadsheet. We insert a “None” item in thecomboboxes for the (optional) secondary and tertiary keys. Although we havenot created this slot using Qt Designer ’sslot editor, Qt Designer will detect
that we have created a new slot in code, and
uicwill automatically generate
the correct function declaration in the SortDialog class deﬁnition.
Lines 14 and 15 present a subtle layout idiom. The QWidget::sizeHint() func-
tion returnsa widget’s“ideal” size,which the layout system tries to honor. Thisexplains why different kinds of widgets, or similar widgets with different con-tents, may be assigned different sizes by the layout system. For comboboxes,this means that the secondary and tertiary comboboxes,which contain “None”,end up larger than the primary combobox, which contains only single-letterentries. To avoid this inconsistency, we set the primary combobox’s minimumsize to the secondary combobox’s ideal size.
Here is a
main() test function that sets the range to include columns ‘C’ to ‘F’
and then shows the dialog:
#include <qapplication.h>
#include "sortdialog.h"int main(int argc, char *argv[])
{    QApplication app(argc, argv);    SortDialog *dialog = new SortDialog;    app.setMainWidget(dialog);    dialog->setColumnRange(’C’, ’F’);    dialog->show();    return app.exec();}
That completes the extension dialog. As the example illustrates, an extension
dialog isn’t much more difﬁcult to design than a plain dialog: All we needis a toggle button, a few extra signal–slot connections, and a non-resizablelayout.
The other common type of shape-changing dialogs, multi-page dialogs, are
even easier to create in Qt, either in code or using Qt Designer .These dialogs
can be built in many different ways.
Shape-Changing Dialogs 33
•AQTabWidget can be used in its own right. It provides a tab bar along the
top that controls a built-in QWidgetStack .
•AQListBox and aQWidgetStack can be used together, with the QListBox ’s
current item determining which page the QWidgetStack shows.
•AQListView or aQIconView can be used with a QWidgetStack in a similar
way to a QListBox .
TheQWidgetStack class is covered in Chapter 6 (Layout Management).
Dynamic Dialogs
Dynamic dialogs are dialogs that are created from a Qt Designer .uiﬁle at run-
time. Dynamic dialogs are not converted into C ++code byuic.Instead, the .ui
ﬁle is loaded at run-time using the QWidgetFactory class, in the following way:
QDialog *sortDialog = (QDialog *)
                      QWidgetFactory::create("sortdialog.ui");
Wecan access the form’s child widgets using QObject::child() :
QComboBox *primaryColumnCombo = (QComboBox *)
        sortDialog->child("primaryColumnCombo", "QComboBox");
Thechild() function returns a null pointer if the dialog has no child that
matches the given name and type.
TheQWidgetFactory class is located in a separate library. To use QWidgetFactory
from a Qt application, we must add this line to the application’s .pro ﬁle:
LIBS         += -lqui
This syntax works on all platforms, even though it has a deﬁnite Unix ﬂavor.Dynamic dialogs make it possible to change the layout of the form without
recompiling the application. For a complete example of an application thatuses a dynamic dialog, see the “Subclassing and Dynamic Dialogs” chapter intheQt Designer manual.
Built-in Widget and Dialog Classes
Qt provides a complete set of built-in widgets and common dialogs that cater
for most situations. In this section, we present screenshots of almost all ofthem. A few specialized widgets are deferred until later: Main window wid-gets such as
QMenuBar ,QPopupMenu ,andQToolBar are covered in Chapter 3, and
database widgets such as QDataView andQDataTable are covered in Chapter 12.
Most of the built-in widgets and dialogs are used in the examples presentedin this book. In the screenshots below, the widgets are shown using the classicWindows style.
34 2. Creating Dialogs
QPushButton QCheckBox QRadioButton
Figure 2.17. Qt’s button widgets
Qt provides three kinds of “buttons”: QPushButton ,QCheckBox ,andQRadioButton .
QPushButton is most commonly used to initiate an action when it is clicked, but
it can also behave like a toggle button (click to press down, click to release).
QRadioButton sare usually used inside a QButtonGroup and are mutually exclu-
sive within their group, whereas QCheckBox can be used for independent on/off
options.
QGroupBox QFrame
QTabWidget QToolBox
Figure 2.18. Qt’s container widgets
Qt’s container widgets are widgets that contain other widgets. QFrame can also
be used on its own to simply to draw lines and is inherited by many otherwidget classes, notably
QLabel andQLineEdit .QButtonGroup is not shown; it is
visually identical to QGroupBox .
QTabWidget andQToolBox are multi-page widgets. Each page is a child widget,
and the pages are numbered from 0.
Built-in Widget and Dialog Classes 35
QListBox QListView
QIconView QTable
Figure 2.19. Qt’s item view widgets
The item views are optimized for handling large amounts of data, and often
use scroll bars. The scroll bar mechanism is implemented in QScrollView ,a
base class for item views and other kinds of views.
QLabel QLCDNumber QProgressBar
Figure 2.20. Qt’s display widgets
Qt provides a few widgets that are used purely for displaying information.
QLabel is the most important of these, and it can be used for showing rich text
(using a simple HTML-like syntax) and images.
QTextBrowser (not shown) is a read-only QTextEdit subclass that has basic
HTML support including lists, tables, images, and hypertext links; Qt Assis-
tant usesQTextBrowser to present documentation to the user.
36 2. Creating Dialogs
QLineEdit
 QComboBox
 QSpinBox
QDateEdit
 QDateTimeEdit
 QTimeEdit
QSlider
 QScrollBar
QTextEdit
 QDial
Figure 2.21. Qt’s input widgets
Qt provides many widgets for data entry. QLineEdit can restrict its input using
an input mask or a validator. QTextEdit is aQScrollView subclass capable of
editing large amounts of text.
QColorDialog QFontDialog
Figure 2.22. Qt’s color dialog and font dialog
Qt provides the standard set of common dialogs that make it easy to ask the
user to select a color, font, or ﬁle, or to print a document.
Built-in Widget and Dialog Classes 37
QFileDialog QPrintDialog
Figure 2.23. Qt’s ﬁle dialog and print dialog
On Windows and Mac OS X, Qt uses the native dialogs rather than its own
common dialogs when possible.
QInputDialog QProgressDialog
QMessageBox QErrorMessage
Figure 2.24. Qt’s feedback dialogs
Qt provides a versatile message box and an error dialog that remembers
which messages it has shown. The progress of time-consuming operations canbe indicated using
QProgressDialog or using the QProgressBar shown earlier.
QInputDialog is very convenient when a single line of text or a single number
is required from the user.
Finally,QWizard provides a framework for creating wizards. Qt Designer
provides a “Wizard” template for creating wizards visually.
38 2. Creating Dialogs
Figure 2.25. Qt’sQWizard dialog
Alot of ready-to-use functionality is provided by the built-in widgets and
common dialogs. More specialized requirements can often be satisﬁed byconnecting signals to slots and implementing custom behavior in the slots.
In some situations, it may be desirable to create a custom widget from scratch.
Qt makes this straightforward, and custom widgets can access all the sameplatform-independent drawing functionality as Qt’s built-in widgets. Customwidgets can even be integrated with Qt Designer so that they can be used
in the same way as Qt’s built-in widgets. Chapter 5 explains how to createcustom widgets.
33
Creating Main Windows•Subclassing QMainWindow
•Creating Menus and Toolbars
•Implementing the File Menu
•Setting Up the Status Bar
•Using Dialogs
•Storing Settings
•Multiple Documents
•Splash Screens
This chapter will teach you how to create main windows using Qt. By the end,
you will be able to build an application’s entire user interface, complete withmenus, toolbars, status bar, and as many dialogs as the application requires.
Figure 3.1. Spreadsheet application
An application’s main window provides the framework upon which the appli-
cation’s user interface is built. The main window for the Spreadsheet applica-tion shown in Figure 3.1 will form the basis of this chapter. The Spreadsheetapplication makes use of the Find, Go-to-Cell, and Sort dialogs that we createdin Chapter 2.
39
40 3. Creating Main Windows
Behind most GUI applications lies a body of code that provides the underlying
functionality—for example, code to read and write ﬁles or to process the datapresented in the user interface. In Chapter 4, we will see how to implementsuch functionality, again using the Spreadsheet application as our example.
Subclassing QMainWindow
An application’s main window is created by subclassing QMainWindow .Many
of the techniques we saw in Chapter 2 for creating dialogs are also relevantfor creating main windows, since both
QDialog andQMainWindow inherit from
QWidget .
Main windows can be created using Qt Designer ,but in this chapter we will use
code to demonstrate how it’s done. If you prefer the more visual approach, seethe “Creating a Main Window Application” chapter in Qt Designer ’smanual.
The source code for the Spreadsheet application’s main window is spread
across
mainwindow.h andmainwindow.cpp .Let’s start with the header ﬁle:
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
#include <qmainwindow.h>
#include <qstringlist.h>
class QAction;
class QLabel;class FindDialog;class Spreadsheet;
class MainWindow : public QMainWindow
{    Q_OBJECTpublic:    MainWindow(QWidget *parent = 0, const char *name = 0);
protected:
    void closeEvent(QCloseEvent *event);    void contextMenuEvent(QContextMenuEvent *event);
Wedeﬁne the class MainWindow as a subclass of QMainWindow .Itcontains the Q_
OBJECT macro because it provides its own signals and slots.
ThecloseEvent() function is a virtual function in QWidget that is automatically
called when the user closes the window. It is reimplemented in MainWindow
so that we can ask the user the standard question “Do you want to save yourchanges?” and to save user preferences to disk.
Similarly, the
contextMenuEvent() function is called when the user right-clicks
awidget or presses a platform-speciﬁc Menu key. It is reimplemented in
MainWindow to pop up a context menu.
private slots:
    void newFile();
Subclassing QMainWindow 41
    void open();
    bool save();    bool saveAs();    void find();    void goToCell();    void sort();    void about();
Some menu options, like File|New and Help|About ,are implemented as private
slots inMainWindow .Most slots have void as their return value, but save() and
saveAs() return a bool.The return value is ignored when a slot is executed in
response to a signal, but when we call a slot as a function the return value isavailable to us just as it is when we call any ordinary C ++function.
    void updateCellIndicators();
    void spreadsheetModified();    void openRecentFile(int param);
private:
    void createActions();    void createMenus();    void createToolBars();    void createStatusBar();    void readSettings();    void writeSettings();    bool maybeSave();    void loadFile(const QString &fileName);    void saveFile(const QString &fileName);    void setCurrentFile(const QString &fileName);    void updateRecentFileItems();    QString strippedName(const QString &fullFileName);
The main window needs some more private slots and several private functions
to support the user interface.
    Spreadsheet *spreadsheet;
    FindDialog *findDialog;    QLabel *locationLabel;    QLabel *formulaLabel;    QLabel *modLabel;    QStringList recentFiles;    QString curFile;    QString fileFilters;    bool modified;
    enum { MaxRecentFiles = 5 };
    int recentFileIds[MaxRecentFiles];
    QPopupMenu *fileMenu;
    QPopupMenu *editMenu;    QPopupMenu *selectSubMenu;    QPopupMenu *toolsMenu;    QPopupMenu *optionsMenu;    QPopupMenu *helpMenu;    QToolBar *fileToolBar;    QToolBar *editToolBar;
42 3. Creating Main Windows
    QAction *newAct;
    QAction *openAct;    QAction *saveAct;
···
    QAction *aboutAct;
    QAction *aboutQtAct;};
#endif
In addition to its private slots and private functions, MainWindow also has lots
of private variables. All of these will be explained as we use them.
Wewill now review the implementation:
#include <qaction.h>
#include <qapplication.h>#include <qcombobox.h>#include <qfiledialog.h>#include <qlabel.h>#include <qlineedit.h>#include <qmenubar.h>#include <qmessagebox.h>#include <qpopupmenu.h>#include <qsettings.h>#include <qstatusbar.h>
#include "cell.h"
#include "finddialog.h"#include "gotocelldialog.h"#include "mainwindow.h"#include "sortdialog.h"#include "spreadsheet.h"
Weinclude the header ﬁles for the Qt classes used in our subclass, and
also some custom header ﬁles, notably finddialog.h ,gotocelldialog.h ,and
sortdialog.h from Chapter 2.
MainWindow::MainWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name){    spreadsheet = new Spreadsheet(this);    setCentralWidget(spreadsheet);
    createActions();
    createMenus();    createToolBars();    createStatusBar();
    readSettings();    setCaption(tr("Spreadsheet"));
    setIcon(QPixmap::fromMimeSource("icon.png"));
    findDialog = 0;
    fileFilters = tr("Spreadsheet files (*.sp)");    modified = false;}
Subclassing QMainWindow 43
In the constructor, we begin by creating a Spreadsheet widget and setting it
to be the main window’s central widget. The central widget occupies the areabetween the toolbars and the status bar. The
Spreadsheet class is a QTable
subclass with some spreadsheet capabilities, such as support for spreadsheetformulas. We will implement it in Chapter 4.
Caption 
menuBar()
topDock()leftDock()centralWidget()
rightDock()
bottomDock()
statusBar()
Figure 3.2. QMainWindow ’sconstituent widgets
Then we call the private functions createActions() ,createMenus() ,create-
ToolBars() ,andcreateStatusBar() to create the rest of the main window. We
also call the private function readSettings() to read the application’s stored
settings.
Weset the window’s icon to icon.png ,aPNG ﬁle. Qt supports many image
formats, including BMP, GIF,#JPEG, MNG, PNG, PNM, XBM, and XPM.
Calling QWidget::setIcon() sets the icon shown in the top-left corner of the
window. Unfortunately, there is no platform-independent way of setting theapplication icon that appears on the desktop. The procedure is explained at
http://doc.trolltech.com/3.2/appicon.html .
GUI applications generally use many images, with some images being used in
several different contexts. Qt has a variety of methods for providing imagesto the application. The most common are:
•Storing images in ﬁles and loading them at run-time.
•Including XPM ﬁles in the source code. (This works because XPM ﬁles are
also valid C ++ﬁles.)
•Using Qt’s “image collection” mechanism.
#If you are in a country that recognizes software patents and where Unisys holds a patent on LZW
decompression, Unisys may require you to license the technology to use GIF. Because of this, GIFsupport is disabled in Qt by default. We believe that this patent will have expired worldwide bythe end of 2004.
44 3. Creating Main Windows
Here we use the “image collection” approach because it is easier and more
efﬁcient than loading ﬁles at run-time, and it works with any supported ﬁleformat. The images are stored in the source tree in a subdirectory called
images .Byadding the entry
IMAGES        = images/icon.png \
                images/new.png \
                images/open.png \
···
                images/find.png \
                images/gotocell.png
to the application’s .pro ﬁle, we tell uicto generate a C ++source code ﬁle that
contains the data for all the speciﬁed images. The data is then compiled intothe application’s executable and can be retrieved using
QPixmap::fromMime-
Source() .This has the advantage that icons and other images cannot get lost;
they are always in the executable.
If you use Qt Designer to create your main windows as well as your dialogs,
you can also use it to handle your .pro ﬁle and to visually add images to the
image collection.
Creating Menus and Toolbars
Most modern GUI applications provide both menus and toolbars,and typicallythey contain more or less the same commands. The menus enable users toexplore the application and learn how to do new things, while the toolbarsprovide quick access to frequently used functionality.
Qt simpliﬁes the programming of menus and toolbars through its “action”
concept. An action is an item that can be added to a menu, a toolbar, or both.
Creating menus and toolbars in Qt involves these steps:
•Create the actions.
•Add the actions to menus.
•Add the actions to toolbars.
In the Spreadsheet application, actions are created in
createActions() :
void MainWindow::createActions()
{    newAct = new QAction(tr("&New"), tr("Ctrl+N"), this);    newAct->setIconSet(QPixmap::fromMimeSource("new.png"));    newAct->setStatusTip(tr("Create a new spreadsheet file"));    connect(newAct, SIGNAL(activated()), this, SLOT(newFile()));
The Newaction has a shortcut key ( New), an accelerator ( Ctrl+N ), a parent (the
main window), an icon ( new.png ), and a status tip.We connect the action’s acti-
vated() signal to the main window’s private newFile() slot, which we’ll imple-
ment in the next section. Without the connection,nothing would happen whenthe user chooses the
File|New menu item or clicks the Newtoolbar button.
Creating Menus and Toolbars 45
The other actions for the File,Edit,and Toolsmenus are very similar to the New
action.
Figure 3.3. The Spreadsheet application’s menus
The Show Grid action in the Options menu is different:
    showGridAct = new QAction(tr("&Show Grid"), 0, this);
    showGridAct->setToggleAction(true);    showGridAct->setOn(spreadsheet->showGrid());    showGridAct->setStatusTip(tr("Show or hide the spreadsheet’s "                                 "grid"));    connect(showGridAct, SIGNAL(toggled(bool)),            spreadsheet, SLOT(setShowGrid(bool)));
Show Grid is a toggle action. It is rendered with a checkmark in the menu and
implemented as a toggle button in the toolbar. When the action is turnedon, the
Spreadsheet component displays a grid. We initialize the action with
the default for the Spreadsheet component, so that they are synchronized at
start up. Then we connect the Show Grid action’s toggled(bool) signal to the
Spreadsheet component’s setShowGrid(bool) slot, which it inherits from QTable .
Once this action is added to a menu or toolbar, the user can toggle the grid onand off.
The
Show Grid and Auto-recalculate actions are independent toggle actions.
QAction also provides for mutually exclusive actions through its QActionGroup
subclass.
Figure 3.4. About Qt
46 3. Creating Main Windows
    aboutQtAct = new QAction(tr("About &Qt"), 0, this);
    aboutQtAct->setStatusTip(tr("Show the Qt library’s About box"));    connect(aboutQtAct, SIGNAL(activated()), qApp, SLOT(aboutQt()));}
ForAbout Qt ,w euse theQApplication object’saboutQt() slot, accessible through
theqApp global variable.
Now that we have created the actions, we can move on to building a menu
system through which the actions can be invoked:
void MainWindow::createMenus()
{    fileMenu = new QPopupMenu(this);    newAct->addTo(fileMenu);    openAct->addTo(fileMenu);    saveAct->addTo(fileMenu);    saveAsAct->addTo(fileMenu);    fileMenu->insertSeparator();    exitAct->addTo(fileMenu);
    for (int i = 0; i < MaxRecentFiles; ++i)
        recentFileIds[i] = -1;
In Qt, all menus are instances of QPopupMenu .Wecreate the Filemenu and then
add the New,Open ,Save,Save As ,and Exitactions to it. We insert a separator
to visually group closely related items together. The forloop takes care of
initializing the recentFilesIds array. We will use recentFilesIds in the next
section when implementing the Filemenu slots.
    editMenu = new QPopupMenu(this);
    cutAct->addTo(editMenu);    copyAct->addTo(editMenu);    pasteAct->addTo(editMenu);    deleteAct->addTo(editMenu);
    selectSubMenu = new QPopupMenu(this);
    selectRowAct->addTo(selectSubMenu);    selectColumnAct->addTo(selectSubMenu);    selectAllAct->addTo(selectSubMenu);    editMenu->insertItem(tr("&Select"), selectSubMenu);
    editMenu->insertSeparator();
    findAct->addTo(editMenu);    goToCellAct->addTo(editMenu);
The Editmenu includes a submenu. The submenu, like the menu it belongs to,
is aQPopupMenu .Wesimply create the submenu with this as parent and insert
it into the Editmenu where we want it to appear.
    toolsMenu = new QPopupMenu(this);
    recalculateAct->addTo(toolsMenu);    sortAct->addTo(toolsMenu);
    optionsMenu = new QPopupMenu(this);
    showGridAct->addTo(optionsMenu);
Creating Menus and Toolbars 47
    autoRecalcAct->addTo(optionsMenu);
    helpMenu = new QPopupMenu(this);
    aboutAct->addTo(helpMenu);    aboutQtAct->addTo(helpMenu);
    menuBar()->insertItem(tr("&File"), fileMenu);
    menuBar()->insertItem(tr("&Edit"), editMenu);    menuBar()->insertItem(tr("&Tools"), toolsMenu);    menuBar()->insertItem(tr("&Options"), optionsMenu);    menuBar()->insertSeparator();    menuBar()->insertItem(tr("&Help"), helpMenu);}
Wecreate the Tools,Options ,and Helpmenus in a similar fashion, and we insert
all the menus into the menu bar. The QMainWindow::menuBar() function returns
apointer to a QMenuBar .(The menu bar is created the ﬁrst time menuBar() is
called.) We insert a separator between the Options and Help menu. In Motif
and similar styles, the separator pushes the Help menu to the right; in other
styles, the separator is ignored.
Figure 3.5. Menu bar in Motif and Windows styles
Creating toolbars is very similar to creating menus:
void MainWindow::createToolBars()
{    fileToolBar = new QToolBar(tr("File"), this);    newAct->addTo(fileToolBar);    openAct->addTo(fileToolBar);    saveAct->addTo(fileToolBar);
    editToolBar = new QToolBar(tr("Edit"), this);
    cutAct->addTo(editToolBar);    copyAct->addTo(editToolBar);    pasteAct->addTo(editToolBar);    editToolBar->addSeparator();    findAct->addTo(editToolBar);    goToCellAct->addTo(editToolBar);}
Wecreate a Filetoolbar and an Edittoolbar. Just like a popup menu, a toolbar
can have separators.
Figure 3.6. The Spreadsheet application’s toolbars
48 3. Creating Main Windows
Now that we have ﬁnished the menus and toolbars, we will add a context
menu to complete the interface:
void MainWindow::contextMenuEvent(QContextMenuEvent *event)
{    QPopupMenu contextMenu(this);    cutAct->addTo(&contextMenu);    copyAct->addTo(&contextMenu);    pasteAct->addTo(&contextMenu);    contextMenu.exec(event->globalPos());}
When the user clicks the right-mouse button (or presses the Menu key on some
keyboards), a “context menu” event is sent to the widget. By reimplementingthe
QWidget::contextMenuEvent() function, we can respond to this event and
pop up a context menu at the current mouse pointer position.
Figure 3.7. The Spreadsheet application’s context menu
Just like signals and slots, events are a fundamental aspect of Qt program-
ming. Events are generated by Qt’s kernel to report mouse clicks, key press-es, resize requests, and similar occurrences. They can be handled by reimple-menting virtual functions, as we are doing here.
Wehave chosen to implement the context menu in
MainWindow because that’s
where we store the actions, but it would also have been possible to implementit in
Spreadsheet .When the user right-clicks the Spreadsheet widget, Qt sends
acontext menu event to that widget ﬁrst. If Spreadsheet reimplements con-
textMenuEvent() and handles the event, the event stops there; otherwise, it is
sent to the parent (the MainWindow ). Events are fully explained in Chapter 7.
The context menu event handler differs from all the code seen so far because
it creates a widget (a QPopupMenu )asavariable on the stack. We could just as
easily have used newanddelete :
    QPopupMenu *contextMenu = new QPopupMenu(this);
    cutAct->addTo(contextMenu);    copyAct->addTo(contextMenu);    pasteAct->addTo(contextMenu);    contextMenu->exec(event->globalPos());    delete contextMenu;
Another noteworthy aspect of the code is the exec() call.QPopupMenu::exec()
shows the popup menu at a given screen position and waits until the user
chooses an option (or dismisses the popup menu) before it returns. At thispoint, the
QPopupMenu object has achieved its purpose, so we can destroy it. If
Creating Menus and Toolbars 49
theQPopupMenu object is located on the stack, it is destroyed automatically at
the end of the function; otherwise, we must call delete .
Wehave now completed the user interface part of the menus and toolbars. We
still have not implemented all of the slots or written code to handle the File
menu’s recently opened ﬁles. The next two sections will address these issues.
Implementing the File Menu
In this section, we will implement the slots and private functions necessary tomake the
Filemenu options work.
void MainWindow::newFile()
{    if (maybeSave()) {        spreadsheet->clear();        setCurrentFile("");    }}
ThenewFile() slot is called when the user clicks the File|New menu option or
clicks the Newtoolbar button. The maybeSave() private function asks the user
“Do you want to save your changes?” if there are unsaved changes. It returns
true if the user chooses either YesorNo(saving the document on Yes), and it
returns false if the user chooses Cancel .ThesetCurrentFile() private function
updates the window’s caption to indicate that an untitled document is beingedited.
Figure 3.8. “Do you want to save your changes?”
bool MainWindow::maybeSave()
{    if (modified) {        int ret = QMessageBox::warning(this, tr("Spreadsheet"),                     tr("The document has been modified.\n"                        "Do you want to save your changes?"),                     QMessageBox::Yes | QMessageBox::Default,                     QMessageBox::No,                     QMessageBox::Cancel | QMessageBox::Escape);        if (ret == QMessageBox::Yes)            return save();        else if (ret == QMessageBox::Cancel)            return false;
50 3. Creating Main Windows
    }
    return true;}
InmaybeSave() ,wedisplay the message box shown in Figure 3.8. The message
box has a Yes,aNo,and a Cancel button. The QMessageBox::Default modiﬁer
makes Yesthe default button. The QMessageBox::Escape modiﬁer makes the
Esckey a synonym for No.
The call to warning() may look a bit complicated at ﬁrst sight, but the general
syntax is straightforward:
QMessageBox::warning( parent, caption, messageText ,
                     button0, button1, ...);
QMessageBox also provides information() ,question() ,andcritical() ,which
behave like warning() but display a different icon.
Information Question Warning Critical
Figure 3.9. Message box icons
void MainWindow::open()
{    if (maybeSave()) {        QString fileName =                QFileDialog::getOpenFileName(".", fileFilters, this);        if (!fileName.isEmpty())            loadFile(fileName);    }}
Theopen() slot corresponds to File|Open .LikenewFile() ,itﬁrst calls maybe-
Save() to handle any unsaved changes. Then it uses the static convenience
function QFileDialog::getOpenFileName() to obtain a ﬁle name. The function
pops up a ﬁle dialog, lets the user choose a ﬁle, and returns the ﬁle name—oran empty string if the user clicked
Cancel .
Wegive the getOpenFileName() function three arguments. The ﬁrst argument
tells it which directory it should start from, in our case the current directory.The second argument,
fileFilters ,speciﬁes the ﬁle ﬁlters. A ﬁle ﬁlter consists
of a descriptive text and a wildcard pattern. In the MainWindow constructor,
fileFilters wasinitialized as follows:
fileFilters = tr("Spreadsheet files (*.sp)");
Had we supported comma-separated values ﬁles and Lotus 1-2-3 ﬁles in
addition to Spreadsheet’s native ﬁle format, we would have initialized thevariable as follows:
Implementing the File Menu 51
fileFilters = tr("Spreadsheet files (*.sp)\n"
                 "Comma-separated values files (*.csv)\n"
                 "Lotus 1-2-3 files (*.wk?)");
Finally, the third argument to getOpenFileName() speciﬁes that the QFileDialog
that pops up should be a child of the main window.
The parent–child relationship doesn’t mean the same thing for dialogs as
for other widgets. A dialog is always a top-level widget (a window in its ownright), but if it has a parent, it is centered on top of the parent by default. Achild dialog also shares the parent’s taskbar entry.
void MainWindow::loadFile(const QString &fileName)
{    if (spreadsheet->readFile(fileName)) {        setCurrentFile(fileName);        statusBar()->message(tr("File loaded"), 2000);    } else {        statusBar()->message(tr("Loading canceled"), 2000);    }}
TheloadFile() private function was called in open() to load the ﬁle. We make
it an independent function because we will need the same functionality to loadrecently opened ﬁles.
Weuse
Spreadsheet::readFile() to read the ﬁle from the disk. If loading is suc-
cessful, we call setCurrentFile() to update the window’s caption. Otherwise,
Spreadsheet::loadFile() will have already notiﬁed the user of the problem
through a message box. In general, it is good practice to let the lower-levelcomponents issue error messages, since they can provide the precise details ofwhat went wrong.
In both cases, we display a message in the status bar for 2000 milliseconds
(2 seconds) to keep the user informed about what the application is doing.
bool MainWindow::save()
{    if (curFile.isEmpty()) {        return saveAs();    } else {        saveFile(curFile);        return true;    }}
void MainWindow::saveFile(const QString &fileName)
{    if (spreadsheet->writeFile(fileName)) {        setCurrentFile(fileName);        statusBar()->message(tr("File saved"), 2000);    } else {        statusBar()->message(tr("Saving canceled"), 2000);    }}
52 3. Creating Main Windows
Thesave() slot corresponds to File|Save .Ifthe ﬁle already has a name because
it was opened before or has already been saved, save() callssaveFile() with
that name; otherwise, it simply calls saveAs() .
bool MainWindow::saveAs()
{    QString fileName =            QFileDialog::getSaveFileName(".", fileFilters, this);    if (fileName.isEmpty())        return false;
    if (QFile::exists(fileName)) {
        int ret = QMessageBox::warning(this, tr("Spreadsheet"),                     tr("File %1 already exists.\n"                        "Do you want to overwrite it?")                     .arg(QDir::convertSeparators(fileName)),                     QMessageBox::Yes | QMessageBox::Default,                     QMessageBox::No | QMessageBox::Escape);        if (ret == QMessageBox::No)            return true;    }    if (!fileName.isEmpty())        saveFile(fileName);    return true;}
ThesaveAs() slot corresponds to File|Save As .WecallQFileDialog::getSave-
FileName() to obtain a ﬁle name from the user. If the user clicks Cancel ,w e
returnfalse ,which is propagated up to maybeSave() .Otherwise, the returned
ﬁle name may be a new name or the name of an existing ﬁle. In the case of anexisting ﬁle, we call
QMessageBox::warning() to display the message box shown
in Figure 3.10.
Figure 3.10. “Do you want to overwrite it?”
The text we passed to the message box is
tr("File %1 already exists\n"
   "Do you want to override it?").arg(QDir::convertSeparators(fileName))
TheQString::arg() function replaces the lowest-numbered “% n”parameter
with its argument and returns the resulting string. For example, if the ﬁlename is
A:\tab04.sp ,the code above is equivalent to
Implementing the File Menu 53
"File A:\\tab04.sp already exists.\n"
"Do you want to override it?"
assuming that the application isn’t translated into another language. The
QDir::convertSeparators() call converts forward slashes, which Qt uses as a
portable directory separator, into the platform-speciﬁc separator (‘/’ on Unixand Mac OS X, ‘/’onWindows).
void MainWindow::closeEvent(QCloseEvent *event)
{    if (maybeSave()) {        writeSettings();        event->accept();    } else {        event->ignore();    }}
When the user clicks File|Exit ,o rclicks Xin the window’s title bar, the QWidget::
close() slot is called. This sends a “close” event to the widget. By reimple-
menting QWidget::closeEvent() ,wecan intercept attempts to close the main
window and decide whether we want the window to close or not.
If there are unsaved changes and the user chooses Cancel ,we“ignore” the
event and leave the window unaffected by it. Otherwise, we accept the event,resulting in Qt closing the window and the application terminating.
void MainWindow::setCurrentFile(const QString &fileName)
{    curFile = fileName;    modLabel->clear();    modified = false;
    if (curFile.isEmpty()) {
        setCaption(tr("Spreadsheet"));    } else {        setCaption(tr("%1 - %2").arg(strippedName(curFile))                                .arg(tr("Spreadsheet")));        recentFiles.remove(curFile);        recentFiles.push_front(curFile);        updateRecentFileItems();    }}
QString MainWindow::strippedName(const QString &fullFileName)
{    return QFileInfo(fullFileName).fileName();}
InsetCurrentFile() ,w e set the curFile private variable that stores the
name of the ﬁle being edited, clear the MOD status indicator, and update the
caption. Notice how arg() is used with two “% n”parameters. The ﬁrst call to
arg() replaces “%1”; the second call replaces “%2”. It would have been easier
to write
54 3. Creating Main Windows
setCaption(strippedName(curFile) + tr(" - Spreadsheet"));
but using arg() gives more ﬂexibility to translators. We remove the ﬁle’s path
withstrippedName() to make the ﬁle name more user-friendly.
If there is a ﬁle name, we update recentFiles ,the application’s recently
opened ﬁles list. We call remove() to remove any occurrence of the ﬁle name
in the list; then we call push_front() to add the ﬁle name as the ﬁrst item.
Calling remove() ﬁrst is necessary to avoid duplicates. After updating the list,
we call the private function updateRecentFileItems() to update the entries in
theFilemenu.
TherecentFiles variable is of type QStringList (list ofQString s). Chapter 11
explains container classes such as QStringList in detail and how they relate to
the C ++Standard Template Library (STL).
This almost completes the implementation of the Filemenu. There is one
function and one supporting slot that we have not implemented yet. Both areconcerned with managing the recently opened ﬁles list.
recentFileIds[0]
recentFileIds[1]recentFileIds[2]recentFileIds[3]recentFileIds[4]separator
Figure 3.11. Filemenu with recently opened ﬁles
void MainWindow::updateRecentFileItems()
{    while ((int)recentFiles.size() > MaxRecentFiles)        recentFiles.pop_back();
    for (int i = 0; i < (int)recentFiles.size(); ++i) {
        QString text = tr("&%1 %2")                       .arg(i + 1)                       .arg(strippedName(recentFiles[i]));        if (recentFileIds[i] == -1) {            if (i == 0)                fileMenu->insertSeparator(fileMenu->count() - 2);            recentFileIds[i] =                    fileMenu->insertItem(text, this,
Implementing the File Menu 55
                                         SLOT(openRecentFile(int)),
                                         0, -1,                                         fileMenu->count() - 2);            fileMenu->setItemParameter(recentFileIds[i], i);        } else {            fileMenu->changeItem(recentFileIds[i], text);        }    }}
TheupdateRecentFileItems() private function is called to update the recently
opened ﬁles menu items. We begin by making sure that there are no moreitems in the
recentFiles list than are allowed ( MaxRecentFiles ,deﬁned as 5 in
mainwindow.h ), removing any extra items from the end of the list.
Then, for each entry, we either create a new menu item or reuse an existing
item if one exists. The very ﬁrst time we create a menu item, we also insert aseparator. We do this here and not in
createMenus() to ensure that we never
display two separators in a row. The setItemParameter() call will be explained
in a moment.
It may seem strange that we create items in updateRecentFileItems() but
never delete items. This is because we can assume that the recently openedﬁles list never shrinks during a session.
The
QPopupMenu::insertItem() function we called has the following syntax:
fileMenu->insertItem( text, receiver , slot, accelerator , id, index);
The text is the text displayed in the menu. We use strippedName() to remove
the path from the ﬁle names. We could keep the full ﬁle names, but thatwould make the
Filemenu very wide. If full ﬁle names are preferred, the best
solution is to put the recently opened ﬁles in a submenu.
The receiver and slot parameters specify the slot that should be called when
the user chooses the item. In our example, we connect to MainWindow ’sopen-
RecentFile(int) slot.
For accelerator and id,wepass default values, meaning that the menu item
has no accelerator and an automatically generated ID. We store the generatedID in the
recentFileIds array so that we can access the items later.
The index is the position where we want to insert the item. By passing the
valuefileMenu->count() +--2, we insert it above the Exititem’s separator.
void MainWindow::openRecentFile(int param)
{    if (maybeSave())        loadFile(recentFiles[param]);}
TheopenRecentFile() slot is where everything falls into place. The slot is
called when a recently opened ﬁle is chosen from the Filemenu. The int
parameter is the value that we set earlier with setItemParameter() .Wechose
56 3. Creating Main Windows
the values in such a way that we can use them magically as indexes into the
recentFiles list.
Menu items Recently opened ﬁles
ID text param index value
+--32 21tab04.sp 0 0 A:\tab04.sp
+--33 2sales 2001.sp 1 1 C:\sales 2001.sp
+--34 3Annual Report.sp 2 2 D:\Annual Report.sp
+--35 4population.sp 3 3 C:\population.sp
+--36 5Customers.sp 4 4 C:\Customers.sp
Figure 3.12. Managing recently opened ﬁles
This is one way to solve the problem. A less elegant solution would have been
to create ﬁve actions and connect them to ﬁve separate slots.
Setting Up the Status Bar
With the menus and toolbars complete,we are ready to tackle the Spreadsheet
application’s status bar. In its normal state, the status bar contains threeindicators: the current cell’s location, the current cell’s formula, and
MOD.The
status bar is also used to display status tips and other temporary messages.
Normal
Status tip
Temporary message
Figure 3.13. The Spreadsheet application’s status bar
TheMainWindow constructor calls createStatusBar() to set up the status bar:
void MainWindow::createStatusBar()
{    locationLabel = new QLabel(" W999 ", this);    locationLabel->setAlignment(AlignHCenter);    locationLabel->setMinimumSize(locationLabel->sizeHint());
    formulaLabel = new QLabel(this);    modLabel = new QLabel(tr(" MOD "), this);
    modLabel->setAlignment(AlignHCenter);    modLabel->setMinimumSize(modLabel->sizeHint());
Setting Up the Status Bar 57
    modLabel->clear();
    statusBar()->addWidget(locationLabel);
    statusBar()->addWidget(formulaLabel, 1);    statusBar()->addWidget(modLabel);
    connect(spreadsheet, SIGNAL(currentChanged(int, int)),
            this, SLOT(updateCellIndicators()));    connect(spreadsheet, SIGNAL(modified()),            this, SLOT(spreadsheetModified()));
    updateCellIndicators();
}
TheQMainWindow::statusBar() function returns a pointer to the status bar.
(The status bar is created the ﬁrst time statusBar() is called.) The status in-
dicators are simply QLabel swhose text we change whenever necessary. When
constructing the QLabel s,we pass this as the parent, but it doesn’t really mat-
ter since QStatusBar::addWidget() automatically “reparents” them to make
them children of the status bar.
Figure 3.13 shows that the three labels have different space requirements.
The cell location and MOD indicators require very little space, and when the
window is resized, any extra space should go to the cell formula indicator inthe middle. This is achieved by specifying a stretch factor of 1 in its
QStatus-
Bar::addWidget() call. The other two indicators have the default stretch factor
of 0, meaning that they prefer not to be stretched.
WhenQStatusBar lays out indicator widgets, it tries to respect each widget’s
ideal size as given by QWidget::sizeHint() and then stretches any stretchable
widgets to ﬁll the available space. A widget’s ideal size is itself dependent onthe widget’s content and varies as we change the content. To avoid constantresizing of the location and
MOD indicators, we set their minimum sizes to
be wide enough to contain the largest possible text on each of the indicators(“W999” and “MOD”), with a little extra space. We also set their alignment to
AlignHCenter to horizontally center their text.
Near the end of the function, we connect two of Spreadsheet ’ssignals to two of
MainWindow ’sslots:updateCellIndicators() andspreadsheetModified() .
void MainWindow::updateCellIndicators()
{    locationLabel->setText(spreadsheet->currentLocation());    formulaLabel->setText(" " + spreadsheet->currentFormula());}
TheupdateCellIndicator() slot updates the cell location and the cell formula
indicators. It is called whenever the user moves the cell cursor to a new cell.The slot is also used as an ordinary function at the end of
createStatusBar()
to initialize the indicators. This is necessary because Spreadsheet doesn’t emit
acurrentChanged() signal at startup.
void MainWindow::spreadsheetModified()
{
58 3. Creating Main Windows
    modLabel->setText(tr("MOD"));
    modified = true;    updateCellIndicators();}
ThespreadsheetModified() slot updates all three indicators so that they reﬂect
the current state of affairs,and sets the modified variable to true.(Weused the
modified variable when implementing the Filemenu to determine whether or
not there were unsaved changes.)
Using Dialogs
In this section, we will explain how to use dialogs in Qt—how to create andinitialize them, run them, and respond to choices made by the user interactingwith them. We will make use of the Find, Go-to-Cell, and Sort dialogs that wecreated in Chapter 2. We will also create a simple About box.
Wewill begin with the Find dialog. Since we want the user to be able to switch
between the main Spreadsheet window and the Find dialog at will, the Finddialog must be modeless. A modeless window is one that runs independently
of any other windows in the application.
When modeless dialogs are created, they normally have their signals connect-
ed to slots that respond to the user’s interactions.
void MainWindow::find()
{    if (!findDialog) {        findDialog = new FindDialog(this);        connect(findDialog, SIGNAL(findNext(const QString &, bool)),                spreadsheet, SLOT(findNext(const QString &, bool)));        connect(findDialog, SIGNAL(findPrev(const QString &, bool)),                spreadsheet, SLOT(findPrev(const QString &, bool)));    }
    findDialog->show();
    findDialog->raise();    findDialog->setActiveWindow();}
The Find dialog is a window that enables the user to search for text in the
spreadsheet. The find() slot is called when the user clicks Edit|Find to pop up
the Find dialog. At that point, several scenarios are possible:
•This is the ﬁrst time the user has invoked the Find dialog.
•The Find dialog was invoked before, but the user closed it.
•The Find dialog was invoked before and is still visible.
If the Find dialog doesn’t already exist, we create it and connect its findNext()
andfindPrev() signals to Spreadsheet ’smatching slots. We could also have
created the dialog in the MainWindow constructor, but delaying its creation
Using Dialogs 59
makes startup faster. Also, if the dialog is never used, it is never created,
saving both time and memory.
Then we call show() ,raise() ,andsetActiveWindow() to ensure that the window
is visible, on top of the others, and active. A call to show() alone is sufﬁcient to
make a hidden window visible, but the Find dialog may be invoked when itswindow is already visible, in which case
show() does nothing. Since we must
make the dialog’s window visible, active, and on top regardless of its previousstate, we must use the
raise() andsetActiveWindow() calls. An alternative
would have been to write
    if (findDialog->isHidden()) {
        findDialog->show();    } else {        findDialog->raise();        findDialog->setActiveWindow();    }
the programming equivalent of driving along at 90 in a 100 km/h zone.
Wewill now look at the Go-to-Cell dialog. We want the user to pop it up, use
it, and close it without being able to switch from the Go-to-Cell dialog to anyother window in the application. This means that the Go-to-Cell dialog mustbe modal. A modal window is a window that pops up when invoked and blocks
the application, preventing any other processing or interactions from takingplace until the window is closed. With the exception of the Find dialog, all thedialogs we have used so far have been modal.
Adialog is modeless if it’s invoked using
show() (unless we call setModal()
beforehand to make it modal); it is modal if it’s invoked using exec() .When
we invoke modal dialogs using exec() ,wetypically don’t need to set up any
signal–slot connections.
void MainWindow::goToCell()
{    GoToCellDialog dialog(this);    if (dialog.exec()) {        QString str = dialog.lineEdit->text();        spreadsheet->setCurrentCell(str.mid(1).toInt() - 1,                                    str[0].upper().unicode() - ’A’);    }}
TheQDialog::exec() function returns true if the dialog is accepted, false oth-
erwise. (Recall that when we created the Go-to-Cell dialog using Qt Designer
in Chapter 2, we connected OKtoaccept() and Cancel toreject() .) If the user
chooses OK,weset the current cell to the value in the line editor; if the user
chooses Cancel ,exec() returns false and we do nothing.
TheQTable::setCurrentCell() function expects two arguments: a row index
and a column index. In the Spreadsheet application, cell A1 is cell (0, 0)and cell B27 is cell (26, 1). To obtain the row index from the
QString returned
byQLabel::text() ,weextract the row number using QString::mid() (which
60 3. Creating Main Windows
returns a substring from the start position to the end of the string), convert it
to anintusingQString::toInt() ,and subtract 1 to make it 0-based. For the
column number, we subtract the numeric value of ‘A’ from the numeric valueof the string’s upper-cased ﬁrst character.
Unlike Find, the Go-to-Cell dialog is created on the stack. This is a common
programming pattern for modal dialogs, just as it is for context menus, sincewe don’t need the dialog after we have used it.
Wewill now turn to the Sort dialog. The Sort dialog is a modal dialog that
allows the user to sort the currently selected area by the columns they specify.Figure 3.14 shows an example of sorting, with column B as the primary sort
key and column A as the secondary sort key (both ascending).
(a) Before sort (b) After sort
Figure 3.14. Sorting the spreadsheet’s selected area
void MainWindow::sort()
{    SortDialog dialog(this);    QTableSelection sel = spreadsheet->selection();    dialog.setColumnRange(’A’ + sel.leftCol(), ’A’ + sel.rightCol());
    if (dialog.exec()) {
        SpreadsheetCompare compare;        compare.keys[0] =              dialog.primaryColumnCombo->currentItem();        compare.keys[1] =              dialog.secondaryColumnCombo->currentItem() - 1;        compare.keys[2] =              dialog.tertiaryColumnCombo->currentItem() - 1;        compare.ascending[0] =              (dialog.primaryOrderCombo->currentItem() == 0);        compare.ascending[1] =              (dialog.secondaryOrderCombo->currentItem() == 0);        compare.ascending[2] =              (dialog.tertiaryOrderCombo->currentItem() == 0);        spreadsheet->sort(compare);    }}
Using Dialogs 61
The code in sort() follows a similar pattern to that used for goToCell() :
•W ecreate the dialog on the stack and initialize it.
•W epop up the dialog using exec() .
•Ifthe user clicks OK,weextract the values entered by the user from the
dialog’s widgets and make use of them.
Thecompare object stores the primary, secondary, and tertiary sort keys and
sort orders. (We will see the deﬁnition of the SpreadsheetCompare class in the
next chapter.) The object is used by Spreadsheet::sort() to compare two rows.
Thekeys array stores the column numbers of the keys. For example, if the
selection extends from C2 to E5, column C has position 0. The ascending array
stores the order associated with each key as a bool.QComboBox::currentItem()
returns the index of the currently selected item, starting at 0. For the sec-ondary and tertiary keys, we subtract one from the current item to account forthe “None” item.
The
sort() dialog does the job, but it is very fragile. It takes for granted that
the Sort dialog is implemented in a certain way, with comboboxes and “None”items. This means that if we redesign the Sort dialog, we may also need torewrite this code. While this approach is adequate for a dialog that is onlycalled from one place, it opens the door to maintenance nightmares if thedialog is used in several places.
Amore robust approach is to make the
SortDialog class smarter by having
it create a SpreadsheetCompare object itself, which can then be accessed by its
caller. This simpliﬁes MainWindow::sort() signiﬁcantly:
void MainWindow::sort()
{    SortDialog dialog(this);    QTableSelection sel = spreadsheet->selection();    dialog.setColumnRange(’A’ + sel.leftCol(), ’A’ + sel.rightCol());    if (dialog.exec())        spreadsheet->performSort(dialog.comparisonObject());}
This approach leads to loosely coupled components and is almost always the
right choice for dialogs that will be called from more than one place.
Amore radical approach is to pass a pointer to the Spreadsheet object when
initializing the SortDialog object and to allow the dialog to operate directly
on theSpreadsheet .This makes the SortDialog much less general, since it will
only work on a certain type of widget, but it simpliﬁes the code ever furtherby eliminating the
SortDialog::setColumnRange() function. The MainWindow::
sort() function then becomes
void MainWindow::sort()
{    SortDialog dialog(this);    dialog.setSpreadsheet(spreadsheet);
62 3. Creating Main Windows
    dialog.exec();
}
This approach mirrors the ﬁrst: Instead of the caller needing intimate knowl-
edge of the dialog, the dialog needs intimate knowledge of the data structuressupplied by the caller. This approach may be useful where the dialog needsto apply changes live. But just as the caller code is fragile using the ﬁrst ap-proach, this third approach breaks if the data structures change.
Some developers choose just one approach to using dialogs and stick with that.
This has the beneﬁt of familiarity and simplicity since all their dialog usagesfollow the same pattern, but it also misses the beneﬁts of the approaches thatare not used. The decision on which approach to use should be made on aper-dialog basis.
Wewill round off this section with a simple About box. We could create a cus-
tom dialog like the Find or Go-to-Cell dialogs to present the “about” informa-tion, but since most About boxes are highly stylized, Qt provides a simpler so-lution.
void MainWindow::about()
{    QMessageBox::about(this, tr("About Spreadsheet"),            tr("<h2>Spreadsheet 1.0</h2>"               "<p>Copyright &copy; 2003 Software Inc."               "<p>Spreadsheet is a small application that "               "demonstrates <b>QAction</b>, <b>QMainWindow</b>, "               "<b>QMenuBar</b>, <b>QStatusBar</b>, "               "<b>QToolBar</b>, and many other Qt classes."));}
The About box is obtained by calling QMessageBox::about() ,astatic conve-
nience function. The function is very similar to QMessageBox::warning() ,except
that it uses the parent window’s icon instead of the standard “warning” icon.
Figure 3.15. About Spreadsheet
So far we have used several convenience static functionsfrom both QMessageBox
andQFileDialog .These functions create a dialog, initialize it, and call exec()
on it. It is also possible, although less convenient, to create a QMessageBox or
aQFileDialog widget like any other widget and explicitly call exec() ,oreven
show() ,o nit.
Storing Settings 63
Storing Settings
In theMainWindow constructor, we called readSettings() to load the applica-
tion’s stored settings. Similarly, in closeEvent() ,wecalledwriteSettings() to
save the settings. These two functions are the last MainWindow member func-
tions that need to be implemented.
The arrangement we opted for in MainWindow ,with all the QSettings -related
code in readSettings() andwriteSettings() ,isjust one of many possible
approaches. A QSettings object can be created to query or modify some setting
at any time during the execution of the application and from anywhere inthe code.
void MainWindow::writeSettings()
{    QSettings settings;    settings.setPath("software-inc.com", "Spreadsheet");    settings.beginGroup("/Spreadsheet");    settings.writeEntry("/geometry/x", x());    settings.writeEntry("/geometry/y", y());    settings.writeEntry("/geometry/width", width());    settings.writeEntry("/geometry/height", height());    settings.writeEntry("/recentFiles", recentFiles);    settings.writeEntry("/showGrid", showGridAct->isOn());    settings.writeEntry("/autoRecalc", showGridAct->isOn());    settings.endGroup();}
ThewriteSettings() function saves the main window’s geometry (position
and size), the list of recently opened ﬁles, and the Show Grid and Auto-recalculate
options.
QSettings stores the application’s settings in platform-speciﬁc locations. On
Windows, it uses the system registry; on Unix, it stores the data in text ﬁles;
on Mac OS X, it uses the Carbon preferences API. The setPath() call provides
QSettings with the organization’s name (as an Internet domain name) and the
product’s name. This information is used in a platform-speciﬁc way to ﬁnd alocation for the settings.
QSettings stores settings as key–value pairs. The keyis similar to a ﬁle system
path and should always start with the name of the application. For example,
/Spreadsheet/geometry/x and/Spreadsheet/showGrid are valid keys. (The
beginGroup() call saves us from writing /Spreadsheet in front of every key.)
Thevalue can be an int,abool,adouble ,aQString ,o raQStringList .
void MainWindow::readSettings()
{    QSettings settings;    settings.setPath("software-inc.com", "Spreadsheet");    settings.beginGroup("/Spreadsheet");
    int x = settings.readNumEntry("/geometry/x", 200);
    int y = settings.readNumEntry("/geometry/y", 200);
64 3. Creating Main Windows
    int w = settings.readNumEntry("/geometry/width", 400);
    int h = settings.readNumEntry("/geometry/height", 400);    move(x, y);    resize(w, h);
    recentFiles = settings.readListEntry("/recentFiles");
    updateRecentFileItems();
    showGridAct->setOn(
            settings.readBoolEntry("/showGrid", true));    autoRecalcAct->setOn(            settings.readBoolEntry("/autoRecalc", true));
    settings.endGroup();
}
ThereadSettings() function loads the settings that were saved by writeSet-
tings() .The second argument to the “read” functions speciﬁes a default value,
in case there are no settings available. The default values are used the ﬁrsttime the application is run.
Wehave now completed the Spreadsheet’s
MainWindow implementation. In the
following sections, we will discuss how the Spreadsheet application can bemodiﬁed to handle multiple documents and how to implement a splash screen.Wewill complete its functionality in the next chapter.
Multiple Documents
Weare now ready to code the Spreadsheet application’s main() function:
#include <qapplication.h>
#include "mainwindow.h"int main(int argc, char *argv[])
{    QApplication app(argc, argv);    MainWindow mainWin;    app.setMainWidget(&mainWin);    mainWin.show();    return app.exec();}
Thismain() function is a little bit different from those we have written so far:
Wehave created the MainWindow instance as a variable on the stack instead of
usingnew.TheMainWindow instance is then automatically destroyed when the
function terminates.
With themain() function shown above, the Spreadsheet application provides
asingle main window and can only handle one document at a time. If we
want to edit multiple documents at the same time, we could start multiple
instances of the Spreadsheet application. But this isn’t as convenient forusers as having a single instance of the application providing multiple main
Multiple Documents 65
windows, just as one instance of a web browser can provide multiple browser
windows simultaneously.
Wewill modify the Spreadsheet application so that it can handle multiple
documents. First, we need a slightly different Filemenu:
•File|New creates a new main window with
an empty document, instead of recyclingthe current main window.
•
File|Close closes the current main
window.
•File|Exit closes all windows.
In the original version of the Filemenu, there
was no Close option because that would have
been the same as Exit.
Figure 3.16. The new Filemenu
This is the new main() function:
#include <qapplication.h>
#include "mainwindow.h"int main(int argc, char *argv[])
{    QApplication app(argc, argv);    MainWindow *mainWin = new MainWindow;    mainWin->show();    QObject::connect(&app, SIGNAL(lastWindowClosed()),                     &app, SLOT(quit()));    return app.exec();}
Weconnect QApplication ’slastWindowClosed() slot toQApplication ’squit()
slot, which will terminate the application.
With multiple windows, it now makes sense to create MainWindow withnew,
because then we can use delete on a main window when we have ﬁnished with
it to save memory. This issue doesn’t arise if the application uses just onemain window.
This is the new
MainWindow::newFile() slot:
void MainWindow::newFile()
{    MainWindow *mainWin = new MainWindow;    mainWin->show();}
Wesimply create a new MainWindow instance. It may seem odd that we don’t
keep any pointer to the new window, but that isn’t a problem since Qt keepstrack of all the windows for us.
These are the actions for
Close and Exit:
66 3. Creating Main Windows
closeAct = new QAction(tr("&Close"), tr("Ctrl+W"), this);
connect(closeAct, SIGNAL(activated()), this, SLOT(close()));
exitAct = new QAction(tr("E&xit"), tr("Ctrl+Q"), this);
connect(exitAct, SIGNAL(activated()),        qApp, SLOT(closeAllWindows()));
QApplication
’scloseAllWindows() slot closes all of the application’s windows,
unless one of them rejects the close event. This is exactly the behavior we needhere. We don’t have to worry about unsaved changes because that’s handledin
MainWindow::closeEvent() whenever a window is closed.
It looks as if we have ﬁnished making the application capable of handling
multiple windows. Unfortunately, there is a hidden problem lurking: If theuser keeps creating and closing main windows, the machine might run outof memory! This is because we keep creating
MainWindow widgets in newFile()
but we never delete them. When the user closes a main window, the defaultbehavior is to hide it, so it still remains in memory. With many main windows,this can be a problem.
The solution is to add the
WDestructiveClose ﬂag to the constructor:
MainWindow::MainWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name, WDestructiveClose){
···
}
This tells Qt to delete the window when it is closed. The WDestructiveClose
ﬂag is one of many ﬂags that can be passed to the QWidget constructor to
inﬂuence a widget’s behavior. Most of the other ﬂags are rarely needed inQt applications.
Memory leaking isn’t the only problem that we must deal with. Our original
application design included an implied assumption that we would only haveone main window. With multiple windows, each main window has its ownrecently opened ﬁles list and its own options. Clearly, the recently opened ﬁleslist should be global to the whole application. We can achieve this quite easilyby declaring the
recentFiles variable static, so that only one instance of it
exists for the whole application. But then we must ensure that wherever wecalled
updateRecentFileItems() to update the Filemenu, we must call it on all
main windows. Here’s the code to achieve this:
QWidgetList *list = QApplication::topLevelWidgets();
QWidgetListIt it(*list);QWidget *widget;while ((widget = it.current())) {    if (widget->inherits("MainWindow"))        ((MainWindow *)widget)->updateRecentFileItems();    ++it;}delete list;
Multiple Documents 67
The code iterates over all the application’s top-level widgets and calls update-
RecentFileItems() on all widgets of type MainWindow .Similar code can be used
for synchronizing the Show Grid and Auto-recalculate options,or to make sure that
the same ﬁle isn’t loaded twice. The QWidgetList type is a typedef for QPtr-
List<QWidget> ,which is presented in Chapter 11 (Container Classes).
Figure 3.17. SDI vs. MDI
Applications that provide one document per main window are said to be SDI
(single document interface) applications. A popular alternative is MDI (mul-tiple document interface), where the application has a single main windowthat manages multiple document windows within its central area. Qt can beused to create both SDI and MDI applications on all its supported platforms.Figure 3.17 shows the Spreadsheet application using both approaches. MDI
is explained in Chapter 6 (Layout Management).
Splash Screens
Many applications present a splash screen at startup. Some developers useasplash screen to disguise a slow startup, while others do it to satisfy their
marketing departments. Adding a splash screen to Qt applications is veryeasy using the
QSplashScreen class.
TheQSplashScreen class shows an image before the application proper has
started. It can also draw a message on the image, to inform the user aboutthe progress of the application’s initialization process. Typically, the splashscreen code is located in
main() ,before the call to QApplication::exec() .
Below is an example main() function that uses QSplashScreen to present a
splash screen in an application that loads modules and establishes networkconnections at startup.
int main(int argc, char *argv[])
{    QApplication app(argc, argv);
68 3. Creating Main Windows
    QSplashScreen *splash =
            new QSplashScreen(QPixmap::fromMimeSource("splash.png"));    splash->show();
    splash->message(QObject::tr("Setting up the main window..."),
                    Qt::AlignRight | Qt::AlignTop, Qt::white);    MainWindow mainWin;    app.setMainWidget(&mainWin);
    splash->message(QObject::tr("Loading modules..."),
                    Qt::AlignRight | Qt::AlignTop, Qt::white);    loadModules();
    splash->message(QObject::tr("Establishing connections..."),
                    Qt::AlignRight | Qt::AlignTop, Qt::white);    establishConnections();
    mainWin.show();
    splash->finish(&mainWin);    delete splash;
    return app.exec();
}
Figure 3.18. AQSplashScreen widget
Wehave now completed the Spreadsheet application’s user interface. In
the next chapter, we will complete the application by implementing the corespreadsheet functionality.
44
Implementing Application
Functionality•TheCentral Widget
•Subclassing QTable
•Loading and Saving
•Implementing the Edit Menu
•Implementing the Other
Menus
•Subclassing QTableItem
In the previous two chapters, we explained how to create the Spreadsheet
application’s user interface. In this chapter, we will complete the program bycoding its underlying functionality. Among other things, we will see how toload and save ﬁles, how to store data in memory, how to implement clipboardoperations, and how to add support for spreadsheet formulas to
QTable .
The Central Widget
The central area of a QMainWindow can be occupied by any kind of widget.
Here’s an overview of the possibilities:
1. Use a standard Qt widget.
Astandard widget like QTable orQTextEdit can be used as a central wid-
get. In this case, the application’s functionality, such as loading and sav-ing ﬁles, must be implemented elsewhere (for example, in a
QMainWindow
subclass).
2. Use a custom widget.
Specialized applications often need to show data in a custom widget. For
example, an icon editor program would have an IconEditor widget as its
central widget. Chapter 5 explains how to write custom widgets in Qt.
3. Use a plain QWidget with a layout manager.
Sometimes the application’s central area is occupied by many widgets.
This can be done by using a QWidget as the parent of all the other widgets,
and using layout managers to size and position the child widgets.
69
70 4. Implementing Application Functionality
4. Use a splitter.
Another way of using multiple widgets together is to use a QSplitter .The
QSplitter arranges its child widgets side by side like a QHBox ,o ri na col-
umn like a QVBox ,with splitter handles to give some sizing control to the
user. Splitters can contain all kinds of widgets, including other splitters.
5. Use an MDI workspace.
If the application uses MDI, the central area is occupied by a QWorkspace
widget, and each of the MDI windows is a child of that widget.
Layouts, splitters, and MDI workspaces can be used in combination with
standard Qt widgets or with custom widgets. Chapter 6 covers these classesin depth.
Forthe Spreadsheet application, a
QTable subclass is used as the central
widget. The QTable class already provides most of the spreadsheet capability
we need, but it doesn’t understand spreadsheet formulas like “=A1+A2+A3”,and it doesn’t support clipboard operations. We will implement this missingfunctionality in the
Spreadsheet class, which inherits from QTable .
Subclassing QTable
Wewill now start implementing the Spreadsheet widget, beginning with the
header ﬁle:
#ifndef SPREADSHEET_H
#define SPREADSHEET_H
#include <qstringlist.h>
#include <qtable.h>
class Cell;
class SpreadsheetCompare;
The header starts with forward declarations for the Cell andSpreadsheetCom-
pare classes.
Qt
QObject QTableItem
QWidget Cell
QTable
Spreadsheet
Figure 4.1. Inheritance tree for Spreadsheet andCell
Subclassing QTable 71
The attributes of a QTable cell, such as its text and its alignment, are stored
in aQTableItem .UnlikeQTable ,QTableItem isn’t a widget class; it is a pure data
class. The Cell class is a QTableItem subclass. In addition to the standard
QTableItem attributes, Cell stores a cell’s formula.
Wewill explain the Cell class when we present its implementation in the last
section of this chapter.
class Spreadsheet : public QTable
{    Q_OBJECTpublic:    Spreadsheet(QWidget *parent = 0, const char *name = 0);
    void clear();
    QString currentLocation() const;    QString currentFormula() const;    bool autoRecalculate() const { return autoRecalc; }    bool readFile(const QString &fileName);    bool writeFile(const QString &fileName);    QTableSelection selection();    void sort(const SpreadsheetCompare &compare);
TheSpreadsheet class inherits from QTable .Subclassing QTable is very similar
to subclassing QDialog orQMainWindow .
In Chapter 3, we relied on many public functions in Spreadsheet when we
implemented MainWindow .For example, we called clear() fromMainWindow::
newFile() to reset the spreadsheet. We also used some functions inherited
fromQTable ,notably setCurrentCell() andsetShowGrid() .
public slots:
    void cut();    void copy();    void paste();    void del();    void selectRow();    void selectColumn();    void selectAll();    void recalculate();    void setAutoRecalculate(bool on);    void findNext(const QString &str, bool caseSensitive);    void findPrev(const QString &str, bool caseSensitive);
signals:
    void modified();
Spreadsheet
provides many slots that implement actions from the Edit,Tools,
and Options menus.
protected:
    QWidget *createEditor(int row, int col, bool initFromCell) const;    void endEdit(int row, int col, bool accepted, bool wasReplacing);
72 4. Implementing Application Functionality
Spreadsheet reimplements two virtual functions from QTable .These functions
are called by QTable itself when the user starts editing the value of a cell. We
need to reimplement them to support spreadsheet formulas.
private:
    enum { MagicNumber = 0x7F51C882, NumRows = 999, NumCols = 26 };
    Cell *cell(int row, int col) const;
    void setFormula(int row, int col, const QString &formula);    QString formula(int row, int col) const;    void somethingChanged();
    bool autoRecalc;
};
In the class’s private section, we deﬁne three constants, four functions, and
one variable.
class SpreadsheetCompare
{public:    bool operator()(const QStringList &row1,                    const QStringList &row2) const;
    enum { NumKeys = 3 };
    int keys[NumKeys];    bool ascending[NumKeys];};
#endif
The header ﬁle ends with the SpreadsheetCompare class declaration. We will
explain this when we review Spreadsheet::sort() .
Wewill now look at the implementation, explaining each function in turn:
#include <qapplication.h>
#include <qclipboard.h>#include <qdatastream.h>#include <qfile.h>#include <qlineedit.h>#include <qmessagebox.h>#include <qregexp.h>#include <qvariant.h>
#include <algorithm>
#include <vector>using namespace std;
#include "cell.h"
#include "spreadsheet.h"
Weinclude the header ﬁles for the Qt classes the application will use. We also
include the standard C ++<algorithm> and<vector> header ﬁles. The using
namespace directive imports all the symbols from the stdnamespace into the
global namespace, allowing us to write stable_sort() andvector<T> instead of
std::stable_sort() andstd::vector<T> .
Subclassing QTable 73
Spreadsheet::Spreadsheet(QWidget *parent, const char *name)
    : QTable(parent, name){    autoRecalc = true;    setSelectionMode(Single);    clear();}
In the constructor, we set the QTable selection mode to Single .This ensures
that only one rectangular area in the spreadsheet can be selected at a time.
void Spreadsheet::clear()
{    setNumRows(0);    setNumCols(0);    setNumRows(NumRows);    setNumCols(NumCols);    for (int i = 0; i < NumCols; i++)        horizontalHeader()->setLabel(i, QChar(’A’ + i));    setCurrentCell(0, 0);}
Theclear() function is called from the Spreadsheet constructor to initialize the
spreadsheet. It is also called from MainWindow::newFile() .
Weresize the spreadsheet down to 0 × 0, effectively clearing the whole
spreadsheet, and resize it again to NumCols ×NumRows (26 × 999). We change the
column labels to “A”, “B”, …, “Z” (the default is “1”, “2”, …, “26”) and move thecell cursor to cell A1.
horizontalHeader()verticalHeader()
verticalScrollBar()
horizontalScrollBar()viewport()
Figure 4.2. QTable ’sconstituent widgets
AQTable is composed of many child widgets. It has a horizontal QHeader at the
top, a vertical QHeader on the left, a QScrollBar on the right, and a QScrollBar
at the bottom. The area in the middle is occupied by a special widget calledtheviewport ,onwhich
QTable draws the cells. The different child widgets
are accessible through functions in QTable and its base class, QScrollView .
Forexample, in clear() ,weaccess the table’s top QHeader through QTable::
horizontalHeader() .
74 4. Implementing Application Functionality
Storing Data as Items
In the Spreadsheet application, every non-empty cell is stored in memory
as an individual QTableItem object. This pattern of storing data as items
is not speciﬁc to QTable ;Qt’sQIconView ,QListBox ,andQListView classes also
operate on items ( QIconViewItem s,QListBoxItem s,andQListViewItem s).
Qt’s item classes can be used out of the box as data holders. For example,
aQTableItem already stores a few attributes, including a string, a pixmap,
and a pointer back to the QTable .Bysubclassing the item class, we can store
additional data and reimplement virtual functions to use that data.
Many toolkits provide a void pointer in their item classes to store custom
data. Qt doesn’t burden every item with a pointer that may not be used;instead, it gives programmers the freedom to subclass the item classes andto store the data there, possibly as a pointer to another data structure. If a
void pointer is required, it can be trivially achieved by subclassing an item
class and adding a void pointer member variable.
WithQTable ,itispossible to bypass the item mechanism by reimplementing
low-level functions such as paintCell() andclearCell() .Ifthe data to dis-
play in a QTable is already available in memory in another data structure,
this approach can be used to avoid data duplication. For details, see the Qt
Quarterly article “A Model/View Table for Large Datasets”, available online
athttp://doc.trolltech.com/qq/qq07-big-tables.html .
Qt 4 is expected to be more ﬂexible than Qt 3 for storing data. In addition
to supporting items, Qt 4 will probably offer a single uniﬁed item typeusable by all item views, and the item views will not take ownership of theitems they display, making it possible to display the same items in multipleviews simultaneously.
QScrollView is the natural base class for widgets that can present lots of data.
It provides a scrollable viewport and two scroll bars, which can be turned onand off. It is covered in Chapter 6.
Cell *Spreadsheet::cell(int row, int col) const
{    return (Cell *)item(row, col);}
Thecell() private function returns the Cell object for a given row and column.
It is almost the same as QTable::item() ,except that it returns a Cell pointer
instead of a QTableItem pointer.
QString Spreadsheet::formula(int row, int col) const
{    Cell *c = cell(row, col);    if (c)        return c->formula();    else
Subclassing QTable 75
        return "";
}
Theformula() private function returns the formula for a given cell. If cell()
returns a null pointer, the cell is empty, so we return an empty string.
void Spreadsheet::setFormula(int row, int col,                             const QString &formula){    Cell *c = cell(row, col);    if (c) {        c->setFormula(formula);        updateCell(row, col);    } else {        setItem(row, col, new Cell(this, formula));    }}
ThesetFormula() private function sets the formula for a given cell. If the
cell already has a Cell object, we reuse it and call updateCell() to tellQTable
to repaint the cell if it’s shown on screen. Otherwise, we create a new Cell
object and call QTable::setItem() to insert it into the table and repaint the cell.
Wedon’t need to worry about deleting the Cell object later on; QTable takes
ownership of the cell and will delete it automatically at the right time.
QString Spreadsheet::currentLocation() const
{    return QChar(’A’ + currentColumn())           + QString::number(currentRow() + 1);}
ThecurrentLocation() function returns the current cell’s location in the usual
spreadsheet format of column letter followed by row number. MainWindow::
updateCellIndicators() uses it to show the location in the status bar.
QString Spreadsheet::currentFormula() const
{    return formula(currentRow(), currentColumn());}
ThecurrentFormula() function returns the current cell’s formula. It is called
fromMainWindow::updateCellIndicators() .
QWidget *Spreadsheet::createEditor(int row, int col,
                                   bool initFromCell) const{    QLineEdit *lineEdit = new QLineEdit(viewport());    lineEdit->setFrame(false);    if (initFromCell)        lineEdit->setText(formula(row, col));    return lineEdit;}
ThecreateEditor() function is reimplemented from QTable .Itiscalled when
the user starts editing a cell—either by clicking the cell, pressing F2,orsimply
starting to type. Its role is to create an editor widget to be shown on top of
76 4. Implementing Application Functionality
the cell. If the user clicked the cell or pressed F2to edit the cell, initFromCell
istrue and the editor must start with the current cell’s content. If the user
simply started typing, the cell’s previous content is ignored.
The default behavior of this function is to create a QLineEdit and initialize
it with the cell’s text if initFromCell istrue.Wereimplement the function to
show the cell’s formula instead of the cell’s text.
Wecreate the QLineEdit as a child of the QTable ’sviewport. QTable takes care
of resizing the QLineEdit to match the cell’s size and of positioning it over the
cell that is to be edited. QTable also takes care of deleting the QLineEdit when
it is no longer needed.
12¬=A1][
Cell QLineEdit
Figure 4.3. Editing a cell by superimposing a QLineEdit
In many cases, the formula and the text are the same; for example, the
formula “Hello” evaluates to the string “Hello”, so if the user types “Hello”into a cell and presses
Enter ,that cell will show the text “Hello”. But there are
some exceptions:
•Ifthe formula is a number, it is interpreted as such. For example, the
formula “1.50” evaluates to the double value 1.5, which is rendered as a
right-aligned “1.5” in the spreadsheet.
•Ifthe formula starts with a single quote, the rest of the formula is
interpreted as text. For example, the formula “ ’12345” evaluates to thestring “12345”.
•Ifthe formula starts with an equals sign (‘=’), the formula is interpreted
as an arithmetic formula. For example, if cell A1 contains “12” and cellA2 contains “6”, the formula “=A1+A2” evaluates to 18.
The task of converting a formula into a value is performed by the
Cell class.
Forthe moment, the important thing to bear in mind is that the text shown in
the cell is the result of evaluating the formula, not the formula itself.
void Spreadsheet::endEdit(int row, int col, bool accepted,
                          bool wasReplacing){    QLineEdit *lineEdit = (QLineEdit *)cellWidget(row, col);    if (!lineEdit)        return;    QString oldFormula = formula(row, col);    QString newFormula = lineEdit->text();
    QTable::endEdit(row, col, false, wasReplacing);    if (accepted && newFormula != oldFormula) {
        setFormula(row, col, newFormula);
Subclassing QTable 77
        somethingChanged();
    }}
TheendEdit() function is reimplemented from QTable .Itiscalled when the
user has ﬁnished editing a cell,either by clicking elsewhere in the spreadsheet(which conﬁrms the edit),by pressing
Enter (which also conﬁrms the edit),or by
pressing Esc(which rejects the edit). The function’s purpose is to transfer the
editor’s content back into the Cell object if the edit is conﬁrmed.
The editor is available from QTable::cellWidget() .Wecan safely cast it to a
QLineEdit since the widget we create in createEditor() is always a QLineEdit .
=A1+A2 ][¬18
QLineEdit Cell
Figure 4.4. Returning a QLineEdit ’scontent to a cell
In the middle of the function, we call QTable ’simplementation of endEdit() ,
because QTable needs to know when editing has ﬁnished. We pass false as
third argument to endEdit() to prevent it from modifying the table item, since
we want to create or modify it ourselves. If the new formula is different fromthe old one, we call
setFormula() to modify the Cell object and call something-
Changed() .
void Spreadsheet::somethingChanged()
{    if (autoRecalc)        recalculate();    emit modified();}
ThesomethingChanged() private function recalculates the whole spreadsheet if
Auto-recalculate is enabled and emits the modified() signal.
Loading and Saving
Wewill now implement the loading and saving of Spreadsheet ﬁles using
acustom binary format. We will do this using QFile andQDataStream ,which
together provide platform-independent binary I/O.
Wewill start with writing a Spreadsheet ﬁle:
bool Spreadsheet::writeFile(const QString &fileName)
{    QFile file(fileName);    if (!file.open(IO_WriteOnly)) {        QMessageBox::warning(this, tr("Spreadsheet"),                             tr("Cannot write file %1:\n%2.")                             .arg(file.name())                             .arg(file.errorString()));        return false;
78 4. Implementing Application Functionality
    }
    QDataStream out(&file);
    out.setVersion(5);
    out << (Q_UINT32)MagicNumber;    QApplication::setOverrideCursor(waitCursor);
    for (int row = 0; row < NumRows; ++row) {        for (int col = 0; col < NumCols; ++col) {            QString str = formula(row, col);            if (!str.isEmpty())                out << (Q_UINT16)row << (Q_UINT16)col << str;        }    }    QApplication::restoreOverrideCursor();    return true;}
ThewriteFile() function is called from MainWindow::saveFile() to write the ﬁle
to disk. It returns true on success, false on error.
Wecreate a QFile object with the given ﬁle name and call open() to open the
ﬁle for writing. We also create a QDataStream object that operates on the QFile
and use it to write out the data. Just before we write the data, we changethe application’s cursor to the standard wait cursor (usually an hourglass)and restore the normal cursor once all the data is written. At the end of thefunction, the ﬁle is automatically closed by
QFile ’sdestructor.
QDataStream supports basic C ++types as well as many of Qt’s types. The
syntax is modeled after the standard <iostream> classes. For example,
out << x << y << z;
writes the variables x,y,andzto a stream, and
in >> x >> y >> z;
reads them from a stream.
Because the C ++basic types char,short ,int,long,andlong long may have
different sizes on different platforms, it is safest to cast these values to oneof
Q_INT8 ,Q_UINT8 ,Q_INT16 ,Q_UINT16 ,Q_INT32 ,Q_UINT32 ,Q_INT64 ,andQ_UINT64 ,
which are guaranteed to be of the size they advertise (in bits).
QDataStream is very versatile. It can be used on a QFile ,but also on a QBuffer ,
aQSocket ,o raQSocketDevice .Similarly, QFile can be used with a QTextStream
instead of QDataStream ,oreven raw. Chapter 10 explains these classes
in depth.
The Spreadsheet application’s ﬁle format is fairly simple. A Spreadsheet ﬁle
starts with a 32-bit number that identiﬁes the ﬁle format ( MagicNumber ,deﬁned
as 0x7F51C882 in spreadsheet.h ). Then come a series of blocks, each of which
contains a single cell’s row, column, and formula. To save space, we don’t writeout empty cells.
Loading and Saving 79
0x7F51C882 122 4Hg 122 5Mercury ···
Figure 4.5. The Spreadsheet ﬁle format
The precise binary representation of the data types is determined by QData-
Stream .For example,a Q_UINT16 is represented as two bytes in big-endian order,
and aQString as the string’s length followed by the Unicode characters.
The binary representation of Qt types has evolved quite a lot since Qt 1.0. It
is likely to continue evolving in future Qt releases to keep pace with the evo-lution of existing types and to allow for new Qt types. By default,
QDataStream
uses the most recent version of the binary format (version 5 in Qt 3.2), but itcan be set to read older versions. To avoid any compatibility problems if theapplication is recompiled later using a newer Qt release, we tell
QDataStream to
use version 5 irrespective of the version of Qt we are compiling against.
bool Spreadsheet::readFile(const QString &fileName)
{    QFile file(fileName);    if (!file.open(IO_ReadOnly)) {        QMessageBox::warning(this, tr("Spreadsheet"),                             tr("Cannot read file %1:\n%2.")                             .arg(file.name())                             .arg(file.errorString()));        return false;    }
    QDataStream in(&file);
    in.setVersion(5);
    Q_UINT32 magic;
    in >> magic;    if (magic != MagicNumber) {        QMessageBox::warning(this, tr("Spreadsheet"),                             tr("The file is not a "                                "Spreadsheet file."));        return false;    }
    clear();    Q_UINT16 row;
    Q_UINT16 col;    QString str;
    QApplication::setOverrideCursor(waitCursor);
    while (!in.atEnd()) {        in >> row >> col >> str;        setFormula(row, col, str);    }    QApplication::restoreOverrideCursor();    return true;}
80 4. Implementing Application Functionality
ThereadFile() function is very similar to writeFile() .W e useQFile to read
in the ﬁle, but this time using the IO_ReadOnly ﬂag rather than IO_WriteOnly .
Then we set the QDataStream version to 5. The format for reading must always
be the same as for writing.
If the ﬁle has the correct magic number at the beginning, we call clear() to
blank out all the cells in the spreadsheet and we read in the cell data. The callto
clear() is necessary to blank out the cells that are not speciﬁed in the ﬁle.
Implementing the Edit Menu
Weare now ready to implement the slots that correspond to the application’s
Editmenu.
void Spreadsheet::cut()
{    copy();    del();}
Thecut() slot corresponds to Edit|Cut .The implementation is simple since Cut
is the same as Copy followed by Delete .
Figure 4.6. The Spreadsheet application’s Editmenu
void Spreadsheet::copy()
{    QTableSelection sel = selection();    QString str;
    for (int i = 0; i < sel.numRows(); ++i) {
        if (i > 0)            str += "\n";        for (int j = 0; j < sel.numCols(); ++j) {            if (j > 0)                str += "\t";            str += formula(sel.topRow() + i, sel.leftCol() + j);        }    }
Implementing the Edit Menu 81
    QApplication::clipboard()->setText(str);
}
Thecopy() slot corresponds to Edit|Copy .Ititerates over the current selection.
Each selected cell’s formula is added to a QString ,with rows separated by
newline characters and columns separated by tab characters.
±
"Red \tGreen \tBlue \nCyan \tMagenta \tYellow"
Figure 4.7. Copying a selection onto the clipboard
The system clipboard is available in Qt through the QApplication::clipboard()
static function. By calling QClipboard::setText() ,wemake the text available
on the clipboard,both to this application and to other applicationsthat supportplain text. Our format with tab and newline characters as separator is under-stood by a variety of applications, including Microsoft Excel.
QTableSelection Spreadsheet::selection()
{    if (QTable::selection(0).isEmpty())        return QTableSelection(currentRow(), currentColumn(),                               currentRow(), currentColumn());    return QTable::selection(0);}
Theselection() private function returns the current selection. It depends on
QTable::selection() ,which returns a selection by number. Since we set the
selection mode to Single ,there is only one selection, numbered 0. But it’s also
possible that there is no selection at all. This is because QTable doesn’t treat
the current cell as a selection in its own right. This behavior is reasonable, butslightly inconvenient here, so we implement a
selection() function that either
returns the current selection or, if there isn’t one, the current cell.
void Spreadsheet::paste()
{    QTableSelection sel = selection();    QString str = QApplication::clipboard()->text();    QStringList rows = QStringList::split("\n", str, true);    int numRows = rows.size();    int numCols = rows.first().contains("\t") + 1;
    if (sel.numRows() * sel.numCols() != 1
        && (sel.numRows() != numRows            || sel.numCols() != numCols)) {        QMessageBox::information(this, tr("Spreadsheet"),                tr("The information cannot be pasted because the "
82 4. Implementing Application Functionality
                   "copy and paste areas aren’t the same size."));
        return;    }
    for (int i = 0; i < numRows; ++i) {
        QStringList cols = QStringList::split("\t", rows[i], true);        for (int j = 0; j < numCols; ++j) {            int row = sel.topRow() + i;            int col = sel.leftCol() + j;            if (row < NumRows && col < NumCols)                setFormula(row, col, cols[j]);        }    }    somethingChanged();}
Thepaste() slot corresponds to Edit|Paste .Wefetch the text on the clipboard
and call the static function QStringList::split() to break the string into a
QStringList .Each row becomes one string in the QStringList .
Next, we determine the dimension of the copy area. The number of rows is the
number of strings in the QStringList ;the number of columns is the number of
tab characters in the ﬁrst row, plus 1.
If only one cell is selected, we use that cell as the top-left corner of the paste
area. Otherwise, we use the current selection as the paste area.
Toperform the paste, we iterate over the rows and split each of them into cells
by using QStringList::split() again, but this time using tab as the separator.
Figure 4.8 illustrates the steps.
"Red \tGreen \tBlue \nCyan \tMagenta \tYellow"
±
["Red \tGreen \tBlue", "Cyan \tMagenta \tYellow" ]
±
["Red", "Green", "Blue" ]
["Cyan", "Magenta", "Y ellow" ]±
Figure 4.8. Pasting clipboard text into the spreadsheet
void Spreadsheet::del()
{    QTableSelection sel = selection();    for (int i = 0; i < sel.numRows(); ++i) {        for (int j = 0; j < sel.numCols(); ++j)            delete cell(sel.topRow() + i, sel.leftCol() + j);
Implementing the Edit Menu 83
    }
    clearSelection();}
Thedel() slot corresponds to Edit|Delete .Itissufﬁcient to use delete on each
of theCell objects in the selection to clear the cells. The QTable notices when
itsQTableItem sare deleted and automatically repaints itself. If we call cell()
with the location of a deleted cell, it will return a null pointer.
void Spreadsheet::selectRow()
{    clearSelection();    QTable::selectRow(currentRow());}
void Spreadsheet::selectColumn()
{    clearSelection();    QTable::selectColumn(currentColumn());}
void Spreadsheet::selectAll()
{    clearSelection();    selectCells(0, 0, NumRows - 1, NumCols - 1);}
TheselectRow() ,selectColumn() ,andselectAll() functions correspond to the
Edit|Select|Row ,Edit|Select|Column ,and Edit|Select|All menu options. The imple-
mentation relies on QTable ’sselectRow() ,selectColumn() ,andselectCells()
functions.
void Spreadsheet::findNext(const QString &str, bool caseSensitive)
{    int row = currentRow();    int col = currentColumn() + 1;
    while (row < NumRows) {
        while (col < NumCols) {            if (text(row, col).contains(str, caseSensitive)) {                clearSelection();                setCurrentCell(row, col);                setActiveWindow();                return;            }            ++col;        }        col = 0;        ++row;    }    qApp->beep();}
ThefindNext() slot iterates through the cells starting from the cell to the right
of the cursor and moving right until the last column is reached,then continuesfrom the ﬁrst column in the row below, and so on until the text is found or
84 4. Implementing Application Functionality
until the very last cell is reached. For example, if the current cell is cell C27,
we search D27, E27, …, Z27, then A28, B28, C28, …, Z28, and so on until Z999.If we ﬁnd a match, we clear the current selection, we move the cell cursor tothe cell that matched, and we make the window that contains the
Spreadsheet
active. If no match is found, we make the application beep to indicate that thesearch ﬁnished unsuccessfully.
void Spreadsheet::findPrev(const QString &str, bool caseSensitive)
{    int row = currentRow();    int col = currentColumn() - 1;
    while (row >= 0) {
        while (col >= 0) {            if (text(row, col).contains(str, caseSensitive)) {                clearSelection();                setCurrentCell(row, col);                setActiveWindow();                return;            }            --col;        }        col = NumCols - 1;        --row;    }    qApp->beep();}
ThefindPrev() slot is similar to findNext() ,except that it iterates backward
and stops at cell A1.
Implementing the Other Menus
Wewill now implement the slots for the Toolsand Options menus.
Figure 4.9. The Spreadsheet application’s Toolsand Options menus
void Spreadsheet::recalculate()
{    int row;
    for (row = 0; row < NumRows; ++row) {
        for (int col = 0; col < NumCols; ++col) {            if (cell(row, col))                cell(row, col)->setDirty();        }    }    for (row = 0; row < NumRows; ++row) {
Implementing the Other Menus 85
        for (int col = 0; col < NumCols; ++col) {
            if (cell(row, col))                updateCell(row, col);        }    }}
Therecalculate() slot corresponds to Tools|Recalculate .Itisalso called auto-
matically by Spreadsheet when necessary.
Weiterate over all the cells and call setDirty() on every cell to mark each
one as requiring recalculation. The next time QTable callstext() on aCell to
obtain the value to show in the spreadsheet, the value will be recalculated.
Then we call updateCell() on all the cells to repaint the whole spreadsheet.
The repaint code in QTable then calls text() on each visible cell to obtain
the value to display. Because we called setDirty() on every cell, the calls to
text() will use a freshly calculated value. The calculation is performed by the
Cell class.
void Spreadsheet::setAutoRecalculate(bool on)
{    autoRecalc = on;    if (autoRecalc)        recalculate();}
ThesetAutoRecalculate() slot corresponds to Options|Auto-recalculate .I fthe fea-
ture is turned on, we recalculate the whole spreadsheet immediately to makesure that it’s up to date. Afterward,
recalculate() is called automatically from
somethingChanged() .
Wedon’t need to implement anything for Options|Show Grid because QTable
already provides a setShowGrid(bool) slot. All that remains is Spreadsheet::
sort() ,which we called from MainWindow::sort() :
void Spreadsheet::sort(const SpreadsheetCompare &compare)
{    vector<QStringList> rows;    QTableSelection sel = selection();    int i;
    for (i = 0; i < sel.numRows(); ++i) {
        QStringList row;        for (int j = 0; j < sel.numCols(); ++j)            row.push_back(formula(sel.topRow() + i,                                  sel.leftCol() + j));        rows.push_back(row);    }
    stable_sort(rows.begin(), rows.end(), compare);    for (i = 0; i < sel.numRows(); ++i) {
        for (int j = 0; j < sel.numCols(); ++j)            setFormula(sel.topRow() + i, sel.leftCol() + j,                       rows[i][j]);
86 4. Implementing Application Functionality
    }
    clearSelection();
    somethingChanged();}
Sorting operates on the current selection and reorders the rows according to
the sort keys and sort orders stored in the compare object. We represent each
row of data with a QStringList and store the selection as a vector of rows.
Thevector<T> class is a standard C ++class; it is explained in Chapter 11
(Container Classes). For simplicity, we sort by formula rather than by value.
±index value
0 ["Edsger", "Dijkstra", "1930-05-11" ]
1 ["Tony", "Hoare", "1934-01-11" ]
2 ["Niklaus", "Wirth", "1934-02-15" ]
3 ["Donald", "Knuth", "1938-01-10" ]
Figure 4.10. Storing the selection as a vector of rows
Wecall the standard C ++stable_sort() function on the rows to perform the
actual sorting. The stable_sort() function accepts a begin iterator, an end
iterator, and a comparison function. The comparison function is a functionthat takes two arguments (two
QStringList s) and that returns true if the ﬁrst
argument is “less than” the second argument, false otherwise. The compare
object we pass as the comparison function isn’t really a function, but it can beused as one, as we will see shortly.
index value
0 ["Donald", "Knuth", "1938-01-10" ]
1 ["Edsger", "Dijkstra", "1930-05-11" ]
2 ["Niklaus", "Wirth", "1934-02-15" ]
3 ["Tony", "Hoare", "1934-01-11" ]±
Figure 4.11. Putting the data back into the table after sorting
After performing the stable_sort() ,wemove the data back into the table,
clear the selection, and call somethingChanged() .
Inspreadsheet.h ,theSpreadsheetCompare class was deﬁned like this:
class SpreadsheetCompare
{public:    bool operator()(const QStringList &row1,                    const QStringList &row2) const;
    enum { NumKeys = 3 };
    int keys[NumKeys];
Implementing the Other Menus 87
    bool ascending[NumKeys];
};
TheSpreadsheetCompare class is special because it implements a ()operator.
This allows us to use the class as if it were a function. Such classes are calledfunctors .Tounderstand how functors work, we will start with a simple ex-
ample:
class Square
{public:    int operator()(int x) const { return x * x; }};
TheSquare class provides one function, operator()(int) ,that returns the
square of its parameter. By naming the function operator()(int) rather than,
say,compute(int) ,wegain the capability of using an object of type Square as if
it were a function:
Square square;
int y = square(5);
Now let’s see an example involving SpreadsheetCompare :
QStringList row1, row2;SpreadsheetCompare compare;
···
if (compare(row1, row2)) {
    // row1 is less than row2}
Thecompare object can be used just as if it had been a plain compare() function.
Additionally, it can access all the sort keys and sort orders, which it stores asmember variables.
An alternative to this scheme would have been to store the sort keys and
sort orders in global variables and use a plain
compare() function. However,
communicating through global variables is inelegant and can lead to subtlebugs. Functors are a more powerful idiom for interfacing with templatefunctions such as
stable_sort() .
Here is the implementation of the function that is used to compare two
spreadsheet rows:
bool SpreadsheetCompare::operator()(const QStringList &row1,
                                    const QStringList &row2) const{    for (int i = 0; i < NumKeys; ++i) {        int column = keys[i];        if (column != -1) {            if (row1[column] != row2[column]) {                if (ascending[i])                    return row1[column] < row2[column];                else                    return row1[column] > row2[column];            }
88 4. Implementing Application Functionality
        }
    }    return false;}
It returns true if the ﬁrst row is less than the second row; otherwise, it returns
false .The standard stable_sort() function uses the result of this function to
perform the sort.
TheSpreadsheetCompare object’skeys andascending arrays are populated in the
MainWindow::sort() function (shown in Chapter 2). Each key holds a column
index, or +--1(“None”).
Wecompare the corresponding cell entries in the two rows for each key in
order. As soon as we ﬁnd a difference, we return an appropriate true orfalse
value. If all the comparisonsturn out to be equal, we return false .Thestable_
sort() function uses the order before the sort to resolve tie situations; if row1
preceded row2 originally and neither compares as “less than” the other, row1
will still precede row2 in the result. This is what distinguishes std::stable_
sort() from its more famous (but less stable) cousin std::sort() .
Wehave now completed the Spreadsheet class. In the next section, we will
review the Cell class. This class is used to hold cell formulas and provides a
reimplementation of the text() function that Spreadsheet calls to display the
result of calculating a cell’s formula.
Subclassing QTableItem
TheCell class inherits from QTableItem .The class is designed to work well
withSpreadsheet ,but it has no speciﬁc dependencies on that class and could
in theory be used in any QTable .
Here’s the header ﬁle:
#ifndef CELL_H
#define CELL_H
#include <qtable.h>
#include <qvariant.h>
class Cell : public QTableItem
{public:    Cell(QTable *table, const QString &formula);
    void setFormula(const QString &formula);
    QString formula() const;    void setDirty();    QString text() const;    int alignment() const;
private:
    QVariant value() const;
Subclassing QTableItem 89
    QVariant evalExpression(const QString &str, int &pos) const;
    QVariant evalTerm(const QString &str, int &pos) const;    QVariant evalFactor(const QString &str, int &pos) const;
    QString formulaStr;
    mutable QVariant cachedValue;    mutable bool cacheIsDirty;};
#endif
TheCell class extends QTableItem by adding three private variables:
•formulaStr stores the cell’s formula as a QString .
•cachedValue caches the cell’s value as a QVariant .
•cacheIsDirty istrue if the cached value isn’t up to date.
TheQVariant type can hold values of many C ++and Qt types. We use it
because some cells have a double value, while others have a QString value.
ThecachedValue andcacheIsDirty variables are declared with the C ++mutable
keyword. This allows us to modify these variables in const functions. Alterna-
tively, we could recalculate the value each time text() is called, but that would
be needlessly inefﬁcient.
Notice that there is no Q_OBJECT macro in the class deﬁnition. Cell is a plain
C++class, with no signals or slots. In fact, because QTableItem doesn’t inherit
fromQObject ,wecannot have signals and slots in Cell as it stands. Qt’s
item classes don’t inherit from QObject to keep their overhead to the barest
minimum. If signals and slots are needed, they can be implemented in thewidget that contains the items or, exceptionally, using multiple inheritancewith
QObject .
Here’s the start of cell.cpp :
#include <qlineedit.h>
#include <qregexp.h>
#include "cell.h"Cell::Cell(QTable *table, const QString &formula)
    : QTableItem(table, OnTyping){    setFormula(formula);}
The constructor accepts a pointer to a QTable and a formula. The pointer is
passed on to the QTableItem constructor and is accessible afterward as QTable-
Item::table() .The second argument to the base class constructor, OnTyping ,
means that an editor pops up when the user starts typing in the current cell.
void Cell::setFormula(const QString &formula)
{    formulaStr = formula;
90 4. Implementing Application Functionality
    cacheIsDirty = true;
}
ThesetFormula() function sets the cell’s formula. It also sets the cacheIsDirty
ﬂag totrue,meaning that cachedValue must be recalculated before a valid val-
ue can be returned. It is called from the Cell constructor and from Spread-
sheet::setFormula() .
QString Cell::formula() const
{    return formulaStr;}
Theformula() function is called from Spreadsheet::formula() .
void Cell::setDirty(){    cacheIsDirty = true;}
ThesetDirty() function is called to force a recalculation of the cell’s value. It
simply sets cacheIsDirty totrue.The recalculation isn’t performed until it is
really necessary.
QString Cell::text() const
{    if (value().isValid())        return value().toString();    else        return "####";}
Thetext() function is reimplemented from QTableItem .Itreturns the text that
should be shown in the spreadsheet. It relies on value() to compute the cell’s
value. If the value is invalid (presumably because the formula is wrong), wereturn “####”.
The
value() function used by text() returns a QVariant .AQVariant can store
values of different types, such as double andQString ,and provides functions to
convert the variant to other types. For example, calling toString() on a vari-
ant that holds a double value produces a string representation of the double .A
QVariant constructed using the default constructor is an “invalid” variant.
int Cell::alignment() const
{    if (value().type() == QVariant::String)        return AlignLeft | AlignVCenter;    else        return AlignRight | AlignVCenter;}
Thealignment() function is reimplemented from QTableItem .Itreturns the
alignment for the cell’s text. We have chosen to left-align string values and toright-align numeric values. We vertically center all values.
Subclassing QTableItem 91
const QVariant Invalid;
QVariant Cell::value() const
{    if (cacheIsDirty) {        cacheIsDirty = false;
        if (formulaStr.startsWith("’")) {
            cachedValue = formulaStr.mid(1);        } else if (formulaStr.startsWith("=")) {            cachedValue = Invalid;            QString expr = formulaStr.mid(1);            expr.replace(" ", "");            int pos = 0;            cachedValue = evalExpression(expr, pos);            if (pos < (int)expr.length())                cachedValue = Invalid;        } else {            bool ok;            double d = formulaStr.toDouble(&ok);            if (ok)                cachedValue = d;            else                cachedValue = formulaStr;        }    }    return cachedValue;}
Thevalue() private function returns the cell’s value. If cacheIsDirty istrue,
we need to recalculate the value.
If the formula starts with a single quote (for example, “ ’12345”), the value is
the string from position 1 to the end. (The single quote occupies position 0.)
If the formula starts with ‘=’, we take the string from position 1 and delete any
spaces it may contain. Then we call evalExpression() to compute the value
of the expression. The posargument is passed by reference; it indicates the
position of the character where parsing should begin. After the call to eval-
Expression() ,posis equal to the length of the expression that was successfully
parsed. If the parse failed before the end, we set cachedValue to beInvalid .
If the formula doesn’t begin with a single quote or an equals sign (‘=’), we
attempt to convert it to a ﬂoating point value using toDouble() .I fthe con-
version works, we set cachedValue to be the resulting number; otherwise, we
setcachedValue to be the formula string. For example, a formula of “1.50”
causestoDouble() to setoktotrue and return 1.5, while a formula of “World
Population” causes toDouble() to setoktofalse and return 0.0.
Thevalue() function is a const function. We had to declare cachedValue and
cacheIsValid as mutable variables so that the compiler will allow us to modify
them in const functions. It might be tempting to make value() non-const
and remove the mutable keywords, but that would not compile because we call
value() fromtext() ,aconst function. In C ++,caching and mutable usually go
hand in hand.
92 4. Implementing Application Functionality
Wehave now completed the Spreadsheet application, apart from parsing for-
mulas. The rest of this section covers evalExpression() and the two helper
functions evalTerm() andevalFactor() .The code is a bit complicated, but it is
included here to make the application complete. Since the code is not relatedto GUI programming, you can safely skip it and continue reading from Chap-ter 5.
The
evalExpression() function returns the value of a spreadsheet expression.
An expression is deﬁned as one or more terms separated by ‘+’ or ‘ +--’operators;
for example, “2 ∗C5+D6” is an expression with “2 ∗C5” as its ﬁrst term and “D6”
as its second term. The terms themselves are deﬁned as one or more factorsseparated by ‘ ∗’or‘/’operators;for example, “2 ∗C5” is a term with “2” as its ﬁrst
factor and “C5” as its second factor. Finally, a factor can be a number (“2”), acell location (“C5”), or an expression in parentheses, optionally preceded by aunary minus. By breaking down expressions into terms and terms into fac-tors, we ensure that the operators are applied with the correct precedence.
Expression Term Factor
Term Factor Number
+ ∗ +-- Cell location
+-- / ( Expression )
Figure 4.12. Syntax diagram for spreadsheet expressions
The syntax of spreadsheet expressions is deﬁned in Figure 4.12.For each sym-
bol in the grammar ( Expression ,Term,andFactor ), there is a corresponding
Cell member function that parses it and whose structure closely follows the
grammar. Parsers written this way are called recursive-descent parsers.
Let’s start with evalExpression() ,the function that parses an Expression :
QVariant Cell::evalExpression(const QString &str, int &pos) const
{    QVariant result = evalTerm(str, pos);    while (pos < (int)str.length()) {        QChar op = str[pos];        if (op != ’+’ && op != ’-’)            return result;        ++pos;
        QVariant term = evalTerm(str, pos);
        if (result.type() == QVariant::Double                && term.type() == QVariant::Double) {            if (op == ’+’)                result = result.toDouble() + term.toDouble();            else                result = result.toDouble() - term.toDouble();        } else {            result = Invalid;
Subclassing QTableItem 93
        }
    }    return result;}
First,we call evalTerm() to get the value of the ﬁrst term. If the following char-
acter is ‘+’ or ‘ +--’, we continue by calling evalTerm() asecond time; otherwise,
the expression consists of a single term, and we return its value as the valueof the whole expression. After we have the value of the ﬁrst two terms, wecompute the result of the operation, depending on the operator. If both termsevaluated to a
double ,wecompute the result as a double ;otherwise, we set the
result to be Invalid .
Wecontinue like this until there are no more terms. This works correctly
because addition and subtraction are left-associative; that is, “1 +--2+--3” means
“(1+--2)+--3”, not “1 +--(2+--3)”.
QVariant Cell::evalTerm(const QString &str, int &pos) const
{    QVariant result = evalFactor(str, pos);    while (pos < (int)str.length()) {        QChar op = str[pos];        if (op != ’*’ && op != ’/’)            return result;        ++pos;
        QVariant factor = evalFactor(str, pos);
        if (result.type() == QVariant::Double                && factor.type() == QVariant::Double) {            if (op == ’*’) {                result = result.toDouble() * factor.toDouble();            } else {                if (factor.toDouble() == 0.0)                    result = Invalid;                else                    result = result.toDouble() / factor.toDouble();            }        } else {            result = Invalid;        }    }    return result;}
TheevalTerm() function is very similar to evalExpression() ,except that it
deals with multiplication and division. The only subtlety in evalTerm() is
that we must avoid division by zero. While it is generally inadvisable to testﬂoating point values for equality because of rounding errors, it is safe to do soto prevent division by zero.
QVariant Cell::evalFactor(const QString &str, int &pos) const
{    QVariant result;    bool negative = false;
94 4. Implementing Application Functionality
    if (str[pos] == ’-’) {
        negative = true;        ++pos;    }
    if (str[pos] == ’(’) {
        ++pos;        result = evalExpression(str, pos);        if (str[pos] != ’)’)            result = Invalid;        ++pos;    } else {        QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");        QString token;
        while (str[pos].isLetterOrNumber() || str[pos] == ’.’) {
            token += str[pos];            ++pos;        }
        if (regExp.exactMatch(token)) {
            int col = token[0].upper().unicode() - ’A’;            int row = token.mid(1).toInt() - 1;
            Cell *c = (Cell *)table()->item(row, col);
            if (c)                result = c->value();            else                result = 0.0;        } else {            bool ok;            result = token.toDouble(&ok);            if (!ok)                result = Invalid;        }    }
    if (negative) {
        if (result.type() == QVariant::Double)            result = -result.toDouble();        else            result = Invalid;    }    return result;}
TheevalFactor() function is a bit more complicated than evalExpression()
andevalTerm() .Westart by noting whether the factor is negated. We then see
if it begins with an open parenthesis. If it does, we evaluate the contents ofthe parentheses as an expression by calling
evalExpression() .This is where
recursion occurs in the parser; evalExpression() callsevalTerm() ,which calls
evalFactor() ,which calls evalExpression() again.
If the factor isn’t a nested expression, we extract the next token, which may
be a cell location or a number. If the token matches the QRegExp ,wetake it to
be a cell reference and we call value() on the cell at the given location. The
Subclassing QTableItem 95
cell could be anywhere in the spreadsheet, and it could have dependencies
on other cells. The dependencies are not a problem; they will simply triggermore
value() calls and (for “dirty” cells) more parsing until all the dependent
cell values are calculated. If the token isn’t a cell location, we take it to beanumber.
What happens if cell A1 contains the formula “=A1”? Or if cell A1 contains
“=A2” and cell A2 contains “=A1”? Although we have not written any specialcode to detect circular dependencies, the parser handles these cases gracefullyby returning an invalid
QVariant .This works because we set cacheIsDirty to
false andcachedValue toInvalid invalue() before we call evalExpression() .I f
evalExpression() recursively calls value() on the same cell, it returns Invalid
immediately, and the whole expression then evaluates to Invalid .
Wehave now completed the formula parser. It would be straightforward to
extend it to handle predeﬁned spreadsheet functions, like “sum()” and “avg()”,by extending the grammatical deﬁnition of Factor .Another easy extension
is to implement the ‘+’ operator with string operands (as concatenation); thisrequires no changes to the grammar.

55
Creating Custom Widgets•Customizing Qt Widgets
•Subclassing QWidget
•Integrating Custom Widgets
with Qt Designer
•Double Buffering
This chapter explains how to create custom widgets using Qt. Custom widgets
can be created by subclassing an existing Qt widget or by subclassing QWidget
directly. We will demonstrate both approaches, and we will also see how tointegrate a custom widget with Qt Designer so that it can be used just like a
built-in Qt widget. We will round off the chapter by presenting a custom wid-get that uses a powerful technique for eliminating ﬂicker: double buffering.
Customizing Qt Widgets
In some cases, we ﬁnd that a Qt widget requires more customization than ispossible by setting its properties in Qt Designer or by calling its functions. A
simple and direct solution is to subclass the relevant widget class and adaptit to suit our needs.
Figure 5.1. TheHexSpinBox widget
In this section, we will develop a hexadecimal spin box to show how this works.
QSpinBox only supports decimal integers, but by subclassing it’s quite easy to
make it accept and display hexadecimal values.
#ifndef HEXSPINBOX_H
#define HEXSPINBOX_H
#include <qspinbox.h>class HexSpinBox : public QSpinBox
{
97
98 5. Creating Custom Widgets
public:
    HexSpinBox(QWidget *parent, const char *name = 0);
protected:
    QString mapValueToText(int value);    int mapTextToValue(bool *ok);};
#endif
TheHexSpinBox inherits most of its functionality from QSpinBox .Itprovides
atypical constructor and reimplements two virtual functions from QSpinBox .
Since the class doesn’t deﬁne its own signals and slots, it doesn’t need the Q_
OBJECT macro.
#include <qvalidator.h>
#include "hexspinbox.h"HexSpinBox::HexSpinBox(QWidget *parent, const char *name)
    : QSpinBox(parent, name){    QRegExp regExp("[0-9A-Fa-f]+");    setValidator(new QRegExpValidator(regExp, this));    setRange(0, 255);}
The user can modify a spin box’s current value either by clicking its up and
down arrows or by typing a value into the spin box’s line editor. In the lattercase, we want to restrict the user’s input to legitimate hexadecimal numbers.Toachieve this, we use a
QRegExpValidator that accepts one or more characters
from the ranges ‘0’ to ‘9’, ‘A’ to ‘F’, and ‘a’ to ‘f’. We also set the default range tobe 0 to 255 (0x00 to 0xFF), which is more appropriate for a hexadecimal spinbox than
QSpinBox ’sdefault of 0 to 99.
QString HexSpinBox::mapValueToText(int value)
{    return QString::number(value, 16).upper();}
ThemapValueToText() function converts an integer value to a string. QSpinBox
calls it to update the editor part of the spin box when the user presses the spin
box’s up or down arrows. We use the static function QString::number() with
asecond argument of 16 to convert the value to lower-case hexadecimal, and
callQString::upper() on the result to make it upper-case.
int HexSpinBox::mapTextToValue(bool *ok)
{    return text().toInt(ok, 16);}
ThemapTextToValue() function performs the reverse conversion, from a string
to an integer value. It is called by QSpinBox when the user types a value into
the editor part of the spin box and presses Enter .W e use theQString::toInt()
Customizing Qt Widgets 99
function to attempt to convert the current text (returned by QSpinBox::text() )
to an integer value, again using base 16.
If the conversion is successful, toInt() sets*oktotrue;otherwise, it sets it to
false .This behavior happens to be exactly what QSpinBox expects.
Wehave now ﬁnished the hexadecimal spin box. Customizing other Qt wid-
gets follows the same pattern: Pick a suitable Qt widget, subclass it, and reim-plement some virtual functions to change its behavior. This technique is com-mon in Qt programming; in fact, we have already used it in Chapter 4 whenwe subclassed
QTable and reimplemented createEditor() andendEdit() .
Subclassing QWidget
Most custom widgets are simply a combination of existing widgets, whetherthey are built-in Qt widgets or other custom widgets such as
HexSpinBox .
Custom widgets that are built by composing existing widgets can usually bedeveloped in Qt Designer :
•Create a new form using the “Widget” template.
•Add the necessary widgets to the form, then lay them out.
•Set up the signals and slots connections and add any necessary code
(either in a
.ui.h ﬁle or in a subclass) to provide the desired behavior.
Naturally,this can also be done entirely in code. Whichever approach is taken,
the resulting class inherits directly from QWidget .
If the widget has no signals and slots of its own and doesn’t reimplement
any virtual functions, it is even possible to simply assemble the widget byaggregating existing widgets without a subclass. That’s the approach weused in Chapter 1 to create the Age application, with a
QHBox ,aQSpinBox ,and
aQSlider .Even so, we could just as easily have subclassed QHBox and created
theQSpinBox andQSlider in the subclass’s constructor.
When none of Qt’s widgets are suitable for the task at hand, and when there’s
no way to combine or adapt existing widgets to obtain the desired result, wecan still create the widget we want. This is achieved by subclassing
QWidget
and reimplementing a few event handlers to paint the widget and to respondto mouse clicks. This approach gives us complete freedom to deﬁne and controlboth the appearance and the behavior of our widget. Qt’s built-in widgets,like
QLabel ,QPushButton ,andQTable ,are implemented this way. If they didn’t
exist in Qt, it would still be possible to create them ourselves using the publicfunctions provided by
QWidget in a totally platform-independent manner.
Todemonstrate how to write a custom widget using this approach, we will
create the IconEditor widget shown in Figure 5.2. The IconEditor is a widget
that could be used in an icon editing program.
Let’s begin by reviewing the header ﬁle.
100 5. Creating Custom Widgets
#ifndef ICONEDITOR_H
#define ICONEDITOR_H
#include <qimage.h>
#include <qwidget.h>
class IconEditor : public QWidget
{    Q_OBJECT    Q_PROPERTY(QColor penColor READ penColor WRITE setPenColor)    Q_PROPERTY(QImage iconImage READ iconImage WRITE setIconImage)    Q_PROPERTY(int zoomFactor READ zoomFactor WRITE setZoomFactor)
public:
    IconEditor(QWidget *parent = 0, const char *name = 0);
    void setPenColor(const QColor &newColor);
    QColor penColor() const { return curColor; }    void setZoomFactor(int newZoom);    int zoomFactor() const { return zoom; }    void setIconImage(const QImage &newImage);    const QImage &iconImage() const { return image; }    QSize sizeHint() const;
TheIconEditor class uses the Q_PROPERTY() macro to declare three custom prop-
erties:penColor ,iconImage ,andzoomFactor .Each property has a type, a “read”
function, and a “write” function. For example, the penColor property is of type
QColor and can be read and written using the penColor() andsetPenColor()
functions.
Figure 5.2. TheIconEditor widget
When we make use of the widget in Qt Designer ,custom properties appear
inQt Designer ’sproperty editor below the properties inherited from QWidget .
Properties may be of any type supported by QVariant .TheQ_OBJECT macro is
necessary for classes that deﬁne properties.
protected:
    void mousePressEvent(QMouseEvent *event);    void mouseMoveEvent(QMouseEvent *event);    void paintEvent(QPaintEvent *event);
Subclassing QWidget 101
private:
    void drawImagePixel(QPainter *painter, int i, int j);    void setImagePixel(const QPoint &pos, bool opaque);
    QColor curColor;
    QImage image;    int zoom;};
#endif
IconEditor
reimplements three protected functions from QWidget and has a few
private functions and variables. The three private variables hold the valuesof the three properties.
The implementation ﬁle begins with
#include directives and the IconEditor ’s
constructor:
#include <qpainter.h>
#include "iconeditor.h"IconEditor::IconEditor(QWidget *parent, const char *name)
    : QWidget(parent, name, WStaticContents){    setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Minimum);    curColor = black;    zoom = 8;    image.create(16, 16, 32);    image.fill(qRgba(0, 0, 0, 0));    image.setAlphaBuffer(true);}
The constructor has some subtle aspects such as the setSizePolicy() call and
theWStaticContents ﬂag. We will discuss them shortly.
The zoom factor is set to 8, meaning that each pixel in the icon will be rendered
as an 8 × 8 square. The pen color is set to black; the black symbol is a prede-
ﬁned value in the Qtclass (QObject ’sbase class).
The icon data is stored in the image member variable and can be accessed
through the setIconImage() andiconImage() functions. An icon editor program
would typically call setIconImage() when the user opens an icon ﬁle and icon-
Image() to retrieve the icon when the user wants to save it.
Theimage variable is of type QImage .Weinitialize it to 16 × 16 pixels and 32-bit
depth, clear the image data, and enable the alpha buffer.
TheQImage class stores an image in a hardware-independent fashion. It can be
set to use a 1-bit, 8-bit, or 32-bit depth. An image with 32-bit depth uses 8 bitsfor each of the red, green, and blue components of a pixel. The remaining8bits store the pixel’s alpha component—that is, its opacity. For example, a
pure red color’s red, green, blue, and alpha components have the values 255, 0,0, and 255. In Qt, this color can be speciﬁed as
QRgb red = qRgba(255, 0, 0, 255);
102 5. Creating Custom Widgets
or as
QRgb red = qRgb(255, 0, 0);
QRgb is simply a typedef for unsigned int ,andqRgb() andqRgba() are inline
functions that combine their argumentsinto one 32-bit integer value. It is alsopossible to write
QRgb red = 0xFFFF0000;
where the ﬁrst FFcorresponds to the alpha component and the second FFto
the red component. In the IconEditor constructor, we ﬁll the QImage with a
transparent color by using 0 as the alpha component.
Qt provides two types for storing colors: QRgb andQColor .WhileQRgb is only a
typedef used in QImage to store 32-bit pixel data, QColor is a class with many
useful functions and is widely used in Qt to store colors. In the IconEditor
widget, we only use QRgb when dealing with the QImage ;w e useQColor for
everything else, including the penColor property.
QSize IconEditor::sizeHint() const
{    QSize size = zoom * image.size();    if (zoom >= 3)        size += QSize(1, 1);    return size;}
ThesizeHint() function is reimplemented from QWidget and returns the ideal
size of a widget. Here, we take the image size multiplied by the zoom factor,with one extra pixel in each direction to accommodate a grid if the zoom factoris 3 or more. (We don’t show a grid if the zoom factor is 2 or 1, because the gridwould hardly leave any room for the icon’s pixels.)
Awidget’s size hint is mostly useful in conjunction with layouts. Qt’s layout
managers try as much as possible to respect a widget’s size hint when they layout a form’s child widgets. For
IconEditor to be a good layout citizen, it must
report a credible size hint.
In addition to the size hint, widgets have a size policy that tells the layout
system whether they like to be stretched and shrunk. By calling setSizePol-
icy() in the constructor with QSizePolicy::Minimum as horizontal and vertical
policies, we tell any layout manager that is responsible for this widget that thewidget’s size hint is really its minimum size. In other words, the widget canbe stretched if required, but it should never shrink below the size hint. Thiscan be overridden in Qt Designer by setting the widget’s
sizePolicy property.
The meaning of the various size policies is explained in Chapter 6 (LayoutManagement).
void IconEditor::setPenColor(const QColor &newColor)
{    curColor = newColor;}
Subclassing QWidget 103
ThesetPenColor() function sets the current pen color. The color will be used
for newly drawn pixels.
void IconEditor::setIconImage(const QImage &newImage)
{    if (newImage != image) {        image = newImage.convertDepth(32);        image.detach();        update();        updateGeometry();    }}
ThesetIconImage() function sets the image to edit. We call convertDepth()
to make the image 32-bit if it isn’t already. Elsewhere in the code, we will
assume that the image data is stored as 32-bit QRgb values.
Wealso call detach() to take a deep copy of the data stored in the image. This
is necessary because the image data might be stored in ROM. QImage tries
to save time and memory by copying the image data only when explicitlyrequested to do so. This optimization is called explicit sharing and is discussed
with
QMemArray<T> in the “Pointer-Based Containers” section of Chapter 11.
After setting the image variable,we call QWidget::update() to force a repainting
of the widget using the new image. Next, we call QWidget::updateGeometry()
to tell any layout that contains the widget that the widget’s size hint haschanged. The layout will then automatically adapt to the new size hint.
void IconEditor::setZoomFactor(int newZoom)
{    if (newZoom < 1)        newZoom = 1;
    if (newZoom != zoom) {
        zoom = newZoom;        update();        updateGeometry();    }}
ThesetZoomFactor() function sets the zoom factor for the image. To prevent
division by zero later, we correct any value below 1. Again, we call update()
andupdateGeometry() to repaint the widget and to notify any managing layout
about the size hint change.
ThepenColor() ,iconImage() ,andzoomFactor() functions are implemented as
inline functions in the header ﬁle.
Wewill now review the code for the paintEvent() function. This function is
IconEditor ’smost important function. It is called whenever the widget needs
repainting. The default implementation in QWidget does nothing, leaving the
widget blank.
104 5. Creating Custom Widgets
Just like contextMenuEvent() andcloseEvent() ,which we met in Chapter 3,
paintEvent() is an event handler. Qt has many other event handlers, each
of which corresponds to a different type of event. Chapter 7 covers eventprocessing in depth.
There are many situations when a paint event is generated and
paintEvent()
is called:
•When a widget is shown for the ﬁrst time, the system automatically
generates a paint event to force the widget to paint itself.
•When a widget is resized, the system automatically generates a paint
event.
•Ifthe widget is obscured by another window and then revealed again, a
paint event is generated for the area that was hidden (unless the windowsystem stored the area).
Wecan also force a paint event by calling
QWidget::update() orQWidget::re-
paint() .The difference between these two functions is that repaint() forces an
immediate repaint, whereas update() simply schedules a paint event for when
Qt next processes events. (Both functions do nothing if the widget isn’t visibleon screen.) If
update() is called multiple times, Qt compresses the consecutive
paint events into a single paint event to avoid ﬂicker. In IconEditor ,w ealways
useupdate() .
Here’s the code:
void IconEditor::paintEvent(QPaintEvent *)
{    QPainter painter(this);
    if (zoom >= 3) {
        painter.setPen(colorGroup().foreground());        for (int i = 0; i <= image.width(); ++i)            painter.drawLine(zoom * i, 0,                             zoom * i, zoom * image.height());        for (int j = 0; j <= image.height(); ++j)            painter.drawLine(0, zoom * j,                             zoom * image.width(), zoom * j);    }
    for (int i = 0; i < image.width(); ++i) {
        for (int j = 0; j < image.height(); ++j)            drawImagePixel(&painter, i, j);    }}
Westart by constructing a QPainter object on the widget. If the zoom factor is
3ormore, we draw the horizontal and vertical lines that form the grid using
theQPainter::drawLine() function.
Acall toQPainter::drawLine() has the following syntax:
painter.drawLine( x1, y1, x2, y2);
Subclassing QWidget 105
where ( x1,y1)isthe position of one end of the line and ( x2,y2)isthe position of
the other end. There is also an overloaded version of the function that takestwo
QPoint sinstead of four ints.
The top-left pixel of a Qt widget is located at position (0, 0), and the bottom-
right pixel is located at ( width() +--1,height() +--1).This is similar to the conven-
tional Cartesian coordinate system, but upside down, and makes a lot of sensein GUI programming. It is perfectly possible to change
QPainter ’scoordinate
system by using transformations, such as translation, scaling, rotation, andshearing. This is covered in Chapter 8 (2D and 3D Graphics).
(0, 0)
(width() +--1, height() +--1)(x1,y1)
(x2,y2)
Figure 5.3. Drawing a line using QPainter
Before we call drawLine() on theQPainter ,weset the line’s color using setPen() .
Wecould hard-code a color, like black or gray, but a better approach is to use
the widget’s palette.
Every widget is equipped with a palette that speciﬁes which colors should be
used for what. For example, there is a palette entry for the background colorof widgets (usually light gray) and one for the color of text on that background(usually black).By default,a widget’s palette adopts the window system’scolorscheme. By using colors from the palette, we ensure that
IconEditor respects
the user’s preferences.
Awidget’s palette consists of three color groups: active, inactive, and disabled.
Which color group should be used depends on the widget’s current state:
•The active color group is used for widgets in the currently active window.
•The inactive color group is used for widgets in the other windows.
•The disabled color group is used for disabled widgets in any window.
TheQWidget::palette() function returns the widget’s palette as a QPalette
object. The color groups are available through QPalette ’sactive() ,inactive() ,
anddisabled() functions, and are of type QColorGroup .For convenience,
QWidget::colorGroup() returns the correct color group for the current state of
the widget, so we rarely need to access the palette directly.
ThepaintEvent() function ﬁnishes by drawing the image itself, using the
IconEditor::drawImagePixel() function to draw each of the icon’s pixels as
ﬁlled squares.
106 5. Creating Custom Widgets
void IconEditor::drawImagePixel(QPainter *painter, int i, int j)
{    QColor color;    QRgb rgb = image.pixel(i, j);
    if (qAlpha(rgb) == 0)
        color = colorGroup().base();    else        color.setRgb(rgb);
    if (zoom >= 3) {
        painter->fillRect(zoom * i + 1, zoom * j + 1,                          zoom - 1, zoom - 1, color);    } else {        painter->fillRect(zoom * i, zoom * j,                          zoom, zoom, color);    }}
ThedrawImagePixel() function draws a zoomed pixel using a QPainter .Thei
andjparameters are pixel coordinates in the QImage —not in the widget. (If
the zoom factor is 1, the two coordinate systems coincide exactly.) If the pixelis transparent (its alpha component is 0), we use the current color group’s“base” color (typically white) to draw the pixel; otherwise, we use the pixel’scolor in the image. Then we call
QPainter::fillRect() to draw a ﬁlled square.
If the grid is shown, the square is reduced by one pixel in both directions toavoid painting over the grid.
(0, 0)
(width() +--1, height() +--1)wh(x, y)
Figure 5.4. Drawing a rectangle using QPainter
The call to QPainter::fillRect() has the following syntax:
painter->fillRect( x, y, w, h, brush);
where ( x,y)isthe position of the top-left corner of the rectangle, w×his the size
of the rectangle, and brush speciﬁes the color to ﬁll with and the ﬁll pattern to
use. By passing a QColor as the brush, we obtain a solid ﬁll pattern.
void IconEditor::mousePressEvent(QMouseEvent *event)
{    if (event->button() == LeftButton)        setImagePixel(event->pos(), true);    else if (event->button() == RightButton)
Subclassing QWidget 107
        setImagePixel(event->pos(), false);
}
When the user presses a mouse button, the system generates a “mouse press”
event. By reimplementing QWidget::mousePressEvent() ,wecan respond to this
event and set or clear the image pixel under the mouse cursor.
If the user pressed the left mouse button, we call the private function setIm-
agePixel() withtrue as the second argument, telling it to set the pixel to the
current pen color. If the user pressed the right mouse button, we also call set-
ImagePixel() ,but pass false to clear the pixel.
void IconEditor::mouseMoveEvent(QMouseEvent *event)
{    if (event->state() & LeftButton)        setImagePixel(event->pos(), true);    else if (event->state() & RightButton)        setImagePixel(event->pos(), false);}
ThemouseMoveEvent() handles “mouse move” events. By default, these events
are only generated when the user is holding down a button. It is possible tochange this behavior by calling
QWidget::setMouseTracking() ,but we don’t
need to do so for this example.
Just as pressing the left or right mouse button sets or clears a pixel, keeping it
pressed and hovering over a pixel is also enough to set or clear a pixel. Sinceit’s possible to hold more than one button pressed down at a time, the valuereturned by
QMouseEvent::state() is a bitwise OR of the mouse buttons (and
of modiﬁer keys like Shiftand Ctrl). We test whether a certain button is pressed
down using the &operator, and if it is, we call setImagePixel() .
void IconEditor::setImagePixel(const QPoint &pos, bool opaque)
{    int i = pos.x() / zoom;    int j = pos.y() / zoom;
    if (image.rect().contains(i, j)) {
        if (opaque)            image.setPixel(i, j, penColor().rgb());        else            image.setPixel(i, j, qRgba(0, 0, 0, 0));
        QPainter painter(this);
        drawImagePixel(&painter, i, j);    }}
ThesetImagePixel() function is called from mousePressEvent() andmouseMove-
Event() to set or clear a pixel. The posparameter is the position of the mouse
on the widget.
The ﬁrst step is to convert the mouse position from widget coordinates to
image coordinates. This is done by dividing the xand ycomponents of the
mouse position by the zoom factor. Next, we check whether the point is within
108 5. Creating Custom Widgets
the correct range. The check is easily made using QImage::rect() andQRect::
contains() ;this effectively checks that iis between 0 and image.width() +--1
and that jis between 0 and image.height() +--1.
Depending on the opaque parameter, we set or clear the pixel in the image.
Clearing a pixel is really setting it to be transparent. At the end, we call
drawImagePixel() to repaint the individual pixel that changed.
Now that we have reviewed the member functions, we will return to the
WStaticContents ﬂag that we used in the constructor. This ﬂag tells Qt that
the widget’s content doesn’t change when the widget is resized and that thecontent stays rooted to the widget’s top-left corner. Qt uses this informationto avoid needlessly repainting areas that are already shown when resizingthe widget.
Normally, when a widget is resized, Qt generates a paint event for the widget’s
entire visible area. But if the widget is created with the
WStaticContents ﬂag,
the paint event’s region is restricted to the pixels that were not previouslyshown. If the widget is resized to a smaller size, no paint event is generatedat all.
±
 ±
Figure 5.5. Resizing a WStaticContents widget
TheIconEditor widget is now complete. Using the information and examples
from earlier chapters, we could write code that uses the IconEditor as a
window in its own right, as a central widget in a QMainWindow ,asachild widget
inside a layout, or as a child widget inside a QScrollView (p. 145). In the next
section, we will see how to integrate it with Qt Designer .
Integrating Custom Widgets with Qt Designer
Before we can use custom widgets in Qt Designer ,wemust make Qt Designer
aware of them. There are two techniques for doing this: the “simple custom
widget” approach and the plugin approach.
The “simple custom widget” approach consists of ﬁlling in a dialog box in Qt
Designer with some information about the custom widget. The widget can
then be used in forms developed using Qt Designer ,but the widget is only rep-
resented by an icon and a dark gray rectangle while the form is edited or pre-viewed. Here’s how to integrate the
HexSpinBox widget using this approach:
Integrating Custom Widgets with Qt Designer 109
1. Click Tools|Custom|Edit Custom Widget .This will launch Qt Designer ’scus-
tom widget editor.
2. Click New Widget .
3. Change the class name from MyCustomWidget toHexSpinBox and the header
ﬁle from mycustomwidget.h tohexspinbox.h .
4. Change the size hint to (60, 20).
5. Change the size policy to (Minimum, Fixed).
The widget will then be available in the “Custom Widgets” section of Qt
Designer ’stoolbox.
Figure 5.6. Qt Designer ’scustom widget editor
The plugin approach requires the creation of a plugin library that Qt Designer
can load at run-time and use to create instances of the widget. The real widgetis then used by Qt Designer when editing the form and for previewing. We will
integrate the
IconEditor as a plugin to demonstrate how to do it.
First, we must subclass QWidgetPlugin and reimplement some virtual func-
tions. We can do everything in the same source ﬁle. We will assume that theplugin source code is located in a directory called
iconeditorplugin and that
theIconEditor source code is located in a parallel directory called iconeditor .
Here’s the header ﬁle:
#include <qwidgetplugin.h>
#include "../iconeditor/iconeditor.h"class IconEditorPlugin : public QWidgetPlugin
{public:    QStringList keys() const;    QWidget *create(const QString &key, QWidget *parent,                    const char *name);
110 5. Creating Custom Widgets
    QString includeFile(const QString &key) const;
    QString group(const QString &key) const;    QIconSet iconSet(const QString &key) const;    QString toolTip(const QString &key) const;    QString whatsThis(const QString &key) const;    bool isContainer(const QString &key) const;};
TheIconEditorPlugin subclass is a factory class that encapsulates the IconEd-
itor widget. The functions are used by Qt Designer to create instances of the
class and to obtain information about it.
QStringList IconEditorPlugin::keys() const
{    return QStringList() << "IconEditor";}
Thekeys() function returns a list of widgets provided by the plugin. The
example plugin only provides the IconEditor widget.
QWidget *IconEditorPlugin::create(const QString &, QWidget *parent,
                                  const char *name){    return new IconEditor(parent, name);}
Thecreate() function is called by Qt Designer to create an instance of a widget
class. The ﬁrst argument is the widget’s class name. We can ignore it in thisexample, because we only provide one class. All the other functions also takeaclass name as their ﬁrst argument.
QString IconEditorPlugin::includeFile(const QString &) const
{    return "iconeditor.h";}
TheincludeFile() function returns the name of the header ﬁle for the
speciﬁed widget encapsulated by the plugin. The header ﬁle is included in thecode generated by the
uictool.
bool IconEditorPlugin::isContainer(const QString &) const
{    return false;}
TheisContainer() function returns true if the widget can contain other wid-
gets; otherwise, it returns false .For example, QFrame is a widget that can con-
tain other widgets. We return false for theIconEditor ,since it doesn’t make
sense for it to contain other widgets. Strictly speaking, any widget can con-tain other widgets, but Qt Designer disallows this when
isContainer() returns
false .
QString IconEditorPlugin::group(const QString &) const
{    return "Plugin Widgets";}
Integrating Custom Widgets with Qt Designer 111
Thegroup() function returns the name of the toolbox group this custom widget
should belong to. If the name isn’t already in use, Qt Designer automatically
creates a new group for the widget.
QIconSet IconEditorPlugin::iconSet(const QString &) const
{    return QIconSet(QPixmap::fromMimeSource("iconeditor.png"));}
TheiconSet() function returns the icon to use to represent the custom widget
inQt Designer ’stoolbox.
QString IconEditorPlugin::toolTip(const QString &) const
{    return "Icon Editor";}
ThetoolTip() function returns the tooltip to show when the mouse hovers
over the custom widget in Qt Designer ’stoolbox.
QString IconEditorPlugin::whatsThis(const QString &) const
{    return "Widget for creating and editing icons";}
ThewhatsThis() function returns the “What’s This?” text for Qt Designer to
display.
Q_EXPORT_PLUGIN(IconEditorPlugin)
At the end of the source ﬁle that implements the plugin class, we must use the
Q_EXPORT_PLUGIN() macro to make the plugin available to Qt Designer .
The.pro ﬁle for building the plugin looks like this:
TEMPLATE      = lib
CONFIG       += pluginHEADERS       = ../iconeditor/iconeditor.hSOURCES       = iconeditorplugin.cpp \                ../iconeditor/iconeditor.cppIMAGES        = images/iconeditor.pngDESTDIR       = $(QTDIR)/plugins/designer
The.pro ﬁle assumes that the QTDIR environment variable is set to the direc-
tory where Qt is installed. When you type make ornmake to build the plugin, it
will automatically install itself in Qt Designer ’splugins directory.
Once the plugin is built, the IconEditor widget can be used in Qt Designer in
the same way as any of Qt’s built-in widgets.
112 5. Creating Custom Widgets
Double Buffering
Double buffering is a technique that can be used to provide a snappier user
interface and to eliminate ﬂicker. Flicker occurs when the same pixel ispainted multiple times with different colors in a very short period of time. Ifthis occurs for only one pixel, it isn’t a problem, but if it occurs for lots of pixelsat the same time, it can be distracting for the user.
When Qt generates a paint event, it ﬁrst erases the widget using the palette’s
background color. Then, in
paintEvent() ,the widget only needs to paint the
pixels that are not the same color as the background. This two-step approachis very convenient, because it means we can simply paint what we need on thewidget without worrying about the other pixels.
Unfortunately, the two-step approach is also a major source of ﬂicker. For ex-
ample, if the user resizes the widget, the widget is ﬁrst cleared in its entirety,and then the pixels are painted. The ﬂicker is even worse if the window sys-tem shows the contents of the window as it is resized, because then the widgetis repeatedly erased and painted.
± ±
Figure 5.7. Resizing a widget that has no provision against ﬂicker
TheWStaticContents ﬂag used to implement the IconEditor widget is one
solution to this problem, but it can only be used for widgets whose content isindependent of the size of the widget. Such widgets are rare. Most widgetstend to stretch their contents to consume all the available space. They need tobe completely repainted when they are resized. We can still avoid ﬂicker, butthe solution is slightly more complicated.
The ﬁrst rule to avoid ﬂicker is to construct the widget with the
WNoAutoErase
ﬂag. This ﬂag tells Qt notto erase the widget before a paint event. The old
pixels are then left unchanged, and any newly revealed pixels are undeﬁned.
±
 ±
Figure 5.8. Resizing a WNoAutoErase widget
Double Buffering 113
When using WNoAutoErase ,itisimportant that the paint handler sets all the
pixels explicitly. Any pixel that is not set in the paint event will keep itsprevious value, which isn’t necessarily the background color.
The second rule to avoid ﬂicker is to paint every pixel just once. The easi-
est way to implement this requirement is to draw the whole widget in an off-screen pixmap and to copy the pixmap onto the widget in one go. Using thisapproach, it doesn’t matter if some pixels are painted multiple times becausethe painting takes place off-screen. This is double buffering.
Adding double buffering to a custom widget to eliminate ﬂicker is straightfor-
ward. Suppose the original paint event handler looks like this:
void MyWidget::paintEvent(QPaintEvent *)
{    QPainter painter(this);    drawMyStuff(&painter);}
The double-buffered version looks like this:
void MyWidget::paintEvent(QPaintEvent *event){    static QPixmap pixmap;    QRect rect = event->rect();
    QSize newSize = rect.size().expandedTo(pixmap.size());
    pixmap.resize(newSize);    pixmap.fill(this, rect.topLeft());
    QPainter painter(&pixmap, this);
    painter.translate(-rect.x(), -rect.y());    drawMyStuff(&painter);    bitBlt(this, rect.x(), rect.y(), &pixmap, 0, 0,           rect.width(), rect.height());}
First, we resize a QPixmap to be at least as large as the bounding rectangle
of the region to repaint. (A “region” is very often either a rectangle or an L-shaped area, but it can be arbitrarily complex.) We make the
QPixmap astat-
ic variable to avoid repeatedly allocating and deallocating it. For the samereason, we never shrink the
QPixmap ;the calls to QSize::expandedTo() and
QPixmap::resize() ensure that it is always large enough. After resizing, we
ﬁll theQPixmap with the widget’s erase color or background pixmap using
QPixmap::fill() .The second argument to fill() speciﬁes which point in the
widget the QPixmap ’stop-left pixel corresponds to. (This makes a difference if
the widget is to be erased using a pixmap instead of a uniform color.)
TheQPixmap class is similar to both QImage andQWidget .Like aQImage ,itstores
an image, but the color depth and possibly the colormap are aligned withthe display, rather like a hidden
QWidget .Ifthe window system is running
in 8-bit mode, all widgets and pixmaps are restricted to 256 colors, and Qtautomatically maps 24-bit color speciﬁcations onto 8-bit colors. (Qt’s colorallocation strategy is controlled by calling
QApplication::setColorSpec() .)
114 5. Creating Custom Widgets
Next,we create a QPainter to operate on the pixmap. By passing the this point-
er to the constructor, we tell QPainter to adopt some of the widget’s settings,
such as its font. We translate the painter to paint the correct rectangle intothe pixmap, before we perform the drawing using the
QPainter as usual.
Finally, we copy the pixmap to the widget using the bitBlt() global function,
whose name stands for “bit-block transfer”.
Double buffering is not only useful for avoiding ﬂicker. It is beneﬁcial if the
widget’s rendering is complex and needed repeatedly. We can then store apixmap permanently with the widget, always ready for the next paint event,and copy the pixmap to the widget whenever we receive a paint event. It isespecially helpful when we want to do small modiﬁcations, such as draw-ing a rubber band, without recomputing the whole widget’s rendering overand over.
Wewill round off this chapter by reviewing the
Plotter custom widget. This
widget uses double buffering, and also demonstrates some other aspects ofQt programming, including keyboard event handling, manual layout, andcoordinate systems.
The
Plotter widget displays one or more curves speciﬁed as vectors of coor-
dinates. The user can draw a rubber band on the image, and the Plotter will
zoom in on the area enclosed by the rubber band. The user draws the rubberband by clicking a point on the graph, dragging the mouse to another positionwith the left mouse button held down, and releasing the mouse button.
±
Figure 5.9. Zooming in on the Plotter widget
The user can zoom in repeatedly by drawing a rubber band multiple times,
zooming out using the Zoom Out button, and then zooming back in using the
Zoom In button. The Zoom In and Zoom Out buttons appear the ﬁrst time they
become available, so that they don’t clutter the display if the user doesn’tzoom the graph.
The
Plotter widget can hold the data for any number of curves. It also
maintains a stack of PlotSettings ,each of which corresponds to a particular
zoom level.
Double Buffering 115
Let’s review the class, starting with plotter.h :
#ifndef PLOTTER_H
#define PLOTTER_H
#include <qpixmap.h>
#include <qwidget.h>
#include <map>
#include <vector>
class QToolButton;
class PlotSettings;
typedef std::vector<double> CurveData;
Weinclude the standard <map> and<vector> header ﬁles. We don’t import all
thestdnamespace’s symbols into the global namespace, because it’s bad style
to do this in a header ﬁle.
WedeﬁneCurveData as a synonym for std::vector<double> .Wewill store a
curve’s points as successive pairs of xandyvalues in the vector. For example,
the curve deﬁned by the points (0, 24), (1, 44), (2, 89) is represented by thevector [0, 24, 1, 44, 2, 89].
class Plotter : public QWidget
{    Q_OBJECTpublic:    Plotter(QWidget *parent = 0, const char *name = 0,            WFlags flags = 0);
    void setPlotSettings(const PlotSettings &settings);
    void setCurveData(int id, const CurveData &data);    void clearCurve(int id);    QSize minimumSizeHint() const;    QSize sizeHint() const;
public slots:
    void zoomIn();    void zoomOut();
Weprovide three public functions for setting up the plot, and two public
slots for zooming in and out. We also reimplement minimumSizeHint() and
sizeHint() fromQWidget .
protected:
    void paintEvent(QPaintEvent *event);    void resizeEvent(QResizeEvent *event);    void mousePressEvent(QMouseEvent *event);    void mouseMoveEvent(QMouseEvent *event);    void mouseReleaseEvent(QMouseEvent *event);    void keyPressEvent(QKeyEvent *event);    void wheelEvent(QWheelEvent *event);
In the protected section of the class, we declare all the QWidget event handlers
that we need to reimplement.
116 5. Creating Custom Widgets
private:
    void updateRubberBandRegion();    void refreshPixmap();    void drawGrid(QPainter *painter);    void drawCurves(QPainter *painter);
    enum { Margin = 40 };    QToolButton *zoomInButton;
    QToolButton *zoomOutButton;    std::map<int, CurveData> curveMap;    std::vector<PlotSettings> zoomStack;    int curZoom;    bool rubberBandIsShown;    QRect rubberBandRect;    QPixmap pixmap;};
In the private section of the class, we declare a constant, a few functions for
painting the widget, and several member variables. The Margin constant is
used to provide some spacing around the graph.
Among the member variables is pixmap of type QPixmap .This variable holds
acopy of the whole widget’s rendering, identical to what is shown on screen.
The plot is always drawn onto this off-screen pixmap ﬁrst; then the pixmap iscopied onto the widget.
class PlotSettings
{public:    PlotSettings();
    void scroll(int dx, int dy);
    void adjust();    double spanX() const { return maxX - minX; }    double spanY() const { return maxY - minY; }
    double minX;
    double maxX;    int numXTicks;    double minY;    double maxY;    int numYTicks;
private:
    void adjustAxis(double &min, double &max, int &numTicks);};
#endif
ThePlotSettings class speciﬁes the range of the xandyaxes and the number
of ticks for these axes. Figure 5.10 shows the correspondence between a
PlotSettings object and the scales on a Plotter widget.
By convention, numXTicks andnumYTicks are off by one; if numXTicks is 5,Plotter
will actually draw 6 tick marks on the xaxis. This simpliﬁes the calculations
later on.
Double Buffering 117
maxY
minY
minX maxXnumYTicksnumXTicks
Figure 5.10. PlotSettings ’smember variables
Now let’s review the implementation ﬁle:
#include <qpainter.h>
#include <qstyle.h>#include <qtoolbutton.h>
#include <cmath>
using namespace std;
#include "plotter.h"
Weinclude the expected header ﬁles and import all the stdnamespace’s
symbols into the global namespace.
Plotter::Plotter(QWidget *parent, const char *name, WFlags flags)
    : QWidget(parent, name, flags | WNoAutoErase){    setBackgroundMode(PaletteDark);    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);    setFocusPolicy(StrongFocus);    rubberBandIsShown = false;
    zoomInButton = new QToolButton(this);
    zoomInButton->setIconSet(QPixmap::fromMimeSource("zoomin.png"));    zoomInButton->adjustSize();    connect(zoomInButton, SIGNAL(clicked()), this, SLOT(zoomIn()));
    zoomOutButton = new QToolButton(this);
    zoomOutButton->setIconSet(            QPixmap::fromMimeSource("zoomout.png"));    zoomOutButton->adjustSize();    connect(zoomOutButton, SIGNAL(clicked()), this, SLOT(zoomOut()));
    setPlotSettings(PlotSettings());
}
ThePlotter has aflags parameter in addition to parent andname.This param-
eter is simply passed on to the base class constructor, along with WNoAutoErase .
The parameter is especially useful for widgets that are likely to be used asstand-alone windows, because it allows the user of the class to conﬁgure thewindow frame and title bar.
118 5. Creating Custom Widgets
ThesetBackgroundMode() call tells QWidget to use the “dark” component of the
palette as the color for erasing the widget, instead of the “background” com-ponent. Although we pass the
WNoAutoErase ﬂag to the base class constructor,
Qt still needs a default color that it may use to ﬁll any newly revealed pixelswhen the widget is resized to a larger size, before
paintEvent() even has the
chance to paint the new pixels. Since the background of the Plotter widget
will be dark, it makes sense to paint these pixels dark.
ThesetSizePolicy() call sets the widget’s size policy to QSizePolicy::Expanding
in both directions. This tells any layout manager that is responsible for the
widget that the widget is especially willing to grow, but can also shrink. Thissetting is typical for widgets that can take up a lot of screen space. The defaultis
QSizePolicy::Preferred in both directions, which means that the widget
prefers to be the size of its size hint, but it can be shrunk down to its minimumsize hint or expanded indeﬁnitely if necessary.
The
setFocusPolicy() call makes the widget accept focus by clicking or by
pressing Tab.When the Plotter has focus, it will receive events for key presses.
ThePlotter widget understands a few keys: +to zoom in, +--to zoom out, and
the arrow keys to scroll up, down, left, and right.
±
Figure 5.11. Scrolling the Plotter widget
Still in the constructor, we create two QToolButton s,each with an icon. These
buttons allow the user to navigate through the zoom stack. The button’s iconsare stored in an image collection. Any application that uses the
Plotter widget
will need this entry in its .pro ﬁle:
IMAGES       += images/zoomin.png \
                images/zoomout.png
The calls to adjustSize() on the buttons sets their sizes to be that of their
size hints.
The call to setPlotSettings() at the end does the rest of the initialization.
void Plotter::setPlotSettings(const PlotSettings &settings)
{    zoomStack.resize(1);    zoomStack[0] = settings;
Double Buffering 119
    curZoom = 0;
    zoomInButton->hide();    zoomOutButton->hide();    refreshPixmap();}
ThesetPlotSettings() function is used to specify the PlotSettings to use for
displaying the plot. It is called by the Plotter constructor,and can be called by
users of the class. The plotter starts out at its default zoom level. Each timethe user zooms in, a new
PlotSettings instance is created and put onto the
zoom stack.
The zoom stack is represented by two member variables:
•zoomStack holds the different zoom settings as a vector<PlotSettings> .
•curZoom holds the current PlotSettings ’sindex in the zoomStack .
After a call to setPlotSettings() ,the zoom stack contains only one entry, and
theZoom In and Zoom Out buttons are hidden. These buttons will not be shown
until we call show() on them in the zoomIn() andzoomOut() slots. (Normally,
it is sufﬁcient to call show() on the top-level widget to show all the children.
But when we explicitly call hide() on a child widget, it is hidden until we call
show() on it.)
The call to refreshPixmap() is necessary to update the display. Usually, we
would call update() ,but here we do things slightly differently because we
want to keep a QPixmap up to date at all times. After regenerating the pixmap,
refreshPixmap() callsupdate() to copy the pixmap onto the widget.
void Plotter::zoomOut()
{    if (curZoom > 0) {        --curZoom;        zoomOutButton->setEnabled(curZoom > 0);        zoomInButton->setEnabled(true);        zoomInButton->show();        refreshPixmap();    }}
ThezoomOut() slot zooms out if the graph is zoomed in. It decrements the
current zoom level and enables the Zoom Out button depending on whether the
graph can be zoomed out any more or not. The Zoom In button is enabled and
shown, and the display is updated with a call to refreshPixmap() .
void Plotter::zoomIn()
{    if (curZoom < (int)zoomStack.size() - 1) {        ++curZoom;        zoomInButton->setEnabled(                curZoom < (int)zoomStack.size() - 1);        zoomOutButton->setEnabled(true);        zoomOutButton->show();        refreshPixmap();
120 5. Creating Custom Widgets
    }
}
If the user has previously zoomed in and then out again, the PlotSettings for
the next zoom level will be in the zoom stack, and we can zoom in. (Otherwise,it is still possible to zoom in using a rubber band.)
The slot increments
curZoom to move one level deeper into the zoom stack, sets
theZoom In button enabled or disabled depending on whether it’s possible to
zoom in any further, and enables and shows the Zoom Out button. Again, we
callrefreshPixmap() to make the plotter use the latest zoom settings.
void Plotter::setCurveData(int id, const CurveData &data)
{    curveMap[id] = data;    refreshPixmap();}
ThesetCurveData() function sets the curve data for a given curve ID.If a curve
with the same ID already exists in the plotter,it is replaced with the new curvedata; otherwise, the new curve is simply inserted. The curves are stored in the
curveMap member variable of type map<int,CurveData> .
Again, we call our own refreshPixmap() function, rather than update() ,t o
update the display.
void Plotter::clearCurve(int id)
{    curveMap.erase(id);    refreshPixmap();}
TheclearCurve() function removes a curve from curveMap .
QSize Plotter::minimumSizeHint() const{    return QSize(4 * Margin, 4 * Margin);}
TheminimumSizeHint() function is similar to sizeHint() ;just assizeHint()
speciﬁes a widget’s ideal size, minimumSizeHint() speciﬁes a widget’s ideal
minimum size. A layout never resizes a widget below its minimum size hint.
The value we return is 160 × 160 to allow for the margin on all four sides and
some space for the plot itself. Below that size, the plot would be too small tobe useful.
QSize Plotter::sizeHint() const
{    return QSize(8 * Margin, 6 * Margin);}
InsizeHint() ,wereturn an “ideal” size in proportion to the margin and with
apleasing 4:3 aspect ratio.
Double Buffering 121
This ﬁnishes the review of the Plotter ’spublic functions and slots. Now let’s
review the protected event handlers.
void Plotter::paintEvent(QPaintEvent *event)
{    QMemArray<QRect> rects = event->region().rects();    for (int i = 0; i < (int)rects.size(); ++i)        bitBlt(this, rects[i].topLeft(), &pixmap, rects[i]);
    QPainter painter(this);    if (rubberBandIsShown) {
        painter.setPen(colorGroup().light());        painter.drawRect(rubberBandRect.normalize());    }    if (hasFocus()) {        style().drawPrimitive(QStyle::PE_FocusRect, &painter,                              rect(), colorGroup(),                              QStyle::Style_FocusAtBorder,                              colorGroup().dark());    }}
Normally, paintEvent() is the place where we perform all the drawing. But
here all the plot drawing is done beforehand in refreshPixmap() ,s ow ecan
render the entire plot simply by copying the pixmap onto the widget.
The call to QRegion::rect() returns an array of QRect sthat deﬁne the region
to repaint. We use bitBlt() to copy each rectangular area from the pixmap to
the widget. The bitBlt() global function has the following syntax:
bitBlt( dest, destPos, source, sourceRect );
where source is the source widget or pixmap, sourceRect is the rectangle in the
source that should be copied, dest is the destination widget or pixmap, and
destPos is the top-left position in the destination.
sourceRect
source
destdestPos
Figure 5.12. Copying arbitrary rectangles to and from pixmaps and widgets
It would have been equally correct to call bitBlt() just once on the region’s
bounding rectangle, as we did in a previous code snippet (p. 113). However,because we call
update() to erase and redraw the rubber band repeatedly
in the mouse event handlers (as we will see shortly), and the rubber bandoutline is basically four tiny rectangles (two 1-pixel-wide rectangles and two
122 5. Creating Custom Widgets
1-pixel-high rectangles),we gain some speed by breaking the region down into
its constituent rectangles and calling bitBlt() for each rectangle.
Once the plot is shown on screen, we draw the rubber band and the focus rect-
angle on top of it. For the rubber band, we use the “light” component from thewidget’s current color group as the pen color to ensure good contrast with the“dark” background. Notice that we draw directly on the widget, leaving theoff-screen pixmap untouched. The focus rectangle is drawn using the widgetstyle’s
drawPrimitive() function with PE_FocusRect as its ﬁrst argument.
TheQWidget::style() function returns the widget style to use to draw the
widget. In Qt, a widget style is a subclass of QStyle .The built-in styles include
QWindowsStyle ,QWindowsXPStyle ,QMotifStyle ,andQMacStyle .Each of these
styles reimplements the virtual functions in QStyle to perform the drawing in
the correct way for the platform the style is emulating. The drawPrimitive()
function is one of these functions; it draws “primitive elements” like panels,buttons, and focus rectangles. The widget style is usually the same for allwidgets in an application (
QApplication::style() ), but it can be overridden on
aper-widget basis using QWidget::setStyle() .
By subclassing QStyle ,itispossible to deﬁne a custom style. This can be done
to give a distinctive look to an application or a suite of applications. While it isgenerally advisable to use the target platform’s native look and feel, Qt offersalot of ﬂexibility if you want to be adventurous.
Qt’s built-in widgets rely almost exclusively on
QStyle to paint themselves.
This is why they look like native widgets on all platforms supported by Qt.Custom widgets can be made style-aware either by using
QStyle to paint
themselves or by using built-in Qt widgets as child widgets. For Plotter ,w e
use both approaches: The focus rectangle is drawn using QStyle ,and the Zoom
Inand Zoom Out buttons are built-in Qt widgets.
void Plotter::resizeEvent(QResizeEvent *)
{    int x = width() - (zoomInButton->width()                       + zoomOutButton->width() + 10);    zoomInButton->move(x, 5);    zoomOutButton->move(x + zoomInButton->width() + 5, 5);    refreshPixmap();}
Whenever the Plotter widget is resized, Qt generates a “resize” event. Here,
we reimplement resizeEvent() to place the Zoom In and Zoom Out buttons at the
top right of the Plotter widget.
Wemove the Zoom In button and the Zoom Out button to be side by side, sepa-
rated by a 5-pixel gap and with a 5-pixel offset from the top and right edges ofthe parent widget.
If we wanted the buttons to stay rooted to the top-left corner, whose coordi-
nates are (0, 0), we would simply have moved them there in the
Plotter con-
structor. But we want to track the top-right corner, whose coordinates depend
Double Buffering 123
on the size of the widget. Because of this, it’s necessary to reimplement re-
sizeEvent() and to set the position there.
Wedidn’t set any positions for the buttons in the Plotter constructor. This
isn’t an issue, since Qt always generates a resize event before a widget isshown for the ﬁrst time.
An alternative to reimplementing
resizeEvent() and laying out the child wid-
gets manually would have been to use a layout manager (for example, QGrid-
Layout ). However, it would have been a little more complicated and would
have consumed more resources. When we write widgets from scratch as weare doing here, laying out our child widgets manually is usually the rightapproach.
At the end, we call
refreshPixmap() to redraw the pixmap at the new size.
void Plotter::mousePressEvent(QMouseEvent *event)
{    if (event->button() == LeftButton) {        rubberBandIsShown = true;        rubberBandRect.setTopLeft(event->pos());        rubberBandRect.setBottomRight(event->pos());        updateRubberBandRegion();        setCursor(crossCursor);    }}
When the user presses the left mouse button, we start displaying a rubber
band. This involves setting rubberBandIsShown totrue,initializing the rubber-
BandRect member variable with the current mouse pointer position,scheduling
apaint event to paint the rubber band, and changing the mouse cursor to have
acrosshair shape.
Qt provides two mechanisms for controlling the mouse cursor’s shape:
•QWidget::setCursor() sets the cursor shape to use when the mouse hovers
over a particular widget. If no cursor is set for a widget, the parent wid-get’s cursor is used. The default for top-level widgets is an arrow cursor.
•
QApplication::setOverrideCursor() sets the cursor shape for the entire ap-
plication, overriding the cursors set by individual widgets until restore-
OverrideCursor() is called.
In Chapter 4, we called QApplication::setOverrideCursor() withwaitCursor to
change the application’s cursor to the standard wait cursor.
void Plotter::mouseMoveEvent(QMouseEvent *event)
{    if (event->state() & LeftButton) {        updateRubberBandRegion();        rubberBandRect.setBottomRight(event->pos());        updateRubberBandRegion();    }}
124 5. Creating Custom Widgets
When the user moves the mouse cursor while holding the left button, we call
updateRubberBandRegion() to schedule a paint event to repaint the area where
the rubber band was, we update rubberBandRect to account for the mouse move,
and we call updateRubberBandRegion() asecond time to repaint the area where
the rubber band has moved to. This effectively erases the rubber band andredraws it at the new coordinates.
The
rubberBandRect variable is of type QRect .AQRect can be deﬁned either as
an (x,y,w,h)quadruple—where ( x,y)isthe position of the top-left corner and
w×his the size of the rectangle—or as a top-left and a bottom-right coordinate
pair. Here, we have used the coordinate pair representation. We set the pointwhere the user clicked the ﬁrst time as the top-left corner and the currentmouse position as the bottom-right corner.
If the user moves the mouse upward or leftward, it’s likely that
rubberBand-
Rect’snominal bottom-right corner will end up above or to the left of its top-left
corner. If this occurs,the QRect will have a negative width or height. QRect has
anormalize() function that adjusts the top-left and bottom-right coordinates
to obtain a nonnegative width and height.
void Plotter::mouseReleaseEvent(QMouseEvent *event)
{    if (event->button() == LeftButton) {        rubberBandIsShown = false;        updateRubberBandRegion();        unsetCursor();
        QRect rect = rubberBandRect.normalize();
        if (rect.width() < 4 || rect.height() < 4)            return;        rect.moveBy(-Margin, -Margin);
        PlotSettings prevSettings = zoomStack[curZoom];
        PlotSettings settings;        double dx = prevSettings.spanX() / (width() - 2 * Margin);        double dy = prevSettings.spanY() / (height() - 2 * Margin);        settings.minX = prevSettings.minX + dx * rect.left();        settings.maxX = prevSettings.minX + dx * rect.right();        settings.minY = prevSettings.maxY - dy * rect.bottom();        settings.maxY = prevSettings.maxY - dy * rect.top();        settings.adjust();
        zoomStack.resize(curZoom + 1);
        zoomStack.push_back(settings);        zoomIn();    }}
When the user releases the left mouse button, we erase the rubber band and
restore the standard arrow cursor. If the rubber band is at least 4 × 4, weperform the zoom. If the rubber band is smaller than that, it’s likely that theuser clicked the widget by mistake or to give it focus, so we do nothing.
Double Buffering 125
The code to perform the zoom is a bit complicated. This is because we deal
with two coordinate systems at the same time: widget coordinates and plottercoordinates. Most of the work we perform here is to convert the
rubberBandRect
from widget coordinates to plotter coordinates.
Once we have done the conversion, we call PlotSettings::adjust() to round
the numbers and ﬁnd a sensible number of ticks for each axis.
0 2 4 6 8 100246810
(94, 73)
13568(0, 0)
±
0 2 4 6 8 1002468102.4 6.8
3.26.5
Figure 5.13. Converting the rubber band from widget to plotter coordinates
0 2 4 6 8 1002468102.0 7.0
3.07.0
±
2 3 4 5 6 734567
Figure 5.14. Adjusting plotter coordinates and zooming in on the rubber band
Then we perform the zoom. The zoom is achieved by pushing the new PlotSet-
tings that we have just calculated on top of the zoom stack and calling zoom-
In() to do the job.
void Plotter::keyPressEvent(QKeyEvent *event)
{    switch (event->key()) {    case Key_Plus:        zoomIn();        break;    case Key_Minus:        zoomOut();        break;    case Key_Left:        zoomStack[curZoom].scroll(-1, 0);        refreshPixmap();
126 5. Creating Custom Widgets
        break;
    case Key_Right:        zoomStack[curZoom].scroll(+1, 0);        refreshPixmap();        break;    case Key_Down:        zoomStack[curZoom].scroll(0, -1);        refreshPixmap();        break;    case Key_Up:        zoomStack[curZoom].scroll(0, +1);        refreshPixmap();        break;    default:        QWidget::keyPressEvent(event);    }}
When the user presses a key and the Plotter widget has focus, the keyPress-
Event() function is called. We reimplement it here to respond to six keys: +,+--,
Up,Down ,Left,and Right.Ifthe user pressed a key that we are not handling, we
call the base class implementation. For simplicity, we ignore the Shift,Ctrl,and
Altmodiﬁer keys, which are available through QKeyEvent::state() .
void Plotter::wheelEvent(QWheelEvent *event)
{    int numDegrees = event->delta() / 8;    int numTicks = numDegrees / 15;
    if (event->orientation() == Horizontal)
        zoomStack[curZoom].scroll(numTicks, 0);    else        zoomStack[curZoom].scroll(0, numTicks);    refreshPixmap();}
Wheel events occur when a mouse wheel is turned. Most mice only provide a
vertical wheel, but some also have a horizontal wheel. Qt supports both kindsof wheels. Wheel events go to the widget that has the focus. The
delta()
function returns the distance the wheel was rotated in eighths of a degree.Mice typically work in steps of 15 degrees.
The most common use of the wheel mouse is to scroll a scroll bar. When we
subclass
QScrollView (covered in Chapter 6) to provide scroll bars, QScrollView
handles the wheel mouse events automatically, so we don’t need to reimple-ment
wheelEvent() ourselves. Qt classes like QListView ,QTable ,andQTextEdit
that inherit QScrollView also support wheel events without needing addition-
al code.
This ﬁnishes the implementation of the event handlers. Now let’s review the
private functions.
void Plotter::updateRubberBandRegion()
{    QRect rect = rubberBandRect.normalize();
Double Buffering 127
    update(rect.left(), rect.top(), rect.width(), 1);
    update(rect.left(), rect.top(), 1, rect.height());    update(rect.left(), rect.bottom(), rect.width(), 1);    update(rect.right(), rect.top(), 1, rect.height());}
TheupdateRubberBand() function is called from mousePressEvent() ,mouseMove-
Event() ,andmouseReleaseEvent() to erase or redraw the rubber band. It con-
sists of four calls to update() that schedule a paint event for the four small
rectangular areas that are covered by the rubber band.
Using NOT to Draw the Rubber Band
Acommon way to draw a rubber band is to use the NOT (or the XOR) math-
ematical operator, which replaces each pixel value on the rubber band rect-angle with the opposite bit pattern. Here’s a new version of
updateRubber-
BandRegion() that does this:
void Plotter::updateRubberBandRegion()
{    QPainter painter(this);    painter.setRasterOp(NotROP);    painter.drawRect(rubberBandRect.normalize());}
ThesetRasterOp() call sets the painter’s raster operation to be NotROP .Inthe
original version, we kept the default value, CopyROP ,which told QPainter to
simply copy the new value over the original.
When we call updateRubberBandRegion() asecond time with the same
coordinates, the original pixels are restored, since two NOTs cancel eachother out.
The advantage of using NOT is that it’s easy to implement and it eliminates
the need to keep a copy of the covered areas. But it isn’t generally applica-ble. For example, if we draw text instead of a rubber band, the text couldbecome very hard to read. Also, NOT doesn’t always produce good contrast;for example,medium gray stays medium gray. Finally, NOT isn’t supportedon Mac OS X.
Another approach is to render the rubber band as an animated dotted line.
This is often used in image manipulation programs, because it providesgood contrast no matter what colors are found in the image. To do this in Qt,the trick is to reimplement
QObject::timerEvent() to erase the rubber band
and then repaint it but starting drawing the dots at a slightly differentoffset each time, producing the illusion of movement.
void Plotter::refreshPixmap()
{    pixmap.resize(size());    pixmap.fill(this, 0, 0);    QPainter painter(&pixmap, this);    drawGrid(&painter);
128 5. Creating Custom Widgets
    drawCurves(&painter);
    update();}
TherefreshPixmap() function redraws the plot onto the off-screen pixmap and
updates the display.
Weresize the pixmap to have the same size as the widget and ﬁll it with the
widget’s erase color. This color is the “dark” component of the palette, becauseof the call to
setBackgroundMode() in thePlotter constructor.
Then we create a QPainter to draw on the pixmap and call drawGrid() and
drawCurves() to perform the drawing. At the end, we call update() to schedule
apaint event for the whole widget. The pixmap is copied to the widget in the
paintEvent() function (p. 121).
void Plotter::drawGrid(QPainter *painter)
{    QRect rect(Margin, Margin,               width() - 2 * Margin, height() - 2 * Margin);    PlotSettings settings = zoomStack[curZoom];    QPen quiteDark = colorGroup().dark().light();    QPen light = colorGroup().light();
    for (int i = 0; i <= settings.numXTicks; ++i) {
        int x = rect.left() + (i * (rect.width() - 1)                                 / settings.numXTicks);        double label = settings.minX + (i * settings.spanX()                                          / settings.numXTicks);        painter->setPen(quiteDark);        painter->drawLine(x, rect.top(), x, rect.bottom());        painter->setPen(light);        painter->drawLine(x, rect.bottom(), x, rect.bottom() + 5);        painter->drawText(x - 50, rect.bottom() + 5, 100, 15,                          AlignHCenter | AlignTop,                          QString::number(label));    }    for (int j = 0; j <= settings.numYTicks; ++j) {        int y = rect.bottom() - (j * (rect.height() - 1)                                   / settings.numYTicks);        double label = settings.minY + (j * settings.spanY()                                          / settings.numYTicks);        painter->setPen(quiteDark);        painter->drawLine(rect.left(), y, rect.right(), y);        painter->setPen(light);        painter->drawLine(rect.left() - 5, y, rect.left(), y);        painter->drawText(rect.left() - Margin, y - 10,                          Margin - 5, 20,                          AlignRight | AlignVCenter,                          QString::number(label));    }    painter->drawRect(rect);}
ThedrawGrid() function draws the grid behind the curves and the axes.
Double Buffering 129
The ﬁrst forloop draws the grid’s vertical lines and the ticks along the xaxis.
The second forloop draws the grid’s horizontal lines and the ticks along the
yaxis. The drawText() function is used to draw the numbers corresponding to
the tick mark on both axes.
The calls to drawText() have the following syntax:
painter.drawText( x, y, w, h, alignment , text);
where ( x,y,w,h)deﬁne a rectangle, alignment the position of the text within
that rectangle, and text the text to draw.
void Plotter::drawCurves(QPainter *painter)
{    static const QColor colorForIds[6] = {        red, green, blue, cyan, magenta, yellow    };    PlotSettings settings = zoomStack[curZoom];    QRect rect(Margin, Margin,               width() - 2 * Margin, height() - 2 * Margin);
    painter->setClipRect(rect.x() + 1, rect.y() + 1,
                         rect.width() - 2, rect.height() - 2);
    map<int, CurveData>::const_iterator it = curveMap.begin();
    while (it != curveMap.end()) {        int id = (*it).first;        const CurveData &data = (*it).second;        int numPoints = 0;        int maxPoints = data.size() / 2;        QPointArray points(maxPoints);
        for (int i = 0; i < maxPoints; ++i) {
            double dx = data[2 * i] - settings.minX;            double dy = data[2 * i + 1] - settings.minY;            double x = rect.left() + (dx * (rect.width() - 1)                                         / settings.spanX());            double y = rect.bottom() - (dy * (rect.height() - 1)                                           / settings.spanY());            if (fabs(x) < 32768 && fabs(y) < 32768) {                points[numPoints] = QPoint((int)x, (int)y);                ++numPoints;            }        }        points.truncate(numPoints);        painter->setPen(colorForIds[(uint)id % 6]);        painter->drawPolyline(points);        ++it;    }}
ThedrawCurves() function draws the curves on top of the grid. We start by
callingsetClipRect() to set the QPainter ’sclip region to the rectangle that con-
tains the curves (excluding the margins). QPainter will then ignore drawing
operations on pixels outside the area.
130 5. Creating Custom Widgets
Next, we iterate over all the curves,and for each curve,we iterate over the ( x,y)
coordinate pairs that constitute it. The first member of the iterator’s value
gives us the ID of the curve and the second member gives us the curve data.
The inner part of the forloop converts a coordinate pair from plotter coordi-
nates to widget coordinates and stores it in the points variable, provided that
it lies within reasonable bounds. If the user zooms in a lot, we could easily endup with numbers that cannot be represented as 16-bit signed integers, leadingto incorrect rendering by some window systems.
Once we have converted all the points of a curve to widget coordinates, we set
the pen color for the curve (using one of a set of predeﬁned colors) and call
drawPolyline() to draw a line that goes through all the curve’s points.
This is the complete Plotter class. All that remains are a few functions in
PlotSettings .
PlotSettings::PlotSettings()
{    minX = 0.0;    maxX = 10.0;    numXTicks = 5;
    minY = 0.0;
    maxY = 10.0;    numYTicks = 5;}
ThePlotSettings constructor initializes both axes to the range 0 to 10 with 5
tick marks.
void PlotSettings::scroll(int dx, int dy)
{    double stepX = spanX() / numXTicks;    minX += dx * stepX;    maxX += dx * stepX;
    double stepY = spanY() / numYTicks;
    minY += dy * stepY;    maxY += dy * stepY;}
Thescroll() function increments (or decrements) minX,maxX,minY,andmaxY by
the interval between two ticks times a given number. This function is used toimplement scrolling in
Plotter::keyPressEvent() .
void PlotSettings::adjust()
{    adjustAxis(minX, maxX, numXTicks);    adjustAxis(minY, maxY, numYTicks);}
Theadjust() function is called from mouseReleaseEvent() to round the minX,
maxX,minY,andmaxY values to “nice” values and to determine the number of
ticks appropriate for each axis. The private function adjustAxis() does its
work one axis at a time.
Double Buffering 131
void PlotSettings::adjustAxis(double &min, double &max,
                              int &numTicks){    const int MinTicks = 4;    double grossStep = (max - min) / MinTicks;    double step = pow(10, floor(log10(grossStep)));
    if (5 * step < grossStep)
        step *= 5;    else if (2 * step < grossStep)        step *= 2;
    numTicks = (int)(ceil(max / step) - floor(min / step));
    min = floor(min / step) * step;    max = ceil(max / step) * step;}
TheadjustAxis() function converts its minandmaxparameters into “nice”
numbers and sets its numTicks parameter to the number of ticks it calculates
to be appropriate for the given [ min,max]range. Because adjustAxis() needs to
modify the actual variables ( minX,maxX,numXTicks ,etc.) and not just copies, its
parameters are non-const references.
Most of the code in adjustAxis() simply attempts to determine an appropriate
value for the interval between two ticks (the “step”). To obtain nice numbersalong the axis, we must select the step with care. For example, a step value of3.8 would lead to an axis with multiples of 3.8, which is difﬁcult for people torelate to. For axes labelled in decimal notation,“nice” step values are numbersof the form
n10 , 2·n10 , or 5·n10 .
Westart by computing the “gross step”, a kind of maximum for the step value.
Then we ﬁnd the corresponding number of the formn10 that is smaller than
or equal to the gross step. We do this by taking the decimal logarithm of thegross step, then rounding that value down to a whole number, then raising 10to the power of this rounded number. For example, if the gross step is 236, we
compute log 236 = 2.37291…; then we round it down to 2 and obtain 10
2=100
as the candidate step value of the formn10 .
Once we have the ﬁrst candidate step value, we can use it to calculate the
other two candidates: 2·n10 and 5·n10 . For the example above, the two other
candidates are 200 and 500. The 500 candidate is larger than the gross step,so we can’t use it. But 200 is smaller than 236, so we use 200 for the step sizein this example.
It’s fairly easy to derive
numTicks ,min,andmaxfrom the step value. The new min
value is obtained by rounding the original mindown to the nearest multiple
of the step, and the new maxvalue is obtained by rounding up to the nearest
multiple of the step. The new numTicks is the number of intervals between the
the rounded minandmaxvalues. For example,if minis 240 and maxis 1184 upon
entering the function, the new range becomes [200, 1200], with 5 tick marks.
This algorithm will give suboptimal results in some cases. A more sophisti-
cated algorithm is described in Paul S. Heckbert’s article “Nice Numbers for
132 5. Creating Custom Widgets
Graph Labels” published in Graphics Gems (ISBN 0-12-286166-3). Also of
interest is the Qt Quarterly article “Fast and Flicker-Free”, available online
athttp://doc.trolltech.com/qq/qq06-flicker-free.html ,which presents some
more ideas for eliminating ﬂicker.
This chapter has brought us to the end of Part I. It has explained how to
customize an existing Qt widget and how to build a widget from the ground upusing
QWidget as the base class. We have already seen how to compose a widget
from existing widgets in Chapter 2, and we will explore the theme further inChapter 6.
At this point, we know enough to write complete GUI applications using Qt.
In Part II, we will explore Qt in greater depth, so that we can make full use ofQt’s power.
Part II
Intermediate Qt

66
Layout Management•Basic Layouts
•Splitters
•Widget Stacks
•Scroll Views
•Dock Windows
•Multiple Document Interface
Every widget that is placed on a form must be given an appropriate size and
position. Some large widgets may also need scroll bars to give the user accessto all their contents. In this chapter, we will review the different ways oflaying out widgets on a form,and also see how to implement dockable windowsand MDI windows.
Basic Layouts
Qt provides three basic ways of managing the layout of child widgets on aform: absolute positioning, manual layout, and layout managers. We willlook at each of these approaches in turn, using the Find File dialog shown inFigure 6.1 as our example.
Figure 6.1. The Find File dialog
135
136 6. Layout Management
Absolute positioning is the crudest way of laying out widgets. It is achieved by
assigning hard-coded sizes and positions (geometries) to the form’s child wid-gets and a ﬁxed size to the form. Here’s what the
FindFileDialog constructor
looks like using absolute positioning:
FindFileDialog::FindFileDialog(QWidget *parent, const char *name)
    : QDialog(parent, name){
···
    namedLabel->setGeometry(10, 10, 50, 20);
    namedLineEdit->setGeometry(70, 10, 200, 20);    lookInLabel->setGeometry(10, 35, 50, 20);    lookInLineEdit->setGeometry(70, 35, 200, 20);    subfoldersCheckBox->setGeometry(10, 60, 260, 20);    listView->setGeometry(10, 85, 260, 100);    messageLabel->setGeometry(10, 190, 260, 20);    findButton->setGeometry(275, 10, 80, 25);    stopButton->setGeometry(275, 40, 80, 25);    closeButton->setGeometry(275, 70, 80, 25);    helpButton->setGeometry(275, 185, 80, 25);
    setFixedSize(365, 220);
}
Absolute positioning has many disadvantages. The foremost problem is that
the user cannot resize the window. Another problem is that some text maybe truncated if the user chooses an unusually large font or if the applicationis translated into another language. And this approach also requires us toperform tedious position and size calculations.
An alternative to absolute positioning is manual layout. With manual layout,
the widgets are still given absolute positions, but their sizes are made propor-tional to the size of the window rather than being entirely hard-coded. Thiscan be achieved by reimplementing the form’s
resizeEvent() function to set its
child widgets’ geometries:
FindFileDialog::FindFileDialog(QWidget *parent, const char *name)
    : QDialog(parent, name){
···
    setMinimumSize(215, 170);
    resize(365, 220);}
void FindFileDialog::resizeEvent(QResizeEvent *)
{    int extraWidth = width() - minimumWidth();    int extraHeight = height() - minimumHeight();
    namedLabel->setGeometry(10, 10, 50, 20);
    namedLineEdit->setGeometry(70, 10, 50 + extraWidth, 20);    lookInLabel->setGeometry(10, 35, 50, 20);    lookInLineEdit->setGeometry(70, 35, 50 + extraWidth, 20);    subfoldersCheckBox->setGeometry(10, 60, 110 + extraWidth, 20);
Basic Layouts 137
    listView->setGeometry(10, 85,
                          110 + extraWidth, 50 + extraHeight);    messageLabel->setGeometry(10, 140 + extraHeight,                              110 + extraWidth, 20);    findButton->setGeometry(125 + extraWidth, 10, 80, 25);    stopButton->setGeometry(125 + extraWidth, 40, 80, 25);    closeButton->setGeometry(125 + extraWidth, 70, 80, 25);    helpButton->setGeometry(125 + extraWidth, 135 + extraHeight,                            80, 25);}
Weset the form’s minimum size to 215 × 170 in the FindFileDialog constructor
and its initial size to 365 × 220. In the resizeEvent() function, we give any
extra space to the widgets that we want to grow.
Just like absolute positioning, manual layout requires a lot of hard-coded con-
stants to be calculated by the programmer. Writing code like this is tiresome,especially if the design changes. And there is still the risk of text truncation.The risk can be avoided by taking account of the child widgets’ size hints, butthat would complicate the code even further.
±
Figure 6.2. Resizing a resizable dialog
The best solution for laying out widgets on a form is to use Qt’s layout man-
agers. The layout managers provide sensible defaults for every type of widgetand take into account each widget’s size hint, which in turn typically dependson the widget’s font, style, and contents. Layout managers also respect mini-mum and maximum sizes, and automatically adjust the layout in response tofont changes, text changes, and window resizing.
Qt provides three layout managers:
QHBoxLayout ,QVBoxLayout ,andQGridLayout .
These classes inherit QLayout ,which provides the basic framework for layouts.
All three classes are fully supported by Qt Designer and can also be used in
code. Chapter 2 presented examples of both approaches.
Here’s the FindFileDialog code using layout managers:
FindFileDialog::FindFileDialog(QWidget *parent, const char *name)
    : QDialog(parent, name){
···
138 6. Layout Management
    QGridLayout *leftLayout = new QGridLayout;
    leftLayout->addWidget(namedLabel, 0, 0);    leftLayout->addWidget(namedLineEdit, 0, 1);    leftLayout->addWidget(lookInLabel, 1, 0);    leftLayout->addWidget(lookInLineEdit, 1, 1);    leftLayout->addMultiCellWidget(subfoldersCheckBox, 2, 2, 0, 1);    leftLayout->addMultiCellWidget(listView, 3, 3, 0, 1);    leftLayout->addMultiCellWidget(messageLabel, 4, 4, 0, 1);
    QVBoxLayout *rightLayout = new QVBoxLayout;
    rightLayout->addWidget(findButton);    rightLayout->addWidget(stopButton);    rightLayout->addWidget(closeButton);    rightLayout->addStretch(1);    rightLayout->addWidget(helpButton);
    QHBoxLayout *mainLayout = new QHBoxLayout(this);
    mainLayout->setMargin(11);    mainLayout->setSpacing(6);    mainLayout->addLayout(leftLayout);    mainLayout->addLayout(rightLayout);}
The layout is handled by one QHBoxLayout ,oneQGridLayout ,and one QVBoxLay-
out.TheQGridLayout on the left and the QVBoxLayout on the right are placed
side by side by the outer QHBoxLayout .The margin around the dialog is 11 pixels
and the spacing between the child widgets is 6 pixels.
Caption 
QLabel QLineEdit
QLabel QLineEdit
QCheckBox
QListView
QLabelQPushButton
QPushButton
QPushButton
εεεεεεεεεεε
QPushButtonmainLayout
leftLayout rightLayout
Figure 6.3. The Find File dialog’s layout
QGridLayout works on a two-dimensional grid of cells.The QLabel at the top-left
corner of the layout is at position (0, 0), and the corresponding QLineEdit is
Basic Layouts 139
at position (0, 1). The QCheckBox spans two columns; it occupies the cells in
positions (2, 0) and (2, 1). The QListView and the QLabel beneath it also span
two columns. The calls to addMultiCellWidget() have the following syntax:
leftLayout->addMultiCellWidget( widget, row1, row2, col1, col2);
where widget is the child widget to insert into the layout, ( row1,col1)i sthe
top-left cell occupied by the widget, and ( row2,col2)isthe bottom-right cell
occupied by the widget.
The same dialog could be created visually in Qt Designer by placing the child
widgets in their approximate positions, selecting those that need to be laidout together, and clicking
Layout|Lay Out Horizontally ,Layout|Lay Out Vertically ,o r
Layout|Lay Out in a Grid .Weused this approach in Chapter 2 for creating the
Spreadsheet application’s Go-to-Cell and Sort dialogs.
Using layout managersprovidesadditional beneﬁtsto those we have discussed
so far. If we add a widget to a layout or remove a widget from a layout, thelayout will automatically adapt to the new situation. The same applies if wecall
hide() orshow() on a child widget. If a child widget’s size hint changes,
the layout will be automatically redone, taking into account the new size hint.Also, layout managers automatically set a minimum size for the form as awhole, based on the form’s child widgets’ minimum sizes and size hints.
In every example presented so far, we have simply put the widgets in layouts,
with spacer items to consume any excess space. Sometimes this isn’t sufﬁcientto make the layout look exactly the way we want. In such situations, we canadjust the layout by changing the size policies and size hints of the widgetsbeing laid out.
Awidget’s size policy tells the layout system how it should stretch or shrink.
Qt provides sensible default size policy values for all its built-in widgets,but since no single default can account for every possible layout, it is stillcommon for developers to change the size policies for one or two widgets on aform. A size policy has both a horizontal and a vertical component. The mostuseful values for each component are
Fixed ,Minimum ,Maximum ,Preferred ,and
Expanding :
•Fixed means that the widget cannot grow or shrink. The widget always
stays at the size of its size hint.
•Minimum means that the widget’s size hint is its minimum size. The widget
cannot shrink below the size hint, but it can grow to ﬁll available spaceif necessary.
•
Maximum means that the widget’s size hint is its maximum size. The widget
can be shrunk down to its minimum size hint.
•Preferred means that the widget’s size hint is its preferred size, but that
the widget can still shrink or grow if necessary.
•Expanding means that the widget can shrink or grow and that it is espe-
cially willing to grow.
140 6. Layout Management
Figure 6.4 summarizes the meaning of the different size policies, using a
QLabel showing the text “Some Text” as an example.
Fixed Some Text
Minimum Some Text Some Text
Maximum Son Some Text
Preferred Son Some Text Some Text
Expanding Son Some Text Some Textmin size hint size hint
Figure 6.4. The meaning of the different size policies
When a form that contains both Preferred andExpanding widgets is resized,
extra space is given to the Expanding widgets, while the Preferred widgets stay
at their size hint.
There are two other size policies: MinimumExpanding andIgnored .The former
wasnecessary in a few rare cases in older versions of Qt, but it isn’t useful
any more; a better approach is to use Expanding and reimplement minimumSize-
Hint() appropriately. The latter is similar to Expanding ,except that it ignores
the widget’s size hint.
In addition to the size policy’s horizontal and vertical components, the QSize-
Policy class stores both a horizontal and a vertical stretch factor.These stretch
factors can be used to indicate that different child widgets should grow atdifferent rates when the form expands. For example, if we have a
QListView
above a QTextEdit and we want the QTextEdit to be twice as tall as the QList-
View,w ecan set the QTextEdit ’svertical stretch factor to 2 and the QListView ’s
vertical stretch factor to 1.
Another way of inﬂuencing a layout is to set a minimum size, a maximum
size, or a ﬁxed size on the child widgets. The layout manager will respectthese constraints when laying out the widgets. And if this isn’t sufﬁcient, wecan always derive from the child widget’s class and reimplement
sizeHint() to
obtain the size hint we need.
Splitters
Asplitter is a widget that contains other widgets and that separates them
with splitter handles. Users can change the sizes of a splitter’s child widgetsby dragging the handles.Splitters can often be used as an alternative to layoutmanagers, to give more control to the user.
Qt supports splitters with the
QSplitter widget. The child widgets of a
QSplitter are automatically placed side by side (or one below the other) in the
Splitters 141
order in which they are created, with splitter bars between adjacent widgets.
Here’s the code for creating the window depicted in Figure 6.5:
#include <qapplication.h>
#include <qsplitter.h>#include <qtextedit.h>
int main(int argc, char *argv[])
{    QApplication app(argc, argv);
    QSplitter splitter(Qt::Horizontal);
    splitter.setCaption(QObject::tr("Splitter"));    app.setMainWidget(&splitter);
    QTextEdit *firstEditor = new QTextEdit(&splitter);
    QTextEdit *secondEditor = new QTextEdit(&splitter);    QTextEdit *thirdEditor = new QTextEdit(&splitter);
    splitter.show();
    return app.exec();}
The example consists of three QTextEdit slaid out horizontally by a QSplitter
widget. Unlike layout managers, which simply lay out a form’s child widgets,
QSplitter inherits from QWidget and can be used like any other widget.
Caption 
QSplitter
QTextEdit QTextEdit QTextEdit
Figure 6.5. The Splitter application’s widgets
AQSplitter can lay out its child widgets either horizontally or vertically. Com-
plex layouts can be achieved by nesting horizontal and vertical QSplitter s. For
example, the Mail Client application shown in Figure 6.6 consists of a horizon-tal
QSplitter that contains a vertical QSplitter on its right side.
Here’s the code in the constructor of the Mail Client application’s QMainWindow
subclass:
MailClient::MailClient(QWidget *parent, const char *name)
    : QMainWindow(parent, name){    horizontalSplitter = new QSplitter(Horizontal, this);    setCentralWidget(horizontalSplitter);
    foldersListView = new QListView(horizontalSplitter);
    foldersListView->addColumn(tr("Folders"));    foldersListView->setResizeMode(QListView::AllColumns);
142 6. Layout Management
    verticalSplitter = new QSplitter(Vertical, horizontalSplitter);
    messagesListView = new QListView(verticalSplitter);
    messagesListView->addColumn(tr("Subject"));    messagesListView->addColumn(tr("Sender"));    messagesListView->addColumn(tr("Date"));    messagesListView->setAllColumnsShowFocus(true);    messagesListView->setShowSortIndicator(true);    messagesListView->setResizeMode(QListView::AllColumns);
    textEdit = new QTextEdit(verticalSplitter);
    textEdit->setReadOnly(true);
    horizontalSplitter->setResizeMode(foldersListView,
                                      QSplitter::KeepSize);    verticalSplitter->setResizeMode(messagesListView,                                    QSplitter::KeepSize);
···
    readSettings();
}
Wecreate the horizontal QSplitter ﬁrst and set it to be the QMainWindow ’s
central widget. Then we create the child widgets and their child widgets.
Figure 6.6. The Mail Client application on Mac OS X
When the user resizes a window, QSplitter normally distributes the space so
that the relative sizes of the child widgets stay the same. In the Mail Clientexample, we don’t want this behavior; instead we want the two
QListView st o
maintain their size and we want to give any extra space to the QTextEdit .This
is achieved by the two setResizeMode() calls near the end.
Splitters 143
When the application is started, QSplitter gives the child widgets appropriate
sizes based on their initial sizes. We can move the splitter handles program-matically by calling
QSplitter::setSizes() .TheQSplitter class also provides
ameans of saving and restoring its state the next time the application is run.
Here’s the writeSettings() function that saves the Mail Client’s settings:
void MailClient::writeSettings()
{    QSettings settings;    settings.setPath("software-inc.com", "MailClient");    settings.beginGroup("/MailClient");
    QString str;
    QTextOStream out1(&str);    out1 << *horizontalSplitter;    settings.writeEntry("/horizontalSplitter", str);    QTextOStream out2(&str);    out2 << *verticalSplitter;    settings.writeEntry("/verticalSplitter", str);
    settings.endGroup();
}
Here’s the corresponding readSettings() function:
void MailClient::readSettings(){    QSettings settings;    settings.setPath("software-inc.com", "MailClient");    settings.beginGroup("/MailClient");
    QString str1 = settings.readEntry("/horizontalSplitter");
    QTextIStream in1(&str1);    in1 >> *horizontalSplitter;    QString str2 = settings.readEntry("/verticalSplitter");    QTextIStream in2(&str2);    in2 >> *verticalSplitter;
    settings.endGroup();
}
These functions rely on QTextIStream andQTextOStream ,twoQTextStream
convenience subclasses.
By default, a splitter handle is shown as a rubber band while the user is
dragging it, and the widgets on either side of the splitter handle are resizedonly when the user releases the mouse button. To make
QSplitter resize the
child widgets in real time, we would call setOpaqueResize(true) .
QSplitter is fully supported by Qt Designer .Toput widgets into a splitter,place
the child widgets approximately in their desired positions, select them, andclick
Layout|Lay Out Horizontally (in Splitter) orLayout|Lay Out Vertically (in Splitter) .
144 6. Layout Management
Widget Stacks
Another useful widget for managing layouts is QWidgetStack .This widget
contains a set of child widgets,or “pages”, and shows only one at a time, hidingthe others from the user. The pages are numbered from 0. If we want to makeaspeciﬁc child widget visible, we can call
raiseWidget() with either a page
number or a pointer to the child widget.
Figure 6.7. QWidgetStack
TheQWidgetStack itself is invisible and provides no intrinsic means for the
user to change page. The small arrows and the dark gray frame in Figure 6.7are provided by Qt Designer to make the
QWidgetStack easier to design with.
Figure 6.8. The Conﬁgure dialog
The Conﬁgure dialog shown in Figure 6.8 is an example that uses QWidget-
Stack .The dialog consists of a QListBox on the left and a QWidgetStack on the
right. Each item in the QListBox corresponds to a different page in the QWid-
getStack .Forms like this are very easy to create using Qt Designer :
Widget Stacks 145
1. Create a new form based on the “Dialog” or the “Widget” template.
2. Add a list box and a widget stack to the form.3. Fill each widget stack page with child widgets and layouts.
(To create a new page, right-click and choose
Add Page ;toswitch pages,
click the tiny left or right arrow located at the top-right of the widgetstack.)
4. Lay the widgets out side by side using a horizontal layout.
5. Connect the list box’s
highlighted(int) signal to the widget stack’s
raiseWidget(int) slot.
6. Set the value of the list box’s currentItem property to 0.
Since we have implemented page-switching using predeﬁned signalsand slots,
the dialog will exhibit the correct page-switching behavior when previewed inQt Designer .
Scroll Views
TheQScrollView class provides a scrollable viewport, two scroll bars, and a
“corner” widget (usually an empty QWidget ). If we want to add scroll bars to
awidget, it is much simpler to use a QScrollView than to instantiate our own
QScrollBar sand implement the scrolling functionality ourselves.
viewport()
verticalScrollBar()
horizontalScrollbar() cornerWidget()
Figure 6.9. QScrollView ’sconstituent widgets
The easiest way to use QScrollView is to call addChild() with the widget we
want to add scroll bars to. QScrollView automatically reparents the widget to
make it a child of the viewport (accessible through QScrollView::viewport() )
if it isn’t already. For example, if we want scroll bars around the IconEditor
widget we developed in Chapter 5, we can write this:
#include <qapplication.h>
#include <qscrollview.h>
#include "iconeditor.h"int main(int argc, char *argv[])
{
146 6. Layout Management
    QApplication app(argc, argv);
    QScrollView scrollView;
    scrollView.setCaption(QObject::tr("Icon Editor"));    app.setMainWidget(&scrollView);
    IconEditor *iconEditor = new IconEditor;
    scrollView.addChild(iconEditor);
    scrollView.show();
    return app.exec();}
By default, the scroll bars are only displayed when the viewport is smaller
than the child widget. We can force the scroll bars to always be shown bywriting this code:
scrollView.setHScrollBarMode(QScrollView::AlwaysOn);
scrollView.setVScrollBarMode(QScrollView::AlwaysOn);
When the child widget’s size hint changes, QScrollView automatically adapts
to the new size hint.
±
Figure 6.10. Resizing a QScrollView
An alternative way of using a QScrollView with a widget is to make the widget
inheritQScrollView and to reimplement drawContents() to draw the contents.
This is the approach used by Qt classes like QIconView ,QListBox ,QListView ,
QTable ,andQTextEdit .Ifawidget is likely to require scroll bars, it’s usually a
good idea to implement it as a subclass of QScrollView .
Toshow how this works, we will implement a new version of the IconEditor
class as a QScrollView subclass. We will call the new class ImageEditor ,since
its scroll bars make it capable of handling large images.
#ifndef IMAGEEDITOR_H
#define IMAGEEDITOR_H
#include <qimage.h>
#include <qscrollview.h>
Scroll Views 147
class ImageEditor : public QScrollView
{    Q_OBJECT    Q_PROPERTY(QColor penColor READ penColor WRITE setPenColor)    Q_PROPERTY(QImage image READ image WRITE setImage)    Q_PROPERTY(int zoomFactor READ zoomFactor WRITE setZoomFactor)
public:
    ImageEditor(QWidget *parent = 0, const char *name = 0);
    void setPenColor(const QColor &newColor);
    QColor penColor() const { return curColor; }    void setZoomFactor(int newZoom);    int zoomFactor() const { return zoom; }    void setImage(const QImage &newImage);    const QImage &image() const { return curImage; }
protected:
    void contentsMousePressEvent(QMouseEvent *event);    void contentsMouseMoveEvent(QMouseEvent *event);    void drawContents(QPainter *painter, int x, int y,                      int width, int height);
private:
    void drawImagePixel(QPainter *painter, int i, int j);    void setImagePixel(const QPoint &pos, bool opaque);    void resizeContents();
    QColor curColor;
    QImage curImage;    int zoom;};
#endif
The header ﬁle is very similar to the original (p. 100). The main difference is
that we inherit from QScrollView instead of QWidget .Wewill run into the other
differences as we review the class’s implementation.
ImageEditor::ImageEditor(QWidget *parent, const char *name)
    : QScrollView(parent, name, WStaticContents | WNoAutoErase){    curColor = black;    zoom = 8;    curImage.create(16, 16, 32);    curImage.fill(qRgba(0, 0, 0, 0));    curImage.setAlphaBuffer(true);    resizeContents();}
The constructor passes the WStaticContents andWNoAutoErase ﬂags to the
QScrollView .These ﬂags are actually set on the viewport. We don’t set a size
policy, because QScrollView ’sdefault of ( Expanding ,Expanding )isappropriate.
In the original version, we didn’t call updateGeometry() in the constructor
because we could depend on Qt’s layout managers picking up the initial widget
148 6. Layout Management
size by themselves. But here we must give the QScrollView base class an initial
size to work with, and we do this with the resizeContents() call.
void ImageEditor::resizeContents()
{    QSize size = zoom * curImage.size();    if (zoom >= 3)        size += QSize(1, 1);    QScrollView::resizeContents(size.width(), size.height());}
TheresizeContents() private function calls QScrollView::resizeContents()
with the size of the content part of the QScrollView .TheQScrollView displays
scroll bars depending on the content’s size in relation to the viewport’s size.
Wedon’t need to reimplement sizeHint() ;QScrollView ’sversion uses the
content’s size to provide a reasonable size hint.
void ImageEditor::setImage(const QImage &newImage)
{    if (newImage != curImage) {        curImage = newImage.convertDepth(32);        curImage.detach();        resizeContents();        updateContents();    }}
In many of the original IconEditor functions, we called update() to schedule
arepaint and updateGeometry() to propagate a size hint change. In the
QScrollView versions, these calls are replaced by resizeContents() to inform
theQScrollView about a change of the content’s size and updateContents() to
force a repaint.
void ImageEditor::drawContents(QPainter *painter, int, int, int, int)
{    if (zoom >= 3) {        painter->setPen(colorGroup().foreground());        for (int i = 0; i <= curImage.width(); ++i)            painter->drawLine(zoom * i, 0,                              zoom * i, zoom * curImage.height());        for (int j = 0; j <= curImage.height(); ++j)            painter->drawLine(0, zoom * j,                              zoom * curImage.width(), zoom * j);    }
    for (int i = 0; i < curImage.width(); ++i) {
        for (int j = 0; j < curImage.height(); ++j)            drawImagePixel(painter, i, j);    }}
ThedrawContents() function is called by QScrollView to repaint the content’s
area. The QPainter object is already initialized to account for the scrolling
Scroll Views 149
offset. We just need to perform the drawing as we normally do in a paint-
Event() .
The second, third, fourth, and ﬁfth parameters specify the rectangle that must
be redrawn. We could use this information to only draw the rectangle thatneeds repainting, but for the sake of simplicity we redraw everything.
The
drawImagePixel() function that is called near the end of drawContents()
is essentially the same as in the original IconEditor class (p. 106), so it is not
reproduced here.
void ImageEditor::contentsMousePressEvent(QMouseEvent *event)
{    if (event->button() == LeftButton)        setImagePixel(event->pos(), true);    else if (event->button() == RightButton)        setImagePixel(event->pos(), false);}
void ImageEditor::contentsMouseMoveEvent(QMouseEvent *event)
{    if (event->state() & LeftButton)        setImagePixel(event->pos(), true);    else if (event->state() & RightButton)        setImagePixel(event->pos(), false);}
Mouse events for the content part of the scroll view can be handled by reim-
plementing special event handlers in QScrollView ,whose names all start
withcontents .Behind the scenes, QScrollView automatically converts the
viewport coordinates to content coordinates, so we don’t need to convert themourselves.
void ImageEditor::setImagePixel(const QPoint &pos, bool opaque)
{    int i = pos.x() / zoom;    int j = pos.y() / zoom;
    if (curImage.rect().contains(i, j)) {
        if (opaque)            curImage.setPixel(i, j, penColor().rgb());        else            curImage.setPixel(i, j, qRgba(0, 0, 0, 0));
        QPainter painter(viewport());
        painter.translate(-contentsX(), -contentsY());        drawImagePixel(&painter, i, j);    }}
ThesetImagePixel() function is called from contentsMousePressEvent() and
contentsMouseMoveEvent() to set or clear a pixel. The code is almost the same
as the original version, except for the way the QPainter object is initialized.
Wepassviewport() as the parent because the painting is performed on the
150 6. Layout Management
viewport, and we translate the QPainter ’scoordinate system to account for the
scrolling offset.
Wecould replace the three lines that deal with the QPainter with this line:
updateContents(i * zoom, j * zoom, zoom, zoom);
This would tell QScrollView to update only the small rectangular area occupied
by the (zoomed) image pixel. But since we didn’t optimize drawContents()
to draw only the necessary area, this would be inefﬁcient, so it’s better toconstruct a
QPainter and do the painting ourselves.
If we use ImageEditor now, it is practically indistinguishable from the origi-
nal,QWidget -basedIconEditor used inside a QScrollView widget. However, for
certain more sophisticated widgets, subclassing QScrollView is the more nat-
ural approach. For example, a class such as QTextEdit that implements word-
wrapping needs tight integration between the document that is shown and the
QScrollView .
Also note that you should subclass QScrollView if the contents are likely to be
very tall or wide, because some window systems don’t support widgets that arelarger than 32,767 pixels.
One thing that the
ImageEditor example doesn’t demonstrate is that we can
put child widgets in the viewport area. The child widgets simply need to beadded using
addWidget() ,and can be moved using moveWidget() .Whenever
the user scrolls the content area, QScrollView automatically moves the child
widgets on screen. (If the QScrollView contains many child widgets, this can
slow down scrolling. We can call enableClipper(true) to optimize this case.)
One example where this approach would make sense is for a web browser.Most of the contents would be drawn directly on the viewport, but buttons andother form-entry elements would be represented by child widgets.
Dock Windows
Dock windows are windows that can be docked in dock areas. Toolbars are theprimary example of dock windows, but there can be other types.
QMainWindow provides four dock areas: one above, one below, one to the left, and
one to the right of the window’s central widget. When we create QToolBar s,
they automatically put themselves in their parent’s top dock area.
Figure 6.11. Floating dock windows
Every dock window has a handle. This appears as two gray lines at the left or
top of each dock window shown in Figure 6.12. Users can move dock windowsfrom one dock area to another by dragging the handle. They can also detach a
Dock Windows 151
dock window from an area and let the dock window ﬂoat as a top-level window
by dragging the dock window outside of any dock area. Free ﬂoating dockwindows have their own caption,and can have a close button. They are always“on top” of their main window.
Figure 6.12. AQMainWindow with ﬁve dock windows
Toturn on the close button when the dock window is ﬂoating, call setClose-
Mode() as follows:
dockWindow->setCloseMode(QDockWindow::Undocked);
QDockArea provides a context menu with the list of all dock windows and
toolbars. Once a dock window is closed, the user can restore it using thecontext menu.
Figure 6.13. AQDockArea context menu
Dock windows must be subclasses of QDockWindow .Ifwejust need a toolbar
with buttons and some other widgets, we can use QToolBar ,which inherits
QDockWindow .Here’s how to create a QToolBar containing a QComboBox ,aQSpinBox ,
and some toolbar buttons, and how to put it in the bottom dock area:
QToolBar *toolBar = new QToolBar(tr("Font"), this);
QComboBox *fontComboBox = new QComboBox(true, toolBar);
152 6. Layout Management
QSpinBox *fontSize = new QSpinBox(toolBar);
boldAct->addTo(toolBar);italicAct->addTo(toolBar);underlineAct->addTo(toolBar);moveDockWindow(toolBar, DockBottom);
This toolbar would look ugly if the user moves it to a QMainWindow ’sleft or
right dock areas because the QComboBox and the QSpinBox require too much
horizontal space. To prevent this from happening, we can call QMainWindow::
setDockEnabled() as follows:
setDockEnabled(toolBar, DockLeft, false);
setDockEnabled(toolBar, DockRight, false);
If what we need is something more like a ﬂoating widget or tool palette, we
can use QDockWindow directly, by calling setWidget() to set the widget to be
shown inside the QDockWindow .The widget can be as complicated as we like. If
we want the user to be able to resize the dock window even when it’s in a dockarea, we can call
setResizeEnabled() on the dock window. The dock window
will then be rendered with a splitter-like handle on the side.
If we want the widget to change itself depending on whether it is put in
ahorizontal or in a vertical dock area, we can reimplement QDockWindow::
setOrientation() and change it there.
If we want to save the position of all the toolbars and other dock windows so
that we can restore them the next time the application is run, we can writecode that is similar to the code we used to save a
QSplitter ’sstate (p. 143),
usingQMainWindow ’s<<operator to write out the state and QMainWindow ’s>>
operator to read it back in.
Applications like Microsoft Visual Studio and Qt Designer make extensive use
of dock windows to provide a very ﬂexible user interface. In Qt, this kind ofuser interface is usually achieved by using a
QMainWindow with many custom
QDockWindow sand aQWorkspace in the middle to control MDI child windows.
Multiple Document Interface
Applications that provide multiple documents within the main window’s
central area are called MDI (multiple document interface) applications. InQt, an MDI application is created by using the
QWorkspace class as the central
widget and by making each document window a child of the QWorkspace .
It is conventional for MDI applications to provide a Windows menu that
includes some commands for managing the windows and the list of windows.The active window is identiﬁed with a checkmark. The user can make anywindow active by clicking its entry in the
Windows menu.
In this section, we will develop the Editor application shown in Figure 6.14
to demonstrate how to create an MDI application and how to implement its
Windows menu.
Multiple Document Interface 153
Figure 6.14. The Editor application
The application consists of two classes: MainWindow andEditor .Its code is
on the CD, and since most of it is the same or similar to the Spreadsheetapplication from Part I, we will only present the new code.
Figure 6.15. The Editor application’s menus
Let’s start with the MainWindow class.
MainWindow::MainWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name){    workspace = new QWorkspace(this);    setCentralWidget(workspace);    connect(workspace, SIGNAL(windowActivated(QWidget *)),            this, SLOT(updateMenus()));    connect(workspace, SIGNAL(windowActivated(QWidget *)),            this, SLOT(updateModIndicator()));
    createActions();
    createMenus();    createToolBars();
154 6. Layout Management
    createStatusBar();
    setCaption(tr("Editor"));
    setIcon(QPixmap::fromMimeSource("icon.png"));}
In theMainWindow constructor, we create a QWorkspace widget and make it the
central widget. We connect the QWorkspace ’swindowActivated() signal to two
private slots. These slots ensure that the menus and the status bar alwaysreﬂect the state of the currently active child window.
void MainWindow::newFile()
{    Editor *editor = createEditor();    editor->newFile();    editor->show();}
ThenewFile() slot corresponds to the File|New menu option. It depends on the
createEditor() private function to create a child Editor window.
Editor *MainWindow::createEditor(){    Editor *editor = new Editor(workspace);    connect(editor, SIGNAL(copyAvailable(bool)),            this, SLOT(copyAvailable(bool)));    connect(editor, SIGNAL(modificationChanged(bool)),            this, SLOT(updateModIndicator()));    return editor;}
ThecreateEditor() function creates an Editor widget and sets up two
signal–slot connections. The ﬁrst connection ensures that Edit|Cut and Edit|
Copy are enabled or disabled depending on whether there is any selected text.
The second connection ensures that the MOD indicator in the status bar is al-
ways up to date.
Because we are using MDI, it is possible that there will be multiple Editor
widgets in use. This is a concern since we are only interested in responding
to thecopyAvailable(bool) andmodificationChanged() signals from the active
Editor window, not from the others. But these signals can only ever be emitted
by the active window, so this isn’t really a problem.
void MainWindow::open()
{    Editor *editor = createEditor();    if (editor->open())        editor->show();    else        editor->close();}
Theopen() function corresponds to File|Open .Itcreates a new Editor for the
new document and calls open() on theEditor .Itmakes more sense to imple-
ment the ﬁle operations in the Editor class than in the MainWindow class, be-
Multiple Document Interface 155
cause each Editor needs to maintain its own independent state. If the open()
fails, we simply close the editor since the user will have already been notiﬁed
of the error.
void MainWindow::save()
{    if (activeEditor()) {        activeEditor()->save();        updateModIndicator();    }}
Thesave() slot calls save() on the active editor, if there is one. Again, the code
that performs the real work is located in the Editor class.
Editor *MainWindow::activeEditor()
{    return (Editor *)workspace->activeWindow();}
TheactiveEditor() private function returns the active child window as an
Editor pointer.
void MainWindow::cut(){    if (activeEditor())        activeEditor()->cut();}
Thecut() slot calls cut() on the active editor. The copy() ,paste() ,anddel()
slots follow the same pattern.
void MainWindow::updateMenus()
{    bool hasEditor = (activeEditor() != 0);    saveAct->setEnabled(hasEditor);    saveAsAct->setEnabled(hasEditor);    pasteAct->setEnabled(hasEditor);    deleteAct->setEnabled(hasEditor);    copyAvailable(activeEditor()                  && activeEditor()->hasSelectedText());    closeAct->setEnabled(hasEditor);    closeAllAct->setEnabled(hasEditor);    tileAct->setEnabled(hasEditor);    cascadeAct->setEnabled(hasEditor);    nextAct->setEnabled(hasEditor);    previousAct->setEnabled(hasEditor);
    windowsMenu->clear();
    createWindowsMenu();}
TheupdateMenus() slot is called whenever a window is activated (or when the
last window is closed) to update the menu system, thanks to the signal–slotconnection we put in the
MainWindow constructor.
156 6. Layout Management
Most menu options only make sense if there is an active window, so we disable
them if there isn’t one. Then we clear the Windows menu and call createWin-
dowsMenu() to reinitialize it with a fresh list of child windows.
void MainWindow::createWindowsMenu()
{    closeAct->addTo(windowsMenu);    closeAllAct->addTo(windowsMenu);    windowsMenu->insertSeparator();    tileAct->addTo(windowsMenu);    cascadeAct->addTo(windowsMenu);    windowsMenu->insertSeparator();    nextAct->addTo(windowsMenu);    previousAct->addTo(windowsMenu);
    if (activeEditor()) {
        windowsMenu->insertSeparator();        windows = workspace->windowList();        int numVisibleEditors = 0;
        for (int i = 0; i < (int)windows.count(); ++i) {
            QWidget *win = windows.at(i);            if (!win->isHidden()) {                QString text = tr("%1 %2")                               .arg(numVisibleEditors + 1)                               .arg(win->caption());                if (numVisibleEditors < 9)                    text.prepend("&");                int id = windowsMenu->insertItem(                              text, this, SLOT(activateWindow(int)));                bool isActive = (activeEditor() == win);                windowsMenu->setItemChecked(id, isActive);                windowsMenu->setItemParameter(id, i);                ++numVisibleEditors;            }        }    }}
ThecreateWindowsMenu() private function ﬁlls the Windows menu with actions
and a list of visible windows. The actions are all typical of such menus andare easily implemented using
QWorkspace ’scloseActiveWindow() ,closeAllWin-
dows() ,tile() ,andcascade() slots.
The entry for the active window is shown with a checkmark next to its name.
When the user chooses a window entry, the activateWindow() slot is called
with the index in the windows list as the parameter, because of the call to
setItemParameter() .This is very similar to what we did in Chapter 3 when we
implemented the Spreadsheet application’s recently opened ﬁles list (p. 54).
Forthe ﬁrst nine entries, we put an ampersand in front of the number to make
that number’s single digit into a shortcut key. We don’t provide a shortcut keyfor the other entries.
Multiple Document Interface 157
void MainWindow::activateWindow(int param)
{    QWidget *win = windows.at(param);    win->show();    win->setFocus();}
TheactivateWindow() function is called when a window is chosen from the Win-
dows menu. The intparameter is the value that we set with setItemParame-
ter() .Thewindows data member holds the list of windows and was set in cre-
ateWindowsMenu() .
void MainWindow::copyAvailable(bool available)
{    cutAct->setEnabled(available);    copyAct->setEnabled(available);}
ThecopyAvailable() slot is called whenever text is selected or deselected in an
editor. It is also called from updateMenus() .Itenables or disables the Cutand
Copy actions.
void MainWindow::updateModIndicator()
{    if (activeEditor() && activeEditor()->isModified())        modLabel->setText(tr("MOD"));    else        modLabel->clear();}
TheupdateModIndicator() updates the MOD indicator in the status bar. It
is called whenever text is modiﬁed in an editor. It is also called when a newwindow is activated.
void MainWindow::closeEvent(QCloseEvent *event)
{    workspace->closeAllWindows();    if (activeEditor())        event->ignore();    else        event->accept();}
ThecloseEvent() function is reimplemented to close all child windows. If one
of the child widgets “ignores” its close event (presumably because the usercanceled an “unsaved changes” message box), we ignore the close event for the
MainWindow ;otherwise we accept it, resulting in Qt closing the window. If we
didn’t reimplement closeEvent() inMainWindow ,the user would not be given
the opportunity to save any unsaved changes.
Wehave now ﬁnished our review of MainWindow ,sowecan move on to the
Editor implementation. The Editor class represents one child window. It
inherits from QTextEdit ,which provides the text editing functionality. Just as
any Qt widget can be used as a stand-alone window, any Qt widget can be usedas a child window in an MDI workspace.
158 6. Layout Management
Here’s the class deﬁnition:
class Editor : public QTextEdit
{    Q_OBJECTpublic:    Editor(QWidget *parent = 0, const char *name = 0);
    void newFile();
    bool open();    bool openFile(const QString &fileName);    bool save();    bool saveAs();    QSize sizeHint() const;
signals:
    void message(const QString &fileName, int delay);
protected:
    void closeEvent(QCloseEvent *event);
private:
    bool maybeSave();    void saveFile(const QString &fileName);    void setCurrentFile(const QString &fileName);    QString strippedName(const QString &fullFileName);    bool readFile(const QString &fileName);    bool writeFile(const QString &fileName);
    QString curFile;
    bool isUntitled;    QString fileFilters;};
Four of the private functions that were in the Spreadsheet application’s Main-
Window class (p.51) are also present in the Editor class:maybeSave() ,saveFile() ,
setCurrentFile() ,andstrippedName() .
Editor::Editor(QWidget *parent, const char *name)
    : QTextEdit(parent, name){    setWFlags(WDestructiveClose);    setIcon(QPixmap::fromMimeSource("document.png"));
    isUntitled = true;
    fileFilters = tr("Text files (*.txt)\n"                     "All files (*)");}
TheEditor constructor sets the WDestructiveClose ﬂag using setWFlags() .
When a class constructor doesn’t provide a flags parameter (as is the case
withQTextEdit ), we can still set most ﬂags using setWFlags() .
Since we allow users to create any number of editor windows, we must make
some provision for naming them so that they can be distinguished before theyhave been saved for the ﬁrst time. One common way of handling this is toallocate names that include a number (for example,
document1.txt ). We use the
Multiple Document Interface 159
isUntitled variable to distinguish between names supplied by the user and
names we have created programmatically.
After the constructor, we expect either newFile() oropen() to be called.
void Editor::newFile()
{    static int documentNumber = 1;
    curFile = tr("document%1.txt").arg(documentNumber);
    setCaption(curFile);    isUntitled = true;    ++documentNumber;}
ThenewFile() function generates a name like document2.txt for the new
document. The code belongs in newFile() ,rather than the constructor,because
we don’t want to consume numbers when we call open() to open an existing
document in a newly created Editor .SincedocumentNumber is declared static, it
is shared across all Editor instances.
bool Editor::open()
{    QString fileName =            QFileDialog::getOpenFileName(".", fileFilters, this);    if (fileName.isEmpty())        return false;
    return openFile(fileName);
}
Theopen() function tries to open an existing ﬁle using openFile() .
bool Editor::save(){    if (isUntitled) {        return saveAs();    } else {        saveFile(curFile);        return true;    }}
Thesave() function uses the isUntitled variable to determine whether it
should call saveFile() orsaveAs() .
void Editor::closeEvent(QCloseEvent *event)
{    if (maybeSave())        event->accept();    else        event->ignore();}
ThecloseEvent() function is reimplemented to allow the user to save unsaved
changes. The logic is coded in the maybeSave() function, which pops up a
message box that asks, “Do you want to save your changes?” If maybeSave()
160 6. Layout Management
returns true,weaccept the close event; otherwise, we “ignore” it and leave the
window unaffected by it.
void Editor::setCurrentFile(const QString &fileName)
{    curFile = fileName;    setCaption(strippedName(curFile));    isUntitled = false;    setModified(false);}
ThesetCurrentFile() function is called from openFile() andsaveFile() to up-
date the curFile andisUntitled variables, to set the window caption, and to
set the editor’s “modiﬁed” ﬂag to false .TheEditor class inherits setModified()
andisModified() fromQTextEdit ,soitdoesn’t need to maintain its own modi-
ﬁed ﬂag. Whenever the user modiﬁes the text in the editor, QTextEdit emits the
modificationChanged() signal and sets its internal modiﬁed ﬂag to true.
QSize Editor::sizeHint() const
{    return QSize(72 * fontMetrics().width(’x’),                 25 * fontMetrics().lineSpacing());}
ThesizeHint() function returns a size based on the width of the letter ‘x’ and
the height of a text line. QWorkspace uses the size hint to give an initial size to
the window.
Finally, here’s the Editor application’s main.cpp ﬁle:
#include <qapplication.h>
#include "mainwindow.h"int main(int argc, char *argv[])
{    QApplication app(argc, argv);    MainWindow mainWin;    app.setMainWidget(&mainWin);
    if (argc > 1) {
        for (int i = 1; i < argc; ++i)            mainWin.openFile(argv[i]);    } else {        mainWin.newFile();    }
    mainWin.show();
    return app.exec();}
If the user speciﬁes any ﬁles on the command line, we attempt to load them.
Otherwise, we start with an empty document. Qt-speciﬁc command-line op-tions, such as
-style and-font ,are automatically removed from the argument
list by the QApplication constructor. So if we write
Multiple Document Interface 161
editor -style=motif readme.txt
on the command line, the Editor application starts up with one document,
readme.txt .
MDI is one way of handling multiple documents simultaneously. Another
approach is to use multiple top-level windows. This approach is covered in the“Multiple Documents” section of Chapter 3.

77
Event Processing•Reimplementing Event
Handlers
•Installing Event Filters
•Staying Responsive During
Intensive Processing
GUI applicationsare event-driven: Everything that happens once the applica-
tion has started is the result of an event. When we program with Qt, we sel-dom need to think about events, because Qt widgets emit signals when some-thing signiﬁcant occurs. Events become useful when we write our own customwidgets or when we want to modify the behavior of existing Qt widgets.
In this chapter,we will explore Qt’s event model. We will see how to handle the
different types of events in Qt. We will also look at how to use event ﬁlters tomonitor events before they reach their destinations. Finally, we will examineQt’s event loop, reviewing how to keep the user interface responsive duringintensive processing.
Reimplementing Event Handlers
Events are generated by the window system or by Qt in response to variousoccurrences. When the user presses or releases a key or mouse button, a keyor mouse event is generated. When a window is moved to reveal a windowthat was underneath, a paint event is generated to tell the newly visiblewindow that it needs to repaint itself. An event is also generated whenever awidget gains or loses keyboard focus. Most events are generated in responseto user actions, but some, like timer events, are generated independently bythe system.
Events should not be confused with signals. Signals are useful when using a
widget, whereas events are useful when implementing awidget. For example,
when we are using
QPushButton ,weare more interested in its clicked() signal
than in the low-level mouse or key events that caused the signal to be emitted.But if we are implementing a class like
QPushButton ,weneed to write code to
handle mouse and key events and emit the clicked() signal when necessary.
163
164 7. Event Processing
Events are notiﬁed to objects through their event() function, inherited from
QObject .Theevent() implementation in QWidget forwards the most common
types of events to speciﬁc event handlers,such as mousePressEvent() ,keyPress-
Event() ,andpaintEvent() ,and ignores other kinds of events.
Wehave already seen many event handlers when implementing MainWindow ,
IconEditor ,Plotter ,ImageEditor ,andEditor in the previous chapters. There
are many other types of events, listed in the QEvent reference documentation,
and it is also possible to create custom event types and dispatch customevents ourselves. Custom events are particularly useful in multithreadedapplications, so they are discussed in Chapter 17 (Multithreading). Here, wewill review two event types that deserve more explanation: key events andtimer events.
Keyevents are handled by reimplementing
keyPressEvent() andkeyRelease-
Event() .ThePlotter widget reimplements keyPressEvent() .Normally, we only
need to reimplement keyPressEvent() since the only keys for which release is
important are the modiﬁer keys Ctrl,Shift,and Alt,and these can be checked for
in akeyPressEvent() usingstate() .For example, if we were implementing a
CodeEditor widget, its stripped-down keyPressEvent() that distinguishes be-
tween Home and Ctrl+Home would look like this:
void CodeEditor::keyPressEvent(QKeyEvent *event)
{    switch (event->key()) {    case Key_Home:        if (event->state() & ControlButton)            goToBeginningOfDocument();        else            goToBeginningOfLine();        break;    case Key_End:
···
    default:
        QWidget::keyPressEvent(event);    }}
The Taband Backtab (Shift+Tab )keys are special cases. They are handled by
QWidget::event() before it calls keyPressEvent() ,with the semantic of passing
the focus to the next or previous widget in the focus chain. This behavior isusually what we want, but in a
CodeEditor widget, we might prefer to make Tab
indent a line. The event() reimplementation would then look like this:
bool CodeEditor::event(QEvent *event)
{    if (event->type() == QEvent::KeyPress) {        QKeyEvent *keyEvent = (QKeyEvent *)event;        if (keyEvent->key() == Key_Tab) {            insertAtCurrentPosition(’\t’);            return true;        }    }
Reimplementing Event Handlers 165
    return QWidget::event(event);
}
If the event is a key press, we cast the QEvent object to a QKeyEvent and check
which key was pressed. If the key is Tab,wedosome processing and return
true to tell Qt that we have handled the event. If we returned false ,Qtwould
propagate the event to the parent widget.
Ahigher-level approach for implementing key bindings is to use a QAction .F o r
example, if goToBeginningOfLine() andgoToBeginningOfDocument() are public
slots in the CodeEditor widget, and the CodeEditor is used as the central widget
in aMainWindow class, we could add the key bindings with the following code:
MainWindow::MainWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name){    editor = new CodeEditor(this);    setCentralWidget(editor);
    goToBeginningOfLineAct =
            new QAction(tr("Go to Beginning of Line"),                        tr("Home"), this);    connect(goToBeginningOfLineAct, SIGNAL(activated()),            editor, SLOT(goToBeginningOfLine()));
    goToBeginningOfDocumentAct =
            new QAction(tr("Go to Beginning of Document"),                        tr("Ctrl+Home"), this);    connect(goToBeginningOfDocumentAct, SIGNAL(activated()),            editor, SLOT(goToBeginningOfDocument()));
···
}
This makes it easy to add the commands to a menu or a toolbar, as we saw
in Chapter 3. If the commands don’t appear in the user interface, the QAction
objects could be replaced with a QAccel object, the class used by QAction
internally to support key bindings.
The choice between reimplementing keyPressEvent() and using QAction (or
QAccel )issimilar to that between reimplementing resizeEvent() and using
aQLayout subclass. If we are implementing a custom widget by subclassing
QWidget ,it’s straightforward to reimplement a few more event handlers and
hard-code the behavior there. But if we are merely using a widget, the higher-level interfaces provided by
QAction andQLayout are more convenient.
Another common type of event is the timer event. While most types of events
occur as a result of a user action, timer events allow applications to performprocessing at regular time intervals. Timer events can be used to implementblinking cursors and other animations, or simply to refresh the display.
Todemonstrate timer events, we will implement a
Ticker widget. This widget
shows a text banner that scrolls left by one pixel every 30 milliseconds. If thewidget is wider than the text, the text is repeated as often as necessary to ﬁllthe entire width of the widget.
166 7. Event Processing
Figure 7.1. TheTicker widget
Here’s the header ﬁle:
#ifndef TICKER_H
#define TICKER_H
#include <qwidget.h>class Ticker : public QWidget
{    Q_OBJECT    Q_PROPERTY(QString text READ text WRITE setText)
public:
    Ticker(QWidget *parent = 0, const char *name = 0);
    void setText(const QString &newText);
    QString text() const { return myText; }    QSize sizeHint() const;
protected:
    void paintEvent(QPaintEvent *event);    void timerEvent(QTimerEvent *event);    void showEvent(QShowEvent *event);    void hideEvent(QHideEvent *event);
private:
    QString myText;    int offset;    int myTimerId;};
#endif
Wereimplement four event handlers in Ticker ,three of which we have not
seen before: timerEvent() ,showEvent() ,andhideEvent() .
Now let’s review the implementation:
#include <qpainter.h>
#include "ticker.h"Ticker::Ticker(QWidget *parent, const char *name)
    : QWidget(parent, name){    offset = 0;    myTimerId = 0;}
The constructor initializes the offset variable to 0. The xcoordinate at which
the text is drawn is derived from the offset value.
Reimplementing Event Handlers 167
void Ticker::setText(const QString &newText)
{    myText = newText;    update();    updateGeometry();}
ThesetText() function sets the text to display. It calls update() to force a
repaint and updateGeometry() to notify any layout manager responsible for the
Ticker widget about a size hint change.
QSize Ticker::sizeHint() const
{    return fontMetrics().size(0, text());}
ThesizeHint() function returns the space needed by the text as the widget’s
ideal size. The QWidget::fontMetrics() function returns a QFontMetrics object
that can be queried to obtain information relating to the widget’s font. In thiscase, we ask for the size required by the given text.
void Ticker::paintEvent(QPaintEvent *)
{    QPainter painter(this);
    int textWidth = fontMetrics().width(text());
    if (textWidth < 1)        return;    int x = -offset;    while (x < width()) {        painter.drawText(x, 0, textWidth, height(),                         AlignLeft | AlignVCenter, text());        x += textWidth;    }}
ThepaintEvent() function draws the text using QPainter::drawText() .Ituses
fontMetrics() to ascertain how much horizontal space the text requires, and
then draws the text as many times as necessary to ﬁll the entire width of thewidget, taking
offset into account.
void Ticker::showEvent(QShowEvent *)
{    myTimerId = startTimer(30);}
TheshowEvent() function starts a timer. The call to QObject::startTimer()
returns an ID number, which we can use later to identify the timer. QObject
supports multiple independent timers, each with its own time interval. After
the call to startTimer() ,Qtwill generate a timer event approximately every
30 milliseconds; the accuracy depends on the underlying operating system.
Wecould have called startTimer() in theTicker constructor, but we save
some resources by having Qt generate timer events only when the widget isactually visible.
168 7. Event Processing
void Ticker::timerEvent(QTimerEvent *event)
{    if (event->timerId() == myTimerId) {        ++offset;        if (offset >= fontMetrics().width(text()))            offset = 0;        scroll(-1, 0);    } else {        QWidget::timerEvent(event);    }}
ThetimerEvent() function is called at intervals by the system. It increments
offset by 1 to simulate movement, wrapping at the width of the text. Then it
scrolls the contents of the widget one pixel to the left using QWidget::scroll() .
It would have been sufﬁcient to call update() instead of scroll() ,butscroll()
is more efﬁcient and prevents ﬂicker, because it simply moves the existing
pixels on screen and only generates a paint event for the widget’s newlyrevealed area (a 1-pixel-wide strip in this case).
If the timer event isn’t for the timer we are interested in, we pass it on to our
base class.
void Ticker::hideEvent(QHideEvent *)
{    killTimer(myTimerId);}
ThehideEvent() function calls QObject::killTimer() to stop the timer.
Timer events are low-level, and if we need multiple timers, it can become
cumbersome to keep track of all the timer IDs. In such situations, it is usuallyeasier to create a
QTimer object for each timer. QTimer emits the timeout()
signal at each time interval. QTimer also provides a convenient interface for
single-shot timers (timers that time out just once).
Installing Event Filters
One really powerful feature of Qt’s event model is that a QObject instance
can be set to monitor the events of another QObject instance before the latter
object even sees them.
Let’s suppose that we have a CustomerInfoDialog widget composed of several
QLineEdit sand that we want to use the Space key to move the focus to the next
QLineEdit .This non-standard behavior might be appropriate for an in-house
application whose users are trained in its use. A straightforward solution isto subclass
QLineEdit and reimplement keyPressEvent() to callfocusNextPrev-
Child() ,like this:
void MyLineEdit::keyPressEvent(QKeyEvent *event)
{    if (event->key() == Key_Space)        focusNextPrevChild(true);
Installing Event Filters 169
    else
        QLineEdit::keyPressEvent(event);}
This approach has many disadvantages. Because MyLineEdit isn’t a standard
Qt class, it must be integrated with Qt Designer if we want to design forms
that make use of it. Also, if we use several different kinds of widgets in theform (for example,
QComboBox es andQSpinBox es), we must also subclass them
to make them exhibit the same behavior and integrate them with Qt Designer
as well.
Abetter solution is to make CustomerInfoDialog monitor its child widgets’ key
press events and implement the required behavior in the monitoring code.This can be achieved using event ﬁlters. Setting up an event ﬁlter involvestwo steps:
1. Register the monitoring object with the target object by calling
install-
EventFilter() on the target.
2. Handle the target object’s events in the monitor’s eventFilter() function.
Agood place to register the monitoring object is in the CustomerInfoDialog con-
structor:
CustomerInfoDialog::CustomerInfoDialog(QWidget *parent,
                                       const char *name)    : QDialog(parent, name){
···
    firstNameEdit->installEventFilter(this);
    lastNameEdit->installEventFilter(this);    cityEdit->installEventFilter(this);    phoneNumberEdit->installEventFilter(this);}
Once the event ﬁlter is registered, the events that are sent to the firstName-
Edit,lastNameEdit ,cityEdit ,andphoneNumberEdit widgets are ﬁrst sent to the
CustomerInfoDialog ’seventFilter() function before they are sent on to their in-
tended destination. (If multiple event ﬁlters are installed on the same object,the ﬁlters are activated in turn, from the most recently installed back to theﬁrst installed.)
Here’s the
eventFilter() function that receives the events:
bool CustomerInfoDialog::eventFilter(QObject *target, QEvent *event)
{    if (target == firstNameEdit || target == lastNameEdit            || target == cityEdit || target == phoneNumberEdit) {        if (event->type() == QEvent::KeyPress) {            QKeyEvent *keyEvent = (QKeyEvent *)event;            if (keyEvent->key() == Key_Space) {                focusNextPrevChild(true);                return true;            }        }
170 7. Event Processing
    }
    return QDialog::eventFilter(target, event);}
First, we check to see if the target widget is one of the QLineEdit s.It’s easy to
forget that the base class, QDialog ,might monitor some widgets of its own. (In
Qt 3.2, this is not the case for QDialog .However, other Qt widget classes, such
asQMainWindow ,domonitor some of their child widgets for various reasons.)
If the event is a key press, we cast it to QKeyEvent and check which key is
pressed. If the pressed key is Space ,wecallfocusNextPrevChild() to pass focus
on to the next widget in the focus chain, and we return true to tell Qt that
we have handled the event. If we returned false ,Qtwould send the event
to its intended target, resulting in a spurious space being inserted into the
QLineEdit .
If the event isn’t a Space key press, we pass control to the base class’s imple-
mentation of eventFilter() .
Qt offers ﬁve levels at which events can be processed and ﬁltered:
1. We can reimplement a speciﬁc event handler.
Reimplementing event handlers such as mousePressEvent() ,keyPress-
Event() ,andpaintEvent() is by far the most common way to process
events. We have already seen many examples of this.
2. We can reimplement QObject::event().
By reimplementing the event() function, we can process events before
they reach the speciﬁc event handlers. This approach is mostly needed tooverride the default meaning of the
Tabkey, as shown earlier (p.164).This
is also used to handle rare types of events for which no speciﬁc event han-dler exists (for example,
LayoutDirectionChange ). When we reimplement
event() ,weneed to call the base class’s event() function for handling the
cases we don’t explicitly handle.
3. We can install an event ﬁlter on a single QObject.
Once an object has been registered using installEventFilter() ,all the
events for the target object are ﬁrst sent to the monitoring object’s event-
Filter() function. We have used this approach to handle Space key press-
es in the CustomerInfoDialog example above.
4. We can install an event ﬁlter on the QApplication object.
Once an event ﬁlter has been registered for qApp (the unique QApplication
object), every event for every object in the application is sent to the event-
Filter() function before it is sent to any other event ﬁlter. This approach
is mostly useful for debugging and for hiding Easter eggs. It can also beused to handle mouse events sent to disabled widgets, which
QApplication
normally discards.
Installing Event Filters 171
5. We can subclass QApplication and reimplement notify().
Qt calls QApplication::notify() to send out an event. Reimplementing
this function is the only way to get all the events, before any event ﬁltersget the opportunity to look at them. Event ﬁlters are generally moreuseful, because there can be any number of concurrent event ﬁlters, butonly one
notify() function.
Many event types, including mouse and key events, can be propagated. If
the event has not been handled on the way to its target object or by the targetobject itself, the whole event processing process is repeated, but this time withthe target object’s parent as the new target. This continues, going from parentto parent, until either the event is handled or the top-level object is reached.
Caption 
QDialog
QGroupBox
QCheckBox QCheckBox
QCheckBox QCheckBox 
Figure 7.2. Event propagation in a dialog
Figure 7.2 shows how a key press event is propagated from child to parent in
adialog. When the user presses a key, the event is ﬁrst sent to the widget that
has focus, in this case the bottom-right QCheckBox .I ftheQCheckBox doesn’t han-
dle the event, Qt sends it to the QGroupBox ,and ﬁnally to the QDialog object.
Staying Responsive During Intensive Processing
When we call QApplication::exec() ,westart Qt’s event loop. Qt issues a few
events on startup to show and paint the widgets. After that, the event loop isrunning, constantly checking to see if any events have occurred and dispatch-ing these events to
QObject sinthe application.
While one event is being processed, additional events may be generated and
appended to Qt’s event queue. If we spend too much time processing a par-ticular event, the user interface will become unresponsive. For example, anyevents generated by the window system while the application is saving a ﬁleto disk will not be processed until the ﬁle is saved. During the save, the appli-cation will not respond to requests from the window system to repaint itself.
One solution is to use multiple threads: one thread for the application’s user
interface and another thread to perform ﬁle saving (or any other time-consum-
172 7. Event Processing
ing operation). This way, the application’s user interface will stay responsive
while the ﬁle is being saved. We will see how to achieve this in Chapter 17.
Asimpler solution is to make frequent calls to QApplication::processEvents()
in the ﬁle saving code. This function tells Qt to process any pending events,
and then returns control to the caller. In fact, QApplication::exec() is little
more than a while loop around a processEvents() function call.
Here’s an example of how we can keep the user interface responsive using
processEvents() ,based on the ﬁle saving code for Spreadsheet (p. 77):
bool Spreadsheet::writeFile(const QString &fileName)
{    QFile file(fileName);
···
    for (int row = 0; row < NumRows; ++row) {
        for (int col = 0; col < NumCols; ++col) {            QString str = formula(row, col);            if (!str.isEmpty())                out << (Q_UINT16)row << (Q_UINT16)col << str;        }        qApp->processEvents();    }    return true;}
One danger with this approach is that the user might close the main window
while the application is still saving, or even click File|Save asecond time,
resulting in undeﬁned behavior. The easiest solution to this problem is toreplace the
qApp->processEvents();
call with a
qApp->eventLoop()->processEvents(QEventLoop::ExcludeUserInput);
call, which tells Qt to ignore mouse and key events.
Often, we want to show a QProgressDialog while a long running operation is
taking place. QProgressDialog has a progress bar that keeps the user informed
about the progress being made by the application. QProgressDialog also
provides a Cancel button that allows the user to abort the operation. Here’s
the code for saving a Spreadsheet ﬁle using this approach:
bool Spreadsheet::writeFile(const QString &fileName)
{    QFile file(fileName);
···
    QProgressDialog progress(tr("Saving file..."), tr("Cancel"),
                             NumRows);    progress.setModal(true);    for (int row = 0; row < NumRows; ++row) {        progress.setProgress(row);        qApp->processEvents();
Staying Responsive During Intensive Processing 173
        if (progress.wasCanceled()) {
            file.remove();            return false;        }
        for (int col = 0; col < NumCols; ++col) {
            QString str = formula(row, col);            if (!str.isEmpty())                out << (Q_UINT16)row << (Q_UINT16)col << str;        }    }    return true;}
Wecreate a QProgressDialog withNumRows as the total number of steps. Then,
for each row, we call setProgress() to update the progress bar. QProgressDialog
automatically computes a percentage by dividing the current progress valueby the total number of steps. We call
QApplication::processEvents() to process
any repaint events or any user clicks or key presses (for example, to allow theuser to click
Cancel ). If the user clicks Cancel ,weabort the save and remove
the ﬁle.
Wedon’t call show() on theQProgressDialog because progress dialogs do that
for themselves. If the operation turns out to be short, presumably because theﬁle to save is small or because the machine is fast,
QProgressDialog will detect
this and will not show itself at all.
There is a completely different way of dealing with long running operations.
Instead of performing the processing when the user requests, we can deferthe processing until the application is idle. This can work if the processingcan be safely interrupted and resumed, since we cannot predict how long theapplication will be idle.
In Qt, this approach can be implemented by using a special kind of timer: a
0-millisecond timer. These timers time out whenever there are no pendingevents. Here’s an example
timerEvent() implementation that shows the idle
processing approach:
void Spreadsheet::timerEvent(QTimerEvent *event)
{    if (event->timerId() == myTimerId) {        while (step < MaxStep && !qApp->hasPendingEvents()) {            performStep(step);            ++step;        }    } else {        QTable::timerEvent(event);    }}
IfhasPendingEvents() returns true,westop processing and give control back to
Qt. The processing will resume when Qt has handled all its pending events.

88
2D and 3D Graphics•Painting with QPainter
•Graphics with QCanvas
•Printing
•Graphics with OpenGL
In this chapter, we will explore Qt’s graphics capabilities. The cornerstone of
Qt’s 2D drawing engine is QPainter ,which can be used to draw on a widget on
the screen, on an off-screen pixmap, or on a physical printer. Qt also includesa
QCanvas class that provides a higher-level way of doing graphics, using an
item-based approach that can efﬁciently handle thousands and thousands ofitems of various shapes. Many predeﬁned items are provided, and it is easyto create custom canvas items.
An alternative to
QPainter andQCanvas is to use the OpenGL library. OpenGL
is a standard library for drawing 3D graphics, but it can also be used for draw-ing 2D graphics. It is very easy to integrate OpenGL code into Qt applications,as we will demonstrate.
Painting with QPainter
AQPainter can be used to draw on a “paint device”, such as a widget or a pix-
map.QPainter is useful when we write custom widgets or custom item classes
with their own look and feel. QPainter is also the class to use for printing; this
will be explained in detail later in the chapter.
QPainter can draw geometric shapes: points, lines, rectangles, ellipses, arcs,
chords, pie segments, polygons, and cubic Bézier curves. It can also drawpixmaps, images, and text.
When we pass a paint device to the
QPainter constructor, QPainter adopts some
settings from the device and initializes other settings to default values. Thesesettings inﬂuence the way drawing is performed. The three most importantare the painter’s pen, brush, and font:
•The penis used for drawing lines and geometric shape boundaries. It
consists of a color, a width, a line style, a cap style, and a join style.
175
176 8. 2D and 3D Graphics
drawLine() drawPoints() drawLineSegments()
drawCubicBezier() drawPolyline() drawPolygon()
drawRect() drawRoundRect() drawEllipse()
drawArc() drawChord() drawPie()(x1,y1)
(x2,y2)p2p3
p1p4p2p3
p1p4
p2p3
p1p4p2p3
p1p4p2p3
p1p4
(x, y) (x, y) (x, y)
h
wh
wh
w+
(x, y)
h
w+βα(x, y)
h
w+βα(x, y)
h
w+βα
Figure 8.1. QPainter functions for drawing geometric shapes
line width
1 2 3 4
NoPen
SolidLine
DashLine
DotLine
DashDotLine
DashDotDotLine
Figure 8.2. Penstyles
•Thebrush is the pattern used for ﬁlling geometric shapes. It consists of
acolor and a style.
•Thefontis used for drawing text. A font has many attributes, including
afamily and a point size.
These settings can be modiﬁed by calling one of setPen() ,setBrush() ,and
setFont() with aQPen,QBrush ,o rQFont object.
Painting with QPainter 177
FlatCap SquareCap RoundCap
MiterJoin BevelJoin RoundJoin
Figure 8.3. Cap and join styles
SolidPattern Dense1Pattern Dense2Pattern Dense3Pattern Dense4Pattern
Dense5Pattern Dense6Pattern Dense7Pattern HorPattern VerPattern
CrossPattern BDiagPattern FDiagPattern DiagCross-
PatternNoBrush
Figure 8.4. Brush styles
Here’s the code to draw the ellipse shown in Figure 8.5 (a):
QPainter painter(this);
painter.setPen(QPen(black, 3, DashDotLine));painter.setBrush(QBrush(red, SolidPattern));painter.drawEllipse(20, 20, 100, 60);
Here’s the code to draw the pie segment shown in Figure 8.5 (b):
QPainter painter(this);painter.setPen(QPen(black, 5, SolidLine));painter.setBrush(QBrush(red, DiagCrossPattern));painter.drawPie(20, 20, 100, 60, 60 * 16, 270 * 16);
The last two arguments to drawPie() are expressed in sixteenths of a degree.
178 8. 2D and 3D Graphics
(a) An ellipse (b) A pie segment (c) A Bézier curve
Figure 8.5. Geometric shape examples
Here’s the code to draw the cubic Bézier curve shown in Figure 8.5 (c):
QPainter painter(this);
QPointArray points(4);points[0] = QPoint(20, 80);points[1] = QPoint(50, 20);points[2] = QPoint(80, 20);points[3] = QPoint(120, 80);painter.setPen(QPen(black, 3, SolidLine));painter.drawCubicBezier(points);
The current state of a painter can be saved on a stack by calling save() and
restored later on by calling restore() .This can be useful if we want to tem-
porarily change some painter settings and then reset them to their previousvalues.
The other settings that control a painter, in addition to the pen, brush, and
font, are:
•Thebackground color is used to ﬁll the background of geometric shapes
(beneath the brush pattern), text, or bitmaps when the background mode
is
OpaqueMode (the default is TransparentMode ).
•Theraster operation speciﬁes how the newly drawn pixels should interact
with the pixels already present on the paint device. The default is Copy-
ROP,which means that the new pixels are simply copied onto the device,
ignoring the previous pixel value. Other raster operations include XorROP ,
NotROP ,AndROP ,andNotAndROP .
•The brush origin is the starting point for brush patterns, normally the
top-left corner of the widget.
•The clip region is the area of the device that can be painted. Drawing
operations performed outside the clip region are ignored.
•Theviewport ,window ,andworld matrix determine how logical QPainter
coordinates map to physical paint device coordinates. By default, these
are set up so that the logical and physical coordinate systems coincide.
Let’s take a closer look at the coordinate system deﬁned by the viewport,
window, and world matrix. (In this context, the term “window” does not referto a window in the sense of a top-level widget, and the “viewport” has nothingto do with
QScrollView ’sviewport.)
Painting with QPainter 179
The viewport and the window are tightly bound. The viewport is an arbi-
trary rectangle speciﬁed in physical coordinates. The window speciﬁes thesame rectangle, but in logical coordinates. When we do the painting, wespecify points in logical coordinates, and those coordinates are convertedinto physical coordinates in a linear algebraic manner, based on the currentwindow–viewport settings.
By default, the viewport and the window are set to the device’s rectangle. For
example, if the device is a 320 × 200 widget, both the viewport and the windoware the same 320 × 200 rectangle with its top-left corner at position (0, 0). Inthis case, the logical and physical coordinate systems are the same.
The window–viewport mechanism is useful to make the drawing code inde-
pendent of the size or resolution of the paint device. We can always do thearithmetic to map logical coordinates to physical coordinates ourselves,but it’susually simpler to let
QPainter do the work. For example,if we want the logical
coordinates to extend from ( +--50,+--50) to (+50, +50), with (0, 0) in the middle,
we can set the window as follows:
painter.setWindow(QRect(-50, -50, 100, 100));
The ( +--50,+--50) pair speciﬁes the origin, and the (100, 100) pair speciﬁes the
width and height. This means that the logical coordinates ( +--50,+--50) now
correspond to the physical coordinates (0, 0), and the logical coordinates(+50, +50) correspond to the physical coordinates (320, 200). In this example,as is often the case, we don’t need to change the viewport.
(+--50,+--50)
(+--30,+--20)
(+10, +20)
(+50, +50)±(0, 0)
(64, 60)
(192, 140)
(320, 200)
window viewport
Figure 8.6. Converting logical coordinates into physical coordinates
Now comes the world matrix. The world matrix is a transformation matrix
that is applied in addition to the window–viewport conversion. It allows us totranslate, scale, rotate, or shear the items we are drawing. For example, if wewanted to draw text at a 45° angle, we would use this code:
QWMatrix matrix;
matrix.rotate(45.0);painter.setWorldMatrix(matrix);painter.drawText(rect, AlignCenter, tr("Revenue"));
The logical coordinates we pass to drawText() are transformed by the world
matrix, then mapped to physical coordinates using the window–viewportsettings.
180 8. 2D and 3D Graphics
If we specify multiple transformations, they are applied in the order in
which they are given. For example, if we want to use the point (10, 20) as therotation’s pivot point, we can do so by translating the window, performing therotation, and then translating the window back to its original position:
QWMatrix matrix;
matrix.translate(-10.0, -20.0);matrix.rotate(45.0);matrix.translate(+10.0, +20.0);painter.setWorldMatrix(matrix);painter.drawText(rect, AlignCenter, tr("Revenue"));
Asimpler way to specify transformations is to use QPainter ’stranslate() ,
scale() ,rotate() ,andshear() convenience functions:
painter.translate(-10.0, -20.0);
painter.rotate(45.0);painter.translate(+10.0, +20.0);painter.drawText(rect, AlignCenter, tr("Revenue"));
But if we want to use the same transformations repeatedly, it’s faster to store
them in a QWMatrix object and set the world matrix on the painter whenever
the transformations are needed.
If we want to just save the world matrix and restore it later, we can use
saveWorldMatrix() andrestoreWorldMatrix() .
Figure 8.7. TheOvenTimer widget
Toillustrate painter transformations, we will review the code of the OvenTimer
widget shown in Figure 8.7.The OvenTimer widget is modeled after the physical
oven timers that were used before it was common to have ovens with clocksbuilt-in. The user can click a notch to set the duration. The wheel automati-cally turns counterclockwise until 0 is reached, at which point
OvenTimer emits
thetimeout() signal.
class OvenTimer : public QWidget
{    Q_OBJECTpublic:    OvenTimer(QWidget *parent, const char *name = 0);
    void setDuration(int secs);
Painting with QPainter 181
    int duration() const;
    void draw(QPainter *painter);
signals:
    void timeout();
protected:
    void paintEvent(QPaintEvent *event);    void mousePressEvent(QMouseEvent *event);
private:
    QDateTime finishTime;    QTimer *updateTimer;    QTimer *finishTimer;};
TheOvenTimer class inherits QWidget and reimplements two virtual functions:
paintEvent() andmousePressEvent() .
#include <qpainter.h>#include <qpixmap.h>#include <qtimer.h>
#include <cmath>
using namespace std;
#include "oventimer.h"const double DegreesPerMinute = 7.0;
const double DegreesPerSecond = DegreesPerMinute / 60;const int MaxMinutes = 45;const int MaxSeconds = MaxMinutes * 60;const int UpdateInterval = 10;
OvenTimer::OvenTimer(QWidget *parent, const char *name)
    : QWidget(parent, name){    finishTime = QDateTime::currentDateTime();    updateTimer = new QTimer(this);    finishTimer = new QTimer(this);    connect(updateTimer, SIGNAL(timeout()), this, SLOT(update()));    connect(finishTimer, SIGNAL(timeout()), this, SIGNAL(timeout()));}
In the constructor, we create two QTimer objects: updateTimer is used to refresh
the appearance of the widget at regular intervals, and finishTimer emits the
widget’s timeout() signal when the timer reaches 0.
void OvenTimer::setDuration(int secs)
{    if (secs > MaxSeconds)        secs = MaxSeconds;    finishTime = QDateTime::currentDateTime().addSecs(secs);    updateTimer->start(UpdateInterval * 1000, false);    finishTimer->start(secs * 1000, true);    update();}
182 8. 2D and 3D Graphics
ThesetDuration() function sets the duration of the oven timer to the given
number of seconds. The false argument passed in the updateTimer ’sstart()
call tells Qt that this a repeating timer that will time out every 10 seconds.The
finishTimer only needs to timeout once, so we use a true argument to in-
dicate that it is a single-shot timer. We compute the ﬁnish time by adding theduration in seconds to the current time, obtained from
QDateTime::current-
DateTime() ,and store it in the finishTime private variable.
ThefinishTime variable is of type QDateTime ,the Qt data type for storing a
date and a time. The date component of the QDateTime is important in situa-
tions where the current time is before midnight and the ﬁnish time is aftermidnight.
int OvenTimer::duration() const
{    int secs = QDateTime::currentDateTime().secsTo(finishTime);    if (secs < 0)        secs = 0;    return secs;}
Theduration() function returns the number of seconds left before the timer is
due to ﬁnish.
void OvenTimer::mousePressEvent(QMouseEvent *event)
{    QPoint point = event->pos() - rect().center();    double theta = atan2(-(double)point.x(), -(double)point.y())                   * 180 / 3.14159265359;    setDuration((int)(duration() + theta / DegreesPerSecond));    update();}
If the user clicks the widget, we ﬁnd the closest notch using a subtle but
effective mathematical formula, and we use the result to set the new duration.Then we schedule a repaint. The notch that the user clicked will now be at thetop and will move counterclockwise as time passes until 0 is reached.
void OvenTimer::paintEvent(QPaintEvent *)
{    QPainter painter(this);    int side = QMIN(width(), height());    painter.setViewport((width() - side) / 2, (height() - side) / 2,                        side, side);    painter.setWindow(-50, -50, 100, 100);    draw(&painter);}
InpaintEvent() ,weset the viewport to be the largest square area that ﬁts in-
side the widget, and we set the window to be the rectangle ( +--50,+--50, 100, 100),
that is, the 100 × 100 rectangle extending from ( +--50,+--50) to (+50, +50). The
QMIN() macro returns the lowest of its two arguments.
Painting with QPainter 183
Figure 8.8. TheOvenTimer widget at three different sizes
If we had not set the viewport to be a square, the oven timer would be an
ellipse when the widget is resized to a non-square rectangle. In general, if wewant to avoid such deformations, we must set the viewport and the window to
rectangles with the same aspect ratio.
The window setting of ( +--50,+--50, 100, 100) was also chosen bearing these
issues in mind:
•
QPainter ’sdraw functions take intcoordinate values. If we choose a
window that is too small, we might not be able to specify all the points weneed as integers.
•Ifweuse a large window and use
drawText() to draw some text, we will
need a larger font to compensate.
This makes ( +--50,+--50, 100, 100) a better choice than, say, ( +--5,+--5, 10, 10) or
(+--2000, +--2000, 4000, 4000).
Now let’s look at the drawing code:
void OvenTimer::draw(QPainter *painter)
{    static const QCOORD triangle[3][2] = {        { -2, -49 }, { +2, -49 }, { 0, -47 }    };    QPen thickPen(colorGroup().foreground(), 2);    QPen thinPen(colorGroup().foreground(), 1);
    painter->setPen(thinPen);
    painter->setBrush(colorGroup().foreground());    painter->drawConvexPolygon(QPointArray(3, &triangle[0][0]));
Westart by drawing the tiny triangle that marks the 0 position at the top
of the widget. The triangle is speciﬁed by three hard-coded coordinates, andwe use
drawConvexPolygon() to render it. We could have used drawPolygon() ,
but when we know the polygon we are drawing is convex, we can save somemicroseconds by calling
drawConvexPolygon() .
184 8. 2D and 3D Graphics
What is so convenient about the window–viewport mechanism is that we can
hard-code the coordinates we use in the draw commands and still get goodresizing behavior. Nor do we have to worry about non-square widgets; this ishandled by setting the viewport appropriately.
    painter->setPen(thickPen);
    painter->setBrush(colorGroup().light());    painter->drawEllipse(-46, -46, 92, 92);    painter->setBrush(colorGroup().mid());    painter->drawEllipse(-20, -20, 40, 40);    painter->drawEllipse(-15, -15, 30, 30);
Wedraw the outer circle and the two inner circles. The outer circle is ﬁlled
with the palette’s “light” component (typically white), while the two innercircles are ﬁlled with the “mid” component (typically medium gray).
    int secs = duration();
    painter->rotate(secs * DegreesPerSecond);    painter->drawRect(-8, -25, 16, 50);
    for (int i = 0; i <= MaxMinutes; ++i) {
        if (i % 5 == 0) {            painter->setPen(thickPen);            painter->drawLine(0, -41, 0, -44);            painter->drawText(-15, -41, 30, 25,                              AlignHCenter | AlignTop,                              QString::number(i));        } else {            painter->setPen(thinPen);            painter->drawLine(0, -42, 0, -44);        }        painter->rotate(-DegreesPerMinute);    }}
Wedraw the knob, the notches, and at every ﬁfth notch we draw the number
of minutes. We call rotate() to rotate the painter’s coordinate system. In
the old coordinate system, the 0-minute mark was on top; now, the 0-minutemark is moved to the place that’s appropriate for the time left. We draw therectangular knob handle after the rotation, since its orientation depends onthe rotation angle.
In the
forloop, we draw the tick marks along the outer circle’s edge and
the numbers for each multiple of 5 minutes. The text is put in an invisiblerectangle underneath the tick mark. At the end of one iteration, we rotate thepainter clockwise by 7°, the amount corresponding to one minute. The nexttime we draw a tick mark, it will be at a different position around the circle,although the coordinates we pass to the
drawLine() anddrawText() calls are
always the same.
Another way of implementing an oven timer would have been to compute the
(x,y)positions ourselves, using sin() andcos() to ﬁnd the positions along the
Painting with QPainter 185
circle. But then we would still need to use a translation and a rotation to draw
the text at an angle.
There is one issue left: ﬂicker. Every ten seconds, we repaint the widget
entirely,causing it to ﬂicker each time. The solution is to add double buffering.This can be done by passing the
WNoAutoErase to the base class constructor and
by replacing the paintEvent() function shown earlier with this one:
void OvenTimer::paintEvent(QPaintEvent *event)
{    static QPixmap pixmap;    QRect rect = event->rect();
    QSize newSize = rect.size().expandedTo(pixmap.size());
    pixmap.resize(newSize);    pixmap.fill(this, rect.topLeft());
    QPainter painter(&pixmap, this);
    int side = QMIN(width(), height());    painter.setViewport((width() - side) / 2 - event->rect().x(),                        (height() - side) / 2 - event->rect().y(),                        side, side);    painter.setWindow(-50, -50, 100, 100);    draw(&painter);    bitBlt(this, event->rect().topLeft(), &pixmap);}
This time, we paint on a pixmap instead of on the widget directly. The pixmap
is given the size of the area to repaint, and the window–viewport pair is ini-tialized in such a way that the painting is performed the same as if it was donedirectly on the widget. The
draw() function is also unchanged. At the end, we
copy the pixmap onto the widget using bitBlt() .
This is similar to what we explained in the “Double Buffering” section of
Chapter 5 (p.113), but there’s one important difference: In Chapter 5, we used
translate() to translate the painter, while here we subtract the paint event’s x
andycoordinates when setting up the viewport. Using translation here would
not be as convenient, because the translation would have to be expressed inlogical window coordinates, whereas the event’s rectangle is in physical coor-dinates.
Graphics with QCanvas
QCanvas offers a higher-level interface for doing graphics than QPainter pro-
vides. A QCanvas can contain items of any shape and uses double buffering in-
ternally to avoid ﬂicker. For applications that need to present many user-ma-nipulable items, like data visualization programs and 2D games, using
QCan-
vasis often a better approach than reimplementing QWidget::paintEvent() or
QScrollView::drawContents() and painting everything manually.
The items shown on a QCanvas are instances of QCanvasItem or of one of its sub-
classes. Qt provides a useful set of predeﬁned subclasses: QCanvasLine ,QCan-
186 8. 2D and 3D Graphics
vasRectangle ,QCanvasPolygon ,QCanvasPolygonalItem ,QCanvasEllipse ,QCanvas-
Spline ,QCanvasSprite ,andQCanvasText .These classes can themselves be sub-
classed to provide custom canvas items.
AQCanvas and itsQCanvasItem sare purely data and have no visual representa-
tion. To render the canvas and its items, we must use a QCanvasView widget.
This separation of the data from its visual representation makes it possible tohave multiple
QCanvasView widgets visualizing the same canvas. Each of these
QCanvasView scan present its own portion of the canvas, possibly with different
transformation matrices.
QCanvas is highly optimized to handle a large number of items. When an
item changes, QCanvas only redraws the “chunks” that have changed. It also
provides an efﬁcient collision-detection algorithm. For these reasons alone,it’s worth considering
QCanvas as an alternative to reimplementing QWidget::
paintEvent() orQScrollView::drawContents() .
Figure 8.9. TheDiagramView widget
Todemonstrate QCanvas usage, we present the code for the DiagramView widget,
aminimalist diagram editor. The widget supports two kinds of shapes (boxes
and lines) and provides a context menu that lets the user add new boxes andlines, copy and paste them, delete them, and edit their properties.
class DiagramView : public QCanvasView
{    Q_OBJECTpublic:    DiagramView(QCanvas *canvas, QWidget *parent = 0,                const char *name = 0);
public slots:
    void cut();    void copy();    void paste();    void del();    void properties();    void addBox();
Graphics with QCanvas 187
    void addLine();
    void bringToFront();    void sendToBack();
TheDiagramView class inherits QCanvasView ,which itself inherits QScrollView .
It provides many public slots that an application could connect to. The slotsare also used by the widget itself to implement its context menu.
protected:
    void contentsContextMenuEvent(QContextMenuEvent *event);    void contentsMousePressEvent(QMouseEvent *event);    void contentsMouseMoveEvent(QMouseEvent *event);    void contentsMouseDoubleClickEvent(QMouseEvent *event);
private:
    void createActions();    void addItem(QCanvasItem *item);    void setActiveItem(QCanvasItem *item);    void showNewItem(QCanvasItem *item);
    QCanvasItem *pendingItem;
    QCanvasItem *activeItem;    QPoint lastPos;    int minZ;    int maxZ;
    QAction *cutAct;
    QAction *copyAct;
···
    QAction *sendToBackAct;
};
The protected and private members of the class will be explained shortly.
Figure 8.10. TheDiagramBox andDiagramLine canvas items
Along with the DiagramView class, we also need to deﬁne two custom canvas
item classes to represent the shapes we want to draw. We will call theseclasses
DiagramBox andDiagramLine .
class DiagramBox : public QCanvasRectangle
{public:    enum { RTTI = 1001 };
    DiagramBox(QCanvas *canvas);
    ~DiagramBox();
    void setText(const QString &newText);
    QString text() const { return str; }    void drawShape(QPainter &painter);
188 8. 2D and 3D Graphics
    QRect boundingRect() const;
    int rtti() const { return RTTI; }
private:
    QString str;};
TheDiagramBox class is a type of canvas item that displays a box and a piece
of text. It inherits some of its functionality from QCanvasRectangle ,aQCanvas-
Item subclass that displays a rectangle. To QCanvasRectangle we add the ability
to show some text in the middle of the rectangle and the ability to show tinysquares (“handles”) at each corner to indicate that an item is active. In a real-world application, we would make it possible to click and drag the handles toresize the box, but to keep the code short we will not do so here.
The
rtti() function is reimplemented from QCanvasItem .Its name stands for
“run-time type identiﬁcation”, and by comparing its return value with the
RTTI constant, we can determine whether an arbitrary item in the canvas is
aDiagramBox or not. We could perform the same check using C ++’sdynamic_
cast<T>() mechanism,but that would restrict us to C ++compilersthat support
this feature.
The value of 1001 is arbitrary. Any value above 1000 is acceptable, as long as
it doesn’t collide with other item types used in the same application.
class DiagramLine : public QCanvasLine
{public:    enum { RTTI = 1002 };
    DiagramLine(QCanvas *canvas);
    ~DiagramLine();
    QPoint offset() const { return QPoint((int)x(), (int)y()); }
    void drawShape(QPainter &painter);    QPointArray areaPoints() const;    int rtti() const { return RTTI; }};
TheDiagramLine class is a canvas item that displays a line. It inherits some
of its functionality from QCanvasLine ,and adds the ability to show handles at
each end to indicate that the line is active.
Now we will review the implementations of these three classes.
DiagramView::DiagramView(QCanvas *canvas, QWidget *parent,
                         const char *name)    : QCanvasView(canvas, parent, name){    pendingItem = 0;    activeItem = 0;    minZ = 0;    maxZ = 0;    createActions();}
Graphics with QCanvas 189
TheDiagramView constructor takes a canvas as its ﬁrst argument and passes it
on to the base class constructor. The DiagramView will show this canvas.
TheQAction sare created in the createActions() private function. We have
implemented several versions of this function in earlier chapters, and this onefollows the same pattern, so we will not reproduce it here.
void DiagramView::contentsContextMenuEvent(QContextMenuEvent *event)
{    QPopupMenu contextMenu(this);    if (activeItem) {        cutAct->addTo(&contextMenu);        copyAct->addTo(&contextMenu);        deleteAct->addTo(&contextMenu);        contextMenu.insertSeparator();        bringToFrontAct->addTo(&contextMenu);        sendToBackAct->addTo(&contextMenu);        contextMenu.insertSeparator();        propertiesAct->addTo(&contextMenu);    } else {        pasteAct->addTo(&contextMenu);        contextMenu.insertSeparator();        addBoxAct->addTo(&contextMenu);        addLineAct->addTo(&contextMenu);    }    contextMenu.exec(event->globalPos());}
ThecontentsContextMenuEvent() function is reimplemented from QScrollView
to create a context menu.
Figure 8.11. TheDiagramView widget’s context menus
If an item is active, the menu is populated with the actions that make sense
on an item: Cut,Copy,Delete ,Bring to Front ,Send to Back ,and Properties .Otherwise,
the menu is populated with Paste,Add Box ,and Add Line .
void DiagramView::addBox()
{    addItem(new DiagramBox(canvas()));}
void DiagramView::addLine()
{    addItem(new DiagramLine(canvas()));}
190 8. 2D and 3D Graphics
TheaddBox() andaddLine() slots create a DiagramBox or aDiagramLine item on
the canvas and then call addItem() to perform the rest of the work.
void DiagramView::addItem(QCanvasItem *item)
{    delete pendingItem;    pendingItem = item;    setActiveItem(0);    setCursor(crossCursor);}
TheaddItem() private function changes the cursor to a crosshair and sets
pendingItem to be the newly created item. The item is not visible in the canvas
until we call show() on it.
When the user chooses Add Box orAdd Line from the context menu, the cursor
changes to a crosshair. The item is not actually added until the user clicks onthe canvas.
void DiagramView::contentsMousePressEvent(QMouseEvent *event)
{    if (event->button() == LeftButton && pendingItem) {        pendingItem->move(event->pos().x(), event->pos().y());        showNewItem(pendingItem);        pendingItem = 0;        unsetCursor();    } else {        QCanvasItemList items = canvas()->collisions(event->pos());        if (items.empty())            setActiveItem(0);        else            setActiveItem(*items.begin());    }    lastPos = event->pos();}
If users press the left mouse button while the cursor is a crosshair, they have
already asked to create a box or line, and have now clicked the canvas at theposition where they want the new item to appear. We move the “pending”item to the position of the click, show it, and reset the cursor to the normalarrow cursor.
Any other mouse press event on the canvas is interpreted as an attempt to
select or deselect an item. We call
collisions() on the canvas to obtain a list
of all the items under the cursor and make the ﬁrst item the current item. Ifthe list contains many items, the ﬁrst one is always the one that is renderedon top of the others.
void DiagramView::contentsMouseMoveEvent(QMouseEvent *event)
{    if (event->state() & LeftButton) {        if (activeItem) {            activeItem->moveBy(event->pos().x() - lastPos.x(),                               event->pos().y() - lastPos.y());            lastPos = event->pos();
Graphics with QCanvas 191
            canvas()->update();
        }    }}
The user can move an item on the canvas by pressing the left mouse button
on an item and dragging. Each time we get a mouse move event, we move theitem by the horizontal and vertical distance by which the mouse moved andcall
update() on the canvas. Whenever we modify a canvas item, we must call
update() to notify the canvas that it needs to redraw itself.
void DiagramView::contentsMouseDoubleClickEvent(QMouseEvent *event)
{    if (event->button() == LeftButton && activeItem            && activeItem->rtti() == DiagramBox::RTTI) {        DiagramBox *box = (DiagramBox *)activeItem;        bool ok;
        QString newText = QInputDialog::getText(
                tr("Diagram"), tr("Enter new text:"),                QLineEdit::Normal, box->text(), &ok, this);        if (ok) {            box->setText(newText);            canvas()->update();        }    }}
If the user double-clicks an item, we call the item’s rtti() function and com-
pare its return value with DiagramBox::RTTI (deﬁned as 1001).
Figure 8.12. Changing the text of a DiagramBox item
If the item is a DiagramBox ,w epop up a QInputDialog to allow the user to change
the text shown in the box. The QInputDialog class provides a label, a line editor,
anOKbutton, and a Cancel button.
void DiagramView::bringToFront()
{    if (activeItem) {        ++maxZ;        activeItem->setZ(maxZ);        canvas()->update();    }}
ThebringToFront() slot raises the currently active item to be on top of the
other items in the canvas. This is accomplished by setting the item’s zcoordi-
192 8. 2D and 3D Graphics
nate to a value that is higher than any other value attributed to an item so far.
When two items occupy the same ( x,y)position, the item that has the highest
zvalue is shown in front of the other item. (If the zvalues are equal, QCanvas
will break the tie by comparing the item pointers.)
void DiagramView::sendToBack()
{    if (activeItem) {        --minZ;        activeItem->setZ(minZ);        canvas()->update();    }}
ThesendToBack() slot puts the currently active item behind all the other items
in the canvas. This is done by setting the item’s zcoordinate to a value that is
lower than any other zvalue attributed to an item so far.
void DiagramView::cut()
{    copy();    del();}
Thecut() slot is trivial.
void DiagramView::copy(){    if (activeItem) {        QString str;
        if (activeItem->rtti() == DiagramBox::RTTI) {
            DiagramBox *box = (DiagramBox *)activeItem;            str = QString("DiagramBox %1 %2 %3 %4 %5")                  .arg(box->width())                  .arg(box->height())                  .arg(box->pen().color().name())                  .arg(box->brush().color().name())                  .arg(box->text());        } else if (activeItem->rtti() == DiagramLine::RTTI) {            DiagramLine *line = (DiagramLine *)activeItem;            QPoint delta = line->endPoint() - line->startPoint();            str = QString("DiagramLine %1 %2 %3")                  .arg(delta.x())                  .arg(delta.y())                  .arg(line->pen().color().name());        }        QApplication::clipboard()->setText(str);    }}
Thecopy() slot converts the active item into a string and copies the string to
the clipboard. The string containsall the information necessary to reconstructthe item. For example, a black-on-white 320 × 40 box containing “My LeftFoot” would be represented by this string:
Graphics with QCanvas 193
DiagramBox 320 40 #000000 #ffffff My Left Foot
Wedon’t bother storing the position of the item on the canvas. When we
paste the item, we simply put the duplicate near the canvas’s top-left corner.Converting an object to a string is an easy way to add clipboard support, but itis also possible to put arbitrary binary data onto the clipboard, as we will seein Chapter 9 (Drag and Drop).
void DiagramView::paste()
{    QString str = QApplication::clipboard()->text();    QTextIStream in(&str);    QString tag;
    in >> tag;
    if (tag == "DiagramBox") {        int width;        int height;        QString lineColor;        QString fillColor;        QString text;
        in >> width >> height >> lineColor >> fillColor;
        text = in.read();
        DiagramBox *box = new DiagramBox(canvas());
        box->move(20, 20);        box->setSize(width, height);        box->setText(text);        box->setPen(QColor(lineColor));        box->setBrush(QColor(fillColor));        showNewItem(box);    } else if (tag == "DiagramLine") {        int deltaX;        int deltaY;        QString lineColor;
        in >> deltaX >> deltaY >> lineColor;        DiagramLine *line = new DiagramLine(canvas());
        line->move(20, 20);        line->setPoints(0, 0, deltaX, deltaY);        line->setPen(QColor(lineColor));        showNewItem(line);    }}
Thepaste() slot uses QTextIStream to parse the contents of the clipboard.
QTextIStream works on whitespace-delimited ﬁelds in a similar way to cin.W e
extract each ﬁeld using the >>operator, except the last ﬁeld of the DiagramBox
item, which might contain spaces. For this ﬁeld, we use QTextStream::read() ,
which reads in the rest of the string.
void DiagramView::del()
{    if (activeItem) {
194 8. 2D and 3D Graphics
        QCanvasItem *item = activeItem;
        setActiveItem(0);        delete item;        canvas()->update();    }}
Thedel() slot deletes the active item and calls QCanvas::update() to redraw
the canvas.
void DiagramView::properties()
{    if (activeItem) {        PropertiesDialog dialog;        dialog.exec(activeItem);    }}
Theproperties() slot pops up a Properties dialog for the active item. The
PropertiesDialog class is a “smart” dialog; we simply need to pass it a pointer
to the item we want it to act on and it takes care of the rest.
Figure 8.13. The Properties dialog’s two appearances
The.uiand.ui.h ﬁles for the PropertiesDialog are on the CD that accompa-
nies this book.
void DiagramView::showNewItem(QCanvasItem *item)
{    setActiveItem(item);    bringToFront();    item->show();    canvas()->update();}
TheshowNewItem() private function is called from a few places in the code to
make a newly created canvas item visible and active.
void DiagramView::setActiveItem(QCanvasItem *item)
{
Graphics with QCanvas 195
    if (item != activeItem) {
        if (activeItem)            activeItem->setActive(false);        activeItem = item;        if (activeItem)            activeItem->setActive(true);        canvas()->update();    }}
Finally, the setActiveItem() private function clears the old active item’s
“active” ﬂag, sets the activeItem variable, and sets the new active item’s ﬂag.
The item’s “active” ﬂag is stored in QCanvasItem .Qtdoesn’t use the ﬂag itself;
it is provided purely for the convenience of subclasses. We use the ﬂag in the
DiagramBox andDiagramLine subclasses because we want them to paint them-
selves differently depending on whether they are active or not.
Let’s now review the code for DiagramBox andDiagramLine .
const int Margin = 2;
void drawActiveHandle(QPainter &painter, const QPoint &center)
{    painter.setPen(Qt::black);    painter.setBrush(Qt::gray);    painter.drawRect(center.x() - Margin, center.y() - Margin,                     2 * Margin + 1, 2 * Margin + 1);}
ThedrawActiveHandle() function is used by both DiagramBox andDiagramLine to
draw a tiny square indicating that an item is the active item.
DiagramBox::DiagramBox(QCanvas *canvas)
    : QCanvasRectangle(canvas){    setSize(100, 60);    setPen(black);    setBrush(white);    str = "Text";}
In theDiagramBox constructor, we set the size of the rectangle to 100 × 60. We
also set the pen color to black and the brush color to white. The pen color isused to draw the box outline and the text, while the brush color is used for thebackground of the box.
DiagramBox::~DiagramBox()
{    hide();}
TheDiagramBox destructor calls hide() on the item. This is necessary for all
classes that inherit from QCanvasPolygonalItem (QCanvasRectangle ’sbase class)
because of the way QCanvasPolygonalItem works.
196 8. 2D and 3D Graphics
void DiagramBox::setText(const QString &newText)
{    str = newText;    update();}
ThesetText() function sets the text shown in the box and calls QCanvasItem::
update() to mark this item as changed. The next time the canvas repaints
itself, it will know that it must repaint this item.
void DiagramBox::drawShape(QPainter &painter)
{    QCanvasRectangle::drawShape(painter);    painter.drawText(rect(), AlignCenter, text());    if (isActive()) {        drawActiveHandle(painter, rect().topLeft());        drawActiveHandle(painter, rect().topRight());        drawActiveHandle(painter, rect().bottomLeft());        drawActiveHandle(painter, rect().bottomRight());    }}
ThedrawShape() function is reimplemented from QCanvasPolygonalItem to draw
the text, and if the item is active, the four handles. We use the base class todraw the rectangle itself.
QRect DiagramBox::boundingRect() const
{    return QRect((int)x() - Margin, (int)y() - Margin,                 width() + 2 * Margin, height() + 2 * Margin);}
TheboundingRect() function is reimplemented from QCanvasItem .Itisused by
QCanvas to perform collision-detection and to optimize painting. The rectangle
it returns must be at least as large as the area painted in drawShape() .
The default QCanvasRectangle implementation is not sufﬁcient, because it does
not take into account the handles that we paint at each corner of the rectangleif the item is active.
DiagramLine::DiagramLine(QCanvas *canvas)
    : QCanvasLine(canvas){    setPoints(0, 0, 0, 99);}
In theDiagramLine constructor, we set the two points that deﬁne the line to be
(0, 0) and (0, 99). The result is a 100-pixel-long vertical line.
DiagramLine::~DiagramLine()
{    hide();}
Again, we must call hide() in the destructor.
Graphics with QCanvas 197
void DiagramLine::drawShape(QPainter &painter)
{    QCanvasLine::drawShape(painter);    if (isActive()) {        drawActiveHandle(painter, startPoint() + offset());        drawActiveHandle(painter, endPoint() + offset());    }}
ThedrawShape() function is reimplemented from QCanvasLine to draw handles
at both ends of the line if the item is active. We use the base class to draw theline itself. The
offset() function was implemented in the DiagramLine class
deﬁnition. It returns the position of the item on the canvas.
QPointArray DiagramLine::areaPoints() const
{    const int Extra = Margin + 1;    QPointArray points(6);    QPoint pointA = startPoint() + offset();    QPoint pointB = endPoint() + offset();
    if (pointA.x() > pointB.x())
        swap(pointA, pointB);
    points[0] = pointA + QPoint(-Extra, -Extra);
    points[1] = pointA + QPoint(-Extra, +Extra);    points[3] = pointB + QPoint(+Extra, +Extra);    points[4] = pointB + QPoint(+Extra, -Extra);    if (pointA.y() > pointB.y()) {        points[2] = pointA + QPoint(+Extra, +Extra);        points[5] = pointB + QPoint(-Extra, -Extra);    } else {        points[2] = pointB + QPoint(-Extra, +Extra);        points[5] = pointA + QPoint(+Extra, -Extra);    }    return points;}
TheareaPoints() function plays a similar role to the boundingRect() function
inDiagramBox .For a diagonal line, and indeed for most polygons, a bounding
rectangle is too crude an approximation. For these, we must reimplement
areaPoints() and return the outline of the area painted by the item. The
QCanvasLine implementation already returns a decent outline for a line, but it
doesn’t take the handles into account.
The ﬁrst thing we do is to store the two points in pointA andpointB and to
ensure that pointA is to the left of pointB ,byswapping them if necessary using
swap() (deﬁned in <algorithm> ). Then there are only two cases to consider:
ascending and descending lines.
The bounding area of a line is always represented by six points, but these
points vary depending on whether the line is ascending or descending. Never-theless,four of the six points (numbered 0, 1, 3, and 4) are the same in both cas-es. For example, points 0 and 1 are always located at the top-left and bottom-
198 8. 2D and 3D Graphics
left corners of handle A; in contrast, point 2 is located at the bottom-right cor-
ner of handle A for an ascending line and at the bottom-left corner of handleBfor a descending line.
B A
A B
1 205 4
30 5
1
4
2 3
Figure 8.14. The bounding area of a DiagramLine
Considering how little code we have written, the DiagramView widget already
provides considerable functionality, with support for selecting and movingitems and for context menus.
One thing that is missing is that the handles shown when an item is active
cannot be dragged to resize the item. If we wanted to change that, we wouldprobably take a different approach to the one we have used here. Instead ofdrawing the handles in the items’
drawShape() functions, we would probably
make each handle a canvas item. If we wanted the cursor to change whenhovering over a handle, we would call
setCursor() in real time as it is moved.
Forthis to work, we would need to call setMouseTracking(true) ﬁrst, because
normally Qt only sends mouse move events when a mouse button is pressed.
Another obvious improvement would be to support multiple selections and
item grouping. The Qt Quarterly article “Canvas Item Groupies”, available on-
line at http://doc.trolltech.com/qq/qq05-canvasitemgrouping.html ,presents
one way to achieve this.
This section has provided a working example of QCanvas andQCanvasView use,
but it has not covered all of QCanvas ’sfunctionality. For example, canvas items
can be set to move on the canvas at regular intervals by calling setVelocity() .
See the documentation for QCanvas and its related classes for the details.
Printing
Printing in Qt is similar to drawing on a widget or on a pixmap. It consists ofthe following steps:
1. Create a
QPrinter to serve as the “paint device”.
2. Call QPrinter::setup() to pop up a print dialog, allowing the user to
choose a printer and to set a few options.
3. Create a QPainter to operate on the QPrinter .
Printing 199
4. Draw a page using the QPainter .
5. CallQPrinter::newPage() to advance to the next page.
6. Repeat steps 4 and 5 until all the pages are printed.
On Windows and Mac OS X, QPrinter uses the system’s printer drivers. On
Unix, it generates PostScript and sends it to lporlpr(or to whatever program
has been set using QPrinter::setPrintProgram() ).
0510
1520253035
40
45
            	 
        	 
     	           	       
           	 
 	 
           
   
    
         
 	      
   	     	      
    	 
       
 	       
      
   	 
     !"  # !$   % & '   #
Figure 8.15. Printing an OvenTimer ,aQCanvas ,and aQImage
Let’s start with some simple examples that all print on a single page. The ﬁrst
example prints an OvenTimer widget:
void PrintWindow::printOvenTimer(OvenTimer *ovenTimer)
{    if (printer.setup(this)) {        QPainter painter(&printer);        QRect rect = painter.viewport();        int side = QMIN(rect.width(), rect.height());        painter.setViewport(0, 0, side, side);        painter.setWindow(-50, -50, 100, 100);        ovenTimer->draw(&painter);    }}
Weassume that the PrintWindow class has a member variable called printer
of typeQPrinter .Wecould simply have created the QPrinter on the stack in
printOvenTimer() ,but then it would not remember the user’s settings from one
print run to another.
Wecallsetup() to pop up a print dialog. It returns true if the user clicked the
OKbutton; otherwise, it returns false .After the call to setup() ,theQPrinter
object is ready to use.Wecreate a
QPainter to draw on the QPrinter .Then we make the painter’s
viewport square and initialize the painter’s window to ( +--50,+--50, 100, 100),
the rectangle expected by OvenTimer .Wecalldraw() to do the painting. If we
200 8. 2D and 3D Graphics
didn’t bother making the viewport square, the OvenTimer would be vertically
stretched to ﬁll the entire page height.
By default, the QPainter ’swindow is initialized so that the printer appears
to have a similar resolution as the screen (usually somewhere between 72and 100 dots per inch), making it easy to reuse widget-painting code forprinting. Here, it didn’t matter, because we set our own window to be ( +--50,
+--50, 100, 100).
Printing an
OvenTimer isn’t a very realistic example, because the widget is
meant for on-screen user interaction. But for other widgets, such as the
Plotter widget we developed in Chapter 5, it makes lots of sense to reuse the
widget’s painting code for printing.
Amore practical example is printing a QCanvas .Applications that use it often
need to be able to print what the user has drawn. This can be done in a genericwayasfollows:
void PrintWindow::printCanvas(QCanvas *canvas)
{    if (printer.setup(this)) {        QPainter painter(&printer);        QRect rect = painter.viewport();        QSize size = canvas->size();        size.scale(rect.size(), QSize::ScaleMin);        painter.setViewport(rect.x(), rect.y(),                            size.width(), size.height());        painter.setWindow(canvas->rect());        painter.drawRect(painter.window());        painter.setClipRect(painter.viewport());
        QCanvasItemList items = canvas->collisions(canvas->rect());
        QCanvasItemList::const_iterator it = items.end();        while (it != items.begin()) {            --it;            (*it)->draw(painter);        }    }}
This time, we set the painter’s window to the canvas’s bounding rectangle, and
we restrict the viewport to a rectangle with the same aspect ratio. To accom-plish this, we use
QSize::scale() withScaleMin as its second argument. For
example, if the canvas has a size of 640 × 480 and the painter’s viewport hasasize of 5000 × 5000, the resulting viewport size that we use is 5000 × 3750.
Wecall
collisions() with the canvas’s rectangle as argument to obtain the list
of all visible canvas items sorted from highest to lowest zvalue. We iterate
over the list from the end to paint the items with a lower zvalue before those
with a higher zvalue and call QCanvasItem::draw() on them. This ensures that
the items that appear nearer the front are drawn on top of the items that arefurther back.
Our third example is to draw a
QImage .
Printing 201
void PrintWindow::printImage(const QImage &image)
{    if (printer.setup(this)) {        QPainter painter(&printer);        QRect rect = painter.viewport();        QSize size = image.size();        size.scale(rect.size(), QSize::ScaleMin);        painter.setViewport(rect.x(), rect.y(),                            size.width(), size.height());        painter.setWindow(image.rect());        painter.drawImage(0, 0, image);    }}
Weset the window to the image’s rectangle and the viewport to a rectangle
with the same aspect ratio, and we draw the image at position (0, 0).
Printing items that take up no more than a single page is simple, as we have
seen. But many applications need to print multiple pages. For those, we needto paint one page at a time and call
newPage() to advance to the next page.
This raises the problem of determining how much information we can printon each page.
There are two approaches to handling multi-page documents with Qt:
•W ecan convert the data we want to HTML and render it using
QSimple-
RichText ,Qt’s rich text engine.
•W ecan perform the drawing and the page breaking by hand.
Wewill review both approaches in turn.
As an example, we will print a ﬂower guide: a list of ﬂower names with a
textual description. Each entry in the guide is stored as a string of the format“name :description ”, for example:
Miltonopsis santanae: An most dangerous orchid species.
Since each ﬂower’s data is represented by a single string, we can represent all
the ﬂowers in the guide using one QStringList .
Here’s the function that prints a ﬂower guide using Qt’s rich text engine:
void PrintWindow::printFlowerGuide(const QStringList &entries)
{    QString str;    QStringList::const_iterator it = entries.begin();    while (it != entries.end()) {        QStringList fields = QStringList::split(": ", *it);        QString title = QStyleSheet::escape(fields[0]);        QString body = QStyleSheet::escape(fields[1]);
        str += "<table width=\"100%\" border=1 cellspacing=0>\n"
               "<tr><td bgcolor=\"lightgray\"><font size=\"+1\">"               "<b><i>" + title + "</i></b></font>\n<tr><td>"               + body + "\n</table>\n<br>\n";
202 8. 2D and 3D Graphics
        ++it;
    }    printRichText(str);}
Aponogeton distachyos( ) * + , - * - . / 0 1 * * 0 2 1 , 3 * 4 ) , 1 3 ) . 4 / 5 67
, 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : 3 ) , 3 ) ,7 ;
: . , 3 6 / < =. > : . / < = 0 , 4 ? < 4 * * / : * , @ *7
1 ) 6 8 ) , 4 *7
. A * 3 6 A *7 7
- : ,7
) * 0 - 9 4 - : * B ( ) * 1 , C D E 1 ) 6 3 *;
: . 1 * 47
) , @ * , 8 ) , 4 , 8 3 * 4 67
3 6 8 F;
. 4 ? * 0 F , - - * , 4 , / 8 * =7
1 * * 37
8 * / 3 , / 0 > : , 8 ?7
3 , A * /7
B( ) * D , - - * , 4;
4 . A * , 4 : D7
- 4 6 / < 9 / 3 6 :;
, : : B ( ) * D < 4 . 1 6 / 0 * * - . 47
) , : : . 1 1 , 3 * 4 , / 07
- 4 * , 0 3 . G BH A B
Cabomba caroliniana( ) * I 67
) < 4 ,7 7
2 . 4;
, / 1 . 4 3 . 4 J ,7
) 6 / < 3 . / < 4 ,7 7
5 67
, 97
*;
9 : . C D < * / , 3 . 4;
. 4 - . / 07
BK 3 67
, 0 * 8 6 0 9 . 97
. 47
* A 6 E * @ * 4 < 4 * * /7
9 > A * 4 < * 0 - * 4 * / / 6 , : 3 ) , 3 67
97
* 0 > D;
67
) ,7
,7
. 9 4 8 * .; ;
. . 0 , / 0 ,7
, - : , 8 * 6 / 1 ) 6 8 ) 3 .7
- , 1 / B L : , / 37 ;
. 4 A7
- 4 * , 0 6 / < ) 9 A A . 8 ?7.; ;
, / E7
) , - * 0 = 8 . , 47
: D 0 6 @ 6 0 * 0 : * , @ *7
1 ) 6 8 ) , 4 * > 4 6 < ) 3 < 4 * * / B ( 6 / D 1 ) 6 3 *;
: . 1 * 47, - - * , 4 6 / 3 ) *7
9 A A * 4 B
Caltha palustris( ) * M , 47
) A , 4 6 < . : 0 2 . 4 ? 6 / < 8 9 - 5 67
, 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : 3 ) , 3 < 4 . 17
6 /7
) , : : . 11 , 3 * 4 , 4 . 9 / 0 3 ) * * 0 < *7
.;
- . / 07
B K3 67
* N 9 , : : D 1 * : :7
9 6 3 * 0 3 . , > . < < , 4 0 * / = A . 67
34 . 8 ? < , 4 0 * / . 4 ) * 4 > , 8 * . 97
> . 4 0 * 4 B ( ) * 4 . 9 / 0 * 0 0 , 4 ? < 4 * * / : * , @ *7 7
* 3 .; ;
6 37
: , 4 < * =8 9 - E7
) , - * 0 < . : 0 * / E D * : : . 1;
: . 1 * 47
B L : , / 37
8 , / < 4 . 1 3 . O P 8 A 6 / ) * 6 < ) 3 = 1 6 3 ) ,7
- 4 * , 0 .; Q R
8 A B ( ) * 0 . 9 > : * E;
: . 1 * 4 * 0 8 9 : 3 6 @ , 4 F I : . 4 * L : * / , F . / : D 4 * , 8 ) *7
G P 8 A B
Ceratophyllum demersum( ) * S . 4 / 1 . 4 3 67
, 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : 3 ) , 3 - 4 . 0 9 8 *7 ;
* , 3 ) * 4 D7
9 > A * 4 < * 0;
. : 6 , < * BK 37
. A * 3 6 A *7 ;
: . , 37
, / 07
- 4 * , 07
. @ * 4 , : , 4 < * , 4 * , B K3 67
, < . . 0 . C D < * / , 3 . 4 , / 0< 4 . 17
> *7
3 6 / 8 . . : 0 * * - 1 , 3 * 4 B K3 ) ,7
/ . 4 . . 37
B
Juncus effusus 'Spiralis'( ) * + . 4 ?7
8 4 * 1 4 97
) 67
, 3 9;
3 * 0 * @ * 4 < 4 * * / - * 4 * / / 6 , : 1 6 3 ) A 6 0 E < 4 * * / : * ,;
: *7 7 7
3 * A71 ) 6 8 ) , 4 * 3 1 67
3 * 0 , / 0 8 9 4 : * 0 : 6 ? * , 8 . 4 ?7
8 4 * 1 B ( ) *7
3 * A7
.;
3 * / : 6 * . / 3 ) * < 4 . 9 / 0 B( ) * < 4 * * / 67
) E > 4 . 1 /;
: . 1 * 47
, - - * , 4 6 /7
9 A A * 4 B L : , / 37
, 4 * > *7
3 97
* 0 , 3 3 ) * * 0 < *.;
, - . / 0 =7
. 3 ) , 3 3 ) *7
3 * A7
8 , / > *7
* * / , < , 6 /7
3 3 ) * 4 *;
: * 8 3 6 @ * 1 , 3 * 47
9 4;
, 8 * BT 3 4 . / < - : , / 37
8 , /7
* / 0 9 - U P 8 A E 3 , : : 3 1 67
3 * 07
) . . 37
1 ) 6 8 ) , 4 * 97
* 0 6 / A . 0 * 4 /;
: . 1 * 4 , 4 4 , / < 6 / < B
1Nuphar lutea( ) * V * : : . 1 1 , 3 * 4 : 6 : D ) ,7 7
A , : : 2 O 8 A 0 6 , A * 3 * 4 5 D * : : . 1;
: . 1 * 47
3 ) , 3 , 4 *> . 3 3 : * E7
) , - * 0 , / 07
6 8 ? : D7
A * : : 6 / < B ( ) * D , 4 * ) * : 0 , > . @ * , A , 3 .;
> 4 . , 0 = . @ , : =A 6 0 E < 4 * * / : * , @ *7
1 ) 6 8 ) , 4 * , > . 9 3Q
P 8 A 1 6 0 * = < 6 @ 6 / < 3 ) * - : , / 3 ,7
- 4 * , 0 .;
9 - 3 .G BR
A B ( ) *7
* * 0 ) * , 07
, 4 * 4 . 9 / 0 * 0 , / 0 1 , 4 3 D B ( ) 67
) , 4 0 D 0 * 8 6 0 9 . 97
- * 4 * / / 6 , :3 ) 4 6 @ *7
6 / 0 * * - 1 , 3 * 4 = 6 /7
9 / . 47
) , 0 * = , / 0 67
97
*;
9 :;
. 4 , 1 , 3 * 4 E : 6 : D *; ;
* 8 3 1 ) * 4 *W D A - ) , * , 1 6 : : / . 3 < 4 . 1 B
Orontium aquaticum( ) * X . : 0 * / 8 : 9 > F7 ;
: . 1 * 47
: , 8 ? 3 ) *7
- , 3 ) * 3 D - 6 8 , : .;
. 3 ) * 4 , 4 . 6 07
= : * , @ 6 / < 3 ) *8 * / 3 4 , : D * : : . 1 , / 0 1 ) 6 3 *7
- , 0 6 C 3 . - 4 . @ 6 0 * 8 . : . 4 B Y 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : = 3 ) * < . : 0 * /8 : 9 > < 4 . 17
* N 9 , : : D 1 * : : 6 /7
) , : : . 1 . 4 0 * * - 1 , 3 * 4 B K /7
- 4 6 / < = 3 ) * - * / 8 6 : E : 6 ? *;
: . 1 * 47
- 6 ? *7
27
- , 0 6 8 *7
5 * A * 4 < *;
4 . A , A . / < 3 ) *;
: . , 3 6 / < A ,7 7
.;
1 , C D : * , @ *7
1 ) 6 8 ) , 4 *, > : 9 67
) . 4 < 4 * D 67
) < 4 * * / B L : , / 37
< 4 . 1 3 . HR
8 A ) 6 < )7
- 4 * , 0 6 / < 9 - 3 . O P 8 A B Z , 4 < *7
* * 07
0 * @ * : . - : , 3 * 4 6 / 3 ) *7
9 A A * 4 , / 0 , 4 * 97
* 0 3 . - 4 . - , < , 3 * - : , / 37
1 ) 6 : * 3 ) * D, 4 *7
3 6 : :;
4 *7
) B
Trapa natans( ) * [ *7
9 6 3 F7
/ 9 3 2 . 4 1 , 3 * 4 8 ) *7
3 / 9 3 5 ) ,7
A 6 0 E < 4 * * / 0 6 , A . / 0 E7
) , - * 0 : * , @ *7
1 6 3 )0 * * - : D 3 . . 3 ) * 0 * 0 < *7
3 ) , 3 < 4 . 1 6 / / * , 3 4 .7
* 3 3 *7
B ( ) * 8 * / 3 * 4 .;
* , 8 ) : * ,;
67
.;
3 * /A , 4 ? * 0 1 6 3 ) 0 * * - - 9 4 - : * > : . 3 8 ) *7
B J ) 6 3 *;
: . 1 * 47
, 4 * - 4 . 0 9 8 * 0 6 /7
9 A A * 4 B \ , 8 );
: . , 3 6 / < - : , / 3 8 , /7
- 4 * , 0 3 . H ] 8 A B
Zantedeschia aethiopica( ) * Y 4 9 A : 6 : D 67
, T . 9 3 ) Y;
4 6 8 , / / , 3 6 @ * 3 ) , 3 < 4 . 17
1 * : : 6 /7
) , : : . 1 1 , 3 * 4 B K3;
: . 1 * 473 ) 4 . 9 < ) . 9 3 3 ) *7
9 A A * 4 = 1 6 3 ) 3 ) * * 4 * 8 3;
9 / / * : E7
) , - * 07
- , 3 ) *7
> * 6 / < ) * : 0 1 * : :, > . @ * 3 ) * , 4 4 . 1 E7
) , - * 0 < : .7 7
D = 0 * * - < 4 * * / : * , @ *7
B \ , 8 )7
- , 3 ) *7
9 4 4 . 9 / 07
,8 * / 3 4 , : D * : : . 17
- , 0 6 C B ( ) * : * , @ *7
, / 0;
: . 1 * 4 6 / <7
3 * A7
, 4 67
*;
4 . A , 3 9 > * 4 B L : , / 378 , / 4 * , 8 ) 9 - 3 . U P 8 A 6 / ) * 6 < ) 3 =7
- 4 * , 0 6 / < 3 .Q R
8 A BH
Figure 8.16. Printing a ﬂower guide using QSimpleRichText
The ﬁrst step is to convert the data into HTML. Each ﬂower becomes an
HTML table with two cells. We use QStyleSheet::escape() to replace the
special characters ‘&’, ‘<’, ‘>’ with the corresponding HTML entities (“&amp;”,“&lt;”, “&gt;”). Then we call
printRichText() to print the text.
const int LargeGap = 48;
void PrintWindow::printRichText(const QString &str)
{    if (printer.setup(this)) {        QPainter painter(&printer);        int pageHeight = painter.window().height() - 2 * LargeGap;        QSimpleRichText richText(str, bodyFont, "", 0, 0,                                 pageHeight);        richText.setWidth(&painter, painter.window().width());        int numPages = (int)ceil((double)richText.height()                                 / pageHeight);        int index;
        for (int i = 0; i < (int)printer.numCopies(); ++i) {
            for (int j = 0; j < numPages; ++j) {                if (i > 0 || j > 0)                    printer.newPage();
                if (printer.pageOrder()
                        == QPrinter::LastPageFirst) {                    index = numPages - j - 1;
Printing 203
                } else {
                    index = j;                }                printPage(&painter, richText, pageHeight, index);            }        }    }}
TheprintRichText() function takes care of printing an HTML document. It
can be reused “as is” in any Qt application to print arbitrary HTML.
Wecompute the height of one page based on the window size and the size of
the gap we want to leave at the top and bottom of the page for a header andafooter. Then we create a
QSimpleRichText object containing the HTML data.
The last argument to the QSimpleRichText constructor is the page height;
QSimpleRichText uses it to produce nice page breaks.
window
ﬂower entries print area
[page number](0, 0)
(0,LargeGap ) LargeGap
LargeGappageHeight
Figure 8.17. The ﬂower guide’s page layout
Then we print each page. The outer forloop iterates as many times as nec-
essary to produce the number of copies requested by the user. Most printerdrivers support multiple copies, so for those
QPrinter::numCopies() always
returns 1. If the printer driver doesn’t support multiple copies, numCopies()
returns the number of copies requested by the user, and the application isresponsible for printing that amount. In the previous examples, we ignored
numCopies() for the sake of simplicity.
The inner forloop iterates through the pages. If the page isn’t the ﬁrst page,
we callnewPage() to ﬂush the old page and start painting on a fresh page. We
callprintPage() to paint each page.
The print dialog allows the user to print the pages in reverse order. It is our
responsibility to honor that option.
204 8. 2D and 3D Graphics
Weassume that printer ,bodyFont ,andfooterFont are member variables of the
PrintWindow class.
void PrintWindow::printPage(QPainter *painter,
                            const QSimpleRichText &richText,                            int pageHeight, int index){    QRect rect(0, index * pageHeight + LargeGap,               richText.width(), pageHeight);
    painter->saveWorldMatrix();
    painter->translate(0, -rect.y());    richText.draw(painter, 0, LargeGap, rect, colorGroup());    painter->restoreWorldMatrix();
    painter->setFont(footerFont);
    painter->drawText(painter->window(), AlignHCenter | AlignBottom,                      QString::number(index + 1));}
TheprintPage() function prints the ( index +1)-th page of the document. The
page consists of some HTML and of a page number in the footer area.
Wetranslate the QPainter and call draw() with a position and rectangle spec-
ifying the portion of the rich text we want to draw. It might help to visualizethe rich text as a single very long page that must be cut into smaller portions,each of height
pageHeight .
Then we draw the page number centered at the bottom of the page. If we
wanted to have a header on each page, we would just use an extra draw-
Text() call.
TheLargeGap constant is set to 48. Assuming a screen resolution of 96 dots
per inch, this is half an inch (12.7 mm). To obtain a precise length regardlessof screen resolution, we could have used the
QPaintDeviceMetrics class as
follows:
QPaintDeviceMetrics metrics(&printer);
int LargeGap = metrics.logicalDpiY() / 2;
Here’s one way we can initialize bodyFont andfooterFont in thePrintWindow
constructor:
bodyFont = QFont("Helvetica", 14);
footerFont = bodyFont;
Let’s now see how we can draw a ﬂower guide using QPainter .Here’s the new
printFlowerGuide() function:
void PrintWindow::printFlowerGuide(const QStringList &entries)
{    if (printer.setup(this)) {        QPainter painter(&printer);        vector<QStringList> pages;        int index;
        paginate(&painter, &pages, entries);
Printing 205
        for (int i = 0; i < (int)printer.numCopies(); ++i) {
            for (int j = 0; j < (int)pages.size(); ++j) {                if (i > 0 || j > 0)                    printer.newPage();
                if (printer.pageOrder() == QPrinter::LastPageFirst) {
                    index = pages.size() - j - 1;                } else {                    index = j;                }                printPage(&painter, pages, index);            }        }    }}
The ﬁrst thing we do after setting up the printer and constructing the painter
is to call the paginate() helper function to determine which entry should
appear on which page. The result of this is a vector of QStringList s,with each
QStringList holding the entries for one page.
Forexample, let’s suppose that the ﬂower guide contains 6 entries, which we
will refer to as A, B, C, D, E, and F. Now let’s suppose that there is room for Aand B on the ﬁrst page, C, D, and E on the second page, and F on the third page.The
pages vector would then have the list [A, B]at index position 0, the list [C,
D,E] at index position 1, and the list [F] at index position 2.
The rest of the function is nearly identical to what we did earlier in printRich-
Text() .TheprintPage() function, however, is different, as we will see shortly.
void PrintWindow::paginate(QPainter *painter,
                           vector<QStringList> *pages,                           const QStringList &entries){    QStringList currentPage;    int pageHeight = painter->window().height() - 2 * LargeGap;    int y = 0;
    QStringList::const_iterator it = entries.begin();
    while (it != entries.end()) {        int height = entryHeight(painter, *it);        if (y + height > pageHeight && !currentPage.empty()) {            pages->push_back(currentPage);            currentPage.clear();            y = 0;        }        currentPage.push_back(*it);        y += height + MediumGap;        ++it;    }    if (!currentPage.empty())        pages->push_back(currentPage);}
206 8. 2D and 3D Graphics
Thepaginate() function distributes the ﬂower guide entries into pages. It
relies on the entryHeight() function, which computes the height of one entry.
Aponogeton distach yos( ) * + , - * - . / 0 1 * * 0 2 1 , 3 * 4 ) , 1 3 ) . 4 / 5 67
, 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : 3 ) , 3 ) ,7 ;
: . , 3 6 / < =. > : . / < = 0 , 4 ? < 4 * * / : * , @ *7
1 ) 6 8 ) , 4 *7
. A * 3 6 A *7 7
- : ,7
) * 0 - 9 4 - : * B ( ) * 1 , C D E 1 ) 6 3 *;
: . 1 * 47
) , @ * , 8 ) , 4 , 8 3 * 4 67
3 6 8 F;
. 4 ? * 0 F , - - * , 4 , / 8 * =7
1 * * 37
8 * / 3 , / 0 > : , 8 ?7
3 , A * /7
B( ) * D , - - * , 4;
4 . A * , 4 : D7
- 4 6 / < 9 / 3 6 :;
, : : B ( ) * D < 4 . 1 6 / 0 * * - . 47
) , : : . 1 1 , 3 * 4 , / 07
- 4 * , 0 3 . G BH A B
Cabomba caroliniana( ) * I 67
) < 4 ,7 7
2 . 4;
, / 1 . 4 3 . 4 J ,7
) 6 / < 3 . / < 4 ,7 7
5 67
, 97
*;
9 : . C D < * / , 3 . 4;
. 4 - . / 07
B K 367
, 0 * 8 6 0 9 . 97
. 47
* A 6 E * @ * 4 < 4 * * /7
9 > A * 4 < * 0 - * 4 * / / 6 , : 3 ) , 3 67
97
* 0 > D;
67
) ,7
,7
. 9 4 8 * .; ;
. . 0 , / 0 ,7
, - : , 8 * 6 / 1 ) 6 8 ) 3 .7
- , 1 / B L : , / 37 ;
. 4 A7
- 4 * , 0 6 / < ) 9 A A . 8 ?7.; ;
, / E7
) , - * 0 = 8 . , 47
: D 0 6 @ 6 0 * 0 : * , @ *7
1 ) 6 8 ) , 4 * > 4 6 < ) 3 < 4 * * / B ( 6 / D 1 ) 6 3 *;
: . 1 * 47, - - * , 4 6 / 3 ) *7
9 A A * 4 B
Caltha palustris( ) * M , 47
) A , 4 6 < . : 0 2 . 4 ? 6 / < 8 9 - 5 67
, 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : 3 ) , 3 < 4 . 17
6 /7
) , : : . 1 1 , 3 * 4, 4 . 9 / 0 3 ) * * 0 < *7
.;
- . / 07
B K 3 67
* N 9 , : : D 1 * : :7
9 6 3 * 0 3 . , > . < < , 4 0 * / = A . 67
3 4 . 8 ?< , 4 0 * / . 4 ) * 4 > , 8 * . 97
> . 4 0 * 4 B ( ) * 4 . 9 / 0 * 0 0 , 4 ? < 4 * * / : * , @ *7 7
* 3 .; ;
6 37
: , 4 < * =8 9 - E7
) , - * 0 < . : 0 * / E D * : : . 1;
: . 1 * 47
B L : , / 37
8 , / < 4 . 1 3 . O P 8 A 6 / ) * 6 < ) 3 = 1 6 3 ) ,7
- 4 * , 0.; Q R
8 A B ( ) * 0 . 9 > : * E;
: . 1 * 4 * 0 8 9 : 3 6 @ , 4 F I : . 4 * L : * / , F . / : D 4 * , 8 ) *7
G P 8 A B
Cerato phyllum demersum( ) * S . 4 / 1 . 4 3 67
, 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : 3 ) , 3 - 4 . 0 9 8 *7 ;
* , 3 ) * 4 D7
9 > A * 4 < * 0;
. : 6 , < * B K 37
. A * 3 6 A *7 ;
: . , 37
, / 07
- 4 * , 07
. @ * 4 , : , 4 < * , 4 * , B K3 67
, < . . 0 . C D < * / , 3 . 4 , / 0 < 4 . 17> *7
3 6 / 8 . . : 0 * * - 1 , 3 * 4 B K 3 ) ,7
/ . 4 . . 37
B
Juncus effusus 'S piralis'( ) * + . 4 ?7
8 4 * 1 4 97
) 67
, 3 9;
3 * 0 * @ * 4 < 4 * * / - * 4 * / / 6 , : 1 6 3 ) A 6 0 E < 4 * * / : * ,;
: *7 7 7
3 * A71 ) 6 8 ) , 4 * 3 1 67
3 * 0 , / 0 8 9 4 : * 0 : 6 ? * , 8 . 4 ?7
8 4 * 1 B ( ) *7
3 * A7
.;
3 * / : 6 * . / 3 ) * < 4 . 9 / 0 B ( ) *< 4 * * / 67
) E > 4 . 1 /;
: . 1 * 47
, - - * , 4 6 /7
9 A A * 4 B L : , / 37
, 4 * > *7
3 97
* 0 , 3 3 ) * * 0 < * .;
,- . / 0 =7
. 3 ) , 3 3 ) *7
3 * A7
8 , / > *7
* * / , < , 6 /7
3 3 ) * 4 *;
: * 8 3 6 @ * 1 , 3 * 47
9 4;
, 8 * B T 3 4 . / <- : , / 37
8 , /7
* / 0 9 - U P 8 A E 3 , : : 3 1 67
3 * 07
) . . 37
1 ) 6 8 ) , 4 * 97
* 0 6 / A . 0 * 4 /;
: . 1 * 4, 4 4 , / < 6 / < B
1Nuphar lutea( ) * V * : : . 1 1 , 3 * 4 : 6 : D ) ,7 7
A , : : 2 O 8 A 0 6 , A * 3 * 4 5 D * : : . 1;
: . 1 * 47
3 ) , 3 , 4 * > . 3 3 : * E7
) , - * 0, / 07
6 8 ? : D7
A * : : 6 / < B ( ) * D , 4 * ) * : 0 , > . @ * , A , 3 .;
> 4 . , 0 = . @ , : = A 6 0 E < 4 * * / : * , @ *71 ) 6 8 ) , 4 * , > . 9 3Q
P 8 A 1 6 0 * = < 6 @ 6 / < 3 ) * - : , / 3 ,7
- 4 * , 0 .;
9 - 3 . G BR
A B ( ) *7
* * 0) * , 07
, 4 * 4 . 9 / 0 * 0 , / 0 1 , 4 3 D B ( ) 67
) , 4 0 D 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : 3 ) 4 6 @ *7
6 / 0 * * - 1 , 3 * 4 =6 /7
9 / . 47
) , 0 * = , / 0 67
97
*;
9 :;
. 4 , 1 , 3 * 4 E : 6 : D *; ;
* 8 3 1 ) * 4 * W D A - ) , * , 1 6 : : / . 3 < 4 . 1 B
Orontium a quaticum( ) * X . : 0 * / 8 : 9 > F7 ;
: . 1 * 47
: , 8 ? 3 ) *7
- , 3 ) * 3 D - 6 8 , : .;
. 3 ) * 4 , 4 . 6 07
= : * , @ 6 / < 3 ) * 8 * / 3 4 , :D * : : . 1 , / 0 1 ) 6 3 *7
- , 0 6 C 3 . - 4 . @ 6 0 * 8 . : . 4 B Y 0 * 8 6 0 9 . 97
- * 4 * / / 6 , : = 3 ) * < . : 0 * / 8 : 9 >< 4 . 17
* N 9 , : : D 1 * : : 6 /7
) , : : . 1 . 4 0 * * - 1 , 3 * 4 B K /7
- 4 6 / < = 3 ) * - * / 8 6 : E : 6 ? *;
: . 1 * 47
- 6 ? *727
- , 0 6 8 *7
5 * A * 4 < *;
4 . A , A . / < 3 ) *;
: . , 3 6 / < A ,7 7
.;
1 , C D : * , @ *7
1 ) 6 8 ) , 4 * , > : 9 67
). 4 < 4 * D 67
) < 4 * * / B L : , / 37
< 4 . 1 3 . HR
8 A ) 6 < )7
- 4 * , 0 6 / < 9 - 3 . O P 8 A B Z , 4 < *7
* * 070 * @ * : . - : , 3 * 4 6 / 3 ) *7
9 A A * 4 , / 0 , 4 * 97
* 0 3 . - 4 . - , < , 3 * - : , / 37
1 ) 6 : * 3 ) * D , 4 *7
3 6 : :;
4 *7
) B
Trapa natans( ) * [ *7
9 6 3 F7
/ 9 3 2 . 4 1 , 3 * 4 8 ) *7
3 / 9 3 5 ) ,7
A 6 0 E < 4 * * / 0 6 , A . / 0 E7
) , - * 0 : * , @ *7
1 6 3 )0 * * - : D 3 . . 3 ) * 0 * 0 < *7
3 ) , 3 < 4 . 1 6 / / * , 3 4 .7
* 3 3 *7
B ( ) * 8 * / 3 * 4 .;
* , 8 ) : * ,;
67
.;
3 * /A , 4 ? * 0 1 6 3 ) 0 * * - - 9 4 - : * > : . 3 8 ) *7
B J ) 6 3 *;
: . 1 * 47
, 4 * - 4 . 0 9 8 * 0 6 /7
9 A A * 4 B \ , 8 );
: . , 3 6 / < - : , / 3 8 , /7
- 4 * , 0 3 . H ] 8 A B
Zantedeschia aethio pica( ) * Y 4 9 A : 6 : D 67
, T . 9 3 ) Y;
4 6 8 , / / , 3 6 @ * 3 ) , 3 < 4 . 17
1 * : : 6 /7
) , : : . 1 1 , 3 * 4 B K3;
: . 1 * 473 ) 4 . 9 < ) . 9 3 3 ) *7
9 A A * 4 = 1 6 3 ) 3 ) * * 4 * 8 3;
9 / / * : E7
) , - * 07
- , 3 ) *7
> * 6 / < ) * : 0 1 * : : , > . @ *3 ) * , 4 4 . 1 E7
) , - * 0 < : .7 7
D = 0 * * - < 4 * * / : * , @ *7
B \ , 8 )7
- , 3 ) *7
9 4 4 . 9 / 07
, 8 * / 3 4 , : D * : : . 17
- , 0 6 C B ( ) * : * , @ *7
, / 0;
: . 1 * 4 6 / <7
3 * A7
, 4 67
*;
4 . A , 3 9 > * 4 B L : , / 37
8 , / 4 * , 8 ) 9 - 3 . U P8 A 6 / ) * 6 < ) 3 =7
- 4 * , 0 6 / < 3 .Q R
8 A BH
Figure 8.18. Printing a ﬂower guide using QPainter
Weiterate through the entries and append them to the current page until we
come to an entry that doesn’t ﬁt; then we append the current page to the pages
vector and start a new page.
Title
Body
MediumGapSmallGap
SmallGapSmallGap
SmallGapSmallGap SmallGap
Figure 8.19. Aﬂower entry’s layout
int PrintWindow::entryHeight(QPainter *painter, const QString &entry)
{    QStringList fields = QStringList::split(": ", entry);    QString title = fields[0];    QString body = fields[1];
    int textWidth = painter->window().width() - 2 * SmallGap;
    int maxHeight = painter->window().height();
Printing 207
    painter->setFont(titleFont);
    QRect titleRect = painter->boundingRect(0, 0,                                            textWidth, maxHeight,                                            WordBreak, title);    painter->setFont(bodyFont);    QRect bodyRect = painter->boundingRect(0, 0,                                           textWidth, maxHeight,                                           WordBreak, body);    return titleRect.height() + bodyRect.height() + 4 * SmallGap;}
TheentryHeight() function uses QPainter::boundingRect() to compute the
vertical space needed by one entry. Figure 8.19 shows the layout of a ﬂowerentry and the meaning of the
SmallGap andMediumGap constants.
void PrintWindow::printPage(QPainter *painter,
                            const vector<QStringList> &pages,                            int index){    painter->saveWorldMatrix();    painter->translate(0, LargeGap);    QStringList::const_iterator it = pages[index].begin();    while (it != pages[index].end()) {        QStringList fields = QStringList::split(": ", *it);        QString title = fields[0];        QString body = fields[1];        printBox(painter, titleFont, title, lightGray);        printBox(painter, bodyFont, body, white);        painter->translate(0, MediumGap);        ++it;    }    painter->restoreWorldMatrix();
    painter->setFont(footerFont);
    painter->drawText(painter->window(), AlignHCenter | AlignBottom,                      QString::number(index + 1));}
TheprintPage() function iterates through all the ﬂower guide entries and
prints them using two calls to printBox() :one for the title (the ﬂower’s name)
and one for the body (its description). It also draws the page number centeredat the bottom of the page.
void PrintWindow::printBox(QPainter *painter, const QFont &font,
                           const QString &str, const QBrush &brush){    painter->setFont(font);
    int boxWidth = painter->window().width();
    int textWidth = boxWidth - 2 * SmallGap;    int maxHeight = painter->window().height();
    QRect textRect = painter->boundingRect(SmallGap, SmallGap,
                                           textWidth, maxHeight,                                           WordBreak, str);    int boxHeight = textRect.height() + 2 * SmallGap;
208 8. 2D and 3D Graphics
    painter->setPen(QPen(black, 2, SolidLine));
    painter->setBrush(brush);    painter->drawRect(0, 0, boxWidth, boxHeight);    painter->drawText(textRect, WordBreak, str);    painter->translate(0, boxHeight);}
TheprintBox() function draws the outline of a box, then draws the text inside
the box.
If the user prints a long document, or requests multiple copies of a short
document, it is usually a good idea to pop up a QProgressDialog to give the user
the opportunity of canceling the printing operation (by clicking Cancel ). Here’s
amodiﬁed version of printFlowerGuide() that does this:
void PrintWindow::printFlowerGuide(const QStringList &entries)
{    if (printer.setup(this)) {        QPainter painter(&printer);        vector<QStringList> pages;        int index;
        paginate(&painter, &pages, entries);        int numSteps = printer.numCopies() * pages.size();
        int step = 0;        QProgressDialog progress(tr("Printing file..."),                                 tr("Cancel"), numSteps, this);        progress.setModal(true);
        for (int i = 0; i < (int)printer.numCopies(); ++i) {
            for (int j = 0; j < (int)pages.size(); ++j) {                progress.setProgress(step);                qApp->processEvents();                if (progress.wasCanceled()) {                    printer.abort();                    return;                }                ++step;
                if (i > 0 || j > 0)
                    printer.newPage();
                if (printer.pageOrder() == QPrinter::LastPageFirst) {
                    index = pages.size() - j - 1;                } else {                    index = j;                }                printPage(&painter, pages, index);            }        }    }}
When the user clicks Cancel ,wecallQPrinter::abort() to stop the printing op-
eration.
Graphics with OpenGL 209
Graphics with OpenGL
OpenGL is a standard API for rendering 2D and 3D graphics. Qt applications
can draw OpenGL graphics by using Qt’s QGL module. This section assumesthat you are familiar with OpenGL. If OpenGL is new to you, a good place tostart learning it is
http://www.opengl.org/ .
Drawing graphics with OpenGL from a Qt application is straightforward:
Wemust subclass QGLWidget ,reimplement a few virtual functions, and link
the application against the QGL and OpenGL libraries. Because QGLWidget
inherits from QWidget ,most of what we already know still applies. The main
difference is that we use standard OpenGL functions to perform the drawinginstead of
QPainter .
Figure 8.20. The Cube application
Toshow how this works,we will review the code of the Cube application shown
in Figure 8.20. The application presents a 3D cube with faces of differentcolors. The user can rotate the cube by pressing a mouse button and dragging.The user can set the color of a face by double-clicking it and choosing a colorfrom the
QColorDialog that pops up.
class Cube : public QGLWidget
{public:    Cube(QWidget *parent = 0, const char *name = 0);
protected:
    void initializeGL();    void resizeGL(int width, int height);    void paintGL();    void mousePressEvent(QMouseEvent *event);    void mouseMoveEvent(QMouseEvent *event);    void mouseDoubleClickEvent(QMouseEvent *event);
210 8. 2D and 3D Graphics
private:
    void draw();    int faceAtPosition(const QPoint &pos);
    GLfloat rotationX;
    GLfloat rotationY;    GLfloat rotationZ;    QColor faceColors[6];    QPoint lastPos;};
Cube
inherits from QGLWidget .TheinitializeGL() ,resizeGL() ,andpaintGL()
functions are reimplemented from QGLWidget .The mouse event handlers are
reimplemented from QWidget as usual. QGLWidget is deﬁned in <qgl.h> .
Cube::Cube(QWidget *parent, const char *name)
    : QGLWidget(parent, name){    setFormat(QGLFormat(DoubleBuffer | DepthBuffer));    rotationX = 0;    rotationY = 0;    rotationZ = 0;    faceColors[0] = red;    faceColors[1] = green;    faceColors[2] = blue;    faceColors[3] = cyan;    faceColors[4] = yellow;    faceColors[5] = magenta;}
In the constructor, we call QGLWidget::setFormat() to specify the OpenGL
display context, and we initialize the class’s private variables.
void Cube::initializeGL()
{    qglClearColor(black);    glShadeModel(GL_FLAT);    glEnable(GL_DEPTH_TEST);    glEnable(GL_CULL_FACE);}
TheinitializeGL() function is called once before paintGL() is called. This is
the place where we can set up the OpenGL rendering context, deﬁne displaylists, and perform other initializations.
All the code is standard OpenGL, except for the call to
QGLWidget ’sqglClear-
Color() function. If we wanted to stick to standard OpenGL, we would call gl-
ClearColor() in RGBA mode and glClearIndex() in color index mode instead.
void Cube::resizeGL(int width, int height)
{    glViewport(0, 0, width, height);    glMatrixMode(GL_PROJECTION);    glLoadIdentity();    GLfloat x = (GLfloat)width / height;    glFrustum(-x, x, -1.0, 1.0, 4.0, 15.0);
Graphics with OpenGL 211
    glMatrixMode(GL_MODELVIEW);
}
TheresizeGL() function is called once before paintGL() is called the ﬁrst
time, but after initializeGL() is called. This is the place where we can set up
the OpenGL viewport, projection, and any other settings that depend on thewidget’s size.
void Cube::paintGL()
{    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    draw();}
ThepaintGL() function is called whenever the widget needs to be repainted.
This is similar to QWidget::paintEvent() ,but instead of QPainter functions
we use OpenGL functions. The actual drawing is performed by the privatefunction
draw() .
void Cube::draw()
{    static const GLfloat coords[6][4][3] = {        { { +1.0, -1.0, +1.0 }, { +1.0, -1.0, -1.0 },          { +1.0, +1.0, -1.0 }, { +1.0, +1.0, +1.0 } },        { { -1.0, -1.0, -1.0 }, { -1.0, -1.0, +1.0 },          { -1.0, +1.0, +1.0 }, { -1.0, +1.0, -1.0 } },        { { +1.0, -1.0, -1.0 }, { -1.0, -1.0, -1.0 },          { -1.0, +1.0, -1.0 }, { +1.0, +1.0, -1.0 } },        { { -1.0, -1.0, +1.0 }, { +1.0, -1.0, +1.0 },          { +1.0, +1.0, +1.0 }, { -1.0, +1.0, +1.0 } },        { { -1.0, -1.0, -1.0 }, { +1.0, -1.0, -1.0 },          { +1.0, -1.0, +1.0 }, { -1.0, -1.0, +1.0 } },        { { -1.0, +1.0, +1.0 }, { +1.0, +1.0, +1.0 },          { +1.0, +1.0, -1.0 }, { -1.0, +1.0, -1.0 } }    };
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();    glTranslatef(0.0, 0.0, -10.0);    glRotatef(rotationX, 1.0, 0.0, 0.0);    glRotatef(rotationY, 0.0, 1.0, 0.0);    glRotatef(rotationZ, 0.0, 0.0, 1.0);
    for (int i = 0; i < 6; ++i) {
        glLoadName(i);        glBegin(GL_QUADS);        qglColor(faceColors[i]);        for (int j = 0; j < 4; ++j) {            glVertex3f(coords[i][j][0], coords[i][j][1],                       coords[i][j][2]);        }        glEnd();    }}
212 8. 2D and 3D Graphics
Indraw() ,wedraw the cube, taking into account the x,y,andzrotations and
the colors stored in the faceColors array. Everything is standard OpenGL, ex-
cept for the qglColor() call. We could have used one of the OpenGL functions
glColor3d() orglIndex() ,depending on the mode.
void Cube::mousePressEvent(QMouseEvent *event)
{    lastPos = event->pos();}
void Cube::mouseMoveEvent(QMouseEvent *event)
{    GLfloat dx = (GLfloat)(event->x() - lastPos.x()) / width();    GLfloat dy = (GLfloat)(event->y() - lastPos.y()) / height();
    if (event->state() & LeftButton) {
        rotationX += 180 * dy;        rotationY += 180 * dx;        updateGL();    } else if (event->state() & RightButton) {        rotationX += 180 * dy;        rotationZ += 180 * dx;        updateGL();    }    lastPos = event->pos();}
ThemousePressEvent() andmouseMoveEvent() functions are reimplement from
QWidget to allow the user to rotate the view by clicking and dragging. The
left mouse button allows the user to rotate around the xandyaxes, the right
mouse button around the xandzaxes.
After modifying the rotationX ,rotationY ,and/orrotationZ variables, we call
updateGL() to redraw the scene.
void Cube::mouseDoubleClickEvent(QMouseEvent *event)
{    int face = faceAtPosition(event->pos());    if (face != -1) {        QColor color = QColorDialog::getColor(faceColors[face],                                              this);        if (color.isValid()) {            faceColors[face] = color;            updateGL();        }    }}
ThemouseDoubleClickEvent() is reimplemented from QWidget to allow the user
to set the color of a cube face by double-clicking it. We call the private function
faceAtPosition() to determine which cube face, if any, is located under the
cursor. If a face was double-clicked,we call QColorDialog::getColor() to obtain
anew color for that face. Then we update the faceColors array with the new
color, and we call updateGL() to redraw the scene.
Graphics with OpenGL 213
int Cube::faceAtPosition(const QPoint &pos)
{    const int MaxSize = 512;    GLuint buffer[MaxSize];    GLint viewport[4];
    glGetIntegerv(GL_VIEWPORT, viewport);
    glSelectBuffer(MaxSize, buffer);    glRenderMode(GL_SELECT);
    glInitNames();
    glPushName(0);
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();    glLoadIdentity();    gluPickMatrix((GLdouble)pos.x(),                  (GLdouble)(viewport[3] - pos.y()),                  5.0, 5.0, viewport);    GLfloat x = (GLfloat)width() / height();    glFrustum(-x, x, -1.0, 1.0, 4.0, 15.0);    draw();    glMatrixMode(GL_PROJECTION);    glPopMatrix();
    if (!glRenderMode(GL_RENDER))
        return -1;    return buffer[3];}
ThefaceAtPosition() function returns the number of the face at a certain
position on the widget, or +--1ifthere is no face at that position. The code for
determining this in OpenGL is a bit complicated. Essentially, what we do isrender the scene in
GL_SELECT mode to take advantage of OpenGL’s picking
capabilities and then retrieve the face number (its “name”) from the OpenGLhit record.
Here’s
main.cpp :
#include <qapplication.h>
#include "cube.h"int main(int argc, char *argv[])
{    QApplication app(argc, argv);    if (!QGLFormat::hasOpenGL())        qFatal("This system has no OpenGL support");
    Cube cube;
    cube.setCaption(QObject::tr("Cube"));    cube.resize(300, 300);    app.setMainWidget(&cube);
    cube.show();
    return app.exec();}
214 8. 2D and 3D Graphics
If the user’s system doesn’t support OpenGL, we print an error message to the
console and abort using Qt’s qFatal() global function.
Tolink the application against the QGL and OpenGL libraries, the .pro ﬁle
needs this entry:
CONFIG       += opengl
That completes the Cube application. For more information about the QGLmodule, see the reference documentation for
QGLWidget ,QGLFormat ,QGLContext ,
andQGLColormap .
99
Drag and Drop•Enabling Drag and Drop
•Supporting Custom Drag
Types
•Advanced Clipboard
Handling
Drag and drop is a modern and intuitive way of transferring information
within an application or between different applications. It is often providedin addition to clipboard support for moving and copying data.
In this chapter, we will begin by showing how to add drag and drop support to
aQtapplication. Then we will reuse the drag and drop code to implement clip-
board support. This code reuse is possible because both mechanisms rely on
QMimeSource ,anabstract base class that provides data in different formats.
Enabling Drag and Drop
Drag and drop involves two distinct actions: dragging and dropping. Widgets
can serve as drag sites, as drop sites, or as both.
Drag and drop is a powerful mechanism for transferring data between appli-
cations. But in some cases, it’s possible to implement drag and drop withoutusing Qt’s drag and drop facilities. If all you want to do is to move data withinone widget in one application,it is usually simpler to reimplement the widget’smouse event handlers. This is the approach we took in the
DiagramView widget
in Chapter 8 (p. 190).
Our ﬁrst example shows how to make a Qt application accept a drag initiated
by another application. The Qt application is a main window with a QTextEdit
as its central widget. When the user drags a ﬁle from the desktop or from a ﬁleexplorer and drops it onto the application, the application loads the ﬁle intothe
QTextEdit .
Here’s the deﬁnition of the MainWindow class:
class MainWindow : public QMainWindow
{
215
216 9. Drag and Drop
    Q_OBJECT
public:    MainWindow(QWidget *parent = 0, const char *name = 0);
protected:
    void dragEnterEvent(QDragEnterEvent *event);    void dropEvent(QDropEvent *event);
private:
    bool readFile(const QString &fileName);    QString strippedName(const QString &fullFileName);
    QTextEdit *textEdit;
};
TheMainWindow class reimplements dragEnterEvent() anddropEvent() from
QWidget .Since the purpose of the example is to show drag and drop, much
of the functionality we would expect to be in a main window class has beenomitted.
MainWindow::MainWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name){    setCaption(tr("Drag File"));    textEdit = new QTextEdit(this);    setCentralWidget(textEdit);    textEdit->viewport()->setAcceptDrops(false);    setAcceptDrops(true);}
In the constructor, we create a QTextEdit and set it as the central widget. We
disable dropping on the QTextEdit ’sviewport and enable dropping on the
main window.
The reason we must disable dropping on the QTextEdit is that we want to take
over drag and drop handling ourselves in our MainWindow subclass. By default,
QTextEdit accepts textual drags from other applications, and if the user drops
aﬁle onto it, it will insert the ﬁle name into the text. Since we want to drop
the entire contents of the ﬁle rather than the ﬁle’s name, we cannot make useof
QTextEdit ’sdrag and drop functionality and must implement our own.
Because drop events are propagated from child to parent, we get the drop
events for the whole main window, including those for the QTextEdit ,i nMain-
Window .
void MainWindow::dragEnterEvent(QDragEnterEvent *event)
{    event->accept(QUriDrag::canDecode(event));}
ThedragEnterEvent() is called whenever the user drags an object onto a
widget. If we call accept(true) on the event, we indicate that the user can drop
the drag object on this widget; if we call accept(false) ,weindicate that the
widget can’t accept the drag. Qt automatically changes the cursor to indicateto the user whether or not the widget is a legitimate drop site.
Enabling Drag and Drop 217
Here we want the user to be allowed to drag ﬁles, but nothing else. To do so,
we askQUriDrag ,the Qt class that handles ﬁle drags, whether it can decode
the dragged object. The class can more generally be used for any universalresource identiﬁer (URI), such as HTTP and FTP paths; hence the name
QUriDrag .
void MainWindow::dropEvent(QDropEvent *event)
{    QStringList fileNames;    if (QUriDrag::decodeLocalFiles(event, fileNames)) {        if (readFile(fileNames[0]))            setCaption(tr("%1 - Drag File")                       .arg(strippedName(fileNames[0])));    }}
ThedropEvent() is called when the user drops an object onto the widget. We
call the static function QUriDrag::decodeLocalFiles() to get a list of ﬁle names
dragged by the user and read in the ﬁrst ﬁle in the list. (The second argumentis passed as a non-const reference.) Typically, users only drag one ﬁle at atime, but it is possible for them to drag multiple ﬁles by dragging a selection.
QWidget also provides dragMoveEvent() anddragLeaveEvent() ,but for most
applications they don’t need to be reimplemented.
The second example illustrates how to initiate a drag and accept a drop. We
will create a QListBox subclass that supports drag and drop, and use it as a
component in the Project Chooser application shown in Figure 9.1.
Figure 9.1. The Project Chooser application
The Project Chooser application presents the user with two list boxes,populat-
ed with names. Each list box represents a project. The user can drag and dropthe names in the list boxes to move a person from one project to another.
The drag and drop code is all located in the
QListBox subclass. Here’s the
class deﬁnition:
class ProjectView : public QListBox
{    Q_OBJECT
218 9. Drag and Drop
public:
    ProjectView(QWidget *parent, const char *name = 0);
protected:
    void contentsMousePressEvent(QMouseEvent *event);    void contentsMouseMoveEvent(QMouseEvent *event);    void contentsDragEnterEvent(QDragEnterEvent *event);    void contentsDropEvent(QDropEvent *event);
private:
    void startDrag();
    QPoint dragPos;
};
ProjectView
reimplements four of the event handlers declared in QScrollView
(QListBox ’sbase class).
ProjectView::ProjectView(QWidget *parent, const char *name)
    : QListBox(parent, name){    viewport()->setAcceptDrops(true);}
In the constructor, we enable drops on the QScrollView viewport.
void ProjectView::contentsMousePressEvent(QMouseEvent *event){    if (event->button() == LeftButton)        dragPos = event->pos();    QListBox::contentsMousePressEvent(event);}
When the user presses the left mouse button, we store the mouse position in
thedragPos private variable. We call QListBox ’simplementation of contents-
MousePressEvent() to ensure that QListBox has the opportunity to process
mouse press events as usual.
void ProjectView::contentsMouseMoveEvent(QMouseEvent *event)
{    if (event->state() & LeftButton) {        int distance = (event->pos() - dragPos).manhattanLength();        if (distance > QApplication::startDragDistance())            startDrag();    }    QListBox::contentsMouseMoveEvent(event);}
When the user moves the mouse cursor while holding the left mouse button,
we consider starting a drag. We compute the distance between the currentmouse position and the position where the left mouse button was pressed.
If the distance is larger than
QApplication ’srecommended drag start distance
(normally 4 pixels), we call the private function startDrag() to start dragging.
This avoids initiating a drag just because the user’s hand shakes.
Enabling Drag and Drop 219
void ProjectView::startDrag()
{    QString person = currentText();    if (!person.isEmpty()) {        QTextDrag *drag = new QTextDrag(person, this);        drag->setSubtype("x-person");        drag->setPixmap(QPixmap::fromMimeSource("person.png"));        drag->drag();    }}
InstartDrag() ,wecreate an object of type QTextDrag withthis as its parent.
TheQTextDrag class represents a drag and drop object for transferring text.
It is one of several predeﬁned types of drag objects that Qt provides; othersinclude
QImageDrag ,QColorDrag ,andQUriDrag .Wealso set a pixmap to represent
the drag. The pixmap is a small icon that follows the cursor while the drag istaking place.
Wecall
setSubtype() to set the subtype of the object’s MIME type to x-person .
This causes the object’s full MIME type to be text/x-person .Ifwedidn’t call
setSubtype() ,the MIME type would be text/plain .
Standard MIME types are deﬁned by the Internet Assigned Numbers Author-
ity (IANA). They consist of a type and a subtype separated by a slash. Whenwe create non-standard types, such as
text/x-person ,itisrecommended that
anx-is prepended to the subtype. MIME types are used by the clipboard and
by the drag and drop system to identify different types of data.
Thedrag() call starts the dragging operation. After the call, the QTextDrag
object will remain in existence until the drag operation is ﬁnished. Qt takes
ownership of the drag object and will delete it when it is no longer required,even if it is never dropped.
void ProjectView::contentsDragEnterEvent(QDragEnterEvent *event)
{    event->accept(event->provides("text/x-person"));}
TheProjectView widget not only originates drags of type text/x-person ,italso
accepts such drags. When a drag enters the widget, we check whether it hasthe correct MIME type and reject it if it hasn’t.
void ProjectView::contentsDropEvent(QDropEvent *event)
{    QString person;
    if (QTextDrag::decode(event, person)) {
        QWidget *fromWidget = event->source();        if (fromWidget && fromWidget != this                && fromWidget->inherits("ProjectView")) {            ProjectView *fromProject = (ProjectView *)fromWidget;            QListBoxItem *item =                    fromProject->findItem(person, ExactMatch);            delete item;
220 9. Drag and Drop
            insertItem(person);
        }    }}
IncontentsDropEvent() ,w e use the QTextDrag::decode() function to extract
the text carried by the drag. The QDropEvent::source() function returns a
pointer to the widget that initiated the drag, if that widget is part of the sameapplication. If the source widget is different from the target widget and is a
ProjectView ,weremove the item from the source widget (by calling delete )and
insert a new item into the target.
Supporting Custom Drag Types
In the examples so far, we have relied on predeﬁned Qt classes to hold thedrag data. For example, we used
QUriDrag for a ﬁle drag and QTextDrag for a
text drag. Both of these classes inherit QDragObject ,the base class for all drag
objects. QDragObject itself inherits QMimeSource ,anabstraction for providing
MIME-typed data.
If we want to drag text, images, URIs, or colors, we can use Qt’s QTextDrag ,
QImageDrag ,QUriDrag ,andQColorDrag classes. But if we want to drag custom
data, none of these predeﬁned classes is suitable, and so we must choose oneof two alternatives:
•W ecan store the drag as binary data in a
QStoredDrag object.
•W ecan create our own drag class by subclassing QDragObject and reimple-
menting a couple of virtual functions.
QStoredDrag allows us to store arbitrary binary data, so it can be used for any
MIME type. For example, if we want to initiate a drag with the contents ofabinary ﬁle that stores data in the (ﬁctitious) ASDF format, we could use the
following code:
void MyWidget::startDrag()
{    QByteArray data = toAsdf();    if (!data.isEmpty()) {        QStoredDrag *drag = new QStoredDrag("octet-stream/x-asdf",                                            this);        drag->setEncodedData(data);        drag->setPixmap(QPixmap::fromMimeSource("asdf.png"));        drag->drag();    }}
One inconvenience of QStoredDrag is that it can only store a single MIME type.
If we perform drag and drop within the same application or between multipleinstances of the same application, this is seldom a problem. But if we want tointeract nicely with other applications, one MIME type is rarely sufﬁcient.
Supporting Custom Drag Types 221
Another inconvenience is that we need to convert our data structure to a
QByteArray even if the drag is not accepted in the end. If the data is large, this
can slow down the application needlessly. It would be better to perform thedata conversion only when the user actually drops the drag object.
Asolution to both of these problems is to subclass
QDragObject and reimple-
mentformat() andencodedData() ,the two virtual functions used by Qt to ob-
tain information about a drag. To show how this works,we will develop a Cell-
Drag class that stores the contents of one or more cells in a rectangular QTable
selection.
class CellDrag : public QDragObject
{public:    CellDrag(const QString &text, QWidget *parent = 0,             const char *name = 0);
    const char *format(int index) const;
    QByteArray encodedData(const char *format) const;
    static bool canDecode(const QMimeSource *source);
    static bool decode(const QMimeSource *source, QString &str);
private:
    QString toCsv() const;    QString toHtml() const;
    QString plainText;
};
TheCellDrag class inherits QDragObject .The two functions that really matter
for dragging are format() andencodedData() .Itisconvenient, although not
strictly necessary, to provide canDecode() anddecode() static functions to
extract the data on a drop.
CellDrag::CellDrag(const QString &text, QWidget *parent,
                   const char *name)    : QDragObject(parent, name){    plainText = text;}
TheCellDrag constructor accepts a string that represents the contents of the
cells that are being dragged. The string is in the “tabs and newlines” plaintext format that we used in Chapter 4 when we added clipboard support to theSpreadsheet application (p. 80).
const char *CellDrag::format(int index) const
{    switch (index) {    case 0:        return "text/csv";    case 1:        return "text/html";    case 2:
222 9. Drag and Drop
        return "text/plain";
    default:        return 0;    }}
Theformat() function is reimplemented from QMimeSource to return the differ-
ent MIME types supported by the drag. We support three types: comma-sepa-rated values (CSV), HTML, and plain text.
When Qt needs to determine which MIME types are provided by the drag, it
calls
format() with an index parameter of 0, 1, 2, …, up until format() returns
anull pointer. The MIME types for CSV and HTML were obtained from the
ofﬁcial list, available at http://www.iana.org/assignments/media-types/ .
The precise order of the formats is usually irrelevant, but it’s good practice
to put the “best” formats ﬁrst. Applications that support many formats willsometimes use the ﬁrst one that matches.
QByteArray CellDrag::encodedData(const char *format) const
{    QByteArray data;    QTextOStream out(data);
    if (qstrcmp(format, "text/csv") == 0) {
        out << toCsv();    } else if (qstrcmp(format, "text/html") == 0) {        out << toHtml();    } else if (qstrcmp(format, "text/plain") == 0) {        out << plainText;    }    return data;}
TheencodedData() function returns the data for a given MIME type. The value
of theformat parameter is normally one of the strings returned by format() ,
but we can’t assume that, since not all applications check the MIME typeagainst
format() beforehand. In Qt applications, this check is usually done
by calling provides() on aQDragEnterEvent orQDragMoveEvent ,aswedid earlier
(p. 219).
Toconvert a QString into aQByteArray ,the best approach is to use a QText-
Stream .Ifthe string contains non-ASCII characters, QTextStream will assume
that the encoding is the local 8-bit encoding. (For most European countries,this means ISO 8859-1 or ISO 8859-15; see Chapter 15 for details.) It can beinstructed to use other encodings by calling
setEncoding() orsetCodec() on the
stream, as explained in Chapter 15.
QString CellDrag::toCsv() const
{    QString out = plainText;    out.replace("\\", "\\\\");    out.replace("\"", "\\\"");    out.replace("\t", "\", \"");
Supporting Custom Drag Types 223
    out.replace("\n", "\"\n\"");
    out.prepend("\"");    out.append("\"");    return out;}
QString CellDrag::toHtml() const
{    QString out = QStyleSheet::escape(plainText);    out.replace("\t", "<td>");    out.replace("\n", "\n<tr><td>");    out.prepend("<table>\n<tr><td>");    out.append("\n</table>");    return out;}
ThetoCsv() andtoHtml() functions convert a “tabs and newlines” string into
aCSV or an HTML string. For example, the data
Red     Green   Blue
Cyan    Yellow  Magenta
is converted to
"Red", "Green", "Blue""Cyan", "Yellow", "Magenta"
or to
<table><tr><td>Red<td>Green<td>Blue<tr><td>Cyan<td>Yellow<td>Magenta</table>
The conversion is performed in the simplest way possible, using QString::
replace() .Toescape HTML special characters, we use the QStyleSheet::
escape() static convenience function.
bool CellDrag::canDecode(const QMimeSource *source)
{    return source->provides("text/plain");}
ThecanDecode() function returns true if we can decode the given drag, false
otherwise. For maximum ﬂexibility, its argument is a QMimeSource .TheQMime-
Source class is a base class of QDragObject ,QDragEnterEvent ,QDragMoveEvent ,
andQDropEvent .
Although we provide the data in three different formats, we only accept plain
text. The reason for this is that plain text is normally sufﬁcient. If the userdrags cells from a
QTable to an HTML editor, we want the cells to be converted
into an HTML table. But if the user drags arbitrary HTML into a QTable ,w e
don’t want to accept it.
bool CellDrag::decode(const QMimeSource *source, QString &str)
{    QByteArray data = source->encodedData("text/plain");
224 9. Drag and Drop
    str = QString::fromLocal8Bit((const char *)data, data.size());
    return !str.isEmpty();}
Finally, the decode() function converts the text/plain data into a QString .
Again, we assume the text is encoded using the local 8-bit encoding.
If we want to be certain of using the right encoding, we could use the charset
parameter of the text/plain MIME type to specify an explicit encoding. Here
are a few examples:
text/plain;charset=US-ASCII
text/plain;charset=ISO-8859-1
text/plain;charset=Shift_JIS
When we use QTextDrag ,italways exports UTF-8, UCS-2 (UTF-16), US-ASCII,
and the local 8-bit encoding, and accepts drops from other encodings as well.Considering this, it might be smarter to implement
CellDrag::decode() simply
by calling QTextDrag::decode() .But even with this approach, it’s still a good
idea to provide a CellDrag::decode() separate from QTextDrag::decode() ,i n
case we want to extend it later to decode another type of drag (for example,CSV drags) in addition to plain text.
Now we have our
CellDrag class. To make it useful, we must integrate it with
QTable .Itturns out that QTable already does almost all of the work for us.
All we need to do is to subclass it, call setDragEnabled(true) in our subclass’s
constructor, and reimplement QTable::dragObject() to return a CellDrag .
Here’s an example:
QDragObject *MyTable::dragObject()
{    return new CellDrag(selectionAsString(), this);}
Wehave not shown the code for the selectionAsString() ,because it is the same
as the core of the Spreadsheet::copy() function (p. 80).
Adding drop support to a QTable would require us to reimplement contents-
DragEnterEvent() andcontentsDropEvent() in the same way as we did for the
Project Chooser application.
Advanced Clipboard Handling
Most applications make use of Qt’s built-in clipboard handling in one way oranother. For example, the
QTextEdit class provides support for Ctrl+X ,Ctrl+C ,
and Ctrl+V ,along with cut() ,copy() ,andpaste() slots, so little or no additional
code is required.
When writing our own classes, we can access the clipboard through QAppli-
cation::clipboard() ,which returns a pointer to the application’s QClipboard
object. Handling the system clipboard is easy: Call setText() ,setImage() ,o r
setPixmap() to put data on the clipboard, and text() ,image() ,o rpixmap() to
Advanced Clipboard Handling 225
retrieve the data. We have already seen examples of clipboard use in the
Spreadsheet application from Chapter 4 and in the Diagram application fromChapter 8.
Forsome applications, the built-in functionality might not be sufﬁcient. For
example, we might want to provide data that isn’t just text or an image. Orwe might want to provide data in many different formats, for maximuminteroperability with other applications. The issue is very similar to what weencountered earlier with drag and drop, and the answer is also similar: Wemust subclass
QMimeSource and reimplement format() andencodedData() .
If our application supports drag and drop, we can simply reuse our custom
QDragObject subclass and put it on the clipboard using the setData() function.
SinceQDragObject inherits QMimeSource and the clipboard understand QMime-
Source s,this works seamlessly.
Forexample, here’s how we could implement the copy() function of a QTable
subclass:
void MyTable::copy()
{    QApplication::clipboard()->setData(dragObject());}
At the end of the previous section, we implemented dragObject() to return a
CellDrag that stores the selected cells’ contents.
Toretrieve the data, we can call data() on the clipboard. Here’s how we could
implement the paste() function of a QTable subclass:
void MyTable::paste()
{    QMimeSource *source = QApplication::clipboard()->data();    if (CellDrag::canDecode(source)) {        QString str;        CellDrag::decode(source, str);        performPaste(str);    }}
TheperformPaste() is essentially the same as the Spreadsheet::paste()
function presented in Chapter 4 (p. 81).
This is all that is required, along with a custom QMimeSource ,toadd clipboard
support for a custom type.
The X11 clipboard provides additional functionality not available on Win-
dows or Mac OS X. On X11, it is usually possible to paste a selection by click-ing the middle button of a three-button mouse. This is done using a separate“selection” clipboard. If you want your widgets to support this kind of clip-board as well as the standard one, you must pass
QClipboard::Selection as an
additional argument to the various clipboard calls. For example, here’s howwe would reimplement
mouseReleaseEvent() in a text editor to support pasting
using the middle mouse button:
226 9. Drag and Drop
void MyTextEditor::mouseReleaseEvent(QMouseEvent *event)
{    QClipboard *clipboard = QApplication::clipboard();    if (event->button() == MidButton            && clipboard->supportsSelection()) {        QString text = clipboard->text(QClipboard::Selection);        pasteText(text);    }}
On X11, the supportsSelection() function returns true.Onother platforms, it
returns false .
1010
Input/Output•Reading and Writing Binary
Data
•Reading and Writing Text
•Handling Files and
Directories
•Inter-Process Communication
This chapter covers reading and writing ﬁles, traversing the ﬁle system, and
interacting with external programs.
Qt’sQDataStream andQTextStream classes make it simple to read and write ﬁles.
These classes take care of issues such as byte ordering and text encodings,ensuring that Qt applications running on different platforms can read andwrite each other’s ﬁles.
Many applications need to traverse directories or get information about a ﬁle.
Qt’s
QDir andQFileInfo classes makes this possible.
In some situations, it is necessary to run external programs from within a
GUI program. Qt’s QProcess class allows us to execute external programs
asynchronously, keeping the GUI responsive, with signals to tell us how theexecution is progressing.
Reading and Writing Binary Data
Reading and writing binary data using QDataStream is the simplest way to
load and save custom data with Qt. QDataStream supports many Qt data types,
including QByteArray ,QFont ,QImage ,QMap<K,T> ,QPixmap ,QString ,QValueList<T> ,
andQVariant .The data types that QDataStream understands and the formats
it uses to store them are described online at http://doc.trolltech.com/3.2/
datastreamformat.html .
Toshow how to handle binary data, we will use two example classes: Drawing
andGallery .TheDrawing class holds some basic information about a drawing
(the artist’s name, the title, and the year it was created), and the Gallery class
holds a list of Drawing s.
Wewill start with the Gallery class.
227
228 10. Input/Output
class Gallery : public QObject
{public:    bool loadBinary(const QString &fileName);    bool saveBinary(const QString &fileName);
···
private:    enum { MagicNumber = 0x98c58f26 };
    void writeToStream(QDataStream &out);
    void readFromStream(QDataStream &in);    void error(const QFile &file, const QString &message);    void ioError(const QFile &file, const QString &message);
    QByteArray getData();
    void setData(const QByteArray &data);    QString toString();
    std::list<Drawing> drawings;
};
TheGallery class contains public functions to save and load its data. The data
is a list of drawings held in the drawings data member. The private functions
will be reviewed as we make use of them.
Here is a simple function for saving a Gallery ’sdrawings as binary data:
bool Gallery::saveBinary(const QString &fileName)
{    QFile file(fileName);    if (!file.open(IO_WriteOnly)) {        ioError(file, tr("Cannot open file %1 for writing"));        return false;    }
    QDataStream out(&file);
    out.setVersion(5);
    out << (Q_UINT32)MagicNumber;
    writeToStream(out);
    if (file.status() != IO_Ok) {
        ioError(file, tr("Error writing to file %1"));        return false;    }    return true;}
Weopen a ﬁle and make the ﬁle the target of a QDataStream .W e set theQData-
Stream ’sversion to 5 (the most recent version in Qt 3.2). The version number
inﬂuences the way Qt data types are represented. Basic C ++data types are
always represented the same way.
Wethen output a number that identiﬁes the Gallery ﬁle format ( MagicNumber ).
Toensure that the number is written as a 32-bit integer on all platforms, we
cast it to Q_UINT32 ,adata type that is guaranteed to be exactly 32 bits.
Reading and Writing Binary Data 229
The ﬁle body is written by the writeToStream() private function. We don’t need
to explicitly close the ﬁle; this is done automatically when the QFile variable
goes out of scope at the end of the function.
After the call to writeToStream() ,wecheck the status of the QFile device. If
there was an error, we call ioError() to present a message box to the user and
returnfalse .
void Gallery::ioError(const QFile &file, const QString &message)
{    error(file, message + ": " + file.errorString());}
TheioError() function relies on the more general error() function:
void Gallery::error(const QFile &file, const QString &message){    QMessageBox::warning(0, tr("Gallery"), message.arg(file.name()));}
Now let’s review the writeToStream() function:
void Gallery::writeToStream(QDataStream &out){    list<Drawing>::const_iterator it = drawings.begin();    while (it != drawings.end()) {        out << *it;        ++it;    }}
ThewriteToStream() function iterates over all of the Gallery ’sdrawings and
outputs them to the stream it has been given, relying on the Drawing class’s<<
operator. If we had used a QValueList<Drawing> to store the drawings instead
of alist<Drawing> ,wecould have omitted the loop and simply written
out << drawings;
When a QValueList<T> is streamed, each item stored in the list is output using
the item type’s <<operator.
QDataStream &operator<<(QDataStream &out, const Drawing &drawing)
{    out << drawing.myTitle << drawing.myArtist << drawing.myYear;    return out;}
Tooutput a Drawing ,wesimply output its three private member variables: my-
Title ,myArtist ,andmyYear .Weneed to declare operator<<() as a friend of
Drawing for this to work. At the end of the function,we return the stream. This
is a common C ++idiom that allows us to use a chain of <<operators with an
output stream. For example:
out << drawing1 << drawing2 << drawing3;
The deﬁnition of the Drawing class follows.
230 10. Input/Output
class Drawing
{    friend QDataStream &operator<<(QDataStream &, const Drawing &);    friend QDataStream &operator>>(QDataStream &, Drawing &);
public:
    Drawing() { myYear = 0; }    Drawing(const QString &title, const QString &artist, int year)    { myTitle = title; myArtist = artist; myYear = year; }
    QString title() const { return myTitle; }
    void setTitle(const QString &title) { myTitle = title; }    QString artist() const { return myArtist; }    void setArtist(const QString &artist) { myArtist = artist; }    int year() const { return myYear; }    void setYear(int year) { myYear = year; }
private:
    QString myTitle;    QString myArtist;    int myYear;};
Now let’s see how to read the data from a Gallery ﬁle:
bool Gallery::loadBinary(const QString &fileName){    QFile file(fileName);    if (!file.open(IO_ReadOnly)) {        ioError(file, tr("Cannot open file %1 for reading"));        return false;    }
    QDataStream in(&file);
    in.setVersion(5);
    Q_UINT32 magic;
    in >> magic;    if (magic != MagicNumber) {        error(file, tr("File %1 is not a Gallery file"));        return false;    }
    readFromStream(in);    if (file.status() != IO_Ok) {
        ioError(file, tr("Error reading from file %1"));        return false;    }    return true;}
Weopen the ﬁle for reading and create a QDataStream to extract the data from
the ﬁle. We set the QDataStream ’sversion to 5, because that’s the version we
used for writing. By using a ﬁxed version number of 5, we guarantee that theapplication can always read and write the data, providing it is compiled withQt 3.2 or later.
Reading and Writing Binary Data 231
Westart by reading back the magic number we wrote and compare it against
MagicNumber .This ensures that we are really reading a Gallery ﬁle. We then
read the data itself using the readFromStream() function.
void Gallery::readFromStream(QDataStream &in)
{    drawings.clear();    while (!in.atEnd()) {        Drawing drawing;        in >> drawing;        drawings.push_back(drawing);    }}
InreadFromStream() ,westart by clearing any existing data. We then read
in one drawing at a time, relying on the >>operator, and append each one
to theGallery ’slist of drawings. If we were using a QValueList<Drawing> to
store the data instead of a list<Drawing> ,wecould read in all the drawings
without looping:
in >> drawings;
QValueList<T> relies on the item type’s >>operator to read in the items.
QDataStream &operator>>(QDataStream &in, Drawing &drawing)
{    in >> drawing.myTitle >> drawing.myArtist >> drawing.myYear;    return in;}
The implementation of the >>operator mirrors that of the <<operator. When
we useQDataStream ,wedon’t need to perform any kind of parsing.
If we want to read and write some raw binary data, we can use readRawBytes()
andwriteRawBytes() to read and write a block of bytes through a QDataStream .
The raw bytes are notpreceded by a block size.
Wecan read and write standard binary formats, such as DBF ﬁles and T EX
DVIﬁles, using the >>and<<operators on basic types (like Q_UINT16 orfloat )
or withreadRawBytes() andwriteRawBytes() .The default byte ordering used by
QDataStream is big-endian. If we want to read and write data as little-endian,
we must call
stream.setByteOrder(QDataStream::LittleEndian);
If theQDataStream is being used purely to read and write basic C ++data types,
there is no need to use setVersion() .
If we want to read or write a ﬁle in one go, we can avoid using QDataStream
altogether and instead use QFile ’swriteBlock() andreadAll() functions. For
example:
file.writeBlock(getData());
232 10. Input/Output
Data written in this way is just a sequence of bytes. We are responsible for
structuring the data when we write it and for parsing it when we read it back.Werely on
Gallery ’sprivate getData() function to create the QByteArray and
populate it with data. Reading it back is just as easy:
setData(file.readAll());
WeuseGallery ’ssetData() function to extract the information out of the
QByteArray .
Having all the data in a QByteArray requires more memory, but it offers some
advantages. For example, we can then use Qt’s qCompress() function to
compress the data (using zlib):
file.writeBlock(qCompress(getData()));
Wecan then use qUncompress() to uncompress the data:
setData(qUncompress(file.readAll()));
One way to implement getData() andsetData() is to use a QDataStream on a
QByteArray .Here’sgetData() :
QByteArray Gallery::getData()
{    QByteArray data;    QDataStream out(data, IO_WriteOnly);    writeToStream(out);    return data;}
Wecreate a QDataStream that writes to a QByteArray rather than to a QFile ,
and we use the writeToStream() function we wrote earlier to ﬁll the array with
binary data.
Similarly, the setData() function can use the readFromStream() function we
wrote earlier:
void Gallery::setData(const QByteArray &data)
{    QDataStream in(data, IO_ReadOnly);    readFromStream(in);}
In the earlier examples, we loaded and saved the data with the stream’s
version hard-coded to 5. This approach is simple and safe, but it does have onesmall drawback: We cannot take advantage of new or updated formats. Forexample, if a later version of Qt added a new component to
QFont (in addition
to its point size, family, etc.), that component would not be saved or loaded.
One solution is to embed the QDataStream version number in the ﬁle:
QDataStream out(&file);
out << (Q_UINT32)MagicNumber;out << (Q_UINT16)out.version();writeToStream(out);
Reading and Writing Binary Data 233
This ensures that we always write the data using the most recent version of
QDataStream ,whatever that happens to be.
When we come to read the ﬁle, we read the magic number and the stream
version:
QDataStream in(&file);
Q_UINT32 magic;
Q_UINT16 streamVersion;in >> magic >> streamVersion;
if (magic != MagicNumber) {
    error(file, tr("File %1 is not a Gallery file"));    return false;}else if ((int)streamVersion > in.version()) {
    error(file, tr("File %1 is from a more recent version of the "                   "application"));    return false;}
in.setVersion(streamVersion);
readFromStream(in);
Wecan read the data as long as the stream version is less than or equal to the
version used by the application. Otherwise, we report an error.
If the ﬁle format contains a version number of its own, we can use that instead
of the stream version number. For example, let’s suppose that the ﬁle formatis for version 1.3 of our application. We might then write the data as follows:
QDataStream out(&file);
out.setVersion(5);out << (Q_UINT32)MagicNumber;out << (Q_UINT16)0x0103;writeToStream(out);
When we read it back, we determine which QDataStream version to use based
on the application’s version number:
QDataStream in(&file);
Q_UINT32 magic;
Q_UINT16 appVersion;in >> magic >> appVersion;
if (magic != MagicNumber) {
    error(file, tr("File %1 is not a Gallery file"));    return false;}else if (appVersion > 0x0103) {
    error(file, tr("File %1 is from a more recent version of the "                   "application"));    return false;}
if (appVersion <= 0x0102) {
    in.setVersion(4);
234 10. Input/Output
}else {
    in.setVersion(5);}readFromStream(in);
In this example, we say that any ﬁle saved with version 1.2 or earlier of the
application uses data stream version 4, and that ﬁles saved with version 1.3of the application use data stream version 5.
Once we have a policy for handling
QDataStream versions, reading and writing
binary data using Qt is simple and reliable.
Reading and Writing Text
Qt provides the QTextStream class for reading and writing textual data. We
can use QTextStream for reading and writing plain text ﬁles or ﬁles of other
textual ﬁle formats, such as HTML, XML, and source ﬁles. It takes careof converting between Unicode and the system’s local 8-bit encoding, andtransparently handles the different line-ending conventions used by differentoperating systems.
QTextStream usesQChar as its fundamental unit of data. In addition to char-
acters and strings, QTextStream supports C ++’sbasic numeric types, which it
converts to and from strings.
Toshow how to use QTextStream ,wewill continue with the Gallery example
from the previous section. Here’s the code for a saveText() function that saves
the drawings data from a Gallery :
bool Gallery::saveText(const QString &fileName)
{    QFile file(fileName);    if (!file.open(IO_WriteOnly | IO_Translate)) {        ioError(file, tr("Cannot open file %1 for writing"));        return false;    }
    QTextStream out(&file);
    out.setEncoding(QTextStream::UnicodeUTF8);
    list<Drawing>::const_iterator it = drawings.begin();
    while (it != drawings.end()) {        out << *it;        ++it;    }    if (file.status() != IO_Ok) {        ioError(file, tr("Error writing to file %1"));        return false;    }    return true;}
Weopen the ﬁle with the IO_Translate ﬂag to translate newline characters
to the correct sequence for the target platform (“/r/n” on Windows, “/r” on
Reading and Writing Text 235
Mac OS X).Then we set the encoding to UTF-8, an ASCII-compatible encoding
that can represent the entire Unicode character set. (For more informationabout Unicode, see Chapter 15.) To handle the output, we iterate over eachdrawing in the
Gallery relying on the <<operator:
QTextStream &operator<<(QTextStream &out, const Drawing &drawing)
{    out << drawing.myTitle << ":" << drawing.myArtist << ":"        << drawing.myYear << endl;    return out;}
When writing out a drawing, we use a colon to separate the drawing’s title
from the artist’s name and another colon to separate the artist’s name fromthe year, and we end the data with a newline. We assume that the title andthe artist’s name don’t contain colons or newlines.
Here’s an example ﬁle output by
saveText() :
The False Shepherds:Hans Bol:1576
Panoramic Landscape:Jan Brueghel the Younger:1619Dune Landscape:Jan van Goyen:1630River Delta:Jan van Goyen:1653
Now let’s look at how we can read the data from the ﬁle:
bool Gallery::loadText(const QString &fileName){    QFile file(fileName);    if (!file.open(IO_ReadOnly | IO_Translate)) {        ioError(file, tr("Cannot open file %1 for reading"));        return false;    }
    drawings.clear();
    QTextStream in(&file);    in.setEncoding(QTextStream::UnicodeUTF8);
    while (!in.atEnd()) {
        Drawing drawing;        in >> drawing;        drawings.push_back(drawing);    }
    if (file.status() != IO_Ok) {
        ioError(file, tr("Error reading from file %1"));        return false;    }    return true;}
The interesting part is the while loop. As long as there is more data available,
we read it in using the >>operator.
Implementing the >>operator isn’t trivial, because textual data is fundamen-
tally ambiguous. Let’s consider the following example:
236 10. Input/Output
out << "alpha" << "bravo";
Ifoutis aQTextStream ,the data that actually gets written is the string
“alphabravo”. We can’t really expect this to work with a QTextStream :
in >> str1 >> str2;
In fact, what happens then is that str1 gets the whole word “alphabravo”, and
str2 gets nothing. QDataStream doesn’t have that problem because it stores the
length of each string in front of the character data.
If the text we write out consists of single words, we can put spaces between
them and read the data back word by word. (The DiagramView::copy() and
DiagramView::paste() functions of Chapter 8 use this approach.) We can’t do
this for the drawings because artist names and drawing titles usually containmore than one word. So we read each line in as a whole and then split it intoﬁelds using
QStringList::split() :
QTextStream &operator>>(QTextStream &in, Drawing &drawing)
{    QString str = in.readLine();    QStringList fields = QStringList::split(":", str);    if (fields.size() == 3) {        drawing.myTitle = fields[0];        drawing.myArtist = fields[1];        drawing.myYear = fields[2].toInt();    }    return in;}
Wecan read entire text ﬁles in one go using QTextStream::read() :
QString wholeFile = in.read();
In the resulting string, the end of each line is signiﬁed with a newline charac-
ter (‘/n’) regardless of the line-ending convention used by the ﬁle being read.
Reading in an entire text ﬁle can be very convenient if we need to preprocess
the data. For example:
wholeFile.replace("&", "&amp;");
wholeFile.replace("<", "&lt;");wholeFile.replace(">", "&gt;");
Forwriting in one go, we could put all our data into a single string and simply
output that.
QString Gallery::saveToString()
{    QString result;    QTextOStream out(&result);    list<Drawing>::const_iterator it = drawings.begin();    while (it != drawings.end()) {        out << *it;        ++it;    }
Reading and Writing Text 237
    return result;
}
It is just as easy to stream text into a string as it is to stream it to a ﬁle, again
relying on the <<operator.
void Gallery::readFromString(const QString &data)
{    QString string = data;    drawings.clear();    QTextIStream in(&string);    while (!in.atEnd()) {        Drawing drawing;        in >> drawing;        drawings.push_back(drawing);    }}
Extracting the data from a string using a QTextStream is straightforward. No
parsing is necessary because we rely on the >>operator.
Writing text data isn’t difﬁcult, but reading text can be challenging. For
complex formats, a full-blown parser might be required. Such a parser wouldtypically work by reading the data character by character using
>>on aQChar ,
or line by line using readLine() and iterating through the returned QString .
Handling Files and Directories
Qt’sQDir class provides a platform-independent means of traversing directo-
ries and retrieving information about ﬁles. To see how QDir is used, we will
write a small console application that calculates the space consumed by all theimages in a particular directory and all its subdirectories to any depth.
The heart of the application is the
imageSpace() function, which computes the
size of a given directory:
int imageSpace(const QString &path)
{    QDir dir(path);    QStringList::Iterator it;    int size = 0;
    QStringList files = dir.entryList("*.png *.jpg *.jpeg",
                                      QDir::Files);    it = files.begin();    while (it != files.end()) {        size += QFileInfo(path, *it).size();        ++it;    }
    QStringList dirs = dir.entryList(QDir::Dirs);
    it = dirs.begin();    while (it != dirs.end()) {        if (*it != "." && *it != "..")            size += imageSpace(path + "/" + *it);
238 10. Input/Output
        ++it;
    }    return size;}
Webegin by creating a QDir object using the given path. We pass the entry-
List() function two arguments. The ﬁrst is a space-separated list of ﬁle name
ﬁlters.These can contain ‘ ∗’and ‘?’ wildcard characters. In this example,we are
ﬁltering to include only PNG and JPEG ﬁles. The second argument speciﬁeswhat kind of entries we want (normal ﬁles, directories, drives, etc.).
Weiterate over the list of ﬁles, accumulating their sizes. The
QFileInfo class
allows us to access a ﬁle’s attributes, such as its size, permissions, owner,and timestamps.
The second
entryList() call retrieves all the subdirectories in this directory.
Weiterate over them and recursively call imageSpace() to ascertain their
accumulated image sizes.
Tocreate each subdirectory’s path, we combine the current directory’s path
with the subdirectory name ( *it), separating them with a slash. QDir treats ‘/’
as a directory separator on all platforms, in addition to ‘/’onWindows. When
presenting paths to the user, we can call the static function QDir::convertSep-
arators() to convert slashes to the correct platform-speciﬁc separator.
Let’s add a main() function to our small program:
int main(int argc, char *argv[])
{    QString path = QDir::currentDirPath();    if (argc > 1)        path = argv[1];
    cerr << "Space used by images in " << endl
         << path.ascii() << endl         << "and its subdirectories is "         << (imageSpace(path) / 1024) << " KB" << endl;
    return 0;
}
Forthis example, we don’t need a QApplication object, because we are only
using Qt’s tool classes. See http://doc.trolltech.com/3.2/tools.html for the
list of these classes.
WeuseQDir::currentDirPath() to initialize the path to the current directory.
Alternatively, we could have used QDir::homeDirPath() to initialize it to the
user’s home directory. If the user has speciﬁed a path on the command line,we use that instead. Finally,we call our
imageSpace() function to calculate how
much space is consumed by images.
TheQDir class provides other ﬁle- and directory-related functions, including
rename() ,exists() ,mkdir() ,andrmdir() .TheQFile class provides some static
convenience functions, including remove() andexists() .
Inter-Process Communication 239
Inter-Process Communication
TheQProcess class allows us to execute and interact with external programs.
The class works asynchronously, doing its work in the background so that theuser interface remains responsive.
QProcess emits signals to notify us when
the external process has data or has ﬁnished.
Wewill develop a small application that provides a user interface for an ex-
ternal image conversion program. For this example, we make use of the Im-ageMagick
convert program, which is freely available for all major platforms.
Figure 10.1. The Image Converter application
The Image Converter’s user interface was created in Qt Designer .The.uiﬁle
is on the CD that accompanies this book. Here, we will focus on the .ui.h ﬁle
that contains the code. Note that the process andfileFilters variables were
declared in Qt Designer ’sMembers tab as follows:
QProcess *process;
QString fileFilters;
Theuictool includes these variables as part of the generated ConvertDia-
logclass.
void ConvertDialog::init()
{    process = 0;    QStringList imageFormats = QImage::outputFormatList();    targetFormatComboBox->insertStringList(imageFormats);    fileFilters = tr("Images") + " (*."                  + imageFormats.join(" *.").lower() + ")";}
Aﬁle ﬁlter consists of a descriptive text and one or more wildcard patterns (for
example, “Text ﬁles ( ∗.txt)”). The QImage::outputFormatList() function returns
240 10. Input/Output
alist of the image output formats that are supported by Qt. This list can vary
depending on the options that were selected when Qt was installed.
void ConvertDialog::browse()
{    QString initialName = sourceFileEdit->text();    if (initialName.isEmpty())        initialName = QDir::homeDirPath();    QString fileName =            QFileDialog::getOpenFileName(initialName, fileFilters,                                         this);    fileName = QDir::convertSeparators(fileName);    if (!fileName.isEmpty()) {        sourceFileEdit->setText(fileName);        convertButton->setEnabled(true);    }}
The dialog’s Browse button is connected to the browse() slot. If the user has
previously selected a ﬁle, we initialize the ﬁle dialog with that ﬁle’s path;otherwise, we use the user’s home directory.
void ConvertDialog::convert()
{    QString sourceFile = sourceFileEdit->text();    targetFile = QFileInfo(sourceFile).dirPath() + QDir::separator()                 + QFileInfo(sourceFile).baseName();    targetFile += ".";    targetFile += targetFormatComboBox->currentText().lower();    convertButton->setEnabled(false);    outputTextEdit->clear();
    process = new QProcess(this);
    process->addArgument("convert");    if (enhanceCheckBox->isChecked())        process->addArgument("-enhance");    if (monochromeCheckBox->isChecked())        process->addArgument("-monochrome");    process->addArgument(sourceFile);    process->addArgument(targetFile);    connect(process, SIGNAL(readyReadStderr()),            this, SLOT(updateOutputTextEdit()));    connect(process, SIGNAL(processExited()),            this, SLOT(processExited()));    process->start();}
The dialog’s Convert button is connected to the convert() slot. We copy the
source ﬁle’s name and change its sufﬁx to match the target ﬁle format.
Wethen create a QProcess object. The ﬁrst argument given to a QProcess
object using addArgument() is the name of the external program to execute.
Subsequent arguments become this program’s arguments.
Weconnect the QProcess ’sreadyReadStderr() to the dialog’s updateOutputText-
Edit() slot to display error messages from the external program in the dialog’s
Inter-Process Communication 241
QTextEdit as they are generated. We also connect the QProcess ’sprocessExit-
ed() signal to the dialog’s slot of the same name.
void ConvertDialog::updateOutputTextEdit()
{    QByteArray data = process->readStderr();    QString text = outputTextEdit->text() + QString(data);    outputTextEdit->setText(text);}
Whenever the external process writes to stderr ,ourupdateOutputTextEdit()
slot is called. We read the error text and append it to the QTextEdit .
void ConvertDialog::processExited()
{    if (process->normalExit()) {        outputTextEdit->append(tr("File %1 created")                               .arg(targetFile));    } else {        outputTextEdit->append(tr("Conversion failed"));    }    delete process;    process = 0;    convertButton->setEnabled(true);}
When the process has ﬁnished, we let the user know the outcome and then
delete the process.
Wrapping a console application in this way can be useful because it allows
us to make use of preexisting functionality rather than having to implementthat functionality ourselves. Another use of
QProcess is to launch other GUI
applications, such as a web browser or an email client.

1111
Container Classes•Vectors
•Lists
•Maps
•Pointer-Based Containers
•QString and QVariant
Container classes are general purpose template classes that store items of
agiven type in memory. Standard C ++already includes many containers as
part of the Standard Template Library (STL).
Qt provides its own container classes, so when we write Qt programs, we can
use both the Qt and the STL containers. If you are already familiar with theSTL containers and have STL available on your target platforms, there’s noparticular reason to use the Qt containers.
In this chapter, we review the most important STL and Qt containers. We also
look at
QString andQVariant ,two classes that have many things in common
with containers and that can be used as alternatives to containers in somecontexts.
Formore information about the STL classes and functions, a good place to
start is SGI’s STL web site:
http://www.sgi.com/tech/stl/ .
Vectors
The STL and Qt classes for vectors, lists, and maps are template classes pa-
rameterized by the types of the objects we want to store in them. The valuesthat can be stored in these classes can be basic types (like
intanddouble ),
pointers, or classes that have a default constructor (a constructor that takes orneeds no arguments),a copy constructor,and an assignment operator. Classesthat qualify include
QDateTime ,QRegExp ,QString ,andQVariant .Qtclasses that
inherit from QObject don’t qualify, because they don’t implement a copy con-
structor and an assignment operator. This isn’t usually a problem, since wecan still store pointers to these types.
In this section, we will review the most common operations for vectors, and in
the next two sections,we will review lists and maps. For most of the examples,
243
244 11. Container Classes
we will use the Film class, which stores the title and duration of a ﬁlm. (We
will not call the class Movie because that looks too similar to Qt’s QMovie class,
which is used to show animated images.)
Here’s the deﬁnition of Film:
class Film
{public:    Film(int id = 0, const QString &title = "", int duration = 0);
    int id() const { return myId; }
    void setId(int catalogId) { myId = catalogId; }    QString title() const { return myTitle; }    void setTitle(const QString &title) { myTitle = title; }    int duration() const { return myDuration; }    void setDuration(int minutes) { myDuration = minutes; }
private:
    int myId;    QString myTitle;    int myDuration;};
int operator==(const Film &film1, const Film &film2);
int operator<(const Film &film1, const Film &film2);
Wedon’t explicitly provide a copy constructor or an assignment operator be-
cause the ones automatically supplied by C ++sufﬁce here. If the class had in-
cluded pointers to memory allocated by the class, we would have to implementthem ourselves.
In addition to the class, we provide an equality operator and a “less than” oper-
ator. The equality operator is used when we search a container to see if it con-tains a particular item. The “less than” operator is used for comparing itemswhen sorting them. We don’t need to implement the four other comparisonoperators (
!=,<=,>,>=)since STL never uses them.
Here’s the implementation of the three non-inline functions:
Film::Film(int id, const QString &title, int duration)
{    myId = id;    myTitle = title;    myDuration = duration;}
int operator==(const Film &film1, const Film &film2)
{    return film1.id() == film2.id();}
int operator<(const Film &film1, const Film &film2)
{    return film1.id() < film2.id();}
Vectors 245
When comparing Film objects, we use IDs rather than titles because titles are
not necessarily unique.
Film(4812, "A Hard Day’s Night", 85)
Film(5051, "Seven Days to Noon", 94)
Film(1301, "Day of Wrath", 105)
Film(9227, "A Special Day", 110)
Film(1817, "Day for Night", 116)films[0]
films[1]films[2]films[3]films[4]
Figure 11.1. Avector of Film s
Avector is a data structure that stores its items at adjacent positions in
memory. What distinguishes a vector from a plain C ++array is that a vector
knows its own size and can be resized. Appending extra elements to the end ofavector is fairly efﬁcient, but inserting elements at the front or in the middle
of a vector is expensive.
The STL’s vector class is called
std::vector<T> and is deﬁned in <vector> .
Here’s an example:
vector<Film> films;
The Qt equivalent is called QValueVector<T> :
QValueVector<Film> films;
Avector created like this has size 0. If we know in advance how many
elements we are going to need, we can give the vector an initial size when wedeﬁne it and use the
[]operator to assign a value to its elements; otherwise,
we must either resize it later or append items.
Aconvenient way to populate a vector is to use push_back() .This function
appends an element at the end, extending the vector by one:
films.push_back(Film(4812, "A Hard Day’s Night", 85));
films.push_back(Film(5051, "Seven Days to Noon", 94));films.push_back(Film(1301, "Day of Wrath", 105));films.push_back(Film(9227, "A Special Day", 110));films.push_back(Film(1817, "Day for Night", 116));
In general, Qt offers the same function names as the STL, although in some
cases Qt has additional more Qt-like names. For example, if we are using theQt classes, we can append items using either
push_back() orappend() .
Another way to populate a vector is to give the vector an initial size and to
initialize the elements individually:
vector<Film> films(5);
246 11. Container Classes
films[0] = Film(4812, "A Hard Day’s Night", 85);
films[1] = Film(5051, "Seven Days to Noon", 94);films[2] = Film(1301, "Day of Wrath", 105);films[3] = Film(9227, "A Special Day", 110);films[4] = Film(1817, "Day for Night", 116);
Vector entries that are created without being assigned an explicit value are
initialized using the item class’s default constructor. For basic and pointertypes, the value is undeﬁned, just as it is when we deﬁne variables of thesetypes on the stack.
Wecan iterate over the vector’s elements using the
[]operator:
for (int i = 0; i < (int)films.size(); ++i)
    cerr << films[i].title().ascii() << endl;
Alternatively, we can use an iterator:
vector<Film>::const_iterator it = films.begin();while (it != films.end()) {    cerr << (*it).title().ascii() << endl;    ++it;}
Every container class has two iterator types: iterator andconst_iterator .The
difference between the two is that const_iterator doesn’t allow us to modify
the data.
Acontainer’s begin() function returns an iterator that refers to the ﬁrst item
in the container (for example, films[0] ). A container’s end() function returns
an iterator that refers to the “one past the last” item (for example, films[5] ).
If a container is empty, begin() equalsend() .This can be used to see if the
container has any elements, although it is more convenient to call empty() for
this purpose.
Iterators have an intuitive syntax that resembles the syntax of C ++pointers.
Wecan use the ++and--operators to move to the next or previous item, and
unary*to retrieve the item stored at the current iterator position. In fact, for
vector<T> ,theiterator andconst_iterator types are merely typedefs for T*
andconst T * .
If we want to ﬁnd an item in a vector using a linear search, we can use the STL
find() function:
vector<Film>::iterator it = find(films.begin(), films.end(),
                                 Film(4812));if (it != films.end())    films.erase(it);
Thefind() function returns an iterator to the ﬁrst item that compared equal
(usingoperator==() )tothe item passed as the last argument. It is deﬁned
in<algorithm> ,along with many other template functions. These functions
typically operate on iterators. Qt provides a few of these functions underdifferent names (for example,
qFind() ). You can use them if you want to use Qt
without the STL.
Vectors 247
Tosort the items in a vector, we can call sort() :
sort(films.begin(), films.end());
Thesort() function uses the <operator to compare items, unless we pass a
different comparison function.
Once sorted, we can use the binary_search() function to see if an item is
present. On a sorted vector, binary_search() gives the same result as find()
(assuming no two ﬁlms have the same ID), but is much faster:
int id = 1817;
if (binary_search(films.begin(), films.end(), Film(id)))    cerr << "Found " << id << endl;
Given a position indicated by an iterator,we can expensively insert a new item
usinginsert() or remove an existing item using erase() :
films.erase(it);
The items that follow the erased item in the vector are then moved oneposition to the left to ﬁll its position, and the vector’s size is reduced by one.
Lists
Alist (or linked list) is a data structure that stores its items at non-adjacent
locations in memory. Unlike vectors, lists have very poor random access per-formance; on the other hand,
insert() anderase() are very fast.
Many algorithms that work on vectors don’t work on lists, notably sort() and
binary_search() .This is because lists don’t provide fast random access. For
sorting an STL list, we can use its sort() member function.
Film(4812, "A Hard Day’s Night", 85)
Film(5051, "Seven Days to Noon", 94)
Film(1301, "Day of Wrath", 105)
Film(9227, "A Special Day", 110)
Film(1817, "Day for Night", 116)films.begin()
films.end()
Figure 11.2. Alist ofFilm s
The STL’s list class is called std::list<T> and is deﬁned in <list> .Here’s
an example:
248 11. Container Classes
list<Film> films;
The Qt equivalent is called QValueList<T> :
QValueList<Film> films;
TheFilm class was presented in the previous section (p. 244).
New items can be added using push_back() or with insert() .Unlike vectors,
inserting at the beginning or in the middle of a list is not expensive.
STL lists do not provide the []operator, so iterators must be used to traverse
their elements. (Qt lists support the []operator, but it can be very slow on
large lists.) The syntax and usage is exactly the same as for vectors, exceptthat we write
list<T> instead of vector<T> in front of the iterator type. For
example:
list<Film>::const_iterator it = films.begin();
while (it != films.end()) {    cerr << (*it).title().ascii() << endl;    ++it;}
Otherwise, lists mostly provide the same functions as vectors, including
empty() ,size() ,erase() ,andclear() .Thefind() algorithm can also be used
on lists.
Afew Qt functions return a QValueList<T> .Ifwewant to iterate over the
return value of a function, we must take a copy of the list and iterate overthe copy. For example, the following code is the correct way to iterate over the
QValueList<int> returned by QSplitter::sizes() :
QValueList<int> list = splitter->sizes();
QValueList<int>::const_iterator it = list.begin();while (it != list.end()) {    do_something(*it);    ++it;}
The following code is wrong:
// WRONGQValueList<int>::const_iterator it = splitter->sizes().begin();while (it != splitter->sizes().end()) {    do_something(*it);    ++it;}
This is because QSplitter::sizes() returns a new QValueList<int> by value
every time it is called. If we don’t store the return value, C ++automatically
destroys it before we have even started iterating, leaving us with a danglingiterator. To make matters worse, each time the loop is run,
QSplitter::sizes()
must generate a new copy of the list because of the splitter->sizes().end()
call. In summary: Always iterate on a copy of a container returned by value.
Lists 249
Copying a container like this sounds expensive, but it isn’t, because Qt uses
an optimization called implicit sharing .This optimization means that we can
program as if the data has been copied, even though behind the scenes no datacopying has taken place.
The
QStringList class, which is used in many places in Qt, is a subclass of
QValueList<QString> .Inaddition to the functions it inherits from its base class,
it provides some extra functions that make the class more powerful. Thesefunctions will be discussed in the last section of this chapter.
Maps
Amap holds an arbitrary number of items of the same type, indexed by a key.
Maps store one unique value per key. Maps have good random access andinsertion performance. If a new value is assigned to an existing key, the oldvalue is replaced by the new value.
1301 Film("Day of Wrath", 105)
1817 Film("Day for Night", 116)
4812 Film("A Hard Day’s Night", 85)
5051 Film("Seven Days to Noon", 94)
9227 Film("A Special Day", 110)films[1301]
films[1817]films[4812]films[5051]films[9227]
Figure 11.3. Amap ofFilm s
Since maps contain key–value pairs, it is common to design data structures
that work with maps in a slightly different way from those that are designedfor use with vectors and lists. Here’s a version of the
Film class that we will
use to illustrate map usage:
class Film
{public:    Film(const QString &title = "", int duration = 0);
    QString title() const { return myTitle; }
    void setTitle(const QString &title) { myTitle = title; }    int duration() const { return myDuration; }    void setDuration(int minutes) { myDuration = minutes; }
private:
    QString myTitle;    int myDuration;};
250 11. Container Classes
Film::Film(const QString &title, int duration)
{    myTitle = title;    myDuration = duration;}
Wedon’t store the catalog ID in the Film class since we will use that as the
key to the map. Nor do we need the comparison operators for Film.Maps are
ordered by their keys, not by their values.
The STL’s map class is called std::map<K,T> and is deﬁned in <map> .Here’s
an example of a map whose keys are ints(catalog IDs) and whose values are
Films:
map<int, Film> films;
The Qt equivalent is QMap<K,T> :
QMap<int, Film> films;
The most natural way to insert items into a map is to assign a value to a
given key:
films[4812] = Film("A Hard Day’s Night", 85);
films[5051] = Film("Seven Days to Noon", 94);films[1301] = Film("Day of Wrath", 105);films[9227] = Film("A Special Day", 110);films[1817] = Film("Day for Night", 116);
The map iterator provides a key–pair value. The key part is extracted using
(*it).first and the value part using (*it).second :
map<int, Film>::const_iterator it = films.begin();while (it != films.end()) {    cerr << (*it).first << ": "         << (*it).second.title().ascii() << endl;    ++it;}
Most compilers also allow us to write it->first andit->second ,but it’s more
portable to write (*it).first and(*it).second .
The Qt map’s iterator differs slightly from the STL one. In a Qt map, the key
is retrieved from an iterator using it.key() and the value with it.data() :
QMap<int, Film>::const_iterator it = films.begin();
while (it != films.end()) {    cerr << it.key() << ": " << it.data().title().ascii() << endl;    ++it;}
When iterating over a map, the items are always ordered by key.
The[]operator can be used for both insertion and retrieval, but if []is used
to retrieve a value for a non-existent key, a new item will be created with thegiven key and an empty value. To avoid accidentally creating empty values,use the
find() member function to retrieve items:
Maps 251
map<int, Film>::const_iterator it = films.find(1817);
if (it != films.end())    cerr << "Found " << (*it).second.title().ascii() << endl;
This function returns the end() iterator if the key is not in the map.
In the example we have used an integer key, but other types of keys are
possible, one popular choice being a QString key. For example:
map<QString, QString> actorToNationality;
actorToNationality["Doris Day"] = "American";actorToNationality["Greta Garbo"] = "Swedish";
If we need to store multiple values for the same key, we can use multimap<K,T> .
If we only need to store keys, we can use set<K> ormultiset<K> .Qtprovides no
equivalent for these classes.
Qt’sQMap<K,T> class has a couple of additional convenience functions that are
especially useful when dealing with small data sets. QMap<K,T>::keys() and
QMap<K,T>::values() returnQValueList sofamap’s keys and values.
Pointer-Based Containers
Along with the STL-like containers described in the previous sections, Qt also
provides an additional set of container classes. These classes were developedin the early 1990s for Qt 1.0, before the STL became part of C ++,and therefore
have their own particular syntax. Because these classes operate on pointersto objects, they are often referred to as pointer-based containers, in contrastto Qt’s and the STL’s value-based containers. In Qt 4, the pointer-basedcontainers will continue to be available for compatibility, but it is expectedthat their use will be deprecated in favor of the value-based containers.
The main reason for using the pointer-based classes in newly written Qt code
is that a few important functions in Qt 3 rely on them. We have already seenone example of this in Chapter 3, where we iterated over an application’stop-level widgets (p. 66), and another example in Chapter 6, where we iteratedover an application’s MDI windows (p. 156).
The main pointer-based containers are
QPtrVector<T> ,QPtrList<T> ,QDict<T> ,
QAsciiDict<T> ,QIntDict<T> ,andQPtrDict<T> .
QPtrVector<T> stores a vector of pointers. Here’s how we would populate a
QPtrVector<Film> with ﬁve Film objects:
QPtrVector<Film> films(5);
films.setAutoDelete(true);films.insert(0, new Film(4812, "A Hard Day’s Night", 85));films.insert(1, new Film(5051, "Seven Days to Noon", 94));films.insert(2, new Film(1301, "Day of Wrath", 105));films.insert(3, new Film(9227, "A Special Day", 110));films.insert(4, new Film(1817, "Day for Night", 116));
252 11. Container Classes
QPtrVector<T> does not provide an append() function, so we must resize the
vector ourselves and insert items at speciﬁc index positions. In this example,we are using the original
Film class, which includes catalog IDs.
One nice feature of Qt’s pointer-based containers is the “auto-delete” property.
If auto-delete is enabled, Qt takes ownership of all the objects inserted intothe container and deletes them when the container is deleted (or when
remove() orclear() are used).
Toremove an item from the vector, we can call remove() with an index:
films.remove(2);
Theremove() operation does not change the size of the vector;instead,the item
is set to a null pointer. If auto-delete is on, the item is automatically deleted.
Totraverse a QPtrVector<T> ,wecan simply use indexes:
for (int i = 0; i < (int)films.count(); ++i) {
    if (films[i])        cerr << films[i]->title().ascii() << endl;}
Wecheck that the pointer at the given index is not null before using it, in case
it has been erased or has never had anything assigned to it.
TheQPtrList<T> class stores a list of pointers. We can add new items to a
QPtrList<T> by calling append() ,prepend() ,o rinsert() :
QPtrList<Film> films;
films.setAutoDelete(true);films.append(new Film(4812, "A Hard Day’s Night", 85));films.append(new Film(5051, "Seven Days to Noon", 94));
Pointer lists have a “current” item, which is updated when we call traversal
functions such as first() ,next() ,prev() ,andlast() .One way to iterate over
alist is like this:
Film *film = films.first();
while (film) {    cerr << film->title().ascii() << endl;    film = films.next();}
It’s also possible to iterate over a list using at():
for (int i = 0; i < (int)films.count(); ++i)    cerr << films.at(i)->title().ascii() << endl;
Athird option is to use QPtrListIterator<T> .
TheQDict<T> ,QAsciiDict<T> ,QIntDict<T> ,andQPtrDict<T> classes are the
nearest pointer-based equivalents to map<K,T> .These classes also operate on
key–value pairs. The key can be any one of four different types ( QString ,const
char * ,int,o rvoid * ), depending on which of the four classes is used. Since
all four classes provide the same functions, we will just look at QIntDict<T> .
Pointer-Based Containers 253
Wewill use this to store Filmsofthe same type we used with map<K,T> earlier,
using catalog IDs as keys.
QIntDict<Film> films(101);
films.setAutoDelete(true);
TheQIntDict<T> constructor accepts a number. That number is used internal-
ly by the class to determine how many “buckets” it puts the data into. For goodperformance, that number should be a prime number a little larger than thenumber of items we expect to hold. A list of the prime numbers smaller than10,000 is available at
http://doc.trolltech.com/3.2/primes.html .
Inserting new items is done with insert() ,which accepts a key and a value:
films.insert(4812, new Film("A Hard Day’s Night", 85));
films.insert(5051, new Film("Seven Days to Noon", 94));
Wecan use find() or the[]operator to look up items, remove() to delete an
item, and replace() to change the value associated with a given key.
If we call insert() multiple times with the same key, only the most recently
inserted item will be accessible. If we call remove() ,the items are removed in
the reverse order in which they were inserted. To avoid multiple values underthe same key, we can use
replace() instead of insert() .
The entire container can be traversed using an iterator:
QIntDictIterator<Film> it(films);
while (it.current()) {    cerr << it.currentKey() << ": "         << it.current()->title().ascii() << endl;    ++it;}
The iterator provides the current key with currentKey() and the current value
withcurrent() .The order in which the items appear is undeﬁned.
Qt provides a special vector-like class, QMemArray<T> ,for storing items of
basic types like intanddouble or of structs of basic types. Few applications
use it directly; however, its two subclasses QByteArray (QMemArray<char> )and
QPointArray (QMemArray<QPoint> )are very common, and we have used them
many times in earlier chapters.
Forexample, here’s how to create a QByteArray :
QByteArray bytes(4);
bytes[0] = ’A’;bytes[1] = ’C’;bytes[2] = ’D’;bytes[3] = ’C’;
When we create a QMemArray<T> ,wecan either pass it an initial size or call
resize() later. We can then access array entries using the []operator:
for (int i = 0; i < (int)bytes.size(); ++i)
    cerr << bytes[i] << endl;
254 11. Container Classes
Wecan search for an item using QMemArray<T>::find() :
if (bytes.find(’A’) != -1)
    cerr << "Found" << endl;
Asubtle pitfall with QMemArray<T> and its subclasses is that they are explicitly
shared .This means that when we create a copy of an object (using the class’s
copy constructor or its assignment operator), both the original and the copyshare the same data. When we modify one of them, the other one is alsomodiﬁed. Explicit sharing should not be confused with implicit sharing,which does not have this problem.
The defensive way to program using
QMemArray<T> is to call copy() to force a
deep copy of the container when copying it:
duplicate = bytes.copy();
This ensures that no two QMemArray<T> objects point to the same data.
Toavoid the inherent problems of explicit sharing, the QMemArray<T> class will
probably be deprecated in favor of QValueVector<T> in Qt 4. The QByteArray and
QPointArray classes will then use QValueVector<T> as their base class.
QString and QVariant
Strings are used by every GUI program, not only for the user interface, butoften also as data structures.
C++natively provides two kinds of strings: traditional C-style ‘/0’-terminated
character arrays and the string class. Qt’s QString class is more powerful
than either of them. The QString class holds 16-bit Unicode values. Unicode
contains ASCII and Latin-1 as a subset, with their usual numeric values.But since
QString is 16-bit, it can represent thousands of other characters for
writing most of the world’s languages. See Chapter 15 for more informationabout Unicode.
QString provides a binary +operator to concatenate two strings and a +=oper-
ator to append one string to another. Here’s an example that combines both:
QString str = "User: ";
str += userName + "\n";
There is also a QString::append() function that does the same thing as the
+=operator:
str = "User: ";
str.append(userName);str.append("\n");
Acompletely different way of combining strings is to use QString ’ssprintf()
function:
str.sprintf("%s %.1f%%", "perfect competition", 100.0);
QString and QVariant 255
This function supports the same format speciﬁers as the C ++library’s
sprintf() function. In the example above, stris assigned “perfect competi-
tion 100.0%”.
Yetanother way of building a string from other strings or from numbers is to
usearg() :
str = QString("%1 %2 (%3s-%4s)")
      .arg("permissive").arg("society").arg(1950).arg(1970);
In this example, “%1” is replaced by “permissive”,“%2” is replaced by “society”,
“%3” is replaced by “1950”, and “%4” is replaced by “1970”. The result is“permissive society (1950s-1970s)”. There are
arg() overloads to handle vari-
ous data types. Some overloads have extra parameters for controlling the ﬁeldwidth, the numerical base, or the ﬂoating-point precision. In general,
arg() is
amuch better solution than sprintf() ,because it is type-safe, fully supports
Unicode, and allows translators to change the order of the “% n”parameters.
QString can convert numbers into strings using the QString::number() static
function:
str = QString::number(59.6);
Or using the setNum() function:
str.setNum(59.6);
The reverse conversion, from a string to a number, is achieved using toInt() ,
toLongLong() ,toDouble() ,and so on. For example:
bool ok;
double d = str.toDouble(&ok);
These functions also accept an optional pointer to a bool and set the bool to
true orfalse depending on the successof the conversion. When the conversion
fails, these functions always return 0.
Once we have a string, we often want to extract parts of it. The mid() function
returns the substring starting at a given position and of a given length. Forexample, the following code prints “pays” to the console:
QString str = "polluter pays principle";
cerr << str.mid(9, 4).ascii() << endl;
If we omit the second argument (or pass +--1),mid() returns the substring
starting at a given position and ending at the end of the string. For example,the following code prints “pays principle” to the console:
QString str = "polluter pays principle";
cerr << str.mid(9).ascii() << endl;
There are also left() andright() functions that perform a similar job. Both
accept a number of characters, n,and return the ﬁrst or last ncharacters
of the string. For example, the following code prints “polluter principle” tothe console:
256 11. Container Classes
QString str = "polluter pays principle";
cerr << str.left(8).ascii() << " " << str.right(9).ascii()     << endl;
If we want to check if a string starts or ends with something, we can use the
startsWith() andendsWith() functions:
if (uri.startsWith("http:") && uri.endsWith(".png"))    ...
This is both simpler and faster than this:
if (uri.left(5) == "http:" && uri.right(4) == ".png")    ...
String comparison with the ==operator is case sensitive. For case insensitive
comparisons, we can use upper() orlower() .For example:
if (fileName.lower() == "readme.txt")
    ...
If we want to replace a certain part of a string by another string, we can use
replace() :
QString str = "a sunny day";str.replace(2, 5, "cloudy");
The result is “a cloudy day”. The code can be rewritten to use remove() and
insert() :
str.remove(2, 5);str.insert(2, "cloudy");
First, we remove ﬁve characters starting at position 2, resulting in the string
“a day” (with two spaces), then we insert “cloudy” at position 2.
There are overloaded versions of replace() that replace all occurrences of
their ﬁrst argument with their second argument. For example, here’s how toreplace all occurrences of “&” with “&amp;” in a string:
str.replace("&", "&amp;");
One very frequent need is to strip the whitespace (such as spaces, tabs, andnewlines) from a string.
QString has a function that strips whitespace from
both ends of a string:
QString str = "   BOB \t THE \nDOG \n";
cerr << str.stripWhiteSpace().ascii() << endl;
Stringstrcan be depicted as
BOB \t THE \nDOG \n
The string returned by stripWhiteSpace() is
BOB \t THE \nDOG
QString and QVariant 257
When handling user input, we often also want to replace every sequence of
one or more internal whitespace characters with single spaces, in addition tostripping whitespace from both ends. This is what the
simplifyWhiteSpace()
function does:
QString str = "   BOB \t THE \nDOG \n";
cerr << str.simplifyWhiteSpace().ascii() << endl;
The string returned by simplifyWhiteSpace() is
BOB THE DOG
Astring can be split into substrings using QStringList::split() :
QString str = "polluter pays principle";
QStringList words = QStringList::split(" ", str);
In the example above, we split the string “polluter pays principle” into three
substrings: “polluter”, “pays”, and “principle”. The split() function has an
optional bool third argument that speciﬁes whether empty substrings should
be ignored (the default) or not.
The elements in a QStringList can be joined to form a single string using
join() .The argument to join() is inserted between each pair of joined strings.
Forexample, here’s how to create a single string that is composed of all the
strings contained in a QStringList sorted into alphabetical order and separat-
ed by newlines:
words.sort();
str = words.join("\n");
When dealing with strings, we often need to determine whether a string is
empty or not. One way of testing this is to call isEmpty() ;another way is to
check whether length() is 0.
QString distinguishes between null strings and empty strings.This distinction
has its roots in the C language, which differentiates between 0(a null pointer)
and""(an empty string). To test whether a string is null, we can call isNull() .
Formost applications, what matters is whether or not a string contains any
characters. The isEmpty() function provides this information, returning true
if a string has no characters (is null or empty), and false otherwise.
The conversions between constchar * strings and QString is automatic in most
cases, for example:
str += " (1870)";
Here we add a const char * to aQString without formality.
In some situations, it is necessary to explicitly convert between const char *
andQString .Toconvert a QString to aconst char * ,useascii() orlatin1() .T o
convert the other way, use a QString cast.
258 11. Container Classes
When we call ascii() orlatin1() on aQString ,orwhen we let the automatic
conversion to const char * do its work, the returned string is owned by the
QString object. This means that we don’t need to worry about memory leaks;
Qt will reclaim the memory for us. On the other hand, we must be careful notto use the pointer for too long. For example, if we modify the original
QString ,
the pointer is not guaranteed to remain valid. If we need to store the const
char * for any length of time, we can assign it to a variable of type QByteArray
orQCString .These will hold a complete copy of the data.
QString is implicitly shared. This means that copying a QString is about as
fast as copying a single pointer. Only if one of the copies is changed is dataactually copied—and this is all handled automatically behind the scenes. Forthis reason, implicit sharing is sometimes referred to as “copy on write”.
The beauty of implicit sharing is that it is an optimization that we don’t have
to think about; it simply works, without requiring any programmer inter-vention.
Qt uses implicit sharing for many other classes, including
QBrush ,QFont ,QPen,
QPixmap ,QMap<K,T> ,QValueList<T> ,andQValueVector<T> .This makes these
classes very efﬁcient to pass by value, both as function parameters and asreturn values.
C++is a strongly typed language, and this provides many beneﬁts, including
type safety and efﬁciency. However, in some situations, it is useful to be ableto store data more generically, and one conventional way of doing so is to usestrings. For example, a string could hold a textual value or a numeric value instring form. Qt provides a much cleaner way of handling variables that canhold different types:
QVariant .
TheQVariant class can hold values of many Qt types, including QBrush ,QCol-
or,QCursor ,QDateTime ,QFont ,QKeySequence ,QPalette ,QPen,QPixmap ,QPoint ,
QRect ,QRegion ,QSize ,andQString .TheQVariant class can also hold contain-
ers:QMap<QString,QVariant> ,QStringList ,andQValueList<QVariant> .Weused a
QVariant in the implementation of the Spreadsheet application in Chapter 4 to
hold the value of a cell, which could be either a QString ,adouble ,oraninvalid
value.
One common use of variants is in a map that uses strings as keys and variants
as values. Conﬁguration data isnormally saved and retrieved using QSettings ,
but some applications may handle this data directly, perhaps storing it in adatabase.
QMap<QString,QVariant> is ideal for such situations:
QMap<QString, QVariant> config;
config["Width"] = 890;config["Height"] = 645;config["ForegroundColor"] = black;config["BackgroundColor"] = lightGray;config["SavedDate"] = QDateTime::currentDateTime();QStringList files;files << "2003-05.dat" << "2003-06.dat" << "2003-07.dat";config["RecentFiles"] = files;
QString and QVariant 259
How Implicit Sharing Works
Implicit sharing works automatically behind the scenes, so when we use
classes that are implicitly shared, we don’t have to do anything in our codeto make this optimization happen. But since it’s nice to know how thingswork, we will study an example and see what happens under the hood.
QString str1 = "Humpty";
QString str2 = str1;
Wesetstr1 to “Humpty” and str2 to be equal to str1.Atthis point, both
QString spoint to the same data structure in memory (of type QStringData ).
Along with the character data, the data structure holds a reference countthat indicates how many
QString spoint to the same data structure. Since
bothstr1 andstr2 point to the same data, the reference count is 2.
str2[0] = ’D’;
When we modify str2,itﬁrst makes a deep copy of the data, to ensure
thatstr1 andstr2 point to different data structures, and it then applies
the change to its own copy of the data. The reference count of str1’sdata
(“Humpty”) becomes 1, and the reference count of str2’sdata (“Dumpty”) is
set to 1. A reference count of 1 means that the data isn’t shared.
str2.truncate(4);
If we modify str2 again, no copying takes place because the reference count
ofstr2’sdata is 1. The truncate() function operates directly on str2’sdata,
resulting in the string “Dump”. The reference count stays at 1.
str1 = str2;
When we assign str2 tostr1,the reference count for str1’sdata goes down
to 0, which means that no QString is using the “Humpty” data anymore. The
data is then freed from memory. Both QString snow point to “Dump”, which
now has a reference count of 2.
Writing implicitly shared classes isn’t very difﬁcult. The Qt Quarterly ar-
ticle “Data Sharing with Class”, available online at http://doc.trolltech.
com/qq/qq02-data-sharing-with-class.html ,explains how to do it.
Iterating over a map that holds variant values can be slightly tricky if some
of the values are containers. We need to use type() to check the type that a
variant holds so that we can respond appropriately:
QMap<QString, QVariant>::const_iterator it = config.begin();
while (it != config.end()) {    QString str;    if (it.data().type() == QVariant::StringList)        str = it.data().toStringList().join(", ");    else        str = it.data().toString();    cerr << it.key().ascii() << ": " << str.ascii() << endl;
260 11. Container Classes
    ++it;
}
It is possible to create arbitrarily complex data structures using QVariant by
holding values of container types:
QMap<QString, QVariant> price;
price["Orange"] = 2.10;price["Pear"].asMap()["Standard"] = 1.95;price["Pear"].asMap()["Organic"] = 2.25;price["Pineapple"] = 3.85;
Here we have created a map with string keys (product names) and values that
are either ﬂoating-point numbers (prices) or maps. The top level map containsthree keys: “Orange”, “Pear”, and “Pineapple”. The value associated with the“Pear” key is a map that contains two keys (“Standard” and “Organic”).
Creating data structures like this can be very seductive since we can structure
the data in any way we like. But the convenience of
QVariant comes at a price.
Forthe sake of readability, it is usually worth deﬁning a proper C ++class
to store our data. A custom class provides type safety and will also be morespeed- and memory-efﬁcient than using
QVariant .
1212
Databases•Connecting and Querying
•Presenting Data in Tabular
Form
•Creating Data-Aware Forms
Qt’s SQL module provides a platform- and database-independent interface for
accessing SQL databases, and a set of classes for integrating databases intothe user interface.
The chapter begins by showing how to open database connections and how
to execute arbitrary SQL statements on a database. The second and thirdsections focus on providing the user with ways of viewing and modifying adatabase through the user interface, using
QDataTable to present data in a
table widget and using QSqlForm to present data as a form. These classes are
designed to interact nicely with each other, making common database idiomssuch as master–detail views and drill-down easy to implement.
Connecting and Querying
Toexecute SQL queries, we must ﬁrst establish a connection with a database.
Typically, database connections are set up in a separate function that we callat application startup. For example:
bool createConnection()
{    QSqlDatabase *db = QSqlDatabase::addDatabase("QOCI8");    db->setHostName("mozart.konkordia.edu");    db->setDatabaseName("musicdb");    db->setUserName("gbatstone");    db->setPassword("T17aV44");    if (!db->open()) {        db->lastError().showMessage();        return false;    }    return true;}
261
262 12. Databases
First, we call QSqlDatabase::addDatabase() to create a QSqlDatabase object.
The argument to addDatabase() speciﬁes which database driver Qt must use
to access the database. In this case, we use Oracle. The commercial versionof Qt 3.2 includes the following drivers:
QODBC3 (ODBC), QOCI8 (Oracle), QTDS7
(Sybase Adaptive Server), QPSQL7 (PostgreSQL), QMYSQL3 (MySQL), and QDB2
(IBM DB2). The free and non-commercial editions contain a subset of these.#
Seehttp://doc.trolltech.com/3.2/sql-driver.html for information on build-
ing the database drivers.
Next, we set the database host name, the database name, the user name, and
the password, and we try to open the connection. If open() fails, we show an
error message using QSqlError::showMessage() .
Typically, we would call createConnection() inmain() :
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    if (!createConnection())        return 1;
···
    return app.exec();
}
Once a connection is established, we can use QSqlQuery to execute any SQL
statement that the underlying database supports. For example, here’s how toexecute a
SELECT statement:
QSqlQuery query;
query.exec("SELECT title, year FROM cd WHERE year >= 1998");
After the exec() call, we can navigate through the query’s result set:
while (query.next()) {    QString title = query.value(0).toString();    int year = query.value(1).toInt();    cerr << title.ascii() << ": " << year << endl;}
Wecallnext() once to position the QSqlQuery on the ﬁrst record of the result
set. Subsequent calls to next() advance the record pointer by one record each
time, until the end is reached,at which point next() returns false .Ifthe result
set is empty, the ﬁrst call to next() will return false .
Thevalue() function returns the value of a ﬁeld as a QVariant .The ﬁelds are
numbered from 0 in the order given in the SELECT statement. The QVariant
class can hold many C ++and Qt types, including intandQString .The differ-
ent types of data that can be stored in a database are mapped into the corre-sponding C ++and Qt types and stored in
QVariant s.Forexample, a VARCHAR is
represented as a QString and aDATETIME as aQDateTime .
#The Qt packages on the accompanying CD include SQLite, a public domain in-process database,
andQSQLITEX ,anexperimental driver. These are only intended for use with the examples on
the CD.
Connecting and Querying 263
QSqlQuery provides some other functions to navigate through the result set:
first() ,last() ,prev() ,seek() ,andat().These functions are convenient, but
for some databases they can be slow and memory-hungry. For an easy opti-mization when operating on large data sets, we can call
QSqlQuery::setFor-
wardOnly(true) before calling exec() ,and then only use next() for navigating
the result set.
Earlier we speciﬁed the SQL query as an argument to exec() ,but we can also
pass it directly to the constructor, which executes it immediately:
QSqlQuery query("SELECT title, year FROM cd WHERE year >= 1998");
Here’s how we would check for an error and pop up a QMessageBox if a problem
occurred:
if (!query.isActive())
    query.lastError().showMessage();
Doing an INSERT is almost as easy as doing a SELECT :
QSqlQuery query("INSERT INTO cd (id, artistid, title, year) "                "VALUES (203, 102, ’Living in America’, 2002)");
After this, QSqlQuery::numRowsAffected() returns the number of rows that
were affected by the SQL statement (or +--1ifthe database cannot provide
that information).
If we need to insert a lot of records, or if we want to avoid converting values
to strings (and escaping them correctly), we can use prepare() to specify a
query that contains placeholders and then bind the values we want to insert.Qt supports both the Oracle-style and the ODBC-style syntax for placeholdersfor all databases, using native support where it is available and simulating itotherwise. Here’s an example that uses the Oracle-style syntax with namedplaceholders:
QSqlQuery query(db);
query.prepare("INSERT INTO cd (id, artistid, title, year) "              "VALUES (:id, :artistid, :title, :year)");query.bindValue(":id", 203);query.bindValue(":artistid", 102);query.bindValue(":title", QString("Living in America"));query.bindValue(":year", 2002);query.exec();
Here’s the same example using ODBC-style positional placeholders:
QSqlQuery query(db);query.prepare("INSERT INTO cd (id, artistid, title, year) "              "VALUES (?, ?, ?, ?)");query.addBindValue(203);query.addBindValue(102);query.addBindValue(QString("Living in America"));query.addBindValue(2002);query.exec();
264 12. Databases
After the call to prepare() ,wecan call bindValue() oraddBindValue() to bind
new values, then call exec() again to execute the query with the new values.
Placeholders are often used to specify binary data or strings that contain non-
ASCII or non-Latin-1 characters. Behind the scenes, Qt uses Unicode withthose databases that support Unicode, and for those that don’t, Qt transpar-ently converts strings to the appropriate encoding.
Qt supports SQL transactions on databases where they are available. To start
atransaction, we call
transaction() on theQSqlDatabase object that represents
the database connection. To terminate the transaction,we call either commit()
orrollback() .For example, here’s how we would look up a foreign key and
execute an INSERT statement inside a transaction:
QSqlDatabase::database()->transaction();
QSqlQuery query;query.exec("SELECT id FROM artist WHERE name = ’Gluecifer’");if (query.next()) {    int artistId = query.value(0).toInt();    query.exec("INSERT INTO cd (id, artistid, title, year) "               "VALUES (201, " + QString::number(artistId)               + ", ’Riding the Tiger’, 1997)");}QSqlDatabase::database()->commit();
TheQSqlDatabase::database() function returns a pointer to the QSqlDatabase
object we created in createConnection() .Ifatransaction cannot be started,
QSqlDatabase::transaction() returns false .
Some databases don’t support transactions. For those, the transaction() ,com-
mit() ,androllback() functions do nothing. We can test whether a database
supports transactions using hasFeature() on theQSqlDriver associated with
the database:
QSqlDriver *driver = QSqlDatabase::database()->driver();
if (driver->hasFeature(QSqlDriver::Transactions))
···
In the examples so far, we have assumed that the application is using a single
database connection. If we want to use multiple connections, we can pass aname as second argument to
addDatabase() .For example:
QSqlDatabase *db = QSqlDatabase::addDatabase("QPSQL7", "OTHER");
db->setHostName("saturn.mcmanamy.edu");db->setDatabaseName("starsdb");db->setUserName("gilbert");db->setPassword("ixtapa6");
Wecan then retrieve a pointer to the QSqlDatabase object by passing the name
toQSqlDatabase::database() :
QSqlDatabase *db = QSqlDatabase::database("OTHER");
Toexecute queries using the other connection, we pass the QSqlDatabase object
to theQSqlQuery constructor:
Connecting and Querying 265
QSqlQuery query(db);
query.exec("SELECT id FROM artist WHERE name = ’Mando Diao’");
Multiple connections are useful if we want to perform more than one transac-
tion at a time, since each connection can only handle a single active transac-tion. When we use multiple database connections, we can still have one name-less connection, and
QSqlQuery will use that connection if none is speciﬁed.
In addition to QSqlQuery ,Qtprovides the QSqlCursor class, a higher-level class
that inherits QSqlQuery and extends it with convenience functions so that
we can avoid typing raw SQL for performing the most common SQL opera-tions:
SELECT ,INSERT ,UPDATE ,andDELETE .QSqlCursor is also the class that ties a
QDataTable to a database. We will cover QSqlCursor here, and in the next sec-
tion we will see how to use QDataTable ,adatabase-aware QTable subclass.
Here’s an example that uses QSqlCursor to perform a SELECT :
QSqlCursor cursor("cd");
cursor.select("year >= 1998");
An equivalent QSqlQuery would be
QSqlQuery query("SELECT id, artistid, title, year FROM cd "                "WHERE year >= 1998");
Navigating through the result set is the same as for QSqlQuery ,except that we
can pass ﬁeld names to value() instead of ﬁeld numbers:
while (cursor.next()) {
    QString title = cursor.value("title").toString();    int year = cursor.value("year").toInt();    cerr << title.ascii() << ": " << year << endl;}
Toinsert a record into a table, we must ﬁrst call primeInsert() ,which returns
apointer to a new QSqlRecord .Then we call setValue() for each of the ﬁelds
in theQSqlRecord that we want to set, and we call insert() to insert the
QSqlRecord ’sdata into the database. For example:
QSqlCursor cursor("cd");
QSqlRecord *buffer = cursor.primeInsert();buffer->setValue("id", 113);buffer->setValue("artistid", 224);buffer->setValue("title", "Shanghai My Heart");buffer->setValue("year", 2003);cursor.insert();
Toupdate a record,we must ﬁrst position the QSqlCursor on the record we want
to modify (for example, using select() andnext() ). Then we call primeUpdate()
to get a pointer to a QSqlRecord that contains a copy of the record’s data. We
can then use setValue() to set the ﬁelds we want to change, and call update()
to write these changes back to the database. For example:
QSqlCursor cursor("cd");
cursor.select("id = 125");
266 12. Databases
if (cursor.next()) {
    QSqlRecord *buffer = cursor.primeUpdate();    buffer->setValue("title", "Melody A.M.");    buffer->setValue("year", buffer->value("year").toInt() + 1);    cursor.update();}
Deleting a record is similar to updating, but easier:
QSqlCursor cursor("cd");cursor.select("id = 128");if (cursor.next()) {    cursor.primeDelete();    cursor.del();}
TheQSqlQuery andQSqlCursor classes provide an interface between Qt and
aSQL database. In the next two sections, we will see how to use them from
within a GUI application to allow the user to view and interact with the datastored in a database.
Presenting Data in Tabular Form
TheQDataTable class is a database-aware QTable widget that supports brows-
ing and editing. It interacts with a database through a QSqlCursor .Here, we
will review two dialogs that use QDataTable .Together with the QSqlForm -based
dialog presented in the next section, these forms constitute the CD Collectionapplication.
The application uses three tables, deﬁned as follows:
CREATE TABLE artist (
    id INTEGER PRIMARY KEY,    name VARCHAR(40) NOT NULL,    country VARCHAR(40));
CREATE TABLE cd (
    id INTEGER PRIMARY KEY,    artistid INTEGER NOT NULL,    title VARCHAR(40) NOT NULL,    year INTEGER NOT NULL,    FOREIGN KEY (artistid) REFERENCES artist);
CREATE TABLE track (
    id INTEGER PRIMARY KEY,    cdid INTEGER NOT NULL,    number INTEGER NOT NULL,    title VARCHAR(40) NOT NULL,    duration INTEGER NOT NULL,    FOREIGN KEY (cdid) REFERENCES cd);
Some databases don’t support foreign keys. For those, we must remove the
FOREIGN KEY clauses. The example will still work, but the database will not
enforce referential integrity.
Presenting Data in Tabular Form 267
track
id
cdid
number
title
durationartist
id
name
countrycd
id
artistid
title
year1:N 1:N
Figure 12.1. The CD Collection application’s tables
The ﬁrst class that we will write is a dialog that allows the user to edit a list
of artists. The user can insert, update, or delete artists using the QDataTable ’s
context menu. The changes are applied to the database when the user clicks
Update .
Figure 12.2. TheArtistForm dialog
Here’s the class deﬁnition for the dialog:
class ArtistForm : public QDialog
{    Q_OBJECTpublic:    ArtistForm(QWidget *parent = 0, const char *name = 0);
protected slots:
    void accept();    void reject();
private slots:
    void primeInsertArtist(QSqlRecord *buffer);    void beforeInsertArtist(QSqlRecord *buffer);    void beforeDeleteArtist(QSqlRecord *buffer);
private:
    QSqlDatabase *db;    QDataTable *artistTable;    QPushButton *updateButton;
268 12. Databases
    QPushButton *cancelButton;
};
Theaccept() andreject() slots are reimplemented from QDialog .
ArtistForm::ArtistForm(QWidget *parent, const char *name)    : QDialog(parent, name){    setCaption(tr("Update Artists"));
    db = QSqlDatabase::database("ARTIST");
    db->transaction();
    QSqlCursor *artistCursor = new QSqlCursor("artist", true, db);
    artistTable = new QDataTable(artistCursor, false, this);    artistTable->addColumn("name", tr("Name"));    artistTable->addColumn("country", tr("Country"));    artistTable->setAutoDelete(true);    artistTable->setConfirmDelete(true);    artistTable->setSorting(true);    artistTable->refresh();
    updateButton = new QPushButton(tr("Update"), this);
    updateButton->setDefault(true);    cancelButton = new QPushButton(tr("Cancel"), this);
In theArtistForm constructor, we start a transaction using the “ARTIST”
database connection. Then we create a QSqlCursor on the database’s artist
table, and a QDataTable to display it.
The second argument to the QSqlCursor constructor is an “auto-populate” ﬂag.
By passing true,wetellQSqlCursor to load information about every ﬁeld in the
table and to operate on all the ﬁelds.
TheQDataTable constructor’s second argument is also an auto-populate ﬂag.
Iftrue,theQDataTable automatically creates columns for each ﬁeld in the
QSqlCursor ’sresult set. We pass false and call addColumn() to provide two
columns corresponding to the result set’s name andcountry ﬁelds.
Wepass ownership of the QSqlCursor to theQDataTable by calling setAuto-
Delete() ,sowedon’t need to delete it ourselves. We call setConfirmDelete()
to make the QDataTable pop up a message box asking the user to conﬁrm dele-
tions. We call setSorting(true) to allow the user to click on the column head-
ers to sort the table according to a certain column. Finally, we call refresh()
to populate the QDataTable with data from the database.
Wealso create an Update and a Cancel button.
    connect(artistTable, SIGNAL(beforeDelete(QSqlRecord *)),
            this, SLOT(beforeDeleteArtist(QSqlRecord *)));    connect(artistTable, SIGNAL(primeInsert(QSqlRecord *)),            this, SLOT(primeInsertArtist(QSqlRecord *)));    connect(artistTable, SIGNAL(beforeInsert(QSqlRecord *)),            this, SLOT(beforeInsertArtist(QSqlRecord *)));    connect(updateButton, SIGNAL(clicked()),            this, SLOT(accept()));
Presenting Data in Tabular Form 269
    connect(cancelButton, SIGNAL(clicked()),
            this, SLOT(reject()));
Weconnect three of the QDataTable ’ssignals to three private slots. We connect
theUpdate button to accept() and the Cancel button to reject() .
    QHBoxLayout *buttonLayout = new QHBoxLayout;
    buttonLayout->addStretch(1);    buttonLayout->addWidget(updateButton);    buttonLayout->addWidget(cancelButton);
    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout->setMargin(11);    mainLayout->setSpacing(6);    mainLayout->addWidget(artistTable);    mainLayout->addLayout(buttonLayout);}
Finally, we put the QPushButton sinto a horizontal layout, and we put the
QDataTable and the horizontal layout into a vertical layout.
void ArtistForm::accept()
{    db->commit();    QDialog::accept();}
If the user clicks Update ,wecommit the transaction and call the base class’s
accept() function.
void ArtistForm::reject()
{    db->rollback();    QDialog::reject();}
If the user clicks Cancel ,weroll back the transaction and call the base class’s
reject() function.
void ArtistForm::beforeDeleteArtist(QSqlRecord *buffer)
{    QSqlQuery query(db);    query.exec("DELETE FROM track WHERE track.id IN "               "(SELECT track.id FROM track, cd "               "WHERE track.cdid = cd.id AND cd.artistid = "               + buffer->value("id").toString() + ")");    query.exec("DELETE FROM cd WHERE artistid = "               + buffer->value("id").toString());}
ThebeforeDeleteArtist() slot is connected to the QDataTable ’sbeforeDelete()
signal, which is emitted just before a record is deleted. Here, we perform a
cascading delete by executing two queries: one to delete all the tracks fromCDs by the artist and one to delete all the CDs by the artist. Performing thesedeletions does not risk relational integrity, because they are all done withinthe context of the transaction that began in the form’s constructor.
270 12. Databases
Another approach would have been to prevent the user from deleting artists
that are referred to by the cdtable. To achieve this, we would have to reim-
plement QDataTable::contextMenuEvent() so that we could handle the deletion
ourselves. A crude alternative that will work if the database has been set upto enforce relational integrity is to simply attempt the deletion and leave it tothe database to prevent it.
void ArtistForm::primeInsertArtist(QSqlRecord *buffer)
{    buffer->setValue("country", "USA");}
TheprimeInsertArtist() slot is connected to the QDataTable ’sprimeInsert()
signal, which is emitted just before the user starts editing a new record. We
use it to set the default value of the new record’s country ﬁeld to “USA”, the
ideal default for a U.S.-centric application.
This is one way of setting default values for ﬁelds. Another way is to subclass
QSqlCursor and reimplement primeInsert() ,which makes sense if we will use
the same QSqlCursor many times in the same application and want to ensure
consistent behavior. A third way is to do it at the database level, using DEFAULT
clauses in the CREATE TABLE statements.
void ArtistForm::beforeInsertArtist(QSqlRecord *buffer)
{    buffer->setValue("id", generateId("artist", db));}
ThebeforeInsertArtist() slot is connected to the QDataTable ’sbeforeInsert()
signal, which is emitted when the user has ﬁnished editing a new record and
presses Enter to save it. We set the value of the idﬁeld to a generated value.
Werely on a function called generateId() to produce a unique primary key.
Since we will need generateId() afew times, we deﬁne it inline in a header
ﬁle and include it each time we need it. Here’s a quick (and inefﬁcient) way ofimplementing it:
inline int generateId(const QString &table, QSqlDatabase *db)
{    QSqlQuery query(db);    query.exec("SELECT max(id) FROM " + table);    query.next();    return query.value(0).toInt() + 1;}
ThegenerateId() function can only be guaranteed to work correctly if it is
executed within the context of the same transaction as the corresponding
INSERT statement.
Some databases support auto-generated ﬁelds. For these, we simply need
to tell the database to auto-generate the idﬁeld and call setGenerated("id",
false) on theQSqlCursor to tell it notto generate the value of the idﬁeld.
Presenting Data in Tabular Form 271
Wewill now review another dialog that uses QDataTable .For this dialog, we
will implement a master–detail view. The master view is a list of CDs. Thedetail view is a list of tracks for the current CD. This dialog is the mainwindow of the CD Collection application.
This time, we provide
Add,Edit,and Delete buttons to allow the user to modify
the CD list, rather than relying on a context menu. When the user clicks Add
orEdit,aCdForm dialog pops up. ( CdForm is covered in the next section.)
Figure 12.3. TheMainForm dialog
Another difference between this example and the previous one is that we must
resolve a foreign key,so we can show the artist’s name and country rather thanthe artist’s ID. To accomplish this, we must use
QSqlSelectCursor ,asubclass of
QSqlCursor that supports arbitrary SELECT statements, in this case a join.
First, the class deﬁnition:
class MainForm : public QDialog
{    Q_OBJECTpublic:    MainForm(QWidget *parent = 0, const char *name = 0);
private slots:
    void addCd();    void editCd();    void deleteCd();    void currentCdChanged(QSqlRecord *record);
private:
    QSplitter *splitter;    QDataTable *cdTable;    QDataTable *trackTable;    QPushButton *addButton;
···
272 12. Databases
    QPushButton *quitButton;
};
TheMainForm class inherits from QDialog .
MainForm::MainForm(QWidget *parent, const char *name)    : QDialog(parent, name){    setCaption(tr("CD Collection"));
    splitter = new QSplitter(Vertical, this);    QSqlSelectCursor *cdCursor = new QSqlSelectCursor(
                    "SELECT cd.id, title, name, country, year "                    "FROM cd, artist WHERE cd.artistid = artist.id");    if (!cdCursor->isActive()) {        QMessageBox::critical(this, tr("CD Collection"),                tr("The database has not been created.\n"                "Run the cdtables example to create a sample "                "database, then copy cdcollection.dat into "                "this directory and restart this application."));        qApp->quit();    }
    cdTable = new QDataTable(cdCursor, false, splitter);
    cdTable->addColumn("title", tr("CD"));    cdTable->addColumn("name", tr("Artist"));    cdTable->addColumn("country", tr("Country"));    cdTable->addColumn("year", tr("Year"));    cdTable->setAutoDelete(true);    cdTable->refresh();
In the constructor, we create a read-only QDataTable for thecdtable and its as-
sociated cursor. The cursor is based on a query that joins the cdand the artist
tables. The QDataTable is read-only because it operates on a QSqlSelectCursor .
Read-only tables don’t provide a context menu.
If the cursor query fails, we pop up a message box indicating that something
is wrong and terminate the application.
    QSqlCursor *trackCursor = new QSqlCursor("track");
    trackCursor->setMode(QSqlCursor::ReadOnly);    trackTable = new QDataTable(trackCursor, false, splitter);    trackTable->setSort(trackCursor->index("number"));    trackTable->addColumn("title", tr("Track"));    trackTable->addColumn("duration", tr("Duration"));
Wecreate the second QDataTable and its cursor. We make the table read-only
by calling setMode(QSqlCursor::ReadOnly) on the cursor, and call setSort() to
sort the tracks by track number.
    addButton = new QPushButton(tr("&Add"), this);
    editButton = new QPushButton(tr("&Edit"), this);    deleteButton = new QPushButton(tr("&Delete"), this);    refreshButton = new QPushButton(tr("&Refresh"), this);    quitButton = new QPushButton(tr("&Quit"), this);
Presenting Data in Tabular Form 273
    connect(addButton, SIGNAL(clicked()),
            this, SLOT(addCd()));
···
    connect(quitButton, SIGNAL(clicked()),
            this, SLOT(close()));    connect(cdTable, SIGNAL(currentChanged(QSqlRecord *)),            this, SLOT(currentCdChanged(QSqlRecord *)));    connect(cdTable,            SIGNAL(doubleClicked(int, int, int, const QPoint &)),            this, SLOT(editCd()));
···
}
Weset up the rest of the user interface and create the signal–slot connections
necessary to produce the desired behavior.
void MainForm::addCd()
{    CdForm form(this);    if (form.exec()) {        cdTable->refresh();        trackTable->refresh();    }}
When the user clicks Add,wepop up a modal CdForm dialog, and if the user
clicks Update on it, we refresh the QDataTable s.
void MainForm::editCd()
{    QSqlRecord *record = cdTable->currentRecord();    if (record) {        CdForm form(record->value("id").toInt(), this);        if (form.exec()) {            cdTable->refresh();            trackTable->refresh();        }    }}
When the user clicks Edit,wepop up a modal CdForm dialog, with the current
CD’s ID as argument to the CdForm constructor. This will cause the dialog to
start up with its ﬁelds populated with the current CD’s data.
When we parameterize a form with an ID as we have done here, it is possible
that the ID will not be valid by the time the form appears. For example, theuser could click
Editafraction of a second before another user deletes the
CD. What we could have done in CdForm is to execute a SELECT on the ID that
is passed in immediately after the transaction() call and only proceed if the
ID still exists. Here, we simply rely on the database to report an error if anattempt to use an invalid ID is made.
void MainForm::deleteCd()
{    QSqlRecord *record = cdTable->currentRecord();
274 12. Databases
    if (record) {
        QSqlQuery query;        query.exec("DELETE FROM track WHERE cdid = "                   + record->value("id").toString());        query.exec("DELETE FROM cd WHERE id = "                   + record->value("id").toString());        cdTable->refresh();        trackTable->refresh();    }}
When the user clicks Delete ,weremove all the tracks for the current CD from
thetrack table and then the current CD from the cdtable. Then we update
both tables.
void MainForm::currentCdChanged(QSqlRecord *record)
{    trackTable->setFilter("cdid = "                          + record->value("id").toString());    trackTable->refresh();}
ThecurrentCdChanged() slot is connected to the cdTable ’scurrentChanged()
signal, which is emitted when the user modiﬁes the current CD or when the
user makes another CD current. Whenever the current CD changes, we call
setFilter() on thetrack table and refresh it to make it display the tracks
related to the current CD, and we call refresh() to force the table to repopulate
itself with the relevant data.
This is all the code that is needed to implement MainForm .One possible im-
provement would be to show the duration of each track split into minutes andseconds (for example, “02:35”) rather than just as seconds (“155”). We couldaccomplish this by subclassing
QSqlCursor and reimplementing the calculate-
Field() function to transform the duration ﬁeld into a QString with the desired
format:
QVariant TrackSqlCursor::calculateField(const QString &name)
{    if (name == "duration") {        int duration = value("duration").toInt();        return QString("%1:%2").arg(duration / 60, 2)                               .arg(duration % 60, 2);    }    return QVariant();}
Wewould also need to call setCalculated("duration", true) on the cursor to
tellQDataTable to use the value returned by calculateField() for theduration
ﬁeld, instead of simply using value() .
Creating Data-Aware Forms 275
Creating Data-Aware Forms
Qt takes an innovative approach to database interaction with forms. Instead
of having a separate database-enabled version of every built-in widget, Qt isable to make any widget data-aware, using
QSqlForm andQSqlPropertyMap to
relate database ﬁelds to widgets. Any built-in or custom widget can be madedata-aware using these classes.
QSqlForm is aQObject subclass that makes it easy to create forms to browse or
edit individual records in a database. The common pattern of usage is this:
1. Create the editor widgets ( QLineEdit s,QComboBox es,QSpinBox es, etc.) for the
record’s ﬁelds.
2. Create a QSqlCursor and move it to the record to edit.
3. Create a QSqlForm object.
4. Tell the QSqlForm which editor widget is bound to which database ﬁeld.
5. Call the QSqlForm::readFields() function to populate the editor widgets
with the data from the current record.
6. Show the dialog.
7. Call the QSqlForm::writeFields() function to copy the updated values
back into the database.
Toillustrate this, we will look at the code for the CdForm dialog. This dialog
allows the user to create or edit a CD record. The user can specify the CD’stitle, artist, and release year, and the title and duration of each track.
Figure 12.4. TheCdForm dialog
Let’s start with the class deﬁnition:
class CdForm : public QDialog
{
276 12. Databases
    Q_OBJECT
public:    CdForm(QWidget *parent = 0, const char *name = 0);    CdForm(int id, QWidget *parent = 0, const char *name = 0);    ~CdForm();
protected slots:
    void accept();    void reject();
private slots:
    void addNewArtist();    void moveTrackUp();    void moveTrackDown();    void beforeInsertTrack(QSqlRecord *buffer);    void beforeDeleteTrack(QSqlRecord *buffer);
private:
    void init();    void createNewRecord();    void swapTracks(int trackA, int trackB);
    QLabel *titleLabel;
    QLabel *artistLabel;
···
    QDataTable *trackTable;
    QSqlForm *sqlForm;    QSqlCursor *cdCursor;    QSqlCursor *trackCursor;    int cdId;    bool newCd;};
Wehave declared two constructors: one for inserting a new CD into the
database, the other for updating an existing CD. The accept() andreject()
slots are reimplemented from QDialog .
CdForm::CdForm(QWidget *parent, const char *name)
    : QDialog(parent, name){    setCaption(tr("Add a CD"));    cdId = -1;    init();}
The ﬁrst constructor sets the dialog’s caption to “Add a CD” and calls the
privateinit() function to do the rest.
CdForm::CdForm(int id, QWidget *parent, const char *name)
    : QDialog(parent, name){    setCaption(tr("Edit a CD"));    cdId = id;    init();}
The second constructor sets the caption to “Edit a CD” and also calls init() .
Creating Data-Aware Forms 277
void CdForm::init()
{    db = QSqlDatabase::database("CD");    db->transaction();    if (cdId == -1)        createNewRecord();
Ininit() ,westart a transaction using the “CD” database connection. We need
to use different connections in CdForm andArtistForm ,because we can have
both forms open at the same time, and we don’t want one form to roll back thetransaction initiated by the other form.
If we have no CD to operate on, we call the private function
createNewRecord()
to insert a blank one into the database. This will allow us to use the CD ID as
aforeign key in the tracks’ QDataTable .Ifthe user clicks Cancel ,weroll back
the transaction and the blank record will disappear.
Forthis dialog, we use a different connection to the database than in the
ArtistForm .This is because we can only have one active transaction per connec-
tion, and we can end up in a situation where we need two, for example, if theuser clicks
Add New to pop up the ArtistForm .
    titleLabel = new QLabel(tr("&Title:"), this);
    artistLabel = new QLabel(tr("&Artist:"), this);    yearLabel = new QLabel(tr("&Year:"), this);    titleLineEdit = new QLineEdit(this);    yearSpinBox = new QSpinBox(this);    yearSpinBox->setRange(1900, 2100);    yearSpinBox->setValue(QDate::currentDate().year());    artistComboBox = new ArtistComboBox(db, this);    artistButton = new QPushButton(tr("Add &New..."), this);
···
    cancelButton = new QPushButton(tr("Cancel"), this);
Wecreate the labels, the line edit, the spin box, the combobox, and the buttons
that form the user interface. The combobox is of type ArtistComboBox ,which
we will cover later on.
    trackCursor = new QSqlCursor("track", true, db);
    trackTable = new QDataTable(trackCursor, false, this);    trackTable->setFilter("cdid = " + QString::number(cdId));    trackTable->setSort(trackCursor->index("number"));    trackTable->addColumn("title", tr("Track"));    trackTable->addColumn("duration", tr("Duration"));    trackTable->refresh();
Weset up the QDataTable that allows the user to browse and edit the tracks
on the current CD. This is very similar to what we did in the previous sectionwith the
ArtistForm class.
    cdCursor = new QSqlCursor("cd", true, db);
    cdCursor->select("id = " + QString::number(cdId));    cdCursor->next();
Weset up the QSqlCursor associated with the QSqlForm and make it point to the
record with the correct ID.
278 12. Databases
    QSqlPropertyMap *propertyMap = new QSqlPropertyMap;
    propertyMap->insert("ArtistComboBox", "artistId");    sqlForm = new QSqlForm(this);    sqlForm->installPropertyMap(propertyMap);    sqlForm->setRecord(cdCursor->primeUpdate());    sqlForm->insert(titleLineEdit, "title");    sqlForm->insert(artistComboBox, "artistid");    sqlForm->insert(yearSpinBox, "year");    sqlForm->readFields();
Wecreate a QSqlPropertyMap .TheQSqlPropertyMap class tells QSqlForm which
Qt property holds the value of a certain type of editor widget. By default,
QSqlForm already knows that a QLineEdit stores its value in the text property
and that a QSpinBox stores its value in the value property. But it doesn’t know
anything about custom widgets such as ArtistComboBox .Byinserting the pair
(“ArtistComboBox”, “artistId”) in the property map and by calling install-
PropertyMap() on theQSqlForm ,wetellQSqlForm to use the artistId property for
widgets of type ArtistComboBox .
TheQSqlForm object also needs a buffer to operate on, which we obtain by
callingprimeUpdate() on theQSqlCursor ,and it needs to know which editor
widget corresponds to which database ﬁeld. At the end, we call readFields()
to read the data from the database into the editor widgets.
    connect(artistButton, SIGNAL(clicked()),
            this, SLOT(addNewArtist()));    connect(moveUpButton, SIGNAL(clicked()),            this, SLOT(moveTrackUp()));    connect(moveDownButton, SIGNAL(clicked()),            this, SLOT(moveTrackDown()));    connect(updateButton, SIGNAL(clicked()),            this, SLOT(accept()));    connect(cancelButton, SIGNAL(clicked()),            this, SLOT(reject()));    connect(trackTable, SIGNAL(beforeInsert(QSqlRecord *)),            this, SLOT(beforeInsertTrack(QSqlRecord *)));
···
}
Weconnect the buttons’ clicked() signals and the QDataTable ’sbeforeInsert()
signal to the private slots that are described next.
void CdForm::accept()
{    sqlForm->writeFields();    cdCursor->update();    db->commit();    QDialog::accept();}
If the user clicks Update ,wewrite the data into the QSqlCursor ’sedit buffer,
we call update() to perform an UPDATE on the database, we call commit() to
really write the record into the database, and we call the base class’s accept()
implementation to close the form.
Creating Data-Aware Forms 279
void CdForm::reject()
{    db->rollback();    QDialog::reject();}
If the user clicks Cancel ,weroll back, leaving the database unchanged, and
close the form.
void CdForm::addNewArtist()
{    ArtistForm form(this);    if (form.exec()) {        artistComboBox->refresh();        updateButton->setEnabled(artistComboBox->count() > 0);    }}
If the user clicks Add New ,wepop up a modal ArtistForm dialog. The dialog
allows the user to add new artists, and also to edit and delete existing artists.If the user clicks
Update ,wecallArtistComboBox::refresh() to ensure that its
list of artists is up to date.
Weenable or disable the Update button depending on whether there are
any artists, since we don’t want to allow a new CD to be created without anartist name.
void CdForm::beforeInsertTrack(QSqlRecord *buffer)
{    buffer->setValue("id", generateId("track", db));    buffer->setValue("number", trackCursor->size() + 1);    buffer->setValue("cdid", cdId);}
ThebeforeInsertTrack() slot is connected to the QDataTable ’sbeforeInsert()
signal. We set the record’s id,number ,andcdid ﬁelds.
void CdForm::beforeDeleteTrack(QSqlRecord *buffer)
{    QSqlQuery query(db);    query.exec("UPDATE track SET number = number - 1 "               "WHERE track.number > "               + buffer->value("number").toString());}
ThebeforeDeleteTrack() slot is connected to the QDataTable ’sbeforeDelete()
signal. We renumber all the tracks that have a number higher than the track
we delete to ensure that the track numbers remain consecutive. For example,if the CD contains six tracks and the user deletes track 4, then track 5 becomestrack 4 and track 6 becomes track 5.
There are four functions that we have not covered:
moveTrackUp() ,moveTrack-
Down() ,swapTracks() ,andcreateNewRecord() .These are necessary to make
the application usable, but their implementations do not show any new tech-niques, so we will not review them here. Their source code is on the CD.
280 12. Databases
Now that we have seen all the forms in the CD Collection application, we
are ready to review the custom ArtistComboBox .Asusual, we start with the
class deﬁnition:
class ArtistComboBox : public QComboBox
{    Q_OBJECT    Q_PROPERTY(int artistId READ artistId WRITE setArtistId)public:    ArtistComboBox(QSqlDatabase *database, QWidget *parent = 0,                   const char *name = 0);
    void refresh();
    int artistId() const;    void setArtistId(int id);
private:
    void populate();
    QSqlDatabase *db;
    QMap<int, int> idFromIndex;    QMap<int, int> indexFromId;};
TheArtistComboBox class inherits QComboBox and adds an artistId property and
afew functions.
In the private section, we declare a QMap<int,int> that associates artist IDs
with combobox indexes and a QMap<int,int> that associates combobox indexes
with artist IDs.
ArtistComboBox::ArtistComboBox(QSqlDatabase *database,
                               QWidget *parent, const char *name)    : QComboBox(parent, name){    db = database;    populate();}
In the constructor, we call the private function populate() to ﬁll the combobox
with the names and IDs in the artist table.
void ArtistComboBox::refresh()
{    int oldArtistId = artistId();    clear();    idFromIndex.clear();    indexFromId.clear();    populate();    setArtistId(oldArtistId);}
In therefresh() function, we repopulate the combobox with the latest data
from the database. We are also careful to ensure that the artist who wasselected before the refresh is still selected afterward, unless that artist hashave been deleted from the database.
Creating Data-Aware Forms 281
void ArtistComboBox::populate()
{    QSqlCursor cursor("artist", true, db);    cursor.select(cursor.index("name"));
    int index = 0;
    while (cursor.next()) {        int id = cursor.value("id").toInt();        insertItem(cursor.value("name").toString(), index);        idFromIndex[index] = id;        indexFromId[id] = index;        ++index;    }}
In the private function populate() ,weiterate through all the artists and call
QComboBox::insertItem() to add them to the combobox. We also update the
idFromIndex and the indexFromId maps.
int ArtistComboBox::artistId() const
{    return idFromIndex[currentItem()];}
TheartistId() function returns the ID for the current artist.
void ArtistComboBox::setArtistId(int id){    if (indexFromId.contains(id))        setCurrentItem(indexFromId[id]);}
ThesetArtistId() function sets the current artist based on an artist ID.
In applications that often need comboboxes that show foreign keys, it would
probably be worthwhile creating a generic DatabaseComboBox class whose
constructor would allow us to specify the table name, the ﬁeld to display, andthe ﬁeld to use for IDs.
Let’s ﬁnish the CD Collection application by implementing its
createConnec-
tions() andmain() functions.
inline bool createOneConnection(const QString &name)
{    QSqlDatabase *db;    if (name.isEmpty())        db = QSqlDatabase::addDatabase("QSQLITEX");    else        db = QSqlDatabase::addDatabase("QSQLITEX", name);    db->setDatabaseName("cdcollection.dat");    if (!db->open()) {        db->lastError().showMessage();        return false;    }    return true;}
282 12. Databases
inline bool createConnections()
{    return createOneConnection("")            && createOneConnection("ARTIST")            && createOneConnection("CD");}
IncreateConnections() ,wecreate three identical connections to the CD data-
base. We don’t give any name to the ﬁrst one; it is used by default when wedon’t specify a database. The other ones are called “ARTIST” and “CD”; theyare used by
ArtistForm andCdForm .
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    if (!createConnections())        return 1;
    MainForm mainForm;
    app.setMainWidget(&mainForm);    mainForm.resize(480, 320);    mainForm.show();    return app.exec();}
Themain() function is the same as most other Qt main() functions, except for
the addition of a createConnections() call.
As we mentioned at the end of the previous section, one possible improvement
would be to display the duration of each track as minutes and seconds ratherthan just seconds. Besides reimplementing
QSqlCursor::calculateField() ,
this would also involve subclassing QSqlEditorFactory to provide a custom
editor (which we could base on QTimeEdit )and using a QSqlPropertyMap to tell
QDataTable how to get the value back from the editor. See the documentation
forQDataTable ’sinstallEditorFactory() andinstallPropertyMap() functions
for more information.
Another improvement would be to store an image of each CD’s cover in the
database and to show it in the CdForm .Toimplement this, we could store the
image data as a BLOB in the database, retrieve it as a QByteArray ,and pass the
QByteArray to theQImage constructor.
1313
Networking•Using QFtp
•Using QHttp
•TCP Networking with
QSocket
•UDP Networking with
QSocketDevice
Qt provides the QFtp andQHttp classes for working with FTP and HTTP. These
protocols are easy to use for downloading and uploading ﬁles and, in the caseof HTTP, for sending requests to web servers and retrieving the results.
Qt’s
QFtp andQHttp classes are built on the lower-level QSocket class, which
provides a TCP socket.TCP operates in terms of data streams transmitted be-tween network nodes.
QSocket is in turn implemented on top of QSocketDevice ,
athin wrapper around the platform-speciﬁc network APIs. The QSocketDevice
class supports both TCP and UDP.
In this chapter, we will learn how to use the four classes mentioned above and
other closely related classes, like QServerSocket andQSocketNotifier .Wewill
also cover uploading and downloading ﬁles and how to use a web form pro-grammatically. We will use TCP in a server application and in a correspondingclient application. Similarly, we will use UDP in a sender application and in acorresponding receiver application. The coverage of
QFtp andQHttp should be
accessible to anyone, but the coverage of QSocket and especially QSocketDevice
does assume some networking experience.
Using QFtp
TheQFtp class implements the client side of the FTP protocol in Qt. It pro-
vides various functions to perform the most common FTP operations, includ-ing
get() ,put() ,remove() ,andmkdir() ,and provides a means of executing ar-
bitrary FTP commands.
TheQFtp class works asynchronously. When we call a function like get()
orput() ,itreturns immediately and the data transfer occurs when control
passes back to Qt’s event loop. This ensures that the user interface remainsresponsive while FTP commands are executed.
283
284 13. Networking
Wewill start with an example that shows how to retrieve a single ﬁle using
get() .The example assumes that the application’s MainWindow class needs to
retrieve a price list from an FTP site.
class MainWindow : public QMainWindow
{    Q_OBJECTpublic:    MainWindow(QWidget *parent = 0, const char *name = 0);
    void getPriceList();
···
private slots:
    void ftpDone(bool error);
private:
    QFtp ftp;    QFile file;
···
};
The class has a public function, getPriceList() ,that retrieves the price list
ﬁle, and a private slot, ftpDone(bool) ,that is called when the ﬁle transfer is
completed. The class also has two private variables: The ftpvariable, of type
QFtp,encapsulates the connection to an FTP server; the file variable is used
for writing the downloaded ﬁle to disk.
MainWindow::MainWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name){
···
    connect(&ftp, SIGNAL(done(bool)), this, SLOT(ftpDone(bool)));
}
In the constructor, we connect the QFtp object’sdone(bool) signal to our ftp-
Done(bool) private slot. QFtp emits the done(bool) signal when it has ﬁnished
processing all requests. The bool parameter indicates whether an error oc-
curred or not.
void MainWindow::getPriceList()
{    file.setName("price-list.csv");    if (!file.open(IO_WriteOnly)) {        QMessageBox::warning(this, tr("Sales Pro"),                             tr("Cannot write file %1\n%2.")                             .arg(file.name())                             .arg(file.errorString()));        return;    }
    ftp.connectToHost("ftp.trolltech.com");
    ftp.login();    ftp.cd("/topsecret/csv");    ftp.get("price-list.csv", &file);    ftp.close();}
Using QFtp 285
ThegetPriceList() function downloads the ftp://ftp.trolltech.com/top-
secret/csv/price-list.csv ﬁle and saves it as price-list.csv in the current
directory.
Westart by opening the QFile for writing. Then we execute a sequence of ﬁve
FTP commands using our QFtp object. The second argument to get() speciﬁes
the output I/O device.
The FTP commands are queued and executed in Qt’s event loop. The comple-
tion of the commands is indicated by QFtp’sdone(bool) signal, which we con-
nected to ftpDone(bool) in the constructor.
void MainWindow::ftpDone(bool error)
{    if (error)        QMessageBox::warning(this, tr("Sales Pro"),                             tr("Error while retrieving file with "                                "FTP: %1.")                             .arg(ftp.errorString()));    file.close();
}
Once the FTP commands are executed, we close the ﬁle. If an error occurred,
we display it in a QMessageBox .
QFtp provides these operations: connectToHost() ,login() ,close() ,list() ,cd(),
get() ,put() ,remove() ,mkdir() ,rmdir() ,andrename() .All of these functions
schedule an FTP command and return an ID number that identiﬁes thecommand. Arbitrary FTP commands can be executed using
rawCommand() .F o r
example, here’s how to execute a SITE CHMOD command:
ftp.rawCommand("SITE CHMOD 755 fortune");
QFtp emits the commandStarted(int) signal when it starts executing a com-
mand, and it emits the commandFinished(int, bool) signal when the command
is ﬁnished. The intparameter is the ID number that identiﬁes a command.
If we are interested in the fate of individual commands, we can store the IDnumbers when we schedule the commands. Keeping track of the ID numbersallows us to provide detailed feedback to the user. For example:
void MainWindow::getPriceList()
{
···
    connectId = ftp.connectToHost("ftp.trolltech.com");
    loginId = ftp.login();    cdId = ftp.cd("/topsecret/csv");    getId = ftp.get("price-list.csv", &file);    closeId = ftp.close();}
void MainWindow::commandStarted(int id)
{    if (id == connectId) {        statusBar()->message(tr("Connecting..."));
286 13. Networking
    } else if (id == loginId) {
        statusBar()->message(tr("Logging in..."));
···
}
Another way of providing feedback is to connect to QFtp’sstateChanged()
signal.
In most applications, we are only interested in the fate of the whole sequence
of commands. We can then simply connect to the done(bool) signal, which is
emitted whenever the command queue becomes empty.
When an error occurs, QFtp automatically clears the command queue. This
means that if the connection or the login fails, the commands that follow in thequeue are never executed. But if we schedule new commands after the errorhas occurred using the same
QFtp object, these commands will be queued and
executed as if nothing had happened.
Wewill now review a more advanced example:
class Downloader : public QObject
{    Q_OBJECTpublic:    Downloader(const QUrl &url);
signals:
    void finished();
private slots:
    void ftpDone(bool error);    void listInfo(const QUrlInfo &urlInfo);
private:
    QFtp ftp;    std::vector<QFile *> openedFiles;};
TheDownloader class downloads all the ﬁles located in an FTP directory. The
directory is speciﬁed as a QUrl passed to the class’s constructor. The QUrl class
is a Qt class that provides a high-level interface for extracting the differentparts of a URL, such as the ﬁle name, path, protocol, and port.
Downloader::Downloader(const QUrl &url)
{    if (url.protocol() != "ftp") {        QMessageBox::warning(0, tr("Downloader"),                             tr("Protocol must be ’ftp’."));        emit finished();        return;    }
    int port = 21;
    if (url.hasPort())        port = url.port();
Using QFtp 287
    connect(&ftp, SIGNAL(done(bool)),
            this, SLOT(ftpDone(bool)));    connect(&ftp, SIGNAL(listInfo(const QUrlInfo &)),            this, SLOT(listInfo(const QUrlInfo &)));
    ftp.connectToHost(url.host(), port);
    ftp.login(url.user(), url.password());    ftp.cd(url.path());    ftp.list();}
In the constructor, we ﬁrst check that the URL starts with “ftp:”. Then we
extract a port number. If no port is speciﬁed, we use port 21, the default portfor FTP.
Next, we establish two signal–slot connections, and we schedule four FTP
commands. The last FTP command,
list() ,retrieves the name of every ﬁle
in the directory and emits a listInfo(const QUrlInfo &) signal for each name
that it retrieves. This signal is connected to a slot also called listInfo() ,which
downloads the ﬁle associated with the URL it is given.
void Downloader::listInfo(const QUrlInfo &urlInfo)
{    if (urlInfo.isFile() && urlInfo.isReadable()) {        QFile *file = new QFile(urlInfo.name());        if (!file->open(IO_WriteOnly)) {            QMessageBox::warning(0, tr("Downloader"),                                 tr("Error: Cannot open file "                                    "%1:\n%2.")                                 .arg(file->name())                                 .arg(file->errorString()));            emit finished();            return;        }
        ftp.get(urlInfo.name(), file);
        openedFiles.push_back(file);    }}
ThelistInfo() slot’sQUrlInfo parameter provides detailed information about
aremote ﬁle. If the ﬁle is a normal ﬁle (not a directory) and is readable, we
callget() to download it. The QFile object used for downloading is allocated
usingnewand a pointer to it is stored in the openedFiles vector.
void Downloader::ftpDone(bool error)
{    if (error)        QMessageBox::warning(0, tr("Downloader"),                             tr("Error: %1.")                             .arg(ftp.errorString()));
    for (int i = 0; i < (int)openedFiles.size(); ++i)
        delete openedFiles[i];    emit finished();}
288 13. Networking
TheftpDone() slot is called when all the FTP commands have ﬁnished, or if
an error occurred. We delete the QFile objects to prevent memory leaks, and
also to close each ﬁle. (The QFile destructor automatically closes the ﬁle if
it’s open.)
If there are no errors, the sequence of FTP commands and signals is as
follows:
connectToHost( host)
login()cd(path)
list()    emit listInfo( file_1)
        get( file_1)
    emit listInfo( file_2)
        get( file_2)
    ...    emit listInfo( file_N)
        get( file_N)
emit done()
If a network error occurs while downloading the ﬁfth of, say, twenty ﬁles to
download, the remaining ﬁles will not be downloaded. If we wanted to down-load as many ﬁles as possible, one solution would be to schedule the
GEToper-
ations one at a time and to wait for the done(bool) signal before scheduling a
newGEToperation. In listInfo() ,wewould simply append the ﬁle name to a
QStringList ,instead of calling get() right away, and in done(bool) we would
callget() on the next ﬁle to download in the QStringList .The sequence of ex-
ecution would then look like this:
connectToHost( host)
login()cd(path)
list()    emit listInfo( file_1)
    emit listInfo( file_2)
    ...    emit listInfo( file_N)
emit done()
get( file_1)
emit done()
get( file_2)
emit done()...get( file_N)
emit done()
Another solution would be to use one QFtp object per ﬁle. This would enable
us to download the ﬁles in parallel, through separate FTP connections.
int main(int argc, char *argv[])
{    QApplication app(argc, argv);
Using QFtp 289
    QUrl url("ftp://ftp.example.com/");
    if (argc >= 2)        url = argv[1];    Downloader downloader(url);    QObject::connect(&downloader, SIGNAL(finished()),                     &app, SLOT(quit()));    return app.exec();}
Themain() function completes the program. If the user speciﬁes a URL on the
command line, we use it; otherwise, we fall back on ftp://ftp.example.com/ .
In both examples, the data retrieved using get() waswritten to a QFile .This
doesn’t have to be the case. If we wanted the data in memory, we could use a
QBuffer ,theQIODevice subclass that wraps a QByteArray .For example:
QBuffer *buffer = new QBuffer(byteArray);
buffer->open(IO_WriteOnly);ftp.get(urlInfo.name(), buffer);
Wecould also omit the I/O device argument to get() ,orpass a null pointer. The
QFtp class then emits a readyRead() signal every time new data is available,
and the data can be read using readBlock() orreadAll() .
If we want to provide the user with feedback while the data is being down-
loaded, we can connect QFtp’sdataTransferProgress(int, int) signal to the
setProgress(int, int) slot in a QProgressBar or in aQProgressDialog .Wewould
then also connect the QProgressBar orQProgressDialog ’scanceled() signal to
QFtp’sabort() slot.
Using QHttp
TheQHttp class implements the client side of the HTTP protocol in Qt. It
provides various functions to perform the most common HTTP operations,including
get() andpost() ,and provides a means of sending arbitrary HTTP
requests. If you have read the previous section about QFtp,you will ﬁnd that
there are many similarities between QFtp andQHttp .
TheQHttp class works asynchronously. When we call a function like get() or
post() ,the function returns immediately, and the data transfer occurs later,
when control returns to Qt’s event loop. This ensures that the application’suser interface remains responsive while HTTP requests are being processed.
Wewill review an example that shows how to download an HTML ﬁle from
Trolltech’s web site from a Qt application’s
MainWindow class. We will omit the
header ﬁle because it is very similar to the one we used in the previous section(p. 284), with a private slot (
httpDone(bool) )and private variables ( http of type
QHttp andfile of typeQFile ).
MainWindow::MainWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name){
···
290 13. Networking
    connect(&http, SIGNAL(done(bool)), this, SLOT(httpDone(bool)));
}
In the constructor, we connect the QHttp object’s done(bool) signal to the
MainWindow ’shttpDone(bool) slot.
void MainWindow::getFile(){    file.setName("aboutqt.html");    if (!file.open(IO_WriteOnly)) {        QMessageBox::warning(this, tr("HTTP Get"),                             tr("Cannot write file %1\n%2.")                             .arg(file.name())                             .arg(file.errorString()));        return;    }
    http.setHost("doc.trolltech.com");
    http.get("/3.2/aboutqt.html", &file);    http.closeConnection();}
ThegetFile() function downloads the http://doc.trolltech.com/3.2/aboutqt.
html ﬁle and saves it as aboutqt.html in the current directory.
Weopen the QFile for writing and schedule a sequence of three HTTP
requests using our QHttp object. The second argument to get() speciﬁes the
output I/O device.
The HTTP requests are queued and executed in Qt’s event loop. The comple-
tion of the commands is indicated by QHttp ’sdone(bool) signal, which we con-
nected to httpDone(bool) in the constructor.
void MainWindow::httpDone(bool error)
{    if (error)        QMessageBox::warning(this, tr("HTTP Get"),                             tr("Error while fetching file with "                                "HTTP: %1.")                             .arg(http.errorString()));    file.close();}
Once the HTTP requests are ﬁnished, we close the ﬁle. If an error occurred,
we display the error message in a QMessageBox .
QHttp provides the following operations: setHost() ,get() ,post() ,andhead() .
Forexample, here’s how we would use post() to send a list of “ name =value ”
pairs to a CGI script:
http.setHost("www.example.com");
http.post("/cgi/somescript.py", QCString("x=200&y=320"), &file);
Formore control, we can use the request() function, which accepts an arbi-
trary HTTP header and data. For example:
Using QHttp 291
QHttpRequestHeader header("POST", "/search.html");
header.setValue("Host", "www.trolltech.com");header.setContentType("application/x-www-form-urlencoded");http.setHost("www.trolltech.com");http.request(header, QCString("qt-interest=on&search=opengl"));
QHttp
emits the requestStarted(int) signal when it starts executing a request,
and it emits the requestFinished(int, bool) signal when the request has
ﬁnished. The intparameter is an ID number that identiﬁes a request. If we
are interested in the fate of individual requests, we can store the ID numberswhen we schedule the requests. Keeping track of the ID numbers allows us toprovide detailed feedback to the user.
In most applications, we only want to know whether the entire sequence of
requests completed successfully or not. This is easily achieved by connectingto the
done(bool) signal, which is emitted when the request queue becomes
empty.
When an error occurs, the request queue is automatically cleared. But if
we schedule new requests after the error has occurred using the same QHttp
object, these requests will be queued and sent as usual.
LikeQFtp,QHttp provides a readyRead() signal as well as the readBlock() and
readAll() functions that we can use instead of specifying an I/O device. It also
provides a dataTransferProgress(int, int) signal that can be connected to a
QProgressBar or to aQProgressDialog ’ssetProgress(int, int) slot.
TCP Networking with QSocket
TheQSocket class can be used to implement TCP clients and servers. TCP is
atransport protocol that forms the basis of many application-level Internet
protocols, including FTP and HTTP, and that can also be used for custom pro-tocols.
TCP is a stream-oriented protocol. For applications, the data appears to be a
long stream, rather like a large ﬂat ﬁle. The high-level protocols built on topof TCP are typically either line-oriented or block-oriented:
•Line-oriented protocols transfer data as lines of text, each terminated by
anewline.
•Block-oriented protocols transfer data as binary data blocks. Each block
consists of a size ﬁeld followed by sizebytes of data.
QSocket inherits from QIODevice ,soitcan be read from and written to using a
QDataStream or aQTextStream .One notable difference when reading data from a
network compared with reading from a ﬁle is that we must make sure that wehave received enough data from the peer before we use the
>>operator. Failing
to do so may result in undeﬁned behavior.
In this section, we will review the code of a client and a server that use a cus-
tom block-oriented protocol. The client is called Trip Planner and allows users
292 13. Networking
to plan their next train trip. The server is called Trip Server and provides the
trip information to the client. We will start by writing the Trip Planner appli-cation.
Figure 13.1. The Trip Planner application
The Trip Planner provides a Fromﬁeld, a Toﬁeld, a Date ﬁeld, an Approximate
Time ﬁeld, and two radio buttons to select whether the approximate time is
that of departure or arrival. When the user clicks Search ,the application
sends a request to the server, which responds with a list of train trips thatmatch the user’s criteria. The list is shown in a
QListView in the Trip Planner
window. The very bottom of the window is occupied by a QLabel that shows the
status of the last operation and a QProgressBar .
The Trip Planner’s user interface was created using Qt Designer .Here, we will
focus on the source code in the corresponding .ui.h ﬁle.Note that the following
four variables were declared in Qt Designer ’sMembers tab:
QSocket socket;
QTimer connectionTimer;QTimer progressBarTimer;Q_UINT16 blockSize;
Thesocket variable of type QSocket encapsulates the TCP connection. The
connectionTimer variable is used to time out a connection that lasts too long.
TheprogressBarTimer variable is used to refresh the progress bar periodically
when the application is busy. Finally, the blockSize variable is used when
parsing the blocks received from the server.
void TripPlanner::init()
{    connect(&socket, SIGNAL(connected()),            this, SLOT(sendRequest()));    connect(&socket, SIGNAL(connectionClosed()),            this, SLOT(connectionClosedByServer()));    connect(&socket, SIGNAL(readyRead()),            this, SLOT(updateListView()));
TCP Networking with QSocket 293
    connect(&socket, SIGNAL(error(int)),
            this, SLOT(error(int)));
    connect(&connectionTimer, SIGNAL(timeout()),
            this, SLOT(connectionTimeout()));    connect(&progressBarTimer, SIGNAL(timeout()),            this, SLOT(advanceProgressBar()));
    QDateTime dateTime = QDateTime::currentDateTime();
    dateEdit->setDate(dateTime.date());    timeEdit->setTime(QTime(dateTime.time().hour(), 0));}
Ininit() ,weconnect the QSocket ’sconnected() ,connectionClosed() ,ready-
Read() ,anderror(int) signals, and the two timers’ timeout() signals, to our
own slots. We also ﬁll the Date and Approximate Time ﬁelds with default values
based on the current date and time.
void TripPlanner::advanceProgressBar()
{    progressBar->setProgress(progressBar->progress() + 2);}
TheadvanceProgressBar() slot is connected to the progressBarTimer ’stimeout()
signal. We advance the progress bar by two units. In Qt Designer ,the progress
bar’stotalSteps property was set to 0, a special value meaning that the bar
should behave as a busy indicator.
void TripPlanner::connectToServer()
{    listView->clear();
    socket.connectToHost("tripserver.zugbahn.de", 6178);
    searchButton->setEnabled(false);
    stopButton->setEnabled(true);    statusLabel->setText(tr("Connecting to server..."));
    connectionTimer.start(30 * 1000, true);
    progressBarTimer.start(200, false);
    blockSize = 0;
}
TheconnectToServer() slot is executed when the user clicks Search to start a
search. We call connectToHost() on theQSocket object to connect to the server,
which we assume is accessible at port 6178 on the ﬁctitious host tripserver.
zugbahn.de .(If you want to try the example on your own machine, replace
the host name with localhost .) TheconnectToHost() call is asynchronous; it
always returns immediately. The connection is typically established later.The
QSocket object emits the connected() signal when the connection is up and
running, or error(int) (with an error code) if the connection failed.
Next, we update the user interface and start the two timers. The ﬁrst timer,
connectionTimer ,isasingle-shot timer that gets triggered when the connection
has been idle for 30 seconds. The second timer, progressBarTimer ,times out
294 13. Networking
every 200 milliseconds to update the application’s progress bar, giving a visual
cue to the user that the application is working.
Finally, we set the blockSize variable to 0. The blockSize variable stores the
length of the next block received from the server. We have chosen to use thevalue of 0 to mean that we don’t yet know the size of the next block.
void TripPlanner::sendRequest()
{    QByteArray block;    QDataStream out(block, IO_WriteOnly);    out.setVersion(5);    out << (Q_UINT16)0 << (Q_UINT8)’S’        << fromComboBox->currentText()        << toComboBox->currentText() << dateEdit->date()        << timeEdit->time();    if (departureRadioButton->isOn())        out << (Q_UINT8)’D’;    else        out << (Q_UINT8)’A’;    out.device()->at(0);    out << (Q_UINT16)(block.size() - sizeof(Q_UINT16));    socket.writeBlock(block.data(), block.size());
    statusLabel->setText(tr("Sending request..."));
}
ThesendRequest() slot is executed when the QSocket object emits the con-
nected() signal, indicating that a connection has been established. The slot’s
task is to generate a request to the server, with all the information entered bythe user.
The request is a binary block with the following format:
Q_UINT16 Block size in bytes (excluding this ﬁeld)
Q_UINT8 Request type (always ‘S’)
QString Departure city
QString Arrival city
QDate Date of travel
QTime Approximate time of travel
Q_UINT8 Time is for departure (‘D’) or arrival (‘A’)
Weﬁrst write the data to a QByteArray calledblock .Wecan’t write the data
directly to the QSocket because we don’t know the size of the block, which must
be sent ﬁrst, until after we have put all the data into the block.
Weinitially write 0 as the block size, followed by the rest of the data. Then
we callat(0) on the I/O device (a QBuffer created by QDataStream behind the
scenes) to move back to the beginning of the byte array, and overwrite theinitial 0 with the size of the block’s data. The size is calculated by taking theblock’s size and subtracting
sizeof(Q_UINT16) (that is, 2) to exclude the size
TCP Networking with QSocket 295
ﬁeld from the byte count. After that, we call writeBlock() on theQSocket to
send the block to the server.
void TripPlanner::updateListView()
{    connectionTimer.start(30 * 1000, true);
    QDataStream in(&socket);
    in.setVersion(5);
    for (;;) {
        if (blockSize == 0) {            if (socket.bytesAvailable() < sizeof(Q_UINT16))                break;            in >> blockSize;        }
        if (blockSize == 0xFFFF) {
            closeConnection();            statusLabel->setText(tr("Found %1 trip(s)")                                 .arg(listView->childCount()));            break;        }
        if (socket.bytesAvailable() < blockSize)
            break;
        QDate date;
        QTime departureTime;        QTime arrivalTime;        Q_UINT16 duration;        Q_UINT8 changes;        QString trainType;
        in >> date >> departureTime >> duration >> changes
           >> trainType;        arrivalTime = departureTime.addSecs(duration * 60);
        new QListViewItem(listView,
                          date.toString(LocalDate),                          departureTime.toString(tr("hh:mm")),                          arrivalTime.toString(tr("hh:mm")),                          tr("%1 hr %2 min").arg(duration / 60)                                            .arg(duration % 60),                          QString::number(changes),                          trainType);        blockSize = 0;    }}
TheupdateListView() slot is connected to the QSocket ’sreadyRead() signal,
which is emitted whenever the QSocket has received new data from the server.
The ﬁrst thing we do is to restart the single-shot connection timer. Wheneverwe receive some data from the server, we know that the connection is alive, sowe set the timer running for another 30 seconds.
296 13. Networking
The server sends us a list of possible train trips that match the user’s criteria.
Each matching trip is sent as a single bloc k, and each block starts with a size.
What complicates the code in the forloop is that we don’t necessarily get one
block of data from the server at a time. We might have received an entireblock, or just part of a block, or one and a half blocks, or even all of the blocksat once.
51 data 48 data ··· 53 data 0xFFFF51 bytes 48 bytes 53 bytes
Figure 13.2. The Trip Server’s blocks
So how does the forloop work? If the blockSize variable is 0, this means
that we have not read the size of the next block. We try to read it (assumingthere are at least 2 bytes available for reading). The server uses a size valueof 0xFFFF to signify that there is no more data to receive, so if we read thisvalue, we know that we have reached the end.
If the block size is not 0xFFFF,we try to read in the next block. First,we check
to see if there are block size bytes available to read. If there are not, we stopthere for now. The
readyRead() signal will be emitted again when more data
is available, and we will try again then.
Once we are sure that an entire block has arrived, we can safely use the >>
operator on the QDataStream we set up on the QSocket to extract the information
related to a trip, and we create a QListViewItem with that information. A block
received from the server has the following format:
Q_UINT16 Block size in bytes (excluding this ﬁeld)
QDate Departure date
QTime Departure time
Q_UINT16 Duration (in minutes)
Q_UINT8 Number of changes
QString Train type
At the end, we reset the blockSize variable to 0 to indicate that the next block’s
size is unknown and needs to be read.
void TripPlanner::closeConnection()
{    socket.close();    searchButton->setEnabled(true);    stopButton->setEnabled(false);    connectionTimer.stop();    progressBarTimer.stop();    progressBar->setProgress(0);}
TCP Networking with QSocket 297
ThecloseConnection() private function closes the connection to the TCP serv-
er, updates the user interface, and stops the timers. It is called from update-
ListView() when the 0xFFFF is read and from several other slots that we will
cover shortly.
void TripPlanner::stopSearch()
{    statusLabel->setText(tr("Search stopped"));    closeConnection();}
ThestopSearch() slot is connected to the Stop button’s clicked() signal.
Essentially it just calls closeConnection() .
void TripPlanner::connectionTimeout()
{    statusLabel->setText(tr("Error: Connection timed out"));    closeConnection();}
TheconnectionTimeout() slot is connected to the connectionTimer ’stimeout()
signal.
void TripPlanner::connectionClosedByServer(){    if (blockSize != 0xFFFF)        statusLabel->setText(tr("Error: Connection closed by "                                "server"));    closeConnection();}
TheconnectionClosedByServer() slot is connected to socket ’sconnection-
Closed() signal. If the server closes the connection and we have not yet re-
ceived the 0xFFFF end-of-stream marker, we tell the user that an error oc-curred. We call
closeConnection() as usual to update the user interface and to
stop the timers.
void TripPlanner::error(int code)
{    QString message;
    switch (code) {
    case QSocket::ErrConnectionRefused:        message = tr("Error: Connection refused");        break;    case QSocket::ErrHostNotFound:        message = tr("Error: Server not found");        break;    case QSocket::ErrSocketRead:    default:        message = tr("Error: Data transfer failed");    }    statusLabel->setText(message);    closeConnection();}
298 13. Networking
Theerror(int) slot is connected to socket ’serror(int) signal. We produce an
error message based on the error code.
Themain() function for the Trip Planner application looks just as we would
expect:
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    TripPlanner tripPlanner;    app.setMainWidget(&tripPlanner);    tripPlanner.show();    return app.exec();}
Now let’s implement the server. The server consists of two classes: TripServer
andClientSocket .TheTripServer class inherits QServerSocket ,aclass that
allows us to accept incoming TCP connections. ClientSocket reimplements
QSocket and handles a single connection. At any one time, there are as many
ClientSocket objects in memory as there are clients being served.
class TripServer : public QServerSocket
{public:    TripServer(QObject *parent = 0, const char *name = 0);
    void newConnection(int socket);
};
TheTripServer class reimplements the newConnection() function from QServ-
erSocket .This function is called whenever a client attempts to connect to the
port the server is listening to.
TripServer::TripServer(QObject *parent, const char *name)
    : QServerSocket(6178, 1, parent, name){}
In theTripServer constructor,we pass the port number (6178) to the base class
constructor. The second argument, 1, is the number of pending connectionswe want to allow.
void TripServer::newConnection(int socketId)
{    ClientSocket *socket = new ClientSocket(this);    socket->setSocket(socketId);}
InnewConnection() ,wecreate a ClientSocket object as a child of the TripServer
object, and we set its socket ID to the number provided to us.
class ClientSocket : public QSocket
{    Q_OBJECTpublic:    ClientSocket(QObject *parent = 0, const char *name = 0);
TCP Networking with QSocket 299
private slots:
    void readClient();
private:
    void generateRandomTrip(const QString &from, const QString &to,                            const QDate &date, const QTime &time);
    Q_UINT16 blockSize;
};
TheClientSocket class inherits from QSocket and encapsulates the state of a
single client.
ClientSocket::ClientSocket(QObject *parent, const char *name)
    : QSocket(parent, name){    connect(this, SIGNAL(readyRead()),            this, SLOT(readClient()));    connect(this, SIGNAL(connectionClosed()),            this, SLOT(deleteLater()));    connect(this, SIGNAL(delayedCloseFinished()),            this, SLOT(deleteLater()));
    blockSize = 0;
}
In the constructor, we establish the necessary signal–slot connections, and we
set theblockSize variable to 0, indicating that we do not yet know the size of
the block sent by the client.
TheconnectionClosed() anddelayedCloseFinished() signals are connected
todeleteLater() ,aQObject -inherited function that deletes the object when
control returns to Qt’s event loop. This ensures that the ClientSocket object
is deleted when the connection is closed by the peer or when a delayed close isﬁnished. We will see what that means in a moment.
void ClientSocket::readClient()
{    QDataStream in(this);    in.setVersion(5);
    if (blockSize == 0) {
        if (bytesAvailable() < sizeof(Q_UINT16))            return;        in >> blockSize;    }    if (bytesAvailable() < blockSize)        return;
    Q_UINT8 requestType;
    QString from;    QString to;    QDate date;    QTime time;    Q_UINT8 flag;
    in >> requestType;
300 13. Networking
    if (requestType == ’S’) {
        in >> from >> to >> date >> time >> flag;
        srand(time.hour() * 60 + time.minute());
        int numTrips = rand() % 8;        for (int i = 0; i < numTrips; ++i)            generateRandomTrip(from, to, date, time);
        QDataStream out(this);
        out << (Q_UINT16)0xFFFF;    }    close();    if (state() == Idle)        deleteLater();}
ThereadClient() slot is connected to QSocket ’sreadyRead() signal. If blockSize
is 0, we start by reading the blockSize ;otherwise, we have already read it, and
instead we check to see if a whole block has arrived. Once an entire block isready for reading, we read it. We use the
QDataStream directly on the QSocket
(thethis object) and read the ﬁelds using the >>operator.
Once we have read the client’s request,we are ready to generate a reply. If this
were a real application, we would look up the information in a train scheduledatabase and try to ﬁnd matching train trips. But here we will be content withafunction called
generateRandomTrip() that will generate a random trip. We
call the function a random number of times, and we send 0xFFFF to signifythe end of the data.
Finally, we close the connection. If the socket’s output buffer is empty, the
connection is terminated immediately and we call
deleteLater() to delete this
object when control returns to Qt’s event loop. (This is safer than delete this .)
Otherwise, QSocket will complete sending out all the data, and will then close
the connection and emit the delayedCloseFinished() signal.
void ClientSocket::generateRandomTrip(const QString &,
        const QString &, const QDate &date, const QTime &time){    QByteArray block;    QDataStream out(block, IO_WriteOnly);    out.setVersion(5);    Q_UINT16 duration = rand() % 200;    out << (Q_UINT16)0 << date << time << duration        << (Q_UINT8)1 << QString("InterCity");    out.device()->at(0);    out << (Q_UINT16)(block.size() - sizeof(Q_UINT16));
    writeBlock(block.data(), block.size());
}
ThegenerateRandomTrip() function shows how to send a block of data over
aTCP connection. This is very similar to what we did in the client in the
sendRequest() function (p. 294). Once again, we write the block to a QByteArray
so that we can determine its size before we send it using writeBlock() .
TCP Networking with QSocket 301
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    TripServer server;    if (!server.ok()) {        qWarning("Failed to bind to port");        return 1;    }    QPushButton quitButton(QObject::tr("&Quit"), 0);    quitButton.setCaption(QObject::tr("Trip Server"));    app.setMainWidget(&quitButton);    QObject::connect(&quitButton, SIGNAL(clicked()),                     &app, SLOT(quit()));    quitButton.show();    return app.exec();}
Inmain() ,wecreate a TripServer object and a QPushButton that enables the
user to stop the server.
This completes our client–server example. In this case, we used a block-ori-
ented protocol that allows us to use QDataStream for reading and writing. If
we wanted to use a line-oriented protocol, the simplest approach would be touse
QSocket ’scanReadLine() andreadLine() functions in a slot connected to the
readyRead() signal:
QStringList lines;
while (socket.canReadLine())    lines.append(socket.readLine());
Wewould then process each line that has been read. As for sending data, that
can be done using a QTextStream on theQSocket .
The server implementation that we have used doesn’t scale very well when
there are lots of connections. The problem is that while we are processingarequest, we don’t handle the other connections. A more scalable approach
would be to start a new thread for each connection. But
QSocket can only
be used in the thread that contains the event loop (the call to QApplication::
exec() ), for reasons that are explained in Chapter 17 (Multithreading). The
solution is to use the low-level QSocketDevice class directly, which doesn’t rely
on the event loop.
UDP Networking with QSocketDevice
TheQSocketDevice class provides a low-level interface that can be used for TCP
and for UDP. For most TCP applications, the higher-level QSocket class is all
we need, but if we want to use UDP, we must use QSocketDevice directly.
UDP is an unreliable, datagram-oriented protocol. Some application-level
protocols use UDP because it is more lightweight than TCP. With UDP, data issent as packets (datagrams) from one host to another. There is no concept of
302 13. Networking
connection, and if a UDP packet doesn’t get delivered successfully, no error is
reported to the system.
Figure 13.3. The Weather Station application
Wewill see how to use UDP from a Qt application through the Weather Bal-
loon and Weather Station example. The Weather Balloon application is a non-GUI application that sends a UDP datagram containing the current atmo-spheric conditions every 5 seconds. The Weather Station application receivesthese datagrams and displays them on screen. We will start by reviewing thecode for the Weather Balloon.
class WeatherBalloon : public QPushButton
{    Q_OBJECTpublic:    WeatherBalloon(QWidget *parent = 0, const char *name = 0);
    double temperature() const;
    double humidity() const;    double altitude() const;
protected:
    void timerEvent(QTimerEvent *event);
private:
    QSocketDevice socketDevice;    int myTimerId;};
TheWeatherBalloon class inherits from QPushButton .Ituses its QSocketDevice
private variable for communicating with the Weather Station.
WeatherBalloon::WeatherBalloon(QWidget *parent, const char *name)
    : QPushButton(tr("Quit"), parent, name),      socketDevice(QSocketDevice::Datagram){    socketDevice.setBlocking(false);    myTimerId = startTimer(5 * 1000);}
UDP Networking with QSocketDevice 303
In the constructor’s initialization list, we pass QSocketDevice::Datagram to the
QSocketDevice constructor to create a UDP socket device. In the constructor
body, we call setBlocking(false) to make the QSocketDevice asynchronous. (By
default, QSocketDevice is synchronous.)
WecallstartTimer() to generate a timer event every 5 seconds.
void WeatherBalloon::timerEvent(QTimerEvent *event)
{    if (event->timerId() == myTimerId) {        QByteArray datagram;        QDataStream out(datagram, IO_WriteOnly);        out.setVersion(5);        out << QDateTime::currentDateTime() << temperature()            << humidity() << altitude();        socketDevice.writeBlock(datagram, datagram.size(),                                0x7F000001, 5824);    } else {        QPushButton::timerEvent(event);    }}
In the timer event handler, we generate a datagram containing the current
date, time, temperature, humidity, and altitude:
QDateTime Date and time of measurement
double Temperature (in °C)
double Humidity (in %)
double Altitude (in meters)
The datagram is sent using writeBlock() .The third and fourth arguments to
writeBlock() are the IP address and the port number of the peer (the Weather
Station). For this example, we assume that the Weather Station is runningon the same machine as the Weather Balloon, so we use an IP address of127.0.0.1 (0x7F000001), a special address that designates the local host.Unlike
QSocket ,QSocketDevice does not accept host names, only host numbers.
If we wanted to resolve a host name to its IP address here, we would need touse the
QDns class.
As usual, we need a main() function:
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    WeatherBalloon balloon;    balloon.setCaption(QObject::tr("Weather Balloon"));    app.setMainWidget(&balloon);    QObject::connect(&balloon, SIGNAL(clicked()),                     &app, SLOT(quit()));    balloon.show();    return app.exec();}
304 13. Networking
Themain() function simply creates a WeatherBalloon object, which serves both
as a UDP peer and as a QPushButton on screen. By clicking the QPushButton ,the
user can quit the application.
Now let’s review the source code for the Weather Station.
class WeatherStation : public QDialog
{    Q_OBJECTpublic:    WeatherStation(QWidget *parent = 0, const char *name = 0);
private slots:
    void dataReceived();
private:
    QSocketDevice socketDevice;    QSocketNotifier *socketNotifier;
    QLabel *dateLabel;
    QLabel *timeLabel;
···
    QLineEdit *altitudeLineEdit;
};
TheWeatherStation class inherits from QDialog .Itlistens to a certain UDP
port,parsesany incoming datagrams(from the Weather Balloon),and displaystheir contents in ﬁve read-only
QLineEdit s.
The class has two private variables of interest here: socketDevice andsocket-
Notifier .ThesocketDevice variable, of type QSocketDevice ,isused for reading
datagrams. The socketNotifier variable, of type QSocketNotifier ,isused to
make the application aware of incoming datagrams.
WeatherStation::WeatherStation(QWidget *parent, const char *name)
    : QDialog(parent, name),      socketDevice(QSocketDevice::Datagram){    socketDevice.setBlocking(false);    socketDevice.bind(QHostAddress(), 5824);
    socketNotifier = new QSocketNotifier(socketDevice.socket(),
                                         QSocketNotifier::Read,                                         this);    connect(socketNotifier, SIGNAL(activated(int)),            this, SLOT(dataReceived()));
···
}
In the constructor’s initialization list, we pass QSocketDevice::Datagram to the
QSocketDevice constructor to create a UDP socket device. In the constructor
body, we call setBlocking(false) to make the socket asynchronous and we call
bind() to assign a port number to the socket. The ﬁrst argument is the IP
address of the Weather Station. By passing QHostAddress() ,weindicate that
we will accept datagrams to any IP address that belongs to the machine theWeather Station is running on. The second argument is the port number.
UDP Networking with QSocketDevice 305
Then we create a QSocketNotifier object to monitor the socket. The QSocket-
Notifier will emit an activated(int) signal whenever the socket receives a
datagram. We connect that signal to our dataReceived() slot.
void WeatherStation::dataReceived()
{    QDateTime dateTime;    double temperature;    double humidity;    double altitude;
    QByteArray datagram(socketDevice.bytesAvailable());
    socketDevice.readBlock(datagram.data(), datagram.size());
    QDataStream in(datagram, IO_ReadOnly);
    in.setVersion(5);    in >> dateTime >> temperature >> humidity >> altitude;
    dateLineEdit->setText(dateTime.date().toString());
    timeLineEdit->setText(dateTime.time().toString());    temperatureLineEdit->setText(tr("%1 °C").arg(temperature));    humidityLineEdit->setText(tr("%1%").arg(humidity));    altitudeLineEdit->setText(tr("%1 m").arg(altitude));}
IndataReceived() ,wecallreadBlock() on theQSocketDevice to read in the data-
gram.QByteArray::data() returns a pointer to the QByteArray ’sdata, which
readBlock() populates. Then, we extract the different ﬁelds using a QData-
Stream ,and we update the user interface to show the information we received.
From the application’s point of view, datagrams are always sent and received
as a single unit of data. This means that if any bytes are available, then ex-actly one datagram has arrived and can be read.
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    WeatherStation station;    app.setMainWidget(&station);    station.show();    return app.exec();}
Finally, in main() ,wecreate a WeatherStation and make it the application’s
main widget.
Wehave now ﬁnished our UDP sender and receiver. The applications are
as simple as possible, with the Weather Balloon sending datagrams and theWeather Station receiving them. In most real-world applications, both appli-
cations would need to both read and write on their socket. The
QSocketDevice
class has a peerAddress() and apeerPort() function that can be used by the
server to determine what address and port to reply to.

1414
XML•Reading XML with SAX
•Reading XML with DOM
•Writing XML
XML (Extensible Markup Language) is a text ﬁle format that is popular for
data interchange and for data storage.
Qt provides two distinct APIs for processing XML documents:
•SAX (Simple API for XML) reports parsing events directly to the applica-
tion through virtual functions.
•DOM (Document Object Model) converts an XML document into a tree
structure, which the application can then navigate.
There are many factors to take into account when choosing between DOM and
SAX for a particular application. SAX is more low-level and usually faster,which makes it especially appropriate both for simple tasks (like ﬁnding alloccurrences of a given tag in an XML document) and for reading very largeﬁles that may not ﬁt in memory. But for many applications, the convenienceoffered by DOM outweighs the potential speed and memory beneﬁts of SAX.
In this chapter, we will see how to read XML ﬁles using both APIs, and we
will show how to write XML ﬁles. This chapter assumes a basic knowledgeof XML.
Reading XML with SAX
SAX is a public domain de-facto standard Java API for reading XML docu-ments. Qt’s SAX classes are modeled after the SAX2 Java implementation,with some differences in naming to match the Qt conventions. For more infor-mation about SAX, see
http://www.saxproject.org/ .
Qt provides a SAX-based non-validating XML parser called QXmlSimpleReader .
This parser recognizes well-formed XML and supports XML namespaces.When the parser goes through the document, it calls virtual functions in
307
308 14. XML
registered handler classes to indicate parsing events. (These “parsing events”
are unrelated to Qt events, such as key and mouse events.) For example, let’sassume the parser is analyzing the following XML document:
<doc>
    <quote>Errare humanum est</quote>
</doc>
The parser would call the following parsing event handlers:
startDocument()startElement("doc")startElement("quote")characters("Errare humanum est")endElement("quote")endElement("doc")endDocument()
The above functions are all declared in QXmlContentHandler .For simplicity, we
omitted some of the arguments of startElement() andendElement() .
QXmlContentHandler is just one of many handler classes that can be used in
conjunction with QXmlSimpleReader .The others are QXmlEntityResolver ,QXml-
DTDHandler ,QXmlErrorHandler ,QXmlDeclHandler ,andQXmlLexicalHandler .These
classes only declare pure virtual functions and give information about differ-ent kinds of parsing events. For most applications,
QXmlContentHandler and
QXmlErrorHandler are the only two that are needed.
Forconvenience, Qt also provides QXmlDefaultHandler ,aclass that inherits
(through multiple inheritance) from all the handler classes and that providestrivial implementations for all the functions. This design, with many abstracthandler classes and one trivial subclass, is rather unusual for Qt; it wasadopted to closely follow the model Java implementation.
Wewill now review an example that shows how to use
QXmlSimpleReader and
QXmlDefaultHandler to parse an ad-hoc XML ﬁle format and render its contents
in aQListView .TheQXmlDefaultHandler subclass is called SaxHandler ,and the
format it handles is that of a book index, with index entries and subentries.
QXmlContentHandler QXmlDTDHandler QXmlLexicalHandler
QXmlErrorHandler QXmlEntityResolver QXmlDeclHandler
QXmlDefaultHandler
SaxHandler
Figure 14.1. Inheritance tree for SaxHandler
Here’s the book index ﬁle that is displayed in the QListView in Figure 14.2:
<?xml version="1.0"?>
<bookindex>
Reading XML with SAX 309
    <entry term="sidebearings">
        <page>10</page>        <page>34-35</page>        <page>307-308</page>    </entry>    <entry term="subtraction">        <entry term="of pictures">            <page>115</page>            <page>244</page>        </entry>        <entry term="of vectors">            <page>9</page>        </entry>    </entry></bookindex>
Figure 14.2. Abook index ﬁle loaded in a QListView
The ﬁrst step to implement the parser is to subclass QXmlDefaultHandler :
class SaxHandler : public QXmlDefaultHandler
{public:    SaxHandler(QListView *view);
    bool startElement(const QString &namespaceURI,
                      const QString &localName,                      const QString &qName,                      const QXmlAttributes &attribs);    bool endElement(const QString &namespaceURI,                    const QString &localName,                    const QString &qName);    bool characters(const QString &str);    bool fatalError(const QXmlParseException &exception);
private:
    QListView *listView;    QListViewItem *currentItem;    QString currentText;};
TheSaxHandler class inherits QXmlDefaultHandler and reimplements four
functions: startElement() ,endElement() ,characters() ,andfatalError() .The
ﬁrst three functions are declared in QXmlContentHandler ;the last function is
declared in QXmlErrorHandler .
310 14. XML
SaxHandler::SaxHandler(QListView *view)
{    listView = view;    currentItem = 0;}
TheSaxHandler constructor accepts the QListView we want to ﬁll with the
information stored in the XML ﬁle.
bool SaxHandler::startElement(const QString &, const QString &,
                              const QString &qName,                              const QXmlAttributes &attribs){    if (qName == "entry") {        if (currentItem) {            currentItem = new QListViewItem(currentItem);        } else {            currentItem = new QListViewItem(listView);        }        currentItem->setOpen(true);        currentItem->setText(0, attribs.value("term"));    } else if (qName == "page") {        currentText = "";    }    return true;}
ThestartElement() function is called when the reader encounters a new open-
ing tag. The third parameter is the tag’s name (or more precisely, its “qualiﬁedname”). The fourth parameter is the list of attributes. In this example, weignore the ﬁrst and second parameters. They are useful for XML ﬁles thatuse XML’s namespace mechanism, a subject that is discussed in detail in thereference documentation.
If the tag is
<entry> ,wecreate a new QListView item. If the tag is nested with-
in another <entry> tag, the new tag deﬁnes a subentry in the index, and the
newQListViewItem is created as a child of the QListViewItem that represents
the encompassing entry. Otherwise,we create the QListViewItem withlistView
as its parent, making it a top-level item. We call setOpen(true) on the item to
show its children, and we call setText() to set the text shown in column 0 to
the value of the <entry> tag’sterm attribute.
If the tag is <page> ,w e set thecurrentText to be an empty string. The cur-
rentText serves as an accumulator for the text located between the <page> and
</page> tags.
At the end, we return true to tell SAX to continue parsing the ﬁle. If we want-
ed to report unknown tags as errors, we would return false in those cases. We
would then also reimplement errorString() fromQXmlDefaultHandler to return
an appropriate error message.
bool SaxHandler::characters(const QString &str)
{    currentText += str;
Reading XML with SAX 311
    return true;
}
Thecharacters() function is called to report character data in the XML
document. We simply append the characters to the currentText variable.
bool SaxHandler::endElement(const QString &, const QString &,
                            const QString &qName){    if (qName == "entry") {        currentItem = currentItem->parent();    } else if (qName == "page") {        if (currentItem) {            QString allPages = currentItem->text(1);            if (!allPages.isEmpty())                allPages += ", ";            allPages += currentText;            currentItem->setText(1, allPages);        }    }    return true;}
TheendElement() function is called when the reader encounters a closing tag.
Just as with startElement() ,the third parameter is the name of the tag.
If the tag is </entry> ,weupdate the currentItem private variable to point
to the current QListViewItem ’sparent. This ensures that the currentItem
variable is restored to the value it held before the corresponding <entry> tag
wasread.
If the tag is </page> ,weadd the speciﬁed page number or page range to the
comma-separated list in the current item’s text in column 1.
bool SaxHandler::fatalError(const QXmlParseException &exception)
{    qWarning("Line %d, column %d: %s", exception.lineNumber(),             exception.columnNumber(), exception.message().ascii());    return false;}
ThefatalError() function is called when the reader fails to parse the XML ﬁle.
If this occurs, we simply output a warning, giving the line number, the columnnumber, and the parser’s error text.
This completes the implementation of the
SaxHandler class. Now let’s see how
we can make use of the class:
bool parseFile(const QString &fileName)
{    QListView *listView = new QListView(0);    listView->setCaption(QObject::tr("SAX Handler"));    listView->setRootIsDecorated(true);    listView->setResizeMode(QListView::AllColumns);    listView->addColumn(QObject::tr("Terms"));    listView->addColumn(QObject::tr("Pages"));
312 14. XML
    listView->show();
    QFile file(fileName);
    QXmlSimpleReader reader;
    SaxHandler handler(listView);
    reader.setContentHandler(&handler);    reader.setErrorHandler(&handler);    return reader.parse(&file);}
Weset up a QListView with two columns. Then we create a QFile object for the
ﬁle that is to be read and a QXmlSimpleReader to parse the ﬁle. We don’t need
to open the QFile ourselves; Qt does that automatically.
Finally, we create a SaxHandler object, we install it on the reader both as a
content handler and as an error handler, and we call parse() on the reader to
perform the parsing.
InSaxHandler ,weonly reimplemented functions from the QXmlContentHandler
andQXmlErrorHandler classes. If we had implemented functions from other
handler classes, we would also have needed to call their corresponding setterfunctions on the reader.
Reading XML with DOM
DOM is a standard API for parsing XML developed by the World Wide WebConsortium (W3C). Qt provides a non-validating DOM Level 2 implementa-tion for reading, manipulating, and writing XML documents.
DOM represents an XML ﬁle as a tree in memory. We can navigate through
the DOM tree as much as we want, and we can modify the tree and save it backto disk as an XML ﬁle.
Let’s consider the following XML document:
<doc>
    <quote>Errare humanum est</quote>
    <translation>To err is human</translation></doc>
It corresponds to the following DOM tree:
Document
Element (doc)
Element (quote)
Text (“Errare humanum est”)
Element (translation)
Text (“To err is human”)
Reading XML with DOM 313
The DOM tree contains nodes of different types. For example, an Element node
corresponds to an opening tag and its matching closing tag. The material thatfalls between the tags appears as child nodes of the
Element node.
In Qt, the node types (like all other DOM-related classes) have a QDom preﬁx.
Thus,QDomElement represents an Element node, and QDomText represents a
Text node.
Different types of nodes can have different kinds of child nodes. For example,
anElement node can contain other Element nodes, and also EntityReference ,
Text,CDATASection ,ProcessingInstruction ,andComment nodes. Figure 14.3
speciﬁes which nodes can have which kinds of child nodes. The nodes shownin gray cannot have any child nodes of their own.
Document
ElementDocument
TypeProcessing
InstructionCommentAttr
Entity
ReferenceText
Document
FragmentElementEntity
ReferenceEntity
ElementEntity
ReferenceTextCDATA
SectionProcessing
InstructionComment
Figure 14.3. Parent–child relationships between DOM nodes
Toillustrate how to use DOM for reading XML ﬁles, we will write a parser for
the book index ﬁle format described in the previous section (p. 308).
class DomParser
{public:    DomParser(QIODevice *device, QListView *view);
private:
    void parseEntry(const QDomElement &element,                    QListViewItem *parent);
    QListView *listView;
};
Wedeﬁne a class called DomParser that will parse a book index XML document
and display the result in a QListView .The class does not inherit from any
other class.
DomParser::DomParser(QIODevice *device, QListView *view)
{    listView = view;
314 14. XML
    QString errorStr;
    int errorLine;    int errorColumn;    QDomDocument doc;    if (!doc.setContent(device, true, &errorStr, &errorLine,                        &errorColumn)) {        qWarning("Line %d, column %d: %s", errorLine, errorColumn,                 errorStr.ascii());        return;    }
    QDomElement root = doc.documentElement();
    if (root.tagName() != "bookindex") {        qWarning("The file is not a bookindex file");        return;    }
    QDomNode node = root.firstChild();
    while (!node.isNull()) {        if (node.toElement().tagName() == "entry")            parseEntry(node.toElement(), 0);        node = node.nextSibling();    }}
In the constructor, we create a QDomDocument object and call setContent() on it
to have it read the XML document provided by the QIODevice .ThesetContent()
function automatically opens the device if it isn’t already open. Then we call
documentElement() on theQDomDocument to obtain its single QDomElement child,
and we check that it is a <bookindex> element. Then we iterate over all the
child nodes, and if the node is an <entry> element, we call parseEntry() to
parse it.
TheQDomNode class can store any type of node. If we want to process a node
further,we must ﬁrst convert it to the right data type. In this example,we onlycare about
Element nodes, so we call toElement() on theQDomNode to convert it
to aQDomElement and then call tagName() to retrieve the element’s tag name.
If the node is not of type Element ,thetoElement() function returns a null
QDomElement object, with an empty tag name.
void DomParser::parseEntry(const QDomElement &element,
                           QListViewItem *parent){    QListViewItem *item;    if (parent) {        item = new QListViewItem(parent);    } else {        item = new QListViewItem(listView);    }    item->setOpen(true);    item->setText(0, element.attribute("term"));
    QDomNode node = element.firstChild();
    while (!node.isNull()) {        if (node.toElement().tagName() == "entry") {
Reading XML with DOM 315
            parseEntry(node.toElement(), item);
        } else if (node.toElement().tagName() == "page") {            QDomNode childNode = node.firstChild();            while (!childNode.isNull()) {                if (childNode.nodeType() == QDomNode::TextNode) {                    QString page = childNode.toText().data();                    QString allPages = item->text(1);                    if (!allPages.isEmpty())                        allPages += ", ";                    allPages += page;                    item->setText(1, allPages);                    break;                }                childNode = childNode.nextSibling();            }        }        node = node.nextSibling();    }}
InparseEntry() ,wecreate a QListView item. If the tag is nested within anoth-
er<entry> tag, the new tag deﬁnes a subentry in the index, and we create the
QListViewItem as a child of the QListViewItem that represents the encompass-
ing entry. Otherwise, we create the QListViewItem withlistView as its parent,
making it a top-level item. We call setOpen(true) on the item to ensure that
any subentries will be visible, and call setText() to set the text shown in col-
umn 0 to the value of the <entry> tag’sterm attribute.
Once we have initialized the QListViewItem ,weiterate over the child nodes of
theQDomElement node corresponding to the current <entry> tag.
If the element is <entry> ,wecallparseEntry() with the current item as the
second argument. The new entry’s QListViewItem will then be created with the
encompassing entry’s QListViewItem as its parent.
If the element is <page> ,wenavigate through the element’s child list to ﬁnd a
Text node. Once we have found it, we call toText() to convert it to a QDomText
object, and data() to extract the text as a QString .Then we add the text to the
comma-separated list of page numbers in column 1 of the QListViewItem .
Let’s now see how we can use the DomParser class to parse a ﬁle:
void parseFile(const QString &fileName)
{    QListView *listView = new QListView(0);    listView->setCaption(QObject::tr("DOM Parser"));    listView->setRootIsDecorated(true);    listView->setResizeMode(QListView::AllColumns);    listView->addColumn(QObject::tr("Terms"));    listView->addColumn(QObject::tr("Pages"));    listView->show();
    QFile file(fileName);
    DomParser(&file, listView);}
316 14. XML
Westart by setting up a QListView .Then we create a QFile and aDomPars-
er.When the DomParser is constructed, it parses the ﬁle and populates the
list view.
As the example illustrates, navigating through a DOM tree can be cumber-
some. Simply extracting the text between <page> and</page> required us
to iterate through a list of QDomNode susingfirstChild() andnextSibling() .
Programmers who use DOM a lot often write their own higher level wrapperfunctions to simplify commonly needed operations, such as extracting the textbetween tags.
Writing XML
There are basically two approaches for generating XML ﬁles from Qt appli-cations:
•W ecan build a DOM tree and call
save() on it.
•W ecan generate XML by hand.
The choice between these approaches is often independent of whether we use
SAX or DOM for reading XML documents.
Here’s a code snippet that illustrates how we can create a DOM tree and write
it using a QTextStream :
const int Indent = 4;
QDomDocument doc;
QDomElement root = doc.createElement("doc");QDomElement quote = doc.createElement("quote");QDomElement translation = doc.createElement("translation");QDomText quoteText = doc.createTextNode("Errare humanum est");QDomText translationText = doc.createTextNode("To err is human");
doc.appendChild(root);
root.appendChild(quote);root.appendChild(translation);quote.appendChild(quoteText);translation.appendChild(translationText);
QTextStream out(&file);
doc.save(out, Indent);
The second argument to save() is the indentation size to use. A non-zero value
makes the ﬁle easier for humans to read. Here’s the XML ﬁle output:
<doc>
    <quote>Errare humanum est</quote>
    <translation>To err is human</translation></doc>
Another scenario occurs in applications that use the DOM tree as their prima-
ry data structure. These applicationswould normally read in XML documents
Writing XML 317
using DOM, then modify the DOM tree in memory, and ﬁnally call save() to
convert the tree back to XML.
In the example above, we used UTF-8 as the encoding. We can use another
encoding by prepending
<?xml version="1.0" encoding="ISO-8859-1"?>
to the DOM tree. The following code snippet shows how to do this:
QTextStream out(&file);
QDomNode xmlNode = doc.createProcessingInstruction("xml",                          "version=\"1.0\" encoding=\"ISO-8859-1\"");doc.insertBefore(xmlNode, doc.firstChild());doc.save(out, Indent);
Generating XML ﬁles by hand isn’t much harder than using DOM.We can use
QTextStream and write the strings as we would do with any text ﬁle. The most
tricky part is to escape special characters in text and attribute values. We cando this in a separate function:
QString escapeXml(const QString &str)
{    QString xml = str;    xml.replace("&", "&amp;");    xml.replace("<", "&lt;");    xml.replace(">", "&gt;");    xml.replace("’", "&apos;");    xml.replace("\"", "&quot;");    return xml;}
Here’s an example that makes use of it:
QTextStream out(&file);out.setEncoding(QTextStream::UnicodeUTF8);out << "<doc>\n"    << "    <quote>" << escapeXml(quoteText) << "</quote>\n"    << "    <translation>" << escapeXml(translationText)    << "</translation>\n"    << "</doc>\n";
The Qt Quarterly article “Generating XML”, available online at http://doc.
trolltech.com/qq/qq05-generating-xml.html ,presents a very simple class that
makes it easy to generate XML ﬁles. The class takes care of the details suchas special characters, indentation, and encoding issues, leaving us free toconcentrate on the XML we want to generate.

1515
Internationalization•Working with Unicode
•Making Applications
Translation-Aware
•Dynamic Language
Switching
•Translating Applications
In this chapter, we will cover how to write Qt applications in languages oth-
er than English and how to translate an existing Qt application to otherlanguages.
The ﬁrst section discusses Unicode, Qt’s native character encoding. The
information contained in this section is useful to all Qt developers, since evenan application with an English user interface could one day be run on a Greekor Japanese user’s machine.
The second section shows how to make applications translation-ready. This
process is so easy that it’s worth doing even if you don’t have plans to offertranslated versions of your software. It then leaves you in a good positionto hire a translator and create a new market for your applications at a lat-er date.
The third section is aimed at truly international applications and shows how
to make an application change language on the ﬂy.
The last section describes the translation process as a whole. It also shows
how programmers and translators can work together using Qt Linguist and
Qt’s other translation tools.
Working with Unicode
Unicode is a character encoding standard that supports most of the world’s
writing systems. The original idea behind Unicode is that by using 16 bitsfor storing characters instead of 8 bits, it would be possible to encode around65,000 charactersinstead of only 256.Unicode contains ASCII and ISO 8859-1(Latin-1) as subsets at the same code positions. For example, the character ‘A’has value 0x41 in ASCII, Latin-1, and Unicode, and the character ‘ß’ has value0xDF in both Latin-1 and Unicode.
319
320 15. Internationalization
Qt’sQString class stores strings as Unicode. Each character in a QString is a
16-bitQChar rather than an 8-bit char.Here are two ways of setting the ﬁrst
character of a string to ‘A’:
str[0] = ’A’;
str[0] = QChar(0x41);
If the source ﬁle is encoded in Latin-1, specifying Latin-1 characters is just
as easy:
str[0] = ’ß’;
And if the source ﬁle has another encoding, the numeric value works:
str[0] = QChar(0xDF);
Wecan specify any Unicode character by its numeric value. For example,
here’s how to specify the Greek capital letter sigma (‘ Σ’) and the euro currency
symbol (‘ ’):
str[0] = QChar(0x3A3);
str[0] = QChar(0x20AC);
The numeric values of all the characters supported by Unicode are listed at
http://www.unicode.org/unicode/standard/standard.html .Ifyou rarely need
non-Latin-1 Unicode characters, looking up characters online is sufﬁcient;but Qt provides more convenient ways of entering Unicode strings in a Qtprogram, as we will see later in this section.
Qt 3.2’s text engine supports the following writing systems on all platforms:
Arabic, Chinese, Cyrillic, Greek, Hebrew, Japanese, Korean, Lao, Latin, Thai,and Vietnamese. It also supports all the Unicode 3.2 scripts that don’t requireany special processing. In addition, the following writing systems are sup-ported on X11 with Xft and on NT-based versions of Windows: Bengali, De-vanagari, Gujarati, Gurmukhi, Kannada, Khmer, Syriac, Tamil, Telugu, andThaana. Finally, Malayalam and Tibetan are supported on X11, and Divehi issupported on Windows XP.Assuming that the proper fonts are installed on thesystem, Qt can render text using any of these writing systems. And assumingthat the proper input methods are installed, users will be able to enter textthat uses these writing systems in their Qt applications.
Programming with
QChar is slightly different from programming with char.
Toobtain the numeric value of a QChar ,callunicode() on it. To obtain the
ASCII or Latin-1 value of a QChar (as achar), calllatin1() .For non-Latin-1
characters, latin1() returns 0.
If we know that all the strings in a program are ASCII or Latin-1, we can use
standard <cctype> functions like isalpha() ,isdigit() ,andisspace() .These
work because QChar sautomatically convert into chars(as Latin-1) given the
right context, just as QString sautomatically convert into constchar * .Howev-
er, it is generally better to use QChar ’smember functions for performing these
operations, since they will work for any Unicode character. The functions
Working with Unicode 321
QChar provides include isPrint() ,isPunct() ,isSpace() ,isMark() ,isLetter() ,
isNumber() ,isLetterOrNumber() ,isDigit() ,isSymbol() ,lower() ,andupper() .
Forexample, here’s one way to test that a character is a digit or an upper-case
letter:
if (ch.isDigit() || ch != ch.lower())
    ...
Thelower() function returns the lower-case version of the character. If the
lower-case version of the character is different from the character itself, thenthe character must be upper-case (or title-case). The code snippet works forany alphabet that distinguishes between upper- and lower-case, includingLatin, Greek, and Cyrillic.
Once we have a Unicode string, we can use it anywhere in Qt’s API where a
QString is expected. It is then Qt’s responsibility to display it properly and to
convert it to other encodings when talking to the operating system.
Special care is needed when we read and write text ﬁles. Text ﬁles can use a
variety of encodings, and it’s often impossible to guess a text ﬁle’s encodingfrom its contents. By default,
QTextStream uses the system’s local 8-bit encod-
ing (available as QTextCodec::codecForLocale() )for both reading and writing.
ForAmerican and West European locales, this usually means Latin-1.
If we design our own ﬁle format and want to be able to read and write arbi-
trary Unicode characters,we can save the data as Unicode by calling setEncod-
ing(QTextStream::Unicode) before we start writing to the QTextStream .The data
will then be saved in UTF-16, a format that requires two bytes per character.The UTF-16 format is very close to the memory representation of a
QString ,
so reading and writing Unicode strings in UTF-16 can be very fast. However,there is an inherent overhead when saving pure ASCII data in UTF-16 format,since it stores two bytes for every character instead of just one.
When reading back the text,
QTextStream normally detects Unicode automati-
cally, but for absolute certainty it is best to call setEncoding(QTextStream::Uni-
code) before reading.
Another encoding that supports the whole of Unicode is UTF-8. Its main ad-
vantage over UTF-16 is that it is a superset of ASCII. Any character in therange 0x00 to 0x7F is represented as a single byte. Other characters,includingLatin-1 characters above 0x7F, are represented by multi-byte sequences. Fortext that is mostly ASCII, UTF-8 takes up about half the space consumed byUTF-16. To use UTF-8 with
QTextStream ,callsetEncoding(QTextStream::Uni-
codeUTF8) before reading and writing.
If we always want to read and write Latin-1 regardless of the user’s locale, we
can call setEncoding(QTextStream::Latin1) on theQTextStream .
Other encodings can be speciﬁed by calling setCodec() with an appropriate
QTextCodec .AQTextCodec is an object that converts between Unicode and a giv-
en encoding. QTextCodec sare used in a variety of contexts by Qt. Internally,
they are used to support fonts, input methods, the clipboard, drag and drop,
322 15. Internationalization
and ﬁle names. But they are also available to us when we write Qt appli-
cations.
Forexample, if we want to read in a ﬁle with the EUC-KR encoding, we can
write this:
QTextStream in(&file);
QTextCodec *koreanCodec = QTextCodec::codecForName("EUC-KR");if (koreanCodec)    in.setCodec(koreanCodec);
Some ﬁle formats specify their encoding in their header. The header is typi-
cally plain ASCII to ensure that it is read correctly no matter what encodingis used (assuming that it is a superset of ASCII). The XML ﬁle format is aninteresting example of this. XML ﬁles are normally encoded as UTF-8 or UTF-16. The proper way to read them in is to call
setEncoding(QTextStream::Uni-
codeUTF8) .Ifthe format is UTF-16, QTextStream will automatically detect this
and adjust itself. The <?xml?> header of an XML ﬁle sometimes contains an
encoding argument, for example:
<?xml version="1.0" encoding="EUC-KR"?>
SinceQTextStream doesn’t allow us to change the encoding once it has started
reading,the right way to respect an explicit encoding is to start reading the ﬁleanew, using the correct codec (obtained from
QTextCodec::codecForName() ).
In the case of XML, we can avoid having to handle the encoding ourselves by
using Qt’s XML classes, described in Chapter 14.
Another use of QTextCodec sistospecify the encoding of strings that occur in
the source code. Let’s consider the example of a team of Japanese program-mers who are writing an application targeted primarily at Japan’s home mar-ket. These programmers are likely to write their source code in a text editorthat uses an encoding such as EUC-JP or Shift-JIS. Such an editor allowsthem to type in Japanese characters seamlessly, so that they can write codelike this:
QPushButton *button = new QPushButton(tr("
 "), 0);
By default, Qt interprets arguments to tr() as Latin-1. To change this, call the
QTextCodec::setCodecForTr() static function. For example:
QTextCodec *japaneseCodec = QTextCodec::codecForName("EUC-JP");
QTextCodec::setCodecForTr(japaneseCodec);
This must be done before the ﬁrst call to tr().Typically, we would do this in
main() ,right after the QApplication object is created.
Other strings speciﬁed in the program will still be interpreted as Latin-1
strings. If the programmers want to enter Japanese characters in those aswell, they can explicitly convert them to Unicode using a
QTextCodec :
QString text = japaneseCodec->toUnicode("
 ");
Working with Unicode 323
Alternatively, they can tell Qt to use a speciﬁc codec when converting between
const char * andQString by calling QTextCodec::setCodecForCStrings() :
QTextCodec::setCodecForCStrings(japaneseCodec);
Because Qt’s internals sometimes convert ASCII strings to QString ,the
encoding must be a superset of ASCII.
The techniques described above can be applied to any non-Latin-1 language,
including Chinese, Greek, Korean, and Russian.
Here’s a list of the encodings supported by Qt 3.2:
•Apple Roman
•Big5-HKSCS
•CP874
•CP1250
•CP1251
•CP1252
•CP1253
•CP1254
•CP1255
•CP1256
•CP1257•CP1258
•EUC-JP
•EUC-KR
•GB2312
•GB18030
•GBK
•IBM-850
•IBM-866
•ISO 8859-1
•ISO 8859-2
•ISO 8859-3•ISO 8859-4
•ISO 8859-5
•ISO 8859-6
•ISO 8859-7
•ISO 8859-8
•ISO 8859-8-I
•ISO 8859-9
•ISO 8859-10
•ISO 8859-11
•ISO 8859-13
•ISO 8859-14•ISO 8859-15
•ISO 10646
UCS-2
•JIS7
•KOI8-R
•KOI8-U
•Shift-JIS
•TIS-620
•TSCII
•UTF-8
Forall of these, QTextCodec::codecForName() will always return a valid pointer.
Other encodings can be supported either by subclassing QTextCodec or by
creating a charmap ﬁle and using QTextCodec::loadCharmapFile() .See the
QTextCodec reference documentation for details.
Making Applications Translation-Aware
If we want to make our applications available in multiple languages, we must
do two things:
•Make sure that every user-visible string goes through tr().
•Load a translation ( .qm)ﬁle at startup.
Neither of these is necessary for applications that will never be translated.
However, using tr() requires almost no effort and leaves the door open for
doing translations at a later date.
Thetr() function is a static function deﬁned in QObject and overridden in
every subclass deﬁned with the Q_OBJECT macro. When writing code inside a
QObject subclass, we can call tr() without formality. A call to tr() returns a
translation if one is available; otherwise, the original text is returned.
Toprepare translation ﬁles, we must run Qt’s lupdate tool. This tool extracts
all the string literals that appear in tr() calls and produces translation ﬁles
324 15. Internationalization
that contain all of these strings ready to be translated. The ﬁles can then be
sent to a translator to have the translations added. This process is explainedin the “Translating Applications” section later in this chapter.
A
tr() call has the following general syntax:
Context::tr( sourceText , comment)
The Context part is the name of a QObject subclass deﬁned with the Q_OBJECT
macro. We don’t need to specify it if we call tr() from a member function of
the class in question. The sourceText part is the string literal that needs to be
translated. The comment part is optional; it can be used to provide additional
information to the translator.
Here are a few examples:
BlueWidget::BlueWidget(QWidget *parent, const char *name)
    : QWidget(parent, name){    QString str1 = tr("Legal");    QString str2 = BlueWidget::tr("Legal");    QString str3 = YellowDialog::tr("Legal");    QString str4 = YellowDialog::tr("Legal", "US paper size");}
The ﬁrst two calls to tr() have “BlueWidget” as context, and the last two calls
have “YellowDialog”.All four have “Legal” as source text. The last call also hasacomment to help the translator understand the meaning of the source text.
Strings in different contexts (classes) are translated independently of each
other. Translators normally work on one context at a time, often with theapplication running and showing the widget or dialog being translated.
When we call
tr() from a global function, we must specify the context explicit-
ly. AnyQObject subclass in the application can be used as the context. If none
is appropriate, we can always use QObject itself. For example:
int main(int argc, char *argv[])
{    QApplication app(argc, argv);
···
    QPushButton button(QObject::tr("Hello Qt!"), 0);
    app.setMainWidget(&button);    button.show();    return app.exec();}
This idiom is useful for translating the name of the application. Instead of
typing it multiple times and leaving the translator to translate it for eachclass it appears in, it is usually more convenient to deﬁne an
APPNAME macro
that expands to the translated application name and to put the macro in aheader ﬁle included by all the application’s ﬁles:
#define APPNAME MainWindow::tr("OpenDrawer 2D")
Making Applications Translation-Aware 325
In every example so far, the context has been a class name. This is convenient,
because we can almost always omit it, but this doesn’t have to be the case. Themost general way of translating a string in Qt is to use the
QApplication::
translate() function, which accepts up to three arguments: the context, the
source text, and the optional comment. For example, here’s another way todeﬁne
APPNAME :
#define APPNAME qApp->translate("Global Stuff", "OpenDrawer 2D")
This time, we put the text in the “Global Stuff” context.
Thetr() andtranslate() functions serve a dual purpose: They are markers
thatlupdate uses to ﬁnd user-visible strings, and at the same time they are
C++functions that translate text. This has an impact on how we write code.
Forexample, the following will not work:
// WRONG
const char *appName = "OpenDrawer 2D";QString translated = tr(appName);
The problem here is that lupdate will not be able to extract the “OpenDraw-
er 2D” string literal, as it doesn’t appear inside a tr() call. This means that
the translator will not have the opportunity to translate the string. This issueoften arises in conjunction with dynamic strings:
// WRONG
statusBar()->message(tr("Host " + hostName + " found"));
Here, the string we pass to tr() varies depending on the value of hostName ,s o
we can’t reasonably expect tr() to translate it correctly.
The solution is to use QString::arg() :
statusBar()->message(tr("Host %1 found").arg(hostName));
Notice how it works: The string literal “Host %1 found” is passed to tr().
Assuming a French translation ﬁle is loaded, tr() would return something
like “Hôte %1 trouvé”. Then the “%1” parameter is replaced with the contentsof the
hostName variable.
Although it is generally inadvisable to call tr() on a variable, it can be made
to work. We must use the QT_TR_NOOP() macro to mark the string literals for
translation before we assign them to a variable. This is mostly useful for staticarrays of strings. For example:
void OrderForm::init()
{    static const char * const flowers[] = {        QT_TR_NOOP("Medium Stem Pink Roses"),        QT_TR_NOOP("One Dozen Boxed Roses"),        QT_TR_NOOP("Calypso Orchid"),        QT_TR_NOOP("Dried Red Rose Bouquet"),        QT_TR_NOOP("Mixed Peonies Bouquet"),        0    };
326 15. Internationalization
    int i = 0;
    while (flowers[i]) {        comboBox->insertItem(tr(flowers[i]));        ++i;    }}
TheQT_TR_NOOP() simply returns its argument. But lupdate will extract all the
strings wrapped in QT_TR_NOOP() ,sothat they can be translated. When using
the variable later on, we call tr() to perform the translation as usual. Even
though we have passed tr() avariable, the translation will still work.
There is also a QT_TRANSLATE_NOOP() macro, which works like QT_TR_NOOP() but
also takes a context. This macro is useful when initializing variables outsideof a class:
static const char * const flowers[] = {
    QT_TRANSLATE_NOOP("OrderForm", "Medium Stem Pink Roses"),    QT_TRANSLATE_NOOP("OrderForm", "One Dozen Boxed Roses"),    QT_TRANSLATE_NOOP("OrderForm", "Calypso Orchid"),    QT_TRANSLATE_NOOP("OrderForm", "Dried Red Rose Bouquet"),    QT_TRANSLATE_NOOP("OrderForm", "Mixed Peonies Bouquet"),    0};
The context argument must be the same as the context given to tr() or
translate() later on.
When we start using tr() in an application, it’s easy to forget to surround
some user-visible strings with a tr() call, especially when we ﬁrst start doing
it. These missing tr() calls are eventually discovered by the translator or,
worse, by users of the translated application, when some strings appear inthe original language. To avoid this problem, we can tell Qt to forbid implicitconversions from
const char * toQString .Wedothis by deﬁning the QT_NO_
CAST_ASCII preprocessor symbol before including <qstring.h> .The easiest way
to ensure this symbol is set is to add the following line to the application’s
.pro ﬁle:
DEFINES      += QT_NO_CAST_ASCII
This will force every string literal to need to be wrapped by tr() orQString::
fromAscii() ,depending on whether it should be translated or not. Strings
that are not suitably wrapped will produce a compile-time error, therebycompelling us to add the missing
tr() orQString::fromAscii() call.
Once we have wrapped every user-visible string by a tr() call, the only thing
left to do to enable translation is to load a translation ﬁle. Typically, we woulddo this in the application’s
main() function. For example, here’s how we would
try to load a translation ﬁle depending on the user’s locale:
int main(int argc, char *argv[])
{    QApplication app(argc, argv);
Making Applications Translation-Aware 327
    QTranslator appTranslator;
    appTranslator.load(QString("app_") + QTextCodec::locale(),                       qApp->applicationDirPath());    app.installTranslator(&appTranslator);
···
    return app.exec();
}
TheQTextCodec::locale() function returns a string that speciﬁes the user’s lo-
cale. Locales can be more or less precise;for example, frspeciﬁesa French-lan-
guage locale, fr_CA speciﬁes a French Canadian locale, and fr_CA.ISO8859-15
speciﬁes a French Canadian locale with ISO 8859-15 encoding (an encoding
that supports ‘ ’, ‘Œ’, ‘œ’, and ‘Y ¨’).
Assuming that the locale is fr_CA.ISO8859-15 ,load() ﬁrst attempts to load the
ﬁleapp_fr_CA.ISO8859-15.qm .Ifthis ﬁle does not exist, load() next tries app_fr_
CA.qm ,thenapp_fr.qm ,and ﬁnally app.qm before giving up. Normally, we would
only provide app_fr.qm ,containing a standard French translation, but if we
need a different ﬁle for French-speaking Canada, we can also provide app_fr_
CA.qm and it will be used for fr_CA locales.
The second argument to load() is the directory where we want load() to look
for the translation ﬁle. In this case, we assume that the translation ﬁles arelocated in the same directory as the executable.
The Qt library itself contains a few strings that need to be translated. Troll-
tech provides French and German translations in Qt’s
translations directory.
(A few other languages are provided as well, but these are contributed by Qtusers and are not ofﬁcially supported.) The Qt library’s translation ﬁle shouldalso be loaded:
QTranslator qtTranslator;
qtTranslator.load(QString("qt_") + QTextCodec::locale(),                  qApp->applicationDirPath());app.installTranslator(&qtTranslator);
AQTranslator object can only hold one translation ﬁle at a time, so we use a
separate QTranslator for Qt’s translation. Having just one ﬁle per translator
is not a problem since we can install as many translators as we need. QAppli-
cation will use all of them when searching for a translation.
Some languages, such as Arabic and Hebrew, are written right-to-left instead
of left-to-right. In those languages, the whole layout of the application mustbe reversed, which is done by calling
QApplication::setReverseLayout(true) .
The translation ﬁles for the Qt library contain a special marker called “LTR”that tells Qt whether the language is left-to-right or right-to-left, so wenormally don’t need to worry about it.
It may prove more convenient for our users if we supply our applications with
the translation ﬁles embedded into the executable. Not only does this reducethe number of ﬁles distributed as part of the product, but it also avoids therisk of translation ﬁles getting lost or deleted by accident. Qt provides the
328 15. Internationalization
qembed tool (located in Qt’s tools directory),which can convert .qmﬁles to a C ++
array that can be passed to QTranslator::load() .
Wehave now covered all that is required to make an application able to oper-
ate using translations into other languages. But language and the directionof the writing system are not the only things that vary between countries andcultures. An internationalized program must also take into account the localdate and time formats, monetary formats, numeric formats, and string col-lation order. Qt 3.2 provides no speciﬁc functions for accessing these, but wecan use the standard C ++
setlocale() andlocaleconv() functions to query the
program’s current locale.#
Some Qt classes and functions adapt their behavior to the locale:
•QString::localeAwareCompare() compares two strings in a locale-depen-
dent manner. It is used by classes like QIconView andQListView for sort-
ing items.
•ThetoString() function provided by QDate ,QTime ,andQDateTime returns a
string in a local format when called with Qt::LocalDate as argument.
•Bydefault, QDateEdit ,QTimeEdit ,andQDateTimeEdit present dates in the
local format.
Finally, a translated application may need to use different icons in certain
situations rather than the original icons. For example, the left and rightarrows on a web browser’s
Back and Forward buttons should be swapped when
dealing with a right-to-left language. We can do this as follows:
if (QApplication::reverseLayout()) {
    backAct->setIconSet(forwardIcon);    forwardAct->setIconSet(backIcon);}else {
    backAct->setIconSet(backIcon);    forwardAct->setIconSet(forwardIcon);}
Icons that contain alphabetic characters very commonly need to be translated.
Forexample, the letter ‘I’ on a toolbar button associated with a word proces-
sor’s Italicoption should be replaced by a ‘C’ in Spanish ( Cursivo )and by a ‘K’ in
Danish, Dutch, German, Norwegian, and Swedish ( Kursiv). Here’s a quick way
to do it:
if (tr("Italic")[0] == ’C’) {
    italicAct->setIconSet(iconC);}else if (tr("Italic")[0] == ’K’) {
    italicAct->setIconSet(iconK);}else {
    italicAct->setIconSet(iconI);}
#Qt 3.3 will probably include a QLocale class that will provide localized numeric formats.
Dynamic Language Switching 329
Dynamic Language Switching
Formost applications, detecting the user’s preferred language in main() and
loading the appropriate .qmﬁles there is perfectly satisfactory. But there are
some situations where users might need the ability to switch language dynam-ically. An application that is used continuously by different people in shiftsmay need to change language without having to be restarted. For example,applicationsused by call center operators,by simultaneoustranslators,and bycomputerized cash register operators often require this capability.
Making an application able to switch language dynamically requires a little
more work than loading a single translation at startup, but it is not difﬁcult.Here’s what must be done:
•Provide a means by which the user can switch language.
•For every widget or dialog, set all of its translatable strings in a separate
function (often called
retranslateStrings() )and call this function when
the language changes.
Let’s review the relevant parts of a Call Center application’s source code. The
application provides a Language menu to allow the user to set the language at
run-time. The default language is English.
Figure 15.1. The Call Center application’s Language menu
Since we don’t know which language the user will want to use when the appli-
cation is started,we no longer load translationsin the main() function. Instead
we will load them dynamically when they are needed, so all the code that weneed to handle translations must go in the main window and dialog classes.
Let’s have a look at the Call Center application’s
QMainWindow subclass:
MainWindow::MainWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name){    journalView = new JournalView(this);    setCentralWidget(journalView);
    qmPath = qApp->applicationDirPath() + "/translations";
330 15. Internationalization
    appTranslator = new QTranslator(this);
    qtTranslator = new QTranslator(this);    qApp->installTranslator(appTranslator);    qApp->installTranslator(qtTranslator);
    createActions();
    createMenus();
    retranslateStrings();
}
In the constructor, we set the central widget to be a JournalView ,aQListView
subclass. Then we set up a few private member variables related to trans-
lation:
•TheqmPath variable is a QString that speciﬁes the path of the directory
that contains the application’s translation ﬁles.
•TheappTranslator variable is a pointer to the QTranslator object used for
storing the current application translation.
•TheqtTranslator variable is a pointer to the QTranslator object used for
storing Qt’s translation.
At the end, we call the createActions() andcreateMenus() private functions
to create the menu system, and we call retranslateStrings() ,also a private
function, to set the user-visible strings for the ﬁrst time.
void MainWindow::createActions()
{    newAct = new QAction(this);    connect(newAct, SIGNAL(activated()), this, SLOT(newFile()));
···
    aboutQtAct = new QAction(this);
    connect(aboutQtAct, SIGNAL(activated()), qApp, SLOT(aboutQt()));}
ThecreateActions() function creates the QAction objects as usual, but without
setting any of the texts or accelerator keys. These will be done in retranslate-
Strings() .
void MainWindow::createMenus()
{    fileMenu = new QPopupMenu(this);    newAct->addTo(fileMenu);    openAct->addTo(fileMenu);    saveAct->addTo(fileMenu);    exitAct->addTo(fileMenu);
···
    createLanguageMenu();
}
ThecreateMenus() function creates menus, but does not insert these menus
into the menu bar. Again, this will be done in retranslateStrings() .
Dynamic Language Switching 331
At the end of the function, we call createLanguageMenu() to ﬁll the Language
menu with the list of supported languages. We will review its source code in
amoment. First, let’s look at retranslateStrings() :
void MainWindow::retranslateStrings()
{    setCaption(tr("Call Center"));
    newAct->setMenuText(tr("&New"));
    newAct->setAccel(tr("Ctrl+N"));    newAct->setStatusTip(tr("Create a new journal"));
···
    aboutQtAct->setMenuText(tr("About &Qt"));
    aboutQtAct->setStatusTip(tr("Show the Qt library’s About box"));
    menuBar()->clear();
    menuBar()->insertItem(tr("&File"), fileMenu);    menuBar()->insertItem(tr("&Edit"), editMenu);    menuBar()->insertItem(tr("&Reports"), reportsMenu);    menuBar()->insertItem(tr("&Language"), languageMenu);    menuBar()->insertItem(tr("&Help"), helpMenu);}
TheretranslateStrings() function is where all the tr() calls for the MainWindow
class occur. It is called at the end of the MainWindow constructor and also every
time a user changes the application’s language using the Language menu.
Weset each QAction ’smenu text, accelerator, and status tip. We also insert the
menus into the menu bar, with their translated names. (The call to clear() is
necessary when retranslateStrings() is called more than once.)
ThecreateMenus() function referred to earlier called createLanguageMenu() to
populate the Language menu with a list of languages:
void MainWindow::createLanguageMenu()
{    QDir dir(qmPath);    QStringList fileNames = dir.entryList("callcenter_*.qm");
    for (int i = 0; i < (int)fileNames.size(); ++i) {
        QTranslator translator;        translator.load(fileNames[i], qmPath);
        QTranslatorMessage message =
                translator.findMessage("MainWindow", "English");        QString language = message.translation();
        int id = languageMenu->insertItem(
                         tr("&%1 %2").arg(i + 1).arg(language),                         this, SLOT(switchToLanguage(int)));        languageMenu->setItemParameter(id, i);        if (language == "English")            languageMenu->setItemChecked(id, true);
        QString locale = fileNames[i];
        locale = locale.mid(locale.find(’_’) + 1);        locale.truncate(locale.find(’.’));
332 15. Internationalization
        locales.push_back(locale);
    }}
Instead of hard-coding the languages supported by the application, we create
one menu entry for each .qmﬁle located in the application’s translations
directory. For simplicity, we assume that English also has a .qmﬁle. An
alternative would have been to call clear() on theQTranslator objects when
the user chooses English.
One particular difﬁculty is to present a nice name for the language provided
by each.qmﬁle. Just showing “en” for “English” or “de” for “Deutsch”,based on
the name of the .qmﬁle, looks crude and will confuse some users. The solution
used increateLanguageMenu() is to check the translation of the string “English”
in the “MainWindow” context. That string should be translated to “Deutsch”in a German translation, to “Français” in a French translation, and to “
”
in a Japanese translation.
Wecreate menu items using QPopupMenu::insertItem() .They are all connected
to the main window’s switchToLanguage(int) slot, which we will review next.
The parameter to the switchToLanguage(int) slot is the value set using set-
ItemParameter() .This is very similar to what we did in Chapter 3 when we im-
plemented the Spreadsheet application’s recently opened ﬁles list (p. 54).
At the end, we append the locale in a QStringList calledlocales ,which we will
use for implementing switchToLanguage() .
void MainWindow::switchToLanguage(int param)
{    appTranslator->load("callcenter_" + locales[param], qmPath);    qtTranslator->load("qt_" + locales[param], qmPath);
    for (int i = 0; i < (int)languageMenu->count(); ++i)
        languageMenu->setItemChecked(languageMenu->idAt(i),                                     i == param);    retranslateStrings();}
TheswitchToLanguage() slot is called when the user chooses a language from
theLanguage menu. We start by loading the translation ﬁles for the applica-
tion and for Qt. Then we update the check marks next to the Language menu
entries so that the language in use is ticked, and we call retranslateStrings()
to retranslate all the strings for the main window.
On Microsoft Windows, an alternative to providing a Language menu is to
respond to LocaleChange events, a type of event emitted by Qt when it detects
achange in the environment’s locale. The event type exists on all platforms
supported by Qt, but is only actually generated on Windows, when the userchanges the system’s locale settings (in the Regional and Language Optionsfrom the Control Panel). To handle
LocaleChange events, we can reimplement
QObject::event() as follows:
Dynamic Language Switching 333
bool MainWindow::event(QEvent *event)
{    if (event->type() == QEvent::LocaleChange) {        appTranslator->load(QString("callcenter_")                            + QTextCodec::locale(),                            qmPath);        qtTranslator->load(QString("qt_") + QTextCodec::locale(),                           qmPath);        retranslateStrings();    }    return QMainWindow::event(event);}
If the user switches locale while the application is being run, we attempt
to load the correct translation ﬁles for the new locale and call retranslate-
Strings() to update the user interface.
In all cases, we pass the event on to the base class’s event() function, since one
of our base classes may also be interested in LocaleChange events.
Wehave now ﬁnished our review of the MainWindow code. We will now review
the code for one of the application’s widget classes,the JournalView class, to see
what changes are needed to make it support dynamic translation.
JournalView::JournalView(QWidget *parent, const char *name)
    : QListView(parent, name){
···
    retranslateStrings();
}
TheJournalView class is a QListView subclass. At the end of the constructor,we
call the private function retranslateStrings() to set the widget’s strings. This
is similar to what we did for MainWindow .
bool JournalView::event(QEvent *event)
{    if (event->type() == QEvent::LanguageChange)        retranslateStrings();    return QListView::event(event);}
Wereimplement the event() function to call retranslateStrings() onLan-
guageChange events.
Qt generates a LanguageChange event when the contents of a QTranslator
currently installed on QApplication changes. In the Call Center application,
this occurs when we call load() onappTranslator orqtTranslator ,either from
MainWindow::switchToLanguage() or from MainWindow::event() .
LanguageChange events are not the same as LocaleChange events. A LocaleChange
event tells the application, “Maybe you should load a new translation.” In
contrast, a LanguageChange event tells the application’s widgets, “Maybe you
should retranslate all your strings.”
334 15. Internationalization
When we implemented MainWindow ,wedidn’t need to respond to Language-
Change .Instead, we simply called retranslateStrings() whenever we called
load() on aQTranslator .
void JournalView::retranslateStrings()
{    for (int i = columns() - 1; i >= 0; --i)        removeColumn(i);    addColumn(tr("Time"));    addColumn(tr("Priority"));    addColumn(tr("Phone Number"));    addColumn(tr("Subject"));}
TheretranslateStrings() function recreates the QListView column headers
with newly translated texts. We do this by removing all column headings andthen adding new column headings. This operation only affects the
QListView
header, not the data stored in the QListView .
This completes the translation-related code of a hand-written widget. For
widgets and dialogs developed with Qt Designer ,theuictool automatically
generates a function similar to our retranslateStrings() function that is
automatically called in response to LanguageChange events. All we need to do
is to load a translation ﬁle when the user switches language.
Translating Applications
Translating a Qt application that contains tr() calls is a three-step process:
1. Runlupdate to extract all the user-visible strings from the application’s
source code.
2. Translate the application using Qt Linguist .
3. Runlrelease to generate binary .qmﬁles that the application can load
usingQTranslator .
Steps 1 and 3 are performed by application developers. Step 2 is handled
by translators. This cycle can be repeated as often as necessary during theapplication’s development and lifetime.
As an example, we will show how to translate the Spreadsheet application
of Chapter 3. The application already contains
tr() calls around every
user-visible string.
First, we must modify the application’s .pro ﬁle slightly to specify which
languages we want to support. For example, if we want to support Germanand French in addition to English, we would add the following
TRANSLATIONS
entry to spreadsheet.pro :
TRANSLATIONS  = spreadsheet_de.ts \
                spreadsheet_fr.ts
Translating Applications 335
Here, we specify two translation ﬁles: one for German and one for French.
These ﬁles will be created the ﬁrst time we run lupdate ,and are updated every
time we subsequently run lupdate .
These ﬁles normally have a .tsextension. They are in a straightforward XML
format and are not as compact as the binary .qmﬁles understood by QTransla-
tor.I ti slrelease ’sjob to convert human-readable .tsﬁles into machine-efﬁ-
cient.qmﬁles. For the curious, .tsstands for “translation source” and .qmfor
“Qt message” ﬁle.
Assuming that we are located in the directory that contains the Spreadsheet
application’s source code, we can run lupdate onspreadsheet.pro from the
command line as follows:
lupdate -verbose spreadsheet.pro
The-verbose argument is optional. It tells lupdate to provide more feedback
than usual. Here’s the expected output:
Updating ’spreadsheet_de.ts’...
 0 known, 101 new and 0 obsoleted messagesUpdating ’spreadsheet_fr.ts’... 0 known, 101 new and 0 obsoleted messages
Every string that appears within a tr() call in the application’s source code is
stored in the .tsﬁles, along with an empty translation. Strings that appear
in the application’s .uiﬁles are also included.
Thelupdate tool assumes by default that the arguments to tr() are Latin-1
strings. If this isn’t the case, we must add a CODEC entry to the .pro ﬁle.
Forexample:
CODEC         = EUC-JP
This must be done in addition to calling QTextCodec::setCodecForTr() from the
application’s main() function.
Translations then need to be added to the spreadsheet_de.ts andspreadsheet_
fr.ts ﬁles using Qt Linguist ,aGUI tool for translating Qt applications.
Tolaunch Qt Linguist ,click Qt 3.2.x|Qt Linguist in the Start menu on Windows,
typelinguist on the command line on Unix, or double-click linguist in the
Mac OS X Finder. To start adding translations to a .tsﬁle, click File|Open and
choose the ﬁle.
The left-hand side of Qt Linguist ’smain window shows the list of contexts
for the application being translated. For the Spreadsheet application, thecontexts are “FindDialog”, “GoToCellDialog”, “MainWindow”, “SortDialog”,and “Spreadsheet”.The top-right area is the list of source texts for the currentcontext. Each source text is shown along with with a translation and a
Done
ﬂag. The middle-right area is where we can enter a translation for the currentsource item. The bottom-right area is a list of suggestions automaticallyprovided by Qt Linguist .
336 15. Internationalization
Once we have a translated .tsﬁle, we need to convert it to a binary .qmﬁle
for it to be understandable by QTranslator .Todothis from within Qt Linguist ,
click File|Release .Typically, we would start by translating only a few strings
and run the application with the .qmﬁle to make sure that everything works.
Figure 15.2. Qt Linguist in action
If we want to regenerate the .qmﬁles for all .tsﬁles, we can use the lrelease
command-line tool as follows:
lrelease -verbose spreadsheet.pro
Assuming that we translated 19 strings to French and clicked the Done ﬂag for
17 of them, lrelease produces the following output:
Updating ’spreadsheet_de.qm’...
 0 finished, 0 unfinished and 101 untranslated messagesUpdating ’spreadsheet_fr.qm’... 17 finished, 2 unfinished and 82 untranslated messages
Untranslated strings are shown in the original languages when running the
application. The Done ﬂag isn’t used by lrelease ;itcan be used by translators
to identify which translations are ﬁnished and which ones must be revisited.
When we modify the source code of the application, the translation ﬁles may
become out of date. The solution is to run lupdate again, provide translations
for the new strings, and regenerate the .qmﬁles. Some development teams
ﬁnd it useful to run lupdate frequently, while others prefer to wait until just
before a ﬁnal product release.
Thelupdate andQt Linguist tools are quite smart. Translations that are no
longer used are kept in the .tsﬁles in case they are needed in later releases.
When updating .tsﬁles,lupdate uses an intelligent merging algorithm that
Translating Applications 337
can save translators considerable time with text that is the same or similar in
different contexts.
Formore information about Qt Linguist ,lupdate ,andlrelease ,refer to the
Qt Linguist manual at http://doc.trolltech.com/3.2/linguist-manual.html .
The manual contains a full explanation of Qt Linguist ’suser interface and a
step-by-step tutorial for programmers.

1616
Providing Online Help•Tooltips,Status Tips,and
“What’s This?” Help
•Using QTextBrowser as a
Simple Help Engine
•Using Qt Assistant for
Powerful Online Help
Most applications provide their users with online help. Some help is short,
such as tooltips, status tips, and “What’s This?” help. Qt supports all of these.Other help can be much more extensive, involving many pages of text. Forthis kind of help, you can use
QTextBrowser as a simple online help browser, or
you can invoke Qt Assistant or another HTML browser from your application.
Tooltips, Status Tips, and “What’s This?” Help
Atooltip is a small piece of text that appears when the mouse hovers over a
widget for a certain period of time. Tooltips are presented with black text onayellow background. Their primary use is to provide textual descriptions of
toolbar buttons.
Wecan add tooltips to arbitrary widgets in code using
QToolTip::add() .
Forexample:
QToolTip::add(findButton, tr("Find next"));
Toset the tooltip of a toolbar button that corresponds to a QAction ,w e can
simply call setToolTip() on the action. For example:
newAct = new QAction(tr("&New"), tr("Ctrl+N"), this);
newAct->setToolTip(tr("New file"));
If we don’t explicitly set a tooltip, QAction will automatically derive one from
the action text and the accelerator key (for example, “New (Ctrl+N)”).
Astatus tip is also a short piece of descriptive text, usually a little longer than
atooltip. When the mouse hovers over a toolbar button or a menu option, a
status tip appears in the status bar. Call setStatusTip() to add a status tip to
an action:
339
340 16. Providing Online Help
newAct->setStatusTip(tr("Create a new file"));
In the absence of a status tip, QAction will use the tooltip text instead.
If we don’t use QAction s,we need to pass a QToolTipGroup object and a status
tip as the third and fourth arguments to QToolTip::add() :
QToolTip::add(findButton, tr("Find next"), toolTipGroup,
              tr("Find the next occurrence of the search text"));
The application can be made to show the longer text in the status bar by
connecting the QToolTipGroup ’sshowTip() andremoveTip() signals to the status
bar’smessage() andclear() slots. The QToolTipGroup object is responsible for
maintaining contact between tooltips and a widget that can show the longerhelp text.
Figure 16.1. An application showing a tooltip and a status tip
InQt Designer ,tooltips and status tips are accessible through the toolTip and
statusTip properties of a widget or action.
In some situations, it is desirable to provide more information about a widget
than can be given by tooltips or status tips. For example, we might wantto provide a complex dialog with explanatory text about each ﬁeld withoutforcing the user to invoke a separate help window. “What’s This?” mode is anideal solution for this. When a window is in “What’s This?” mode, the cursorchanges to
and the user can click on any user interface component to obtain
its help text. To enter “What’s This?” mode, the user can either click the ?
button in the dialog’s title bar (on Windows and KDE) or press Shift+F1 .
The help text can be set by calling QWhatsThis::add() .Here’s an example:
Tooltips,Status Tips,and “What’s This?” Help 341
QWhatsThis::add(sourceLineEdit,
    tr("<img src=\"icon.png\">"       "&nbsp;The meaning of the Source field depends on the "       "Type field:"       "<ul>"       "<li><b>Books</b> have a Publisher</li>"       "<li><b>Articles</b> have a Journal name with volume and "       "issue number</li>"       "<li><b>Thesis</b> have an Institution name and a "       "department name</li>"       "</ul>"));
As with many other Qt widgets, we can use HTML-style tags to format the
text of a tooltip. In the example, we include an image (which is listed in theapplication’s
.pro ﬁleIMAGE entry), a bulleted list, and some text in bold. The
tags that Qt supports are speciﬁed in the QStyleSheet documentation.
Figure 16.2. Adialog showing a “What’s This?” help text
Wecan also set a “What’s This?” text on an action:
openAct->setWhatsThis(tr("<img src=open.png>&nbsp;"
                         "Click this option to open an "                         "existing file."));
The text will be shown when the user clicks the menu item or toolbar button or
presses the accelerator key while in “What’s This?” mode. In Qt Designer ,the
“What’s This?” text for a widget or action is available through the whatsThis
property.
When the user interface components of an application’s main window provide
“What’s This?” text, it is customary to provide a What’s This? option in the Help
menu as well as a What’s This? toolbar button. This can be done by creating a
What’s This? action and connecting its activated() signal to the QMainWindow ’s
whatsThis() slot, which enters “What’s This?” mode when executed.
342 16. Providing Online Help
Using QTextBrowser as a Simple Help Engine
Large and sophisticated applications may require more online help than
tooltips, status tips, and “What’s This?” help can provide. A simple solutionto this is to provide a help browser. Applications that provide a help browsertypically have a
Helpentry in the main window’s Helpmenu and a Helpbutton
in every dialog.
In this section, we present the simple help browser shown in Figure 16.3
and explain how it can be used within an application. The window uses a
QTextBrowser to display help pages that are marked up with an HTML-based
syntax. QTextBrowser can handle a lot of simple HTML tags, so it is ideal for
this purpose.
Figure 16.3. TheHelpBrowser widget
Webegin with the header ﬁle:
#include <qwidget.h>
class QPushButton;
class QTextBrowser;
class HelpBrowser : public QWidget
{    Q_OBJECTpublic:    HelpBrowser(const QString &path, const QString &page,                QWidget *parent = 0, const char *name = 0);
    static void showPage(const QString &page);private slots:
    void updateCaption();
private:
Using QTextBrowser as a Simple Help Engine 343
    QTextBrowser *textBrowser;
    QPushButton *homeButton;    QPushButton *backButton;    QPushButton *closeButton;};
TheHelpBrowser provides a static function that can be called from anywhere
in the application. This function creates a HelpBrowser window and shows the
given page.
Here’s the beginning of the implementation:
#include <qapplication.h>
#include <qlayout.h>#include <qpushbutton.h>#include <qtextbrowser.h>
#include "helpbrowser.h"HelpBrowser::HelpBrowser(const QString &path, const QString &page,
                         QWidget *parent, const char *name)    : QWidget(parent, name, WGroupLeader | WDestructiveClose){    textBrowser = new QTextBrowser(this);    homeButton = new QPushButton(tr("&Home"), this);    backButton = new QPushButton(tr("&Back"), this);    closeButton = new QPushButton(tr("Close"), this);    closeButton->setAccel(tr("Esc"));
    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    QHBoxLayout *buttonLayout = new QHBoxLayout(mainLayout);    buttonLayout->addWidget(homeButton);    buttonLayout->addWidget(backButton);    buttonLayout->addStretch(1);    buttonLayout->addWidget(closeButton);    mainLayout->addWidget(textBrowser);
    connect(homeButton, SIGNAL(clicked()),
            textBrowser, SLOT(home()));    connect(backButton, SIGNAL(clicked()),            textBrowser, SLOT(backward()));    connect(closeButton, SIGNAL(clicked()),            this, SLOT(close()));    connect(textBrowser, SIGNAL(sourceChanged(const QString &)),            this, SLOT(updateCaption()));
    textBrowser->mimeSourceFactory()->addFilePath(path);
    textBrowser->setSource(page);}
The layout is simply a row of buttons above a QTextBrowser .Thepath param-
eter is a path in the ﬁle system that contains the application’s documentation.The
page parameter is the name of the documentation ﬁle, with an optional
HTML anchor.
Weuse theWGroupLeader ﬂag because we want to pop up HelpBrowser windows
from modal dialogs in addition to the main window. Modal dialogs normally
344 16. Providing Online Help
prevent the user from interacting with any other window in the application.
However, after requesting help, the user must obviously be allowed to interactwith both the modal dialog and the help browser. Using the
WGroupLeader ﬂag
makes this interaction possible.
void HelpBrowser::updateCaption()
{    setCaption(tr("Help: %1").arg(textBrowser->documentTitle()));}
Whenever the source page changes, the updateCaption() slot is executed. The
documentTitle() function returns the text speciﬁed in the page’s <title> tag.
void HelpBrowser::showPage(const QString &page){    QString path = qApp->applicationDirPath() + "/doc";    HelpBrowser *browser = new HelpBrowser(path, page);    browser->resize(500, 400);    browser->show();}
In theshowPage() static function, we create the HelpBrowser window and then
show it. The window will be destroyed automatically when the user closes it,since we set the
WDestructiveClose ﬂag in the constructor.
Forthis example, we assume that the documentation is located in the doc
subdirectory of the directory containing the application’s executable. All the
pages passed to the showPage() function will be taken from this docsubdirec-
tory.
Now we are ready to invoke the help browser from the application. In the
application’s main window, we would create a Help action and connect it to a
help() slot that could look like this:
void MainWindow::help()
{    HelpBrowser::showPage("index.html");}
This assumes that the main help ﬁle is called index.html .For dialogs,we would
connect the Helpbutton to a help() slot that could look like this:
void EntryDialog::help()
{    HelpBrowser::showPage("dialogs.html#entrydialog");}
Here we look in a different help ﬁle, dialogs.html ,and scroll the QTextBrowser
to theentrydialog anchor.
One other place from which we might want to invoke help is a “What’s
This?” text. We can link the “What’s This?” text to the documentation by usingHTML
<a href="..."> tags.
Using QTextBrowser as a Simple Help Engine 345
Figure 16.4. A“What’s This?” text with links
Tomake hypertext links work from “What’s This?” text, we must use a QWhats-
This that is aware of the help browser. This is accomplished by subclassing
QWhatsThis and reimplementing its clicked() function to call HelpBrowser::
showPage() .Here’s the class deﬁnition:
class MyWhatsThis : public QWhatsThis
{public:    MyWhatsThis(QWidget *widget, const QString &text);
    QString text(const QPoint &point);
    bool clicked(const QString &page);
private:
    QString myText;};
Thetext() andclicked() functions are reimplemented from QWhatsThis .
MyWhatsThis::MyWhatsThis(QWidget *widget, const QString &text)    : QWhatsThis(widget){    myText = text;}
The constructor accepts a widget and a “What’s This?” text for that widget. We
pass on the widget to the base class and store the text in a private variable.
QString MyWhatsThis::text(const QPoint &)
{    return myText;}
Thetext() function returns the “What’s This?” text for a widget given a cer-
tain mouse cursor position. For some widgets, it might make sense to returnadifferent text depending on where the user clicked on it, but here we always
return the same text.
bool MyWhatsThis::clicked(const QString &page)
{    if (page.isEmpty()) {        return true;    } else {        HelpBrowser::showPage(page);
346 16. Providing Online Help
        return false;
    }}
Theclicked() function is called by QWhatsThis when the user clicks on the
“What’s This?” window. If the user clicked on an HTML link, QWhatsThis
passes the target page to the clicked() function. (If anything else is clicked,
an empty string is passed.) We invoke the help browser with the given page.
The return value of clicked() is used by QWhatsThis to determine whether it
should hide the “What’s This?” text (indicated by true)orcontinue to show it.
When the user clicks a link, we want the “What’s This?” to stay visible alongwith the help window, so we return
false .Ifthe user clicked elsewhere in the
“What’s This?” window, we return true to hide the “What’s This?” window.
Here’s how the MyWhatsThis class can be used:
new MyWhatsThis(sourceLineEdit,
    tr("<img src=\"icon.png\">"
       "&nbsp;The meaning of the "       "<a href=\"fields.html#source\">Source</a> field depends on "       "the <a href=\"fields.html#type\">Type</a> field:"       "<ul>"       "<li><b>Books</b> have a Publisher</li>"       "<li><b>Articles</b> have a Journal name with volume and "       "issue number</li>"       "<li><b>Thesis</b> have an Institution name and a department "       "name</li>"       "</ul>"));
Instead of calling QWhatsThis::add() ,wecreate a MyWhatsThis object with the
widget and its associated text. But this time, if the user clicks a link, the helpbrowser is invoked.
It may look strange that we allocate an object with
newand don’t assign the
value to a variable. This is not a problem here because Qt keeps track of all
QWhatsThis objects and deletes them when they are no longer needed.
Using Qt Assistant for Powerful Online Help
Qt Assistant is a redistributable online help application supplied by Trolltech.
Its main virtues are that it supports indexing and full text search and that itcan handle multiple documentation sets for multiple applications.
Tomake use of Qt Assistant ,wemust incorporate the necessary code in our
application, and we must make Qt Assistant aware of our documentation.
Communication between a Qt application and Qt Assistant is handled by the
QAssistantClient located in a separate library. To link this library with an
application, we must add the following line to the application’s .pro ﬁle:
LIBS         += -lqassistantclient
Using Qt Assistant for Powerful Online Help 347
Wewill now review the code of a new HelpBrowser class that uses Qt Assis-
tant.
#ifndef HELPBROWSER_H
#define HELPBROWSER_H
class QAssistantClient;class HelpBrowser
{public:    static void showPage(const QString &page);
private:
    static QAssistantClient *assistant;};
#endif
Here’s the new helpbrowser.cpp :
#include <qassistantclient.h>#include "helpbrowser.h"QAssistantClient *HelpBrowser::assistant = 0;void HelpBrowser::showPage(const QString &page)
{    if (!assistant)        assistant = new QAssistantClient("");    assistant->showPage(page);}
TheQAssistantClient constructor accepts a path string as its ﬁrst argument,
which it uses to locate the Qt Assistant executable. By passing an empty
path, we signify that QAssistantClient should look for the executable in the
PATH environment variable. QAssistantClient has its own showPage() function
that accepts a page name with an optional HTML anchor, just like the earlier
QTextBrowser subclass’s showPage() function.
The next step is to tell Qt Assistant where the documentation is located. This
is done by creating a Qt Assistant proﬁle and creating a .dcf ﬁle that provides
information about the documentation. All this is explained in Qt Assistant ’s
online documentation, so we will not duplicate that information here.
An alternative to using QTextBrowser orQt Assistant is to use platform-speciﬁc
approaches to providing online help. For Windows applications, it might bedesirable to create Windows HTML Help ﬁles and to provide access to themusing Microsoft Internet Explorer. You could use Qt’s
QProcess class or the
ActiveQt framework for this. For Unix and Mac OS X applications, a suitableapproach might be to provide HTML ﬁles and launch a web browser.

1717
Multithreading•Working with Threads
•Communicating with the GUI
Thread
•Using Qt’s Classes in
Non-GUI Threads
Conventional GUI applications have one thread of execution and perform one
operation at a time. If the user invokes a time-consuming operation from theuser interface in a single-threaded application, the interface typically freezeswhile the operation is in progress. Chapter 7 (Event Processing) providessome solutions to this problem. Multithreading is another solution.
In a multithreaded Qt application,the GUI runs in its own thread and the pro-
cessing takes place in one or more other threads. This results in applicationsthat have responsive GUIs even during intensive processing. Another beneﬁtof multithreading is that on multiprocessor machines different threads maybe executed simultaneously on different processors, resulting in better per-formance.
In this chapter, we will start by showing how to subclass
QThread and how to
useQMutex ,QSemaphore ,andQWaitCondition to synchronize threads. Then we
will see how to communicate with the GUI thread from non-GUI threads whilethe event loop is running, and round off with a review of which Qt classes canbe used in non-GUI threads and which cannot.
Multithreading is a large topic with many books devoted exclusively to the
subject. Here, it is assumed that you already understand the fundamentalsof multithreaded programming; the focus is on explaining how to developmultithreaded Qt applications rather than on the subject of threading itself.
Working with Threads
Providing multiple threads in a Qt application is straightforward: We just
subclass QThread and reimplement its run() function. To show how this works,
we will start by reviewing the code for a very simple QThread subclass that
repeatedly prints the same text on a console.
349
350 17. Multithreading
class Thread : public QThread
{public:    Thread();
    void setMessage(const QString &message);
    void run();    void stop();
private:
    QString messageStr;    volatile bool stopped;};
TheThread class inherits from QThread and reimplements the run() function.
It provides two additional functions: setMessage() andstop() .
Thestopped variable is declared volatile because it is accessed from different
threads and we want to be sure that it is freshly read every time it is needed.If we omitted the
volatile keyword, the compiler might optimize access to the
variable, possibly leading to incorrect results.
Thread::Thread()
{    stopped = false;}
Wesetstopped tofalse in the constructor.
void Thread::run()
{    while (!stopped)        cerr << messageStr.ascii();    stopped = false;    cerr << endl;}
Therun() function is called to start executing the thread. As long as the
stopped variable is false ,the function keeps printing the given message to the
console. The thread terminates when control leaves the run() function.
void Thread::stop()
{    stopped = true;}
Thestop() function sets the stopped variable to true,thereby telling run() to
stop printing text to the console. This function can be called from any threadat any time. For the purposes of this example, we assume that assignment toa
bool is an atomic operation. This is a reasonable assumption, considering
that abool is either true orfalse .Wewill see later in this section how to use
QMutex to guarantee that assigning to a variable is an atomic operation.
QThread provides a terminate() function that terminates the execution of a
thread while it is still running. Using terminate() is not recommended, since
it can stop the thread at any point and does not give the thread any chance to
Working with Threads 351
clean up after itself. It is always safer to use a stopped variable and a stop()
function, as we did here.
Figure 17.1. The Threads application
Wewill now see how to use the Thread class in a small Qt application that uses
two threads, A and B, in addition to the initial thread.
class ThreadForm : public QDialog
{    Q_OBJECTpublic:    ThreadForm(QWidget *parent = 0, const char *name = 0);
protected:
    void closeEvent(QCloseEvent *event);
private slots:
    void startOrStopThreadA();    void startOrStopThreadB();
private:
    Thread threadA;    Thread threadB;    QPushButton *threadAButton;    QPushButton *threadBButton;    QPushButton *quitButton;};
TheThreadForm class declares two variables of type Thread and some buttons
to provide a basic user interface.
ThreadForm::ThreadForm(QWidget *parent, const char *name)
    : QDialog(parent, name){    setCaption(tr("Threads"));
    threadA.setMessage("A");
    threadB.setMessage("B");
    threadAButton = new QPushButton(tr("Start A"), this);
    threadBButton = new QPushButton(tr("Start B"), this);    quitButton = new QPushButton(tr("Quit"), this);    quitButton->setDefault(true);
    connect(threadAButton, SIGNAL(clicked()),
            this, SLOT(startOrStopThreadA()));    connect(threadBButton, SIGNAL(clicked()),            this, SLOT(startOrStopThreadB()));
352 17. Multithreading
    connect(quitButton, SIGNAL(clicked()),
            this, SLOT(close()));
···
}
In the constructor, we call setMessage() to make the ﬁrst thread repeatedly
print “A” and the second thread “B”.
void ThreadForm::startOrStopThreadA()
{    if (threadA.running()) {        threadA.stop();        threadAButton->setText(tr("Start A"));    } else {        threadA.start();        threadAButton->setText(tr("Stop A"));    }}
When the user clicks the button for thread A, startOrStopThreadA() stops
the thread if it was running and starts it otherwise. It also updates the but-ton’s text.
void ThreadForm::startOrStopThreadB()
{    if (threadB.running()) {        threadB.stop();        threadBButton->setText(tr("Start B"));    } else {        threadB.start();        threadBButton->setText(tr("Stop B"));    }}
The code for startOrStopThreadB() is very similar.
void ThreadForm::closeEvent(QCloseEvent *event){    threadA.stop();    threadB.stop();    threadA.wait();    threadB.wait();    event->accept();}
If the user clicks Quitor closes the window, we stop any running threads and
wait for them to ﬁnish (using QThread::wait() )before we call QCloseEvent::
accept() .This ensures that the application exits in a clean state, although it
doesn’t really matter in this example.
Tocompile the application, we must add this line to the .pro ﬁle:
CONFIG       += thread
This tells qmake to use the threaded version of the Qt library. To build a thread-
ed Qt library, pass the -thread command-line option to the configure script on
Working with Threads 353
Unix and Mac OS X. On Windows, the Qt library is threaded by default. For
this particular example, we also need the console option since we want the
program’s output to appear in the console on Windows:
win32:CONFIG += console
If you run the application and click Start A ,the console will be ﬁlled with ‘A’s.
If you click Start B ,itwill now ﬁll with alternating sequences of ‘A’s and ‘B’s.
Click Stop A ,and now it will only print ‘B’s.
Acommon requirement for multithreaded applications is that of synchroniz-
ing several threads. Qt provides the following classes to do this: QMutex ,QMu-
texLocker ,QSemaphore ,andQWaitCondition .
TheQMutex class provides a means of protecting a variable or a piece of code
so that only one thread can access it at a time. The class provides a lock()
function that locks the mutex. If the mutex is unlocked, the current threadseizes it immediately and locks it; otherwise, the current thread is blockeduntil the thread that holds the mutex unlocks it. Either way, when the callto
lock() returns, the current thread holds the mutex until it calls unlock() .
QMutex also provides a tryLock() function that returns immediately if the
mutex is already locked.
Forexample, let’s suppose that we wanted to protect the stopped variable of
theThread class with a QMutex .Wewould then add the following data member
toThread :
QMutex mutex;
Therun() function would change to this:
void Thread::run()
{    for (;;) {        mutex.lock();        if (stopped) {            stopped = false;            mutex.unlock();            break;        }        mutex.unlock();
        cerr << messageStr.ascii();
    }    cerr << endl;}
Thestop() function would become this:
void Thread::stop(){    mutex.lock();    stopped = true;    mutex.unlock();}
354 17. Multithreading
Locking and unlocking a mutex in complex functions,especially functionsthat
use C ++exceptions, can be error-prone. Qt provides the QMutexLocker conve-
nience class to simplify mutex handling. QMutexLocker ’sconstructor accepts a
QMutex as argument and locks it. QMutexLocker ’sdestructor unlocks the mutex.
Forexample, we could rewrite the stop() function above as follows:
void Thread::stop()
{    QMutexLocker locker(&mutex);    stopped = true;}
QSemaphore
provides semaphores in Qt. A semaphore is a generalization of
mutexes that can be used to guard a certain number of identical resources.
The following two code snippets show the correspondence between QSemaphore
andQMutex :
QSemaphore semaphore(1);
semaphore++;semaphore--;QMutex mutex;           
mutex.lock();mutex.unlock();
The postﬁx ++and--operators acquire and release one resource protected by
the semaphore. By passing 1 to the constructor, we tell the semaphore that itcontrols a single resource. The advantage of using a semaphore is that we canpass numbers other than 1 to the constructor and then call
++multiple times
to acquire many resources.
Atypical application of semaphores is when transfering a certain amount of
data (DataSize )between two threads using a shared circular buffer of a certain
size (BufferSize ):
const int DataSize = 100000;
const int BufferSize = 4096;char buffer[BufferSize];
The producer thread writes data to the buffer until it reaches the end, and
then restarts from the beginning, overwriting existing data. The consumerthread reads the data as it is generated. Figure 17.2 illustrates this, assumingatiny 16-byte buffer.
012 3456789 1 0 11 12 131415
AAGCCTAC
consumer producerusedSpace (5) freeSpace (11)
Figure 17.2. The producer–consumer model
The need for synchronization in the producer–consumer example is twofold:
If the producer generates the data too fast, it will overwrite data that theconsumer hasn’t yet read; if the consumer reads the data too fast, it will passthe producer and read garbage.
Working with Threads 355
Acrude way to solve this problem is to have the producer ﬁll the buffer, then
wait until the consumer has read the entire buffer,and so on. However,on mul-
tiprocessor machines, this isn’t as fast as letting the producer and consumerthreads operate on different parts of the buffer at the same time.
One way to efﬁciently solve the problem is to use two semaphores:
QSemaphore freeSpace(BufferSize);
QSemaphore usedSpace(BufferSize);
ThefreeSpace semaphore governs the part of the buffer that the producer
can ﬁll with data. The usedSpace semaphore governs the area that the con-
sumer can read. These two areas are complementary. Both are initializedwith
BufferSize (4096), meaning that they can administer up to that many
resources.
Forthis example,each byte countsas one resource. In a real-world application,
we would probably operate on larger units (for example, 64 or 256 bytes at atime) to reduce the overhead associated with using semaphores.
void acquire(QSemaphore &semaphore)
{    semaphore++;}
Theacquire() function attempts to acquire one resource (one byte in the
buffer). QSemaphore uses the postﬁx ++operator for this, but in our particular
example it is more intuitive to use a function called acquire() .
void release(QSemaphore &semaphore)
{    semaphore--;}
Similarly, we implement the release() function as a synonym for the postﬁx
--operator.
void Producer::run(){    for (int i = 0; i < DataSize; ++i) {        acquire(freeSpace);        buffer[i % BufferSize] = "ACGT"[(uint)rand() % 4];        release(usedSpace);    }}
In the producer, we start by acquiring one “free” byte. If the buffer is full of
data that the consumer hasn’t read yet, the call to acquire() will block until
the consumer has started to consume the data. Once we have acquired thebyte, we ﬁll it with some random data (‘A’, ‘C’, ‘G’, or ‘T’) and release the byteas “used”, so that it can be read by the consumer thread.
void Consumer::run()
{    for (int i = 0; i < DataSize; ++i) {
356 17. Multithreading
        acquire(usedSpace);
        cerr << buffer[i % BufferSize];        release(freeSpace);    }    cerr << endl;}
In the consumer, we start by acquiring one “used” byte. If the buffer contains
no data to read, the call to acquire() will block until the producer has produced
some. Once we have acquired the byte, we print it and release the byte as“free”, making it possible for the producer to ﬁll it with data again.
int main()
{    usedSpace += BufferSize;
    Producer producer;
    Consumer consumer;    producer.start();    consumer.start();    producer.wait();    consumer.wait();    return 0;}
Finally, in main() ,westart by acquiring all the “used” space (using QSemaphore ’s
counterintuitive +=operator) to ensure that the consumer will not acquire it
and read garbage. Then we start the producer and consumer threads. Whathappens then is that the producer converts some “free” space into “used”space, and the consumer can then convert it back to “free” space.
When we run the program, it writes a random sequence of 100,000 ‘A’s, ‘C’s,
‘G’s, and ‘T’s to the console and then terminates. To really understand what isgoing on, we can disable writing the output and instead write ‘P’ each time theproducer generates a byte and ‘c’ each time the consumer reads a byte. And tomake things as simple to follow as possible, we can use much smaller valuesfor
DataSize andBufferSize .
Forexample, here’s a possible run with a DataSize of 10 and a BufferSize
of 4: “PcPcPcPcPcPcPcPcPcPc”. In this case, the consumer reads the bytes
as soon as they are generated by the producer; the two threads are executingat the same speed. Another possibility is that the producer ﬁlls the wholebuffer before the consumer even starts reading it: “PPPPccccPPPPccccPPcc”.There are many other possibilities. Semaphores give a lot of latitude to thesystem-speciﬁc thread scheduler, which can study the threads’ behavior andchoose an optimal scheduling policy.
Adifferent approach to the problem of synchronizing a producer and a con-
sumer is to use
QWaitCondition andQMutex .AQWaitCondition allows a thread
to wake up other threads when some condition has been met. This allowsfor more precise control than is possible with mutexes alone. To show how itworks, we will redo the producer–consumer example using wait conditions.
Working with Threads 357
const int DataSize = 100000;
const int BufferSize = 4096;char buffer[BufferSize];
QWaitCondition bufferIsNotFull;
QWaitCondition bufferIsNotEmpty;QMutex mutex;int usedSpace = 0;
In addition to the buffer, we declare two QWaitCondition s,oneQMutex ,and one
variable that stores how many bytes in the buffer are “used” bytes.
void Producer::run()
{    for (int i = 0; i < DataSize; ++i) {        mutex.lock();        while (usedSpace == BufferSize)            bufferIsNotFull.wait(&mutex);        buffer[i % BufferSize] = "ACGT"[(uint)rand() % 4];        ++usedSpace;        bufferIsNotEmpty.wakeAll();        mutex.unlock();    }}
In the producer,we start by checking whether the buffer is full. If it is, we wait
on the “buffer is not full” condition. When that condition is met, we write onebyte to the buffer, increment
usedSpace ,and wake any thread waiting for the
“buffer is not empty” condition to turn true.
Weuse a mutex to protect all accesses to the usedSpace variable. The QWaitCon-
dition::wait() function can take a locked mutex as its ﬁrst argument, which
it unlocks before blocking the current thread and then locks before returning.
Forthis example, we could have replaced the while loop
while (usedSpace == BufferSize)
    bufferIsNotFull.wait(&mutex);
with this ifstatement:
if (usedSpace == BufferSize) {    mutex.unlock();    bufferIsNotFull.wait();    mutex.lock();}
However, this would break as soon as we allow more than one producer thread,
since another producer could seize the mutex immediately after the wait()
call and make the “buffer is not full” condition false again.
void Consumer::run()
{    for (int i = 0; i < DataSize; ++i) {        mutex.lock();        while (usedSpace == 0)            bufferIsNotEmpty.wait(&mutex);
358 17. Multithreading
        cerr << buffer[i % BufferSize];
        --usedSpace;        bufferIsNotFull.wakeAll();        mutex.unlock();    }    cerr << endl;}
The consumer does the opposite of the producer: It waits for the “buffer is
not empty” condition and wakes up any thread waiting for the “buffer is notfull” condition.
In all the examples so far, our threads have accessed the same global variables.
But some threaded applications need to have a global variable hold differentvalues in different threads. This is often called thread-local storage (TLS) orthread-speciﬁc data (TSD). We can fake it using a map keyed on thread IDs(returned by
QThread::currentThread() ), but a nicer approach is to use the
QThreadStorage<T> class.
Acommon use of QThreadStorage<T> is for caches. By having a separate cache
in different threads, we avoid the overhead of locking, unlocking, and possiblywaiting for a mutex. For example:
QThreadStorage<QMap<int, double> *> cache;
void insertIntoCache(int id, double value)
{    if (!cache.hasLocalData())        cache.setLocalData(new QMap<int, double>);    cache.localData()->insert(id, value);}
void removeFromCache(int id)
{    if (cache.hasLocalData())        cache.localData()->remove(id);}
Thecache variable holds one pointer to a QMap<int,double> per thread. (Be-
cause of problems with some compilers, the template type in QThreadStor-
age<T> must be a pointer type.) The ﬁrst time we use the cache in a particu-
lar thread, hasLocalData() returns false and we create the QMap<int,double>
object.
In addition to caching, QThreadStorage<T> can be used for global error-state
variables (similar to errno ), to ensure that modiﬁcations in one thread don’t
affect other threads.
Communicating with the GUI Thread 359
Communicating with the GUI Thread
When a Qt application starts, only one thread is running—the initial thread.
This is the only thread that is allowed to create the QApplication object and
callexec() on it. For this reason, we normally refer to this thread as the GUI
thread. After the call to exec() ,this thread is either waiting for an event or
processing an event.
The GUI thread can start new threads by creating objects of a QThread sub-
class, as we did in the previous section. If these new threads need to communi-cate among themselves, they can use shared variables together with mutexes,semaphores, or wait conditions. But none of these techniques can be used tocommunicate with the GUI thread, since they would lock the event loop andfreeze the user interface.
The solution for communicating from a non-GUI thread to the GUI thread is
to use custom events. Qt’s event mechanism allows us to deﬁne custom eventtypes in addition to the built-in types, and allows us to post events of thesetypes using
QApplication::postEvent() .Furthermore, since postEvent() is
thread-safe, we can use it from any thread to post events to the GUI thread.
Figure 17.3. The Image Pro application
Toillustrate how this works, we will review the code of the Image Pro applica-
tion, a basic image processing application that allows the user to rotate,resize,and change the color depth of an image. The application uses one non-GUIthread to perform operations on images without locking the event loop. Thismakes a signiﬁcant difference when processing large images. The non-GUI
360 17. Multithreading
thread has a list of tasks, or “transactions”,to accomplish, and sends events to
the main window to report progress.
ImageWindow::ImageWindow(QWidget *parent, const char *name)
    : QMainWindow(parent, name){    thread.setTargetWidget(this);
···
}
In theImageWindow constructor, we set the “target widget” of the non-GUI
thread to be the ImageWindow .The thread will post progress events to that
widget. The thread variable is of type TransactionThread ,which we will cover
in a moment.
void ImageWindow::flipHorizontally()
{    addTransaction(new FlipTransaction(Horizontal));}
TheflipHorizontally() slot creates a “ﬂip” transaction and registers it using
the private function addTransaction() .TheflipVertical() ,resizeImage() ,
convertTo32Bit() ,convertTo8Bit() ,andconvertTo1Bit() functions are similar.
void ImageWindow::addTransaction(Transaction *transact)
{    thread.addTransaction(transact);    openAct->setEnabled(false);    saveAct->setEnabled(false);    saveAsAct->setEnabled(false);}
TheaddTransaction() function adds a transaction to the non-GUI thread’s
transaction queue and disables the Open ,Save,and Save As actions while
transactions are being processed.
void ImageWindow::customEvent(QCustomEvent *event)
{    if ((int)event->type() == TransactionStart) {        TransactionStartEvent *startEvent =                (TransactionStartEvent *)event;        infoLabel->setText(startEvent->message);    } else if ((int)event->type() == AllTransactionsDone) {        openAct->setEnabled(true);        saveAct->setEnabled(true);        saveAsAct->setEnabled(true);        imageLabel->setPixmap(QPixmap(thread.image()));        infoLabel->setText(tr("Ready"));        modLabel->setText(tr("MOD"));        modified = true;        statusBar()->message(tr("Done"), 2000);    } else {        QMainWindow::customEvent(event);    }}
Communicating with the GUI Thread 361
ThecustomEvent() function is reimplemented from QObject to handle custom
events. The TransactionStart andAllTransactionsDone constants are deﬁned
intransactionthread.h as
enum { TransactionStart = 1001, AllTransactionsDone = 1002 };
Qt’s built-in events have values below 1000. Higher values can be used forcustom events.
The data type for custom events is
QCustomEvent ,aQEvent subclass that stores
avoid pointer in addition to the event type. For TransactionStart events, we
use aQCustomEvent subclass that stores an additional data member:
class TransactionStartEvent : public QCustomEvent
{public:    TransactionStartEvent();
    QString message;
};
TransactionStartEvent::TransactionStartEvent()
    : QCustomEvent(TransactionStart){}
In the constructor,we pass the TransactionStart constant to the base class con-
structor.
Now, let’s turn to the TransactionThread class:
class TransactionThread : public QThread
{public:    void run();    void setTargetWidget(QWidget *widget);    void addTransaction(Transaction *transact);    void setImage(const QImage &image);    QImage image();
private:
    QWidget *targetWidget;    QMutex mutex;    QImage currentImage;    std::list<Transaction *> transactions;};
TheTransactionThread class maintains a list of transactions to process and
executes them one after the other in the background.
void TransactionThread::addTransaction(Transaction *transact)
{    QMutexLocker locker(&mutex);    transactions.push_back(transact);    if (!running())        start();}
362 17. Multithreading
TheaddTransaction() function adds a transaction to the transaction queue
and starts the transaction thread if it isn’t already running.
void TransactionThread::run()
{    Transaction *transact;
    for (;;) {
        mutex.lock();        if (transactions.empty()) {            mutex.unlock();            break;        }        QImage oldImage = currentImage;        transact = *transactions.begin();        transactions.pop_front();        mutex.unlock();
        TransactionStartEvent *event = new TransactionStartEvent;
        event->message = transact->messageStr();        QApplication::postEvent(targetWidget, event);
        QImage newImage = transact->apply(oldImage);
        delete transact;
        mutex.lock();
        currentImage = newImage;        mutex.unlock();    }    QApplication::postEvent(targetWidget,                            new QCustomEvent(AllTransactionsDone));}
Therun() function goes through the transaction queue and executes each
transaction in turn (by calling apply() on them). All accesses to the transac-
tions andcurrentImage member variables are protected with a mutex.
When a transaction is started, we post a TransactionStart event to the target
widget (the ImageWindow ). When all the transactions have ﬁnished processing,
we post an AllTransactionsDone event.
class Transaction
{public:    virtual QImage apply(const QImage &image) = 0;    virtual QString messageStr() = 0;};
TheTransaction class is an abstract base class for operations that the user can
perform on an image. It has three concrete subclasses: FlipTransaction ,Re-
sizeTransaction ,andConvertDepthTransaction .Wewill only review FlipTrans-
action ;the other two classes are similar.
class FlipTransaction : public Transaction
{public:
Communicating with the GUI Thread 363
    FlipTransaction(Qt::Orientation orient);
    QImage apply(const QImage &image);
    QString messageStr();
private:
    Qt::Orientation orientation;};
TheFlipTransaction constructor takes one parameter that speciﬁes the
orientation of the ﬂip ( Horizontal orVertical ).
QImage FlipTransaction::apply(const QImage &image)
{    return image.mirror(orientation == Qt::Horizontal,                        orientation == Qt::Vertical);}
Theapply() function calls QImage::mirror() on the QImage it receives as
parameter and returns the resulting QImage .
QString FlipTransaction::messageStr()
{    if (orientation == Qt::Horizontal)        return QObject::tr("Flipping image horizontally...");    else        return QObject::tr("Flipping image vertically...");}
ThemessageStr() returns the message to display in the status bar while the
operation is in progress. This function is called in ImageWindow::customEvent() ,
in the GUI thread.
Forlong-running operations, it might be desirable to report ﬁne-grained
progress. We can achieve this by creating an additional custom event andposting it when a certain percentage of the processing is completed.
Using Qt’s Classes in Non-GUI Threads
Afunction is said to be thread-safe when it can safely be called from different
threads simultaneously. If two thread-safe functions are called from differentthreads on the same shared data, the result is always deﬁned. By extension,aclass is said to be thread-safe when all of its functions can be called from
different threads simultaneously without interfering with each other, evenwhen operating on the same object.
Qt’s thread-safe classes are
QThread ,QMutex ,QMutexLocker ,QSemaphore ,QThread-
Storage<T> ,andQWaitCondition .Inaddition, the following functions are
thread-safe: QApplication::postEvent() ,QApplication::removePostedEvent() ,
QApplication::removePostedEvents() ,andQEventLoop::wakeUp() .
Most of Qt’s non-GUI classes meet a less stringent requirement: They are
reentrant .Aclass is reentrant if different instances of the class can be used
simultaneously in different threads. However, accessing the same reentrant
364 17. Multithreading
object in multiple threads simultaneously is not safe,and such accesses should
be protected with a mutex. Reentrant classesare marked as such in the Qt ref-erence documentation. Typically, any C ++class that doesn’t reference global
or otherwise shared data is reentrant.
QObject is reentrant, but none of Qt’s QObject subclasses are reentrant. One
consequence of this is that we cannot directly call functions on a widgetfrom a non-GUI thread. If we want to, say, change the text of a
QLabel from a
non-GUI thread, we must post a custom event to the GUI thread, asking it tochange the text for us.
Deleting a
QObject withdelete is not reentrant. To delete a QObject from a
non-GUI thread, we can call QObject::deleteLater() ,which posts a “deferred
delete” event.
QObject ’ssignals and slots mechanism can be used in any thread. When a
signal is emitted in one thread, the slots that are connected to it are calledimmediately, and the execution takes place in the same thread—not in thethread where the receiver object was created. This means that we can’t usesignals and slots to communicate with the GUI thread from other threads.
The
QTimer class and the networking classes QFtp,QHttp ,QSocket ,andQSock-
etNotifier all depend on the event loop, so we cannot use them in non-GUI
threads. The only networking class available is QSocketDevice ,the low-lev-
el wrapper for the platform-speciﬁc networking APIs. A common techniqueis to use a synchronous
QSocketDevice in a non-GUI thread. Some program-
mers ﬁnd that it leads to simpler code than using QSocket (which works
asynchronously), and by working in a non-GUI thread, they don’t block theevent loop.
Qt’s SQL and OpenGL modules can also be used in multithreaded applica-
tions, but have their own restrictions, which vary from system to system. Fordetails, see
http://doc.trolltech.com/3.2/sql-driver.html as well as the Qt
Quarterly article “Glimpsing the Third Dimension”, available online at http:
//doc.trolltech.com/qq/qq06-glimpsing.html .
Many of Qt’s non-GUI classes, including QImage ,QString ,and the container
classes, use implicit or explicit sharing as an optimization technique. Theseclasses are reentrant except for their copy constructors and assignment oper-ators. When a copy of an instance of these classes is taken, only a pointer tothe internal data is copied. This is dangerous if multiple threads attempt tomodify the data simultaneously. In such cases, a solution is to use the
QDeep-
Copy<T> class when performing an assignment to an instance of an implicitly
or explicitly shared class. For example:
QString password;
QMutex mutex;
void setPassword(const QString &str)
{    mutex.lock();    password = QDeepCopy<QString>(str);
Using Qt’s Classes in Non-GUI Threads 365
    mutex.unlock();
}
Qt 4 will probably provide enhanced threading support. Among other things,
it is expected that the signal–slot mechanism will be extended to support con-nections across threads, eliminating the need to use custom events for com-municating with the GUI thread. It is also expected that non-GUI classes like
QSocket andQTimer will be available in non-GUI threads,and that QDeepCopy<T>
will no longer be necessary when copying instances of implicitly and explicitlyshared classes across threads.

1818
Platform-Speciﬁc Features•Interfacing with Native APIs
•Using ActiveX
•Session Management
In this chapter, we will look at some of the platform-speciﬁc options available
to Qt programmers. We begin by looking at how to access native APIs such asthe Win32 API on Windows, Core Graphics on Mac OS X, and Xlib on X11. Wethen move on to explore Qt’s ActiveQt extension, showing how to use ActiveXcontrols within Qt/Windows applications and how to create applications thatact as ActiveX servers. And in the last section, we explain how to make Qtapplications cooperate with the session manager under X11.
In addition to the features presented here, the Enterprise Edition of Qt in-
cludes the Qt/Motif extension to ease the migration of Motif and Xt applica-tions to Qt. A similar extension for Tcl/Tk applicationsis provided by froglogic,and a Microsoft Windows resource converter is available from KlarälvdalensDatakonsult. And for embedded development, Trolltech provides the Qtopiaapplication framework. See the following web pages for details:
•
http://doc.trolltech.com/3.2/motif-extension.html
•http://www.froglogic.com/tq/
•http://www.klaralvdalens-datakonsult.se/?page=products&sub=knut
•http://www.trolltech.com/products/qtopia/
Interfacing with Native APIs
Qt provides a comprehensive API that caters for most needs on all platforms.
But in some circumstances, we may want to use the underlying, platform-speciﬁc APIs. In this section, we will show how to use the native APIs for thedifferent platforms supported by Qt to accomplish particular tasks.
On every platform,
QWidget provides a winId() function that returns the win-
dow ID (the HWND on Windows). QWidget also provides a static function called
find() that returns the QWidget with a particular window ID. We can pass
367
368 18. Platform-Speciﬁc Features
this ID to native API functions to achieve platform-speciﬁc effects. For ex-
ample, the following code uses winId() to make a QLabel semi-transparent on
Mac OS X using native Core Graphics functions:#
#include <qapplication.h>
#include <qlabel.h>#include <qt_mac.h>
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    QLabel *label = new QLabel("Hello Qt!", 0);    app.setMainWidget(label);
    CGSWindowRef winRef =
        GetNativeWindowFromWindowRef((WindowRef)label->winId());    CGSSetWindowAlpha(_CGSDefaultConnection(), winRef, 0.5);
    label->show();
    return app.exec();}
Here’s how to achieve the same effect on Windows, using the Win32 API:
#define _WIN32_WINNT 0x0501
#include <qapplication.h>
#include <qt_windows.h>
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    QLabel *label = new QLabel("Hello Qt!", 0);    app.setMainWidget(label);
    int exstyle = GetWindowLong(label->winId(), GWL_EXSTYLE);
    exstyle |= WS_EX_LAYERED;    SetWindowLong(label->winId(), GWL_EXSTYLE, exstyle);    SetLayeredWindowAttributes(label->winId(), 0, 128,                               LWA_ALPHA);
    label->show();
    return app.exec();}
This code assumes that the platform is Windows 2000 or XP. If we wanted the
application to compile and run on older versionsof Windowsthat don’t supportsemi-transparency, we could use
QLibrary to resolve the SetLayeredWindowAt-
tributes symbol at run-time instead of at link-time:
    typedef BOOL (__stdcall *PSetLayeredWindowAttributes)
            (HWND, COLORREF, BYTE, DWORD);    PSetLayeredWindowAttributes pSetLayeredWindowAttributes =            (PSetLayeredWindowAttributes) QLibrary::resolve("user32",                    "SetLayeredWindowAttributes");
#Qt 3.3 will probably provide a function to achieve this without resorting to native API calls.
Interfacing with Native APIs 369
    if (pSetLayeredWindowAttributes) {
        int exstyle = GetWindowLong(label->winId(), GWL_EXSTYLE);        exstyle |= WS_EX_LAYERED;        SetWindowLong(label->winId(), GWL_EXSTYLE, exstyle);        pSetLayeredWindowAttributes(label->winId(), 0, 128,                                    LWA_ALPHA);    }
Qt/Windows uses this technique internally to ensure that Qt applications
take advantage of advanced features such as native Unicode support and fonttransformations where they are available, while still being able to run on oldWindows versions.
On X11, there is no standard way to achieve transparency. However, here’s
how we would modify an X11 window property:
    Atom atom = XInternAtom(win->x11Display(), "MY_PROPERTY", False);
    long data = 1;    XChangeProperty(win->x11Display(), win->winId(), atom, atom,                    32, PropModeReplace, (unsigned char *)&data, 1);
Qt/Embedded differs from the other Qt versions in that it is implemented di-
rectly on top of the Linux frame buffer, with no native API in between. It alsoprovides its own window system,QWS,which can be conﬁgured by subclassingQt/Embedded-speciﬁc classes like
QWSDecoration andQWSInputMethod .Another
difference of Qt/Embedded is that its size can be reduced by compiling outunused classes and features. For more information about Qt/Embedded, see
http://www.trolltech.com/products/embedded/ andhttp://doc.trolltech.com/
3.2/winsystem.html .
If we want to use platform-speciﬁc code in an otherwise portable Qt applica-
tion, we can surround the native code with #ifand#endif .For example:
#if defined(Q_WS_MAC)
    CGSWindowRef winRef =        GetNativeWindowFromWindowRef((WindowRef)label->winId());    CGSSetWindowAlpha(_CGSDefaultConnection(), winRef, 0.5);#endif
Qt deﬁnes one of the following four window system symbols: Q_WS_WIN ,Q_WS_
X11,Q_WS_MAC ,andQ_WS_QWS .Wemust make sure to include at least one Qt
header before we use them in applications. Qt also provides preprocessorsymbols to identify the operating system:
•
Q_OS_WIN32
•Q_OS_WIN64
•Q_OS_CYGWIN
•Q_OS_MAC
•Q_OS_AIX
•Q_OS_BSDI•Q_OS_DGUX
•Q_OS_DYNIX
•Q_OS_FREEBSD
•Q_OS_HPUX
•Q_OS_HURD
•Q_OS_IRIX•Q_OS_LINUX
•Q_OS_LYNX
•Q_OS_NETBSD
•Q_OS_OPENBSD
•Q_OS_OSF
•Q_OS_QNX•Q_OS_QNX6
•Q_OS_RELIANT
•Q_OS_SCO
•Q_OS_SOLARIS
•Q_OS_ULTRIX
•Q_OS_UNIXWARE
Wecan assume that at most one of these will be deﬁned. For convenience, Qt
deﬁnesQ_OS_WIN when either Win32 or Win64 is detected, and Q_OS_UNIX when
370 18. Platform-Speciﬁc Features
any Unix-based operating system (including Mac OS X) is detected. At run-
time, we can call QApplication::winVersion() orQApplication::macVersion() to
distinguish between different versions of Windows (95, 98, etc.) or Mac OS X(10.0, 10.1, etc.).
Several of Qt’s GUI-related classes provide a platform-speciﬁc
handle()
function that returns a low-level handle to the object. Figure 18.1 lists the
return type of handle() on different platforms.
Windows X11 Mac OS X Embedded
QCursor HCURSOR Cursor int int
QFont HFONT Font FMFontFamily FontID
QPaintDevice HDC Drawable GWorldPtr N/A
QPainter HDC Drawable GWorldPtr N/A
QRegion HRGN Region RgnHandle void *
QSessionManager N/A SmcConn N/A N/A
Figure 18.1. Platform-speciﬁc handle types
TheQWidget ,QPixmap ,QPrinter ,andQPicture classes all inherit from QPaint-
Device .O n X11 and Mac OS X, handle() means the same thing as winId() on
aQWidget .OnWindows, handle() returns the device context, whereas winId()
returns the window handle. Similarly, QPixmap provides a hbm() function that
returns a bitmap handle ( HBITMAP )onWindows.
On X11, QPaintDevice provides many functions that return various pointers or
handles, including x11Display() andx11Screen() .Wecan use these to set up
an X11 graphics context on a QWidget orQPixmap ,for example.
Qt applications that need to interface with other toolkits or libraries frequent-
ly need to access the low-level events ( XEvent sonX11,MSGsonWindows and
Mac OS X, QWSEvent sonQt/Embedded) before they are converted into QEvent s.
Wecan do this by subclassing QApplication and reimplementing the relevant
platform-speciﬁc event ﬁlter, one of winEventFilter() ,x11EventFilter() ,mac-
EventFilter() ,andqwsEventFilter() .
Wecan access the platform-speciﬁc events that are sent to a given QWidget
by reimplementing one of winEvent() ,x11Event() ,macEvent() ,andqwsEvent() .
This can be useful for handling certain types of events that Qt normallyignores, such as joystick events.
Formore information about platform-speciﬁc issues, including how to get
started with Qt/Embedded and how to deploy Qt applications on differentplatforms, see
http://doc.trolltech.com/3.2/winsystem.html .
Using ActiveX 371
Using ActiveX
Microsoft’s ActiveX technology allows applications to incorporate user inter-
face components provided by other applications or libraries. It is built on Mi-crosoft COM and deﬁnes one set of interfaces for applications that use compo-nents and another set of interfaces for applications and libraries that providecomponents.
Qt/WindowsEnterprise Edition providesthe ActiveQt framework to seamless-
ly combine ActiveX and Qt. ActiveQt consists of two modules:
•The QAxContainer module allows us to use COM objects and to embed
ActiveX controls in Qt applications.
•The QAxServer module allows us to export custom COM objects and
ActiveX controls written using Qt.
Our ﬁrst example will embed the Windows Media Player in a Qt application
using QAxContainer .The Qt application adds an
Open button, a Play/Pause
button, a Stop button, and a slider to the Windows Media Player ActiveX
control.
Figure 18.2. The Media Player application
The application’s main window is of type PlayerWindow :
class PlayerWindow : public QWidget
{    Q_OBJECT    Q_ENUMS(ReadyStateConstants)public:    enum PlayStateConstants { Stopped = 0, Paused = 1, Playing = 2 };    enum ReadyStateConstants { Uninitialized = 0, Loading = 1,                               Interactive = 3, Complete = 4 };
    PlayerWindow(QWidget *parent = 0, const char *name = 0);protected:
    void timerEvent(QTimerEvent *event);
372 18. Platform-Speciﬁc Features
private slots:
    void onPlayStateChange(int oldState, int newState);    void onReadyStateChange(ReadyStateConstants readyState);    void onPositionChange(double oldPos, double newPos);    void sliderValueChanged(int newValue);    void openFile();
ThePlayerWindow class inherits from QWidget .TheQ_ENUMS() macro is necessary
to tellmocthat the ReadyStateConstants type used in the onReadyStateChange()
slot is an enum type.
private:
    QAxWidget *wmp;    QToolButton *openButton;    QToolButton *playPauseButton;    QToolButton *stopButton;    QSlider *seekSlider;    QString fileFilters;    int updateTimer;};
In the private section, we declare a QAxWidget * data member.
PlayerWindow::PlayerWindow(QWidget *parent, const char *name)    : QWidget(parent, name){
···
    wmp = new QAxWidget(this);
    wmp->setControl("{22D6F312-B0F6-11D0-94AB-0080C74C7E95}");
In the constructor, we create a QAxWidget object to encapsulate the Windows
Media Player ActiveX control. The QAxContainer module consists of three
classes: QAxObject encapsulates a COM object, QAxWidget encapsulates an
ActiveX control, and QAxBase implements the core COM functionality for
QAxObject andQAxWidget .
QObject QAxBase QWidget
QAxObject QAxWidget
Figure 18.3. Inheritance tree for the QAxContainer module
WecallsetControl() on theQAxWidget with the class ID of the Windows Me-
dia Player 6.4 control. This will create an instance of the required compo-nent. From then on, all the properties, events, and methods of the ActiveXcontrol are available as Qt properties, signals, and slots through the
QAxWidget
object.
The COM data types are automatically converted into the corresponding Qt
types, as summarized in Figure 18.4. For example, an in-parameter of type
VARIANT_BOOL becomes a bool,and an out-parameter of type VARIANT_BOOL
Using ActiveX 373
becomes a bool& .Ifthe resulting type is a Qt class ( QString ,QDateTime ,etc.),the
in-parameter is a const reference (for example, const QString & ).
COM types Qt type
VARIANT_BOOL bool
char ,short ,int,long int
unsigned char ,unsigned short ,
unsigned int ,unsigned longuint
float ,double double
CY Q_LLONG
BSTR QString
DATE QDateTime
OLE_COLOR QColor
SAFEARRAY(VARIANT) QValueList<QVariant>
SAFEARRAY(BYTE) QByteArray
VARIANT QVariant
IFontDisp * QFont
IPictureDisp * QPixmap
Figure 18.4. Relationship between COM types and Qt types
Toobtain the list of all the properties, signals, and slots available in a QAxOb-
ject orQAxWidget with their Qt data types, call generateDocumentation() or use
Qt’sdumpdoc command-line tool, located in Qt’s extensions\activeqt\example
directory.
    wmp->setProperty("ShowControls", QVariant(false, 0));
    wmp->setSizePolicy(QSizePolicy::Expanding,                       QSizePolicy::Expanding);    connect(wmp, SIGNAL(PlayStateChange(int, int)),            this, SLOT(onPlayStateChange(int, int)));    connect(wmp, SIGNAL(ReadyStateChange(ReadyStateConstants)),            this, SLOT(onReadyStateChange(ReadyStateConstants)));    connect(wmp, SIGNAL(PositionChange(double, double)),            this, SLOT(onPositionChange(double, double)));
After calling setControl() in thePlayerWindow constructor, we call setProper-
ty() to set the ShowControls property of the Windows Media Player to false ,
since we provide our own buttons to manipulate the component. The setProp-
erty() function is deﬁned in QObject and can be used both for COM properties
and for normal Qt properties. Its second parameter is of type QVariant .B e -
cause some C ++compilers don’t support the bool type properly yet, the QVari-
antconstructor that takes a bool also has a dummy intparameter. For types
other than bool,the conversion to QVariant is automatic.
374 18. Platform-Speciﬁc Features
Next, we call setSizePolicy() to make the ActiveX control take all the avail-
able space in the layout, and we connect three ActiveX events from the COMcomponent to three slots.
The rest of the
PlayerWindow constructor follows the usual pattern, except
that we connect some Qt signals to slots provided by the COM object ( Play() ,
Pause() ,andStop() ).
Let’s leave the constructor and look at the timerEvent() function:
void PlayerWindow::timerEvent(QTimerEvent *event)
{    if (event->timerId() == updateTimer) {        double curPos = wmp->property("CurrentPosition").toDouble();        onPositionChange(-1, curPos);    } else {        QWidget::timerEvent(event);    }}
ThetimerEvent() function is called at regular intervals while a media clip is
playing. We use it to advance the slider. This is done by calling property()
on the ActiveX control to obtain the value of the CurrentPosition property
as aQVariant and calling toDouble() to convert it to a double .Wethen call
onPositionChange() to perform the update.
Wewill not review the rest of the code because most of it isn’t directly relevant
to ActiveX and doesn’t show anything that we haven’t covered already. Thecode is included on the CD.
In the
.pro ﬁle, we need this entry to link with the QAxContainer module:
LIBS         += -lqaxcontainer
One frequent need when dealing with COM objects is to be able to call a COM
method directly (as opposed to connecting it to a Qt signal). The easiest wayto do this is to call
dynamicCall() with the name and signature of the method
as ﬁrst parameter and the arguments to the method as additional parameters.Forexample:
wmp->dynamicCall("TitlePlay(uint)", 6);
ThedynamicCall() function takes up to eight parameters of type QVariant and
returns a QVariant .Ifweneed to pass an IDispatch * or anIUnknown * this way,
we can encapsulate the component in a QAxObject and call asVariant() on it
to convert it to a QVariant .Ifweneed to call a COM method that returns an
IDispatch * or anIUnknown * ,orifweneed to access a COM property of one of
those types, we must use querySubObject() instead:
QAxObject *session = outlook.querySubObject("Session");
QAxObject *defaultContacts =        session->querySubObject("GetDefaultFolder(OlDefaultFolders)",                                "olFolderContacts");
Using ActiveX 375
If we want to call functions that have unsupported data types in their param-
eter list, we can use QAxBase::queryInterface() to retrieve the COM interface
and call the function directly. We must call Release() when we have ﬁnished
using the interface.
If we often need to call such functions, we can subclass QAxObject orQAxWidget
and provide member functions that encapsulate the COM interface calls.
However, be aware that QAxObject andQAxWidget subclasses cannot deﬁne
their own properties, signals, and slots.
Wewill now review the QAxServer module. This module enables us to turn
astandard Qt program into an ActiveX server. The server can either be a
shared library or a stand-alone application. Servers built as shared librariesare often called in-process servers, and stand-alone applications are calledout-of-process servers.
Our ﬁrst QAxServer example is an in-process server that provides a widget
that shows a ball bouncing left and right. We will also see how to embed thewidget in Internet Explorer.
Figure 18.5. TheAxBouncer widget in Internet Explorer
Here’s the beginning of the class deﬁnition of the AxBouncer widget:
class AxBouncer : public QWidget, public QAxBindable
{    Q_OBJECT    Q_ENUMS(Speed)    Q_PROPERTY(QColor color READ color WRITE setColor)    Q_PROPERTY(Speed speed READ speed WRITE setSpeed)    Q_PROPERTY(int radius READ radius WRITE setRadius)    Q_PROPERTY(bool running READ isRunning)
376 18. Platform-Speciﬁc Features
AxBouncer inherits from both QWidget andQAxBindable .TheQAxBindable class
provides an interface between the widget and an ActiveX client. Any QWidget
can be exported as an ActiveX control, but by subclassing QAxBindable we can
notify the client when a property’s value changes, and we can implement COMinterfaces to supplement those already implemented by QAxServer .
When doing multiple inheritance involving a
QObject -derived class, we must
always put the QObject -derived class ﬁrst so that moccan pick it up.
Wedeclare three read-write properties and one read-only property. The Q_
ENUMS() macro is necessary to tell mocthat the Speed type is an enum type. The
Speed enum is declared in the public section of the class.
public:
    enum Speed { Slow, Normal, Fast };
    AxBouncer(QWidget *parent = 0, const char *name = 0);    void setSpeed(Speed newSpeed);
    Speed speed() const { return ballSpeed; }    void setRadius(int newRadius);    int radius() const { return ballRadius; }    void setColor(const QColor &newColor);    QColor color() const { return ballColor; }    bool isRunning() const { return myTimerId != 0; }    QSize sizeHint() const;    QAxAggregated *createAggregate();
public slots:
    void start();    void stop();
signals:
    void bouncing();
TheAxBouncer constructor is a standard constructor for a widget, with a parent
and aname parameter. The QAXFACTORY_DEFAULT() macro, which we will use to
export the component, expects a constructor with this signature.
ThecreateAggregate() function is reimplemented from QAxBindable .Wewill
explain it in a moment.
protected:
    void paintEvent(QPaintEvent *event);    void timerEvent(QTimerEvent *event);
private:
    int intervalInMilliseconds() const;
    QColor ballColor;
    Speed ballSpeed;    int ballRadius;    int myTimerId;    int x;    int delta;};
Using ActiveX 377
The protected and private sections of the class are the same as what we would
have in a standard Qt widget.
AxBouncer::AxBouncer(QWidget *parent, const char *name)
    : QWidget(parent, name, WNoAutoErase){    ballColor = blue;    ballSpeed = Normal;    ballRadius = 15;    myTimerId = 0;    x = 20;    delta = 2;}
TheAxBouncer constructor initializes the class’s private variables.
void AxBouncer::setColor(const QColor &newColor){    if (newColor != ballColor && requestPropertyChange("color")) {        ballColor = newColor;        update();        propertyChanged("color");    }}
ThesetColor() function sets the value of the color property. It calls update()
to repaint the widget.
The unusual part is the requestPropertyChange() andpropertyChanged() calls.
These functions are inherited from QAxBindable and should ideally be called
whenever we change a property. The requestPropertyChange() asks the client’s
permission to change a property, and returns true if the client allows the
change. The propertyChanged() function notiﬁes the client that the property
has been changed.
ThesetSpeed() andsetRadius() property setters also follow this pattern,
and so do the start() andstop() slots, since they change the value of the
running property.
There is one interesting AxBouncer member function left:
QAxAggregated *AxBouncer::createAggregate()
{    return new ObjectSafetyImpl;}
ThecreateAggregate() function is reimplemented from QAxBindable .Itallows
us to implement COM interfaces that the QAxServer module doesn’t already
implement or to bypass QAxServer ’sdefault COM interfaces. Here, we do it
to provide the IObjectSafety interface, which is used by Internet Explorer to
access a component’s safety options. This is the standard trick to get rid ofInternet Explorer’s infamous “Object not safe for scripting” error message.
Here’s the deﬁnition of the class that implements the
IObjectSafety in-
terface:
378 18. Platform-Speciﬁc Features
class ObjectSafetyImpl : public QAxAggregated, public IObjectSafety
{public:    long queryInterface(const QUuid &iid, void **iface);
    QAXAGG_IUNKNOWN    HRESULT WINAPI GetInterfaceSafetyOptions(REFIID riid,
            DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);    HRESULT WINAPI SetInterfaceSafetyOptions(REFIID riid,            DWORD pdwSupportedOptions, DWORD pdwEnabledOptions);};
TheObjectSafetyImpl class inherits both QAxAggregated andIObjectSafety .The
QAxAggregated class is an abstract base class for implementations of additional
COM interfaces. The COM object that the QAxAggregated extends is accessible
through controllingUnknown() .This COM object is created behind the scenes
by the QAxServer module.
TheQAXAGG_IUNKNOWN macro provides standard implementationsof QueryInter-
face() ,AddRef() ,andRelease() .These implementations simply call the same
functions on the controlling COM object.
long ObjectSafetyImpl::queryInterface(const QUuid &iid, void **iface)
{    *iface = 0;    if (iid == IID_IObjectSafety)        *iface = (IObjectSafety *)this;    else        return E_NOINTERFACE;
    AddRef();
    return S_OK;}
ThequeryInterface() function is a pure virtual function of QAxAggregated .I ti s
called by the controlling COM object to give access to the interfaces providedby the
QAxAggregated subclass. We must return E_NOINTERFACE for interfaces
that we don’t implement and for IUnknown .
HRESULT WINAPI ObjectSafetyImpl::GetInterfaceSafetyOptions(
            REFIID riid, DWORD *pdwSupportedOptions,            DWORD *pdwEnabledOptions){    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA                           | INTERFACESAFE_FOR_UNTRUSTED_CALLER;    *pdwEnabledOptions = *pdwSupportedOptions;    return S_OK;}
HRESULT WINAPI ObjectSafetyImpl::SetInterfaceSafetyOptions(REFIID,
            DWORD, DWORD){    return S_OK;}
Using ActiveX 379
TheGetInterfaceSafetyOptions() andSetInterfaceSafetyOptions() functions
are declared in IObjectSafety .Weimplement them to tell the world that our
object is safe for scripting.
Let’s now review main.cpp :
#include <qaxfactory.h>
#include "axbouncer.h"QAXFACTORY_DEFAULT(AxBouncer,
                   "{5e2461aa-a3e8-4f7a-8b04-307459a4c08c}",                   "{533af11f-4899-43de-8b7f-2ddf588d1015}",                   "{772c14a5-a840-4023-b79d-19549ece0cd9}",                   "{dbce1e56-70dd-4f74-85e0-95c65d86254d}",                   "{3f3db5e0-78ff-4e35-8a5d-3d3b96c83e09}")
int main()
{    return 0;}
TheQAXFACTORY_DEFAULT() macro exports an ActiveX control. We can use it for
ActiveX servers that export only one control. Otherwise, we must subclass
QAxFactory and use a macro called QAXFACTORY_EXPORT() .The next example in
this section shows how to do it.
The ﬁrst argument to QAXFACTORY_DEFAULT() is the name of the Qt class to
export. This is also the name under which the control is exported. The otherﬁve arguments are the class ID, the interface ID, the event interface ID, thetype library ID, and the application ID. We can use standard tools like
guidgen
oruuidgen to generate these identiﬁers.
Because the server is a library, we don’t need a real main() function. We must
still provide a fake implementation to pacify the linker.
Here’s the .pro ﬁle for our in-process ActiveX server:
TEMPLATE      = lib
CONFIG       += activeqt dllHEADERS       = axbouncer.h \                objectsafetyimpl.hSOURCES       = axbouncer.cpp \                main.cpp \                objectsafetyimpl.cppRC_FILE       = qaxserver.rcDEF_FILE      = qaxserver.def
Theqaxserver.rc andqaxserver.def ﬁles referred to in the .pro ﬁle are stan-
dard ﬁles that can be copied from Qt’s extensions\activeqt\control directory.
The makeﬁle or Visual C ++project ﬁle generated by qmake contains rules to
register the server in the Windows registry. To register the server on end usermachines, we can use the
regsvr32 tool available on all Windows systems.
380 18. Platform-Speciﬁc Features
Wecan then include the Bouncer component in an HTML page using the
<object> tag:
<object id="AxBouncer"
        classid="clsid:5e2461aa-a3e8-4f7a-8b04-307459a4c08c"><b>The ActiveX control is not available. Make sure you have built andregistered the component server.</b></object>
Wecan create buttons that invoke slots:
<input type="button" value="Start" onClick="AxBouncer.start()">
<input type="button" value="Stop" onClick="AxBouncer.stop()">
And we can manipulate the widget using JavaScript or VBScript just like any
other ActiveX control. See the demo.html ﬁle on the CD for a rudimentary page
that uses the ActiveX server.
Our last example is a scriptable Address Book application. The application
can serve as a standard Qt/Windows application or an out-of-process ActiveXserver. The latter possibility allows us to script the application using, say,Visual Basic.
class AddressBook : public QMainWindow
{    Q_OBJECT    Q_PROPERTY(int count READ count)public:    AddressBook(QWidget *parent = 0, const char *name = 0);    ~AddressBook();
    int count() const;public slots:
    ABItem *createEntry(const QString &contact);    ABItem *findEntry(const QString &contact) const;    ABItem *entryAt(int index) const;
···
};
TheAddressBook widget is the application’s main window. The property and
the slots it provides will be available for scripting.
class ABItem : public QObject, public QListViewItem
{    Q_OBJECT    Q_PROPERTY(QString contact READ contact WRITE setContact)    Q_PROPERTY(QString address READ address WRITE setAddress)    Q_PROPERTY(QString phoneNumber READ phoneNumber               WRITE setPhoneNumber)public:    ABItem(QListView *listView);
    void setContact(const QString &contact);
    QString contact() const { return text(0); }    void setAddress(const QString &address);    QString address() const { return text(1); }
Using ActiveX 381
    void setPhoneNumber(const QString &number);
    QString phoneNumber() const { return text(2); }
public slots:
    void remove();};
TheABItem class represents one entry in the address book. It inherits from
QListViewItem so that it can be shown in a QListView and from QObject so that
it can be exported as a COM object.
int main(int argc, char *argv[])
{    QApplication app(argc, argv);    if (!QAxFactory::isServer()) {        AddressBook addressBook;        app.setMainWidget(&addressBook);        addressBook.show();        return app.exec();    }    return app.exec();}
Inmain() ,wecheck whether the application is being run stand-alone or as
aserver. The -activex command-line option makes it run as a server. If the
application isn’t run as a server, we create the main widget and show it as wewould normally do in any stand-alone Qt application.
In addition to
-activex ,ActiveX servers understand the following command-
line options:
•-regserver registers the server in the system registry.
•-unregserver unregisters the server from the system registry.
•-dumpidl file writes the server’s IDL to the speciﬁed ﬁle.
Forthe case where the application is run as a server, we need to export the
AddressBook andABItem classes as COM components:
QAXFACTORY_EXPORT(ABFactory,
                  "{2b2b6f3e-86cf-4c49-9df5-80483b47f17b}",                  "{8e827b25-148b-4307-ba7d-23f275244818}")
TheQAXFACTORY_EXPORT() macro exports a factory for creating COM objects.
Since we want to export two types of COM objects, we cannot simply use
QAXFACTORY_DEFAULT() as we did in the previous example.
The ﬁrst argument to QAXFACTORY_EXPORT() is the name of the QAxFactory class
that provides the application’s COM objects. The other two arguments are thetype library ID and the application ID.
class ABFactory : public QAxFactory
{public:    ABFactory(const QUuid &lib, const QUuid &app);    QStringList featureList() const;
382 18. Platform-Speciﬁc Features
    QWidget *create(const QString &key, QWidget *parent,
                    const char *name);    QUuid classID(const QString &key) const;    QUuid interfaceID(const QString &key) const;    QUuid eventsID(const QString &key) const;    QString exposeToSuperClass(const QString &key) const;};
TheABFactory class inherits QAxFactory and reimplements virtual functions
to export the AddressBook class as an ActiveX control and the ABItem class as a
COM component.
ABFactory::ABFactory(const QUuid &lib, const QUuid &app)
    : QAxFactory(lib, app){}
TheABFactory constructor simply forwards its two parameters to the base
class constructor.
QStringList ABFactory::featureList() const
{    return QStringList() << "AddressBook" << "ABItem";}
ThefeatureList() function returns a list of the COM components provided by
the factory.
QWidget *ABFactory::create(const QString &key, QWidget *parent,
                           const char *name){    if (key == "AddressBook")        return new AddressBook(parent, name);    else        return 0;}
Thecreate() function creates an instance of an ActiveX control. We return
anull pointer for ABItem because we don’t want users to create ABItem objects.
Furthermore, the return type of create() isQWidget * ,which prevents it from
returning COM objects that aren’t ActiveX controls.
QUuid ABFactory::classID(const QString &key) const
{    if (key == "AddressBook")        return QUuid("{588141ef-110d-4beb-95ab-ee6a478b576d}");    else if (key == "ABItem")        return QUuid("{bc82730e-5f39-4e5c-96be-461c2cd0d282}");    else        return QUuid();}
TheclassId() function returns the class ID for all the classes exported by
the factory.
Using ActiveX 383
QUuid ABFactory::interfaceID(const QString &key) const
{    if (key == "AddressBook")        return QUuid("{718780ec-b30c-4d88-83b3-79b3d9e78502}");    else if (key == "ABItem")        return QUuid("{c8bc1656-870e-48a9-9937-fbe1ceff8b2e}");    else        return QUuid();}
TheinterfaceId() function returns the interface ID for the classes exported
by the factory.
QUuid ABFactory::eventsID(const QString &key) const
{    if (key == "AddressBook")        return QUuid("{0a06546f-9f02-4f14-a269-d6d56ffeb861}");    else if (key == "ABItem")        return QUuid("{105c6b0a-3fc7-460b-ae59-746d9d4b1724}");    else        return QUuid();}
TheeventsId() function returns the event interface ID for the classes exported
by the factory.
QString ABFactory::exposeToSuperClass(const QString &key) const
{    return key;}
By default, ActiveX controls expose not only their own properties, signals,
and slots to clients, but also those of their superclasses up to QWidget .W e
can reimplement the exposeToSuperClass() function to return the highest
superclass (in the inheritance tree) that we want to expose.
Here, we return the class name of the component (“AddressBook” or “ABItem”)
as the highest superclass to export, meaning that properties, signals, and slotsdeﬁned in
AddressBook ’sandABItem ’ssuperclasses will not be exported.
This is the .pro ﬁle for our out-of-process ActiveX server:
CONFIG       += activeqt
HEADERS       = abfactory.h \
                abitem.h \                addressbook.h \                editdialog.hSOURCES       = abfactory.cpp \                abitem.cpp \                addressbook.cpp \                editdialog.cpp \                main.cppRC_FILE       = qaxserver.rc
Theqaxserver.rc ﬁle referred to in the .pro ﬁle is a standard ﬁle that can be
copied from Qt’s extensions\activeqt\control directory.
384 18. Platform-Speciﬁc Features
Look in the example’s vbdirectory for a Visual Basic project that uses the
Address Book server.
This completes our overview of the ActiveQt framework. The Qt distribution
includes additional examples, and the documentation contains informationabout how to build the QAxContainer and QAxServer modules and how to
solve common interoperability issues.
Session Management
When we log out on X11, some window managers ask us whether we want tosave the session. If we say yes, the applications that were running are au-tomatically restarted the next time we log in, with the same screen positionsand, ideally, with the same state as they had when we logged out.
The X11-speciﬁc component that takes care of saving and restoring the
session is called the session manager .Tomake a Qt application aware of the
session manager, we must reimplement
QApplication::saveState() and save
the application’s state there.
Figure 18.6. Logging out on KDE
Windows 2000 and XP (and some Unix systems) offer a different mechanism,
called hibernation. When the user puts the computer into hibernation, theoperating system simply dumps the computer’s memory onto disk and reloadsit on startup. Applications do not need to do anything or even be aware thatthis happens.
When the user initiates a shutdown, we can take control just before the
shutdown occurs by reimplementing
QApplication::commitData() .This allows
us to save any unsaved data and to interact with the user if required. Thisworks the same way on both X11 and Windows.
Wewill explore session management by going through the code of a session-
aware Tic-Tac-Toe application. First, let’s look at the
main() function:
int main(int argc, char *argv[])
{    Application app(argc, argv);    TicTacToe tic(0, "tic");    app.setTicTacToe(&tic);    tic.show();    return app.exec();}
Session Management 385
Wecreate an Application object. The Application class inherits from QAppli-
cation and reimplementsboth commitData() andsaveState() to support session
management.
Next, we create a TicTacToe widget, make the Application object aware of it,
and show it. We have called the TicTacToe widget “tic”. We must give unique
names to top-level widgets if we want the session manager to restore thewindows’ sizes and positions.
Figure 18.7. The Tic-Tac-Toe application
Here’s the deﬁnition of the Application class:
class Application : public QApplication
{    Q_OBJECTpublic:    Application(int &argc, char *argv[]);
    void setTicTacToe(TicTacToe *tic);
    void commitData(QSessionManager &sessionManager);    void saveState(QSessionManager &sessionManager);
private:
    TicTacToe *ticTacToe;};
TheApplication class keeps a pointer to the TicTacToe widget as a private
variable.
void Application::saveState(QSessionManager &sessionManager)
{    QString fileName = ticTacToe->saveState();
    QStringList discardCommand;
    discardCommand << "rm" << fileName;    sessionManager.setDiscardCommand(discardCommand);}
386 18. Platform-Speciﬁc Features
On X11, the saveState() function is called when the session manager wants
the application to save its state. The function is available on other platformsas well, but it is never called. The
QSessionManager parameter allows us to
communicate with the session manager.
Westart by asking the TicTacToe widget to save its state to a ﬁle. Then we set
the session manager’s discard command. A discard command is a command
that the session manager must execute to delete any stored informationregarding the current state. For this example, we set it to
rm file
where file is the name of the ﬁle that contains the saved state for the session,
andrmis the standard Unix command to remove ﬁles.
The session manager also has a restart command .This is the command that
the session manager must execute to restart the application. By default, Qtprovides the following restart command:
appname -session id_key
The ﬁrst part, appname ,isderived from argv[0] .The idpart is the session ID
provided by the session manager; it is guaranteed to be unique among dif-ferent applications and among different runs of the same application. The
keypart comes in addition to uniquely identify the time at which the state
wassaved. For various reasons, the session manager can call saveState()
multiple times during the same session, and the different states must be dis-
tinguished.
Because of limitations in existing session managers, we need to make sure
that the application’s directory is in the PATH environment variable if we want
the application to restart correctly. In particular, if you want to try out theTic-Tac-Toe example for yourself, you must install it in, say,
/usr/bin and
invoke it as tictactoe .
Forsimple applications, including Tic-Tac-Toe, we could save the state as an
additional command-line argument to the restart command. For example:
tictactoe -state OX-XO-X-O
This would save us from storing the data in a ﬁle and providing a discardcommand to remove the ﬁle.
void Application::commitData(QSessionManager &sessionManager)
{    if (ticTacToe->gameInProgress()            && sessionManager.allowsInteraction()) {        int ret = QMessageBox::warning(ticTacToe, tr("Tic-Tac-Toe"),                     tr("The game hasn’t finished.\n"                        "Do you really want to quit?"),                     QMessageBox::Yes | QMessageBox::Default,                     QMessageBox::No | QMessageBox::Escape);        if (ret == QMessageBox::Yes)            sessionManager.release();
Session Management 387
        else
            sessionManager.cancel();    }}
ThecommitData() function is called when the user logs out. We can reimple-
ment it to pop up a message box warning the user about potential data loss.The default implementation closes all top-level widgets, which results in thesame behavior as when the user closes the windows one after another by click-ing the
Xbutton in their title bars. In Chapter 3, we saw how to reimplement
closeEvent() to catch this and pop up a message box.
Forthe purposes of this example, we reimplement commitData() and pop up a
message box asking the user to conﬁrm the log out if a game is in progress andif the session manager allows us to interact with the user. If the user clicks
Yes,wecallrelease() to tell the session manager to continue logging out; if the
user clicks No,wecallcancel() to cancel the log out.
Figure 18.8. “Do you really want to quit?”
Now let’s look at the TicTacToe class:
class TicTacToe : public QWidget
{    Q_OBJECTpublic:    TicTacToe(QWidget *parent = 0, const char *name = 0);
    QSize sizeHint() const;
    bool gameInProgress() const;    QString saveState() const;
protected:
    void paintEvent(QPaintEvent *event);    void mousePressEvent(QMouseEvent *event);
private:
    enum { Empty = ’-’, Cross = ’X’, Nought = ’O’ };
    void clearBoard();
    void restoreState();    QString sessionFileName() const;    QRect cellRect(int row, int col) const;    int cellWidth() const { return width() / 3; }    int cellHeight() const { return height() / 3; }
    char board[3][3];
388 18. Platform-Speciﬁc Features
    int turnNumber;
};
TheTicTacToe class inherits from QWidget and reimplements sizeHint() ,
paintEvent() ,andmousePressEvent() .Italso provides the gameInProgress() and
saveState() functions that we used in Application .
TicTacToe::TicTacToe(QWidget *parent, const char *name)
    : QWidget(parent, name){    setCaption(tr("Tic-Tac-Toe"));    clearBoard();    if (qApp->isSessionRestored())        restoreState();}
In the constructor, we clear the board, and if the application was invoked with
the-session option, we call the private function restoreState() to reload the
old session.
void TicTacToe::clearBoard()
{    for (int row = 0; row < 3; ++row) {        for (int col = 0; col < 3; ++col) {            board[row][col] = Empty;        }    }    turnNumber = 0;}
InclearBoard() ,weclear all the cells and set turnNumber to 0.
QString TicTacToe::saveState() const
{    QFile file(sessionFileName());    if (file.open(IO_WriteOnly)) {        QTextStream out(&file);        for (int row = 0; row < 3; ++row) {            for (int col = 0; col < 3; ++col) {                out << board[row][col];            }        }    }    return file.name();}
InsaveState() ,wewrite the state of the board to disk. The format is straight-
forward, with ‘X’ for crosses, ‘O’ for noughts, and ‘ +--’for empty cells.
QString TicTacToe::sessionFileName() const
{    return QDir::homeDirPath() + "/.tictactoe_"           + qApp->sessionId() + "_" + qApp->sessionKey();}
Session Management 389
ThesessionFileName() private function returns the ﬁle name for the current
session ID and session key. This function is used for both saveState() and
restoreState() .The ﬁle name is derived from the session ID and session key.
void TicTacToe::restoreState()
{    QFile file(sessionFileName());    if (file.open(IO_ReadOnly)) {        QTextStream in(&file);        for (int row = 0; row < 3; ++row) {            for (int col = 0; col < 3; ++col) {                in >> board[row][col];                if (board[row][col] != Empty)                    ++turnNumber;            }        }    }    repaint();}
InrestoreState() ,weload the ﬁle that corresponds to the restored session and
ﬁll the board with that information. We deduce the value of turnNumber from
the number of X’sand O’son the board.
In theTicTacToe constructor, we called restoreState() ifQApplication::is-
SessionRestored() returned true.Inthat case, sessionId() andsessionKey()
return the same values as when the application’s state was saved, and so ses-
sionFileName() returns the ﬁle name for that session.
Testing and debugging session management can be frustrating, because we
need to log in and out all the time. One way to avoid this is to use the standard
xsmutility provided with X11. The ﬁrst time we invoke xsm,itpops up a session
manager window and a terminal. The applications we start from that termi-nal will all use
xsmas their session manager instead of the usual, system-wide
session manager. We can then use xsm’swindow to end, restart, or discard a
session, and see if our application behaves as it should. For details about howto do this, see
http://doc.trolltech.com/3.2/session.html .

Appendices

AA
Installing Qt•ANote on Licensing
•Installing Qt/Windows
•Installing Qt/Mac
•Installing Qt/X11
This appendix explains how to install Qt from the CD onto your system. The
CD has editions of Qt 3.2.1 for Windows, Mac OS X, and X11 (for Linux andmost versions of Unix). They all include SQLite, a public domain in-processdatabase, together with an experimental driver. The editions of Qt on the CDare provided for your convenience. For serious software development,it is bestto download the latest version of Qt from
http://www.trolltech.com/download/
or to buy a commercial version.
Trolltech also provides Qt/Embedded for building applications for Linux-
based embedded devices such as PDAs and mobile phones. If you are inter-ested in creating embedded applications, you can obtain Qt/Embedded fromTrolltech’s download web page.
The example applications used in the book are on the CD in the
examples di-
rectory. In addition, Qt provides many small example applications located inthe
examples ,tools\designer\examples ,andextensions\activeqt\examples sub-
directories.
ANote on Licensing
Qt is produced in three forms: free, non-commercial, and commercial. The
free and non-commercial editions are available free of charge; the commercialeditions must be paid for.
The software on the CD is suitable for creating applications for your own
educational and personal use.
If you want to distribute the applications that you create with a free or non-
commercial edition of Qt, you must comply with the speciﬁc terms and con-ditions laid down in the licenses for the software you use to create the appli-cations. For free editions, the terms and conditions include the requirement
393
394 A. Installing Qt
to use an open license—for example, the GNU General Public License (GPL).
Open licenses like the GPL give the applications’ users certain rights, includ-ing the right to view and modify the source and to distribute the applications(on the same terms).The non-commercial license hassimilar provisions. If youwant to distribute your applications without source code (to keep your code
private) or if you want to apply your own commercial license conditionsto yourapplications, you must buy commercial editions of the software you use to cre-ate the applications. The commercial editions of the software allow you to selland distribute your applications on your own terms.
The CD contains a non-commercial version of Qt/Windows, a free edition of
Qt/Mac, and a free edition of Qt/X11. It also contains some other non-commer-cial software, including Borland C ++Builder 5 and a trial version of Borland
C++Builder 6. Each product on the CD has its own speciﬁc license conditions;
for example, the non-commercial Qt/Windows edition may not be redistribut-ed, and its license isn’t compatible with the GPL. The full legal texts of thelicenses are included with the packages on the CD, along with information onhow to obtain commercial versions.
Installing Qt/Windows
When you insert the CD on a Windows machine, a setup program should startautomatically. If this doesn’t occur, run
setup.exe located in the CD’s root
directory.
Figure A.1. Qt/Windows Non-Commercial installer
The setup program will ask you which compiler you want to use for Qt de-
velopment. If you have chosen a Borland compiler, check the Install Appropriate
Compiler option if you also want to install the compiler. If you check the Install
Book Examples option, the example applications shown in this book will be in-
stalled in C:\Qt\3.2.1\book (assuming C:\Qt\3.2.1 is the location where you
installed Qt).
If you choose to install a Borland compiler, note that there may be a delay
between the completion of the Borland installation and the start of theQt installation.
Installing Qt/Windows 395
In the Qt installer, check the Set QTDIR option. If you are using Microsoft
Visual C ++,you must specify Visual Studio’s path so that Qt can integrate
itself with the development environment.
If you are installing on a Windows 95, 98, or ME system, the compilation step
is skipped due to technical limitations in the operating system. The setup pro-gram writes the steps needed to build Qt into a batch ﬁle and puts a shortcutto the batch ﬁle in the
Start menu. To build Qt, simply click this shortcut.
Some Windows versions may require a reboot to set the environment vari-
ables. If you installed Borland C ++Builder 5, you must update your PATH en-
vironment variable to include the Borland executable directory (for example,
C:\Borland\Bcc55\bin ). You must also create two conﬁguration ﬁles in the Bor-
land executable directory. The ﬁrst ﬁle must be called bcc32.cfg and contain
the lines
-I"C:\Borland\Bcc55\include"
-L"C:\Borland\Bcc55\lib"
The second ﬁle must be called ilink32.cfg and contain the line
-L"C:\Borland\Bcc55\lib"
If you installed the Borland compiler in a non-default location, you must
replaceC:\Borland\Bcc55 with the appropriate path.
Installing Qt/Mac
The Mac OS X installation is done from a terminal. To launch a terminal, lookin
Applications/Utilities with Finder.
If your system does not have a C ++compiler installed, you must install one
yourself before installing Qt. An easy option is to install GCC from Apple’sDeveloper Tools CD.
1. Unpack the archive ﬁle from the CD:
cd /Developer
tar zxf /Volumes/Qt\ 3\ Programming/mac/qt-mac-free-3.2.1.tar.gz
The archive is unpacked into /Developer/qt-mac-free-3.2.1 .
2. Create a symlink from this directory to /Developer/qt :
ln -sf qt-mac-free-3.2.1 qt
3. Set up certain environment variables for Qt.
The variables are set differently depending on which shell you are using.
Forexample, if your user name is kelly ,you can ﬁnd out which shell you
are using with the finger command:
finger kelly
396 A. Installing Qt
If your shell is bash,ksh,zsh,o rsh,add the following lines to the .profile
ﬁle in your home directory:
QTDIR=/Developer/qt
PATH=$QTDIR/bin:$PATH
MANPATH=$QTDIR/doc/man:$MANPATHDYLD_LIBRARY_PATH=$QTDIR/lib:$DYLD_LIBRARY_PATHexport QTDIR PATH MANPATH DYLD_LIBRARY_PATH
If your shell is cshortcsh,add the following lines to your .login ﬁle:
setenv QTDIR /Developer/qt
setenv PATH $QTDIR/bin:$PATH
setenv MANPATH $QTDIR/doc/man:$MANPATHsetenv DYLD_LIBRARY_PATH $QTDIR/lib:$DYLD_LIBRARY_PATH
If you encounter “undeﬁned variable” problems, change the last two lines
above to these:
setenv MANPATH $QTDIR/doc/man
setenv DYLD_LIBRARY_PATH $QTDIR/lib
After you have done this, the settings must be activated. The easiest way
to do this is to close the terminal window and then open a new terminalwindow.
4. Execute the
configure tool in the new terminal with your preferred
options to build the Qt library and the tools supplied with it:
cd $QTDIR
./configure
Youcan run ./configure -help to get a list of conﬁguration options. For
example, you can use the -thread option to create a threaded version of
the library.
5. Type make.
6. Make your applications launchable from Finder.
If you built Qt using the -static option, your executables will contain
the Qt library and can be run from Finder automatically. Otherwise,your executables will need to use the Qt library on your system. This isachieved by creating two symlinks:
ln -sf $QTDIR/lib/libqt.3.dylib /usr/lib
ln -sf $QTDIR/lib/libqui.1.dylib /usr/lib
If you built a multithreaded version of Qt, replace libqt.3.dylib with
libqt-mt.3.dylib in the ﬁrst lncommand above.
Creating these links may require administrator access; if this is the case,
run the commands preceded by sudo:
sudo ln -sf $QTDIR/lib/libqt.3.dylib /usr/lib
Installing Qt/Mac 397
sudo ln -sf $QTDIR/lib/libqui.1.dylib /usr/lib
If you don’t have administrator access or just want to install Qt locally,
use these links instead:
ln -sf $QTDIR/lib/libqt.3.dylib $HOME/lib
ln -sf $QTDIR/lib/libqui.1.dylib $HOME/lib
As mentioned above, if you built a multithreaded version of Qt, replace
libqt.3.dylib withlibqt-mt.3.dylib .
If you want to customize how you install Qt or if you encounter problems with
installing Qt, refer to the INSTALL ﬁle in$QTDIR for more information.
Installing Qt/X11
Toinstall Qt on X11, you may need to be root, depending on the permissions
of the directory where you choose to install Qt.
1. Change directory to where you want to install Qt. For example:
cd /usr/local
2. Unpack the archive ﬁle from the CD:
cp /cdrom/x11/qt-x11-free3.2.1.tar.gz .
gunzip qt-x11-free-3.2.1.tar.gztar xf qt-x11-free-3.2.1.tar
This will create the directory qt-x11-free-3.2.1 ,assuming that your
CD-ROM is mounted at /cdrom .
3. Set up certain environment variables for Qt.
The variables are set differently depending on which shell you are using.
Forexample, if your user name is gregory ,you can ﬁnd out which shell
you are using with the finger command:
finger gregory
If your shell is bash,ksh,zsh,o rsh,add the following lines to the .profile
ﬁle in your home directory:
QTDIR=/usr/local/qt-x11-free-3.2.1
PATH=$QTDIR/bin:$PATH
MANPATH=$QTDIR/doc/man:$MANPATHLD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATHexport QTDIR PATH MANPATH LD_LIBRARY_PATH
If your shell is cshortcsh,add the following lines to your .login ﬁle:
setenv QTDIR /usr/local/qt-x11-free-3.2.1
setenv PATH $QTDIR/bin:$PATH
setenv MANPATH $QTDIR/doc/man:$MANPATHsetenv LD_LIBRARY_PATH $QTDIR/lib:$LD_LIBRARY_PATH
398 A. Installing Qt
If you encounter “undeﬁned variable” problems, change the last two lines
above to these:
setenv MANPATH $QTDIR/doc/man
setenv LD_LIBRARY_PATH $QTDIR/lib
Irrespective of which shell you use, if you install Qt on AIX, replace all
occurrences of LD_LIBRARY_PATH withLIBPATH .And if you install Qt on
HP-UX, replace LD_LIBRARY_PATH withSHLIB_PATH .
After you have done this, you must either login again or re-source the
.profile or.login ﬁle before continuing.
4. Execute the configure tool with your preferred options to build the Qt
library and the tools supplied with it:
cd $QTDIR
./configure
Youcan run ./configure -help to get a list of conﬁguration options. For
example, you can use the -thread option to create a threaded version of
the library.
5. Type make.
If you want to customize how you install Qt or if you encounter problems with
installing Qt, refer to the INSTALL ﬁle in$QTDIR for more information.
BB
Qt’s Class Hierarchy
Qt 3.2 provides more than 400 public classes. The class hierarchy depicted
on the following pages presents the majority of them, but omits those that aremore specialized and those that are infrequently used.
399
400 B.Qt’s Class Hierarchy
Qt QObject QWidget
QBrush QEvent QAccel QButton
QCursor QIMEvent QAction QComboBox
QKeySequence QKeyEvent QApplication QDateEdit
QPainter QHideEvent QCanvas QDateTimeEdit
QPen QDropEvent QClipboard QDesktopWidget
QSyntaxHighlighter QPaintEvent QDns QDialog
QTab QChildEvent QDragObject QDial
QThread QMoveEvent QEventLoop QDockArea
QToolTip QShowEvent QProcess QWorkspace
QWhatsThis QCloseEvent QServerSocket QGLWidget
QCanvasItem QTimerEvent QSessionManager QHeader
QCanvasText QFocusEvent QSignal QMainWindow
QCanvasSprite QWheelEvent QSignalMapper QScrollBar
QCanvasPolygonalItem QMouseEvent QSocket QSlider
QCanvasEllipse QResizeEvent QSound QFrame
QCanvasLine QCustomEvent QTimer QSizeGrip
QCanvasPolygon QContextMenuEvent QTranslator QSpinBox
QCanvasSpline QStyleSheet QSplashScreen
QCanvasRectangle QStyle QStatusBar
QCommonStyle QUrlOperator QTabBar
QWindowsStyle QNetworkOperation QTabWidget
QWindowsXPStyle QMotifStyle QNetworkProtocol QTimeEdit
QMacStyle QValidator QToolBox
QPlatinumStyle QFtp QDoubleValidator QScrollView
QSGIStyle QHttp QIntValidator QCanvasView
QCDEStyle QLocalFs QRegExpValidator QIconView
QMotifPlusStyle QEditorFactory QListView
QStylePlugin QSqlField QLayout QListBox
QSqlFieldInfo QTextEdit
QSqlEditorFactory QSqlRecord QSqlDatabase QTextBrowser
QSql QSqlRecordInfo QSqlDriver QGridLayout
QSqlResult QSqlCursor QSqlForm QBoxLayout
QSqlPropertyMap QSqlIndex QDataBrowser QHBoxLayout
QSqlDriverPlugin QSqlQuery QDataView QVBoxLayout
QDataTable QTable
B.Qt’s Class Hierarchy 401
QWidgetFactory QAccessible QMemArray
QCheckBox QWidgetPlugin QAsciiCache QMenuData QByteArray
QToolButton QAsyncIO QMetaObject QPointArray
QPushButton QXmlAttributes QChar QMetaProperty QBitArray
QRadioButton QXmlContentHandler QColor QMovie QCString
QXmlDeclHandler QColorGroup QMimeSource QMimeSourceFactory
QWizard QXmlDTDHandler QDataStream QMutex QMutexLocker
QTabDialog QXmlEntityResolver QDate QPaintDevice
QFileDialog QXmlLexicalHandler QDateTime QPaintDeviceMetrics QPrinter
QFontDialog QXmlLocator QDeepCopy QPair QPicture
QInputDialog QXmlNamespaceSupport QDir QPalette QPixmap
QColorDialog QXmlReader QDomNode QPixmapCache QBitmap
QMessageBox QFileInfo QPoint
QErrorMessage QDomAttr QFont QPtrCollection
QProgressDialog QDomEntity QFontDatabase QPtrQueue QDict
QDomElement QFontInfo QPtrStack QCache
QGrid QDomDocument QFontManager QRangeControl QPtrList
QLabel QDomCharacterData QFontMetrics QRect QIntDict
QHBox QGL QRegExp QPtrDict
QVBox QGLFormat QGLColormap QRegion QAsciiDict
QSplitter QGLContext QGuardedPtr QSemaphore QPtrVector
QLineEdit QHostAddress QSettings QObjectList
QMenuBar QIconSet QSimpleRichText QSortedList
QGroupBox QImage QSize QValueList
QPopupMenu QFile QImageFormatPlugin QSizePolicy QStringList
QProgressBar QBuffer QImageIO QString QValueStack
QLCDNumber QSocketDevice QIntCache QConstString QValueVector
QWidgetStack QIODevice QTextCodec QUrl
QDockWindow QStyleSheetItem QLibrary QTextCodecPlugin QUrlInfo
QToolBar QCustomMenuItem QMap QTextStream QVariant
QIconViewItem QListBoxItem QTime QWMatrix
QListViewItem QListBoxText QAsciiCacheIterator QPtrDictIterator QHButtonGroup
QCheckListItem QListBoxPixmap QCacheIterator QMapIterator QVButtonGroup
QTableItem QLayoutItem QIntCacheIterator QValueListIterator QButtonGroup
QCheckTableItem QSpacerItem QAsciiDictIterator QPtrListIterator QHGroupBox
QComboTableItem QWidgetItem QDictIterator QIntDictIterator QVGroupBox

Index
%(percent sign), 52 ,53,255
&(ampersand), 14 ,156
/(slash), 53 ,63,238
\(backslash), 53 ,238
(euro symbol), 320 ,327
A
ABFactory
class deﬁnition, 381
ABFactory() ,382
classID() ,382
create() ,382
eventsID() ,383
exposeToSuperClass() ,383
featureList() ,382
interfaceID() ,383
ABItem class, 380–381
abort()
QFtp,289
QPrinter ,208
about()
MainWindow ,6 2
QMessageBox ,6 2
aboutQt() (QApplication ), 46
absolute positioning, 136accelerator keys, 14
,23,44,165,341
See also shortcut keys
accept()
ArtistForm ,269
CdForm ,278
QCloseEvent ,5 3,157,159,352
QDialog ,2 5,59
QDragEnterEvent ,216,219
actions, 44–45 ,56,155–156 ,341,360
activateWindow() (MainWindow ),157
activated()
QAction ,4 4
QSocketNotifier ,305
active() (QPalette ),105
activeEditor() (MainWindow ),155
active handles, 198active MDI window, 154
,155
ActiveQt, 347 ,371–384
active window, 59 ,105
activeWindow() (QWorkspace ),155ActiveX, 371–384
-activex option, 381
add()
QToolTip ,339,340
QWhatsThis ,340,346
addArgument() (QProcess ),240
addBindValue() (QSqlQuery ),263
addBox() (DiagramView ),189
addCd() (MainForm ),273
addChild() (QScrollView ),145
addColumn()
QDataTable ,268
QListView ,312
addDatabase() (QSqlDatabase ),262,264
addItem() (DiagramView ),190
addLayout() (QBoxLayout ), 15–16
addLine() (DiagramView ),189
addMultiCellWidget() (QGridLayout ),139
addNewArtist() (CdForm ),279
AddRef() (IUnknown ),378
addSeparator() (QToolBar ), 47
addStretch() (QBoxLayout ), 14
addTo() (QAction ), 46,152
addTransaction()
ImageWindow ,360
TransactionThread ,361
addWidget()
QBoxLayout ,1 4
QScrollView ,150
QStatusBar ,5 7
AddressBook class, 380
Address Book example, 380–384
adjust() (PlotSettings ),130
adjustAxis() (PlotSettings ),131
adjustSize() (QWidget ),118
advanceProgressBar() (TripPlanner ),293
Age example, 6–8AIX, 369alignment, 57
,90,129
alignment() (Cell), 90
allocated memory. Seenewoperator
alpha channel, 101 ,106
Altkey, 14 ,164
ampersand (‘&’), 14 ,156
AndROP ,178
angles, 126 ,177
animations, 165 ,198,244
403
404 Index
append()
QPtrList<T> ,252
QString ,254
QValueVector<T> ,245
appendChild() (QDomNode ),316
Apple Roman, 323
Application
class deﬁnition, 385
commitData() ,386
saveState() ,385
application settings, 63–64 ,143,152,
258
apply() (FlipTransaction ),363
Arabic, 320arcs, 176
areaPoints() (DiagramLine ),197
arg() (QString ), 52–54,255,325
argc andargv parameters, 3 ,160,386
arguments to an external program, 240arrays, 253–254
See also vectors
ArtistComboBox
class deﬁnition, 280
ArtistComboBox() ,280
artistId() ,281
populate() ,281
refresh() ,280
setArtistId() ,281
ArtistForm
class deﬁnition, 267
invocation, 279
ArtistForm() ,268
accept() ,269
beforeDeleteArtist() ,269
beforeInsertArtist() ,270
primeInsertArtist() ,270
reject() ,269
artistId() (ArtistComboBox ),281
ASCII, 222 ,235,254,264,319–323 ,
326
ascii() (QString ),257
aspect ratio, 183 ,200
Assistant .See Qt Assistant
assistants. Seewizards
asynchronous operations, 283 ,289,293,
303,304,364
at()
QIODevice ,294
QSqlQuery ,263
atomicity, 350attributes (XML), 310
,315
auto-delete, 252 ,268
auto-generated ﬁelds, 270auto-populate, 268autoRecalculate() (Spreadsheet ), 71
AxBouncer
class deﬁnition, 375
AxBouncer() ,377
createAggregate() ,377
setColor() ,377
B
background color, 105 ,112,113,118,
178
background mode, 118 ,128,178
backslash (‘/’), 53,238
Backtab key, 164
BDiagPattern ,177
beep() (QApplication ), 83
beforeDelete() (QDataTable ),269,279
beforeDeleteArtist() (ArtistForm ),269
beforeDeleteTrack() (CdForm ),279
beforeInsert() (QDataTable ),270,279
beforeInsertArtist() (ArtistForm ),270
beforeInsertTrack() (CdForm ),279
begin() (container classes), 246
beginGroup() (QSettings ), 63
Bengali, 320
BevelJoin ,177
Bézier curves, 176 ,178,186
Big5-HKSCS, 323big-endian, 231binary I/O, 77–80
,227–234 ,291
binary_search() (STL), 247
bind() (QSocketDevice ),304
bindValue() (QSqlQuery ),263
bitBlt() ,114,121–122 ,185
bit depth. Seecolor depth
bitmaps, 178
See also QPixmap
blinking, 165
BLOB (SQL), 282
block-oriented protocols, 291 ,301
blocking operations. Seesynchronous
operations
BMP ﬁles, 43Borland C ++Builder, 394–395
bottomDock() (QMainWindow ), 43
Bouncer example, 375–380
boundingRect()
DiagramBox ,196
QCanvasItem ,197
QPainter ,207
box layouts, 15 ,23,137
bringToFront() (DiagramView ),191
browse() (ConvertDialog ),240
Index 405
brushes, 176–178
BSDI, 369bubble help. Seetooltips
buddies, 14
,23
building applications, 4built-in dialogs, 36–38built-in widgets, 33–36
,69,99
busy cursor, 78busy indicators, 293button groups, 34buttons
checkboxes, 34
mouse, 107
,225
push, 5 ,14,23,34
radio, 34
byte order, 231
bytesAvailable() (QSocket ),300
C
calculateField() (QSqlCursor ),274,282
canDecode()
CellDrag ,223
QUriDrag ,216
canReadLine() (QSocket ),301
cancel() (QSessionManager ),387
canceled()
QProgressBar ,289
QProgressDialog ,289
canvases, 185–198 ,200
cap styles, 177captions, 7
,151
Carbon API, 63carriage return, 234
,236
Cartesian coordinate system, 105
cascade() (QWorkspace ),156
case sensitivity, 256 ,321
cd() (QFtp),285,286
CD Collection example, 266–282
CdForm
class deﬁnition, 275
invocation, 273
CdForm() ,276
init() ,277
accept() ,278
addNewArtist() ,279
beforeDeleteTrack() ,279
beforeInsertTrack() ,279
reject() ,279
CD Tables example, 272CDE style, 8
Cell
class deﬁnition, 88Cell (continued)
inheritance tree, 70
Cell() ,8 9
alignment() ,9 0
evalExpression() ,9 2
evalFactor() ,9 3
evalTerm() ,9 3
formula() ,9 0
setDirty() ,9 0
setFormula() ,8 9
text() ,9 0
value() ,9 1
cell() (Spreadsheet ), 74
CellDrag
class deﬁnition, 221
CellDrag() ,221
canDecode() ,223
decode() ,223
encodedData() ,222
format() ,221
toCsv() ,222
toHtml() ,223
Cell Drag example, 221–224
cellWidget() (QTable ), 77
central widget, 43 ,69–70 ,142,152
See also main widget
centralWidget() (QMainWindow ), 43
character encodings, 222 ,224,234,317,
319–323
character strings, 254–258
characters() (SaxHandler ),310
charmap ﬁles, 323
checkboxes, 34
checkmarks, 45 ,156
child() (QObject ), 33
child dialogs, 51
child layouts, 15 ,138
child objects, 16 ,26
child processes, 239
child widgets
of a layout widget, 6 ,16
of a scroll view, 150of a splitter, 140of a widget stack, 144of an invisible widget, 119of an MDI workspace, 152
Chinese, 320chords, 176
circles. Seeellipses
circular buffer, 354class documentation, 8–10
classID() (ABFactory ),382
className() (QObject ), 20
406 Index
clear()
container classes, 248
QStatusBar ,340
Spreadsheet ,7 3
clearBoard() (TicTacToe ),388
clearCell() (QTable ), 73
clearCurve() (Plotter ),120
clicked()
MyWhatsThis ,345
QPushButton ,6,163
client–server applications, 291–301
ClientSocket
class deﬁnition, 298
ClientSocket() ,299
generateRandomTrip() ,300
readClient() ,299
clip region, 129 ,178
clipboard() (QApplication ), 81,224
clipboard operations, 80–82 ,154,155,
192–193 ,224–226
clipper, 150
close()
QFtp,285
QWidget ,1 4,53
closeActiveWindow() (QWorkspace ),156
closeAllWindows()
QApplication ,6 6
QWorkspace ,156
closeConnection() (TripPlanner ),296
closeEvent()
Editor ,159
MainWindow ,5 3,157
QWidget ,4 0,387
ThreadForm ,352
code editor ( Qt Designer ), 25–27,31
CODEC entry (.pro ﬁles), 335
codecForLocale() (QTextCodec ),321
codecForName() (QTextCodec ),322
codecs, 317 ,321–323
collection classes. Seecontainer classes
collisions() (QCanvas ),190,200
color depth, 101 ,113
color dialog, 36
colorGroup() (QWidget ),105,121
colormaps, 113
See also QGLColormap
colors, 5 ,36,100,102
columns
in a data table, 268in a list view, 312in a table, 74
COM, 371–384comboboxes, 36comma-separated values (CSV), 223commandFinished() (QFtp),285
command-line of an external program,
240
command-line options, 3 ,8,160,386
commandStarted() (QFtp),285
commercial editions of Qt, 393–394
commit() (QSqlDatabase ),264,269,278
commitData()
Application ,386
QApplication ,384
common dialogs, 36–37compiling applications, 4compiling Qt, 394–398compression of data, 232compression of events, 104
CONFIG entry (.pro ﬁles), 214 ,352–353
conﬁguration data, 63–64 ,258
conﬁguring Qt, 352 ,394–398
connect() (QObject ), 6–8 ,14,18–20
connectToHost()
QFtp,285,286
QSocket ,293
connectToServer() (TripPlanner ),293
connected() (QSocket ),293
connecting to a database, 261–262 ,
264–265
connectionClosed() (QSocket ),297,299
connectionClosedByServer()
(TripPlanner ),297
connection editor ( Qt Designer ), 24
connectionTimeout() (TripPlanner ),297
console applications, 237 ,241,353
const iterators, 246constructors
copy, 243default, 243
,246
flags parameter, 66 ,117,147,158
parent andname parameters, 12
consumer–producer model, 354–358container classes
as return values, 248auto-delete, 252dictionaries, 252–253iterators, 246lists, 247–249
,252
maps, 249–251memory arrays, 253–254pointer-based, 251–253Qt vs. STL, 243strings, 254–258type of objects stored, 243variants, 89
,100,258–260 ,262
vectors, 243–247 ,251–252
container widgets, 3 ,34
Index 407
contains() (QRect ),108
contentsContextMenuEvent()
(DiagramView ),189
contentsDragEnterEvent() (ProjectView ),
219
contentsDropEvent() (ProjectView ),219
contentsMouseDoubleClickEvent()
(DiagramView ),191
contentsMouseMoveEvent()
DiagramView ,190
ImageEditor ,149
ProjectView ,218
contentsMousePressEvent()
DiagramView ,190
ImageEditor ,149
ProjectView ,218
contextMenuEvent()
MainWindow ,4 8
QDataTable ,270
QWidget ,4 0
context menus, 40 ,48,151,189,267,
270
controllingUnknown() (QAxAggregated ),
378
controls. Seewidgets
convert() (ConvertDialog ),240
convertDepth() (QImage ),103
ConvertDepthTransaction class, 362
ConvertDialog
init() ,239
browse() ,240
convert() ,240
processExited() ,241
updateOutputTextEdit() ,241
convertSeparators() (QDir), 53,238
convex polygons, 183coordinate system
of a painter, 105–106
,150,178–179
of a scroll view, 149of a widget, 105
,107,125
copy()
DiagramView ,192
MyTable ,225
QMemArray<T> ,254
Spreadsheet ,8 0
copyAvailable()
MainWindow ,157
QTextEdit ,154
copy constructors, 243copy on write. Seeimplicit sharing
CopyROP ,127,178
Core Graphics API, 368
cornerWidget() (QScrollView ),145
CP874, 323CP125 x,323
create()
ABFactory ,382
IconEditorPlugin ,110
QWidgetFactory ,3 3
createActions()
DiagramView ,189
MainWindow ,4 4,330
createAggregate() (AxBouncer ),377
createConnection() ,261
createConnections() ,282
createEditor()
MainWindow ,154
Spreadsheet ,7 5
createElement() (QDomDocument ),316
createLanguageMenu() (MainWindow ),331
createMenus() (MainWindow ), 46,330
createOneConnection() ,281
createStatusBar() (MainWindow ), 56
createTextNode() (QDomDocument ),316
createToolBars() (MainWindow ), 47
createWindowsMenu() (MainWindow ),156
critical() (QMessageBox ), 50
CRLF. Seeline-ending conventions
CrossPattern ,177
CSV, 223
Ctrlkey, 107 ,164
Cube
class deﬁnition, 209
Cube() ,210
draw() ,211
faceAtPosition() ,213
initializeGL() ,210
mouseDoubleClickEvent() ,212
mouseMoveEvent() ,212
mousePressEvent() ,212
paintGL() ,211
resizeGL() ,210
Cube example, 209–214
currentCdChanged() (MainForm ),274
currentChanged() (QDataTable ),274
currentDateTime() (QDateTime ),182
currentDirPath() (QDir),238
currentFormula() (Spreadsheet ), 75
currentItem property ( QListBox ),145
currentItem() (QComboBox ), 61
currentLocation() (Spreadsheet ), 75
currentRecord() (QDataTable ),273
currentThread() (QThread ),358
cursor (mouse), 78 ,123,124,190
Cursor type, 370
cursors (SQL), 265–266
CurveData typedef, 115
custom canvas items, 187
408 Index
custom dialogs, 11–18 ,21–33
custom drag types, 220–224
customEvent() (ImageWindow ),360
custom events, 164 ,359–363
custom properties, 100 ,280
custom styles, 122custom widgets, 69
,97–132 ,278
cut()
DiagramView ,192
MainWindow ,155
Spreadsheet ,8 0
cyclic connections, 8 ,21
Cygwin, 369
D
DashDotDotLine ,176
DashDotLine ,176
DashLine ,176
data()
QClipboard ,225
QDomText ,315
QMap<K,T> iterators, 250
data-aware widgets, 275data compression, 232data-entry widgets, 36
dataReceived() (WeatherStation ),305
data structures. Seecontainer classes
data tables, 266–274
dataTransferProgress()
QFtp,289
QHttp ,291
database() (QSqlDatabase ),264
databases
built-in drivers, 262 ,393
connecting to, 261–262 ,264–265
navigating result sets, 262 ,265
transactions, 264value binding, 263–264
Datagram (QSocketDevice ),303,304
date, 182date/time editors, 36
,328
DB2 (IBM), 262
.dcf ﬁles ( Qt Assistant ),347
decode()
CellDrag ,223
QTextDrag ,220,224
decodeLocalFiles() (QUriDrag ),217
deep copy, 254 ,259,364
.def ﬁles, 379
Default (QMessageBox ), 50
default buttons, 14 ,23,50
default constructors, 243 ,246default database connection, 265
default ﬁeld values, 270deferred deletion, 299
,300,364
#define directive, 12
DEFINES entry (.pro ﬁles), 326
degrees, 126 ,177
del()
DiagramView ,193
QSqlCursor ,266
Spreadsheet ,8 2
delayedCloseFinished() (QSocket ),299,
300
delete operator, 16 ,48–49 ,64–66 ,83,
300,364
DELETE statement, 265
deleteCd() (MainForm ),273
deleteLater() (QObject ),299,300,364
delta() (QWheelEvent ),126
Dense?Pattern ,177
deriving. Seesubclassing
Designer .See Qt Designer
destructors, 17 ,195
detach() (QImage ),103
Devanagari, 320device coordinates, 178–179DG/UX, 369
DiagCrossPattern ,177
Diagram example, 186–198
DiagramBox
class deﬁnition, 187
DiagramBox() ,195
~DiagramBox() ,195
boundingRect() ,196
drawShape() ,196
setText() ,196
DiagramLine
class deﬁnition, 188
DiagramLine() ,196
~DiagramLine() ,196
areaPoints() ,197
drawShape() ,197
offset() ,188
DiagramView
class deﬁnition, 186
DiagramView() ,188
addBox() ,189
addItem() ,190
addLine() ,189
bringToFront() ,191
contentsContextMenuEvent() ,189
contentsMouseDoubleClickEvent() ,
191
contentsMouseMoveEvent() ,190
contentsMousePressEvent() ,190
Index 409
DiagramView (continued)
copy() ,192
createActions() ,189
cut() ,192
del() ,193
paste() ,193
properties() ,194
sendToBack() ,192
setActiveItem() ,194
showNewItem() ,194
dialogs
built-in, 36–38creating in code, 12–13creating using Qt Designer ,2 1 – 3 3
invoking, 58–62meaning of parent, 51modal, 59–60modeless, 58passing data to and from, 61–62
dials, 36dictionaries, 252–253
See also maps
directories, 53
,237–238
disabled() (QPalette ),105
disabled actions, 155disabled widgets, 14
,105,170
discard command, 386
disconnect() (QObject ), 19,20
display context (OpenGL), 210Divehi, 320division by zero, 93
,103
DNS lookup. SeeQDns
dock areas, 43 ,150–152
documentElement() (QDomDocument ),314
documentTitle() (QTextBrowser ),344
documentation, 8–10 ,342–347
DOM, 307 ,312–317
DomParser
class deﬁnition, 313
DomParser() ,313
parseEntry() ,314
DOM Parser example, 313–316
done()
QFtp,284
QHttp ,290
DotLine ,176
double buffering, 112–114 ,185
double-click, 191 ,212
doubly linked lists, 247–249 ,252
Downloader
class deﬁnition, 286
Downloader() ,286
ftpDone() ,287
listInfo() ,287Downloader example, 286–289
drag() (QDragObject ),219
drag and drop
accepting drops, 215–220built-in drag types, 219custom drag types, 220–224originating drags, 217–219start distance, 218
dragEnterEvent() (QWidget ),216
Drag File example, 215–217drag handles, 198
dragLeaveEvent() (QWidget ),217
dragMoveEvent() (QWidget ),217
dragObject() (MyTable ),224
draw()
Cube,211
OvenTimer ,183,199
QCanvasItem ,200
drawActiveHandle() ,195
drawArc() (QPainter ),176
drawChord() (QPainter ),176
drawContents() (ImageEditor ),148
drawConvexPolygon() (QPainter ),183
drawCubicBezier() (QPainter ),176
drawCurves() (Plotter ),129
drawEllipse() (QPainter ),176,177
drawGrid() (Plotter ),128
drawImagePixel() (IconEditor ),106
drawLine() (QPainter ),104,176,184
drawLineSegments() (QPainter ),176
drawPie() (QPainter ),176,177
drawPoints() (QPainter ),176
drawPolygon() (QPainter ),176,183
drawPolyline() (QPainter ),130,176
drawPrimitive() (QStyle ),122
drawRect() (QPainter ),121,176,184
drawRoundRect() (QPainter ),176
drawShape()
DiagramBox ,196
DiagramLine ,197
drawText() (QPainter ),129,167,179,
184
Drawable type, 370
Drawing class, 230
drill-down, 261
driver() (QSqlDatabase ),264
drivers
database, 262 ,393
printer, 199
dropEvent() (QWidget ),217
druids. Seewizards
.dsp ﬁles (Visual Studio), 5
dumpdoc ,373
-dumpidl option, 381
410 Index
duration() (OvenTimer ),182
DYLD_LIBRARY_PATH environment
variable, 395
dynamicCall() (QAxBase ),374
dynamic_cast<T>() ,188
dynamic dialogs, 33
See also shape-changing dialogs
dynamic memory. Seenewoperator
dynamic menus, 54–56 ,156–157
DYNIX, 369
E
Easter eggs, 170
Editmenus, 80–84
editions of Qt, 393–394
Editor
class deﬁnition, 158
Editor() ,158
closeEvent() ,159
maybeSave() ,159
newFile() ,159
open() ,159
save() ,159
setCurrentFile() ,160
sizeHint() ,160
Editor example, 152–161editor widgets, 36ellipses, 176
,177,186
Embedded Linux, 367–370
emit pseudo-keyword, 17
Employee class, 20–21
empty() (container classes), 246 ,248
empty strings, 257emulated look and feel, 8
,122
enableClipper() (QScrollView ),150
enableOkButton() (GoToCellDialog ), 25
enabled widgets. Seedisabled widgets
encodedData() (CellDrag ),222
encodings, 222 ,224,234,317,319–323
end() (container classes), 246
endDocument() (QXmlContentHandler ),308
endEdit() (Spreadsheet ), 76
endElement() (SaxHandler ),311
endGroup() (QSettings ), 63
endian, 231
endsWith() (QString ),256
entryHeight() (PrintWindow ),206
entryList() (QDir),238
environment variables
DYLD_LIBRARY_PATH ,395
LD_LIBRARY_PATH ,397
LIBPATH ,397environment variables (continued)
MANPATH ,395,397
PATH,4,347,386,395,397
QTDIR ,111,395,397
SHLIB_PATH ,397
erase()
list<T> ,247
vector<T> ,247
erase color, 112 ,113,118,128
error()
Gallery ,229
QSocket ,293
TripPlanner ,297
error dialog, 37
errorString()
QFile ,7 8,79,229
QXmlErrorHandler ,310
Esckey, 50
Escape (QMessageBox ), 50
escape() (QStyleSheet ),202,223
escapeXml() ,317
EUC-JP, 323EUC-KR, 323euro symbol (‘
’), 320 ,327
evalExpression() (Cell), 92
evalFactor() (Cell), 93
evalTerm() (Cell), 93
event()
JournalView ,333
MainWindow ,333
QObject ,164,170
eventFilter() (QObject ),169,170
event loop, 171 ,283,289,300,301,359,
364
event types
close, 40 ,53,157,159,352,387
context menu, 40 ,48,189,270
custom, 164 ,359–363
drag enter, 216 ,219
drag leave, 217drag move, 217drop, 217
,219
hide, 168key press, 125
,164,168
key release, 164language change, 333layout direction change, 170locale change, 332–333mouse double-click, 191
,212
mouse move, 107 ,123,149,190,212,
218
mouse press, 106 ,107,123,149,182,
190,212,218
mouse release, 124 ,226
Index 411
event types (continued)
paint, 104 ,113,121,167,182,185
resize, 122 ,136
show, 167timer, 165–168
,173,303,374
wheel, 126
events, 4 ,48
compared with signals, 163compression, 104custom types, 164
,359–363
ﬁltering, 168–171 ,370
handling, 104 ,163–168 ,170,370
pending, 173platform-speciﬁc, 370propagation, 165
,171,216
eventsID() (ABFactory ),383
examples
Address Book, 380–384Age, 6–8Bouncer, 375–380CD Collection, 266–282CD Tables, 272Cell Drag, 221–224Cube, 209–214Diagram, 186–198DOM Parser, 313–316Downloader, 286–289Drag File, 215–217Editor, 152–161Find, 11–18
,58
Go-to-Cell, 21–28 ,59
Hello, 3–5Hex Spin Box, 97–99
,108
Icon Editor, 99–111Image Converter, 239–241Image Editor, 146–150Image Pro, 359–363Image Space, 237–238Media Player, 371–374Oven Timer, 180–185Plotter, 114–132Project Chooser, 217–220Quit, 5–6SAX Handler, 308–312Semaphores, 354–356Sort, 28–32
,60
Spreadsheet, 39–68 ,69–95
Threads, 349–353Tic-Tac-Toe, 384–389Ticker, 165–168Trip Planner, 292–298Trip Server, 292
,298–301
Wait Conditions, 356–358
Weather Balloon, 302–304examples (continued)
Weather Station, 302 ,304–305
ExcludeUserInput (QEventLoop ),172
exclusive actions, 45exclusive buttons, 34
exec()
QApplication ,3,171,359
QDialog ,5 9
QPopupMenu ,4 8
QSqlQuery ,262
exists()
QDir,238
QFile ,238
expandedTo() (QSize ),113
Expanding (QSizePolicy ),118,139
explicit sharing, 103 ,254,364
exporting plugins, 111
exposeToSuperClass() (ABFactory ),383
Extensible Markup Language. See
XML
extension dialogs, 28–32external programs, 239
F
faceAtPosition() (Cube),213
FALSE constant, 14
fatalError() (SaxHandler ),311
FDiagPattern ,177
featureList() (ABFactory ),382
ﬁle dialog, 37 ,50–51
Filemenus, 45 ,46,49–56 ,65
fileName() (QFileInfo ), 53
ﬁles
attributes, 238binary I/O, 77–80
,227–234 ,291
directory separator, 53 ,238
dragging, 217encodings, 321–322image formats, 43
,239
name ﬁlters, 50 ,238,239
reading and writing XML, 307–317recently opened, 46
,54–56
text I/O, 234–237 ,321–322
traversing directories, 237–238uploading and downloading,
283–291
ﬁll patterns, 176–178
,177
fillRect() (QPainter ),106
Film class, 244 ,249–250
ﬁlters
for events, 168–171 ,370
for ﬁle names, 50 ,238,239
412 Index
ﬁlters (continued)
on a data table, 274
find()
MainWindow ,5 8
map<K,T> ,250
QMemArray<T> ,254
QWidget ,367
STL, 246 ,248
Find example, 11–18 ,58
findClicked() (FindDialog ), 17
FindDialog
class deﬁnition, 12 ,13
invocation, 58 ,59
FindDialog() ,1 3 – 1 5
findClicked() ,1 7
findNext() ,1 2
findPrev() ,1 2
FindFileDialog class, 135–138
findNext()
FindDialog ,1 2
Spreadsheet ,8 3
findPrev()
FindDialog ,1 2
Spreadsheet ,8 4
first member ( map<K,T> iterators), 130 ,
250
first() (QSqlQuery ),263
firstChild() (QDomNode ),316
Fixed (QSizePolicy ),139
ﬁxed size, 140ﬂags
setting after construction, 158setting in constructor, 66
,117
setting on a scroll view, 147
WDestructiveClose ,6 6,158,344
WGroupLeader ,343
WNoAutoErase ,112–113 ,117,118,147,
185
WStaticContents ,101,108,112,147
flags parameter, 66 ,117,147,158
FlatCap ,177
ﬂicker, 104 ,112,168,185
flipHorizontally() (ImageWindow ),360
FlipTransaction
class deﬁnition, 362
apply() ,363
messageStr() ,363
ﬂoating dock windows, 150–152
FMFontFamily type, 370
focus, 14 ,24,118,122,164,171
focusNextPrevChild() (QWidget ),169,
170
focus policies, 118focus rectangle, 122folders, 237–238
font dialog, 36
fontMetrics() (QWidget ),160,167
Font type, 370
fonts, 36 ,137,167,176,183,320
foreign keys, 266 ,271,277,281
form editor. See Qt Designer
format() (CellDrag ),221
formula()
Cell,9 0
Spreadsheet ,7 4
forward declarations, 12 ,13
frame buffer, 369frames, 34FreeBSD, 369
free edition of Qt, 393–394
froglogic, 367
fromAscii() (QString ),326
fromMimeSource() (QPixmap ), 44
FTP, 283–289
ftpDone()
Downloader ,287
MainWindow ,285
functors, 87
G
Gallery
class deﬁnition, 228
error() ,229
getData() ,232
ioError() ,229
loadBinary() ,230
loadText() ,235
readFromStream() ,231
readFromString() ,237
saveBinary() ,228
saveToString() ,236
setData() ,232
writeToStream() ,229
GB2312, 323GB18030, 323GBK, 323GCC, 18
,395
General Public License, 394
generateDocumentation() (QAxBase ),373
generateId() ,270
generateRandomTrip() (ClientSocket ),
300
geometric shapes, 176 ,185
geometries, 136
get()
QFtp,284,285,287
Index 413
get() (continued)
QHttp ,290
getColor() (QColorDialog ),212
getData() (Gallery ),232
getFile() (MainWindow ),290
GetInterfaceSafetyOptions()
(ObjectSafety ),378
getOpenFileName() (QFileDialog ), 50–51,
159,240
getPriceList() (MainWindow ),284
getSaveFileName() (QFileDialog ), 52
GIF ﬁles, 43
globalPos() (QContextMenuEvent ), 48
GNU General Public License, 394GNU Hurd, 369
goToCell() (MainWindow ), 59
GoToCellDialog
creating using Qt Designer ,2 1 – 2 8
invoking, 59
init() ,2 5
enableOkButton() ,2 5
GoToCellDialogBase class, 27
GoToCellDialogImpl class, 27
Go-to-Cell example, 21–28 ,59
GPL, 394graphics, 175–214Graphics Gems ,132
gravity. See
WStaticContents
grayed out widgets, 14
Greek, 320grid layouts, 29
,30,137,138
group() (IconEditorPlugin ),110
group boxes, 34GUI builder. See Qt Designer
GUI thread, 359Gujarati, 320Gurmukhi, 320
GWorldPtr type, 370
H
handle() (GUI classes), 370
hasAcceptableInput() (QLineEdit ), 25
hasFeature() (QSqlDriver ),264
hasLocalData() (QThreadStorage<T> ),358
hasPendingEvents() (QApplication ),173
hashes. Seecontainer classes
HBITMAP type, 370
HCURSOR type, 370
HDCtype, 370
head() (QHttp ),290
header ﬁles, 13heap memory. See
newoperatorheavy processing, 171 ,349
Hebrew, 320
height() (QImage ),108
Hello example, 3–5help, 47
,339–347
HelpBrowser
class deﬁnition, 342 ,347
HelpBrowser() ,343
showPage() ,344,347
updateCaption() ,344
HexSpinBox
class deﬁnition, 97
integration with Qt Designer ,
108–109
HexSpinBox() ,9 8
mapTextToValue() ,9 8
mapValueToText() ,9 8
Hex Spin Box example, 97–99 ,108
HFONT type, 370
hibernation, 384
hidden widgets, 4 ,31,59,119,139
hide()
QCanvasItem ,195,196
QWidget ,3 1,119
hideEvent() (Ticker ),168
highlighted() (QListBox ),145
Home key, 164
homeDirPath() (QDir),238
HorPattern ,177
horizontalHeader() (QTable ), 73
horizontal layouts, 6 ,15,23,137
horizontalScrollBar() (QScrollView ), 73,
145
host addresses, 303host names, 303hourglass cursor, 78HP-UX, 369
HRGN type), 370
HTML, 5 ,8,35,202–203 ,223,341,
342–347 ,380
HTTP, 283 ,289–291
httpDone() (MainWindow ),290
Hurd, 369
HWND type, 367
I
IANA, 219IBM-850, 323IBM-866, 323IBM DB2, 262
IconEditor
class deﬁnition, 100
414 Index
IconEditor (continued)
integration with Qt Designer ,
109–111
IconEditor() ,101
drawImagePixel() ,106
mouseMoveEvent() ,107
mousePressEvent() ,106
paintEvent() ,104
setIconImage() ,103
setImagePixel() ,107
setPenColor() ,102
setZoomFactor() ,103
sizeHint() ,102
Icon Editor example, 99–111
IconEditorPlugin
class deﬁnition, 109
create() ,110
group() ,110
iconSet() ,111
includeFile() ,110
isContainer() ,110
keys() ,110
toolTip() ,111
whatsThis() ,111
iconSet() (IconEditorPlugin ),111
icon views, 33 ,35
icons, 43 ,44,50,62,219,328
See also images
ID
of a COM component, 372 ,379,382
of a menu item, 55of a session, 386of a timer, 167of a widget, 367of an FTP command, 285of an HTTP request, 291
IDL, 381idle processing, 173
#ifdirective, 369
#ifndef directive, 12
ignore() (QCloseEvent ), 53,157,159
Ignored (QSizePolicy ),140
image collections, 44Image Converter example, 239–241
ImageEditor
class deﬁnition, 146
ImageEditor() ,147
contentsMouseMoveEvent() ,149
contentsMousePressEvent() ,149
drawContents() ,148
resizeContents() ,148
setImage() ,148
setImagePixel() ,149
Image Editor example, 146–150ImageMagick, 239
Image Pro example, 359–363
imageSpace() ,237
Image Space example, 237–238
ImageWindow
ImageWindow() ,360
addTransaction() ,360
customEvent() ,360
flipHorizontally() ,360
images
alpha channel, 101color depth, 101
,113
distributing with the application, 43ﬁle formats, 43
,239
icons, 43 ,44,50,62,219,328
QImage vs.QPixmap ,113
storing in a database, 282
IMAGES entry (.pro ﬁles), 44 ,118
implicit sharing, 249 ,258–259 ,364
in-process database. SeeSQLite
inactive() (QPalette ),105
includeFile() (IconEditorPlugin ),110
information() (QMessageBox ), 50
inheriting. Seesubclassing
initial thread, 359
initializeGL() (Cube),210
input dialogs, 37input methods, 320
insert()
list<T> ,247
QPtrList<T> ,252
QSqlCursor ,265
QString ,256
vector<T> ,247
INSERT statement, 263 ,265
insertItem()
QComboBox ,3 2,281
QMenuBar ,4 7
QPopupMenu ,4 6,332
insertSeparator()
QMenuBar ,4 7
QPopupMenu ,4 6,55
installEditorFactory() (QDataTable ),
282
installEventFilter() (QObject ),169,
170
installPropertyMap()
QDataTable ,282
QSqlForm ,278
installing Qt, 394–398intensive processing, 171
,349
Interface Deﬁnition Language (IDL),
381
interfaceID() (ABFactory ),383
Index 415
interfaces (COM), 375 ,377
internationalization, 319–337Internet Assigned Numbers Authority,
219
Internet Explorer, 375Internet protocols
DNS. See
QDns
FTP, 283–289
HTTP, 289–291TCP, 291–301UDP, 301–305
inter-process communication, 239–241introspection, 20invisible widgets, 4
,31,59,119,139
I/O
binary, 77–80 ,227–234 ,291
devices, 78 ,285,289,290,291
text, 234–237
ioError() (Gallery ),229
IO_ReadOnly ,8 0
IO_Translate ,234
IO_WriteOnly ,7 8
IObjectSafety ,377–379
IP addresses, 303IPC, 239–241Irix, 369
isActive() (QSqlQuery ),263
isContainer() (IconEditorPlugin ),110
isDigit() (QChar ),321
isEmpty() (QString ),257
isLetter() (QChar ),321
isLetterOrNumber() (QChar ),321
isMark() (QChar ),321
isModified() (QTextEdit ),160
isNull() (QString ),257
isNumber() (QChar ),321
isPrint() (QChar ),321
isPunct() (QChar ),321
isSessionRestored() (QApplication ),388,
389
isSpace() (QChar ),321
isSymbol() (QChar ),321
isValid() (QVariant ), 90
ISO 8859-1, 222 ,319–323
ISO 8859-15, 222 ,327
ISO 8859- x,323
ISO 10646 UCS-2, 323item views, 35
,73
iterators
const vs. non-const, 246dereferencing, 246for dictionaries, 253for lists, 248for pointer lists, 252iterators (continued)
for vectors, 246incrementing and decrementing, 246
IUnknown
AddRef() ,378
QueryInterface() ,378
Release() ,375,378
J
Japanese, 320
JavaScript, 380
JIS7, 323
join() (QStringList ),257
join styles, 177
JournalView
JournalView() ,333
event() ,333
retranslateStrings() ,334
JPEG ﬁles, 43
K
Kannada, 320
KeepSize (QSplitter ),142
key()
QKeyEvent ,164
QMap<K,T> iterators, 250
key events, 164–165
keyPressEvent()
Plotter ,125
QWidget ,164,168
keyReleaseEvent() (QWidget ),164
keyboard accelerators, 14 ,23,44,165,
341
keyboard focus. Seefocus
keyboard shortcuts, 44 ,156
keys
Alt,164
Backtab ,164
Ctrl,107,164
Esc,5 0
Home ,164
Menu ,4 0
Shift,107,164
Space ,168
Tab,118,164
keys()
IconEditorPlugin ,110
QMap<K,T> ,251
Khmer, 320
killTimer() (QObject ),168
416 Index
Klarälvdalens Datakonsult, 367
KOI8-R, 323KOI8-U, 323Korean, 320
L
labels, 3 ,35
language change events, 333
Language menus, 329 ,331–332
languages supported by Qt, 320Lao, 320
last() (QSqlQuery ),263
lastError() (QSqlQuery ),263
lastWindowClosed() (QApplication ), 65
Latin-1, 254 ,264,319–323
latin1()
QChar ,320
QString ,257
Latin-9. SeeISO 8859-15
launching external programs, 239layout direction, 15
,170,327,328
layout managers, 15 ,137
alternatives to, 122–123 ,136–137
box, 15 ,23,137
grid, 29 ,30,137,138
inQt Designer ,2 3,29,30,139
margin and spacing, 138nesting, 15
,138
size hints, 32 ,57,102,103,118,137,
139–140
size policies, 102 ,118,139
spacer items, 15
layout widgets, 6 ,16
LCD numbers, 35
LD_LIBRARY_PATH environment variable,
397
left() (QString ),255
leftDock() (QMainWindow ), 43
left mouse button, 107 ,123,190,212,
218
length() (QString ),257
LIBPATH environment variable, 397
LIBS entry (.pro ﬁles), 33 ,346,374
licensing, 393–394line editors, 36line-ending conventions, 234
,236
line-oriented protocols, 291 ,301
Linguist .See Qt Linguist
link errors, 18linked lists, 247–249
,252
Linux, 367–370 ,397–398
list() (QFtp),285,286,287list<T> ,247
iterators, 248
erase() ,247
insert() ,247
push_back() ,248
list boxes, 33 ,35
listInfo()
Downloader ,287
QFtp,287
list views, 33 ,35
lists, 247–249 ,252
little-endian, 231
load() (QTranslator ),327–328
loadBinary() (Gallery ),230
loadFile() (MainWindow ), 51
loadText() (Gallery ),235
localData() (QThreadStorage<T> ),358
LocalDate ,328
local host, 293 ,303
locale() (QTextCodec ),327
localeAwareCompare() (QString ),328
locale change events, 332–333
localization. Seeinternationalization
lock() (QMutex ),353,354
logical coordinates, 178–179 ,185
login() (QFtp),285,286
logout, 384 ,387
look and feel, 8 ,122
lower()
QChar ,321
QString ,256
lrelease ,334–337
“LTR” marker, 327
lupdate ,323,325–326 ,334–337
LynxOS, 369
M
macEvent() (QWidget ),370
macEventFilter() (QApplication ),370
Mac OS X, 367–370 ,395–397
Mac style, 8 ,122
macVersion() (QApplication ),370
MailClient
MailClient() ,141
readSettings() ,143
writeSettings() ,143
main()
argc andargv parameters, 3 ,160
for ActiveX applications, 379 ,381
for database applications, 262for internationalized applications,
326
Index 417
main() (continued)
for MDI applications, 67 ,160
for SDI applications, 65for simple example, 3
MainForm
class deﬁnition, 271
MainForm() ,272
addCd() ,273
currentCdChanged() ,274
deleteCd() ,273
main layout, 15main thread, 359main widget, 4
See also central widget
MainWindow
class deﬁnition, 40 ,215,284
MainWindow() ,4 2,66,153,284,289,
329
about() ,6 2
activateWindow() ,157
activeEditor() ,155
closeEvent() ,5 3,157
contextMenuEvent() ,4 8
copyAvailable() ,157
createActions() ,4 4,330
createEditor() ,154
createLanguageMenu() ,331
createMenus() ,4 6,330
createStatusBar() ,5 6
createToolBars() ,4 7
createWindowsMenu() ,156
cut() ,155
event() ,333
find() ,5 8
ftpDone() ,285
getFile() ,290
getPriceList() ,284
goToCell() ,5 9
httpDone() ,290
loadFile() ,5 1
maybeSave() ,4 9
newFile() ,4 9,65,154
open() ,5 0,154
openRecentFile() ,5 5
readSettings() ,6 3
retranslateStrings() ,331
save() ,5 1,155
saveAs() ,5 2
saveFile() ,5 1
setCurrentFile() ,5 3
sort() ,6 0 – 6 2
spreadsheetModified() ,5 7
strippedName() ,5 3
switchToLanguage() ,332MainWindow (continued)
updateCellIndicators() ,5 7
updateMenus() ,155
updateModIndicator() ,157
updateRecentFileItems() ,5 4
writeSettings() ,6 3
main windows, 40–43 ,64–67 ,69
makeﬁles, 4 ,17–18
Malayalam, 320
manhattanLength() (QPoint ),218
MANPATH environment variable, 395 ,397
manual layout, 122–123 ,136
map<K,T> ,250
iterators, 130 ,250
find() ,250
operator[]() ,250
mapTextToValue() (HexSpinBox ), 98
mapValueToText() (HexSpinBox ), 98
maps, 249–251margin (in layouts), 7
,138
master–detail views, 271
Maximum (QSizePolicy ),139
maximum size, 137 ,140
maybeSave()
Editor ,159
MainWindow ,4 9
MDI, 67 ,152–161
Media Player example, 371–374
Members tab (Qt Designer ), 28,239,292
memory arrays, 253–254memory management, 16–17
,48–49 ,
66
menuBar() (QMainWindow ), 43,47
Menu key, 40
menus
bars, 43 ,47
context, 40 ,48,151,189,267,270
creating, 44–47disabling items, 155dynamic, 54–56
,156–157
toggle items, 45 ,156
message() (QStatusBar ), 51,340
message boxes, 37 ,49–50 ,268
messageStr() (FlipTransaction ),363
messages. Seeevents
metaObject() (QObject ), 20
meta-object compiler ( moc), 17–18,20,
376
metrics, 167 ,204
Microsoft Internet Explorer, 375Microsoft SQL Server, 262Microsoft Visual C ++,4
,18,395
Microsoft Visual Studio, 5 ,395
mid() (QString ), 59,255
418 Index
middle mouse button, 225
MIME sources, 44 ,220
MIME types, 219 ,222
Minimum (QSizePolicy ),102,139
MinimumExpanding (QSizePolicy ),140
minimumHeight() (QWidget ),136
minimum size, 32 ,57,137,140
minimumSizeHint()
Plotter ,120
QWidget ,140
minimumWidth() (QWidget ),136
mirror() (QImage ),363
MiterJoin ,177
mkdir()
QDir,238
QFtp,285
MNG ﬁles, 43
moc,1 7 – 1 8 ,20,376
modal dialogs, 59–60modeless dialogs, 58
modificationChanged() (QTextEdit ),154,
160
modified() (Spreadsheet ), 77
modiﬁer keys, 164monitoring events, 168–171
,370
most recently used ﬁles, 46 ,54–56
Motif integration, 367Motif style, 8
,47,122
MotifPlus style, 8mouse buttons, 107
,225
mouse cursor, 78 ,123,124,190
mouseDoubleClickEvent() (Cube),212
mouseMoveEvent()
Cube,212
IconEditor ,107
Plotter ,123
mouse position, 48
mousePressEvent()
Cube,212
IconEditor ,106
OvenTimer ,182
Plotter ,123
mouseReleaseEvent()
Plotter ,124
QWidget ,226
mouse tracking, 107mouse wheels, 126
move() (QWidget ), 64
moveDockWindow() (QMainWindow ),152
moveWidget() (QScrollView ),150
movies, 244MRU ﬁles, 46
,54–56
MSGtype, 370
multi-line editors. SeeQTextEditmultimap<K,T> ,251
multi-page dialogs, 32multi-page widgets, 34multiple database connections,
264–265
multiple document interface (MDI), 67
,
152–161
multiple documents, 64–67multiple inheritance, 376
multiset<K> ,251
multithreading, 349–365
mutable keyword, 89 ,91
mutexes, 353mutual exclusion, 34
,45
MySQL, 262
MyTable
copy() ,225
dragObject() ,224
paste() ,225
MyWhatsThis
class deﬁnition, 345
MyWhatsThis() ,345
clicked() ,345
text() ,345
N
name parameter, 12 ,13,385
nameless database connection, 265namespaces
C++,7 2
,115
XML, 307 ,310
native APIs, 367–370native dialogs, 37navigating result sets, 262
,265
nested layouts, 15 ,138
NetBSD, 369networking, 283–305
,364
newoperator, 16 ,48–49 ,64–66 ,346
newConnection() (TripServer ),298
newFile()
Editor ,159
MainWindow ,4 9,65,154
newPage() (QPrinter ),199,201,203
newlines, 234 ,236
newsletter, 10
next() (QSqlQuery ),262–263
nextSibling() (QDomNode ),316
nmake ,5
NoBrush ,177
NoPen ,176
non-blocking operations. See
asynchronous operations
Index 419
non-commercial edition of Qt, 393–394
non-GUI threads, 359non-validating XML parsers, 307
,312
normalize() (QRect ),124
northwest gravity. SeeWStaticContents
NotAndROP ,178
NotROP ,127,178
notify() (QApplication ),171
null strings, 257
numCopies() (QPrinter ),203
numRowsAffected() (QSqlQuery ),263
number() (QString ), 75,98,255
O
ObjectSafety
class deﬁnition, 378
GetInterfaceSafetyOptions() ,378
SetInterfaceSafetyOptions() ,378
objects
event processing, 163–173introspection, 20names, 12
,13,385
parent–child mechanism, 16signals and slots mechanism, 18–21
ODBC, 262
offset() (DiagramLine ),188
one-shot timers, 168 ,182,293
online documentation, 8–10 ,342–347
online help, 339–347opacity, 101
,368–369
OpaqueMode ,178
opaque resizing, 143
open()
Editor ,159
MainWindow ,5 0,154
QFile ,7 8,79,228,230,234,235
OpenBSD, 369OpenGL, 209–214
openRecentFile() (MainWindow ), 55
Open UNIX. SeeUnixWare
operating systems, 369–370
operator()() ,8 7
operator*() (iterators), 246
operator+() (QString ),254
operator++()
iterators, 246
QSemaphore ,354
operator+=()
QSemaphore ,356
QString ,254
operator--()
iterators, 246operator--() (continued)
QSemaphore ,354
operator<() ,244
operator<<() ,143,152,229,235
operator==() ,244
operator>>() ,143,152,231,236
operator[]()
map<K,T> ,250
QMemArray<T> ,253
QValueList<T> ,248
vector<T> ,245,246
Oracle, 262OSF, 369
outputFormatList() (QImage ),239
OvenTimer
class deﬁnition, 180
printing, 199
OvenTimer() ,181
draw() ,183–184 ,199
duration() ,182
mousePressEvent() ,182
paintEvent() ,182,185
setDuration() ,181
timeout() ,180
Oven Timer example, 180–185override cursor, 78
,123
ownership. Seeparent
P
paginate() (PrintWindow ),205
paintCell() (QTable ), 73
paint devices, 175 ,198,204
paintEvent()
IconEditor ,104
OvenTimer ,182,185
Plotter ,121
QWidget ,104,113
Ticker ,167
paintGL() (Cube),211
painter coordinates, 178–179painters. See
QPainter
palette() (QWidget ),105
palettes, 105 ,118,184
parent
of a dialog, 51of a layout, 15of a list view item, 315of a table item, 75of a validator, 26of a widget, 7
,16
of an object, 16
parent parameter, 12 ,13
420 Index
parse() (QXmlSimpleReader ),312
parseEntry() (DomParser ),314
parsers, 92 ,237,307
parsing events, 308
paste()
DiagramView ,193
MyTable ,225
Spreadsheet ,8 1
PATH environment variable, 4 ,347,386,
395,397
peerAddress() (QSocketDevice ),305
peerPort() (QSocketDevice ),305
pending events, 173pens, 175–177percent sign (‘%’), 52
,53,255
physical coordinates, 178–179 ,185
pie segments, 176 ,177
pixmaps. SeeQPixmap
placeholders (SQL), 263–264
platform-speciﬁc APIs, 367–370Platinum style, 8
PlayerWindow
class deﬁnition, 371
PlayerWindow() ,372
timerEvent() ,374
PlotSettings
class deﬁnition, 116
PlotSettings() ,130
adjust() ,130
adjustAxis() ,131
scroll() ,130
spanX() ,116
spanY() ,116
Plotter
class deﬁnition, 115
Plotter() ,117
clearCurve() ,120
drawCurves() ,129
drawGrid() ,128
keyPressEvent() ,125
minimumSizeHint() ,120
mouseMoveEvent() ,123
mousePressEvent() ,123
mouseReleaseEvent() ,124
paintEvent() ,121
refreshPixmap() ,127
resizeEvent() ,122
setCurveData() ,120
setPlotSettings() ,118
sizeHint() ,120
updateRubberBandRegion() ,126
wheelEvent() ,126
zoomIn() ,119
zoomOut() ,119Plotter example, 114–132
plugins, 109PNG ﬁles, 43PNM ﬁles, 43pointer-based containers, 251–253polygonal items, 186polygons, 176
,183,186
polylines, 130 ,176
populate() (ArtistComboBox ),281
popup menus. Seemenus
pos() (QMouseEvent ),106
post() (QHttp ),290
postEvent() (QApplication ),359,363
PostScript, 199
PostgreSQL, 262
preferences, 63–64 ,258
Preferred (QSizePolicy ),118,139
prepare() (QSqlQuery ),263
prepend() (QPtrList<T> ),252
prev() (QSqlQuery ),263
previewing in Qt Designer ,2 5,145
primeDelete() (QSqlCursor ),266
primeInsert()
QDataTable ,270
QSqlCursor ,265,270
primeInsertArtist() (ArtistForm ),270
primeUpdate() (QSqlCursor ),265,278
printBox() (PrintWindow ),207
printCanvas() (PrintWindow ),200
print dialog, 37 ,198
printFlowerGuide() (PrintWindow ),201,
204,208
printImage() (PrintWindow ),201
printOvenTimer() (PrintWindow ),199
printPage() (PrintWindow ),204,207
printRichText() (PrintWindow ),202
PrintWindow
PrintWindow() ,204
entryHeight() ,206
paginate() ,205
printBox() ,207
printCanvas() ,200
printFlowerGuide() ,201,204,208
printImage() ,201
printOvenTimer() ,199
printPage() ,204,207
printRichText() ,202
printer drivers, 199printing, 198–208
.pro ﬁles
creating using qmake ,4
for ActiveX applications, 374 ,379,
383
for console applications, 353
Index 421
.pro ﬁles (continued)
for internationalized applications,
326,334,335
for multithreaded applications, 352for OpenGL applications, 214forQt Designer plugins, 111
for using
QAssistantClient ,346
for using QWidgetFactory ,3 3
processEvents()
QApplication ,172,208
QEventLoop ,172
processExited()
ConvertDialog ,241
QProcess ,241
processes, 239producer–consumer model, 354–358programs. Seeexamples
progress() (QProgressBar ),293
progress bars, 35 ,289,291,293
progress dialogs, 37 ,208,289,291
Project Chooser example, 217–220project ﬁles. See
.dsp ﬁles and.pro
ﬁles
ProjectView
class deﬁnition, 217
ProjectView() ,218
contentsDragEnterEvent() ,219
contentsDropEvent() ,219
contentsMouseMoveEvent() ,218
contentsMousePressEvent() ,218
startDrag() ,219
propagation of events, 165 ,171,216
properties, 20 ,22,100,280
properties() (DiagramView ),194
PropertiesDialog class, 194
property() (QObject ),374
propertyChanged() (QAxBindable ),377
property maps, 278 ,282
proportional resizing, 136protocols. SeeInternet protocols
provides()
QDragEnterEvent ,219,222
QDragMoveEvent ,222
push_back()
list<T> ,248
QValueVector<T> ,245
vector<T> ,245
push buttons, 5 ,14,23,34
put() (QFtp),285Q
Q_ENUMS() macro, 372 ,376
Q_EXPORT_PLUGIN() macro, 111
Q_INT x,7 8,228
Q_OBJECT macro
for meta-object system, 20for properties, 100for signals and slots, 12
,20,40
fortr(),1 3,323,324
Q_OS_ xxx,369
Q_PROPERTY() macro, 100 ,280
Q_UINT x,7 8,228
Q_WS_ xxx,369
QAccel ,165
QAction ,4 4 – 4 5 ,341
compared with key events, 165
activated() ,4 4
addTo() ,4 6,152
setEnabled() ,155
setToggleAction() ,4 5
setToolTip() ,339
setWhatsThis() ,341
toggled() ,4 5
QActionGroup ,4 5
qApp global variable, 46 ,170
QApplication ,3
in console applications, 238subclassing, 385
aboutQt() ,4 6
beep() ,8 3
clipboard() ,8 1,224
closeAllWindows() ,6 6
commitData() ,384,386
exec() ,3,171–172 ,359
hasPendingEvents() ,173
isSessionRestored() ,388,389
lastWindowClosed() ,6 5
macEventFilter() ,370
macVersion() ,370
notify() ,171
postEvent() ,359,363
processEvents() ,172–173 ,208
quit() ,6,65,272
qwsEventFilter() ,370
restoreOverrideCursor() ,7 8,123
reverseLayout() ,328
saveState() ,384
sessionId() ,388
sessionKey() ,388
setColorSpec() ,113
setMainWidget() ,3,64
setOverrideCursor() ,7 8,123
setReverseLayout() ,327
422 Index
QApplication (continued)
startDragDistance() ,218
style() ,122
translate() ,325
winEventFilter() ,370
winVersion() ,370
x11EventFilter() ,370
QAsciiDict<T> ,252
QAssistantClient ,347
QAXAGG_IUNKNOWN macro, 378
QAxAggregated
subclassing, 378
controllingUnknown() ,378
queryInterface() ,378
QAxBase ,372
dynamicCall() ,374
generateDocumentation() ,373
queryInterface() ,375
querySubObject() ,374
QAxBindable
subclassing, 375
createAggregate() ,377
propertyChanged() ,377
requestPropertyChange() ,377
QAxContainer module, 371–375
QAxFactory ,381
classID() ,382
create() ,382
eventsID() ,383
exposeToSuperClass() ,383
featureList() ,382
interfaceID() ,383
QAXFACTORY_DEFAULT() macro, 376 ,379
QAXFACTORY_EXPORT() macro, 381
QAxObject ,372
subclassing, 375
QAxServer module, 371 ,375–384
QAxWidget ,372
subclassing, 375
setControl() ,372
QBrush ,176
QBuffer ,7 8,289,294
QButtonGroup ,3 4
QByteArray ,222,253,282,289,294
QCanvas ,185
printing, 200
collisions() ,190,200
update() ,191
QCanvasEllipse ,186
QCanvasItem ,185
boundingRect() ,196,197
draw() ,200
hide() ,195,196
rtti() ,188,191QCanvasItem (continued)
setActive() ,195
setVelocity() ,198
setZ() ,191
show() ,190
update() ,196
QCanvasLine ,185,188
QCanvasPolygon ,186
QCanvasPolygonalItem ,186,195
areaPoints() ,197
drawShape() ,196
setBrush() ,195
setPen() ,195
QCanvasRectangle ,185,187
QCanvasSpline ,186
QCanvasSprite ,186
QCanvasText ,186
QCanvasView ,186
QChar ,320
is...() functions, 321
latin1() ,320
lower() ,321
unicode() ,320
upper() ,321
QCheckBox ,3 4
QClipboard ,224
Selection ,225
data() ,225
setData() ,225
setText() ,8 1,224
supportsSelection() ,226
text() ,8 2,224
QCloseEvent ,5 3,157,159,352
QColor ,102
QColorDialog ,3 6,212
QColorDrag ,219
QColorGroup ,105
QComboBox ,3 1 – 3 2 ,36
subclassing, 280
currentItem() ,6 1
insertItem() ,3 2,281
qCompress() ,232
QCString ,258
QCursor ,370
QCustomEvent ,361
QDataStream ,7 8
binary format, 79 ,228,231
on a byte array, 294 ,305
on a socket, 291 ,300
supported data types, 227versioning, 79
readRawBytes() ,231
setByteOrder() ,231
setVersion() ,7 9,228,230,231,232
Index 423
QDataStream (continued)
writeRawBytes() ,231
QDataTable ,265,266,277
auto-populate, 268
addColumn() ,268
beforeDelete() ,269,279
beforeInsert() ,270,279
contextMenuEvent() ,270
currentChanged() ,274
currentRecord() ,273
installEditorFactory() ,282
installPropertyMap() ,282
primeInsert() ,270
refresh() ,268,273
setAutoDelete() ,268
setConfirmDelete() ,268
setFilter() ,274
setSort() ,272
QDate ,328
QDateEdit ,3 6,328
QDateTime ,182,328
QDateTimeEdit ,3 6,328
QDB2,262
QDeepCopy<T> ,364,365
QDial ,3 6
QDialog ,1 2
subclassing, 12 ,267,271,275,304,
351
accept() ,2 5,59,269,278
exec() ,5 9
reject() ,2 5,59,269,279
setModal() ,5 9,173
QDict<T> ,252
QDir,237
convertSeparators() ,5 3,238
currentDirPath() ,238
entryList() ,238
exists() ,238
homeDirPath() ,238
mkdir() ,238
rename() ,238
rmdir() ,238
QDns,303
QDockWindow ,151
QDomDocument
createElement() ,316
createTextNode() ,316
documentElement() ,314
setContent() ,314
QDomElement ,313,314
QDomNode ,314
appendChild() ,316
firstChild() ,316
nextSibling() ,316QDomNode (continued)
save() ,316
toElement() ,314
toText() ,315
QDomText ,313,315
QDoubleValidator ,2 6
QDragEnterEvent ,216,219,222,223
QDragMoveEvent ,222,223
QDragObject ,220,223
copying to the clipboard, 225subclassing, 221
drag() ,219
encodedData() ,222
format() ,221
setPixmap() ,219
QDropEvent ,220,223
qembed ,328
QErrorMessage ,3 7
QEvent ,164
QEventLoop ,172
ExcludeUserInput ,172
processEvents() ,172
wakeUp() ,363
qFatal() ,214
QFile ,7 7,289
implicit close, 229implicit open, 312
errorString() ,7 8,79,229
exists() ,238
open() ,7 8,79,228,230,234,235
readAll() ,231–232
remove() ,238
status() ,229
writeBlock() ,231
QFileDialog ,3 7
getOpenFileName() ,5 0,159,240
getSaveFileName() ,5 2
QFileInfo ,5 3,238
qFind() ,246
QFont ,176,370
QFontDialog ,3 6
QFontMetrics ,167
QFrame ,3 4
QFtp,283
in multithreaded applications, 364
abort() ,289
cd(),285,286
close() ,285
commandFinished() ,285
commandStarted() ,285
connectToHost() ,285,286
dataTransferProgress() ,289
done() ,284
get() ,284,285,287
424 Index
QFtp (continued)
list() ,285,286,287
listInfo() ,287
login() ,285,286
mkdir() ,285
put() ,285
rawCommand() ,285
readAll() ,289
readBlock() ,289
readyRead() ,289
remove() ,285
rename() ,285
rmdir() ,285
stateChanged() ,286
qglClearColor() (QGLWidget ),210
QGLColormap ,214
QGLContext ,214
QGLFormat ,214
QGLWidget ,209
initializeGL() ,210
paintGL() ,211
qglClearColor() ,210
resizeGL() ,210
setFormat() ,210
updateGL() ,212
QGrid ,1 6
QGridLayout ,1 5,29,30,137–139
QGroupBox ,3 4
QHBox ,6 – 7,16
QHBoxLayout ,1 5,23,137
QHostAddress ,304
QHttp ,289
in multithreaded applications, 364
dataTransferProgress() ,291
done() ,290
get() ,290
head() ,290
post() ,290
readAll() ,291
readBlock() ,291
readyRead() ,291
request() ,290
requestFinished() ,291
requestStarted() ,291
setHost() ,290
QHttpRequestHeader ,291
QIconView ,3 3,35,73
QIconViewItem ,7 3
QImage ,101,282
compared with QPixmap ,113
printing, 200
convertDepth() ,103
detach() ,103
height() ,108QImage (continued)
mirror() ,363
outputFormatList() ,239
rect() ,108
width() ,108
QImageDrag ,219
QInputDialog ,3 7,191
QIntDict<T> ,252–253
QIntDictIterator<T> ,253
QIntValidator ,2 6
QIODevice ,289,291,294,314
QKeyEvent ,126,164
QLabel ,3,35,57,59
QLayout ,15,137
resize mode, 30
setMargin() ,1 4,138
setSpacing() ,1 5,138
QLCDNumber ,3 5
QLibrary ,368
QLineEdit ,1 3,36
hasAcceptableInput() ,2 5
setBuddy() ,1 3
setFrame() ,7 5
setText() ,7 5
setValidator() ,2 5,98
text() ,7 7
textChanged() ,1 4
QListBox ,3 3,35,73,145,217
QListBoxItem ,7 3
QListView ,3 3,35,73,308,312,316
addColumn() ,312
setResizeMode() ,312
setRootIsDecorated() ,312
QListViewItem ,7 3
subclassing, 380
setOpen() ,310,315
setText() ,310,315
QLocale ,328
QMacStyle ,122
QMainWindow ,4 0
central widget, 43 ,69–70 ,142,152
constituent widgets, 43streaming operators, 152subclassing, 40
,380
bottomDock() ,4 3
centralWidget() ,4 3
leftDock() ,4 3
menuBar() ,4 3,47
moveDockWindow() ,152
rightDock() ,4 3
setCentralWidget() ,4 2
setDockEnabled() ,152
statusBar() ,4 3,57
topDock() ,4 3
Index 425
QMainWindow (continued)
whatsThis() ,341
qmake ,4 – 5,17–18 ,20,25
See also .pro ﬁles
QMap<K,T> ,250
keys() ,251
values() ,251
QMemArray<T> ,253
copy() ,254
find() ,254
operator[]() ,253
resize() ,253
QMenuBar ,4 7
QMessageBox ,3 7
Default ,5 0
Escape ,5 0
about() ,6 2
critical() ,5 0
information() ,5 0
question() ,5 0
warning() ,4 9,52
QMimeSource ,220,223,225
QMIN() macro, 182
QMotifStyle ,122
QMouseEvent ,106,107
QMovie ,244
QMutex ,353
lock() ,353,354
tryLock() ,353
unlock() ,353,354
QMutexLocker ,354
QMYSQL3 ,262
QNX, 369
QObject ,20
reentrancy, 364subclassing, 20–21
,286,380
child() ,3 3
className() ,2 0
connect() ,6,14,18
customEvent() ,360
deleteLater() ,299,300,364
disconnect() ,1 9,20
event() ,164,170,333
eventFilter() ,169,170
installEventFilter() ,169,170
killTimer() ,168
metaObject() ,2 0
property() ,374
setProperty() ,373
startTimer() ,167
timerEvent() ,168,173,303,374
tr(),1 3,20,322,323,331,335
QOCI8 ,262
QODBC3 ,262QPaintDevice ,370
QPaintDeviceMetrics ,204
QPainter ,175–185
coordinate system, 105–106 ,150,
178–179
for printing, 198
boundingRect() ,207
drawArc() ,176
drawChord() ,176
drawConvexPolygon() ,183
drawCubicBezier() ,176
drawEllipse() ,176,177
drawLine() ,104,176,184
drawLineSegments() ,176
drawPie() ,176,177
drawPoints() ,176
drawPolygon() ,176,183
drawPolyline() ,130,176
drawRect() ,121,176,184
drawRoundRect() ,176
drawText() ,129,167,179,184
fillRect() ,106
handle() ,370
restore() ,178
restoreWorldMatrix() ,180
rotate() ,180,184
save() ,178
saveWorldMatrix() ,180
scale() ,180
setBrush() ,176
setClipRect() ,129
setFont() ,176
setPen() ,176
setRasterOp() ,127
setViewport() ,182
setWindow() ,179,182
setWorldMatrix() ,179
shear() ,180
translate() ,180,185
QPalette ,105
QPen,176
QPicture ,370
QPixmap ,113
compared with QImage ,113
for double buffering, 113 ,116,185
fromMimeSource() ,4 4
handle() ,370
QPoint ,105,218
QPointArray ,253
QPopupMenu ,46–48
exec() ,4 8
insertItem() ,4 6,332
insertSeparator() ,4 6,55
setItemParameter() ,5 5,56,156,332
426 Index
QPrintDialog ,3 7,198
QPrinter ,198–208
abort() ,208
handle() ,370
newPage() ,199,201,203
numCopies() ,203
setPrintProgram() ,199
setup() ,198,199
QProcess ,239–241 ,347
addArgument() ,240
processExited() ,241
readyReadStderr() ,240
QProgressBar ,3 5
as busy indicator, 293
canceled() ,289
progress() ,293
setProgress() ,289,291,293
QProgressDialog ,3 7
invoking, 172 ,208
canceled() ,289
setProgress() ,173,289,291
wasCanceled() ,173
QPSQL7 ,262
QPtrDict<T> ,252
QPtrList<T> ,6 7,252
QPtrListIterator<T> ,252
QPtrVector<T> ,251–252
QPushButton ,5,34
subclassing, 302
clicked() ,6,163
setDefault() ,1 3
QRadioButton ,3 4
QRect ,121,124
contains() ,108
normalize() ,124
QRegExp ,2 6,94,98
QRegExpValidator ,2 6,98
QRegion ,113
handle() ,370
rect() ,121
QRgb,102
qRgb() ,102
qRgba() ,101–102
QScrollBar ,3 6,73,145
QScrollView ,3 5 – 3 6 ,74
constituent widgets, 145subclassing, 146
addChild() ,145
addWidget() ,150
contentsContextMenuEvent() ,189
contentsDragEnterEvent() ,219
contentsDropEvent() ,219
contentsMouseDoubleClickEvent() ,
191QScrollView (continued)
contentsMouseMoveEvent() ,149,190,
218
contentsMousePressEvent() ,149,190,
218
cornerWidget() ,145
drawContents() ,148
enableClipper() ,150
horizontalScrollBar() ,7 3,145
moveWidget() ,150
resizeContents() ,148
setHScrollBarMode() ,146
setVScrollBarMode() ,146
sizeHint() ,148
updateContents() ,148,150
verticalScrollBar() ,7 3,145
viewport() ,7 3,145,149,216
QSemaphore ,354
operator++() ,354
operator+=() ,356
operator--() ,354
QServerSocket ,298
QSessionManager ,386
cancel() ,387
handle() ,370
release() ,387
setDiscardCommand() ,386
QSettings ,6 3,143,258
beginGroup() ,6 3
endGroup() ,6 3
readBoolEntry() ,6 4
readListEntry() ,6 4
readNumEntry() ,6 4
setPath() ,6 3
writeEntry() ,6 3
QSimpleRichText ,201–203
QSize ,113,200
QSizePolicy ,102,139
stretch factors, 140
Expanding ,118,139
Fixed ,139
Ignored ,140
Maximum ,139
Minimum ,102,139
MinimumExpanding ,140
Preferred ,118,139
QSlider ,6,36
setRange() ,7
setValue() ,7
valueChanged() ,7
QSocket ,7 8,291,300
in multithreaded applications, 364subclassing, 298
bytesAvailable() ,300
Index 427
QSocket (continued)
canReadLine() ,301
connectToHost() ,293
connected() ,293
connectionClosed() ,297,299
delayedCloseFinished() ,299,300
error() ,293
readLine() ,301
readyRead() ,295,296,300,301
writeBlock() ,295
QSocketDevice ,7 8,283,304
in multithreaded applications, 364
Datagram ,303,304
bind() ,304
peerAddress() ,305
peerPort() ,305
readBlock() ,305
setBlocking() ,303,304
writeBlock() ,303
QSocketNotifier ,304
in multithreaded applications, 364
activated() ,305
QSpinBox ,6,36
subclassing, 97–99
mapTextToValue() ,9 8
mapValueToText() ,9 8
setRange() ,7
setValue() ,7
text() ,9 8
valueChanged() ,7
QSplashScreen ,6 7 – 6 8
QSplitter ,140
streaming operators, 143
KeepSize ,142
setOpaqueResize() ,143
setResizeMode() ,142
setSizes() ,143
sizes() ,248
QSqlCursor ,265,266,275
auto-populate, 268subclassing, 270
,274
ReadOnly ,272
calculateField() ,274,282
del() ,266
insert() ,265
primeDelete() ,266
primeInsert() ,265,270
primeUpdate() ,265,278
select() ,265,277,281
setCalculated() ,274
setGenerated() ,270
setMode() ,272
update() ,265,278
value() ,265QSqlDatabase ,261
addDatabase() ,262,264
commit() ,264,269,278
database() ,264
driver() ,264
rollback() ,264,269,279
setDatabaseName() ,261
setHostName() ,261
setPassword() ,261
setUserName() ,261
transaction() ,264,268,273
QSqlDriver ,264
QSqlEditorFactory ,282
QSqlError ,262,263
QSqlForm ,275
installPropertyMap() ,278
readFields() ,275,278
setRecord() ,278
writeFields() ,275,278
QSQLITEX ,262
QSqlPropertyMap ,275,282
QSqlQuery ,262,265
addBindValue() ,263
at(),263
bindValue() ,263
exec() ,262–264
first() ,263
isActive() ,263
last() ,263
lastError() ,263
next() ,262
numRowsAffected() ,263
prepare() ,263
prev() ,263
seek() ,263
setForwardOnly() ,263
value() ,262
QSqlRecord ,265
QSqlSelectCursor ,271
QStatusBar ,57
addWidget() ,5 7
clear() ,340
message() ,5 1,340
QStoredDrag ,220–221
QString ,254–258
case sensitivity, 256conversion to and from
const char * ,
257–258
null vs. empty, 257Unicode support, 254
,320–323
append() ,254
arg() ,5 2,255,325
ascii() ,257
endsWith() ,256
428 Index
QString (continued)
fromAscii() ,326
insert() ,256
isEmpty() ,257
isNull() ,257
latin1() ,257
left() ,255
length() ,257
localeAwareCompare() ,328
lower() ,256
mid() ,5 9,255
number() ,7 5,98,255
operator+() ,254
operator+=() ,254
remove() ,256
replace() ,223,236,256
right() ,255
setNum() ,255
simplifyWhitespace() ,257
sprintf() ,254
startsWith() ,256
stripWhitespace() ,256
toDouble() ,9 1,255
toInt() ,6 0,98,255
truncate() ,259
upper() ,9 8,256
QStringList ,5 4,249
join() ,257
split() ,8 2,236,257
QStyle ,122
QStyleSheet ,341
escape() ,202,223
Qtclass, 10
Qt 4 features, 73 ,251,254,365
Qt Assistant
browsing the Qt documentation, 9providing online help, 346
Qt Designer
creating dialogs, 21–33creating main windows, 40
,44
launching, 21layouts, 23
,29,30
previewing, 25 ,145
specifying member variables, 28 ,239,
292
splitters, 143templates, 21
,37,99,145
.uiﬁles, 25 ,26,33,194,239
.ui.h ﬁles, 26–28 ,99,194,239,292
using custom widgets, 108–111
Qt editions, 393–394Qt/Embedded, 367–370Qt Linguist ,334–337
QT_NO_CAST_ASCII ,326Qt Quarterly ,1 0,73,132,198,259,317,
364
QT_TR_NOOP() ,325–326
QT_TRANSLATE_NOOP() ,326
QTabWidget ,3 3,34
QTable ,3 5
constituent widgets, 73database-aware subclass, 266drag and drop, 221item ownership, 75subclassing, 71
,224
Single ,7 3,81
cellWidget() ,7 7
clearCell() ,7 3
createEditor() ,7 5
dragObject() ,224
endEdit() ,7 6
horizontalHeader() ,7 3
paintCell() ,7 3
selection() ,8 1
setCurrentCell() ,5 9
setDragEnabled() ,224
setItem() ,7 5
setSelectionMode() ,7 3
setShowGrid() ,4 5
setSorting() ,268
verticalHeader() ,7 3
QTableItem ,7 1,73
ownership, 75subclassing, 88
alignment() ,9 0
text() ,9 0
QTDIR environment variable, 111 ,395,
397
QTDS7 ,262
QTextBrowser ,3 5,342,344
QTextCodec ,321,323
codecForLocale() ,321
codecForName() ,322
locale() ,327
setCodecForCStrings() ,323
setCodecForTr() ,322,335
toUnicode() ,322
QTextDrag ,219
decode() ,220,224
setSubtype() ,219
QTextEdit ,3 6
subclassing, 158
copyAvailable() ,154
isModified() ,160
modificationChanged() ,154,160
setModified() ,160
QTextIStream ,143,193
QTextOStream ,143,222
Index 429
QTextStream ,7 8,234
on a byte array, 222on a socket, 291
read() ,193,236
readLine() ,237
setCodec() ,321
setEncoding() ,235,321
QThread ,349
subclassing, 350 ,361
currentThread() ,358
run() ,350,353,355,357,362
start() ,352
terminate() ,350
wait() ,352
QThreadStorage<T> ,358
hasLocalData() ,358
localData() ,358
setLocalData() ,358
QTime ,328
QTimeEdit ,3 6,328
QTimer ,168
compared with timer events, 168in multithreaded applications, 364single-shot, 168
,182,293
start() ,182
timeout() ,168,181,293
QToolBar ,4 7 – 4 8 ,150–152
QToolBox ,3 4
QToolTip ,339–340
QToolTipGroup ,340
QTranslator ,327
queries, 262
QueryInterface() (IUnknown ),378
queryInterface()
QAxAggregated ,378
QAxBase ,375
querySubObject() (QAxBase ),374
question() (QMessageBox ), 50
quit() (QApplication ), 6,65,272
Quit example, 5–6
qUncompress() ,232
QUriDrag ,219
canDecode() ,216–217
decodeLocalFiles() ,217
QUrl,286
QUrlInfo ,287
QValidator ,2 6
QValueList<T> ,248
streaming operators, 229 ,231
operator[]() ,248
QValueVector<T> ,245,254
append() ,245
push_back() ,245QVariant ,8 9,100,258–260 ,262,373
isValid() ,9 0
toString() ,9 0
type() ,9 0,259
QVBox ,1 6
QVBoxLayout ,1 5,23,137
QWaitCondition ,356
wait() ,357
wakeAll() ,357
QWhatsThis ,345
add() ,340,346
clicked() ,345
text() ,345
QWheelEvent ,126
QWidget ,10
subclassing, 100 ,115,166,180,342,
371,375,387
adjustSize() ,118
close() ,1 4,53
closeEvent() ,4 0,53,157,159,352,
387
colorGroup() ,105,121
contextMenuEvent() ,4 0,48
dragEnterEvent() ,216
dragLeaveEvent() ,217
dragMoveEvent() ,217
dropEvent() ,217
find() ,367
focusNextPrevChild() ,169,170
fontMetrics() ,160,167
handle() ,370
hide() ,3 1,119
hideEvent() ,168
keyPressEvent() ,125,164,168
keyReleaseEvent() ,164
macEvent() ,370
minimumHeight() ,136
minimumSizeHint() ,120,140
minimumWidth() ,136
mouseDoubleClickEvent() ,212
mouseMoveEvent() ,107,123,212
mousePressEvent() ,106,123,182,212
mouseReleaseEvent() ,124,226
move() ,6 4
paintEvent() ,104,113,121,167,182,
185
palette() ,105
qwsEvent() ,370
raise() ,5 8
repaint() ,104
resize() ,6 4,136
resizeEvent() ,122,136
scroll() ,168
setAcceptDrops() ,216,218
430 Index
QWidget (continued)
setActiveWindow() ,5 8,83
setBackgroundMode() ,118,128
setCaption() ,7
setCursor() ,123,190
setEnabled() ,1 3,17,25
setFixedSize() ,136
setFocus() ,157
setFocusPolicy() ,118
setGeometry() ,136
setIcon() ,4 3
setMinimumSize() ,3 2,57,136
setMouseTracking() ,107
setShown() ,3 1
setSizePolicy() ,102,118,373
setStyle() ,122
setTabOrder() ,1 8
setWFlags() ,158
show() ,3,58–59 ,119
showEvent() ,167
sizeHint() ,3 2,57,102,120,140,160,
167
style() ,122
unsetCursor() ,124,190
update() ,103,104,119,148,167,168
updateGeometry() ,103,147,167
wheelEvent() ,126
winEvent() ,370
winId() ,367,370
x11Event() ,370
QWidgetFactory ,3 3
QWidgetList ,6 7
QWidgetPlugin ,109
create() ,110
group() ,110
iconSet() ,111
includeFile() ,110
isContainer() ,110
keys() ,110
toolTip() ,111
whatsThis() ,111
QWidgetStack ,3 3,144
QWindowsStyle ,122
QWindowsXPStyle ,122
QWizard ,3 7 – 3 8
QWMatrix ,179
QWorkspace ,152
activeWindow() ,155
cascade() ,156
closeActiveWindow() ,156
closeAllWindows() ,156
tile() ,156
windowActivated() ,154
windowList() ,156QWS, 369
QWSEvent ,370
qwsEvent() (QWidget ),370
qwsEventFilter() (QApplication ),370
QXmlContentHandler ,308
characters() ,310
endDocument() ,308
endElement() ,311
startDocument() ,308
startElement() ,310
QXmlDeclHandler ,308
QXmlDefaultHandler ,308,309
QXmlDTDHandler ,308
QXmlEntityResolver ,308
QXmlErrorHandler ,308
errorString() ,310
fatalError() ,311
QXmlLexicalHandler ,308
QXmlSimpleReader ,307,308,312
parse() ,312
setContentHandler() ,312
setErrorHandler() ,312
R
radio buttons, 34
raise() (QWidget ), 58–59
raiseWidget() (QWidgetStack ),144
range controls, 36raster operations, 127
,178
rawCommand() (QFtp),285
.rcﬁles, 379 ,383
read() (QTextStream ),193,236
readAll()
QFile ,231
QFtp,289
QHttp ,291
readBlock()
QFtp,289
QHttp ,291
QSocketDevice ,305
readBoolEntry() (QSettings ), 64
readClient() (ClientSocket ),299
readFields() (QSqlForm ),275,278
readFile() (Spreadsheet ), 79
readFromStream() (Gallery ),231
readFromString() (Gallery ),237
readLine()
QSocket ,301
QTextStream ,237
readListEntry() (QSettings ), 64
readNumEntry() (QSettings ), 64
ReadOnly (QSqlCursor ),272
Index 431
readRawBytes() (QDataStream ),231
readSettings()
MailClient ,143
MainWindow ,6 3
readyRead()
QFtp,289
QHttp ,291
QSocket ,295,296,300,301
readyReadStderr() (QProcess ),240
recalculate() (Spreadsheet ), 84
recently opened ﬁles, 46 ,54–56
rect()
QImage ,108
QRegion ,121
rectangles, 124recursive-descent parsers, 92reentrancy, 363–364reference counting, 259reference documentation, 8–10
refresh()
ArtistComboBox ,280
QDataTable ,268,273
refreshPixmap() (Plotter ),127
Region type, 370
regions, 113registry, 63
-regserver option, 381
regular expressions, 26 ,94,98
reject()
ArtistForm ,269
CdForm ,279
QDialog ,2 5,59
Release() (IUnknown ),375,378
release() (QSessionManager ),387
Reliant UNIX, 369
remove()
QFile ,238
QFtp,285
QString ,256
removeTip() (QToolTipGroup ),340
rename()
QDir,238
QFtp,285
repaint() (QWidget ),104
repainting, 103 ,104,108
reparenting, 16 ,57,145
replace() (QString ),223,236,256
request() (QHttp ),290
requestFinished() (QHttp ),291
requestPropertyChange() (QAxBindable ),
377
requestStarted() (QHttp ),291
resize()
QMemArray<T> ,253resize() (continued)
QWidget ,6 4,136
resizeContents()
ImageEditor ,148
QScrollView ,148
resizeEvent()
FindFileDialog ,136
Plotter ,122
resizeGL() (Cube),210
resize handles, 198
resizeMode property ( QLayout ), 30
ResizeTransaction class, 362
resizing, 30 ,108,136–137 ,143
resolution (of a paint device), 179 ,200,
204
resolve() (QLibrary ),368
resource ﬁles, 367
restart command, 386
restore() (QPainter ),178
restoreOverrideCursor() (QApplication ),
78,123
restoreState() (TicTacToe ),389
restoreWorldMatrix() (QPainter ),180
restoring settings, 63 ,143,152
retranslateStrings()
JournalView ,334
MainWindow ,331
reverseLayout() (QApplication ),328
reverse layouts, 15 ,170,327,328
RGB model, 101
RgnHandle type, 370
rich text, 35 ,201–203
See also HTML
right() (QString ),255
rightDock() (QMainWindow ), 43
right mouse button, 40 ,107,212
right-to-left languages, 15 ,327,328
rmdir()
QDir,238
QFtp,285
rollback() (QSqlDatabase ),264,269,279
rotate() (QPainter ),180,184
RoundCap ,177
RoundJoin ,177
round rectangles, 176RTTI, 188
rtti() (QCanvasItem ),188,191
rubber bands, 114 ,121–122 ,123–125 ,
127
run()
Thread ,350,353
TransactionThread ,362
running applications, 4
432 Index
running external programs, 239
run-time type identiﬁcation, 188
S
sample programs. Seeexamples
save()
Editor ,159
MainWindow ,5 1,155
QDomNode ,316
QPainter ,178
saveAs() (MainWindow ), 52
saveBinary() (Gallery ),228
saveFile() (MainWindow ), 51
saveState()
Application ,385
QApplication ,384
TicTacToe ,388
saveToString() (Gallery ),236
saveWorldMatrix() (QPainter ),180
SAX, 307–312SAX Handler
,SaxHandler
class deﬁnition, 309
example, 308–312inheritance tree, 308
SaxHandler() ,310
characters() ,310
endElement() ,311
fatalError() ,311
startElement() ,310
scale()
QPainter ,180
QSize ,200
SCO OpenServer, 369
scroll()
PlotSettings ,130
QWidget ,168
scroll bars, 35–36 ,73,145
scroll views, 35–36 ,74
adding child widgets, 145constituent widgets, 145coordinate systems, 149enabling the clipper, 150subclassing
QScrollView ,146–150
SDI, 67
second member ( map<K,T> iterators),
130,250
seek() (QSqlQuery ),263
select() (QSqlCursor ),265,277,281
SELECT statement, 262 ,265
selectAll() (Spreadsheet ), 83
selectColumn() (Spreadsheet ), 83
selectRow() (Spreadsheet ), 83Selection (QClipboard ),225
selection()
QTable ,8 1
Spreadsheet ,8 1
semaphores, 354–356Semaphores example, 354–356semi-transparency, 101
,368–369
sendRequest() (TripPlanner ),294
sendToBack() (DiagramView ),192
separators
in ﬁle names, 53 ,238
in menu bars, 47in menus, 46in toolbars, 47
-session option, 386 ,388
sessionFileName() (TicTacToe ),388
sessionId() (QApplication ),388
sessionKey() (QApplication ),388
session management, 384–389
set<K> ,251
setAcceptDrops() (QWidget ),216,218
setActive() (QCanvasItem ),195
setActiveItem() (DiagramView ),194
setActiveWindow() (QWidget ), 58–59,83
setArtistId() (ArtistComboBox ),281
setAutoDelete()
QDataTable ,268
QPtrVector<T> ,252
setAutoRecalculate() (Spreadsheet ), 85
setBackgroundMode() (QWidget ),118,128
setBlocking() (QSocketDevice ),303,304
setBrush()
QCanvasPolygonalItem ,195
QPainter ,176
setBuddy() (QLineEdit ), 13
setByteOrder() (QDataStream ),231
setCalculated() (QSqlCursor ),274
setCaption() (QWidget ), 7
setCentralWidget() (QMainWindow ), 42
setClipRect() (QPainter ),129
setCloseMode() (QDockWindow ),151
setCodec() (QTextStream ),321
setCodecForCStrings() (QTextCodec ),323
setCodecForTr() (QTextCodec ),322,335
setColor() (AxBouncer ),377
setColorSpec() (QApplication ),113
setColumnRange() (SortDialog ), 31
setConfirmDelete() (QDataTable ),268
setContent() (QDomDocument ),314
setContentHandler() (QXmlSimpleReader ),
312
setControl() (QAxWidget ),372
setCurrentCell() (QTable ), 59
Index 433
setCurrentFile()
Editor ,160
MainWindow ,5 3
setCursor() (QWidget ),123,190
setCurveData() (Plotter ),120
setData()
Gallery ,232
QClipboard ,225
setDatabaseName() (QSqlDatabase ),261
setDefault() (QPushButton ), 13
setDirty() (Cell), 90
setDiscardCommand() (QSessionManager ),
386
setDockEnabled() (QMainWindow ),152
setDragEnabled() (QTable ),224
setDuration() (OvenTimer ),181
setEnabled()
QAction ,155
QWidget ,1 3,17,25
setEncoding() (QTextStream ),235,321
setErrorHandler() (QXmlSimpleReader ),
312
setFilter() (QDataTable ),274
setFixedSize() (QWidget ),136
setFocus() (QWidget ),157
setFocusPolicy() (QWidget ),118
setFont() (QPainter ),176
setFormat() (QGLWidget ),210
setFormula()
Cell,8 9
Spreadsheet ,7 5
setForwardOnly() (QSqlQuery ),263
setFrame() (QLineEdit ), 75
setGenerated() (QSqlCursor ),270
setGeometry() (QWidget ),136
setHScrollBarMode() (QScrollView ),146
setHost() (QHttp ),290
setHostName() (QSqlDatabase ),261
setIcon() (QWidget ), 43
setIconImage() (IconEditor ),103
setImage() (ImageEditor ),148
setImagePixel()
IconEditor ,107
ImageEditor ,149
SetInterfaceSafetyOptions()
(ObjectSafety ),378
setItem() (QTable ), 75
setItemParameter() (QPopupMenu ), 55,56,
156–157 ,332
setLocalData() (QThreadStorage<T> ),358
setMainWidget() (QApplication ), 3,64
setMargin()
QHBox ,7
QLayout ,1 4,138setMinimumSize() (QWidget ), 32,57,136
setModal() (QDialog ), 59,173
setMode() (QSqlCursor ),272
setModified() (QTextEdit ),160
setMouseTracking() (QWidget ),107
setNum() (QString ),255
setOpaqueResize() (QSplitter ),143
setOpen() (QListViewItem ),310,315
setOrientation() (QDockWindow ),152
setOverrideCursor() (QApplication ), 78,
123
setPassword() (QSqlDatabase ),261
setPath() (QSettings ), 63
setPen()
QCanvasPolygonalItem ,195
QPainter ,176
setPenColor() (IconEditor ),102
setPixmap() (QDragObject ),219
setPlotSettings() (Plotter ),118
setPrintProgram() (QPrinter ),199
setProgress()
QProgressBar ,289,291,293
QProgressDialog ,173,289,291
setProperty() (QObject ),373
setRange()
QSlider ,7
QSpinBox ,7
setRasterOp() (QPainter ),127
setRecord() (QSqlForm ),278
setResizeEnabled() (QDockWindow ),152
setResizeMode()
QListView ,312
QSplitter ,142
setReverseLayout() (QApplication ),327
setRootIsDecorated() (QListView ),312
setSelectionMode() (QTable ), 73
setShowGrid() (QTable ), 45
setShown() (QWidget ), 31
setSizePolicy() (QWidget ),102,118,373
setSizes() (QSplitter ),143
setSort() (QDataTable ),272
setSorting() (QTable ),268
setSpacing()
QHBox ,7
QLayout ,1 5,138
setStyle() (QWidget ),122
setSubtype() (QTextDrag ),219
setTabOrder() (QWidget ), 18
setText()
DiagramBox ,196
QClipboard ,8 1,224
QLabel ,5 7
QLineEdit ,7 5
QListViewItem ,310,315
434 Index
setText() (continued)
Ticker ,167
setToggleAction() (QAction ), 45
setToolTip() (QAction ),339
setUserName() (QSqlDatabase ),261
setVScrollBarMode() (QScrollView ),146
setValidator() (QLineEdit ), 25,98
setValue()
QSlider ,7
QSpinBox ,7
QSqlRecord ,265
setVelocity() (QCanvasItem ),198
setVersion() (QDataStream ), 79,228,230,
231,232–234
setViewport() (QPainter ),182
setWFlags() (QWidget ),158
setWhatsThis() (QAction ),341
setWidget() (QDockWindow ),152
setWindow() (QPainter ),179,182
setWorldMatrix() (QPainter ),179
setZ() (QCanvasItem ),191
setZoomFactor() (IconEditor ),103
settings, 63–64 ,143,152,258
setup() (QPrinter ),198,199
SGI style, 8shape-changing dialogs, 28–33shared classes, 103
,249,254,258–259 ,
364
shear() (QPainter ),180
Shiftkey, 107 ,164
Shift-JIS, 323
SHLIB_PATH environment variable, 397
shortcut keys, 44 ,156
See also accelerator keys
show()
QCanvasItem ,190
QWidget ,3,58,119
showEvent() (Ticker ),167
showMessage() (QSqlError ),262,263
showNewItem() (DiagramView ),194
showPage() (HelpBrowser ),344,347
showTip() (QToolTipGroup ),340
shutdown, 384 ,387
signals and slots
compared with events, 163connecting, 6–8
,18–19 ,24
declaring, 12 ,18
disconnecting, 19emitting signals, 17establishing connections in Qt
Designer ,2 5
,32
implementing slots, 17 ,21
in multithreaded applications, 364 ,
365signals and slots (continued)
parameter types, 19return values for slots, 41
SIGNAL() andSLOT() macros, 6 ,19
signals andslots pseudo-keywords,
12,20
simplifyWhitespace() (QString ),257
Single (QTable ), 73,81
single document interface (SDI), 67single-shot timers, 168
,182,293
size() (container classes), 248
sizeHint property ( QSpacerItem ), 30
sizeHint()
Editor ,160
IconEditor ,102
Plotter ,120
QScrollView ,148
QWidget ,3 2,57,140
Ticker ,167
size hints, 32 ,57,102,103,118,137,
139–140
size policies, 102 ,118,139
sizes() (QSplitter ),248
slash (‘/’), 53 ,63,238
sliders, 6 ,36
slots
connecting to a signal, 6–8 ,18–19 ,
24
declaring, 12 ,18
disconnecting, 19establishing connections in Qt
Designer ,2 5
,32
implementing, 17 ,21
parameter types, 19
SLOT() macro, 6 ,19
slots pseudo-keyword, 13 ,20
SmcConn type, 370
sockets. SeeQSocket
Solaris, 369
SolidLine ,176
SolidPattern ,177
somethingChanged() (Spreadsheet ), 77
sort()
MainWindow ,6 0
Spreadsheet ,8 5
STL, 88 ,247
SortDialog
creating using Qt Designer ,2 8 – 3 2
invocation, 60 ,61
init() ,3 1
setColumnRange() ,3 1
Sort example, 28–32 ,60
source() (QDropEvent ),220
Space key, 168
Index 435
spacer items, 15 ,22,30
spaces (in strings), 256–257spacing (in layouts), 7
,138
spanX() (PlotSettings ),116
spanY() (PlotSettings ),116
specializing. Seesubclassing
spin boxes, 6 ,36,97–99
splash screens, 67–68splines, 176
,178,186
split() (QStringList ), 82,236,257
splitters, 140–143 ,152
Spreadsheet
class deﬁnition, 71
inheritance tree, 70
Spreadsheet() ,7 3
autoRecalculate() ,7 1
cell() ,7 4
clear() ,7 3
copy() ,8 0
createEditor() ,7 5
currentFormula() ,7 5
currentLocation() ,7 5
cut() ,8 0
del() ,8 2
endEdit() ,7 6
findNext() ,8 3
findPrev() ,8 4
formula() ,7 4
modified() ,7 7
paste() ,8 1
readFile() ,7 9
recalculate() ,8 4
selectAll() ,8 3
selectColumn() ,8 3
selectRow() ,8 3
selection() ,8 1
setAutoRecalculate() ,8 5
setFormula() ,7 5
somethingChanged() ,7 7
sort() ,8 5
writeFile() ,7 7,172
SpreadsheetCompare class, 60 ,86–88
Spreadsheet example, 39–68 ,69–95
spreadsheetModified() (MainWindow ), 57
sprintf() (QString ),254
SQL, 261–282SQLite, 262
,393
Square class, 87
SquareCap ,177
stable_sort() (STL), 86 ,88
stack memory, 48–49 ,60,64
standard dialogs, 36–38Standard Template Library, 243–251standard widgets, 33–36start()
QThread ,352
QTimer ,182
startDocument() (QXmlContentHandler ),
308
startDrag() (ProjectView ),219
startDragDistance() (QApplication ),218
startElement() (SaxHandler ),310
startOrStopThreadA() (ThreadForm ),352
startTimer() (QObject ),167
startsWith() (QString ),256
state()
QKeyEvent ,126,164
QMouseEvent ,107
stateChanged() (QFtp),286
status() (QFile ),229
statusBar() (QMainWindow ), 43,57
status bars, 43 ,51,56–58 ,157,339–340 ,
363
status tips, 44 ,56,339–340
stdnamespace, 72 ,115
STL, 243–251
stop() (Thread ),350,353–354
stopSearch() (TripPlanner ),297
streaming, 227–237stretch factors, 57
,140
stretches. Seespacer items
string class, 254
strings, 254–258
stripWhitespace() (QString ),256
strippedName() (MainWindow ), 53
style()
QApplication ,122
QWidget ,122
-style option, 8
styles, 8 ,47,122
subclassing
built-in widgets, 97–99COM interfaces, 378Qt Designer forms, 27
QApplication ,385
QAxAggregated ,378
QAxBindable ,375
QAxFactory ,381
QAxObject ,375
QAxWidget ,375
QCanvasLine ,188
QCanvasRectangle ,187
QCanvasView ,186
QComboBox ,280
QCustomEvent ,361
QDialog ,1 2,267,271,275,304,351
QDragObject ,221
QGLWidget ,209
436 Index
subclassing (continued)
QListBox ,217
QListViewItem ,380
QMainWindow ,4 0,380
QObject ,2 0 – 2 1 ,286,380
QPushButton ,302
QScrollView ,146
QServerSocket ,298
QSocket ,298
QSpinBox ,9 7 – 9 9
QSqlEditorFactory ,282
QTable ,7 1,224
QTableItem ,8 8
QTextEdit ,158
QThread ,350,361
QWhatsThis ,345
QWidget ,100,115,166,180,342,371,
375,387
QWidgetPlugin ,109
QXmlDefaultHandler ,309
sub-layouts, 15 ,138
submenus, 46 ,55
supportsSelection() (QClipboard ),226
switchToLanguage() (MainWindow ),332
Sybase Adaptive Server, 262synchronizing threads, 353–358synchronous operations, 364
See also asynchronous operations
Syriac, 320system registry, 63
T
Tabkey, 118 ,164
tab order, 18 ,24,164
tab widgets, 33 ,34
table cells, 71tables. See
QTable
“tabs and newlines” format, 81 ,221,
223
tagName() (QDomElement ),314
Tamil, 320
taskbar, 51Tcl/Tk integration, 367TCP, 283
,291–301
TDS, 262Telugu, 320
template classes. Seecontainer classes
templates ( Qt Designer ), 21
,37,99,145
terminate() (QThread ),350
text()
Cell,9 0
MyWhatsThis ,345text() (continued)
QClipboard ,8 2,224
QLabel ,5 9
QLineEdit ,7 7
QSpinBox ,9 8
text browsers, 35
textChanged() (QLineEdit ), 14
text editors, 36text encodings, 222
,224,234,317,
319–323
text engine, 201–203 ,320
text I/O, 234–237 ,291,301
Thaana, 320Thai, 320theme engines, 8
Thread
class deﬁnition, 350
Thread() ,350
run() ,350,353
stop() ,350,353
-thread option, 352
ThreadForm
class deﬁnition, 351
ThreadForm() ,351
closeEvent() ,352
startOrStopThreadA() ,352
thread-local storage, 358thread-safety, 363thread synchronization, 353–358Threads example, 349–353three-button mice, 225three-dimensional graphics, 209–214Tibetan, 320
TicTacToe
class deﬁnition, 387
TicTacToe() ,388
clearBoard() ,388
restoreState() ,389
saveState() ,388
sessionFileName() ,388
Tic-Tac-Toe example, 384–389
Ticker
class deﬁnition, 166
Ticker() ,166
hideEvent() ,168
paintEvent() ,167
setText() ,167
showEvent() ,167
sizeHint() ,167
timerEvent() ,168
Ticker example, 165–168
tile() (QWorkspace ),156
time, 182time editors, 36
,328
Index 437
timeout()
OvenTimer ,180
QTimer ,168,181,293
timerEvent()
PlayerWindow ,374
QObject ,173
Ticker ,168
WeatherBalloon ,303
timer events, 165–168timers
0-millisecond, 173in multithreaded applications, 364single-shot, 168
,182,293
timerEvent() vs.QTimer ,168
TIS-620, 323title bars, 4
,7
TLS (thread-local storage), 358
toCsv() (CellDrag ),222
toDouble() (QString ), 91,255
toElement() (QDomNode ),314
toHtml() (CellDrag ),223
toInt() (QString ), 60,98,255
toString()
QDate ,328
QDateTime ,328
QTime ,328
QVariant ,9 0
toText() (QDomNode ),315
toUnicode() (QTextCodec ),322
toggle actions, 45toggle buttons, 34
,45
toggle menu items, 45 ,156
toggled() (QAction ), 45
toolbars, 44 ,47–48 ,150–152
toolbox ( Qt Designer ), 22
toolboxes, 34tool palettes, 152
toolTip() (IconEditorPlugin ),111
tooltips, 111 ,339,340
topDock() (QMainWindow ), 43
top-level widgets, 4 ,51
tr() (QObject ), 13,20,322,323–326 ,331,
335
tracking mouse moves, 107
Transaction
class deﬁnition, 362
apply() ,363
messageStr() ,363
transaction() (QSqlDatabase ),264,268,
273
TransactionStartEvent class, 361
TransactionThread
class deﬁnition, 361
addTransaction() ,361TransactionThread (continued)
run() ,362
transformations, 105 ,179–180
translate()
QApplication ,325
QPainter ,180,185
translating applications, 13 ,319,
323–328 ,334–337
TRANSLATIONS entry (.pro ﬁles), 334
transparency, 101 ,106,368–369
TransparentMode ,178
traversing directories, 237–238
TripPlanner
init() ,292
advanceProgressBar() ,293
closeConnection() ,296
connectToServer() ,293
connectionClosedByServer() ,297
connectionTimeout() ,297
error() ,297
sendRequest() ,294
stopSearch() ,297
updateListView() ,295
Trip Planner example, 292–298
TripServer
class deﬁnition, 298
TripServer() ,298
newConnection() ,298
Trip Server example, 292 ,298–301
Tru64 UNIX. SeeOSF
TRUE constant, 14
truncate() (QString ),259
tryLock() (QMutex ),353
TSCII, 323TSD (thread-speciﬁc data), 358two-dimensional graphics, 175–214
type()
QEvent ,164
QVariant ,9 0,259
U
UCS-2 (UTF-16), 224 ,321,323
UDP, 283 ,301–305
UI builder. See Qt Designer
.uiﬁles, 25 ,26,33,194,239
.ui.h ﬁles, 26–28 ,99,194,239,292
uic,2 5,28,33,44,239,334
Ultrix, 369Unicode, 234
,235,254,264,319–323
unicode() (QChar ),320
uniform resource locators (URLs), 286
438 Index
universal resource identiﬁers (URIs),
217
Unix, 367–370 ,397–398
UnixWare, 369
unlock() (QMutex ),353,354
-unregserver option, 381
unsetCursor() (QWidget ),124,190
untitled documents, 158
update()
QCanvas ,191
QCanvasItem ,196
QSqlCursor ,265,278
QWidget ,103,104,119,148,167,168
UPDATE statement, 265
updateCaption() (HelpBrowser ),344
updateCellIndicators() (MainWindow ), 57
updateContents() (QScrollView ),148,
150
updateGeometry() (QWidget ),103,147,
167
updateGL() (QGLWidget ),212
updateListView() (TripPlanner ),295
updateMenus() (MainWindow ),155
updateModIndicator() (MainWindow ),157
updateOutputTextEdit() (ConvertDialog ),
241
updateRecentFileItems() (MainWindow ),
54
updateRubberBandRegion() (Plotter ),
126–127
upper()
QChar ,321
QString ,9 8,256
URIs, 217URLs, 286user actions, 4
,5,163
user interface compiler ( uic), 25,28,33,
44,239,334
using namespace directive, 72
UTF-8, 224 ,235,317,321,323
UTF-16 (UCS-2), 224 ,321,323
V
validating XML parsers, 307 ,312
validators, 26 ,98
value()
Cell,9 1
QSqlCursor ,265
QSqlQuery ,262
value binding (SQL), 263–264
valueChanged()
QSlider ,7valueChanged() (continued)
QSpinBox ,7
values() (QMap<K,T> ),251
variants, 89 ,100,258–260 ,262,373
vector<T> ,245
iterators, 246
erase() ,247
insert() ,247
operator[]() ,245,246
push_back() ,245
vectors, 243–247 ,251–252
VerPattern ,177
version of data stream, 79 ,228,230,
232–234
version of operating system, 370version of Qt, 4
,393
verticalHeader() (QTable ), 73
vertical layouts, 15 ,23,137
verticalScrollBar() (QScrollView ), 73,
145
Vietnamese, 320
viewport
of a painter, 178–179 ,182–184 ,185,
199
of a scroll view, 73 ,145,147,149
viewport() (QScrollView ), 73,145,149,
216
visible widgets, 4 ,59,119
Visual Basic, 380
Visual C ++,4,18
Visual Studio, 5
volatile keyword, 350
W
W3C, 312
wait()
QThread ,352
QWaitCondition ,357
wait conditions, 356–358
Wait Conditions example, 356–358
wait cursor, 78
wakeAll() (QWaitCondition ),357
wakeUp() (QEventLoop ),363
warning() (QMessageBox ), 49–50,52
wasCanceled() (QProgressDialog ),173
WDestructiveClose ,6 6,158,344
WeatherBalloon
class deﬁnition, 302
WeatherBalloon() ,302
timerEvent() ,303
Weather Balloon example, 302–304
Index 439
WeatherStation
class deﬁnition, 304
WeatherStation() ,304
dataReceived() ,305
Weather Station example, 302 ,
304–305
WFlags .Seeﬂags
WGroupLeader ,343
whatsThis()
IconEditorPlugin ,111
QMainWindow ,341
What’s This?, 111 ,340–341 ,344
wheelEvent() (Plotter ),126
whitespace, 256–257widget stacks, 33
,144
widgets
built-in, 33–36 ,69,99
coordinate system, 105 ,107,125
custom, 97–132 ,278
disabled, 14 ,105,170
ﬁxed size, 140ﬂags. Seeﬂags
focus policy, 118geometry, 136hidden, 4
,59,139
maximum size, 137 ,140
minimum size, 137 ,140
names, 12 ,13,385
palette, 105 ,118,184
platform-speciﬁc ID, 367properties, 20
,22,100,280
size hint, 32 ,57,102,103,118,137,
139–140
size limit, 150size policy, 102
,118,139
styles, 8 ,47,122
top-level, 4 ,51
See also windows
width() (QImage ),108
Win32 API, 368 ,369
Win64 API, 369
winEvent() (QWidget ),370
winEventFilter() (QApplication ),370
winId() (QWidget ),367,370
winVersion() (QApplication ),370
window (of a painter), 178–179 ,
182–184 ,199
windowActivated() (QWorkspace ),154
windowList() (QWorkspace ),156
window managers, 384windows
active, 59
,105,154
caption, 7 ,151
closing, 4 ,14windows (continued)
icon, 43MDI children, 152platform-speciﬁc ID, 367title bar, 4
,7
See also widgets
Windows (Microsoft)
classic style, 8 ,47,122
hibernation, 384installing Qt, 394–395Media Player, 371native APIs, 367–370
registry, 63
versions, 370XP style, 8
,122
Windows menus (MDI), 152 ,156–157
wizards, 37
WNoAutoErase ,112,117,118,147,185
world matrix, 178 ,179–180
World Wide Web Consortium, 312
writeBlock()
QFile ,231
QSocket ,295
QSocketDevice ,303
writeEntry() (QSettings ), 63
writeFields() (QSqlForm ),275,278
writeFile() (Spreadsheet ), 77,172
writeRawBytes() (QDataStream ),231
writeSettings()
MailClient ,143
MainWindow ,6 3
writeToStream() (Gallery ),229
writing systems, 319 ,320
WStaticContents ,101,108,112,147
X
X11
installing Qt, 397–398native APIs, 367–370selection clipboard, 225session management, 384–389
x11Display() (QPaintDevice ),370
x11Event() (QWidget ),370
x11EventFilter() (QApplication ),370
x11Screen() (QPaintDevice ),370
XBM ﬁles, 43
XEvent type, 370
XML
reading documents, 307–316SAX vs. DOM, 307
.uiﬁles, 27
validation, 307 ,312
440 Index
XML (continued)
writing documents, 316–317
XorROP ,127,178
XP style, 8 ,122
XPM ﬁles, 43
xsm,389
Xt integration, 367
Z
zcoordinate of canvas items, 191 ,200
zlib, 232
zoomIn() (Plotter ),119
zoomOut() (Plotter ),119

Articles
Keep your edge with thousands of free articles, in-depth
features, interviews, and IT reference recommendations –
all written by experts you know and trust.
Online Books
Answers in an instant from InformIT Online Book’s 600+
fully searchable on line books. Sign up now and get your
first 14 days free .
Catalog
Review online sample chapters, author biographies and
customer rankings and choose exactly the right book from
a selection of over 5,000 titles. www.informit.com
YOUR GUIDE TO IT REFERENCE
Informit 7x9.25  8/7/02  8:22 AM  Page 1
Wouldn’t it be great
if the world’s leading technical 
publishers joined forces to deliver 
their best tech books in a common 
digital reference platform?
They have. Introducing 
InformIT Online Books 
powered by Safari.
■ Specific answers to specific questions.
InformIT Online Books’ powerful search engine gives you relevance-
ranked results in a matter of seconds.
■ Immediate results.
With InformIt Online Books, you can select the book you want
and view the chapter or section you need immediately .
■ Cut, paste and annotate.
Paste code to save time and eliminate typographical errors.
Make notes on the material you find useful and choose whether
or not to share them with your work group.
■ Customized for your enterprise.
Customize a library for you, your department or your entireorganization. You only pay for what you need.
informit.com/onlinebooks Get your first 14 days FREE!
InformIT Online Books is offering its members a 10 book subscription risk-free for
14 days. Visit http://www.informit.com/onlinebooks for details.
Online BooksWouldn’t it be great
if the world’s leading technical 
publishers joined forces to deliver 
their best tech books in a common 
digital reference platform?
They have. Introducing 
InformIT Online Books 
powered by Safari.
■ Specific answers to specific questions.
InformIT Online Books’ powerful search engine gives you relevance-
ranked results in a matter of seconds.
■ Immediate results.
With InformIt Online Books, you can select the book you want
and view the chapter or section you need immediately .
■ Cut, paste and annotate.
Paste code to save time and eliminate typographical errors.
Make notes on the material you find useful and choose whether
or not to share them with your work group.
■ Customized for your enterprise.
Customize a library for you, your department or your entireorganization. You only pay for what you need.
informit.com/onlinebooks Get your first 14 days FREE!
InformIT Online Books is offering its members a 10 book subscription risk-free for
14 days. Visit http://www.informit.com/onlinebooks for details.
Online BooksWouldn’t it be great
if the world’s leading technical 
publishers joined forces to deliver 
their best tech books in a common 
digital reference platform?
They have. Introducing 
InformIT Online Books 
powered by Safari.
■ Specific answers to specific questions.
InformIT Online Books’ powerful search engine gives you relevance-
ranked results in a matter of seconds.
■ Immediate results.
With InformIt Online Books, you can select the book you want
and view the chapter or section you need immediately .
■ Cut, paste and annotate.
Paste code to save time and eliminate typographical errors.
Make notes on the material you find useful and choose whether
or not to share them with your work group.
■ Customized for your enterprise.
Customize a library for you, your department or your entireorganization. You only pay for what you need.
informit.com/onlinebooks Get your first 14 days FREE!
InformIT Online Books is offering its members a 10 book subscription risk-free for
14 days. Visit http://www.informit.com/onlinebooks for details.
Online BooksWouldn’t it be great
if the world’s leading technical 
publishers joined forces to deliver 
their best tech books in a common 
digital reference platform?
They have. Introducing 
InformIT Online Books 
powered by Safari.
■ Specific answers to specific questions.
InformIT Online Books’ powerful search engine gives you relevance-
ranked results in a matter of seconds.
■ Immediate results.
With InformIt Online Books, you can select the book you want
and view the chapter or section you need immediately .
■ Cut, paste and annotate.
Paste code to save time and eliminate typographical errors.
Make notes on the material you find useful and choose whether
or not to share them with your work group.
■ Customized for your enterprise.
Customize a library for you, your department or your entireorganization. You only pay for what you need.
informit.com/onlinebooks Get your first 14 days FREE!
InformIT Online Books is offering its members a 10 book subscription risk-free for
14 days. Visit http://www.informit.com/onlinebooks for details.
Online BooksWouldn’t it be great
if the world’s leading technical 
publishers joined forces to deliver 
their best tech books in a common 
digital reference platform?
They have. Introducing 
InformIT Online Books 
powered by Safari.
■ Specific answers to specific questions.
InformIT Online Books’ powerful search engine gives you relevance-
ranked results in a matter of seconds.
■ Immediate results.
With InformIt Online Books, you can select the book you want
and view the chapter or section you need immediately .
■ Cut, paste and annotate.
Paste code to save time and eliminate typographical errors.
Make notes on the material you find useful and choose whether
or not to share them with your work group.
■ Customized for your enterprise.
Customize a library for you, your department or your entireorganization. You only pay for what you need.
informit.com/onlinebooks Get your first 14 days FREE!
InformIT Online Books is offering its members a 10 book subscription risk-free for
14 days. Visit http://www.informit.com/onlinebooks for details.
Online BooksWouldn’t it be great
if the world’s leading technical 
publishers joined forces to deliver 
their best tech books in a common 
digital reference platform?
They have. Introducing 
InformIT Online Books 
powered by Safari.
■ Specific answers to specific questions.
InformIT Online Books’ powerful search engine gives you relevance-
ranked results in a matter of seconds.
■ Immediate results.
With InformIt Online Books, you can select the book you want
and view the chapter or section you need immediately .
■ Cut, paste and annotate.
Paste code to save time and eliminate typographical errors.
Make notes on the material you find useful and choose whether
or not to share them with your work group.
■ Customized for your enterprise.
Customize a library for you, your department or your entireorganization. You only pay for what you need.
informit.com/onlinebooks Get your first 14 days FREE!
InformIT Online Books is offering its members a 10 book subscription risk-free for
14 days. Visit http://www.informit.com/onlinebooks for details.
Online BooksSafari 7x9.25  8/7/02  8:24 AM  Page 1
FROM PRENTICE HALL PTR •www.phptr.comBruce Perens’ Open Source Series 
FROM PRENTICE HALL PTR  
www.phptr.com/perens
THEOFFICIAL SAMBA -3 
HOWTO and Reference Guide
BY JOHN H. TERPSTRA AND JELMER RINZE VERNOOIJ
• ©2004, paper, 736 pages, 0-13-145355-6
This is the definitive guide to using Samba-3 in production environments. It
begins with the immense amount of HOWTO information published by theSamba Team and volunteers around the world . . . but that’s just the beginning.The book’s Samba-Team editors have organized and edited this material around the practical needs of working Windows
®administrators. UNIX®/Linux
administrators will find all the answers they need as well.
MANAGING LINUX SYSTEMS WITH WEBMIN
System Administration and Module Development 
BY JAMIE CAMERON • ©2004, paper, 720 pages, 0-13-140882-8
Written by the creator of Webmin, this book explains how to use the most popular Webmin modules to perform common administration tasks on a Linuxsystem. Each chapter covers a single server or service and is broken down intosections that list the steps required to carry out certain tasks using Webmin.
IMPLEMENTING CIFS 
The Common Internet File System
BY CHRISTOPHER R. HERTEL • ©2004, paper, 400 pages, 
0-13-047116-X
This book, written by a member of the Samba Team dedicated to investigating theinner-workings of CIFS, gathers together and presents, in a readable, accessibleformat, a complete reference for system administrators and network programmerson the CIFS protocol. 
INTRUSION DETECTION SYSTEMS WITH SNORT
Advanced IDS Techniques Using SNORT, 
Apache, MySQL, PHP , and ACID 
BY RAFEEQ UR REHMAN • ©2003, paper, 300 pages, 
0-13-140733-3
This book provides information about how to use free Open Source tools to 
build and manage an Intrusion Detection System. Rehman provides detailedinformation about using SNORT as an IDS and using Apache, MySQL, PHP and ACID to analyze intrusion data. 
Perens Series (BOB) 12/03  12/23/03  3:42 PM  Page 1
FROM PRENTICE HALL PTR •www.phptr.comTHELINUX DEVELOPMENT PLATFORM
BY RAFEEQ UR REHMAN AND CHRISTOPHER PAUL 
• ©2003, paper with CD-ROM, 512 pages, 0-13-009115-4 
This is an all-in-one resource for setting up, maintaining, and using Linux as an
enterprise-level deployment environment. It provides information for all the latestversions of the tools needed for development on Linux systems, with examplesabout how to build, install, and use these tools. 
EMBEDDED SOFTWARE DEVELOPMENT
WITH E COS
BY ANTHONY I. MASSA • ©2003, paper with CD-ROM, 
432 pages, 0-13-035473-2
This book shows developers and managers the advantages of using eCos — theEmbedded Configurable Operating System — over proprietary or commercialembedded operating systems. 
RAPID APPLICATION DEVELOPMENT
WITH MOZILLA
BY NIGEL MCFARLANE • ©2004, paper, 800 pages, 0-13-142343-6
In Rapid Application Development with Mozilla , Web, XML, and Open Standards
expert Nigel McFarlane explores Mozilla’s revolutionary XML User interfaceLanguage (XUL) and its library of well over 1,000 pre-built objects. 
COMING EARLY 2004
UNDERSTANDING THE LINUX VIRTUAL
MEMORY MANAGER
BY MEL GORMAN • ©2004, paper with CD-ROM, 832 pages, 
0-13-145348-3
Your expert guide to the 2.6 Linux Kernel’s most important component: The Virtual Memory Manager. Plus, the amazing CD-ROM is a virtual VM “learning lab” with tools developed specifically for VM study PLUS all of the 2.6 kernel source code. 
COMING SOON
SAMBA -3 BYEXAMPLE
Practical Exercises to Successful Deployment
JOHN H. TERPSTRA • ©2004, paper with CD-ROM, 256 pages, 
0-13-147221-6
Perens Series (BOB) 12/03  12/23/03  3:42 PM  Page 2
Keep Up to Date with
PH PTR Online
We strive to stay on the cutting edge of what’s happening in 
professional computer science and engineering. Here’s a bit of what you’ll find when you stop by www.phptr.com :
What’s new at PHPTR? We don’t just publish books for the
professional community, we’re a part of it. Check out our convention
schedule, keep up with your favorite authors, and get the latest reviewsand press releases on topics of interest to you.
Special interest areas offering our latest books, book series,
features of the month, related links, and other useful information to helpyou get the job done.
User Groups Prentice Hall Professional Technical Reference’s User
Group Program helps volunteer, not-for-profit user groups provide theirmembers with training and information about cutting-edge technology.
Companion Websites Our Companion Websites provide 
valuable solutions beyond the book. Here you can download the sourcecode, get updates and corrections, chat with other users and the authorabout the book, or discover links to other websites on this topic.
Need to find a bookstore? Chances are, there’s a bookseller
near you that carries a broad selection of PTR titles. Locate a Magnetbookstore near you at www.phptr.com.
Subscribe today! Join PHPTR’s monthly email newsletter!
Want to be kept up-to-date on your area of interest? Choose a targetedcategory on our website, and we’ll keep you informed of the latest PHPTRproducts, author events, reviews and conferences in your interest area.
Visit our mailroom to subscribe today! 
http://www.phptr.com/mail_lists
PTR Online pg (9/02)7x9.25  9/25/02  11:06 AM  Page 1
About the Authors
Jasmin Blanchette
Jasmin graduated in computer science in 2001 from the University of Sher-
brooke, Quebec, and was awarded the Fernand Seguin medal of excellence.He did a work term at Trolltech in the summer of 2000 as a software engineerand has been working there continuously since early 2001. Now a senior soft-ware engineer, he is the driving force behind the Qt Linguist translation tool
and provides Qt Quarterly ,Trolltech’s technical newsletter, with much of its
content. In his spare time, he is writing a novel in Norwegian and Swedish.He lives in Oslo with his girlfriend Anne-Lene.
Mark Summerﬁeld
Mark graduated in computer science in 1993 from the University of Wales
Swansea. He followed this with a year’s postgraduate research before goinginto industry. He spent many years working as a software engineer for a vari-ety of ﬁrms before joining Trolltech. For the past few years, he has been Troll-tech’s documentation manager, responsible for maintaining over 1500 pagesof online Qt documentation and for editing Qt Quarterly .Inhis free time, he
writes open source software. He lives in the Swansea Valley in South Wales,UK, with his wife Andrea.
Production
The authors wrote the text using NEdit and Vim. They typeset and indexedthe text themselves, marking it up with a modiﬁed Lout syntax that they con-verted to pure Lout using a custom preprocessor written in Python. They pro-duced all the diagrams in Lout and used ImageMagick to convert screenshotsto PostScript. The monospaced font used for code is derived from Courier andwascreated using PfaEdit. The cover was provided by the publisher; the pho-
tograph is of the fall of the Berlin Wall, November 1989. The marked-up textwasconverted to PostScript by Lout, then to PDF by Ghostscript. The authors
did all the editing and processing on Debian GNU/Linux systems under KDE.The example programs were tested on Windows, Linux, and Mac OS X.
About the CD-ROM
The CD-ROM included with C++GUI Programming with Qt 3 contains all the
software and source code needed to create and run applications on Windows,
Mac OS X, and Unix/Linux with X11. The CD-ROM includes the following:
• Qt 3.2.1 Non-Commercial Edition for Windows
• Qt 3.2.1 Free Edition for Mac OS X
• Qt 3.2.1 Free Edition for Unix/Linux with X11
• Borland C ++Builder 5 Non-Commercial Edition
• Borland C ++Builder 6 Trial Edition
• Source code for the book’s examples
All versions of Qt come with the Qt library and a set of tools including the
qmake build tool, Qt Designer for visual dialog design, Qt Linguist for interna-
tionalization support, and Qt Assistant for presenting documentation.
The CD-ROM can be used on Microsoft Windows 95, 98, NT 4, ME, 2000, XP,
Mac OS X, Linux, and most versions of Unix.
License Agreement
Each of the software packages on the CD-ROM has its own license agree-
ment. The full legal texts of the licenses are included with the packages on the
CD-ROM.
Technical Support
Neither Prentice Hall nor Trolltech offers any technical support for any of
the software on the CD-ROM. (Fully supported commercial editions of Qt are
available from Trolltech; fully supported commercial editions of Borland C ++
Builder are available from Inprise.) If the CD-ROM is damaged, you can
obtain a replacement copy by sending an email that describes the problem to
disc_exchange@prenhall.com .

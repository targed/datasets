Exploring Generic Haskell
Generic Haskell van alle kanten
(met een samenvatting in het Nederlands)
Proefschrift ter verkrijging van de graad van doctor aan de Universiteit Utrecht
op gezag van de Rector Magniﬁcus, Prof. dr. W. H. Gispen, ingevolge het besluit
van het College voor Promoties in het openbaar te verdedigen op donderdag
2 september 2004 des ochtends te 10.30 uur
door
Andres L ¨oh
geboren op 18 augustus 1976 te L ¨ubeck, Duitsland
promotoren: Prof. dr. Johan Th. Jeuring, Universiteit Utrecht
en Open Universiteit Nederland
Prof. dr. S. Doaitse Swierstra, Universiteit Utrecht
The work in this thesis has been carried out under the auspices of the research
school ipa(Institute for Programming research and Algorithmics), and has been ﬁ-
nanced by the nwo (Nederlandse Organisatie voor Wetenschappelijk Onderzoek).
Printed by Febodruk, Enschede.
All drawings by Clara Strohm.
ISBN 90-393-3765-9
Contents
1 Adventure Calls! 1
1.1 From static types to generic programming . . . . . . . . . . . . . . . . 2
1.2 History of Generic Haskell and contributions of this thesis . . . . . . . 4
1.3 Related work on generic programming . . . . . . . . . . . . . . . . . . 7
1.4 Selecting a route . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2 Choosing the Equipment 15
2.1 Prerequisites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.2 The Generic Haskell compiler . . . . . . . . . . . . . . . . . . . . . . . . 16
2.3 A note on notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3 A Functional Core 21
3.1 Syntax of the core language fc. . . . . . . . . . . . . . . . . . . . . . . . 22
3.2 Scoping and free variables . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.3 Types and kinds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.4 Well-formed programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.5 Operational semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.6 Recursive let . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
iii
Contents
4 Type-indexed Functions 41
4.1 Exploring type-indexed functions . . . . . . . . . . . . . . . . . . . . . . 41
4.2 Relation to type classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.3 Core language with type-indexed functions fcr+tif . . . . . . . . . . . 44
4.4 Translation and specialization . . . . . . . . . . . . . . . . . . . . . . . . 45
4.5 Type checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
5 Parametrized Type Patterns 53
5.1 Goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
5.2 Parametrized type patterns . . . . . . . . . . . . . . . . . . . . . . . . . 55
5.3 Dependencies between type-indexed functions . . . . . . . . . . . . . . 56
5.4 Type application in type arguments . . . . . . . . . . . . . . . . . . . . 65
6 Dependencies 69
6.1 Core language with parametrized type patterns . . . . . . . . . . . . . 69
6.2 Dependency variables and kinds . . . . . . . . . . . . . . . . . . . . . . 72
6.3 Dependency types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
6.4 Types and translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
6.5 Correctness of the translation . . . . . . . . . . . . . . . . . . . . . . . . 95
6.6 Kind-indexed types? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
7 Going Generic 107
7.1 Unit, Sum, and Prod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
7.2 Generic enumeration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
7.3 Generic equality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
7.4 Generic compression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
7.5 Extending the language . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
8 Local Redeﬁnition 121
8.1 Enhanced equality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
8.2 Size of data structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
8.3 Short notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
8.4 Local redeﬁnition within type-indexed functions . . . . . . . . . . . . . 129
8.5 Core language with local redeﬁnition fcr+tif+par+lr . . . . . . . . . . 130
9 Types of Type-indexed Functions 133
9.1 Identity and mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
9.2 Zipping data structures . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
9.3 Generically collecting values . . . . . . . . . . . . . . . . . . . . . . . . . 137
9.4 More choice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
9.5 Type tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
9.6 Multi-argument type signatures . . . . . . . . . . . . . . . . . . . . . . . 145
iv
Contents
9.7 Revised generic application algorithm . . . . . . . . . . . . . . . . . . . 149
9.8 Multiple dependencies on one function . . . . . . . . . . . . . . . . . . 153
9.9 Translation and correctness . . . . . . . . . . . . . . . . . . . . . . . . . 154
10 Embedding Datatypes 155
10.1 Zero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
10.2 A few examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
10.3 Formal translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
11 Translation by Specialization 167
11.1 Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
11.2 Lifting isomorphisms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
11.3 Lifting isomorphisms and universal quantiﬁcation . . . . . . . . . . . . 172
11.4 Reﬂexivity of the dependency relation . . . . . . . . . . . . . . . . . . . 178
11.5 Translation of generic functions . . . . . . . . . . . . . . . . . . . . . . . 180
11.6 How to determine the required components . . . . . . . . . . . . . . . 185
11.7 Discussion of translation by specialization . . . . . . . . . . . . . . . . 186
11.8 Other translation techniques . . . . . . . . . . . . . . . . . . . . . . . . . 187
12 Generic Abstraction 193
12.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
12.2 Generic reductions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
12.3 Cata- and anamorphisms . . . . . . . . . . . . . . . . . . . . . . . . . . 198
12.4 Types and translation of generic abstractions . . . . . . . . . . . . . . . 200
12.5 Type indices of higher kind . . . . . . . . . . . . . . . . . . . . . . . . . 205
12.6 Multiple type arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
13 Type Inference 209
13.1 Type inference of type arguments . . . . . . . . . . . . . . . . . . . . . . 210
13.2 Dependency inference . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
13.3 Base type inference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
14 Default Cases 215
14.1 Generic Traversals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
14.2 Variants of equality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
14.3 Simulating multiple dependencies on one function . . . . . . . . . . . 219
14.4 Implementation of default cases . . . . . . . . . . . . . . . . . . . . . . 221
14.5 Typing default cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
15 Type, Newtype, Data 229
15.1 Datatype renamings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
15.2 Type synonym declarations . . . . . . . . . . . . . . . . . . . . . . . . . 231
v
Contents
16 Type-indexed Datatypes 235
16.1 Type-indexed tries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
16.2 Explicit specialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
16.3 Idea of the translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
16.4 Local redeﬁnition on the type level . . . . . . . . . . . . . . . . . . . . . 244
16.5 Generic abstraction on the type level . . . . . . . . . . . . . . . . . . . . 245
16.6 The Zipper . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
16.7 Implementation of type-indexed datatypes . . . . . . . . . . . . . . . . 249
16.8 Translation by specialization and type-indexed datatypes . . . . . . . . 270
17 Alternative Views on Datatypes 273
17.1 Constructors and labels . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
17.2 Fixpoints of regular functors . . . . . . . . . . . . . . . . . . . . . . . . 280
17.3 Balanced encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
17.4 List-like sums and products . . . . . . . . . . . . . . . . . . . . . . . . . 283
17.5 Constructor cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
17.6 A language for views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
18 Modules 289
18.1 A language with modules . . . . . . . . . . . . . . . . . . . . . . . . . . 290
18.2 Translation of modules containing type-indexed entities . . . . . . . . 292
18.3 Explicit specialization of type-indexed types is necessary . . . . . . . . 297
18.4 Open versus closed type-indexed functions . . . . . . . . . . . . . . . . 299
Syntax overview 303
Complete syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
All languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
Metavariables used . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
Samenvatting in het Nederlands 311
Van statische types naar generiek programmeren . . . . . . . . . . . . . . . 311
Generic Haskell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
Bibliography 315
Index 323
vi
List of Figures
2.1 Sample deduction rule . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.1 Syntax of the core language fc. . . . . . . . . . . . . . . . . . . . . . . 23
3.2 Kind checking for core language of Figure 3.1 . . . . . . . . . . . . . . 26
3.3 Type checking for core language of Figure 3.1 . . . . . . . . . . . . . . 27
3.4 Type checking for patterns, extends Figure 3.3 . . . . . . . . . . . . . 28
3.5 Subsumption relation on core types, extends Figure 3.3 . . . . . . . . 28
3.6 Well-formed data declarations . . . . . . . . . . . . . . . . . . . . . . . 31
3.7 Well-formed programs . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.8 Syntax of values, extends Figure 3.1 . . . . . . . . . . . . . . . . . . . . 32
3.9 Type rule for run-time failure, extends Figure 3.3 . . . . . . . . . . . . 32
3.10 Reduction rules for core language of Figure 3.1 . . . . . . . . . . . . . 34
3.11 Pattern matching for the core language of Figure 3.1, extends Fig-
ure 3.10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.12 Syntax of fcr, modiﬁes the core language fcof Figure 3.1 . . . . . . . 38
3.13 Translation of fcrtofc. . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.14 Type checking for recursive let, modiﬁes Figure 3.3 . . . . . . . . . . . 39
vii
List of Figures
4.1 Core language with type-indexed functions fcr+tif, extends language
fcrin Figures 3.1 and 3.12 . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.2 Translation of fcr+tif to fcr . . . . . . . . . . . . . . . . . . . . . . . . 46
4.3 Type checking for fcr+tif, extends Figure 3.3 . . . . . . . . . . . . . . 48
4.4 Type checking for declarations in fcr+tif, extends Figure 4.3 . . . . . 49
4.5 Translation of fcr+tif environments to fcrtype environments . . . . 50
5.1 Types for generic applications of addto type arguments of different
form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
5.2 Types for generic applications of sizeto type arguments of different
form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
6.1 Core language with type-indexed functions and parametrized type
patterns fcr+tif+par, extends language fcr+tif in Figure 4.1 . . . . . 70
6.2 Kind checking for language fcr+tif+par of Figure 6.1, extends Fig-
ure 3.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
6.3 Kind checking of type patterns in language fcr+tif+par of Figure 6.1 73
6.4 Well-formedness of dependency constraints in language fcr+tif+par
of Figure 6.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
6.5 Kind checking of qualiﬁed types in fcr+tif+par of Figure 6.1 . . . . 74
6.6 Extracting information from the type signature of a type-indexed
function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
6.7 Well-formedness of type signatures for type-indexed functions . . . . 76
6.8 Generic application algorithm . . . . . . . . . . . . . . . . . . . . . . . 78
6.9 Translation of qualiﬁed types and dependency constraints in lan-
guage fcr+tif+par . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
6.10 Subsumption relation on qualiﬁed types, extends Figure 3.5 . . . . . 85
6.11 Conversion of dependency constraints into explicit abstractions, ex-
tends Figure 6.10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
6.12 Entailment of dependency constraints, extends Figure 6.10 . . . . . . 88
6.13 Translation of fcr+tif+par expressions to fcr . . . . . . . . . . . . . . 88
6.14 Revelation of dependency constraints in fcr+tif+par . . . . . . . . . 89
6.15 Translation of fcr+tif+par declarations to fcr. . . . . . . . . . . . . . 91
6.16 Translation of fcr+tif+par kind environments to fcr. . . . . . . . . . 92
6.17 Translation of fcr+tif+par environments to fcrtype environments . 93
6.18 Translation of generic application in fcr+tif+par . . . . . . . . . . . . 94
6.19 Generic application algorithm extension for type arguments of higher
kinds, extends Figure 6.8 . . . . . . . . . . . . . . . . . . . . . . . . . . 100
8.1 Short notation for local redeﬁnition . . . . . . . . . . . . . . . . . . . . 126
8.2 Alternative deﬁnition of short notation . . . . . . . . . . . . . . . . . . 128
viii
List of Figures
8.3 Core language with local redeﬁnition fcr+tif+par+lr, extends lan-
guage fcr+tif+par in Figures 6.1, 4.1, and 3.1 . . . . . . . . . . . . . . 130
8.4 New rule for checking and translating recursive let in fcr+tif+par+lr,
replaces rule (e/tr-let) in Figure 6.13 . . . . . . . . . . . . . . . . . . . 131
8.5 Translation of fcr+tif+par+lr declarations to fcr, extends Figure 6.15 131
9.1 Example types for generic applications of map to type arguments of
different form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
9.2 Example types for generic applications of zipWith to type arguments
of different form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
9.3 Example types for generic applications of collect to type arguments of
different form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
9.4 Syntax of type tuples and their kinds . . . . . . . . . . . . . . . . . . . 142
9.5 Kind checking of type and type argument tuples . . . . . . . . . . . . 143
9.6 Comparison of type tuples . . . . . . . . . . . . . . . . . . . . . . . . . 144
9.7 Bounded type tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
9.8 Generalized type signatures in fcr+tif+mpar, replaces type signa-
tures from Figure 6.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
9.9 Revised base type judgment, replaces rule (base) from Figure 6.6 . . 146
9.10 Dependency judgment . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
9.11 Revised well-formedness of type signatures for type-indexed func-
tions, replaces rule (typesig) of Figure 6.7 . . . . . . . . . . . . . . . . 147
9.12 Wrapper for the revised generic application algorithm . . . . . . . . . 150
9.13 Revised generic application algorithm, replaces Figures 6.8 and 6.19 151
9.14 Revised generic application algorithm, continued from Figure 9.13,
replaces Figures 6.8 and 6.19 . . . . . . . . . . . . . . . . . . . . . . . . 152
10.1 Kind checking of parametrized types, extends Figure 3.2 . . . . . . . 160
10.2 Structural representation of datatypes . . . . . . . . . . . . . . . . . . 161
10.3 Structural representation of constructors . . . . . . . . . . . . . . . . . 161
10.4 Generation of embedding-projection pairs for datatypes . . . . . . . . 163
10.5 Generation of embedding-projection pairs for constructors . . . . . . 164
11.1 Well-formed programs, replaces Figure 3.7 . . . . . . . . . . . . . . . 181
11.2 Translation of fcr+gf declarations to fcr, extends Figure 6.15 . . . . . 183
12.1 Core language with generic abstraction fcr+gf+gabs, extends lan-
guage fcr+gf in Figures 9.4, 8.3, 6.1, 4.1, and 3.1 . . . . . . . . . . . . 201
12.2 Well-formedness of type signatures for type-indexed functions in-
cluding generic abstractions, replaces Figure 9.11 . . . . . . . . . . . . 201
12.3 Translation of generic abstractions to fcr. . . . . . . . . . . . . . . . . 203
ix
List of Figures
12.4 Modiﬁed base type judgment for fcr+gf+gabs, replaces Figure 9.9 . 204
12.5 Types for generic applications of fsize to type arguments of different
form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
14.1 Core language with default cases fcr+gf+gabs +dc, extends language
fcr+gf+gabs in Figures 12.1, 9.4, 8.3, 6.1, 4.1, and 3.1 . . . . . . . . . 221
14.2 Translation of default cases, extends Figures 11.2 and 6.15 . . . . . . . 222
14.3 Conversion of arms for a default case . . . . . . . . . . . . . . . . . . . 223
15.1 Full syntax of type declarations for language fcrt, extends Figures 3.1
and 3.12 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
16.1 Kinds for generic applications of FMap to type arguments of different
form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
16.2 Syntax of type-indexed datatypes in language fcrt+gftx . . . . . . . 250
16.3 Well-formedness of kind dependency constraints in fcrt+gftx of Fig-
ure 16.2, compare with Figure 6.4 . . . . . . . . . . . . . . . . . . . . . 252
16.4 Well-formedness of qualiﬁed kinds in fcrt+gftx of Figure 16.2, com-
pare with Figure 6.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
16.5 Translation of qualiﬁed kinds and kind dependency constraints in
fcrt+gftx, compare with Figure 6.9 . . . . . . . . . . . . . . . . . . . . 253
16.6 Subsumption relation on qualiﬁed kinds, compare with Figure 6.10 . 253
16.7 Extracting information from the kind signature of a type-indexed
datatype, compare with Figure 6.6 . . . . . . . . . . . . . . . . . . . . 255
16.8 Well-formedness of kind signatures for type-indexed datatypes, com-
pare with Figure 6.7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
16.9 Generic application algorithm for type-indexed datatypes, compare
with Figures 6.8 and 6.19 . . . . . . . . . . . . . . . . . . . . . . . . . . 256
16.10 Translation of generic application of type-indexed datatypes in lan-
guage fcr+tif+par, compare with Figure 6.18 . . . . . . . . . . . . . . 257
16.11 Translation of fcrt+gftx types to fcrt . . . . . . . . . . . . . . . . . . . 259
16.12 Revelation of kind dependency constraints in fcrt+gftx, compare
with Figure 6.14 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
16.13 Translation of fcrt+gftx expressions to fcrt, extends Figures 6.13, 8.1,
and 12.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
16.14 Translation of fcrt+gftx type declarations to fcrt, compare with Fig-
ure 6.15 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
16.15 Translation of fcrt+gftx declarations to fcrt, continued from Fig-
ure 16.14 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
16.16 Closed base type with respect to applications of type-indexed types . 267
16.17 Translation of fcrt+gftx declarations to fcrt, replaces Figure 11.2 . . 269
x
List of Figures
17.1 Operations on the Cardinality type . . . . . . . . . . . . . . . . . . . . 279
18.1 Language with modules fcrtm , extends Figures 3.1, 3.12, and 15.1 . . 290
18.2 Language with modules and type-indexed entities fcrtm +gftx, ex-
tends Figure 18.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
18.3 Translation of fcrtm +gftx export list entries to fcrtm , continued from
Figure 18.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
18.4 Translation of fcrtm +gftx export list entries to fcrtm , continued from
Figure 18.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
18.5 Translation of fcrtm +gftx modules to fcrtm . . . . . . . . . . . . . . . 295
18.6 Conﬂicting components of type-indexed types . . . . . . . . . . . . . 298
18.7 Explicit specialization in a separate module . . . . . . . . . . . . . . . 299
xi
List of Figures
xii
Acknowledgements
The story of me ending up in Utrecht to do a Ph.D. on Generic Haskell is full of
lucky coincidences. Therefore, ﬁrst of all, I want to thank fate, if there is such a
thing, for the fact that everything turned out so well.
When I arrived in Utrecht, I did not even know my supervisor, Johan Jeuring
– well, okay, I had read papers authored by him. Now, four years later, I can
conﬁdently say that I could not imagine a better supervisor. He has proved to be
a patient listener, encouraged me where needed, warned me when I was about to
be carried away by some spontaneous idea, let me participate in his insights, and
shared his experiences regarding survival in the academic world. Most of all, he
has become a friend. My whole time here would have been far less enjoyable if it
were not for him. Johan, thank you very much.
Although on second position in these acknowledgments, Doaitse Swierstra
may well have deserved the ﬁrst. After all, he is “responsible” for the fact that
I abandoned everything else, moved to Utrecht, and started working on a Ph.D.
When I ﬁrst met him at a conference, I asked him about possibilities to do a
Ph.D. in Utrecht and to work in the area of functional programming. Afterwards,
I had a hard time convincing him that it would not be possible for me to start
immediately, but that I still had almost a year to go until ﬁnishing my “Diplom”.
During my time here, Doaitse has been a constant source of interesting ideas and
enlightening discussions. I envy his seemingly unshakable enthusiasm for his
work, and hope that this enthusiasm will inspire many others as it did inspire
me.
I want to thank Ralf Hinze, who had the doubtful privilege to share an ofﬁce
with me during my ﬁrst year, and as another German eased the transition to the
Netherlands. For me, working on generic programming, he has been the ideal
person to have close by and to learn from. I thank him for showing an interest in
me and my work, also after he left.
Jeremy Gibbons, Ralf Hinze, Lambert Meertens, Rinus Plasmeijer, and Peter
Thiemann are the members of the reading committee. I am grateful that they
took the time to read this thesis, and for several helpful comments and insights.
I am sorry that I could not act on all of them due to time constraints.
One of the really amazing things about Utrecht University has been the at-
mosphere in the software technology group. There are so many people that are
interested in each other’s work, and if there ever was a problem just outside
my own area of expertise, I was very likely to ﬁnd a helpful answer just a few
steps away next door. Many of my colleagues have provided interesting ideas
and valuable discussions. I would like to mention Daan Leijen, Eelco Dolstra,
xiii
Acknowledgements
Arjan van IJzendoorn, and Bastiaan Heeren in particular, who have become good
friends over the years.
I am very grateful to Martin Bravenboer, Bastiaan Heeren, Arjan van IJzen-
doorn, Daan Leijen, Ganesh Sittampalam, Ian Lynagh, Shae Matijs Erisson, Andr ´e
Pang, the “Matthiases” Auer and Weisgerber, Carmen Schmitt, Clara Strohm, and
G¨unter L ¨oh for reading parts of my thesis and constructively commenting on var-
ious aspects of my work. Especially to those of you who do not have a degree in
computer science: thank you for taking the time and trying to understand what I
have done.
The people on the freenode #haskell channel, including, but not limited to
earthy, Heffalump, Igloo, Marvin--, ozone, shapr, and SyntaxNinja, have pro-
vided a great deal of – probably largely subconscious – mental support during
the phase in which I had to write my thesis and diversions were scarce.
I am indebted to Torsten Grust and Ulrik Brandes, who back during my time in
Konstanz, managed to change my view of computer science into a positive one.
Without them, I am convinced that I would never even have considered doing
a Ph.D. in computer science. Thanks, Torsten, for exposing me to functional
programming. I, too, once came to the university thinking that C is the only cool
programming language in existence.
My parents deserve a big “Dankesch ¨on” because they never complained about
the choices I have made in my life, including the places where I have lived, and
supported me in all my decisions in every way imaginable.
Words cannot describe what Clara means to me and how much impact she
had on the creation of the thesis. Not only did she read almost all of it, ﬁnding
several smaller and larger mistakes, she also invested an incredible amount of
time and creativity into creating all the drawings in this thesis, thereby giving it
a unique character – not to mention all the mental support and patience during a
time where she herself had a thesis to write. To say it in the words the “Lambda”
would choose: “Schlububius? Einmal? Alle Achtung!”
xiv
1 Adventure Calls!
This thesis is an exploration – an exploration of a language extension of the func-
tional programming language Haskell. The extension is called Generic Haskell ,
albeit the name has been used to refer to different objects over the last several
years: Many papers have described different proposals, features, variations, and
generations of the language. One purpose of this thesis is to do away with at least
part of this fuzziness: everything is described in a common notation and from a
single starting point. The other purpose is to simply give a complete overview of
the language: we will systematically explain the core features of Generic Haskell,
and several extensions, all with motivating examples and details on how the fea-
tures can be implemented.
Before we start our exploration, though, Section 1.1 will explain the idea and
motivation behind generic programming which, at the same time, is the motivation
for the design of Generic Haskell. After that, Section 1.2 will give an overview
of the history of Generic Haskell. In Section 1.3 we discuss other important ap-
proaches to generic programming. In the last section of this chapter, Section 1.4,
we give an overview of all the chapters of this thesis, their contents, the papers
they are based on, and how they are interconnected.
1
1 Adventure Calls!
1.1 From static types to generic programming
Static types are used in many programming languages to facilitate the creation
of error-free software. While static types cannot guarantee the correctness of
all programs written in a language, a sound static type system is capable of
eliminating a certain class of runtime errors, which result in particularly nasty
program crashes, because operating systems usually do not allow us to catch such
errors. These errors result from the program inadvertently accessing a memory
position that does not belong to the program. With static types, a program is
checked at compile time, to prevent this kind of behaviour. Ideally, the successful
type checking process together with the translation semantics of the language
make up a proof that the programs cannot “go wrong” (Milner 1978).
In a less perfect world, these proofs often do not fully exist, because the trans-
lation that the compilers perform is too complex and involves too many external
factors. Nevertheless, statically checked types in the user’s programs result in
less error-prone programs.
The amount of information about the program that a type checker can verify
is not ﬁxed. Some static type systems can type more programs than others, some
can catch more errors than others – other kinds of errors, which are less nasty,
but still inconvenient enough, such as divisions by zero or array indices that are
out of bound. Nevertheless, there is a constant struggle: if too much cleverness is
incorporated into the types, the type checking becomes inefﬁcient or even unde-
cidable. If too little information is covered by the type checker, programmers ﬁnd
themselves ﬁghting the type system: programs that would behave correctly are
nevertheless rejected as incorrect, because the type system is not capable of ﬁnd-
ing out that a potentially unsafe construct is only used in safe contexts throughout
a particular program.
The Hindley-Milner type system (Hindley 1969; Milner 1978) with the Damas-
Milner inference algorithm (Damas and Milner 1982) is a great historical achieve-
ment, because it is an expressive type system which allows to type day-to-day
programs without any problems, and not only has an efﬁcient type checking al-
gorithm, but even permits efﬁcient type inference! Thus, the programmer is not
forced to annotate a program with types or declare the types of entities used –
everything is inferred by the compiler automatically and checked for consistency.
One of the highlights of this type system is the possibility for parametrically poly-
morphic functions . Functions that work in the same way for all datatypes need not
be instantiated over and over again, making a new copy for each new datatype,
but can be written once and used everywhere.
Haskell (Peyton Jones 2003), along with other languages such as sml(Milner
et al. 1997) or Clean (Plasmeijer and van Eekelen 2001), are based on the Hindley-
2
1.1 From static types to generic programming
Milner type checking rules. Haskell in particular has also proved to be a testbed
for various type system extensions. Even in its standard form, Haskell has sev-
eral extensions over the classic Hindley-Milner algorithm. It allows explicit type
signatures, if desired, to restrict a function’s type. It provides type classes, which
allow one to write overloaded functions, with different functionality for different
types. There is a kind system, which mirrors the type system yet again on the
level of datatypes, and thus allows the systematic treatment of type constructors
such as lists or tuples, which are parametrized over other types – and there is
more . . .
However, Haskell – just as the other languages mentioned – suffers from a
problem: There is a conﬂict between the use of static types to prevent type errors
and the goal of code reuse. Static types, in particular nominal types (types distin-
guished by name rather than by structure) make a difference where there would
not normally be one for the computer. For instance, a date is nothing more than
a triple of integers, but in a static type system, a date will be treated as a separate
type, and only special functions, tailored for dates, can be used on them.
Often, this is exactly what is desired, but sometimes, it is a hindrance as well.
Parametrically polymorphic functions make the situation bearable. Declaring
new types is cheap, because a lot of functions, especially functions that process
the structure of the data, work on any type. Everything can be put into a list, or
a tree, selected, rearranged, and so forth.
Parametrically polymorphic functions, however, are only good for doing things
that are completely independent of the actual values. The values are put into a
box and cannot be touched from within a polymorphic function. Often, however,
we would want to make use of the underlying structure of the type. Suppose
we have hidden an identiﬁcation number, a room number, and a year in three
different datatypes. This is usually a good thing, because most likely it should
be prevented that a year is suddenly used as a room number. Still, all three are
in principle integers, and integers admit some operations that are not applicable
to all datatypes. They can be added, compared, tested for equality, incremented,
and much more. Such functionality can never be captured in a parametrically
polymorphic function, because it is only applicable to integers and, maybe, other
numeric types, but not to all types, and deﬁnitely not to all types in the same way!
Type classes can help here. A function can be overloaded to work on different
datatypes in a different fashion. For instance, equality is already overloaded in
Haskell, and so is addition or comparison. We can make identiﬁcation numbers,
room numbers, and years instances of the appropriate classes, and then use the
functions. But, as soon as we deﬁne a new datatype that is just an integer, we
have to write the instance declarations all over again. Similarly, when we add a
new function that works perfectly on integers, we have to overload it and write
instance declarations for all the datatypes again.
3
1 Adventure Calls!
What we really need is a controlled way to forget the distinctions that the
type system makes for a time and deﬁne functions that mainly care about the
structure of a type. The possibility to deﬁne functions by analysis of the structure
of datatypes is what we call generic programming in the context of this thesis.
Haskell in particular offers a limited mechanism to achieve some of the desired
functionality: the deriving construct allows automatic generation of type class
instances for a ﬁxed set of Haskell type classes – type classes that provide meth-
ods such as the equality test, comparison, lower and upper bounds of values,
generating a canonical representation of values as a string, and reading such a
representation back in. Thus, Haskell has some built-in generic programs, but
does not allow you to write your own generic programs. Other generic functions,
or variations of the functions that can be derived, have to be deﬁned for each
datatype by hand.
1.2 History of Generic Haskell and
contributions of this thesis
In this section, we present a brief summary of how Generic Haskell came to life,
and which language(s) it refers to. In this context, it will also become clear on
whose work this thesis is based and what the contributions of this thesis are.
The ﬁrst generic programming language extension that has been designed for
Haskell is PolyP (Jansson and Jeuring 1997; Jansson 2000). In PolyP, generic
functions are called polytypic . The language introduces a special construct in
which such polytypic functions can be deﬁned via structural induction over the
structure of the pattern functor of a regular datatype. Regular datatypes in PolyP
are a subset of Haskell datatypes. A regular datatype tmust be of kind∗→∗ ,
and if ais the formal type argument in the deﬁnition, then all recursive calls to t
must have the form t a. These restrictions rule out higher kinded datatypes as
well as nested datatypes, where the recursive calls are of a different form.
In the lecture notes for a Summer School (Backhouse et al. 1999), theoretical
background on generic programming is combined with an introduction to PolyP,
thereby establishing generic programming as a synonym for polytypic program-
ming in the context of Haskell.
Ralf Hinze reused the term generic programming for the ability to deﬁne type-
indexed functions during his own presentation of a programming language ex-
tension for Haskell (Hinze 1999 a, 2000 b). As in PolyP, Haskell is extended with
a construct to deﬁne type-indexed functions. Type indices can be of kind ∗(for
generic equality, or showing values) or ∗→∗ (for mapping functions or reduc-
tions), and in principle, for all kinds of the form ∗→···→∗ . The approach
4
1.2 History of Generic Haskell and contributions of this thesis
has two essential advantages over PolyP: ﬁrst, generic functions can be deﬁned
over the structure of datatypes themselves, without falling back to pattern func-
tors. Second, nested types do not pose a problem for Hinze’s theory. While most
generic functions are easier to deﬁne over the structure of a datatype directly
than via the pattern functor, some functions that make explicit use of the points
of recursion, such as generic cata- and anamorphisms, become harder to deﬁne.
Hinze’s approach still suffers from some limitations: for each kind, the type
language over which generic functions are deﬁned is a different one, thus making
the extension difﬁcult to implement. Furthermore, types of kinds that are not in
the above-mentioned form are not allowed as type indices of generic functions.
And even though the set of types over which a generic function is explicitly
deﬁned is variable, no types of complex kinds are allowed in that set.
These limitations are overcome in Hinze’s later work (Hinze 2000 c), where
generic functions can be deﬁned for datatypes of all kinds, using a single function
deﬁnition. In other words, one generic function can not only be instantiated to
type arguments of a ﬁxed kind, but to type arguments of all kinds. The essence of
the idea is captured in the paper’s title: “Polytypic functions possess polykinded
types”. The type of the generic function (to be precise, the number of function
arguments it takes) is determined by the kind of the datatype it is instantiated to.
In his “Habilitationsschrift” (Hinze 2000 a), Hinze presents both his approaches
in parallel, comparing them and favouring the second for an implementation
which he calls “Generic Haskell”. His thesis also contains some hints about how
to implement an extension for Haskell, taking the peculiarities of the Haskell lan-
guage into account. The translation of generic functions proceeds by specializa-
tion: speciﬁc instances of a generic function are generated for the types at which
the function is used in the program. This has the advantage that type informa-
tion can still be completely eliminated in the translation, allowing for an efﬁcient
translation. On the other hand, generic functions remain special constructs in the
language which are not ﬁrst-class: they cannot be passed as arguments to other
functions.
In another paper (Hinze and Peyton Jones 2001), a possible extension for the
Glasgow Haskell Compiler ghc (ghc Team) is proposed (which has also been
implemented), that is integrated into the type class system of Haskell: generic
functions are not available as separate declarations, but only as class methods.
Haskell allows default deﬁnitions for class methods to be given, such that if an
instance is deﬁned for a class without a new deﬁnition for a certain method, then
the default deﬁnition is used. Using “derivable type classes”, generic default
deﬁnitions are allowed, consisting of several cases for some basic types, thus
allowing generic behaviour to be derived when a new instance is requested. In
Haskell, type classes are parametrized by type arguments of ﬁxed kinds. For this
5
1 Adventure Calls!
reason, the derivable type classes are more related to Hinze’s ﬁrst approach, and
do not have kind-indexed types. Moreover, they only work for type indices of
kind∗. Several of the classes for which Haskell provides the deriving construct
can now be deﬁned generically. Other desirable classes, such as the Functor class
which provides a generic mapping function, are still out of reach.
The ﬁrst release of the Generic Haskell compiler (Clarke et al. 2001) – in the
context of the “Generic Haskell” project at Utrecht University – was therefore
separate from the ghcextension for derivable type classes, and supported type-
indexed functions with kind-indexed types following Hinze’s earlier sugges-
tions (Hinze 2000 a), without integrating genericity with the type class system.
The existence of the compiler made practical programming experiments pos-
sible, and these uncovered some weaknesses in expressivity which lead to the
extensions described in the paper “Generic Haskell, speciﬁcally” (Clarke and L ¨oh
2003): default cases, constructor cases, and generic abstraction. These extensions
were incorporated into a second release (Clarke et al. 2002) of the Generic Haskell
compiler, together with support for type-indexed datatypes (Hinze et al. 2002).
Such generic datatypes mirror the principle of structural induction over the lan-
guage of datatypes on the type level. In other words, datatypes can be deﬁned
which have an implementation that depends on the structure of a type argument.
While Hinze’s framework provided a strong and solid foundation, it turned out
to have some inherent weaknesses as well: the concept of kind-indexed types,
which implies that different cases of a generic deﬁnition take a different num-
ber of arguments, proved to be difﬁcult to explain in teaching, and unwieldy in
presentations. The theory forces all generic functions into the shape of catamor-
phisms, where recursion is not explicit; instead, the recursive calls are passed as
arguments to the function.
Transferred to ordinary Haskell functions, this means that we would need to
write the factorial function as
fac 0 =1
fac rec (n+1) = ( n+1)·rec.
Note that this is an example by analogy: the factorial function does not have
to be written this way in Generic Haskell, only recursion on generic functions
followed this principle. An additional argument rec, which is equivalent to the
recursive call to fac n , is passed to the second case. Such a deﬁnition requires a
clear understanding of how the mechanism works; it is not immediately obvious
what is going on. It is much easier to make the recursion explicit:
fac 0 =1
fac (n+1) = ( n+1)·fac n .
6
1.3 Related work on generic programming
Furthermore, if recursion is only possible via explicitly passed arguments, it is
also difﬁcult to break free of the catamorphic scheme: what if we do not want to
recurse on the immediate predecessor? Maybe we would rather call fac(n−1).
Or what if we have two functions which are mutually recursive?
Dependency-style Generic Haskell (L ¨ohet al. 2003) is an attempt to alleviate
this problem by providing a clearer, more ﬂexible syntax without losing any of
the generality and the features that were previously available.
Dependencies also form the core of the presentation in this thesis. While the
paper introduces dependencies as a modiﬁcation of previous work on Generic
Haskell, we present Generic Haskell from scratch, using dependencies from the
very beginning. The main chapters dealing with dependencies are 5, 6, and 9.
Because the introduction of dependencies addresses the foundations of Generic
Haskell, it has implications on almost every aspect of it. Therefore, prior results
have to be reevaluated in the new setting. We repeat fundamental aspects of
Hinze’s theory in Chapters 7, 10, and 11.
In later chapters, we concentrate on extensions to Generic Haskell that make
it more expressive and easier to use. These results – as far as they have been
published – are taken from the papers “Generic Haskell, speciﬁcally” (Clarke
and L ¨oh 2003) and “Type-indexed data types” (Hinze et al. 2002). This material is
also adapted and revised to ﬁt into the framework of Dependency-style Generic
Haskell.
This thesis can be seen as a description of Generic Haskell in a consistent state
after four years of research as well as an explanation of how to write a compiler
for a language like Generic Haskell. In several places, we point out design deci-
sions taken and sketch other possibilities to solve problems. The current state of
the Generic Haskell implementation is described in Section 2.2.
A more detailed overview over the contents of this thesis is given in Section 1.4,
after we have surveyed related work.
1.3 Related work on generic programming
First of all, it should be mentioned that generic programming is not an ideal term
for the structural polymorphism that we talk about in this thesis, because the term
is used by different communities in different meanings. Most notably, the object-
oriented programming community, when talking about generic programming,
mean about the same as is captured by parametric polymorphism in Hindley-
Milner based type systems. Nevertheless, generic programming is the term that
has been used for a while now (Bird et al. 1996) in the functional programming
community to refer to structural polymorphism, i.e., functions deﬁned over the
structure of datatypes, and we will continue the habit.
7
1 Adventure Calls!
Generic programming in functional languages has grown into a rich and di-
verse ﬁeld, and it is hard to do justice to all the excellent work that has been done
during the last years. We will pick a few examples which we think are espe-
cially related to the work presented in this thesis, knowing that we omit several
noteworthy others.
1.3.1 Intensional type analysis
Using intensional type analysis (Harper and Morrisett 1995), it is possible to
analyze types at runtime, for instance to select a more efﬁcient implementation of
a function. The idea is very similar to the type-indexed functions that we discuss
in Chapter 4. Stephanie Weirich (2002) has extended intensional type analysis
to higher-kinded type arguments, thereby following some of the ideas of Hinze
and making the approach usable for generic programming as well, especially in
a purely structural type system.
More recent work (Vytiniotis et al. 2004) throws some additional light on the
relation between structural and nominal types. An intermediate language with
support for both structural and nominal types and type-indexed functions which
can be open (i.e., extensible with new cases) or closed is presented. The language
does not provide an automatic transformation of datatypes into their underlying
structure (cf. Chapters 10 and 17), but it could be used as a target language for
Generic Haskell.
1.3.2 Scrap your boilerplate!
Recently, Ralf L ¨ammel and Simon Peyton Jones have joined forces to provide a
workable generic programming extension directly in ghc. Two papers (L ¨ammel
and Peyton Jones 2003, 2004) describe the extension. The fundamental idea is a
different one than for Generic Haskell: genericity is created by extending a poly-
morphic, uniform traversal function with type-speciﬁc behaviour. For instance,
the identity traversal can be extended with the function that increases all integers
by 1, resulting in a function that still works for all datatypes, but is no longer
parametrically polymorphic.
Internally, a type representation is passed for such functions, and a typesafe
cast is used to check if special behaviour has been speciﬁed for a datatype. The
strength of the approach lies in the manipulation of large data structures, which
is related to what Generic Haskell can achieve by means of default cases – the re-
lation is described further in Chapter 14. Furthermore, generic functions deﬁned
in the “boilerplate” style are ﬁrst class and require no special treatment in the
Haskell type system.
Even though the perspective of the approach is a different one, it can also be
used to write many of the generic operations that work by structural induction
8
1.3 Related work on generic programming
over the language of types – such as equality, comparison, parsing and unparsing
– which is the original motivation behind Generic Haskell.
However, the “boilerplate” approach does not support type-indexed types.
1.3.3 Template Haskell
Template Haskell (Sheard and Peyton Jones 2002) is a language extension of
Haskell, allowing the programmer to write meta-programs that are executed at
compile time. Meta-programs have access to the abstract syntax tree of the pro-
gram, and can use the tree to perform reﬂection on already existing code and to
produce new code.
Using Template Haskell, it is possible to write generic programs as meta-
programs. At the call site of a generic function, a specialized version of the
generic program that works for one speciﬁc type, can be spliced into the program
code.
Template Haskell aims at being far more than just a generic programming
extension, but in the area of generic programming, it suffers from a couple of
disadvantages. Template Haskell does not yet have a type system, although there
is ongoing work to resolve this problem (Lynagh 2004). While the code resulting
from meta-programs is type checked normally by the Haskell compiler, there is
no check that the template program can only produce correct code. Furthermore,
the syntax trees that Template Haskell manipulates contain less information than
one would need to write good generic programs. For instance, it is hard to
detect recursion (for instance, between datatypes), and the syntax trees are not
annotated with type information. Finally, Template Haskell does not support
syntactic sugar for generic functions.
1.3.4 Generic Clean
The programming language Clean (Plasmeijer and van Eekelen 2001) provides
a fully integrated generic programming facility (Alimarine and Plasmeijer 2001)
that is based on the same ideas (Hinze 2000 c) as Generic Haskell. The Clean ex-
tension is integrated into the type class system, which is very similar to Haskell’s
system of type classes. Generic functions are deﬁned as special, kind-indexed
classes: a few instances have to be deﬁned, and others can then be derived auto-
matically in a generic way.
Generic Clean does not allow for dependencies between type-indexed func-
tions, which makes it difﬁcult to write generic functions that use other generic
functions on variable types.
Generic programming in Clean has been used for several applications, such as
the generation of automatic tests (Koopman et al. 2003), in the context of dynamic
9
1 Adventure Calls!
types (Achten and Hinze 2002; Achten et al. 2003), and to generate components
of graphical user interfaces (Achten et al. 2004). There has also been work on
optimization of generic functions (Alimarine and Smetsers 2004).
1.3.5 Pattern calculus
The pattern calculus (Jay 2003), based on the constructor calculus (Jay 2001), pro-
vides a very ﬂexible form of pattern matching that permits patterns of multiple
types to occur in a single case construct. Furthermore, special patterns such
as application patterns can be used to match against any constructor. Generic
functions can be implemented by analyzing a value, using sufﬁciently general
patterns. Jay’s calculus allows type inference and has been implemented in the
programming language FIS h2.
Generic functions written in this system are ﬁrst class. Still, the implementation
does not rely on type information to drive the evaluation. Functions written in the
pattern calculus are, however, more difﬁcult to write: the set of patterns for which
a function must be deﬁned in order to behave generically is relatively large, and
some of the patterns embody complicated concepts. Furthermore, because the
pattern match works on a concrete value, not on a type, functions that produce
values generically, such as parsers, are difﬁcult to write.
1.3.6 Dependent types
Lennart Augustsson (1999) was the ﬁrst to suggest the use of dependent types
in the context of Haskell, and proposed a language called Cayenne. While type-
indexed functions, such as provided by Generic Haskell, are functions (or values)
that depend on a type argument, dependent types are types that depend on a
value argument. However, by using dependent types one can simulate generic
functions. In addition, dependent types allow several applications beyond type-
indexed functions, but at the price of signiﬁcantly complicating the type system.
Using some features not provided by Cayenne, a number of complex encodings
of generic functions within a dependently typed language have been presented
by Altenkirch and McBride (2003). The style of dependent programming used in
that paper is further developed in another article (McBride and McKinna 2004),
and has led to the development of Epigram, another programming language that
supports dependent types. Once the development has reached a stable point, it
will be interesting to ﬁnd out if generic programming can be provided in the form
of a simple library in such a language, or if syntactic additions are still desirable
to make generic programming practicable.
10
1.4 Selecting a route
1.4 Selecting a route
In Chapter 2, we make a remark about previous knowledge that we assume from
readers, and discuss notational conventions.
We start our tour of Generic Haskell slowly, ﬁrst introducing a core language
in Chapter 3. This language consists of a subset of Haskell, and is held in a
syntactic style that is mostly compatible with Haskell. Haskell can be relatively
easily desugared to the core language. In this chapter, we also give type checking
rules for the language and present a small step operational semantics.
In most of the other chapters, we will – step by step – introduce the features
that make up Generic Haskell. We usually present some examples, both to mo-
tivate the need for the features that are presented, and to show how they can be
used. For the examples, we usually use full Haskell syntax, to give an impression
of what actual programs look like. After this leisurely introduction of a new fea-
ture, we generally discuss its implementation. We extend the core language with
new constructs as necessary, and discuss the semantics of the new constructs,
usually by presenting a translation back into the original core language. In these
theoretical parts, we work exclusively on the core language and its extensions.
Often, such theoretical parts are marked by a “Lambda”. The “Lambdas” are
friendly fellows and experts on both functional and generic programming. They
accompany the reader during his or her explorations. In this case, the “Lambda”
is advising the reader who is interested more in practical usage of the language
than in the gritty details, that the “Lambda”-marked section could be skipped
without danger (at least on a ﬁrst reading).
Similarly, on rare occasions, the “Lambda” warns that a certain area has not
yet been explored in full detail, and that the following text describes future or
ongoing work.
The chapters on additions to the core language are grouped into two parts.
Chapters 4 to 11 introduce a basic language for generic programming, which is
already quite powerful, but in many places not as convenient as would be de-
sirable. Therefore, the remaining chapters focus on several extensions that allow
writing generic programs more easily, but also aim at enhancing the expressive-
ness of the language even further.
Chapter 4 covers the ﬁrst extension of the core language, the possibility to
deﬁne type-indexed functions. Generic functions are type-indexed functions that
fulﬁll speciﬁc conditions. It thus makes sense to introduce type-indexed functions
ﬁrst, in this chapter, and to discuss genericity later.
The idea of dependencies between type-indexed functions, as introduced in the
paper “Dependency-style Generic Haskell” (L ¨ohet al. 2003), forms the core of
this thesis. Dependencies are ﬁrst discussed in a limited setting in Chapter 5,
11
1 Adventure Calls!
which also slightly generalizes type-indexed functions by allowing more ﬂexible
type patterns. Chapter 6 gives a theoretical account of the extensions explained
in Chapter 5. Only later, in Chapter 9, will we introduce dependencies in full
generality.
In between, we sketch how generic functions work, and give the ﬁrst few ex-
ample generic functions, in Chapter 7. This is not new material, but covered in
several of Hinze’s papers on generic programming in Haskell.
In Chapter 8, we discuss the principle of local redeﬁnition, which offers the
possibility to locally modify the behaviour of a type-indexed function. Local
redeﬁnition forms an essential part of Dependency-style Generic Haskell.
After having presented the full story about dependencies in Chapter 9, we
complete our account of generic functions in the Chapters 10, which focuses on
how to map datatypes to a common structural representation, and 11, which
explains how to translate generic functions, in particular if they are called on
datatypes for which the behaviour has to be derived in a generic way. Both
chapters are based on earlier work on Generic Haskell and adapted here such
that they ﬁt into our framework.
Chapter 11 at the same time marks the end of the central features of Generic
Haskell. With the features discussed up to this point, one has a fully operational
language at hand. Nevertheless, several extensions are extremely helpful, because
they make generic programming both easier and more ﬂexible. These additional
features are introduced in the remainder of the thesis.
Generic abstraction, covered by Chapter 12, is another way of deﬁning type-
indexed functions. Functions deﬁned by generic abstraction do not perform case
analysis on a type argument directly, but use other type-indexed functions and
inherit their type-indexed-ness from those. Generic abstraction is one of the ex-
tensions introduced in the “Generic Haskell, speciﬁcally” (Clarke and L ¨oh 2003)
paper. They are shown here from the perspective of Dependency-style, and ben-
eﬁt signiﬁcantly from the changed setting, allowing for a far cleaner treatment
than in the paper.
In Chapter 13, we discuss type inference, speciﬁcally for type-indexed func-
tions, which can help to reduce the burden on the programmer while writing
generic functions further. Several different problems are discussed, such as infer-
ence of the type arguments in calls to generic functions or the inference of type
signatures of generic functions. While the answers to the questions about type
inference for generic functions are not all positive, it is possible to infer a reason-
able amount of information that allows comfortable programming. This chapter
is for the most part ongoing work and based on unpublished material.
Chapter 14 on default cases presents a way to reuse cases from existing type-
indexed functions while deﬁning new generic functions. Frequently occurring
traversal patterns can thus be captured in basic type-indexed functions, and sub-
12
1.4 Selecting a route
sequently extended to deﬁne several variations of that pattern. Default cases
are covered in “Generic Haskell, speciﬁcally”, but adapted for Dependency-style
here.
In Chapter 15, we extend our core language to allow all of Haskell’s type dec-
laration constructs: type andnewtype as well as data . This becomes relevant
in the following Chapter 16, on type-indexed datatypes, which is based on the
paper of the same name (Hinze et al. 2002). Type-indexed datatypes are like
type-indexed functions, but on the type level: they are datatypes that have a dif-
ferent implementation depending on the structure of a type argument. Again, the
presentation of type-indexed datatypes is signiﬁcantly different from the paper,
because we extend the dependency type system to the type level.
In Chapter 17, we describe a number of different encodings of datatypes into
the Haskell type language, which form alternatives to the standard encoding that
is discussed in Chapter 10. By changing the view on datatypes, some generic
functions become easier to deﬁne, others become more difﬁcult or even impossi-
ble to write. This chapter describes ongoing work.
Chapter 18 on modules shows how type-indexed – and in particular generic
– functions and datatypes can live in programs consisting of multiple mod-
ules, and to what extent separate compilation can be achieved. This chapter
draws upon unpublished knowledge gained from the implementation of Generic
Haskell (Clarke et al. 2002). Modules are also the last step in making Generic
Haskell a complete language on top of Haskell; therefore this chapter concludes
the thesis.
All in all, we present a complete and rich language for generic programming,
which can, has been, and hopefully will be used for several interesting applica-
tions. I wish you a joyful exploration!
13
1 Adventure Calls!
14
2Choosing
the Equipment
In this chapter, we will prepare for our exploration. Section 2.1 brieﬂy discusses
prerequisites for the material presented in this thesis and pointers to introductory
material to gain the assumed knowledge. In Section 2.2, we discuss the status
of the Generic Haskell compiler. In Section 2.3, we explain several notational
conventions that are used in the remainder of this thesis.
2.1 Prerequisites
I have tried to write this thesis in such a way that it is understandable without
a heavy background in generic programming in the context of functional lan-
guages. Because the thesis describes a language extension of Haskell, a familiar-
ity with Haskell is very advisable. I recommend Bird’s excellent textbook (Bird
1998), but the very readable language report (Peyton Jones 2003) might do as
well, especially if another statically typed functional language, such as Clean or
anmlvariant, is already known. It is extremely helpful if one is comfortable with
thedata construct in Haskell to deﬁne new datatypes, and with the kind system
15
2 Choosing the Equipment
that classiﬁes types in the same way as types classify expressions.
In the formal discussion of the language, we use many deduction rules to
deﬁne type checking algorithms and translations. It can therefore do no harm if
one has seen such concepts before. I heartily recommend Pierce’s book on “Types
and programming languages” (Pierce 2002), which serves as a well-motivated
general introduction into the theory of statically typed languages.
If one is interested in the background of generic programming beyond Generic
Haskell, I recommend the Summer School article of Backhouse et al. (1999) –
which contains an introduction to the ﬁeld from a theoretical perspective, without
focus on a speciﬁc programming language – or some of the materials mentioned
in Section 1.3 on related work. If more examples or even exercises are desired,
then the later Summer School articles of Hinze and Jeuring (2003 a,b) provide
material.
2.2 The Generic Haskell compiler
There exists a Generic Haskell compiler. There have been two formal releases,
Amber (Clarke et al. 2001) and Beryl (Clarke et al. 2002), and the current devel-
opment version supports a couple of features that the two released versions do
not. Nevertheless, the compiler lags considerably behind the development of
the theory. The compiler translates into Haskell, and leaves all type checking to
the Haskell compiler. Furthermore, the support for Dependency-style Generic
Haskell, as it is used in this thesis, is rudimentary at best, and type signatures
have to be written using kind-indexed types (cf. Section 6.6). The syntax used in
the compiler is discussed in the User’s Guides for the two releases, and the Sum-
mer School material (Hinze and Jeuring 2003 a,b) contains examples and exercises
that are speciﬁcally targeted at the language that is implemented by the compiler.
Even with its limitations, the compiler can be used to implement a large num-
ber of the examples in this thesis and provide valuable insight into the prac-
tice of generic programming. The current version is available from http://www.
generic-haskell.org/ . It is my hope that in the future this site will have a
version with full support for the features discussed in this thesis.
2.3 A note on notation
This section lists several notational conventions that we adhere to in this thesis.
16
2.3 A note on notation
2.3.1 Natural numbers and sequences
Natural numbers start with 0. Whenever the domain of a numerical value is not
explicitly given, it is a natural number. We use m. .nto denote the set of natural
numbers between mand n, including both mand n. We use m. . to denote the
set of natural numbers greater than or equal to m, and . . nto denote the set of
natural numbers smaller than or equal to n.
2.3.2 Syntactic equality
We use the symbol ≡to denote syntactic equality or meta-equality. The symbol =
is used in Haskell and our languages for declarations, and ==is used as a name
for the equality function in Haskell and our languages.
2.3.3 Repetition
Whenever possible, the ellipsis . . . is notused in this thesis. Instead, we use
repetition constructs that are deﬁned as follows:
{X}i∈m..n|m>n≡ε
|otherwise≡X[i/m]{X}i∈m+1..n
{X}i∈m..n
s|m>n≡ε
|otherwise≡X[i/m]{s X}i∈m+1..n
Read these deﬁnitions as syntactical macros where Xand srepresent arbitrary
syntactical content, iis a variable, and mand nare natural numbers. The substi-
tution is syntactical: where the bound variable i literally occurs in X, the natural
number mis substituted.
Note that if Xorscontain inﬁx operators, the intention is that the associativity
of the inﬁx operator is interpreted after the expansion. For example, the list
1 : 2 : 3 : 4 : 5 : [ ], to be read as 1 : (2 :(3 :(4 :(5 :[ ])))) , could be written as
{i:}i∈1..5[ ].
Using Haskell’s syntactic sugar for lists, we could write
[{i}i∈1..5
, ]
for the same list, namely [1, 2, 3, 4, 5 ].
17
2 Choosing the Equipment
2.3.4 Environments
Environments are ﬁnite maps, associating keys with values. For the entries we
use different syntax depending on what an entry is meant to express. For demon-
stration, we will use entries of the form x/mapsto→v, mapping a key xto a value v. Most
often, we treat environments as lists that extend to the right:
Environments
E :: =ε empty environment
|E,x/mapsto→v non-empty environment .
If not otherwise stated, an environment can only contain one binding for a cer-
tain key. If a second binding is added to the right, then it overwrites the old.
Environments can be reordered. Consequently, we use the notation x/mapsto→v∈E,
but also E≡E/prime,x/mapsto→v, to express the fact that the binding x/mapsto→vis contained in
the environment E. We use the comma (,) also as union operator for two environ-
ments, again with the rightmost binding for a key overwriting all earlier bindings
for the same key. We use the same notation for sets as for environments. Sets are
environments with only keys, i.e., empty values.
2.3.5 Syntax descriptions, metavariables and indices
We introduce a multitude of languages in this thesis, and an important part of
languages is syntax. The syntax of environments above is an example of how we
present syntax descriptions: each syntactic category is named before it is listed,
and each alternative is followed by a description to the right. The symbols on
the right hand side of productions are either terminals that are part of the syntax
(such as εabove), or metavariables that refer to nonterminals of different cate-
gories. The left-hand side of a production introduces the symbol that we use as
metavariable for the category that is just deﬁned, in this case E for environments.
In most cases, we use only one symbol to denote all occurrences of this syn-
tactic category, and distinguish different entities by indexing. Thus, if E is an
environment, then so are E/prime, E2, Ei, or E/prime
j. A list of all metavariables that we use
and their meaning is shown on page 307.
Often, we use variable repetition constructs in syntax descriptions. For exam-
ple, we could also have described the syntax of environments non-inductively
using the following production:
Environments, alternatively
E :: ={xi/mapsto→vi}i∈1..n
, (n∈0 . .)
environment .
18
2.3 A note on notation
Here, we state that an environment may be any comma-separated sequence of
key-value pairs of the form xi/mapsto→vi, where that sequence may be of any length n
in the given range. In the spirit of Section 2.3.1, we drop the explicit range
speciﬁcation (n∈0 . .)if the range is 0 . ., i.e., unrestricted.
2.3.6 Deduction rules
Most properties and algorithms in this thesis are speciﬁed by means of deduction
rules. A sample deduction rule is shown in Figure 2.1.
K;Γ/turnstilelefte::t
Γ/turnstilelefte1::t1→t2
Γ/turnstilelefte2::t1
Γ/turnstileleft(e1e2)::t2(e-app-sample)
Figure 2.1: Sample deduction rule
We give the form of the judgment before the rules, between horizontal lines. In
this case, the judgment is of the form
K;Γ/turnstilelefte::t.
We use the same metavariables as in the syntactic descriptions, and distinguish
multiple occurrences of objects of the same category by use of indices.
Each rule has a name, such as (e-app-sample) in the example. If an environ-
ment such as K in this case is passed on unchanged, we sometimes drop it from
the rule.
2.3.7 Free variables and substitutions
We deﬁne which variables are free when we describe a particular language.
Throughout this thesis, we use fev(e)to refer to free variables of an expression e,
whereas dv(t)refers to free type variables of a type t, and fdv(t)refers to free
dependency variables (see Chapter 6) of a type t.
We write e1[e2/x]to denote the application of the substitution that replaces
every free occurrence of variable xin expression e1by expression e2. We use
substitutions also on other syntactic categories, for instance types. We use the
19
2 Choosing the Equipment
metavariables ϕandψto stand for substitutions, and then write ϕeto denote the
application of a substitution ϕto an expression e.
We usually assume that the application of substitutions does not lead to name
capture, i.e., that alpha-conversion is performed in such a way that no name
capture occurs.
2.3.8 Font conventions
We use bold face in the text to denote language keywords and for deﬁnitions. In
the index, pages containing the deﬁnition of a certain notion are also in bold face.
We emphasize important notions that are not deﬁned elsewhere or not deﬁned
in this thesis. Again, we point to pages containing such notions using an empha-
sized page number in the index.
We use capital Greek letters to denote environments. Note that capital Greek
letters are always written upright, so E denotes a capital “epsilon”, whereas Eis
a capital “e” – we try to avoid such clashes as much as possible, though, to avoid
confusion.
In code examples, next to the bold keywords ,identiﬁers are written in italics,
Type names are capitalized, Constructors capitalized in italics, and type Classes
capitalized using a sans-serif font.
We also use a sans-serif font for internal operations, i.e., functions on the meta-
language level, such as fev(e)to determine the free variables of an expression.
The arguments of internal operations are always enclosed in parentheses.
20
3 A Functional Core
Before we will start on our tour into the ﬁeld of generic functions, we will stick
to the known for a while. While we will describe generic programming in the
context of Generic Haskell, an extension to the Haskell language, in an informal
way, we also need a vehicle for formal analysis of the generic features, a solid
core language to base our extensions on. To this end, we will introduce a basic
functional core language, named fc, in this chapter, much like what the Haskell
Language Report (Peyton Jones 2003) uses as the target of translation for all of
the advanced constructs deﬁned in the Haskell language.
The language fcis designed to be sufﬁciently rich that, in conjunction with the
gradual extensions following in future chapters, it can be used to demonstrate
the full power of generic programming in a formal setting.
Although there are no language constructs speciﬁc to generic functions in this
chapter and the language may look very familiar, this chapter also introduces
some notations and mechanisms that will be used extensively throughout the
rest of the thesis. This chapter is probably not necessary to understand the rest of
the thesis, but is a good reference to look up unfamiliar notation or terminology.
Type systems and their properties for very similar languages are given in
Pierce’s book (2002).
21
3 A Functional Core
3.1 Syntax of the core language fc
The syntax of the core language is shown in Figure 3.1.
A program is a list of datatype declarations followed by a special expression
called main .
Datatype declarations are modelled after Haskell’s data construct. A datatype
may be parametrized (we write the type arguments using a type-level Λ, which
may only occur in a datatype deﬁnition). A datatype has zero or more con-
structors , each of which has a number of arguments (or ﬁelds ).
Kinds are the types of types. Kind ∗is reserved for all types that can be
assigned to expressions, whereas parametrized datatypes (also called type con-
structors) have functional kinds.
The type language has variables and named types (types that have been de-
ﬁned as datatypes). Two types can be applied to each other. We can universally
quantify over a type variable. Function types are not explicitly included in the
syntax, but we assume that the function type constructor (→)is part of the named
types T, and available as a built-in type constant.
In expressions, one can refer to variables and constructors. Application and
lambda abstraction deal with functions. An expression can be analyzed in a case
statement. We call this expression the head of that case statement.
A case statement consists of multiple arms , where each arm consists of an
expression that is guarded by a pattern. Patterns are a restricted form of expres-
sions, consisting of (fully applied) constructors and variables only. All variables
in a pattern must be distinct.
A let statement allows to locally deﬁne a new function via a function decla-
ration. The value bound in the let is visible in the expression that constitutes
thebody of the let. It is, however, not visible in the deﬁnition of the local value
itself, i.e., this is nota recursive let. The ﬁxstatement can be used to introduce
recursion.
Using ﬁxand assuming that we have n-ary tuples for arbitrary n, we can deﬁne
a recursive let statement letrec as a derived form. In Section 3.6, we will formally
introduce recursive let as a language extension, and subsequently replace letwith
letrec , as in Haskell.
We will often assume that certain datatypes, such as tuples and lists or inte-
gers, and some primitive functions on them, are predeﬁned. We will also often
use more convenient notation for some operations and constructs, such as the
tuple and list notation that is standard in Haskell, grouping of multiple lambda
abstractions, and inﬁx operators. In particular (and probably most important),
we will write
t1→t2
22
3.1 Syntax of the core language fc
Programs
P::={Di;}i∈1..nmain =etype declarations plus main expression
Type declarations
D::=data T={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|
datatype declaration
Value declarations
d::=x=e function declaration
Kinds
κ::=∗ kind of manifest types
|κ1→κ2 functional kind
Types
t,u::=a,b,c,f, . . . type variable
|T named type
|(t1t2) type application
| ∀a::κ.t universal quantiﬁcation
Expressions
e::=x,y,z, . . . variable
|C constructor
|(e1e2) application
|λx→e lambda abstraction
|case e0of{pi→ei}i∈1..n
;
case
|letdine let
|ﬁxe ﬁxed point
Patterns
p::= (C{pi}i∈1..n) constructor pattern
|x,y,z, . . . variable pattern
Figure 3.1: Syntax of the core language fc
23
3 A Functional Core
for the type of functions from t1tot2. All these constructs are used to make
examples more readable. It is easy to translate them away.
In the following, we will deﬁne when an fcprogram is correct and present an
operational semantics of the language.
3.2 Scoping and free variables
The language fchas the usual scoping rules. Type variables are bound only
by type-level lambda Λin datatype declarations, and by universal quantiﬁers.
Abstracted type variables in datatypes are visible in the entire datatype deﬁnition;
quantiﬁed type variables everywhere underneath the quantiﬁer. We use dv(t)to
refer to the free type variables of a type t.
Constructor and type names scope over the whole program.
Value-level variables are introduced by a let statement, by a lambda abstraction,
and by the patterns in a case statement. A let binds all variables that occur on
the left hand side of its declarations in its body. A lambda abstraction binds its
variable in its body, too. A pattern binds all variables that occur in the pattern
in the expression that corresponds to the pattern. Patterns are only legal if all
variables in one pattern are different. We use fev(e)to refer to the free variables
of an expression e.
Programs are equivalent under alpha-conversion, i.e., bound variables can be
renamed without changing the meaning of the program.
Substitution is generally meant to be capture-avoiding: if the substituted ex-
pression contains variables that would be captured by a binding construct, it is
assumed that alpha-conversion is performed so that no name capture takes place.
If name capture is intended, we will explicitly mention that fact.
3.3 Types and kinds
For the large part of this thesis, we will not consider type inference (an exception is
Chapter 13). Nevertheless, type safety is an essential part of generic programming
and thus of Generic Haskell. Therefore we present rules that specify when a
program in the core language can be assigned a type. We will not, however,
present algorithms to ﬁnd a suitable type.
We annotate all type variables with kinds; therefore ﬁnding the kind of a type is
straightforward, given the kind rules that follow. On the value level, however, we
do not use type annotations explicitly, but assume that they are given as needed,
in addition to the program.
24
3.3 Types and kinds
One way to view the core language is as a variant of the polymorphic lambda
calculus Fω(Girard 1972), where all the type applications and type abstractions
have been separated from the program, but can be recovered during the type
checking phase as needed. Leaving out the type annotations allows us to focus
on the part that is central to this thesis – the generic programming – and also to
write the examples in a language which is closer to what the programmer will
actually write in a real programming language, which will be able to infer types
at least for expressions that Haskell can infer types for.
Our language is more expressive than Haskell, though. We allow universal
quantiﬁcation to occur everywhere in types, thereby opening the possibility to
express types of arbitrary rank, as opposed to Haskell 98, which only admits
rank-1 types. Rank- ntypes do occur frequently in the treatment of generic func-
tions, and it is desirable that a language for generic programming supports them.
They are implemented as an extension to Haskell and useful in many other ar-
eas (Peyton Jones and Shields 2003).
Furthermore, we allow universally quantiﬁed types to occur within datatypes,
and even datatypes parametrized with polymorphic types, but these features are
rarely used and not essential.
As datatypes play a central role in Generic Haskell, it is important to be familiar
with the concept of kinds. Let us therefore review the Haskell kind system.
The kind∗is reserved for types that can be assigned to expressions in the lan-
guage, whereas parametrized types (or type constructors ) behave like functions
on the type level and are assigned functional kinds. For instance, the Haskell
types Int, Char and Bool are all of kind ∗, whereas Maybe, the list constructor [ ],
or the input-output monad IO are of kind ∗→∗ . The pair constructor (,)and
Either are both of kind ∗→∗→∗ . We will sometimes abbreviate ∗→∗→∗ to
∗2, where
∗n={∗→}i∈1..n∗.
Kinds need not be of the form ∗nfor some natural number n, as types can be
parametrized over type constructors. A simple example is
data IntStruct (f::∗→∗ ) =I(fInt).
Here, fis a variable of kind ∗→∗ that can be instantiated, for example, to some
container type. Hence, IntStruct has kind (∗→∗ )→∗. We will encounter more
examples of types with complex kinds later.
During kind checking, we make use of an environment K that contains bind-
ings of the form a::κand T::κ, associating type variables and named types with
kinds. The kind checking rules are given in Figure 3.2 and are of the form
K/turnstileleftt::κ,
25
3 A Functional Core
K/turnstileleftt::κ
a::κ∈K
K/turnstilelefta::κ(t-var)T::κ∈K
K/turnstileleftT::κ(t-named)
K/turnstileleftt1::κ1→κ2K/turnstileleftt2::κ1
K/turnstileleft(t1t2)::κ2(t-app)
K,a::κ/turnstileleftt::∗
K/turnstileleft∀a::κ.t::∗(t-forall)
Figure 3.2: Kind checking for core language of Figure 3.1
expressing that under environment K, the type thas kind κ. The rules themselves
bear no surprises: variables and named types are looked up in the environment,
application eliminates functional kinds, and universal quantiﬁcation works for
variables of any kind, but the resulting type is always of kind ∗.
The type rules that are displayed in Figure 3.3 are of the form
K;Γ/turnstilelefte::t,
which means that expression eis of type tunder environment Γand kind en-
vironment K. The environment K is of the same form as in the kind inference
rules, whereas Γcontains entries of the form x::tand C::t, associating a type
twith a variable xor a constructor C. Recall our convention from Section 2.3.6
that we may omit environments that are not important to a rule (i.e., passed on
unchanged). The kind environment K is rarely needed during type checking.
Again, most rules are simple: variables and constructors are looked up in the
environment. Application and lambda abstraction are simple. Also, let state-
ments are easy to check as they are non-recursive.
The rule for case statements is the most complicated rule: The head of the
case, e0, must type check against a type t0. This type must match the type of the
patterns. Each pattern can bind a number of variables, which is witnessed by
the environments Γi. Each arm eiis now checked with an extended environment
where the variables bound by the respective pattern are added. All arms must be
of the same type t, which is then also the type of the whole expression. The rules
for pattern matching are shown in Figure 3.4 and explained in Section 3.3.1.
26
3.3 Types and kinds
K;Γ/turnstilelefte::t
x::t∈Γ
Γ/turnstileleftx::t(e-var)C::t∈Γ
Γ/turnstileleftC::t(e-con)
Γ/turnstilelefte1::t1→t2
Γ/turnstilelefte2::t1
Γ/turnstileleft(e1e2)::t2(e-app)K/turnstileleftt1::∗
K;Γ,x::t1/turnstilelefte::t2
K;Γ/turnstileleftλx→e::t1→t2(e-lam)
Γ/turnstilelefte0::t0
{Γ/turnstileleftpatpi::t0/squigglerightΓi}i∈1..n
K/turnstileleftt::∗
{K;Γ,Γi/turnstileleftei::t}i∈1..n
K;Γ/turnstileleftcase e0of{pi→ei}i∈1..n
; ::t(e-case)
Γ/turnstilelefte/prime::t/prime
Γ,x::t/prime/turnstilelefte::t
Γ/turnstileleftletx=e/primeine::t(e-let-val)Γ/turnstilelefte::t→t
Γ/turnstileleftﬁxe::t(e-ﬁx)
a/∈dv(Γ)
K,a::κ;Γ/turnstilelefte::t
K;Γ/turnstilelefte::∀a::κ.t(e-gen)Γ/turnstilelefte::t1
/turnstileleftt1/lessorequalslantt2
Γ/turnstilelefte::t2(e-subs)
Figure 3.3: Type checking for core language of Figure 3.1
27
3 A Functional Core
The ﬁx behaves as a ﬁxpoint construct. Therefore the expression must have
the type of a function where domain and codomain are both of type t. The least
ﬁxpoint is then of type t.
A type can be generalized, that is, universally quantiﬁed with respect to a type
variable, if it can be type checked without any assumption about the type variable
in the type environment Γ.
Finally, there is a rule for subsumption. Polymorphic types can be specialized,
and monomorphic types generalized under certain circumstances. The subsump-
tion relation is shown in Figure 3.5 and described in Section 3.3.2.
Γ1/turnstileleftpatp::t/squigglerightΓ2
Γ/turnstileleftpatx::t/squigglerightx::t(p-var)
C::{ti→}i∈1..nt0∈Γ
{Γ/turnstileleftpatpi::ti/squigglerightΓi}i∈1..n
Γ/turnstileleftpatC{pi}i∈1..n::t0/squiggleright{Γi}i∈1..n
,(p-con)
Figure 3.4: Type checking for patterns, extends Figure 3.3
K/turnstileleftt1/lessorequalslantt2
/turnstileleftt/lessorequalslantt(s-reﬂ)/turnstileleftt3/lessorequalslantt1
/turnstileleftt2/lessorequalslantt4
/turnstileleft(t1→t2)/lessorequalslant(t3→t4)(s-fun)
a/∈dv(t1)
K,a::κ/turnstileleftt1/lessorequalslantt2
K/turnstileleftt1/lessorequalslant∀a::κ.t2(s-skol)K/turnstileleftu::κ
K/turnstileleftt1[u/a]/lessorequalslantt2
K/turnstileleft∀a::κ.t1/lessorequalslantt2(s-inst)
Figure 3.5: Subsumption relation on core types, extends Figure 3.3
28
3.4 Well-formed programs
3.3.1 Patterns
For patterns, we use a variation of the typing judgment that tells us about the
variables that are bound by the pattern. The form of the judgment is
Γ1/turnstileleftpatp::t/squigglerightΓ2,
which means that under environment Γ1the pattern pis of type t, binding the
environment Γ2.
A variable can have any type, and the variable is bound to that type. Note that
pattern variables are not taken from the environment: patterns bind variables
rather than refer to them.
A constructor pattern is checked as follows: the constructor has to be in the
environment. In the pattern, the constructor has to appear fully applied, i.e., if
its type is a function with narguments, then there must be nargument patterns
piof matching type. The pattern binds all variables bound by the arguments. We
require all the bound variables to be distinct.
3.3.2 Subsumption
The subsumption judgments are of the form
K/turnstileleftt1/lessorequalslantt2,
which expresses the fact that an expression of type t1can behave as an expression
of type t2under kind environment K.
The relation is reﬂexive and furthermore has two rules that deal with adding
and removing universal quantiﬁers. The function type constructor is contravari-
ant in its ﬁrst argument, which is reﬂected in the subsumption rule for functions.
3.4 Well-formed programs
Some loose ends remain to be tied: for example, constructors need to be present
in the environments, but are nowhere inserted. In fact, constructors are deﬁned
by the data declarations.
Figure 3.6 shows how: each type that occurs in one of the constructors (i.e., all
thetj,k’s) must be of kind ∗, where the kind environment is extended with the type
variables that constitute the parameters of the datatype. For each constructor, a
type is added to the resulting environment.
A whole program can now be checked as shown in Figure 3.7: checking pro-
ceeds against two environments K 0andΓ0, which may contain external types
29
3 A Functional Core
and functions. We always assume that at least (→)::∗→∗→∗ is in K 0, but
we often add additional types and functions on them, such as tuples or inte-
gers and arithmetic operations. All datatype declarations are checked for well-
formedness against an extended environment K, which consists of K 0plus all the
datatypes declared in the program with their kinds. This expresses the fact that
all datatypes may be mutually recursive. The Γicontaining the constructors are
added to Γ0to form Γ, and using this Γ, the main function is type checked. The
type of the main function is also the type of the program.
3.5 Operational semantics
We deﬁne values , which are intended to be results of programs, in Figure 3.8.
Values are a subset of the expression language, built from constructors (construc-
tors are distinguished from functions by the fact that they cannot be reduced) and
lambda abstractions. In addition, there is fail, which represents run-time failure.
Failure will be used as the result of a case expression where none of the patterns
matches the expression in the head.
Heads of case expressions are evaluated to weak head-normal form to reveal
the top-level constructor during pattern matching. The syntax for weak head-
normal form expressions is like the syntax for values, only that the arguments
of the top-level constructor do not have to be evaluated and can be arbitrary
expressions.
We extend the expression language with failure as well, as failure can occur
while reducing expressions. The new type rule for failis given in Figure 3.9: as
failrepresents failure, it can have any type.
Figure 3.10 presents small-step reduction rules to reduce expressions to values.
We write
/turnstilelefte1/arrowtailrighte2
to denote that e1reduces to e2in one reduction step.
The reduction of a program is equivalent to the reduction of the main expres-
sion. In other words, the datatype declarations are not needed for the reduction
of an expression. Constructors are syntactically distinguished, and knowing that
a name represents a constructor is enough to formulate the reduction rules.
The reduction rules can be extended by additional rules for built-in functions.
If a program is type checked under an initial type environment Γ0containing
primitive functions (not constructors), it is necessary to provide reduction rules
for these functions as well.
30
3.5 Operational semantics
K1/turnstileleftD/squigglerightK2;Γ
D≡data T={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|/braceleftbig{K{,ai::κi}i∈1../lscript/turnstilelefttj,k::∗}k∈1..nj/bracerightbigj∈1..m
Γ≡/braceleftbig
Cj::{∀ai::κi.}i∈1../lscript{tj,k→}k∈1..njT{ai}i∈1../lscript/bracerightbigj∈1..m
,
K/turnstileleftD/squigglerightT::{κi→}i∈1../lscript∗;Γ(p-data)
Figure 3.6: Well-formed data declarations
K;Γ/turnstileleftP::t
P≡{Di;}i∈1..nmain =e
{K/turnstileleftDi/squigglerightKi;Γi}i∈1..n
K≡K0,{Ki}i∈1..n
, Γ≡Γ0,{Γi}i∈1..n
,
K;Γ/turnstilelefte::t
K0;Γ0/turnstileleftP::t(p-prog)
Figure 3.7: Well-formed programs
31
3 A Functional Core
Values
v::=C{vi}i∈1..nconstructor
|λx→e function
|fail run-time failure
Weak head-normal form
w::=C{ei}i∈1..nconstructor
|λx→e function
|fail run-time failure
Expressions
e::=. . . everything from Figure 3.1
|fail run-time failure
Figure 3.8: Syntax of values, extends Figure 3.1
K;Γ/turnstilelefte::t
K;Γ/turnstileleftt::∗
K;Γ/turnstileleftfail::t(e-fail)
Figure 3.9: Type rule for run-time failure, extends Figure 3.3
Let us look at the reduction rules in a little bit more detail. The rule (r-con)
causes that, if a constructor is encountered, its arguments are reduced to values
one by one. The rule for application implements lazy evaluation and beta reduc-
tion: the function is reduced before its argument, and when a lambda abstraction
is encountered, the argument is substituted for the variable in the body of the
function. Run-time failure is propagated.
Most involved is, once more, the treatment of case statements. We try to match
the ﬁrst pattern against the head expression. If the match succeeds, as in (r-
case-1), the match results in a substitution ϕ(mapping the variables bound in
the pattern to the matching parts of the expression). Note that alpha-conversion
may need to be performed on the arm p1→e1prior to the derivation of ϕin
order to avoid name capture. The substitution ϕis then applied to the expression
belonging to the ﬁrst arm. If the match fails, as in (r-case-2), the ﬁrst arm of
the case is discarded, i.e., matching continues with the next arm. If no arms
are available anymore, as in (r-case-3), there is nothing we can do but to admit
run-time failure.
32
3.5 Operational semantics
A let statement is reduced by substituting the expression for the variable in the
body. Finally, a ﬁxpoint statement introduces recursion.
We have not yet shown how to perform a pattern match. This is detailed in
Figure 3.11. These rules have conclusions of the form
/turnstileleftmatchp←e/squigglerightϕ.
This is to be understood as that pattern pmatches value e, yielding a substitution
ϕ, mapping variables to expressions. We assume that failis a special substitution,
mapping all variables to the expression fail.
First, the expression to be matched is reduced using rule (m-reduce) until it
reaches weak head-normal form. We use the internal function whnf (e)to express
the syntactic condition that eis in weak head-normal form. The rule (m-con)
shows that if both pattern and expression are of the same constructor, the argu-
ments are matched one by one. The resulting substitution is the reverse compo-
sition of all substitutions originating from the arguments. (The order of compo-
sition is actually not important, because the pattern variables do not occur in the
substituting expressions and the domains of the substitutions will be disjoint, as
we declare patterns legal only if each variable occurs at most once.) Note that
if one of the substitutions is fail, then the resulting substitution is fail, too. In
rule (m-var), we see that matching against a variable always succeeds, binding
the variable to the expression. The other rules indicate that everything else fails:
matching two different constructors against each other, or matching a function
against a constructor, and matching the failvalue against anything.
There is a slight deviation from Haskell here, which simpliﬁes the rules a little,
but is otherwise nonessential: if the evaluation of an expression during a pattern
match fails, then only this particular match fails, but the entire case statement
may still succeed.
We can capture the safety of the reduction relation in the following two the-
orems. The progress and preservation properties are easy to prove for this lan-
guage, as it is a core language without any special features. Readers familiar with
such proofs may want to skip ahead to the next section.
Theorem 3.1 (Progress). Ifeis a closed expression (i.e., fev(e)≡ε) and K; Γ/turnstilelefte::t,
then either eis a value or there is an e/primewith/turnstilelefte/arrowtailrighte/prime.
Note that there is no guarantee of termination, as we have unbounded recur-
sion by means of the ﬁx statement.
Proof. We prove the theorem by induction on the type derivation for e. The last
rule applied cannot have been (e-var), because eis closed. If it was (e-con), then e
is a constructor and thereby a value. Likewise for (e-lam) and (e-fail).
33
3 A Functional Core
/turnstilelefte1/arrowtailrighte2
n∈1 . ./turnstilelefte1/arrowtailrighte/prime
1
/turnstileleftC{vi}i∈1..m{ei}i∈1..n/arrowtailrightC{vi}i∈1..me/prime
1{ei}i∈2..n(r-con)
/turnstilelefte1/arrowtailrighte/prime
1
/turnstileleft(e1e2)/arrowtailright(e/prime
1e2)(r-app-1)
/turnstileleft((λx→e1)e2)/arrowtailrighte1[e2/x](r-app-2)
/turnstileleft(faile)/arrowtailrightfail(r-app-3)
n∈1 . ./turnstileleftmatchp1←e/squigglerightϕ ϕ/negationslash≡fail
/turnstileleftcase eof{pi→ei}i∈1..n
;/arrowtailrightϕe1(r-case-1)
n∈1 . ./turnstileleftmatchp1←e/squigglerightfail
/turnstileleftcase eof{pi→ei}i∈1..n
;/arrowtailrightcase eof{pi→ei}i∈2..n
;(r-case-2)
/turnstileleftcase eofε/arrowtailrightfail(r-case-3)
/turnstileleftletx=e1ine2/arrowtailrighte2[e1/x](r-let)/turnstileleftﬁxe/arrowtailrighte(ﬁxe)(r-ﬁx)
Figure 3.10: Reduction rules for core language of Figure 3.1
34
3.5 Operational semantics
/turnstileleftmatchp←e/squigglerightϕ
¬whnf (e)/turnstilelefte/arrowtailrighte/prime
/turnstileleftmatchx←e/prime/squigglerightϕ
/turnstileleftmatchx←e/squigglerightϕ(m-reduce)
{/turnstileleftmatchpi←ei/squigglerightϕi}i∈1..n
ϕ≡{ϕn+1−i}i∈1..n·
/turnstileleftmatchC{pi}i∈1..n←C{ei}i∈1..n/squigglerightϕ(m-con)
/turnstileleftmatchx←w/squiggleright(x/mapsto→w)(m-var)
C1/negationslash≡C2
/turnstileleftmatchC1{pi}i∈1..n←C2{ej}j∈1..n/squigglerightfail(m-fail-1)
/turnstileleftmatchC{pi}i∈1..n←λx→e/squigglerightfail(m-fail-2)
/turnstileleftmatchC{pi}i∈1..n←fail/squigglerightfail(m-fail-3)
Figure 3.11: Pattern matching for the core language of Figure 3.1, extends Figure 3.10
35
3 A Functional Core
In the case (e-app) (i.e., e≡(e1e2)), by induction hypothesis e1is either a value
or can be reduced. If e1can be reduced, then (r-app-1) applies. If e1is a value,
then e1is either failor a lambda abstraction or a (partially applied) constructor.
Depending on that, either (r-app-3) or (r-app-2) or (r-con) can be applied.
If the last type rule used is (e-case) and there is at least one arm in the state-
ment, then (r-case-1) or (r-case-2) applies, depending on whether the pattern
match succeeds or fails. We assume here that the pattern match can always be
performed, which can be proved by another induction argument. Rule (r-case-3)
is left for the case that there are no arms.
If the type derivation ends in a (e-let-val) or (e-ﬁx), the corresponding reduction
rules (r-let) and (r-ﬁx) are possible.
For both (e-gen) and (e-subs), applying the induction hypothesis yields the
proposition immediately.
Theorem 3.2 (Type preservation). If K;Γ/turnstilelefte::tand/turnstilelefte/arrowtailrighte/prime, then K; Γ/turnstilelefte/prime::t.
This property, often called subject reduction , means in words that if an expres-
sion ecan be assigned type tunder some environment, and ereduces to e/prime, then
e/primestill has type tunder the same environment.
Proof. Again, we proceed by induction on the typing derivation. If the last rule is
(e-var) or (e-con), then there are no reduction rules that can be applied. The same
holds for rules (e-lam) and (e-fail).
In the case that the last rule is (e-app), four reduction rules are possible: in the
case of (r-app-3), the proposition trivially holds, and in the case of (r-app-1), the
proposition follows immediately from the induction hypothesis applied to the
function. The same holds for the case of (r-con); here, the induction hypothesis
is applied to the ﬁrst non-value argument of the constructor. If the reduction
rule applied is (r-app-2), then we need the fact that a type is preserved under
substitution, which we will prove as Lemma 3.3.
This lemma also helps us in case (e-let-val), where the only reduction rule that
applies is (r-let).
If we have a case statement and the last type rule used is (e-case), there are three
reduction rules that could apply: for (r-case-2), we see from the form of (e-case)
that an arm from a case statement still allows the same type judgment as before.
For (r-case-3), the proposition holds again trivially, which leaves (r-case-1). In this
situation,
e≡case e0of{pi→ei}i∈1..n
; .
Let{xi}i∈1..m
, be the variables contained in p1. Then, by (e-case), we have
Γ,Γ1/turnstilelefte1::t
36
3.6 Recursive let
where Γ1≡{xi::ti}i∈1..m
, (we can prove this equality using a straightforward
induction on the pattern ( /turnstileleftpat) judgments). From (r-case-1), we know that
/turnstileleftmatchp1←e/squigglerightϕ,
and using a similarly straightforward induction on the pattern matching ( /turnstileleftmatch)
judgments, we can show that ϕis a composition of simple substitutions replacing
each xiwith some expression of type ti. Applying Lemma 3.3 then leads to the
desired result that Γ/turnstileleftϕe1::t.
If the last step has been (e-ﬁx), then e≡ﬁxe0. Hence, we have to show that
Γ/turnstilelefte0(ﬁxe0)::t. ButΓ/turnstilelefte0::t→t, andΓ/turnstileleftﬁxe0::t, therefore an application
of (e-app) does the trick.
In the case (e-gen), we have to show that /turnstilelefte/prime::∀a::κ.t. From the induction
hypothesis, applied to e::t, we know that K, a::κ;Γ/turnstilelefte/prime::t. Because a/∈dv(Γ),
we can immediately reapply (e-gen) to get the desired result.
If the last derivation step is using rule (e-subs), then there is a type t/primewith
/turnstileleftt/prime/lessorequalslanttand/turnstilelefte::t/prime. We can apply the induction hypothesis to e::t/prime, resulting
in/turnstilelefte/prime::t/prime. Reapplying (e-subs), which only depends on the type, not on the
expression, proves the proposition.
It remains to show the promised lemma:
Lemma 3.3 (Substitution). IfΓ,x::u/turnstilelefte::tandΓ/turnstilelefte/prime::u, then Γ/turnstilelefte[e/prime/x]::t.
Proof. Once more, we will prove the lemma using an induction on the type
derivation for e, inspecting the last derivation step.
If the last step is (e-var), then eis a variable, i.e., e≡y. Ify/negationslash≡x, then e[e/prime/x]≡
e, and the proposition holds. If y≡x, then t≡u, because Γ,x::u/turnstileleftx::u.
Furthermore, e[e/prime/x]≡e/prime. Since Γ/turnstilelefte/prime::u, we are done.
If the last step is (e-con), then eis a constructor and unaffected by substitution.
In the case of (e-app), we can apply the induction hypothesis to both function
and argument.
All other cases are similar to (e-app). We can make sure that bound variables
do not interfere with the substituted variable xby renaming. After that, the sub-
stitution only affects the subexpressions that occur in the construct, and we can
therefore obtain the desired result directly by applying the induction hypothesis
to all subexpressions.
3.6 Recursive let
We introduce letrec as a derived syntactic construct, deﬁned by its translation to a
combination of ﬁx,let, and case , as in Figure 3.13. We only show rule (tr-letrec)
37
3 A Functional Core
for the letrec construct – all other constructs are unaffected by the translation.
The translation assumes that we have tuples available in the language, and we
use sel(m,n)(where 1/lessorequalslantm/lessorequalslantn) as an abbreviation for the function that selects
them-th component of an n-tuple. It can be deﬁned as
sel(m,n)≡λx→case xof/parenleftbig{xi}i∈1..n
,/parenrightbig→xm.
We call the language that contains letrec , but no (non-recursive) let,fcr. Its
syntax is deﬁned in Figure 3.12.
Expressions
e::=. . . everything except letfrom Figure 3.1
|letrec{di}i∈1..n
; inerecursive let
Figure 3.12: Syntax of fcr, modiﬁes the core language fcof Figure 3.1
/llbracketefcr/rrbracketrec≡efc
zfresh/largellbracket
letrec{xi=ei}i∈1..n
; ine0/largerrbracketrec≡
letz=ﬁx/parenleftBig
λz→{letxi=sel(i,n)zin}i∈1..n/parenleftbig{/llbracketei/rrbracketrec}i∈1..n
,/parenrightbig/parenrightBig
in case zof({xi}i∈1..n
, )→/llbrackete0/rrbracketrec(tr-letrec)
Figure 3.13: Translation of fcrtofc
We deﬁne the operational semantics of letrec via the translation into the lan-
guage without letrec , given above. The translation touches only recursive lets,
leaving everything else unchanged.
We need a new type judgment for recursive let and prove that it coincides with
the type of its translation. The rule is given in Figure 3.14: both expressions
bound and the body are checked in an extended environment, which contains
the types of the bound variables.
Theorem 3.4 (Correctness of letrec typing). Ife≡letrec{xi=ei}i∈1..n
; ine0,
and K; Γ/turnstilelefte::tcan be assigned using (e-letrec-val), then K; Γ/turnstileleft/llbrackete/rrbracketrec::t.
Proof. The proof is by induction on the derivation of the translated expression.
38
3.6 Recursive let
Γ/prime≡Γ{,xi::ti}i∈1..n
{Γ/prime/turnstileleftei::ti}i∈1..nΓ/prime/turnstilelefte::t
Γ/turnstileleftletrec{xi=ei}i∈1..n
; ine::t(e-letrec-val)
Figure 3.14: Type checking for recursive let, modiﬁes Figure 3.3
The translation for a recursive let statement involves tuples, thus we assume
that appropriate entries are present in the environments. If we set t0≡t, then we
know from rule (e-letrec-val) that for all ei, we have Γ/prime/turnstileleftei::ti, where Γ/prime≡Γ,Γ/prime/prime
with
Γ/prime/prime≡{xi::ti}i∈1..n
, .
The induction hypothesis states that
{Γ/prime/turnstileleft/llbracketei/rrbracketrec::ti}i∈0..n.
The ﬁrst goal is to make a statement about the type of the argument to the ﬁx
operator. The innermost tuple has the type
Γ/prime/turnstileleft({/llbracketei/rrbracketrec}i∈1..n
, )::({ti}i∈1..n
, ).
From the deﬁnition of sel(i,n), it is easy to see that
Γ,z::({ti}i∈1..n
, )/turnstileleftsel(i,n,z)::ti.
Therefore, the entire nested non-recursive letstatement is of type
Γ,z::({ti}i∈1..n
, )/turnstileleft{letxi=sel(i,n)zin}i∈1..n/parenleftbig{/llbracketei/rrbracketrec}i∈1..n
,/parenrightbig
::({ti}i∈1..n
, ),
by repeated application of rule (e-let-val). Subsequently, we use (e-lam) followed
by (e-ﬁx) to see that
Γ/turnstileleftﬁx/parenleftBig
λz→{letxi=sel(i,n)zin}i∈1..n/parenleftbig{/llbracketei/rrbracketrec}i∈1..n
,/parenrightbig/parenrightBig
::({ti}i∈1..n
, ).
In the following, let
e/prime≡ﬁx/parenleftBig
λz→{letxi=sel(i,n)zin}i∈1..n/parenleftbig{/llbracketei/rrbracketrec}i∈1..n
,/parenrightbig/parenrightBig
,
and we will now inspect the whole translation result
letz=e/primein case zof({xi}i∈1..n
, )→/llbrackete0/rrbracketrec.
39
3 A Functional Core
The rule (e-let-val) states that since we already know that Γ/turnstilelefte/prime::({ti}i∈1..n
, ), it
sufﬁces to show that
Γ,z::({ti}i∈1..n
, )/turnstileleftcase zof({xi}i∈1..n
, )→/llbrackete0/rrbracketrec::t
to prove the theorem. The induction hypothesis stated that Γ/prime/turnstileleft/llbrackete0/rrbracketrec::t, and it
does not change anything if we extend the environment Γ/primewith the binding for z
because zdoes not occur free in e0or/llbrackete0/rrbracketrec. It thus remains to apply (e-case) in
the right way: because the pattern is the same as above and therefore of type
Γ,z::({ti}i∈1..n
, )/turnstileleftpat({xi}i∈1..n
, )::({ti}i∈1..n
, )/squigglerightΓ/prime/prime,
we are done.
In Haskell, the keyword letis used to denote recursive let. Because fcrcontains
only recursive let statements, we will do the same from now on and use the let
keyword instead of letrec .
40
4 Type-indexed Functions
We are now going to leave the known territory of the functional core language.
Over the next chapters, we will introduce the theory necessary to compile generic
functions in several small steps.
As we have learned in the introduction, generic functions are type-indexed
functions. We will therefore, in this chapter, explain type-indexed functions,
which are functions that take an explicit type argument and can have behaviour
that depends on the type argument. The next chapter extends the class of type
arguments we admit in both deﬁnition and call sites of type-indexed functions.
After that, in Chapter 7, we will really make type-indexed functions generic, such
that they work for a signiﬁcantly larger class of type arguments than those that
they are explicitly deﬁned for.
4.1 Exploring type-indexed functions
We call a function type-indexed if it takes an explicit type argument and can have
behaviour that depends on the type argument. Let us jump immediately to a ﬁrst
41
4 Type-indexed Functions
example and see what a type-indexed function looks like:
add/angbracketleftBool/angbracketright= (∨)
add/angbracketleftInt/angbracketright= (+)
add/angbracketleftChar/angbracketright=λx y→chr(add/angbracketleftInt/angbracketright(ord x ) (ord y )).
The above function adddeﬁnes an addition function that works for any of the
three types Bool, Int, Char. In principle, the deﬁnition can be seen as the def-
inition of three independent functions: one function add/angbracketleftBool/angbracketright, which takes
two boolean values and returns the logical “or” of its arguments; one function
add/angbracketleftInt/angbracketright, which performs numerical addition on its two integer arguments; ﬁ-
nally, one function add/angbracketleftChar/angbracketright, which returns the character of which the nu-
merical code is the sum of the numerical codes of the function’s two character
arguments. The three functions just happen to have a name consisting of two
parts, the ﬁrst of which is identical for all three of them, and the second of which
is the name of a type in special parentheses.
In Generic Haskell, type arguments are always emphasized by special paren-
theses.
One way in which this type-indexed function differs from three independent
functions is its type. The type of addis
/angbracketlefta::∗/angbracketright→ a→a→a.
Very often, to emphasize that addis a type-indexed function, we move the type
argument to the left hand side of the type signature:
add/angbracketlefta::∗/angbracketright::a→a→a.
This means that addhas an additional argument, its type argument a, which is of
kind∗(indeed, Bool, Int, and Char are all three types of kind ∗), and then two
arguments of the type indicated by the type argument, yielding a result of the
same type. Hence, for a type-indexed function different cases have related types.
According to this type, the function can be called by providing three argu-
ments: one type, and two arguments of that type. Indeed, the calls
add/angbracketleftBool/angbracketrightFalse True
add/angbracketleftInt/angbracketright2 7
add/angbracketleftChar/angbracketright’A’ ’ ’
would evaluate to True, 9, and ’a’respectively.
What happens if we call addon a different type, say Float? For
add/angbracketleftFloat/angbracketright3.7 2.09 ,
42
4.2 Relation to type classes
we do not have an appropriate case to select, so all we can do is to fail. But
the program fails at compile time! The compiler can check that the function is
deﬁned for three types only, and that Float is not among them, and thus report
an error.
We could even decide to include the types for which addis deﬁned in its type
signature and write
add/angbracketlefta::∗,a∈{Bool, Int, Char}/angbracketright::a→a→a,
but this would make the type language extremely verbose, and as we will see,
it will get verbose enough anyway. Therefore we make the failure to specialize
a call to a generic function due to the absence of an appropriate case in the
deﬁnition another sort of error, which we call specialization error . Hence, if
we have a Generic Haskell program containing the above deﬁnition of addand
subsequently a call to add/angbracketleftFloat/angbracketrightlike the one above, we get a statically reported
specialization error claiming that add/angbracketleftFloat/angbracketrightcannot be derived, given the cases
addis deﬁned for.
4.2 Relation to type classes
It should be mentioned once more that what we have seen so far is not very
exciting; everything we have done can also – probably even better – be done by
using type classes.
Instead of deﬁning addas a generic function, we could also deﬁne a type class
with a method named add:
class Adda where
add::a→a→a
instance AddBool where
add= (∨)
instance AddInt where
add= (+)
instance AddChar where
add=λx y→chr(ord x +ord y )
This code has nearly the same effect as deﬁnition of the type-indexed function add
before. The Haskell type for the class method addis
add::(Adda)⇒a→a→a,
43
4 Type-indexed Functions
where the class constraint Addacaptures the same information as type argument
before, namely that there has to be some type aof kind∗(the kind is implicit in
the constraint, because class Addexpects an argument of kind ∗). The occurrence
of class Addalso encodes the fact that the function can only be called on Bool, Int,
and Char. If addis called on any other type, such as Float, an “instance error”
will be reported statically which corresponds directly to the specialization error
for the type-indexed functions.
There are two differences. First, the type class can be extended with new in-
stances, whereas the type-indexed function is closed, i.e., it has the cases that are
present at the site of its deﬁnition, and cannot be extended later. This does not
make a huge difference while we consider only single-module programs, but for
large programs consisting of multiple modules it can have both advantages and
disadvantages. We will discuss the impacts of this design decision as well as the
possibilities of “open” type-indexed functions later, in Section 18.4.
Second – and this is a clear advantage of the type classes for now – we do not
have to provide the type argument at the call site of the function. We can just
write add’A’ ’ ’ and the case for type Char will be selected automatically. In
other words, the type argument is inferred for type classes. Type inference for
generic functions – in different variations – is the topic of Chapter 13. For now,
we assume that all type information is explicitly provided.
4.3 Core language with type-indexed functions fcr+tif
Having introduced the concept of type-indexed functions informally in the con-
text of Haskell, we will now extend the core language of Chapter 3 with type-
indexed functions and formally analyze their properties and semantics. This
extended language is called fcr+tif, and the syntax modiﬁcations with respect to
fcrare shown in Figure 4.1.
The language extension introduces a new form of value declarations, for type-
indexed functions, using a type-level case statement to pattern match on types.
The notation that we have seen in the beginning of this chapter serves as syntactic
sugar for the typecase construct: the function
add/angbracketleftBool/angbracketright= (∨)
add/angbracketleftInt/angbracketright= (+)
add/angbracketleftChar/angbracketright=λx y→chr(ord x +ord y )
can be written as
add/angbracketlefta/angbracketright=typecase aof
Bool→(∨)
44
4.4 Translation and specialization
Value declarations
d::=x=e function declaration, from Figure 3.1
|x/angbracketlefta/angbracketright=typecase aof{Pi→ei}i∈1..n
;
type-indexed function declaration
Expressions
e::=. . . everything from Figures 3.1 and 3.12
|x/angbracketleftA/angbracketright generic application
Type patterns
P::=T named type pattern
Type arguments
A::=T named type
Figure 4.1: Core language with type-indexed functions fcr+tif, extends language fcrin
Figures 3.1 and 3.12
Int→(+)
Char→λx y→chr(ord x +ord y )
infcr+tif.
Note that the typecase construct is tied to the declaration level and, unlike
ordinary case , may not occur freely in any expression. Furthermore, arms of a
case statement distinguish on elaborate patterns, whereas type patterns are for
now just names of datatypes (we introduce the syntactic category of type patterns
already here because type patterns will be allowed to be more complex later). We
assume that a typecase is only legal if all type patterns are mutually distinct.
The expression language is extended with generic application that constitutes
the possibility to call a type-indexed function (again, only named types are al-
lowed as arguments for now). Type-indexed functions are not ﬁrst-class in our
language: whenever they are called, a type argument must be supplied immedi-
ately. Furthermore, type-indexed functions cannot be bound to ordinary variables
or passed as arguments to a function. We will explain the reasons for this restric-
tion in Section 11.7. We use the special parentheses to mark type arguments also
at the call sites of type-indexed functions.
4.4 Translation and specialization
We will deﬁne the semantics of fcr+tif not by providing additional reduction
rules for the generic constructs, but by giving a translation into the original core
45
4 Type-indexed Functions
language fcr. We will then prove that the translation is correct by proving that
the translation preserves types. The translation is the topic of Figure 4.2.
/llbracketdfcr+tif/rrbrackettif
Σ1≡{dfcr}i∈1..n
;/squigglerightΣ2
/braceleftbig
di≡cp(x,Ti) =/llbracketei/rrbrackettif/bracerightbigi∈1..n
/largellbracket
x/angbracketlefta/angbracketright=typecase aof{Ti→ei}i∈1..n
;/largerrbrackettif
≡{di}i∈1..n
;/squiggleright{x/angbracketleftTi/angbracketright}i∈1..n
,(tr-tif)
/llbracketx=e/rrbrackettif≡x=/llbrackete/rrbrackettif/squigglerightε(tr-fdecl)
/llbracketefcr+tif/rrbrackettif
Σ≡efcr
Σ/prime≡Σ{,Σi}i∈1..n
/braceleftbig
/llbracketdi/rrbrackettif
Σ/prime≡{di,j}j∈1..mi/squigglerightΣi/bracerightbigi∈1..n
/largellbracket
let{di}i∈1..n
; ine/largerrbrackettif
Σ≡let/braceleftbig{di,j}j∈1..mi;/bracerightbigi∈1..n
;in/llbrackete/rrbrackettif
Σ/prime(tr-let)
x/angbracketleftT/angbracketright∈Σ
/llbracketx/angbracketleftT/angbracketright/rrbrackettif
Σ≡cp(x,T)(tr-genapp)
Figure 4.2: Translation of fcr+tif to fcr
We ﬁrst introduce a rule to translate one fcr+tif declaration into a sequence of
fcrdeclarations. The judgment is of the form
/llbracketdfcr+tif/rrbrackettif
Σ1≡{dfcr}i∈1..n
;/squigglerightΣ2
where the environments Σ1andΣ2aresignature environments .
We deﬁne the signature of a generic function to be the list of types that appear
in the patterns of the typecase that deﬁnes the function. At the moment, type
46
4.4 Translation and specialization
patterns are plainly named types, thus the signature is the list of types for there
are cases in the typecase construct. For example, the addfunction deﬁned on
page 4.1 in Section 4.1 has signature Bool, Int, Char. Note that the signature of a
type-indexed function is something different than the type signature of a (type-
indexed) function. The former is a list of named types that is relevant for the
translation process, the latter assigns a type to the whole function for type check-
ing purposes.
Asignature environment contains entries of the form x/angbracketleftT/angbracketright, indicating that the
named type Tis in the signature of the type-indexed function x.
In the above-mentioned judgment, the environment Σ1is the input environ-
ment under which the translation is to take place, Σ2is the output environment
containing bindings of which we learn during the analysis of the declaration. The
environment is only really accessed in the translation of expressions, which takes
the form
/llbracketefcr+tif/rrbrackettif
Σ≡efcr.
Both translations are understood to be projections – they translate every fcr+tif
declaration or expression construct for which there is no special rule and that is
also valid in fcrto itself. Therefore, rules that are similar to (tr-fdecl), are left
implicit in the translation of expressions.
The declaration of a type-indexed function is translated into a group of decla-
rations with different names. The operation cpis assumed to take a variable and
a type name and create a unique variable name out of the two. Here, cpstands for
component , and we call the translation of a single case of a type-indexed function
component henceforth. Furthermore, the signature of the type indexed function
deﬁned is stored in the output environment. For a normal function declaration,
the expression is translated, and the empty environment is returned.
In a let construct, one or more type-indexed functions can be deﬁned. The
environment Σ/prime, containing all the available components, is recursively made
visible for the translation of the declarations (i.e., the right hand sides of the
declarations may contain recursive calls to the just-deﬁned functions) and to the
body of the let statement.
We call the process of translating a call to a type-indexed function specializa-
tion, because we replace the call to a function which depends on a type argument
by a call to a specialized version of the function, for a speciﬁc type. The process
of specialization thus amounts to selecting the right case of the type-indexed
function, or, in other words, performing the pattern match at the type level. In
rule (tr-genapp), a generic application is specialized by verifying that the type
argument occurs in the signature of the function, and then using the appropriate
component of the function as translation.
47
4 Type-indexed Functions
If the type argument is not an element of the signature of the generic function
called, then the translation will fail with a specialization error. In Chapter 5, we
will extend the language further to allow a larger class of generic applications to
succeed.
4.5 Type checking
To make fcr+tif a “real” language extension, we extend the type rules for the
functional core language fcrto cover the constructs for deﬁning and calling type-
indexed functions as well. The additional rules are shown in Figure 4.3 and 4.4.
Together with the type checking rules of Figure 3.3 and 3.14, they form the type
checking judgments for fcr+tif. The judgments still have the same shape, namely
K;Γ/turnstilelefte::t,
but the environment Γcan now, next to the usual entries of the form x::t, also
contain entries of the form x/angbracketlefta::∗/angbracketright::t, associating a type with a type-indexed
function. As type-indexed and ordinary functions share the same name space,
there can only be one active binding for any name x, either as a type-indexed or
as an ordinary function.
K;Γ/turnstilelefte::t
K/turnstileleftT::∗
x/angbracketlefta::∗/angbracketright::t0∈Γ
K;Γ/turnstileleftx/angbracketleftT/angbracketright::t0[T/a](e-genapp)
Γ/prime≡Γ{,Γi}i∈1..n
{Γ/prime/turnstileleftdecldi/squigglerightΓi}i∈1..n
Γ/prime/turnstilelefte::t
Γ/turnstileleftlet{di}i∈1..n
; ine::t(e-let)
Figure 4.3: Type checking for fcr+tif, extends Figure 3.3
The rule for generic application checks that the kind of the type argument is ∗
and that xis a type-indexed function in scope. The type is the type of the type-
48
4.5 Type checking
K;Γ1/turnstileleftdecld/squigglerightΓ2
/turnstilelefte::t
/turnstileleftdeclx=e/squigglerightx::t(d-val)
{K/turnstileleftTi::∗}i∈1..nK,a::∗/turnstileleftt::∗
K;Γ/turnstileleftei::t[Ti/a]
K;Γ/turnstileleftdeclx/angbracketlefta/angbracketright=typecase aof{Ti→ei}i∈1..n
;/squigglerightx/angbracketlefta::∗/angbracketright::t(d-tif)
Figure 4.4: Type checking for declarations in fcr+tif, extends Figure 4.3
indexed function, with the formal type argument in its type substituted by the
actual type argument of the application.
The former rule (e-letrec-val) is now obsolete and replaced by the more general
(e-let) that allows for both value and type-indexed function declarations. It makes
use of a subsidiary judgment for declarations of the form
K;Γ1/turnstileleftdecld/squigglerightΓ2
that checks a declaration under environments K and Γ1and results in an envi-
ronment Γ2containing possible new bindings introduced by the declaration. The
two rules for that judgment are presented in Figure 4.4.
The rule (d-val) is for value declarations. It is easy to see that the new rules
for let-statements are generalizations that coincide with the old rules for the case
that all declarations are of the form x=e.
The second rule, (d-tif), is for declarations of type-indexed functions. All type
patterns must be of kind ∗. There must be a type tof kind∗, containing a type
variable aof kind∗, and all expressions eiin the arms of the typecase must have
an instance of this type t, with asubstituted by the type pattern Ti. The type tthat
has this characteristic is then returned as the type of the type-indexed function in
the resulting environment.
We now want to show that the translation is correct, i.e., that it preserves type
correctness, or in this case even the exact types of expressions. However, before
we can proceed to the theorem, we ﬁrst have to extend the translation to environ-
ments. Signature environments do not exist in fcr, and type environments cannot
contain type signatures for type-indexed functions. Translations are introduced
in Figure 4.5, and judgments are of the forms
49
4 Type-indexed Functions
/llbracketΓfcr+tif/rrbrackettif≡Γfcr
/llbracketε/rrbrackettif≡ε(tif-gam-1)
/llbracketΓ,x::t/rrbrackettif≡/llbracketΓ/rrbrackettif,x::t(tif-gam-2)
/llbracketΓ,x/angbracketlefta::∗/angbracketright::t/rrbrackettif≡/llbracketΓ/rrbrackettif(tif-gam-3)
/llbracketΣfcr+tif/rrbrackettif
Γfcr+tif≡Γfcr
/llbracketε/rrbrackettif≡ε(tif-sig-1)
x/angbracketlefta::∗/angbracketright::t∈Γ
/llbracketΣ,x/angbracketleftT/angbracketright/rrbrackettif
Γ≡/llbracketΣ/rrbrackettif
Γ,cp(x,T)::t[T/a](tif-sig-2)
Figure 4.5: Translation of fcr+tif environments to fcrtype environments
50
4.5 Type checking
/llbracketΓfcr+tif/rrbrackettif≡Γfcr
/llbracketΣfcr+tif/rrbrackettif
Γfcr+tif≡Γfcr.
The former ﬁlters type signatures of type-indexed functions from a type envi-
ronment, whereas the latter translates a signature environment into type sig-
natures for the associated components: every type that is in the signature of a
type-indexed function is translated into a type assumption for the corresponding
component of the function. We use the abbreviation
/llbracketΓ;Σ/rrbrackettif
Γ≡/llbracketΓ/rrbrackettif,/llbracketΣ/rrbrackettif
Γ.
Note that the translation of the signature environment produces bindings for
components only, and they never clash with the bindings from the translated
type environment.
Now we have everything we need for the theorem:
Theorem 4.1 (Correctness of fcr+tif).Ifeis afcr+tif expression with K; Γ/turnstilelefte::t,
then K; /llbracketΓ;Σ/rrbrackettif
Γ/turnstileleft/llbrackete/rrbrackettif
Σ::t, assuming that Σis a signature environment such that
/llbrackete/rrbrackettif
Σexists.
Corollary 4.2. Ifeis afcr+tif expression with K; Γ/turnstilelefte::twith no type-indexed
bindings in Γ, andΣ≡ε, then K; Γ/turnstileleft/llbrackete/rrbrackettif
ε::t.
In other words, if the translation of an fcr+tif expression into fcrsucceeds, the
resulting expression has the same type as the original expression. The corollary,
which follows immediately from the theorem, emphasizes the special case where
Σis empty. In this situation exactly the same environments can be used to assign
tto both eand its translation.
Proof of the theorem. An induction on the type derivation for ewill do the trick
once more. Only the new cases that are possible for the last derivation step are
interesting: if the last step is (e-genapp), then e≡x/angbracketleftT/angbracketright, and we know by (tr-
genapp) that x/angbracketleftT/angbracketrightis inΣ. Furthermore, (e-genapp) ensures that x/angbracketlefta::∗/angbracketright::t0
is inΓ, where t≡t0[T/a]. Now, /llbrackete/rrbrackettif
Σ≡cp(x,T), and cp(x,T)::t0[T/a]is in
/llbracketΓ;Σ/rrbrackettif
Γ.
If the last step of the type derivation for eis (e-let), we ﬁrst need to extend the
correctness theorem (and the induction) to the translation of declarations. We will
prove the following property: if /llbracketd/rrbrackettif
Σ≡{di}i∈1..n/squigglerightΣ/primeand both K; Γ/turnstileleftdecld/squigglerightΓ/prime
and{K;/llbracketΓ;Σ/rrbrackettif
Γ/turnstileleftdecldi/squigglerightΓi}i∈1..n, then /llbracketΓ/prime;Σ/prime/rrbrackettif
Γ/prime≡{Γi}i∈1..n
, .
If the derivation for dends in the rule (d-val), then d≡x=e. In this case,
Σ/prime≡ε,n≡1, and d1≡x=/llbrackete/rrbrackettif
Σ. By induction hypothesis, we know that if
Γ/turnstilelefte::t, then /llbracketΓ;Σ/rrbrackettif
Γ/turnstileleft/llbrackete/rrbrackettif
Σ::t. Therefore, the two applications of /turnstileleftdeclare
K;Γ/turnstileleftdeclx=e/squigglerightx::t
51
4 Type-indexed Functions
and
K;/llbracketΓ;Σ/rrbrackettif
Γ/turnstileleftdeclx=/llbrackete/rrbrackettif
Σ/squigglerightx::t,
thusΓ/prime≡Γ1≡x::t. This implies /llbracketΓ/prime;Σ/rrbrackettif
Γ/prime≡/llbracketΓ/prime;ε/rrbrackettif
Γ/prime≡Γ1.
If the derivation for dends in the rule (d-tif), then
d≡x/angbracketlefta/angbracketright=typecase aof{Ti→ei}i∈1..n
; .
Here, we apply the induction hypothesis to the ei, getting the eiand their transla-
tions /llbracketei/rrbrackettif
Σhave the same type, say Γ/turnstileleftei::tiand /llbracketΓ;Σ/rrbrackettif
Γ/turnstileleft/llbracketei/rrbrackettif
Σ::ti. We know
from (d-tif) that there is a tsuch that ti≡t[Ti/a]. Furthermore, in this situation
di≡cp(x,Ti) =/llbracketei/rrbrackettif
Σ, andΣ/prime≡{x/angbracketleftTi/angbracketright}i∈1..n
, . Next to that, we can conclude that
Γ/prime≡x/angbracketlefta::∗/angbracketright::tandΓi≡cp(x,Ti)::ti. We thus have to show that
/llbracketx/angbracketlefta::∗/angbracketright::t;{x/angbracketleftTi/angbracketright}i∈1..n
, /rrbrackettif
x/angbracketlefta::∗/angbracketright::t≡{cp(x,Ti)::ti}i∈1..n
, ,
but this follows immediately from the rules in Figure 4.5 for the translation of
signature environments.
We can now cover the case of the proof of the theorem where the derivation for
econcludes on an application of (e-let).
Here, we know that e≡let{di}i∈1..n
; ine0, and
/llbrackete/rrbrackettif
Σ≡let/braceleftbig{di,j}j∈1..mi;/bracerightbigi∈1..n
;ine/prime
0
where /llbrackete0/rrbrackettif
Σ/prime≡e/prime
0, andΣ/prime≡Σ{,Σi}i∈1..nwith
/braceleftbig
/llbracketdi/rrbrackettif
Σ/prime≡{di,j}j∈1..mi/squigglerightΣi/bracerightbigi∈1..n.
We now apply the induction hypothesis to e0and the di. For e0, we get that both
Γ/prime/turnstilelefte0::tand /llbracketΓ/prime;Σ/prime/rrbrackettif
Γ/prime/turnstilelefte/prime
0::t, where Γ/prime≡Γ{,Γi}i∈1..nandΓ/prime/turnstileleftdecldi/squigglerightΓi).
For the declarations, we use the correctness property that we have proved
above, which yields
/braceleftbig
/llbracketΓi;Σi/rrbrackettif
Γi≡{Γi,j}j∈1..mi,/bracerightbigi∈1..n,
where /llbracketΓ/prime;Σ/prime/rrbrackettif
Γ/prime/turnstileleftdecldi,j/squigglerightΓi,j. Observing that
/llbracketΓ/prime;Σ/prime/rrbrackettif
Γ/prime≡/llbracketΓ;Σ/rrbrackettif
Γ{,/llbracketΓi;Σi/rrbrackettif
Γi,}i∈1..n
an application of rule (e-letrec-val) results in
/llbracketΓ;Σ/rrbrackettif
Γ/turnstileleftlet/braceleftbig{di,j}j∈1..mi;/bracerightbigi∈1..n
;ine/prime
0::t,
which is precisely what we need.
52
5Parametrized
Type Patterns
5.1 Goals
In the type-indexed functions that we have treated so far, one deﬁciency stands
out: types of a kind other than ∗are nowhere allowed, not in type patterns nor
in type arguments. A consequence is that also composite types of kind ∗– such
as[Int], where the list type constructor [ ], of kind∗→∗ , is involved – are not
allowed.
What if we want a type-indexed function that computes something based on
a data structure of kind ∗→∗ , for example the size of a data structure, i.e., the
number of “elements” in that structure?
A deﬁnition such as
size/angbracketleft[α]/angbracketright x =length x
size/angbracketleftMaybe α/angbracketrightNothing =0
size/angbracketleftMaybe α/angbracketright(Just ) = 1
size/angbracketleftTree α/angbracketrightLeaf =0
size/angbracketleftTree α/angbracketright(Node/lscriptx r) =size/angbracketleftTree α/angbracketright/lscript+1+size/angbracketleftTree α/angbracketrightr
53
5 Parametrized Type Patterns
might do, if we assume that Tree is a Haskell datatype deﬁned as
data Tree (a::∗) =Leaf|Node (Tree a)a(Tree a).
For the deﬁnition, we assume that patterns of the form Tαare allowed, where T
is a named type of kind ∗→∗ , and αis a variable. All patterns that occur in the
deﬁnition are of this form.
But that is still too limiting: a type-indexed function that works on types of
kind∗may as well work on some data structures of higher kind. Recall our
example from last chapter, the addfunction:
add/angbracketleftBool/angbracketright = (∨)
add/angbracketleftInt/angbracketright = (+)
add/angbracketleftChar/angbracketright x y =chr(ord x +ord y ).
Given that we know how to add two values of some type t, we can also add two
values of type Maybe t, by treating Nothing as exceptional value:
add/angbracketleftMaybe α/angbracketrightNothing =Nothing
add/angbracketleftMaybe α/angbracketright Nothing =Nothing
add/angbracketleftMaybe α/angbracketright(Just x ) (Just y ) = Just (add/angbracketleftα/angbracketrightx y),
The knowledge of how to add two values of the argument type of Maybe is
hidden in the reference to add/angbracketleftα/angbracketrightin the ﬁnal case, and we still have to make sure
that we get access to that information somehow.
We could also extend the function addto lists as pointwise addition:
add/angbracketleft[α]/angbracketright x y
|length x ==length y =map (uncurry (add/angbracketleftα/angbracketright)) (zip x y )
|otherwise =error "args must have same length" .
We do not even have to restrict ourselves to kind ∗and∗→∗ datatypes. We can
do pointwise addition for pairs, too:
add/angbracketleft(α,β)/angbracketright (x1,x2) (y1,y2) = ( add/angbracketleftα/angbracketrightx1y1,add/angbracketleftβ/angbracketrightx2y2).
Now our function addhas arms which involve type constructors of kinds ∗,∗→
∗, and∗→∗→∗ , all at the same time.
Perhaps surprisingly, we need not just one, but three signiﬁcant extensions to
the simple type-indexed functions introduced in Chapter 4, to be able to success-
fully handle the above examples.
The ﬁrst requirement is clear: type patterns must become more general. Instead
of just named types of kind ∗, we will admit named types of arbitrary kind,
54
5.2 Parametrized type patterns
applied to type variables in such a way that the resulting type is of kind ∗again.
This addition will be described in more detail in Section 5.2.
Secondly, and this is the most difﬁcult part, we need to introduce the notion of
dependencies between type-indexed functions. A dependency arises if in the def-
inition of one type-indexed function, another type-indexed function (including
the function itself) is called, with a variable type as type argument. Dependen-
cies must be tracked by the type system, so the type system must be extended
accordingly. All this is the topic of Section 5.3.
Last, to be of any use, we must also extend the specialization mechanism. Until
now, we could only handle calls to type-indexed functions for named types of
kind∗. Now, we want to be able to call size/angbracketleft[Int]/angbracketrightoradd/angbracketleft(Char, [Bool ])/angbracketright. Thus,
type arguments have to be generalized so that they may contain type applications
as well. This is explained in Section 5.4.
In the rest of this chapter, we will describe all of these extensions in detail
by means of examples. In the next chapter, we will formally extend our core
language with the constructs necessary to support the extensions.
5.2 Parametrized type patterns
We now allow patterns such as /angbracketleft[α]/angbracketrightor/angbracketleftEither α β/angbracketrightin the deﬁnitions of type-
indexed functions. A pattern must be of kind ∗, and of the form that a named
type constructor is applied to variables to satisfy the type constructor. Thus
/angbracketleftEither α/angbracketrightis not allowed because Either is only partially applied. Of course,
types of kind∗are a special case of this rule: the type pattern /angbracketleftInt/angbracketrightis the nullary
type constructor Int applied to no type variables at all.
All type variables in type patterns have to be distinct, just as we require vari-
ables in ordinary patterns to be distinct. A pattern such as /angbracketleft(α,α)/angbracketrightis illegal.
Also, we do notallow nested type patterns:/angbracketleft[Int]/angbracketrightis forbidden, and so is
/angbracketleftEither αChar/angbracketright. The top-level type constructor is the only named type occur-
ring in a type pattern, the rest are all type variables. This restriction on type
patterns is not essential. One could allow nested type patterns, or multiple pat-
terns for the same type, such as they are allowed in Haskell case statements.
This would signiﬁcantly complicate the future algorithms for the translation of
type-indexed functions with issues that are not directly related to generic pro-
gramming. With our restriction, performing pattern matching on the cases of a
type-indexed deﬁnition remains as simple as possible: comparing the top-level
constructors is sufﬁcient to ﬁnd and select the correct branch.
We retain the notions of signature ,specialization , and component , all deﬁned in
Section 4.4. The signature of a type-indexed function is the set of named types
55
5 Parametrized Type Patterns
occurring in the type patterns. For size, the signature is [ ], Maybe, Tree. For add,
including the new cases, the signature consists of the six types Bool, Int, Char,
Maybe, [ ],(,). Specialization is the process of translating a call of a generic
function. A component is the result of translating a single arm of a typecase
construct.
This translation to components can be very simple in some cases. For instance,
the arm of the sizefunction for lists,
size/angbracketleft[α]/angbracketrightx=length x ,
can be translated into a component cp(size,[ ])x=length x almost in the same
way as we translate arms for types of kind ∗. Note that components are always
generated for a type-indexed function and a named type. In this case, the func-
tion is size, and the named type [ ]. As the signature of a type-indexed function
can contain types of different kind (compare with the example signature for add
above), also components can be created for named types of different types. The
variables in the type patterns do not occur in the translation.
In this case, the translation is easy because the variable αis not used on the
right hand side. Things get more difﬁcult if the variables in the type patterns are
used in generic applications on the right hand sides, and we will discuss that in
the following section.
5.3 Dependencies between type-indexed functions
When a type-indexed function is called within the deﬁnition of another type-
indexed function, we must distinguish different sorts of calls, based on the type
argument: calls with type arguments that are constant are treated differently from
calls where the type argument contains variables.
Let us look at the addfunction once more, in particular at the Int and Char
cases of the function:
add/angbracketleftInt/angbracketright = (+)
add/angbracketleftChar/angbracketrightx y =chr(ord x +ord y )
The ordof a character is an integer, therefore we could equivalently have written
add/angbracketleftChar/angbracketrightx y =chr/parenleftbig
add/angbracketleftInt/angbracketright(ord x ) (ord y )/parenrightbig
During translation, we can generate a component cp(add, Char )as usual: we
specialize the call add/angbracketleftInt/angbracketrighton the right hand side to refer to cp(add, Int). The type
argument Int is statically known during the translation of the function deﬁnition,
therefore the compiler can locate and access the appropriate component.
56
5.3 Dependencies between type-indexed functions
On the other hand, in the case for lists
add/angbracketleft[α]/angbracketrightx y
|length x ==length y =map/parenleftbig
uncurry (add/angbracketleftα/angbracketright)/parenrightbig(zip x y )
|otherwise =error "args must have same length" ,
wecannot simply generate a component cp(add,[ ]), because we have to specialize
the call add/angbracketleftα/angbracketright, without knowing at the deﬁnition site of addwhat αwill be. This
information is only available where the function addis called. Nevertheless, it is
desirable that we can translate the deﬁnition of a type-indexed function without
having to analyze where and how the function is called.
The solution to this problem is surprisingly simple: we say that the function
addis adependency ofadd. A dependency makes explicit that information is
missing. This information is needed during the translation. In the result of the
translation, this information is provided in the form of an additional function
argument passed to the components of add. The right hand sides can then access
this argument.
To be more precise: a component for a type argument involving free variables
expects additional arguments – one for each combination of variable and func-
tion among the dependencies. In our example, there is one variable α, and one
dependency, add, so there is one additional argument, which we will succinctly
callcp(add,α), because it tells us how to add values of type αand abstracts from
an unknown component. The component that is generated will be
cp(add,[ ])cp(add,α)x y
|length x ==length y =map (uncurry cp(add,α)) (zip x y )
|otherwise =error "args must have same length" .
In this example, the type-indexed function adddepends on itself – we say that
it is reﬂexive . This reﬂexivity occurs frequently with type-indexed functions, be-
cause it corresponds to the common case that a function is deﬁned using direct re-
cursion. Still, type-indexed function can depend on arbitrary other type-indexed
functions. These can, but do not have to include the function itself.
Dependencies of type-indexed functions are reﬂected in their type signatures .
Previously, addhad the type
add/angbracketlefta::∗/angbracketright::a→a→a.
This type is no longer adequate – we use a new syntax,
add/angbracketlefta::∗/angbracketright::(add)⇒a→a→a.
In addition to the old type, we store the dependency of addon itself in the type
signature. This type signature is a formal way to encode all type information
57
5 Parametrized Type Patterns
about addthat is necessary. In general, the type signature of a type-indexed
function consists of the name of the function and its type argument to the left of
the double colon ::, and a list of function names that constitute dependencies of
the function, followed by a double arrow ⇒and the function’s base type to the
right of the double colon. Sometimes, we use the term type signature to refer only
to the part to the right of the double colon.
According to the deﬁnitions above, the function addhas one dependency: the
function additself. The base type of addisa→a→a.
This generalized form of type signature with a list of dependencies still does
not enable us to cover the types of all generic functions we would like to write.
We will extend upon the material of this chapter later, in Chapter 9.
There is an algorithm that allows us – given the type signature – to determine
the type of add/angbracketleftA/angbracketrightfor any type argument (or pattern) A. This algorithm, called
gapp , will be discussed in detail in Section 6.3.
Now, let us look at some example types for speciﬁc applications of add: for a
constant type argument such as Int, or [Char ], the dependencies are ignored, and
the types are simply
add/angbracketleftInt/angbracketright :: Int→Int→Int
add/angbracketleft[Char ]/angbracketright::[Char ]→[Char ]→[Char ].
These types are for speciﬁc instances of the type-indexed functions, and they can
be derived automatically from above type signature. In general, for any type
argument Athat is dependency-variable free, we have
add/angbracketleftA/angbracketright::A→A→A.
Dependencies have an impact on the type of a generic application once vari-
ables occur in the type argument. For instance, if the type argument is [α], the
resulting type is
add/angbracketleft[α]/angbracketright::∀a::∗.(add/angbracketleftα/angbracketright::a→a→a)⇒[a]→[a]→[a].
We call the part in the parentheses to the left of the double arrow a dependency
constraint . In this case, add/angbracketleftα/angbracketright::a→a→ais a dependency constraint. This
means that we can assign the type [a]→[a]→[a]to the call, but only under the
condition that we know how add/angbracketleftα/angbracketrightis deﬁned, and that add/angbracketleftα/angbracketrighthas to be of type
a→a→a, which is the base type of add. Again, this is the type for the generic
application add/angbracketleft[α]/angbracketright, and the type can be derived from the type signature for add
given above using the gapp algorithm from Section 6.3.
Dependency constraints are comparable to type class constraints (Wadler and
Blott 1989; Jones 1994) in Haskell, or perhaps even better to constraints for implicit
58
5.3 Dependencies between type-indexed functions
parameters (Lewis et al. 2000). A dependency constraint encodes an implicit
argument that must be provided. We will see later that in the translation to
the core language fcr, these implicit arguments are turned into explicit function
arguments.
Recall the deﬁnition of addfor[α]:
add/angbracketleft[α]/angbracketrightx y
|length x ==length y =map (uncurry (add/angbracketleftα/angbracketright)) (zip x y )
|otherwise =error "args must have same length" .
On the right hand side, there is a call to add/angbracketleftα/angbracketright. This occurrence of add/angbracketleftα/angbracketrighthas
the type
∀a::∗.(add/angbracketleftα/angbracketright::a→a→a)⇒a→a→a.
The call has the type a→a→a, but at the same time introduces a dependency
onadd/angbracketleftα/angbracketrightof type a→a→a. This reﬂects the fact that the generic applica-
tion add/angbracketleftα/angbracketrightdoes only make sense in a context where the lacking information is
provided somehow. The translation refers to cp(add,α), which must be in scope.
The whole right hand side of the deﬁnition – because it is the arm of addfor[α]
– must have the aforementioned type for add/angbracketleft[α]/angbracketright, which is
∀a::∗.(add/angbracketleftα/angbracketright::a→a→a)⇒[a]→[a]→[a].
The right hand side thus may depend on add/angbracketleftα/angbracketright. The type pattern of the arm
eliminates the dependency. The translation will provide the function argument
cp(add,α), which is then in scope for the right hand side of the component.
In general, we say that dependency constraints are introduced by a call to a
generic function on a type argument involving variables, and they are eliminated
orsatisﬁed by a type pattern in the deﬁnition of a type-indexed function.
For now, type patterns are the only way to eliminate dependency constraints.
This implies that there is not much sense in calling type-indexed functions on
type arguments with variables except while deﬁning a type-indexed function.
We will learn about another mechanism to eliminate dependency constraints in
Chapter 8.
Figure 5.1 summarizes example types for generic applications of the addfunc-
tion, for different sorts of type arguments. In all cases, the metavariable Ais
supposed to be free of variables, but we assume that it is of different kind in
each case:∗,∗→∗ ,∗→∗→∗ , and ﬁnally (∗→∗ )→∗, applied to variables
of suitable kind to make the type argument as a whole a kind ∗type. For each
variable in the type pattern, there is one dependency constraint. We call the vari-
ables in the pattern (denoted by Greek letters) dependency variables . For each
59
5 Parametrized Type Patterns
add/angbracketleftA::∗/angbracketright:: A→A→A
add/angbracketleftA(α::∗)::∗/angbracketright
::∀a::∗. (add/angbracketleftα/angbracketright::a→a→a)⇒A a→A a→A a
add/angbracketleftA(α::∗) (β::∗)::∗/angbracketright
::∀(a::∗) (b::∗).(add/angbracketleftα/angbracketright::a→a→a,
add/angbracketleftβ/angbracketright::b→b→b)⇒A a b→A a b→A a b
add/angbracketleftA(α::∗→∗ )::∗/angbracketright
::∀a::∗→∗ . (add/angbracketleftα(γ::∗)/angbracketright::
∀c::∗.(add/angbracketleftγ/angbracketright::c→c→c)⇒a c→a c→a c)
⇒A a→A a→A a.
Figure 5.1: Types for generic applications of addto type arguments of different form
dependency variable, one type variable of the same kind is introduced. In the
examples, αis associated with a, and βwith b, and γwith c. It may seem strange
that we do not just use the same variables, but rather distinguish the quantiﬁed
type variables from the dependency variables (we distinguish the two sorts of
variables even on a syntactic level, which is why we use Greek letters to denote
dependency variables). The reason is that in the more general situation that will
be discussed in Chapter 9, we will allow multiple type variables to be associated
with one dependency variable. Dependency variables are only allowed in type
patterns of type-indexed function deﬁnitions and in type arguments in depen-
dency constraints and calls to type-indexed functions – everywhere between the
special type parentheses /angbracketleft·/angbracketright.
If a dependency variable is of higher kind – as can be seen in the last example
forαof kind∗→∗ – the associated dependency constraint is nested: it introduces
local dependency variables – such as γin the example – and the type of the
dependency is itself a dependency type. How can this nested dependency type
be understood? The call add/angbracketleftA(α::∗→∗ )/angbracketrightis of type A a→A a→A a, but
depends on an implicit argument called add/angbracketleftα γ/angbracketright, which is of type
∀c::∗.(add/angbracketleftγ/angbracketright::c→c→c)⇒a c→a c→a c.
This add/angbracketleftα γ/angbracketrightmay thus itself depend on some function add/angbracketleftγ/angbracketrightof some type
c→c→c, and must, given this function, be of type a c→a c→a c. Note that
the form of the type that the dependency has, is itself very similar to the type of
the second example, where Ais of kind∗→∗ .
In theory, there is no limit to the kinds that may occur in the type arguments.
However, more complex kinds rarely occur in practice.
The function addrepresents the most common case of dependency: addde-
pends on itself, and on nothing else. This corresponds to a normal function
60
5.3 Dependencies between type-indexed functions
which is deﬁned by means of recursion on itself. But a type-indexed function
need not depend on itself, or it may depend on other type-indexed functions.
We have already seen a function of the ﬁrst category, namely size(deﬁned on
page 53). Its type signature is
size/angbracketlefta::∗/angbracketright::()⇒a→Int .
We often omit the empty list of dependencies and write
size/angbracketlefta::∗/angbracketright::a→Int ,
which coincides with the old form of type signatures, that we used when we did
not know about dependencies.
Note that although sizecalls itself recursively in the Tree arm,
size/angbracketleftTree α/angbracketright(Node/lscriptx r) =size/angbracketleftTree α/angbracketright/lscript+1+size/angbracketleftTree α/angbracketrightr,
it does not depend on itself. The position of a dependency variable in a type
argument determines whether or not (and if yes, which) dependency constraints
are needed: if the type argument is of the form A0{Ai}i∈1..n, and A0does not
contain any further application, then A0is called the head . We also write head (A)
to denote the head of a type argument. In size/angbracketleftTree α/angbracketright, the head of the type
argument is Tree. In add/angbracketleftα/angbracketright, the head of the type argument is α.
If a dependency variable αis the head of A, then a call x/angbracketleftA/angbracketrightintroduces a
dependency constraint on x/angbracketleftα/angbracketright. Ifαoccurs in A, but not as the head of A, then
the call xintroduces dependency constraints according to the dependencies of x:
for each function ykthat is a dependency of x, a dependency constraint on yk/angbracketleftα/angbracketright
is introduced.
Let us map this abstract rule to our examples. The deﬁnition of add(see
page 54) contains, for instance, a call to add/angbracketleftα/angbracketrighton the right hand side of the
case for add/angbracketleft[α]/angbracketright. The dependency variable αis in the head position in this call,
therefore a dependency constraint on add/angbracketleftα/angbracketrightis introduced (amounting to a ref-
erence to cp(add,α)in the translation). As a result, addmust depend on itself,
because only then the dependency constraint can be satisﬁed. The translation
will then provide the additional function argument cp(add,α)for the component
cp(add,[ ])resulting from case add/angbracketleft[α]/angbracketright.
On the other hand, in the situation of size, the head of the type argument in
the call size/angbracketleftTree α/angbracketrightis Tree, and αoccurs somewhere else in the type argument.
Therefore, this application of sizedoes not necessarily force a dependency for
size/angbracketleftα/angbracketright. Instead, the call introduces dependency constraints for all functions that
sizedepends on. But this is the empty set, thus the call introduces no dependen-
cies, and everything is ﬁne, i.e., type correct.
61
5 Parametrized Type Patterns
Intuitively, the type of the elements does not matter anywhere in the compu-
tation of the size of the data structure (at least, according to the way we deﬁned
that size). We can generate a component cp(size, Tree )and specialize the recursive
call without need for an additional argument:
cp(size, Tree ) (Node/lscriptx r) =cp(size, Tree )/lscript+1+cp(size, Tree )r.
(In Section 8.2, we will learn about a better way to deﬁne size, as a generic function
that does depend on itself.)
The fact that function sizeis restricted to type arguments constructed with type
constructors of kind ∗→∗ stems from its arms, not from its type. Consequently,
a call to size/angbracketleftInt/angbracketrightresults in a specialization error rather than a type error. From
the type signature of size, which is
size/angbracketlefta::∗/angbracketright::a→Int ,
we can derive example types for applications of sizeto different type arguments,
just as we in Figure 5.1 for add. This time, there are no dependencies, therefore
the resulting types are simpler. The examples are shown in Figure 5.2. These
types can once more be calculated automatically from the type signature using
thegapp algorithm from Section 6.3.
size/angbracketleftA::∗/angbracketright :: A→Int
size/angbracketleftA(α::∗)::∗/angbracketright ::∀a::∗. A a→Int
size/angbracketleftA(α::∗) (β::∗)::∗/angbracketright::∀(a::∗) (b::∗).A a b→Int
size/angbracketleftA(α::∗→∗ )::∗/angbracketright ::∀(a::∗→∗ ).A a→Int .
Figure 5.2: Types for generic applications of sizeto type arguments of different form
It is perfectly possible to deﬁne an arm of sizefor type patterns involving type
constructors of different kind such as pairs
size/angbracketleft(α,β)/angbracketright=const 2 ,
or integers
size/angbracketleftInt/angbracketright=const 0 .
Next, let us look at an example of a function that depends on another function.
Suppose we want to deﬁne a partial order that works on lists and pairs and
combinations thereof. We deﬁne two lists to be comparable only if they both
have the same size and the elements are comparable pointwise. If the comparison
62
5.3 Dependencies between type-indexed functions
yields the same result for all elements, then that is the result of the function. For
pairs though, two elements are only comparable if the ﬁrst components are equal ,
the result being the result of comparing the second components:
data CprResult =Less|More|Equal|NotComparable
cpr/angbracketleft[α]/angbracketrightx y
|size/angbracketleft[α]/angbracketrightx==size/angbracketleft[α]/angbracketrighty=ifsize/angbracketleft[α]/angbracketrightx==0
then Equal
else let p=zipWith (cpr/angbracketleftα/angbracketright)x y
in if allEqual/angbracketleft[CprResult ]/angbracketrightp
then head p
else NotComparable
|otherwise =NotComparable
cpr/angbracketleft(α,β)/angbracketright(x1,x2) (y1,y2)
|equal/angbracketleftα/angbracketrightx1y1 =cpr/angbracketleftβ/angbracketrightx2y2
|otherwise =NotComparable .
This function deliberately uses quite a number of other type-indexed functions
which we assume to be deﬁned: sizewe already know, equal is a function to test
two values for equality, and allEqual is a function to check for a list (and possibly
other data structures) whether all elements stored in the list are equal. Finally,
cpritself is used recursively. We assume that the type signatures for equal and
allEqual are as follows:
equal/angbracketlefta::∗/angbracketright::(equal )⇒a→a→Bool
allEqual/angbracketlefta::∗/angbracketright::(equal )⇒a→Bool
Whereas equal is supposed to test two values of the same type for equality,
the function allEqual is intended to be used on data structures – such as a list,
[CprResult ], in the deﬁnition of cpr– to test if all elements of that data structure
are equal.
The question is: what is the type signature for cpr? You may try to guess the
answer before reading on, as an exercise for your intuition.
The situation of the calls to sizeare as in the Tree arm of sizeitself: no depen-
dency is needed. The type argument [α]does contain a dependency variable, but
not in the head. Therefore, because sizedoes not depend on itself, the specializa-
tion to the List arm can be made without referring to the element type α.
Even more clearly, there is no dependency on allEqual . The call has a constant
type argument, and the specialization to constant type arguments is always pos-
sible without additional arguments and hence does never cause a dependency.
The function equal is a different story: in the arm for pairs, we call equal/angbracketleftα/angbracketright,
therefore there isa dependency on equal . And, because cpris called on αin the
63
5 Parametrized Type Patterns
arm for lists, and on βin the arm for pairs, there is also a dependency on cpr.
Hence, the type signature of cpris
cpr/angbracketlefta::∗/angbracketright::(equal ,cpr)⇒a→a→CprResult .
Note that the type signature is not as ﬁne-grained as one might expect: a depen-
dency is a global property of a type-indexed function, not attached to some arm.
Although the arm for lists does not depend on equal , the type for cpr/angbracketleft[α]/angbracketrightthat is
derived from the above type signature exhibits the dependency:
cpr/angbracketleft[α]/angbracketright::∀a::∗.(equal/angbracketleftα/angbracketright::a→a→Bool,
cpr/angbracketleftα/angbracketright::a→a→CprResult )
⇒[a]→[a]→CprResult .
Also, there is no distinction between different dependency variables. The arm for
pairs does only depend on cprfor the second component. Nevertheless, the type
forcpr/angbracketleftα,β/angbracketrightcontains the dependency on cprfor both components:
cpr/angbracketleft(α,β)/angbracketright::∀(a::∗) (b::∗).(equal/angbracketleftα/angbracketright::a→a→Bool,
cpr/angbracketleftα/angbracketright::a→a→CprResult,
equal/angbracketleftβ/angbracketright::b→b→Bool,
cpr/angbracketleftβ/angbracketright::b→b→CprResult )
⇒(a,b)→(a,b)→CprResult .
Another look at type classes reveals again a certain connection, this time be-
tween dependencies and instance rules , i.e., instances that have a condition. If we
had a type class with a method size, such as
class Sizea where
size ::a→Int ,
we could deﬁne instances for lists and trees as follows:
instance Size[a] where
size x =length x
instance Size(Tree a)where
size Leaf =0
size(Node/lscriptx r) =size/lscript+1+size r .
The instance deﬁnitions are universal in the sense that they work for alllists and
alltrees, without any condition on the element type.
64
5.4 Type application in type arguments
However, if the class for the addfunction, deﬁned in Section 4.2 as
class Addawhere
add ::a→a→a
needed to be extended to lists in the same way as the type-indexed function, we
must write
instance Adda⇒Add [a]where
add x y
|length x ==length y =map (uncurry add ) (zip x y )
|otherwise =error "args must have same length" .
The fact that the type-indexed function depends on itself is mirrored in the con-
straint on the instance declaration: an Addinstance for [a]can only be deﬁned if
ais an instance of class Addas well.
5.4 Type application in type arguments
Assuming we have successfully deﬁned a type-indexed function such as addto
work on lists, it is only natural that we also want to use it somewhere. In Chap-
ter 4, a generic application had the form x/angbracketleftT/angbracketright, i.e., the language of type argu-
ments was restricted to named types.
We are going to extend the syntax for type arguments (as opposed to type pat-
terns) to include type application. We have already used such type arguments
in the examples in the previous sections; for instance, the deﬁnition of sizeon
page 53 contains the call size/angbracketleftTree α/angbracketrighton the right hand side of the case for trees.
Perhaps more interesting, the function cpruses the call allEqual/angbracketleft[CprResult ]/angbracketright,
thus an application of two named types to each other.
A comparable situation would be a call to add/angbracketleft[Int]/angbracketright. For example, the call
add/angbracketleft[Int]/angbracketright[1, 2, 3 ] [2, 3, 5 ]
should have type [Int]and evaluate to [3, 5, 8 ]. The question is, how is addspecial-
ized to [Int]? The answer is that an application in the type argument is translated
into an application of specializations. There is a deﬁnition for add/angbracketleft[α]/angbracketright– we thus
know how to add two lists, provided that we know how to add list elements, i.e.,
that we have access to add/angbracketleftα/angbracketright. We have also deﬁned the case add/angbracketleftInt/angbracketright, therefore
we also know how to add two integers. It is pretty obvious that these two cases
can be combined to get to add/angbracketleft[Int]/angbracketright, by supplying add/angbracketleftInt/angbracketrightfor the dependency
onadd/angbracketleftα/angbracketrightthat is required by add/angbracketleft[α]/angbracketright.
65
5 Parametrized Type Patterns
In the translation, dependencies are turned into explicit function arguments. It
has already been sketched that the component for addon[ ]looks as follows:
cp(add,[ ])cp(add,α)x y
|length x ==length y =map (uncurry cp(add,α)) (zip x y )
|otherwise =error "args must have same length" .
The dependency of addon itself is translated into an explicit additional argument.
This can now be supplied using the component of addfor Int, such that add/angbracketleft[Int]/angbracketright
can be specialized to
cp(add,[ ])cp(add, Int).
This is the general idea: dependencies reappear in the translation as explicit
arguments. If a type-indexed function is called with a complex type argument
that contains type application, the translation process automatically ﬁlls in the
required dependencies. Thus, a call to cpr/angbracketleft[Int]/angbracketrightrequires twodependencies to
be supplied and is translated to
cp(cpr,[ ])cp(equal , Int)cp(cpr, Int),
under the precondition that both equal and cprhave arms for Int. If that is not the
case, such as in our deﬁnition of cprabove, a specialization error is be reported.
With the help of the dependencies in the types of type-indexed functions, we
can prove the translation technique sketched above correct. In other words, spe-
cializing a generic application to an application of specializations will always
produce a type correct term in fcr, and the type of that term is related to the de-
pendency type the term has in the original language that supports type-indexed
functions. The proof will be given in Section 6.5. For the programmer, this cor-
rectness means that type-indexed functions can be used “naturally”, even for
complex type arguments, because all plugging and plumbing happens under the
hood.
The translation method just outlined also implies a couple of restrictions that
should hold for dependencies. If, for instance, the call add/angbracketleft[Int]/angbracketrightis translated
tocp(add,[ ])cp(add, Int), then the type of cp(add, Int)must match the the type of
the argument expected by cp(add,[ ]). This explains why, in the examples above,
the types that appear in the dependency constraints are always related to the base
type of the function in question.
Furthermore, the dependency relation is transitive. Assume that function x
depends on both xand y, and function ydepends on both yand z. IfT1and T2
are two named types, and the call x/angbracketleftT1(T2α)/angbracketrightoccurs on the right hand side
of the deﬁnition of an arm of x, this call would be – incorrectly, as we shall see
below – translated to
66
5.4 Type application in type arguments
cp(x,T1)/parenleftbig
cp(x,T2)cp(x,α)cp(y,α)/parenrightbig
/parenleftbig
cp(y,T2)cp(y,α)cp(z,α)/parenrightbig
.
The type argument is an application of T1toT2α, therefore the translation is
an application of the component of xforT1to the dependencies of xon the
argument. The function xhas two dependencies, xand y, thus cp(x,T1)has two
arguments, corresponding to the calls x/angbracketleftT2α/angbracketrightand y/angbracketleftT2α/angbracketright. In both cases the
type argument is again an application, and in both cases the function that is called
has again two dependencies, therefore both arguments are itself applications of
a component, each to two arguments. But the function ydepends on z, therefore
the call to cp(z,α)occurs in the translation! This means that the compiler must
provide not only cp(x,α)and cp(y,α), but also cp(z,α)in this component of x.
As we have said before, we choose not to have the added complexity of different
dependencies depending on the arm we are deﬁning, thus the only solution is to
make xdirectly depend on zas well.
The price we pay for this transitivity condition is that sometimes unnecessary
dependencies are carried around. The correct translation of x/angbracketleftT1(T2α)/angbracketright, for
example, is
cp(x,T1)/parenleftbig
cp(x,T2)cp(x,α)cp(y,α)cp(z,α)/parenrightbig
/parenleftbig
cp(y,T2)cp(y,α)cp(z,α)/parenrightbig
/parenleftbig
cp(z,T2)cp(z,α)/parenrightbig
,
assuming that zdepends only on itself.
67
5 Parametrized Type Patterns
68
6 Dependencies
This chapter constitutes a formalization of the language extensions that have
been introduced in the previous Chapter 5. We will introduce a new language
fcr+tif+par, based on fcr+tif, that can handle parametrized type patterns and
type-indexed functions with dependencies. The syntax of the language is intro-
duced in Section 6.1. Subsequently, we delve into the details of dependencies
and discuss dependency variables in Section 6.2 and dependency types in Sec-
tion 6.3. We will then explain how to translate programs in the extended language
fcr+tif+par to programs in fcr, in Section 6.4. In Section 6.5, we discuss why the
translation is correct. We conclude with Section 6.6, which puts the theory cov-
ered in this chapter in relation with Ralf Hinze’s work on generic programming.
6.1 Core language with parametrized type patterns
We will now extend the language fcr+tif of Figure 4.1 – our functional core lan-
guage with type-indexed functions – to cover the extensions necessary to handle
the new forms of type patterns and type arguments, and dependencies between
69
6 Dependencies
Qualiﬁed types
q::={∀ai::κi.}i∈1..n(∆)⇒t
qualiﬁed type
Constraint sets
∆::={Yi}i∈1..n
, constraint set
Type constraints
Y::=x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q
dependency constraint
Type patterns
P::=T{αi}i∈1..nparametrized named type pattern
Type arguments
A::=T named type, from Figure 4.1
|α,β,γ, . . . dependency variable
|(A1A2) type application
Type signatures
σ::= ({yk}k∈1..n
, )⇒t type signature of type-indexed function
Figure 6.1: Core language with type-indexed functions and parametrized type patterns
fcr+tif+par, extends language fcr+tif in Figure 4.1
type-indexed functions. The extended language is called fcr+tif+par. The addi-
tional syntactic constructs are shown in Figure 6.1.
Dependency variables are a new form of type variables used in the context of
dependencies. We distinguish them by using lowercase Greek letters ( α,β,γ) for
them. Dependency variables are the topic of Section 6.2.
Aqualiﬁed type is a type with dependency constraints. A dependency constraint
is of the form
x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q
and consists of the name of a type-indexed function x, a type argument consist-
ing of dependency variables, and a qualiﬁed type. The constraint expresses a
dependency on function xat dependency variable α0. Depending on the kind of
the dependency variable α0, there may be further dependency variable parame-
ters, with kind annotations, which are local to the constraint and scope over the
qualiﬁed type qonly.
Dependency constraints may appear nested in the sense that the type in a
particular constraint can be qualiﬁed again. However, all constraints are always
at the beginning of a type. Type variables may be universally quantiﬁed in a
qualiﬁed type.
70
6.1 Core language with parametrized type patterns
A set of constraints is much like an environment. For a speciﬁc combination of
type-indexed function xand dependency variable α0, there may be at most one
constraint. The order of the constraints is unimportant – in other words, we treat
types that differ only in the order of dependency constraints as equivalent.
To keep forthcoming algorithms deterministic, and save us from a lot of re-
ordering hassle during the deﬁnition of the translation to fcr, we will now deﬁne
a canonical ordering on dependency constraints, and can henceforth assume that
qualiﬁed types appear with their constraints ordered when needed. We assume
that there is a total order <lexon both dependency variables and expression vari-
ables (lexical order would do, but it can be any other total order). We can extend
this order to dependency constraints via the equivalence
x1/angbracketleftα1{βi}i∈1..m/angbracketright::q1<lexx2/angbracketleftα2{γj}j∈1..n/angbracketright::q2
⇐⇒ α1<lexα2∨(α1≡α2∧x1<lexx2).
The types q1and q2that appear in the constraints are irrelevant for the ordering.
If a qualiﬁed type has no dependency, we often write
{∀(ai::κi).}i∈1..mt
instead of
{∀(ai::κi).}i∈1..m()⇒t.
Similarly, every ordinary type is trivially also a qualiﬁed type.
Sometimes, we split dependency constraints and write
{∀ai::κi.}i∈1..m(∆)⇒q,
with qbeing still a qualiﬁed type. Now, if qis of the form
{∀a/prime
i::κi.}i∈(m+1)..n(∆/prime)⇒t,
and if there are no clashes between bound variables or dependencies in ∆and∆/prime,
then the ﬁrst type is considered equivalent to
{∀ai::κi.}i∈1..n(∆,∆/prime)⇒t.
If a dependency constraint occurs in both ∆and∆/prime, and both are equal modulo
renaming of bound variables, then the rewrite step is still possible, and ∆,∆/prime
denotes the constraint set where the duplicate constraint occurs only once.
Back to the syntax in Figure 6.1: the old form of type patterns is subsumed by
a new one, where a named type may appear followed by an arbitrary number
71
6 Dependencies
of dependency variables as arguments. The case where there are no dependency
variables is still allowed and coincides with the old form.
The syntax for type arguments is extended: dependency variables and type
application are allowed here. Note that thus the type pattern language forms a
subset of the type argument language, and we will make use of that fact occa-
sionally.
Type signatures are a list of function names followed by a type. Type signatures
are used to convey the type information of a type-indexed function. We discuss
the syntax and semantics of type signatures further in Section 6.3.
6.2 Dependency variables and kinds
Dependency variables are a new form of variables. They do not occur in normal
type expressions, but only in type patterns and type arguments – as a rule of
thumb, only within the special /angbracketleft·/angbracketrightparentheses.
They are completely independent of normal type variables. We use fdv(A)to
refer to the free dependency variables of a type argument (or pattern) A, and
continue to refer to the disjoint set of free type variables by dv(A).
Dependency variables are bound by a type pattern. The arguments appearing
in a pattern scope over the expression belonging to the branch (note that ordinary
type variables never scope over expressions; they are only bound by lambdas in
datatype declarations and by universal quantiﬁcation). Furthermore, dependency
variables can be local to a dependency constraint, if the dependency variable
of the constraint is of higher kind and thus has additional parameters. Bound
dependency variables can be renamed, as other sorts of bound variables, and
we will assume that this is implicitly done during substitutions to prevent name
capture.
The kind checking rules need to be extended to cover type arguments and type
patterns, and qualiﬁed types. The form of judgment for arguments is, as for
ordinary types,
K/turnstileleftA::κ,
stating the type argument Ahas kind κunder environment K. The environment K
may now also contain assumptions for dependency variables, of the form α::κ.
These bindings may also be contained in K during the checking of normal type
expressions – they are not used there, though, only propagated.
Kind checking for type arguments makes use of the rules for ordinary types in
Figure 3.2 and only needs one new judgment for dependency variables, shown
in Figure 6.2. The judgment is what one would expect for a variable: we look up
the variable in the environment.
72
6.2 Dependency variables and kinds
K/turnstileleftA::κ
α::κ∈K
K/turnstileleftα::κ(t-depvar)
Figure 6.2: Kind checking for language fcr+tif+par of Figure 6.1, extends Figure 3.2
For patterns, we use a modiﬁed judgment of the form
K1/turnstileleftpatP::κ/squigglerightK2,
which is analogous to the judgment for value-level patterns (cf. Figure 3.4). Under
input environment K 1we ﬁnd pattern Pto be of kind κ, thereby binding the
dependency variables in K 2. The rules are stated in Figure 6.3. For a named type,
we look up its kind in the input environment, and then bind the arguments to the
appropriate kinds. The subsidiary judgment for dependency variables is trivial.
K1/turnstileleftpatP::κ/squigglerightK2
K/turnstileleftpatα::κ/squigglerightα::κ(tp-depvar)
K/turnstileleftT::{κi→}i∈1..n∗
{K/turnstileleftpatαi::κi/squigglerightKi}i∈1..n
K/turnstileleftpatT{αi}i∈1..n::∗/squiggleright{Ki}i∈1..n
,(tp-named)
Figure 6.3: Kind checking of type patterns in language fcr+tif+par of Figure 6.1
Qualiﬁed types are always of kind ∗, thus the corresponding judgment is:
K/turnstileleftq::∗.
The rule is given in Figure 6.5, and makes use of the judgment for well-formed-
ness of a dependency constraint in Figure 6.4, which is of the form
K/turnstileleftY::∗.
73
6 Dependencies
K/turnstileleftY::∗
K/prime≡K{,αi::κi}i∈1..n
K/prime/turnstileleftα0{αi}i∈0..n::∗ K/prime/turnstileleftq::∗
K/turnstileleft/parenleftbig
x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q/parenrightbig
::∗(t-constraint)
Figure 6.4: Well-formedness of dependency constraints in language fcr+tif+par of Fig-
ure 6.1
K/turnstileleftq::∗
K/prime≡K{,ai::κi}i∈1..m
{K/prime/turnstileleftYj::∗}j∈1..nK/prime/turnstileleftt::∗
K/turnstileleft/parenleftbig{∀ai::κi.}i∈1..m({Yj}j∈1..n
, )⇒t/parenrightbig
::∗(t-qual)
Figure 6.5: Kind checking of qualiﬁed types in fcr+tif+par of Figure 6.1
6.3 Dependency types
This section is a formalization of Section 5.3. We explain how qualiﬁed types can
be assigned to both calls of type-indexed functions and arms of a typecase.
6.3.1 Type signatures of type-indexed functions
During type checking, we have to verify that arms of type-indexed functions and
occurrences of calls to type-indexed functions are type correct. In the situation of
Chapter 4, this was relatively easy: for each generic function x, we added a type
signature of form
x/angbracketlefta::∗/angbracketright::t
to the type environment Γ; and to compute the type of x/angbracketleftT/angbracketright(or, similarly, the
type of the right hand side of the arm for Tin the deﬁnition of x), we just returned
t[T/a].
74
6.3 Dependency types
Type arguments were not allowed if they were not of the form T, with Tbeing a
named type of kind ∗.
The situation is far more difﬁcult now: we have more complex type patterns
and arguments, and if they contain dependency variables, dependencies might
arise. In Section 5.3, we have already noted that the syntax for type signatures of
type-indexed functions must be extended to cover the dependencies of a function.
These extended type signatures are of the form
x/angbracketlefta::∗/angbracketright::({yk}k∈1..n
, )⇒t.
Such a type signature consists of a number of dependencies y k, which are names
of other type-indexed functions, and an unqualiﬁed type t, which we call the base
type of the function. The type variable ais bound on the right hand side and may
thus appear free in the dependencies and the base type. We use the symbol σas
a metavariable for a type signature.
From a type signature for a type-indexed function x– so we have demonstrated
by example – we can generate qualiﬁed types for x/angbracketleftA/angbracketrightfor many different type
arguments (and, similarly, also type patterns) A.
For type checking in fcr+tif+par, the type environment Γcontains bindings of
the form x::tto assign unqualiﬁed types to variables, and x/angbracketlefta::∗/angbracketright::σ, to store
type signatures of generic functions.
We use a judgment of the form
base K;Γ(x/angbracketleftA/angbracketright)≡t
to instantiate the base type of a generic function. The rule is given in Figure 6.6,
together with a judgment
dependenciesΓ(x)≡{yk}k∈1..n
,
that can be applied to extract the dependencies of a type-indexed function. Both
judgments can be used as functions.
The well-formedness of a type-indexed function’s type signature is relatively
easy to verify: the dependencies must be type-indexed functions in scope, and
the base type must be of kind ∗. In addition, the dependency relation must be
equal to its transitive closure: if one function indirectly depends on another, it
also depends on it directly (cf. Section 5.4).
We express the well-formedness of a type signature formally via
K;Γ/turnstilelefttpsigx/angbracketlefta::∗/angbracketright::σ.
The deﬁnition is given in Figure 6.7. This judgment is used later in rule (d/tr-tif),
while type checking and translating the declaration of a type-indexed function.
75
6 Dependencies
base K;Γ(x/angbracketleftA/angbracketright)≡t
x/angbracketlefta::∗/angbracketright::({yk}k∈1..n
, )⇒t∈Γ K/turnstileleftA::∗
base K;Γ(x/angbracketleftA/angbracketright)≡t[A/a](base)
dependenciesΓ(x)≡{yk}k∈1..n
,
x/angbracketlefta::∗/angbracketright::({yk}k∈1..n
, )⇒t∈Γ
dependenciesΓ(x)≡{yk}k∈1..n
,(deps)
Figure 6.6: Extracting information from the type signature of a type-indexed function
K;Γ/turnstilelefttpsigx/angbracketlefta::∗/angbracketright::σ
/braceleftbig
K;Γ/turnstilelefttpsigyk/angbracketlefta::∗/angbracketright::({zk,i}i∈1..mk, )⇒tk/bracerightbigk∈1..n
/braceleftbig{zk,i∈{yj}j∈1..n
,}i∈1..mk/bracerightbigk∈1..n
K,a::∗/turnstileleftt::∗
K;Γ/turnstilelefttpsigx/angbracketlefta::∗/angbracketright::({yk}k∈1..n
, )⇒t(typesig)
Figure 6.7: Well-formedness of type signatures for type-indexed functions
76
6.3 Dependency types
6.3.2 Generic application algorithm
Finally, we have collected all the prerequisites to start deﬁning an algorithm that
can, from a type signature for a type-indexed function x, compute the (qualiﬁed)
type of x/angbracketleftA/angbracketrightfor some type argument A. Judgments for this algorithm are of the
form
gappK;Γ(x/angbracketleftA/angbracketright)≡q.
The algorithm is shown in Figure 6.8 and makes use of a subsidiary judgment to
create a single dependency constraint, of the form
mkdepK;Γ(x/angbracketleftα←a/angbracketright)≡Y.
The idea of the algorithm is that for each free dependency variable that occurs
in the type argument Aof function x, one set of dependencies is introduced.
Rule (ga-1) is thus for type arguments which do not contain any free dependency
variables. If a dependency variable is contained in A, we distinguish two cases. If
the dependency variable appears in the head of A, then (ga-2) applies, otherwise
(ga-3).
If there are no free dependency variables in A, (ga-1) states that the desired
type is the instantiated base type of x.
Both (ga-2) and (ga-3) deal with the occurrence of a dependency variable α
inA. In both rules dependencies for αare introduced, and in both rules we create
a fresh type variable ato replace α, which should be of the same kind as α. This
substitution takes place because we do not allow dependency variables to appear
anywhere but in type arguments, and because later, in the generalization that
will be discussed in Chapter 9, one dependency variable can be instantiated to
multiple type variables.
Ifαoccurs in the head of A, then a dependency of xonαis introduced in (ga-
2), implementing the case – discussed in Section 5.3 – that a call to a function x
where αis the head of the type argument does always introduce a dependency of x
onα. The dependency constraint itself is generated by the call mkdepx(y/angbracketleftα←a/angbracketright),
explained below. The remainder of the qualiﬁed type is then generated by the
recursive call to gapp , where the head occurrence of αin the type argument has
been replaced by a.
Ifαoccurs in A, but not in the head, then dependencies are introduced for
all functions ykthat xdepends on. This time, in the recursive call to gapp , all
occurrences of αare substituted by a.
Note that if αoccurs in both the head of the type argument Aand somewhere
else in A, then ﬁrst rule (ga-2) and then rule (ga-3) is applied, creating dependen-
cies for xonαas well as for all dependencies ykonαin the process. If xdepends
77
6 Dependencies
gappK;Γ(x/angbracketleftA/angbracketright)≡q
K/turnstileleftA::∗ fdv(A)≡ε
gappK;Γ(x/angbracketleftA/angbracketright)≡base K;Γ(x/angbracketleftA/angbracketright)(ga-1)
K/turnstileleftα::κ afresh K/prime≡K,a::κ
gappK;Γ(x/angbracketleftα{Ai}i∈1..n/angbracketright)≡∀a::κ.(mkdepK/prime;Γ(x/angbracketleftα←a/angbracketright))
⇒gappK/prime;Γ(x/angbracketlefta{Ai}i∈1..n/angbracketright)(ga-2)
α∈fdv(A) head (A)/negationslash≡α
K/turnstileleftα::κ afresh K/prime≡K,a::κ
dependenciesΓ(x)≡{yk}k∈1..n
,
gappK;Γ(x/angbracketleftA/angbracketright)≡∀a::κ.({mkdepK/prime;Γ(yk/angbracketleftα←a/angbracketright)}k∈1..n
, )
⇒gappK/prime;Γ(x/angbracketleftA[a/α]/angbracketright)(ga-3)
mkdepK;Γ(y/angbracketleftα←a/angbracketright)≡Y
K/turnstileleftα::κ κ≡{κh→}h∈1../lscript∗
{γhfresh}h∈1../lscriptK/prime≡K{,γh::κh}h∈1../lscript
mkdepK;Γ(x/angbracketleftα←a/angbracketright)
≡(x/angbracketleftα{γh}h∈1../lscript/angbracketright::gappK;Γ(x/angbracketlefta{γh}h∈1../lscript/angbracketright))(mkdep)
Figure 6.8: Generic application algorithm
78
6.3 Dependency types
on itself, the algorithm generates a double dependency constraint with the same
type, in which case we ignore the duplicate and just keep a single constraint.
The algorithm gapp is nondeterministic, because it leaves the choice of which
free dependency variable in the type argument to choose next. For the result, the
order makes no difference; only the dependency constraints of the resulting type
will be generated in a different order, and the order of dependency constraints
does not matter. Thus, we can assume that always the smallest dependency
variable is chosen in rules (ga-2) and (ga-3), which eliminates the choice and
makes gapp a deterministic algorithm that can be used as a function.
It remains to discuss the mkdep judgment, which is of the form
mkdepK;Γ(x/angbracketleftα←a/angbracketright)≡Y.
It is used to determine the type that is associated with a dependency on function x
for the dependency variable α, which is instantiated with type variable a, where
both αand aare of kind κ. The resulting constraint is Y.
There is only one rule, named (mkdep). We can almost directly apply gapp
onxagain to determine the type of the dependency, but αis not necessarily of
kind∗, and if it is not, local dependency variables γhare introduced as arguments
toα. While the name of the dependency constraint makes use of the dependency
variable α, the type itself is generated with αsubstituted by the type variable a.
Theorem 6.1 (Termination of gapp).If K/turnstileleftA::∗and xis a type-indexed func-
tion, thus
x/angbracketlefta::∗/angbracketright::σ∈Γ
and
K;Γ/turnstilelefttpsigx/angbracketlefta::∗/angbracketright::σ,
then gappK;Γ(x/angbracketleftA/angbracketright)has a solution qthat can be derived in a ﬁnite number of
steps.
Proof. The conditions of the theorem ensure that one of the rules is always appli-
cable.
Thesize of a kind can be deﬁned as follows:
size(∗)≡1
size(κ1→κ2)≡size(κ1) +size(κ2).
We can now compute the size of a type argument by determining all free depen-
dency variables in it, and computing the sum of the sizes of their kinds. We count
multiple occurrences of one dependency variable multiple times.
79
6 Dependencies
Then, in each recursive call of gapp , the size of the type argument is strictly
smaller than before. In rules (ga-2) and (ga-3), we eliminate at least one depen-
dency variable, and the size of its kind is strictly positive. In (mkdep), we know
that the size of the original type argument was at least the size of κ, the kind of α
(because αoccurs in the original type argument). By construction,
size(a{γh}h∈1..p)≡size(κ)−1 .
Since the size of the initial type argument is ﬁnite, and the size is always a
natural number, the algorithm terminates.
For a concrete function such as cpr, let us investigate what the algorithm returns
as type for a generic application to Tα, where Tis some constant type constructor
of kind∗→∗ , and α::∗is a dependency variable. The resulting type is
cpr/angbracketleftTα/angbracketright::∀a::∗.(equal/angbracketleftα/angbracketright::a→a→Bool,
cpr/angbracketleftα/angbracketright::a→a→CprResult )
⇒T a→T a→CprResult .
If we apply cprto a type argument containing two dependency variables, such
asTα β, with T::∗→∗→∗ , and both αandβof kind∗, we obtain two
sets of dependencies, because the recursive call in (ga-3) on x/angbracketleftA[a/α]/angbracketright, after
substituting one dependency variable, still contains another:
cpr/angbracketleftTα β/angbracketright::∀(a::∗) (b::∗).(equal/angbracketleftα/angbracketright::a→a→Bool,
cpr/angbracketleftα/angbracketright::a→a→CprResult,
equal/angbracketleftβ/angbracketright::b→b→Bool,
cpr/angbracketleftβ/angbracketright::b→b→CprResult )
⇒T a b→T a b→CprResult .
If a dependency variable is itself of higher kind, such as in cpr/angbracketleftTα/angbracketright, where
T::(∗→∗ )→∗ andα::∗→∗ , the result is a nested dependency constraint:
cpr/angbracketleftTα/angbracketright::
∀a::∗→∗ ./parenleftbig
equal/angbracketleftα(γ::∗)/angbracketright::∀c::∗.(equal/angbracketleftγ/angbracketright::c→c→Bool )
⇒a c→a c→Bool,
cpr/angbracketleftα(γ::∗)/angbracketright::∀c::∗.(equal/angbracketleftγ/angbracketright::c→c→Bool,
cpr/angbracketleftγ/angbracketright::c→c→CprResult )
⇒a c→a c→CprResult/parenrightbig
⇒T a→T a→CprResult .
Note that the overall structure is still that we have one set of dependency con-
straints, for the dependencies equal and cpr, on dependency variable α. But,
80
6.4 Types and translation
because α::∗→∗ , each of the types of the dependencies has a dependency
again, on a local dependency variable γ::∗. The type of the dependency
equal/angbracketleftα(γ::∗)/angbracketrightis exactly the same as the type for equal/angbracketleftaγ/angbracketrightwould be (and
similar for cpr/angbracketleftα(γ::∗)/angbracketright. This stems from the fact that in (mkdep), for the
dependencies the generic application algorithm is called recursively as well, with
the freshly introduced type variable as argument, applied to equally freshly in-
troduced dependency variables. You may want to refer back to Section 5.3 and
conﬁrm that the example types given for addand sizein Figure 5.1 and 5.2 can all
be generated with help of the gapp algorithm.
6.4 Types and translation
We will now discuss the translation of fcr+tif+par to fcr. First, we will have a
close look at how types are translated: we use qualiﬁed types for arms of type-
indexed functions and calls to type-indexed functions. In fcr, these qualiﬁed
types are represented as ordinary functions. Section 6.4.1 shows the details. In the
following Section 6.4.2, we sketch which environment we need for type checking
and translating fcr+tif+par. Section 6.4.3 contains more about qualiﬁed types,
before Sections 6.4.4 and 6.4.5 talk about the actual translation of expressions and
declarations, respectively. In Section 6.4.6, we show how fcr+tif+par environ-
ments can be mapped to fcrenvironments, and in Section 6.4.7, we discuss the
critical question of how to translate generic applications, i.e., calls to type-indexed
functions.
6.4.1 Translation of qualiﬁed types
In the translation of fcr+tif+par to fcr, we represent values of types with depen-
dency constraints as functions, where the constraints are represented as explicit
arguments. The translation has to ensure that the dependency arguments that
are needed are also provided.
Dependency constraints may be reordered, whereas function arguments usu-
ally may not. To save us from a lot of tedious and – even worse – confusing
reordering work, we make use of the canonical ordering <lexdeﬁned in Sec-
tion 6.1.
Figure 6.9 shows how such a canonically ordered qualiﬁed type can be trans-
lated into an fcrtype. The judgments are of the form
/llbracketqfcr+tif+par/rrbracketpar≡tfcr
or
81
6 Dependencies
/llbracket∆fcr+tif+par/rrbracketpar≡tfcr[•],
the former taking a qualiﬁed type in fcr+tif+par to a type in fcr, the latter taking
dependency constraints to a type with a hole. We use the notation t[•]to denote
a type where one position that syntactically could hold another type has been
replaced by a hole, written •. Ifuis another type, then t[u]is the type where the
hole is ﬁlled by type u.
As an example of how the translation proceeds, recall the type for cpr/angbracketleftTα/angbracketright
with T::(∗→∗ )→∗ from page 80. Rewritten in canonical order, this type is
∀a::∗→∗ .(cpr/angbracketleftα(γ::∗)/angbracketright::∀c::∗.(cpr/angbracketleftγ/angbracketright::c→c→CprResult,
equal/angbracketleftγ/angbracketright::c→c→Bool )
⇒a c→a c→CprResult,
equal/angbracketleftα(γ::∗)/angbracketright::∀c::∗.(equal/angbracketleftγ/angbracketright::c→c→Bool )
⇒a c→a c→Bool )
⇒T a→T a→CprResult .
The translation of this type, according to the rules in Figure 6.9, is
∀a::∗→∗ . (∀c::∗. (c→c→CprResult )
→(c→c→Bool )
→a c→a c→CprResult )
→(∀c::∗. (c→c→Bool )
→a c→a c→Bool )
→T a→T a→CprResult .
In the translation, one can no longer see with which function and dependency
variable a certain argument is associated. But because we have agreed on a canon-
ical ordering of the constraints, the position of the function argument is enough to
recover that information. Furthermore, nested dependency constraints translate
to higher-order functions.
A simpler example would be add/angbracketleft[α]/angbracketright. Here, the qualiﬁed type is
∀a.(add/angbracketleftα/angbracketright::a→a→a)⇒[a]→[a]→[a],
and the corresponding fcrtype is simply
∀a.(a→a→a)→[a]→[a]→[a].
6.4.2 Environments for type checking and translation
Because the presence of dependency constraints plays an important role for the
result of the translation, we combine type checking and translation rules for the
82
6.4 Types and translation
/llbracketqfcr+tif+par/rrbracketpar≡tfcr
/llbracket∆/rrbracketpar≡u[•]
/llbracket{∀ai::κi.}i∈1..n(∆)⇒t/rrbracketpar≡{∀ ai::κi.}i∈1..nu[t](tr-qtype)
/llbracket∆fcr+tif+par/rrbracketpar≡tfcr[•]
/llbracketε/rrbracketpar≡•(tr-constraint-1)
/llbracket∆/rrbracketpar≡u[•]
/llbracketq/rrbracketpar≡t
/llbracket∆,x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q/rrbracketpar≡u[t→• ](tr-constraint-2)
Figure 6.9: Translation of qualiﬁed types and dependency constraints in language
fcr+tif+par
83
6 Dependencies
language fcr+tif+par. In this process, we make use of four environments. The
kind environment K stores kinds for both type and dependency variables.
The type environment Γstores the types of variables and type signatures of
type-indexed functions. Again, we make use of a signature environment Σ, in
which we store the signatures of type-indexed functions that are in scope. Note
that we distinguish signatures of type-indexed functions, such as deﬁned in Sec-
tion 4.4, and type signatures. The former contain a list of types and type con-
structors that appear in the type patterns of the typecase construct. The latter
contain information on how to type check calls to a type-indexed functions.
New is a dependency environment ∆. We use the same symbol that we use
to denote a dependency constraint set, because both are of the same form: the
dependency environment ∆contains bindings of the form
x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q
and stores dependencies that are currently available. If a dependency is available,
that means that in the translation, a variable cp(x,α0)of type /llbracketq/rrbracketparis in scope.
6.4.3 Coercing qualiﬁed types
Given a dependency environment ∆, it is possible to coerce a value of a certain
qualiﬁed type into a value of another qualiﬁed type, either adding or removing
dependency constraints in the process. The idea is that on the level of the lan-
guage fcr+tif+par, we have a subtyping relation between two qualiﬁed types q1
and q2, if on the level of the language fcr, we can ﬁnd a coercion function that
transforms any value of type /llbracketq1/rrbracketparinto a value of type /llbracketq2/rrbracketpar.
Following this idea, we have rules of the form
K;∆/turnstileleftq1/lessorequalslantq2/squigglerighte[•],
that are given in Figure 6.10 and extend the subsumption relation on fcrtypes in
Figure 3.5. In some cases, when we are not interested in the coercion term, we
write
K;∆/turnstileleftq1/lessorequalslantq2
for simplicity.
A subsumption judgment is to be interpreted as the following statement: under
environments K and ∆, any expression efcr+tif+parof type q1can be used as a
value of type q2. But the types /llbracketq1/rrbracketparand /llbracketq2/rrbracketparare different in fcr. Therefore,
the translation of efcr+tif+parmust be different depending on whether it is given
type q1or type q2. The coercion function e[•]– which is a holed expression in the
84
6.4 Types and translation
K;∆/turnstileleftq1/lessorequalslantq2/squigglerighte[•]
∆1,∆2/turnstileleftq/lessorequalslantt/squigglerighte[•]/turnstileleft∆2/squigglerighte∆[•]
∆1/turnstileleftq/lessorequalslant(∆2)⇒t/squigglerighte∆[e[•]](qs-dep-1)
K/turnstileleftt1/lessorequalslantt2 K;∆1⊩∆2/squigglerighte[•]
K;∆1/turnstileleft(∆2)⇒t1/lessorequalslantt2/squigglerighte[•](qs-dep-2)
a/∈dv(q1)
K,a::κ;∆/turnstileleftq1/lessorequalslantq2/squigglerighte[•]
K;∆/turnstileleftq1/lessorequalslant∀a::κ.q2/squigglerighte[•](qs-skol)
K/turnstileleftu::κ
K;∆/turnstileleftq1[u/a]/lessorequalslantq2/squigglerighte[•]
K;∆/turnstileleft∀a::κ.q1/lessorequalslantq2/squigglerighte[•](qs-inst)
Figure 6.10: Subsumption relation on qualiﬁed types, extends Figure 3.5
85
6 Dependencies
same way as we had holed types before – can be used to modify the translation
accordingly.
If the subsumption relation is used as an algorithm to determine a coercion
function, there is a strategy: ﬁrst the rules (qs-skol) and (qs-inst) can be applied to
“remove” universal quantiﬁers from the types. Both are analogues of the rules (s-
skol) and (s-inst) that deal with universal quantiﬁcation in unqualiﬁed types.
After the quantiﬁers have been dealt with, rule (qs-dep-1) allows to add the
constraints ∆2of the right qualiﬁed type (∆2)⇒tto the environment of assumed
constraints ∆1. We then check the left qualiﬁed type qto be convertible in tunder
the extended environment ∆1,∆2. The conversion is witnessed by e[•], but this
expression context may make use of the dependencies in ∆1and∆2. To turn this
into an expression that only makes use of the dependencies in ∆1, we have to
abstract from ∆2again. This is the job of the judgment /turnstileleft∆2/squigglerighte∆[•].
The subsidiary judgment form
/turnstileleft∆/squigglerighte[•]
is deﬁned in Figure 6.11. It maps a list of dependency constraints ∆into a se-
quence of lambda abstractions of the associated component names.
Rule (qs-dep-2) of Figure 6.10 is for the case that the right hand side depen-
dencies have been eliminated with help of (qs-dep-1), but the left-hand side still
is a qualiﬁed type (∆2)⇒t1. In this case we check that /turnstileleftt1/lessorequalslantt2using the sub-
sumption relation on normal types from Figure 3.5. Ordinary types are fcrtypes,
therefore we do not need a coercion function witnessing the coercion from t1tot2.
But the dependencies in ∆2express arguments that need to be provided, and we
must verify that environment ∆1contains enough information to provide these
arguments. This is achieved using the entailment judgment ∆1⊩∆2/squigglerighte[•],
which delivers the expression context that is returned.
The entailment judgment form
K;∆1⊩∆2/squigglerighte[•]
is given in Figure 6.12. It checks if the dependencies available in ∆1are sufﬁcient
to supply the dependencies required by ∆2and returns a number of applications
to the appropriate dependency arguments as a witness in the expression context
e[•]. Rule (ent-2) is the important case: if x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q2is the ﬁrst of
the expected constraints (according to the canonical ordering of the dependency
constraints), there must be a constraint for xonαamong the available constraints
as well, such as x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q1. We recursively satisfy the remaining
dependencies ∆2by invoking the entailment judgment again, yielding an expres-
sion context e∆that can supply all the dependencies in ∆2. It remains to supply
the dependency on x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright. The available term cp(x,α0)is of the
86
6.4 Types and translation
/turnstileleft∆/squigglerighte[•]
/turnstileleftε/squiggleright•(abs-1)
/turnstileleft∆/squigglerighte[•]
/turnstileleftx/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q,∆/squigglerightλcp(x,α0)→e[•](abs-2)
Figure 6.11: Conversion of dependency constraints into explicit abstractions, extends Fig-
ure 6.10
type corresponding to q1and can thus be converted to the type corresponding to
q2bye[•], because q1/lessorequalslantq2.
We will prove the correctness of the subsumption relation on qualiﬁed types in
Section 6.5.
6.4.4 Translation of expressions
The judgments for expressions are of the form
/llbracketefcr+tif+par::tfcr+tif+par/rrbracketpar
K;Γ;∆;Σ≡efcr.
The expression efcr+tif+paris checked against an unqualiﬁed type tfcr+tif+par, and
translated to the expression efcr. As announced earlier, we make use of four
environments: the kind environment K, the type environment Γ, the environment
of available dependencies ∆, and the signature environment Σ.
For most syntactic constructs in the expression language, the combination of
type checking and translation is entirely straightforward. As an example consider
the rule for application, which is
/llbrackete1::t1→t2/rrbracketpar≡e/prime
1
/llbrackete2::t1/rrbracketpar≡e/prime
2
/llbracket(e1e2)::t2/rrbracketpar≡(e/prime
1e/prime
2)(e/tr-app) .
The type checking parts are analogous to (e-app), and the translation is the trans-
lation of the subexpressions. Figure 6.13 lists the cases that deal in one way or an-
other with type-indexed functions, namely let statements (where the declarations
might contain deﬁnitions of type-indexed functions), and generic application.
87
6 Dependencies
K;∆1⊩∆2/squigglerighte[•]
K;∆⊩ε/squiggleright•(ent-1)
K;∆1⊩∆2/squigglerighte∆[•]
x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q1∈∆1
K;∆1/turnstileleftq1/lessorequalslantq2/squigglerighte[•]
K;∆1⊩x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q2,∆2/squiggleright(e∆[•e[cp(x,α0)]])(ent-2)
Figure 6.12: Entailment of dependency constraints, extends Figure 6.10
/llbracketefcr+tif+par::tfcr+tif+par/rrbracketpar
K;Γ;∆;Σ≡efcr
Γ/prime≡Γ{,Γi}i∈1..nΣ/prime≡Σ{,Σi}i∈1..n
/braceleftbig
/llbracketdi/squigglerightΓi;Σi/rrbracketpar
K;Γ/prime;∆;Σ/prime≡{di,j}j∈1..mi/bracerightbigi∈1..n
/llbrackete::t/rrbracketpar
K;Γ/prime;∆;Σ/prime≡e/prime
/llbracketlet{di}i∈1..n
; ine::t/rrbracketpar
K;Γ;∆;Σ≡let/braceleftbig{di,j}j∈1..mi;/bracerightbigi∈1..n
;ine/prime(e/tr-let)
K/turnstileleftA::∗
gappK;Γ(x/angbracketleftA/angbracketright)≡q /llbracketx/angbracketleftA/angbracketright/rrbracketgtrans
K;Γ;Σ≡e
K;∆/turnstileleftq/lessorequalslantt
/llbracketx/angbracketleftA/angbracketright::t/rrbracketpar
K;Γ;∆;Σ≡e(e/tr-genapp)
Figure 6.13: Translation of fcr+tif+par expressions to fcr
88
6.4 Types and translation
/llbracketefcr+tif+par::qfcr+tif+par/rrbracketpar
K;Γ;∆;Σ≡efcr
/llbrackete::t/rrbracketpar
∆,∆/prime≡e/prime
∆/turnstileleftt/lessorequalslant(∆/prime)⇒t/squigglerighte/prime/prime[•]
/llbrackete::(∆/prime)⇒t/rrbracketpar
∆≡e/prime/prime[e/prime](e/tr-reveal)
a/∈dv(Γ)
/llbrackete::q/rrbracketpar
Γ≡e/prime
/llbrackete::∀a.q/rrbracketpar
Γ≡e/prime(e/tr-gen)/llbrackete::q1/rrbracketpar≡e/prime
/turnstileleftq1/lessorequalslantq2/squigglerighte/prime/prime[•]
/llbrackete::q2/rrbracketpar≡e/prime/prime[e/prime](e/tr-subs)
Figure 6.14: Revelation of dependency constraints in fcr+tif+par
The rule (e/tr-let) for let statements is a combination of the type checking rule
(e-let) and the translation rule (tr-let), both from Chapter 4. In this rule, we make
use of the correctness and translation judgment for declarations, which will be
deﬁned in Section 6.4.5.
The rule for generic application (e/tr-genapp) is different, though: the type
argument is checked to be of kind ∗. The generic application algorithm from
Section 6.3 is invoked to get a qualiﬁed type qfor the application x/angbracketleftA/angbracketright. Inde-
pendently, a translation algorithm is used to obtain an fcrexpression eforx/angbracketleftA/angbracketright.
The translation algorithm will be discussed later in this section. If the qualiﬁed
type qhas dependency constraints, the expression eis an expression that contains
references to these dependency constraints. We use the judgment K; ∆/turnstileleftq/lessorequalslanttto
check that the current dependency environment ∆contains enough information,
such that in the translation, all variables that erefers to are indeed in scope at this
position.
In addition to the rules just discussed, Figure 6.14 shows three rules for judg-
ments of the form
/llbracketefcr+tif+par::q/rrbracketpar
K;Γ;∆;Σ≡efcr,
where a qualiﬁed type is assigned to an expression. We will make use of these
rules while checking the arms of a typecase statement.
Most important is rule (e/tr-reveal), which can be used to make the depen-
dency constraints of a type, which are usually implicitly recorded in the ∆envi-
ronment passed around, explicit as a qualiﬁed type.
89
6 Dependencies
The other two rules, (e/tr-gen) and (e/tr-subs), are counterparts of the former
generalization and subsumption rules (e-gen) and (e-subs).
6.4.5 Translation of declarations
Checking and translation of declarations is shown in Figure 6.15, with judgments
of the form
/llbracketdfcr+tif+par/squigglerightΓ2;Σ2/rrbracketpar
K;Γ1;∆;Σ1≡{dfcr}i∈1..n
; ,
Other than in the judgments for expressions, the translation is a list of fcrdec-
larations. As a byproduct, new bindings for the type environment, and possibly
new signature entries for deﬁnitions of type-indexed functions are generated in
Γ2andΣ2.
The rule for declarations of type-indexed functions is the interesting one. Let
us ﬁrst look at the result: a well-formed type signature must exist and is returned
for the type environment, and a signature environment is produced that contains
one entry for each arm of the typecase. The translation consists of declarations of
components, each of which also stems from one arm of the typecase.
The translation of the arms is handled by an auxiliary rule (d/tr-arm) of the
form
/llbracketx|P→efcr+tif+par/squigglerightΣ2/rrbracketpar
K;Γ;∆;Σ1≡dfcr.
We take the name of the function xand a single arm P→efcr+tif+paras input.
Compared to the declaration judgments, we produce only one declaration and
no type environment.
The type pattern Pis of the form T{αi}i∈1..n, a named type applied to depen-
dency variables. We implicitly assume that all type constructors Tthat appear
in the type patterns of a typecase are distinct. The named type Tis, together
with the name of the function x, used to name the resulting component cp(x,T).
The generic application algorithm gapp is used to derive the type qthat the arm
should have. The type qdetermines which dependencies may be required by
expression on the right hand side. That expression is therefore checked to be of
this qualiﬁed type q, making use of the rules in Figure 6.14. The translation of
the expression, e/prime, is used as the body of the component.
Compared to a type-indexed function, a normal value deﬁnition is trivial to
check and translate: The type of the right hand side determines the binding for
the type environment that is returned. No new signature entries are produced.
The translation is a value declaration again, assigning the same name to the trans-
lation of the right hand side.
90
6.4 Types and translation
/llbracketdfcr+tif+par/squigglerightΓ2;Σ2/rrbracketpar
K;Γ1;∆;Σ1≡{dfcr}i∈1..n
;
K;Γ/turnstilelefttpsigx/angbracketlefta::∗/angbracketright::σ
Γ/prime≡x/angbracketlefta::∗/angbracketright::σΣ/prime≡{Σi}i∈1..n
,/braceleftbig
/llbracketPi→ei/squigglerightΣi/rrbracketpar
K;Γ,Γ/prime;∆;Σ≡di/bracerightbigi∈1..n
/largellbracket
x/angbracketlefta/angbracketright=typecase aof{Pi→ei}i∈1..n
;/squigglerightΓ/prime;Σ/prime/largerrbracketpar
K;Γ;∆;Σ≡{di}i∈1..n
;(d/tr-tif)
/llbrackete::t/rrbracketpar≡e/prime
/llbracketx=e/squigglerighte::t;ε/rrbracketpar≡x=e/prime(d/tr-fdecl)
/llbracketx|P→efcr+tif+par/squigglerightΣ2/rrbracketpar
K;Γ;∆;Σ1≡dfcr
K/turnstileleftpatP::∗/squigglerightK/primeP≡T{αi}i∈1..n
gappK,K/prime;Γ(x/angbracketleftP/angbracketright)≡q /llbrackete::q/rrbracketpar
K,K/prime;Γ;∆;Σ≡e/prime
/llbracketx|P→e/squigglerightx/angbracketleftT/angbracketright/rrbracketpar
K;Γ;∆;Σ≡cp(x,T) =e/prime(d/tr-arm)
Figure 6.15: Translation of fcr+tif+par declarations to fcr
91
6 Dependencies
/llbracketKfcr+tif+par/rrbracketpar≡Kfcr
/llbracketε/rrbracketpar≡ε(par-kap-1)/llbracketK,a::κ/rrbracketpar≡/llbracketK/rrbracketpar,a::κ(par-kap-2)
/llbracketK,α::κ/rrbracketpar≡/llbracketK/rrbracketpar(par-kap-3)
Figure 6.16: Translation of fcr+tif+par kind environments to fcr
6.4.6 Translation of environments
Before we can hope to state any results about the correctness of the translation,
we also need a way to map the four environments that are needed to translate
fcr+tif+par programs to the two environments (kind environment and type en-
vironment) that are required to check fcrprograms.
In Figure 4.5, we have mapped a type and a signature environment in lan-
guage fcr+tif to a type environment fcr. We must now extend that algorithm to
incorporate the dependency environment.
Figure 6.16 shows how to translate fcr+tif+par kind environments to fcr. This
is achieved by removing all bindings for dependency variables, and keeping ev-
erything else.
Figure 6.17 shows how to translate type environments, signature environments,
and dependency environments, all resulting in fcrtype environments. To trans-
late a type environment, we remove all type signatures for type-indexed func-
tions, but keep the rest.
If a signature environment contains an entry x/angbracketleftT/angbracketright, this is translated into a
binding for cp(x,T). We now use gapp to ﬁrst determine the qualiﬁed type that
is associated with the component, and then translate that qualiﬁed type to an fcr
type. Because the gapp expects a type argument of kind ∗, we introduce fresh
dependency variables as arguments of Tif needed.
An entry x/angbracketleftα0{(αi::κi)}i∈1..n::q/angbracketrightof a dependency environment is translated
into a binding for cp(x,α0), and the type that is associated with that component
is the translation of q.
In the following, we use
/llbracketK;Γ;∆;Σ/rrbracketpar
K;Γ≡/llbracketK/rrbracketpar;/llbracketΓ/rrbracketpar,/llbracket∆/rrbracketpar,/llbracketΣ/rrbracketpar
K;Γ
as an abbreviation.
92
6.4 Types and translation
/llbracketΓfcr+tif+par/rrbracketpar≡Γfcr
/llbracketε/rrbracketpar≡ε(par-gam-1)/llbracketΓ,x::t/rrbracketpar≡/llbracketΓ/rrbracketpar,x::t(par-gam-2)
/llbracketΓ,x/angbracketlefta::∗/angbracketright::σ/rrbracketpar≡/llbracketΓ/rrbracketpar(par-gam-3)
/llbracketΣfcr+tif+par/rrbracketpar
Kfcr+tif+par;Γfcr+tif+par≡Γfcr
/llbracketε/rrbracketpar≡ε(par-sig-1)
K/turnstileleftT::{κi→}i∈1..n∗
{αifresh}i∈1..nK/prime≡K{,αi::κi}i∈1..n
/llbracketΣ,x/angbracketleftT/angbracketright/rrbracketpar
K;Γ≡/llbracketΣ/rrbracketpar
K;Γ,cp(x,T)::/llbracketgappK/prime;Γ(x/angbracketleftT{αi}i∈1..n/angbracketright)/rrbracketpar(par-sig-2)
/llbracket∆fcr+tif+par/rrbracketpar≡Γfcr
/llbracketε/rrbracketpar≡ε(par-dep-1)
/llbracket∆,x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q/rrbracketpar≡/llbracket∆/rrbracketpar,cp(x,α0)::/llbracketq/rrbracketpar(par-dep-2)
Figure 6.17: Translation of fcr+tif+par environments to fcrtype environments
93
6 Dependencies
/llbracketx/angbracketleftA/angbracketright/rrbracketgtrans
K;Γ;Σ≡efcr
x/angbracketleftT/angbracketright∈Σ
/llbracketx/angbracketleftT/angbracketright/rrbracketgtrans
K;Γ;Σ≡cp(x,T)(gtr-named)
/llbracketx/angbracketleftα/angbracketright/rrbracketgtrans≡cp(x,α)(gtr-depvar)
dependenciesΓ(x)≡{yk}k∈1../lscript
,
/llbracketx/angbracketleftA1A2/angbracketright/rrbracketgtrans
K;Γ;Σ≡/llbracketx/angbracketleftA1/angbracketright/rrbracketgtrans
K;Γ;Σ{/llbracketyk/angbracketleftA2/angbracketright/rrbracketgtrans
K;Γ;Σ}k∈1../lscript(gtr-app)
Figure 6.18: Translation of generic application in fcr+tif+par
6.4.7 Translation of generic application
The ﬁnal topic that we need to discuss is the translation of generic application (as
opposed to the algorithm gapp that determines the type of a generic application).
The judgment is of the form
/llbracketx/angbracketleftA/angbracketright/rrbracketgtrans
K;Γ;Σ≡efcr,
and is for use in situations where the dependency constraints that are required
by the translation of x/angbracketleftA/angbracketrightare already in scope. References to the constraints
occur in efcras free variables. The kind of the type argument Ais not restricted
to∗. Although external calls will always provide a type argument Aof kind∗,
the recursive calls may be on type arguments of higher kinds as well.
The algorithm is deﬁned in Figure 6.18. We have used the algorithm in rule
(e/tr-genapp) of Figure 6.13.
We have sketched the idea of the translation in Section 5.4. A generic appli-
cation is translated into an application of components. If dependency variables
appear in the type argument, components of the form cp(x,α), referring to the
component of a generic function for some dependency variable, are used in the
translation. We call such components dependency components . The translation
as a whole has to make sure that all components that are used – both normal
and dependency components – are also available. For normal components, the
signature environment Σcan be used to check which ones are available. For de-
94
6.5 Correctness of the translation
pendency components, the type system takes care that only available components
are referred to. The environment ∆does not play a role in the /llbracket·/rrbracketgtransalgorithm.
The ﬁrst two rules, (gtr-named) and (gtr-depvar) are the base cases of the algo-
rithm. If the type argument is a named type or a dependency variable, we can
translate the call directly to the appropriate component. In the case of a named
type, we have to require that the component is available, and thus require an en-
try of the form x/angbracketleftT/angbracketrightto be contained in the signature environment. Note that the
components cp(x,T)orcp(x,α)are functions in the case that the type argument
is not of kind∗.
If none of the base cases is applicable, the type argument is an application,
and the call is of the form x/angbracketleftA1A2/angbracketright. We recursively translate the call x/angbracketleftA1/angbracketright,
where A1is now of functional kind! The translation of this call is a function that
expects arguments corresponding to the dependencies of x. We thus provide the
translations of the calls yk/angbracketleftA2/angbracketright– where the ykare the dependencies of x– as
arguments. We will show in Theorem 6.5 that the result is type correct in fcr.
6.5 Correctness of the translation
In the previous section, we have explained how the additional features that we
have introduced in fcr+tif+par, such as parametrized type patterns, dependen-
cies, and compound type arguments in calls to type-indexed functions, can be
translated into the core language fcr. This is signiﬁcantly more difﬁcult than
translating the plain type-indexed functions in language fcr+tif, which was the
topic of Chapter 4.
We have deﬁned a translation on expressions, declarations, (qualiﬁed) types,
and environments, and it is of course desirable that the result of the translation
is indeed a correct fcrprogram.
Theorem 6.2 (Correctness of fcr+tif+par).If we can check and translate an ex-
pression in fcr+tif+par, i.e.,
/llbrackete::q/rrbracketpar
K;Γ;∆;Σ≡e/prime,
then the translation is type correct in fcr, and
/llbracketK;Γ;∆;Σ/rrbracketpar
K;Γ/turnstilelefte/prime::/llbracketq/rrbracketpar.
The theorem does not only state that the translation is type correct, but also
that the fcrtype of the translated expression is the translated qualiﬁed type of
the original expression. The following corollary summarizes a few interesting
special cases:
95
6 Dependencies
Corollary 6.3. If we can check an expression to be of an unqualiﬁed type, i.e.,
/llbrackete::t/rrbracketpar
K;Γ;∆;Σ≡e/prime,
then the translation is of the same type,
/llbracketK;Γ;∆;Σ/rrbracketpar
K;Γ/turnstilelefte/prime::t.
IfΓdoes not contain any type-indexed functions and K does not contain any
dependency variables, we even have K; Γ/turnstilelefte/prime::t.
The proof of the theorem proceeds once more by induction on the combined
typing and translation derivation for the original expression. Several different
judgment forms are involved in such a derivation, and many of them are mu-
tually dependent. Therefore, for each of these judgments, a variant of the cor-
rectness theorem has to formulated, and the induction has to be performed with
respect to all of these judgments.
We will pick two relatively interesting parts of the derivation and state them as
separate theorems and give proofs for these parts, while assuming correctness of
the other parts.
Theorem 6.4 (Correctness of subsumption for qualiﬁed types). If K;∆/turnstileleftq1/lessorequalslant
q2/squigglerighte[•],Γis a type environment, and e/primeis an fcrexpression with
/llbracketK/rrbracketpar;Γ,/llbracket∆/rrbracketpar/turnstilelefte/prime::/llbracketq1/rrbracketpar,
then
/llbracketK/rrbracketpar;Γ,/llbracket∆/rrbracketpar/turnstilelefte[e/prime]::/llbracketq2/rrbracketpar.
Proof. The subsumption relation (cf. Figure 6.10) makes signiﬁcant use of two
auxiliary judgments. The conversion into abstractions in Figure 6.11, and the
entailment relation in Figure 6.12.
For both, we can state variants of the correctness claim. Let us start with the
abstraction judgment. The statement to prove here is that if /turnstileleft∆/squigglerighte[•],Γis a
type environment, e/primeis an fcrexpression and qa qualiﬁed type such that
/llbracketK/rrbracketpar;Γ,/llbracket∆/rrbracketpar/turnstilelefte/prime::/llbracketq/rrbracketpar,
then
/llbracketK/rrbracketpar;Γ/turnstilelefte[e/prime]::/llbracket(∆)⇒q/rrbracketpar.
The case (abs-1) is trivial. To prove case (abs-2), we assume that we know that
96
6.5 Correctness of the translation
/llbracketK/rrbracketpar;Γ,/llbracketx/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q/prime,∆/rrbracketpar/turnstilelefte/prime::/llbracketq/rrbracketpar.
Of course, we assume during this proof that the dependency constraints in all
dependency environments appear in ascending order. We know that
/llbracketx/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q/prime,∆/rrbracketpar≡cp(x,α0)::/llbracketq/prime/rrbracketpar,/llbracket∆/rrbracketpar.
We can therefore apply the induction hypothesis to
/llbracketK/rrbracketpar;Γ,cp(x,α0)::/llbracketq/prime/rrbracketpar,/llbracket∆/rrbracketpar/turnstilelefte/prime::/llbracketq/rrbracketpar
and get
/llbracketK/rrbracketpar;Γ,cp(x,α0)::/llbracketq/prime/rrbracketpar/turnstilelefte[e/prime]::/llbracket(∆)⇒q/rrbracketpar.
Applying (e-lam) now yields
/llbracketK/rrbracketpar;Γ/turnstileleft(λcp(x,α0)→e[e/prime])::/llbracketq/prime/rrbracketpar→/llbracket(∆)⇒q/rrbracketpar.
Observing that
/llbracketq/prime/rrbracketpar→/llbracket(∆)⇒q/rrbracketpar≡/llbracket(x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q/prime,∆)⇒q/rrbracketpar,
we are done.
Next, we will deal with the entailment judgment. Here, the adapted correctness
statement we are proving states that if K; ∆1⊩∆2/squigglerighte∆[•], and Γis a type
environment, e/primeanfcrexpression, and qa qualiﬁed type such that
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstilelefte/prime::/llbracket(∆2)⇒q/rrbracketpar,
then
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstilelefte∆[e/prime]::/llbracketq/rrbracketpar.
Again, the case (ent-1) is trivial. For case (ent-2), we assume that there are K,
Γ,∆1and∆2such that
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstilelefte/prime::/llbracket(x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q2,∆2)⇒q/rrbracketpar.
We know that x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q1is in∆1– that is a condition on (ent-2).
Therefore,
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstileleftcp(x,α0)::/llbracketq1/rrbracketpar.
To this judgment we can apply the induction hypothesis (on the subsumption
statement K; ∆1/turnstileleftq1/lessorequalslantq2/squigglerighte[•]in the antecedent), and conclude that
97
6 Dependencies
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstilelefte[cp(x,α0)]::/llbracketq2/rrbracketpar.
Next, we apply rule (e-app), which gives us
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstileleft(e/primee[cp(x,α0)])::/llbracket(∆2)⇒q/rrbracketpar.
Applying the induction hypothesis for the entailment K; ∆1⊩∆2/squigglerighte∆[•]to the
above judgment results in
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstilelefte∆[e/primee[cp(x,α0)]]::/llbracketq/rrbracketpar,
which is what we require.
We are now going to prove the rules of the subsumption judgment itself. For
case (qs-dep-1), we assume that
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstilelefte/prime::/llbracketq/rrbracketpar.
Then, of course, also
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar,/llbracket∆2/rrbracketpar/turnstilelefte/prime::/llbracketq/rrbracketpar,
which under the induction hypothesis (on the subsumption ∆1,∆2/turnstileleftq/lessorequalslantt/squiggleright
e[•]) yields
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar,/llbracket∆2/rrbracketpar/turnstilelefte[e/prime]::/llbrackett/rrbracketpar.
We can apply the induction hypothesis once more (on the abstraction /turnstileleft∆2/squiggleright
e∆[•]) to get
/llbracketK/rrbracketpar;Γ,/llbracket∆1/rrbracketpar/turnstilelefte∆[e[e/prime]]::/llbracket(∆2)⇒t/rrbracketpar.
Next, case (qs-dep-2). We assume
/llbracketK/rrbracketpar;Γ,/llbracket∆2/rrbracketpar/turnstilelefte/prime::/llbracket(∆1)⇒t1/rrbracketpar.
Using the induction hypothesis (on the entailment K; ∆2⊩∆1/squigglerighte[•]), we can
conclude
/llbracketK/rrbracketpar;Γ,/llbracket∆2/rrbracketpar/turnstilelefte[e/prime]::/llbrackett1/rrbracketpar.
Because /llbrackett1/rrbracketpar≡t1as well as /llbrackett2/rrbracketpar≡t2and /llbracketK/rrbracketpar/turnstileleftt1/lessorequalslantt2, we can apply
(e-subs) and are done.
For (qs-skol), we assume that
/llbracketK/rrbracketpar;Γ,/llbracket∆/rrbracketpar/turnstilelefte/prime::/llbracketq1/rrbracketpar
98
6.5 Correctness of the translation
and that ais a type variable that does not occur free in q1, thus neither in /llbracketq1/rrbracketpar.
We can furthermore assume that adoes not occur in K or Γ(otherwise, rename a
everywhere). From the induction hypothesis, we can conclude that
/llbracketK,a::κ/rrbracketpar;Γ,/llbracket∆/rrbracketpar/turnstilelefte[e/prime]::/llbracketq2/rrbracketpar.
We can now apply (e-gen) to get
/llbracketK/rrbracketpar;Γ,/llbracket∆/rrbracketpar/turnstilelefte[e/prime]::/llbracket∀a::κ.q2/rrbracketpar,
observing that∀a::κ./llbracketq2/rrbracketpar≡/llbracket∀a::κ.q2/rrbracketpar, which is what we need (we can
re-rename anow everywhere but in the quantiﬁed expression).
The last case is (qs-inst): here, we assume that
/llbracketK/rrbracketpar;Γ,/llbracket∆/rrbracketpar/turnstilelefte/prime::/llbracket∀a::κ.q2/rrbracketpar.
Again, /llbracket∀a::κ.q2/rrbracketpar≡∀a::κ./llbracketq2/rrbracketpar. Furthermore, /llbracketq1/rrbracketpar[u/a]≡/llbracketq1[u/
a]/rrbracketpar. We can thus apply the induction hypothesis and rule (e-subs) to get
/llbracketK/rrbracketpar;Γ,/llbracket∆/rrbracketpar/turnstilelefte[e/prime]::/llbracketq2/rrbracketpar,
which is the desired result.
The critical part of the whole correctness proof is the one that involves the
generic application algorithm. We want to show that the translation that gapp
generates for a call x/angbracketleftA/angbracketrightis type correct in fcr, and that the type of that translation
infcris related to the qualiﬁed type gapp (x/angbracketleftA/angbracketright).
The /llbracket·/rrbracketgtransalgorithm internally uses calls x/angbracketleftA/angbracketright, where Ahas arbitrary kind.
In contrast, gapp , as given in Figure 6.8, is limited to type arguments of kind ∗.
To facilitate the proof, we now lift this restriction and extend gapp to type ar-
guments of arbitrary kind. The additional rule is displayed in Figure 6.19. The
prerequisites are that the type argument is free of dependency variable. A closer
inspection reveals that in the original rules of the algorithm in Figure 6.8, only the
base case (ga-1) contains the restriction that the type argument must be of kind ∗.
The other two, for handling dependency variables, can be applied on type ar-
guments of higher kind, but will fall back on rule (ga-4) once all dependency
variables have been eliminated.
The new rule (ga-4) itself is similar to the rule (ga-3), the case where a depen-
dency variable of kind κoccurs in the type argument A, but not in the head.
Here, the type argument that Ahas been abstracted over plays a role similar to
a dependency variable. If Ais of kind κ→κ/prime, we introduce a new type variable
with kind κ. Instead of dependencies, we generate explicit function arguments
for each of the generic functions yk, which we assume to be listed in canonical
99
6 Dependencies
gappK;Γ(x/angbracketleftA/angbracketright)≡q
fdv(A)≡ε K/turnstileleftA::κ→κ/prime
afresh K/prime≡K,a::κ
dependenciesΓ(x)≡{yk}k∈1..n
,
gappK;Γ(x/angbracketleftA/angbracketright)≡∀a::κ.{gappK/prime;Γ(yk/angbracketlefta/angbracketright)→}k∈1..ngappK/prime;Γ(x/angbracketleftA a/angbracketright)(ga-4)
Figure 6.19: Generic application algorithm extension for type arguments of higher kinds,
extends Figure 6.8
ascending order. The types of the function arguments are computed by recursive
calls to gapp (yk/angbracketlefta/angbracketright), and the result type is given by gapp (x/angbracketleftA a/angbracketright), where type
application takes the place of the substitution of the dependency variable.
Given the extended generic application algorithm, we are now capable of stat-
ing the correctness of the translation of generic application.
Theorem 6.5 (Correctness of generic application). IfgappK;Γ(x/angbracketleftA/angbracketright)≡qand
K;∆/turnstileleftq/lessorequalslantt, then
/llbracketK;Γ;∆;Σ/rrbracketpar
K;Γ/turnstileleft/llbracketx/angbracketleftA/angbracketright/rrbracketgtrans
K;Γ;Σ::t.
The theorem states that if the gapp algorithm gives us a qualiﬁed type q, and
we have environments in which we can satisfy all the dependency constraints
that qhas to yield an unqualiﬁed type t, then we can assign this type tunder
the translated environments to the translated generic application. The type argu-
ment Acan be of arbitrary kind – we make thus use of the generalized generic
application algorithm just introduced.
Proof. We prove the theorem by induction over the /llbracket·/rrbracketgtransderivation in Fig-
ure 6.18.
In the case of rule (gtr-named), we know that the type argument Ais a named
type T. In this case, we know that x/angbracketleftT/angbracketrightis inΣ, and that /llbracketx/angbracketleftT/angbracketright/rrbracketgtrans
K;Γ;Σ≡cp(x,T).
Now, the translation of signature environments, in particular (par-sig-2), reveals
that /llbracketK;Γ;∆;Σ/rrbracketparcontains the binding
cp(x,T)::/llbracketgappK/prime;Γ(x/angbracketleftT{αi}i∈1..n/angbracketright)/rrbracketpar,
where, by construction of the rule (ga-4),
100
6.5 Correctness of the translation
/llbracketgappK/prime;Γ(x/angbracketleftT{αi}i∈1..n/angbracketright)/rrbracketpar≡gappK/prime;Γ(x/angbracketleftT/angbracketright)
(the dependencies on the left hand side translate to the same explicit function
arguments that are introduced on the right hand side by rule (ga-4)).
In case (gtr-depvar), we have A≡α, and /llbracketx/angbracketleftα/angbracketright/rrbracketgtrans≡cp(x,α). By rule (ga-2)
and (mkdep), we have that
q≡gappK;Γ(x/angbracketleftα/angbracketright)
≡∀a::κ./parenleftBig
x/angbracketleftα{γh}h∈1..p/angbracketright::gappK/prime;Γ/parenleftbig
x/angbracketlefta{γh}h∈1..p/angbracketright/parenrightbig/parenrightBig
⇒gappK/prime;Γ(x/angbracketlefta/angbracketright),
where κis the kind of α, the γhare local dependency variables, and K/prime≡K,a::κ.
We observe that for any generic function x, type argument Aand type t/prime, we
have that
gapp (x/angbracketleftA/angbracketright)[t/prime/a]≡gapp (x/angbracketleftA[t/prime/a]/angbracketright).
Hence, we can conclude from the precondition K; ∆/turnstileleftq/lessorequalslanttthat∆contains a
binding of the form
x/angbracketleftα{γh}h∈1..p/angbracketright::gappK/prime;Γ/parenleftbig
x/angbracketleftt/prime{γh}h∈1..p/angbracketright/parenrightbig
for some type t/primeof kind κthat the type variable ahas been instantiated with, and
we have to show that
/llbracketK;Γ;∆;Σ/rrbracketpar/turnstileleft/llbracketx/angbracketleftα/angbracketright/rrbracketgtrans
K;Γ;Σ::gappK/prime;Γ(x/angbracketleftt/prime/angbracketright)
for the same t/prime. (Actually, the binding in ∆may be to any type convertible into
the above type, but that does not make an essential difference).
Because of the binding in ∆, the translated environments /llbracketK;Γ;∆;Σ/rrbracketparcontains
a binding of the form
cp(x,α)::/llbracketgappK/prime;Γ(x/angbracketlefta{γh}h∈1..p/angbracketright)/rrbracketpar,
of which the right hand side by construction is the same as
gappK/prime;Γ(x/angbracketlefta/angbracketright).
An application of (e-var) thus shows that cp(x,α)is of the required type.
This leaves case (gtr-app): here, A≡A1A2. To simplify the notation slightly,
we assume that xhas just one dependency, which we name y. It is straightforward
to generalize to multiple dependencies. We can write
q≡gappK;Γ(x/angbracketleftA1A2/angbracketright)≡{∀ ai::κi.}i∈1..n(∆/prime)⇒gappK/prime;Γ(x/angbracketleftA/prime
1A/prime
2/angbracketright),
101
6 Dependencies
where
fdv(A1A2)≡{αi}i∈1..n
,
A/prime
1≡A1{[ai/αi]}i∈1..n
A/prime
2≡A2{[ai/αi]}i∈1..n.
The translation /llbracketx/angbracketleftA1A2/angbracketright/rrbracketgtransis, according to rule (gtr-app), the application
(/llbracketx/angbracketleftA1/angbracketright/rrbracketgtrans/llbrackety/angbracketleftA2/angbracketright/rrbracketgtrans).
Let us ﬁrst inspect the call x/angbracketleftA1/angbracketrightmore closely. Let /turnstileleftA1::κ→κ/prime. We have
that under K and ∆,
gappK;Γ(x/angbracketleftA1/angbracketright)/lessorequalslant{∀ai::κi.}i∈1..n(∆/prime)⇒
∀a::κ.gappK/prime;Γ(y/angbracketlefta/angbracketright)→gappK/prime;Γ(x/angbracketleftA/prime
1a/angbracketright)
≡q1.
We know that
K;∆/turnstileleftq/lessorequalslantt,
which implies
K;∆/turnstileleftq1/lessorequalslantgappK/prime;Γ(y/angbracketleftA/prime
2/angbracketright)→t
if we substitute abyA/prime
2. We apply the induction hypothesis to the call x/angbracketleftA1/angbracketrightand
the unqualiﬁed type gappK/prime;Γ(y/angbracketleftA/prime
2/angbracketright)→t, which yields
/llbracketK;Γ;∆;Σ/rrbracketpar/turnstileleft/llbracketx/angbracketleftA1/angbracketright/rrbracketgtrans
K;Γ;Σ::gappK/prime;Γ(y/angbracketleftA/prime
2/angbracketright)→t.
Now, let us inspect the call y/angbracketleftA2/angbracketright. Under K and ∆,
gappK;Γ(y/angbracketleftA2/angbracketright)/lessorequalslant{∀ai::κi.}i∈1..n(∆/prime)⇒gappK/prime;Γ(y/angbracketleftA/prime
2/angbracketright)
≡q2.
This time, the precondition /turnstileleftq/lessorequalslanttimplies that
K;∆/turnstileleftq1/lessorequalslantgappK/prime;Γ(y/angbracketleftA/prime
2/angbracketright).
The induction hypothesis applied to the call y/angbracketleftA2/angbracketrightand the type gappK/prime;Γ(y/angbracketleftA/prime
2/angbracketright)
yields
/llbracketK;Γ;∆;Σ/rrbracketpar/turnstileleft/llbrackety/angbracketleftA2/angbracketright/rrbracketgtrans
K;Γ;Σ::gappK/prime;Γ(y/angbracketleftA/prime
2/angbracketright).
The result of /llbracketx/angbracketleftA1A2/angbracketright/rrbracketgtransis the application (/llbracketx/angbracketleftA1/angbracketright/rrbracketgtrans/llbrackety/angbracketleftA2/angbracketright/rrbracketgtrans).
We can therefore apply rule (e-app) to get
/llbracketK;Γ;∆;Σ/rrbracketpar/turnstileleft/llbracketx/angbracketleftA1A2/angbracketright/rrbracketgtrans
K;Γ;Σ::t,
which proves the ﬁnal case of the induction and therefore the theorem.
102
6.6 Kind-indexed types?
6.6 Kind-indexed types?
Ralf Hinze has introduced two styles of generic function deﬁnitions, which he
named after the conferences where he ﬁrst presented papers on them, mpc-style
(Hinze 2000 c) and popl-style (Hinze 2000 b). Generic Haskell has originally been
based on mpc-style deﬁnitions of type-indexed functions.
In his mpc paper, Hinze revealed that a type-indexed value possesses a kind-
indexed type . Where a type-indexed function is deﬁned over the structure of types,
a kind-indexed type is deﬁned over the (much simpler) structure of kinds. A
function such as addwould make use of the following kind-indexed type:
type Add/angbracketleft/angbracketleft∗/angbracketright/angbracketright a=a→a→a
type Add/angbracketleft/angbracketleftκ→κ/prime/angbracketright/angbracketrighta=∀b::κ. Add/angbracketleft/angbracketleftκ/angbracketright/angbracketrightb→Add/angbracketleft/angbracketleftκ/prime/angbracketright/angbracketright(a b)
add/angbracketlefta::κ/angbracketright :: Add/angbracketleft/angbracketleftκ/angbracketright/angbracketrighta
The ﬁrst two lines declare a kind-indexed type – the type keyword indicates that
we deﬁne a type-level entity, and we use double angle brackets /angbracketleft/angbracketleft·/angbracketright/angbracketrightto denote
the kind index. There are two arms, one for the kind ∗, and one for functional
kinds of the form κ→κ/prime. The argument ais supposed to be of the kind that is
associated with the particular branch, so that we could assign the kind
Add/angbracketleftκ/angbracketright::κ→∗
to the kind-indexed type Add. The ﬁnal line assigns the kind-indexed type to the
function add.
For comparison, this is the type signature that we use for add:
add/angbracketlefta::∗/angbracketright::(add)⇒a→a→a.
The Dependency-style that we use is essentially a generalization of mpc-style.
For kind∗type arguments without dependency variables, both signatures match:
ifAis a type argument of kind ∗with fdv(A)≡ε, the kind-indexed type is
used at Add/angbracketleft/angbracketleft∗/angbracketright/angbracketright A, which expands to A→A→A. Similarly gapp (x/angbracketleftA/angbracketright)≡
base (x/angbracketleftA/angbracketright)≡A→A→Ain this case.
Differences occur if type constructors of higher kind are involved in the type
arguments. In mpc-style, there are no dependency variables, nor are there de-
pendency constraints. But neither are type arguments restricted to kind ∗in
mpc-style. Using dependency variables, we deﬁned addfor lists as follows:
add/angbracketleft[α]/angbracketright x y
|length x ==length y =map (uncurry (add/angbracketleftα/angbracketright)) (zip x y )
|otherwise =error "args must have same length" .
103
6 Dependencies
Inmpc-style, we would just deﬁne the arm in terms of the list type constructor [ ]:
add/angbracketleft[ ]/angbracketrightaddαx y
|length x ==length y =map (uncurry (addα)) ( zip x y )
|otherwise =error "args must have same length" .
Instead of the explicit recursive call to add/angbracketleftα/angbracketright, the function is provided with
an extra argument addα, that can be used in the places where we would like to
call addon the list element type. Interestingly though, the second version of
the function is (modulo renaming) identical to the component cp(add,[ ])that we
translate the arm add/angbracketleft[α]/angbracketrightto. The type of add/angbracketleft[ ]/angbracketrightis justiﬁed by the kind-indexed
type, which states that
Add/angbracketleft∗→∗/angbracketright ([ ])≡∀a::∗.(a→a→a)→[a]→[a]→[a].
This corresponds to the fact that we have generalized the gapp algorithm to yield
gapp (x/angbracketleft[ ]/angbracketright)≡∀a::∗.(a→a→a)→[a]→[a]→[a].
Indeed, we use kind-indexed types internally – during the translation – because
they form an expressive, theoretically solid and elegant way to treat type-indexed
functions. However, on the surface, visible to the programmer and user of type-
indexed functions, we make use of dependency variables instead.
The advantage of the use of dependency types is that it is more explicit: in the
deﬁnition of add/angbracketleft[α]/angbracketright, we can immediately see that addis recursively deﬁned and
depends on itself, whereas we have to know how the specialization mechanism
works to understand that addα– which is only the name of a bound variable
here, and could have been given a much less informative name – will indeed be
instantiated with the addfunction on the element type of the list in the deﬁnition
ofadd/angbracketleft[ ]/angbracketright.
This becomes even clearer in the presence of type-indexed functions that have
more than one dependency. Recall the type of cprfrom Section 5.3:
cpr/angbracketlefta::∗/angbracketright::(equal ,cpr)⇒a→a→CprResult .
The type signature of cprinmpc-style would look as follows:
type Cpr/angbracketleft/angbracketleft∗/angbracketright/angbracketright a=a→a→CprResult
type Cpr/angbracketleft/angbracketleftκ→κ/prime/angbracketright/angbracketrighta=∀b::κ. Equal/angbracketleft/angbracketleftκ/angbracketright/angbracketrightb→Cpr/angbracketleft/angbracketleftκ/angbracketright/angbracketrightb
→Cpr/angbracketleft/angbracketleftκ/prime/angbracketright/angbracketright(a b)
type Equal/angbracketleft/angbracketleft∗/angbracketright/angbracketright a=a→a→Bool
type Equal/angbracketleft/angbracketleftκ→κ/prime/angbracketright/angbracketrighta=∀b::κ. Equal/angbracketleft/angbracketleftκ/angbracketright/angbracketrightb→Equal/angbracketleft/angbracketleftκ/prime/angbracketright/angbracketright(a b)
cpr/angbracketlefta::κ/angbracketright :: Cpr/angbracketleft/angbracketleftκ/angbracketright/angbracketrighta.
104
6.6 Kind-indexed types?
The kind-indexed type Cpr makes use of the kind-indexed type Equal which
belongs to the equal function. An arm of the cprfunction for a type constructor
of higher kind is supplied with additional arguments not only for the recursive
calls of cpr, but also for calls to equal .
It is the programmer’s responsibility to remember the order of the dependent
functions and to assign suitable names to the additional arguments in order to
visualize what the arguments represent. Furthermore, there needs to be some
mechanism in the language that actually ﬁnds out that the function cprdepends
on the functions equal and cpr. The names Cpr and Equal are names on the
type level which we have chosen as appropriate, but Equal could be the type of
several type-indexed functions, not only of equal , and there is no easy way for
the compiler to determine the correct dependencies between the functions only
from the type. Finally, if this problem has been solved, the deﬁnition is still not
very robust with respect to change. Once we add an arm to a generic function
that requires an additional dependency, all other arms for type constructors of
higher kind suddenly get new arguments, and all deﬁnitions have to be adapted
accordingly. It may be for these reasons that Hinze considers only type-indexed
functions that depend exclusively on themselves in his mpcpaper.
Using dependency variables, we thus achieve that we can easily determine the
dependencies, because we use the names of the functions in the deﬁnitions. The
dependencies are also recorded in the type. An additional dependency can be
added by changing the type signature of the function – none of the arms need
to be changed. Because dependencies are no longer explicit function arguments,
but implicit ones, their order is irrelevant to the user.
The translation for dependencies that we have outlined in this chapter reveals
that dependencies form a layer around kind-indexed types, that shields the user
from its complexities and provide the user with a more explicit syntax and addi-
tional ﬂexibility due to the practical use of functions that have multiple depen-
dencies.
Interestingly, the syntax for type-indexed functions that we use in this thesis is
very similar to the other style that Hinze introduced, popl-style. In that approach,
type constructors in type arguments are augmented with type variables, and
recursive calls to type-indexed functions are explicit. Unfortunately, popl-style
is less expressive and more restricted in some respects. The Dependency-style
used in this thesis, by being in essence a wrapper around mpc-style, has all the
expressiveness of that style. It combines thus the advantages of both approaches:
the ease of use of popl-style with the generality of mpc-style.
105
6 Dependencies
106
7 Going Generic
With the additions of Chapter 6, we have extended the type-indexed deﬁnitions
of Chapter 4 signiﬁcantly, but there is still no genericity: the set of type arguments
that a type-indexed function can be specialized to is exactly the set of types that
can be built from the named types that are in the signature of the function.
The idea of genericity, however, is that we can write type-indexed algorithms
based on the structure of datatypes, surpassing the differences that the names of
datatypes make.
As it turns out, the remaining step, from a programmer’s point of view, is a
very small one. The programmer must only write a few additional arms of a type-
indexed deﬁnition, for a number of special purpose datatypes, and suddenly, the
function can be specialized to nearly all Haskell datatypes!
Later in this chapter, we discuss several examples of generic functions. All of
them have been mentioned before and are more or less “classics” in the world of
generic functions. Presenting them in the framework of Generic Haskell should
give a good intuition about the way generic functions are deﬁned and used in
Generic Haskell.
107
7 Going Generic
7.1 Unit, Sum, and Prod
Let Unit, Sum and Prod be datatypes deﬁned as follows:
data Unit =Unit
data Sum (a::∗) (b::∗) =Inl a|Inr b
data Prod (a::∗) (b::∗) =a×b.
These types are very basic, and in fact have their isomorphic counterparts in
Haskell: Unit is isomorphic to the unit type (), a type with just one value (with
the exception of the undeﬁned value ⊥, of course); Sum is isomorphic to Either,
which gives a choice between two alternatives. The constructors are Inl(read
“in-left”) and Inr(“in-right”). Finally Prod is the same as a pair, but we use ×as
an inﬁx constructor, instead of Haskell’s standard pair constructor (,).
These three types play a special role in the deﬁnition and use of generic func-
tions, which is also the reason why we choose to introduce our own new types,
instead of reusing the standard Haskell types. This way, (), Either, and (,)can
still be used as any other type.
Recall the type-indexed function add. In Chapter 4, we had deﬁned it for Bool,
Int, and Char:
add/angbracketleftBool/angbracketright = (∨)
add/angbracketleftInt/angbracketright = (+)
add/angbracketleftChar/angbracketright x y =chr(ord x +ord y ).
It is easy to add an extra arm for Unit: there is only one value of that type, so we
decide that the sum of two Unit’s should be Unit again:
add/angbracketleftUnit/angbracketright Unit Unit =Unit .
Later, in Chapter 6 we deﬁned additional cases for lists and pairs. Just as for
Haskell pairs, we can of course also deﬁne addition for products of type Prod,
adding the two components pointwise:
add/angbracketleftProd α β/angbracketright(x1×x2) (y1×y2) = ( add/angbracketleftα/angbracketrightx1y1)×(add/angbracketleftβ/angbracketrightx2y2).
Of the three types just introduced, only a case for Sum remains to be deﬁned.
Here we take an approach similar to what we did when we tried to deﬁne ad-
dition of lists: we deﬁned addition pointwise on the elements, provided the lists
were of the same shape, i.e., length. Two values of the Sum type are of the same
shape if they belong to the same alternative.
108
7.1 Unit, Sum, and Prod
add/angbracketleftSum α β/angbracketright(Inl x ) ( Inl y ) = Inl(add/angbracketleftα/angbracketrightx y)
add/angbracketleftSum α β/angbracketright(Inr x ) ( Inr y ) = Inr(add/angbracketleftβ/angbracketrightx y)
add/angbracketleftSum α β/angbracketright =
error "args must have same shape" .
With the arms for Bool, Int, Char, Unit, Prod, and Sum, the function addbecomes
generic : the compiler can interpret applications of addto more datatypes than it
has been deﬁned for. How this is achieved will be the topic of Section 7.5 and
later chapters. Let us ﬁrst look at examples.
Using the extended deﬁnition of add, we can call the function on a broad variety
of datatypes, for instance on lists:
add/angbracketleft[Bool ]/angbracketright[False ,True,True ] [False ,False ,True ]
evaluates successfully to [False ,True,True ], and the call
add/angbracketleft[Int]/angbracketright[2, 3] [1]
results in the error message "args must have same shape" . A speciﬁc deﬁnition
for lists is no longer needed, because it can be derived from the cases for Unit,
Sum, and Prod that have been speciﬁed. The function addworks for trees as well:
the call
add/angbracketleftTree Int/angbracketright/parenleftbig
Node (Node Leaf 1Leaf)2(Node Leaf 3Leaf)/parenrightbig
/parenleftbig
Node (Node Leaf 2Leaf)3(Node Leaf 5Leaf)/parenrightbig
evaluates to Node (Node Leaf 3Leaf)5(Node Leaf 8Leaf). Arbitrary combinations
of types are possible, such as triples of integer lists, booleans and characters: the
expression
add/angbracketleftbig/parenleftbig[Int], Bool, Char/parenrightbig/angbracketrightbig([4, 2],False ,’!’) ([1, 3],False ,’Y’)
results in ([5, 5],False ,’z’).
Datatypes with higher-kinded type arguments and nested datatypes may ap-
pear in the type arguments as well. The only condition is that if the type argu-
ment contains any abstract types , i.e., types for which no datatype deﬁnition is
known, these abstract types must occur in the signature of the generic function.
Examples of such abstract types are built-in types such as Int, Char, Float, or the
function type constructor (→). Whereas Int and Char are part of the signature of
add, the types Float and (→)are not. Hence, a call to
add/angbracketleftFloat/angbracketright
or also
109
7 Going Generic
add/angbracketleftbig/bracketleftbig[(Int, Float )]/bracketrightbig/angbracketrightbig
still – notwithstanding genericity – fails at compile time with a specialization
error.
In the next sections, we will – now that we ﬁnally can – discuss a few more
example generic functions.
7.2 Generic enumeration
A very simple generic function computes a default value (that should somehow
represent null or empty) for each datatype.
empty/angbracketlefta::∗/angbracketright ::(empty )⇒a
empty/angbracketleftInt/angbracketright =0
empty/angbracketleftChar/angbracketright =’ ’
empty/angbracketleftFloat/angbracketright =0.0
empty/angbracketleftUnit/angbracketright =Unit
empty/angbracketleftSum α β/angbracketright=Inl(empty/angbracketleftα/angbracketright)
empty/angbracketleftProd α β/angbracketright=empty/angbracketleftα/angbracketright×empty/angbracketleftβ/angbracketright
empty/angbracketleftα→β/angbracketright=const (empty/angbracketleftβ/angbracketright)
The function is deﬁned on the abstract types Int, Char, Float to return an ap-
propriate value. For the Unit type, there is not much choice but to return the Unit
value. For a Sum, we decide to prefer the left alternative. In a Prod, we return
a pair of two empty values. Finally, we have also deﬁned an arm for functions.
Functions are another example of an abstract type: if there is no explicit arm,
function types could not be handled generically. Here, we decide to return the
constant function returning the empty value of the result type.
Therefore, the call
map/parenleftbig
λ(x,y,z)→(x’A’,y,z)/parenrightbig /parenleftbig
empty/angbracketleft(Char→[Int], Tree Float, Bool )/angbracketright/parenrightbig
can successfully be translated, and evaluates to ([ ],Leaf,False ). The signature of
empty is Int, Char, Float, Unit, Sum, Prod, (→), thus Bool is not contained in the
signature. Nevertheless, the call above succeeds. This indicates that Bool is not
considered abstract. Instead, we assume that Bool is deﬁned via the following
datatype declaration:
data Bool =False|True .
The generic function (or generic value, in this case) empty also serves as an
example that generic functions can be used to produce, not only to consume,
110
7.2 Generic enumeration
values of generic type. In general, it is easy to generate values of a large class
of datatypes automatically using a generic function. A variant of empty is the
function enum that generates allvalues of a datatype:
enum/angbracketlefta::∗/angbracketright ::(enum )⇒[a]
enum/angbracketleftInt/angbracketright =interleave [0,−1 . .] [1 . .]
enum/angbracketleftChar/angbracketright = [’\NUL’ . .]
enum/angbracketleftUnit/angbracketright = [Unit ]
enum/angbracketleftSum α β/angbracketright=interleave (map Inl (enum/angbracketleftα/angbracketright))
(map Inr (enum/angbracketleftβ/angbracketright))
enum/angbracketleftProd α β/angbracketright=diag (enum/angbracketleftα/angbracketright) (enum/angbracketleftβ/angbracketright).
We take some precautions to handle inﬁnite types in a way that every value
will be enumerated with a ﬁnite index. The functions interleave and diag can be
deﬁned as follows:
interleave ::∀a::∗.[a]→[a]→[a]
interleave [ ] [ ] = [ ]
interleave [ ] ys=ys
interleave (x:xs)ys=x:interleave ys xs
diag ::∀(a::∗) (b::∗).[a]→[b]→[Prod a b]
diag xs ys =concat (diag/primexs ys )
diag/prime::∀(a::∗) (b::∗).[a]→[b]→[[Prod a b]]
diag/prime[ ] ys =map (const [ ])ys
diag/primexs [ ] = map (const [ ])xs
diag/prime(x:xs) (y:ys) = [( x×y)]:zipWith (+ +) ( diag/prime[x]ys)
(diag/primexs(y:ys)).
The function enum , maybe with some reﬁnements to generate a better dis-
tribution, has applications in automatic test case generation, for tools such as
QuickCheck (Claessen and Hughes 2000) or GAST (Koopman et al. 2003). These
tools allow the programmer to verify properties of their programs on a randomly
generated set of example values. Because the values involved can be from a mul-
titude of different types, the use of generic functions to generate suitable values
is desirable.
Other, similar functions, include a generic function to generate the “minimal”
or “maximal” value of a datatype, and a function that, given a “lower” and an
“upper” bound, enumerates all values that lie in between.
111
7 Going Generic
7.3 Generic equality
Next, we look at the prototypical example of a generic function. An equality test
is probably the most often needed operation on values of a particular datatype.
Haskell has an overloaded equality function, and provides a built-in deriving
mechanism that – on demand – automatically generates the equality function for
a user-deﬁned datatype. It seems a safe bet to guess that the reason that deriving
is present in Haskell, is mainly the equality function. In Standard ml(Milner et al.
1997) equality is also treated specially, and can be automatically generated for a
large class of types.
With Generic Haskell, we can now deﬁne the equality function.
equal/angbracketleftInt/angbracketright = (≡)
equal/angbracketleftChar/angbracketright = (≡)
equal/angbracketleftFloat/angbracketright = (≡)
equal/angbracketleftUnit/angbracketright Unit Unit =True
equal/angbracketleftSum α β/angbracketright(Inl x ) ( Inl y ) = equal/angbracketleftα/angbracketrightx y
equal/angbracketleftSum α β/angbracketright(Inr x ) ( Inr y ) = equal/angbracketleftβ/angbracketrightx y
equal/angbracketleftSum α β/angbracketright =False
equal/angbracketleftProd α β/angbracketright(x1×x2) (y1×y2) =equal/angbracketleftα/angbracketrightx1x2∧equal/angbracketleftβ/angbracketrighty1y2
For the primitive types Int, Char, and Float, we use Haskell’s equality func-
tion (≡). We could also use primitive equality functions on these types, but
Haskell gives us access to them only via the overloaded (≡)function.
Two Unit values are easy to compare. In the situation that we are given two
sums, we distinguish three cases: both values are from the left alternative, both
are from the right alternative, or they are from different alternatives. In the last
case, they cannot be equal. In the other two cases, we compare the two values
embedded in the sum. Products are tested for equality pointwise.
Functions are hard to compare in general, but if their domain is ﬁnite, it is
possible, using enum :
equal/angbracketleftα→β/angbracketrightfx fy =equal/angbracketleft[β]/angbracketright/parenleftbig
map fx (enum/angbracketleftα/angbracketright)/parenrightbig
/parenleftbig
map fy (enum/angbracketleftα/angbracketright)/parenrightbig
.
This function will correctly compare functions with a ﬁnite domain, and it will
sooner or later return False for functions with an inﬁnite domain that are not
equal. If two equal functions of inﬁnite domain are compared, the call will not
terminate. (Using the generic cardinality test that is deﬁned in Section 17.1.3, we
could add a run-time check if the domain type of the function is inﬁnite, and
return a run-time error instead of a nonterminating computation.) The equality
112
7.4 Generic compression
function, such as written here, depends on both itself and enum . Its type signature
is thus
equal/angbracketlefta::∗/angbracketright::(equal ,enum )⇒a→a→Bool .
Although empty ,enum , and equal are all deﬁned only for abstract types and the
three special types Unit, Sum, and Prod, it is by no means forbidden to specify
explicit behaviour also for non-abstract types. If a type is part of the signature of
a generic function, the explicitly speciﬁed functionality always takes precedence
over the generic behaviour.
For instance, a large class of datatypes might be used to represent an abstract
syntax tree for some programming language. The abstract syntax tree is created
by parsing a concrete program. To produce good error messages, it might be
useful to store position information in the datatypes. All of these datatypes might
have a ﬁeld of type
data Range =Range Position Position ,
storing a start and an end position, where
data Position =Position String Int Int ,
consisting of a ﬁlename, a line, and a column number. When checking two syn-
tactic constructs for equality, the positional information is irrelevant. Therefore,
we would like to treat two values of type Range always as equal. In this case, we
simply add an additional line to the deﬁnition of equal :
equal/angbracketleftRange/angbracketrightx y =True ,
and values of type Range will not be tested generically.
A generalized variant of generic equality is a generic total comparison function,
that returns for any two values of a type one of the results LT(“less than”), EQ
(“equal”), or GT(“greater than”).
7.4 Generic compression
A classic application area of generic functions is parsing and unparsing, i.e., read-
ing values of different types from some universal representation, or writing val-
ues to that universal representation. The universal representation can be aimed
at being human-readable (such as the result of Haskell’s show function; see also
Section 17.1.2), or it can be intended for data exchange, such as xml(W3C 2004)
113
7 Going Generic
or ATerms (Van den Brand et al. 2000). Other applications include encryption,
transformation, or storage.
We will treat a very simple case of compression here, by deﬁning functions that
can write to and read from a sequence of bits. A bit is deﬁned by the following
datatype declaration:
data Bit=0|1
(the names 0and 1are used as constructors here). We can now deﬁne a simple
encoding function that produces a single bit whenever a choice is made:
encode/angbracketlefta::∗/angbracketright ::(encode )⇒a→[Bit]
encode/angbracketleftUnit/angbracketright Unit = [ ]
encode/angbracketleftSum α β/angbracketright(Inl x ) = 0:encode/angbracketleftα/angbracketrightx
encode/angbracketleftSum α β/angbracketright(Inr x ) = 1:encode/angbracketleftβ/angbracketrighty
encode/angbracketleftProd α β/angbracketright(x1×x2) =encode/angbracketleftα/angbracketrightx1+ +encode/angbracketleftβ/angbracketrightx2.
The only place where there really is a choice is in the Sum type. Here, the value
can be either an Inlor an Inr. If we have to encode a value of type Unit, it can only
beUnit, so we need no bits to encode that knowledge. Similarly, for a product
we know that the value is the ﬁrst component followed by the second – we need
no extra bits except the encodings of the components.
The function is only really useful if we add some deﬁnitions for primitive types
that encode integers or characters as suitable sequences of bits. We omit these
cases here.
To recover a value from a list of bits, we deﬁne the function decodes (a function
decode will be deﬁned later, in Section 12.1):
decodes/angbracketlefta::∗/angbracketright ::(decodes )⇒[Bit]→[(a,[Bit])]
decodes/angbracketleftUnit/angbracketright x = [(Unit ,x)]
decodes/angbracketleftSum α β/angbracketright(0:x) = [( Inl y ,r)|(y,r)←decodes/angbracketleftα/angbracketrightx]
decodes/angbracketleftSum α β/angbracketright(1:x) = [( Inr y ,r)|(y,r)←decodes/angbracketleftβ/angbracketrightx]
decodes/angbracketleftSum α β/angbracketright[ ] = [ ]
decodes/angbracketleftProd α β/angbracketrightx = [(y1×y2,r2)|(y1,r1)←decodes/angbracketleftα/angbracketrightx,
(y2,r2)←decodes/angbracketleftβ/angbracketrightr1]
The function is a bit more involved than encode , because it has to deal with incor-
rect input, and it has to return the unconsumed part of the input. This is solved
using a standard list-of-successes parser type (Wadler 1985), where the input list
is transformed into a list of pairs, containing all possible parses with the associ-
ated unconsumed parts of the input. The decoding process in not ambiguous, so
only lists of zero (indicating failure) and one (indicating success) elements occur.
114
7.5 Extending the language
A value of type Unit is represented using no bits at all, therefore it can be
decoded without consuming any input. The case for Sum is the only place where
input is consumed (as it was the only case where output is produced in encode ),
and depending on the ﬁrst bit of the input, we produce an Inlor an Inr. A third
case lets the decoding process fail if we run out of input while decoding a sum.
The product ﬁrst decodes the left component, and then runs decodes for the right
component on the rest of the input.
7.5 Extending the language
From a user perspective, there are almost no changes needed to allow generic
functions: the syntax is unchanged, and so are the kind and type checking rules.
The only thing that we have to assume is that Unit, Sum, and Prod are in the
environments, together with their constructors.
What needs to be modiﬁed, though, is the translation: for datatypes, a structural
representation is generated, replacing the toplevel structure of a datatype by a type
expression constructed from the Unit, Sum, and Prod types. This is what makes
it possible to reduce such a large class of types to these three datatypes.
Next to that, the translation of type-indexed functions needs to be modiﬁed.
So far, we have generated components for the types in the signature of a generic
function. Now, we have to generate additional components for datatypes that
do not occur in the signature, but appear in the type arguments of calls to a
generic function. The specialization mechanism has to be adapted to record the
components that are required.
We will sketch the changes in the following, and treat them in detail in Chap-
ters 10 and 11.
7.5.1 Structural representation of datatypes
Each datatype consists of multiple constructors, and each of the constructors has
a number of ﬁelds. Constructors represent choice: a value can be constructed by
means of one constructor or another, but not by both. The ﬁelds of a constructor
represent pairing: the ﬁelds translate to arguments of the constructor, and if a
constructor has nﬁelds, then it could also be written as having one n-tuple as
argument, or, isomorphically, a nested pair of in total ncomponents.
The idea of the translation of datatypes is thus: replace the choice between the
constructors by a nested application of Sum, and for each constructor, replace the
sequence of ﬁelds by a nested application of Prod. Only if a constructor is nullary,
the type Unit is used instead of the product. The ﬁelds of the constructors are not
translated.
115
7 Going Generic
An example: the datatype of binary trees was deﬁned as
data Tree (a::∗) =Leaf|Node (Tree a)a(Tree a).
The translated datatype, which we will call Str(Tree ), is the type synonym
type Str(Tree ) (a::∗) =Sum Unit (Prod (Tree a) (Prod a(Tree a))).
The function Stris similar to the function cpthat we already know: it constructs
fresh names from existing names. In this case, Strtakes a type name, such as Tree,
and yields a new type name, for the structural representation.
The choice between the two constructors of Tree is represented by an applica-
tion of Sum in Str(Tree ). The ﬁrst constructor, Leaf, has no ﬁelds. Therefore, its
representation is Unit. We apply Prod twice, nested, to translate the three ﬁelds
of the second constructor Node . The ﬁelds itself occur again in the representation
type, as does the type parameter aof Tree. In fact, if a type Tis of kind κ, then
Str(T)is of kind κas well.
It may be surprising that the structural representation Str(Tree )still refers to
the original type Tree. The structural representation is only for the toplevel of
a datatype. All ﬁelds of all constructors, thus including recursive calls to the
original datatype, appear in the representation type without modiﬁcation. This
one-layer translation turns out to be sufﬁcient for our purposes, and it prevents
problems with recursive type synonyms or inﬁnite types.
A type and its structural representation are always isomorphic (if we ignore
undeﬁned values). The isomorphism is witnessed by a so-called embedding-
projection pair , i.e., a value of the datatype
data EP(a::∗) (b::∗) =EP(a→b) (b→a).
IfTand Str(T)are indeed isomorphic, and Tis of kind{κi→}i∈1..n∗, then there
exists a value
ep(T)::{∀ai::κi.}i∈1..nEP(T{ai}i∈1..n) (Str(T){ai}i∈1..n)
with ep(T) =EP from to such that
from·to≡id::{∀ai::κi.}i∈1..nStr(T){ai}i∈1..n→Str(T){ai}i∈1..n
to·from≡id::{∀ai::κi.}i∈1..nT{ai}i∈1..n→T{ai}i∈1..n.
The function epconstructs again a new name, this time a function name (the
name of the embedding-projection pair) from a type name.
In the case of our example, for the type Tree, the embedding-projection pair
witnessing the isomorphism can be deﬁned as follows:
116
7.5 Extending the language
ep(Tree )::∀a::∗. EP (Tree a) (Str(Tree )a)
ep(Tree ) =letfromTree Leaf =Inl Unit
fromTree (Node/lscriptx r) = Inr(/lscript×(x×r))
toTree (Inl Unit ) = Leaf
toTree (Inr(/lscript×(x×r))) = Node/lscriptx r
inEP fromTree toTree .
In Chapter 10, we will formally deﬁne the translation of a type to its structural
representation, together with the generation of a suitable embedding-projection
pair. We will see that the embedding-projection pair consists of isomorphisms
between the two types.
7.5.2 Specialization to datatypes not in the signature
In Chapter 6, we have established that a generic application to a type argument
that is the application of two types is translated via
/llbracketx/angbracketleftt1t2/angbracketright/rrbrackettif≡/llbracketx/angbracketleftt1α/angbracketright/rrbrackettif/braceleftbig
/llbracketyi/angbracketleftt2/angbracketright/rrbrackettif/bracerightbigi∈1..k,
where{yi}i∈1..kare the dependencies of function x.
On the other hand, if the type argument is a named type (possibly followed by
dependency variables to make it kind correct), then
/llbracketx/angbracketleftT{αi}i∈1..n/angbracketright/rrbrackettif≡cp(x,T).
For this translation to be possible, Tmust be in the signature of x. We will
not change the translation, but lift the restriction: in the presence of structural
representations of the datatypes, we can generate additional components, beyond
the ones in the signature of a function, upon demand.
At the deﬁnition site of a generic function, we will thus statically locate all the
uses of the function to determine which types occur in the type arguments of
that function. If any of these types do not occur in the signature of the function,
the compiler will try to generate a component. This is possible if the type is
not abstract, i.e., if its deﬁnition and thus a structural representation is available.
The deﬁnition of the type may contain other types, so this process may need to
be recursively applied. Only if we run into an abstract type that is not in the
signature, a specialization error is reported – but that should happen far less
frequently than before we had generic functions.
We will now sketch how to generate a component cp(encode , Tree )(for function
encode deﬁned on page 114). Before we can deﬁne this component, we must make
a detour: the structural representation of Tree tis
117
7 Going Generic
Sum Unit (Prod (Tree t) (Prod t(Tree t))),
and for the moment let us assume that
encode/angbracketleftBig
Sum Unit/parenleftBig
Prod (Tree α)/parenleftbig
Prod α(Tree α)/parenrightbig/parenrightBig/angbracketrightBig
is the call that needs to be translated. According to the rules that we know
so far, and assuming that several components are in scope, the corresponding
translation is
λcp(encode ,α)→
cp(encode , Sum )
cp(encode , Unit )/parenleftbigg
cp(encode , Prod )
/parenleftbig
cp(encode , Tree )cp(encode ,α)/parenrightbig
/parenleftBig
cp(encode , Prod )cp(encode ,α)
/parenleftbig
cp(encode , Tree )cp(encode ,α)/parenrightbig/parenrightBig/parenrightbigg
.
The type argument involves a dependency variable α, and encode depends on
itself, hence the translation depends on the explicit argument that we choose to
call cp(encode ,α), accordingly. (The translation would have a different shape for
a function such as equal , which has two dependencies.) The form of the type
expression is reﬂected on the value level in the translation: the application of
types has been replaced by application of components. We will name the above
translation cp(encode ,Str(Tree )).
Note that cp(encode ,Str(Tree ))still depends on cp(encode , Tree ). Given the dec-
laration of cp(encode ,Str(Tree )), however, it is not difﬁcult to come up with an
implementation of cp(encode , Tree ). After all, we have ep(Tree )available to con-
vert between original type and its structural representation. Let us assume that
from and toare functions deﬁned as follows:
from (EP x y ) =x
to (EP x y ) =y.
We can then informally write
encode/angbracketleftTree α/angbracketrightx=encode/angbracketleftStr(Tree )α/angbracketright/parenleftbig
from ep(Tree )x/parenrightbig
which, as component, gives
118
7.5 Extending the language
cp(encode , Tree ) =λcp(encode ,α)→λx→
cp(encode ,Str(Tree ))cp(encode ,α)/parenleftbig
from ep(Tree )x/parenrightbig
.
The two functions cp(encode , Tree )and cp(encode ,Str(Tree ))are mutually recur-
sive, but if deﬁned together in one recursive let, they do the job. Using partial
application in a cunning way, one can see that the deﬁnition we have given for
encode/angbracketleftTree α/angbracketrightis equivalent to what one would write by hand:
encode/angbracketleftTree α/angbracketrightLeaf =0
encode/angbracketleftTree α/angbracketright(Node/lscriptx r) =
1:(encode/angbracketleftTree α/angbracketright/lscript+ +encode/angbracketleftα/angbracketrightx+ +encode/angbracketleftTree α/angbracketrightr).
The fact that we had to apply the from function once in the deﬁnition of the
component cp(encode , Tree )to convert from trees to their structural representa-
tions is connected to the base type of encode , which is a→[Bit]. The type ar-
gument aappears once as an argument in the function. If the type would be
different, the conversion would need to be different. For instance, the base type
ofaddisa→a→a. Next to the two arguments, that need to be converted via
from, also the result is of the argument type. The component for the structural
representation of Tree,
cp(add,Str(Tree )) =
λcp(add,α)→
cp(add, Sum )
cp(add, Unit )/parenleftbigg
cp(add, Prod )/parenleftbig
cp(add, Tree )cp(add,α)/parenrightbig
/parenleftBig
cp(add, Prod )cp(add,α)
/parenleftbig
cp(add, Tree )cp(add,α)/parenrightbig/parenrightBig/parenrightbigg
,
has the same shape as before cp(encode ,Str(Tree )), because add, asencode , depends
on only on itself. But the type of the component is
∀a::∗.(a→a→a)→Str(Tree )a→Str(Tree )a→Str(Tree )a.
In consequence, while deﬁning cp(add, Tree ), we not only have to convert the two
incoming trees to type Str(Tree ), but also the result back to the original Tree type:
cp(add, Tree ) =λcp(add,α)→λx→λy→
toep(Tree )
119
7 Going Generic
/parenleftBig
cp(add,Str(Tree ))cp(add,α)
/parenleftbig
from ep(Tree )x/parenrightbig /parenleftbig
from ep(Tree )y/parenrightbig/parenrightBig
.
If the base type of a generic function is more complicated, the conversion required
is more involved as well.
The whole process of generating components, together with the required gen-
eration of conversions between types and their structural representations, is the
topic of Chapter 11.
120
8 Local Redeﬁnition
In Chapter 6, we have introduced dependencies and dependency constraints.
A type-indexed function can depend on other type-indexed functions. Depen-
dencies are caused whenever one type-indexed function is called within another,
with a variable type argument.
Internally, dependency constraints can be seen as hidden arguments that are
made explicit by the translation. Seen in this light, dependencies play a role in
two situations: during the deﬁnition of a type-indexed function, where calls to
dependent functions translate into lambda abstractions that need to be supplied
by the compiler whenever the component is called; and during the call of generic
functions, where an application in the type argument is translated into an ap-
plication of components, where the arguments required are determined by the
dependencies of the function that is called.
Dependency constraints are recorded on the type level. The type checking rules
of Chapter 6 make use of an environment ∆to store dependency constraints,
and this environment is only modiﬁed in the arm of a generic function, where
the dependencies of the generic function are added while checking the arm, and
during applications of generic functions, where the entries in ∆are used to supply
the arguments needed in the call.
121
8 Local Redeﬁnition
In this chapter, we will give the programmer more control over ∆: we make it
possible to locally extend or redeﬁne the dependency environment. Dependen-
cies are like class (Wadler and Blott 1989; Jones 1994) dictionaries: they explain
how to perform a generic operation on a speciﬁc datatype. By giving the user
access to the environment that stores the dictionaries, the behaviour of a generic
function can be changed or extended depending on the location in the program.
What this means and why it is useful is best shown by example, therefore the
next sections will demonstrate different applications of the feature. Afterwards,
we provide the necessary extensions to the language in Section 8.5.
8.1 Enhanced equality
For some datatypes, there are different ways to determine equality, or even dif-
ferent notions of equality. For lists, we can compare the lengths of the lists ﬁrst
and only then check the elements, and thereby save a lot of work in cases where
we have to compare lists of which the preﬁxes are frequently identical. Other
datatypes may have an amount of redundancy encoded, that is superﬂuous to
compare or even should be ignored. For strings, which are lists of characters in
Haskell, we may have applications for which it is irrelevant if something is writ-
ten in upper- or lowercase letters or any mixture thereof. The string "laMBdA"
might be considered equal to "Lambda" in some situations, but not in others.
The ﬁrst two example cases are easy to solve with generic functions: if we
decide that we want to check the length when testing lists for equality, then we
must make sure that the deﬁnition of equal (the original deﬁnition is on page 112)
has a speciﬁc case for the list type constructor [ ]that instructs the compiler to
do so. The generic functionality for other datatypes is not compromised by this
speciﬁc case. Similarly, if special equality algorithms are required for speciﬁc
datatypes, they should also be included in the deﬁnition of the generic equal
deﬁnition. More problematic is the latter case: we have some situations in which
we want to compare case-insensitively, and others in which case-sensitivity is
desired.
One solution is to deﬁne two functions, equal and equalCaseInsensitive , where
the former compares strictly, and the latter ignores the case for strings. Both
deﬁnitions look the same, except for the case on characters. There are a couple of
disadvantages to this approach.
First, it is a lot of work. This problem can be alleviated, which is exactly what
default cases are for (cf. Chapter 14).
Second, we might need a lot of different equality functions. If there are two
ways to compare characters and two ways to compare ﬂoats, then there are al-
ready at least four ways to compare data structures containing ﬂoats and charac-
122
8.1 Enhanced equality
ters. In other words, the number of function deﬁnitions required grows exponen-
tially with the number of different possibilities for equality (although certainly
not all possibilities are used).
Third, at deﬁnition time of the generic function it may not be obvious which
alternative notions of equality will be required somewhere in the program. Even a
good library writer cannot possibly foresee all application areas where his library
will ever be put to use, but would nevertheless like to spare the programmer the
burden of deﬁning his own generic functions.
Fourth, if there are different generic functions for the different types of equality,
then there is no pragmatic way to combine them: say that only some of the strings
in a data structure should be compared case-insensitively, whereas the others
should be tested for standard equality. This is not possible without deﬁning
yet another generic function, thereby partially defeating the whole purpose of
generic programming.
A case-insensitive equality test for characters can easily be implemented in
Haskell as a monomorphic function
equalCaseInsensitive x y =toUpper x ==toUpper y .
Whereas we usually would compare the strings "laMBdA" and "Lambda" using
the generic call
equal/angbracketleft[Char ]/angbracketright"laMBdA" "Lambda" ,
which would result in False , we are now going to locally redeﬁne the equality
function by marking the position which is to be redeﬁned with a dependency
variable:
equal/angbracketleft[α]/angbracketright"laMBdA" "Lambda" .
This call, on its own, is type incorrect, because it has unsatisﬁed dependencies
(the dependency environment under which a complete program is checked is
empty and is only ﬁlled for the right hand sides of typecase arms). It could be
assigned the qualiﬁed type
(enum/angbracketleft[α]/angbracketright::[Char ],equal/angbracketleft[α]/angbracketright:: Char→Char→Bool )⇒Bool ,
if we would allow qualiﬁed types to be assigned to simple expressions. The two
dependencies to enum (deﬁned on page 111) and equal stem from the fact that
the function equal , as we have deﬁned it on page 112, depends on both enum and
equal .
123
8 Local Redeﬁnition
Local redeﬁnition allows us to locally ﬁll in these dependencies:
letequal/angbracketleftα/angbracketright=equalCaseInsensitive
enum/angbracketleftα/angbracketright=enum/angbracketleftChar/angbracketright
inequal/angbracketleft[α]/angbracketright"laMBdA" "Lambda" .
This expression is of type Bool, without open dependencies, and it evaluates to
True. The function enum does not actually play a role, so it is safest to fall back to
the default behaviour for characters.
It is important to realize that dependency variables are not instantiated by one
concrete type, such as ordinary type variables usually are. Instead, we locally
name the element type of lists with dependency variable α, and we describe how
elements that occur at the position named αcan be tested for equality or enu-
merated. But αcould not simply be instantiated to Char. The call equal/angbracketleft[Char ]/angbracketright
always refers to the original deﬁnition of equal for lists on characters, and cannot
be modiﬁed by redeﬁnition. The expression
letequal/angbracketleftα/angbracketright=equalCaseInsensitive
enum/angbracketleftα/angbracketright=enum/angbracketleftChar/angbracketright
inequal/angbracketleft([α],[Char ])/angbracketright("laMBdA" ,"laMBdA" ) ("Lambda" ,"Lambda" )
evaluates to False : the characters in the ﬁrst components are compared using
equalCaseInsensitive yielding True for this part of the equality test, but the elements
in the second components are compared using the standard equality for type
Char and are unaffected by the local redeﬁnition, thus resulting in False for the
total computation.
On the other hand, one redeﬁnition can be used for a larger part of program
text, involving multiple calls to generic functions. The next section contains an
example of such a call.
Local redeﬁnition is very similar to the binding of implicit parameters (Lewis
et al. 2000).
8.2 Size of data structures
We will now write a truly generic sizefunction, to determine the number of
elements in a data structure. This deﬁnition replaces the old sizefunction from
page 53 that works only for a limited number of datatypes.
size/angbracketlefta::∗/angbracketright ::(size)⇒a→Int
size/angbracketleftInt/angbracketright x =0
size/angbracketleftChar/angbracketright x =0
124
8.2 Size of data structures
size/angbracketleftFloat/angbracketright x =0
size/angbracketleftUnit/angbracketright Unit =0
size/angbracketleftSum α β/angbracketright(Inl x ) = size/angbracketleftα/angbracketrightx
size/angbracketleftSum α β/angbracketright(Inr x ) = size/angbracketleftβ/angbracketrightx
size/angbracketleftProd α β/angbracketright(x×y) =size/angbracketleftα/angbracketrightx+size/angbracketleftβ/angbracketrighty.
Deﬁned like this, the sizefunction seems quite a disappointment: it returns 0 on
all datatypes. With local redeﬁnition, though, we can make it useful: the code
fragment
letsize/angbracketleftα/angbracketright=const 1
insize/angbracketleft[α]/angbracketright
is an expression of type ∀a::∗.[a]→Int and evaluates to the length of a list. We
explicitly state what to count – in this case, the elements of the list. It is possible
to draw a clear boundary between shape and content (Jay et al. 1998) by placing
theαwith care. The following expression demonstrates four different ways to
calculate the size of a list of lists:
letsize/angbracketleftα/angbracketright=const 1
in(size/angbracketleft[[Int]]/angbracketright[[1, 2, 3 ],[4, 5]],
size/angbracketleft[[α]]/angbracketright[[1, 2, 3 ],[4, 5]],
size/angbracketleft[α]/angbracketright [[1, 2, 3 ],[4, 5]],
size/angbracketleftα/angbracketright [[1, 2, 3 ],[4, 5]]).
The above expression evaluates to
(0, 5, 2, 1 ).
The ﬁrst call treats the list of lists as a constant value, therefore its size is 0.
The second call treats the argument as a list of lists, and thus counts all integer
elements, of which there are ﬁve. The third call views the argument as a list,
which has two lists as elements, therefore the result 2. Finally, the last call treats
its entire argument as an element of the structure, resulting in 1 as an answer.
The example shows that it is not just a burden, but can be really useful that
we are able to specify the type arguments to type-indexed and generic functions
explicitly. The four calls to sizeare identical but for the type arguments involved
– yet they produce four different results. This is an important observation when
we discuss type inference of type arguments, in Section 13.1.
The example above demonstrates also that local redeﬁnition via a let statement
does not have to surround a call to a type-indexed function tightly, but may scope
over a larger program fragment, as long as the type of the dependency provided
ﬁts everywhere where it is required.
125
8 Local Redeﬁnition
Multiple dependency variables can be used in one type argument, and the
same dependency variable may occur more than once in a type argument: the
expression
letsize/angbracketleftα/angbracketright=const 1
size/angbracketleftβ/angbracketright=const 0
insize/angbracketleft[Either (α,α)β]/angbracketright
[Left(1, 2),Right (+),Left(2, 4),Right (λx y→0)]
evaluates to 4, because each of the two pairs counts as 2, whereas the functions
are ignored. The redeﬁnition for βcauses sizeto work on function types, which
it normally does not.
If a redeﬁnition is sufﬁciently polymorphic, it is possible to use the function at
different types in different calls: the fragment
letsize/angbracketleftα/angbracketright=const 1
in(size/angbracketleft[α]/angbracketright[1, 2, 3 ],size/angbracketleft[α]/angbracketright["foo" ,"bar" ])
is a valid expression that evaluates to (3, 2).
8.3 Short notation
Very frequently, a type-indexed function depends only on one function (usually
itself). In this case, the syntax for local redeﬁnition is unnecessarily verbose. It
requires to write the name of the dependency which should be redeﬁned, but if
there is only one, there is not much of a choice.
/llbracketefcr+tif+par::tfcr+tif+par/rrbracketpar
K;Γ;∆;Σ≡efcr
K/turnstileleftA::κ1→κ2 dependenciesΓ(x)≡y
gappK;Γ(x/angbracketleftA/angbracketright)≡q /llbracketx/angbracketleftA/angbracketright/rrbracketgtrans
K;Γ;Σ≡e
K;∆/turnstileleftq/lessorequalslantt
/llbracketx/angbracketleftA/angbracketright::t/rrbracketpar
K;Γ;∆;Σ≡e(e/tr-genapp-short)
Figure 8.1: Short notation for local redeﬁnition
126
8.3 Short notation
In this situation, we allow the type argument to the type-indexed function to
be of higher kind. The local redeﬁnition can then be passed as an ordinary,
positional function argument.
A call such as
letsize/angbracketleftα/angbracketright=const 1insize/angbracketleft[α]/angbracketright
can be abbreviated to
size/angbracketleft[ ]/angbracketright(const 1),
and
letsize/angbracketleftα/angbracketright=const 1
size/angbracketleftβ/angbracketright=id
insize/angbracketleftEither α β/angbracketright
becomes alternatively
size/angbracketleftEither/angbracketright(const 1)id.
Nevertheless, the explicit notation is more expressive. Local redeﬁnitions around
type-indexed function calls such as size/angbracketleftEither α α/angbracketrightorsize/angbracketleft[[α]]/angbracketrightcannot easily
be written using short notation.
Short notation can be deﬁned by adding a variant of rule (e/tr-genapp) (cf. Fig-
ure 6.13) to the translation from fcr+tif+par to fcrthat we have deﬁned in Sec-
tion 6.4. The original rule,
K/turnstileleftA::∗
gappK;Γ(x/angbracketleftA/angbracketright)≡q /llbracketx/angbracketleftA/angbracketright/rrbracketgtrans
K;Γ;Σ≡e
K;∆/turnstileleftq/lessorequalslantt
/llbracketx/angbracketleftA/angbracketright::t/rrbracketpar
K;Γ;∆;Σ≡e(e/tr-genapp) ,
restricts the type argument Ato kind∗. However, we have deﬁned both gapp and
/llbracket·/rrbracketgtransin such a way that they accept type arguments of higher kind. The reason
why we have disallowed such arguments in (e/tr-genapp) is that the type of such
a call is a function that expects arguments for all the dependencies of the type-
indexed function x. If there is more than one function, then the order in which
the arguments are expected depends on the internal ordering of the dependency
constraints (we suggested lexical ordering, but this is essentially irrelevant as
long as there is a well-deﬁned ordering). However, as we have noticed before,
there is no possibility for confusion if xhas only one dependency. Therefore, we
add a different rule, (e/tr-genapp-short), in Figure 8.1. The only difference to
127
8 Local Redeﬁnition
/llbrackete1/rrbracketshort
K;Γ≡e2
K/turnstileleftA::κ1→κ2 dependenciesΓ(x)≡y
κ1≡{κ/prime
i→}i∈1..n∗
αfresh{γifresh}i∈1..n
dependenciesΓ(y)≡{y}k∈1../lscript/lscript∈0 . . 1
/llbracketx/angbracketleftA/angbracketright/rrbracketshort
K;Γ≡λz→lety/angbracketleftα{(γi::κ/prime
i)}i∈1..n/angbracketright=
z/braceleftbig{/llbrackety/angbracketleftγi/angbracketright/rrbracketshort
K,γi::κ/prime
i;Γ}k∈1../lscript/bracerightbigi∈1..n
in/llbracketx/angbracketleftAα/angbracketright/rrbracketshort
K,α::κ1;Γ)(short)
Figure 8.2: Alternative deﬁnition of short notation
the original rule is in the preconditions: we require the type argument to be of
functional kind, and the type-indexed function that is called to have exactly one
dependency. The translation is the same as before.
The correctness of the translation follows directly from Theorem 6.5, where we
already have proved the more general case that the type argument may be of
arbitrary kind.
Instead of deﬁning short notation directly via extension of the translation, we
could also deﬁne it as syntactic sugar for let-based local redeﬁnition. We show
this alternative deﬁnition, which makes use of a judgment of the form
/llbrackete1/rrbracketshort
K;Γ≡e2,
in Figure 8.2. The judgment states that the result of translating e1under environ-
ments K and Γis the expression e2.
The only rule (short) is applicable under the condition that xhas precisely
one dependency, named y. The type argument Ahas to be of functional kind
κ1→κ2. We introduce a fresh dependency variable α, supposed to be of kind κ1.
Depending on the arity of kind κ1, we also introduce fresh γi, to serve as local
arguments for α.
The translation result is a function that takes a positional argument zin place
of the local redeﬁnition. The result of the function is a let statement surrounding
the recursive call /llbracketx/angbracketleftAα/angbracketright/rrbracketshort. This call depends on y/angbracketleftα{γi}i∈1..n/angbracketright, which is
deﬁned in the let statement to be of the form
z/braceleftbig{/llbrackety/angbracketleftγi/angbracketright/rrbracketshort
K,γi::κ/prime
i;Γ}k∈1../lscript/bracerightbigi∈1..n.
128
8.4 Local redeﬁnition within type-indexed functions
This might seem more complex than expected: the function ycan have no de-
pendencies or one, but if it has one, that dependency is yagain (because the
dependency relation is transitive). If αis of higher kind, the function zmay de-
pend on yfor all the γi, and is therefore supposed to be a function that takes
these dependencies as explicit arguments, using short notation recursively. If αis
of kind∗, oryhas no dependencies, then ztakes no dependency arguments.
8.4 Local redeﬁnition within type-indexed functions
The possibility for local redeﬁnition is not just a useful addition to the language,
but it can be absolutely necessary to have it even to deﬁne a type-indexed func-
tion.
Consider the datatype for ﬁxpoints of functors, given by
data Fix(a::∗→∗ ) =In(a(Fixa)).
Using Fix, one can write recursive types in a way that makes the places of the
recursion explicit. For instance, the type Fix NatF, with
data NatF (a::∗) =ZeroF|SuccF a ,
is isomorphic to the type
data Nat =Zero|Succ Nat
of natural numbers, via
natf tonat(In ZeroF ) = Zero
natf tonat(In(SuccF a )) = Succ (natf tonat a )
nattonatf Zero =In ZeroF
nattonatf (Succ a ) = In(SuccF (nattonatf a )).
The ﬁxpoint view of a datatype has the advantage that operations that work with
the recursive structure, such as cata- and anamorphisms, can be deﬁned easily.
Fixpoints will therefore be our topic again later, in Section 12.3 and Section 17.2.
Fortunately, in most cases, we do not have to care how a generic function can
be deﬁned for datatypes such as Fix. The function is generic, and the compiler
derives the deﬁnition of a call such as equal/angbracketleftFix NatF/angbracketrightautomatically. We could
also deﬁne it ourselves:
equal/angbracketleftFixα/angbracketright(In x) (In y) =equal/angbracketleftα(Fixα)/angbracketrightx y.
129
8 Local Redeﬁnition
But what if we want to change this deﬁnition, and do something out of the ordi-
nary? We might only be interested in equality at the top level of a datatype, and
want to stop comparing once we hit a point of recursion. We can only do this
using local redeﬁnition:
equal/angbracketleftFixα/angbracketright(In x) (In y) =letequal/angbracketleftβ/angbracketrightx y=True
enum/angbracketleftβ/angbracketright =enum/angbracketleftFixα/angbracketright
inequal/angbracketleftα β/angbracketright.
A similar situation arises whenever we want to deﬁne a type-indexed function
explicitly for a type constructor which takes arguments of higher kind.
8.5 Core language with local redeﬁnition
fcr+tif+par+lr
The language extension that is needed to support local redeﬁnition is relatively
simple. We extend the syntax for value declarations with one additional case, as
shown in Figure 8.3.
Value declarations
d::=. . . everything from Figure 4.1
|x/angbracketleftα{(γi::κi)}i∈1..n/angbracketright=e
local redeﬁnition
Figure 8.3: Core language with local redeﬁnition fcr+tif+par+lr, extends language
fcr+tif+par in Figures 6.1, 4.1, and 3.1
We then need a new declaration translation rule, along the lines of the rules
of Figure 6.15. Since local redeﬁnition affects the dependency and kind environ-
ments, we have to extend the form of the judgment to be able to redeﬁne these
two environments:
/llbracketdfcr+tif+par+lr/squigglerightK2;Γ2;∆2;Σ2/rrbracketpar
K1;Γ1;∆1;Σ1≡{dfcr}i∈1..n
; .
The environments K 2and∆2have been added. The rule for recursive let, (e/tr-
let), is adapted to tie the knot for these environments as it already did for Γand
Σ. The updated rule is shown in Figure 8.4.
The translation of a local redeﬁnition declaration is described in Figure 8.5.
We only allow local redeﬁnition for a type-indexed function xthat is in scope.
Based on the kinds of the local arguments γi, we determine the kind κofα.
130
8.5 Core language with local redeﬁnition fcr+tif+par+lr
/llbracketefcr+tif+par+lr::tfcr+tif+par+lr/rrbracketpar
K;Γ;∆;Σ≡efcr
K/prime≡K{, Ki}i∈1..nΓ/prime≡Γ{,Γi}i∈1..n
∆/prime≡∆{,∆i}i∈1..nΣ/prime≡Σ{,Σi}i∈1..n
/braceleftbig
/llbracketdi/squigglerightKi;Γi;∆i;Σi/rrbracketpar
K/prime;Γ/prime;∆/prime;Σ/prime≡{di,j}j∈1..mi/bracerightbigi∈1..n
/llbrackete::t/rrbracketpar
K/prime;Γ/prime;∆/prime;Σ/prime≡e/prime
/llbracketlet{di}i∈1..n
; ine::t/rrbracketpar
K;Γ;∆;Σ≡let/braceleftbig{di,j}j∈1..mi;/bracerightbigi∈1..n
;ine/prime(e/tr-let-lr)
Figure 8.4: New rule for checking and translating recursive let in fcr+tif+par+lr, replaces
rule (e/tr-let) in Figure 6.13
/llbracketdfcr+tif+par+lr/squigglerightK2;Γ2;∆2;Σ2/rrbracketpar
K1;Γ1;∆1;Σ1≡{dfcr}i∈1..n
;
x/angbracketlefta::∗/angbracketright::σ∈Γ
κ≡{κi→}i∈1..n∗
K/prime≡K{,γi::κi}i∈1..n
/llbrackete::q/rrbracketpar
K/prime;Γ;∆;Σ≡e/prime
∆/prime≡x/angbracketleftα{(γi::κi)}i∈1..n/angbracketright::q/largellbracket
x/angbracketleftα{(γi::κi)}i∈1..n/angbracketright=e/squigglerightα::κ;ε;∆/prime;ε/largerrbracketpar
K;Γ;∆;Σ≡cp(x,α) =e/prime(d/tr-lr)
Figure 8.5: Translation of fcr+tif+par+lr declarations to fcr, extends Figure 6.15
131
8 Local Redeﬁnition
The dependency variable αis visible in the scope of the let that contains the local
redeﬁnition, therefore the new kind binding α::κis also exported. The right hand
side expression eis checked to be of a qualiﬁed type q, and this type is added as
type of the dependency constraint for x/angbracketleftα{γi::κi}i∈1..n/angbracketright. The translation of the
declaration is consequently a declaration for cp(x,α).
It is noteworthy that we do not make use of the type of xwhile checking the
declaration. Restrictions on the type are only imposed by the usages of xin
the scope of the let that contains the local redeﬁnition. In other words, if the
body of that let statements does not depend on x/angbracketleftα{γi::κi}i∈1..n/angbracketright, there are no
restrictions on the type of the right hand side. For instance, the expression
letsize/angbracketleftα/angbracketright="foo"
in1
is legal and evaluates to 1.
132
9Types of
Type-indexed Functions
We have imposed relatively strict conditions on the types of type-indexed func-
tions. While a large class of type-indexed and generic functions can be written
within these limits, some other – very useful – functions cannot.
Luckily for the programmer, it is not a big step to surpass these limits and
write functions such as map,zipWith , and concat , all of which will be introduced
throughout the next few sections.
After the examples, we will have a look at the implications for the theory of
dependencies and qualiﬁed types, which becomes considerably more complex
due to the additional generality.
9.1 Identity and mapping
Let us look at the generic identity function gid, which can be deﬁned as follows:
gid/angbracketlefta::∗/angbracketright ::(gid)⇒a→a
gid/angbracketleftInt/angbracketright x =x
133
9 Types of Type-indexed Functions
gid/angbracketleftChar/angbracketright x =x
gid/angbracketleftFloat/angbracketright x =x
gid/angbracketleftUnit/angbracketright x =x
gid/angbracketleftSum α β/angbracketright(Inl x ) = Inl(gid/angbracketleftα/angbracketrightx)
gid/angbracketleftSum α β/angbracketright(Inr x ) = Inr(gid/angbracketleftβ/angbracketrightx)
gid/angbracketleftProd α β/angbracketright(x×y) =gid/angbracketleftα/angbracketrightx×gid/angbracketleftβ/angbracketrighty.
Note that we have made a choice in the above deﬁnition: the deﬁnition is writ-
ten recursively, applying the generic identity deeply to all parts of a value. We
could have written the following instead of the last three lines, removing the
dependency of gidon itself:
gid/angbracketleftSum α β/angbracketrightx=x
gid/angbracketleftProd α β/angbracketrightx=x.
But retaining the dependency and applying the function recursively has an ad-
vantage: local redeﬁnition (cf. Chapter 8) can be used to change the behaviour of
the function!
As an example, we could increase all elements of a list by one, using the func-
tion
incBy1 x =letgid/angbracketleftα/angbracketright= (+ 1)ingid/angbracketleft[α]/angbracketrightx.
Note that this is something that would normally be written as an application of
map:
incBy1 x =map (+1)x.
If we compare map with the locally redeﬁned version of gid, then two differ-
ences spring to mind. First, the function map can only be used on lists, whereas
gidcan be used on other data structures as well. Second, map has a more liberal
type. If we deﬁne
map/primef=letgid/angbracketleftα/angbracketright=fingid/angbracketleft[α]/angbracketright,
then we can observe that map/prime, compared to map has a restricted type:
map/prime::∀a::∗. (a→a)→[a]→[a]
map ::∀(a::∗) (b::∗).(a→b)→[a]→[b].
The function passed to map may change the type of its argument; the function
passed to map/primemust preserve the argument type.
Inspired by this deﬁciency, we can ask ourselves if it would not be possible
to also pass a function of type a→bwhile locally redeﬁning gid. The function
gid/angbracketleft[α]/angbracketrighthas the qualiﬁed type
134
9.1 Identity and mapping
gid/angbracketleft[α]/angbracketright::∀a::∗. (gid/angbracketleftα/angbracketright::a→a)⇒[a]→[a],
but we are now going to generalize this type to
map/angbracketleft[α]/angbracketright::∀(a::∗) (b::∗).(map/angbracketleftα/angbracketright::a→b)⇒[a]→[b],
thereby renaming function gidto function map (but using exactly the same deﬁ-
nition). For this to work, map needs a different type signature:
map/angbracketlefta::∗,b::∗/angbracketright::(map/angbracketlefta,b/angbracketright)⇒a→b.
The function is now parametrized over twotype variables, and so is the depen-
dency. (We will discuss further extensions to the syntax of type signatures and
their exact meaning later in this chapter.) When used at a constant type, both
variables aand bare instantiated to the same type – only when locally redeﬁning
the function for a dependency variable, the additional ﬂexibility is available. We
will adapt the algorithm gapp from Figure 6.8 to handle type signatures such as
the one of map, and can then use this adapted algorithm to derive types for ap-
plications of map to speciﬁc type arguments. Some examples of such types are
shown in Figure 9.1. In all of the examples, the type argument Ais assumed not
to contain any free dependency variables.
map/angbracketleftA::∗/angbracketright :: A→A
map/angbracketleftA(α::∗)::∗/angbracketright ::∀(a1::∗) (a2::∗).
(map/angbracketleftα/angbracketright::a1→a2)
⇒A a1→A a2,
map/angbracketleftA(α::∗) (β::∗)::∗/angbracketright::∀(a1::∗) (a2::∗) (b1::∗) (b2::∗).
(map/angbracketleftα/angbracketright::a1→a2,
map/angbracketleftβ/angbracketright::b1→b2)
⇒A a1a2→A b1b2
map/angbracketleftA(α::∗→∗ )::∗/angbracketright ::∀(a1::∗→∗ ) (a2::∗→∗ ).
(map/angbracketleftα γ/angbracketright::∀(c1::∗) (c2::∗).
(map/angbracketleftγ/angbracketright::c1→c2)
⇒a1c1→a2c2)
⇒A a1→A a2.
Figure 9.1: Example types for generic applications of map to type arguments of different
form
Using the short notation of Section 8.3 can be a big help with map, as it allows
us to use map almost as the standard list map, only on far more datatypes. The
expressions
135
9 Types of Type-indexed Functions
map/angbracketleft[ ]/angbracketright (+1) [ 1, 2, 3, 4, 5 ]
map/angbracketleft(,)/angbracketright (∗2) ("y"+ +) ( 21,"es" )
map/angbracketleftEither/angbracketrightnot id (Left True )
evaluate to [2, 3, 4, 5, 6 ],(42,"yes" ), and Left False , respectively.
We will consider some more examples of generalized type signatures in the
next sections, before we discuss the (unfortunately) considerable theoretical im-
plications of this generalization in Section 9.6.
9.2 Zipping data structures
The Haskell standard prelude contains a list function zipWith of type
∀(a::∗) (b::∗) (c::∗).(a→b→c)→[a]→[b]→[c].
It takes a function to combine a value of type aand one of type binto a value
of type c, and uses this function to combine two lists of same length pointwise.
(In fact, it discards the extraneous elements of the longer list, but we will assume
that it should only work on lists of the same length.) The probably better known
function zipis an instance of zipWith :
zip::∀(a::∗) (b::∗).[a]→[b]→[(a,b)]
zip=zipWith (,).
We are going to generalize the function zipWith to a generic function in a very
similar way as we just have generalized the list function mapto a generic function.
The trick is once again to allow more than one type variable parameter in the
type signature: this time, we need even three type variables!
zipWith/angbracketlefta::∗,b::∗,c::∗/angbracketright ::(zipWith/angbracketlefta,b,c/angbracketright)⇒a→b→c
zipWith/angbracketleftInt/angbracketright x y
|x≡y =x
|otherwise =
error "args must have same shape!"
zipWith/angbracketleftUnit/angbracketright Unit Unit =Unit
zipWith/angbracketleftSum α β/angbracketright(Inl x ) ( Inl y ) = zipWith/angbracketleftα/angbracketrightx y
zipWith/angbracketleftSum α β/angbracketright(Inr x ) ( Inr y ) = zipWith/angbracketleftβ/angbracketrightx y
zipWith/angbracketleftSum α β/angbracketright =
error "args must have same shape!"
zipWith/angbracketleftProd α β/angbracketright(x1×x2) (y1×y2) =
zipWith/angbracketleftα/angbracketrightx1y1×zipWith/angbracketleftβ/angbracketrightx2y2
136
9.3 Generically collecting values
Applied to type arguments without dependency variables, the function is, much
asmap, almost useless: it tests whether two values are of the same shape. If they
are not, a runtime error is thrown.
But using local redeﬁnition, the functionality of the list function zipWith can be
recovered, but of course, we can zipnot only lists now: the expression
letzipWith/angbracketleftα/angbracketright= (+)
inzipWith/angbracketleftTree α/angbracketright(Node (Node Leaf 1Leaf)2Leaf)
(Node (Node Leaf 3Leaf)4Leaf)
evaluates to
Node (Node Leaf 4Leaf)6Leaf .
Figure 9.2 contains examples of types for a few speciﬁc applications of zipWith
to type arguments of different shape, corresponding to the types for map given in
Figure 9.1.
zipWith/angbracketleftA::∗/angbracketright :: A→A→A
zipWith/angbracketleftA(α::∗)::∗/angbracketright ::∀(a1::∗) (a2::∗) (a3::∗).
(zipWith/angbracketleftα/angbracketright::a1→a2→a3)
⇒A a1→A a2→A a3
zipWith/angbracketleftA(α::∗) (β::∗)::∗/angbracketright::∀(a1::∗) (a2::∗) (a3::∗)
(b1::∗) (b2::∗) (b3::∗).
(zipWith/angbracketleftα/angbracketright::a1→a2→a3,
zipWith/angbracketleftβ/angbracketright::b1→b2→b3)
⇒A a1b1→A a2b2→A a3b3
zipWith/angbracketleftA(α::∗→∗ )::∗/angbracketright ::∀(a1::∗→∗ ) (a2::∗→∗ ) (a3::∗→∗ ).
(zipWith/angbracketleftα γ/angbracketright::
∀(c1::∗) (c2::∗) (c3::∗).
(zipWith/angbracketleftγ/angbracketright::c1→c2→c3)
⇒a1c1→a2c2→a3c3)
⇒A a1→A a2→A a3.
Figure 9.2: Example types for generic applications of zipWith to type arguments of different
form
9.3 Generically collecting values
Let us look at another function that is only useful in the context of local redef-
inition, but also requires that we again introduce some new syntax for the type
137
9 Types of Type-indexed Functions
signatures of type-indexed functions. The generic function collect is supposed to
collect values from a data structure:
collect/angbracketlefta::∗|c::∗/angbracketright ::(collect/angbracketlefta|c/angbracketright)⇒a→[c]
collect/angbracketleftInt/angbracketright x = [ ]
collect/angbracketleftUnit/angbracketright Unit = [ ]
collect/angbracketleftSum α β/angbracketright(Inl x ) = collect/angbracketleftα/angbracketrightx
collect/angbracketleftSum α β/angbracketright(Inr x ) = collect/angbracketleftβ/angbracketrightx
collect/angbracketleftProd α β/angbracketright(x1×x2) =collect/angbracketleftα/angbracketrightx1+ +collect/angbracketleftβ/angbracketrightx2
We will discuss the type signature below, and ﬁrst discuss the implementation:
the function is deﬁned in a way that always returns the empty list on constant
type arguments. For kind ∗types such as Int or Unit, the empty list is returned
directly. In a sum, we descend to the branch that is selected by the argument. For
a product, we concatenate the resulting lists of the two components. The only
way to add content to the list is by local redeﬁnition.
The type signature of collect is interesting. Once more, the type is parametrized
over more than one type variable. However, the cis different from the type
parameters we have seen so far as it appears to the right of a vertical bar. The c
is called a non-generic type variable. Such non-generic variables appear in type-
indexed functions that are parametrically polymorphic with respect to some type
variables. The collect function is, as deﬁned, parametrically polymorphic in the
element type of its list result. It returns always the empty list, so there is no need,
but also no desire, to ﬁx the type of the list elements.
We can further specify this type as soon as we use collect in a local redeﬁni-
tion. Let us look at speciﬁc example cases for the type of collect again, presented
in Figure 9.3, to get an intuition about how the non-generic quantiﬁed variable
inﬂuences the type. As can easily be seen, the variable cis always quantiﬁed just
once, at the outside, and is used in all the dependency constraints (also nested
ones) without modiﬁcation.
As mentioned before, we can make use of collect through local redeﬁnition. For
example, the list function concat is
letcollect/angbracketleftα/angbracketrightx=xincollect/angbracketleft[α]/angbracketright,
whereas
letcollect/angbracketleftα/angbracketrightx= [x]incollect/angbracketleftTree α/angbracketright
computes the inorder traversal of a tree. But also other applications of collect are
possible: all negative list elements can be collected by
138
9.3 Generically collecting values
collect/angbracketleftA::∗/angbracketright::∀c::∗. A→[c]
collect/angbracketleftA/angbracketleftα::∗/angbracketright::∗/angbracketright
::∀(a::∗) (c::∗). (collect/angbracketleftα/angbracketright::a→[c])
⇒A a→[c]
collect/angbracketleftA/angbracketleftα::∗/angbracketright(β::∗)::∗/angbracketright
::∀(a::∗) (b::∗) (c::∗).(collect/angbracketleftα/angbracketright::a→[c],
collect/angbracketleftβ/angbracketright::b→[c])
⇒A a b→[c]
collect/angbracketleftA/angbracketleftα::∗→∗/angbracketright ::∗/angbracketright
::∀(a::∗→∗ ) (c::∗).(collect/angbracketleftα γ/angbracketright::
∀b::∗.(collect/angbracketleftγ/angbracketright::b→[c])
⇒a b→[c])
⇒A a→[c].
Figure 9.3: Example types for generic applications of collect to type arguments of different
form
letcollect/angbracketleftα/angbracketrightx|x<0 = [x]
|otherwise = [ ]
incollect/angbracketleft[α]/angbracketright.
At a ﬁrst glance, it might be unclear why we need to add the notion of non-
generic type parameters to our language. After all, the deﬁnition of collect as given
above would also type check with the following type signature
collect/angbracketlefta::∗/angbracketright::(collect/angbracketlefta/angbracketright)⇒∀c::∗.a→[c].
Here, there is only one type parameter, and the cis quantiﬁed on the right hand
side. But although the deﬁnition is still correct with respect to this type signature,
the resulting function cannot be used as before in the context of local redeﬁnition.
If we expand this internally quantiﬁed type for collect/angbracketleft[α]/angbracketright, we get
∀a::∗.(collect/angbracketleftα/angbracketright::∀c::∗.a→[c])⇒∀c::∗.[a]→[c].
If the dependency constraint itself is universally quantiﬁed, then we can only
redeﬁne the dependency to a sufﬁciently polymorphic function. The concat deﬁ-
nition,
letcollect/angbracketleftα/angbracketrightx=xincollect/angbracketleft[α]/angbracketright,
would fail because λx→xis of type∀c::∗.c→c, which does not match
∀c::∗.a→[c]. We are forced to redeﬁne collect in a way that it still returns a
polymorphic list, i.e., it must still return the empty list . . .
139
9 Types of Type-indexed Functions
With the original and correct type for collect , we have
∀(a::∗) (c::∗).(collect/angbracketleftα/angbracketright::a→[c])⇒[a]→[c]
as type for collect/angbracketleft[α]/angbracketright, and here ccan be instantiated to be the same as a.
9.4 More choice
The generalizations of the type signatures of type-indexed functions that we have
introduced in this chapter so far lead to additional complexity in the theory. One
of the reasons is that functions can depend on each other in more than just one
way now. Therefore, we add variables also to the list of dependencies, such as in
the type signature for map,
map/angbracketlefta::∗,b::∗/angbracketright::(map/angbracketlefta,b/angbracketright)⇒a→b,
where we now use map/angbracketlefta,b/angbracketrightto specify the dependency, instead of just map. We
will look at a few examples that demonstrate why this is necessary.
Assume we have a list-based implementation for sets: deﬁned as follows:
data Set(a::∗) =Set[a].
This datatype is supposed to fulﬁll the invariant that no duplicates occur in the
list. The generic function map does not respect the invariant, so it is advisable to
add a speciﬁc arm to the map function for sets:
map/angbracketleftSetα/angbracketright(Set xs ) =Set(nubBy (equal/angbracketleftα/angbracketright) (map/angbracketleft[α]/angbracketrightxs)).
The function nubBy is deﬁned in the Haskell standard library and has the type
signature
nubBy ::∀a::∗.(a→a→Bool )⇒[a]→[a].
It removes duplicates from a list, given an equality function for the list element
type. In above deﬁnition of map for datatype Set, we ﬁrst apply map to the un-
derlying list implementation, then use nubBy with argument equal/angbracketleftα/angbracketrightto remove
duplicates, and ﬁnally apply the Setconstructor again to create the resulting set.
The implementation is ﬁne, but it obviously introduces a dependency of func-
tion map on function equal . Furthermore, because equal depends on enum , the
function map must depend on enum as well. The correct type signature for map
with the additional arm for Set is thus
map/angbracketlefta::∗,b::∗/angbracketright::(map/angbracketlefta,b/angbracketright,equal/angbracketleftb/angbracketright,enum/angbracketleftb/angbracketright)⇒a→b.
140
9.5 Type tuples
We are in a situation where map, which is parametrized over two type variables,
depends on functions which are parametrized over only one type variable. There-
fore, there is choice. In this case, we need the equality and thus enumeration on
the result type of the mapping, because we apply nubBy (equal/angbracketleftα/angbracketright)after mapping
over the list.
Another (contrived) example to demonstrate the improved expressivity is the
following arm of a type-indexed function that performs some sort of consistency
check on a value. We just present one arm here, for a datatype of pairs, deﬁned
as
data Pair (a::∗) =Pair a a .
The type signature and the arm itself are as follows:
check/angbracketlefta::∗/angbracketright ::(map/angbracketlefta,a/angbracketright,collect/angbracketlefta|Int/angbracketright)⇒a→Bool
check/angbracketleftPairα/angbracketright(Pair x 1x2) =sum/parenleftbig
collect/angbracketleftPairα/angbracketright
(Pair (map/angbracketleftα/angbracketrightx1)x2)/parenrightbig≡0 .
The function check is parametrized over only one type parameter a, but it de-
pends on both map and collect . The mapping is requested in a version that does
not modify the type, and the result type of collect is already ﬁxed to Int by the
example, because of the usage of function sum ::[Int]→Int on the result of a call
tocollect .
In general, if a function with ntype parameters depends on a function with m
type parameters, there are nmpossibilities to choose the type of the dependency.
In addition, if there are non-generic type parameters such as with collect , those
can be instantiated to any type of matching kind.
To put everything in a common setting, we will now also write type signatures
of one-parameter type-indexed functions using variables on the list of dependen-
cies, for example:
equal/angbracketlefta::∗/angbracketright::(enum/angbracketlefta/angbracketright,equal/angbracketlefta/angbracketright)⇒a→a→Bool
empty/angbracketlefta::∗/angbracketright::(empty/angbracketlefta/angbracketright)⇒a
encode/angbracketlefta::∗/angbracketright::(encode/angbracketlefta/angbracketright)⇒a→[Bit].
The following section will start the formal discussion of generalized type signa-
tures.
9.5 Type tuples
As we have seen in the examples, we parametrize type signatures (and conse-
quently, the types) of type-indexed functions no longer over just one argument,
141
9 Types of Type-indexed Functions
Type tuple patterns
π::={ai::∗}i∈1..r
,|{bj::κj}j∈1..s
,
type tuple pattern
Type tuples
ϑ::={ti}i∈1..r
,|{t/prime
j}j∈1..s
, type tuple
Type argument tuples
Θ::={Ai}i∈1..r
,|{tj}j∈1..s
, type argument tuple
Figure 9.4: Syntax of type tuples and their kinds
but over a a tuple made up from two different sorts of variables: a type tuple
pattern consisting of rgeneric and snon-generic variables has the form
{ai::∗}i∈1..r
,|{tj::κj}j∈1..s
, .
All variables are supposed to be different. Each type variable is associated with a
kind, but generic type variables are always of kind ∗. We also say that the tuple
is/angbracketleftr|s/angbracketright-ary. We omit the vertical bar if s≡0.
A type with multiple arguments must also be instantiated to multiple types,
and those types must match in number and kind. A type tuple is of the form
{ti}i∈1..r
,|{t/prime
j}j∈1..s
, .
It has the structure of a type tuple pattern, but consists of rtypes in the generic
slots , and stypes in the non-generic slots .
Atype argument tuple is like a type tuple, but the generic slots contain type
arguments instead of types:
{Ai}i∈1..r
,|{tj}j∈1..s
, .
Figure 9.4 shows the new syntactic categories. We use πto abbreviate type
tuple patterns, ϑto denote type tuples, and Θfor type argument tuples.
We can use the kind information that is contained in a type tuple pattern to
kind check a type tuple (or a type argument tuple) under a kind environment K,
using judgments of the forms
K/turnstileleftpatϑ::π/squigglerightϕ
K/turnstileleftpatΘ::π/squigglerightϕ,
where ϕis a substitution mapping the variables that occur in pattern πto the
respective types or type arguments in ϑorΘ. The rules are shown in Figure 9.5.
142
9.5 Type tuples
K/turnstileleftpatϑ::π/squigglerightϕ
{K/turnstileleftti::κ}i∈1..r{K/turnstileleftt/prime
j::κj}j∈1..s
ϕ≡{(ai/mapsto→ti)}i∈1..r·{·(bj/mapsto→t/prime
j)}j∈1..s
K/turnstileleftpat/parenleftbig{ti}i∈1..r
,|{t/prime
j}j∈1..s
,/parenrightbig
::/parenleftbig{ai::κ}i∈1..r
,|{bj::κj}j∈1..s
,/parenrightbig/squigglerightϕ(tt)
K/turnstileleftpatΘ::π/squigglerightϕ
{K/turnstileleftAi::κ}i∈1..r{K/turnstilelefttj::κj}j∈1..s
ϕ≡{(ai/mapsto→Ai)}i∈1..r·{·(bj/mapsto→tj)}j∈1..s
K/turnstileleftpat/parenleftbig{Ai}i∈1..r
,|{tj}j∈1..s
,/parenrightbig
::/parenleftbig{ai::κ}i∈1..r
,|{bj::κj}j∈1..s
,/parenrightbig/squigglerightϕ(tat)
Figure 9.5: Kind checking of type and type argument tuples
We require the arities of the tuple and the tuple pattern to match, and the types
(or type arguments) must be of the kinds speciﬁed in the pattern. Note that rules
are more general than allowed by the current syntax in that the generic variables
are checked against some kind κnot restricted to ∗. This is because we will
extend the syntax of type tuples in Chapter 12 on generic abstraction.
Two type tuples can be compared; the corresponding judgment is dependent
on a kind environment K and reads
K/turnstileleftϑ1/lessorequalslantϑ2.
The rule is shown in Figure 9.6. A simple example for an application of compar-
ison is the judgment
a1::∗,a2::∗/turnstilelefta1,a2/lessorequalslanta1,a1.
We can choose
π≡(b1::∗,b2::∗)
ϕ1≡(b1/mapsto→a1)·(b2/mapsto→a1)
143
9 Types of Type-indexed Functions
K/turnstileleftϑ1/lessorequalslantϑ2
K/turnstileleftpatϑ1::π/squigglerightϕ1
K/turnstileleftpatϑ2::π/squigglerightϕ2
ψ·ϕ1≡ϕ2
K/turnstileleftψkind preserving
K/turnstileleftϑ1/lessorequalslantϑ2(tt-compare)
Figure 9.6: Comparison of type tuples
/turnstileleftϑ↓
/turnstileleft{ai}i∈1..r
,|{tj}i∈1..s
,↓(tt-bounded)
Figure 9.7: Bounded type tuples
ϕ2≡(b1/mapsto→a1)·(b2/mapsto→a2)
ψ≡(a2/mapsto→a1)
to show that (a1,a2)is indeed smaller than (a1,a1). Here are some more examples:
a1::∗,a2::∗,b1::∗/turnstilelefta1,a2|b1/lessorequalslanta1,a2|Int
a1::∗,a2::∗,b1::∗/turnstilelefta1,a2|b1/lessorequalslanta2,a1|[b1]
a1::∗ /turnstileleft a1/lessorequalslantChar .
We will make use of the ordering relation on type tuples throughout the following
sections.
Furthermore, we say that a type tuple is bounded , and write
/turnstileleftϑ↓,
if all generic slots of the type tuple ϑconsist of type variables. The corresponding
rule is deﬁned in Figure 9.7.
144
9.6 Multi-argument type signatures
9.6 Multi-argument type signatures
Type signatures of type-indexed functions are now of the form
x/angbracketleftπ/angbracketright::/parenleftbig{yk/angbracketleftϑk/angbracketright}k∈1..n/parenrightbig⇒t.
The variables that occur in the pattern πare supposed to be bound in the ϑkand
int(thus, alpha-conversion is possible). If πis a/angbracketleftr|s/angbracketright-ary type tuple pattern,
then xis said to be of arity/angbracketleftr|s/angbracketright.
Two things have changed compared to the situation of Chapter 6: the type
signature has no longer just one argument, but possibly many; the associated
kind is of the same form as that of a type tuple. And the dependencies ykare
now associated with type tuples ϑk, which specify in what way xdepends on
yk. This is a generalization of the former setting: previously, all type-indexed
functions were of arity /angbracketleft1|0/angbracketright. As a consequence of that, there was no need for
the type tuples to go with the dependencies.
In this and the next section, we will revise the theory of Section 6.3 to work with
multi-argument type signatures. Most of the judgments and rules introduced
there are replaced with more general variants. We call the generalized language
fcr+tif+mpar instead of fcr+tif+par.
Type signatures
σ::= ({yk/angbracketleftϑk/angbracketright}k∈1..n
, )⇒ttype signature of type-indexed function
Figure 9.8: Generalized type signatures in fcr+tif+mpar, replaces type signatures from
Figure 6.1
We still use σto abbreviate the right hand side of a type signature, the part
that is of the form ({yk/angbracketleftϑk/angbracketright}k∈1..n)⇒t(cf. Figure 9.8).
We also retain the notion of a base type . It is no longer instantiated to a type
argument, but to a type argument tuple. The revised judgment is shown in
Figure 9.9. If the base type of xis instantiated to Θ, then a type signature for x
must be in Γ. The type argument Θmust be kind compatible with the pattern π
in the type signature. The returned type is the type of the type signature without
dependencies, and the variables from the pattern πsubstituted by the types in
Θ, via substitution ϕ.
We still use the function dependencies from Figure 6.6 to access the depen-
dencies of a type-indexed function. In addition, we need a function deptt that
determines in which way one function depends on another. We need to access
the information that is encoded in the type tuple associated with the dependency
in the type signature. An invocation of deptt takes the form
145
9 Types of Type-indexed Functions
mbase K;Γ(x/angbracketleftΘ/angbracketright)≡t
x/angbracketleftπ/angbracketright::({yk/angbracketleftϑk/angbracketright}k∈1..n
, )⇒t∈Γ
K/turnstileleftpatΘ::π/squigglerightϕ
mbase K;Γ(x/angbracketleftΘ/angbracketright)≡ϕt(base-m)
Figure 9.9: Revised base type judgment, replaces rule (base) from Figure 6.6
depttK;Γ(x/angbracketleftΘ1/angbracketright,y)≡Θ2.
This means that under environments K and Γ, if function xis instantiated to type
argument tuple Θ1, and it depends on function y, then it will do so with type
argument tuple Θ2. Figure 9.6 shows how to compute this function. A type
depttK;Γ(x/angbracketleftΘ1/angbracketright,y)≡Θ2
x/angbracketleftπ/angbracketright::({yk/angbracketleftϑk/angbracketright}k∈1..n)⇒t∈Γ
h∈1 . .n
K/turnstileleftpatΘ1::π/squigglerightϕ
depttK;Γ(x/angbracketleftΘ1/angbracketright,yh)≡ϕ ϑh(deptt)
Figure 9.10: Dependency judgment
signature for xhas to be in the environment, and the function function yhmust
indeed be one of the dependencies of x. Therefore, there is an associated type
tuple ϑh. The type argument tuple Θthat xis instantiated to must match the type
tuple pattern πin the type signature of x. The match results in a substitution ϕ
for the variables in π, that may also occur in ϑh. Therefore, we apply ϕtoϑhand
return the result.
The type signatures of the type-indexed functions that we have introduced so
far ﬁt into this scheme easily. For instance, for map we have
map/angbracketlefta1::∗,a2::∗/angbracketright::(map/angbracketlefta1,a2/angbracketright)⇒a1→a2
and can state that
146
9.6 Multi-argument type signatures
mbase (map/angbracketleftInt, Char/angbracketright)≡(Int→Char )
deptt (map/angbracketleftInt, Char/angbracketright,map)≡(Int, Char ).
Similarly, for collect we have
collect/angbracketlefta::∗|b::∗/angbracketright::(collect/angbracketlefta|b/angbracketright)⇒a→[c]
and can derive that
mbase (collect/angbracketleftTree Int|Int/angbracketright)≡(Tree Int→[Int])
deptt (collect/angbracketleftTree Int|Int/angbracketright,collect )≡(Tree Int|Int).
Forcheck , which we had introduced with type signature
check/angbracketlefta::∗/angbracketright::(map/angbracketlefta,a/angbracketright,collect/angbracketlefta|Int/angbracketright)⇒a→Bool ,
we can apply the deptt judgment to get
deptt (check/angbracketleftFloat/angbracketright,map)≡(Float, Float )
deptt (check/angbracketleftFloat/angbracketright,collect )≡(Float|Int).
K;Γ/turnstilelefttpsigx/angbracketleftπ/angbracketright::σ
/braceleftbig
K;Γ/turnstilelefttpsigyk/angbracketleftπk/angbracketright::({zk,i/angbracketleftϑk,i/angbracketright}i∈1..mk, )⇒tk/bracerightbigk∈1..n
/braceleftbig{zk,i∈{yj}j∈1..n
,}i∈1..mk/bracerightbigk∈1..n
K/prime≡K{,ai::∗}i∈1..r{,bj::κj}j∈1..s
/braceleftBig/braceleftbig{zk,i≡yj=⇒K/prime,πk/turnstileleftϑk,i/lessorequalslantϑk}j∈1..n/bracerightbigi∈1..mk/bracerightBigk∈1..n
K/prime/turnstileleftt::∗/braceleftbig
K/prime/turnstileleftϑk::πk/bracerightbigk∈1..n /braceleftbig/turnstileleftϑk↓/bracerightbigk∈1..n
K;Γ/turnstilelefttpsigx/angbracketleftbig{ai::∗}i∈1..r
,|{bj::κj}j∈1..s
,/angbracketrightbig
::/parenleftbig{yk/angbracketleftϑk/angbracketright}k∈1..n
, )⇒t/parenrightbig(typesig-m)
Figure 9.11: Revised well-formedness of type signatures for type-indexed functions, re-
places rule (typesig) of Figure 6.7
The correctness of type signatures is a bit harder to verify in this generalized
setting. The old rule (typesig) in Figure 6.7 checked the kind correctness of the
type and the transitivity of the direct dependency relation. In addition, we now
have to verify that the way in which one function depends on another is legal.
147
9 Types of Type-indexed Functions
The new rule (typesig-m) is given in Figure 9.11. All dependencies ykofxmust
have a valid type signature in scope. All indirect dependencies zk,imust be direct
dependencies.
There are two new conditions: the type tuple that is associated with an indi-
rect dependency has to be smaller than the type tuple associated with a direct
dependency (we use πkhere to extend the kind environment, in the obvious
meaning); and each type tuple that is associated with a direct dependency has to
be bounded.
The remaining conditions of rule (typesig-m) deal with kind correctness: en-
vironment K/primeis K extended with the bindings from the type tuple pattern that
is associated with x. Each type tuple ϑkthat appears with a dependency ykof
xmust match the pattern πkthat is associated with the type signature of yk.
Furthermore, the base type tmust be of kind∗.
Both new conditions are a consequence of how calls to type-indexed functions
are translated. Here is an example for why we need the boundedness: consider
type-indexed functions xand ywith type signatures
x/angbracketlefta/angbracketright::(y/angbracketleftChar/angbracketright)⇒a
y/angbracketlefta/angbracketright::(y/angbracketlefta/angbracketright)⇒a.
The type tuple Char that is associated with yinxviolates the boundedness con-
dition. The generic application x/angbracketleft[Int]/angbracketrightis translated to
cp(x,[ ])cp(y, Int),
applying the generic translation algorithm from Figure 6.18 in Section 6.4.7. How-
ever, using the generalized generic application algorithm that will be introduced
in the following Section 9.7, we can conclude that the fcrtype of cp(x,[ ])would
be∀a::∗. Char→[a], because the dependency on yis ﬁxed to type Char. But
cp(y, Int)is of type Int, and this is type incorrect.
To see why the absence of the ordering condition between direct and indirect
dependencies causes problems, consider the three type-indexed functions x,y,
and zwith type signatures
x/angbracketlefta1,a2/angbracketright::(y/angbracketlefta1/angbracketright,z/angbracketlefta1,a2/angbracketright)⇒Int
y/angbracketlefta/angbracketright ::(z/angbracketlefta,a/angbracketright)⇒Int
z/angbracketlefta1,a2/angbracketright::(z/angbracketlefta1,a2/angbracketright)⇒(a1,a2).
The function xdepends both directly and indirectly on z. However, the condition
that/turnstilelefta,a/lessorequalslanta1,a2does not hold here. Now, let us have a look at the fragment
lety/angbracketleftα/angbracketright=0
z/angbracketleftα/angbracketright= (1,"foo" )
inx/angbracketleft[[α]]/angbracketright.
148
9.7 Revised generic application algorithm
From the revised generic application algorithm that will be introduced in the next
section, we can conclude that the generic application x/angbracketleft[[α]]/angbracketrightis of the qualiﬁed
type
∀(a1::∗) (a2::∗).(y/angbracketleftα/angbracketright:: Int, z/angbracketleftα/angbracketright::(a1,a2))⇒Int
The dependencies that arise from the use of αin the generic application of xare
deﬁned via local redeﬁnition, so that the entire fragment is of type Int. Thereby,
the universally quantiﬁed variables a1and a2are instantiated to Int and [Char ].
The fragment translates to
letcp(y,α) =0
cp(z,α) = ( 1,"foo" )
incp(x,[ ])/parenleftbig
cp(y,[ ])cp(z,α)/parenrightbig
/parenleftbig
cp(z,[ ])cp(z,α)/parenrightbig
.
The term cp(z,α)is used in the translation twice – but the ﬁrst use is type in-
correct, because of the restricted type in the dependency of yonz. The type of
component cp(y,[ ])is
∀a::∗.(a,a)→Int ,
and we cannot apply that to a tuple of type (Int,[Char ]). By insisting that the type
tuples associated with indirect dependencies are always smaller than the type
tuples associated with direct dependencies, we prevent such type mismatches.
9.7 Revised generic application algorithm
It is now time to look once more at the generic application algorithm. This algo-
rithm does now exist in two versions: one is still parametrized by a single type
argument, because that is the way a type-indexed function is called in a program.
The other is the actual replacement for the former algorithm, which now works
on type argument tuples.
The ﬁrst, the wrapper, is shown in Figure 9.12. Syntactically, this call is of the
same for than the old generic application algorithm in Figure 6.8. The only rule,
(ga), looks up the arity /angbracketleftr|s/angbracketrightof the generic function xin the environment Γ. The
type argument Ais replicated rtimes, and the stype variables bjare universally
quantiﬁed in the resulting type. The computation is then delegated to the type
tuple version of the algorithm, which is called gmapp .
The algorithm gmapp directly corresponds to the original gapp in Figure 6.8,
including the additional rule (ga-4) in Figure 6.19 for type arguments of higher
149
9 Types of Type-indexed Functions
gappK;Γ(x/angbracketleftA/angbracketright)≡q
x/angbracketleft{ai::∗}i∈1..r
,|{bj::κj}j∈1..s
,/angbracketright::σ∈Γ
gappK;Γ(x/angbracketleftA/angbracketright)≡{∀ bj::κj.}j∈1..sgmappK;Γ(x/angbracketleft{A}i∈1..r
,|{bj}j∈1..s
,/angbracketright)(ga)
Figure 9.12: Wrapper for the revised generic application algorithm
kind. The new rules are shown in Figure 9.13 and 9.14. The judgments are of the
form
gmappK;Γ(x/angbracketleftΘ/angbracketright)≡q,
the only difference except for the name being that we parametrize over a type
argument tuple Θnow. To create a single dependency constraint, we now use the
auxiliary judgment
mkmdepK;Γ(y/angbracketleftα←Θ/angbracketright)≡Y,
again with a type argument tuple in place of the former single type variable.
In the original algorithm, we distinguish cases based on the dependency vari-
ables that occur in the type argument. We still do the same thing, based on the
dependency variables that occur in the type argument tuple. The generic slots in
the type argument tuple are always of the same shape. They are all of the same
kind, and do all contain the same dependency variables in the same positions.
This uniformity is easy to see: the wrapper gapp places a single type argument A
in all generic slots of the type argument tuple, and during the whole algorithm
we only perform operations on the type argument that preserve uniformity, such
as substituting one dependency variable in all generic slots. The non-generic
slots of the type argument tuple are never really involved in the algorithm and
passed around everywhere without modiﬁcation. Only the wrapper gapp per-
forms universal quantiﬁcation on those, on the outside of the resulting qualiﬁed
type.
It thus makes sense to distinguish the following four cases (they correspond
one by one to the four cases of the original algorithm): rule (ga-m-1) covers type
argument tuples where no dependency variables appear and where the generic
slots are all of kind ∗– we use the judgment K /turnstileleftΘ::∗to denote this particular
property.
The second case (ga-m-2) is for type argument tuples in which the dependency
variable αforms the head of all generic slots. The third case (ga-m-3) is for type
150
9.7 Revised generic application algorithm
gmappK;Γ(x/angbracketleftΘ/angbracketright)≡q
K/turnstileleftΘ::∗ fdv(Θ)≡ε
gmappK;Γ(x/angbracketleftΘ/angbracketright)≡mbase (x/angbracketleftΘ/angbracketright)(ga-m-1)
K/turnstileleftα::κ{aifresh}i∈1..rK/prime≡K{,ai::κ}i∈1..r
gmappK;Γ(x/angbracketleft{α{Ai,h}h∈1../lscripti}i∈1..r
,|{tj}j∈1..s
,/angbracketright)
≡{∀ ai::κ.}i∈1..r/parenleftBig
mkmdepK/prime;Γ/parenleftbig
yk/angbracketleftα←{ai}i∈1..r
,|{tj}j∈1..s
,/angbracketright/parenrightbig/parenrightBig
⇒gmappK/prime;Γ/parenleftbig
x/angbracketleft{ai{Ai,h}h∈1../lscripti}i∈1..r
,|{tj}j∈1..s
,/angbracketright/parenrightbig(ga-m-2)
α∈fdv(Θ)Θ≡{Ai}i∈1..r
,|{tj}j∈1..s
,{head (Ai)/negationslash≡α}i∈1..r
K/turnstileleftα::κ{aifresh}i∈1..rK/prime≡K{,ai::κ}i∈1..r
dependenciesΓ(x)≡{yk}k∈1..n
,/braceleftbig
Θk≡depttK/prime;Γ(x/angbracketleft{ai}i∈1..r
,|{tj}j∈1..s
,/angbracketright,yk)/bracerightbigk∈1..n
gmappK;Γ(x/angbracketleftΘ/angbracketright)
≡{∀ ai::κ.}i∈1..r/parenleftbig/braceleftbig
mkmdepK/prime;Γ(yk/angbracketleftα←Θk/angbracketright)/bracerightbigk∈1..n
,/parenrightbig
⇒gmappK/prime;Γ/parenleftbig
x/angbracketleft{Ai[αi/ai]}i∈1..r
,|{tj}j∈1..s
,/angbracketright/parenrightbig(ga-m-3)
K/turnstileleftΘ::κ→κ/primefdv(Θ)≡εΘ≡{Ai}i∈1..r
,|{tj}j∈1..s
,
{aifresh}i∈1..rK/prime≡K{,ai::κ}i∈1..r
dependenciesΓ(x)≡{yk}k∈1..n
,/braceleftbig
Θk≡depttK/prime;Γ(x/angbracketleft{ai}i∈1..r
,|{tj}j∈1..s
,/angbracketright,yk)/bracerightbigk∈1..n
gmappK;Γ(x/angbracketleftΘ/angbracketright)
≡{∀ ai::κ.}i∈1..r{gmappK/prime;Γ(yk/angbracketleftΘk/angbracketright)→}k∈1..n
gmappK/prime;Γ/parenleftbig
x/angbracketleft{Aiai}i∈1..r
,|{tj}j∈1..s
,/angbracketright/parenrightbig(ga-m-4)
Figure 9.13: Revised generic application algorithm, replaces Figures 6.8 and 6.19
151
9 Types of Type-indexed Functions
mkmdepK;Γ(y/angbracketleftα←Θ/angbracketright)≡Y
K/turnstileleftα::κ κ≡{κh→}h∈1../lscript∗
{γhfresh}h∈1../lscriptK/prime≡K{,γh::κh}h∈1../lscript
mkmdepK;Γ/parenleftbig
x/angbracketleftα←{Ai}i∈1..r
,|{tj}j∈1..s
,/angbracketright/parenrightbig
≡/parenleftBig
x/angbracketleftα{γh}h∈1../lscript/angbracketright
::gmappK;Γ/parenleftbig
x/angbracketleft{Ai{γh}h∈1../lscript}i∈1..r
,|{tj}j∈1..s
,/angbracketright/parenrightbig/parenrightBig(mkdep-m)
Figure 9.14: Revised generic application algorithm, continued from Figure 9.13, replaces
Figures 6.8 and 6.19
argument tuples where a dependency variable appears in all generic slots, but
not in the head.
The fourth rule (ga-m-4) remains for type argument tuples which are without
dependency variables, but of functional kind. Again, we use the judgment K /turnstileleft
Θ::κ→κ/primeto state that all generic slots of Θare of kind κ→κ/prime.
The implementation of each of the cases is also only a generalization and thus
a more complicated version of the corresponding cases in the original algorithm.
In the ﬁrst case, we instantiate the base type, now via mbase .
In the second case, we create a dependency for the function xonα. Instead of
one type variable, we create rfresh type variables aiof the same kind as α, where
ris the number of generic slots in the type argument tuple. When generating the
dependency with help of the mkmdep function, we instantiate αwith these fresh
type variables ai, but pass on the non-generic types tjwithout modiﬁcation. We
then recursively call gmapp with αsubstituted by the ai.
The third case generates dependencies for dependency variable αand all func-
tions ykthat xdepends on. As in the second case, we create rfresh type variables
aiof the same kind as α, where/angbracketleftr|s/angbracketrightis the arity of the type argument tuple Θ.
We have to respect the way in which xdepends on each of the yk, therefore we
pass the type argument tuple
{ai}i∈1..r
,|{tj}j∈1..s
, ,
where the original generic entries have been replaced by the fresh type variables,
to the deptt function. As a result, we get modiﬁed type argument tuples Θk
which we can use to generate the dependency constraints. In the recursive call,
we substitute aiforαin the i-th generic slot of Θ.
152
9.8 Multiple dependencies on one function
The fourth case is for the situation that all dependency variables have been
eliminated, but the generic slots in the type argument tuple Θare not of kind∗,
but of functional kind κ→κ/prime. We treat this situation similarly to the previous
case, only that we do not introduce dependency constraints, but explicit function
arguments.
It remains to discuss the mkmdep function, which is displayed in Figure 9.14.
The call
mkmdepK;Γ(x/angbracketlefty←Θ/angbracketright)≡Y
expresses that under environments K and Γ, the dependency constraint Ybelongs
to the dependency yofxforα, ifαis instantiated by the type argument tuple Θ.
To compute the constraint, we introduce new local dependency variables γh,
guided by the arity of the kind κofα. Note that the generic slots of the type
argument tuple Θare of the same kind κ. Therefore, the γhare used as arguments
not only for αin the name of the dependency constraint that is generated, but
also as arguments for the generic slots AiofΘin the recursive call to gmapp .
9.8 Multiple dependencies on one function
There is a restriction that a dependency constraint set must contain at most one
entry per function and dependency variable. Similarly, the type signature of a
type-indexed function must contain at most one dependency on a certain other
function.
In the situation of Chapter 6, this was not really a limitation, because one type-
indexed function could depend on another in only one way. Now, where each
dependency is associated with a type tuple, there might be the need to depend
on the same function more than once, in different ways.
As an example, consider the following implementation of a product case for a
hypothetical generic function combine which takes two values and performs some
analysis whether they can be combined:
combinable/angbracketleftProd α β/angbracketright(x1×x2) (y1×y2) =special/angbracketleftα/angbracketrightx1∨special/angbracketleftα/angbracketrighty1.
Two pairs can be combined if one of the ﬁrst components is special in the sense
that another generic function special returns True on the value.
If we assume that combinable has the type signature
combinable/angbracketlefta::∗/angbracketright ::(combinable/angbracketlefta/angbracketright,special/angbracketlefta/angbracketright)
⇒a→a→Bool ,
153
9 Types of Type-indexed Functions
then everything is ﬁne. However, if we want the possibility to combine values of
different types, we need two dependencies on special :
combinable/angbracketlefta1::∗,a2::∗/angbracketright::(combinable/angbracketlefta1,a2/angbracketright,special/angbracketlefta1/angbracketright,special/angbracketlefta2/angbracketright)
⇒a1→a2→Bool ,
and the two calls to special/angbracketleftα/angbracketrightabove would refer to different dependencies. We
do not allow such double dependencies.
Instead, we enable multiple dependencies to the same function via an easy way
to create copies of an existing type-indexed function. This is achieved via default
cases , which are introduced in Chapter 14 and are mainly used to create variants
of existing type-indexed functions by extending them. The facility to create copies
of functions is a special case that is useful here: we can write
special/primeextends special
to create a copy of special and then use the legal type signature
combinable/angbracketlefta1::∗,a2::∗/angbracketright::(combinable/angbracketlefta1,a2/angbracketright,special/angbracketlefta1/angbracketright,special/prime/angbracketlefta2/angbracketright)
⇒a1→a2→Bool ,
with the deﬁnition
combinable/angbracketleftProd α β/angbracketright(x1×x2) (y1×y2) =special/angbracketleftα/angbracketrightx1∨special/prime/angbracketleftα/angbracketrighty1,
where special/primeand special implement the same function.
9.9 Translation and correctness
In the translation of fcr+tif+par to fcrthat we have introduced in Chapter 6, we
refer to the original generic application algorithm gapp . The only change that we
need in order to obtain a translation of fcr+tif+mpar to fcris to interpret each
call to the original gapp algorithm as a call to the new gapp wrapper. Everything
else works exactly as before.
The effect of the change is that in some situations, we allow more liberal types
for generic applications or arms of type-indexed functions. We thus have to verify
the correctness of the translation once more, to ensure that the translation actually
warrants the more liberal types we assign. We require a variant of Theorem 6.5
that is adapted to type argument tuples.
Theorem 9.1 (Correctness of revised generic application). If we have are in the
situation that gmappK;Γ(x/angbracketleftΘ/angbracketright)≡qand K; ∆/turnstileleftq/lessorequalslantt, then
/llbracketK;Γ;∆;Σ/rrbracketpar
K;Γ/turnstileleft/llbracketx/angbracketleftΘ/angbracketright/rrbracketgtrans
K;Γ;Σ::t.
154
10 Embedding Datatypes
In order to specialize a generic function to a type that is not in the signature of
that function (i.e., for which the function is not explicitly deﬁned), it is helpful to
realize that we can map each datatype to an isomorphic structural representation
type. In Section 7.5.1, we have sketched that such a structural representation
replaces the toplevel structure of a datatype with occurrences of the datatypes
Unit, Sum, and Prod (all introduced in Section 7.1), but leaves the ﬁelds and
possible recursive calls intact.
The details of the translation are not as essential as the fact that the translation
is an embedding of all datatypes into type expressions, making use of a limited
number of additional datatypes. Using this embedding, we can reduce the prob-
lem of specializing a generic function to a new datatype to the following two
subproblems: ﬁrst, we can specialize the generic function to the structural repre-
sentation of the datatype instead. Second, we need to ﬁnd a way to exploit the
fact that the structural representation is isomorphic to the original type in such a
way that we can turn the specialization on the representation type into a function
that works for the original type.
In this chapter, we formally deﬁne the embedding of datatypes into the type
language, and we will convince ourselves that the structural representations are
155
10 Embedding Datatypes
really isomorphic to the original types. In the Chapter 11, we will focus on how
to exploit the structural representation for the specialization of calls to generic
functions.
10.1 Zero
A close look at the grammar of fcin Figure 3.1 reveals that a datatype is allowed
to have no constructors at all. The declaration
data Zero =
is valid in fc(and thus, in all languages based upon it). In Haskell 98, this is
not a legal declaration, but datatypes without constructors are allowed by some
implementations as an extension – including the ghc, where one can simply write
data Zero
to deﬁne such a type.
There is no way to construct a value of the type Zero, therefore Zero is a
type without any values (except for the undeﬁned value ⊥). Nevertheless, the
type is sometimes useful, particularly in combination with other datatypes. For
parametrized types, Zero can be used to exclude certain alternatives – for in-
stance, the type [Zero ]of lists of elements of type Zero has (ignoring ⊥values or
combinations therewith) only one value, the empty list [ ]. We will see a useful
application of Zero in the Chapter 16 on type-indexed types.
Unfortunately, the structure of a type with no constructors cannot be repre-
sented as a type expression involving Unit, Sum, and Prod. We therefore choose
Zero as a fourth special type. Types with no constructors are represented using
Zero. Note that there are also parametrized data types that have no constructors.
For
data ParZero (f::∗→∗ ) (a::∗) =,
the representation type is
type Str(ParZero ) (f::∗→∗ ) (a::∗) =Zero .
Does that mean that we now have to add a case for Zero to every generic
deﬁnition? Yes and no. Types without values are used very infrequently, and
as with any other type, we do not need a case for it as long as we do not want
to use the function on such types. For example, if we omit the Zero case for
the generic equality function, everything is ﬁne – unless we actually have calls
156
10.2 A few examples
such as equal/angbracketleftZero/angbracketrightorequal/angbracketleft[Zero ]/angbracketrightin our program, which cause specialization
errors.
On the other hand, a library writer might want to add a case for Zero to make
the generic functions ﬁt for use also in such rare scenarios.
An example for a function that can actually beneﬁt from an arm for the Zero
type is the generic enumeration function enum (deﬁned on page 111). We could
deﬁne enum on Zero as follows:
enum/angbracketleftZero/angbracketright= [ ] .
The enum function lists all (non- ⊥) values of a datatype, and as such computes a
characteristic of the type itself rather than performing some operation on values
of the type.
10.2 A few examples
The translation to structural representation types is simple enough. Nevertheless,
we have only seen one example so far, back in Section 7.5.1, and it can do no harm
to discuss the embedding for a few more datatypes.
In Section 7.2, we stated that the type Bool is, unlike Int or Char or Float, not
considered abstract, but assumed to be deﬁned as
data Bool =False|True .
Indeed, it is easy to give the structural representation of Bool,
type Str(Bool ) =Sum Unit Unit ,
and the associated embedding-projection pair is trivial.
Likewise, the type of lists, although we assume special syntax for it, is not
considered abstract, but assumed to be deﬁned as
data [a::∗] = [ ]|a:[a].
If we translate the special syntax away and assume the type constructor to be List,
the “nil” constructor to be Nil, and the “cons” constructor to be Cons , this would
correspond to the deﬁnition
data List (a::∗) =Nil|Cons a (Lista).
The structural representation of lists is
type Str([ ]) ( a::∗) =Sum Unit (Prod a[a]),
157
10 Embedding Datatypes
and the associated embedding-projection pair is:
ep([ ]) = letfromList [ ] = Inl Unit
fromList (x:xs) = Inr(x×xs)
toList (Inl Unit ) = [ ]
toList (Inr(x×xs)) = ( x:xs)
inEP fromList toList .
Look at the deﬁnitions of fromList and toList . The patterns in fromList appear as
right hand sides of toList , and the patterns of toList double as right hand sides of
fromList . This symmetry holds in general, and makes it obvious that fromList and
toList are indeed inverses of each other, and thus deﬁne isomorphisms. Note that
the structural representation of List cannot be distinguished from the representa-
tion of [ ], because the representation types do not (yet) contain any information
about the names of the constructors or the original datatype.
Structural representations are never directly recursive. The ﬁelds in the original
datatype are not touched by the translation, and as a consequence, Str([ ]) still
refers to the original type [ ]. The translation replaces the top layer of a datatype
with its structure. If necessary, the translation can be applied repeatedly, to reveal
the structure of the ﬁelds as well.
If a datatype has only one constructor, then no application of Sum occurs in
the structural representation. An example is the datatype of rose trees, deﬁned
as
data Rose (a::∗) =Fork a [Rose a].
A rose tree is a tree with a variable degree of branching. In each node, it stores a
value and a list of possible subtrees. There is no need for a separate constructor
to represent a leaf, we can simply use the auxiliary function
roseleaf x =Fork x [ ]
to construct a leaf. The representation type for rose trees is
type Str(Rose ) (a::∗) =Prod a[Rose a],
the associated embedding-projection pair is
ep(Rose ) =letfromRose (Fork x y ) =x×y
toRose (x×y) = Fork x y
inEP fromRose toRose
If a datatype has more than two constructors, or more than two ﬁelds in a con-
structor, we use nested applications of Sum and Prod to represent the datatype.
158
10.3 Formal translation
We have already seen one such example, Tree (where there are three ﬁelds in the
Node constructor), in Section 7.5.1. Another one is a datatype such as Direction,
deﬁned as
data Direction =North|East|South|West ,
where the structural representation and embedding-projection pair are deﬁned
as follows:
type Str(Direction ) =Sum Unit (Sum Unit (Sum Unit Unit ))
ep(Direction ) =
letfromDirection North =Inl Unit
fromDirection East =Inr(Inl Unit )
fromDirection South =Inr(Inr(Inl Unit ))
fromDirection West =Inr(Inr(Inr Unit ))
toDirection (Inl Unit ) = North
toDirection (Inr(Inl Unit )) = East
toDirection (Inr(Inr(Inl Unit ))) = South
toDirection (Inr(Inr(Inr Unit ))) = West
inEP fromDirection toDirection .
Note that we have chosen a biased encoding for the sum structure, nesting to
the right, and we do the same for the product structure. We will discuss other
choices brieﬂy in Chapter 17.
To summarize: for datatypes without constructors, Zero is used as represen-
tation; if there is one constructor, no sum structure is generated, as in the Rose
example; if there are two or more constructors, we produce a nested sum. For
each constructor, we proceed similarly: if there are no ﬁelds, we use Unit to repre-
sent the constructor; one ﬁeld is represented by itself; for multiple ﬁelds, a nested
product is created.
In the following section, we will formalize both the generation of structural
representations and of embedding-projection pairs.
10.3 Formal translation
Let us now look at the translation in detail. We deﬁne two functions, one to
construct a parametrized type from the deﬁnition of a datatype, and one to build
the deﬁnition of the embedding-projection pair converting between the original
type and its structural representation. A parametrized type is of the form
{Λai::κi.}i∈1../lscriptt,
159
10 Embedding Datatypes
a type twith a number of kind-annotated type-level lambda abstractions in front.
The aihave to be all different and are considered to be bound in t. We extend
kind checking to parametrized types using the new rule in Figure 10.1.
K/turnstileleftt::κ
K{,ai::κi}i∈1../lscript/turnstileleftt::κ
K/turnstileleft{Λai::κi.t}i∈1../lscript::{κi→}i∈1../lscriptκ(t-par)
Figure 10.1: Kind checking of parametrized types, extends Figure 3.2
We will use parametrized types to represent the generic representations of
datatypes. Before, in the examples, we have used Haskell type synonyms, us-
ing the type keyword. But type is not part of our fcrlanguage. The structural
representation types are only used internally, therefore we can use parametrized
types that are applied to arguments where needed, instead of extending our lan-
guage with an additional construct.
The translation to the structural representation is expressed by judgments of
the forms
/llbracketD/rrbracketstr≡{Λai::κi.}i∈1../lscriptt
/llbracket{Cj{tj,k}k∈1..nj}j∈1..m
|/rrbracketstr≡t.
In the ﬁrst case, a datatype declaration is mapped to a parametrized type; in the
second case, a list of constructors is mapped to a type. The rules are shown in
Figures 10.2 and 10.3.
The main part of the work happens during the translation of the constructors.
For a complete datatype, handled by rule (str-data), the type variables over which
it is parametrized are stripped. Then, the bare constructors are translated. In the
end, the variables are reinserted without modiﬁcation to form the parameters of
the structural representation.
For constructors, we distinguish several different cases. In the special case that
there is no constructor, rule (str-constr-1) applies, and we translate to Zero, as
explained in Section 10.1. The datatype Zero is used only in this case.
The next three rules deal with a single constructor. Again, we distinguish
different cases. If the constructor is without ﬁelds, the rule (str-constr-2) translates
it to Unit. Again, Unit is only used in this speciﬁc case. If the constructor has one
ﬁeld t, the translation is the ﬁeld itself according to rule (str-constr-3). Only if at
160
10.3 Formal translation
/llbracketD/rrbracketstr≡{Λai::κi.}i∈1../lscriptt
/largellbracket{(Cj{tj,k}k∈1..nj)}j∈1..m
|/largerrbracketstr≡t
/largellbracket
data T={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketstr
≡{Λai::κi.}i∈1../lscriptt(str-data)
Figure 10.2: Structural representation of datatypes
/largellbracket{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketstr≡t
/llbracketε/rrbracketstr≡Zero(str-constr-1)/llbracketC/rrbracketstr≡Unit(str-constr-2)
/llbracketC t/rrbracketstr≡t(str-constr-3)
n∈2 . . /llbracketC{tk}k∈2..n/rrbracketstr≡t/prime
2
/llbracketC{tk}k∈1..n/rrbracketstr≡Prod t1t/prime
2(str-constr-4)
m∈2 . ./largellbracket{Cj{tj,k}k∈1..nj}j∈2..m
|/largerrbracketstr≡t2/largellbracket
C1{t1,k}k∈1..n1/largerrbracketstr≡t1/largellbracket{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketstr≡Sum t1t2(str-constr-5)
Figure 10.3: Structural representation of constructors
161
10 Embedding Datatypes
least two ﬁelds are present, a product structure is created in rule (str-constr-4).
The constructor with all but the ﬁrst ﬁeld is recursively translated (but there still
is at least one) to t/prime
2, whereas the ﬁrst ﬁeld is included in the result Prod t1t/prime
2
unchanged.
The ﬁnal rule, (str-constr-5), is for the situation that there are at least two con-
structors. Only in this case a sum structure is created, analogous to the product
structure. The ﬁrst constructor is translated on its own, and all remaining con-
structors (there is still at least one) are translated as a sequence, and the result is
Sum applied to the two partial translations.
Theorem 10.1. Assume that K contains the bindings necessary for the embed-
ding, Zero ::∗, Unit ::∗, Sum ::∗2, and Prod ::∗2. IfDis a well-formed datatype,
thus K/turnstileleftD/squigglerightT::κ;Γ, then K/turnstileleft/llbracketD/rrbracketstr::κ.
In other words, the structural representation is of the same kind as the original
datatype.
Proof. The well-formedness of the datatype declaration (cf. rule (p-data) in Fig-
ure 3.6) implies that all constructor ﬁelds are of kind ∗under environment K/prime≡
K{ai::κi}i∈1../lscript, where the aiare the parameters of the datatype. Under this
condition, it is easy to see that if any judgment of the form
/largellbracket{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketstr≡t
holds, then K/prime/turnstileleftt::∗. This holds thus for the speciﬁc type tthat is the result
of the constructor translation in rule (str-data). Application of the new kind
checking rule (t-par) yields
K/prime/turnstileleft{Λai::κi.}i∈1../lscriptt::κ,
which is the claim.
The structural representation type of a datatype is also called the standard view
of the datatype, as opposed to alternative views that are the topic of Chapter 17.
The translation that generates embedding-projection pairs consists of judg-
ments of the forms
/llbracketD/rrbracketep≡d/largellbracket{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketep≡{pfrom j}j∈1..m
|;{ptoj}j∈1..m
|.
The rules that are presented in Figures 10.4 and 10.5 are exactly analogous to the
rules for generating the structural representations. Not only do we distinguish
162
10.3 Formal translation
/llbracketD/rrbracketep≡d
/largellbracket{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketep≡{pfrom j}j∈1..m
|;{ptoj}j∈1..m
|
dfrom≡xfrom =λy→case yof{pfrom j→ptoj}j∈1..m
;
dto≡xto=λy→case yof{ptoj→pfrom j}j∈1..m
;
e≡let{dfrom;dto}inEP x from xto/largellbracket
data T={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketep≡ep(T) =e(ep-data)
Figure 10.4: Generation of embedding-projection pairs for datatypes
between the translation of a complete datatype declaration Dto a value decla-
ration dagain and the translation of a list of constructors to a pair of two lists
of patterns. Also, the ﬁve rules for the translation of constructors correspond
one by one to the ﬁve rules in Figure 10.3. Structural representation type and
embedding-projection pair generation can thus easily be fused in an implemen-
tation.
The rule (ep-data) processes the declaration for one datatype T. The declaration
produced is for the value of the name ep(T). We assume that the function ep
maps a type name to a variable name in a way that it does not clash with any
user-deﬁned names. The right hand side of the value declaration is of the form
letxfrom =λy→case yof{pfrom j→ptoj}j∈1..m
;
xto =λy→case yof{ptoj→pfrom j}j∈1..m
;
inEP x from xto.
This structure makes it very obvious that the EP contains two mutual inverses.
Note that patterns are used as expressions here. This is possible because the
pattern language is a subset of the expression language, and, as we will see, the
rules for translating constructors ensure that pfrom jalways contains exactly the
same variables as ptoj. The shape of the expressions also reveals what the patterns
should look like. The pfrom jshould match on a value of the j-th constructor of
the datatype, whereas ptojshould be a suitable product that is injected into the
sum structure of the representation type.
To return these patterns is the job of the rules that translate a list of construc-
tors. Rule (ep-constr-1) states that no constructors translate to no patterns. As a
result, the two case statements above will be empty. But in such a situation, also
they’s above are of a type with no constructors, and thus no deﬁned values – it
163
10 Embedding Datatypes
/largellbracket{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketep≡{pfrom j}j∈1..m
|;{ptoj}j∈1..m
|
ε/squigglerightε;ε(ep-constr-1)/llbracketC/rrbracketep≡C;Unit(ep-constr-2)
xfresh
/llbracketC t/rrbracketep≡C x;x(ep-constr-3)
n∈2 . . x1fresh /llbracketC{tk}k∈2..n/rrbracketep≡C{xk}k∈2..n;pto
/llbracketC{tk}k∈1..n/rrbracketep≡C{xk}k∈1..n;x1×pto(ep-constr-4)
m∈2 . ./largellbracket{Cj{tj,k}k∈1..nj}j∈2..m
|/largerrbracketep≡{pfrom j}j∈2..m
|;{ptoj}j∈2..m
|/largellbracket
C1{t1,k}k∈1..n1/largerrbracketep≡pfrom 1 ;pto 1/largellbracket{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketep
≡{pfrom j}j∈1..m
|;Inl p to 1{|Inr p toj}j∈2..m(ep-constr-5)
Figure 10.5: Generation of embedding-projection pairs for constructors
164
10.3 Formal translation
is irrelevant what the conversion function looks like, as it will never be applied
to a non-⊥value.
If there is one constructor Cwithout any ﬁelds, the constructor is associated
with Unit in rule (ep-constr-2). If there is one ﬁeld, as in rule (ep-constr-3), we
introduce a new variable to represent the value of that ﬁeld. Because the repre-
sentation of a single ﬁeld is the ﬁeld itself, we associate the pattern C xwith x.
If there are multiple ﬁelds, we introduce a fresh variable x1for the ﬁrst ﬁeld and
map the the constructor to a (possibly nested) product pattern x1×pto, where
ptois the result of recursively translating the constructor with all but the ﬁrst
ﬁeld. Note that the rules (ep-constr-3) and (ep-constr-4) are the only two rules
in which variables are introduced into the patterns, and in both cases they are
introduced into both resulting patterns, thereby maintaining the invariant that
corresponding patterns contain the same variables.
The rule (ep-constr-5) is for multiple (i.e., at least two) constructors. In this
case, we translate the ﬁrst constructor C1on its own, resulting in a pair of pat-
terns pfrom 1 ;pto 1. The other constructors are also recursively translated. In the
representation type, the choice between C1and one of the other constructors is
expressed by an application of Sum, where C1values correspond to Inlvalues,
whereas values of any other constructor correspond to Inrvalues. Therefore, the
pattern pto 1is preﬁxed by Inl, and the remaining patterns ptojare all preﬁxed by
Inr.
Theorem 10.2. Assume that K and Γcontain the bindings for Zero, Unit, Sum,
and Prod, and their constructors. If Dis a well-formed datatype, thus K /turnstileleftD/squiggleright
T::κ;Γ/primewhere κ≡{κi→}i∈1..n∗, and if /llbracketD/rrbracketep≡ep(T) =eand Str(T)≡/llbracketD/rrbracketstr,
then
K,T::κ;Γ,Γ/prime/turnstilelefte::{∀ai::κi}i∈1..n. EP/parenleftbig
T{ai}i∈1..n/parenrightbig /parenleftbig
Str(T){ai}i∈1..n/parenrightbig
.
The theorem states that the embedding-projection pair resulting from the dec-
laration of a datatype is type correct and is indeed a value of type EP, being able
to convert back and forth between values of type Tand values of type Str(T), the
structural representation of T.
Theorem 10.3. LetDbe a well-formed datatype, thus K /turnstileleftD/squigglerightT::κ;Γ/prime. Then,
for any two expressions eand e/prime, the fcrexpression
letfrom =λz→case zofEPx y→x
to =λz→case zofEPx y→y
/llbracketD/rrbracketep
in/parenleftbig
from ep(T) (toep(T)e),toep(T) (from ep(T)e/prime)/parenrightbig
evaluates to (e,e/prime).
165
10 Embedding Datatypes
Note that we include the from and todeﬁnitions in the let statement, because
they may occur in the embedding-projection pair, but the deﬁnition of the em-
bedding-projection pair, /llbracketD/rrbracketep, is the important declaration.
166
11Translation by
Specialization
In Chapter 10, we have shown how a datatype can be converted into an iso-
morphic parametrized type that reveals the structure of the datatype deﬁnition.
A generic function can be specialized to such a parametrized type expression
using the algorithm discussed in Chapter 6.
In this Chapter we show how exactly the isomorphism between a datatype T
and its generic representation type Str(T)can be exploited to reduce the special-
ization problem for a generic application x/angbracketleftT{Ai}i∈1..n/angbracketrightto the specialization
problem for x/angbracketleftStr(T){Ai}i∈1..n/angbracketright. The solution has already been sketched in Sec-
tion 7.5.2. In Section 11.1, we will discuss another example and show that the key
to the problem is to lift the isomorphism between Tand Str(T)that is available in
an embedding-projection pair to an isomorphism between the types t[T/a]and
t[Str(T)/a]for a type tthat is the base type of the generic function x. In Sec-
tions 11.2 and 11.3, we will show how this problem can be solved using a generic
function called bimap . Afterwards, in Section 11.4, we will discuss implications
for the dependency relation and show in Section 11.5 how generic functions can
be translated into fcr. Section 11.6 adds some remarks on how to implement the
translation. Having outlined how translation by specialization works, we discuss
167
11 Translation by Specialization
the merits of the approach and point out limitations in Section 11.7. We conclude
by presenting two alternative possibilities to translate type-indexed and generic
functions, in Section 11.8.
11.1 Problem
Let us recall the examples from Section 7.5.2. We were trying to specialize the
calls encode/angbracketleftTree α/angbracketrightand add/angbracketleftTree α/angbracketright. The datatype Tree has been deﬁned as
data Tree (a::∗) =Leaf|Node (Tree a)a(Tree a),
which makes the parametrized type
Λa::∗. Sum Unit/parenleftBig
Prod (Tree a)/parenleftbig
Prod a(Tree a)/parenrightbig/parenrightBig
its structural representation. We will abbreviate as follows:
Str(Tree )A≡Sum Unit/parenleftBig
Prod (Tree A)/parenleftbig
Prod A(Tree A)/parenrightbig/parenrightBig
.
The base types of the functions addand encode are
mbase (encode/angbracketleftA/angbracketright)≡A→[Bit]
mbase (add/angbracketleftA/angbracketright)≡A→A→A.
Now, we can specialize the calls encode/angbracketleftStr(Tree )α/angbracketrightand add/angbracketleftStr(Tree )α/angbracketright–
using the /llbracket·/rrbracketgtransalgorithm from Figure 6.18 – to do the main part of the work,
but we still need a wrapper for encode/angbracketleftTree α/angbracketrightand add/angbracketleftTree α/angbracketright, because Tree is
recursive, and because the original call in the program refers to the Tree datatype,
not to Str(Tree ).
According to the gapp algorithm from Figure 9.12, we know that
encode/angbracketleftStr(Tree )α/angbracketright::∀a.(encode/angbracketleftα/angbracketright::a→[Bit])⇒Str(Tree )a→[Bit]
encode/angbracketleftTree α/angbracketright ::∀a.(encode/angbracketleftα/angbracketright::a→[Bit])⇒Tree a→[Bit]
add/angbracketleftStr(Tree )α/angbracketright::∀a.(add/angbracketleftα/angbracketright::a→a→a)
⇒Str(Tree )a→Str(Tree )a→Str(Tree )a
add/angbracketleftTree α/angbracketright ::∀a.(add/angbracketleftα/angbracketright::a→a→a)
⇒Tree a→Tree a→Tree a.
We have an isomorphism between Str(Tree )tand Tree tfor any type t. Therefore,
also the types of the two encode applications as well as the types of the two add
168
11.2 Lifting isomorphisms
applications can be expected to be isomorphic. We have demonstrated by exam-
ple that we can deﬁne the calls encode/angbracketleftTree α/angbracketrightand add/angbracketleftTree α/angbracketrightwith the desired
types by making use of the embedding-projection pair ep(Tree )as follows:
encode/angbracketleftTree α/angbracketrightx=encode/angbracketleftStr(Tree )α/angbracketright(from ep(Tree )x)
add/angbracketleftTree α/angbracketrightx y=
toep(Tree )/parenleftbig
add/angbracketleftStr(Tree )α/angbracketright(from ep(Tree )x) (from ep(Tree )y)/parenrightbig
.
The question remains – can we ﬁnd a general solution to the following prob-
lem: we have a named type T{αi}i∈1..n, a generic representation type thereof,
abbreviated as Str(T){αi}i∈1..n, and a generic function x. We must ﬁnd a way to
deﬁne x/angbracketleftT{αi}i∈1..n/angbracketrightin terms of x/angbracketleftStr(T){αi}i∈1..n/angbracketright, making use of ep(T).
11.2 Lifting isomorphisms
As it turns out, we can solve the problem just posed. Assume for now that x
is a type-indexed function of arity /angbracketleftr|0/angbracketrightfor some r, i.e., it has no non-generic
variables. We can then deﬁne
x/angbracketleftT{αj}j∈1..n/angbracketright=
let{bimap/angbracketleftβi/angbracketright=ep(T)}i∈1..r
;
into bimap/angbracketleftbig
mbase (x/angbracketleft{βi}i∈1..r
,/angbracketright)/angbracketrightbig /parenleftbig
x/angbracketleftStr(T){αj}j∈1..n/angbracketright/parenrightbig
.
In above deﬁnition, we use local redeﬁnition on a generic function bimap yet to be
deﬁned. This function bimap is a bidirectional variant of map(deﬁned on page 135
in Section 9.1), and computes embedding-projection pairs instead of functions.
While introducing map, we noticed a strong relationship between the identity
function and mapping, and that we can use local redeﬁnition to “plug in” a
modifying function into an identity that works on a complicated datatype. Here,
we use the same idea, only that the function that we plug in is the embedding-
projection pair ep(T). The type we use bimap on is the base type of x, instantiated
to dependency variables βiin the generic slots, because we want to change all
occurrences of the type arguments from an application of Str(T)to an application
ofT.
The deﬁnition of bimap is indeed strongly related to map. The type signature is
bimap/angbracketlefta1::∗,a2::∗/angbracketright::(bimap/angbracketlefta1,a2/angbracketright)⇒EPa1a2.
The function bimap results in an EP where map uses the function space construc-
tor(→). Instead of deﬁning one function, from a type a1to a type a2,bimap
169
11 Translation by Specialization
deﬁnes a pair of functions, one from a1toa2, the other from a2toa1. The ad-
vantage is that it is straightforward to extend the deﬁnition of bimap to function
types. This is the deﬁnition of the generic function:
bimap/angbracketleftUnit/angbracketright =EP id id
bimap/angbracketleftSum α β/angbracketright=
letfromSum z =case zof
Inl x→Inl(from (bimap/angbracketleftα/angbracketright)x)
Inr x→Inr(from (bimap/angbracketleftβ/angbracketright)x)
toSum z =case zof
Inl x→Inl(to (bimap/angbracketleftα/angbracketright)x)
Inr x→Inr(to (bimap/angbracketleftβ/angbracketright)x)
inEP fromSum toSum
bimap/angbracketleftProd α β/angbracketright=
letfromProd z =case zof
x×y→(from (bimap/angbracketleftα/angbracketright)x)×(from (bimap/angbracketleftβ/angbracketright)y)
toProd z =case zof
x×y→(to (bimap/angbracketleftα/angbracketright)x)×(to (bimap/angbracketleftβ/angbracketright)y)
inEP fromProd toProd
bimap/angbracketleftα→β/angbracketright=
letfromFun z =from (bimap/angbracketleftβ/angbracketright)·z·to (bimap/angbracketleftα/angbracketright)
toFun z =to (bimap/angbracketleftβ/angbracketright)·z·from (bimap/angbracketleftα/angbracketright)
inEP fromFun toFun
In addition to the arms given above, bimap can be deﬁned as EP id id for all
abstract types of kind ∗, including Int, Float and Char.
We also need to deﬁne bimap on EP, to close a vicious circle: if we do not, the
automatic specialization would produce the following deﬁnition:
bimap/angbracketleftEPα β/angbracketright=letbimap/angbracketleftγ/angbracketright=ep(EP)
into bimap/angbracketleftEPγ γ/angbracketright(bimap/angbracketleftProd (α→β) (β→α)/angbracketright).
This deﬁnition calls itself immediately (the let does not matter, and tois strict in
its argument), thus a call of bimap to EP would not terminate. Here is a deﬁnition
that works:
bimap/angbracketleftEPα β/angbracketright=
lete1 =bimap/angbracketleftα→β/angbracketright
e2 =bimap/angbracketleftβ→α/angbracketright
fromEP z =case zof
EP x y→EP(from e 1x) (from e 2y)
170
11.2 Lifting isomorphisms
toEP z =case zof
EP x y→EP(to e 1x) (to e 2y)
inEPfromEP toEP .
The following theorem states that if we proceed as outlined above, specializing
a call to a generic function with a new datatype by producing a wrapper around
the call that uses the structural representation of that datatype, we always pro-
duce a type correct component.
Theorem 11.1. For a type-indexed function xof arity/angbracketleftr|0/angbracketright, the declaration
x/angbracketleftT{αj}j∈1..n/angbracketright=
let{bimap/angbracketleftβi/angbracketright=ep(T)}i∈1..r
;
into bimap/angbracketleftbig
mbase (x/angbracketleft{βi}i∈1..r
,/angbracketright)/angbracketrightbig /parenleftbig
x/angbracketleftStr(T){αj}j∈1..n/angbracketright/parenrightbig
is type correct, i.e., the right hand side of the declaration is of the qualiﬁed type
gmapp (x/angbracketleftT{αj}j∈1..n/angbracketright).
Proof. According to the revised generic application algorithm from Figure 9.12,
we get that
gmapp (x/angbracketleftT{αi}j∈1..n/angbracketright)≡/braceleftbig{∀ai,j::κj.}j∈1..n/bracerightbigi∈1..r(∆)⇒mbase/parenleftbig
x/angbracketleft{T{ai,j}j∈1..n}i∈1..r
,/angbracketright/parenrightbig
for a set of dependency constraints ∆containing dependencies for all combina-
tions of functions in dependencies (x)and variables αi. The above qualiﬁed type is
the type that the right hand side expression should have.
The generic application algorithm also dictates that
x/angbracketleftStr(T){αi}j∈1..n/angbracketright::/braceleftbig{∀ai,j::κj.}j∈1..n/bracerightbigi∈1..r(∆)⇒mbase/parenleftbig
x/angbracketleft{Str(T){ai,j}j∈1..n}i∈1..r
,/angbracketright/parenrightbig
,
for the same ∆. The only difference between this type and the type above is that
one uses Str(T)where the other uses T.
The local redeﬁnition extends ∆to∆/primefor the scope of the let. We have
/turnstileleftep(T)::{∀ai::κi.}i∈1..nEP(T{ai}i∈1..n) (Str(T){ai}i∈1..n),
thus∆/primeis∆extended with
/braceleftbig
bimap/angbracketleftβi/angbracketright::{∀ai,j::κj.}j∈1..nEP(T{ai,j}j∈1..n) (Str(T){ai,j}j∈1..n)/bracerightbigi∈1..r.
Another application of gmapp , for the bimap call, yields
171
11 Translation by Specialization
/turnstileleftbimap/angbracketleftmbase (x/angbracketleft{β}i∈1..r
,/angbracketright)/angbracketright
::{∀(bi,1::∗) (bi,2::∗)}i∈1..r.)/parenleftbig{bimap/angbracketleftβi::∗/angbracketright:: EP bi,1bi,2}i∈1..r
,/parenrightbig
⇒EP/parenleftbig
mbase (x/angbracketleft{bi,1}i∈1..r
,/angbracketright)/parenrightbig /parenleftbig
mbase (x/angbracketleft{bi,2}i∈1..r
,/angbracketright)/parenrightbig
.
Considering ∆/prime, we can conclude that
∆/prime/turnstileleftto bimap/angbracketleftmbase (x/angbracketleft{β}i∈1..r
,/angbracketright)/angbracketright
::mbase/parenleftbig
x/angbracketleft{Str(T){ai,j}j∈1..n}i∈1..r
,/angbracketright/parenrightbig→mbase/parenleftbig
x/angbracketleft{T{ai,j}j∈1..n}i∈1..r
,/angbracketright/parenrightbig
and
∆/prime/turnstileleftx/angbracketleftStr(T){αi}j∈1..n/angbracketright::mbase/parenleftbig
x/angbracketleft{Str(T){ai,j}j∈1..n}i∈1..r
,/angbracketright/parenrightbig
for suitable ai,j. After applying (e-app) to the two terms and revealing the depen-
dency constraints, we are done.
11.3 Lifting isomorphisms and
universal quantiﬁcation
In the previous section, we assumed that the arity of the generic function that in
the call is/angbracketleftr|0/angbracketrightfor some r. Now, we turn to the general case where the arity is
/angbracketleftr|s/angbracketrightfor natural numbers rand s.
The non-generic slots of a base type are usually universally quantiﬁed on the
outside; therefore one possible way to generate a wrapper would be to deﬁne
x/angbracketleftT{αj}j∈1..n/angbracketright=
let{bimap/angbracketleftβi/angbracketright=ep(T)}i∈1..r
;
into bimap/angbracketleftBig
{∀bj::κj.}j∈1..smbase/parenleftbig
x/angbracketleft{βi}i∈1..r
,|{bj}j∈1..s
,/angbracketright/parenrightbig/angbracketrightBig
/parenleftbig
x/angbracketleftStr(T){αj}j∈1..n/angbracketright/parenrightbig
where the bjare fresh type variables of suitable kind. However, universal quan-
tiﬁcations are not allowed in the language of type arguments, and it is not clear
how we should specialize the bimap call in the code fragment above.
We will use this as incentive to discuss universal quantiﬁcation over kind ∗
type variables and outline two possible solutions. Subsequently, we discuss why
these approaches are difﬁcult to extend to variables of higher kind.
After that, we use the knowledge gained to circumvent the direct need for
universal quantiﬁcation in type arguments in the situation of bimap above.
172
11.3 Lifting isomorphisms and universal quantiﬁcation
11.3.1 Kind∗default arms
A possible extension to our language is to allow a default arm of a generic func-
tion for types of kind ∗that do not have an explicit arm. Such an extension can
be useful for several of the functions that we have encountered so far:
size/angbracketleft::∗/angbracketrightx=0
map/angbracketleft::∗/angbracketrightx=x
collect/angbracketleft::∗/angbracketrightx= [ ]
In the case of the generic functions map,zipWith and collect , this makes the ex-
plicit deﬁnition of Unit and all kind ∗abstract types such as Int, Float, and Char
superﬂuous. It not only saves code lines – the function also becomes applicable
to any other abstract type that might be introduced into the program.
The kind∗default must be sufﬁciently polymorphic – it must not make any
assumptions about the type. This can be achieved by extending gapp to handle
kind∗arms as follows:
gapp (x/angbracketleft::∗/angbracketright)≡∀a::∗.gapp (x/angbracketlefta/angbracketright).
Subsequently, whenever we have to specialize a call x/angbracketleftT/angbracketrightfor a named type Tof
kind∗, we ﬁrst check if Tis in the signature of T. If so, we use the explicit arm.
Otherwise, we check if there is a kind ∗default, and use that if possible. Only
if no kind∗default and no explicit arm exist, we try to generate a component
using the generic specialization technique outlined in Sections 11.1 and 11.2.
Kind∗default arms also help with universally quantiﬁed type variables of
kind∗, because they work for alltypes of kind∗, even for a type we do not know.
When encountering a call x/angbracketleft∀a::∗.A/angbracketright, we can thus skolemize ato a fresh named
type T, and treat the call as x/angbracketleftA[T/a]/angbracketright. As long as there is a kind ∗default for
x, this will be used during the specialization.
Forbimap , we can deﬁne a kind ∗default arm as follows:
bimap/angbracketlefta::∗/angbracketright=EP id id .
This will work as intended and makes the explicit deﬁnitions for Unit and the
abstract types unnecessary.
11.3.2 Arms for universal quantiﬁcation
A quantiﬁcation over a kind ∗variable can be viewed as application of a type
constructor of kind (∗→∗ )→∗. If we have a value of type
∀a::∗.t
173
11 Translation by Specialization
and assume that we can somehow rewrite it to a type where the occurrences of a
intare explicit, such as
∀a::∗.t/primea
with a/∈dv(t/prime), then the application of the quantiﬁer is a type-level function that
takes the type t/prime, of kind∗→∗ , to the type∀a::∗.t/primea, of kind∗. In Haskell with
extensions, this idea could be captured by deﬁning a type synonym
type Forall∗(c::∗→∗ ) =∀a::∗.c a.
Now, if universal quantiﬁcation over a kind ∗datatype is just the application
of a type constructor, then type-indexed functions can be deﬁned for this type.
size/angbracketleft∀a::∗.γa/angbracketrightx=letsize/angbracketleftα/angbracketright=0
insize/angbracketleftγ α/angbracketrightx
map/angbracketleft∀a::∗.γa/angbracketrightx=letmap/angbracketleftα/angbracketright=id
inmap/angbracketleftγ α/angbracketrightx
collect/angbracketleft∀a::∗.γa/angbracketrightx=letcollect/angbracketleftα/angbracketright= [ ]
incollect/angbracketleftγ α/angbracketrightx.
In all cases, we essentially know how to deﬁne the function for any kind ∗
datatype, thus also for a universally quantiﬁed one.
Other than in the solution using a kind ∗default, we have more control over the
structure of the type. We can, for example, write a generic function that counts
the universal quantiﬁers in the type:
countForall/angbracketlefta::∗/angbracketright ::(countForall/angbracketlefta/angbracketright)⇒Int
countForall/angbracketleftInt/angbracketright =0
countForall/angbracketleftUnit/angbracketright =0
countForall/angbracketleftSum α β/angbracketright=countForall/angbracketleftα/angbracketright+countForall/angbracketleftβ/angbracketright
countForall/angbracketleftProd α β/angbracketright=countForall/angbracketleftα/angbracketright+countForall/angbracketleftβ/angbracketright
countForall/angbracketleftα→β/angbracketright =countForall/angbracketleftα/angbracketright+countForall/angbracketleftβ/angbracketright,
countForall/angbracketleft∀a::∗.γa/angbracketright=1+letcountForall/angbracketleftα/angbracketright=0
incountForall/angbracketleftγ α/angbracketright
and then call
countForall/angbracketleft(∀a::∗.a→Int→a)→(∀a::∗. Int→a→a)/angbracketright
to get the result 2. Similarly, we could write a show function that displays univer-
sal quantiﬁcation in a human-readable fashion, assigning a fresh variable name
174
11.3 Lifting isomorphisms and universal quantiﬁcation
from a supply of names whenever a universal quantiﬁer is encountered. These
effects are out of reach using kind ∗default deﬁnitions.
Of course, the deﬁnition of countForall demonstrates that it might be useful
to have both kind ∗defaults and arms for universal quantiﬁcation. We could
augment the deﬁnition of countForall using
countForall/angbracketleft::∗/angbracketright=0 ,
discarding the arms for Int and Unit instead. Having both is not a problem – the
two extensions can be added to the language independently.
Forbimap , we can use the deﬁnition:
bimap/angbracketleft∀a::∗.γa/angbracketright=letbimap/angbracketleftα/angbracketright=EP id id
inbimap/angbracketleftγ α/angbracketright.
Note that the type of this arm is
∀(c1::∗→∗ ) (c2::∗→∗ )./parenleftbig
bimap/angbracketleftγ α/angbracketright::∀(a1::∗) (a2::∗).(bimap/angbracketleftα/angbracketright:: EP a1a2)
⇒EP(c1a1) (c2a2)/parenrightbig
⇒EP(∀a::∗.c1a) (∀a::∗.c2a).
This type is valid in our functional core language, but it is not valid in Haskell
– not even with the current set of extensions available, because it uses the type
constructor EP impredicatively at a polymorphic type. There is a ghcextension
for arbitrary rank types (Peyton Jones and Shields 2003), but it allows polymor-
phic types only as arguments to the function space constructor (→). Other type
constructors, such as EP, may only be applied to monomorphic types.
Therefore, this solution works only if we either make it speciﬁc to the generic
function bimap and take special precautions for the polymorphic case (for exam-
ple, use another, monomorphic type, which is allowed to contain polymorphic
ﬁelds in ghc), or if we really have support for type constructors to be instantiated
with polymorphic values in our target language – at least in some limited form.
For instance, if we would allow tuples to contain polymorphic values, we could
deﬁne EP as a type synonym
type EP(a::∗) (b::∗) = ( a→b,b→a)
which would be sufﬁcient for our purposes.
Yet another possibility is to deﬁne bimap in two parts, from and to, where from
and toare both deﬁned in exactly the same way as map, but have an additional
case for function types that makes use of the other function:
175
11 Translation by Specialization
from/angbracketlefta::∗,b::∗/angbracketright::(from/angbracketlefta,b/angbracketright,to/angbracketleftb,a/angbracketright)⇒a→b
to/angbracketleftb::∗,a::∗/angbracketright::(from/angbracketlefta,b/angbracketright,to/angbracketleftb,a/angbracketright)⇒b→a
from/angbracketleftα→β/angbracketrightz=from/angbracketleftβ/angbracketright·z·to/angbracketleftα/angbracketright
to/angbracketleftα→β/angbracketrightz=to/angbracketleftβ/angbracketright·z·from/angbracketleftα/angbracketright
If we now extend from and towith cases for universal quantiﬁers, we still get a
higher ranked type, but the quantiﬁers appear in positions where they are legal
inghc.
Even if the problem of assigning a type to the universal case is solved, there
is still the question of how to express a call of the form x/angbracketleft∀a::∗.A/angbracketrightfor some
type argument A, possibly containing a, in terms of the case x/angbracketleft∀a::∗.γa/angbracketrightwhich
requires a type constructor of kind ∗→∗ that expects the quantiﬁed variable as
an argument. This abstraction step can be simulated using local redeﬁnition: we
can deﬁne
x/angbracketleft∀a::∗.A/angbracketright≡let{yi/angbracketleftγ(α::∗)/angbracketright=yi/angbracketleftA[α/a]/angbracketright}i∈1..k
;
inx/angbracketleft∀a::∗.γa/angbracketright,
where{yi}i∈1..k
, are the dependencies of x. This translation is only type correct
if either the yiare all reﬂexive, i.e., depend on themselves, or if we exclude the
case that A≡a. The reﬂexivity requirement originates from the fact that γwould
essentially be instantiated by the identity type constructor Λa::∗.aifA≡a.
Reﬂexivity will be treated in more detail in the Section 11.4. For bimap , there is
no problem, because bimap depends only on itself, and is thus reﬂexive.
11.3.3 Quantiﬁed variables of higher kind
Unfortunately, the two solutions just discussed do not help with universally
quantiﬁed variables of higher kind. The problem is that in Haskell, we cannot
write a map function that is polymorphic in the type constructor:
pmap ::∀(a::∗) (b::∗) (f::∗→∗ ).(a→b)→(f a→f b)
But such a function is exactly what would be needed to deﬁne a case such as
map/angbracketleft∀b::∗→∗ .γb/angbracketrightx=. . .
or even
bimap/angbracketleft∀b::∗→∗ .γb/angbracketrightx=. . . .
The reason why we cannot deﬁne pmap is that we know nothing about the struc-
ture of f, and how to map a function over a value of type f afor some type a
176
11.3 Lifting isomorphisms and universal quantiﬁcation
depends on the structure of the type constructor f. This is the reason why we
deﬁned a generic function map in the ﬁrst place.
There are possibilities to work around this problem, for instance to allow de-
pendency constraints within type patterns:
map/angbracketleft∀b::∗→∗ .
(map/angbracketleftbα/angbracketright::∀a1a2.(map/angbracketleftα/angbracketright⇒ (a1→a2)→b a1→b a2))
⇒γb/angbracketrightx=letmap/angbracketleftβ(α::∗)/angbracketright=map/angbracketleftbα/angbracketright
inmap/angbracketleftγ β/angbracketright.
Note that we also need the name bin scope on the right hand side. Here, we
expect that with the quantiﬁed type constructor bcomes some information of
how to map over it. We can then put this information to use. We could deﬁne a
bimap case similarly.
But if we can somehow give semantics to this case, it still does not work for
all universal quantiﬁcations, but only those that provide a map dependency of
the required form. For our bimap situation, that would mean that non-generic
variables of higher kind must not be simply universally quantiﬁed, but also be
equipped with mapping information.
Furthermore, all this only covers kind ∗ → ∗ so far. For other kinds, we
would need to introduce yet more cases, and there is no easy way to generalize
to universally quantiﬁed type variables of arbitrary kind.
11.3.4 A pragmatic solution for bimap
If we do not want to extend the language with either kind ∗default cases or cases
for universal quantiﬁcation, and at the same time want to prevent problems with
impredicativity, we can use local redeﬁnition once more in the deﬁnition of the
wrapper function.
We deﬁne
x/angbracketleftT{αj}j∈1..n/angbracketright=
let{bimap/angbracketleftβi/angbracketright=ep(T)}i∈1..r
;
{bimap/angbracketleftβ/prime
j/angbracketright=EP id id}j∈1..s
;
into bimap/angbracketleftbig
mbase (x/angbracketleft{βi}i∈1..r
,|{β/prime
j}j∈1..s
,/angbracketright)/angbracketrightbig
/parenleftbig
x/angbracketleftStr(T){αj}j∈1..n/angbracketright/parenrightbig
and directly plug in EP id id for all occurrences of non-generic type variables –
assuming they are all of kind ∗– thus alleviating the need for universal quantiﬁ-
cation.
177
11 Translation by Specialization
The same, namely using EP id id in a local redeﬁnition, works also for non-
generic type variables of higher kind, as long as they are not applied to the
type argument, but to a constant type. Then, the wrapper need not map the
conversion between Str(T)and Tover an unknown type constructor, and there is
no problem. We disallow situations where non-generic variables are applied to
the type argument.
Theorem 11.2. For a type-indexed function xof arity/angbracketleftr|s/angbracketright, where all non-generic
slots of xare of kind∗, the declaration
x/angbracketleftT{αj}j∈1..n/angbracketright=
let{bimap/angbracketleftβi/angbracketright=ep(T)}i∈1..r
;
{bimap/angbracketleftβ/prime
j/angbracketright=EP id id}i∈1..s
;
into bimap/angbracketleftbig
mbase (x/angbracketleft{βi}i∈1..r
,|{β/prime
j}j∈1..s
,/angbracketright)/angbracketrightbig
/parenleftbig
x/angbracketleftStr(T){αj}j∈1..n/angbracketright/parenrightbig
is type correct, i.e., the right hand side of the declaration is of the qualiﬁed type
gmapp (x/angbracketleftT{αj}j∈1..n/angbracketright).
The proof is largely identical to the proof of Theorem 11.1.
11.4 Reﬂexivity of the dependency relation
It turns out that we also need an additional requirement on the dependencies for
generic functions. Consider the following datatype:
data Id(a::∗) =Id a .
According to the translations deﬁned in Chapter 10, we have
/llbracketdata Id=Λa::∗.Id a/rrbracketstr≡Λa::∗.a
and
/llbracketdata Id=Λa::∗.Id a/rrbracketep≡ep(Id) =letxfrom =λy→case yof
Idx→x
xto =λy→case yof
x→Idx
inEP x from xto.
We will write Str(Id)AforA.
178
11.4 Reﬂexivity of the dependency relation
Now, if a call such as x/angbracketleftIdα/angbracketrightis encountered in the program, for a generic
function xthat has no speciﬁc arm for Id, we have seen that we could make use
of the deﬁnition
x/angbracketleftIdα/angbracketright=letbimap/angbracketleftβ::∗/angbracketright=ep(Id)
into bimap/angbracketleftbase (x/angbracketleftβ/angbracketright)/angbracketright(x/angbracketleftStr(Id)α/angbracketright),
which, reducing the abbreviation Str(Id)αtoα, is
x/angbracketleftIdα/angbracketright=letbimap/angbracketleftβ::∗/angbracketright=ep(Id)
into bimap/angbracketleftbase (x/angbracketleftβ/angbracketright)/angbracketright(x/angbracketleftα/angbracketright).
Now, the right hand side refers to x/angbracketleftα/angbracketright, and therefore depends on x/angbracketleftα/angbracketright, but
x/angbracketleftα/angbracketrightis available only if xdepends on itself!
We have thus seen that transforming a datatype to its structural representation
as deﬁned in Chapter 10, and subsequently applying the translation using the
lifted isomorphism by locally redeﬁning bimap , can lead to a translation which
requires that a generic function depends on itself. We call a function that depends
on itself reﬂexive .
Note that Id is not the only datatype that triggers this problem. Another ex-
ample is the datatype for ﬁxpoints on the type level:
data Fix(a::∗→∗ ) =In(a(Fixa)).
Its structural representation is the parametrized type
Λa::∗→∗ .a(Fixa).
The situation that we need a reﬂexive dependency arises whenever one of the
type variables appears in the head of the representation type. That – given the
translation we use to compute the structural representation – happens whenever
the datatype in question has exactly one constructor with exactly one ﬁeld, and a
type variable is the head of the type of this ﬁeld.
There are basically two solutions to this problem: ﬁrst, we can live with the
problem and accept the additional requirement that a function can only be generic
if it is reﬂexive. A non-reﬂexive type-indexed function can still exist, but it is not
possible to specialize it to datatypes generically.
Second, we can modify the representation type generation in such a way that
the problem does not arise. We could, for example, introduce Type as yet an-
other special datatype and use it in the translation of all datatypes. The adapted
rule (str-data) from Figure 10.2 would look as follows:
/largellbracket{(Cj{tj,k}k∈1..nj)}j∈1..m
|/largerrbracketstr≡t
/largellbracket
data T={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|/largerrbracketstr
≡{Λai::κi.}i∈1../lscriptType t
179
11 Translation by Specialization
Although using an explicit marker such as Type for the border of a datatype
has certain advantages (and we will revisit this possibility in Chapter 17), it also
has the disadvantage that every single generic function would need an additional
case for Type, one that is usually trivial, but tedious to write.
As a variation of the second solution, we could adapt the structural type rep-
resentations in such a way that we introduce the Id type into the representations
in only those situations where one of the type variables appears in the head.
We could then allow automatic specialization of a generic function to Id if the
function is reﬂexive, and report a specialization error instead.
On the other hand, there are very few generic functions that are not reﬂexive
anyway – with the exception of generic abstractions, which will be handled in
Chapter 12. Therefore, we go for the ﬁrst solution, which is the simplest: in the
formal translation outlined in the following Section 11.5, a function can only be
generic , i.e., new components can only be generated, if the function is reﬂexive.
11.5 Translation of generic functions
In this section, we will adapt the translation rules in such a way that reﬂexive
functions that are deﬁned for at least some of the datatypes Unit, Sum, Prod, and
Zero, can be extended in a generic way to a large class of datatypes.
First of all, we have to make the information that is generated by the trans-
lations described in Chapter 10 available where it is needed: the embedding-
projection pairs must be included as declarations into the translation of the pro-
gram so that they can be referred to from everywhere; the information about the
structural representations must be passed in an environment to all places where
generic functions can be deﬁned.
Furthermore, we have to assume that the generic bimap function is available,
because we need it to specialize calls to generic functions.
Apart from that, we do not need to change a lot. At the declaration site of a
generic function, we now make it possible to generate additional components for
a generic function, and thereby to extend the signature environment in the scope
of the generic function.
The language that we deﬁne now is called fcr+gf, and includes all the fea-
tures we have seen so far, such as type-indexed functions with parametrized type
patterns, dependencies, and local redeﬁnition.
To distribute information, we introduce two new environments. The environ-
ment E for declarations of the embedding-projection pairs contains entries of the
form ep(T) =d. The structural representation types are stored in Ψ, using entries
of the form Str(T)≡{Λai::κi.}i∈1../lscriptt. We assume that the number of entries in Ψ
180
11.5 Translation of generic functions
and E is always the same. For a type T, there exists an embedding-projection pair
if and only if there is a structural representation type. Utilizing this assumption,
we need E only for checking programs, not in the judgments for declarations and
expressions.
/llbracketP::t/rrbracketgf
K;Γ;Ψ;E≡P/prime
P≡{Di;}i∈1..nmain =e
{K/turnstileleftDi/squigglerightKi;Γi}i∈1..n
K≡K0{, Ki}i∈1..nΓ≡Γ0{,Γi}i∈1..n
Ψ≡Ψ0{,/llbracketDi/rrbracketstr}i∈1..nE≡E0{,/llbracketDi/rrbracketep}i∈1..n
/llbracketletdfrom;dtoin let dbimap ine::t/rrbracketgf
K;Γ;ε;ε;Ψ≡e/prime
P/prime≡{Di;}i∈1..nmain =letEine/prime
/llbracketP::t/rrbracketgf
K0;Γ0;Ψ0;E0≡P/prime(p-gprog)
Figure 11.1: Well-formed programs, replaces Figure 3.7
Both environments, Ψand E, are populated while checking and translating the
program. We present a new rule to check the well-formedness of a program while
at the same time translating it, in Figure 11.1. This judgment is a replacement for
Figure 3.7, which was intended for language fcr. We have already extended
that original judgment in a trivial way to be able to deal with dependencies in
Chapter 6, without repeating the rule.
The new rule is named (p-gprog), to emphasize that it is capable of handling
generic functions. We take four input environments, containing external types
with their kinds, external functions and constructors (as in Chapter 3, if we im-
port external functions, we have to extend the set of reduction rules for fcras
well), and now also structural representation types and embedding-projection
pairs for external types.
We assume that Unit, Sum, Prod, and Zero are all contained in K 0, with their
constructors in Γ0. These types have neither structural representations nor em-
bedding-projection pairs in Ψ0and E 0– they are abstract.
On the other hand, the datatype EP should be contained in K 0, the constructor
EPinΓ0, and a suitable representation and embedding-projection pair for EP
should be contained in Ψ0and E 0, respectively. Even though it sounds strange,
there exists an embedding-projection pair for the EP datatype. The structural
representation can be abbreviated as
181
11 Translation by Specialization
Str(EP)A1A2≡Prod (A1→A2) (A2→A1),
and the embedding-projection pair can be deﬁned as follows:
ep(EP) =letxfrom =λy→case yofEP x 1x2→x1×x2
xto =λy→case yofx1×x2→EP x 1x2
inEP x from xto.
The datatype declarations Diare checked for well-formedness using the rule (p-
data) from Chapter 3 which still applies unchanged. Datatypes need not be trans-
lated. They appear in the resulting fcrprogram as they appear in the fcr+gf
program, without any modiﬁcations. The datatypes are checked under the envi-
ronment K, which in addition to K 0contains all kinds of the datatypes deﬁned in
the program. This means that datatypes can be mutually recursive.
The environment K is also used to check and translate the main expression
of the program, e. The other environments that are used in this position are Γ,
containing Γ0plus all constructors deﬁned by the Di, andΨ, containing Ψ0and
all structural type representations of the Di. The expression eis translated with
an empty dependency environment and an empty signature environment. There
is no need to pass the E environment around while checking and translating the
expression. We only require the information which datatypes have embedding-
projection pairs, and we can query Ψfor that, since we assume that both Ψand E
have associated entries.
Not plain eis translated, though, but rather
letdfrom;dtoin let dbimap ine.
The declarations in the outer let are simply the from and tofunctions that we have
already used before
dfrom≡from =λx→case xofEP from to→from
dto≡to =λx→case xofEP from to→to,
and dbimap contains a deﬁnition of the generic function bimap , much as the one
given in Section 11.2, but desugared (i.e., written as a typecase, idrewritten to
λx→x, and composition expanded to application). We assume the dbimap con-
tains cases for the primitive abstract types in K 0, such as Int, Float and Char.
Due to the presence of these let bindings, not only the programmer, but also
the translation can assume the presence of the bimap function.
The/llbracket·/rrbracketgftranslation on expressions is mostly the same as the /llbracket·/rrbracketpartranslation
from Chapters 6, using the revised generic application algorithm from Chapter 9
– with the exception that /llbracket·/rrbracketgfadditionally passes around the Ψenvironment.
The one signiﬁcant difference is in how we translate declarations of type-indexed
182
11.5 Translation of generic functions
/llbracketdfcr+tif+par/squigglerightΓ2;Σ2/rrbracketgf
K;Γ1;∆;Σ1;Ψ≡{dfcri}i∈1..n
;
P0≡T{αk}k∈1../lscript
Str(T)≡{Λak::κk.}k∈1../lscriptt∈Ψ
K;Γ/prime/turnstilelefttpsigx/angbracketleftπ/angbracketright::σ
π≡({bi::∗}i∈1..r|{b/prime
j::κ/prime
j}j∈1..s)
{βifresh}i∈1..r{β/prime
jfresh}j∈1..s
depttK;Γ(x/angbracketleftπ/angbracketright,x)≡π
K/prime≡K{,βi::∗}i∈1..r{,β/prime
j::κ/prime
j}j∈1..s
e0≡let{bimap/angbracketleftβi/angbracketright=ep(T)}i∈1..r
;
{bimap/angbracketleftβ/prime
j/angbracketright=EP id id}j∈1..s
;
into bimap/angbracketleftbig
mbase K/prime;Γ(x/angbracketleft{βi}i∈1..r
,|{β/prime
j}j∈1..s
,/angbracketright)/angbracketrightbig
(x/angbracketleftt{[αk/ak]}k∈1../lscript/angbracketright)
d/prime≡x/angbracketlefta/angbracketright=typecase aofP0→e0{;Pi→ei}i∈1..n
/llbracketd/prime/squigglerightΓ/prime;Σ/prime/rrbracketgf
K;Γ;∆;Σ;Ψ≡{dfcri}i∈1..n
;
/llbracketx/angbracketlefta/angbracketright=typecase aof{Pi→ei}i∈1..n
;/squigglerightΓ/prime;Σ/prime/rrbracketgf
K;Γ;∆;Σ;Ψ
≡{dfcri}i∈1..n
;(d/tr-gf)
Figure 11.2: Translation of fcr+gf declarations to fcr, extends Figure 6.15
183
11 Translation by Specialization
functions: we deﬁne a companion for the rule (d/tr-tif) from Figure 6.15, named
rule (d/tr-gf) in Figure 11.2. This rule can be applied before rule (d/tr-tif), to add
arms for additional datatypes to a generic function.
Ifxis deﬁned via typecase on patterns {Pi}i∈1..n
, , we can use rule (d/tr-gf) to
derive generically an additional case for pattern P0. We implicitly assume that the
named type Tappearing in P0is not yet covered by any of the other type patterns.
We need the structural representation of Tout of environment Ψ, which is of the
form{Λak::κk.}k∈1../lscriptt. We are going to extend the typecase of xwith a new arm
P0→e0. As discussed before, e0is in essence a generic application of xto the
structural representation type, of the form x/angbracketleftt{[αk/ak]}k∈1../lscript/angbracketright, where the formal
parameters akof the structural representation type are replaced by the formal
dependency parameters αkin pattern P0. The call of xis surrounded by a call to
bimap , applied to the base type of x, to lift the isomorphism between Tand Str(T)
to the type of x. In the base type we replace all generic and non-generic slots
with fresh dependency variables, and use local redeﬁnition to plug in ep(T)for
the generic slots, and EP id id for the non-generic slots.
The extended typecase is bound to d/prime. We return the translation of d/primeas a result,
where d/primeis translated using the same judgment recursively. After adding this one
new case, we can thus either add more cases, for more types, or ultimately fall
back to rule (d/tr-tif) to translate all cases – the user-deﬁned original ones plus
the newly generated generic ones – in the same way as for any type-indexed
function.
The condition depttK;Γ(x/angbracketleftπ/angbracketright,x)≡πimplements the reﬂexivity condition that
we have pointed out in Section 11.4. The function xmust depend on itself, and
the dependency must use the same type tuple that appears on the left hand side
of the type signature.
To see why this additional requirement is necessary, consider the functions x
and ywith type signatures as follows:
x/angbracketlefta1,a2/angbracketright::(x/angbracketlefta1,a1/angbracketright,y/angbracketlefta2/angbracketright)⇒Either a1a2
y/angbracketlefta/angbracketright ::(y/angbracketlefta/angbracketright)⇒a.
Here, the dependency of xon itself is restricted, because deptt (x/angbracketlefta1,a2/angbracketright,x)≡
a1,a1. We then have
x/angbracketleftIdα/angbracketright::∀(a1::∗) (a2::∗).(x/angbracketleftα/angbracketright:: Either a1a1,y/angbracketleftα/angbracketright::a2)
⇒Either (Ida1) (Ida2).
If we use rule (d/tr-gf) to generate an arm for type Id, we end up with
x/angbracketleftIdα/angbracketright=letbimap/angbracketleftβ1/angbracketright=ep(Id)
bimap/angbracketleftβ2/angbracketright=ep(Id)
into bimap/angbracketleftEither β1β2/angbracketrightx/angbracketleftα/angbracketright,
184
11.6 How to determine the required components
because Str(Id)α≡α. The right hand side is of type
∀(a1::∗) (a2::∗).(x/angbracketleftα/angbracketright:: Either a1a2,y/angbracketleftα/angbracketright::a2)
⇒Either (Ida1) (Ida1),
which does not match the type above that is required for x/angbracketleftIdα/angbracketright.
11.6 How to determine the required components
Translation via rule (d/tr-gf) in Figure 11.2 introduces nondeterminism into the
translation, because it is not exactly speciﬁed which additional components are
generated, and in which order. Now, the order is irrelevant, because the new arms
do not depend on the already existing arms, and the order of arms in a typecase
is irrelevant. Furthermore, the rule ensures that a consistent set of additional
components is generated: the generation of additional components extends the
signature environment, but all components that are referred to in the body (i.e.,
including the additional components), must be present.
But the rule does not specify that no extraneous components must be generated
(and, in fact, it does not do any harm to do so – they will end up as unused
declarations in a let, thus be dead code). Maybe more importantly, it does not
give any hints as to how an actual implementation could proceed to ﬁnd out
which specializations are needed.
First of all, it is reassuring to note that the number of required additional com-
ponents will always be ﬁnite, simply because all components for xare of the form
x/angbracketleftT/angbracketright, where Tis a named type (and not a type expression). Of named types there
are the ones declared in the beginning of the program, plus types contained in
the initial kind environment K 0. Provided that K 0is ﬁnite, the number of named
types in ﬁnite. Even if it is inﬁnite (because, for example, K 0might contain all
tuple types), only ﬁnitely many of them can ever be used in one program.
Therefore, there is the conservative option to generate components for any
combination of type-indexed function and datatype that is used in the program,
whenever possible. A function cannot be specialized to a certain datatype if the
function is not sufﬁciently generic (some of the arms for Unit, Prod, Sum, and
Zero are missing, or the function is not reﬂexive), if the datatype is abstract and
there is no explicit arm, or if the datatype is deﬁned in terms of a datatype to
which the function cannot be specialized.
However, we can do much better than that and generate only as many com-
ponents as needed to produce a consistent program. To this end, we simply let
the translation drive the generation of additional components. Whenever we spe-
cialize a generic application that requires a certain component of a type-indexed
185
11 Translation by Specialization
function to exist, we try to produce this component. The generation of a new
component and its translation might refer to yet other components and may thus
recursively cause new components to be generated. As long as all these gener-
ations succeed, everything is ﬁne. When one of the generations is not possible,
we report a specialization error. But we never generate a component that is not
required somewhere during the translation process. This process is guaranteed
to yield the smallest set of components that produces a correct program, and it is
guaranteed to terminate, because the “conservative” approach outlined above is
the worst case.
11.7 Discussion of translation by specialization
Translation by specialization has one central advantage: the type arguments are
eliminated from the code, and specialized instances are used on the different
types. For a non-generic type-indexed function, there is no performance over-
head, because at compile time, the specialized instances that are required at a call
site are determined and ﬁlled in.
Furthermore, the translation itself is reasonably simple and efﬁcient. As we
have seen, we can determine the set of additional components that is needed for
generic functions easily by essentially scanning the translated code for references
to components that do not yet exist and then providing them. One very important
point is that the specialization of calls to generic functions is compositional: com-
ponents are always generated for a combination of a type-indexed function and
a named type; calls to type expressions can be specialized in a way that the re-
sulting expression is constructed from such basic components. This is absolutely
essential to our approach, and enables to have an always terminating specializa-
tion algorithm, also for nested types or generic functions involving weird forms
of recursion.
A disadvantage of specialization is the fact that type-indexed functions are not
ﬁrst class. In our language, the name of a type-indexed function on its own is not
a legal expression – it may exclusively appear in the context of a generic applica-
tion. If ﬁrst class generic functions are allowed, it becomes harder to determine
which components are required and where they have to be used. Allowing a
more liberal use of type-indexed functions is the subject of ongoing and future
work.
Another disadvantage of the specialization approach is that the code for the
derived components of generic functions is not at all efﬁcient: values are con-
verted to isomorphic structural representations and back at runtime, everytime a
generic function is called, and possibly several times if the function is recursive –
and the vast majority of generic functions is recursive.
186
11.8 Other translation techniques
To obtain an efﬁcient program, it is therefore crucial to perform optimizations
on the generated code, where we can utilize the knowledge that we are indeed
only performing conversions of values between two isomorphic representations.
We have therefore implemented an experimental post-optimizer for the Generic
Haskell compiler that performs partial evaluation on the generated components,
thereby aggressively inlining and reducing all the conversions (de Vries 2004).
The generic programming extension in Clean makes use of a similar optimization
step (Alimarine and Smetsers 2004). These approaches show promising results: a
few programs are still difﬁcult to optimize, but for many examples, the resulting
code after optimization is very much like what one would have written by hand
as a specialized component for the generic function.
11.8 Other translation techniques
Translation by specialization is not the only possibility to handle type-indexed
functions. In this section we sketch two alternative techniques, and evaluate their
differences with the specialization approach.
11.8.1 Explicit type arguments and equality types
Cheney and Hinze (2002) developed a method of generic programming within
Haskell, using already available extensions. An important idea is that type equal-
ity can be expressed in Haskell as a datatype:
data Equal a b=Proof (∀f::∗→∗ .f a→f b).
The only possible value for this datatype – undeﬁned aside – is the identity func-
tion, therefore the existence of a value of type Equal a bconstitutes a proof that
aand bare the same type. It is possible to derive coercion functions of types
a→band b→afrom such a proof. This equality type has independently been
proposed by Baars and Swierstra (2002) in order to implement dynamic typing.
Cheney and Hinze describe an application of equality types to generic pro-
gramming: a datatype of type representations is deﬁned using equality types,
and type analysis can then proceed as an ordinary case construct. Generic func-
tions written in this style have to be augmented with several applications of co-
ercion functions that employ the proofs from the type representations to con-
vince the type system that certain types are equal. Furthermore, the automatic
translation of datatypes to their structural representations still requires manual
intervention by the programmer.
187
11 Translation by Specialization
If direct support for equality types would be added to the compiler (Hinze
2003; Cheney and Hinze 2003), the type coercions could be inferred automatically.
However, additional annotations are not as bad if the encoding is used as a
target language for Generic Haskell: both type coercions and the structural rep-
resentation could be automatically generated.
The examples of generic functions that are discussed in the mentioned pa-
pers are less expressive than what we need to handle the generic functions in
this thesis. In Section 6.6 we have explained that we translate generic functions
into functions that have a kind-indexed type. Interestingly, the approach can be
adapted to simulate kind-indexed types, following a joint idea of the author of
this thesis and Ralf Hinze: the datatype of type representations encodes the type
of the type-indexed function.
data Generic (f::∗→∗ ) (r::∗) =
Unit/prime(Equal r (fUnit ))
|∀(a::∗) (b::∗).Sum/prime(Equal r(f a→f b→f(Sum a b))
|∀(a::∗) (b::∗).Prod/prime(Equal r(f a→f b→f(Prod a b))
| Var r
|∀(a::∗) (b::∗).App (Generic f(a→b)) (Generic f a) (Equal r b)
|∀(a::∗) (b::∗).Lam (Generic f a→Generic f b) ( Equal r(a→b))
The type Generic (which makes use of “existentially” quantiﬁed type variables in
the syntax used by ghc) can be used in the type of a generic function, for example
enum :
type Enum/prime(a::∗) = [ a]
type Enum (r::∗) = Generic Enum/primer
enum ::∀r::∗. Enum r→r
The type Generic takes two type arguments. The ﬁrst one, for which we pass
Enum/prime, is the type of the type-indexed function, the second is used to determine
the type resulting from an application of the type-indexed function. The func-
tion enum takes a type representation as argument, and this type representation
determines the type of the result. If we assume that
reﬂ::∀a::∗. Equal a a
reﬂ=Proof id
and
unit =Unit/primereﬂ
sum =Sum/primereﬂ
prod =Prod/primereﬂ
188
11.8 Other translation techniques
app x 1x2=App x 1x2reﬂ
lam x =Lam x reﬂ ,
we have for instance that
enum (app(app sum unit )unit)::[Sum Unit Unit ].
The advantage of this translation of type-indexed functions is that in principle,
the result is a ﬁrst-class generic function. It is still parametrized by a type ar-
gument (encoded as a representation), and at the same time, it is an ordinary
Haskell function. First-class generic functions are desirable, because they allow
to parametrize generic functions with other generic functions.
The situation is, however, a bit more difﬁcult: the type Generic as deﬁned above
can only hold generic functions with signature {Unit, Sum, Prod}. If a function
needs an explicit deﬁnition for Int, the type Generic must be extended with a case
for Int:
|Int(Equal r(fInt)).
But type-indexed functions with different signatures require different datatypes,
and are therefore incompatible, even if they have otherwise the same type. Nev-
ertheless, we hope to pursue this approach further in the future and ﬁnd a way
to allow ﬁrst-class generic functions in Generic Haskell.
11.8.2 Type class encoding
Another idea for translating Generic Haskell is by encoding Dependency-style
Generic Haskell as directly as possible in the Haskell type class system, making
use of multi-parameter type classes with functional dependencies (Jones 2000).
Indeed, a type-indexed function such as enum can be encoded as a type class as
follows:
class Enum (n::∗) (a::∗)|n→awhere
enum ::n→[a]
We use the additional type parameter nto represent the type argument of the
generic function. For each case in the deﬁnition of enum , one instance is deﬁned.
For example, for Unit and Sum:
instance Enum DUnit Unit where
enum DUnit = [ Unit ]
189
11 Translation by Specialization
instance (Enum α a,
Enum β b)
⇒Enum (DSum α β) (Sum a b)where
enum (DSum α β) =interleave (map Inl (enum α))
(map Inr (enum β))
The fact that enum depends on itself is reﬂected in the constraints on the instance
declaration for Sum. A function that depends on more than one function would
need additional constraints on the instance declarations. We use αand βas
normal type variables here, because they play the role of dependency variables.
The types DUnit and DSum are used as names of the type Unit and Sum, which
can be used both on the type and on the value level. Their deﬁnition is
data DUnit =DUnit
data DSum a b=DSum a b
We now have
enum (DSum DUnit DUnit )::[Sum Unit Unit ],
and the expression evaluates to [InlUnit, InrUnit ].
Local redeﬁnition can be modelled by a local datatype and instance declaration.
Assuming a similar encoding for the generic function equal , we could encode our
example from Chapter 8,
letequal/angbracketleftα/angbracketright=equalCaseInsensitive
enum/angbracketleftα/angbracketright=enum/angbracketleftChar/angbracketright
inequal/angbracketleft[α]/angbracketright"laMBdA" "Lambda" ,
as
let data Dα=Dα
instance Equal DαChar where
equal D α=equalCaseInsensitive
instance Enum DαChar where
enum D α=enum DChar
inequal (DList D α)"laMBdA" "Lambda" .
Of course, Haskell does not allow local datatypes, nor local instances. But we can
lift both to the toplevel if we store the class methods in the datatype D α:
190
11.8 Other translation techniques
data Dαa=Dα(a→a→Bool ) [a]
instance Equal (Dαa)awhere
equal (Dαequalαenum α) =equalα
instance Enum (Dαa)awhere
enum (Dαequalαenum α) =enum α
letdα =Dαequalαenum α
equalα=equalCaseInsensitive
enum α=enum DChar
inequal (DList d α)"laMBdA" "Lambda" .
The idea to simulate named instances (Kahl and Scheffczyk 2001) via functional
dependencies, using datatypes as names, has been discussed in the Haskell com-
munity and been brought to the author’s attention by Peter Thiemann.
Encoding Generic Haskell with the help of type classes is interesting for sev-
eral reasons: ﬁrst, it makes the relation between type classes and generic pro-
gramming more obvious, and shows which features (such as local instances and
datatypes) are currently lacking from the class system to support generic pro-
gramming in the style of Generic Haskell with ease. Second, by reducing Generic
Haskell programs to type class programs, we can make use of results regarding
type inference for type classes. For instance, we can deﬁne variants of equal (or
other type-indexed functions) that can be used without passing a type argument,
by ﬁrst deﬁning
class DefaultInstance n a|a→n,n→awhere
di::n
with instances such as
instance DefaultInstance DUnit Unit where
di=DUnit
instance (DefaultInstance m a,DefaultInstance n b)
⇒DefaultInstance (DSum m n) (Sum a b)where
di=DSum di di .
After that, we can deﬁne
class Equal/primeawhere
equal/prime::a→a→Bool
instance (DefaultInstance n a,Equal n a)⇒Equal/primen awhere
equal/prime=equal (di::n),
and use equal/primeto let the compiler infer the type argument for equal . This solves
the inference problem for type arguments as discussed in Section 13.1.
191
11 Translation by Specialization
A third reason for a class encoding is that it allows us to easily combine ordi-
nary Haskell programs with generic programs. Generic Haskell could be used
as a compiler on parts of a program, producing a Haskell library which can then
be used by other programmers using an ordinary Haskell compiler that need not
be aware of generic functions. Such an approach has been realized for PolyP by
Norell and Jansson (2004). In the same paper, an application to Generic Haskell
based on kind-indexed types (cf. Section 6.6) has also been attempted, but the
Haskell class system turned out to be not very suitable to model functions with
kind-indexed types. The Dependency-style view seems to help here.
192
12 Generic Abstraction
In this chapter, we add a new possibility to deﬁne type-indexed functions. So far,
generic functions are functions deﬁned by means of a typecase construct. There
is no other way to deﬁne a type-indexed function. Every function that makes use
of another generic function must either itself be deﬁned via typecase , or be at
most parametrically polymorphic.
Generic abstraction has been used by Hinze since he started to work on generic
programming in Haskell (Hinze 1999 a), to deﬁne type-indexed functions in terms
of other type-indexed functions, in a mostly informal way. The term “generic
abstraction” was coined in the “Generic Haskell, speciﬁcally” paper (Clarke and
L¨oh 2003), where this technique of deﬁning new functions is one of the extensions
described. The description in that paper, although clearly deﬁned, makes use of
a very naive translation that can lead to non-terminating specializations in some
cases. The implementation that is presented in this chapter does not suffer from
this limitation and integrates smoothly with the dependency type system (L ¨oh
et al. 2003).
We motivate the use of generic abstractions in Section 12.1. Then we present
some further examples in Sections 12.2 and 12.3, before we discuss the imple-
193
12 Generic Abstraction
mentation of generic abstractions in Section 12.4. We discuss how to simulate
type-indexed functions with type indices of higher kinds using generic abstrac-
tions in 12.5, and how to generalize to generic abstractions over multiple type
arguments in Section 12.6.
12.1 Motivation
Let us recall one of the examples we used to demonstrate the power of local
redeﬁnition: the function size, deﬁned in Section 8.2. If applied to a constant type
argument, sizealways returns 0. But using local redeﬁnition, we can compute the
size of a data structure, for example the length of a list:
/parenleftbig
letsize/angbracketleftα::∗/angbracketright=const 1insize/angbracketleft[α]/angbracketright/parenrightbig[1, 2, 3, 4, 5 ]
evaluates to 5.
Likewise, we can count the number of labels in a tree: the expression
/parenleftbig
letsize/angbracketleftα::∗/angbracketright=const 1insize/angbracketleftTree α/angbracketright/parenrightbig(Node Leaf ’x’Leaf)
evaluates to 1.
If we need the sizes of lists and trees more often, it is also possible to capture
the computation in a function:
sizeList =letsize/angbracketleftα::∗/angbracketright=const 1insize/angbracketleft[α]/angbracketright
sizeTree =letsize/angbracketleftα::∗/angbracketright=const 1insize/angbracketleftTree α/angbracketright.
These functions are polymorphic – their types are
sizeList ::∀a::∗.[a]→Int
sizeTree ::∀a::∗. Tree a→Int .
They are, however, no longer type-indexed. The type argument of the generic
function sizehas irrevocably been instantiated, once to [α], once to Tree α, and
what remains is an ordinary function. In fact, we can write
letsize/angbracketleftα::∗/angbracketright=const 1insize/angbracketleftfα/angbracketright
foranyfunctor fof kind∗→∗ , but there is no way to capture this expression as
a function, without binding fto one concrete type at the same time.
Generic abstraction lifts this limitation. We can deﬁne
fsize/angbracketleftγ::∗→∗/angbracketright =letsize/angbracketleftα::∗/angbracketright=const 1insize/angbracketleftγ α/angbracketright,
194
12.1 Motivation
and we can then use fsize/angbracketleft[ ]/angbracketrightand fsize/angbracketleftTree/angbracketrightinstead of being forced to deﬁne
specialized versions such as sizeList and sizeTree . The feature is called generic
abstraction because it allows us to abstract from the type argument represented
byγin the deﬁnition of fsize. Using generic abstraction, we can thus deﬁne
functions that depend on a type argument, but are not deﬁned using a typecase .
Note that fsize cannot be parametrically polymorphic in its type argument γ,
because sizeis not parametrically polymorphic in its type argument.
A speciality in the deﬁnition of fsize immediately catches the eye: the type
argument between the type parentheses /angbracketleft·/angbracketrightis of kind∗→∗ here. The type argu-
ment used in generic abstractions is not restricted to kind ∗. Functions deﬁned
via generic abstraction are thus different from ordinary type-indexed functions
in some respects, but of course, they also have type signatures. This is the type
signature for fsize:
fsize/angbracketleftf::∗→∗| a::∗/angbracketright::(size/angbracketleftf/angbracketright)⇒f a→Int .
The function has one generic type parameter fof kind∗ → ∗ , and one non-
generic type parameter aof kind∗, because fsize is polymorphic in the element
type of the data structure. There is a dependency on size, but not on itself. Func-
tions deﬁned by generic abstraction never depend on themselves. Only type-
indexed functions deﬁned by a typecase occur in dependency constraint sets. We
will discuss the type signatures of functions deﬁned by generic abstraction in
Section 12.4.
Another typical example for the use of generic abstraction arises if we want to
generically deﬁne zipin terms of zipWith (cf. page 136):
zip/angbracketleftf::∗→∗| a::∗,b::∗/angbracketright::(zipWith/angbracketleftf,f,f/angbracketright)⇒f a→f b→f(a,b)
zip/angbracketleftγ::∗→∗/angbracketright =zipWith/angbracketleftγ/angbracketright(,).
Here, we have made use of the short notation (deﬁned in Section 8.3) for zipWith .
The function zipWith had a type of arity /angbracketleft3|0/angbracketright, hence the three type variables in
the dependency.
The use of generic abstraction is not conﬁned to type arguments of kind ∗→∗ .
An example of a kind ∗generic abstraction is the function card, which determines
the cardinality of a datatype:
card/angbracketlefta::∗/angbracketright::(enum/angbracketlefta/angbracketright)⇒Int
card/angbracketleftα::∗/angbracketright=fsize/angbracketleft[ ]/angbracketright(enum/angbracketleftα/angbracketright).
We ﬁrst enumerate the datatype in question, and then apply fsize to determine
the number of elements in the resulting list (of course, we could have used the
standard list function length just as well, but that would not serve as an example
195
12 Generic Abstraction
of generic abstraction). This function will only terminate for ﬁnite datatypes (we
will deﬁne a variant of card that can detect inﬁnite datatypes in Section 17.1.3).
This example demonstrates that there is no problem in reusing one function that
is deﬁned by generic abstraction ( fsize) in another. The dependency of fsize on
sizedoes not propagate to card, because fsize is used here on a constant type
constructor.
Another example where we could already have used generic abstraction is the
deﬁnition of decodes : the counterpart to encode , to retrieve a typed value from a
list of bits, has type
decodes/angbracketlefta::∗/angbracketright::(decodes/angbracketlefta/angbracketright)⇒[Bit]→[(a,[Bit])]
The result type contains the possibility for failure (empty list), and can store a
remaining part of the input. This is necessary for the recursive calls of decodes ,
but does not mirror the type of encode , which is
encode/angbracketlefta::∗/angbracketright::(encode/angbracketlefta/angbracketright)⇒a→[Bit].
Using, generic abstraction, we can now deﬁne a proper inverse for encode , named
decode :
decode/angbracketlefta::∗/angbracketright::(decodes/angbracketlefta/angbracketright)⇒[Bit]→a
decode/angbracketleftα::∗/angbracketrightx=case decodes/angbracketleftα/angbracketrightxof
[(y,[ ])]→y
→error "no parse" .
For a value xof type t, we have
(decode/angbracketleftt/angbracketright·encode/angbracketleftt/angbracketright)x≡x,
provided there is no specialization error.
12.2 Generic reductions
A very large class of useful generic operations – including sizeand collect – can be
expressed in terms of reduce via generic abstraction. The function reduce is deﬁned
normally, using a case analysis on the type argument, and takes a (supposedly)
neutral element eand a binary operator ⊕as arguments.
reduce/angbracketlefta::∗|c::∗/angbracketright::(reduce/angbracketlefta|c/angbracketright⇒ c→(c→c→c)→a→c
reduce/angbracketleftInt/angbracketright e(⊕)x =e
reduce/angbracketleftChar/angbracketright e(⊕)x =e
196
12.2 Generic reductions
reduce/angbracketleftFloat/angbracketright e(⊕)x =e
reduce/angbracketleftUnit/angbracketright e(⊕)Unit =e
reduce/angbracketleftSum α β/angbracketrighte(⊕) (Inl x ) = reduce/angbracketleftα/angbracketrighte(⊕)x
reduce/angbracketleftSum α β/angbracketrighte(⊕) (Inr x ) = reduce/angbracketleftβ/angbracketrighte(⊕)x
reduce/angbracketleftProd α β/angbracketrighte(⊕) (x×y) =reduce/angbracketleftα/angbracketrighte(⊕)x⊕reduce/angbracketleftβ/angbracketrighte(⊕)y.
All constant types are replaced by e. We descend into sums in both directions,
and combine the two partial results in a product using ⊕.
Using reduce, we can now deﬁne:
collect/angbracketlefta::∗|c::∗/angbracketright::(reduce/angbracketlefta|[c]/angbracketright)⇒a→[c]
collect/angbracketleftα::∗/angbracketright =reduce/angbracketleftα/angbracketright[ ] (+ +)
size/angbracketlefta::∗/angbracketright ::(reduce/angbracketlefta|Int/angbracketright)⇒a→Int
size/angbracketleftα::∗/angbracketright =reduce/angbracketleftα/angbracketright0 (+)
conj/angbracketlefta::∗/angbracketright ::(reduce/angbracketlefta|Bool/angbracketright)⇒a→Bool
conj/angbracketleftα::∗/angbracketright =reduce/angbracketleftα/angbracketrightTrue (∧)
disj/angbracketlefta::∗/angbracketright ::(reduce/angbracketlefta|Bool/angbracketright)⇒a→Bool
disj/angbracketleftα::∗/angbracketright =reduce/angbracketleftα/angbracketrightFalse (∨)
The thus deﬁned functions collect and sizeare similar, but not identical to the
stand-alone versions. They are still most valuable when used on a non-constant
type argument, in the context of a local redeﬁnition. But these versions all depend
onreduce rather than on themselves! To compute the size of a list, one now needs
to write
letreduce/angbracketleftα/angbracketrighte(⊕)x=1insize/angbracketleft[α]/angbracketright.
The short notation that has been introduced in Section 8.3 can without any prob-
lems be extended slightly such that it works for any function that has exactly one
dependency (instead of being restricted to functions that depend on only itself),
and we can alternatively write
size/angbracketleft[ ]/angbracketright(λe(⊕)x→1)
to express the same: the dependency on reduce is supplied as a positional argu-
ment to size, using an anonymous function that ignores its three arguments and
returns 1.
A reimplementation of fsize that works for any type constructor of kind ∗→∗
can be arranged via either of
fsize/angbracketleftγ::∗→∗/angbracketright =reduce/angbracketleftγ/angbracketright(λe(⊕)x→1)0(+)
fsize/angbracketleftγ::∗→∗/angbracketright =size/angbracketleftγ/angbracketright(λe(⊕)x→1),
again employing short notation in both variants.
197
12 Generic Abstraction
Similarly, the functions conj and disjdeﬁned above can be a foundation for the
deﬁnition of generic versions of Haskell’s list functions and,or,any, and all:
and/angbracketleftf::∗→∗/angbracketright ::(reduce/angbracketleftf|Bool/angbracketright)⇒fBool→Bool
and/angbracketleftγ::∗→∗/angbracketright =conj/angbracketleftγ/angbracketright(λe(⊕)x→x)
or/angbracketleftf::∗→∗/angbracketright ::(reduce/angbracketleftf|Bool/angbracketright)⇒fBool→Bool
or/angbracketleftγ::∗→∗/angbracketright =disj/angbracketleftγ/angbracketright(λe(⊕)x→x)
all/angbracketleftf::∗→∗| a::∗/angbracketright::(reduce/angbracketleftf|Bool/angbracketright)⇒(a→Bool )→f a→Bool
all/angbracketleftγ::∗→∗/angbracketright p =conj/angbracketleftγ/angbracketright(λe(⊕)x→p x)
any/angbracketleftf::∗→∗| a::∗/angbracketright::(reduce/angbracketleftf|Bool/angbracketright)⇒(a→Bool )→f a→Bool
any/angbracketleftγ::∗→∗/angbracketright p =disj/angbracketleftγ/angbracketright(λe(⊕)x→p x).
Yet more instances of reduce are the generalization of list concatenation concat ,
the ﬂattening of a data structure into a list ﬂatten , and a function compose that can
compose a data structure containing functions into one function.
concat/angbracketleftf::∗→∗| a::∗/angbracketright::(reduce/angbracketleftf|[a]/angbracketright)⇒f[a]→[a]
concat/angbracketleftγ::∗→∗/angbracketright =collect/angbracketleftγ/angbracketrightid
ﬂatten/angbracketleftf::∗→∗| a::∗/angbracketright::(reduce/angbracketleftf|[a]/angbracketright)⇒f a→[a]
ﬂatten/angbracketleftγ::∗→∗/angbracketright =collect/angbracketleftγ/angbracketright(λx→[x])
compose/angbracketleftf::∗→∗| a::∗/angbracketright::(reduce/angbracketleftf|a→a/angbracketright)⇒f(a→a)→(a→a)
compose/angbracketleftγ::∗→∗/angbracketright =reduce/angbracketleftγ/angbracketright(λe(⊕)x→x)id(·).
12.3 Cata- and anamorphisms
If we have a representation of a datatype with explicit ﬁxpoints, using the ﬁxpoint
datatype
data Fix(a::∗→∗ ) =In(a(Fixa)),
we can express catamorphisms and anamorphisms – their list variants are better
known as foldand unfold in the Haskell world – on that datatype using generic
abstraction over the generic map function.
Assume that outis deﬁned as follows:
out(In x) =x.
Then cataand anaare deﬁned by:
cata/angbracketleftf::∗→∗| a::∗/angbracketright::(map/angbracketleftf,f/angbracketright)⇒(f a→a)→Fixf→a
ana/angbracketleftf::∗→∗| a::∗/angbracketright::(map/angbracketleftf,f/angbracketright)⇒(a→f a)→a→Fixf
198
12.3 Cata- and anamorphisms
cata/angbracketleftγ::∗→∗/angbracketright alg =alg·map/angbracketleftγ/angbracketright(cata/angbracketleftγ/angbracketrightalg)·out
ana/angbracketleftγ::∗→∗/angbracketright coalg =In·map/angbracketleftγ/angbracketright(ana/angbracketleftγ/angbracketrightcoalg )·coalg .
The occurrences of cata/angbracketleftγ/angbracketrightand ana/angbracketleftγ/angbracketrighton the right hand side do not trigger
dependencies – they denote ordinary recursion. The function catacould as well
have been implemented via
cata/angbracketleftγ::∗→∗/angbracketright =letf alg =alg·map/angbracketleftγ/angbracketright(f alg )·outinf
instead.
If we want to use these functions on a recursive datatype, we ﬁrst have to deﬁne
the datatype in terms of Fix. For example, the datatype of lists can isomorphically
be deﬁned as:
type List (a::∗) = Fix(ListF a)
data ListF (a::∗) (r::∗) =NilF|ConsF a r .
The datatype ListF is also called the pattern functor of List (hence the “F” in the
names).
The type of built-in lists is isomorphic to the type List. We can deﬁne an
embedding-projection pair that holds isomorphisms:
epList ::∀a::∗. EP (Lista) [a]
epList =letfromList (In NilF ) = [ ]
fromList (In(ConsF x r )) = x:fromList r
toList [ ] = In NilF
toList (x:xs) = In(ConsF x (toList xs ))
inEP fromList toList .
The ListF type is not recursive, but in turn, the conversion functions are. This
is different from the standard view on datatypes discussed in Chapter 10, where
the structural representation of a recursive datatype is not directly recursive, but
still refers to the original datatype.
On the list datatype, viewed as a ﬁxpoint, we can deﬁne all the classical cata-
morphisms. Many of those can be expressed as reductions (cf. Section 12.2), but
there are some that cannot, for instance:
reverse ::∀a::∗.(Lista)→[a]
reverse =letreverseAlg NilF = [ ]
reverseAlg (ConsF x r ) = r+ + [x]
incata/angbracketleftListF/angbracketrightreverseAlg .
199
12 Generic Abstraction
sublists ::∀a::∗.(Lista)→[[a]]
sublists =letsublistsAlg NilF = [ ]
sublistsAlg (ConsF x r ) =map/angbracketleft[ ]/angbracketright(x:)r+ +r
incata/angbracketleftListF/angbracketrightsublistsAlg .
Using the embedding-projection pair, we can explicitly specify the relation with
the prelude function foldr:
foldr ::∀(a::∗) (b::∗).(a→b→b)→b→[a]→b
foldr (⊕)e xs=letalg NilF =e
alg(ConsF x r ) =x⊕r
incata/angbracketleft[ ]/angbracketrightalg(to epList xs )
Hinze (1999 b) presents catamorphisms and anamorphisms in the way just de-
scribed, using an explicit representation of datatypes based on the Fix type con-
structor. In PolyP (Jansson and Jeuring 1997), catamorphisms can be represented
as generic functions more directly, because generic functions are deﬁned on func-
tors of kind∗→∗ in PolyP, and the computation of the pattern functor is per-
formed automatically by the compiler. We discuss a similar approach in Sec-
tion 17.2.
12.4 Types and translation of generic abstractions
Functions deﬁned via generic abstraction have type signatures that are almost like
type signatures of ordinary type-indexed functions. As a slight generalization,
generic type variables are not restricted to kind ∗. We have seen several examples
for functions where the generic arguments were of kind ∗→∗ instead, among
them
and/angbracketleftf::∗→∗/angbracketright ::(reduce/angbracketleftf|Bool/angbracketright)⇒fBool→Bool
cata/angbracketleftf::∗→∗| a::∗/angbracketright::(map/angbracketleftf,f/angbracketright)⇒(f a→a)→Fixf→a.
Obviously, the generic type variables may be used in the dependencies, even
though both reduce and map – as ordinary type-indexed functions deﬁned via a
typecase – normally take generic variables of kind ∗. A generic abstraction itself
never appears in dependency constraints.
In Figure 12.1, we present the syntax extensions necessary to cover generic
abstractions in our language. We call the extended language fcr+gf+gabs. We
introduce a new form of value declaration to deﬁne a function via generic ab-
straction. It is syntactically distinguished from local redeﬁnition by the kind
annotation in the type argument (we keep the kind annotation not only in the
200
12.4 Types and translation of generic abstractions
Value declarations
d::=. . . everything from Figures 4.1 and 8.3
|x/angbracketleftα::κ/angbracketright=e generic abstraction
Type tuple patterns
π::={ai::κ}i∈1..r
,|{bj::κj}j∈1..s
,
type tuple pattern
Figure 12.1: Core language with generic abstraction fcr+gf+gabs, extends language
fcr+gf in Figures 9.4, 8.3, 6.1, 4.1, and 3.1
type signature mainly for this reason, but also to emphasize that generic abstrac-
tions can be for type arguments of higher kind). Furthermore, we generalize the
syntax of type tuple patterns to allow generic type variables to be of arbitrary
kind. Note, though, that all generic type variables must still be of the same kind.
The kind checking rules for type and type argument tuples in Figure 9.5 have
been formulated in such a way that they can directly deal with the more general
situation.
K;Γ;Σ/turnstilelefttpsigx/angbracketleftπ/angbracketright::σ
/braceleftbig
K;Γ;Σ/turnstilelefttpsigyk/angbracketleftπk/angbracketright::({zk,i/angbracketleftϑk,i/angbracketright}i∈1..mk, )⇒tk/bracerightbigk∈1..n
/braceleftbig
yk/angbracketleftAbs/angbracketright/∈Σ/bracerightbigk∈1..n /braceleftbig{zk,i∈{yj}j∈1..n
,}i∈1..mk/bracerightbigk∈1..n
K∗≡K{,ai::∗}i∈1..r{,bj::κj}j∈1..s
K/prime≡K{,ai::κ}i∈1..r{,bj::κj}j∈1..s
/braceleftBig/braceleftbig{zk,i≡yj=⇒K∗,πk/turnstileleftϑk,i/lessorequalslantϑk}j∈1..n/bracerightbigi∈1..mk/bracerightBigk∈1..n
K/prime/turnstileleftt::∗/braceleftbig
K∗/turnstileleftϑk::πk/bracerightbigk∈1..n /braceleftbig/turnstileleftϑk↓/bracerightbigk∈1..n
K;Γ;Σ/turnstilelefttpsigx/angbracketleftbig{ai::κ}i∈1..r
,|{bj::κj}j∈1..s
,/angbracketrightbig
::/parenleftbig{yk/angbracketleftϑk/angbracketright}k∈1..n
, )⇒t/parenrightbig(typesig-m)
Figure 12.2: Well-formedness of type signatures for type-indexed functions including
generic abstractions, replaces Figure 9.11
The rule (typesig-m) to check well-formedness of type signatures of type-
indexed functions, needs to be adapted. The changed rule, which we still call
(typesig-m), is shown in Figure 12.2. As it stands now, it works for type signa-
201
12 Generic Abstraction
tures of all type-indexed functions, whether they are deﬁned using a typecase
or generic abstraction. There are a couple of differences with the old rule: we
require that functions deﬁned via generic abstractions never appear in the de-
pendencies of a type-indexed function. We use the statement x/angbracketleftAbs/angbracketright/∈Σto
express that xis not deﬁned via generic abstraction, for reasons that will become
clear soon. This condition requires that the judgment is extended to take the
signature environment Σas additional input.
In addition to that, we extend the kind environment K twice in the new rule:
once, for K/prime, we add the generic and non-generic type variables with the kinds
declared in the type tuple pattern (where we now allow any kind for the generic
variables); and once, in K ∗, we add the non-generic type variables with their
declared kinds, but the generic type variables with kind ∗. We then use K/primeto
kind check the base type t, but K∗to kind check the type tuples that go with the
dependencies.
The translation of generic abstractions is simple: a generic abstraction xis
translated to a single component, which is called cp(x,Abs). The identiﬁer Abs
denotes a special type name that cannot occur in user-written programs, and
we treat any occurrence of x/angbracketleftA/angbracketrightas if it were the call x/angbracketleftAbsA/angbracketright. For a generic
abstraction of form x/angbracketleftα::κ/angbracketright=e, we assume that Abs is of kind κ→ ∗ –
this corresponds to the fact that we treat generic type variables as kind ∗in the
dependencies.
The rule to check and translate a generic abstraction is rule (d/tr-gabs) in Fig-
ure 12.3 and is analogous to the rule (d/tr-tif) for a type-indexed function, only
that it is simpler because there is only one arm to check. There are two rules
now to type check and translate generic applications, also shown in Figure 12.3.
One, (e/tr-genapp), is just like the former, with the additional condition that
x/angbracketleftAbs/angbracketright/∈Σ, which serves to verify that xis not deﬁned by generic abstraction.
The other, (e/tr-genapp-gabs), is for generic abstractions and performs the con-
version of the type argument AtoAbsA.
The only additional modiﬁcation we then need is in the mbase function, where
we ignore occurrences of Absin the head of the generic slots – this corresponds
to the fact that we use generic type variables with their declared kind in the
base type. The modiﬁed base type judgments are shown in Figure 12.4. The
generic application algorithm gapp now falls back on the thus modiﬁed base
type function, and can be used without modiﬁcation. Neither is the translation
algorithm /llbracket·/rrbracketgtransin need of change: because Absis syntactically a type name, its
appearance as the head of a type argument for the generic abstraction xcauses a
reference to cp(x,Abs)to appear in the translation.
Let us conclude this section with a few examples. Recall the function fsize from
Section 12.1, which computes the size of a container type of kind ∗→∗ . With
202
12.4 Types and translation of generic abstractions
/llbracketdfcr+gf+gabs/squigglerightK2;Γ2;∆2;Σ2/rrbracketgabs
K1;Γ1;∆1;Σ1≡{dfcr}i∈1..n
;
K;Γ/turnstilelefttpsigx/angbracketleftπ/angbracketright::σ
K/prime≡K,α::κ,Abs::κ→∗ Γ/prime≡x/angbracketleftπ/angbracketright::σΣ/prime≡x/angbracketleftAbs/angbracketright
gappK/prime;Γ,Γ/prime(x/angbracketleftAbsα/angbracketright)≡q∆/turnstileleftq/prime/lessorequalslantq/squigglerighte/prime/prime[•]
/llbrackete::q/prime/rrbracketgabs
K/prime;Γ;∆;Σ≡e/prime
/largellbracket
x/angbracketleftα::κ/angbracketright=e/squigglerightε;Γ/prime;ε;Σ/prime/largerrbracketgabs
K;Γ;∆;Σ≡cp(x,Abs) =e/prime/prime[e/prime](d/tr-gabs)
/llbracketefcr+gf+gabs::tfcr+gf+gabs/rrbracketgabs
K;Γ;∆;Σ≡efcr
x/angbracketleftAbs/angbracketright/∈Σ
K/turnstileleftA::∗
gappK;Γ(x/angbracketleftA/angbracketright)≡q /llbracketx/angbracketleftA/angbracketright/rrbracketgtrans
K;Γ;Σ≡e
K;∆/turnstileleftq/lessorequalslantt
/llbracketx/angbracketleftA/angbracketright::t/rrbracketgabs
K;Γ;∆;Σ≡e(e/tr-genapp)
x/angbracketleftAbs/angbracketright∈Σ
K;Γ/turnstilelefttpsigx/angbracketleft{ai::κ}i∈1..r
,|{bj::κj}j∈1..r
,/angbracketright::σ
K/turnstileleftA::κ K/prime≡K,Abs::κ→∗
gappK;Γ(x/angbracketleftAbsA/angbracketright)≡q /llbracketx/angbracketleftAbsA/angbracketright/rrbracketgtrans
K/prime;Γ;Σ≡e
K;∆/turnstileleftq/lessorequalslantt
/llbracketx/angbracketleftA/angbracketright::t/rrbracketgabs
K;Γ;∆;Σ≡e(e/tr-genapp-gabs)
Figure 12.3: Translation of generic abstractions to fcr
203
12 Generic Abstraction
mbase K;Γ(x/angbracketleftΘ/angbracketright)≡t
Θ≡{Ai}i∈1..r
,|{tj}j∈1..s
,{head (Ai)/negationslash≡Abs}i∈1..r
x/angbracketleftπ/angbracketright::({yk/angbracketleftϑk/angbracketright}k∈1..n
, )⇒t∈Γ
K/turnstileleftpatΘ::π/squigglerightϕ
mbase K;Γ(x/angbracketleftΘ/angbracketright)≡ϕt(base-m)
Θ≡{AbsAi}i∈1..r
,|{tj}j∈1..s
, Θ/prime≡{Ai}i∈1..r
,|{tj}j∈1..s
,
x/angbracketleftπ/angbracketright::({yk/angbracketleftϑk/angbracketright}k∈1..n
, )⇒t∈Γ
K/turnstileleftpatΘ/prime::π/squigglerightϕ
mbase K;Γ(x/angbracketleftΘ/angbracketright)≡ϕt(base-m-gabs)
Figure 12.4: Modiﬁed base type judgment for fcr+gf+gabs, replaces Figure 9.9
type signature, the function can be deﬁned as follows:
fsize/angbracketleftf::∗→∗| a::∗/angbracketright::(size/angbracketleftf/angbracketright)⇒f a→Int .
fsize/angbracketleftγ::∗→∗/angbracketright =letsize/angbracketleftα::∗/angbracketright=const 1
insize/angbracketleftγ α/angbracketright.
We have one generic slot f, of kind∗→∗ , and one non-generic variable aof
kind∗, which represents the element type of the underlying data structure, in
which fsize is polymorphic. The translation of the function, according to the rules
given above, is
cp(fsize,Abs)cp(fsize,γ) =letcp(size,α) = const 1
in(cp(size,γ)) (cp(size,α)).
If the function fsize is called on a type argument containing dependency variables,
the generic application algorithm can be used to derive a type for such a call as in
rule (e/tr-genapp-gabs). We show some of the resulting qualiﬁed types if fsize is
applied to type arguments of different shapes in Figure 12.5. The type argument
Ais supposed to contain no dependency variables in all the examples.
The function fsize can be used in the same way as any other type-indexed
function – it can occur on the right hand side of deﬁnitions of other type-indexed
functions, and it can be used with dependency variables in the type argument to
create dependencies that can be locally redeﬁned, and it is even possible to use
short notation with a function such as fsize.
204
12.5 Type indices of higher kind
fsize/angbracketleftA::∗→∗/angbracketright ::∀a::∗.A a→Int
fsize/angbracketleftA(β::∗)::∗→∗/angbracketright ::∀(a::∗) (b::∗).
(size/angbracketleftβ/angbracketright::b→Int)
⇒A b a→Int
fsize/angbracketleftA(β::∗) (γ::∗)::∗→∗/angbracketright ::∀(a::∗) (b::∗) (c::∗).
(size/angbracketleftβ/angbracketright::b→Int,
size/angbracketleftγ/angbracketright::c→Int)
⇒A b c a→Int
fsize/angbracketleftA(β::∗→∗ )::∗→∗/angbracketright ::∀(a::∗) (b::∗→∗ ).
(size/angbracketleftβ γ/angbracketright::∀c::∗.
(size/angbracketleftγ/angbracketright::c→Int)
⇒b c→Int)
⇒A b a→Int
Figure 12.5: Types for generic applications of fsize to type arguments of different form
Here are two other examples for translations of generic abstractions. The conj
function
conj/angbracketlefta::∗/angbracketright ::(reduce/angbracketlefta|Bool/angbracketright)⇒a→Bool
conj/angbracketleftα::∗/angbracketright =reduce/angbracketleftα/angbracketrightTrue (∧)
translates to
cp(conj,Abs)cp(reduce ,α) =cp(reduce ,α)True (∧),
and the catafunction
cata/angbracketleftf::∗→∗| a::∗/angbracketright::(map/angbracketleftf,f/angbracketright)⇒(f a→a)→Fixf→a
cata/angbracketleftγ::∗→∗/angbracketright alg =alg·map/angbracketleftγ/angbracketright(cata/angbracketleftγ/angbracketright alg)·out
becomes
cp(cata,Abs)cp(map,γ)alg
=alg·cp(map,γ) (cp(cata,Abs)cp(map,γ)alg)·out
Note how the recursive call to cata/angbracketleftγ/angbracketrightcan be translated without cata being re-
ﬂexive, i.e., without catahaving a dependency on itself.
12.5 Type indices of higher kind
Generic abstraction allows us to deﬁne type-indexed functions that are indexed
by a type argument that is not of kind ∗. In the literature on generic functions,
205
12 Generic Abstraction
there are many examples of type-indexed functions that are deﬁned via a type-
case, but indexed by a type argument of higher kind. For example, in Hinze’s
popl paper (2000 b), one ﬁnds map deﬁned as follows:
map/angbracketleftf::∗→∗/angbracketright ::∀c1c2.(c1→c2)→f c1→f c2
map/angbracketleftK Char/angbracketright f x =x
map/angbracketleftK Int/angbracketright f x =x
map/angbracketleftK Unit/angbracketright f x =x
map/angbracketleftId/angbracketright f(Id x) = Id(f x)
map/angbracketleftLSum α β/angbracketrightf(LInl x ) = map/angbracketleftα/angbracketrightf x
map/angbracketleftLSum α β/angbracketrightf(LInr x ) = map/angbracketleftβ/angbracketrightf x
map/angbracketleftLProd α β/angbracketrightf(x1⊗x2) =map/angbracketleftα/angbracketrightf x1⊗map/angbracketleftβ/angbracketrightf x2
Note that we use a completely different set of type constructors to deﬁne the
function, all of them of kind ∗→∗ , and basically lifted versions of the usual
representation types:
data K(a::∗) (b::∗) = K a
data Id(a::∗) = Id a
data LSum (a::∗→∗ ) (b::∗→∗ ) (c::∗) =LInl (a c)|LInr (b c)
data LProd (a::∗→∗ ) (b::∗→∗ ) (c::∗) =a c⊗b c
We use⊗as an inﬁx data constructor, the lifted version of ×. With these deﬁni-
tions in place, K tcan be used to lift any type of kind ∗, among them Unit. The
types LSum and LProd are lifted versions of Sum and Prod, respectively. Only Id
is really new.
In Hinze’s setting, map, when deﬁned in this form, is limited to kind ∗→∗ .
No use of type arguments of other kind or local redeﬁnition is possible.
It is straightforward to translate the above deﬁnition – and, in fact, any deﬁni-
tion on such lifted type constructors – into a kind ∗deﬁnition, augmented by a
generic abstraction:
map/prime/angbracketlefta1::∗,a2::∗|c1::∗,c2::∗/angbracketright::(map/prime/angbracketlefta1,a2|c1,c2/angbracketright)
⇒(c1→c2)→a1→a2
map/prime/angbracketleftChar/angbracketright f x =x
map/prime/angbracketleftInt/angbracketright f x =x
map/prime/angbracketleftUnit/angbracketright f x =x
map/prime/angbracketleftSum α β/angbracketrightf(Inl x ) = map/prime/angbracketleftα/angbracketrightf x
map/prime/angbracketleftSum α β/angbracketrightf(Inr x ) = map/prime/angbracketleftβ/angbracketrightf x
map/prime/angbracketleftProd α β/angbracketrightf(x1×x2) =map/prime/angbracketleftα/angbracketrightf x1×map/prime/angbracketleftβ/angbracketrightf x2
mapId f x =f x
206
12.6 Multiple type arguments
map/angbracketleftf::∗→∗| c1::∗,c2::∗/angbracketright::(map/prime/angbracketleftf,f|c1,c2/angbracketright)
⇒(c1→c2)→f c1→f c2
map/angbracketleftγ::∗→∗/angbracketright f x =letmap/prime/angbracketleftα/angbracketright=mapId
inmap/prime/angbracketleftγ α/angbracketrightf x
For each case but Id, we have a direct corresponding case for the unlifted version
of the type. The identity case can be deﬁned as a separate function, here mapId ,
that is subsequently plugged into the locally redeﬁned element position αof the
type argument γinmap, that is deﬁned via generic abstraction.
The rewritten version of map has the advantage that we can apply short nota-
tion to apply it to type arguments of arbitrary kind, or, more generally, that we
can use local redeﬁnition to modify its behaviour. This version of mapdiffers from
themap that we have deﬁned in Section 9.1 only in the presence of the function
argument fthat is passed everywhere. A closer look reveals that it is indeed not
needed anywhere but in mapId , and thus can be optimized away.
12.6 Multiple type arguments
In the general case, type-indexed functions with multiple type arguments are
not a trivial extension. The reason is that for multiple type arguments, we get
an explosion of dependencies: for one type argument, we need one dependency
constraint per function we depend on and dependency variable. With two type
arguments, we already have one per function and pair of dependency variables.
For instance, poly/angbracketleftSum α1β1/angbracketright/angbracketleftSum α2β2/angbracketrightcould – because four dependency
variables occur – depend up to 42≡16 times on poly.
Allowing different dependencies for each case in a type-indexed function deﬁ-
nition could help, but would be a signiﬁcant change of the theory and make the
type system yet more complex. The exact implications of such an approach are
future work.
Perhaps surprisingly, though, multiple type arguments are easy to allow for
functions deﬁned using generic abstraction. The reason is that generic abstrac-
tions do not occur in dependency constraints, hence there is no combinatorial
explosion of dependencies.
The following function deﬁnes a generic variant of the standard list function
elem that determines whether an element is contained in a data structure.
elem/angbracketlefta::∗/angbracketright/angbracketleftf::∗→∗/angbracketright ::(enum/angbracketlefta/angbracketright,equal/angbracketlefta/angbracketright,reduce/angbracketleftf|Bool/angbracketright)
⇒a→f a→Bool
elem/angbracketleftα::∗/angbracketright/angbracketleftγ::∗→∗/angbracketright x=any/angbracketleftγ/angbracketright(equal/angbracketleftα/angbracketrightx)
207
12 Generic Abstraction
We must be able to apply reduce to the data structure, because we use anyin
the implementation of the function, and anyis deﬁned via generic abstraction
over reduce . The function anytakes a predicate and checks if the predicate holds
for at least one element in the structure. As predicate, we take the partially
applied equal function.
The translation is simple to adapt. For elem, we get
cp(elem,Abs)cp(enum ,α)cp(equal ,α)cp(reduce ,γ)x=
cp(any,Abs)cp(reduce ,γ) (cp(equal ,α)x).
208
13 Type Inference
So far in this thesis, we have completely ignored type inference. We have as-
sumed completely type-annotated programs and have only presented rules that
can check programs to be type correct. For practical programming, this is, how-
ever, inadequate. One of the great strengths of Haskell is that, as it is based on
the Hindley-Milner type system (Hindley 1969; Milner 1978), type annotations
are rarely required.
Even in standard Haskell we sometimes need type signatures: for polymor-
phic recursion, to circumvent the dreaded monomorphism restriction, or for the
methods of type classes, we have to explicitly specify a signature to give the
type checker a nudge into the right direction. If arbitrary-rank polymorphic
types (Peyton Jones and Shields 2003) are allowed, then functions involving such
types need explicit annotations as well.
Therefore, one option to tackle the type inference of type-indexed functions is
simply not to do it. Type-indexed functions have mandatory type signatures, and
so do functions deﬁned via generic abstraction. At the call sites of type-indexed
functions, we always pass an explicit type argument anyway. At all other places,
we can use ordinary Haskell type inference and do not have to annotate. This is
209
13 Type Inference
a simple and pragmatic solution that works. Generic functions are deﬁned once
and used often, thus the overhead of giving a type signature during deﬁnition
seems bearable.
On the other hand, the presence of dependencies makes type signatures of
type-indexed functions nontrivial, because the theory of dependencies must be
known to the programmer. Furthermore, the requirement that type arguments
must be passed at the call sites of generic functions is annoying. It is, for example,
much more pleasant to use a class method, where the compiler usually infers the
instances to use.
In this chapter, we distinguish and formulate a number of different inference
problems in the context of Generic Haskell, and relate them to other problems or
sketch how they might be solved.
In Section 13.1, we will discuss inference of type arguments of type-indexed
functions, so that we can, for example, write equal 4 2 instead of equal/angbracketleftInt/angbracketright4 2. In
Section 13.2, we will discuss how dependencies of type-indexed functions could
be inferred automatically. This would simplify the type signatures that the pro-
grammer has to provide and make it easier to start with generic programming
because one does not have to delve into the theory of dependencies before doing
so. Last, in Section 13.3 we look into possibilities for inferring the base type of
a type-indexed function. If both dependency inference and inference of the base
type were possible, no explicit type signatures for type-indexed functions would
be needed at all. However, base type inference turns out to be difﬁcult, because
in general, there is no such thing as a principal type for a type-indexed function.
13.1 Type inference of type arguments
In all languages that we have introduced, generic application – the application of
a type-indexed function to a type argument – is explicit: a type argument has to
be passed to specify to which type the function in question is to be instantiated.
This seems adequate in cases where dependency variables occur in the type
argument – after all, we might want to locally redeﬁne the function for some of
these dependency variables, so it is better to be precise about the details. Recall
the example
letsize/angbracketleftα/angbracketright=const 1
in(size/angbracketleft[[Int]]/angbracketright[[1, 2, 3 ],[4, 5]],
size/angbracketleft[[α]]/angbracketright[[1, 2, 3 ],[4, 5]],
size/angbracketleft[α]/angbracketright [[1, 2, 3 ],[4, 5]],
size/angbracketleftα/angbracketright [[1, 2, 3 ],[4, 5]])
210
13.2 Dependency inference
from Section 8.2, where only the type arguments distinguish the four calls, indi-
cating which part of the data structure we want to count.
However, most calls of type-indexed functions in a program probably have
constant (i.e., dependency variable free) type arguments, and for constant types,
it is desirable to be allowed to omit the type argument.
If we use a class method of a Haskell type argument, the compiler infers the
dictionary to use, i.e., the combination of type class instances that provide the
desired functionality. We write show ’c’orshow False orshow [1]without having
to specify explicitly on which type show should be invoked. The compiler detects
automatically, using context information, that we intend to call show on Char,
Bool, and [Int], respectively. For type classes, there is no way to specify this
implicit argument explicitly, thus if the inference fails, there is no way to pass the
missing information to the type checker.
The type inference problem for type arguments of type-indexed functions is
very similar to the one for type classes in Haskell. Provided that all generic type
parameters of a type-indexed function’s type signature actually occur in the base
type of the function (functions like enum orcard do not fulﬁll this condition), we
can apply the same technique that the Haskell compiler uses to infer the correct
dictionary for a type class method.
An important difference is, though, that even in the presence of type inference
for type arguments, we still allow to explicitly specify a type argument, be it
for documentation purposes, or because we want to make use of dependency
variables or local redeﬁnitions, or to bypass restrictions (such as for enum or
card).
The type class encoding, presented as an alternative translation for generic
functions in Section 11.8.2, demonstrates the relation between the inference of
type arguments and the inference of dictionaries for type classes further.
13.2 Dependency inference
Dependency inference amounts to partially inferring the type signatures of type-
indexed functions. We still require the base type of a generic function to be
speciﬁed, but we would like to infer the dependency list automatically.
For example, the type signature of equal could then be written as
equal/angbracketlefta::∗/angbracketright::a→a→Bool ,
and the one for map would become
map/angbracketlefta::∗,b::∗/angbracketright::a→b.
211
13 Type Inference
This would yet again signiﬁcantly reduce the amount of knowledge the program-
mer needs to have about the underlying type system.
The problem is easy to solve in the situation of Chapter 6, where we ﬁrst in-
troduced dependencies. There, we have treated the special case that types of
type-indexed functions are always of arity /angbracketleft1|0/angbracketright, i.e., they have one generic,
and no non-generic arguments. In this situation, there is only one way in which
a type-indexed function can depend on another. Therefore, it sufﬁces to infer
thenames of the functions that are dependencies. We can achieve this by scan-
ning the deﬁnitions of type-indexed functions and determining the minimal set
of dependencies for each functions that is sufﬁcient.
Although we believe that dependency inference is possible also for the general
case of Chapter 9 – at least partially – this remains future work.
13.3 Base type inference
In the presence of polymorphism and subtyping, an expression often can have
more than one type. A function such as
λx y→x
can be assigned any of the types
Int→Char→Int
Bool→Bool→Bool
∀a::∗. Tree a→[a]→Tree a
∀(a::∗) (b::∗).a→b→a.
The type system on which Haskell is based (Damas and Milner 1982) has the
advantage that there always exists a most general type, the principal type , which
is convertible into all other types that the expression can have. Formally, if an
expression ehas principal type t, then if also e::t/prime, then t/lessorequalslantt/prime, where t/lessorequalslantt/prime
means that every texpression can be used as a t/primeexpression. In the example of
λx y→x, the last of the four types given above is the principal type.
The type inference system for Haskell is only really helpful because it ﬁnds
and returns the principal type for every expression. This way, we can run the
inference algorithm on single functions to learn about their types, and we can be
sure that the types that are inferred are the best we can come up with.
In this section, we discuss the question whether there exist principal types for
generic functions. Unfortunately, the answer is no, and we will demonstrate this
negative answer with an example.
212
13.3 Base type inference
Recall the introduction of function map in Section 9.1. We obtained map as a
generalization of the generic identity function gid, by using a more general type
signature, but without touching the implementation. The type signatures of gid
and map are
gid/angbracketlefta ::∗/angbracketright::(gid/angbracketlefta/angbracketright)⇒a→a
map/angbracketlefta1,a2::∗/angbracketright::(map/angbracketlefta1,a2/angbracketright)⇒a1→a2.
Both functions have exactly the same code, i.e., the type of gidwould also work
formap (renaming the dependency, of course), and vice versa. Using local redef-
inition, both can be used to map a function over a data structure, but with map
we can change the type of the elements, whereas with gidwe cannot.
Let us analyze which of the two types a type inferencer should return for a
function that has the implementation of gidormap. Certainly, the second type
seems “better”, somehow, as in practice, map is far more useful than gidis.
However, we will demonstrate now that neither of the two types is more gen-
eral. The type of gidcannot be used for map in the following situation:
map/angbracketleft[ ]/angbracketrightchr[1, 2, 3, 4, 5 ].
This is a simple application on lists that changes the element type.
The other direction requires a datatype that takes a type argument of higher
kind to be involved, a datatype such as GRose:
data GRose (f::∗→∗ ) (a::∗) =GFork a (f a).
This is a generalization of the datatype Rose of rose trees, deﬁned on page 158
in Section 10.2. Here, the children can be stored in an arbitrary data structure f,
whereas in a rose tree, f≡[ ]. Now, consider the expression
letgid/angbracketleftγ(α::∗)/angbracketrightz=case zof
[ ]→[ ]
(x:y)→gid/angbracketleftα/angbracketright(gid/angbracketleftα/angbracketrightx):gid/angbracketleftγ α/angbracketrighty
ingid/angbracketleftGRose γInt/angbracketright.
The redeﬁnition uses γat the list type constructor. In the second arm of the case
construct, the funcion gid/angbracketleftα/angbracketrightis applied twice to the head of the list. We therefore
rely on the fact that gid/angbracketleftα/angbracketrightin the local redeﬁnition does notchange the type of
its argument. We could not make this assumption if gidhad the type of map; the
redeﬁnition gid/angbracketleftγ α/angbracketrightwould then need to be of the type
∀(c1::∗→∗ ) (c2::∗→∗ ) (a1::∗) (a2::∗).
(gid/angbracketleftα/angbracketright::a→b)⇒c1a1→c2a2.
213
13 Type Inference
Compare this situation with the four types for λx y→xthat we have given
above. We could always replace one of the ﬁrst three types for the function with
the fourth, without breaking programs that use the function.
The whole consideration has an effect for type inference of the type signature
of a type-indexed function: we cannot hope to ﬁnd a best possible type in general.
If a function with the deﬁnition such as map and gidis encountered, it is unclear
whether to assign it gid’s or map’s type. We could still try to ﬁnd a type (or,
extend the type system and permit a type) which is convertible into any of the
two other types, but it is not obvious what this type would look like.
Even in the knowledge of this negative result, we do not have to give up com-
pletely, though. For example, the above problem does only occur if we consider
functions with more than one generic type variable in the type tuple, i.e., func-
tions of arity/angbracketleftr|s/angbracketrightwhere r>1. If we restrict ourselves to the case r≡1, and
possibly impose further restrictions, we believe that type inference can be done.
Even for the case that r>1, it might be possible to infer a type under certain cir-
cumstances, or to develop a type-inference algorithm that returns more than one
type. We might even choose to prefer the type of map over the type of gidanyway,
because examples where the more restrictive type can prove useful require local
redeﬁnition on types of higher kinds, a situation which is not likely to occur very
frequently. All this is future work.
214
14 Default Cases
Experience with generic programming shows that one often writes several minor
variations of one generic function over and over again. The reason is that while
one is interested in generic behaviour for the large part of the datatypes involved,
some particular types should be treated in a special way. An example is the col-
lection of variables from an abstract syntax tree, where the algorithm is basically
the generic function collect (deﬁned on page 137 in Section 9.3), but occurrences of
the datatype Var that holds variables should be added to the list that is collected.
A ﬁrst approach to solve the problem would probably be to locally redeﬁne
collect somehow and capture the redeﬁned functionality in a generic abstraction:
varcollect/angbracketleftα::∗/angbracketright=letcollect/angbracketleftα/angbracketright(V x) = [ x]
incollect/angbracketleftExpr α/angbracketright,
assuming that Expr is the datatype that holds an expression of the language in
question. This deﬁnition is not ideal, because it requires Expr to be parametrized
over the type of variables. If we subsequently want to collect something else,
say type signatures, then we have to parametrize over those as well. It is not
acceptable to change the datatype just to be able to write another function, nor
215
14 Default Cases
can we necessarily predict which functions might be needed while designing the
datatype.
In this chapter, we introduce default cases , which provide another solution to
this dilemma: we can extend an already existing type-indexed function by adding
new cases or even overriding existing ones. For the collection of variables, we can
then write
varcollect extends collect
varcollect/angbracketleftVar/angbracketright(V x) = [ x]
to achieve the desired effect.
In the following section, we build upon the variable collection example and
discuss some other examples in which default cases can be applied successfully.
After that, we take a look at the corresponding language extension and its se-
mantics.
14.1 Generic Traversals
Let us assume the following system of datatypes which describe a simple expres-
sion language based on the lambda calculus.
data Var =V String
data Type =TyVar Var
|Fun Type Type
data Expr =Var Var
|App Expr Expr
|Lam (Var, Type )Expr
|Let (Var, Type )Expr Expr
Using a default case, a function to collect all variables from an expression can
be written as a type-indexed function:
varcollect/angbracketlefta::∗/angbracketright::(varcollect/angbracketlefta/angbracketright)⇒a→[Var]
varcollect extends collect
varcollect/angbracketleftVar/angbracketright x =x
varcollect/angbracketleftProd α β/angbracketright(x1×x2) =varcollect/angbracketleftα/angbracketrightx1‘union ‘varcollect/angbracketleftβ/angbracketrightx2
In comparison with the example from the introduction to this chapter, we give
a full deﬁnition here, including a type signature, and we add yet another case,
redeﬁning the behaviour for products to use set union and eliminate duplicates
216
14.1 Generic Traversals
instead of list concatenation. Note that the function does extend collect , but does
not depend on it.
Even though this function is intended to be used on the type Expr, it is still
generic. It is robust against changes in the deﬁnitions of datatypes, it will work
for other languages that make use of the Var type, and it will work for data
structures that contain expressions, such as [Expr ]or Tree Expr, all for free.
The following deﬁnition of varcollect is semantically equivalent to the one above
and shows how varcollect would have to be written in absence of the default case
construct:
varcollect/angbracketlefta::∗/angbracketright::(varcollect/angbracketlefta/angbracketright)⇒a→[String ]
varcollect/angbracketleftVar/angbracketright (V x) = [ x]
varcollect/angbracketleftProd α β/angbracketright(x1×x2) =varcollect/angbracketleftα/angbracketrightx1‘union ‘varcollect/angbracketleftβ/angbracketrightx2
varcollect/angbracketleftInt/angbracketright =collect/angbracketleftInt/angbracketright
varcollect/angbracketleftUnit/angbracketright =collect/angbracketleftUnit/angbracketright
varcollect/angbracketleftSum α β/angbracketright =letcollect/angbracketleftα/angbracketright=varcollect/angbracketleftα/angbracketright
collect/angbracketleftβ/angbracketright=varcollect/angbracketleftβ/angbracketright
incollect/angbracketleftSum α β/angbracketright
From this equivalent deﬁnition, we can infer how the default case works: for each
type that is in the signature of collect , but for which there is no explicit arm in
varcollect , the compiler maps the varcollect call to a call of collect . Most interesting
is the case for Sum: the compiler automatically remaps the dependencies that
collect has on itself to point to varcollect . This way, the extension is deep: all
occurrences of the Var type will be collected, and there is no dependency on the
original collect function.
Type patterns of type-indexed functions always consist of a named type applied
to dependency variables (cf. Figure 6.1). The order of cases in a typecase is
unimportant, because we can always determine the matching case by analyzing
the toplevel constructor of the type argument. For default cases, it is therefore
unimportant whether the new cases are inserted in the beginning, the end, or
somewhere in the middle of the typecase construct – it makes no difference.
It is also possible to reuse arms from an existing deﬁnition in a new function,
even arms that are overridden. The following function collects just term variables
from our expression, assuming a function termvar :: Var→Bool to determine
whether a variable comes from the syntactic category of term variables:
termcollect/angbracketlefta::∗/angbracketright::(termcollect/angbracketlefta/angbracketright)⇒a→[Var]
termcollect extends varcollect
termcollect/angbracketleftVar/angbracketrightv=iftermvar v then varcollect/angbracketleftVar/angbracketrightvelse [ ].
217
14 Default Cases
Based on termcollect , we can then write a function that determines the free vari-
ables in an expression:
freecollect/angbracketlefta::∗/angbracketright::(freecollect/angbracketlefta/angbracketright)⇒a→[Var]
freecollect extends termcollect
freecollect/angbracketleftExpr/angbracketrighte=
case eof
Lam (v,t)e/prime→ﬁlter (/negationslash==v) (freecollect/angbracketleftExpr/angbracketrighte/prime)
Let (v,t)e/primee/prime/prime→freecollect/angbracketleftExpr/angbracketrighte/prime
+ +ﬁlter/angbracketleft/negationslash==v/angbracketright(freecollect/angbracketleftExpr/angbracketrighte/prime/prime)
→termcollect/angbracketleftExpr/angbracketrighte
In general, operations on larger systems of datatypes such as abstract syntax
trees, datatypes representing xml dtd s or schemata (W3C 2001), or datatypes rep-
resenting an organizational structure, such as a company, a package database, or
a ﬁle system, are good candidates for processing with generic functions deﬁned
by means of default cases. A library of basic traversals such as collect ormap can
be used to deﬁne several variations that perform the tasks at hand and adapt to
changes in the data structures automatically.
Ralf L ¨ammel has studied such generic traversals in detail (L ¨ammel et al. 2000),
also in the context of Haskell (L ¨ammel and Visser 2002). This line of research
has recently culminated in a convincing proposal to extend the Haskell language
with support for generic traversals and queries (L ¨ammel and Peyton Jones 2003).
Compared with Generic Haskell, this language extension puts the focus on traver-
sal functions and the unproblematic extension of existing functions with speciﬁc
behaviour, and puts less emphasis on the generic structure of types. In a more
recent version, it is now also possible to deﬁne a larger class of classic generic
operations such as equality or show in this setting (L ¨ammel and Peyton Jones
2004).
14.2 Variants of equality
Another example where default cases come in handy is to deﬁne a variant of an
existing standard function, such as equality. In Section 7.3, we already discussed
that we have the possibility to deﬁne special behaviour for a datatype, and as an
example we added the arm
equal/angbracketleftRange/angbracketrightx y=True .
However, this deﬁnition robs us of the possibility to use the generic, structural
equality, on the Range type. Maybe we are interested in ignoring ranges in data
218
14.3 Simulating multiple dependencies on one function
structures sometimes, but not always. Even worse, we may not yet know about
the Range type and our speciﬁc application when deﬁning the equality function
– especially if the program consists of multiple modules (cf. Chapter 18).
An alternative is to create a new function that extends equal :
requal/angbracketlefta::∗/angbracketright::(enum/angbracketlefta/angbracketright,requal/angbracketlefta/angbracketright)⇒a→a→Bool
requal extends equal
requal/angbracketleftRange/angbracketrightx y=True .
Another variant of equal results from comparing characters case-insensitively:
ciequal/angbracketlefta::∗/angbracketright::(enum/angbracketlefta/angbracketright,requal/angbracketlefta/angbracketright)⇒a→a→Bool
ciequal extends equal
ciequal/angbracketleftChar/angbracketrightx y=toUpper x≡toUpper y .
Several other variations of equal are possible and may be useful occasionally.
14.3 Simulating multiple dependencies on one
function
In Section 9.8, we promised that default cases would provide a solution for type-
indexed functions that depend on the same function more than once.
As an example, let us use the map function. In Section 11.2, we have introduced
thebimap function that produces a pair of functions EP a binstead of a single
function a→b, mainly because we could then easily lift bimap to function types.
An alternative, sketched in Section 11.3, is to deﬁne two copies of map, there
called from and to, which depend on each other in the function case.
Had we multiple dependencies on one function, we could deﬁne map for func-
tions directly:
map/angbracketlefta::∗,b::∗/angbracketright::(map/angbracketlefta,b/angbracketright,map/angbracketleftb,a/angbracketrightascomap )⇒a→b.
We depend on map as usual, and once more with reversed type variables and
using the name comap . The deﬁnition would be as usual, plus the case for the
function type constructor, namely
map/angbracketleftα→β/angbracketrightx=map/angbracketleftβ/angbracketright·x·comap/angbracketleftα/angbracketright
In the function case, we need an arrow in the other direction, corresponding to
the contravariance of the ﬁrst argument of the function arrow.
219
14 Default Cases
Using default cases, we can achieve the same goal without an additional re-
naming construct in the syntax of type signatures. We adapt the type signature
ofmap to refer to comap as a different function:
map/angbracketlefta::∗,b::∗/angbracketright::(map/angbracketlefta,b/angbracketright,comap/angbracketleftb,a/angbracketright)⇒a→b.
The deﬁnition of map is exactly as before. We use a default case to deﬁne comap
as a copy of map:
comap/angbracketleftb::∗,a::∗/angbracketright::(map/angbracketlefta,b/angbracketright,comap/angbracketleftb,a/angbracketright)⇒a→b
comap extends map
where map ascomap
comap asmap .
Note that we swap the dependencies to map and comap in the deﬁnition of comap ,
using a where clause to the extends construct.
The compiler now treats comap/angbracketleftα→β/angbracketrightas if it were deﬁned as
comap/angbracketleftα→β/angbracketright=letsim map/angbracketleftα/angbracketright=comap/angbracketleftα/angbracketright
map/angbracketleftβ/angbracketright=comap/angbracketleftβ/angbracketright
comap/angbracketleftα/angbracketright=map/angbracketleftα/angbracketright
comap/angbracketleftβ/angbracketright=map/angbracketleftβ/angbracketright
in map/angbracketleftα→β/angbracketright,
where the letsim construct is a simultaneous, non-recursive let: all assignments
are performed at the same time, and the right hand sides can only refer to objects
on the outside of the let. The compiler can translate a letsim into an ordinary,
nested letstatement, making use of temporary variables, or simply by perform-
ing a simultaneous substitution. The deﬁnition above is thus not mutually recur-
sive. The component belonging to the function case of bimap is:
cp(comap ,(→))cp(comap ,α)cp(map,α)cp(comap ,β)cp(map,β) =
cp(map,(→))cp(map,α)cp(comap ,α)cp(map,β)cp(comap ,β).
Awhere clause in the default case such as the one in the deﬁnition of comap can
generally be used in a default case to rename the dependencies of the extended
function.
A normal extends clause without a where-part, as discussed in all the previous
examples, is a special case, where we assume that we want to rename a reﬂexive
dependency to point to the new function. Thus, the statement
xextends y
is short for
220
14.4 Implementation of default cases
xextends y
where yasx.
If the function being extended has no dependency on itself, then there is no
implicit renaming of dependencies.
14.4 Implementation of default cases
Value declarations
d::=. . . everything from Figures 4.1, 8.3, and 12.1
|x/primeextends xwhere{ykasy/prime
k}k∈1../lscript
;
default case
Figure 14.1: Core language with default cases fcr+gf+gabs +dc, extends language
fcr+gf+gabs in Figures 12.1, 9.4, 8.3, 6.1, 4.1, and 3.1
To implement default cases, we need only a very simple extension of the syntax,
that is shown in Figure 14.1. We introduce a new form of value declarations, that
augments a type-indexed function deﬁnition in a typecase . A default case thus
only makes if it is paired with a (possibly empty) typecase .
Default cases are translated to a number of components for the type-indexed
function that they refer to. To deﬁne precisely which components are generated
for a default case, we have to clarify the notion of a type-indexed function’s
signature a bit: the presignature of a function is the set of type constructors that
the programmer has written arms for in the typecase of the function deﬁnition.
Thesignature consists of the type constructors that make up the presignature
plus the type constructors for which additional components are deﬁned via a
default case. In particular, for a type-indexed function that is not deﬁned with a
default case, presignature and signature refer to the same set of type constructors.
Ifx/primeextends x, then the signature of x/primeis the union of the presignature of x/prime
and the signature of x. As a formula, this is
x/primeextends x=⇒signature (x/prime)≡signature (x),presignature (x/prime).
The cases that make up the presignature of a function x/primeare always taken from
x/prime. The type constructors that are in the signature of x, but not in the presignature
ofx/prime, are the ones that the default case expands to.
We assume that every entry in the signature environment Σof the form x/angbracketleftT/angbracketright
is marked with either pre,dc, or gf. All arms that are explicitly deﬁned in the
221
14 Default Cases
/llbracketdfcr+gf+gabs +dc/squigglerightΓ2;Σ2/rrbracketdc
K;Γ1;∆;Σ1;Ψ≡{dfcri}i∈1..n
;
signatureΣ(x)−presignatureΣ(x/prime)≡{Ti}i∈1..n
,/braceleftbig
convert K;Γ(x,x/prime,Ti,new)≡x/prime/angbracketleftPi/angbracketright=ei/bracerightbigi∈1..n
/braceleftbig
/llbracketx/prime|Pi→ei/squigglerightx/prime/angbracketleftTi/angbracketright/rrbracketdc
K;Γ;∆;Σ;Ψ≡di/bracerightbigi∈1..n
new≡{yk/mapsto→y/prime
k}k∈1../lscript·
Σ/prime≡{x/angbracketleftTi/angbracketrightdc}i∈1..n
,
/llbracketx/primeextends xwhere{ykasy/prime
k}k∈1../lscript
;/squigglerightε;Σ/prime/rrbracketdc
K;Γ;∆;Σ;Ψ≡{di}i∈1..n
;(d/tr-dc)
Figure 14.2: Translation of default cases, extends Figures 11.2 and 6.15
program are marked with preand make up the presignature. All arms that are
added by a default case are marked with dc. The cases marked with pretogether
with the cases marked with dcmake up the signature of a function. Finally, all
entries that stem from the generation of an additional component for a generic
function are marked with gf. They are of no direct interest for the translation of
default cases. Assuming that these tags are present in the signature environment,
we can deﬁne functions of the form
signatureΣ(x)≡{Ti}i∈1..n
,
presignatureΣ(x)≡{Ti}i∈1..n
,
that return the signature or presignature of a type-indexed function xby scanning
the environment Σ. The tags are ignored by the generic translation algorithm, for
which it is unimportant where a speciﬁc component comes from.
In Figure 14.2, we learn how a default case is formally translated. As we have
explained, the extends construct generates arms for a certain number of type
constructors. These are computed by subtracting the presignature of the new
function x/primefrom the signature of the extended function x. These type constructors
are called Ti. For each of the Ti, we call the convert function to perform the
renaming, including the renaming of the dependencies. The convert function
takes four arguments: the old function x, the new function x/prime, the type constructor
in question Ti, and a function called newthat maps names of dependencies of the
original function to names of dependencies of the new function. The function
newis built from the where clause of the extends construct.
The convert function returns a declaration of the form x/prime/angbracketleftPi/angbracketright=ei, where Piis
a type pattern built from Ti. We reformat this declaration as if it were an arm
222
14.4 Implementation of default cases
convert K;Γ(x,x/prime,A,new)≡d
K/turnstileleftA::{κi→}i∈1..nκ
{αifresh}i∈1..nK/prime≡K{,αi::κi}i∈1..n
dependenciesΓ(x)≡{yk}k∈1../lscript
,
convert K;Γ(x,x/prime,A,new)≡
x/prime/angbracketleftA{(αi::κi)}i∈1..n/angbracketright=
letsim/braceleftbig{convert K/prime;Γ(new(yk),yk,αi,new−1)}i∈1..n/bracerightbigk∈1../lscript
in x/angbracketleftA{αi}i∈1..n/angbracketright.(dc-convert)
Figure 14.3: Conversion of arms for a default case
of the typecase Pi→ei, and use the old rule (d/tr-arm) to translate the arm to
a declaration difor a single component cp(x,Ti). Note that this translation also
type checks the declaration di. We record in the signature environment that x/angbracketleftTi/angbracketright
has been generated by a default case, marking the entry with dc.
The component declarations diresulting from the converted arms are returned
together with the signature environment and an empty type environment, be-
cause no new fcr+gf+gabs +dc functions are declared by a default case.
The convert function is deﬁned in Figure 14.3. An application looks as follows:
convert K;Γ(x,x/prime,A,new)≡d.
It takes a type argument A(which should be either a named type or a single
dependency variable), an old and a new function name xand x/prime, and a map
from old dependencies to new dependencies, which we call new. It produces a
declaration. The conversion takes place under environments K and Γ, because
we need access to the dependencies of the functions involved.
There is only one rule, (dc-convert). It makes use of a letsim construct in the
result, which is like a letconstruct, but performs all bindings simultaneously and
non-recursively. It is easy to translate a letsim construct performing a simulta-
neous substitution of the bound variables. An example of in which situations the
letsim construct is necessary and how it can be translated was given on page 220.
We use the construct here to simplify the rule, but do not formally deﬁne it. The
rule (dc-convert) checks the kind of the type argument A, and introduces de-
pendency variables αias arguments for A, of appropriate kinds. We cannot, in
general, write
223
14 Default Cases
x/prime/angbracketleftA{(αi::κi)}i∈1..n/angbracketright=x/angbracketleftA{αi}i∈1..n/angbracketright.
because that would ignore possible dependencies of x. The dependencies of x
should be remapped to dependencies of x/primeaccording to the function new. We will
perform the remapping by using local redeﬁnition around the call x/angbracketleftA{αi}i∈1..n/angbracketright.
We must redeﬁne every dependency ykofxin terms of the function new(yk), as
speciﬁed by the function new, and this for every dependency variable αithat
occurs in the type pattern. It turns out that we can use convert recursively for this
job. We only need to invert the mapping new, and we write the inverse mapping
new−1.
Let us assume for the moment that this inverse exists and have a look at an
example. We had
varcollect extends collect
which with explicit where clause corresponds to
varcollect extends collect
where collect asvarcollect .
The function new that remaps the dependencies is in this case thus collect/mapsto→
varcollect .
For a case of kind ∗such as Int, we get
convert (collect ,varcollect , Int, collect/mapsto→varcollect )≡
varcollect/angbracketleftInt/angbracketright=collect/angbracketleftInt/angbracketright.
Because there are no dependency variables involved, we also do not have any
dependencies to remap. We omit the empty letconstruct. For a type of the kind
∗nforn>0, such as Sum, we can witness the remapping of the dependencies:
convert (collect ,varcollect , Sum, collect/mapsto→varcollect )≡
varcollect/angbracketleftSum (α::∗) (β::∗)/angbracketright=
letsim collect/angbracketleftα/angbracketright=varcollect/angbracketleftα/angbracketright
collect/angbracketleftβ/angbracketright=varcollect/angbracketleftβ/angbracketright
in collect/angbracketleftSum α β/angbracketright.
Note that the inverse mapping new−1, which would be varcollect/mapsto→collect , is not
needed in this case. The dependency variables are all of kind ∗, and thus have no
arguments on their own.
We do need the inverse mapping only for type constructors of higher ranked
kind, such as Fix. The type Fix is not in the signature of collect and would thus
not appear in a convert call for varcollect , but we will show the result anyway for
the sake of example:
224
14.5 Typing default cases
convert (collect ,varcollect , Fix, collect/mapsto→varcollect )≡
varcollect/angbracketleftFix(α::∗→∗ )/angbracketright=
letsim collect/angbracketleftα(γ::∗)/angbracketright=
letsim varcollect/angbracketleftγ/angbracketright=collect/angbracketleftγ/angbracketright
in varcollect/angbracketleftα γ/angbracketright
in collect/angbracketleftSum α β/angbracketright.
Cases for type constructors of higher ranked kinds appear rarely in type-
indexed functions, therefore we do not require the remapping of dependencies
to be invertible, and fail only lazily during the translation, i.e., only if the inverse
is requested at a dependency for which it cannot be produced (this can happen
because no name is mapped to that dependency, or because multiple names are
mapped to that dependency).
14.5 Typing default cases
In the previous section, we have shown how a function that has a default case
is type checked: all arms that are explicitly deﬁned are type checked against the
type signature of the function as usual; for the default case, the conversions are
generated, and then also type checked against the type signature of the function.
We do not type check the extends construct directly, but rather check its trans-
lation. The reasoning behind this is relatively simple: we want to be as liberal as
possible. In the general case, however, a type-indexed function is very sensitive
to any change in its type.
There are several situations in which it is desirable to be able to use a differ-
ent type in the derived function than in the original function. For instance, the
function collect is polymorphic in the element type of the resulting list. That is
possible because collect , without local redeﬁnition or an extension via a default
case, returns always the empty list. But surely, we do not want extensions to
suffer from the same restriction, and indeed, varcollect and termcollect return a list
of type Var.
Other possibilities are that one of the newly deﬁned arms of the function intro-
duces an additional dependency that the original function does not have. Or the
original function has multiple generic slots, and we want the new function to have
fewer. For instance, if we do not need or even do not want the possibility of func-
tion map to possibly change the type of its argument, we could want to restrict it
to the type of gidin an extension. Both these changes are critical, though, if the
function should be deﬁned for type patterns involving higher-ranked type con-
structors. We have discussed in Section 13.3 that reducing the number of generic
type variables can prove fatal in such a situation. Introducing a new dependency
225
14 Default Cases
is not much different from that, because it implies that the function new, which
remaps dependencies of the old function to the new function, is not invertible.
Still, if there are no such cases in the extended function, such modiﬁcations in the
types may be possible.
Instead of designing cunning type checking rules for an extends construct that
grant this ﬂexibility, we choose the pragmatic solution to simply type check the
expansion of the extends construct. This is not as bad as it sounds: the expansion
depends on the signature and the type signature of the original function, but not
on its implementation.
While we are at discussing types of default cases, let us point out that it may
be desirable to extend the function convert in such a way that not only remapping
of dependencies can be performed, but also arguments can be introduced or
eliminated. For instance, in the paper introducing Dependency-style Generic
Haskell (L ¨ohet al. 2003), a type-indexed function update is used to increase the
salary of all employees in an organization. This function is deﬁned using a default
case as follows
update/angbracketlefta::∗/angbracketright::(update/angbracketlefta/angbracketright)⇒Float→a→a
update frac extends map
update/angbracketleftSalary/angbracketrightfrac(SalaryC s ) =SalaryC (s‘times ‘(1+frac)).
The function is based on map, because it traverses a value of the several data struc-
tures that are used to represent the organization, and produces a new value of
the same type. We use only one generic type argument, because we are not mod-
ifying types anywhere. The only position where we actually change something
is whenever we encounter a value of the type Salary , deﬁned as
data Salary =SalaryC Float .
In such a case, we increase the salary by a given fraction frac. The argument frac
is an argument of update , but not of map. The extends construct declares that
we intend to introduce the variable fracwhile extending. The expansion of the
default case is supposed to look as follows:
update/angbracketleftInt/angbracketright frac=map/angbracketleftInt/angbracketright
update/angbracketleftChar/angbracketright frac=map/angbracketleftChar/angbracketright
update/angbracketleftFloat/angbracketright frac=map/angbracketleftFloat/angbracketright
update/angbracketleftUnit/angbracketright frac=map/angbracketleftUnit/angbracketright
update/angbracketleftSum α β/angbracketrightfrac=letmap/angbracketleftα/angbracketright=update/angbracketleftα/angbracketrightfrac
map/angbracketleftβ/angbracketright=update/angbracketleftβ/angbracketrightfrac
inmap/angbracketleftSum α β/angbracketright
226
14.5 Typing default cases
update/angbracketleftProd α β/angbracketrightfrac=letmap/angbracketleftα/angbracketright=update/angbracketleftα/angbracketrightfrac
map/angbracketleftβ/angbracketright=update/angbracketleftβ/angbracketrightfrac
inmap/angbracketleftProd α β/angbracketright
The variable frac is automatically threaded through the computation and re-
spected while remapping mapdependencies to update . The full extends statement
forupdate – including a where clause – could be written
update frac extends map
where mapasupdate frac .
Of course, if such constructions are allowed, it becomes even harder to properly
invert the dependency remapping function new. Not only the association between
function names, but also the connected operations, such as the threading of frac
in this case, must be inverted. It is thus difﬁcult to make such extensions possible
on functions that involve patterns with higher ranked type constructors. But such
functions are rare.
227
14 Default Cases
228
15 Type, Newtype, Data
The Haskell language offers three constructs to deﬁne types: next to data , the
general construct to deﬁne new datatypes that is also part of all languages dis-
cussed in this thesis, there is newtype , a limited version of data that can be used
to declare a new, distinct, datatype that is isomorphic to an already existing type,
andtype , a construct to deﬁne type synonyms, which are symbolic names that
can be used as abbreviations for existing types, but are not considered distinct.
In this short chapter, we will discuss how a language with generic functions
can be extended with both newtype andtype statements, and what effect the
presence of these additional constructs has on type-indexed functions. In Fig-
ure 15.1, the relevant additional syntax is shown. The language that has all three
type-deﬁnition constructs available is called fcrt, and all languages based thereon
do also get an fcrt preﬁx. For instance, the language including generic functions,
generic abstraction, and default cases on the basis of the full diversity of type-
level declarations is called fcrt+gf+gabs +dc.
229
15 Type, Newtype, Data
Type declarations
D::=data T={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|
datatype declaration
|newtype T={Λai::κi.}i∈1../lscriptC t
newtype declaration
|type T={Λai::κi.}i∈1../lscriptt
type synonym declaration
Figure 15.1: Full syntax of type declarations for language fcrt, extends Figures 3.1 and 3.12
15.1 Datatype renamings
The Haskell Report (Peyton Jones 2003) calls the functionality that is offered by
thenewtype construct the “renaming” of an existing datatype. The syntactic dif-
ference between a newtype and a data is that a newtype is restricted to exactly
one constructor with exactly one ﬁeld. We therefore use the following syntax for
newtype :
newtype T={Λai::κi.}i∈1../lscriptC t.
In Haskell, there is a subtle difference between a newtype statement and a
data statement of the same form, as for example
data RoomNumber =Room Int
newtype RoomNumber =Room Int .
For the data statement, the values Room⊥and⊥are different, whereas for the
newtype statement, they are considered the same. As a consequence, there are
slightly different pattern matching rules for constructors deﬁned via newtype .
Apart from that, and especially as far as type-indexed functions are considered,
anynewtype statement
newtype T={Λai::κi.}i∈1../lscriptC t
can be treated exactly as the corresponding data statement
data T={Λai::κi.}i∈1../lscriptC t.
In particular, one can deﬁne arms of type-indexed functions for datatypes deﬁned
innewtype statements, and types deﬁned via newtype do also have structural
representations, embedding-projection pairs and may occur in type arguments.
230
15.2 Type synonym declarations
15.2 Type synonym declarations
A type synonym introduces a new name for a type expression. Type synonyms
can be parametrized. Other than the data andnewtype constructs, the new type
names are not considered to be distinct types. They are rather alternative names
for already existing types.
Furthermore, Haskell imposes some severe restrictions on the use of type syn-
onyms in programs: they must always appear fully applied, and they must not be
(directly or indirectly) recursive. They also cannot be used in instance declara-
tions. All these restrictions together ensure that type synonyms can be expanded
to their deﬁnitions, and can be seen as no more than a way to make the program
more readable.
As such, type synonyms also pose no problems in a language that allows
generic programming. The syntax for type synonyms is
type T={Λai::κi.}i∈1../lscriptt.
The type tthat occurs on the right hand side is notrequired to be of kind ∗. It
is thus possible to deﬁne synonyms for higher kinds without eta-expansion, i.e.,
we can deﬁne
type AltMaybe =Sum Unit
instead of
type AltMaybe/primea=Sum Unit a,
which is valuable, because the synonym AltMaybe can still be used on its own,
whereas AltMaybe/primemust always be applied to its argument.
Type synonyms can be used in type arguments that are part of generic appli-
cations, as long as long as they are fully applied. The type synonyms can then be
replaced by their deﬁnitions, and specialization can proceed as usual.
A more problematic question is whether type synonyms could or should be
allowed in type patterns in deﬁnitions of type-indexed functions. In the following,
we will outline a simple way to let the answer to this question be “yes”, and
outline the implications.
We want to allow type patterns of the form T{αi}i∈1../lscript, where the pattern can
be checked to be of kind ∗, and Tis the name of a type synonym. The type
requirements for an arm associated with such a pattern are exactly as for other
arms. The interesting part is to analyze when such an arm should be applied.
We take a very simplistic approach here. Type synonyms can occur in the
signatures of type-indexed functions as any other type. They are not expanded if
231
15 Type, Newtype, Data
they occur in type patterns. We do also not expand type synonyms that occur in
type arguments, but treat them as other named types and specialize as usual.
During specialization, we can thus reach a situation where we need a compo-
nent cp(x,T)for some generic function xon type synonym T. Now, if Tis in
the signature of x, we take the explicitly deﬁned cp(x,T). Otherwise, we try to
generate it. For datatypes, generation of new components proceeds as explained
in Chapter 11, making use of the structural representation of the datatype instead
of the original datatype and using the lifted embedding-projection pair to map
between the two components that work on different, but isomorphic datatypes.
For type synonyms, we can reuse the existing mechanism if we can deﬁne a
structural representation, plus embedding-projection pairs. This is trivial, as we
can simply let the right hand side of a type synonym double as its structural
representation, together with the identity embedding-projection pair EP id id .
For example, for strings, that in Haskell are deﬁned as a type synonym
type String = [Char ],
we would deﬁne
Str(String )≡[Char ]
ep(String ) =EP id id ,
and then reuse the established machinery to treat generic applications involving
String. We could then deﬁne a special arm of showP (cf. Section 17.1.2) for strings,
as
showP/angbracketleftString/angbracketrightp xs ="\"" + +map/angbracketleft[ ]/angbracketright(show/angbracketleftChar/angbracketright)xs+ +"\"" .
With this extra case, the function show can be used as follows
show/angbracketleftString/angbracketright"Hello"
show/angbracketleft[Int]/angbracketright[1, 2, 3, 4, 5 ]
show/angbracketleft[Char ]/angbracketright"Hello"
to produce the results
"\"Hello\""
"[1, 2, 3, 4, 5]"
"[’H’, ’e’, ’l’, ’l’, ’o’]" ,
where we assume that showP has components for both Char and Int that imple-
ment its functionality in the same way as Haskell’s standard show function. The
ﬁrst string is shown as a string, because the type argument explicitly mentions
232
15.2 Type synonym declarations
String, whereas the two others are shown as normal lists, using the [ ]arm that
showP provides.
Note that the only difference between the ﬁrst and the third case is the way in
which the type argument has been written! We do not make any attempts to ﬁnd
out that [Char ]is the same as String. We also respect the use (or non-use) of type
synonyms in the deﬁnitions of other types. In the presence of the deﬁnitions
newtype Name 1=N1String
newtype Name 2=N2[Char ],
the expression
(show/angbracketleftName 1/angbracketright"foo" ,show/angbracketleftName 2/angbracketright"bar" )
evaluates to
("\"foo\"" ,"[’b’, ’a’, ’r’]" ).
Being able to treat type synonyms in a special way in type-indexed function
deﬁnitions can turn out to be both a blessing and a curse.
A blessing, because deﬁning a type synonym and associated special behaviour
of a type-indexed function can be a very lightweight and readable way to modify
the normal, generically deﬁned behaviour that would be derived for a datatype.
A programmer can choose names for type synonyms that cover the intention in
which a value of this type should be used. Achieving exactly the same using local
redeﬁnition can turn out to be much harder.
A curse, because a type-indexed function can have different results for two
calls x/angbracketleftt1/angbracketrightand x/angbracketleftt2/angbracketright, even though t1and t2are considered to be the same types
in Haskell. This makes reasoning about calls to type-indexed functions much
harder, and can also lead to surprising results for users who do not expect that
the behaviour of a program can change if they just replace a type expression by
an equivalent type synonym somewhere.
Furthermore, we have to watch out if we perform type argument inference, as
described in Section 13.1. If the presence of type synonyms can inﬂuence the
result of a generic application, it is required that it is speciﬁed when and where
an inferred type argument will make use of type synonyms. A simple solution
here is to demand that an inferred type argument is always fully expanded, thus
free of any type synonyms. If that does not yield the behaviour that is desired,
one can always override the inferred type argument by specifying it explicitly.
233
15 Type, Newtype, Data
234
16 Type-indexed Datatypes
Type-indexed functions are functions that are parametrized by a type argument,
and have access to the structure of the type argument during deﬁnition, such
that they can behave differently for different types. If deﬁned for the types and
type constructors Unit, Sum, Prod, and Zero, that make up the standard view on
datatypes (cf. Chapter 10), type-indexed functions become generic, and work for
nearly all Haskell datatypes.
The same mechanism can be useful on the type level: a type-indexed datatype
is a datatype with a type argument, and we can pattern match on the type argu-
ment, making use of its structure while deﬁning the datatype. A type-indexed
datatype can thus have a different implementation depending on the type argu-
ment. Type-indexed datatypes can also be generic – if they are deﬁned for the
suitable type constructors, an implementation can be derived for a large class of
Haskell datatypes.
In Section 16.1, we will show how to deﬁne a type-indexed datatype by means
of an example. We will also discuss how such a datatype can be put to use, mainly
in generic functions. In Sections 16.2 and 16.3, we discuss – still using the example
– some peculiarities of type-indexed datatypes and how they can be translated.
235
16 Type-indexed Datatypes
After that, in Sections 16.4 and 16.5, we will analyze how some of the concepts
known from type-indexed and generic functions can be transferred to the type
domain. In Section 16.6, we discuss the “zipper”, another example of a type-
indexed datatype. Section 16.7 contains a discussion the language extensions
necessary to support type-indexed and generic datatypes.
16.1 Type-indexed tries
A digital search tree or trieis a search tree scheme that employs the structure
of search keys to organize information efﬁciently. Searching is useful for various
datatypes, so we would like to allow both keys and information to be of any
datatype.
If the key type should be ﬂexible, and the structure of the keys should be used
in the organization of the data structure, then the logical consequence is that we
need a type-indexed – or even better, generic – datatype.
Deﬁning a type-indexed datatype is not much different from the deﬁnition of
a type-indexed function: we deﬁne several cases of a datatype, using different
type patterns. Let us call the datatype of type-indexed tries FMap. It is deﬁned
as follows:
type FMap/angbracketleftInt/angbracketright v=IntMap v
type FMap/angbracketleftChar/angbracketright v=CharMap v
type FMap/angbracketleftUnit/angbracketright v=Maybe v
type FMap/angbracketleftSum α β/angbracketrightv= (FMap/angbracketleftα/angbracketrightv, FMap/angbracketleftβ/angbracketrightv)
type FMap/angbracketleftProd α β/angbracketrightv=FMap/angbracketleftα/angbracketright(FMap/angbracketleftβ/angbracketrightv).
All cases of the type deﬁnition start with the keyword type . This indicates that
each of the cases behaves as if it were a type synonym. Therefore, the right
hand side is simply a type expression. It is also possible to use newtype and
data constructs in the deﬁnition of a type-indexed type, and even to use different
constructs for different cases. The right hand side of a case always reﬂects the
construct that is used to deﬁne that particular case.
Each of the cases above takes a type parameter v, for the type of values that is
stored in the trie. For integers and characters, we assume that we have predeﬁned
ﬁnite maps, called IntMap and CharMap. A not very efﬁcient, but working,
possibility to implement these would be as lists of pairs, [(Int,v)]or[(Char, v)],
respectively, but we could, of course, choose another, more ingenious deﬁnition.
A trie for the Unit type is simply Maybe v. We use Nothing to denote the empty
trie in this case, where the key Unit has no associated value. Otherwise, we store
the associated value xasJust x .
236
16.1 Type-indexed tries
A trie for a Sum datatype is a pair of two tries, for each of the components. In
the left trie, we store entries of which the keys are of the form Inl x , and in the
right trie those whose keys are of the form Inr x .
For the Prod datatype, we use a nested trie to store entries. The outer trie has
key values that correspond to the left component of the Prod values. Each of
these keys is associated with another trie, that maps right components of Prod
values to values of type v.
The deﬁnition of the FMap datatype corresponds to the laws of exponentials.
If we denote the type of ﬁnite maps from keys of type tto values of type u
byt→ﬁnu, use 1 for the Unit type and use the inﬁx operators +and×for
the Sum and Prod type constructors, we have the following isomorphisms:
1→ﬁnu∼=u
(t1+t2)→ﬁnu∼=t1→ﬁnu×t2→ﬁnu
(t1×t2)→ﬁnu∼=t1→ﬁn(t2→ﬁnu).
The only difference is that we use Maybe uinstead of uin the case for Unit. While
the isomorphisms are valid for total ﬁnite maps, we allow partial ﬁnite maps in
our deﬁnition of FMap.
Having deﬁned FMap for Unit, Sum, and Prod makes it generic in much the
same way as a generic function: we can apply FMap not only to type terms
that are built from the type constructors appearing in the signature , but to all
datatypes of which the translation into the standard view is expressible using
these datatypes.
The deﬁnition of FMap makes use of dependency variables, and it calls FMap
recursively on these dependency variables on the right hand side of the deﬁnition.
For type-indexed functions, such behaviour causes a dependency that is recorded
in the type signature. For type-indexed types, we also keep track of dependencies,
but they are stored in the kind signature of the type. The kind signature of FMap
is:
FMap/angbracketlefta::∗/angbracketright::(FMap )⇒∗→∗ .
The name of the type variable ais irrelevant. We mention it only in order to stay
as close as possible to the type signatures of type-indexed functions; but unlike
the situation for type-indexed functions, the variable cannot occur on the right
hand side of the signature. The right hand side is structured similar to a type
signature for a type-indexed function: the dependencies are listed – in this case
only FMap itself – before the kind, which in this case is ∗→∗ , because all arms
of the type are parametrized over the type of values that are to be stored in the
ﬁnite map.
The notation for dependencies corresponds to the simple case for type-indexed
functions that we have discussed in Chapter 6. Since neither kind variables nor
237
16 Type-indexed Datatypes
polymorphic kinds exist in our language, the kind of a type-indexed type is
always constant. There is thus just one way to depend on another type-indexed
type. Consequently, there is no need to parametrize a kind signature over a type
tuple, or to add type tuples to the dependencies.
Nevertheless, the form of the kind signature implies that we have qualiﬁed kinds
in the presence of type-indexed types. Using an algorithm corresponding to gapp
(the simple variant has been described in Section 6.3.2) on the type level, we can
assign a qualiﬁed kind to each call of a type-indexed type. Figure 16.1 shows
examples for type arguments of different form. In all four cases, Ais assumed to
be free of dependency variables. The case for A(α::∗) (β::∗), for example, tells
FMap/angbracketleftA::∗/angbracketright ::∗→∗
FMap/angbracketleftA(α::∗)::∗/angbracketright ::(FMap/angbracketleftα/angbracketright::∗→∗ )⇒∗→∗
FMap/angbracketleftA(α::∗) (β::∗)::∗/angbracketright::(FMap/angbracketleftα/angbracketright::∗→∗ , FMap/angbracketleftβ/angbracketright::∗→∗ )
⇒∗→∗
FMap/angbracketleftA(α::∗→∗ )::∗/angbracketright ::(FMap/angbracketleftα γ/angbracketright::(FMap/angbracketleftγ/angbracketright::∗→∗ )
⇒∗→∗ )
⇒∗→∗
Figure 16.1: Kinds for generic applications of FMap to type arguments of different form
us that while deﬁning FMap /angbracketleftSum α β/angbracketrightor FMap/angbracketleftProd α β/angbracketright, we may assume
on the right hand side that FMap /angbracketleftα/angbracketrightand FMap/angbracketleftβ/angbracketrightare both available with
kind∗→∗ . Analogous to qualiﬁed types, we will translate qualiﬁed kinds into
functional kinds with explicit arguments.
The natural way to deﬁne operations on type-indexed datatypes is to use type-
indexed functions. We need to distinguish cases based on the type argument,
because each time we have to deal with a different data structure. The func-
tion lookup takes a key and a trie and returns a Maybe containing either the value
that is associated with the key in the trie or Nothing if no value is associated with
the key:
lookup/angbracketleftUnit/angbracketright Unit z =z
lookup/angbracketleftSum α β/angbracketright(Inl x ) (z1,z2) =lookup/angbracketleftα/angbracketrightx z1
lookup/angbracketleftSum α β/angbracketright(Inr x ) (z1,z2) =lookup/angbracketleftβ/angbracketrightx z2
lookup/angbracketleftProd α β/angbracketright(x×y)z1 =case lookup/angbracketleftα/angbracketrightx z1of
Nothing→Nothing
Just z 2→lookup/angbracketleftβ/angbracketrighty z2.
We omit the cases for Int and Char, which deal with the primitive, abstract ﬁnite
maps IntMap and CharMap. The deﬁnition is straightforward if one bears in
238
16.1 Type-indexed tries
mind the idea of the deﬁnition of the type-indexed trie. The second argument
is the trie, therefore it is of different form in each of the three arms: a Maybe v,
where vis the value type, for Unit, a pair in the Sum case, and a nested ﬁnite
map for Prod. If we want to lookup Unit in a unit trie, we can just return the
Maybe as the result. In the case Sum α β, we recursively call lookup , either on α
or on β, depending on whether the key is constructed by InlorInr. In the Prod
case, we take the nested trie z1and look for the ﬁrst component of the key x, in
that trie. If this key is not contained in the trie, then we return Nothing . If it is,
we end up with another trie z2, in which we can look for the second component
of the key y.
The type signature of lookup reﬂects the use of a type-indexed type:
lookup/angbracketlefta::∗/angbracketright::(lookup/angbracketlefta/angbracketright)⇒∀v::∗.a→FMap/angbracketlefta/angbracketrightv→Maybe v.
Note that in this case, we really need an inner quantiﬁcation for the type vari-
able v. A type signature of the form
lookup/angbracketlefta::∗|v::∗/angbracketright:: . . .
would not do! The reason is that lookup is polymorphically recursive in the Prod
arm: lookup/angbracketleftα/angbracketrightuses the function with result type Maybe (FMap/angbracketleftβ/angbracketrightv), whereas
lookup/angbracketleftβ/angbracketrightuses it with Maybe vas result type.
Another example of a type-indexed function on tries is the empty function that
produces an empty trie:
empty/angbracketleftUnit/angbracketright =Nothing
empty/angbracketleftSum α β/angbracketright= (empty/angbracketleftα/angbracketright,empty/angbracketleftβ/angbracketright)
empty/angbracketleftProd α β/angbracketright=empty/angbracketleftα/angbracketright.
For Unit, we return Nothing . For a Sum, we return a pair of empty tries. For
Prod, an empty trie on αsufﬁces. The type signature of empty is:
empty/angbracketlefta::∗/angbracketright::(empty/angbracketlefta/angbracketright)⇒∀v::∗. FMap/angbracketlefta/angbracketrightv.
Apart from the type argument, empty takes no further arguments. Like enum or
card, it is a type-indexed value.
All other operations on tries, such as insert and delete , can also be deﬁned as
generic functions. Therefore, FMap can be treated as an abstract datatype only
accessible through these functions. As already said, it is rare that one feels the
need to deﬁne non-generic functions that use speciﬁc instances of type-indexed
datatypes. In such a situation it is necessary that we know more about how
type-indexed datatypes are specialized.
239
16 Type-indexed Datatypes
16.2 Explicit specialization
Other than type-indexed functions, type-indexed datatypes have to be special-
ized explicitly. This is because a choice has to be made whether they should be
specialized using a type or a newtype construct, a choice that is hard to make
optimally using only the compiler. Another reason will become apparent when
we discuss modules in Chapter 18.
Type indexed datatypes are, similarly to functions, specialized to an application
of several components, thus constructor names can soon prevail and obfuscate
the code. While Haskell type synonyms have the advantage of not introducing
constructors, they are also subject to restrictions: they may not be recursive (not
even indirectly, except if a proper datatype intervenes), and they must always be
fully applied.
Because of these restrictions, not all specializations of type-indexed datatypes
can be made using type synonyms only. For example, the specialization to a type
argument that involves a recursive datatype will always be recursive and must
thus always involve a newtype . For systems of mutually recursive datatypes, it is
necessary to use a newtype somewhere, but not necessarily everywhere. Instead
of equipping the compiler with some heuristic that tries to determine when to
choose a newtype and when a type , we leave this choice to the user, and require
the user to explicitly make this choice before using the type.
Explicit specialization means that we cannot use a call such as lookup/angbracketleft[Int]/angbracketright
without preparation. Such a call would result in a specialization error, because
lookup/angbracketleft[Int]/angbracketrightrequires an FMap /angbracketleft[Int]/angbracketright. Whereas FMap/angbracketleftInt/angbracketrightis directly available
as a case of the deﬁnition, FMap cannot be automatically specialized to the list
type constructor [ ]. The type constructor [ ]is not in the signature of FMap, and
the compiler has to be instructed whether to generate the component using a
newtype or atype construct.
If we ﬁrst write
newtype FMap/angbracketleft[ ]/angbracketrightasFMapList ,
where FMapList is a constructor name, the call lookup/angbracketleft[Int]/angbracketrightcan be specialized
successfully. Such a construct is called a specialization request , and here asks
the compiler to specialize FMap to the list type using a newtype construct with
the constructor FMapList . As discussed above, we cannot use a type synonym
in this place because [ ]is a recursive datatype. An example for a specialization
request for a type synonym is
type FMap/angbracketleftBool/angbracketright.
240
16.3 Idea of the translation
Only newtype andtype statements are valid as specialization requests, because
the additional ﬂexibility of the data construct is of no use here. The type ar-
gument of a specialization request must be a single named type, or a (possibly
nested) type application to a named type. The latter occurs if a type-indexed
datatype is to be used on a type argument that contains a type-indexed datatype
again, such as in the call FMap /angbracketleftFMap/angbracketleft[Int]/angbracketrightChar/angbracketright, that describes the type of ﬁ-
nite maps which have keys that are ﬁnite maps from lists of integers to characters.
We then need a specialization request such as
newtype FMap/angbracketleftFMap/angbracketleft[ ]/angbracketright/angbracketrightasFMapFMapList
in addition to the specialization request for FMap to [ ](see also Section 16.8).
16.3 Idea of the translation
In this section, we will brieﬂy sketch how the FMap example is translated, before
formally discussing the process in Section 16.7.
For each of the cases in the FMap deﬁnition, a component is generated in the
output program, only that the component is now a type declaration instead of a
function declaration:
type Cp(FMap, Int ) v=IntMap v
type Cp(FMap, Char ) v=CharMap v
type Cp(FMap, Unit ) v=Maybe v
type Cp(FMap, Sum )Cp(FMap, α)Cp(FMap, β)v=
(Cp(FMap, α)v,Cp(FMap, β)v)
type Cp(FMap, Prod )Cp(FMap, α)Cp(FMap, β)v=
Cp(FMap, α) (Cp(FMap, β)v).
The internal operation Cpis the type level analogue to cp. It produces a named
type if applied to two named types, but a type variable if applied to a named type
and a dependency variable, as in Cp(FMap, α). The deﬁnition of FMap depends
on itself, hence the kind signature
FMap/angbracketlefta::∗/angbracketright::(FMap )⇒∗→∗ .
In the translation, we can see this fact reﬂected in the presence of two type argu-
ments for the dependencies that are provided to the Sum and Prod components.
A direct consequence of this translation scheme is that a reference to the type
FMap/angbracketleft[Int]/angbracketrightends up as a reference to the type Cp(FMap, [ ])Cp(FMap, Int )in
the resulting program. Such type applications in type arguments are always
241
16 Type-indexed Datatypes
simpliﬁed, and components are deﬁned for a type-indexed type applied to a
single named type.
A specialization request such as
newtype FMap/angbracketleft[α]/angbracketrightasFMapList
leads to the generation of a component of FMap for the list type constructor.
Because FMap is not deﬁned for lists, we make use of the genericity of FMap
and structurally represent the list datatype, much as we do for generic functions.
Recall that
type Str([ ]) ( a::∗) =Sum Unit (Prod a[a]),
We can specialize type-indexed types to type terms in analogy to how we special-
ize type-indexed functions to type terms. Thus, we can translate FMap /angbracketleftStr([ ])/angbracketright
to
type Cp(FMap, Str([ ])) ( Cp(FMap, α)::∗) =
Cp(FMap, Sum )
Cp(FMap, Unit )/parenleftbig
Cp(FMap, Prod )Cp(FMap, α)
(Cp(FMap, [ ])Cp(FMap, α))/parenrightbig
.
We deﬁne a type synonym Cp(FMap, Str([ ])) to hold the translation. For type-
indexed functions, we subsequently needed a wrapper to convert the component
for the structural representation type into a component for the original type.
The reason is that we were deﬁning two functions, one of which referred to the
structural representation type whereas the other had to refer to the original type.
The types of the components were dictated by the type signature of the function.
Here, the situation is much simpler! We deﬁne types, and their kinds are
dictated by the kind signature of the type indexed type, and the base kind of a
function is constant, i.e., it does not involve the type argument in any way. As a
consequence, the above component for the structural representation has the same
kind as Cp(FMap, [ ]), and we can almost use it as it stands as the component
for lists itself. The only thing we have to add is a newtype construct with the
constructor that has been requested:
newtype Cp(FMap, [ ]) ( Cp(FMap, α)::∗) =
FMapList (Cp(FMap, Str([ ])) Cp(FMap, α)).
In addition, we generate another embedding-projection pair:
ep(Cp(FMap, [ ])) ::∀a::∗. EP (Cp(FMap, [ ])a) (Cp(FMap, Str([ ])) a)
242
16.3 Idea of the translation
ep(Cp(FMap, [ ])) = letfrom (FMapList x ) =x
to x =FMapList x
inEP from to .
We need these conversion functions when translating type-indexed functions that
make use of type-indexed datatypes.
For a specialization request to a type synonym, such as
type FMap/angbracketleftBool/angbracketright,
we have to perform even less work. The component for the structural represen-
tation is in this case
type Cp(FMap, Str(Bool )) =
Cp(FMap, Sum )Cp(FMap, Unit )Cp(FMap, Unit ),
and it can directly be used as the component for the original type, which in this
case is also a type synonym:
type Cp(FMap, Bool ) =Cp(FMap, Str(Bool )).
Hence, the embedding-projection pair in this case is the identity pair EP id id .
If we want to translate type-indexed functions on type-indexed datatypes, we
can proceed almost as before. For example, the specialization of call lookup/angbracketleft[Int]/angbracketright
would require the component cp(lookup ,[ ])to be generated. As before, we go via
the structure type, and can deﬁne the component as a translation of a wrapper of
the following form:
lookup/angbracketleft[α]/angbracketright=
let. . .
into bimap/angbracketleft. . ./angbracketright(lookup/angbracketleftStr([ ])α/angbracketright),
but we have to adapt the bimap call slightly. Previously, we would have ﬁlled
in the base type of lookup for the type argument, mbase (lookup/angbracketleftβ/angbracketright), the generic
slot instantiated to a fresh dependency variable, and then redeﬁned bimap/angbracketleftβ/angbracketright=
ep([ ])on this dependency variable.
However, mbase (lookup/angbracketleftβ/angbracketright)is
∀v::∗.β→FMap/angbracketleftβ/angbracketrightv→Maybe v.
Apart from the fact that there is a universally quantiﬁed type variable of kind ∗in
this type, which we can handle according to the methods in Section 11.3, a more
imminent problem is that this type is not of kind ∗! The dependency variable β
appears in the type argument of FMap, and FMap depends on itself. Hence, the
243
16 Type-indexed Datatypes
above type has an unsatisﬁed dependency constraint on the kind level, and is of
the qualiﬁed kind
(FMap/angbracketleftβ/angbracketright::∗→∗ )⇒∗ .
Furthermore, we should be aware that the type of lookup/angbracketleftStr([ ])α/angbracketrightturns out
to be
∀a::∗.(lookup/angbracketleftα/angbracketright::∀v::∗.a→FMap/angbracketlefta/angbracketrightv→Maybe v)
⇒∀v::∗.Str([ ])a→FMap/angbracketleftStr([ ])a/angbracketrightv→Maybe v.
Here, the type Str([ ]) appears within the type argument of FMap! As we have
just seen, FMap/angbracketleftStr([ ])/angbracketrightcorresponds to Cp(FMap, Str([ ])) , which can be con-
verted into the component for the original type Cp(FMap, [ ])via the embedding-
projection pair ep(Cp(FMap, [ ])).
The solution is to use local redeﬁnition on the type level to get rid of the depen-
dency constraint in such a way that we can use ep(Cp(FMap, [ ]))at the position
of FMap/angbracketleftβ/angbracketrightin the base type:
lookup/angbracketleft[α]/angbracketright=
letbimap/angbracketleftβ/angbracketright=ep([ ])
bimap/angbracketleftγ/angbracketright=ep(Cp(FMap, [ ]))
into bimap/angbracketleftLet type FMap/angbracketleftβ/angbracketright(a::∗) =γInmbase (lookup/angbracketleftβ/angbracketright)/angbracketright
(lookup/angbracketleftStr([ ])α/angbracketright).
We choose to redeﬁne FMap /angbracketleftβ/angbracketrightto another dependency variable, γ, which in
turn creates another dependency of the bimap function, for which we can plug in
the desired embedding-projection pair.
16.4 Local redeﬁnition on the type level
What we have just seen while deﬁning the wrapper for lookup/angbracketleft[α]/angbracketright, is an example
of local redeﬁnition on the type level. Local redeﬁnition works on the type level
in much the same way as on the value level (cf. Chapter 8). However, local
redeﬁnition is a construct that appears within type expressions. For example, we
could write
Let type FMap/angbracketleftα/angbracketright(a::∗) = [ a]
InFMap/angbracketleftTree α/angbracketright
to locally use a list of values as a ﬁnite map implementation for keys which are
of the element type of the Tree.
244
16.5 Generic abstraction on the type level
In the lookup example, we have used a dependency variable on the right hand
side,
Let type FMap/angbracketleftβ/angbracketright(a::∗) =γ
Inmbase (lookup/angbracketleftβ/angbracketright).
This is possible because the entire type expression is used as a type argument in
this case.
Although we have used type synonyms in the declaration part of the local
redeﬁnition, it is theoretically possible to use newtype anddata as well, just as
all three type deﬁnition constructs may appear in the arms of a typecase.
On the value level, we translate a local redeﬁnition by mapping it to a normal
let statement in fcr(cf. Section 8.5). On the type level, however, there is no Let.
We therefore must, in essence, add a Letto the type language: the translation
should substitute the types declared in a Letwithin the body of the construct.
We can also lift the short notation of Section 8.1 to the type level, which al-
lows us to write local redeﬁnition as type application when there is only one
dependency. Using short notation, we could write the ﬁrst example above as
FMap/angbracketleftTree/angbracketright[ ]
instead. Another example of local redeﬁnition on the type level appears in Sec-
tion 16.6.
16.5 Generic abstraction on the type level
Local redeﬁnition is not the only concept from type-indexed functions that can
be transferred to type-indexed datatypes: type-indexed types can also be deﬁned
via generic abstraction. For instance, if we want to ﬁx the value type of a ﬁnite
map to Int, without ﬁxing the key type, we can deﬁne
type Frequency/angbracketleftα::∗/angbracketright=FMap/angbracketleftα/angbracketrightInt .
Whereas generic abstraction and local redeﬁnition are almost indistinguishable
syntactically on the value level, they are clearly separated on the type level. Type-
level local redeﬁnition is a construct in the language of types, whereas generic
abstraction uses a type declaration to deﬁne a new entity. Much as a typecase-
based deﬁnition, a deﬁnition via generic abstraction can also make use of all
three type deﬁnition keywords – type ,newtype , and data – with their usual
differences.
245
16 Type-indexed Datatypes
16.6 The Zipper
The zipper (Huet 1997) is a data structure that is used to represent a tree together
with a subtree that is the focus of attention, where that focus may move left,
right, up or down in the tree. The zipper is used in applications where the user
interactively manipulates trees; for instance, in editors for structured documents
such as proofs or programs.
The focus of the zipper may only move to recursive components. Consider, for
example, the datatype Tree:
data Tree (a::∗) =Leaf|Node (Tree a)a(Tree a).
If the left subtree is the current focus, moving right means moving to the right
subtree, not to the label of type a. We therefore must have access to the recursive
positions in the tree, and thus decide to represent datatypes as ﬁxpoints of their
pattern functors, as we have done before in Section 12.3.
The zipper works on locations, where locations are pairs of a value of the
datatype over which we navigate (the focus), together with a context (represent-
ing the rest of the structure). The type of locations is a type-indexed type, deﬁned
via generic abstraction:
type Loc/angbracketleftγ::∗→∗/angbracketright =/parenleftBig
Fix(ID/angbracketleftγ/angbracketright), Context/angbracketleftγ/angbracketright/parenleftbig
Fix(ID/angbracketleftγ/angbracketright)/parenrightbig/parenrightBig
.
The location type is parametrized over a type of kind ∗→∗ , the pattern functor of
a datatype. This requires the datatype we want to navigate on to be transformed
manually into such a form that it can be expressed as a ﬁxpoint of a pattern
functor. The pattern functor thus obtained for the tree type is
data TreeF (a::∗) (b::∗) =LeafF|NodeF b a b ,
and Tree ais isomorphic to Fix (TreeF a)(cf. Sections 12.3 and 17.2).
The type Loc depends on two other type-indexed types, ID and Context, and
thus has kind
Loc/angbracketlefta::∗→∗/angbracketright ::(Context, ID )⇒∗ .
The type-indexed type ID is built-in and somewhat special. It is the identity type-
indexed type and reduces to the type argument for all types. One can think of it
as being implicitly deﬁned as
type ID/angbracketleftT{αi}i∈1..n/angbracketright=T{(ID/angbracketleftαi/angbracketright)}i∈1..n
for all named types T, including abstract types. Another possible way to look at
the ID type is as a way to convert a dependency variable into a type that can be
used in an ordinary type expression.
246
16.6 The Zipper
The type of contexts Context stores a path from the root of the tree to the
current point of focus, and in addition it stores the information on that path,
so that we can merge the context with the point of focus to get the complete
structure – hence the name “zipper” for the complete data structure.
For a functor, the generic type Ctx is deﬁned to hold the possible paths:
Ctx/angbracketlefta::∗/angbracketright::(Ctx, ID )⇒∗
type Ctx/angbracketleftInt/angbracketright =Zero
type Ctx/angbracketleftChar/angbracketright =Zero
type Ctx/angbracketleftUnit/angbracketright =Zero
type Ctx/angbracketleftSum α β/angbracketright=Sum (Ctx/angbracketleftα/angbracketright) (Ctx/angbracketleftβ/angbracketright)
type Ctx/angbracketleftProd α β/angbracketright=Sum/parenleftbig
Prod (Ctx/angbracketleftα/angbracketright) (ID/angbracketleftβ/angbracketright)/parenrightbig
/parenleftbig
Prod (ID/angbracketleftα/angbracketright) (Ctx/angbracketleftβ/angbracketright)/parenrightbig
.
This type can de seen as the derivative (as in calculus) of a datatype (McBride
2001). The real type of contexts Context is deﬁned as the ﬁxpoint of a variation
of type Ctx, namely as
Context/angbracketlefta::∗→∗/angbracketright ::(Ctx, ID )⇒∗→∗
type Context/angbracketleftγ::∗→∗/angbracketright (a::∗) =Fix(CtxF/angbracketleftγ/angbracketrighta),
where CtxF is deﬁned via generic abstraction from Ctx below. Because the type
Context represents paths down the structure of a tree, we must provide the pos-
sibility for a path to end. Therefore, we allow an occurrence of Stop in each
recursive position, which marks the end of the path, or Down , which expresses
that the path continues to the next recursive layer:
data CtxF/angbracketleftγ::∗→∗/angbracketright (a::∗) (r::∗) =Stop
|Down (Let type Ctx/angbracketleftα/angbracketright=a
type ID/angbracketleftα/angbracketright=r
InCtx/angbracketleftγ α/angbracketright).
Having made these preparations, we are now able to deﬁne navigation functions
up,down ,left, and right on locations, that move the focus to the parent node, the
leftmost child, to the next child on the same level to the left, and to the next child
on the same level to the right, respectively. Here, we will only deﬁne down . For a
far more thorough treatment with more explanations and examples, consult the
paper on type-indexed datatypes (Hinze et al. 2002).
We deﬁne down in terms of ﬁrst, which tries to determine the leftmost recursive
child in the tree. We simulate a function that is indexed over functors of kind
∗→∗ , in the same way as described in Section 12.5:
247
16 Type-indexed Datatypes
ﬁrst/prime/angbracketlefta::∗/angbracketright::(ﬁrst/prime/angbracketlefta/angbracketright)⇒∀b::∗.a→Maybe (b, Ctx/angbracketlefta/angbracketright)
ﬁrst/prime/angbracketleftInt/angbracketright x =Nothing
ﬁrst/prime/angbracketleftChar/angbracketright x =Nothing
ﬁrst/prime/angbracketleftUnit/angbracketright Unit =Nothing
ﬁrst/prime/angbracketleftSum α β/angbracketright(Inl x ) = do(t,cx)←ﬁrst/prime/angbracketleftα/angbracketrightx
return (t,Inl cx )
ﬁrst/prime/angbracketleftSum α β/angbracketright(Inr x ) = do(t,cx)←ﬁrst/prime/angbracketleftβ/angbracketrightx
return (t,Inr cx )
ﬁrst/prime/angbracketleftProd α β/angbracketright(x1×x2) =/parenleftbig
do(t,cx1)←ﬁrst/prime/angbracketleftα/angbracketrightx1
return (t,Inl(cx1×x2))/parenrightbig
‘mplus ‘/parenleftbig
do(t,cx2)←ﬁrst/prime/angbracketleftβ/angbracketrightx2
return (t,Inr(x1×cx2))/parenrightbig
ﬁrstId x c =Just (x,c)
ﬁrst/angbracketleftf::∗→∗/angbracketright ::
(ﬁrst/prime/angbracketleftf/angbracketright)⇒∀ (b::∗) (c::∗).f b→c→Maybe (b, Ctx/angbracketleftf/angbracketrightb c)
ﬁrst/angbracketleftγ::∗→∗/angbracketright x c =letﬁrst/prime/angbracketleftα/angbracketrightx=ﬁrstId x c
inﬁrst/prime/angbracketleftγ α/angbracketrightx
We pass to the ﬁrst function the opened functor, and the context. If ﬁrst suc-
ceeds and ﬁnds a child, it returns the child paired with the new context. We use
do-notation for the Maybe monad in the deﬁnition, to simplify the presentation.
The type Unit as well as primitive types of kind ∗such as Int and Char have no
children, we thus return Nothing . In the Sum case, we try to ﬁnd the ﬁrst child of
whatever alternative the value we get belongs to. The Prod case is most interest-
ing. We ﬁrst try to ﬁnd a child of the left component, and only if that does not
exist, we proceed to look in the right component.
We can now deﬁne down to shift focus to the leftmost child if there is any, and
to do nothing if no children exist:
down/angbracketleftf::∗→∗/angbracketright ::(ﬁrst/prime/angbracketleftf/angbracketright)⇒Loc/angbracketleftf/angbracketright→ Loc/angbracketleftf/angbracketright
down/angbracketleftγ::∗→∗/angbracketright (x,c) =case ﬁrst/angbracketleftγ/angbracketright(out x )cof
Nothing→(x,c)
Just (newx ,newc )→(newx ,In(Down newc )).
The function down depends on ﬁrst/prime– it is deﬁned in terms of generic abstrac-
tion on ﬁrst, but ﬁrst is itself a generic abstraction over ﬁrst/prime. However, down is
intended to be used on constant types of kind ∗→∗ , thus the dependency is
mostly irrelevant.
248
16.7 Implementation of type-indexed datatypes
16.7 Implementation of type-indexed datatypes
In this section, we describe how type-indexed datatypes can be translated. In
many aspects, the algorithms needed here correspond to the mechanisms that
we have introduced for type-indexed functions. And because type-indexed types
are not parametrized by type tuples, but always by single types, the analogous
situation for type-indexed functions that is described in Chapter 6 is the closest
match.
It helps to compare the rules for type-indexed types with the counterparts for
type-indexed functions, therefore the references to the corresponding rules are
always provided.
Because it would lead to too much duplication of concepts, we omit some of the
less interesting parts of the translation, such as the translation of environments.
After having introduced the additional syntax in Section 16.7.1, we discuss several
aspects of the translation: qualiﬁed kinds, generic application, types and type ar-
guments, expressions, type declarations, and ﬁnally declarations of type-indexed
functions.
16.7.1 Syntax of fcrt+gftx
Figure 16.2 shows all syntactic extensions that are necessary to cover type-indexed
types, including local redeﬁnition and generic abstraction on the type level.
We deviate from the syntax used in the examples and write type-indexed types
using a Typecase construct (corresponding to typecase for type-indexed func-
tions). Furthermore, we do not allow type ,newtype , and data to appear directly
in type-indexed type deﬁnitions, local redeﬁnitions, and generic abstraction, but
require all the right hand sides to be ordinary types. This restriction is made here
to simplify the presentation.
It is, however, easy to translate the syntax used in the previous sections to the
syntax that we use for the formal language. The deﬁnition for type-indexed tries,
as given in Section 16.1, was
type FMap/angbracketleftInt/angbracketright v=IntMap v
type FMap/angbracketleftChar/angbracketright v=CharMap v
type FMap/angbracketleftUnit/angbracketright v=Maybe v
type FMap/angbracketleftSum α β/angbracketrightv= (FMap/angbracketleftα/angbracketrightv, FMap/angbracketleftβ/angbracketrightv)
type FMap/angbracketleftProd α β/angbracketrightv=FMap/angbracketleftα/angbracketright(FMap/angbracketleftβ/angbracketrightv).
In a ﬁrst step, we move all arms under a Typecase construct:
FMap/angbracketlefta/angbracketright=Typecase aof
Int→typeΛv::∗. IntMap v
Char→typeΛv::∗. CharMap v.
249
16 Type-indexed Datatypes
Type declarations
D::=. . . everything from Figure 15.1
|T/angbracketlefta/angbracketright=Typecase aof{Pi→ti}i∈1..n
;
type-indexed datatype declaration
|newtype T/angbracketleftR/angbracketrightasCnewtype specialization request
|type T/angbracketleftR/angbracketright type specialization request
|T/angbracketleftα::κ/angbracketright=t type-level generic abstraction
Types
t,u::=. . . everything from Figure 3.1
|T/angbracketleftA/angbracketright type-level generic application
|LetT/angbracketleftα{(γi::κi)}i∈1..n/angbracketright=t1Int2
type-level local redeﬁnition
Type arguments
A::=. . . everything from Figure 6.1
|T/angbracketleftA/angbracketright type-level generic application
|LetT/angbracketleftα{(γi::κi)}i∈1..n/angbracketright=A1InA2
type-level local redeﬁnition
Specialization request patterns
R::=T named type
|T/angbracketleftR/angbracketright type-indexed datatype component
Kind signatures
¯σ::= ({Tk}k∈1..n
, )⇒κ kind signature of type-indexed datatype
Qualiﬁed kinds
ρ::= (¯∆)⇒κ qualiﬁed kind
Kind constraint sets
¯∆::={¯Yi}i∈1..n
, kind constraint set
Kind constraints
¯Y::=T/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::ρ0
kind dependency constraint
Figure 16.2: Syntax of type-indexed datatypes in language fcrt+gftx
250
16.7 Implementation of type-indexed datatypes
Unit→typeΛv::∗. Maybe v
Sum α β→typeΛv::∗.(FMap/angbracketleftα/angbracketrightv, FMap/angbracketleftβ/angbracketrightv)
Prod α β→typeΛv::∗. FMap/angbracketleftα/angbracketright(FMap/angbracketleftβ/angbracketrightv)
Now, we assume that we have deﬁned top-level type synonyms such that we can
get rid of the type deﬁnitions in the arms of the Typecase :
type FMapSum (a::∗→∗ ) (b::∗→∗ ) (v::∗) = ( a v,b v)
type FMapProd (a::∗→∗ ) (b::∗→∗ ) (v::∗) =a(b v).
The deﬁnition of the type-indexed type FMap then becomes
FMap/angbracketlefta/angbracketright=Typecase aof
Int→IntMap
Char→CharMap .
Unit→Maybe
Sum α β→FMapSum (FMap/angbracketleftα/angbracketright) (FMap/angbracketleftβ/angbracketright)
Prod α β→FMapProd (FMap/angbracketleftα/angbracketright) (FMap/angbracketleftβ/angbracketright)
This deﬁnition is legal according to the syntax in Figure 16.2. Cases declared us-
ingdata ornewtype constructs can be handled in a similar way. A full compiler
would allow the more convenient syntax used in the examples, and implicitly in-
troduce additional type declarations such as FMapSum and FMapProd as needed.
This technique works for local redeﬁnition and generic abstraction as well.
The other syntactic extensions are the explicit specialization requests as de-
scribed in Section 16.2, generic application on the type level to instantiate type-
indexed datatypes, and everything that is related to kind signatures of type-
indexed datatypes and qualiﬁed kinds.
Note that generic application and local redeﬁnition are added not only to the
language of types, but also to the language of type arguments. This makes it
possible to call generic functions on instances of type-indexed types, so that we
can, for example, compare two type-indexed tries for equality using the generic
equal function.
Kind signatures list as dependencies a set of named types, and have a constant
base kind . Qualiﬁed kinds are derived internally from a kind signature using a
type level generic application algorithm. They are very similar to qualiﬁed types:
a kind preﬁxed by a list of kind dependency constraints, where each of the de-
pendency constraints associates the name of a type-indexed type at a dependency
variable (possibly with arguments) with a kind.
For some of the syntactic categories related to type-indexed datatypes (signa-
tures, kind constraint sets, kind constraints), we reuse the latter for metavariables
of the equivalent category for type-indexed functions, with a bar on top.
251
16 Type-indexed Datatypes
16.7.2 Translation of qualiﬁed kinds
K/turnstileleft¯Y
K/prime≡K{,αi::κi}i∈1..n
K/prime/turnstileleftα0{αi}i∈1..n::∗
T/angbracketlefta::∗/angbracketright::({Tk}k∈1../lscript
, )⇒κ∈K
K/prime/turnstileleftρ
K/turnstileleftT/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::ρ(k-constraint)
Figure 16.3: Well-formedness of kind dependency constraints in fcrt+gftx of Figure 16.2,
compare with Figure 6.4
K/turnstileleftρ
{K/turnstileleft¯Yj}j∈1..n
K/turnstileleft({¯Yj}j∈1..n
, )⇒κ(k-qual)
Figure 16.4: Well-formedness of qualiﬁed kinds in fcrt+gftx of Figure 16.2, compare with
Figure 6.5
Figures 16.3 and 16.4 specify under which conditions qualiﬁed kinds are well-
formed: a qualiﬁed kind is well-formed if each of the dependency constraints is
well-formed. A constraint is well-formed if it refers to a named type which is
in scope, i.e., which has a kind signature in the kind environment, if the type
argument is of kind ∗, and if the qualiﬁed kind in the constraint is well-formed.
As for type dependency constraints (cf. Section 6.1), we assume that there is a
canonical order for kind dependency constraints, so that we can translate quali-
ﬁed kinds in a deterministic way by replacing constraints with arrows, as detailed
in Figure 16.5. The idea is exactly the same as for qualiﬁed types, the situation is
simpler though, because there are no quantiﬁed variables involved.
There is a subsumption relation on qualiﬁed kinds, shown in Figure 16.6. The
relation is simpler than the equivalent one on qualiﬁed types because it only
252
16.7 Implementation of type-indexed datatypes
/llbracketρfcrt+gftx/rrbracketgftx≡κfcrt
/llbracket¯∆/rrbracketgftx≡κ/prime[•]
/llbracket(¯∆)⇒κ/rrbracketgftx≡κ/prime[κ](tr-qkind)
/llbracket¯∆fcrt+gftx/rrbracketgftx≡κfcrt[•]
/llbracketε/rrbracketgftx≡•(tr-kconstraint-1)
/llbracket¯∆/rrbracketgftx≡κ/prime[•]
/llbracketρ/rrbracketgftx≡κ
/llbracket¯∆,T/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::ρ/rrbracketgftx≡κ/prime[κ→• ](tr-kconstraint-2)
Figure 16.5: Translation of qualiﬁed kinds and kind dependency constraints in fcrt+gftx,
compare with Figure 6.9
¯∆/turnstileleftρ1/lessorequalslantρ2/squigglerightt[•]
¯∆1,¯∆2/turnstileleftρ/lessorequalslantκ/squigglerightt[•]/turnstileleft¯∆2/squigglerightt¯∆[•]
¯∆1/turnstileleftρ/lessorequalslant(¯∆2)⇒κ/squigglerightt¯∆[t[•]](rhos-dep-1)
¯∆2⊩¯∆1/squigglerightt[•]
¯∆2/turnstileleft(¯∆1)⇒κ/lessorequalslantκ/squigglerightt[•](rhos-dep-2)
Figure 16.6: Subsumption relation on qualiﬁed kinds, compare with Figure 6.10
253
16 Type-indexed Datatypes
involves the addition or removal of kind dependency constraints, whereas the
type-level equivalent (cf. Figure 6.10) must handle universal quantiﬁcations as
well. The rules in Figure 16.6 make use of a conversion and an entailment judg-
ment, of the forms
/turnstileleft¯∆/squigglerightt[•]
¯∆1⊩¯∆2/squigglerightt[•].
They correspond directly to the judgments displayed in Figures 6.11 and 6.12 on
pages 87 and 88, and do not provide anything new. They are therefore omitted
here.
16.7.3 Translation of generic application
A central part of the treatment of type-indexed datatypes is the translation of
generic application on the type level. We present two algorithms: the generic
application algorithm Gapp , which corresponds to gapp on pages 78 and 100 in
Figures 6.8 and 6.19; and the generic translation algorithm /llbracket·/rrbracketGtrans, which corre-
sponds to /llbracket·/rrbracketgtranson page 94 in Figure 6.18. The former assigns a qualiﬁed kind
to a generic application, using the kind signature of the type-indexed datatype,
while the latter specializes a generic application to an application of components
of a type-indexed datatype.
Before we can proceed to the ﬁrst of the two, we require some judgments to
access information on the kind signatures. Kind signatures are stored in the kind
environment, as we have already assumed in the rules for the well-formedness of
qualiﬁed kinds. Kind signatures have a base kind , which is the part to the right
of the list of dependencies and the double arrow. Other than the base type, the
base kind of a type-indexed datatype is constant. The base kind of a type-indexed
datatype Tcan be accessed using a judgment of the form
Base K(T)≡κ.
The dependencies can be determined using a judgment of the form
DependenciesK(T)≡{Tk}k∈1..n
, .
The corresponding rules are presented in Figure 16.7.
In Figure 16.8, we show how to check the well-formedness of a kind signature:
a transitivity condition must hold such as in rule (typesig) in Figure 6.7 for type-
indexed functions, and for reasons analogous to those explained in Section 5.4; all
type-indexed datatypes named in the dependencies must themselves have valid
kind signatures, and all indirect dependencies must also be direct dependencies.
254
16.7 Implementation of type-indexed datatypes
Base K(T)≡κ
T/angbracketlefta::∗/angbracketright::({Tk}k∈1..n
, )⇒κ∈K
Base K(T)≡κ(Base)
DependenciesK(T)≡{Tk}k∈1..n
,
T/angbracketlefta::∗/angbracketright::({Tk}k∈1..n
, )⇒κ∈K
DependenciesK(T)≡{Tk}k∈1..n
,(Deps)
Figure 16.7: Extracting information from the kind signature of a type-indexed datatype,
compare with Figure 6.6
K/turnstileleftksigT/angbracketlefta::∗/angbracketright::¯σ
/braceleftbig
K/turnstileleftksigTk/angbracketlefta::∗/angbracketright::({Tk,i}i∈1..mk, )⇒κk/bracerightbigk∈1..n
/braceleftbig{Tk,i∈{Tj}j∈1..n
,}i∈1..mk/bracerightbigk∈1..n
K/turnstileleftksigT/angbracketlefta::∗/angbracketright::({Tk}k∈1..n
, )⇒κ(kindsig)
Figure 16.8: Well-formedness of kind signatures for type-indexed datatypes, compare with
Figure 6.7
255
16 Type-indexed Datatypes
GappK(T/angbracketleftA/angbracketright)≡ρ
K/turnstileleftA::∗ fdv(A)≡ε
GappK(T/angbracketleftA/angbracketright)≡Base K(T)(Ga-1)
K/turnstileleftα::κ afresh K/prime≡K,a::κ
GappK(T/angbracketleftα{Ai}i∈1..n/angbracketright)≡(MkdepK/prime(T/angbracketleftα←a/angbracketright))
⇒GappK/prime(T/angbracketlefta{Ai}i∈1..n/angbracketright)(Ga-2)
α∈fdv(A) head (A)/negationslash≡α
K/turnstileleftα::κ afresh K/prime≡K,a::κ
DependenciesK(T)≡{Tk}k∈1..n
,
GappK(T/angbracketleftA/angbracketright)≡({MkdepK/prime(Tk/angbracketleftα←a/angbracketright)}k∈1..n
, )
⇒GappK/prime(T/angbracketleftA[a/α]/angbracketright)(Ga-3)
fdv(A)≡ε K/turnstileleftA::κ→κ/prime
afresh K/prime≡K,a::κ
DependenciesK(T)≡{Tk}k∈1..n
,
GappK(T/angbracketleftA/angbracketright)≡{GappK/prime(Tk/angbracketlefta/angbracketright)→}k∈1..nGappK/prime(T/angbracketleftA a/angbracketright)(Ga-4)
MkdepK(T/angbracketleftα←a/angbracketright)≡¯Y
K/turnstileleftα::κ κ≡{κh→}h∈1../lscript∗
{γhfresh}h∈1../lscriptK/prime≡K{,γh::κh}h∈1../lscript
MkdepK(T/angbracketleftα←a/angbracketright)
≡T/angbracketleftα{γh}h∈1../lscript/angbracketright::GappK(T/angbracketlefta{γh}h∈1../lscript/angbracketright)(Mkdep)
Figure 16.9: Generic application algorithm for type-indexed datatypes, compare with Fig-
ures 6.8 and 6.19
256
16.7 Implementation of type-indexed datatypes
/llbracketT/angbracketleftA/angbracketright/rrbracketGtrans
K;¯Σ;Ψ≡tfcrt
T/angbracketleftT/prime/angbracketright∈¯Σ
/llbracketT/angbracketleftT/prime/angbracketright/rrbracketGtrans
K;¯Σ;Ψ≡Cp(T,T/prime)(Gtr-named)
T/angbracketlefta/angbracketright∈¯Σ
/llbracketT/angbracketlefta/angbracketright/rrbracketGtrans
K;¯Σ;Ψ≡Cp(T,a)(Gtr-var)
Cp(T,α)≡t∈Ψ
/llbracketT/angbracketleftα/angbracketright/rrbracketGtrans
K;¯Σ;Ψ≡t(Gtr-depvar)
DependenciesK(T)≡{Tk}k∈1../lscript
,
/llbracketT/angbracketleftA1A2/angbracketright/rrbracketGtrans
K;¯Σ;Ψ≡/llbracketT/angbracketleftA1/angbracketright/rrbracketGtrans
K;Σ;Ψ{/llbracketTk/angbracketleftA2/angbracketright/rrbracketGtrans
K;¯Σ;Ψ}k∈1../lscript(Gtr-app)
Figure 16.10: Translation of generic application of type-indexed datatypes in language
fcr+tif+par, compare with Figure 6.18
Now let us have a look at the generic application algorithm on the type level,
in Figure 16.9. The four rules of the algorithm Gapp and the auxiliary judg-
ment Mkdep to create a single dependency constraint, correspond directly to the
rules in Figures 6.8 and 6.19 for gapp and mkdep . Rule (Ga-1) returns the base
kind if the type argument is without dependency variables and of kind ∗. For
type arguments with dependency variables, kind dependencies are introduced in
rules (Ga-2) and (Ga-3), using the rule (Mkdep) to generate the actual constraint.
Rule (Ga-2) handles the special case that a dependency variable αis the head of
the type argument of type-indexed type T, which always causes a dependency
onTforα. The rule (Ga-4) is for type arguments without dependency variables,
but of a kind different than ∗. This rule is similar to (Ga-3), but instead of depen-
dency constraints, (type-level) function arguments are introduced.
Using this algorithm, one can determine the kinds that instances of type-
indexed types must have for speciﬁc type arguments. For example, we can verify
the kinds given in Figure 16.1 on page 238 for applications of FMap to different
type arguments.
257
16 Type-indexed Datatypes
The associated translation algorithm in Figure 16.10 has judgments of the form
/llbracketT/angbracketleftA/angbracketright/rrbracketGtrans
K;Σ;Ψ≡tfcrt,
transforming a generic application of a type-indexed datatype Tto a type argu-
ment Ainto an fcrt type tfcrt. If the type argument of the application is a named
type T/prime, then rule (Gtr-named) replaces the application with a reference to the
appropriate component, under the condition that an entry T/angbracketleftT/prime/angbracketrightis contained
in the signature environment. Recall that we use Cpto produce the names of
components for type-indexed datatypes.
A type variable is treated in the same way as a named type, as described by
rule (Gtr-var). Generic application to normal (not dependency) type variables
occurs sometimes for universally quantiﬁed type variables. The translation of
universal quantiﬁcation is such that additional type variables for components
of the form Cp(T,a)may be brought into scope. This translation of universal
quantiﬁcation is described in Section 16.7.4.
If the type argument is a dependency variable, as in rule (Gtr-depvar), we check
environment Ψfor an entry of the form Cp(T,α)≡t, and use tas translation. To
keep the rule simple, we implicitly assume that Ψcontains entries of the form
Cp(T,α)≡Cp(T,α)for each type-indexed type Tand each dependency variable
αin scope. These default entries are overwritten if a type-level local redeﬁnition is
encountered, as described in Section 16.7.4. Because the target language fcrt pro-
vides no type-level Let, we choose to store local redeﬁnitions in the environment
Ψand apply them here, during the translation of generic application.
The ﬁnal rule, (Gtr-app), translates a generic application of Tto a type argu-
ment that consists itself of an application (A1A2). The result is the translation of
T/angbracketleftA1/angbracketright, applied to all Tk/angbracketleftA2/angbracketright, where the Tkare the dependencies of T. As in the
algorithm for type-indexed functions, in Figure 6.18 on page 94, we thus trans-
late an application in the type argument to an application of the translations, and
keep the whole algorithm compositional. We have described in Section 6.6 that
the way in which we translate generic applications of type-indexed functions cor-
responds to the use of kind-indexed types internally. In analogy, our translation
here treats type-indexed types as if they possessed kind-indexed kinds. This anal-
ogy is described in more detail in the paper on type-indexed datatypes (Hinze
et al. 2002).
The translation algorithm just described cannot handle type arguments con-
taining generic application or local redeﬁnition. We will see in the next section
that we simplify these constructs prior to calling the algorithm.
258
16.7 Implementation of type-indexed datatypes
/llbrackettfcrt+gftx::κfcrt+gftx/rrbracketgftx
K;¯∆;¯Σ;Ψ≡tfcrt
T/angbracketlefta::∗/angbracketright::¯σ∈K
K/prime≡K{,γi::κi}i∈1..nκ/prime≡{κi→}i∈1..n∗
Ψ/prime≡Ψ,Cp(T,α) =t/prime
1¯∆/prime≡¯∆,T/angbracketleftα{(γi::κi)}i∈1..n/angbracketright::ρ1
/llbrackett1::ρ1/rrbracketgftx
K/prime;¯∆;¯Σ;Ψ≡t/prime
1/llbrackett2::κ/rrbracketgftx
K,α::κ/prime;¯∆/prime;¯Σ;Ψ/prime≡t/prime
2/largellbracket
LetT/angbracketleftα{(γi::κi)}i∈1..n/angbracketright=t1Int2::κ/largerrbracketgftx
K;¯∆;¯Σ;Ψ≡t/prime
2(t/tr-let-lr)
{Base K(Ti)≡κi}i∈1..n
K/prime≡K,a::κΣ/prime≡Σ{,Ti/angbracketlefta/angbracketright}i∈1..n
/llbrackett::∗/rrbracketgftx
K/prime;¯∆;¯Σ/prime;Ψ≡t/prime
/llbracket∀a::κ.t::∗/rrbracketgftx
K;¯∆;¯Σ;Ψ≡∀a::κ.{∀(Cp(Ti,a)::κi).}i∈1..nt/prime(t/tr-forall)
/llbracketA::∗/rrbracketgftx
K;¯∆;¯Σ;Ψ≡A/prime
GappK(T/angbracketleftA/prime/angbracketright)≡ρ /llbracketT/angbracketleftA/prime/angbracketright/rrbracketGtrans
K;¯Σ;Ψ≡t
K;¯∆/turnstileleftρ/lessorequalslantκ
/llbracketT/angbracketleftA/angbracketright::κ/rrbracketgftx
K;¯∆;¯Σ;Ψ≡t(t/tr-genapp)
Figure 16.11: Translation of fcrt+gftx types to fcrt
259
16 Type-indexed Datatypes
/llbrackettfcrt+gftx::ρfcrt+gftx/rrbracketgftx
K;¯∆;¯Σ;Ψ≡tfcrt
/llbrackett::κ/rrbracketgftx
¯∆,¯∆/prime≡t/prime
¯∆/turnstileleftκ/lessorequalslant(¯∆/prime)⇒κ/squigglerightt/prime/prime[•]
/llbrackett::(¯∆/prime)⇒κ/rrbracketgftx
¯∆≡t/prime/prime[t/prime](t/tr-reveal)
/llbrackett::ρ1/rrbracketgftx≡t/prime
/turnstileleftρ1/lessorequalslantρ2/squigglerightt/prime/prime[•]
/llbrackett::ρ2/rrbracketgftx≡t/prime/prime[t/prime](t/tr-subs)
Figure 16.12: Revelation of kind dependency constraints in fcrt+gftx, compare with Fig-
ure 6.14
16.7.4 Translation of types and type arguments
With the rules for handling generic application available, we can now tackle kind
checking and translation of types and type arguments. Judgments are of the form
/llbrackettfcrt+gftx::κfcrt+gftx/rrbracketgftx
K;¯∆;¯Σ;Ψ≡tfcrt,
expressing that type tfcrt+gftxof kind κfcrt+gftxtranslates to type tfcrt. We need the
kind environment K, containing – among other things – the kind signatures of
type-indexed datatypes, a kind dependency environment ¯∆, a signature environ-
ment ¯Σfor type-indexed datatypes, and the environment Ψfor type synonyms.
The rules are given in Figure 16.11.
Next to the two new constructs in the type language, local redeﬁnition and
generic application, also the translation of universal quantiﬁcation needs discus-
sion. Rule (t/tr-let-lr) is for the type-level Letconstruct, which exists only for the
purpose of local redeﬁnition. In contrast to the expression-level let, it contains
only one binding and is non-recursive. In the examples, we have used the con-
struct with multiple bindings, which is to be understood as syntactic sugar for a
nested Letstatement. The type-indexed type Tthat is redeﬁned must be in scope,
i.e., its kind signature must be in the kind environment K. We translate the right
hand side of the redeﬁnition, t1, tot/prime
1, under an environment K/primewhich contains
the argument dependency variables γi. Note that t1may be of a qualiﬁed kind ρ1.
To allow this, we use the modiﬁed type checking rules in Figure 16.12 that can
260
16.7 Implementation of type-indexed datatypes
be used to reveal the kind dependencies of a type. The body of the let construct,
t2, is translated under an environment that contains the dependency variable α
for which the local redeﬁnition occurs. Furthermore, it is passed extended envi-
ronments ¯∆/prime, containing the redeﬁnition, and Ψ/prime, which contains a mapping from
Cp(T,α)tot/prime
1. This entry can be used to translate generic applications that occur
in the body (cf. Figure 16.10).
In many cases, a universal quantiﬁcation can be translated to itself. However,
if the body refers to a type-indexed datatype, say T, and the quantiﬁed variable a
occurs in its type argument, then the translation must contain additional uni-
versal quantiﬁcations. These additional quantiﬁed variables take the form of a
component, Cp(T,a). We then also extend the type-level signature environment
with an entry T/angbracketlefta/angbracketrightfor the scope of the quantiﬁer, such that they are available
while translating the generic application (again, cf. Figure 16.10). There is an
example below.
The rule (t/tr-genapp) translates a generic application. The type argument A
is recursively translated to A/primeﬁrst, thereby removing possible further generic
applications, quantiﬁcations, or local redeﬁnitions. Therefore, A/primeis in a form
such that we can ﬁnd the kind of the application by an invocation of Gapp . The
dependency constraints of that kind must be satisﬁable in the current type-level
dependency environment ¯∆. We can then use /llbracket·/rrbracketgtrans, also on A/prime, to determine
the ﬁnal translation.
As an example application of the translation rules for types, consider the func-
tion lookup (deﬁned in Section 16.1), which is of type
lookup/angbracketlefta::∗/angbracketright::(lookup/angbracketlefta/angbracketright)⇒∀v::∗.a→FMap/angbracketlefta/angbracketrightv→Maybe v.
A call lookup/angbracketleft[α]/angbracketrightis of type
∀a::∗.(lookup/angbracketleftα/angbracketright::∀v::∗.a→FMap/angbracketlefta/angbracketrightv→Maybe v)
⇒∀v::∗.[a]→FMap/angbracketleft[a]/angbracketrightv→Maybe v.
According to the rules given in this section, the corresponding fcrt translation of
this type is
∀(a::∗) (Cp(FMap, a)::∗→∗ ).
(∀v::∗.a→Cp(FMap, a)v→Maybe v)
→∀v::∗.[a]→Cp(FMap, [ ])Cp(FMap, a)v→Maybe v.
The rules of Figure 16.11 can be applied also to type arguments, and can be
extended canonically to qualiﬁed types.
261
16 Type-indexed Datatypes
/llbrackete1::tfcrt+gftx/rrbracketgftx
K;Γ;Σ;¯Σ;Ψ≡e2
/llbrackett::∗/rrbracketgftx
K;ε;¯Σ;Ψ≡t/prime/llbrackete::t/prime/rrbracketgftx≡e/prime
/llbrackete::t/rrbracketgftx
K;Γ;Σ;¯Σ;Ψ≡e/prime(e/tr-gtype)
Figure 16.13: Translation of fcrt+gftx expressions to fcrt, extends Figures 6.13, 8.1, and
12.3
16.7.5 Translation of expressions
Expressions can now have types involving the new constructs, such as generic
application or local redeﬁnition. We therefore add an additional rule (e/tr-gtype)
to the checking and translation rules for expressions, that states that an expression
ecan be of type tif it can also be of type t/prime, where t/primeis the translation of t
according to the rules stated in Section 16.7.4. The additional rule, which extends
the previous rules for expressions, is displayed in Figure 16.13.
16.7.6 Translation of type declarations
The type declaration language is signiﬁcantly richer in the presence of type-
indexed datatypes. Therefore, it is worthwhile to analyze how type declara-
tions are checked and translated. We present selected rules in the Figures 16.14
and 16.15. Judgments are of the form
/llbracketDfcrt+gftx/squigglerightK2;Γ;¯Σ2;Ψ2; E/rrbracketgftx
K1;¯Σ1;Ψ1≡{Dfcrt}i∈1..n
; .
Under a kind environment K 1, a type-level signature environment ¯Σ1, and a type
synonym environment Ψ1, the type declaration Dfcrt+gftxis translated into a se-
quence of fcrt type declarations {Dfcrt}i∈1..n
; . As a side product, we get environ-
ments that contain new information won from the declaration: kind information
in K 2, constructor information in Γ, components of type-indexed datatypes in ¯Σ2,
type synonyms including structural representation types in Ψ2, and embedding-
projection pairs in E.
Rule (p/tr-tid) explains how to translate a type-indexed datatype, and closely
corresponds to rule (d/tr-tif) on page 91 for type-indexed functions. We delegate
the translation of each of the arms to an auxiliary rule (p/tr-arm), which trans-
forms the arm into a type synonym. For the whole Typecase construct, we then
262
16.7 Implementation of type-indexed datatypes
/llbracketDfcrt+gftx/squigglerightK2;Γ;¯Σ2;Ψ2; E/rrbracketgftx
K1;¯Σ1;Ψ1≡{Dfcrt}i∈1..n
;
K/turnstileleftksigT/angbracketlefta::∗/angbracketright::¯σ
K/prime≡T/angbracketlefta::∗/angbracketright::¯σ{, Ki}i∈1..n ¯Σ/prime≡{¯Σi}i∈1..n
,
Γ/prime≡{Γi}i∈1..n
, Ψ/prime≡{Ψi}i∈1..n
, E/prime≡{Ei}i∈1..n
,/braceleftbig
/llbracketT|Pi→ti/squigglerightKi;Γi;¯Σi;Ψi; Ei/rrbracketgftx
K;¯Σ;Ψ≡Di/bracerightbigi∈1..n
/largellbracket
T/angbracketlefta/angbracketright=Typecase aof{Pi→ti}i∈1..n
;/squigglerightK/prime;Γ/prime;¯Σ/prime;Ψ/prime; E/prime/largerrbracketgftx
K;¯Σ;Ψ
≡{Di}i∈1..n
;(p/tr-tid)
/llbracketT|P→tfcrt+gftx/squigglerightK2;Γ;¯Σ2;Ψ2; E/rrbracketgftx
K1;¯Σ1;Ψ1≡Dfcrt
K/turnstileleftpatP::∗/squigglerightKP P≡T/prime{αi}i∈1..n
GappK,K P(T/angbracketleftP/angbracketright)≡ρ /llbrackett::ρ/rrbracketgftx
K,K P;ε;¯Σ;Ψ≡{Λak::κk.}k∈1../lscriptt/prime
/llbrackettype Cp(T,T/prime) ={Λak::κk.}k∈1../lscriptt/prime/squigglerightK/prime;Γ/prime;ε;Ψ/prime; E/prime/rrbracketgftx
K;¯Σ;Ψ≡D
/llbracketT|P→t/squigglerightK/prime;Γ/prime;T/angbracketleftT/prime/angbracketright;Ψ/prime; E/prime/rrbracketgftx
K;¯Σ;Ψ≡D(p/tr-arm)
Figure 16.14: Translation of fcrt+gftx type declarations to fcrt, compare with Figure 6.15
263
16 Type-indexed Datatypes
/llbracketDfcrt+gftx/squigglerightK2;Γ;¯Σ2;Ψ2; E/rrbracketgftx
K1;¯Σ1;Ψ1≡{Dfcrt}i∈1..n
;
D≡data T={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|
Ka≡K{,ai::κi}i∈1../lscriptK/prime≡T::{κi→}i∈1../lscriptκ0/braceleftBig/braceleftbig
/llbrackettj,k::∗/rrbracketgftx
Ka;ε;¯Σ;Ψ≡t/prime
j,k/bracerightbigk∈1..nj/bracerightBigj∈1..m
D/prime≡data T={Λai::κi.}i∈1../lscript{Cj{t/prime
j,k}k∈1..nj}j∈1..m
|
Γ/prime≡/braceleftbig
Cj::{∀ai::κi.}i∈1../lscript{tj,k→}k∈1..njT{ai}i∈1../lscript/bracerightbigj∈1..m
,/largellbracket
D/squigglerightK/prime;Γ/prime;ε;/llbracketD/prime/rrbracketstr;/llbracketD/prime/rrbracketep/largerrbracketgftx
K;¯Σ;Ψ≡D/prime(p/tr-data)
Join(R)≡T/prime{αk}k∈1../lscriptfresh
P≡T/prime{αk}k∈1../lscriptK/turnstileleftpatP::∗/squigglerightKP
Str(T/prime)≡{Λak::κk.}k∈1../lscriptt∈Ψ
GappK,K P(T/angbracketleftP/angbracketright)≡ρ
/llbracketT/angbracketleftt{[αk/ak]}k∈1../lscript/angbracketright::ρ/rrbracketgftx
K,K P;ε;¯Σ≡{Λbi::κ/prime
i.}i∈1..nt/prime
D≡newtype Cp(T,T/prime) ={Λbi::κ/prime
i.}i∈1..nC t/prime
/llbracketD/squigglerightK/prime;Γ/prime;ε;Ψ/prime; E/prime/rrbracketgftx
K;¯Σ;Ψ≡D/prime
/llbracketnewtype T/angbracketleftR/angbracketrightasC/squigglerightK/prime;Γ/prime;T/angbracketleftT/prime/angbracketright;Ψ/prime; E/prime/rrbracketgftx
K;¯Σ;Ψ≡D/prime(p/tr-sr-newtype)
Figure 16.15: Translation of fcrt+gftx declarations to fcrt, continued from Figure 16.14
264
16.7 Implementation of type-indexed datatypes
only add the kind signature, and collect all the environments that result from
processing the arms.
For each arm, we check that the type pattern is well-formed. We determine the
qualiﬁed kind ρthat the right hand side tmust have using the Gapp algorithm,
and then translate tusing ρinto a type expression {Λak::κk.}k∈1../lscriptt/prime. This re-
sulting type forms the right hand side of the type synonym Cp(T,T/prime), and will in
general be parametrized, because ρcan have dependency constraints. The whole
type synonym is then translated again! This means that the generated type syn-
onym is treated in the same way as a user-deﬁned type synonym. A structure
type and an embedding-projection pair are generated, and the kind information
is added to the kind environment. This is necessary to allow nested generic appli-
cations such as T/prime/prime/angbracketleftT/angbracketleftP/angbracketright/angbracketright(cf. Section 16.8). Returned are the declaration and the
environments resulting from the translation of the type synonym for Cp(T,T/prime).
In addition, the entry T/angbracketleftT/prime/angbracketrightis added to the signature environment.
Rule (p/tr-data) is for the translation of a datatype. Types declared by newtype
ortype constructs have similar rules – they are omitted here. All ﬁelds tj,kof all
constructors are checked to be of kind ∗and translated into ﬁelds t/prime
j,k, which make
up the resulting fcrt datatype declaration D/prime. The constructors are added to the
type environment, and the embedding-projection pair as well as the structural
representation are generated. The generation of those is based on the translated
type D/prime; the algorithms from Chapter 10 are therefore still valid.
The rule (p/tr-sr-newtype) translates a newtype specialization request. The
request is of the form T/angbracketleftR/angbracketright, where R– according to the syntax in Figure 16.2
can be either a named type (this is the common case), or a type application. Each
request is translated into a single component. To determine the name of the
request, we make use of the function Join, which collapses a possibly nested type
application into a single name, and is deﬁned as follows:
Join(T)≡T
Join(T/angbracketleftR/angbracketright)≡Cp(T,Join(R)).
In the rule, we assign the name T/primetoJoin(R). This joined type T/primeis assumed
to be already in scope, i.e., in K, and to have a structural representation in Ψ.
We therefore create fresh dependency variables αkas arguments for T/prime, such that
the pattern P, deﬁned as T/prime{αk}k∈1../lscriptis of kind∗. We then translate T, applied
to the structural representation of T/prime, where Gapp (T/angbracketleftP/angbracketright)gives us the kind of
that generic application. The resulting type expression contains abstractions that
correspond to the type-level dependencies. This type, including the abstractions,
forms the body of the newtype component Dthat we generate under the name
Cp(T,T/prime), with the user-speciﬁed constructor plugged in. The declaration Dis
then translated again, as if it would be a normal newtype occurring in the pro-
gram. This adds the component, together with its structural representation and
265
16 Type-indexed Datatypes
embedding-projection pair, to the appropriate environments. In the ﬁnal result,
we also add T/angbracketleftT/prime/angbracketrightto the signature environment.
Let us play this rule through for the specialization request
newtype FMap/angbracketleft[ ]/angbracketrightasFMapList .
Here, R≡[ ]and Join(R)≡[ ]. Because the kind of [ ]is∗→∗ , we have /lscript≡1
and introduce one dependency variable α≡α1. The pattern Pis[α], and
gapp (FMap/angbracketleft[α]/angbracketright)≡(FMap/angbracketleftα/angbracketright::∗→∗ )⇒∗→∗≡ ρ.
We now translate FMap applied to the structural representation of lists:
/llbracketFMap/angbracketleftSum Unit (Prod α[α])/angbracketright::ρ/rrbracketgftx
≡Λ(Cp(FMap, α)::∗→∗ ).
Cp(FMap, Sum )Cp(FMap, Unit )
(Cp(FMap, Prod )Cp(FMap, α)
(Cp(FMap, [ ])Cp(FMap, α))).
We abbreviate the right hand side as Λ(Cp(FMap, α)::∗→∗ ).t/prime. We now deﬁne
thenewtype component as follows:
newtype Cp(FMap, [ ]) =Λ(Cp(FMap, α)::∗→∗ ).FMapList t/prime.
This whole construct is now translated as a user-deﬁned newtype statement
would be. Therefore, Cp(FMap, [ ])is added to the kind environment, and an
embedding-projection pair and structural representation for the type is gener-
ated. The resulting environment entries are returned.
We do not show the rule for type specialization requests as it is quite similar.
The only difference is that a type synonym is generated for the component, of the
form
type Cp(T,T/prime) ={Λbi::κ/prime
i.}i∈1..nt/prime,
which is then translated recursively.
16.7.7 Translation of declarations
We have sketched in Section 16.3 that it is also necessary to adapt the generation
of components for generic functions slightly. Not only embedding-projection
pairs for the component type have to be deﬁned for the bimap wrapper, but also
embedding-projection pairs for applications of type-indexed datatypes, at least if
the components are not type synonyms, but deﬁned via newtype ordata .
266
16.7 Implementation of type-indexed datatypes
cmbase K;Γ/parenleftbig
x/angbracketleft{βi}i∈1..r
,|{β/prime
j}j∈1..s
,/angbracketright/squiggleright{γi∼Ti}i∈1..r/prime
,|{γ/prime
j}j∈1..s/prime
,/parenrightbig≡A
Θ≡{βi}i∈1..r
,|{β/prime
j}j∈1..s
,
mbase K;Γ/parenleftbig
x/angbracketleftΘ/angbracketright/parenrightbig≡A
/llbracketA::ρ/rrbracketgftx
K;ε;¯Σ;Ψ≡A/prime
ρ≡/parenleftbig/braceleftbig{Ti,k/angbracketleftβi/angbracketright::κi,k}k∈1..ri,/bracerightbigi∈1..r
,/braceleftbig{,T/prime
j,k/angbracketleftβ/prime
j/angbracketright::κ/prime
j,k}k∈1..sj/bracerightbigj∈1..s/parenrightbig⇒∗
/braceleftbig{γi,kfresh}k∈1..ri/bracerightbigi∈1..r /braceleftbig{γ/prime
j,kfresh}k∈1..sj/bracerightbigj∈1..s
A/prime≡/braceleftbig{Let type Ti,k/angbracketleftβi/angbracketright{ah}h∈1..arity(κi,k)=γi,kIn}k∈1..ri/bracerightbigi∈1..r
/braceleftbig{Let type T/prime
j,k/angbracketleftβ/prime
j/angbracketright{ah}h∈1..arity(κ/prime
j,k)=γ/prime
j,kIn}k∈1..sj/bracerightbigj∈1..sA
Θ/prime≡{γi,k∼Ti,k}k∈1..ri, )|{{γ/prime
j,k}k∈1..sj,}i∈1..s
,
cmbaseK;Γ;¯Σ;Ψ/parenleftbig
x/angbracketleftΘ/angbracketright/squiggleright{Θ/prime}i∈1..r
,/parenrightbig≡A/prime(cmbase)
Figure 16.16: Closed base type with respect to applications of type-indexed types
We have given an example for lookup/angbracketleft[α]/angbracketright, which would need to be deﬁned as
lookup/angbracketleft[α]/angbracketright=
letbimap/angbracketleftβ/angbracketright=ep([ ])
bimap/angbracketleftγ/angbracketright=ep(Cp(FMap, [ ]))
into bimap/angbracketleftLet type FMap/angbracketleftβ/angbracketright(a::∗) =γInmbase (lookup/angbracketleftβ/angbracketright)/angbracketright
(lookup/angbracketleftStr([ ])α/angbracketright).
In a ﬁrst step, we discuss the judgment of the form
cmbase K;Γ/parenleftbig
x/angbracketleft{βi}i∈1..r
,|{β/prime
j}j∈1..s
,/angbracketright/squiggleright{γi∼Ti}i∈1..r/prime
,|{γ/prime
j}j∈1..s/prime
,/parenrightbig≡A
which can be used to produce a closed base type application, by surrounding an
application of mbase with local redeﬁnitions on the type level, thereby ﬁlling in
fresh dependency variables for applications of type-indexed datatypes.
The cmbase function thus takes
mbase (lookup/angbracketleftβ/angbracketright)
to
Let type FMap/angbracketleftβ/angbracketright(a::∗) =γInmbase (lookup/angbracketleftβ/angbracketright)
in the situation of the example.
267
16 Type-indexed Datatypes
At the same time, cmbase returns information about the Letconstructs that
have been added. We separate the dependency variables γithat are bound to
type-level dependencies for the βi, and the γ/prime
jthat correspond to the β/prime
j. For
theγi, we also return the name of the corresponding type-indexed type. In the
example, we have r≡1 and s≡0. Hence, the function returns
γ∼FMap|ε.
Even though syntactically not a proper type argument tuple, we abbreviate
{γi∼Ti}i∈1..r/prime
,|{γ/prime
j}j∈1..s/prime
,
using the symbol Θin the rules to come.
The rule (cmbase) for the cmbase judgment is shown in Figure 16.16: we use A
as an abbreviation for the mbase call. The kind of Aisρ, and because Acan con-
tain applications of type-indexed datatypes, ρcan have dependency constraints
for the dependency variables βiandβ/prime
jthat occur in the mbase call. We make
all these dependencies on the βiand the β/prime
jexplicit in ρ. The Ti,kare all type-
indexed datatypes that occur in dependencies with one of the βi, and the T/prime
j,kare
all type-indexed datatypes that occur in dependencies with one of the β/prime
j.
We now introduce fresh dependency variables for each of the dependencies,
and associate γi,kwith Ti,kandγ/prime
j,kwith T/prime
j,k. The dependency variables are then
used as right hand sides for type-level local redeﬁnitions.
In the example, we get
A/prime≡Let type FMap/angbracketleftβ/angbracketright(a1::∗) =γ1,1InA.
In the local redeﬁnitions, we have to introduce type variables – such as a1in the
example, if the kind of the dependency is not ∗. For example, the base kind of
FMap is of kind∗→∗ , therefore the dependency of Aon FMap/angbracketleftβ/angbracketrightis of kind
∗→∗ as well, thus we need to introduce one local type variable.
In general, the number of type variables introduced is arity(κi,k)and arity(κ/prime
j,k),
where arity(κ)is deﬁned as
arity(∗)≡0
arity(κ1→κ2)≡1+arity(κ2).
Together with the locally redeﬁned type argument A/prime, we return the newly in-
troduced dependency variables γi,k(together with the name of the corresponding
type indexed type) and γ/prime
j,k. In our example, that is just γ1,1∼FMap.
Now, we can proceed to the generation of additional components for a generic
function declaration, as described by rule (d/tr-tidgf) in Figure 16.17. This rule
268
16.7 Implementation of type-indexed datatypes
/llbracketdfcr+tif+par/squigglerightΓ2;Σ2/rrbracketgftx
K;Γ1;∆;Σ1;Ψ≡{dfcri}i∈1..n
;
P0≡T{αk}k∈1../lscript
Str(T)≡{Λak::κk.}k∈1../lscriptt∈Ψ
K;Γ/prime/turnstilelefttpsigx/angbracketleftπ/angbracketright::σ
π≡({bi::∗}i∈1..r|{b/prime
j::κ/prime
j}j∈1..s)
{βifresh}i∈1..r{β/prime
jfresh}j∈1..s
depttK;Γ(x/angbracketleftπ/angbracketright,x)≡π
K/prime≡K{,βi::∗}i∈1..r{,β/prime
j::κ/prime
j}j∈1..s
Θ≡{βi}i∈1..r
,|{β/prime
j}j∈1..s
, Θ/prime≡{γi∼Ti}i∈1..r/prime
,|{γ/prime
j}j∈1..s/prime
,
e0≡let{bimap/angbracketleftβi/angbracketright=ep(T)}i∈1..r
;
{bimap/angbracketleftβ/prime
j/angbracketright=EP id id}j∈1..s
;
{bimap/angbracketleftγi/angbracketright=ep(Cp(Ti,T))}i∈1..r/prime
;
{bimap/angbracketleftγ/prime
j/angbracketright=EP id id}j∈1..s/prime
;
into bimap/angbracketleftbig
cmbase K/prime;Γ(x/angbracketleftΘ/angbracketright/squigglerightΘ/prime)/angbracketrightbig
(x/angbracketleftt{[αk/ak]}k∈1../lscript/angbracketright)
d/prime≡x/angbracketlefta/angbracketright=typecase aofP0→e0{;Pi→ei}i∈1..n
/llbracketd/prime/squigglerightΓ/prime;Σ/prime/rrbracketgftx
K;Γ;∆;Σ;Ψ≡{dfcri}i∈1..n
;
/llbracketx/angbracketlefta/angbracketright=typecase aof{Pi→ei}i∈1..n
;/squigglerightΓ/prime;Σ/prime/rrbracketgftx
K;Γ;∆;Σ;Ψ
≡{dfcri}i∈1..n
;(d/tr-tidgf)
Figure 16.17: Translation of fcrt+gftx declarations to fcrt, replaces Figure 11.2
269
16 Type-indexed Datatypes
is a replacement for rule (d/tr-gf), deﬁned in Figure 11.2 on page 183, and it
is very similar. Nevertheless it is probably the most complicated rule in this
thesis, because this is the place where type-indexed functions and type-indexed
datatypes interact. The difference with (d/tr-gf) is that we refer to cmbase instead
ofmbase to generate the wrapper, and that we use the information about the
introduced dependency variables for a local redeﬁnition on the value level to
plug in the embedding-projection pair for the appropriate components of the
type-indexed datatypes.
In our running example, the call lookup/angbracketleft[α]/angbracketright, we get
e0≡letbimap/angbracketleftβ1/angbracketright=ep([ ])
bimap/angbracketleftγ1/angbracketright=ep(Cp(FMap, [ ]))
into bimap/angbracketleftLet type FMap/angbracketleftβ1/angbracketright(a::∗) =γ1Inmbase (lookup/angbracketleftβ1/angbracketright)/angbracketright
(lookup/angbracketleftStr([ ])α1/angbracketright),
as promised. This expression will be added in an arm of the form
[α1]→e0
to the typecase construct that deﬁnes the lookup function.
Apart from the just discussed new rule (d/tr-tidgf), there is one more thing
we have to verify while translating type-indexed functions: if a type-indexed
function refers to a type-indexed datatype, all the types that are in the signature
of the type-indexed datatype must also be in the signature of the type-indexed
function. The reason is that we cannot generically generate a component for a
function if the corresponding component of the type-indexed datatype is non-
generic. This check is best added to the rule (d/tr-tif) which translates the ﬁnal
type-indexed function, including all generically generated components.
At this point, we conclude our account of the translation of type-indexed
datatypes. We have omitted some less interesting parts, such as the translation of
the environments or how to adapt the checking of the entire program.
16.8 Translation by specialization and
type-indexed datatypes
Translation by specialization in the presence of type-indexed datatypes requires a
stronger interaction between different phases of the translation. The reason is that
applications of type-indexed datatypes can occur nested in type arguments. As
a consequence, the generation of structural representation types and embedding-
projection pairs cannot be done once and for all in the beginning; the components
270
16.8 Translation by specialization and type-indexed datatypes
of type-indexed datatypes are datatypes themselves, and their structure must be
made available.
We therefore need a staged approach: a specialization request for a type ar-
gument involving other calls to type-indexed datatypes can only be processed
after the components for those calls have been generated, and the structure of the
associated datatypes is available.
Furthermore, specialization of type-indexed function calls should only take
place after all components of type-indexed datatype have been generated. This
allows us to use ordinary generic functions on type-indexed datatypes, too, so
that we can for example compare two ﬁnite maps for equality using the generic
application equal/angbracketleftFMap/angbracketleftTree Int/angbracketrightString/angbracketright, or generate a generic string represen-
tation of a zipper using show/angbracketleftLoc/angbracketleftTreeF/angbracketright/angbracketright.
271
16 Type-indexed Datatypes
272
17Alternative Views on
Datatypes
In Chapter 10, we have shown that we can view a datatype as an isomorphic
representation type, thereby replacing complex concepts such as n-ary choice and
constructors with multiple arguments by simpler ones, and by using a limited set
of abstract datatypes to embody these simple concepts. In particular, we have
made use of three datatypes, Unit, Prod, and Sum. But was this choice a good
one? Well, it certainly is not the only choice possible. In fact, we have already
discussed in the context of the generic bimap function that it can be useful to treat
the universal quantiﬁer over a type variable of kind ∗, written Forall ∗, as a type
constructor (∗→∗ )→∗ (cf. Section 11.3). We have also noted that the treatment
of identity types (cf. Section 11.4) might warrant the introduction of Id as a special
type, or even a marker Type for the boundary of a datatype. Furthermore, we
have mentioned that some datatypes can be represented as ﬁxpoints in Section 8.4
and 12.3. Some functions, including generic functions, can be written more easily
using such a representation of a datatype, because it allows explicit access to the
points of recursion.
All the described changes are modiﬁcations or variations of the standard view
that we have described in Chapter 10. These modiﬁcations require to adapt the
273
17 Alternative Views on Datatypes
translation of datatypes into generic representation types. In this chapter, we will
discuss several possibilities for alternative views and the resulting consequences
for the implementation.
We will start, in Section 17.1, with an extension of the structural representation
that allows access to information about names of datatypes, constructors, and
possibly record ﬁeld labels. Using this extension, it is possible to write functions
such as read and show generically. Afterwards, in Section 17.2, we investigate
the implementation of a ﬁxpoint view and sketch how it can be implemented.
This view can be used to write a generic function children that collects the recur-
sive children of a datatype. Sections 17.3, 17.4, and 17.5 list three more possible
views: a balanced encoding of sums and products, a list-like encoding of sums
and products, and a view which allows constructor cases , speciﬁc cases of generic
functions for special behaviour on a single constructor. Finally, in Section 17.6,
we point out that it would be nice if one could deﬁne one’s own views as a user
of the language.
17.1 Constructors and labels
Parsing and pretty-printing are common examples of generic functions: showing
values on screen, storing them on disk in both human readable or compressed for-
mat, exchanging data between different programs – all these problems have one
thing in common: a universal representation has to be found for all datatypes and
we need functions to convert between values of the datatypes and the universal
representation.
We have already discussed simple encoding and decoding functions, in Sec-
tion 7.4. With encode a value of any type is stored in a list of bits, and, given
the type of the expected value, decodes (ordecode from Section 12.1), recovers the
value from such a list.
All encodings that we can deﬁne so far are either not generic or cannot make
use of the name information that is contained in a datatype, simply because the
structural representation is not equipped to represent such names. For example,
the datatypes
data Bool =False|True
data Bit =0|1
data Motion =Clockwise|Counterclockwise
all three have the same structural representation, namely Sum Unit Unit. Conse-
quently, the encoding of [False ,True,True ]is the same as the encoding of [0,1,1].
While this might be desirable in some situations, for the purpose of conversion
274
17.1 Constructors and labels
between isomorphic datatypes (Atanassow and Jeuring 2004), it is unwanted in
general. Haskell provides a show function that generically computes a human-
readable string representation of almost any Haskell value, and a counterpart
read that can be used to recover a typed value from a string. The string represen-
tation contains the constructor names from the datatypes, and thereby ensures
that the string representation of one value cannot be read back as a value of
another type.
17.1.1 Extending structural representations
To be able to do the same with a Generic Haskell function, we must extend the
structural representation of datatypes and give the programmer some means to
access information about constructors and datatypes, such as their names.
As a ﬁrst step, we introduce a new datatype along the lines of Unit, Sum, Prod,
and Zero. The datatype Con, deﬁned as
data Con (a::∗) =Con a ,
serves as a simple marker for the position of a constructor. We insert such tags
in the structural representation between the sum and the product structure. For
instance, the representation of any of the three types Bool, Bit, and Motion above
becomes
Sum (Con Unit ) (Con Unit ),
and the representation of lists becomes
Λa::∗. Sum (Con Unit ) (Con (Prod a[a])).
While the representation types are generated, the compiler tags each occurrence
of Con with an abstract value describing the original constructor, called the con-
structor descriptor . In the case of lists, the constructors are [ ]and (:), so the
compiler remembers
Λa::∗. Sum (Con[ ]Unit ) (Con(:)(Prod a[a])).
The tags are omitted in the actual translation, and ignored in the embedding-
projection pair as well. The only place where they play a role is if a generic
function has a speciﬁc arm for the type Con. The type pattern associated with
the Con type takes a special form, not Con α, but
Con xα,
275
17 Alternative Views on Datatypes
thexbeing a value-level variable that is bound to the constructor descriptor. This
value is of the abstract type ConDescr. This datatype supports several methods
to obtain information about the constructor, among them
conName :: ConDescr→String
conType :: ConDescr→String ,
to return the name of the constructor and the name of the datatype that the
constructor belongs to.
17.1.2 Showing values
As a concrete example of the use of a constructor descriptor in a generic function,
let us look at the function showP , a slightly generalized variant of Haskell’s show
that takes an additional argument of type String →String. This parameter is used
internally to place parentheses around a fragment of the result when needed.
showP/angbracketlefta::∗/angbracketright::(showP/angbracketlefta/angbracketright)⇒(String→String )→a→String
showP/angbracketleftUnit/angbracketright p Unit =""
showP/angbracketleftSum α β/angbracketrightp(Inl x ) = showP/angbracketleftα/angbracketrightp x
showP/angbracketleftSum α β/angbracketrightp(Inr x ) = showP/angbracketleftβ/angbracketrightp x
showP/angbracketleftProd α β/angbracketrightp(x1×x2) =showP/angbracketleftα/angbracketrightp x1+ +" "+ +showP/angbracketleftβ/angbracketrightp x2
showP/angbracketleftCon cα/angbracketrightp(Con x ) = letparens x ="("+ +x+ +")"
body =showP/angbracketleftα/angbracketrightparens x
in if null body
then conName c
else p(conName c + +" "+ +body )
showP/angbracketleft[α]/angbracketright p xs =letbody = (concat/angbracketleft[ ]/angbracketright
·intersperse ", "
·map/angbracketleft[ ]/angbracketright(showP/angbracketleftα/angbracketrightid))
xs
in"["+ +body + +"]"
The type Unit represents a constructor with no ﬁelds. In such a situation, the
constructor name alone is the representation, and it will be generated from the
Con case, so we do not need to produce any output here. We just descend through
the sum structure; again, no output is produced here because the constructor
names are produced from the Con case. A product concatenates ﬁelds of a single
constructor; we therefore show both components, and separate them from each
other by whitespace.
Most of the work is done in the arm for Con. We show the body of the con-
structor, using parentheses where necessary. The body is empty if and only if
276
17.1 Constructors and labels
there are no ﬁelds for this constructor. In this case, we only return the name of
the constructor. Here we make use of the function conName on the constructor de-
scriptor cto obtain that name. Otherwise, we connect the constructor name and
the output of the body with a space, and surround the result with parentheses if
requested by parameter p.
The last case is for lists and implements the Haskell list syntax, with brackets
and commas.
In addition to the cases above, we need cases for abstract primitive types such
as Char, Int, or Float that implement the operation in some primitive way.
The function show is deﬁned in terms of showP via generic abstraction, instan-
tiating the ﬁrst parameter to the identity function, because outer parentheses are
usually not required.
show/angbracketlefta::∗/angbracketright::(showP/angbracketlefta/angbracketright)⇒a→String
show/angbracketleftα::∗/angbracketright=showP/angbracketleftα/angbracketrightid
The deﬁnition of a generic read function that parses the generic string repre-
sentation of a value is also possible using the Con case, and only slightly more
involved because we have to consider partial consumption of the input string and
possible failure.
17.1.3 Generic cardinality
There are other generic functions that can beneﬁt from constructor information
being available in the structural representation of datatypes. For example, we can
deﬁne a variant of the cardinality function card that terminates even for inﬁnite
types. We deﬁne a new datatype
data Cardinality =FinInt|Inf
and expect card to return a value of that type, thus Infin the case that it is called
on a datatype with inﬁnitely many elements.
The trick is that we can break inﬁnite recursion by maintaining a list of data-
types we have visited:
card/prime/angbracketlefta::∗/angbracketright::(card/prime/angbracketlefta/angbracketright)⇒[String ]→Cardinality .
The argument list is supposed to contain all the type names that we already have
visited on our path down. The deﬁnition of the function is as follows:
card/prime/angbracketleftInt/angbracketright visited =Inf
card/prime/angbracketleftFloat/angbracketright visited =Inf
277
17 Alternative Views on Datatypes
card/prime/angbracketleftChar/angbracketright visited =fromEnum (maxBound :: Char )
−fromEnum (minBound :: Char ) +1
card/prime/angbracketleftZero/angbracketright visited =Fin0
card/prime/angbracketleftUnit/angbracketright visited =Fin1
card/prime/angbracketleftSum α β/angbracketrightvisited =card/prime/angbracketleftα/angbracketrightvisited⊕card/prime/angbracketleftβ/angbracketrightvisited
card/prime/angbracketleftProd α β/angbracketrightvisited =card/prime/angbracketleftα/angbracketrightvisited⊗card/prime/angbracketleftβ/angbracketrightvisited
card/prime/angbracketleftα→β/angbracketrightvisited =card/prime/angbracketleftβ/angbracketrightvisited /owedgecard/prime/angbracketleftα/angbracketrightvisited
card/prime/angbracketleftCon cα/angbracketrightvisited
|conType c∈visited =Inf
|otherwise =card/prime/angbracketleftα/angbracketright(conType c :visited ).
We consider the base types Int and Float as inﬁnite (although both are not re-
ally), and deﬁne the cardinality of Char using the Bounded class in Haskell. The
Zero type contains no elements, the Unit type contains one element. For sums,
products, and functions, we make use of the operations ⊕,⊗, and /owedge, which
are versions of addition, multiplication, and exponentiation, that work on the
Cardinality datatype. Their deﬁnitions are given in Figure 17.1. If a constructor
is encountered, we check if the associated datatype is already known to us. If that
is the case, we can return Inffor this part of the structure. If not, we descend, but
add the new datatype to the list. Note that this approach considers all recursive
types as inﬁnite, which is not correct. For example, the type
data Rec=RecRec
which has no values not relying on lazy evaluation, is wrongly identiﬁed as an
inﬁnite type.
We can deﬁne a wrapper around card/prime, using generic abstraction, that initializes
the list of known datatypes to the empty list:
card/angbracketlefta::∗/angbracketright::(card/prime/angbracketlefta/angbracketright)⇒Cardinality
card/angbracketleftα::∗/angbracketright=card/prime/angbracketleftα/angbracketright[ ].
Note that card is an example of a generic function where the type argument does
not occur at all in the type (except for the type argument itself). Neither does it
take any arguments, and is more a generic value than a generic function.
17.1.4 An additional view?
We have seen now how to write generic functions using constructor information
provided that we have the Con marker. We have discussed the adapted transla-
tion to structural representations, and also the adapted specialization code that
passes the constructor descriptor whenever a Con component is called. But how
278
17.1 Constructors and labels
(⊕),(⊗),(/owedge):: Cardinality→Cardinality→Cardinality
Inf⊕x =Inf
x⊕Inf =Inf
Fin x 1⊕Fin x 2=Fin(x1+x2)
Inf⊗Fin0=Fin0
Inf⊗x =Inf
Fin0⊗Inf =Fin0
x⊗Inf =Inf
Fin x 1⊗Fin x 2=Fin(x1∗x2)
Inf /owedgeFin0=Fin1
Inf /owedgex =Inf
Fin0/owedgeInf =Fin0
x /owedgeInf =Inf
Fin x 1/owedgeFin x 2=Fin/parenleftbig
xx2
1/parenrightbig
Figure 17.1: Operations on the Cardinality type
do these additions integrate with the generic functions that do not care about
constructors?
Fortunately, the integration is very simple. With a minor addition, we can
transparently make use of constructor information: if the function does not need
it, an explicit arm can be omitted, i.e., the function can be written exactly as
before. If the function does need it, it is available.
To achieve this, we always produce the enriched structural representation, con-
taining the Con markers. But other than Unit, Sum, Prod, and Zero, we do not
treat Con itself as an abstract type, but rather deﬁne a structural representation
for it, namely
Λa::∗.a.
In other words, Str(Con t)≡tfor any t. Now we can proceed with specialization
as we are used to.
17.1.5 Record labels
Haskell facilitates the deﬁnition of records by providing a special syntax for
datatypes, where ﬁeld names are associated with the ﬁelds of constructors. These
ﬁeld names can also be made accessible for generic functions such as show , in an
analogous way to the treatment of constructor information.
279
17 Alternative Views on Datatypes
We deﬁne a new datatype Lab as
data Lab (a::∗) =Lab a
and use Lab to mark the position of a ﬁeld label. Field label markers are thus
inserted in the product structure of a type. Internally, they are again tagged with
an abstract description of the label, in this case of type LabDescr. This label
descriptor is then used in components for the type Lab.
17.2 Fixpoints of regular functors
The idea of a ﬁxpoint view on datatypes is that regular datatypes are automati-
cally represented as ﬁxpoints of their pattern functors. Regular datatypes are the
class of datatypes that generic (or polytypic) functions work on in PolyP (Jansson
and Jeuring 1997). A datatype of the form
data T ={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|
is called regular if all recursive references on the right hand side – i.e., in the tj,k
– have the form T{ai}i∈1..n. Then, we can deﬁne the pattern functor ofTto be
data PF(T) ={Λai::κi.}i∈1../lscriptΛc::∗.
{PF(Cj){tj,k[c/T{ai}i∈1../lscript]}k∈1..nj}j∈1..m
|,
where cis a fresh type variable. The type T{ai}i∈1../lscriptis isomorphic to the type
Fix(PF(T){ai}i∈1../lscript), assuming the usual deﬁnition of Fix as
data Fix(f::∗→∗ ) =In(f(Fixf)).
For example, for the datatype of lists [ ], we get
data PF([ ]) ( a::∗) (c::∗) =PF([ ])
|PF((:))a c,
and the isomorphism between [a]and Fix (PF([a]))is witnessed by
epf([ ]) ::∀a::∗. EP [a] (Fix(PF([a])))
epf([ ]) = letfrom [ ] = In(PF([ ]))
from (x:xs) = In(PF((:))x(from xs ))
to (In(PF([ ]))) = [ ]
to (In(PF((:))x xs)) = x:to xs
inEP from to .
280
17.2 Fixpoints of regular functors
Note that while the pattern functor PF([ ]) is not recursive, the conversion func-
tions from and tothat make up the embedding-projection pair are.
For datatypes of higher-rank kinds, we need access to the bimap function to
deﬁne embedding-projection pairs between a datatype and its ﬁxpoint represen-
tation.
The pattern functor is itself translated into a structural representation, this
time using the standard sum of products view and an associated embedding-
projection pair.
Str(PF([ ]))≡Sum Unit (Prod a c)
ep(PF([ ])) ::∀a::∗. EP PF([ ]) Str(PF([ ]))
ep(PF([ ])) = letfrom (PF([ ])) = InlUnit
from (PF((:))x y) =Inr x y
to (InlUnit ) = PF([ ])
to (Inr x y ) = PF((:))x y
inEP from to .
Using the ﬁxpoint view, one can for example write the generic function children :
children/angbracketlefta::∗/angbracketright::(collect/angbracketlefta|a/angbracketright)⇒a→[a]
children/angbracketleftFixγ/angbracketright=letcollect/angbracketleftα/angbracketrightx= [x]
incollect/angbracketleftγ α/angbracketright.
This function depends on collect and uses it to gather all direct recursive occur-
rences of the datatype in a list. Using this deﬁnition, the call
children/angbracketleft[Int]/angbracketright[3, 4, 5 ]
evaluates to [[4, 5]], because non-empty lists have exactly one child, their tail.
The call
children/angbracketleftTree Int/angbracketright/parenleftbig
Node (Node Leaf 2Leaf)3(Node Leaf 5Leaf)/parenrightbig
returns [(Node Leaf 2Leaf),(Node Leaf 5Leaf)].
Of course, we can deﬁne children without a ﬁxpoint view, but then we cannot
directly apply it to datatypes such as [Int]or Tree Int. It is then the programmer’s
responsibility to explicitly transform the data structures into a ﬁxpoint represen-
tation, prior to calling children .
By deﬁning a type-indexed datatype to hold algebras belonging to a datatype,
we can also deﬁne a more convenient variant of cata(cf. Section 12.3):
AlgebraOf/angbracketlefta::∗/angbracketright ::(ID/angbracketlefta/angbracketright)⇒∗
type AlgebraOf/angbracketleftFixγ/angbracketrightr=ID/angbracketleftγ/angbracketrightr→r
281
17 Alternative Views on Datatypes
cata/angbracketlefta::∗/angbracketright ::(map/angbracketlefta,a/angbracketright)⇒∀ (r::∗). AlgebraOf/angbracketlefta/angbracketrightr→a→r
cata/angbracketleftFixγ/angbracketrightalg=alg·map/angbracketleftγ/angbracketright(cata/angbracketleftFixγ/angbracketrightalg)·out.
The deﬁnition of cata is as before, but the ﬁrst argument to the cata function is
now of the type-indexed type AlgebraOf, which is also deﬁned using the ﬁxpoint
view, and maps a datatype to a function from its pattern functor to the result
type.
We can deﬁne a generic abstraction on cata speciﬁcally for functors of kind
∗→∗ :
cataf/angbracketleftc::∗→∗/angbracketright ::(map/angbracketleftc,c/angbracketright)⇒∀ (a::∗) (r::∗).
AlgebraOf/angbracketleftc/angbracketrighta r→c a→r
cataf/angbracketleftγ::∗→∗/angbracketright =letmap/angbracketleftα/angbracketright=idincata/angbracketleftγ α/angbracketright.
In the type signature, we have used “short notation” for local redeﬁnition on the
type level. Without short notation, we would have to write
cataf/angbracketleftc::∗→∗/angbracketright ::(map/angbracketleftc,c/angbracketright)⇒∀ (a::∗) (r::∗).
LetID/angbracketleftα/angbracketright=a
InAlgebraOf/angbracketleftcα/angbracketrightr→c a→r.
We can further facilitate the use of cata by deﬁning an operator that lets us
construct algebras easily:
(⊕) ::∀(a::∗) (b::∗) (r::∗)→(a→r)→(b→r)→(Sum a b→r)
(⊕)f1f2=λx→case xof
Inl x 1→f1x1
Inr x 2→f2x2.
We assume that⊕associates to the right. Using both ⊕and cataf , one can now
apply catamorphisms with almost the same convenience as by using Haskell’s
foldr function. The expression
cataf/angbracketleft[ ]/angbracketright(const 0⊕λ(x×y)→x+y) [1 . . 100 ]
evaluates to 5050, and
cataf/angbracketleftTree/angbracketright/parenleftbig
const [ ]⊕λ(x×(y×z))→y:x+ +z/parenrightbig
/parenleftbig
Node (Node Leaf 1Leaf)2(Node Leaf 3Leaf)/parenrightbig
results in [2, 1, 3 ].
282
17.3 Balanced encoding
17.3 Balanced encoding
The standard view on datatypes uses a binary representation for sums and prod-
ucts. The choice between multiple constructors is expressed as a nested, right-
deep, binary sum. Similarly, multiple ﬁelds are translated to a nested, right-
associative, binary product. These encodings are somewhat arbitrary: we could
have used a left-deep nesting instead, or a balanced encoding.
The direction datatype
data Direction =North|East|South|West
that is represented as
Sum Unit (Sum Unit (Sum Unit Unit ))
using the standard view, would be translated to
Sum (Sum Unit Unit ) (Sum Unit Unit )
in a balanced encoding.
The choice of encoding can affect both efﬁciency and behaviour of generic func-
tions. The generic equality function equal , if applied to datatypes with many
constructors, is less efﬁcient using the standard view than it would be with the
balanced encoding. If both values belong to the rightmost constructor, then the
whole sum structure must be traversed in the standard view, whereas we have a
logarithmic complexity for the balanced encoding.
This difference is even more visible in the encode function, where it leads to
different results. We need a maximum of three bits to encode a value of type
Direction in the standard view, but two bits are always sufﬁcient using the bal-
anced view.
17.4 List-like sums and products
Yet another possibility to represent sums and products is to use a right-biased
nesting, but to always use the neutral elements Zero and Unit to mark the end
of a sum or product, respectively. The neutral elements play a similar role as the
“nil” constructor [ ]for lists. The encoding of the Direction type would become
Sum Unit (Sum Unit (Sum Unit (Sum Unit Zero ))),
and the type of rose trees, deﬁned as
283
17 Alternative Views on Datatypes
data Rose (a::∗) =Fork a [Rose a],
would be embedded as
Sum/parenleftbig
Prod a(Prod [Rose a]Unit )/parenrightbig
Zero .
This encoding has the advantage of being more uniform than the standard view:
there are always as many occurrences of Sum as there are constructors, and as
many occurrences of Prod per constructor as there are ﬁelds. The left argument
of a Sum always represents a single constructor, and the left argument of a Prod
always represents a single ﬁeld.
If a generic function should operate in a certain uniform way for all ﬁelds of a
constructor, then that function might be easier to write using the list-like view.
17.5 Constructor cases
The “Generic Haskell, speciﬁcally” paper (Clarke and L ¨oh 2003) describes con-
structor cases, which are a way to view constructors themselves as datatypes and
use them in type patterns during the deﬁnition of type-indexed functions. For
example, the function freecollect , deﬁned on page 218 in Section 14.1, could be
written in the following way using constructor cases:
freecollect/angbracketlefta::∗/angbracketright::(freecollect/angbracketlefta/angbracketright)⇒a→[Var]
freecollect extends termcollect
freecollect/angbracketleftLam/angbracketright(Lam (v,t)e) = ﬁlter (/negationslash==v) (freecollect/angbracketleftExpr/angbracketrighte)
freecollect/angbracketleftLet/angbracketright(Let (v,t)e e/prime) =freecollect/angbracketleftExpr/angbracketrighte
+ +ﬁlter (/negationslash==v) (freecollect/angbracketleftExpr/angbracketrighte/prime).
We deﬁne special behaviour for the Lam andLetconstructors of the Expr datatype
simply by writing additional arms. The constructors which are not mentioned
still enjoy generic behaviour. The original deﬁnition deﬁnes an arm for the Expr
datatype itself, using a case construct to detect the interesting constructors:
freecollect/angbracketleftExpr/angbracketrighte=
case eof
Lam (v,t)e/prime→ﬁlter (/negationslash==v) (freecollect/angbracketleftExpr/angbracketrighte/prime)
Let (v,t)e/primee/prime/prime→freecollect/angbracketleftExpr/angbracketrighte/prime
+ +ﬁlter (/negationslash==v) (freecollect/angbracketleftExpr/angbracketrighte/prime/prime)
→termcollect/angbracketleftExpr/angbracketrighte.
Using constructor cases has a couple of subtle advantages over the approach us-
ing the case construct. The ﬁrst is that we do not need to specify the fallback
284
17.5 Constructor cases
explicitly. The line termcollect/angbracketleftExpr/angbracketrighteis easy to write in this particular case. It
is, however, more difﬁcult to do so if we are not extending an already existing
function using a default case, or if the type pattern of the case we deﬁne involves
dependency variables, and the dependencies of the fallback functions need to be
redirected, such as described in the conversion function for default cases (cf. Sec-
tion 14.4).
The other advantage requires to take a look of how constructor cases are im-
plemented. In the presence of constructor cases, datatypes are encoded in two
levels. The datatype for expressions, which is deﬁned as
data Expr =Var Var
|App Expr Expr
|Lam (Var, Type )Expr
|Let (Var, Type )Expr Expr ,
is expressed as a sum of its constructors:
Str(Expr )≡Sum (Con Con(Var))
(Sum (Con Con(App))
(Sum (Con Con(Lam))
(Con Con(Let)))) ,
where Conis an internal function taking a constructor name to a type name. The
constructor types are type synonyms pointing to the datatype they belong to:
type Con(Var) = Expr
type Con(App) =Expr
type Con(Lam) =Expr
type Con(Let) = Expr .
However, these type synonyms have non-standard structural representations, in
that they are translated into only the product structure of the ﬁelds of the con-
structor they represent:
Str(Var)≡Var
Str(App)≡Prod Expr Expr
Str(Lam)≡Prod (Var, Type )Expr
Str(Let)≡Prod (Var, Type ) (Prod Expr Expr ).
Using this encoding, the standard specialization procedure from Chapter 11 can
be used to translate constructor cases. As can be seen from the example, the
type synonyms representing the constructor types are positioned between sum
and product structure, and beneath the Con markers from Section 17.1. This
285
17 Alternative Views on Datatypes
means that if a constructor case is used, the functionality for that the type-indexed
function implements for the sum structure or the Con case is still implemented for
the associated datatype. In the deﬁnition of freecollect without constructor cases,
where the Expr datatype is explicitly speciﬁed, the functionality of freecollect for
Sum and Con is no longer executed for values of type Expr that belong to the
Lam orLetconstructors. For freecollect , this is no real disadvantage, because no
Con deﬁnition exists, and the Sum case only propagates the collected variables.
17.6 A language for views
The examples discussed in this chapter have demonstrated that some generic
functions are easier to deﬁne or more efﬁcient using a non-standard view on
datatypes, and some functions cannot even be deﬁned in the standard view from
Chapter 10.
In some situations, such as in the case of constructor information (cf. Sec-
tion 17.1), it is possible to extend the standard view in such a way that functions
which do not require the extra information continue to work without modiﬁca-
tion. Nevertheless, additional constructors appear in the encoding and thus in
the translation, which makes the generated code less efﬁcient. Other views, such
as the balanced encoding or the list-like view, are not extensions, but proper
variations of the encoding.
In general, a view deﬁnes a way to translate a datatype into a type expression,
thestructural representation , that is (at least nearly) isomorphic to the original
datatype. An embedding-projection pair is required to witness the conversion.
Generic functions that make use of that particular view can then be deﬁned by
providing cases for the types that occur in the structural representations gener-
ated by the view.
Generic Haskell views are related to Wadler’s views (1987), proposed as an
extension for the Haskell language. In Wadler’s proposal, views provide different
ways of viewing one datatype, by providing different sets of data constructors
by which a value of the datatype may be constructed or deconstructed. In this
chapter, we show how to view datatypes in various ways, by providing different
sets of type constructors by which structural representations of datatypes may be
constructed or deconstructed.
Because there are many views (our list of examples certainly is not exhaustive),
and because it is unlikely that there is one single best view, it seems desirable to
equip Generic Haskell with a language to deﬁne views. The user would then need
to specify for each generic function which view it should use. How exactly this
might be achieved is the subject of ongoing research. It is difﬁcult to guarantee
that a user-deﬁned view is correct. If the representations that are produced are
286
17.6 A language for views
not truly isomorphic, run-time errors might be the result. It is also unclear how
different views interact: can functions that are deﬁned using different views all
seamlessly depend on each other?
287
17 Alternative Views on Datatypes
288
18 Modules
Real programs rarely consist of just one huge blob of code. Haskell offers the
possibility to group functions into modules. Modules can be compiled separately,
and code from one module can be reused in several others.
All the concepts in Generic Haskell were demonstrated in the limited setting
of single-module programs. All of them can easily be transferred to a language
with multiple modules. However, if we allow multiple modules, this opens up
a few new questions and problems: how can type-indexed functions and type-
indexed types be exported from one and imported into another module, and,
probably more important, how does separate compilation work in the presence
of type-indexed entities and genericity?
In this chapter, we will try to answer these questions. To this end, we add
modules both to the language fcrt, resulting in fcrtm , and to fcrt+gftx, yielding
fcrtm +gftx, and discuss how to translate the latter into the former. We will not
go into the details of the semantics of fcrtm or the module system itself, but
concentrate on the additional overhead resulting from type-indexed functions
and datatypes.
The new languages are introduced in Section 18.1. The translation of the lan-
guage fcrtm +gftx to fcrtm is the topic of Section 18.2. In the end, we discuss two
289
18 Modules
Programs
P::={B}i∈1..n
; (n∈1 . .)
sequence of modules
Modules
B::=Hwhere{Dj;}j∈1..nmain =e
type declarations plus main expression
Module headers
H::=module M({Xi}i∈1..m
, ) ({Ij}j∈1..n
; )
header with export list
Import declarations
I::=import M import module by name
Export list entries
X::=x function name
|abstract T abstract type
|T concrete type
Figure 18.1: Language with modules fcrtm , extends Figures 3.1, 3.12, and 15.1
problems that become more pronounced in the presence of modules: whether
type-indexed functions should be open or closed, in Section 18.4, and why explicit
specialization requests for type-indexed datatypes are necessary, in Section 18.3.
18.1 A language with modules
Figure 18.1 shows the syntax extensions necessary to cover programs consisting
of multiple modules, deﬁning language fcrtm as an extension of the functional
core language with recursive let and all type declaration constructs. Compared
to Haskell, there are some modiﬁcations – mainly simpliﬁcations – because we
want to concentrate on the issues related to type-indexed entities.
A program consists of a non-empty sequence of modules now. The last module
is considered the main module. The structure of modules is similar to the former
syntax of programs. There is now a module header, but the body of a module
still consists of declarations that are followed by a main expression. The main
expression of the main module is to be evaluated; all other main expressions are
type checked, but discarded.
A module header declares a name for a module, and governs which names are
exported and imported. We allow to hide functions and types by not including
290
18.1 A language with modules
Export list entries
X::=. . . everything from Figure 18.1
|abstract T/angbracketleftR/angbracketright abstract type-indexed type component
|T/angbracketleftR/angbracketright concrete type-indexed type component
Figure 18.2: Language with modules and type-indexed entities fcrtm +gftx, extends Fig-
ure 18.1
them in the export list. A module can only be included as a whole, and since we
are not interested in namespace management here, we do not consider qualiﬁed
imports or the renaming of imported modules.
Consequently, an import declaration simply lists a number of modules. The
export list controls the entities that are visible in other modules that import the
current module: functions and values can be exported by adding them to the
list; for datatypes, there is a choice: a datatype can be exported as an abstract
type (i.e., without knowledge of constructors and structure) or as a concrete type
(including constructors and its structure). It is illegal to export a type synonym
as abstract type.
While all datatypes that are declared in a module can also be exported, func-
tions can only be exported if they are deﬁned at the toplevel of the module. The
set of toplevel functions is the set of functions deﬁned in the outermost letcon-
struct of the main expression. We therefore require the main expression to be a
letconstruct, but since the declaration part may be empty, this is not a restriction.
We do not go into the details of the semantics. The idea is that all exported
entities of a module Mare visible in all following modules that import module M.
For simplicity, we assume that an imported function can only be typed if all
necessary datatypes are also in scope, at least as abstract types. This is different
from Haskell, where datatypes can be internally available to help type checking
imported functions, yet not be in scope, thus being invisible to the user.
To type a module, we must transfer knowledge from the imported modules: the
kind environment contains information about all imported datatypes and type
synonyms, both abstract and concrete; the type environment contains knowl-
edge about all imported functions, and the constructors of imported concrete
datatypes. Furthermore, we need the deﬁnitions of imported type synonyms in
the type synonym environment. Of course, we must also produce this informa-
tion for the exported entities while processing a module.
Let us now look at the additional modiﬁcations needed to deﬁne language
fcrtm +gftx, having modules as well as type-indexed functions and datatypes, all
at the same time. Syntactically, we require almost no changes. The only difference
is in the export lists: function names can now also be names of toplevel generic
291
18 Modules
functions, and we allow to export a type-indexed datatype concrete or abstract
(we discuss in the next section what that means precisely). In addition, we need
the possibility to export specialized components of type-indexed datatypes – such
as generated by explicit specialization requests – both abstract and concrete.
18.2 Translation of modules containing
type-indexed entities
In this section, we describe how to translate an fcrtm +gftx module, i.e., a module
possibly containing type-indexed functions and type-indexed datatypes, into an
fcrtm module.
This will inevitably also say some things about the module semantics for nor-
mal functions and datatypes, as they are part of the extended language as well.
As far as module syntax is concerned, the export list must be simpliﬁed. Oc-
currences of type-indexed functions, type-indexed datatypes, and type-indexed
datatype components have to be replaced. For this purpose, we introduce a judg-
ment of the form
/llbracketXfcrtm +gftx/squigglerightK2;Γ2;Σ2;¯Σ2;Ψ2; E2/rrbracketmod
K1;Γ1;Σ1;¯Σ1;Ψ1;E1≡{Xfcrtm i}i∈1..n
, .
Under all input environments, we process a single export list entry X1. This
results in contributions to the environments that will be exported from the current
module, and a number of export list entries in the target program.
The translation rules are shown in Figures 18.3 and 18.4. The rule (x-fun) is for
ordinary functions. A function xmentioned in the export list must be a toplevel
function of the current module or imported from somewhere else. This is checked
by testing that xhas an entry in the global type environment Γthat is provided as
input. This test also veriﬁes that xis not type-indexed. The resulting program has
the same entry xin its export list. Furthermore, we return a type environment
Γ/primecontaining an entry for x, because this is the information we export to other
modules.
For a type-indexed function x, the rule (x-tif) checks whether an appropriate
type signature x/angbracketleftϑ/angbracketright::σis contained in the input type environment Γ. We
extract the signature of xfrom the input signature environment Σ, using the
signature function explained on page 222 in Section 14.4. Both the type signature
and the signature of xare then exported to other modules through the output
environments Γ/primeandΣ/prime. The translated module will not contain the type-indexed
function anymore, though. Instead, it contains the components that have been
generated for the function. Therefore, the export list of the target module contains
entries of the form cp(x,Ti)for all types Tithat constitute the signature of x.
292
18.2 Translation of modules containing type-indexed entities
/llbracketXfcrtm +gftx/squigglerightK2;Γ2;Σ2;¯Σ2;Ψ2; E2/rrbracketmod
K1;Γ1;Σ1;¯Σ1;Ψ1;E1≡{Xfcrtm i}i∈1..n
,
x::t∈Γ Γ/prime≡x::t
/llbracketx/squigglerightε;Γ/prime;ε;ε;ε;ε/rrbracketmod
Γ≡x(x-fun)
x/angbracketleftϑ/angbracketright::σ∈Γ Γ/prime≡x/angbracketleftϑ/angbracketright::σ
signatureΣ(x)≡{Ti}i∈1..n
, Σ/prime≡{x/angbracketleftTi/angbracketright}i∈1..n
,
/llbracketx/squigglerightε;Γ/prime;Σ/prime;ε;ε;ε/rrbracketmod
Γ;Σ≡{cp(x,Ti)}i∈1..n
,(x-tif)
T::κ∈K K/prime≡T::κ
/llbracketabstract T/squigglerightK/prime;ε;ε;ε;ε;ε/rrbracketmod
K≡abstract T(x-atp)
T::κ∈K K/prime≡T::κ
Γ/prime≡constructors Γ(T)
Str(T)≡{Λai::κi.}i∈1..nt∈Ψ Ψ/prime≡(Str(T)≡{Λai::κi.}i∈1..nt)
ep(T) =e∈E E/prime≡ep(T) =e
/llbracketT/squigglerightK/prime;Γ/prime;ε;ε;Ψ/prime; E/prime/rrbracketmod
K;Γ;Ψ;E≡T,ep(T)(x-tp)
T/angbracketlefta/angbracketright::¯σ∈K Signature ¯Σ(T)≡{Ti}i∈1..n
,/braceleftbig
/llbracketT/angbracketleftTi/angbracketright/squigglerightK/prime
i;Γ/prime
i;ε;¯Σ/prime
i;Ψ/prime
i; E/prime
i/rrbracketmod≡{Xi,j}j∈1..mi,/bracerightbigi∈1..n
K/prime≡T/angbracketleftϑ/angbracketright::¯σ{, K/prime
i}i∈1..nΓ/prime≡{Γ/prime
i}i∈1..n
,¯Σ/prime≡{¯Σ/prime
i}i∈1..n
,
Ψ/prime≡{Ψ/prime
i}i∈1..n
, E/prime≡{E/prime
i}i∈1..n
,
/llbracketT/squigglerightK/prime;Γ/prime;ε;¯Σ/prime;Ψ/prime; E/prime/rrbracketmod
K;¯Σ≡/braceleftbig{Xi,j}j∈1..mi,/bracerightbigi∈1..n
,(x-tid)
Figure 18.3: Translation of fcrtm +gftx export list entries to fcrtm , continued from Fig-
ure 18.3
293
18 Modules
T/angbracketleftJoin(R)/angbracketright∈¯Σ ¯Σ/prime≡T/angbracketleftJoin(R)/angbracketright
/llbracketabstract Cp(T,Join(R))/squigglerightK/prime;ε;ε;ε;ε;ε/rrbracketmod≡{Xi}i∈1..n
,
/llbracketT/angbracketleftR/angbracketright/squigglerightK/prime;ε;ε;¯Σ/prime;ε;ε/rrbracketmod
¯Σ≡{Xi}i∈1..n
,(x-atc)
T/angbracketleftJoin(R)/angbracketright∈¯Σ ¯Σ/prime≡T/angbracketleftJoin(R)/angbracketright
/llbracketCp(T,Join(R))/squigglerightK/prime;Γ/prime;ε;ε;Ψ/prime; E/prime/rrbracketmod≡{Xi}i∈1..n
,
/llbracketT/angbracketleftR/angbracketright/squigglerightK/prime;Γ/prime;ε;¯Σ/prime;Ψ/prime; E/prime/rrbracketmod
¯Σ≡{Xi}i∈1..n
,(x-tc)
Figure 18.4: Translation of fcrtm +gftx export list entries to fcrtm , continued from Fig-
ure 18.3
The next rule, (x-atp), handles abstract types. If a type Tis to be exported
abstract, it has to be in scope, i.e., there must be an entry in K. The form of this
entry implies that Tis not type-indexed. The export list entry then appears in the
same form in the resulting module, and the kind information of the type (but not
its constructors, nor structural representation, nor embedding-projection pair) is
exported.
In contrast, if a type Tis exported as a concrete type, then rule (x-tp) deter-
mines the constructors of type Tfrom the type environment Γ, using an internal
operation of the form
constructors Γ(T)≡Γ/prime.
This operation traverses Γfor all constructors of which the result type matches T,
and returns the ﬁltered environment. Furthermore, the structural representa-
tion is extracted from the type synonym environment Ψ, and the embedding-
projection pair from E. The kind information of T, the types of the construc-
tors, the structural representation, and the embedding-projection pair are all ex-
ported, hence available for other modules. The target module does also contain
the type T, therefore the target export list exports Tas well. Furthermore, the
translated module contains the embedding-projection pair as a toplevel declara-
tion, and ep(T)is exported with its type.
For a type-indexed type T, the rule (x-tid) checks if a kind signature is present
in K. For type-indexed types, we can deﬁne a function Signature in analogy to
signature for type-indexed functions: the statement
Signature ¯Σ(T)≡{Ti}i∈1..n
,
expresses that the Tiare the named types for which the user has explicitly de-
ﬁned the type-indexed type T. This function requires that we mark each entry
294
18.2 Translation of modules containing type-indexed entities
/llbracketBfcrtm +gftx::t/squigglerightK2;Γ2;Σ2;Ψ2; E2;{Mk}k∈1../lscript
, /rrbracketmod
K1;Γ1;Σ1;Ψ1;E1≡Bfcrtm
B≡Hwhere{Di}i∈1..n
; main =e/braceleftbig
/llbracketDi/squigglerightKi;Γi;¯Σi;Ψi; Ei/rrbracketgftx
K;¯Σ;Ψ≡{Di,j}j∈1../lscripti;/bracerightbigi∈1..n
K≡K0{, Ki}i∈1..nΓ≡Γ0{,Γi}i∈1..n
¯Σ≡¯Σ0{,¯Σi}i∈1..nΨ≡Ψ0{,Ψi}i∈1..nE≡{Ei}i∈1..n
,
/llbrackete::t/squigglerightΓtoplevel /rrbracketmod
K;Γ;Σ;¯Σ;Ψ≡let{d/prime
i}i∈1..m/prime
; ine/prime
/llbracketH/squigglerightK/prime;Γ/prime;Σ/prime;Ψ/prime; E/prime;{Mk}k∈1../lscript
, /rrbracketmod
K;Γ,Γtoplevel ;Σ;Ψ;E0,E≡H/prime
B/prime≡H/primewhere{{Di,j}j∈1../lscripti;}i∈1..n
; main =letE{;d/prime
i}i∈1..m/primeine/prime
/llbracketB::t/squigglerightK/prime;Γ/prime;Σ/prime;Ψ/prime; E/prime;{Mk}k∈1../lscript
, /rrbracketmod
K0;Γ0;Σ0;Ψ0;E0≡B/prime(p-module)
Figure 18.5: Translation of fcrtm +gftx modules to fcrtm
in¯Σwhether it stems from an explicit deﬁnition or from a generically generated
component (cf. Section 14.4). Each of the components is then translated on its
own. The results from those translations, together with the kind signature for the
whole datatype, are then exported.
A request for a type component is handled by rules (x-atc) and (x-tc), depend-
ing on whether it is for an abstract component or not. In both cases, we verify
that the component exists by checking the type-level signature environment ¯Σ.
We also export this signature entry to other modules. Furthermore, we translate
an export list entry for the name of the associated type component and return the
results.
In addition to the translation of the export list, we have to create a translation
rule to handle complete modules. This rule is based on (p-gprog) on page 181.
The judgment for modules is of the form
/llbracketBfcrtm +gftx::t/squigglerightK2;Γ2;Σ2;Ψ2; E2;{Mk}k∈1../lscript
, /rrbracketmod
K1;Γ1;Σ1;Ψ1;E1≡Bfcrtm .
It takes a module and environments as input. We assume that there is a rule
for programs consisting of several modules that analyzes the import lists of the
modules and provides the imported entities in their respective environments.
Thus, we assume that all input environments contain precisely those entities from
other modules that are visible in Bfcrtm +gftx, plus possible built-in entities. All
entities that are exported from the module are returned, together with the module
names that constitute the import list. Furthermore, a type tis assigned to the
main expression of the module.
295
18 Modules
The rule (p-module) is shown in Figure 18.5. The module Bis of the form
Hwhere{Di}i∈1..n
; main =e.
There is the module header H, containing import and export information. Then
there are type declarations Di, and the main expression e.
Each of the type declarations Diis checked and translated. For this, we can
reuse the rules from Chapter 16 on type-indexed datatypes. Each declaration can
produce potentially multiple fcrtm declarations. In addition, several entries for
various environments can be produced. All type declarations may be mutually
recursive, therefore we pass to the type declarations environments K, ¯Σ, and Ψ
that contain not only the imported entities, but also the locally deﬁned types.
The main expression is translated using an adapted judgment of the form
/llbrackete::t/squigglerightΓtoplevel /rrbracketmod
K;Γ;Σ;¯Σ;Ψ≡e/prime.
We will make a brief excursion now to explain how the main expression is trans-
lated (which is not shown in a ﬁgure), and return to the discussion of rule (p-
module) thereafter. There a two differences between the judgment of the main
expression here, and the previous judgments for expressions. First, we force the
source expression einto the form of a letstatement, to reveal the toplevel decla-
rations of the expression. Hence, we can assume
e≡{di}i∈1..m
; .
The judgment returns the type environment Γtoplevel , containing the types of the
toplevel declarations di. Second, before the actual translation of the expression e,
it will be extended by additional declarations:
let{dgfcomps i}i∈1..m/prime
;{;di}i∈1..mine.
For each imported type-indexed function x, we add one declaration. Each of
these declarations is an empty typecase construct for the imported type-indexed
function x:
x/angbracketlefta/angbracketright=typecase aofε,
with the exception that the statement does not shadow the existing deﬁnition,
but extends it. Using this mechanism, we can make use of rule (d/tr-tidgf) (see
page 269, Section 16.7.7) to locally (i.e., per module) generate additional generic
components for the type-indexed functions.
For a type-indexed function in the context of modules, only the components
that make up the signature of the function are exported. Generically generated
296
18.3 Explicit specialization of type-indexed types is necessary
components are always local to the current module. If the same component is
needed in different modules, it is generated several times. This duplicates work,
but spares us the burden of administrating the information which specializations
are available already and which are not. A sophisticated compiler could optimize
here. Note that the implementations of type-indexed functions need not be ex-
ported; the type information and the signature are sufﬁcient for rule (d/tr-tidgf)
to produce new components.
For type-indexed datatypes, we generate components generically only upon a
specialization request. If these generated components are then exported, they can
also be used in other modules. This is discussed in more detail in Section 18.3.
Back to (p-module): we thus translate the main expression eusing the just
discussed adapted translation rule, yielding the translated fcrtm expression
let{d/prime
i}i∈1..m/prime
; ine/prime
and the toplevel environment Γtoplevel . We keep the toplevel of the translation
separate, for reasons that will become obvious soon.
The module header His translated using another judgment that we will not
present here, because it is a trivial wrapper around the export list translation of
Figures 18.3 and 18.4. The judgment is of the form
/llbracketH/squigglerightK1;Γ1;Σ1;Ψ1; E1;{Mk}k∈1../lscript
, /rrbracketmod
K2;Γ2;Σ2;Ψ2;E2≡H/prime.
Next to traversing the export list with the input environments and merging all
the result environments, the judgment also returns the module names Mkfrom
the import list.
The header translation is here called with environments containing all im-
ported entities, plus all entries derived from the type declarations, plus all local
toplevel declarations. The resulting environments are also the resulting environ-
ments for the module judgment.
It remains to construct the target module B/primefrom the translated header H/prime, the
translated type declarations Di,j. The local embedding-projection pairs, contained
in E, are added to the toplevel declarations of the translated expressions. It is im-
portant that they are added to the toplevel, because rule (x-tp) on page 293 causes
embedding-projection pairs to be exported if the associated type is exported as a
concrete type, and only toplevel declarations are allowed for export.
18.3 Explicit specialization of type-indexed types
is necessary
Type-indexed types have to be specialized explicitly by the user, by stating spe-
cialization requests in the program. This is different from type-indexed functions,
297
18 Modules
where the components that are needed are inferred automatically from the calls
that occur in the scope of a function.
One of the reasons for the explicit specialization of type-indexed types – the
one mentioned in Chapter 16 – was that there is a choice to be made, namely
whether a type should be specialized as a type synonym or as a new, distinct,
datatype. In the presence of modules, there is one additional reason why it is
very helpful to specialize type-indexed types explicitly.
As we have seen, a specialization of a type-indexed type to a type synonym is
often not possible, because of the limitations that type synonyms have, mainly
that they do not allow recursion. On the other hand, the specialization via
newtype introduces a new datatype, one that is distinct from all other types
that are in scope. As a consequence, generating the same component of a type-
indexed type twice via a newtype statement also introduces two different types
automatically.
M0(denes T1)
(uses T1/angbracketleftT2/angbracketright)M1 M2(uses T1/angbracketleftT2/angbracketright)
M3(conict!)
Figure 18.6: Conﬂicting components of type-indexed types
Now consider the following situation, shown in Figure 18.6. We have a module
M0, which deﬁnes a type-indexed type T1. We want to apply type T1to another,
recursive type T2, in two other modules, M1and M2. Therefore these two mod-
ules import T1from module M0. Because T2is a recursive type, the component
Cp(T1,T2)has to be a newtype component. This newtype deﬁnition cannot –
in general – be placed in module M0. The type T2might not even be known
in that module. The component also cannot be contained in whatever module
deﬁnes T2, because there, the type-indexed type might not be known.
If we adopt the same technique that we use for type-indexed functions, we
would thus generate the component twice, in the modules M1and M2. But
T1/angbracketleftT2/angbracketrightin module M1is now a different type than T1/angbracketleftT2/angbracketrightin module M2! If
we import both M1and M2into yet another module M3, we will get a name clash
– or, if we allow qualiﬁed imports, we will at least have to deal with two different
types and have no (easy) way to convert from one to the other.
Explicit specializations provide a way out of this dilemma: the user decides
where (and how often) the specialization T1/angbracketleftT2/angbracketrightis performed and Cp(T1,T2)is
298
18.4 Open versus closed type-indexed functions
M0(denes T1)
Mspec (explicitly specializes T1/angbracketleftT2/angbracketright)
(uses T1/angbracketleftT2/angbracketright)M1 M2(uses T1/angbracketleftT2/angbracketright)
M3(noconict)
Figure 18.7: Explicit specialization in a separate module
generated. If the programmer instructs the compiler to perform the specialization
T1/angbracketleftT2/angbracketrightin both M1and M2, we will be in the same situation as before. But there
is another option, depicted in Figure 18.7: one can deﬁne a specialization module
Mspec, importing the type-indexed type T1from M0(and possibly the datatype
T2from some other module), and containing at least the following code
module Mspec(T1/angbracketleftT2/angbracketright) (import M0; . . .)where
newtype T1/angbracketleftT2/angbracketrightasCspec .
This specialization module can be imported into both M1and M2, and thus the
two usage sites of T1/angbracketleftT2/angbracketrightcan make use of the same component. In this situation,
also further usage of the type in M3is unproblematic, because both imports will
refer to the same type.
18.4 Open versus closed type-indexed functions
We have treated deﬁnitions of type-indexed functions (and of type-indexed data-
types) as closed . All arms of the typecase construct have to be given at the deﬁ-
nition site of the function. It is not possible to add new cases at a later point.
This is not much of a problem if we consider programs consisting of only one
module. If we discover that we need an additional case for an already existing
type-indexed function, we can just go back to the deﬁnition and add it. However,
in real programs consisting of many modules this may be very inconvenient.
A datatype for which we need a special case might not yet be deﬁned in the
module where the type-indexed function is deﬁned, and we might not want the
299
18 Modules
module containing the type-indexed function to depend on a lot of modules pro-
viding datatype deﬁnitions. Even worse, the type-indexed function might be part
of a library, and if we change the library, we need access to the source, and the
modiﬁcation must be allowed by the license. Even then, we are in danger of
losing the change again if the library is updated.
It would be much more convenient to be able to have an open type-indexed
function, one that could be extended with new cases over different modules. This
is a central feature of Haskell type classes: instances for classes can be deﬁned in
every module where the class is in scope.
Default cases (cf. Chapter 14) give us the possibility to extend type-indexed
functions even though they remain closed. We can deﬁne a copy of the function,
and extend the copy with new cases. Other functions that are deﬁned in terms of
the original function, however, retain a dependency on the original function, and
have to be copied as well in order to work with the new deﬁnition.
Therefore, it might be desirable to allow open type-indexed functions that can
be extended like type classes. Open type-indexed functions, do, however, also
have a number of disadvantages. First, the order of cases in a typecase construct
should not matter. In this thesis, we have only considered type patterns for which
this property holds. This has been mainly for reasons of simplicity. It might be
desirable to extend the pattern language to allow nested, and hence overlapping
type patterns, too. For instance, Chakravarty and Keller (2003) describe a type-
indexed datatype for arrays that performs a ﬂattening optimization step if the
type argument is of a speciﬁc, nested form.
For type classes, some Haskell implementations circumvent the problem by al-
lowing overlapping instances . This does, however, lead to a rather complex and
sometimes counterintuitive algorithm to ﬁnd the correct instance in a given situ-
ation.
Another disadvantage of open type-indexed functions is that new cases can
change the behaviour of already written code, but only to a certain extent. As-
sume we have a module M1which contains the following deﬁnitions:
module M1(x,test1,test2) (. . .)where
x/angbracketlefta::∗/angbracketright ::(x/angbracketlefta/angbracketright)⇒Int
x/angbracketleftUnit/angbracketright =1
x/angbracketleftSum α β/angbracketright=x/angbracketleftα/angbracketright+x/angbracketleftβ/angbracketright
test1/angbracketlefta::∗/angbracketright::(x/angbracketlefta/angbracketright)⇒Int
test1/angbracketleftα::∗/angbracketright=2·x/angbracketleftα/angbracketright
test2 :: Int
test2 =2·x/angbracketleftBool/angbracketright.
300
18.4 Open versus closed type-indexed functions
The type-indexed function xcan derive a generic component for type Bool, be-
cause cases for types Unit and Sum are deﬁned. In the context of module M1, the
calls test1/angbracketleftBool/angbracketrightand test2both evaluate to 4.
If we extend function xin another module M2as follows,
module M2(. . .) (import M1; . . .)where
x/angbracketleftBool/angbracketright =0 ,
then, in the context of this module, call test1/angbracketleftBool/angbracketrightevaluates to 0, whereas test2
still evaluates to 4. The reason is, that test1still depends on x, and a component
forxon type Bool, which is different for modules M1and M2, is passed to the
translation. For test2, the component for xon type Bool is already determined
and applied in module M1, and cannot be changed later.
Other semantics of the above situation would be possible, but require deeper
changes to the translation mechanism.
All in all, it might be a good compromise to allow both open and closed type-
indexed functions in the language. By default, a type-indexed function would
be closed. If it should be open, it must be marked using an open keyword. We
might then impose certain restrictions on the functions (with respect to the type
patterns, for example), but in turn allow the deﬁnition of new cases in other
modules. Vytiniotis et al. (2004) also consider a calculus for generic programming
in which both open and closed deﬁnitions are possible. The precise implications
of such an extension for Generic Haskell remain future work.
301
18 Modules
302
Syntax overview
Complete syntax
Here, we list the complete syntax of the language, with all modiﬁcations that
have been introduced. For each construct, we state where it has been deﬁned.
Programs
P::={Di;}i∈1..nmain =e
[type declarations plus main expression, Figure 3.1]
| {B}i∈1..n
; (n∈1 . .)
sequence of modules, Figure 18.1
Modules
B::=Hwhere{Dj;}j∈1..nmain =e
type declarations plus main expression, Figure 18.1
Module headers
H::=module M({Xi}i∈1..m
, ) ({Ij}j∈1..n
; )
header with export list, Figure 18.1
Import declarations
I::=import M import module by name, Figure 18.1
303
Syntax overview
Export list entries
X::=x function name, Figure 18.1
|abstract T abstract type, Figure 18.1
|T concrete type, Figure 18.1
|abstract T/angbracketleftR/angbracketrightabstract type-indexed type component, Figure 18.2
|T/angbracketleftR/angbracketright concrete type-indexed type component, Figure 18.2
Type declarations
D::=data T={Λai::κi.}i∈1../lscript{Cj{tj,k}k∈1..nj}j∈1..m
|
datatype declaration, Figure 3.1
|newtype T={Λai::κi.}i∈1../lscriptC t
newtype declaration, Figure 15.1
|type T={Λai::κi.}i∈1../lscriptt
type synonym declaration, Figure 15.1
|T/angbracketlefta/angbracketright=Typecase aof{Pi→ti}i∈1..n
;
type-indexed datatype declaration, Figure 16.2
|newtype T/angbracketleftR/angbracketrightasC
newtype specialization request, Figure 16.2
|type T/angbracketleftR/angbracketright type specialization request, Figure 16.2
|T/angbracketleftα::κ/angbracketright=t type-level generic abstraction, Figure 16.2
Value declarations
d::=x=e function declaration, Figure 3.1
|x/angbracketlefta/angbracketright=typecase aof{Pi→ei}i∈1..n
;
type-indexed function declaration, Figure 4.1
|x/angbracketleftα{(γi::κi)}i∈1..n/angbracketright=e
local redeﬁnition, Figure 8.3
|x/angbracketleftα::κ/angbracketright=e generic abstraction, Figure 12.1
|x/primeextends xwhere{ykasy/prime
k}k∈1../lscript
;
default case, Figure 14.1
Kinds
κ::=∗ kind of manifest types, Figure 3.1
|κ1→κ2 functional kind, Figure 3.1
Kind signatures
¯σ::= ({Tk}k∈1..n
, )⇒κ
kind signature of type-indexed datatype, Figure 16.2
Qualiﬁed kinds
ρ::= (¯∆)⇒κ qualiﬁed kind, Figure 16.2
Kind constraint sets
¯∆::={¯Yi}i∈1..n
, kind constraint set, Figure 16.2
304
Complete syntax
Kind constraints
¯Y::=T/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::ρ0
kind dependency constraint, Figure 16.2
Types
t,u::=a,b,c,f, . . . type variable, Figure 3.1
|T named type, Figure 3.1
|(t1t2) type application, Figure 3.1
| ∀a::κ.t universal quantiﬁcation, Figure 3.1
|T/angbracketleftA/angbracketright type-level generic application, Figure 16.2
|LetT/angbracketleftα{(γi::κi)}i∈1..n/angbracketright=t1)Int2
type-level local redeﬁnition, Figure 16.2
Type patterns
P::=T [named type pattern, Figure 4.1]
|T{αi}i∈1..nparametrized named type pattern, Figure 6.1
Type arguments
A::=T named type, Figure 4.1
|α,β,γ, . . . dependency variable, Figure 6.1
|(A1A2) type application, Figure 6.1
|T/angbracketleftA/angbracketright type-level generic application, Figure 16.2
|LetT/angbracketleftα{(γi::κi)}i∈1..n/angbracketright=A1)InA2
type-level local redeﬁnition, Figure 16.2
Qualiﬁed types
q::={∀ai::κi.}i∈1..n(∆)⇒t
qualiﬁed type, Figure 6.1
Constraint sets
∆::={Yi}i∈1..n
, constraint set, Figure 6.1
Type constraints
Y::=x/angbracketleftα0{(αi::κi)}i∈1..n/angbracketright::q
dependency constraint, Figure 6.1
Type signatures
σ::= ({yk}k∈1..n
, )⇒t
[type signature of type-indexed function, Figure 6.1]
|({yk/angbracketleftϑk/angbracketright}k∈1..n
, )⇒t
type signature of type-indexed function, Figure 9.8
Type tuple patterns
π::={ai::∗}i∈1..r
,|{bj::κj}j∈1..s
,
[type tuple pattern, Figure 9.4]
305
Syntax overview
| {ai::κ}i∈1..r
,|{bj::κj}j∈1..s
,
type tuple pattern, Figure 12.1
Type tuples
ϑ::={ai}i∈1..r
,|{tj}j∈1..s
,
type tuple, Figure 9.4
Type argument tuples
Θ::={Ai}i∈1..r
,|{tj}j∈1..s
,
type argument tuple, Figure 9.4
Specialization request patterns
R::=T named type, Figure 16.2
|T/angbracketleftR/angbracketright type-indexed datatype component, Figure 16.2
Expressions
e::=x,y,z, . . . variable, Figure 3.1
|C constructor, Figure 3.1
|(e1e2) application, Figure 3.1
|λx→e lambda abstraction, Figure 3.1
|case e0of{pi→ei}i∈1..n
;
case, Figure 3.1
|letdine [let, Figure 3.1]
|ﬁxe [ﬁxed point, Figure 3.1]
|fail run-time failure, Figure 3.8
|letrec{di}i∈1..n
; ine
recursive let, Figure 3.12
|x/angbracketleftA/angbracketright generic application, Figure 4.1
Patterns
p::=C{pi}i∈1..nconstructor pattern, Figure 3.1
|x,y,z, . . . variable pattern, Figure 3.1
Values
v::=C{vi}i∈1..nconstructor, Figure 3.8
|λx→e function, Figure 3.8
|fail run-time failure, Figure 3.8
Weak head-normal form
w::=C{ei}i∈1..nconstructor, Figure 3.8
|λx→e function, Figure 3.8
|fail run-time failure, Figure 3.8
306
All languages
All languages
Here, we provide a list of all languages that are used.
Languages without generic programming features (target languages)
fc functional core language
fcr fc with recursive let
fcrt fcr with newtype andtype
fcrtm fcrt with modules
Languages with generic programming features (source languages)
fcr+tif fcrwith type-indexed functions
fcr+tif+par fcr+tif with parametrized type patterns
fcr+tif+par+lr fcr+tif+par with local redeﬁnition
fcr+tif+mpar fcr+tif+par with generalized type signatures
fcr+gf fcr+tif+(m)par +lr with generic components
fcr+gf+gabs fcr+gf with generic abstraction
fcr+gf+gabs +dc fcr+gf+gabs with default cases
fcrt+gf+gabs +dc like fcr+gf+gabs +dc, but based on fcrt
fcrt+gftx fcrt+gf+gabs +dc with type-indexed datatypes
fcrtm +gftx like fcrt+gftx, but based on fcrtm
Metavariables used
This is an exhaustive list of all metavariables that are used for entities in the core
languages and their several extensions. For each metavariable, we list what it is
used for and in which ﬁgure it is introduced.
atype variable Figure 3.1
btype variable Figure 3.1
ctype variable Figure 3.1
dvalue declaration Figure 3.1
eexpression Figure 3.1
ftype variable Figure 3.1
inatural number
jnatural number
knatural number
/lscriptnatural number
mnatural number
nnatural number
ppattern Figure 3.1
307
Syntax overview
qqualiﬁed type Figure 6.1
rnatural number
snatural number
ttype Figure 3.1
utype Figure 3.1
vvalue Figure 3.8
wweak head-normal form Figure 3.8
xvariable Figure 3.1
yvariable Figure 3.1
zvariable Figure 3.1
Atype argument Figure 4.1
Bmodule Figure 18.1
Cconstructor Figure 3.1
Dtype declaration Figure 3.1
Hmodule header Figure 18.1
Iimport declaration Figure 18.1
Mmodule name Figure 18.1
Pprogram Figure 3.1
Rspecialization request pattern Figure 16.2
Stype declaration shell Figure 16.2
Tnamed type Figure 3.1
Xexport list entry Figure 18.1
Ytype constraint Figure 6.1
¯Ykind constraint Figure 16.2
αdependency variable Figure 6.1
βdependency variable Figure 6.1
γdependency variable Figure 6.1
εempty environment/list/word
ϑtype tuple Figure 9.4
κkind Figure 3.1
λ(symbol for lambda abstraction) Figure 3.1
πtype tuple pattern Figure 9.4
ρqualiﬁed kind Figure 16.2
σtype signature Figure 6.1
¯σkind signature Figure 16.2
ϕsubstitution
ψsubstitution
Γtype environment Section 3.3
∆constraint set Figure 6.1
dependency environment Section 6.4.2
308
Metavariables used
¯∆kind constraint set Figure 16.2
kind dependency environment Section 16.7
E environment
embedding-projection pair environment Section 11.5
Θtype argument tuple Figure 9.4
K kind environment Section 3.3
Λ(symbol for type-level lambda abstraction) Figure 3.1
Σsignature environment Section 4.4
¯Σkind signature environment Section 16.7
Ψstructural representation environment Section 11.5
309
Syntax overview
310
Samenvatting in het
Nederlands
Dit proefschrift bekijkt Generic Haskell – een uitbreiding van de functionele pro-
grammeertaal Haskell – van alle kanten. De naam “Generic Haskell” is namelijk
de afgelopen jaren voor een behoorlijk aantal verschillende idee ¨en en talen ge-
bruikt. Er zijn veel artikelen gepubliceerd, die allemaal een iets andere versie
van de taal beschrijven. De verschillen doen zich voor in syntax, features, theorie
en meer. E ´en van de doelen van dit proefschrift is om de mogelijke verwarring
weg te nemen. De huidige stand van zaken m.b.t. Generic Haskell wordt in zijn
geheel beschreven in een consistente notatie. Dit proefschrift bevat een integra-
le beschrijving van Generic Haskell samen met voorgestelde uitbreidingen. De
taal en de uitbreidingen worden ge ¨ıntroduceerd met aanschouwelijke voorbeel-
den. Verder wordt beschreven hoe de componenten van de taal ge ¨ımplementeerd
kunnen worden.
Van statische types naar generiek programmeren
Statische types ondersteunen het schrijven van correcte programma’s. Veel pro-
grammeertalen hebben statische typering. Door gebruik te maken van statische
types kunnen niet alle programmeerfouten worden gevonden, maar een goed ty-
pesysteem is in staat om een aantal, soms lastige, run-time fouten te elimineren.
311
Samenvatting in het Nederlands
Omdat besturingssystemen voor sommige van deze fouten geen goede uitzonde-
ringsbehandelingen hebben, is het belangrijk ze al in een vroegtijdig stadium op
te sporen. De fouten worden vaak veroorzaakt doordat een programma op een
plek in het geheugen wil lezen of schrijven, die niet bij het programma hoort.
Met behulp van statische typering kan een programma al tijdens de vertaling
naar machinecode worden getest, en kan worden gecontroleerd dat bovenstaand
gedrag niet voorkomt.
Typesystemen verschillen vooral in hoeveel informatie over een programma
kan worden geveriﬁeerd. Sommige typesystemen proberen bijvoorbeeld ook de-
ling door nul te voorkomen, of dat een array index buiten de grenzen van het
array ligt. Maar er is een trade-off: als het typesysteem te slim wil zijn, wordt de
typechecking procedure heel inefﬁci ¨ent of zelfs onbeslisbaar. En als een typesys-
teem weinig intelligentie bevat, dan kan een vertaler programma’s afwijzen die
eigenlijk goedgekeurd zouden moeten worden. De vertaler kan dan bijvoorbeeld
niet herkennen dat een gevaarlijke constructie alleen in omstandigheden die aan
bepaalde condities voldoen wordt gebruikt.
Het typesysteem van Hindley (1969) en Milner (1978) kan de meeste gebruike-
lijke programma’s typeren. Het leidt op een efﬁci ¨ente manier het best mogelijke
type voor een programma af, zonder dat een programmeur het programma hoeft
te annoteren. Een verder pluspunt van dit systeem is de mogelijkheid om parame-
trisch polymorfe functies te kunnen schrijven. Een parametrisch polymorfe functie
werkt op dezelfde manier voor alle datatypes, en hoeft maar ´e´en keer geschre-
ven te worden. Vervolgens kan zo’n functie dan automatisch voor alle datatypes
ge¨ınstantieerd worden.
Haskell (Peyton Jones 2003), maar ook andere programmeertalen zoals bijvoor-
beeld sml(Milner et al. 1997) en Clean (Plasmeijer and van Eekelen 2001), zijn ge-
baseerd op het Hindley-Milner typesysteem. Vooral Haskell wordt veel gebruikt
bij experimenten met uitbreidingen van het Hindley-Milner typesysteem. De
deﬁnitie van Haskell bevat al een aantal uitbreidingen van het klassieke Hindley-
Milner systeem. Het bevat bijvoorbeeld expliciete typesignaturen, wardoor een
type van een functie kan worden ingeperkt, en met behulp van type klassen
kunnen overloaded functies worden geschreven. Het gedrag van een overloaded
functie hangt af van het type waarop het wordt gebruikt.
Haskell en de andere talen gebaseerd op het Hindley-Milner typesysteem heb-
ben echter een probleem: er is een conﬂict tussen het gebruik van statische types
om typefouten te voorkomen en het doel zo veel mogelijk code te hergebruiken.
Statische types introduceren voor de computer een verschil waar er normaal geen
verschil zou zijn. Bijvoorbeeld, een datum bestaat uit drie integers, maar als een
datum wordt opgevat als een apart datatype, dan kunnen alleen speciale functies,
die voor waardes van het type datum bedoelt zijn, toegepast worden.
312
Generic Haskell
Hoewel dit gedrag vaak gewenst is, kan het soms ook in de weg staan. Pa-
rametrisch polymorfe functies helpen hier. Het werken met veel verschillende
datatypes wordt vereenvoudigd omdat er veel functies zijn die op alle dataty-
pes werken. Voorbeelden van parametrisch polymorfe functies zijn: het plaatsen
van een element in een lijst of een boom, of het selecteren of herschikken van
elementen in een datastructuur.
Maar met parametrisch polymorfe functies kan men alleen maar dingen doen
die volledig onafhankelijk zijn van de eigenlijke waardes. Vaak wil men echter
destructuur van een datatype gebruiken in de deﬁnitie van een functie. Stel dat
er drie types zijn voor identiﬁcatienummers, kamernummers en jaartallen. Al
deze types zijn in principe integers, maar men wil graag voorkomen dat een jaar
opeens als een kamernummer wordt gebruikt. Niettemin is het soms beter om
direct met de onderliggende integers te werken, omdat er operaties voor integers
bestaan die niet op alle datatypes werken. Integers kunnen worden gesommeerd,
vergeleken, opgehoogd enzovoorts. Deze functionaliteit kan niet worden uitge-
drukt via een parametrisch polymorfe functie, omdat het alleen toepasbaar is op
integers en misschien andere numerieke types, maar niet op alle types, en zeker
niet op alle types op dezelfde manier.
Met een type klasse kan een programmeur een overloaded versie van een func-
tie schrijven, die op verschillende datatypes op een verschillende manier werkt.
Een voorbeeld van een overloaded functie is de in Haskell voorgedeﬁnieerde
gelijkheidstest. Andere voorbeelden zijn optellen en vergelijken. Als identiﬁ-
catienummers, kamernummers en jaartallen als een instantie van de juiste type
klassen worden gedeclareerd, dan kunnen we dezelfde functies voor alle drie ty-
pes gebruiken. Maar wanneer we een nieuw datatype deﬁni ¨eren, dan moeten we
ook nieuwe instance declaraties voor deze type klassen verzinnen, en als we een
nieuwe functie deﬁni ¨eren die in principe op integers werkt, moeten we de functie
zelf aan een type klasse toevoegen en alle instance declaraties aanpassen.
Er ontbreekt dus een gecontroleerd mechanisme om de verschillen die door het
typesysteem worden gemaakt te negeren, en alleen maar naar de structuur van
de types te kijken. Het deﬁni ¨eren van functies met behulp van analyse van de
structuur van datatypes is waar generiek programmeren om draait.
Generic Haskell
Haskell heeft al een beperkt mechanisme voor de gewenste functionaliteit: met
behulp van het deriving construct kunnen voor een vast aantal type klassen auto-
matisch instanties worden gegenereerd, waaronder gelijkheid, het vergelijken van
waardes, het opleveren van een kleinste en grootste waarde van een type, of het
vertalen van een waarde naar een canonieke string-representatie. Haskell heeft
313
Samenvatting in het Nederlands
dus een aantal ingebouwde generieke programma’s, maar geen taalconstructies
waarmee men zijn eigen generieke programma’s kan schrijven. Als men een an-
dere generieke functie of een variant van een voorgedeﬁnieerde functie nodig
heeft, moet deze functie voor alle datatypes opnieuw gedeﬁnieerd worden.
In de afgelopen jaren zijn er meerdere talen voor generiek programmeren ont-
wikkelt. E ´en daarvan is Generic Haskell. Generic Haskell breidt Haskell uit met
een constructie waarmee generieke functies en zelfs generieke datatypes kunnen
worden gedeﬁnieerd. Deze worden voor een beperkt aantal eenvoudige dataty-
pes gedeﬁnieerd, maar kunnen dan op alle (of bijna alle) datatypes in Haskell
gebruikt worden. Als een nieuw datatype wordt gedeﬁnieerd of ge ¨ımporteerd,
dan zijn generieke functies automatisch ook voor dit nieuwe datatype beschik-
baar.
In de context van Generic Haskell zijn er twee verschillende manieren ontwik-
keld om generieke functies te deﬁni ¨eren. Deze zijn allebei gebaseerd op artikelen
van Ralf Hinze. De eerste manier (Hinze 2000 b) is makkelijker te gebruiken. De
tweede (Hinze 2000 c) is krachtiger, maar vereist meer kennis over de theorie van
generiek programmeren. E ´en van de belangrijkste bijdragen van dit proefschrift
is een combinatie van deze twee stijlen, genaamd “Dependency-style” (L ¨ohet al.
2003).
Wij gebruiken “Dependency-style” niet alleen om generiek programmeren in
Haskell uit te leggen, maar ook om alle varianten en verbeteringen van de taal,
zoals generieke abstracties, “default cases”, en type-indexed datatypes te intro-
duceren.
314
Bibliography
P. Achten, A. Alimarine, and R. Plasmeijer. When generic functions use dynamic
values . In: R. Pe ˜na and T. Arts (editors), Implementation of Functional Languages:
14th International Workshop, IFL 2002, Madrid, Spain, September 16–18, 2002, Re-
vised Selected Papers , volume 2670 of Lecture Notes in Computer Science , pages
17–33. Springer-Verlag 2003.
P. Achten, M. van Eekelen, and R. Plasmeijer. Generic graphical user interfaces .
In:Implementation of Functional Languages: 15th International Workshop, IFL 2003,
Edinburg, Scotland, September 8–10, 2003, Revised Selected Papers . Lecture Notes
in Computer Science, Springer-Verlag 2004. To appear.
P. Achten and R. Hinze. Combining generics and dynamics . Technical Report NIII-
R0206, Nijmegen Institute for Computing and Information Sciences, Faculty of
Science, University of Nijmegen 2002.
A. Alimarine and R. Plasmeijer. A generic programming extension for Clean . In:
T. Arts and M. Mohnen (editors), Proceedings of the 13th International Workshop on
the Implementation of Functional Languages, IFL 2001, Selected Papers, ¨Alvsj¨ o, Swe-
den, volume 2312 of Lecture Notes in Computer Science , pages 168–185. Springer-
Verlag 2001.
315
Bibliography
A. Alimarine and S. Smetsers. Optimizing generic functions . In: Proceedings of the
Seventh International Conference on Mathematics of Program Construction, Stirling,
United Kingdom 2004. To appear.
T. Altenkirch and C. McBride. Generic programming within dependently typed
programming . In: J. Gibbons and J. Jeuring (editors), Generic Programming:
IFIP TC2/WG2.1 Working Conference on Generic Programming July 11–12, 2002,
Dagstuhl, Germany , pages 1–20. Number 115 in International Federation for In-
formation Processing, Kluwer Academic Publishers 2003.
F. Atanassow and J. Jeuring. Inferring type isomorphisms generically . In: Proceedings
of the Seventh International Conference on Mathematics of Program Construction,
Stirling, United Kingdom 2004. To appear.
L. Augustsson. Cayenne – a language with dependent types . ACM SIGPLAN Notices,
34(1):pages 239–250 1999.
A. I. Baars and S. D. Swierstra. Typing dynamic typing . In: Proceedings of the
seventh ACM SIGPLAN international conference on Functional programming , pages
157–166. ACM Press 2002.
R. Backhouse, P. Jansson, J. Jeuring, and L. Meertens. Generic programming: An
introduction . In: S. D. Swierstra, P. R. Henriques, and J. N. Oliveira (editors),
Advanced Functional Programming , volume 1608 of Lecture Notes in Computer Sci-
ence, pages 28–115. Springer-Verlag 1999.
R. Bird. Introduction to Functional Programming using Haskell . Prentice Hall Europe,
London, second edition 1998.
R. Bird, O. de Moor, and P. Hoogendijk. Generic functional programming with types
and relations . Journal of Functional Programming, 6(1):pages 1–28 1996.
M. M. T. Chakravarty and G. Keller. An approach to fast arrays in Haskell . In:
J. Jeuring and S. Peyton Jones (editors), Advanced Functional Programming, 4th
International School, AFP 2002, Oxford, UK, August 19-24, 2002, Revised Lectures ,
volume 2638 of Lecture Notes in Computer Science , pages 27–58. Springer-Verlag
2003.
J. Cheney and R. Hinze. A lightweight implementation of generics and dynamics . In:
Proceedings of the ACM SIGPLAN workshop on Haskell , pages 90–104. ACM Press
2002.
J. Cheney and R. Hinze. First-class phantom types . Technical Report CUCIS
TR2003-1901, Cornell University 2003.
316
Bibliography
URL http://techreports.library.cornell.edu:8081/Dienst/UI/1.0/
Display/cul.cis/TR2003-1901/
K. Claessen and J. Hughes. QuickCheck: A lightweight tool for random testing of
Haskell programs . In: Proceedings of the ﬁfth ACM SIGPLAN international confer-
ence on Functional programming , pages 268–279. ACM Press 2000.
D. Clarke, R. Hinze, J. Jeuring, A. L ¨oh, and J. de Wit. The Generic Haskell user’s
guide, version 0.99 (Amber) . Technical Report UU-CS-2001-26, Institute of Infor-
mation and Computing Sciences, Universiteit Utrecht 2001.
D. Clarke, J. Jeuring, and A. L ¨oh. The Generic Haskell user’s guide, version 1.23 –
Beryl release . Technical Report UU-CS-2002-047, Institute of Information and
Computing Sciences, Universiteit Utrecht 2002.
D. Clarke and A. L ¨oh. Generic Haskell, speciﬁcally . In: J. Gibbons and J. Jeuring
(editors), Generic Programming: IFIP TC2/WG2.1 Working Conference on Generic
Programming July 11–12, 2002, Dagstuhl, Germany , pages 21–47. Number 115 in
International Federation for Information Processing, Kluwer Academic Pub-
lishers 2003.
L. Damas and R. Milner. Principal type-schemes for functional programs . In: Proceed-
ings of the 9th ACM SIGPLAN-SIGACT symposium on Principles of Programming
Languages , pages 207–212. ACM Press 1982.
ghcTeam. The Glasgow Haskell Compiler User’s Guide .
URL http://haskell.org/ghc/docs/latest/users_guide.ps.gz
J.-Y. Girard. Interpr´ etation fonctionelle et ´ elimination des coupures dans l’arithm´ etique
d’ordre sup´ erieur . Ph.D. thesis, Universit ´e Paris VII 1972.
R. Harper and G. Morrisett. Compiling polymorphism using intensional type analysis .
In:Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of
programming languages , pages 130–141. ACM Press 1995.
R. Hindley. The principal type-scheme of an object in combinatory logic . Transactions
of the American Mathematical Society, 146:pages 29–66 1969.
R. Hinze. A generic programming extension for Haskell . In: E. Meijer (editor), Pro-
ceedings of the Third Haskell Workshop, Paris, France . Number UU-CS-1999-28 in
Universiteit Utrecht Technical Reports 1999 a.
R. Hinze. Polytypic functions over nested datatypes . Discrete Mathematics and The-
oretical Computer Science, 3(4):pages 193–214 1999 b.
317
Bibliography
R. Hinze. Generic Programs and Proofs 2000 a. Habilitationsschrift, Bonn University.
R. Hinze. A new approach to generic functional programming . In: T. W. Reps (editor),
Proceedings of the 27th Annual ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages, Boston, Massachusetts , pages 119–132. ACM Press
2000 b.
R. Hinze. Polytypic values possess polykinded types . In: R. Backhouse and J. N.
Oliveira (editors), Proceedings of the Fifth International Conference on Mathematics
of Program Construction, July 3–5, 2000 , volume 1837 of Lecture Notes in Computer
Science , pages 2–27. Springer-Verlag 2000 c.
R. Hinze. Fun with phantom types . In: J. Gibbons and O. de Moor (editors), The
Fun of Programming . Cornerstones of Computing, Palgrave Macmillan 2003.
R. Hinze and J. Jeuring. Generic Haskell: applications . In: R. Backhouse and J. Gib-
bons (editors), Generic Programming, Advanced Lectures , volume 2793 of Lecture
Notes in Computer Science , pages 57–96. Springer-Verlag 2003 a.
R. Hinze and J. Jeuring. Generic Haskell: practice and theory . In: R. Backhouse
and J. Gibbons (editors), Generic Programming, Advanced Lectures , volume 2793
ofLecture Notes in Computer Science , pages 1–56. Springer-Verlag 2003 b.
R. Hinze, J. Jeuring, and A. L ¨oh. Type-indexed data types . In: E. A. Boiten
and B. M ¨oller (editors), Mathematics of Program Construction: Sixth International
Conference , volume 2386 of Lecture Notes in Computer Science , pages 148–174.
Springer 2002. Also appeared as Universiteit Utrecht Technical Report UU-CS-
2002-011.
URL http://www.cs.ukc.ac.uk/pubs/2002/1368/
R. Hinze and S. Peyton Jones. Derivable type classes . In: G. Hutton (editor), Pro-
ceedings of the 2000 ACM SIGPLAN Haskell Workshop , volume 41(1) of Electronic
Notes in Theoretical Computer Science . Elsevier Science 2001. The preliminary
proceedings appeared as a University of Nottingham technical report.
G. Huet. Functional Pearl: The Zipper . Journal of Functional Programming,
7(5):pages 549–554 1997.
P. Jansson. Functional Polytypic Programming . Ph.D. thesis, Chalmers University
of Technology and G ¨oteborg University 2000.
P. Jansson and J. Jeuring. PolyP – a polytypic programming language extension . In:
Conference Record 24th ACM SIGPLAN-SIGACT Symposium on Principles of Pro-
gramming Languages, Paris, France , pages 470–482. ACM Press 1997.
318
Bibliography
C. B. Jay. Distinguishing data structures and functions: the constructor calculus and
functorial types . In: S. Abramsky (editor), Typed Lambda Calculi and Applica-
tions: 5th International Conference TLCA 2001, Krak´ ow, Poland, May 2001 Proceed-
ings, volume 2044 of Lecture Notes in Computer Science , pages 217–239. Springer-
Verlag 2001.
C. B. Jay. The pattern calculus 2003. Accepted for publication by ACM Transactions
on Programming Languages and Systems.
URL http://www-staff.it.uts.edu.au/~cbj/Publications/pattern_
calculus.ps
C. B. Jay, E. Moggi, and G. Bell `e.Functors, types and shapes . In: R. Backhouse and
T. Sheard (editors), Workshop on Generic Programming: Marstrand, Sweden, 18th
June, 1998 . Chalmers University of Technology 1998.
M. P. Jones. Qualiﬁed Types: Theory and Practice . Cambridge University Press 1994.
M. P. Jones. Type classes with functional dependencies . In: Proceedings of the 9th
European Symposium on Programming Languages and Systems , pages 230–244.
Springer-Verlag 2000.
W. Kahl and J. Scheffczyk. Named instances for Haskell type classes . In: R. Hinze
(editor), Preliminary Proceedings of the 2001 ACM SIGPLAN Haskell Workshop .
Number UU-CS-2001-62 in Technical Report, Institute of Information and Com-
puting Sciences, Universiteit Utrecht 2001.
P. Koopman, A. Alimarine, J. Tretmans, and R. Plasmeijer. GAST: Generic Auto-
mated Software Testing . In: R. Pe ˜na and T. Arts (editors), Implementation of Func-
tional Languages: 14th International Workshop, IFL 2002, Madrid, Spain, September
16–18, 2002, Revised Selected Papers , volume 2670 of Lecture Notes in Computer
Science , pages 84–100. Springer-Verlag 2003.
R. L ¨ammel and S. Peyton Jones. Scrap your boilerplate: a practical design pattern
for generic programming . ACM SIGPLAN Notices, 38(3):pages 26–37 2003. Pro-
ceedings of the ACM SIGPLAN Workshop on Types in Language Design and
Implementation (TLDI 2003).
R. L ¨ammel and S. Peyton Jones. Scrap more boilerplate: reﬂection, zips, and gener-
alised casts 2004. Draft; submitted to ICFP 2004.
R. L ¨ammel and J. Visser. Typed combinators for generic traversal . In: Proceedings
Practical Aspects of Declarative Programming PADL 2002 , volume 2257 of Lecture
Notes in Computer Science , pages 137–154. Springer-Verlag 2002.
319
Bibliography
R. L¨ammel, J. Visser, and J. Kort. Dealing with large bananas . In: J. Jeuring (editor),
Workshop on Generic Programming 2000, Ponte de Lima, Portugal , volume UU-CS-
2000-19 of Universiteit Utrecht Technical Report , pages 46–59 2000.
J. R. Lewis, M. B. Shields, E. Meijer, and J. Launchbury. Implicit parameters: Dy-
namic scoping with static types . In: T. W. Reps (editor), Proceedings of the 27th
Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Lan-
guages, Boston, Massachusetts , pages 108–118 2000.
A. L ¨oh, D. Clarke, and J. Jeuring. Dependency-style Generic Haskell . In: Proceedings
of the eighth ACM SIGPLAN international conference on Functional programming ,
pages 141–152. ACM Press 2003.
I. Lynagh. Typing Template Haskell: Soft types 2004. Submitted to Haskell Workshop
2004.
C. McBride. The derivative of a regular type is its type of one-hole contexts 2001.
Unpublished manuscript.
C. McBride and J. McKinna. The view from the left . Journal of Functional Program-
ming, 14(1):pages 69–111 2004.
R. Milner. A theory of type polymorphism in programming . Journal of Computer and
System Sciences, 17(3):pages 348–375 1978.
R. Milner, M. Tofte, R. Harper, and D. MacQueen. The Deﬁnition of Standard ML
(Revised) . The MIT Press 1997.
U. Norell and P. Jansson. Polytypic programming in Haskell . In: Implementation
of Functional Languages: 15th International Workshop, IFL 2003, Edinburg, Scot-
land, September 8–10, 2003, Revised Selected Papers . Lecture Notes in Computer
Science, Springer-Verlag 2004. To appear.
S. Peyton Jones (editor). Haskell 98 Language and Libraries: The Revised Report .
Cambridge University Press 2003.
S. Peyton Jones and M. Shields. Practical type inference for arbitrary-rank types 2003.
URL http://research.microsoft.com/Users/simonpj/papers/putting/
B. C. Pierce. Types and Programming Languages . The MIT Press 2002.
R. Plasmeijer and M. van Eekelen. The Concurrent Clean language report, version 2.0
2001.
URL ftp://ftp.cs.kun.nl/pub/Clean/Clean20/doc/CleanRep2.0.pdf
320
Bibliography
T. Sheard and S. Peyton Jones. Template meta-programming for Haskell . ACM SIG-
PLAN Notices, 37(12):pages 60–75 2002.
M. G. T. Van den Brand, H. A. de Jong, P. Klint, and P. A. Olivier. Efﬁcient
annotated terms . Software – Practice and Experience, 30(3):pages 259–291 2000.
M. de Vries. Specializing Type-Indexed Values by Partial Evaluation . Master’s thesis,
Rijksuniversiteit Groningen 2004.
D. Vytiniotis, G. Washburn, and S. Weirich. An open and shut typecase 2004. Sub-
mitted to ICFP 2004.
W3C. XML Schema: Formal description 2001.
URL http://www.w3.org/TR/xmlschema-formal/
W3C. Extensible markup language (XML) 1.0 (third edition), W3C recommendation
2004.
URL http://www.w3.org/TR/2004/REC-xml-20040204/
P. Wadler. Views: a way for pattern matching to cohabit with data abstraction . In:
Proceedings of the 14th ACM SIGACT-SIGPLAN symposium on Principles of pro-
gramming languages , pages 307–313. ACM Press 1987.
P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad hoc . In: Proceed-
ings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming
languages , pages 60–76. ACM Press 1989.
P. L. Wadler. How to replace failure by a list of successes . In: J. P. Jouannaud (ed-
itor), Functional Programming Languages and Computer Architecture , volume 201
ofLecture Notes in Computer Science , pages 113–128. Springer-Verlag 1985.
S. Weirich. Higher-order intensional type analysis . In: D. L. M ´etayer (editor),
Programming Languages and Systems, 11th European Symposium on Programming,
ESOP 2002, held as Part of the Joint European Conferences on Theory and Practice of
Software, ETAPS 2002 , volume 2305 of Lecture Notes in Computer Science , pages
98–114. Springer-Verlag 2002.
321
Bibliography
322
Index
∗n,25
<lex,71, 81
[ ],157
Abs,202
abstract component, 288
abstract syntax tree, 215
abstract type, 109, 173, 239, 271, 287,
290
add,42,54, 56, 59, 65, 81, 82, 103, 108,
168
algebra
of a datatype, 279
AlgebraOf, 279
algorithm
generic application, 238
all,197
allEqual , 63
alpha-conversion, 20, 24ana,198
anamorphism, 5, 198
and,197, 200
any,197, 207
arity, 145, 153, 172, 178, 195, 212, 214
arity,268
arms, 22
ATerm, 113
automatic testing, 111
balanced encoding, 272, 280, 284
base kind, 251,254
base type, 58,75,145, 152, 168, 172, 202,
211
base type inference, 212
bimap , 167, 169, 172, 173, 175, 177, 180,
182, 219, 243, 266, 271
Bit,114, 272
bit, 114
323
Index
body, 22
Bool, 110,157, 272
bounded type tuple, 144, 148
capture
of names, 20, 24
card, 195, 211, 239, 275
Cardinality, 275
cardinality test, 112
case-sensitive, 122
cata,198, 200, 205, 279
catamorphism, 5, 6, 198
Cayenne, 10
check ,141, 147
children , 272, 279
choice, 108, 271
Clean, 2, 9, 187
closed base type application, 267
closed expression, 33
closed type-indexed function, 8, 44,
286, 295
coercion function, 84, 187
collect ,138, 141, 147, 196, 197, 215, 217,
218, 225, 279
comap ,220
Cp,241, 258
cp,47
company, 218
comparison
generic, 113
of type tuples, 143
component, 47,55, 56, 66, 90, 92, 94,
115, 171, 180, 185, 186, 202,
220, 222, 232, 241, 242, 254,
258, 262, 288, 292
extraneous, 185
generation of, 117, 268
compose ,198
compositional, 186, 258
compression, 114
Con, 273concat ,198
concrete type, 287, 290
conj,197, 204
constructor, 22, 156, 158, 160, 179, 230,
240, 242, 271, 287
name of, 274
constructor case, 6, 272,282
constructor descriptor, 273, 275
constructors ,290
Context, 247
contravariant, 29
core language, 21, 95
countForall ,174
cpr,63, 65, 80, 82, 104
CprResult, 63
Ctx,247
CtxF, 247
data , 229, 236, 245, 249
datatype, 4, 22, 107, 156, 160, 171, 179,
187, 199, 216, 229, 235, 270
abstract, 239, 271
embedding of, 155, 157
ﬁnite, 195
local, 190
nested, 4, 109, 186
of type representations, 187
recursive, 240
regular, 4, 278
translation of, 115
decode ,196, 272
decodes ,114, 196, 272
deep extension, 217
default arm
for kind∗,173
default case, 6, 8, 12, 122, 154,216, 225,
229, 282, 296
implementation of, 221
dependencies
explosion of, 207
multiple on one function, 219
324
Index
dependency, 7, 11,55,57,58, 61, 64, 65,
75, 77, 95, 117, 121, 123, 124,
133, 135, 140, 146, 180, 184,
197, 202, 210, 217, 220, 245
of a type-indexed datatype, 237,
254
unnecessary, 67
dependency component, 94
dependency constraint, 58,70, 80, 89,
94, 103, 121, 127, 150, 153, 172,
177, 195, 261
kind-level, 244
well-formed, 73
well-formed kind-level, 252
dependency environment, 84, 87, 92,
121, 122, 123, 130, 182
dependency inference, 211
dependency relation, 167
transitivity of, 66, 75, 148
dependency variable, 59,70, 71, 72, 77,
90, 92, 94, 103, 124, 126, 135,
150, 153, 169, 184, 190, 210,
217, 237, 243, 257, 268, 282
free, 19
Dependency-style, 7, 11, 12, 16, 103,
189, 226
dependent types, 10
deriving , 4, 5, 112
dictionary, 122, 211
digital search tree, 236
Direction, 159, 281
disj,197
down ,248
DSum, 190
DUnit, 190
dynamic typing, 187
editor
for structured documents, 246
efﬁciency
of a generic function, 281elem,207
elimination of dependency, 59
embedding-projection pair, 116, 157,
162, 169, 199, 232, 262, 266,
270, 273, 279, 284, 290
embedding-projection pair environ-
ment, 180
empty ,110,239
encode ,114, 117, 168, 196, 272, 281
entailment, 86, 97
enum ,111, 112, 123, 140, 157, 188, 189,
195, 211, 239
environment, 71
EP,116, 169, 175, 181
ep,116
Epigram, 10
Equal, 187
equal , 63, 112, 123, 140, 190, 207, 211,
218, 251, 270, 281
equality, 112, 218
case-insensitive, 123
of types, 187
variants of, 122, 218
equality symbols, 17
existentially quantiﬁed type variable,
188
explicit specialization, 240
exponentials
laws of, 237
export list, 287, 287, 288, 291, 293
Expr, 283
expression
translation of, 87
factorial, 6
fail,30
failure, 196
run-time, 30
fc, 21,23, 24, 156
fcr,38, 44, 46, 48, 49, 69, 71, 81, 84, 86,
89, 92, 95, 99, 160, 167, 182, 245
325
Index
fcr+gf,180, 182
fcr+gf+gabs, 200
fcr+gf+gabs +dc,221, 222
fcr+tif,44, 45, 48, 69, 92, 95
correctness of, 51
fcr+tif+mpar, 145
fcr+tif+par, 69, 70, 75, 81, 84, 92, 95,
145
correctness of, 95
fcr+tif+par+lr,130
fcrt,229
fcrt, 258, 285
fcrt+gf+gabs +dc,229
fcrt+gftx, 285
fcrt+gftx, 250
fcrtm , 285
fcrtm ,286
fcrtm +gftx, 285, 287
fdv, 19,72
fev, 19
ﬁeld, 22, 160, 179, 230
ﬁle system, 218
ﬁnite datatype, 195
ﬁnite map, 236, 244
ﬁrst,247
ﬁrst class, 186, 189
Fix,129, 179, 198
ﬁxpoint, 28, 129, 179, 198, 246, 271, 278
ﬂatten ,198
FMap, 236, 249
focus, 246
fold, 198
foldr, 200, 280
Forall∗,174, 271
free type variable, 24
free variable, 19, 24
freecollect ,218, 282
Frequency, 245
friendly fellow, 11
from,118, 166, 175, 219fsize,194, 197, 202
dv, 19, 72
function
overloaded, 3
polytypic, 4
function argument
of a component, 66
function space, 22, 29, 109, 110, 169,
175, 219
functional dependency, 189
functor, 129, 194
gapp , 58, 62, 77, 81, 90, 92, 94, 99, 135,
173, 202
GAST, 111
generalization, 90
Generic, 188
generic abstraction, 6, 143, 180, 193,
195, 196, 198, 200, 206, 215,
229, 246, 280
on the type level, 245, 249
generic application, 48, 59, 65, 81, 89,
117, 167, 184, 210, 249, 260
correctness of, 100
on the type level, 251, 254, 261
translation of, 94
generic application algorithm, 58, 78,
81, 90, 202, 238
correctness of revised, 154
extension of, 99
revised, 148, 151, 171
termination of, 79
type-level, 254
generic datatype, 235,237
generic function, 107, 109, 121, 125, 155,
179, 180, 193, 212, 229, 235
variations of, 215
Generic Haskell, 10, 107, 112, 187, 188,
189, 210, 218, 226, 273, 284,
285, 297
generic programming, 4
326
Index
generic slot, 142, 144, 150, 169, 184, 204,
243
generic traversal, 216
generic type variable, 142, 200
genericity, 107
ghc, 5, 6, 8, 156, 175, 176, 188
gid,133, 212, 225
GRose, 213
guarded, 22
Haskell, 1, 5, 25, 40, 58, 107, 108, 112,
113, 122, 136, 156, 174, 175,
176, 187, 190, 198, 209, 211,
212, 229, 231, 235, 273, 280,
284, 285, 286, 296
Haskell Report, 230
head, 22, 179, 202
of a type argument, 61, 77
head ,61
head-normal form, 30, 33
higher-order generic function, 189
hole, 82, 84
ID,246
Id,178,206, 271
identity, 169
generic, 133
implicit parameters, 58, 124
import
of a module, 287
impredicative, 175
inference
of base type, 212
of dependencies, 211
inﬁnite type
enumeration of, 111
inﬁx constructor, 108, 206
inﬁx operator, 22
Inl,108
Inr,108
instancelocal, 190
of a type class, 64
introduction of dependency, 59, 77
isomorphic, 116, 156, 167, 169, 199, 229,
246, 271, 273, 284
isomorphism, 237
lifted, 167, 179
Join,265
K,206
kind, 4, 5, 22, 25, 53, 127, 237
qualiﬁed, 238, 249
kind annotation, 24, 70
kind environment, 84, 87, 92, 130, 143,
148, 202, 252, 254, 260
kind parentheses, 103
kind signature, 237, 251, 252, 254, 290
kind-indexed kind, 258
kind-indexed type, 5, 103, 188, 192, 258
Lab, 277
label descriptor, 278
lambda calculus, 216
polymorphic, 25
laws of exponentials, 237
Let,245, 258
letrec , 22,37
letsim ,220, 223
lifted isomorphism, 167, 179
lifted representation type, 206
List, 157
list-like encoding, 272, 281
list-like view, 282, 284
Loc, 246
local datatype, 190
local instance, 190
local redeﬁnition, 11, 122, 124, 125, 128,
130, 134, 137, 169, 171, 176,
180, 184, 190, 194, 214, 215, 260
on the type level, 244, 249, 261, 268,
280
327
Index
local redeﬁnition environment, 258
lookup ,238, 243, 245, 261, 266
LProd, 206
LSum, 206
main expression, 286, 292
main module, 286
map,135, 136, 140, 146, 169, 175, 176,
198, 200, 205, 211, 212, 218,
219, 225
marking
of signature entries, 221
Maybe, 238
metavariable, 18, 20, 59, 75, 251
module, 285, 292
module header, 286
translation of, 293
monomorphism restriction, 209
Motion, 272
mpc-style, 103
name capture, 20, 24, 72
named instance, 191
named type, 54, 65, 90, 107, 117, 169,
186, 217, 241, 252, 258
named types, 22
names
of types, 190
Nat, 129
NatF, 129
navigation function, 247
nested datatype, 4, 109, 186
nested dependency constraint, 60, 70,
82
nested type application, 265
nested type-indexed datatype, 241
newtype , 229, 236, 240, 242, 245, 249,
294
nominal types, 3
non-generic slot, 142, 150, 172, 178, 184non-generic type variable, 138, 141, 142,
204
nonterminals, 18
open , 297
open type-indexed function, 8, 286, 296
operational semantics, 38
optimization
of generated code, 187
or,197
order
for kind dependency constraints,
252
overlapping instances, 296
overriding, 216, 217
package database, 218
Pair, 141
pair, 108
parametrically polymorphic, 2,138, 193
parametrized type, 159, 167, 168, 179
parametrized type pattern, 55, 180
parsing, 113, 272
pattern functor, 4, 5, 129, 199, 246, 278
pattern matching, 26
on types, 44, 235
polymorphic, 126, 139, 173, 176, 194,
204, 225
parametrically, 2,138, 193
polymorphic lambda calculus, 25
polymorphic recursion, 209
polymorphism, 212
PolyP, 4, 192, 200, 278
polytypic function, 4, 278
popl-style, 103, 205
Position, 113
post-optimizer, 187
presignature, 221
presignature ,221
pretty-printing, 272
principal type, 210,212
328
Index
Prod, 108, 271
program
well-formed, 181
qualiﬁed kind, 238, 244, 249, 251
well-formed, 252
qualiﬁed type, 70, 73, 74, 81, 89, 92, 133,
150, 178
coercion of, 84
quantiﬁcation, 239
quantiﬁed variable
of higher kind, 176
QuickCheck, 111
Range, 113, 219
rank- ntypes, 25, 175, 209
record, 277
recursive, 240
recursive call, 4, 6, 62, 77, 80, 94, 104,
105, 116, 153, 196, 205, 237, 239
recursive datatype, 240
recursive let, 37
redeﬁnition
of behaviour, 216
reduce ,196, 200, 207
reduction, 30
reﬂexive, 57, 176, 179
reﬂexivity condition, 178, 184
regular datatype, 4, 278
Rose, 158, 213
rose tree, 158, 213
/angbracketleftr|s/angbracketright-ary, 142
Salary ,226
satisfying a dependency, 59
scope, 24, 70, 94, 130, 180, 252, 296
search key, 236, 238
sel,38
separate compilation, 285
Set,140
shape, 125short notation, 126, 135, 195, 197, 204
on the type level, 245, 280
show , 174, 270, 273, 274
showP , 232, 274
Signature ,290
signature, 46,55, 84, 107, 109, 115, 117,
155, 189, 221, 288, 292
of a type-indexed datatype, 237
signature ,221, 288
signature environment, 47, 49, 84, 87,
90, 92, 94, 180, 182, 185, 202,
221, 258
size, 79
size,53, 61, 64, 65, 81, 124, 194, 195, 196,
197, 210
sml, 2, 112
specialization, 47, 55, 55, 62, 65, 155,
167, 170, 173, 179, 180, 185,
187, 232, 270, 283
explicit, 240
non-terminating, 193
specialization error, 43, 110, 186, 196,
240
specialization module, 295
specialization request, 240, 242, 243,
251, 265, 270, 286, 288, 291,
293, 293
translation of, 265
staged specialization, 270
standard view, 162, 235, 237, 271, 281,
284
static types, 2, 3
String, 232
structural representation, 115,155, 157,
160, 179, 184, 232, 243, 262,
270, 271, 272, 275, 277, 279,
284, 290
modiﬁed generation of, 179
structural representation environment,
180
329
Index
structure
of a type, 4, 107
substitution, 19, 24, 142
subsumption, 28, 84, 90
correctness of, 87, 96
for qualiﬁed kinds, 252
subtyping, 212
Sum, 108, 271
syntactic sugar, 17, 44, 128, 260
termcollect ,217, 225, 282
terminals, 18
to,118, 166, 175, 219
toplevel, 287, 288, 290
transitivity of dependency relation, 66,
75, 148
transitivity of type-level dependency
relation, 254
Tree, 54, 168, 244
tree
search, 236
TreeF, 246
trie,236, 238, 249
tuple, 38
Type, 179, 271
type
abstract, 109, 173, 239
kind-indexed, 5, 103
type , 229, 236, 240, 249
type annotation, 209
type application, 55, 65, 117, 245
nested, 265
type argument, 4, 5, 55, 65, 72, 94, 95,
107, 117, 121, 125, 127, 135,
137, 149, 169, 195, 196, 210,
235, 238, 240, 243, 258
of higher kind, 109, 149, 194, 200,
205, 213
type argument tuple, 142, 145, 150, 267
type arguments
multiple, 194, 207type class, 3, 43, 58, 64, 189, 209, 211,
296
type constructor, 25, 62, 80, 90, 173, 176,
196, 222
of higher kind, 103, 130
type declaration
translation of, 262
type environment, 49, 75, 84, 87, 90, 92,
288
type equality, 187
type inference, 24, 125, 209
for type classes, 191
of base type, 212
of dependencies, 211
of type argument, 44, 191, 210, 233
type parentheses, 42, 60, 72, 195
type pattern, 49, 54, 59, 72, 90, 177, 217,
231, 236, 282, 296
nested, 55, 296
parametrized, 55, 95, 180
well-formed, 262
type safety, 24
type signature, 57, 61, 84, 209, 239, 280,
288
of a generic abstraction, 195, 200
of a type-indexed function, 49, 58,
74, 75, 135, 138, 140, 141, 145,
153, 184, 211, 214
well-formed, 75, 90, 147, 201
type synonym, 160, 174, 229, 236, 245,
266, 287, 294
recursive, 116
type synonym environment, 290
type tuple, 142, 184, 202, 238, 249
bounded, 144
type tuple pattern, 142, 200
type variable, 24, 72, 124, 135, 144, 160,
172, 190, 195, 258
free, 19, 24
non-generic, 138
330
Index
universally quantiﬁed, 243, 258
type-indexed datatype, 6, 235, 238, 246,
254, 258, 279, 285, 288, 290, 293
implementation of, 249
nested, 241
structure of, 270
type-indexed function, 41, 44, 49, 53, 59,
74, 81, 90, 95, 105, 121, 125,
126, 129, 130, 133, 148, 174,
178, 180, 184, 186, 187, 193,
209, 210, 216, 221, 231, 235,
238, 249, 251, 258, 285, 292
well-formed, 75
type-level case, 44
Typecase ,249
typecase ,45, 193, 217, 295
unfold , 198
Unit, 108, 271, 281
universal quantiﬁcation, 25, 70, 86, 150,
172, 174, 258, 260, 271
universal quantiﬁer, 174
universal representation, 113
unparsing, 113
update ,226
values, 30
varcollect , 216, 216, 225
variable, 71
free, 24
view, 272, 284
language for, 284
weak head-normal form, 30, 33
well-formed type-indexed function, 75
whnf ,33
xml, 113, 218
Zero, 156, 159, 273, 281
zip,195
zipper, 236, 246
zipWith ,136, 195
331
Index
332
Curriculum vitae
Andres L ¨oh
18 August 1976 born in L ¨ubeck, Germany
1986 – 1995 grammar school, Katharineum zu L ¨ubeck, Germany
10 June 1995 school-leaving exam
1995 – 2000 studies of Mathematics
with Computer Science as subsidiary subject
at the University of Konstanz, Germany
1996 – 2000 scholarship granted by the
German National Scholarship Foundation
17 August 2000 “Diplom”
2000 – 2004 “assistent in opleiding” at Utrecht University, Netherlands
333
334
Titles in the IPA Dissertation Series
J.O. Blanco .The State Operator in Process Algebra .
Faculty of Mathematics and Computing Science,
TUE. 1996-01
A.M. Geerling .Transformational Development of
Data-Parallel Algorithms . Faculty of Mathematics
and Computer Science, KUN. 1996-02
P.M. Achten .Interactive Functional Programs:
Models, Methods, and Implementation . Faculty
of Mathematics and Computer Science, KUN.
1996-03
M.G.A. Verhoeven .Parallel Local Search . Faculty
of Mathematics and Computing Science, TUE.
1996-04
M.H.G.K. Kesseler .The Implementation of Func-
tional Languages on Parallel Machines with Distrib.
Memory . Faculty of Mathematics and Computer
Science, KUN. 1996-05
D. Alstein .Distributed Algorithms for Hard Real-
Time Systems . Faculty of Mathematics and Com-
puting Science, TUE. 1996-06
J.H. Hoepman .Communication, Synchronization,
and Fault-Tolerance . Faculty of Mathematics and
Computer Science, UvA. 1996-07
H. Doornbos .Reductivity Arguments and Pro-
gram Construction . Faculty of Mathematics and
Computing Science, TUE. 1996-08
D. Turi .Functorial Operational Semantics and its
Denotational Dual . Faculty of Mathematics and
Computer Science, VUA. 1996-09
A.M.G. Peeters .Single-Rail Handshake Circuits .
Faculty of Mathematics and Computing Science,
TUE. 1996-10
N.W.A. Arends .A Systems Engineering Speciﬁca-
tion Formalism . Faculty of Mechanical Engineer-
ing, TUE. 1996-11
P. Severi de Santiago .Normalisation in Lambda
Calculus and its Relation to Type Inference . Faculty
of Mathematics and Computing Science, TUE.
1996-12
D.R. Dams .Abstract Interpretation and Partition
Reﬁnement for Model Checking . Faculty of Mathe-
matics and Computing Science, TUE. 1996-13M.M. Bonsangue .Topological Dualities in Seman-
tics. Faculty of Mathematics and Computer Sci-
ence, VUA. 1996-14
B.L.E. de Fluiter .Algorithms for Graphs of Small
Treewidth . Faculty of Mathematics and Com-
puter Science, UU. 1997-01
W.T.M. Kars .Process-algebraic Transformations in
Context . Faculty of Computer Science, UT. 1997-
02
P.F. Hoogendijk .A Generic Theory of Data Types .
Faculty of Mathematics and Computing Science,
TUE. 1997-03
T.D.L. Laan .The Evolution of Type Theory in Logic
and Mathematics . Faculty of Mathematics and
Computing Science, TUE. 1997-04
C.J. Bloo .Preservation of Termination for Explicit
Substitution . Faculty of Mathematics and Com-
puting Science, TUE. 1997-05
J.J. Vereijken .Discrete-Time Process Algebra . Fac-
ulty of Mathematics and Computing Science,
TUE. 1997-06
F.A.M. van den Beuken .A Functional Approach
to Syntax and Typing . Faculty of Mathematics and
Informatics, KUN. 1997-07
A.W. Heerink .Ins and Outs in Refusal Testing .
Faculty of Computer Science, UT. 1998-01
G. Naumoski and W. Alberts .A Discrete-Event
Simulator for Systems Engineering . Faculty of Me-
chanical Engineering, TUE. 1998-02
J. Verriet .Scheduling with Communication for
Multiprocessor Computation . Faculty of Mathe-
matics and Computer Science, UU. 1998-03
J.S.H. van Gageldonk .An Asynchronous Low-
Power 80C51 Microcontroller . Faculty of Mathe-
matics and Computing Science, TUE. 1998-04
A.A. Basten .In Terms of Nets: System Design with
Petri Nets and Process Algebra . Faculty of Mathe-
matics and Computing Science, TUE. 1998-05
E. Voermans .Inductive Datatypes with Laws and
Subtyping – A Relational Model . Faculty of Math-
ematics and Computing Science, TUE. 1999-01
H. ter Doest .Towards Probabilistic Uniﬁcation-
based Parsing . Faculty of Computer Science, UT.
1999-02
J.P.L. Segers .Algorithms for the Simulation of Sur-
face Processes . Faculty of Mathematics and Com-
puting Science, TUE. 1999-03
C.H.M. van Kemenade .Recombinative Evolution-
ary Search . Faculty of Mathematics and Natural
Sciences, UL. 1999-04
E.I. Barakova .Learning Reliability: a Study on In-
decisiveness in Sample Selection . Faculty of Math-
ematics and Natural Sciences, RUG. 1999-05
M.P. Bodlaender .Schedulere Optimization in Real-
Time Distributed Databases . Faculty of Mathemat-
ics and Computing Science, TUE. 1999-06
M.A. Reniers .Message Sequence Chart: Syntax
and Semantics . Faculty of Mathematics and Com-
puting Science, TUE. 1999-07
J.P. Warners .Nonlinear approaches to satisﬁability
problems . Faculty of Mathematics and Comput-
ing Science, TUE. 1999-08
J.M.T. Romijn .Analysing Industrial Protocols with
Formal Methods . Faculty of Computer Science,
UT. 1999-09
P.R. D’Argenio .Algebras and Automata for Timed
and Stochastic Systems . Faculty of Computer Sci-
ence, UT. 1999-10
G. F´ abi´ an .A Language and Simulator for Hy-
brid Systems . Faculty of Mechanical Engineering,
TUE. 1999-11
J. Zwanenburg .Object-Oriented Concepts and
Proof Rules . Faculty of Mathematics and Com-
puting Science, TUE. 1999-12
R.S. Venema .Aspects of an Integrated Neural Pre-
diction System . Faculty of Mathematics and Nat-
ural Sciences, RUG. 1999-13
J. Saraiva .A Purely Functional Implementation of
Attribute Grammars . Faculty of Mathematics and
Computer Science, UU. 1999-14R. Schiefer .Viper, A Visualisation Tool for Paral-
lel Progam Construction . Faculty of Mathematics
and Computing Science, TUE. 1999-15
K.M.M. de Leeuw .Cryptology and Statecraft in
the Dutch Republic . Faculty of Mathematics and
Computer Science, UvA. 2000-01
T.E.J. Vos .UNITY in Diversity. A stratiﬁed ap-
proach to the veriﬁcation of distributed algorithms .
Faculty of Mathematics and Computer Science,
UU. 2000-02
W. Mallon .Theories and Tools for the Design of
Delay-Insensitive Communicating Processes . Fac-
ulty of Mathematics and Natural Sciences, RUG.
2000-03
W.O.D. Grifﬁoen .Studies in Computer Aided Ver-
iﬁcation of Protocols . Faculty of Science, KUN.
2000-04
P.H.F.M. Verhoeven .The Design of the MathSpad
Editor . Faculty of Mathematics and Computing
Science, TUE. 2000-05
J. Fey .Design of a Fruit Juice Blending and Pack-
aging Plant . Faculty of Mechanical Engineering,
TUE. 2000-06
M. Franssen .Cocktail: A Tool for Deriving Correct
Programs . Faculty of Mathematics and Comput-
ing Science, TUE. 2000-07
P.A. Olivier .A Framework for Debugging Hetero-
geneous Applications . Faculty of Natural Sciences,
Mathematics and Computer Science, UvA. 2000-
08
E. Saaman .Another Formal Speciﬁcation Language .
Faculty of Mathematics and Natural Sciences,
RUG. 2000-10
M. Jelasity .The Shape of Evolutionary Search Dis-
covering and Representing Search Space Structure .
Faculty of Mathematics and Natural Sciences,
UL. 2001-01
R. Ahn .Agents, Objects and Events a computa-
tional approach to knowledge, observation and com-
munication . Faculty of Mathematics and Com-
puting Science, TU/e. 2001-02
M. Huisman .Reasoning about Java programs in
higher order logic using PVS and Isabelle . Faculty
of Science, KUN. 2001-03
I.M.M.J. Reymen .Improving Design Processes
through Structured Reﬂection . Faculty of Mathe-
matics and Computing Science, TU/e. 2001-04
S.C.C. Blom .Term Graph Rewriting: syntax and
semantics . Faculty of Sciences, Division of Math-
ematics and Computer Science, VUA. 2001-05
R. van Liere .Studies in Interactive Visualization .
Faculty of Natural Sciences, Mathematics and
Computer Science, UvA. 2001-06
A.G. Engels .Languages for Analysis and Testing
of Event Sequences . Faculty of Mathematics and
Computing Science, TU/e. 2001-07
J. Hage .Structural Aspects of Switching Classes .
Faculty of Mathematics and Natural Sciences,
UL. 2001-08
M.H. Lamers .Neural Networks for Analysis of
Data in Environmental Epidemiology: A Case-study
into Acute Effects of Air Pollution Episodes . Faculty
of Mathematics and Natural Sciences, UL. 2001-
09
T.C. Ruys .Towards Effective Model Checking . Fac-
ulty of Computer Science, UT. 2001-10
D. Chkliaev .Mechanical veriﬁcation of concur-
rency control and recovery protocols . Faculty of
Mathematics and Computing Science, TU/e.
2001-11
M.D. Oostdijk .Generation and presentation of for-
mal mathematical documents . Faculty of Mathe-
matics and Computing Science, TU/e. 2001-12
A.T. Hofkamp .Reactive machine control: A sim-
ulation approach using χ. Faculty of Mechanical
Engineering, TU/e. 2001-13
D. Boˇ snaˇ cki .Enhancing state space reduction tech-
niques for model checking . Faculty of Mathematics
and Computing Science, TU/e. 2001-14
M.C. van Wezel .Neural Networks for Intelligent
Data Analysis: theoretical and experimental aspects .
Faculty of Mathematics and Natural Sciences,
UL. 2002-01
V. Bos and J.J.T. Kleijn .Formal Speciﬁcation and
Analysis of Industrial Systems . Faculty of Math-
ematics and Computer Science and Faculty of
Mechanical Engineering, TU/e. 2002-02T. Kuipers .Techniques for Understanding Legacy
Software Systems . Faculty of Natural Sciences,
Mathematics and Computer Science, UvA. 2002-
03
S.P. Luttik .Choice Quantiﬁcation in Process Alge-
bra. Faculty of Natural Sciences, Mathematics,
and Computer Science, UvA. 2002-04
R.J. Willemen .School Timetable Construction: Al-
gorithms and Complexity . Faculty of Mathematics
and Computer Science, TU/e. 2002-05
M.I.A. Stoelinga .Alea Jacta Est: Veriﬁcation
of Probabilistic, Real-time and Parametric Systems .
Faculty of Science, Mathematics and Computer
Science, KUN. 2002-06
N. van Vugt .Models of Molecular Computing . Fac-
ulty of Mathematics and Natural Sciences, UL.
2002-07
A. Fehnker .Citius, Vilius, Melius: Guiding and
Cost-Optimality in Model Checking of Timed and
Hybrid Systems . Faculty of Science, Mathemat-
ics and Computer Science, KUN. 2002-08
R. van Stee .On-line Scheduling and Bin Packing .
Faculty of Mathematics and Natural Sciences,
UL. 2002-09
D. Tauritz .Adaptive Information Filtering: Con-
cepts and Algorithms . Faculty of Mathematics and
Natural Sciences, UL. 2002-10
M.B. van der Zwaag .Models and Logics for Pro-
cess Algebra . Faculty of Natural Sciences, Mathe-
matics, and Computer Science, UvA. 2002-11
J.I. den Hartog .Probabilistic Extensions of Se-
mantical Models . Faculty of Sciences, Division of
Mathematics and Computer Science, VUA. 2002-
12
L. Moonen .Exploring Software Systems . Faculty
of Natural Sciences, Mathematics, and Com-
puter Science, UvA. 2002-13
J.I. van Hemert .Applying Evolutionary Compu-
tation to Constraint Satisfaction and Data Mining .
Faculty of Mathematics and Natural Sciences,
UL. 2002-14
S. Andova .Probabilistic Process Algebra . Faculty
of Mathematics and Computer Science, TU/e.
2002-15
Y.S. Usenko .Linearization in µCRL. Faculty
of Mathematics and Computer Science, TU/e.
2002-16
J.J.D. Aerts .Random Redundant Storage for Video
on Demand . Faculty of Mathematics and Com-
puter Science, TU/e. 2003-01
M. de Jonge .To Reuse or To Be Reused: Tech-
niques for component composition and construction .
Faculty of Natural Sciences, Mathematics, and
Computer Science, UvA. 2003-02
J.M.W. Visser .Generic Traversal over Typed
Source Code Representations . Faculty of Natural
Sciences, Mathematics, and Computer Science,
UvA. 2003-03
S.M. Bohte .Spiking Neural Networks . Faculty of
Mathematics and Natural Sciences, UL. 2003-04
T.A.C. Willemse .Semantics and Veriﬁcation in
Process Algebras with Data and Timing . Faculty
of Mathematics and Computer Science, TU/e.
2003-05
S.V. Nedea .Analysis and Simulations of Catalytic
Reactions . Faculty of Mathematics and Computer
Science, TU/e. 2003-06
M.E.M. Lijding .Real-time Scheduling of Tertiary
Storage . Faculty of Electrical Engineering, Math-
ematics & Computer Science, UT. 2003-07
H.P. Benz .Casual Multimedia Process Annotation
– CoMPAs . Faculty of Electrical Engineering,
Mathematics & Computer Science, UT. 2003-08
D. Distefano .On Modelchecking the Dynamics
of Object-based Software: a Foundational Approach .
Faculty of Electrical Engineering, Mathematics
& Computer Science, UT. 2003-09
M.H. ter Beek .Team Automata – A Formal Ap-
proach to the Modeling of Collaboration Between Sys-
tem Components . Faculty of Mathematics and
Natural Sciences, UL. 2003-10
D.J.P. Leijen .TheλAbroad – A Functional Ap-
proach to Software Components . Faculty of Mathe-
matics and Computer Science, UU. 2003-11W.P.A.J. Michiels .Performance Ratios for the Dif-
ferencing Method . Faculty of Mathematics and
Computer Science, TU/e. 2004-01
G.I. Jojgov .Incomplete Proofs and Terms and
Their Use in Interactive Theorem Proving . Faculty
of Mathematics and Computer Science, TU/e.
2004-02
P. Frisco .Theory of Molecular Computing – Splic-
ing and Membrane systems . Faculty of Mathemat-
ics and Natural Sciences, UL. 2004-03
S. Maneth .Models of Tree Translation . Faculty of
Mathematics and Natural Sciences, UL. 2004-04
Y. Qian .Data Synchronization and Browsing for
Home Environments . Faculty of Mathematics and
Computer Science and Faculty of Industrial De-
sign, TU/e. 2004-05
F. Bartels .On Generalised Coinduction and Proba-
bilistic Speciﬁcation Formats . Faculty of Sciences,
Division of Mathematics and Computer Science,
VUA. 2004-06
L. Cruz-Filipe .Constructive Real Analysis: a Type-
Theoretical Formalization and Applications . Faculty
of Science, Mathematics and Computer Science,
KUN. 2004-07
E.H. Gerding .Autonomous Agents in Bargaining
Games: An Evolutionary Investigation of Fundamen-
tals, Strategies, and Business Applications . Faculty
of Technology Management, TU/e. 2004-08
N. Goga .Control and Selection Techniques for the
Automated Testing of Reactive Systems . Faculty
of Mathematics and Computer Science, TU/e.
2004-09
M. Niqui .Formalising Exact Arithmetic: Represen-
tations, Algorithms and Proofs . Faculty of Science,
Mathematics and Computer Science, RU. 2004-
10
A. L¨ oh .Exploring Generic Haskell . Faculty of
Mathematics and Computer Science, UU. 2004-
11

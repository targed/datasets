COMP150: Practical Programming (in Python)
Jeffrey Elkner Allen B. Downey Chris Meyers Brendan McCane
Iain Hewson Nick Meek
February 10, 2014
ii
Contents
License xi
Foreword xiii
Preface xv
Contributor List xix
Course Information xxiii
1 The way of the program 1
1.1 The Python programming language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 What is a program? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3 What is debugging? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.4 Experimental debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.5 Formal and natural languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.6 The ﬁrst program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.7 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.8 The COMP150 lab . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.8.1 Logging-on . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.8.2 The OSX desktop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.8.3 Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.8.4 The dock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.8.5 The Finder window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.8.6 Your home directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.8.7 Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.8.8 IDLE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.8.9 Getting help . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.8.10 Coursework ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.8.11 Terms requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.9 Blackboard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
iii
1.10 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2 Variables, expressions and statements 17
2.1 Values and types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.2 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3 Variable names and keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.4 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.5 Evaluating expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.6 Operators and operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.7 The modulus operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.8 Order of operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.9 Operations on strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.11 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3 Functions: part 1 27
3.1 Composing expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
3.2 Function calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
3.3 Function deﬁnitions and use . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.4 Flow of execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.5 Parameters and arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.6 Function composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.7 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.9 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
4 Functions: part 2 37
4.1 Variables and parameters are local . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
4.2 Stack diagrams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.3 Input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.4 Type conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.5 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.6 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
5 Conditionals 45
5.1 Conditional execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.2 Boolean values and expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.3 Logical operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.4 Alternative execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.5 Chained conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
iv
5.6 Nested conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
5.7 Booleans and type conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
5.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
5.9 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
6 Fruitful functions 55
6.1 The return statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
6.2 Return values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
6.3 Program development . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
6.4 Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
6.5 Boolean functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
6.6 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
6.7 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
7 Modules and TDD 63
7.1 Modules, ﬁles and the import statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
7.2 Triple quoted strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
7.3 Unit testing with doctest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
7.4 Good Practice Development . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
7.5 Test-driven development demonstrated . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
7.6 Programming with style . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
7.7 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
7.8 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
8 Strings part 1 73
8.1 A compound data type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
8.2 Length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
8.3 String slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
8.4 String comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
8.5 Strings are immutable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
8.6 Traversal and the for loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
8.7 Theinoperator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
8.8 Looping and counting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
8.9str Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
8.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
8.11 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
9 Files and modules 85
9.1 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
9.2 Processing things from a ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
v
9.3 Directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
9.4 Files as a Unifying Concept . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
9.5 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
9.6 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
10 Iteration: part 1 93
10.1 Multiple assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
10.2 Updating variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
10.3 Abbreviated assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
10.4 Thewhile statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
10.5 Tracing a program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
10.6 Counting digits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
10.7 Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
10.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
10.9 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
11 Iteration: part 2 101
11.1 Two-dimensional tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
11.2 Encapsulation and generalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
11.3 More encapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
11.4 Local variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
11.5 More generalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
11.6 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
11.7 Newton’s method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
11.8 Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
11.9 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
11.10Laboratory Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
12 Strings part 2 109
12.1 String formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
12.2 Character classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
12.3 A ﬁnd function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
12.4 Optional parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
12.5 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
12.6 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
13 Lists part 1 117
13.1 List values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
13.2 Accessing elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
13.3 List length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
vi
13.4 The range function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
13.5 Lists and for loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
13.6 List membership . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
13.7 List operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
13.8 List slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
13.9 Lists are mutable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
13.10List deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
13.11Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
13.12Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
14 Lists part 2 127
14.1 Objects and values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
14.2 Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
14.3 Cloning lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
14.4 List parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
14.5 Pure functions and modiﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
14.6 Which is better? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
14.7 Nested lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
14.8 Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
14.9 Strings and lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
14.10Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
14.11Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
15 T uples, Sets and Dictionaries 137
15.1 Tuples and mutability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
15.2 Tuple assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
15.3 Tuples as return values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
15.4 Why tuples? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
15.5 When should you use tuples? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
15.6 Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
15.7 Dictionaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
15.8 Dictionary operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
15.9 Dictionary methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
15.10Aliasing and copying . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
15.11Counting letters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
15.12Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
15.13Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
16 No Lecture Today 147
vii
16.1 No Lab This Session . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
17 Classes and objects - Part 1 149
17.1 Object-oriented programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
17.2 User-deﬁned compound types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
17.3 The init Method and self . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
17.4 Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
17.5 Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
17.6 Sameness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
17.7 Interface and Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
17.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
17.9 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
18 Classes and objects - Part 2 159
18.1 Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
18.2 Instances as return values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
18.3 Objects are mutable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
18.4 Copying . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
18.5 A Polygon Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
18.6 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
18.7 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
19 Graphical user interface programming 165
19.1 Event driven programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
19.2 TkInter introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
19.3 Introducing callbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
19.4 User input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
19.5 Mini-case study . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
19.6 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
19.7 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
20 Case study: Catch 175
20.1 Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
20.2 Moving the ball . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
20.3 Adding randomness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
20.4 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
20.5 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
21 Case study: Catch continued 183
21.1 Keyboard input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
viii
21.2 Checking for collisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
21.3 Keeping score . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
21.4 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
21.5 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
21.6 Optional extension project: pong.py . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
22 System programming 193
22.1 The sys module and argv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
22.2 Theosandglob module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
22.3 A mini-case study . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
22.3.1 ImageMagick . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
22.3.2 Scripting ImageMagick . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
22.4 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
22.5 Laboratory exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
23 Case study 2 Part 1 203
23.1 Program Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
23.2 The Initial Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
23.3 Opening a File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
23.4 Saving to a File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
23.5 Adding a Command Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
23.6 Laboratory Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
24 Case study 2 Part 2 209
24.1 Encrypting the Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
24.2 Putting it All Together . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
24.3 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
24.4 Laboratory Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
25 The last lecture 217
25.1 Stuff we haven’t covered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
25.2 What you can expect from COMP160 and Computer Science . . . . . . . . . . . . . . . . . . . 217
GNU Free Documentation License 219
1. APPLICABILITY AND DEFINITIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
2. VERBATIM COPYING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
3. COPYING IN QUANTITY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
4. MODIFICATIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
5. COMBINING DOCUMENTS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
6. COLLECTIONS OF DOCUMENTS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
ix
7. AGGREGATION WITH INDEPENDENT WORKS . . . . . . . . . . . . . . . . . . . . . . . . . . 223
8. TRANSLATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
9. TERMINATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
10. FUTURE REVISIONS OF THIS LICENSE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
ADDENDUM: How to use this License for your documents . . . . . . . . . . . . . . . . . . . . . . 224
x
License
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free
Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with
the Invariant Sections being “Foreword”, “Preface”, “Contributor List”, and “Notes on the Otago Edition”,
with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license is included in the section
entitled ”GNU Free Documentation License”.
xi
xii
Foreword
By David Beazley
As an educator, researcher, and book author, I am delighted to see the completion of this book. Python is a
fun and extremely easy-to-use programming language that has steadily gained in popularity over the last
few years. Developed over ten years ago by Guido van Rossum, Python’s simple syntax and overall feel
is largely derived from ABC, a teaching language that was developed in the 1980’s. However, Python was
also created to solve real problems and it borrows a wide variety of features from programming languages
such as C++, Java, Modula-3, and Scheme. Because of this, one of Python’s most remarkable features is its
broad appeal to professional software developers, scientists, researchers, artists, and educators.
Despite Python’s appeal to many different communities, you may still wonder why Python? or why teach
programming with Python? Answering these questions is no simple task—especially when popular opin-
ion is on the side of more masochistic alternatives such as C++ and Java. However, I think the most direct
answer is that programming in Python is simply a lot of fun and more productive.
When I teach computer science courses, I want to cover important concepts in addition to making the
material interesting and engaging to students. Unfortunately, there is a tendency for introductory pro-
gramming courses to focus far too much attention on mathematical abstraction and for students to become
frustrated with annoying problems related to low-level details of syntax, compilation, and the enforcement
of seemingly arcane rules. Although such abstraction and formalism is important to professional software
engineers and students who plan to continue their study of computer science, taking such an approach
in an introductory course mostly succeeds in making computer science boring. When I teach a course, I
don’t want to have a room of uninspired students. I would much rather see them trying to solve interesting
problems by exploring different ideas, taking unconventional approaches, breaking the rules, and learning
from their mistakes. In doing so, I don’t want to waste half of the semester trying to sort out obscure syn-
tax problems, unintelligible compiler error messages, or the several hundred ways that a program might
generate a general protection fault.
One of the reasons why I like Python is that it provides a really nice balance between the practical and
the conceptual. Since Python is interpreted, beginners can pick up the language and start doing neat
things almost immediately without getting lost in the problems of compilation and linking. Furthermore,
Python comes with a large library of modules that can be used to do all sorts of tasks ranging from web-
programming to graphics. Having such a practical focus is a great way to engage students and it allows
them to complete signiﬁcant projects. However, Python can also serve as an excellent foundation for intro-
ducing important computer science concepts. Since Python fully supports procedures and classes, students
can be gradually introduced to topics such as procedural abstraction, data structures, and object-oriented
programming—all of which are applicable to later courses on Java or C++. Python even borrows a number
of features from functional programming languages and can be used to introduce concepts that would be
covered in more detail in courses on Scheme and Lisp.
In reading Jeffrey’s preface, I am struck by his comments that Python allowed him to see a higher level of
success and a lower level of frustration and that he was able to move faster with better results. Although
these comments refer to his introductory course, I sometimes use Python for these exact same reasons in
xiii
advanced graduate level computer science courses at the University of Chicago. In these courses, I am
constantly faced with the daunting task of covering a lot of difﬁcult course material in a blistering nine
week quarter. Although it is certainly possible for me to inﬂict a lot of pain and suffering by using a
language like C++, I have often found this approach to be counterproductive—especially when the course
is about a topic unrelated to just programming. I ﬁnd that using Python allows me to better focus on the
actual topic at hand while allowing students to complete substantial class projects.
Although Python is still a young and evolving language, I believe that it has a bright future in education.
This book is an important step in that direction.
David Beazley University of Chicago Author of the Python Essential Reference
xiv
Preface
By Jeffrey Elkner
This book owes its existence to the collaboration made possible by the Internet and the free software move-
ment. Its three authors—a college professor, a high school teacher, and a professional programmer—have
yet to meet face to face, but we have been able to work closely together and have been aided by many
wonderful folks who have donated their time and energy to helping make this book better.
We think this book is a testament to the beneﬁts and future possibilities of this kind of collaboration, the
framework for which has been put in place by Richard Stallman and the Free Software Foundation.
How and why I came to use Python
In 1999, the College Board’s Advanced Placement (AP) Computer Science exam was given in C++ for the
ﬁrst time. As in many high schools throughout the country, the decision to change languages had a direct
impact on the computer science curriculum at Yorktown High School in Arlington, Virginia, where I teach.
Up to this point, Pascal was the language of instruction in both our ﬁrst-year and AP courses. In keeping
with past practice of giving students two years of exposure to the same language, we made the decision
to switch to C++ in the ﬁrst-year course for the 1997-98 school year so that we would be in step with the
College Board’s change for the AP course the following year.
Two years later, I was convinced that C++ was a poor choice to use for introducing students to computer
science. While it is certainly a very powerful programming language, it is also an extremely difﬁcult lan-
guage to learn and teach. I found myself constantly ﬁghting with C++’s difﬁcult syntax and multiple ways
of doing things, and I was losing many students unnecessarily as a result. Convinced there had to be a
better language choice for our ﬁrst-year class, I went looking for an alternative to C++.
I needed a language that would run on the machines in our GNU/Linux lab as well as on the Windows and
Macintosh platforms most students have at home. I wanted it to be free software, so that students could
use it at home regardless of their income. I wanted a language that was used by professional programmers,
and one that had an active developer community around it. It had to support both procedural and object-
oriented programming. And most importantly, it had to be easy to learn and teach. When I investigated
the choices with these goals in mind, Python stood out as the best candidate for the job.
I asked one of Yorktown’s talented students, Matt Ahrens, to give Python a try. In two months he not only
learned the language but wrote an application called pyTicket that enabled our staff to report technology
problems via the Web. I knew that Matt could not have ﬁnished an application of that scale in so short
a time in C++, and this accomplishment, combined with Matt’s positive assessment of Python, suggested
that Python was the solution I was looking for.
xv
Finding a textbook
Having decided to use Python in both of my introductory computer science classes the following year, the
most pressing problem was the lack of an available textbook.
Free documents came to the rescue. Earlier in the year, Richard Stallman had introduced me to Allen
Downey. Both of us had written to Richard expressing an interest in developing free educational materials.
Allen had already written a ﬁrst-year computer science textbook, How to Think Like a Computer Scientist .
When I read this book, I knew immediately that I wanted to use it in my class. It was the clearest and most
helpful computer science text I had seen. It emphasized the processes of thought involved in programming
rather than the features of a particular language. Reading it immediately made me a better teacher.
How to Think Like a Computer Scientist was not just an excellent book, but it had been released under a GNU
public license, which meant it could be used freely and modiﬁed to meet the needs of its user. Once I
decided to use Python, it occurred to me that I could translate Allen’s original Java version of the book
into the new language. While I would not have been able to write a textbook on my own, having Allen’s
book to work from made it possible for me to do so, at the same time demonstrating that the cooperative
development model used so well in software could also work for educational materials.
Working on this book for the last two years has been rewarding for both my students and me, and my
students played a big part in the process. Since I could make instant changes whenever someone found
a spelling error or difﬁcult passage, I encouraged them to look for mistakes in the book by giving them a
bonus point each time they made a suggestion that resulted in a change in the text. This had the double
beneﬁt of encouraging them to read the text more carefully and of getting the text thoroughly reviewed by
its most important critics, students using it to learn computer science.
For the second half of the book on object-oriented programming, I knew that someone with more real
programming experience than I had would be needed to do it right. The book sat in an unﬁnished state
for the better part of a year until the open source community once again provided the needed means for its
completion.
I received an email from Chris Meyers expressing interest in the book. Chris is a professional program-
mer who started teaching a programming course last year using Python at Lane Community College in
Eugene, Oregon. The prospect of teaching the course had led Chris to the book, and he started helping out
with it immediately. By the end of the school year he had created a companion project on our Website at
http://openbookproject.net called Python for Fun and was working with some of my most advanced
students as a master teacher, guiding them beyond where I could take them.
Introducing programming with Python
The process of translating and using How to Think Like a Computer Scientist for the past two years has con-
ﬁrmed Python’s suitability for teaching beginning students. Python greatly simpliﬁes programming exam-
ples and makes important programming ideas easier to teach.
The ﬁrst example from the text illustrates this point. It is the traditional “hello, world program”, which in
the C++ version of the book looks like this:
#include <iostream.h>
void main()
{
cout << "Hello, world." << endl;
}
xvi
in the Python version it becomes:
print "Hello, World!"
Even though this is a trivial example, the advantages of Python stand out. Yorktown’s Computer Science I
course has no prerequisites, so many of the students seeing this example are looking at their ﬁrst program.
Some of them are undoubtedly a little nervous, having heard that computer programming is difﬁcult to
learn. The C++ version has always forced me to choose between two unsatisfying options: either to explain
the#include ,void main() ,{, and}statements and risk confusing or intimidating some of the students
right at the start, or to tell them, “Just don’t worry about all of that stuff now; we will talk about it later,”
and risk the same thing. The educational objectives at this point in the course are to introduce students to
the idea of a programming statement and to get them to write their ﬁrst program, thereby introducing them
to the programming environment. The Python program has exactly what is needed to do these things, and
nothing more.
Comparing the explanatory text of the program in each version of the book further illustrates what this
means to the beginning student. There are thirteen paragraphs of explanation of “Hello, world!” in the
C++ version; in the Python version, there are only two. More importantly, the missing eleven paragraphs
do not deal with the “big ideas” in computer programming but with the minutia of C++ syntax. I found this
same thing happening throughout the book. Whole paragraphs simply disappear from the Python version
of the text because Python’s much clearer syntax renders them unnecessary.
Using a very high-level language like Python allows a teacher to postpone talking about low-level details
of the machine until students have the background that they need to better make sense of the details. It
thus creates the ability to put “ﬁrst things ﬁrst” pedagogically. One of the best examples of this is the way
in which Python handles variables. In C++ a variable is a name for a place that holds a thing. Variables
have to be declared with types at least in part because the size of the place to which they refer needs to be
predetermined. Thus, the idea of a variable is bound up with the hardware of the machine. The powerful
and fundamental concept of a variable is already difﬁcult enough for beginning students (in both computer
science and algebra). Bytes and addresses do not help the matter. In Python a variable is a name that refers
to a thing. This is a far more intuitive concept for beginning students and is much closer to the meaning of
“variable” that they learned in their math courses. I had much less difﬁculty teaching variables this year
than I did in the past, and I spent less time helping students with problems using them.
Another example of how Python aids in the teaching and learning of programming is in its syntax for
functions. My students have always had a great deal of difﬁculty understanding functions. The main
problem centers around the difference between a function deﬁnition and a function call, and the related
distinction between a parameter and an argument. Python comes to the rescue with syntax that is nothing
short of beautiful. Function deﬁnitions begin with the keyword def, so I simply tell my students, “When
you deﬁne a function, begin with def, followed by the name of the function that you are deﬁning; when you
call a function, simply call (type) out its name.” Parameters go with deﬁnitions; arguments go with calls.
There are no return types, parameter types, or reference and value parameters to get in the way, so I am
now able to teach functions in less than half the time that it previously took me, with better comprehension.
Using Python has improved the effectiveness of our computer science program for all students. I see a
higher general level of success and a lower level of frustration than I experienced during the two years
I taught C++. I move faster with better results. More students leave the course with the ability to cre-
ate meaningful programs and with the positive attitude toward the experience of programming that this
engenders.
xvii
Building a community
I have received email from all over the globe from people using this book to learn or to teach programming.
A user community has begun to emerge, and many people have been contributing to the project by sending
in materials for the companion Website at http://openbookproject.net/pybiblio
With the continued growth of Python, I expect the growth in the user community to continue and acceler-
ate. The emergence of this user community and the possibility it suggests for similar collaboration among
educators have been the most exciting parts of working on this project for me. By working together, we
can increase the quality of materials available for our use and save valuable time. I invite you to join our
community and look forward to hearing from you. Please write to me at jeff@elkner.net .
Jeffrey Elkner
Arlington Public Schools
Arlington, Virginia
xviii
Contributor List
To paraphrase the philosophy of the Free Software Foundation, this book is free like free speech, but not
necessarily free like free pizza. It came about because of a collaboration that would not have been possible
without the GNU Free Documentation License. So we would like to thank the Free Software Foundation
for developing this license and, of course, making it available to us.
We would also like to thank the more than 100 sharp-eyed and thoughtful readers who have sent us sug-
gestions and corrections over the past few years. In the spirit of free software, we decided to express our
gratitude in the form of a contributor list. Unfortunately, this list is not complete, but we are doing our best
to keep it up to date. It was also getting too large to include everyone who sends in a typo or two. You
have our gratitude, and you have the personal satisfaction of making a book you found useful better for
you and everyone else who uses it. New additions to the list for the 2nd edition will be those who have
made on-going contributions.
If you have a chance to look through the list, you should realize that each person here has spared you and
all subsequent readers from the confusion of a technical error or a less-than-transparent explanation, just
by sending us a note.
Impossible as it may seem after so many corrections, there may still be errors in this book. If you should
stumble across one, we hope you will take a minute to contact us. The email address is jeff@elkner.net .
Substantial changes made due to your suggestions will add you to the next version of the contributor list
(unless you ask to be omitted). Thank you!
Second Edition
• A special thanks to the students in Jeff’s Computer Science class at the HB-Woodlawn program dur-
ing the 2007-2008 school year: James Crowley, Joshua Eddy, Eric Larson, Brian McGrail, and Iliana
Vazuka. Your willingness to serve as beta-testers of the new chapters as they were completed, and to
endure frequent changes in response to your feedback have proved invaluable. Thanks to you this is
truly a student tested text.
• Ammar Nabulsi sent in numerous corrections from Chapters 1 and 2.
• Aldric Giacomoni pointed out an error in our deﬁnition of the Fibonacci sequence in Chapter 5.
• Roger Sperberg sent in several spelling corrections and pointed out a twisted piece of logic in Chapter
3.
• Adele Goldberg sat down with Jeff at PyCon 2007 and gave him a list of suggestions and corrections
from throughout the book.
• Ben Bruno sent in corrections for chapters 4, 5, 6, and 7.
xix
• Carl LaCombe pointed out that we incorrectly used the term “commutative” in chapter 6 where “sym-
metric” was the correct term.
• Alessandro Montanile sent in corrections for errors in the code examples and text in chapters 3, 12,
15, 17, 18, 19, and 20.
• Emanuele Rusconi found errors in chapters 4, 8, and 15.
• Michael Vogt reported an indentation error in an example in chapter 6, and sent in a suggestion for
improving the clarity of the shell vs. script section in chapter 1.
First Edition
• Lloyd Hugh Allen sent in a correction to Section 8.4.
• Yvon Boulianne sent in a correction of a semantic error in Chapter 5.
• Fred Bremmer submitted a correction in Section 2.1.
• Jonah Cohen wrote the Perl scripts to convert the LaTeX source for this book into beautiful HTML.
• Michael Conlon sent in a grammar correction in Chapter 2 and an improvement in style in Chapter 1,
and he initiated discussion on the technical aspects of interpreters.
• Benoit Girard sent in a correction to a humorous mistake in Section 5.6.
• Courtney Gleason and Katherine Smith wrote horsebet.py , which was used as a case study in an
earlier version of the book. Their program can now be found on the website.
• Lee Harr submitted more corrections than we have room to list here, and indeed he should be listed
as one of the principal editors of the text.
• James Kaylin is a student using the text. He has submitted numerous corrections.
• David Kershaw ﬁxed the broken catTwice function in Section 3.10.
• Eddie Lam has sent in numerous corrections to Chapters 1, 2, and 3. He also ﬁxed the Makeﬁle so
that it creates an index the ﬁrst time it is run and helped us set up a versioning scheme.
• Man-Yong Lee sent in a correction to the example code in Section 2.4.
• David Mayo pointed out that the word “unconsciously” in Chapter 1 needed to be changed to “sub-
consciously”.
• Chris McAloon sent in several corrections to Sections 3.9 and 3.10.
• Matthew J. Moelter has been a long-time contributor who sent in numerous corrections and sugges-
tions to the book.
• Simon Dicon Montford reported a missing function deﬁnition and several typos in Chapter 3. He also
found errors in the increment function in Chapter 13.
• John Ouzts corrected the deﬁnition of “return value” in Chapter 3.
• Kevin Parks sent in valuable comments and suggestions as to how to improve the distribution of the
book.
• David Pool sent in a typo in the glossary of Chapter 1, as well as kind words of encouragement.
xx
• Michael Schmitt sent in a correction to the chapter on ﬁles and exceptions.
• Robin Shaw pointed out an error in Section 13.1, where the printTime function was used in an example
without being deﬁned.
• Paul Sleigh found an error in Chapter 7 and a bug in Jonah Cohen’s Perl script that generates HTML
from LaTeX.
• Craig T. Snydal is testing the text in a course at Drew University. He has contributed several valuable
suggestions and corrections.
• Ian Thomas and his students are using the text in a programming course. They are the ﬁrst ones to test
the chapters in the latter half of the book, and they have make numerous corrections and suggestions.
• Keith Verheyden sent in a correction in Chapter 3.
• Peter Winstanley let us know about a longstanding error in our Latin in Chapter 3.
• Chris Wrobel made corrections to the code in the chapter on ﬁle I/O and exceptions.
• Moshe Zadka has made invaluable contributions to this project. In addition to writing the ﬁrst draft
of the chapter on Dictionaries, he provided continual guidance in the early stages of the book.
• Christoph Zwerschke sent several corrections and pedagogic suggestions, and explained the differ-
ence between gleich and selbe .
• James Mayer sent us a whole slew of spelling and typographical errors, including two in the contrib-
utor list.
• Hayden McAfee caught a potentially confusing inconsistency between two examples.
• Angel Arnal is part of an international team of translators working on the Spanish version of the text.
He has also found several errors in the English version.
• Tauhidul Hoque and Lex Berezhny created the illustrations in Chapter 1 and improved many of the
other illustrations.
• Dr. Michele Alzetta caught an error in Chapter 8 and sent some interesting pedagogic comments and
suggestions about Fibonacci and Old Maid.
• Andy Mitchell caught a typo in Chapter 1 and a broken example in Chapter 2.
• Kalin Harvey suggested a clariﬁcation in Chapter 7 and caught some typos.
• Christopher P . Smith caught several typos and is helping us prepare to update the book for Python
2.2.
• David Hutchins caught a typo in the Foreword.
• Gregor Lingl is teaching Python at a high school in Vienna, Austria. He is working on a German
translation of the book, and he caught a couple of bad errors in Chapter 5.
• Julie Peters caught a typo in the Preface.
xxi
Notes on the Otago Edition
This course book is a modiﬁed version of the online textbook: “How to think like a computer scientist:
learning with Python, 2nd Edition”, by Jeffrey Elkner, Allen B. Downey, and Chris Meyers. It has been
modiﬁed for the Otago context, and also the combined wisdom of the local course developers (Brendan
McCane, Iain Hewson and Nick Meek) have been distilled into written form. An online copy of this text-
book is available from: https://launchpad.net/practical-programming/ . Special thanks also to
Raymond Scurr, Michael Albert, Matthew Jenkins, Xiangfei Jia, Thomas Harper and Paul McCarthy for
their contributions.
When we started writing this coursebook, the stable release of the Python language was version 2.5. To-
wards the end of 2008, a new release of the language called Python 3000 was released. Python 3000 is
incompatible with older versions of the language. For 2014, we have decided to use version 2.7 since it is
installed by default on Mac OS-X and most Linux distributions. Also some existing third-party software
is not yet compatible with Python 3. However, where there are differences in the language, we note them
throughout the text.
This book is all you need for COMP150. There is no expensive textbook to buy. You can have an electronic
copy for free, and either print it yourself at home, or view it on an electronic device of your choice (e.g.
laptop, ipad etc). Alternatively, we are happy to provide a hard copy for the cost of printing and these can
be purchased from the Computer Science ofﬁce.
We hope you enjoy COMP150: Practical Programming.
Brendan McCane
Iain Hewson
Nick Meek
xxii
Course Information
People
• Brendan McCane (Course Coordinator): mccane@cs.otago.ac.nz
• Nick Meek (Lab Coordinator): nickmeek@cs.otago.ac.nz
Assessment and Terms
• Mastery Tests
The ability to program relies heavily on mastering certain skills and techniques. These skills are
cumulative in the sense that mastering skills further on in the material requires that you’ve fully
mastered prior skills. Therefore, the structure of COMP150 is based on a mastery model. There are
7 mastery tests and one ﬁnal practical test. The 7 mastery tests are worth 5% each and are offered in
the lab each week starting at week 2. You need to successfully complete the previous mastery test
before you can sit the next one. If you do not successfully complete a test, then you can resit the test
during your next scheduled laboratory, but you can only sit one test per lab session. Mastery tests
are pass/fail. If you pass, you get 5%, if you fail you get 0% (but you can resit next time). The ﬁnal
practical test is worth 15% and will happen in week 12 and is graded.
• Final Exam
The ﬁnal exam is worth 50%.
• Terms
COMP150 aims to teach you the fundamentals of programming. To learn to program you must prac-
tice. The laboratories are an essential part of COMP150, and hence we require that you attend at least
20 out of the 23 scheduled lab sessions.
To satisfy ’Terms’ requirements (and be allowed to sit the exam) you are required to attend at least 20
of the 23 scheduled lab sessions. During each assigned lab session you should show your work to a
demonstrator and have your attendance recorded.
Lectures and Laboratories
• Lectures
Monday at 9am and
Wednesday at 2pm
xxiii
• Laboratories
You will be streamed into two scheduled laboratories each week. Each lab is two hours long. The
streaming lists will be posted on the noticeboards near the Computer Science Main Ofﬁce in the
Owheo Building (133 Union Street East).
Use of the Labs
The lab has 24 hour, 7 days access.
• Eating is not allowed in the lab. Drinking from sipper-top bottles is ok.
• Cell phones off please.
• Installing your own software on our machines is forbidden.
• Copying software installed on lab machines is forbidden.
• Students streamed to a particular lab session will be given priority for seating and demonstrator time.
• Files not related to your Computer Science course(s) should not be stored in your Computer Science
Home directory. You should be aware that Computer Science Systems Administrators can inspect the
contents of your home directory at any time.
• Students must behave in a sensible, responsible and adult manner whilst in the lab.
• Please ensure that your behaviour, music or conversation is not adversely affecting others trying to
use the lab.
More information regarding Departmental regulations can be found at:
http://www.cs.otago.ac.nz/resreg/index.html
Blackboard
COMP150 will be using Blackboard. You can log-on to Blackboard at:
https://blackboard.otago.ac.nz/webapps/login/
xxiv
Lecture 1
The way of the program
The goal of this paper is twofold: to teach you how to program in Python; and to teach you to think like
acomputer scientist . It is almost impossible to become a competent programmer without also learning
how to think like a computer scientist. This way of thinking combines some of the best features of math-
ematics, engineering, and natural science. Like mathematicians, computer scientists use formal languages
to denote ideas (speciﬁcally computations). Like engineers, they design things, assembling components
into systems and evaluating trade-offs among alternatives. Like scientists, they observe the behaviour of
complex systems, form hypotheses, and test predictions.
If you aren’t interested in becoming a computer scientist, but just want to gain some programming skills,
then this is the perfect paper for you. In this paper we are going to focus on practical programming skills
suitable for solving smallish programming problems. Problems that you will often encounter if you use a
computer regularly.
The single most important skill for a computer scientist is problem solving . Problem solving is the ability
to formulate problems, think creatively about solutions, and express a solution clearly and accurately. As it
turns out, the process of learning to program is an excellent opportunity to practice problem-solving skills.
That’s why this chapter is called, “The way of the program.”
On one level, you will be learning to program, a useful skill by itself. On another level, you will use
programming as a means to an end. As we go along, that end will become clearer.
1.1 The Python programming language
The programming language you will be learning is Python. Python is an example of a high-level language ;
other high-level languages you might have heard of are C++, PHP , and Java.
As you might infer from the name high-level language, there are also low-level languages , sometimes
referred to as machine languages or assembly languages. Loosely speaking, computers can only execute
programs written in low-level languages. Thus, programs written in a high-level language have to be
processed before they can run. This extra processing takes some time, which is a small disadvantage of
high-level languages.
But the advantages are enormous. First, it is much easier to program in a high-level language. Programs
written in a high-level language take less time to write, they are shorter and easier to read, and they are more
likely to be correct. Second, high-level languages are portable , meaning that they can run on different kinds
of computers with few or no modiﬁcations. Low-level programs can run on only one kind of computer and
have to be rewritten to run on another.
1
Due to these advantages, almost all programs are written in high-level languages. Low-level languages are
used only for a few specialized applications.
Two kinds of applications process high-level languages into low-level languages: interpreters and compil-
ers. An interpreter reads a high-level program and executes it, meaning that it does what the program says.
It processes the program a little at a time, alternately reading lines and performing computations.
OUTPUTSOURCE
CODEINTERPRETER
A compiler reads the program and translates it into a low-level program, which can then be run.
In this case, the high-level program is called the source code , and the translated program is called the
object code or the executable . Once a program is compiled, you can execute it repeatedly without further
translation.
OUTPUT
CODEOBJECTEXECUTOR
CODESOURCECOMPILER
Many modern languages use both processes. They are ﬁrst compiled into a lower level language, called
byte code , and then interpreted by a program called a virtual machine . Python uses both processes, but
because of the way programmers interact with it, it is usually considered an interpreted language.
There are two ways to use the Python interpreter: shell mode and script mode . In shell mode, you type Python
statements into the Python shell and the interpreter immediately prints the result.
In this course we will be using an IDE (Integrated Development Environment) called IDLE. When you ﬁrst
start IDLE it will open an interpreter window.1
Python 2.6.4 (r264:75821M, Oct 27 2009, 19:48:32)
[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
Type "copyright", "credits" or "license()" for more information.
****************************************************************
Personal firewall software may warn about the connection IDLE
makes to its subprocess using this computer’s internal loopback
interface. This connection is not visible on any external
interface and no data is sent to or received from the Internet.
****************************************************************
IDLE 2.6.4
>>>
The ﬁrst few lines identify the version of Python being used as well as a few other messages; you can safely
ignore the lines about the ﬁrewall. Next there is a line identifying the version of IDLE. The last line starts
with>>>, which is the Python prompt . The interpreter uses the prompt to indicate that it is ready for
instructions.
If we type print 1 + 1 the interpreter will reply 2and give us another prompt.2
1You can also run the python interpreter by just entering the command python in a terminal. To exit from the interpreter type
exit() and hit return, or press Ctrl-D on a new line.
2Theprint statement is one of the changes between Python 2.x and Python 3.x. In Python 3.x, print is a function and not a
2
>>> print 1 + 1
2
>>>
Alternatively, you can write a program in a ﬁle and use the interpreter to execute the contents of the ﬁle.
Such a ﬁle is called a script . For example, we used the text editor in IDLE (but we could have used any text
editor) to create a ﬁle named firstprogram.py with the following contents:
print1 + 1
By convention, ﬁles that contain Python programs have names that end with .py. To execute the program
we have to invoke the interpreter and tell it the name of the script:
$ python firstprogram.py
2
This example shows Python being run from a terminal (with $ representing the Unix prompt). In other de-
velopment environments, the details of executing programs may differ. IDLE simpliﬁes the whole process
by presenting interpreter windows and a text editor within the same application. You can run a script in
IDLE by either choosing Run!Run Module or pressing F5. Most programs are more interesting than this
one. The examples in this book use both the Python interpreter and scripts. You will be able to tell which is
intended since shell mode examples (i.e. entering lines directly into the interpreter) will always start with
the Python prompt, >>>. Working in shell mode is convenient for testing short bits of code because you get
immediate feedback. Think of it as scratch paper used to help you work out problems. Anything longer
than a few lines should be put into a script so it can be saved for future use.
1.2 What is a program?
Aprogram is a sequence of instructions that speciﬁes how to perform a computation. The computation
might be something mathematical, such as solving a system of equations or ﬁnding the roots of a poly-
nomial, but it can also be a symbolic computation, such as searching and replacing text in a document or
(strangely enough) compiling a program.
The details look different in different languages, but a few basic instructions appear in just about every
language:
input: Get data from the keyboard, a ﬁle, or some other device.
output: Display data on the screen or send data to a ﬁle or other device.
math: Perform basic mathematical operations like addition and multiplication.
conditional execution: Check for certain conditions and execute the appropriate sequence of statements.
repetition: Perform some action repeatedly, usually with some variation.
Believe it or not, that’s pretty much all there is to it. Every program you’ve ever used, no matter how com-
plicated, is made up of instructions that look more or less like these. Thus, we can describe programming
as the process of breaking a large, complex task into smaller and smaller subtasks until the subtasks are
simple enough to be performed with one of these basic instructions.
That may be a little vague, but we will come back to this topic later when we talk about algorithms .
statement with syntax print(1+1) . In Python 2.x, print(1+1) will still work, but it is actually printing a tuple and is not a simple
print statement. Tuples are discussed in Lecture 15.
3
1.3 What is debugging?
Programming is a complex process, and because it is done by human beings, programs often contain errors.
For whimsical reasons, programming errors are called bugs and the process of tracking them down and
correcting them is called debugging .
Three kinds of errors can occur in a program: syntax errors, runtime errors, and semantic errors. It is useful
to distinguish between them in order to track them down more quickly.
Syntax errors Python can only execute a program if the program is syntactically correct; otherwise, the
process fails and returns an error message. Syntax refers to the structure of a program and the rules
about that structure. For example, in English, a sentence must begin with a capital letter and end with
a period. this sentence contains a syntax error . So does this one
For most readers, a few syntax errors are not a signiﬁcant problem, which is why we can read the
poetry of e. e. cummings without spewing error messages. Python is not so forgiving. If there is a
single syntax error anywhere in your program, Python will print an error message and quit, and you
will not be able to run your program. During the ﬁrst few weeks of your programming career, you
will probably spend a lot of time tracking down syntax errors. As you gain experience, though, you
will make fewer syntax errors and ﬁnd them faster.
Runtime errors The second type of error is a runtime error, so called because the error does not appear
until you run the program. These errors are also called exceptions because they usually indicate that
something exceptional (and bad) has happened. Runtime errors are rare in the simple programs you
will see in the ﬁrst few chapters, so it might be a while before you encounter one.
Semantic errors The third type of error is the semantic error . If there is a semantic error in your program,
it will run successfully, in the sense that the computer will not generate any error messages, but it will
not do the right thing. It will do something else. Speciﬁcally, it will do what you told it to do.
The problem is that the program you wrote is not the program you wanted to write. The meaning of
the program (its semantics) is wrong. Identifying semantic errors can be tricky because it requires you
to work backward by looking at the output of the program and trying to ﬁgure out what it is doing.
1.4 Experimental debugging
One of the most important skills you will acquire is debugging. Although it can be frustrating, debugging
is one of the most intellectually rich, challenging, and interesting parts of programming.
In some ways, debugging is like detective work. You are confronted with clues, and you have to infer the
processes and events that led to the results you see.
Debugging is usually a trial and error process. Once you have an idea what is going wrong, you modify
your program and try again. If your hypothesis was correct, then you can predict the result of the modiﬁca-
tion, and you take a step closer to a working program. If your hypothesis was wrong, you have to come up
with a new one. As Sherlock Holmes pointed out, “When you have eliminated the impossible, whatever
remains, however improbable, must be the truth.” (A. Conan Doyle, The Sign of Four )
For some people, programming and debugging are the same thing. That is, programming is the process
of gradually debugging a program until it does what you want. The idea is that you should start with a
program that does something and make small modiﬁcations, debugging them as you go, so that you always
have a working program.
For example, Linux is an operating system that contains thousands of lines of code, but it started out as a
simple program Linus Torvalds used to explore the Intel 80386 chip. According to Larry Greenﬁeld, one
4
of Linus’s earlier projects was a program that would switch between printing AAAA and BBBB. This later
evolved into Linux ( The Linux Users’ Guide Beta Version 1).
Later chapters will make more suggestions about debugging and other programming practices.
1.5 Formal and natural languages
Natural languages are the languages that people speak, such as English, Spanish, and French. They were
not designed by people (although people try to impose some order on them); they evolved naturally.
Formal languages are languages that are designed by people for speciﬁc applications. For example, the
notation that mathematicians use is a formal language that is particularly good at denoting relationships
among numbers and symbols. Chemists use a formal language to represent the chemical structure of
molecules. And most importantly:
Programming languages are formal languages that have been designed to express computations.
Formal languages tend to have strict rules about syntax. For example, 3+3=6 is a syntactically correct
mathematical statement, but 3=+6$ is not. H 2O is a syntactically correct chemical name, but 2Zz is not.
Syntax rules come in two ﬂavors, pertaining to tokens and structure. Tokens are the basic elements of the
language, such as words, numbers, and chemical elements. One of the problems with 3=+6$ is that $ is
not a legal token in mathematics (at least as far as we know). Similarly, 2Zz is not legal because there is no
element with the abbreviation Zz. The second type of syntax rule pertains to the structure of a statement—
that is, the way the tokens are arranged. The statement 3=+6$ is structurally illegal because you can’t place
a plus sign immediately after an equal sign. Similarly, molecular formulas have to have subscripts after the
element name, not before.
When you read a sentence in English or a statement in a formal language, you have to ﬁgure out what the
structure of the sentence is (although in a natural language you do this subconsciously). This process is
called parsing . For example, when you hear the sentence, “The brown dog barked”, you understand that
the brown dog is the subject and barked is the verb. Once you have parsed a sentence, you can ﬁgure out
what it means, or the semantics of the sentence. Assuming that you know what a dog is and what it means
to bark, you will understand the general implication of this sentence.
Although formal and natural languages have many features in common—tokens, structure, syntax, and
semantics—there are many differences:
ambiguity: Natural languages are full of ambiguity, which people deal with by using contextual clues and
other information. Formal languages are designed to be nearly or completely unambiguous, which
means that any statement has exactly one meaning, regardless of context.
redundancy: In order to make up for ambiguity and reduce misunderstandings, natural languages employ
lots of redundancy. As a result, they are often verbose. Formal languages are less redundant and more
concise.
literalness: Natural languages are full of idiom and metaphor. If someone says, “The penny dropped”,
there is probably no penny and nothing dropped. Formal languages mean exactly what they say.
People who grow up speaking a natural language—everyone—often have a hard time adjusting to formal
languages. In some ways, the difference between formal and natural language is like the difference between
poetry and prose, but more so:
Poetry: Words are used for their sounds as well as for their meaning, and the whole poem together creates
an effect or emotional response. Ambiguity is not only common but often deliberate.
5
Prose: The literal meaning of words is more important, and the structure contributes more meaning. Prose
is more amenable to analysis than poetry but still often ambiguous.
Programs: The meaning of a computer program is unambiguous and literal, and can be understood entirely
by analysis of the tokens and structure.
Here are some suggestions for reading programs (and other formal languages). First, remember that formal
languages are much more dense than natural languages, so it takes longer to read them. Also, the structure
is very important, so it is usually not a good idea to read from top to bottom, left to right. Instead, learn to
parse the program in your head, identifying the tokens and interpreting the structure. Finally, the details
matter. Little things like spelling errors and bad punctuation, which you can get away with in natural
languages, can make a big difference in a formal language.
1.6 The ﬁrst program
Traditionally, the ﬁrst program written in a new language is called Hello, World! because all it does is
display the words, Hello, World! In Python, it looks like this:
print"Hello, World!"
This is an example of a print statement , which doesn’t actually print anything on paper. It displays a value
on the screen. In this case, the result is the words
Hello, World!
The quotation marks in the program mark the beginning and end of the value; they don’t appear in the
result.
Some people judge the quality of a programming language by the simplicity of the Hello, World! program.
By this standard, Python does about as well as is possible.
1.7 Glossary
algorithm: A general process for solving a category of problems.
bug: An error in a program.
byte code: An intermediate language between source code and object code. Many modern languages ﬁrst
compile source code into byte code and then interpret the byte code with a program called a virtual
machine .
compile: To translate a program written in a high-level language into a low-level language all at once, in
preparation for later execution.
debugging: The process of ﬁnding and removing any of the three kinds of programming errors.
exception: Another name for a runtime error.
executable: Another name for object code that is ready to be executed.
formal language: Any one of the languages that people have designed for speciﬁc purposes, such as repre-
senting mathematical ideas or computer programs; all programming languages are formal languages.
6
high-level language: A programming language like Python that is designed to be easy for humans to read
and write.
interpret: To execute a program in a high-level language by translating it one line at a time.
low-level language: A programming language that is designed to be easy for a computer to execute; also
called machine language or assembly language.
natural language: Any one of the languages that people speak that evolved naturally.
object code: The output of the compiler after it translates the program.
parse: To examine a program and analyze the syntactic structure.
portability: A property of a program that can run on more than one kind of computer.
print statement: An instruction that causes the Python interpreter to display a value on the screen.
problem solving: The process of analysing a problem, ﬁnding a solution, and expressing the solution.
program: a sequence of instructions that speciﬁes to a computer actions and computations to be performed.
Python shell: An interactive user interface to the Python interpreter. The user of a Python shell types
commands at the prompt ( >>>), and presses the return key to send these commands immediately to
the interpreter for processing.
runtime error: An error that does not occur until the program has started to execute but that prevents the
program from continuing.
script: A program stored in a ﬁle (usually one that will be interpreted).
semantic error: An error in a program that makes it do something other than what the programmer in-
tended.
semantics: The meaning of a program.
source code: A program in a high-level language before being compiled.
syntax: The structure of a program.
syntax error: An error in a program that makes it impossible to parse (and therefore impossible to inter-
pret).
token: One of the basic elements of the syntactic structure of a program, analogous to a word in a natural
language.
1.8 The COMP150 lab
The COMP150 lab is in G14 (Lab C) on the ground ﬂoor of the Owheo Building (133 Union Street East). It
currently houses 28 iMac computers running the latest version of Mac OSX. You will be streamed into two
two-hour labs per week. You are expected to attend at those times and your attendance will be recorded
for Terms requirements. During your streamed times lab demonstrators will be available to assist you. You
should also feel free to attend the lab at other times as well, if there is a spare seat you are most welcome to
it. Check the noticeboard outside the lab for more details. Also check the whiteboard in the lab each time
you attend, we will put notices and hints for completing lab work there.
Computer Science operates its own authentication and Home directory system. This means that your user-
name and password in labs operated by Computer Science are different from your ITS ones. It also means
7
that the contents of your Home directories will be different from your ITS Home directory, after all it is a
different directory on a completely different and separate system. Files saved in the COMP150 lab will not
be available to you in the ITS labs and vice versa. You may however transfer ﬁles between the systems by
using either a USB ﬂash drive or by visiting www.otago.ac.nz/NetStorage .
1.8.1 Logging-on
If this is the ﬁrst time you have used a Computer Science laboratory your username will usually3beyour ﬁrst
initial followed by your last name . For example Billie Blogs has the username bblogs, and Edwin Heisenberg
has the username eheisenberg. Your password will be your id number as shown on your student id card .
Your ﬁrst action should be to change your password . To do this click on your username at top-right of the
computer screen. Choose “Users and Groups Preferences”, then click on the “Change Password ...” button,
and ﬁll out the required entry boxes. Your new password must follow the following convention:
• Include an upper-case letter.
• Include a lower-case letter.
• Include a digit.
• Not be an English word
When you leave the lab remember to log-out. To do this click on the Apple menu (top-left of the Desktop)
and choose “Log-out <your username >”
In the rest of this book, the action of selecting menu items will be denoted Apple!Log Out .
1.8.2 The OSX desktop
If you are used to a Microsoft Windows environment you will ﬁnd the Mac OS X environment sort of the
same, but different. Pointing, selecting, dragging-and-dropping, left- and right-clicking with the mouse are
all much the same. There are still menus and they are in a familiar order; File, Edit, View etc.. There is now
a Dock instead of a Taskbar, but it operates in much the same fashion - all those icons on the Dock are links
to applications and folders. There are however some differences between the Mac way of doing things and
the Microsoft way. The following will help you use the Mac environment.
1.8.3 Menus
An application’s menus are always displayed in the Menu bar at the top of the Desktop. The default set of
menus, as shown, are the Finder’s menus. In addition to the familiar sounding menus, there is an Apple
menu and a Finder menu. The Apple menu is always there and always has the same contents; explore the
contents of the Apple menu, especially the About This Mac, System Preferences and the Dock options.
The next menu is the Finder menu. Finder is actually an application, it is the one which manages your
Desktop. The options on the Finder menu and in fact all the rest of the menus are currently speciﬁc to the
Finder application. When a different application is active the menus in the Menu bar will be speciﬁc to that
application.
3if the name is not unique, a slightly different one will be created — ask Nick to check.
8
Figure 1.1: The Mac OS X Desktop
1.8.4 The dock
The Dock is similar in nature to Windows’ Taskbar.
• The left part of the Dock contains shortcuts (aliases in Mac-talk) to applications.
• You can remove application aliases from the Dock by simply dragging them to the Desktop and re-
leasing them.
• To add an application to the Dock drag its icon from the Application folder to the Dock, see below.
• An application that is running has a small blue/white dot beneath it.
• Any application that is running will appear in the Dock, even if it doesn’t usually have an alias there.
• The right-hand side of the Dock contains the Trash and any windows or documents you have col-
lapsed (minimised) and aliases to folders.
Clicking once on an item in the Dock will do one of a number of things:
• If the item is an application that is not already running it will start the application.
• If the item is an application that is already running it will become the active application. Note that an
application window may not be displayed in which case you will need to select File!New or similar.
• If the application was ‘hidden’ it will be unhidden.
• If the application had been collapsed it will be restored.
9
Figure 1.2: A Finder Window
1.8.5 The Finder window
A Finder window is similar to a Windows Explorer window, it allows you to navigate folders and drives
and see and manipulate their contents.
Open a new Finder window by clicking the Finder icon in the Dock, it is the left-most one, or by clicking
the Desktop (to make Finder the active program) then choosing File!New Finder Window .
The buttons along the top (from the left) allow you to: navigate back and forth (like in a web browser),
modify the view options, burn folders and ﬁles to CD and make new folders. The left column lists place,
drives and locations you can navigate to and explore. The most useful locations for you will be your home
drive and the Applications folder. Your home drive probably won’t show up in the sidebar by default. You
should enable it by Finder!Preferences!Sidebar!username .
1.8.6 Your home directory
Your Home directory is in fact an amount of space on the department’s shared server.4This is where you
should save your lab work. We recommend that you make folders called Lab1 ,Lab2 (or similar) so that
you can keep your work organised. You are going to be creating a lot of ﬁles during this course, keeping
them organised will make working with them much easier.
Click on your Home directory in the Favorites list and create folders for the ﬁrst few labs by making sure
the Finder window is active (click on it once) and then File!New Folder or by clicking the New Folder
button on the Finder window or by using the shortcut.
1.8.7 Applications
On a Mac, most of the GUI (Graphical User Interface) applications are installed in the Applications folder.
4The server is actually a RAID array (Redundant Array of Inexpensive Disks) rather than a single server.
10
Figure 1.3: IDLE starts with an interpreter window open.
• Open a Finder window and click on the Applications folder, it is also in the Favorites group. A list of
all the applications installed on your machine is displayed.
• Scroll down the list until you ﬁnd the Firefox application icon, drag the icon to the Dock to create an
alias to the Firefox application.
• Scroll down further until you ﬁnd the Utilities folder. If you are viewing the directory in list mode,
click the little triangle to expand the list, if in icon mode, double click on the Utilities folder. Scroll
down the list until you ﬁnd Terminal.
• Drag Terminal to the Dock to create an alias for it as well. Terminal starts a shell session.
• Create a shortcut to IDLE as well, it is also in the Applications folder.
Remember, you can remove unwanted items from the Dock by simply dragging them to the Desktop and
releasing them.
1.8.8 IDLE
In COMP150 you will be using a development environment (also called an IDE - Integrated Development
Environment) called IDLE . IDLE is a very simple IDE and is ideal for our purposes. Start IDLE by clicking
on the IDLE shortcut icon in the Dock that you created moments ago. You should see a window that looks
like Figure 1.3 on page 11. By default IDLE starts with an interpreter window open. Click on the window
to give it focus . Notice the menu bar changes and now contains Python menus; this is because IDLE is a
Python application.
To open an editor window for writing scripts either choose File!New Window or use the Command-N
shortcut. Open an editor window now.
1.8.9 Getting help
Demonstrators will be available to help you in the lab. However, before you call a demonstrator stop and
think; is the answer to your question written in this book? Have you tried a number of different approaches?
Do you know exactly what the problem is? Have you looked on the Internet?! Have you asked the person
sitting next to you? One of the skills we want you to develop this semester is that of ﬁnding solutions
11
Figure 1.4: IDLE with both interpreter and editor windows.
yourself. However if you get really stuck please feel free to ask. On your Mac OS Desktop you will see a
“?” icon labeled “DemoCall”, double-clicking on it will start the DemoCall application. Clicking on “Call”
will place you in the queue and a demonstrator will be along shortly. While you wait, continue working on
the problem; if you solve it you can dequeue yourself by clicking “Cancel”.
1.8.10 Coursework ﬁles
For some exercises in this course we will supply you with ﬁles to work with. These ﬁles can be found
incoursework/COMP150/coursefiles150 . There should be a link to coursework on your Desktop,
double click it to open the remote drive. At the start of each lab copy the appropriate folder to your Desktop
or Home drive by simply clicking and dragging the appropriate folder. There is a folder for this lab. Try
dragging the Lab1 folder from coursework/COMP150/coursefiles150 to your Desktop now.
1.8.11 Terms requirements
To establish you were at a lab, which is necessary for Terms requirements, you will need to show your work
to a demonstrator. The demonstrator will submit your work electronically and that submission will be used
to verify your attendance at the lab.
Important Note: Please note that it is not necessary for you to have completed the laboratory to have your
work marked off for Terms purposes. If, towards the end of the lab, it is becoming obvious that you won’t
be able to complete the work, you should nevertheless show it to a demonstrator. If you have made an
honest effort to complete the work, then that is good enough for Terms.
12
1.9 Blackboard
Many papers at Otago make use of Blackboard, an online course management tool that provides staff and
students with communication and ﬁle sharing tools as well as a host of other features. COMP150 will
use Blackboard for making class announcements and for discussion boards. You should check Blackboard
every time you come to the lab. To log-on to Blackboard:
• Start a browser (Safari, Firefox) and navigate to http://blackboard.otago.ac.nz .
• Log-on (using your University username and password).
• Locate the MyPapers group of links and click on the COMP150 link. You will be taken to the An-
nouncements page. This is where all important course-related messages will be posted.
• Read the announcements.
• Examine the options you have on the left.
• Click on the Discussion Board link. We have created two Discussion Boards, one for questions
about Python or any other part of the course, the other for any suggestions or requests you have for
COMP150.
• There is at least one posting on each board, read them and reply as appropriate.
• When you have ﬁnished log out from Blackboard.
1.10 Laboratory exercises
Remember: you should submit all ﬁles you create during a lab at the end of that lab. For the written
answers, create a new ﬁle in IDLE called “Lab1.txt” and type your answers in there.
1. “this is a syntactically incorrect sentence” has two syntax errors. What are they?
2. Write an English sentence with understandable semantics but incorrect syntax. If English is not your
ﬁrst language, feel free to use the language of your choice for this question and the next.
3. “Three of his legs were both the same.” is an example of a sentence with correct syntax but some
semantic errors, that is it is not clear what it means. Think up another sentence that is syntactically ok
but has semantic (meaning) errors.
4. If you haven’t already done so, start IDLE. Type 2 + 3 at the prompt and then hit return. The symbols +
and-stand for plus and minus as they do in mathematics. The asterisk ( *) is the symbol for multiplication,
and**is the symbol for exponentiation (so 5**2means 5 to the power of 2).
Python evaluates any expression you type in, prints the result, and then prints another prompt. Experiment
by entering different expressions and recording what is printed by the Python interpreter.
Expression Answer
1.
2.
3.
4.
5.
6.
7.
13
What happens if you use /(the division operator)? Are the results what you expect? Explain. Make
sure you try divisions that would result in a non-integer result such as 5/2.5
Expression Answer
1.
2.
3.
4.
5. 10/7
6. 10/4
7. 10/5
5. Typeprint "hello" at the prompt. Python executes this statement, which has the effect of printing
the letters h-e-l-l-o. Notice that the quotation marks that you used to enclose the string are not part of
the output.
Now type print ’"hello"’ and describe and explain your result.
6. Start an editor in IDLE ( File!New Window, or Command-N ) and type print "hello" into the editor
window, which is currently called Untitled. Save your script ( File!Save, or Command-S ) by ﬁrst changing to
your home directory in the Save Dialog Box, then creating a New Folder called Lab1 , and ﬁnally changing
the name untitled tohello.py before clicking Save. Once you have done this run it by either pushing F5
or clicking Run!Run Module . Write down and explain what happens in the prompt window below:
7. Typeprint cheese without the quotation marks into the interpreter. The output will look some-
thing like this:
Traceback (most recent call last):
File "<pyshell#7>", line 1, in <module>
cheese
NameError: name ’cheese’ is not defined
This is a run-time error; speciﬁcally, it is a NameError, and even more speciﬁcally, it is an error because
the name cheese is not deﬁned. If you don’t know what that means yet, you will soon.
8. Still in the interpreter, type 1 2 (with a space in between) and then hit return. Python tries to evaluate
the expression, but it can’t because the expression is not syntactically legal. Instead, it prints the error
message:
SyntaxError: invalid syntax
In many cases, Python indicates where the syntax error occurred, but it is not always right, and it
doesn’t give you much information about what is wrong. So, for the most part, the burden is on you
to learn the syntax rules. In this case, Python is complaining because there is no operator between the
numbers.
Write down three more examples of statements that will produce error messages when you enter
them at the Python prompt. Explain why each example is not valid Python syntax.
5This is another thing that has changed with Python 3.x. The / operator returns a ﬂoat (a number with a fractional part) in Python
3.x. Floats will be explained in more detail later in the course
14
9. Whenever an expression is typed at the Python prompt, it is evaluated and the result is printed on the line
below."This is a test..." is an expression, which evaluates to "This is a test..." (just like
the expression 42 evaluates to 42). In a script, however, evaluations of expressions are not sent to the
program output, so it is necessary to explicitly print it.
Type"This is a test..." at the prompt and hit enter. Record what happens.
10. Now open a new ﬁle ( File!New Window, or Command-N ) and type "This is a test..." into the
Untitled document.
Save your ﬁle in the Lab1 folder (you can quickly change to it using the drop down list) as test.py .
What happens when you run this script ( Run!Run Module, or F5 )?
Now change the contents to:
print"This is a test..."
save and run it again. What happened this time?
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
15
16
Lecture 2
Variables, expressions and statements
2.1 Values and types
Avalue is one of the fundamental things—like a letter or a number—that a program manipulates. The
values we have seen so far are 2 (the result when we added 1 + 1), and “Hello, World!”. These values
belong to different types : 2 is an integer , and “Hello, World!” is a string . You (and the interpreter) can
identify strings because they are enclosed in quotation marks.
The print statement also works for integers.
>>> print 4
4
If you are not sure what type a value has, the interpreter can tell you.
>>> type("Hello, World!")
<type ’str’>
>>> type(17)
<type ’int’>
Strings belong to the type strand integers belong to the type int. Less obviously, numbers with a decimal
point belong to a type called ﬂoat , because these numbers are represented in a format called ﬂoating-point .
>>> type(3.2)
<type ’float’>
What about values like “17” and “3.2”? They look like numbers, but they are in quotation marks like strings.
>>> type("17")
<type ’str’>
>>> type("3.2")
<type ’str’>
17
They’re strings. Strings in Python can be enclosed in either single quotes (’) or double quotes (”):
>>> type(’This is a string.’)
<type ’str’>
>>> type("And so is this.")
<type ’str’>
Double quoted strings can contain single quotes inside them, as in "What’s your name?" , and single
quoted strings can have double quotes inside them, as in ’The cat said "Meow!"’ .
When you type a large integer, you might be tempted to use commas between groups of three digits, as in
1,000,000. Resist the temptation as the commas mean something completely different in Python... which
we will look at later in the course.
2.2 Variables
One of the most powerful features of a programming language is the ability to manipulate variables . A
variable is a name that refers to a value. The assignment statement creates new variables and assigns them
values:
>>> message = "What’s your name?"
>>> n = 17
>>> pi = 3.14159
This example makes three assignments. The ﬁrst assigns the string "What’s your name?" to a new
variable named message . The second assigns the integer 17 to n, and the third assigns the ﬂoating-point
number 3.14159 to pi. The assignment operator , =, should not be confused with an equals sign (even
though it uses the same character). Assignment operators link a name , on the left hand side of the operator,
with a value , on the right hand side. This is why you will get an error if you enter:
>>> 17 = n
A common way to represent variables on paper is to write the name with an arrow pointing to the variable’s
value. This kind of ﬁgure is called a state diagram because it shows what state each of the variables is in
(think of it as the variable’s state of mind). This diagram shows the result of the assignment statements:
message
n
pi17
3.14159"What’s your name?"
18
The print statement also works with variables.
>>> print message
What’s your name?
>>> print n
17
>>> print pi
3.14159
In each case the result is the value of the variable. Variables also have types; again, we can ask the interpreter
what they are.
>>> type(message)
<type ’str’>
>>> type(n)
<type ’int’>
>>> type(pi)
<type ’float’>
The type of a variable is the type (or kind) of value it refers to.
2.3 Variable names and keywords
Programmers generally choose names for their variables that are meaningful—they document what the
variable is used for. Variable names can be arbitrarily long. They can contain both letters and num-
bers, but they have to begin with a letter. Although it is legal to use uppercase letters, by convention
we don’t. If you do, remember that case matters. Bruce andbruce are different variables. The underscore
character ( ) can appear in a name. It is often used in names with multiple words, such as myname or
priceofteainchina . If you give a variable an illegal name, you get a syntax error:
>>> 76trombones = "big parade"
SyntaxError: invalid syntax
>>> more$ = 1000000
SyntaxError: invalid syntax
>>> class = "COMP150"
SyntaxError: invalid syntax
76trombones is illegal because it does not begin with a letter. more$ is illegal because it contains an
illegal character, the dollar sign. But what’s wrong with class ? It turns out that class is one of the Python
keywords . Keywords deﬁne the language’s rules and structure, and they cannot be used as variable names.
Python has thirty-one keywords:
and del from not while
as elif global or with
assert else if pass yield
break except import print
class exec in raise
continue finally is return
def for lambda try
You might want to keep this list handy. If the interpreter complains about one of your variable names and
you don’t know why, see if it is on this list.
19
2.4 Statements
Astatement is an instruction that the Python interpreter can execute. We have seen two kinds of statements:
print and assignment. When you type a statement on the command line, Python executes it and displays
the result, if there is one. The result of a print statement is a value. Assignment statements don’t produce
a visible result. A script usually contains a sequence of statements. If there is more than one statement, the
results appear one at a time as the statements execute. For example, the script
print1
x = 2
printx
produces the output
1
2
Again, the assignment statement produces no output.
2.5 Evaluating expressions
Anexpression is a combination of values, variables, and operators. If you type an expression on the com-
mand line, the interpreter evaluates it and displays the result:
>>> 1 + 1
2
The evaluation of an expression produces a value, which is why expressions can appear on the right hand side
of assignment statements. A value all by itself is a simple expression, and so is a variable.
>>> 17
17
>>> x
2
Confusingly, evaluating an expression is not quite the same thing as printing a value.
>>> message = "What’s your name?"
>>> message
"What’s your name?"
>>> print message
What’s your name?
When the Python shell displays the value of an expression, it uses the same format you would use to enter a
value. In the case of strings, that means that it includes the quotation marks. But the print statement prints
the value of the expression, which in this case is the contents of the string. In a script, an expression all by
itself is a legal statement, but it doesn’t do anything. The script
17
3.2
"Hello, World!"
1 + 1
20
produces no output at all. How would you change the script to display the values of these four expressions?
2.6 Operators and operands
Operators are special symbols that represent computations like addition and multiplication. The values the
operator uses are called operands . The following are all legal Python expressions whose meaning is more
or less clear:
20 + 32
hour - 1
hour*60 + minute
minute / 60
5**2
(5 + 9) *(15 - 7)
The symbols +,-,*,/, have the usual mathematical meanings. The symbol, **, is the exponentiation
operator. The statement, 5**2, means 5 to the power of 2, or 5 squared in this case. Python also uses
parentheses for grouping, so we can force operations to be done in a certain order just like we can in
mathematics.
When a variable name appears in the place of an operand, it is replaced with its value before the operation
is performed. Addition, subtraction, multiplication, and exponentiation all do what you expect, but you
might be surprised by division. The following operation has an unexpected result:
>>> minute = 59
>>> minute / 60
0
The value of minute is59, and59divided by 60is0.98333 , not0. The reason for the discrepancy is that
Python is performing integer division1. When both of the operands are integers, the result must also be
an integer, and by convention, integer division always rounds down , even in cases like this where the next
integer is very close. A possible solution to this problem is to calculate a percentage rather than a fraction:
>>> minute *100 / 60
98
Again the result is rounded down, but at least now the answer is approximately correct. Another alternative
is to use ﬂoating-point division. We’ll see in Section 4.4 how to convert integer values and variables to
ﬂoating-point values.
2.7 The modulus operator
The modulus operator works on integers (and integer expressions) and ﬂoats and produces the remainder
when the ﬁrst operand is divided by the second. In Python, the modulus operator is a percent sign ( %). The
syntax is the same as for other operators:
1In Python 3.x, ﬂoating point division is used.
21
>>> quotient = 7 / 3
>>> print quotient
2
>>> remainder = 7 % 3
>>> print remainder
1
So7divided by 3is2with1left over. The modulus operator turns out to be surprisingly useful. For
example, you can check whether one number is divisible by another—if x % y is zero, then xis divisible
byy. Also, you can extract the right-most digit or digits from a number. For example, x % 10 yields the
right-most digit of x(in base 10). Similarly x % 100 yields the last two digits.
2.8 Order of operations
When more than one operator appears in an expression, the order of evaluation depends on the rules of
precedence . Python follows the same precedence rules for its mathematical operators that mathematics
does. The acronym PEMDAS is a useful way to remember the order of operations:
1.Parentheses have the highest precedence and can be used to force an expression to evaluate in the or-
der you want. Since expressions in parentheses are evaluated ﬁrst, 2*(3-1) is4, and(1+1)**(5-2)
is 8. You can also use parentheses to make an expression easier to read, as in (minute*100)/60 ,
even though it doesn’t change the result.
2.Exponentiation has the next highest precedence, so 2**1+1 is3and not4, and3*1**3is3and not
27.
3.Multiplication and Division have the same precedence, which is higher than Addition and Subtraction,
which also have the same precedence. So 2*3-1 yields5rather than 4, and2/3-1 is-1, not1(re-
member that in integer division, 2/3=0 ).
Operators with the same precedence are evaluated from left to right. So in the expression minute*100/60 ,
the multiplication happens ﬁrst, yielding 5900/60 , which in turn yields 98. If the operations had been
evaluated from right to left, the result would have been 59*1, which is 59, which is wrong. Similarly, in
evaluating 17-4-3 ,17-4 is evaluated ﬁrst.
If in doubt, use parentheses.
2.9 Operations on strings
In general, you cannot perform mathematical operations on strings, even if the strings look like numbers.
The following are illegal (assuming that message has type string):
message - 1
"Hello" / 123
message *"Hello"
"15" + 2
Interestingly, the + operator does work with strings, although it does not do exactly what you might expect.
For strings, the + operator represents concatenation , which means joining the two operands by linking them
end-to-end. For example:
22
fruit = "banana"
baked_good = " nut bread"
printfruit + baked_good
The output of this program is banana nut bread . The space before the word nut is part of the string,
and is necessary to produce the space between the concatenated strings. The * operator also works on
strings; it performs repetition. For example, "Fun"*3is"FunFunFun" . One of the operands has to be a
string; the other has to be an integer. On one hand, this interpretation of + and * makes sense by analogy
with addition and multiplication. Just as 4*3is equivalent to 4+4+4 , we expect "Fun"*3to be the same as
"Fun"+"Fun"+"Fun" , and it is. On the other hand, there is a signiﬁcant way in which string concatenation
and repetition are different from integer addition and multiplication. Can you think of a property that
addition and multiplication have that string concatenation and repetition do not?
2.10 Glossary
value: A number or string (or other thing to be named later) that can be stored in a variable or computed
in an expression.
type: A set of values. The type of a value determines how it can be used in expressions. So far, the types
you have seen are integers (type int), ﬂoating-point numbers (type ﬂoat), and strings (type string).
type function: A function which returns the type of the given argument, for example:
>>> type("Hello, world!")
<type 'str'>
>>> type(17)
<type 'int'>
int: A Python data type that holds positive and negative whole numbers.
str: A Python data type that holds a string of characters.
ﬂoat: A Python data type which stores ﬂoating-point numbers. Floating-point numbers are stored internally
in two parts: a base and an exponent . When printed in the standard format, they look like decimal num-
bers. Beware of rounding errors when you use ﬂoats, and remember that they are only approximate
values.
variable: A name that refers to a value.
assignment statement: A statement that assigns a value to a name (variable). To the left of the assignment
operator, =, is a name. To the right of the assignment operator is an expression which is evaluated
by the Python interpreter and then assigned to the name. The difference between the left and right
hand sides of the assignment statement is often confusing to new programmers. In the following
assignment:
n = n + 1
n plays a very different role on each side of the =. On the right it is a value and makes up part of the
expression which will be evaluated by the Python interpreter before assigning it to the name on the
left.
23
assignment operator: = is Python’s assignment operator, which should not be confused with the mathe-
matical comparison operator using the same symbol.
state diagram: A graphical representation of a set of variables and the values to which they refer.
variable name: A name given to a variable. Variable names in Python consist of a sequence of letters (a..z,
A..Z, and ) and digits (0..9) that begins with a letter. In best programming practice, variable names
should be chosen so that they describe their use in the program, making the program self documenting .
keyword: A reserved word that is used by the compiler to parse a program; you cannot use keywords like
if,def, andwhile as variable names.
statement: An instruction that the Python interpreter can execute. Examples of statements include the
assignment statement and the print statement.
expression: A combination of variables, operators, and values that represents a single result value.
evaluate: To simplify an expression by performing the operations in order to yield a single value.
operator: A special symbol that represents a simple computation like addition, multiplication, or string
concatenation.
operand: One of the values on which an operator operates.
modulus operator: An operator, denoted with a percent sign (%), that works on integers and ﬂoats and
yields the remainder when one number is divided by another.
integer division: An operation that divides one integer by another and yields an integer. Integer divi-
sion yields only the whole number of times that the numerator is divisible by the denominator and
discards any remainder.
rules of precedence: The set of rules governing the order in which expressions involving multiple opera-
tors and operands are evaluated.
concatenate: To join two operands end-to-end.
24
2.11 Laboratory exercises
1. Create a Folder in your Home Directory called Lab2 to store the ﬁles you create during this lab.
2. Enter the following statements into the interpreter and note which ones produce an error:
>>> n = 7
>>> 7 = n
>>> n = 5 + 2
>>> n = 5 + n
>>> n + 5 = n
>>> n = y
What are variables used for?
3. Enter the following print statements into the interpreter and note which ones produce an error:
>>> print n
>>> print n + 5
>>> print n + 5 + 2
>>> print n = 5
>>> print 7 + 5
>>> print n, 7+5, n+7
What can follow the print keyword?
4. Look at the following lines of code and predict what will be printed out. Use a python script to check
your prediction.
n = 2
printn + 2
print"n is ", n
n = 2
n = n + 2
print"n is ", n
5. Take the sentence: Jack is a dull boy. Show how you would use the interpreter to store each word in a separate
variable, then print out the sentence on one line using print.
Check that your answer is correct by entering it into the interpreter.
6. Repeat exercise 5, this time using a script (a script is another name for a saved Python ﬁle).
7. Add parentheses to the expression 6*1-2 to change its value from 4to-6.
25
8. Try to evaluate the following numerical expressions in your head, and put the answer beside each one, then
use the Python interpreter to check your results:
>>> 5 % 2
>>> 9 % 5
>>> 15 % 12
>>> 12 % 15
>>> 6 % 6
>>> 0 % 7
>>> 7 % 0
What happened with the last example? Why? If you were able to correctly anticipate the computer’s
response in all but the last one, it is time to move on. If not, take time now to make up examples of your
own. Explore the modulus operator until you are conﬁdent you understand how it works.
9. Start the Python interpreter and enter bruce + 4 at the prompt. This will give you an error:
NameError: name ’bruce’ is not defined
Assign a value to bruce so thatbruce + 4 evaluates to 10.
10. In a python script, assign a value greater than 1000 to the variable xe.g. 1468. Write code which will
assign to a variable xrounded the value of xrounded down to the nearest 100 e.g. for x of 1468,
xrounded will be 1400. Your code should display both values.
11. Since this lab is reasonably short we have provided you with a little game to play that can help you
practice thinking in a problem solving way. Look on the whiteboard for instructions on how to begin
the game. Work your way through the ﬁrst three levels.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
26
Lecture 3
Functions: part 1
3.1 Composing expressions
So far, we have looked at the elements of a program—variables, expressions, and statements—in isolation,
without talking about how to combine them. One of the most useful features of programming languages is
their ability to take small building blocks and compose them. For example, we know how to add numbers
and we know how to print; it turns out we can do both at the same time:
>>> print 17 + 3
20
In reality, the addition has to happen before the printing, so the actions aren’t actually happening at the
same time. The point is that any expression involving numbers, strings, and variables can follow print :
print"Number of minutes since midnight: ", hour *60 + minute
You can also put arbitrary expressions on the right-hand side of an assignment statement:
percentage = (minute *100) / 60
This ability may not seem impressive now, but you will see other examples where composition makes it
possible to express complex computations neatly and concisely.
Warning: There are limits on where you can use certain expressions. For example, the left-hand side of an
assignment statement has to be a variable name, not an expression. So, the following is illegal:
>>> minute+1 = hour
File "<stdin>", line 1
SyntaxError: can’t assign to operator
3.2 Function calls
Many common tasks come up time and time again when programming. Instead of requiring you to con-
stantly reinvent the wheel, Python has a number of built-in features which you can use. Including so much
ready to use code is sometimes referred to as a ’batteries included’ philosophy. Python comes with just
27
under ﬁfty predeﬁned functions (of which we’ll be only using about a dozen) and the simplest way to use
this prewritten code is via function calls.12
The syntax of a function call is simply
FUNCTION NAME(ARGUMENTS)
Not all functions take an argument, and some take more than one (in which case the arguments are sepa-
rated by commas).
You have already seen an example of a function call :
>>> type("Hello, World!")
<type ’str’>
>>> type(17)
<type ’int’>
The name of the function is type , and it displays the type of a value or variable. The value or variable,
which is called the argument of the function, has to be enclosed in parentheses. It is common to say that a
function “takes” an argument and “returns” a result. The result is called the return value .
We can assign the return value to a variable:
>>> result = type(17)
>>> print result
<type ’int’>
Another useful function is len. It takes a Python sequence as an argument. The only Python sequence we
have met so far is a string. A string is a sequence of characters. For a string argument, len returns the
number of characters the string contains.
>>> my_str = "Hello world"
>>> len(my_str)
11
Thelen function can only be used on sequences. Trying to use it on a number, for example, results in an
error.
>>> len(3)
TypeError: object of type ’int’ has no len()
3.3 Function deﬁnitions and use
As well as the built-in functions provided by Python you can deﬁne your own functions. In the context
of programming, a function is a named sequence of statements that performs a desired operation. This
operation is speciﬁed in a function deﬁnition . In Python, the syntax for a function deﬁnition is:
defNAME( LIST OF PARAMETERS ):
STATEMENTS
1Not everything that appears to be a function call actually is, but you don’t need to worry about that in this course. For the sake of
simplicity we’ll say that everything that looks like a function is a function.
2There is a full list of built-in functions at http://docs.python.org/2/library/functions.html
28
The ’list of parameters’ is where the arguments supplied to the function end up. You will see more of this
later.
You can make up any names you want for the functions you create, except that you can’t use a name that is
a Python keyword. The list of parameters speciﬁes what information, if any, you have to provide in order
to use the new function.
There can be any number of statements inside the function, but they have to be indented from the def. In
the examples in this book, we will use the standard indentation of four spaces3. IDLE automatically indents
compound statements for you. Function deﬁnitions are the ﬁrst of several compound statements we will
see, all of which have the same pattern:
1. A header , which begins with a keyword and ends with a colon.
2. A body consisting of one or more Python statements, each indented the same amount – 4 spaces is the
Python standard – from the header.
In a function deﬁnition, the keyword in the header is def, which is followed by the name of the function
and a list of parameters enclosed in parentheses. The parameter list may be empty, or it may contain any
number of parameters. In either case, the parentheses are required. The ﬁrst couple of functions we are
going to write have no parameters, so the syntax looks like this:
defnew_line():
print
This function is named newline . The empty parentheses indicate that it has no parameters (that is it takes
no arguments). Its body contains only a single statement, which outputs a newline character. (That’s what
happens when you use a print command without any arguments.)
Deﬁning a new function does not make the function run. To do that we need a function call . Function calls
contain the name of the function to be executed followed by a list of values, called arguments , which are
assigned to the parameters in the function deﬁnition. Our ﬁrst examples have an empty parameter list, so
the function calls do not take any arguments. Notice, however, that the parentheses are required in the function
call:
print"First Line."
new_line()
print"Second Line."
The output of this program is:
First line.
Second line.
The extra space between the two lines is a result of the newline() function call. What if we wanted more
space between the lines? We could call the same function repeatedly:
print"First Line."
new_line()
new_line()
3The Python language deﬁnition does not require 4 spaces, but it does require consistency. You could use any number of spaces or
a tab, but each ﬁle must use the same indentation scheme throughout. A common error is to mix 4 spaces and tabs, as these look the
same in an editor.
29
new_line()
print"Second Line."
Or we could write a new function named threelines that prints three new lines:
defthree_lines():
new_line()
new_line()
new_line()
print"First Line."
three_lines()
print"Second Line."
This function contains three statements, all of which are indented by four spaces. Since the next statement
is not indented, Python knows that it is not part of the function. You should notice a few things about this
program:
• You can call the same procedure repeatedly. In fact, it is quite common and useful to do so.
• You can have one function call another function; in this case threelines callsnewline .
So far, it may not be clear why it is worth the trouble to create all of these new functions. Actually, there are
a lot of reasons, but this example demonstrates two:
1. Creating a new function gives you an opportunity to name a group of statements. Functions can
simplify a program by hiding a complex computation behind a single command and by using English
words in place of arcane code.
2. Creating a new function can make a program smaller by eliminating repetitive code. For example, a
short way to print nine consecutive new lines is to call threelines three times.
Pulling together the code fragments from the previous section into a script named functions.py , the
whole program looks like this:
defnew_line():
print
defthree_lines():
new_line()
new_line()
new_line()
print"First Line."
three_lines()
print"Second Line."
This program contains two function deﬁnitions: newline andthreelines . Function deﬁnitions get
executed just like other statements, but the effect is to create the new function. The statements inside the
function do not get executed until the function is called, and the function deﬁnition generates no output.
As you might expect, you have to create a function before you can execute it. In other words, the function
deﬁnition has to be executed before the ﬁrst time it is called.
30
3.4 Flow of execution
In order to ensure that a function is deﬁned before its ﬁrst use, you have to know the order in which state-
ments are executed, which is called the ﬂow of execution . Execution always begins at the ﬁrst statement
of the program. Statements are executed one at a time, in order from top to bottom. Function deﬁnitions
do not alter the ﬂow of execution of the program, but remember that statements inside the function are
not executed until the function is called. Although it is not common, you can deﬁne one function inside
another. In this case, the inner deﬁnition isn’t executed until the outer function is called.
Function calls are like a detour in the ﬂow of execution. Instead of going to the next statement, the ﬂow
jumps to the ﬁrst line of the called function, executes all the statements there, and then comes back to pick
up where it left off. That sounds simple enough, until you remember that one function can call another.
While in the middle of one function, the program might have to execute the statements in another function.
But while executing that new function, the program might have to execute yet another function! Fortu-
nately, Python is adept at keeping track of where it is, so each time a function completes, the program picks
up where it left off in the function that called it. When it gets to the end of the program, it terminates.
It is usually not helpful to read a program from top to bottom. In python programs the top part of a
ﬁle is almost always used for function deﬁnitions and it is not necessary to read those until you want to
understand what a particular function does. The bottom part of a python ﬁle is often called the main
program. This part can be recognised because it is often not indented. It is easier to understand a program
by following the ﬂow of execution starting at the beginning of the main program.
3.5 Parameters and arguments
Most functions require arguments. Arguments are values that are input to the function and these contain
the data that the function works on. For example, if you want to ﬁnd the absolute value of a number (the
distance of a number from zero) you have to indicate what the number is. Python has a built-in function
for computing the absolute value:
>>> abs(5)
5
>>> abs(-5)
5
In this example, the arguments to the abs function are 5and-5.
Some functions take more than one argument. For example the built-in function pow takes two arguments,
the base and the exponent. Inside the function, the values that are passed get assigned to variables called
parameters .
>>> pow(2, 3)
8
>>> pow(3, 2)
9
The ﬁrst argument is raised to the power of the second argument.
round() , not surprisingly, rounds a number and returns the ﬂoating point value rounded to n-digits digits
after the decimal point. It takes one or two arguments. The ﬁrst is the number to be rounded and the second
(optional) value is the number of digits to round to. If the second number is not supplied it is assumed to
be zero.
31
>>> round(1.23456789)
1.0
>>> round(1.5)
2.0
>>> round(1.23456789, 2)
1.23
>>> round(1.23456789, 3)
1.235
Another built-in function that takes more than one argument is max.
>>> max(7, 11)
11
>>> max(4, 1, 17, 2, 12)
17
>>> max(3 *11, 5**3, 512-9, 1024 **0)
503
The function max can be sent any number of arguments, separated by commas, and will return the max-
imum value sent. The arguments can be either simple values or expressions. In the last example, 503 is
returned, since it is larger than 33,125, and1.
Here is an example of a user-deﬁned function that has a parameter:
defprint_twice(some_variable_name):
printsome_variable_name, some_variable_name
This function takes a single argument and assigns it to the parameter named somevariable name . The
value of the parameter (at this point we have no idea what it will be) is printed twice, followed by a newline.
The name somevariable name was chosen to suggest that the name you give a parameter is up to you,
but in general, you want to choose something more descriptive than somevariable name .
In a function call, the value of the argument is assigned to the corresponding parameter in the function def-
inition. In effect, it is as if somevariable name = "Spam" is executed when printtwice("Spam") is
called;somevariable name = 5 is executed when printtwice(5) is called; and somevariable name
= 3.14159 is executed when printtwice(3.14159) is called. Any type of argument that can be
printed can be sent to printtwice . In the ﬁrst function call, the argument is a string. In the second,
it’s an integer. In the third, it’s a ﬂoat.
As with built-in functions, we can use an expression as an argument for printtwice :
>>> print_twice("Spam" *4)
SpamSpamSpamSpam SpamSpamSpamSpam
"Spam"*4is ﬁrst evaluated to ’ SpamSpamSpamSpam ’, which is then passed as an argument to printtwice .
3.6 Function composition
Just as with mathematical functions, Python functions can be composed , meaning that you use the result
of one function as the input to another.
>>> print_twice(abs(-7))
7 7
32
>>> print_twice(max(3, 1, abs(-11), 7))
11 11
In the ﬁrst example, abs(-7) evaluates to 7, which then becomes the argument to printtwice . In the
second example we have two levels of composition, since abs(-11) is ﬁrst evaluated to 11beforemax(3,
1, 11, 7) is evaluated to 11andprinttwice(11) then displays the result.
We can also use a variable as an argument:
>>> saying = "Eric, the half a bee."
>>> print_twice(saying)
Eric, the half a bee. Eric, the half a bee.
Notice something very important here. The name of the variable we pass as an argument ( saying ) has
nothing to do with the name of the parameter ( somevariable name ). It doesn’t matter what the argu-
ment is called; here in printtwice , we call everybody somevariable name .
3.7 Comments
As programs get bigger and more complicated, they get more difﬁcult to read. Formal languages are dense,
and it is often difﬁcult to look at a piece of code and ﬁgure out what it is doing, or why. For this reason,
it is a good idea to add notes to your programs to explain in natural language what the program is doing.
These notes are called comments , and they are marked with the # symbol:
# compute the percentage of the hour that has elapsed
percentage = (minute *100) / 60
In this case, the comment appears on a line by itself. You can also put comments at the end of a line:
percentage = (minute *100) / 60 # caution: integer division
Everything from the # to the end of the line is ignored—it has no effect on the program. The message is
intended for the programmer or for future programmers who might use this code. In this case, it reminds
the reader about the ever-surprising behaviour of integer division.
3.8 Glossary
function: A named sequence of statements that performs some useful operation. Functions may or may
not take parameters and may or may not produce a result.
function deﬁnition: A statement that creates a new function, specifying its name, parameters, and the
statements it executes.
Python sequence: Several data structures in Python are collectively known as “sequences”. They are struc-
tures for storing a collection of values in a speciﬁc order. For example, a string is a sequence of char-
acters.
compound statement: A statement that consists of two parts:
1. header - which begins with a keyword determining the statement type, and ends with a colon.
2. body - containing one or more statements indented the same amount from the header.
33
The syntax of a compound statement looks like this:
keyword expression :
statement
statement ...
header: The ﬁrst part of a compound statement. Headers begin with a keyword and end with a colon ( :).
body: The second part of a compound statement. The body consists of a sequence of statements all in-
dented the same amount from the beginning of the header. The standard amount of indentation used
within the Python community is 4 spaces.
ﬂow of execution: The order in which statements are executed during a program run.
parameter: A name used inside a function to refer to the value passed as an argument.
argument: A value provided to a function when the function is called. This value is assigned to the corre-
sponding parameter in the function.
abs function: Returns the absolute value of the argument.
pow function: Returns the ﬁrst argument raised to the power of the second one. pow(x,y) is equivalent
tox**y.
round function: Rounds a number and returns the ﬂoating point value rounded to n-digits digits after the
decimal point.
max function: Returns the largest argument (if given more than one), or the largest item in a sequence (if
given a single sequence).
>>> max(3, 8, 2, 1)
8
>>> max("hello")
'o'
composition: The ability to combine simple expressions and statements into compound statements and
expressions in order to represent complex computations concisely.
function composition: Using the output from one function call as the input to another.
comment: Information in a program that is meant for other programmers (or anyone reading the source
code) and has no effect on the execution of the program.
main program: The part at the bottom of a ﬁle that is usually not indented. It is easier to understand a
program by following the ﬂow of executing starting from the main program.
34
3.9 Laboratory exercises
1. Using IDLE, create a Python script named functions.py . Type the deﬁnition of the function
newline from the lecture at the top of the ﬁle, and then add the deﬁnition of the function threelines
below it. Add a main routine at the bottom of the script (and not indented) which is a call to
threelines() . Don’t forget to add the parentheses when you call the function. Run the program.
2. Add a function to the ﬁle called ninelines that uses threelines to print nine blank lines.
Change the call in the main routine to be a call to ninelines() rather than threelines() .
3. Now add a function named clearscreen that prints out exactly forty blank lines. Change the main
routine call again to call clearscreen to check that it works as expected.
4. What would happen if ninelines was above threelines in the script? Why?
5. Start a new script morefunctions.py and add a function called powers(n) that prints out the
ﬁrst 5 powers of a given number.
>>> powers(6)
The first 5 powers of 6 are: 1 6 36 216 1296
>>> powers(10)
The first 5 powers of 10 are: 1 10 100 1000 10000
You can test your script by running it and then calling your functions from the Python interpreter.
6. Add another function to morefunctions.py calledscoresummary which takes 3 arguments,
representing scores from 3 judges. The function should determine and display the bottom, top, and
average score. Call this function from the interpreter, sending it different data e.g.
>>> score_summary(9.5, 7, 8.5)
Max 9.5 Min 7 Average 8.333333333333334
>>> score_summary(9, 8, 7)
Max 9 Min 7 Average 8.0
7. The results (in the question above) are listed without any way of identifying who they refer to. Make
the output more meaningful by adding a name string to the parameter list (and supplying a name
argument when you call the function).
>>> score_summary("Bruce",9.5, 7, 8.5)
Bruce : Max 9.5 Min 7 Average 8.333333333333334
>>> score_summary("Fred", 9, 8, 7)
Fred : Max 9 Min 7 Average 8.0
8. Writereject andaccept functions which can produce acceptance or rejection form letters. The
signature should be in a separate function, used by both the reject and accept functions.
>>> reject("Bill")
Dear Bill
I am sorry to inform you that you do nothave the job
Yours sincerely
Humphrey Hopalong
>>> reject("Amanda")
35
Dear Amanda
I am sorry to inform you that you do nothave the job
Yours sincerely
Humphrey Hopalong
>>> accept("Vicki")
Dear Vicki
I am pleased to inform you that you have the job
Yours sincerely
Humphrey Hopalong
9. Recall that min() andmax() take a ’sequence’ as an argument and that strings are ’sequences’ of
characters. Write a function showfirst which takes a string argument and prints the minimum
value in the string. Call your string from the interpreter sending it various strings. Try it with ”dog”,
xylophone”, ”elephant”, ”Elephant”
10. Try to complete up to level seven on the game you played in the previous labs.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
36
Lecture 4
Functions: part 2
Remember the printtwice function from the previous lecture? We are going to use it again, but we will
change the parameter name to something a bit more sensible.
defprint_twice(phrase):
printphrase, phrase
4.1 Variables and parameters are local
defprint_joined_twice(part1, part2):
joined = part1 + part2
print_twice(joined)
This function takes two arguments, concatenates them and stores the result in a local variable joined . It
then calls printtwice withjoined as the argument. printtwice prints the value of the argument,
twice. We can call the function with two strings:
>>> line1 = "Happy birthday, "
>>> line2 = "to you."
>>> print_joined_twice(line1, line2)
Happy birthday, to you. Happy birthday, to you.
Whenprintjoinedtwice terminates, the variable joined is destroyed. If we try to print it, we get an
error:
>>> printjoined
NameError: name 'joined' is notdefined
When you create a local variable inside a function, it only exists inside that function, and you cannot use it
outside. Parameters are also local. For example, outside the function printtwice , there is no such thing
asphrase . If you try to use it, Python will complain. Similarly, part1 andpart2 do not exist outside
printjoinedtwice
37
4.2 Stack diagrams
To keep track of which variables can be used where, it is sometimes useful to draw a stack diagram . Like
state diagrams, stack diagrams show the value of each variable, but they also show the function to which
each variable belongs. Each function is represented by a frame . A frame is a box with the name of a
function beside it and the parameters and variables of the function inside it. The stack diagram for the
previous example looks like this:
"Happy birthday, to you." phrase print_twice
__main__line1
line2"Happy birthday, "
"to you."joinedpart2part1 "Happy birthday, "
"to you."
"Happy birthday, to you."print_joined_twice
The order of the stack shows the ﬂow of execution. printtwice was called by printjoinedtwice ,
andprintjoinedtwice was called by main , which is a special name for the topmost function. When
you create a variable outside of any function, it belongs to main . Each parameter refers to the same
value as its corresponding argument. So, part1 has the same value as line1 ,part2 has the same value
asline2 , andphrase has the same value as joined .
If an error occurs during a function call, Python prints the name of the function, and the name of the
function that called it, and the name of the function that called that, all the way back to the top most
function. To see how this works, we create a Python script named stacktrace.py that looks like this:
1defprint_twice(phrase):
2 printphrase, phrase
3 printjoined
4
5defprint_joined_twice(part1, part2):
6joined = part1 + part2
7print_twice(joined)
8
9line1 = "Happy birthday, "
10line2 = "to you."
11print_joined_twice(line1, line2)
We’ve added the statement, print joined inside the printtwice function, but joined is not deﬁned
there. Running this script will produce an error message like this:
Traceback (most recent call last):
File "stack-example.py", line 11, in <module>
print_joined_twice(line1, line2)
File "stack-example.py", line 7, in print_joined_twice
print_twice(joined)
File "stack-example.py", line 3, in print_twice
print joined
NameError: global name ’joined’ is not defined
38
This list of functions is called a traceback . It tells you what program ﬁle the error occurred in, and what
line, and what functions were executing at the time. It also shows the line of code that caused the error.
Notice the similarity between the traceback and the stack diagram. It’s not a coincidence. In fact, another
common name for a traceback is a stack trace .
4.3 Input
Remember at the start of the course we said that programs are made up of instructions which only perform
a handful of operations1. The ﬁrst two of these operations were input and output. Input involves getting
data from the keyboard, a ﬁle, or some other device. Output is concerned with displaying data on the
screen or sending data to a ﬁle or other device.
We have already done quite a bit of displaying data on the screen using the print command, which ﬁts
into the category of output. We are now going to look at one of the most basic input tasks: getting keyboard
input.
There are two built-in functions in Python for getting keyboard input, input andrawinput2:
name = raw_input("Please enter your name: ")
printname
num = input("Enter a numerical expression: ")
printnum
A sample run of this script would look something like this:
$ python tryinput.py
Please enter your name: Arthur, King of the Britons
Arthur, King of the Britons
Enter a numerical expression: 7 *3
21
Each of these functions allows a prompt to be given between the parentheses as an argument to the function.
The result returned by rawinput is always a string. But the result returned from input can be any valid
Python type.
>>> n = raw_input()
hello
>>> n
’hello’
>>> type(n)
<type ’str’>
>>> n = input()
1.5 + 2
>>> n
3.5
>>> type(n)
<type ’float’>
1See the list on page 3 to refresh your memory.
2in Python 3 there is just input , but it behaves the same as rawinput in Python 2.x
39
4.4 Type conversion
Each Python type comes with a built-in function that attempts to convert values of another type into that
type. Theint(ARGUMENT) function, for example, takes any value and converts it to an integer, if possible,
or complains otherwise:
>>> int("32")
32
>>> int("Hello")
ValueError: invalid literal for int() with base 10: ’Hello’
Theint function can also convert ﬂoating-point values to integers, but note that it truncates the fractional
part:
>>> int(-2.3)
-2
>>> int(3.99999)
3
>>> int("42")
42
>>> int(1.0)
1
Thefloat(ARGUMENT) function converts integers and strings to ﬂoating-point numbers:
>>> float(32)
32.0
>>> float("3.14159")
3.14159
>>> float(1)
1.0
It may seem odd that Python distinguishes the integer value 1from the ﬂoating-point value 1.0. They may
represent the same number, but they belong to different types as they are represented differently inside the
computer.
Thestr(ARGUMENT) function converts any argument to type string:
>>> str(32)
’32’
>>> str(3.14149)
’3.14149’
>>> str(True)
’True’
>>> str(true)
NameError: name ’true’ is not defined
Thestr(ARGUMENT) function will work with any value and convert it into a string. Note: True is a
predeﬁned value in Python; true is not. We will see more of True in lecture 5.
4.5 Glossary
local variable: A variable deﬁned inside a function. A local variable can only be used inside its function.
40
stack diagram: A graphical representation of a stack of functions, their variables, and the values to which
they refer.
frame: A box in a stack diagram that represents a function call. It contains the local variables and parame-
ters of the function.
traceback: A list of the functions that are executing, printed when a runtime error occurs. A traceback is
also commonly referred to as a stack trace , since it lists the functions in the order in which they are
stored in the runtime stack.
4.6 Laboratory exercises
1. Create a script named params.py with the following contents:
defprint_param(x):
printx
x = "Hello"
print_param("Goodbye")
printx
Run the script and record the output of the program.
Draw a stack diagram showing the value of each function’s variables at the moment that the print state-
ment inprintparam is called.
2. Create a script called changeparam.py with the following contents:
defchange_param(x):
x = "Goodbye"
x = "Hello"
change_param(x)
printx
Run the script and record the output of the program in a text ﬁle.
Explain how the output comes about.
41
3. Try to ﬁgure out what the output of the program below will be.
defprint_all(first, second, third):
printfirst, second, third
defprint_reverse(first, second, third):
printthird, second, first
defprint_add(first, second, third):
printfirst + second + third
defprint_add_reverse(first, second, third):
printthird + second + first
one = "fish"
two = "and"
three = "chips"
print_all(one, two, three)
print_reverse(one, two, three)
print_all(three, two, one)
print_add(one, two, three)
print_add_reverse(one, two, three)
print_all(1, 2, 3)
print_reverse(1, 2, 3)
print_add(1, 2, 3)
print_add_reverse(1, 2, 3)
Put your answer in a text ﬁle, and then type in and run the code to check that you are right.
Draw the stack diagram at the moment printaddreverse(one, two, three) is called.
4. Type the following code into a ﬁle called inputfun.py :
print"Enter some text:"
text = raw_input()
print"You entered: " + text
print"Enter some text:"
text = raw_input()
print"You entered: " + text
print"Enter some text:"
text = raw_input()
print"You entered: " + text
Run the script to see what it does. Simplify the script by identifying the repeated code and placing it in a
function. This is called ’encapsulation’.
5. Create a script called convert.py which uses the function rawinput to read a string from the keyboard.
Attempt to convert the string to a ﬂoat using float(x) and also to an integer using int(x) . Print out the
resulting ﬂoat and integer. Test the script with the following input:
10
103
1e12
0.000001
blah
Explain the output produced.
42
6. Try to complete up to level nine on the game you played in the previous labs.
7. So far we have used the ’,’ to print more than one item at a time. In the following exercises this
will prove problematic, in particular adding the full stop in the correct place when using a ’,’ always
introduces a space. Try using ’+’ to concatenate the various strings instead. Note: concatenation only
works with strings so you will need to cast any non-string values.
>>> a = "one"
>>> b = "two"
>>> c = 3
>>> printa, b, c
one two 3
>>> printa + b + str(c)
onetwo3
8. Create a script called filmcritic.py . In it deﬁne a function ratemovie that takes an argument movie
and asks the user to give it a rating out of ﬁve. The function should produce output similar to:
Movie: The Meaning of Life; Your rating: 4.
9. Deﬁne a function that takes two arguments, name andage. It should produce output similar to:
Hello Eric, you are 67 years old.
Next year you will be 68.
What happens if you pass the parameters in the wrong order?
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
43
44
Lecture 5
Conditionals
5.1 Conditional execution
In order to write useful programs, we almost always need the ability to check conditions and change the
behaviour of the program accordingly. Conditional statements give us this ability. We use this idea of con-
ditional execution very often in our everyday lives. For example, when leaving the house in the morning,
you might habitually “execute” the following:
if it is windy, take your coat
if it is windy and rainy, take your coat
if it is not windy and it is rainy, take your umbrella.
Or, if you live in Dunedin, you probably just take your coat and umbrella every day.
In Python, the simplest form of a conditional statement is the if statement :
ifweather == "windy":
print"take your coat"
The part after the ifkeyword and before the colon is a boolean expression and is called the condition .
A boolean expression is simply an expression that evaluates to True orFalse . If the condition is true,
then the indented statement gets executed. If the condition is false then the indented statement is skipped
and the ﬂow of control jumps to the statement immediately following the ifblock. The syntax for an if
statement looks like this:
ifBOOLEAN EXPRESSION:
STATEMENTS
As with the function deﬁnition from Lecture 3 and other compound statements, the ifstatement consists
of a header and a body. The header begins with the keyword iffollowed by a boolean expression and ends
with a colon ( :). The indented statements that follow are called a block . The ﬁrst unindented statement
marks the end of the block. A statement block inside a compound statement is called the body of the
statement. Each of the statements inside the body are executed in order if the boolean expression evaluates
toTrue . The entire block is skipped if the boolean expression evaluates to False . There is no limit on the
number of statements that can appear in the body of an ifstatement, but there has to be at least one.
45
5.2 Boolean values and expressions
The Python type for storing true and false values is called bool, named after the British mathematician,
George Boole. George Boole created Boolean algebra , which is the basis of all modern computer arithmetic.
There are only two boolean values :True andFalse . Capitalization is important, since true andfalse
are not boolean values in Python.
>>> type(True)
<type ’bool’>
>>> type(true)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name ’true’ is not defined
The operator ==compares two values and produces a boolean value:
>>> 5 == 5
True
>>> 5 == 6
False
In the ﬁrst statement, the two operands are equal, so the expression evaluates to True ; in the second state-
ment, 5 is not equal to 6, so we get False . The==operator is one of the comparison operators ; the others
are:
x != y # x is not equal to y
x > y # x is greater than y
x < y # x is less than y
x >= y # x is greater than or equal to y
x <= y # x is less than or equal to y
Although these operations are probably familiar to you, the Python symbols are different from the math-
ematical symbols. A common error is to use a single equal sign ( =) instead of a double equal sign ( ==).
Remember that =is an assignment operator and ==is a comparison operator. Also, there is no such thing
as =<or =>.
5.3 Logical operators
Boolean expressions can be combined to create more complicated boolean expressions using one of the
three logical operators :and,or, andnot. The semantics (meaning) of these operators is similar to their
meaning in English. For example, x>0 and x<10is true only if xis greater than 0 andless than 10.
n % 2 == 0 or n % 3 == 0 is true if either (or both) of the conditions is true, that is, if the number is
divisible by 2 or3. Finally, the not operator negates a boolean expression, so not(x>y)is true if(x>
y)is false, that is, if x is less than or equal to y.
5.4 Alternative execution
A second form of the ifstatement is alternative execution, in which there are two possibilities and the
condition determines which one gets executed. The syntax looks like this:
46
x y z Boolean Expression Value
"windy" "rainy" - x=="windy"
"windy" "rainy" - y=="rainy"
"windy" "rainy" - (x=="windy") and (y=="rainy")
"windy" "sunny" - (x=="windy") and (y=="rainy")
"windy" "sunny" - (x=="windy") or (y=="rainy")
True - - x
True True - x or y
True False - x and y
True False True x and (y or z)
10 5 7 (x<y) or (y<z)
10 5 7 (x<y) and (y<z)
10 5 7 (x<y) and (y<x)
10 5 7 (x<y) or (y<z)
10 10 7 (x<y) or (y<z)
10 10 7((x<y) or (y<z)) and ((x<20) and (y>5))
Figure 5.1: Test your knowledge of Boolean expressions
ifx % 2 == 0:
printx, "is even"
else:
printx, "is odd"
If the remainder when xis divided by 2is0, then we know that xis even, and the program displays a
message to that effect. If the condition is false, the second set of statements is executed. Since the condition
must be true or false, exactly one of the alternatives will be executed. The alternatives are called branches ,
because they are branches in the ﬂow of execution.
As an aside, if you need to check the parity (evenness or oddness) of numbers often, you might wrap this
code in a function:
defprint_parity(x):
ifx % 2 == 0:
printx, "is even"
else:
printx, "is odd"
For any value of x, printparity displays an appropriate message. When you call it, you can provide
any integer expression as an argument.
>>> print_parity(17)
17 is odd.
>>> y = 41
>>> print_parity(y+1)
42 is even.
47
5.5 Chained conditionals
Sometimes there are more than two possibilities and we need more than two branches. One way to express
a computation like that is a chained conditional :
ifx < y:
printx, "is less than", y
elifx > y:
printx, "is greater than", y
else:
printx, "and", y, "are equal"
elif is an abbreviation of else if. Again, exactly one branch will be executed. There is no limit to the
number of elif statements but only a single (and optional) else statement is allowed and it must be the
last branch in the statement:
ifchoice == 'a':
function_a()
elifchoice == 'b':
function_b()
elifchoice == 'c':
function_c()
else:
print"Invalid choice."
Each condition is checked in order. If the ﬁrst is false, the next is checked, and so on. If one of them is true,
the corresponding branch executes, and the statement ends. Even if more than one condition is true, only
the ﬁrst true branch executes.
5.6 Nested conditionals
One conditional can also be nested within another. Consider the following example:
ifx == y:
printx, "and", y, "are equal"
else:
ifx < y:
printx, "is less than", y
else:
printx, "is greater than", y
The outer conditional contains two branches. The ﬁrst branch contains a simple output statement. The
second branch contains another if statement, which has two branches of its own. Those two branches
are both output statements, although they could have been conditional statements as well. Although the
indentation of the statements makes the structure apparent, nested conditionals become difﬁcult to read
very quickly. A nested conditional can always be rewritten as a chained conditional and vice versa. What
to use is partly a matter of choice, but in general you should use the structure that is easiest to understand.
Logical operators often provide a way to simplify nested conditional statements. For example, we can
rewrite the following code using a single conditional:
48
if0 < x:
ifx < 10:
print"x is a positive single digit."
The print statement is executed only if we make it past both the conditionals, so we can use the andopera-
tor:
if0 < x andx < 10:
print"x is a positive single digit."
These kinds of conditions are common, so Python provides an alternative syntax that is similar to mathe-
matical notation:
if0 < x < 10:
print"x is a positive single digit."
This condition is semantically the same as the compound boolean expression and the nested conditional.
5.7 Booleans and type conversion
Python assigns boolean values to values of other types. For numerical types like integers and ﬂoating-
points, zero values are false and non-zero values are true. For strings, empty strings are false and non-
empty strings are true.
>>> str(True)
’True’
>>> str(true)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name ’true’ is not defined
>>> bool(1)
True
>>> bool(0)
False
>>> bool("Banana")
True
>>> bool("")
False
>>> bool(3.14159)
True
>>> bool(0.0)
False
>>> bool("False") # "False" is a non-empty string, cf. bool("Banana")
True
This can cause real confusion in conditional statements. For example:
badWeather = "False"
ifbadWeather:
print"Take your coat"
will always print "Take your coat" (perfect for Dunedin perhaps).
49
5.8 Glossary
boolean value: There are exactly two boolean values: True and False. Boolean values result when a boolean
expression is evaluated by the Python interpreter. They have type bool.
boolean expression: An expression that is either true or false.
bool function: Converts the argument to a boolean.
comparison operator: One of the operators that compares two values: ==, !=, >,<,>=, and<=.
logical operator: One of the operators that combines boolean expressions: and, or, and not.
conditional statement: A statement that controls the ﬂow of execution depending on some condition. In
Python the keywords if, elif, and else are used for conditional statements.
condition: The boolean expression in a conditional statement that determines which branch is executed.
block: A group of consecutive statements with the same indentation.
body: The block of statements in a compound statement that follows the header.
branch: One of the possible paths of the ﬂow of execution determined by conditional execution.
chained conditional: A conditional branch with more than two possible ﬂows of execution. In Python
chained conditionals are written with if ... elif ... else statements.
nesting: One program structure within another, such as a conditional statement inside a branch of another
conditional statement.
50
5.9 Laboratory exercises
1. Look at the following expressions. What do you think the results would be? Enter the expressions in
to the Python interpreter to check your predictions.
True orFalse
True andFalse
not(False) andTrue
not(False orTrue)
not(False andTrue)
False or not(True)
True andTrue
True orTrue
False orFalse
Analyze these results. In words, explain the behaviour of the and andoroperators.
2.
ifx < y:
printx, "is less than", y
elifx > y:
printx, "is greater than", y
else:
printx, "and", y, "are equal"
Encapsulate (wrap) this code in a function called compare(x, y) . Callcompare three times: one
each where the ﬁrst argument is less than, greater than, and equal to the second argument and check
that it prints the appropriate message.
3. Write a function named isdivisible by3that takes a single integer as an argument and prints
“This number is divisible by three.” if the argument is evenly divisible by 3 and “This number is not
divisible by three.” otherwise. Hint: remember the mod operator %returns 0 if the ﬁrst argument is
divisible by the second (so 6%3 is 0).
Now write a similar function named isdivisible by5.
4. Write a function waterstate which takes one parameter that represents a temperature in degrees
centigrade. If the temperature is greater than 100, print ”Steam”, less than 0, print”Ice”, otherwise
print ”Liquid”.
5. Write a function which asks a yes/no question of the user. If the user types any variation of Y, y, Yes,
yes, or YES print ”You chose Yes” otherwise print ”You chose No”
6.
ifchoice == 'a':
function_a()
elifchoice == 'b':
function_b()
elifchoice == 'c':
function_c()
else:
print"Invalid choice."
Wrap this code in a function called dispatch(choice) . Then deﬁne function a,function b,
andfunction cso that they print out a message saying they were called. For example:
51
deffunction_a():
print"function_a was called..."
Put the four functions ( dispatch ,function a,function b, andfunction c) into a script named
choice.py and check it in the interpreter as follows:
>>> dispatch("a")
function_a was called.
>>> dispatch("b")
function_b was called.
>>> dispatch("c")
function_c was called.
Finally, modify the script so that user is prompted to enter ’a’, ’b’, or ’c’. Remove the parameter from
dispatch() and userawinput indispatch() instead.
7. Write a function which takes 3 integer arguments and prints ”equal” if any of the arguments is equal
to any other argument.
>>> any_equal(1, 2, 3)
No inputs match.
>>> any_equal(1, 2, 1)
At least two inputs are the same.
>>> any_equal(1, 1, 3)
At least two inputs are the same.
>>> any_equal("ant", "ant", 3)
At least two inputs are the same.
>>> any_equal("ant", "ant", "ant")
At least two inputs are the same.
8. Write a function nextlevel which takes 6 scores as arguments. A student needs to have a total
score of 200 from the 5 best subjects in order to move on. Write a body for the function which discards
the lowest score and totals the rest, printing ”Pass” or ”Repeat” as appropriate. Hint: remember the
min() function.
9. Try to ﬁnish the game (there are twelve levels) that you have been playing in previous labs.
10.Extension Exercise: Write a function that takes 3 parameters and prints them out in order. For example:
>>> print_in_order(5, 6, 4)
In order: 4, 5, 6
11.Extension Exercise: Write a function findmiddle that takes 3 parameters and prints the middle one.
For example:
>>> print_middle(5, 6, 4)
The middle value is 5
12.Extension Exercise: To better understand boolean expressions, it is helpful to construct truth tables.
Two boolean expressions are logically equivalent if they have the same truth table. The following
Python function showtruthtable prints out the truth table for any boolean expression in two
variablespandq:
boolean ex.py :
52
defshow_boolean_expression(p, q, expression):
printstr(p) + "\t" + str(q) + "\t" + str(eval(expression))
defshow_truth_table(expression):
print" p q " + expression
length = len(" p q " + expression)
printlength*"-"
show_boolean_expression(True, True, expression)
show_boolean_expression(True, False, expression)
show_boolean_expression(False, True, expression)
show_boolean_expression(False, False, expression)
There is a new function in the above code: eval evaluates its argument as a python expression. You
can useeval to evaluate arbitrary strings. Let’s ﬁnd out more about boolean expressions. Copy this
program to a ﬁle named boolean ex.py . Runboolean ex.py from IDLE, then use the interpreter
window to call showtruthtable with various strings. For example:
>>> show_truth_table("p or q")
p q p or q
----------------------
True True True
True False True
False True True
False False False
>>>
Use theshowtruthtable function with the following boolean expressions, recording the truth
table produced each time:
(a) not(p or q)
(b) p and q
(c) not(p and q)
(d) not(p) or not(q)
(e) not(p) and not(q)
Which of these are logically equivalent?
53
13.Extension Exercise: This really is quite an advanced question. Type in and call the following function. Then
try to come up with a sensible description of what is going on.
defadams():
answer = 42
guess = input("What is the answer to the ultimate question? ")
ifguess < answer:
print"No silly, that's too small."
adams()
elifguess > answer:
print"You dope, that's too big."
adams()
else:
print"Well done. Wonder what the question is?"
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
54
Lecture 6
Fruitful functions
6.1 The return statement
The return statement allows you to terminate the execution of a function before you reach the end. One
reason to use it is if you detect an error condition:
defprint_square_root(x):
ifx < 0:
print"Warning: cannot take square root of a negative number."
return
result = x **0.5
print"The square root of x is", result
The function printsquareroot has a parameter named x. The ﬁrst thing it does is check whether xis
less than0, in which case it displays an error message and then uses return to exit the function. The ﬂow
of execution immediately returns to the caller, and the remaining lines of the function are not executed.
6.2 Return values
The built-in functions we have used, such as abs,pow,round andmax, have produced results. Calling each
of these functions generates a value, which we usually assign to a variable or use as part of an expression.
biggest = max(3, 7, 2, 5)
x = abs(3 - 11) + 10
So far, none of the functions we have written has returned a value, they have printed values. In this lecture,
we are going to write functions that return values, which we will call fruitful functions , for want of a better
name. The ﬁrst example is areaofcircle , which returns the area of a circle with the given radius:
55
defarea_of_circle(radius):
ifradius < 0:
print"Warning: radius must be non-negative"
return
area = 3.14159 *radius**2
returnarea
We have seen the return statement before, but in a fruitful function the return statement includes a re-
turn value . This statement means: Return immediately from this function and use the following expression
as a return value. The expression provided can be arbitrarily complicated, so we could have written this
function more concisely:
defarea_of_circle(radius):
ifradius < 0:
print"Warning: radius must be non-negative"
return
return3.14159 *radius**2
On the other hand, temporary variables like area often make debugging easier. Sometimes it is useful to
have multiple return statements, one in each branch of a conditional. For instance, we have already seen
the built-in abs, now we see how to write our own:
defabsolute_value(x):
ifx < 0:
return-x
else:
returnx
Since these return statements are in an alternative conditional, only one will be executed. As soon as
one is executed, the function terminates without executing any subsequent statements. Another way to
write the above function is to leave out the else and just follow the ifcondition by the second return
statement.
defabsolute_value(x):
ifx < 0:
return-x
returnx
Think about this version and convince yourself it works the same as the ﬁrst one. Code that appears any
place the ﬂow of execution can never reach, is called dead code . In a fruitful function, it is a good idea to
ensure that every possible path through the program hits a return statement. The following version of
absolute value fails to do this:
defabsolute_value(x):
ifx < 0:
return-x
elifx > 0:
returnx
This version is not correct because if xhappens to be 0, neither condition is true, and the function ends
without hitting a return statement. In this case, the return value is a special value called None :
56
>>> print absolute_value(0)
None
None is the unique value of a type called the NoneType :
>>> type(None)
<type ’NoneType’>
All Python functions return None whenever they do not return another value. So the earlier functions we
wrote that didn’t have a return statement were actually returning values, we just never checked.
>>> def print_hello():
... print "hello"
...
>>> return_value = print_hello()
hello
>>> type(return_value)
<type ’NoneType’>
6.3 Program development
At this point, you should be able to look at complete functions and tell what they do. Also, while completing
the laboratory exercises given so far, you will have written some small functions. As you write larger
functions, you might start to have more difﬁculty, especially with runtime and semantic errors. To deal with
increasingly complex programs, we are going to suggest a technique called incremental development . The
goal of incremental development is to avoid long debugging sessions by adding and testing only a small
amount of code at a time.
As an example, suppose you want to ﬁnd the distance between two points, given by the coordinates (x1;y1)
and(x2;y2). By the Pythagorean theorem, the distance is:
distance =p
(x2 x1)2+ (y2 y1)2
The ﬁrst step is to consider what a distance function should look like in Python. In other words, what are
the inputs (parameters) and what is the output (return value)? In this case, the two points are the inputs,
which we can represent using four parameters. The return value is the distance, which is a ﬂoating-point
value. Already we can write an outline of the function:
defdistance(x1, y1, x2, y2):
return0.0
Obviously, this version of the function doesn’t compute distances; it always returns zero. But it is syntacti-
cally correct, and it will run, which means that we can test it before we make it more complicated.
To test the new function, we call it with sample values:
>>> distance(1, 2, 4, 6)
0.0
We chose these values so that the horizontal distance equals 3 and the vertical distance equals 4; that way,
the result is 5 (the hypotenuse of a 3-4-5 triangle). When testing a function, it is useful to know the right
57
answer. At this point we have conﬁrmed that the function is syntactically correct, and we can start adding
lines of code. After each incremental change, we test the function again. If an error occurs at any point, we
know where it must be—in the last line we added.
A logical ﬁrst step in the computation is to ﬁnd the differences x2 x1andy2 y1. We will store those
values in temporary variables named dxanddyand print them.
defdistance(x1, y1, x2, y2):
dx = x2 - x1
dy = y2 - y1
print"dx is", dx
print"dy is", dy
return0.0
If the function is working, the outputs should be 3 and 4. If so, we know that the function is getting the
right parameters and performing the ﬁrst computation correctly. If not, there are only a few lines to check.
Next we compute the sum of squares of dx and dy:
defdistance(x1, y1, x2, y2):
dx = x2 - x1
dy = y2 - y1
dsquared = dx **2 + dy**2
print"dsquared is: ", dsquared
return0.0
Notice that we removed the print statements we wrote in the previous step. Code like that is called scaf-
folding because it is helpful for building the program but is not part of the ﬁnal product. Again, we would
run the program at this stage and check the output (which should be 25). Finally, using the fractional
exponent 0.5 to ﬁnd the square root, we compute and return the result:
defdistance(x1, y1, x2, y2):
dx = x2 - x1
dy = y2 - y1
dsquared = dx **2 + dy**2
result = dsquared **0.5
returnresult
If that works correctly, you are done. Otherwise, you might want to print the value of result before the
return statement. When you start out, you should add only a line or two of code at a time. As you gain more
experience, you might ﬁnd yourself writing and debugging bigger chunks. Either way, the incremental
development process can save you a lot of debugging time.
The key aspects of the process are:
1. Start with a working program and make small incremental changes. At any point, if there is an error,
you will know exactly where it is.
2. Use temporary variables to hold intermediate values so you can output and check them.
3. Once the program is working, you might want to remove some of the scaffolding or consolidate
multiple statements into compound expressions, but only if it does not make the program difﬁcult to
read.
58
6.4 Composition
As you should expect by now, you can call one function from within another. This ability is called compo-
sition . As an example, we’ll write a function that takes two points, the center of the circle and a point on
the perimeter, and computes the area of the circle. Assume that the center point is stored in the variables
xcandyc, and the perimeter point is in xpandyp. The ﬁrst step is to ﬁnd the radius of the circle, which
is the distance between the two points. Fortunately, we’ve just written a function, distance, that does just
that, so now all we have to do is use it:
radius = distance(xc, yc, xp, yp)
The second step is to ﬁnd the area of a circle with that radius and return it. Again we will use one of our
earlier functions:
result = area_of_circle(radius)
Wrapping that up in a function, we get:
defarea_of_circle_two_points(xc, yc, xp, yp):
radius = distance(xc, yc, xp, yp)
result = area_of_circle(radius)
returnresult
We called this function areaofcircletwopoints to distinguish it from the areaofcircle func-
tion deﬁned earlier. There can only be one function with a given name within a given module. The tem-
porary variables radius and result are useful for development and debugging, but once the program is
working, we can make it more concise by composing the function calls:
defarea_of_circle_two_points(xc, yc, xp, yp):
returnarea_of_circle(distance(xc, yc, xp, yp))
6.5 Boolean functions
Functions can return boolean values, which is often convenient for hiding complicated tests inside func-
tions. For example:
defis_divisible(x, y):
ifx % y == 0:
returnTrue
else:
returnFalse
The name of this function is isdivisible . It is common to give boolean functions names that sound
like yes/no questions. isdivisible returns either True orFalse to indicate whether the xis or is not
divisible by y. We can make the function more concise by taking advantage of the fact that the condition
of theifstatement is itself a boolean expression. We can return it directly, avoiding the ifstatement
altogether:
defis_divisible(x, y):
returnx % y == 0
59
This session shows the new function in action:
>>> is_divisible(6, 4)
False
>>> is_divisible(6, 3)
True
Boolean functions are often used in conditional statements:
ifis_divisible(x, y):
print"x is divisible by y"
else:
print"x is not divisible by y"
It might be tempting to write something like:
ifis_divisible(x, y) == True:
print"x is divisible by y"
else:
print"x is not divisible by y"
But the extra comparison is unnecessary.
6.6 Glossary
fruitful function: A function that yields a return value.
return value: The value provided as the result of a function call.
temporary variable: A variable used to store an intermediate value in a complex calculation.
dead code: Part of a program that can never be executed, often because it appears after a return statement.
None :A special Python value returned by functions that have no return statement, or a return statement
without an argument. None is the only value of the type NoneType .
incremental development: A program development plan intended to simplify debugging by adding and
testing only a small amount of code at a time.
scaffolding: Code that is used during program development but is not part of the ﬁnal version.
boolean function: A function that returns a boolean value.
composition (of functions): Calling one function from within the body of another, or using the return
value of one function as an argument to the call of another.
60
6.7 Laboratory exercises
1. Write a function called iseven(n) that takes an integer as an argument and returns True if the
argument is an even number andFalse if it is odd .
2. Now write the function isodd(n) that returns True whennis odd and False otherwise. Finally,
modifyisodd so that it uses a call to iseven to determine if its argument is an odd integer.
3. Write a function called isfactor which returns True if the ﬁrst argument is a factor of the second.
That is,isfactor(3, 12) isTrue whereasisfactor(5, 12) isFalse .
4. Write a function called hypotenuse that returns the length of the hypotenuse of a right angled trian-
gle given the length of the other two sides as parameters. Here’s an initial deﬁnition:
defhypotenuse(a,b):
return0.0
5. Copy the areaofcircle function deﬁnition from Section 6.2. Now write a function called areaofsnowman
that takes as arguments three numbers representing the radii of the head, middle and bottom sections
of a snowman. Return the area of the snowman using calls to areaofcircle to calculate the result.
6. Make a copy of your 3 judges program from exercise 6 on page 35. Adapt the function so it returns
the average score. Adapt the function calls so each value is stored in a variable. Write a statement in
the main routine which reports the highest average score.
7. Make a copy of your nextlevel function from exercise 8 on page 52. Adapt the function so it returns
the best 5 total. Adapt the function calls so each value is stored in a variable. Write a statement in the
main routine which reports the highest best 5 score.
8. Make a copy of your waterstate function from the exercise 4 on page 51. Adapt the function so
itreturns the descriptive string. The main routine should collect the temperature from the user, then
display the state e.g. H2O at 300 degrees will be steam.
9. Python functions return None whenever they do not return anything else. Using the two functions
below show that this statement is true.
deffunc1():
print"Function 1"
return
deffunc2():
print"Function 2"
10. If you didn’t complete all the levels of the game in the previous lab try to ﬁnish it this time.
11. Write a function that presents a menu as follows:
Calculate the area of which shape?
1 a triangle
2 a circle
3 a square
Enter a number to choose:
Depending on the user’s choice, ask for the appropriate inputs, call an appropriate function to get the
correct area and display the result sensibly.
61
12. Open filmcritic.py that you wrote in Exercise 8, page 43. Add a function called getstars
that takes a number and returns either “BOMB” ( if the argument is zero), a string of up to four stars
(depending on the argument), “MUST SEE” (if the argument is 5), or “?”. Call this function inside
ratemovie instead of just printing the numerical rating.
13.Extension Exercise: Make a copy of your findmiddle program from exercise 11 on page 52. Adapt
the function so it returns the middle value. The main routine should collect 3 integers from the user
then display the middle number.
14.Extension Exercise: Recall that the equation for a line can be written as y=mx+c, wheremis the slope
of the line and cis they-intercept. For a line that passes through two points, (x1;y1)and(x2;y2), we
have the following identities:
m=y2 y1
x2 x1
c=y1 mx1
(a) Write a function slope(x1, y1, x2, y2) that returns the slope of the line through the points
(x1, y1) and(x2, y2) .
(b) Write a function intercept(x1, y1, x2, y2) that returns the y-intercept of the line through
the points (x1, y1) and(x2, y2) .
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
62
Lecture 7
Modules and TDD
This chapter primarily deals with a development methodology called Test Driven Development (TDD).
Before we get to TDD though, we need a couple of extra parts of python: modules and triple quoted
strings.
7.1 Modules, ﬁles and the import statement
Amodule is simply a Python ﬁle that contains deﬁnitions (usually function deﬁnitions). As programs
get large, it makes sense to separate the program into different modules. This allows the programmer to
minimize the complexity of the programming task. Typically, similar functionality or related functions are
grouped into a single module and separate modules are as independent of each other as possible. Creating
your own modules is as easy as creating a Python script with deﬁnitions in it; in fact you have already
written lots of Python modules.
The Python standard library contains a very large number of modules for many different tasks. It is worth-
while browsing the library just to get a feel for all the useful things it can do. The current documentation
can be accessed at: http://www.python.org/doc/current/library/index.html , or by choosing
Help!Python Docs ... in IDLE. We will look at the doctest module later in this lecture, and throughout
the course several other modules will be introduced.
There are three ways of using import to import a module and subsequently use what was imported. The
math module contains many useful math functions, we will use it to illustrate:
1.
importmath
printmath.cos(math.pi/2.0)
This statement imports every function from the math module which are then accessed using dot
notation.
2.
frommath importcos, pi
printcos(pi/2.0)
This statement imports only the deﬁnitions of cos andpifrom the math library. Nothing else is
imported.
63
3.
frommath import*
printcos(pi/2.0)
This statement also imports everything from the math module, the difference being that dot notation
is not needed to access module members.
It is more common to use the ﬁrst or second alternative than the last. The ﬁrst has the advantage of avoiding
naming conﬂicts (two different modules deﬁning cos for example), at the cost of lengthier function calls.
The second has the opposite advantages and disadvantages.
We can use the help function to see the functions and data contained within modules. The keyword
module contains a single function, iskeyword , which as its name suggests is a boolean function that
returnsTrue if a string passed to it is a keyword:
>>> from keyword import *
>>> iskeyword("for")
True
>>> iskeyword("all")
False
>>>
The data item, kwlist contains a list of all the current keywords in Python:
>>> from keyword import *
>>> print kwlist
[’and’, ’as’, ’assert’, ’break’, ’class’, ’continue’, ’def’, ’del’, ’elif’,
’else’, ’except’, ’exec’, ’finally’, ’for’, ’from’, ’global’, ’if’, ’import’,
’in’, ’is’, ’lambda’, ’not’, ’or’, ’pass’, ’print’, ’raise’, ’return’, ’try’,
’while’, ’with’, ’yield’]
>>>
We encourage you to check out http://docs.python.org/library/ to explore the extensive libraries
that come with Python. There are so many treasures to discover!
7.2 Triple quoted strings
In addition to the single and double quoted strings we ﬁrst saw in Lecture 2, Python also has triple quoted
strings . We will need triple quoted strings for Unit Testing (next section). Here are some examples:
>>> type("""This is a triple quoted string using 3 double quotes.""")
<type ’str’>
>>> type(’’’This triple quoted strings uses 3 single quotes.’’’)
<type ’str’>
>>>
Triple quoted strings can contain both single and double quotes inside them:
>>> print ’’’"Oh no", she exclaimed, "Ben’s bike is broken!"’’’
"Oh no", she exclaimed, "Ben’s bike is broken!"
>>>
64
Finally, triple quoted strings can span multiple lines:
>>> message = """This message will
... span several
... lines."""
>>> print message
This message will
span several
lines.
>>>
7.3 Unit testing with doctest
It is a common best practice in software development these days to include automatic unit testing of source
code. Unit testing provides a way to automatically verify that individual pieces of code, such as functions,
are working correctly. This makes it possible to change the implementation of a function at a later time
and quickly test that it still does what it was intended to do. Python has a built-in doctest module for
easy unit testing. Doctests can be written within a triple quoted string on the ﬁrst line of the body of a
function or script. They consist of sample interpreter sessions with a series of inputs to a Python prompt
followed by the expected output from the Python interpreter. The doctest module automatically runs any
statement beginning with >>> (followed by a space) and compares the following line with the output from
the interpreter. To see how this works, put the following in a script named firstdoctest.py1:
defis_divisible_by_2_or_5(n):
"""
>>> is_divisible_by_2_or_5(8)
True
"""
if__name__ == "__main__":
importdoctest
doctest.testmod()
The last three lines are what make doctest run. Put them in the main routine of any ﬁle that includes
doctests. Running the script will produce the following output:
**********************************************************************
File "myfunctions.py", line 3, in __main__.is_divisible_by_2_or_5
Failed example:
is_divisible_by_2_or_5(8)
Expected:
True
Got nothing
**********************************************************************
1 items had failures:
1 of 1 in __main__.is_divisible_by_2_or_5
***Test Failed ***1 failures.
This is an example of a failing test . The test says: if you call isdivisible by2or5(8) the result
1There are four underscores in name , two at the start and two at the end.
65
should be True . Sinceisdivisible by2or5as written doesn’t return anything at all, the test fails,
and doctest tells us that it expected True but got nothing.
We can make this test pass by returning True:
defis_divisible_by_2_or_5(n):
"""
>>> is_divisible_by_2_or_5(8)
True
"""
returnTrue
if__name__ == "__main__":
importdoctest
doctest.testmod()
If we run it now, there will be no output, which indicates that the test passed. Note again that the doctest
string must be placed immediately after the function deﬁnition header in order to run. To see more detailed
output, add the keyword argument verbose=True to thetestmod method call
doctest.testmod(verbose=True)
and run the module again. This will produce output showing the result of running the tests and whether
they pass or not.
Trying:
is_divisible_by_2_or_5(8)
Expecting:
True
ok
1 items had no tests:
__main__
1 items passed all tests:
1 tests in __main__.is_divisible_by_2_or_5
1 tests in 2 items.
1 passed and 0 failed.
Test passed.
While the test passed, our test suite is clearly inadequate, since isdivisible by2or5will now return
True no matter what argument is passed to it. Here is a completed version with a more complete test suite
and code that makes the tests pass:
66
defis_divisible_by_2_or_5(n):
"""
>>> is_divisible_by_2_or_5(8)
True
>>> is_divisible_by_2_or_5(7)
False
>>> is_divisible_by_2_or_5(5)
True
>>> is_divisible_by_2_or_5(9)
False
"""
returnn % 2 == 0 orn % 5 == 0
if__name__ == "__main__":
importdoctest
doctest.testmod()
Run the module again and see what you get.
7.4 Good Practice Development
The difﬁcult part of programming, ironically, is not the programming part. The difﬁcult part is the problem
solving part. That is, deciding how to solve the problem at hand. Most programming problems can be
solved by splitting the problem into smaller problems until you get to problems you can solve. Then you
join up those smaller solutions to solve the larger problem. Of course, it is not always obvious to know how
to split up a large problem and this is where experience and practice plays a key role. Nevertheless, here
are some things you can try when presented with a problem you have no idea how to solve.
Try splitting the problem into two sub-problems, and progressively split each sub-problem until you know
how to solve something. For example:
1. Count the number of “the”s in a string.
(a) split the string into separate words
(b) count the number of words that are equal to “the”
i. test if a single word equals “the”
ii. scan a list of words and keep count of those that equal “the”
Even if you don’t know how to solve a given sub-problem, and you can’t think of how to split it further, at
least you have a better chance of discovering how to solve a simpler problem (either by asking someone, or
asking Google for example).
There are also simple rules to follow when you are developing your own test cases. You should include:
• typical input
• atypical input (e.g. input at the extreme edge of allowable input)
• incorrect or invalid input
• the simplest type of input (if that makes sense)
• the most complicated type of input (if that makes sense)
67
• enough tests so that each line of code is exercised at least once in your test set (this is called test
coverage).
7.5 Test-driven development demonstrated
At this point in the lecture, the lecturer will demonstrate how test-driven development should be used. We
will use the extension exercise from Lecture 6 as our example.
7.6 Programming with style
Readability is very important to programmers, since in practice programs are read and modiﬁed far more
often then they are written. All the code examples in this book will be consistent with the Python Enhance-
ment Proposal 8 (PEP 8), a style guide developed by the Python community. We’ll have more to say about
style as our programs become more complex, but a few pointers will be helpful already:
• use 4 spaces for indentation
• imports should go at the top of the ﬁle
• separate function deﬁnitions with two blank lines
• keep function deﬁnitions together
• keep top level statements, including function calls, together in the main routine of the program
• use Test-driven development to develop your programs (this is not part of PEP 8, but is more a phi-
losophy of software development).
7.7 Glossary
unit testing: An automatic procedure used to validate that individual units of code are working properly.
Python has doctest built in for this purpose.
module: A ﬁle containing Python deﬁnitions and statements intended for use in other Python programs.
The contents of a module are made available to the other program by using the import statement.
standard library: A library is a collection of software used as tools in the development of other software.
The standard library of a programming language is the set of such tools that are distributed with the
core programming language. Python comes with an extensive standard library.
import statement: A statement which makes the objects contained in a module available for use. There
are three forms for the import statement. Using a hypothetical module named mymod containing
functionsf1andf2, and variables v1andv2, examples of these three forms include:
importmymod
and:
frommymod importf1, f2, v1, v2
68
and:
frommymod import*
namespace: A syntactic container providing a context for names so that the same name can reside in dif-
ferent namespaces without ambiguity. In Python, modules, classes, functions and methods all form
namespaces.
naming collision: A situation in which two or more names in a given namespace cannot be unambiguously
resolved. Using
importmymodule
instead of
frommymodule import*
prevents naming collisions.
attribute: A variable deﬁned inside a module. Module attributes are accessed by using the dot operator
(.).
dot operator: The dot operator (.) permits access to attributes and functions of a module.
docstring A string constant on the ﬁrst line of a function or module deﬁnition (and as we will see later, in
class and method deﬁnitions as well). Docstrings provide a convenient way to associate documenta-
tion with code. Docstrings are also used by the doctest module for automated testing.
69
7.8 Laboratory exercises
All of the exercises below should be added to a ﬁle named doctest ex.py that contains the following in
the main routine:
if__name__ == "__main__":
importdoctest
doctest.testmod(verbose=True)
After completing each exercise in turn, run the program to conﬁrm that the doctests for your new function
pass.
1. Write a compare function that returns 1ifa>b,0ifa == b , and-1ifa<b.
defcompare(a, b):
"""
Returns 1 if a>b, 0 if a equals b, and -1 if a<b
>>> compare(5, 4)
1
>>> compare(7, 7)
0
>>> compare(2, 3)
-1
>>> compare(42, 1)
1
"""
# Your function body should begin here.
Fill in the body of the function so the doctests pass.
2. Use incremental development to write a function called hypotenuse that returns the length of the
hypotenuse of a right triangle given the lengths of the other two sides as parameters. Record each
stage of the incremental development process as you go.
defhypotenuse(a, b):
"""
Compute the hypotenuse of a right triangle with sides of length a
and b.
>>> hypotenuse(3, 4)
5.0
>>> hypotenuse(12, 5)
13.0
>>> hypotenuse(7, 24)
25.0
>>> hypotenuse(9, 12)
15.0
"""
When you are ﬁnished add your completed function with the doctests to doctest ex.py and con-
ﬁrm that the doctests pass.
3. Write a body for the function deﬁnition of fahrenheit tocelsius designed to return the integer
value of the nearest degree Celsius for a given temperature in Fahrenheit. Use your favourite web
search engine to ﬁnd the equation for doing the conversion if you don’t already know it. ( Hint: you
70
may want to make use of the built-in function, round . Try typing help(round) in a Python shell
and experimenting with round until you are comfortable with how it works.)
deffahrenheit_to_celsius(t):
"""
>>> fahrenheit_to_celsius(212)
100
>>> fahrenheit_to_celsius(32)
0
>>> fahrenheit_to_celsius(-40)
-40
>>> fahrenheit_to_celsius(36)
2
>>> fahrenheit_to_celsius(37)
3
>>> fahrenheit_to_celsius(38)
3
>>> fahrenheit_to_celsius(39)
4
"""
4. Add a function body for celsius tofahrenheit to convert from Celsius to Fahrenheit.
defcelsius_to_fahrenheit(t):
"""
>>> celsius_to_fahrenheit(0)
32
>>> celsius_to_fahrenheit(100)
212
>>> celsius_to_fahrenheit(-40)
-40
>>> celsius_to_fahrenheit(12)
54
>>> celsius_to_fahrenheit(18)
64
>>> celsius_to_fahrenheit(-48)
-54
"""
5.Extension Exercise: Write a function to convert kilograms to pounds. Devise a sensible test suite for
your function.
6.Extension Exercise: Write a function that takes the width, height and depth of a cuboid and returns
its surface area. It should return -1 if an argument is negative. Devise a sensible test suite for your
function.
71
7.Extension Exercise: Write a function that returns the volume of a square based pyramid. It should take as
arguments the length of a bottom edge and the height. It should return -1 if either parameter is less than 0.
Your function should pass the doctests below.
defvol_of_a_pyramid(edge, height):
"""
>>> vol_of_a_pyramid(0, 3)
0.0
>>> vol_of_a_pyramid(3, 0)
0.0
>>> vol_of_a_pyramid(2, 3)
4.0
>>> vol_of_a_pyramid(4, 3)
16.0
>>> vol_of_a_pyramid(6, 4)
48.0
>>> vol_of_a_pyramid(5, 4.5)
37.5
>>> vol_of_a_pyramid(-2, 4)
-1
>>> vol_of_a_pyramid(2, -4)
-1
"""
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
72
Lecture 8
Strings part 1
8.1 A compound data type
So far we have seen a number of types, including: int,float ,bool ,NoneType andstr. Strings are
qualitatively different from the ﬁrst four because they are made up of smaller pieces—characters. Types
that comprise smaller pieces are called compound data types . Depending on what we are doing, we may
want to treat a compound data type as a single thing, or we may want to access its parts. This ﬂexibility is
useful.
The bracket operator selects a single character from a string:
>>> fruit = "banana"
>>> letter = fruit[1]
>>> print letter
The expression fruit[1] selects character number 1 from fruit . The variable letter refers to the result.
When we display letter , we get a surprise:
a
The ﬁrst letter of “banana” is not a, unless you are a computer scientist. For perverse reasons, computer
scientists always start counting from zero. The 0thletter of “banana” is b. The ﬁrst letter is a, and the second
letter isn. If you want the 0thletter of a string, you just put 0, or any expression with the value 0, in the
brackets:
>>> letter = fruit[0]
>>> print letter
b
The expression in brackets is called an index . An index speciﬁes a member of an ordered list, in this case
the list of characters in the string. The index indicates which one you want, hence the name. It can be any
integer expression.
8.2 Length
Thelen function returns the number of characters in a string:
73
>>> fruit = "banana"
>>> len(fruit)
6
To get the last letter of a string, you might be tempted to try something like this:
length = len(fruit)
last = fruit[length] # ERROR!
That won’t work. It causes the runtime error IndexError: string index out of range . The reason
is that there is no 6th letter in “banana”. Since we started counting at zero, the six letters are numbered 0 to
5. To get the last character, we have to subtract 1 from length:
length = len(fruit)
last = fruit[length-1]
Alternatively, we can use negative indices, which count backward from the end of the string. The expression
fruit[-1] yields the last letter, fruit[-2] yields the second to last, and so on.
8.3 String slices
A substring of a string is called a slice . Selecting a slice is similar to selecting a character:
>>> s = "Peter, Paul, and Mary"
>>> print s[0:5]
Peter
>>> print s[7:11]
Paul
>>> print s[17:21]
Mary
The operator [n:m] returns the part of the string from the nthcharacter to the mthcharacter, including the
ﬁrst but excluding the last. If you ﬁnd this behaviour counterintuitive it might make more sense if you
imagine the indices pointing between the characters, as in the following diagram:
fruit b a n n a a ’
0 1 2 3 4 5 6 index’
If you omit the ﬁrst index (before the colon), the slice starts at the beginning of the string. If you omit the
second index, the slice goes to the end of the string. Thus:
>>> fruit = "banana"
>>> fruit[:3]
’ban’
>>> fruit[3:]
’ana’
What do you think s[:] means?
74
8.4 String comparison
The comparison operators work on strings. To see if two strings are equal:
ifword == "banana":
print"Yes, we have no bananas!"
Other comparison operations are useful for putting words in alphabetical order:
ifword < "banana":
print"Your word," + word + ", comes before banana."
elifword > "banana":
print"Your word," + word + ", comes after banana."
else:
print"Yes, we have no bananas!"
You should be aware, though, that Python does not handle upper- and lowercase letters the same way that
people do. All the uppercase letters come before all the lowercase letters. As a result:
Your word, Zebra, comes before banana.
A common way to address this problem is to convert strings to a standard format, such as all lowercase,
before performing the comparison. A more difﬁcult problem is making the program realize that zebras are
not fruit.
8.5 Strings are immutable
It is tempting to use the [] operator on the left side of an assignment, with the intention of changing a
character in a string. For example:
greeting = "Hello, world!"
greeting[0] = "J" # ERROR!
printgreeting
Instead of producing the output Jello, world! , this code produces the runtime error TypeError:
’str’ object doesn’t support item assignment . Strings are immutable , which means you can’t
change an existing string. The best you can do is create a new string that is a variation on the original:
greeting = "Hello, world!"
newGreeting = "J" + greeting[1:]
printnewGreeting
The solution here is to concatenate a new ﬁrst letter onto a slice of greeting. This operation has no effect on
the original string.
Do you think the following will work?
greeting = "Hello, world!"
greeting = "J" + greeting[1:]
printgreeting
75
8.6 Traversal and the for loop
Recall (on page 3) we said that all programming languages allowed you to perform a few basic operations:
get input, display output, do math, do conditional execution and then there was just one more thing. The
last thing we need to add to the list is repetition , the ability to loop through a set of statements repeatedly.
We will look at this in a lot more detail later (Lectures 10 and 11) but there is a special type of loop that
is particularly useful with strings (and other compound types) which is worth introducing while we are
looking at strings.
A lot of computations involve processing a string one character at a time. Often they start at the beginning,
select each character in turn, do something to it, and continue until the end. This pattern of processing is
called a traversal . Python provides a very useful language feature for traversing many compound types—
thefor loop:
forchar infruit:
printchar
The above piece of code can be understood as an abbreviated version of an English sentence: “For each
character in the string fruit, print out the character”. The for loop is an example of an iterator : something
that visits or selects every element in a structure (in this case a string), usually in turn. The for loop also
works on other compound types such as lists and tuples, which we will look at later.
The following example shows how to use concatenation and a for loop to generate an abecedarian series.
Abecedarian refers to a series or list in which the elements appear in alphabetical order. For example, in
Robert McCloskey’s book Make Way for Ducklings , the names of the ducklings are Jack, Kack, Lack, Mack,
Nack, Ouack, Pack, and Quack. This loop outputs these names in order:
prefixes = "JKLMNOPQ"
suffix = "ack"
forletter inprefixes:
printletter + suffix
The output of this program is:
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
Of course, that’s not quite right because Ouack and Quack are misspelled. You’ll ﬁx this as an exercise
below.
8.7 The inoperator
Theinoperator tests if one string is a substring of another:
76
>>> "p" in "apple"
True
>>> "i" in "apple"
False
>>> "ap" in "apple"
True
>>> "pa" in "apple"
False
Note that a string is a substring of itself:
>>> "a" in "a"
True
>>> "apple" in "apple"
True
Combining the inoperator with string concatenation using +, we can write a function that removes all the
vowels from a string:
defremove_vowels(s):
# vowels contains all the letters we want to remove
vowels = "aeiouAEIOU"
s_without_vowels = ""
# scan through each letter in the input string
forletter ins:
# check if the letter is not in the disallowed list of letters
ifletter not invowels:
# the letter is allowed, add it to the result
s_without_vowels += letter
returns_without_vowels
Test this function to conﬁrm that it does what we wanted it to do.
8.8 Looping and counting
The following program counts the number of times the letter aappears in a string and is an example of a
counter pattern (more counter patterns will be encountered (ha ha) in Lecture 10):
fruit = "banana"
count = 0
forchar infruit:
ifchar == "a":
count += 1
printcount
8.9 str Methods
In addition to the functions that we have seen so far there is also a special type of function called a method .
You can think of a method as a function which is attached to a certain type of variable (e.g. a string).
When calling a function you just need the name of the function followed by parentheses (possibly with
77
some arguments inside). In contrast a method also needs to be associated with a variable (also called an
object). The syntax that is used is the variable (or object) name or a value followed by a dot followed by the
name of the method along with possibly some arguments in parentheses like this:
VARIABLE.METHODNAME(ARGUMENTS)
You can see that it looks just like a function call except for the variable name and the dot at the start.
Compare how the len function and the upper method are used below.
>>> my_str = "hello world"
>>> len(my_str)
11
>>> my_str.upper()
’HELLO WORLD’
Thelen function returns the length of the sequence which is given as an argument. The upper method
returns a new string which is the same as the string that it is called upon except that each character has
been converted to uppercase. In each case the original string remains unchanged.
An example of a method which needs an argument to operate on is the count method.
>>> my_str = "the quick brown fox jumps over the lazy dog."
>>> my_str.count("the")
2
>>> my_str.count("hello")
0
>>> my_str.count("e")
3
The count method returns the number of times the string given as an argument occurs within the string
that it is called upon. But what about the following:
>>> ms = "ahaha"
>>> ms.count("aha")
Thestr type contains useful methods that manipulate strings. To see what methods are available, use the
dir function with str as an argument.
>>> dir(str)
which will return the list of items associated with strings:
[’__add__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__doc__’,
’__eq__’, ’__ge__’, ’__getattribute__’, ’__getitem__’,
’__getnewargs__’, ’__getslice__’, ’__gt__’, ’__hash__’, ’__init__’,
’__le__’, ’__len__’, ’__lt__’, ’__mod__’, ’__mul__’, ’__ne__’,
’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__rmod__’,
’__rmul__’, ’__setattr__’, ’__str__’, ’capitalize’, ’center’,
’count’, ’decode’, ’encode’, ’endswith’, ’expandtabs’, ’find’,
’index’, ’isalnum’, ’isalpha’, ’isdigit’, ’islower’, ’isspace’,
’istitle’, ’isupper’, ’join’, ’ljust’, ’lower’, ’lstrip’,
’partition’, ’replace’, ’rfind’, ’rindex’, ’rjust’, ’rpartition’,
’rsplit’, ’rstrip’, ’split’, ’splitlines’, ’startswith’, ’strip’,
’swapcase’, ’title’, ’translate’, ’upper’, ’zfill’]
To ﬁnd out more about an item in this list, we can use the help command:
78
>>> help(str.capitalize)
Help on method_descriptor:
capitalize(...)
S.capitalize() -> string
Return a copy of the string S with only its first character
capitalized.
We can call any of these methods using dot notation :
>>> s = "brendan"
>>> s.capitalize()
’Brendan’
str.find is a useful method for ﬁnding substrings in a string. To ﬁnd out more about it, we can print out
itsdocstring ,doc , which contains documentation on the function:
>>> print str.find.__doc__
S.find(sub [,start [,end]]) -> int
Return the lowest index in S where substring sub is found,
such that sub is contained within s[start,end]. Optional
arguments start and end are interpreted as in slice notation.
Return -1 on failure.
Calling the help function also prints out the docstring:
>>> help(str.find)
Help on method_descriptor:
find(...)
S.find(sub [,start [,end]]) -> int
Return the lowest index in S where substring sub is found,
such that sub is contained within s[start,end]. Optional
arguments start and end are interpreted as in slice notation.
Return -1 on failure.
The parameters in square brackets are optional parameters. We can use str.find to ﬁnd the location of a
character in a string:
>>> fruit = "banana"
>>> index = fruit.find("a")
>>> print index
1
Or a substring:
>>> fruit.find("na")
2
79
It also takes an additional argument that speciﬁes the index at which it should start:
>>> fruit.find("na", 3)
4
And has a second optional parameter specifying the index at which the search should end:
>>> "bob".find("b", 1, 2)
-1
In this example, the search fails because the letter bdoes not appear in the index range from 1 to 2 (not
including 2).
8.10 Glossary
compound data type: A data type in which the values are made up of components, or elements, that are
themselves values.
index: A variable or value used to select a member of an ordered set, such as a character from a string.
traverse: To iterate through the elements of a set, performing a similar operation on each.
slice: A part of a string (substring) speciﬁed by a range of indices. More generally, a subsequence of any
sequence type in Python can be created using the slice operator ( sequence [start :stop]).
immutable: A compound data types whose elements can not be assigned new values.
method: A function that is attached to a particular type and can be accessed via dot notation. For example
‘‘monday’’.upper()
80
8.11 Laboratory exercises
1. Replace the ’?’ to achieve the shown output.
>>> saying = "Be as happy as possible"
>>> saying[?:?]
’Be’
>>> saying[?:?]
’happy’
>>> saying[?:?]
’Be as happy as possible’
>>> print ? # use slices and concatenation
’Be as happy as humanly possible’
>>> print ? # use concatenation and len() function
The number of letters in saying is: 23
2. Write a function onmanylines that takes a string as an argument and uses a for loop to print the
letter one per line. For example:
>>> on_many_lines("banana")
b
a
n
a
n
a
3. Record the output after executing the following statements:
>>> saying = "Be as happy as possible"
>>> saying.swapcase()
>>> saying.upper()
>>> saying.count("e")
>>> saying[0].isupper()
>>> saying[:2].isalpha()
4. Modify:
prefixes = "JKLMNOPQ"
suffix = "ack"
forletter inprefixes:
printletter + suffix
so that Ouack and Quack are spelled correctly. You will need to use an ifstatement inside the for
loop to decide if a different sufﬁx is needed.
5. Encapsulate (or wrap):
81
fruit = "banana"
count = 0
forchar infruit:
ifchar == "a":
count += 1
printcount
in a function named countletters , and generalise it so that it accepts the string and the letter as ar-
guments. When you are ﬁnished you will be able to call the function like this: countletters("banana",
"a") to count the ’a’s in ’banana’ or like this: countletters("fruit fly", "f") to count the
’f’s in ’fruit ﬂy’ and so on.
6. Write a function onlyupper that takes a string as an argument and uses a for loop to print only the
uppercase letters. For example:
>>> saying = "Be As Happy As Possible"
>>> only_upper(saying)
BAHAP
You will need to use the isupper method. See help(str.isupper) for more information.
7. Create a ﬁle named stringtools.py and put the following in it:
defremove_letter(letter, strng):
"""
>>> remove_letter("a", "apple")
'pple'
>>> remove_letter("a", "banana")
'bnn'
>>> remove_letter("z", "banana")
'banana'
>>> remove_letter("i", "Mississippi")
'Msssspp'
"""
Write a function body for it that will make it work as indicated by the doctests.
8. Include reverse instringtools.py .
defreverse(s):
"""
>>> reverse("happy")
'yppah'
>>> reverse("Python")
'nohtyP'
>>> reverse("")
''
>>> reverse("P")
'P'
"""
if__name__ == "__main__":
importdoctest
doctest.testmod(verbose=True)
Add a function body to reverse to make the doctests pass.
82
9. Addmirror tostringtools.py .
defmirror(s):
"""
>>> mirror("good")
'gooddoog'
>>> mirror("yes")
'yessey'
>>> mirror("Python")
'PythonnohtyP'
>>> mirror("")
''
>>> mirror("a")
'aa'
"""
Write a function body for it that will make it work as indicated by the doctests.
10.Extension Exercise: Write a function removeduplicates which takes a string argument and returns
a string which is the same as the argument except only the ﬁrst occurrence of each letter is present.
Make your function case sensitive, and ensure that it passes the doctests below.
defremove_duplicates(strng):
"""
>>> remove_duplicates("apple")
'aple'
>>> remove_duplicates("Mississippi")
'Misp'
>>> remove_duplicates("The quick brown fox jumps over the lazy dog")
'The quick brown fx jmps v t lazy dg'
"""
11.Extension Exercise: Convert a date read from the user, given in DD/MM/YYYY format into written
format. For example, here’s a run of how the program might work:
Enter a date in DD/MM/YY format: 16/7/2003
Output: 16th July, 2003
There are two problems to solve here: converting a numeric month into the name for the month, and
getting the correct sufﬁx to the day (st, nd, rd, th). Both problems can be solved with judicious use of
lists.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
83
84
Lecture 9
Files and modules
Remember at the start of the course we said that programs are made up of instructions which only perform
a handful of operations1. The ﬁrst two of these operations were input and output. Input involves getting
data from the keyboard, a ﬁle, or some other device. Output is concerned with displaying data on the
screen or sending data to a ﬁle or other device.
We have already seen how to generate output to the screen and get input from the keyboard. In this lecture
we are going to look at getting input from a ﬁle and generating output to a ﬁle.
9.1 Files
While a program is running, its data is stored in random access memory (RAM ). RAM is fast and inexpensive,
but it is also volatile , which means that when the program ends, or the computer shuts down, data in RAM
disappears. To make data available the next time you turn on your computer and start your program, you
have to write it to a non-volatile storage medium, such as a hard drive, USB drive, or optical disk. Data on
non-volatile storage media is stored in named locations called ﬁles . By reading and writing ﬁles, programs
can save information between program runs.
Working with ﬁles is a lot like working with a notebook. To use a notebook, you have to open it. When
you’re done, you have to close it. While the notebook is open, you can either write in it or read from it. In
either case, you know where you are in the notebook. You can read the whole notebook in its natural order
or you can skip around. All of this applies to ﬁles as well. To open a ﬁle, you specify its name and indicate
whether you want to read or write.
Opening a ﬁle creates a ﬁle object. In this example, the variable myfile refers to the new ﬁle object.
>>> myfile = open("test.txt", "w")
>>> print myfile
<open file ’test.txt’, mode ’w’ at 0x87bb608>
Theopen function takes two arguments. The ﬁrst is the name of the ﬁle, and the second is the mode . Mode
"w" means that we are opening the ﬁle for writing. If there is no ﬁle named test.txt , it will be created.
If there already is one, it will be replaced by the ﬁle we are writing. When we print the ﬁle object, we see
the name of the ﬁle, the mode, and the location of the object in memory. To put data in the ﬁle we invoke
thewrite method on the ﬁle object:
1See the list back on page 3 to refresh your memory.
85
>>> myfile.write("Now is the time")
>>> myfile.write("to close the file")
Closing the ﬁle tells the system that we are done writing and makes sure that everything actually gets
written to disk.
>>> myfile.close()
Now we can open the ﬁle again, this time for reading, and read the contents into a string. This time, the
mode argument is "r" for reading:
>>> myfile = open("test.txt", "r")
Actually the second argument is optional, since the default mode when opening a ﬁle is "r". So we could
have just done:
>>> myfile = open("test.txt")
If we try to open a ﬁle for reading that doesn’t exist, we get an error:
>>> myfile = open("toast.txt")
IOError: [Errno 2] No such file or directory: ’toast.txt’
Not surprisingly, the read method of a ﬁle reads data from the ﬁle. With no arguments, it reads the entire
contents of the ﬁle into a single string:
>>> text = myfile.read()
>>> print text
Now is the timeto close the file
There is no space between time andtobecause we did not write a space between the strings.
Theread method can also take an argument that indicates how many characters to read:
>>> myfile = open("test.txt")
>>> print myfile.read(5)
Now i
If not enough characters are left in the ﬁle, read returns the remaining characters. When we get to the end
of the ﬁle, read returns the empty string:
>>> print myfile.read(1000006)
s the timeto close the file
>>> print myfile.read()
>>>
9.2 Processing things from a ﬁle
You would normally read information from a ﬁle in a Python program because you want to do something
with it. Let’s try counting the number of words in a ﬁle. Here is a short ﬁle for us to work with.
86
Mary had a little lamb
little lamb little lamb
Mary had a little lamb
its fleece was white as snow
and everywhere that Mary went
Mary went Mary went
everywhere that Mary went
the lamb was sure to go
We can start by opening the ﬁle and reading its contents into a string.
>>> myfile = open("mary.txt")
>>> text_string = myfile.read()
>>> text_string
’Mary had a little lamb\nlittle lamb little lamb\nMary had a little
lamb\nits fleece was white as snow\nand everywhere that Mary
went\nMary went Mary went\neverywhere that Mary went\nthe lamb was
sure to go\n’
Those funny little nncharacters which you can see in textstring represent newlines in the ﬁle.
Now that we have the entire ﬁle in textstring we can use split to get a listof words from the string.
Alist is another python sequence type and has many properties similar to a string. A list is designated
by comma separated values of any type surrounded by square braces. We will see more of lists in Lecture
13, but for now just think of them as a sequence of values. Once we have a list, we can use the len function
to tell us how many items are in the list. The number of items in the list will be exactly the same as the
number of words in the ﬁle.
>>> word_list = text_string.split()
>>> word_list
[’Mary’, ’had’, ’a’, ’little’, ’lamb’, ’little’, ’lamb’, ’little’,
’lamb’, ’Mary’, ’had’, ’a’, ’little’, ’lamb’, ’its’, ’fleece’, ’was’,
’white’, ’as’, ’snow’, ’and’, ’everywhere’, ’that’, ’Mary’, ’went’,
’Mary’, ’went’, ’Mary’, ’went’, ’everywhere’, ’that’, ’Mary’, ’went’,
’the’, ’lamb’, ’was’, ’sure’, ’to’, ’go’]
>>> len(word_list)
39
What if we wanted to create a new ﬁle which contained a poem about John instead of Mary? We already
have the poem about Mary in textstring so all we need to do is change every occurrence of Mary to
John and then write the new poem to a ﬁle.
>>> new_poem = text_string.replace("Mary", "John")
>>> new_poem
’John had a little lamb\nlittle lamb little lamb\nJohn had a little
lamb\nits fleece was white as snow\nand everywhere that John
went\nJohn went John went\neverywhere that John went\nthe lamb was
sure to go\n’
>>> myfile = open("john.txt", "w")
>>> myfile.write(new_poem)
>>> myfile.close()
87
9.3 Directories
Files on non-volatile storage media are organized by a set of rules known as a ﬁle system . File systems
are made up of ﬁles and directories , which are containers for both ﬁles and other directories. When you
create a new ﬁle by opening it and writing, the new ﬁle goes in the current directory (wherever you were
when you ran the program). Similarly, when you open a ﬁle for reading, Python looks for it in the current
directory.
If you open a python interpreter with IDLE, the current working directory may not be where you think. To
ﬁnd out what directory we’re currently in, we need to use the osmodule which holds information about
various aspects of the operating system. Here is what happens on my Linux machine:
>>> import os
>>> os.getcwd()
’/home/cshome/m/mccane/’
/home/cshome/m/mccane/ is Brendan’s home directory and happens to be where I started IDLE from.
If you want to open a ﬁle somewhere else, you have to specify the path to the ﬁle, which is the name of the
directory (or folder) where the ﬁle is located:
>>> wordsfile = open("/usr/share/dict/words", "r")
>>> wordlist = wordsfile.readlines()
>>> print wordlist[:5]
[’\n’, ’A\n’, "A’s\n", ’AOL\n’, "AOL’s\n", ’Aachen\n’]
This example opens a ﬁle named words that resides in a directory named dict , which resides in share ,
which resides in usr, which resides in the top-level directory of the system, called /. It then reads in each
line into a list using readlines , and prints out the ﬁrst 5 elements from that list. You cannot use /as part of
a ﬁlename; it is reserved as a delimiter between directory and ﬁlenames. The ﬁle /usr/share/dict/words
should exist on unix based systems, and contains a list of words in alphabetical order.
Alternatively, you can change the current working directory using the method os.chdir(DIRECTORYNAME) ,
whereDIRECTORYNAME is a string indicating the new directory. For example, to change the current work-
ing directory to your home directory, try the following:
>>> import os
>>> os.chdir(os.path.expanduser("˜"))
’/home/cshome/m/mccane’
>>> os.getcwd()
’/home/cshome/m/mccane’
The function os.path.expanduser("˜") returns a string representing your home directory.
9.4 Files as a Unifying Concept
The Unix operating system was introduced in 1969, and with it ﬁles became the unifying concept for
non-volatile storage and network communication. Most modern operating systems and programming lan-
guages have adopted the ﬁle as the unifying concept of storage and communication. As an example, we
are going to use web pages to show the usefulness of ﬁles and several other concepts.
For this example, we are going to make use of the Python module urllib22. Usingurllib2 and the ﬁle
2urllib2 is a Python 2.x module. In Python 3.x, the functionality is split over several libraries. The simplest is urllib.request
88
concept makes reading webpages trivial. Here’s a very simple bit of code that reads and then prints out an
entire webpage:
importurllib2
pagefile = urllib2.urlopen("http://www.cs.otago.ac.nz")
page = pagefile.read()
printpage
Which results in output that looks a bit like the following (well, the ﬁrst part does):
!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>Department of Computer Science</title>
<link rel="stylesheet" href="/site/css/cssite.css" type="text/css" />
</head>
...
Note thaturllib2.urlopen behaves very similar to open , andpagefile acts just like a ﬁle opened for
reading. Essentially, this is pretty much what a web-browser does. It goes and gets a web page (as a ﬁle),
and then displays the result. What distinguishes most web-browsers though is how it does the displaying
- we won’t go into that here.
Now that we have the whole page in a string, we can start to do some pretty interesting things with it. For
example, we might want to split the string into it’s constituent words:
>>> words = page.split()
>>> words
[’<!DOCTYPE’, ’html’, ’PUBLIC’, ’"-//W3C//DTD’, ’XHTML’, ’1.0’, ...]
OK, so perhaps not so interesting yet, but we might be interested in only those words which have the string
“http” in them:
>>> for word in words:
... if "http" in word:
... print word
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
xmlns="http://www.w3.org/1999/xhtml"
http-equiv="content-type"
href="http://www.otago.ac.nz">
href="http://www.cs.otago.ac.nz/student/papers.php">here</a>.
href="http://www.ict.org.nz/index.php/04112009_ict-skills-shortage-confirmed">the
href="http://www.otago.ac.nz">University
That’s not quite what I’d like to extract. What I really want is just the string with the “http” bit in it. I’m
going to cheat a bit here and redo my split just for the current purpose3. Here’s the new code:
3Python also has a library for parsing (that’s kind of what we’re doing here) web pages. It’s called HTMLParser . In general, it
would be better to make use of HTMLParser , but that would overcomplicate matters at the moment.
89
>>> words2 = page.split(’"’) # split at quotes
>>> for word in words2:
... if "http://" in word:
... print word
http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd
http://www.w3.org/1999/xhtml
http://www.otago.ac.nz
http://www.cs.otago.ac.nz/student/papers.php
http://www.ict.org.nz/index.php/04112009_ict-skills-shortage-confirmed
http://www.otago.ac.nz
Now the only strings printed are those which are urls. A program that can scan a web page and extract the
urls could be useful for: crawling the web, building a search engine, downloading just your favourite web
pages without having to use a browser, or any number of things.
9.5 Glossary
volatile memory: Memory which requires an electrical current to maintain state. The main memory or RAM
of a computer is volatile. Information stored in RAM is lost when the computer is turned off.
non-volatile memory: Memory that can maintain its state without power. Hard drives, ﬂash drives, and
optical disks (CD or DVD) are each examples of non-volatile memory.
ﬁle: A named entity, usually stored on a hard drive, ﬂoppy disk, or CD-ROM, that contains a stream of
characters.
mode: A distinct method of operation within a computer program. Files in Python can be opened in one
of three modes: read (”r”), write (”w”), and append (”a”).
directory: A special type of ﬁle that contains other ﬁles (and directories).
path: A sequence of directory names that speciﬁes the exact location of a ﬁle.
text ﬁle: A ﬁle that contains printable characters organized into lines separated by newline characters.
list: A sequence of values separated by commas and surrounded by square braces. E.g. [1, 2, 3] or
[’comma’, ’separated’, ’values’] .
9.6 Laboratory exercises
1. Write a program/script that will open a ﬁle (you can specify the ﬁlename in your code) for reading
and print its contents to the screen.
2. Extend your program from the ﬁrst question so that it asks the user for a ﬁle to print, and then prints
out the contents of that ﬁle.
3. Extend your program so that it ﬁrst prints out all the ﬁles in the current working directory before
asking for a ﬁle to print. Hint: use theos.listdir(".") function to list the ﬁles in the current
directory (don’t forget to import os ﬁrst).
4. Put the code from Section 9.4 into a script and run it to see that it works. Now extend the program so
that it asks the user for a web-page to open, then opens it and prints all the links in that page.
90
5.Extension Exercise: Extend your answer from Question 3 so that if the requested ﬁle is a directory it
will list the contents of the directory instead of printing the contents of a ﬁle. Make use of the function
os.path.isdir to tell if a given ﬁle is a directory.
6.Extension Exercise: Modify your program from Question 4 so that it lists all links in the web page, then
prints all the links in one of those web pages as well.
7.Extension Exercise: Adaptfilmcritic.py from Exercise 12 and instead of printing the program’s
output to the screen, write it to a new ﬁle called newfile.txt . Make sure the output still contains
line breaks in the appropriate places.
8.Extension Exercise: Write a program that reads in a ﬁle and calculates the average word length. The
code at the end of Section 9.4 in the book is a good starting place.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
91
92
Lecture 10
Iteration: part 1
10.1 Multiple assignment
As you may have discovered, it is legal to make more than one assignment to the same variable. A new
assignment makes an existing variable refer to a new value (and stop referring to the old value).
bruce = 5
printbruce,
bruce = 7
printbruce
The output of this program is 5 7, because the ﬁrst time bruce is printed, his value is 5, and the second
time, his value is 7. The comma at the end of the ﬁrst print statement suppresses the newline after the
output, which is why both outputs appear on the same line. Here is what multiple assignment looks like
in a state diagram:
75bruce
With multiple assignment it is especially important to distinguish between an assignment operation and a
statement of equality. Because Python uses the equal sign ( =) for assignment, it is tempting to interpret a
statement like a = b as a statement of equality. It is not! First, equality is symmetric and assignment is not.
For example, in mathematics, if a= 7then 7 =a. But in Python, the statement a = 7 is legal and 7 = a is
not. Furthermore, in mathematics, a statement of equality is always true. If a=bnow, thenawill always
equalb. In Python, an assignment statement can make two variables equal, but they don’t have to stay that
way:
a = 5
b = a # a and b are now equal
a = 3 # a and b are no longer equal
The third line changes the value of abut does not change the value of b, so they are no longer equal.
(In some programming languages, a different symbol is used for assignment, such as <- or :=, to avoid
confusion.)
93
10.2 Updating variables
One of the most common forms of multiple assignment is an update, where the new value of the variable
depends on the old.
x = x + 1
This means get the current value of x, add one, and then update xwith the new value. If you try to update
a variable that doesn’t exist, you get an error, because Python evaluates the expression on the right side of
the assignment operator before it assigns the resulting value to the name on the left:
>>> x = x + 1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name ’x’ is not defined
Before you can update a variable, you have to initialize it, usually with a simple assignment:
>>> x = 0
>>> x = x + 1
>>>
Updating a variable by adding 1is called an increment ; subtracting 1is called a decrement .
10.3 Abbreviated assignment
Incrementing a variable is so common that Python provides an abbreviated syntax for it:
>>> count = 0
>>> count += 1
>>> count
1
>>> count += 1
>>> count
2
>>>
count += 1 is an abbreviation for count = count + 1 . The increment value does not have to be 1:
>>> n = 2
>>> n += 5
>>> n
7
>>>
Python also allows the abbreviations -=,*=,/=, and%=:
>>> n = 2
>>> n*= 5
>>> n
10
>>> n -= 4
94
>>> n
6
>>> n /= 2
>>> n
3
>>> n %= 2
>>> n
1
10.4 The while statement
Computers are often used to automate repetitive tasks. Repeating identical or similar tasks without making
errors is something that computers do well and people do poorly. Repeated execution of a set of statements
is called iteration . Because iteration is so common, Python provides several language features to make it
easier. The ﬁrst feature we are going to look at is the while statement.
Here is a function called countdown that demonstrates the use of the while statement:
defcountdown(n):
whilen > 0:
printn
n = n-1
print"Blastoff!"
You can almost read the while statement as if it were English. It means, while nis greater than 0, continue
displaying the value of nand then reducing the value of nby1. When you get to 0, display the word
Blastoff! More formally, here is the ﬂow of execution for a while statement:
1. Evaluate the condition, yielding False orTrue .
2. If the condition is false, exit the while statement and continue execution at the next statement.
3. If the condition is true, execute each of the statements in the body and then go back to step 1.
The body consists of all of the statements below the header with the same indentation.
This type of ﬂow is called a loop because the third step loops back around to the top. Notice that if the
condition is false the ﬁrst time through the loop, the statements inside the loop are never executed. The
body of the loop should change the value of one or more variables so that eventually the condition becomes
false and the loop terminates. Otherwise the loop will repeat forever, which is called an inﬁnite loop . An
endless source of amusement for computer scientists is the observation that the directions on shampoo –
Lather, rinse, repeat – are an inﬁnite loop.
In the case of countdown , we can prove that the loop terminates because we know that the value of nis
ﬁnite, and we can see that the value of ngets smaller each time through the loop, so eventually we have to
get to0. In other cases, it is not so easy to tell:
defcollatz_sequence(n):
whilen != 1:
printn,
ifn % 2 == 0: # n is even
n = n / 2
else: # n is odd
n = n*3 + 1
95
The condition for this loop is n != 1 , so the loop will continue until nis1, which will make the condition
false. Each time through the loop, the program outputs the value of nand then checks whether it is even
or odd. If it is even, the value of nis divided by 2. If it is odd, the value is replaced by n*3 + 1 . For
example, if the starting value (the argument passed to collatz sequence ) is 3, the resulting sequence
is 3, 10, 5, 16, 8, 4, 2, 1. Since nsometimes increases and sometimes decreases, there is no obvious proof
thatnwill ever reach 1, or that the program terminates. For some particular values of n, we can prove
termination. For example, if the starting value is a power of two, then the value of n will be even each time
through the loop until it reaches 1. The previous example ends with such a sequence, starting with 16.
Particular values aside, the interesting question is whether we can prove that this program terminates for
allvalues ofn. So far, no one has been able to prove it ordisprove it!
10.5 Tracing a program
To write effective computer programs a programmer needs to develop the ability to trace the execution of a
computer program. Tracing involves simulating the computer and following the ﬂow of execution through
a sample program run, recording the state of all variables and any output the program generates after each
instruction is executed. To understand this process, let’s trace the call to collatz sequence(3) from the
previous section. At the start of the trace, we have a local variable, n(the parameter), with an initial value
of3. Since3is not equal to 1, thewhile loop body is executed. 3is printed and 3 % 2 == 0 is evaluated.
Since it evaluates to False , the else branch is executed and 3*3 + 1 is evaluated and assigned to n.
To keep track of all this as you hand trace a program, make a column heading on a piece of paper for each
variable created as the program runs and another one for output. Our trace so far would look something
like this:
n output
--- ------
3 3
10
Since10 != 1 evaluates to True , the loop body is again executed, and 10is printed. 10 % 2 == 0 is
true, so the ifbranch is executed and nbecomes5. By the end of the trace we have:
n output
--- ------
3 3
10 10
5 5
16 16
8 8
4 4
2 2
1
Tracing can be a bit tedious and error prone (that’s why we get computers to do this stuff in the ﬁrst place!),
but it is an essential skill for a programmer to have. From this trace we can learn a lot about the way our
code works. We can observe that as soon as nbecomes a power of 2, for example, the program will require
log2(n)executions of the loop body to complete. We can also see that the ﬁnal 1will not be printed as
output.
96
10.6 Counting digits
The following function counts the number of decimal digits in a positive integer expressed in decimal
format:
defnum_digits(n):
count = 0
whilen > 0:
count = count + 1
n = n / 10
returncount
A call tonumdigits(710) will return 3. Trace the execution of this function call to convince yourself
that it works. This function demonstrates another pattern of computation called a counter . The variable
count is initialized to 0and then incremented each time the loop body is executed. When the loop exits,
count contains the result – the total number of times the loop body was executed, which is the same as
the number of digits. If we wanted to only count digits that are either 0 or 5, adding a conditional before
incrementing the counter will do the trick:
defnum_zero_and_five_digits(n):
count = 0
whilen > 0:
digit = n % 10
ifdigit == 0 ordigit == 5:
count = count + 1
n = n / 10
returncount
Conﬁrm that numzeroandfivedigits(1055030250) returns 7.
10.7 Tables
One of the things loops are good for is generating tabular data. Before computers were readily available,
people had to calculate logarithms, sines and cosines, and other mathematical functions by hand. To make
that easier, mathematics books contained long tables listing the values of these functions. Creating the tables
was slow and boring, and they tended to be full of errors. When computers appeared on the scene, one of
the initial reactions was, “This is great! We can use the computers to generate the tables, so there will be no
errors.” That turned out to be true (mostly) but shortsighted. Soon thereafter, computers and calculators
were so pervasive that the tables became obsolete. Well, almost. For some operations, computers use tables
of values to get an approximate answer and then perform computations to improve the approximation. In
some cases, there have been errors in the underlying tables, most famously in the table the Intel Pentium
used to perform ﬂoating-point division.
Although a logtable is not as useful as it once was, it still makes a good example of iteration. The following
program outputs a sequence of values in the left column and 2 raised to the power of that value in the right
column:
x = 1
whilex < 13:
printx, "\t", 2 **x
x += 1
97
The string ’nt’ represents a tabcharacter. The backslash character in ’ nt’ indicates the beginning of an
escape sequence . Escape sequences are used to represent invisible characters like tabs and newlines. The
sequencenn represents a newline . An escape sequence can appear anywhere in a string; in this example,
the tab escape sequence is the only thing in the string. How do you think you represent a backslash in a
string?
As characters and strings are displayed on the screen, an invisible marker called the cursor keeps track of
where the next character will go. After a print statement, the cursor normally goes to the beginning of the
next line. The tab character shifts the cursor to the right until it reaches one of the tab stops. Tabs are useful
for making columns of text line up, as in the output of the previous program:
1 2
2 4
3 8
4 16
5 32
6 64
7 128
8 256
9 512
10 1024
11 2048
12 4096
Because of the tab characters between the columns, the position of the second column does not depend on
the number of digits in the ﬁrst column.
10.8 Glossary
multiple assignment: Making more than one assignment to the same variable during the execution of a
program.
initialization (of a variable): To initialize a variable is to give it an initial value, usually in the context of
multiple assignment. Since in Python variables don’t exist until they are assigned values, they are
initialized when they are created. In other programming languages this is not the case, and variables
can be created without being initialized, in which case they have either default or garbage values.
increment Both as a noun and as a verb, increment means to increase by 1.
decrement Decrease by 1.
iteration: Repeated execution of a set of programming statements.
loop: A statement or group of statements that execute repeatedly until a terminating condition is satisﬁed.
inﬁnite loop: A loop in which the terminating condition is never satisﬁed.
trace: To follow the ﬂow of execution of a program by hand, recording the change of state of the variables
and any output produced.
counter A variable used to count something, usually initialized to zero and incremented in the body of a
loop.
body: The statements inside a loop.
loop variable: A variable used as part of the terminating condition of a loop.
98
10.9 Laboratory exercises
When starting to write loops it can be easy to make a mistake and end up in an inﬁnite loop. If you ﬁnd
yourself in this situation you can exit from it by pressing Ctrl-C .
1. Recallnumdigits from page 97. What will numdigits(0) return? Modify it to return 1for this
case. Modify numdigits so that it works correctly with any integer value. Type the following into
a script.
defnum_digits(n):
"""
>>> num_digits(12345)
5
>>> num_digits(0)
1
>>> num_digits(-12345)
5
"""
if__name__ == "__main__":
importdoctest
doctest.testmod(verbose=True)
Add your function body to numdigits and conﬁrm that it passes the doctests, by running it.
2. Add the following to your script.
defnum_even_digits(n):
"""
>>> num_even_digits(123456)
3
>>> num_even_digits(2468)
4
>>> num_even_digits(1357)
0
>>> num_even_digits(2)
1
>>> num_even_digits(20)
2
"""
Write a body for numevendigits and run it to check that it works as expected.
3. Add the following to your program:
defprint_digits(n):
"""
>>> print_digits(13789)
9 8 7 3 1
>>> print_digits(39874613)
3 1 6 4 7 8 9 3
>>> print_digits(213141)
1 4 1 3 1 2
"""
Write a body for printdigits so that it passes the given doctests.
99
4. Create a ﬁle called numbers.txt that has an integer on every line. Modify the last few lines of your
script from the previous questions: comment out the doctest lines; and add lines which read data
from a ﬁle:
if__name__ == "__main__"
# import doctest
# doctest.testmod(verbose=True)
numfile = open("numbers.txt")
line = numfile.readline()
whileline:
printline,
line = numfile.readline()
numfile.close()
Unlike in the last chapter, when we read an entire ﬁle in at once using read orreadlines , here we
are reading one line at a time using the readline method. When we reach the end of the ﬁle then
while line: will evaluate to False and our loop will ﬁnish. Also notice the “ ,” at the end of the
print statement to prevent an extra newline from being added after each line.
Make the changes above to your script and run it to conﬁrm that it prints out the contents of the ﬁle
that gets read. Note that the ﬁle ( numbers.txt ) should be in the same directory that your script ﬁle
is saved in.
5. Add code to your script to call numdigits on each line of ’numbers.txt’ so that instead of print-
ing each line of the ﬁle it prints out the number of digits found on each line of the ﬁle.
6.Extension Exercise: Open a new script ﬁle and add the following:
if__name__ == "__main__":
importdoctest
doctest.testmod(verbose=True)
Write a function, isprime , which takes a single integer argument and returns True when the ar-
gument is a prime number andFalse otherwise. Add doctests to your function as you develop
it.
7.Extension Exercise: Write a function that ﬁnds all the prime numbers less than a given number:
defprime_numbers(n):
"""
>>> prime_numbers(10)
2 3 5 7
>>> prime_numbers(20)
2 3 5 7 11 13 17 19
"""
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
100
Lecture 11
Iteration: part 2
11.1 Two-dimensional tables
A two-dimensional table is a table where you read the value at the intersection of a row and a column. A
multiplication table is a good example. Let’s say you want to print a multiplication table for the values
from 1 to 6. A good way to start is to write a loop that prints the multiples of 2, all on one line:
i = 1
whilei <= 6:
print2*i, " ",
i += 1
print
The ﬁrst line initializes a variable named i, which acts as a counter or loop variable . As the loop executes,
the value of iincreases from 1 to 6. When iis 7, the loop terminates. Each time through the loop, it
displays the value of 2*i, followed by three spaces. Again, the comma in the print statement suppresses
the newline. After the loop completes, the second print statement starts a new line. The output of the
program is:
2 4 6 8 10 12
So far, so good. The next step is to encapsulate and generalize .
11.2 Encapsulation and generalization
Encapsulation is the process of wrapping a piece of code in a function, allowing you to take advantage of all
the things functions are good for. You have already seen two examples of encapsulation: printparity
in Lecture 5; and isdivisible in Lecture 6. Generalization means taking something speciﬁc, such as
printing the multiples of 2, and making it more general, such as printing the multiples of any integer. This
function encapsulates the previous loop and generalizes it to print multiples of n:
101
defprint_multiples(n):
i = 1
whilei <= 6:
printn*i, "\t",
i += 1
print
To encapsulate, all we had to do was add the ﬁrst line, which declares the name of the function and the
parameter list. To generalize, all we had to do was replace the value 2 with the parameter n. If we call this
function with the argument 2, we get the same output as before. With the argument 3, the output is:
3 6 9 12 15 18
With the argument 4, the output is:
4 8 12 16 20 24
By now you can probably guess how to print a multiplication table—by calling printmultiples repeat-
edly with different arguments. In fact, we can use another loop:
i = 1
whilei <= 6:
print_multiples(i)
i += 1
Notice how similar this loop is to the one inside printmultiples . All we did was replace the print
statement with a function call. The output of this program is a multiplication table:
1 2 3 4 5 6
2 4 6 8 10 12
3 6 9 12 15 18
4 8 12 16 20 24
5 10 15 20 25 30
6 12 18 24 30 36
11.3 More encapsulation
To demonstrate encapsulation again, let’s take the code from the last section and wrap it up in a function:
defprint_mult_table():
i = 1
whilei <= 6:
print_multiples(i)
i += 1
This process is a common development plan . We develop code by writing lines of code outside any func-
tion, or typing them in to the interpreter. When we get the code working, we extract it and wrap it up in a
function. This development plan is particularly useful if you don’t know how to divide the program into
functions when you start writing. This approach lets you design as you go along.
102
11.4 Local variables
You might be wondering how we can use the same variable, i, in bothprintmultiples andprintmulttable .
Doesn’t it cause problems when one of the functions changes the value of the variable? The answer is no,
because the iinprintmultiples and theiinprintmulttable arenotthe same variable. Variables
created inside a function deﬁnition are local ; you can’t access a local variable from outside its home func-
tion. That means you are free to have multiple variables with the same name as long as they are not in the
same function.
The stack diagram for this program shows that the two variables named iare not the same variable. They
can refer to different values, and changing one does not affect the other.
The value of iinprintmulttable goes from 1 to 6. In the diagram it happens to be 3. The next time
through the loop it will be 4. Each time through the loop, printmulttable callsprintmultiples
with the current value of ias an argument. That value gets assigned to the parameter n. Insideprintmultiples ,
the value of igoes from 1 to 6. In the diagram, it happens to be 2. Changing this variable has no effect on
the value of iinprintmulttable .
It is common and perfectly legal to have different local variables with the same name. In particular, names
likeiandjare used frequently as loop variables. If you avoid using them in one function just because you
used them somewhere else, you will probably make the program harder to read.
11.5 More generalization
As another example of generalization, imagine you wanted a program that would print a multiplication
table of any size, not just the six-by-six table. You could add a parameter to printmulttable :
defprint_mult_table(high):
i = 1
whilei <= high:
print_multiples(i)
i += 1
We replaced the value 6with the parameter high . If we call printmulttable with the argument 7, it
displays:
1 2 3 4 5 6
2 4 6 8 10 12
3 6 9 12 15 18
4 8 12 16 20 24
5 10 15 20 25 30
6 12 18 24 30 36
7 14 21 28 35 42
103
This is ﬁne, except that we probably want the table to be square—with the same number of rows and
columns. To do that, we add another parameter to printmultiples to specify how many columns the
table should have. Just to be annoying, we call this parameter high, demonstrating that different functions
can have parameters with the same name (just like local variables). Here’s the whole program:
defprint_multiples(n, high):
i = 1
whilei <= high:
printn*i, "\t",
i += 1
print
defprint_mult_table(high):
i = 1
whilei <= high:
print_multiples(i, high)
i += 1
Notice that when we added a new parameter, we had to change the ﬁrst line of the function (the function
heading), and we also had to change the place where the function is called in printmulttable . As
expected, this program generates a square seven-by-seven table:
1 2 3 4 5 6 7
2 4 6 8 10 12 14
3 6 9 12 15 18 21
4 8 12 16 20 24 28
5 10 15 20 25 30 35
6 12 18 24 30 36 42
7 14 21 28 35 42 49
When you generalize a function appropriately, you often get a program with capabilities you didn’t plan.
For example, you might notice that, because ab=ba, all the entries in the table appear twice. You could save
ink by printing only half the table. To do that, you only have to change one line of printmulttable .
Change
print_multiples(i, high)
to
print_multiples(i, i)
and you get
1
2 4
3 6 9
4 8 12 16
5 10 15 20 25
6 12 18 24 30 36
7 14 21 28 35 42 49
104
11.6 Functions
A few times now, we have mentioned all the things functions are good for. By now, you might be wondering
what exactly those things are. Here are some of them:
1. Giving a name to a sequence of statements makes your program easier to read and debug.
2. Dividing a long program into functions allows you to separate parts of the program, debug them in
isolation, and then compose them into a whole.
3. Facilitating the use of iteration.
4. Producing reusable code; as well deﬁned functions are often useful in many different situations.
11.7 Newton’s method
Loops are often used in programs that compute numerical results by starting with an approximate answer
and iteratively improving it. For example, one way of computing square roots is Newton’s method. Sup-
pose that you want to know the square root of n. If you start with almost any approximation, you can
compute a better approximation with the following formula1:
better = (approx + n/approx)/2
By repeatedly applying this formula until the better approximation is equal to the previous one, we can
write a function for computing the square root:
defsqrt_newton(n):
eps = 1e-8
approx = n/2.0
better = (approx + n/approx)/2.0
whileabs(better-approx) > eps:
approx = better
better = (approx + n/approx)/2.0
returnapprox
Try calling this function with 25 as an argument to conﬁrm that it returns 5.0.
11.8 Algorithms
Newton’s method is an example of an algorithm : it is a mechanical process for solving a category of
problems (in this case, computing square roots). It is not easy to deﬁne an algorithm. It might help to
start with something that is not an algorithm. When you learned to multiply single-digit numbers, you
probably memorized the multiplication table. In effect, you memorized 100 speciﬁc solutions. That kind
of knowledge is not algorithmic. But if you were lazy, you probably cheated by learning a few tricks. For
example, to ﬁnd the product of nand9, you can write n 1as the ﬁrst digit and 10 nas the second digit.
This trick is a general solution for multiplying any single-digit number by 9. That’s an algorithm! Similarly,
the techniques you learned for addition with carrying, subtraction with borrowing, and long division are
all algorithms. One of the characteristics of algorithms is that they do not require any intelligence to carry
1Ifsis the square root of n, then sandn=s are the same, so even for a number xwhich isn’t the square root, the average of xand
n=x might well be a better approximation.
105
out. They are mechanical processes in which each step follows from the last according to a simple set of
rules.
Executing algorithms does not require any great intelligence but does require great attention to detail,
and that’s why computers are so good at it. On the other hand, the process of designing algorithms is
interesting, intellectually challenging, and a central part of what we call programming. Some of the things
that people do naturally, without difﬁculty or conscious thought, are the hardest to express algorithmically.
Understanding natural language is a good example. We all do it, but so far no one has been able to explain
how we do it, at least not in the form of an algorithm.
Unfortunately, there is no algorithm for designing algorithms! But there are methods that can make it easier.
Test-driven development is one of those. If you’re not sure how to solve a particular problem, try going
back to look at Section 7.4 to reboot your thinking.
11.9 Glossary
tab: A special character that causes the cursor to move to the next tab stop on the current line.
newline: A special character that causes the cursor to move to the beginning of the next line.
cursor: An invisible marker that keeps track of where the next character will be printed.
escape sequence: An escape character, n, followed by one or more printable characters used to designate a
non-printable character.
encapsulate: To divide a large complex program into components (like functions) and isolate the compo-
nents from each other (by using local variables, for example).
generalize: To replace something unnecessarily speciﬁc (like a constant value) with something appropri-
ately general (like a variable or parameter). Generalization makes code more versatile, more likely to
be reused, and sometimes even easier to write.
development plan: A process for developing a program. In this chapter, we demonstrated a style of devel-
opment based on developing code to do simple, speciﬁc things and then encapsulating and general-
izing.
algorithm: A step-by-step process for solving a category of problems.
106
11.10 Laboratory Exercises
1. Create a function, called printpowers , that takes two parameters, nandhigh , and prints the
values ofn1;n2;;nhighon a single line.
2. Create another function, called printpowerstable , that takes a single parameter, high , and
prints on the ﬁrst line the result of 11;12;;1high, then on the second line the result of 21;22;;2high,
and so on until the last line is printed as high1;high2;;highhigh.
3. Write a function, isprime , which takes a single integer argument, n, and returns True when the
argument is a prime number andFalse otherwise. Add doctests to your function as you develop it.
Use doctests to test your function. Hint: A simple method is to loop through all the numbers from 2
ton=2and check if any of the numbers divide nevenly (i.e. no remainder).
4. Write a function that ﬁnds all the prime numbers less than a given number. Use doctests to test your
function.
5.Extension Exercise: Write a spell-checking program that reads in a text ﬁle, scans through every word
in the ﬁle and checks that it is spelled correctly. To do this you will probably also want to read in the
system dictionary: /usr/share/dict/words .
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
107
108
Lecture 12
Strings part 2
12.1 String formatting
The most concise and powerful way to format a string in Python is to use the string formatting method ,
str.format . To see how this works, let’s start with a few examples:
>>> "His name is {}.".format("Arthur")
’His name is Arthur.’
>>> name = "Alice"
>>> age = 10
>>> "I am {} and I am {} years old.".format(name, age)
’I am Alice and I am 10 years old.’
>>> n1 = 4
>>> n2 = 5
>>> "2**10 = {} and {} *{} = {}".format(2 **10, n1, n2, n1 *n2)
’2**10 = 1024 and 4 *5 = 20’
>>>
The syntax for the string formatting operation looks like this:
"<FORMAT>".format(<VALUES>)
It begins with a format string which contains a sequence of characters and format ﬁelds . A format ﬁeld is
enclosed infg. Theformat method call contains a sequence of values, one per format ﬁeld . The format ﬁeld
may be empty, in which case a default conversion from the value type passed in to a string is performed (as
has happened in all the examples above)1.
Format ﬁelds can seem quite complicated, but mostly they are very simple. We can optionally specify a
ﬁeld number indicating which argument of the format method is to be placed where or we can use ﬁeld
name arguments instead of using ﬁeld numbers:
1This is a change from Python 2.6 which requires that a ﬁeld be numbered or named.
109
>>> n1 = 4
>>> n2 = 5
>>> "2**10 = {0} and {1} *{2} = {3}".format(2 **10, n1, n2, n1 *n2)
’2**10 = 1024 and 4 *5 = 20’
>>> "2**10 = {0} and {2} *{1} = {3}".format(2 **10, n1, n2, n1 *n2)
’2**10 = 1024 and 5 *4 = 20’
>>> "{first} *{second} = {product}".format(first=n1, second=n2, product=n1 *n2)
’4*5 = 20’
This allows us to reorder or reuse the arguments easily.
Following the optional ﬁeld name or ﬁeld number is an optional format speciﬁcation following a colon.
Here is the ofﬁcial python deﬁnition of the format speciﬁcation:
format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type]
fill ::= <a character other than ’}’>
align ::= "<" | ">" | "=" | "ˆ"
sign ::= "+" | "-" | " "
width ::= integer
precision ::= integer
type ::= "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" |
"n" | "o" | "s" | "x" | "X" | "%"
Again, this looks daunting, but is actually straightforward once you understand the notation used. Here is
a brief description of some of the elements of the format speciﬁcation:
ﬁllan optional ﬁll character (by default, it is a space),
align “<” for left alignment, “ >” for right alignment, “ ˆ” for centre alignment,
sign “+” indicates print a sign character for both positive and negative numbers, “-” indicates print a sign
character for negative numbers only (the default),
0if present, numbers will be padded with zeros.
width the minimum number of digits to use for the width of the ﬁeld,
precision how many digits to display after the decimal point for ﬂoating point values,
type different integer or ﬂoating point representations. “b” is binary, “c” is character, “d” is decimal integer,
“e” is exponent notation, “f” is ﬁxed point, “g” is general format which switches between ﬁxed and
exponent depending on the magnitude of the value.
To see a complete list, see the String Formatting Operations section of the Python Library Reference. Some
examples should illustrate the utility of string formatting. First, here is an attempt to line up columns with
using tab spaces.
i = 1
print"i\ti**2\ti**3\ti**5\ti**10\ti**20"
whilei <= 10:
printi, "\t", i **2, "\t", i **3, "\t", i **5, "\t", i **10, "\t", i **20
i += 1
This program prints out a table of various powers of the numbers from 1 to 10. In its current form it relies
on the tab character ( nt) to align the columns of values, but this breaks down when the values in the table
get larger than the 8 character tab width:
110
i i **2 i**3 i**5 i**10 i**20
1 1 1 1 1 1
2 4 8 32 1024 1048576
3 9 27 243 59049 3486784401
4 16 64 1024 1048576 1099511627776
5 25 125 3125 9765625 95367431640625
6 36 216 7776 60466176 3656158440062976
7 49 343 16807 282475249 79792266297612001
8 64 512 32768 1073741824 1152921504606846976
9 81 729 59049 3486784401 12157665459056928801
10 100 1000 100000 10000000000 100000000000000000000
One possible solution would be to change the tab width, but the ﬁrst column already has more space than
it needs. The best solution would be to set the width of each column independently. As you may have
guessed by now, string formatting provides the solution:
i = 1
s = "{:ˆ4} {:ˆ5} {:ˆ6} {:ˆ8} {:ˆ13} {:ˆ21}"
prints.format("i", "i **2", "i**3", "i**5", "i**10", "i**20")
whilei <= 10:
s = "{:<4} {:ˆ5} {:>6} {:<8} {:<13} {:ˆ21}"
prints.format(i, i **2, i**3, i**5, i**10, i**20)
i += 1
Running this version produces the following output:
i i**2 i**3 i**5 i **10 i **20
1 1 1 1 1 1
2 4 8 32 1024 1048576
3 9 27 243 59049 3486784401
4 16 64 1024 1048576 1099511627776
5 25 125 3125 9765625 95367431640625
6 36 216 7776 60466176 3656158440062976
7 49 343 16807 282475249 79792266297612001
8 64 512 32768 1073741824 1152921504606846976
9 81 729 59049 3486784401 12157665459056928801
10 100 1000 100000 10000000000 100000000000000000000
Here are some examples with ﬂoating point numbers:
111
>>> x = 12.342354453463456456
>>> "{:5.1f}".format(x)
’ 12.3’
>>> "{:5.5f}".format(x)
’12.34235’
>>> "{:05.1f}".format(x)
’012.3’
>>> "{:5.1e}".format(x)
’1.2e+01’
>>> "{:5.1E}".format(x)
’1.2E+01’
>>> "{:015.1E}".format(x)
’000000001.2E+01’
>>> "{:>15.1E}".format(x)
’ 1.2E+01’
12.2 Character classiﬁcation
It is often helpful to examine a character or string and test whether it is upper- or lowercase, or whether it
is a character or a digit. The str type includes several methods for this functionality:
>>> "3".isalnum() # alphabetical or numeral
True
>>> "3".isalpha() # alphabetical
False
>>> "hello".isalpha()
True
>>> "342".isdigit() # numeral
True
>>> "hello".islower() # lower case
True
>>> "hello".isupper() # upper case
False
>>> " ".isspace() # whitespace
True
>>> "Hello".istitle() # capitalised
True
>>> "hello".istitle()
False
>>>
These methods are often very useful for checking for the correct format when reading in information from
a user. For example, when asking for someone’s name, it is often useful to check for capitilization:
name = raw_input("Enter your name: ")
if notname.istitle():
name = name.capitalize()
112
12.3 A ﬁnd function
What does the following function do?
deffind(strng, ch):
index = 0
whileindex < len(strng):
ifstrng[index] == ch:
returnindex
index += 1
return-1
In a sense, find is the opposite of the []operator. Instead of taking an index and extracting the corre-
sponding character, it takes a character and ﬁnds the index where that character appears. If the character
is not found, the function returns -1. This is the ﬁrst example we have seen of a return statement inside
a loop. Ifstrng[index] == ch , the function returns immediately, breaking out of the loop prematurely.
If the character doesn’t appear in the string, then the program exits the loop normally and returns -1. This
pattern of computation is sometimes called a eureka traversal because as soon as we ﬁnd what we are
looking for, we can cry Eureka! and stop looking.
12.4 Optional parameters
To ﬁnd the locations of the second or third occurrence of a character in a string, we can modify the find
function, adding a third parameter for the starting position in the search string:
deffind2(strng, ch, start):
index = start
whileindex < len(strng):
ifstrng[index] == ch:
returnindex
index += 1
return-1
The callfind2("banana", "a", 2) now returns 3, the index of the second ”a” in ”banana”. Better still,
we can combine find andfind2 using an optional parameter :
deffind(strng, ch, start=0):
index = start
whileindex < len(strng):
ifstrng[index] == ch:
returnindex
index += 1
return-1
The callfind("banana", "a", 2) to this version of ﬁnd behaves just like find2 , while in the call
find("banana", "a") ,start will be set to the default value of0. Adding another optional parameter
to ﬁnd makes it search both forward and backward:
113
deffind(strng, ch, start=0, step=1):
index = start
while0 <= index < len(strng):
ifstrng[index] == ch:
returnindex
index += step
return-1
Passing in a value of -1for step will make it search toward the beginning of the string instead of the end.
Note that we needed to check for a lower bound for index in the while loop as well as an upper bound to
accommodate this change.
12.5 Glossary
whitespace: Any of the characters that move the cursor without printing visible characters. The constant
string.whitespace contains all the white-space characters.
optional parameter: A parameter written in a function header with an assignment to a default value which
it will receive if no corresponding argument is given for it in the function call.
default value: The value given to an optional parameter if no argument for it is provided in the function
call.
114
12.6 Laboratory exercises
1. Try each of the following formatted string operations in a Python shell and record the results:
(a)"fg f:dg f:fg".format(5, 5, 5)
(b)"f:>.2fg".format(3)
(c)"f:>10.2fgf:>10.2fg".format(7, 1.0/2)
(d) print"$f:5.2fgnn$f:5.2fgnn$f:5.2fg".format(3, 4.5, 11.2)
2. The following formatted strings have errors. Fix them:
(a)"fg fg fg fg ".format("this", "that", "something")
(b)"fg fg fg".format("yes", "no", "up", "down")
(c)"f:dg f:fg f:fg".format(3, 3, "three")
3. Rewrite the countletters function from Exercise 5 in Section 8.11 so that instead of traversing the
string, it repeatedly calls find (the version from section 12.4), with the optional third parameter to
locate new occurrences of the letter being counted.
4. Write a function countapluses(filename) which reads lines from a ﬁle of numbers and returns
how many were in the range 90 to 100. Create your own text ﬁles to test your code.
5.Extension Exercise: Write a function sumofsquares ofdigits that computes the sum of the squares
of the digits of an integer passed to it. For example, sumofsquares ofdigits(987) should re-
turn194, since9**2 + 8**2 + 7**2 == 81 + 64 + 49 == 194 .
defsum_of_squares_of_digits(n):
"""
>>> sum_of_squares_of_digits(1)
1
>>> sum_of_squares_of_digits(9)
81
>>> sum_of_squares_of_digits(11)
2
>>> sum_of_squares_of_digits(121)
6
>>> sum_of_squares_of_digits(987)
194
"""
Check your solution against the doctests above.
115
6.Extension Exercise: Create useful utilities for dealing with ﬁlenames:
(a) Remove the trailing ﬁlename extension from a string:
defremove_extension(name):
"""
>>> remove_extension("tst.txt")
'tst'
>>> remove_extension("tst.2.txt")
'tst.2'
"""
(b) Remove all leading pathname components, leaving only the extension:
defget_extension(name):
"""
>>> get_extension("tst.txt")
'txt'
>>> get_extension("/usr/dict/words.txt")
'txt'
>>> get_extension("tst.3.png")
'png'
"""
(c) Strip out the leading pathname components, leaving only the ﬁlename:
defstrip_pathname(name):
"""
>>> strip_pathname("/usr/dict/words")
'words'
>>> strip_pathname("tst.txt")
'tst.txt'
"""
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
116
Lecture 13
Lists part 1
Alistis an ordered set of values, where each value is identiﬁed by an index. The values that make up a
list are called its elements . Lists are similar to strings, which are ordered sets of characters, except that the
elements of a list can have any type. Lists and strings—and other things that behave like ordered sets—are
called sequences .
13.1 List values
There are several ways to create a new list; the simplest is to enclose the elements in square brackets
([and]):
[10, 20, 30, 40]
["spam", "bungee", "swallow"]
The ﬁrst example is a list of four integers. The second is a list of three strings. The elements of a list don’t
have to be the same type. The following list contains a string, a ﬂoat, an integer, and another list:
["hello", 2.0, 5, [10, 20]]
A list within another list is said to be nested . Finally, there is a special list that contains no elements. It is
called the empty list, and is denoted []. Like numeric 0 values and the empty string, the empty list is false
in a boolean expression:
>>> if []:
... print "This is true."
... else:
... print "This is false."
...
This is false.
>>>
With all these ways to create lists, it would be disappointing if we couldn’t assign list values to variables or
pass lists as parameters to functions. We can:
117
>>> vocabulary = ["ameliorate", "castigate", "defenestrate"]
>>> numbers = [17, 5]
>>> empty = []
>>> print vocabulary, numbers, empty
[’ameliorate’, ’castigate’, ’defenestrate’] [17, 5] []
13.2 Accessing elements
The syntax for accessing the elements of a list is the same as the syntax for accessing the characters of
a string—the bracket operator ( []– not to be confused with an empty list). The expression inside the
brackets speciﬁes the index. Remember that the indices start at 0:
>>> print numbers[0]
17
Any integer expression can be used as an index:
>>> numbers[9-8]
5
>>> numbers[1.0]
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: list indices must be integers
If you try to read or write an element that does not exist, you get a runtime error:
>>> numbers[2]
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
IndexError: list index out of range
If an index has a negative value, it counts backward from the end of the list:
>>> numbers[-1]
5
>>> numbers[-2]
17
>>> numbers[-3]
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
IndexError: list index out of range
numbers[-1] is the last element of the list, numbers[-2] is the second to last, and numbers[-3] doesn’t
exist. It is common to use a loop variable as a list index.
118
horsemen = ["war", "famine", "pestilence", "death"]
i = 0
whilei < 4:
printhorsemen[i]
i += 1
This while loop counts from 0 to 4. When the loop variable iis 4, the condition fails and the loop terminates.
The body of the loop is only executed when iis 0, 1, 2, and 3. Each time through the loop, the variable iis
used as an index into the list, printing the ithelement. This pattern of computation is called a list traversal .
13.3 List length
The function len returns the length of a list, which is equal to the number of its elements. It is a good idea
to use this value as the upper bound of a loop instead of a constant. That way, if the size of the list changes,
you won’t have to go through the program changing all the loops; they will work correctly for any size list:
horsemen = ["war", "famine", "pestilence", "death"]
i = 0
num = len(horsemen)
whilei < num:
printhorsemen[i]
i += 1
The last time the body of the loop is executed, iislen(horsemen) - 1 , which is the index of the last
element. When iis equal to len(horsemen) , the condition fails and the body is not executed, which is a
good thing, because len(horsemen) is not a legal index.
Although a list can contain another list, the nested list still counts as a single element. The length of this list
is 4:
["spam!", 1, ["Brie", "Roquefort", "Pol le Veq"], [1, 2, 3]]
13.4 The range function
Lists that contain consecutive integers are common, so Python provides a simple way to create them:
>>> range(1, 5)
[1, 2, 3, 4]
The range function takes two arguments and returns a list that contains all the integers from the ﬁrst to the
second, including the ﬁrst but not the second .1There are two other forms of range. With a single argument,
it creates a list that starts at 0:
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
If there is a third argument, it speciﬁes the space between successive values, which is called the step size .
1There is also a function called xrange that acts much like range . However, xrange does not actually construct the requested
list in memory, and will generate the numbers as needed. This is more memory efﬁcient, especially when generating a lot of numbers.
119
This example counts from 1 to 10 by steps of 2:
>>> range(1, 10, 2)
[1, 3, 5, 7, 9]
If the step size is negative, then start must be greater than stop:
>>> range(20, 4, -5)
[20, 15, 10, 5]
or the result will be an empty list:
>>> range(10, 20, -5)
[]
13.5 Lists and for loops
Thefor loop also works with lists. The generalized syntax of a for loop is:
forVARIABLE inLIST:
BODY
This statement is equivalent to:
i = 0
whilei < len(LIST):
VARIABLE = LIST[i]
BODY
i += 1
Thefor loop is more concise because we can eliminate the loop variable, i. Here is the horsemen while
loop written with a for loop:
forhorseman inhorsemen:
printhorseman
It almost reads like English: For (every) horseman in (the list of) horsemen , print (the name of the)
horseman .
Any list expression can be used in a for loop:
fornumber inrange(20):
ifnumber % 3 == 0:
printnumber
forfruit in["banana", "apple", "quince"]:
print"I like to eat " + fruit + "s!"
The ﬁrst example prints all the multiples of 3 between 0 and 19. The second example expresses enthusiasm
for various fruits.
Since lists are mutable, it is often desirable to traverse a list, modifying each of its elements. The following
squares all the numbers from 1 to 5:
120
numbers = [1, 2, 3, 4, 5]
forindex inrange(len(numbers)):
numbers[index] = numbers[index] **2
Take a moment to think about range(len(numbers)) until you understand how it works. We are inter-
ested here in both the value and its index within the list, so that we can assign a new value to it.
This pattern is common enough that Python provides a nicer way to implement it:
numbers = [1, 2, 3, 4, 5]
forindex, value inenumerate(numbers):
numbers[index] = value **2
enumerate generates both the index and thevalue associated with it during the list traversal. Try this
next example to see more clearly how enumerate works:
>>> for index, value in enumerate(["banana", "apple", "pear", "quince"]):
... print index, value
...
0 banana
1 apple
2 pear
3 quince
>>>
13.6 List membership
inis a boolean operator that tests membership in a sequence. We used it previously with strings, but it also
works with lists and other sequences:
>>> horsemen = ["war", "famine", "pestilence", "death"]
>>> "pestilence" in horsemen
True
>>> "debauchery" in horsemen
False
Sincepestilence is a member of the horsemen list, theinoperator returns True . Sincedebauchery is
not in the list, inreturnsFalse . We can use not in combination with into test whether an element is not
a member of a list:
>>> "debauchery" not in horsemen
True
13.7 List operations
The+operator concatenates lists:
121
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1, 2, 3, 4, 5, 6]
Similarly, the *operator repeats a list a given number of times:
>>> [0] *4
[0, 0, 0, 0]
>>> [1, 2, 3] *3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
The ﬁrst example repeats [0] four times. The second example repeats the list [1, 2, 3] three times.
13.8 List slices
The slice operations we saw with strings also work on lists:
>>> a_list = ["a", "b", "c", "d", "e", "f"]
>>> a_list[1:3]
[’b’, ’c’]
>>> a_list[:4]
[’a’, ’b’, ’c’, ’d’]
>>> a_list[3:]
[’d’, ’e’, ’f’]
>>> a_list[:]
[’a’, ’b’, ’c’, ’d’, ’e’, ’f’]
13.9 Lists are mutable
Unlike strings lists are mutable , which means we can change their elements. Using the bracket operator
on the left side of an assignment, we can update one of the elements:
>>> fruit = ["banana", "apple", "quince"]
>>> fruit[0] = "pear"
>>> fruit[-1] = "orange"
>>> print fruit
[’pear’, ’apple’, ’orange’]
The bracket operator applied to a list can appear anywhere in an expression. When it appears on the left
side of an assignment, it changes one of the elements in the list, so the ﬁrst element of fruit has been
changed from "banana" to"pear" , and the last from "quince" to"orange" . An assignment to an
element of a list is called item assignment .
122
Item assignment does not work for strings:
>>> my_string = "TEST"
>>> my_string[2] = "X"
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: ’str’ object does not support item assignment
but it does for lists:
>>> my_list = ["T", "E", "S", "T"]
>>> my_list[2] = "X"
>>> my_list
[’T’, ’E’, ’X’, ’T’]
With the slice operator we can update several elements at once:
>>> a_list = ["a", "b", "c", "d", "e", "f"]
>>> a_list[1:3] = ["x", "y"]
>>> print a_list
[’a’, ’x’, ’y’, ’d’, ’e’, ’f’]
We can also remove elements from a list by assigning the empty list to them:
>>> a_list = ["a", "b", "c", "d", "e", "f"]
>>> a_list[1:3] = []
>>> print a_list
[’a’, ’d’, ’e’, ’f’]
And we can add elements to a list by squeezing them into an empty slice at the desired location:
>>> a_list = ["a", "d", "f"]
>>> a_list[1:1] = ["b", "c"]
>>> print a_list
[’a’, ’b’, ’c’, ’d’, ’f’]
>>> a_list[4:4] = ["e"]
>>> print a_list
[’a’, ’b’, ’c’, ’d’, ’e’, ’f’]
13.10 List deletion
Using slices to delete list elements can be awkward, and therefore error-prone. Python provides an alterna-
tive that is more readable. del removes an element from a list:
>>> a = ["one", "two", "three"]
>>> del a[1]
>>> a
[’one’, ’three’]
As you might expect, del handles negative indices and causes a runtime error if the index is out of range.
123
You can use a slice as an index for del:
>>> a_list = ["a", "b", "c", "d", "e", "f"]
>>> del a_list[1:5]
>>> print a_list
[’a’, ’f’]
As usual, slices select all the elements up to, but not including, the second index.
13.11 Glossary
list: A named collection of objects, where each object is identiﬁed by an index.
index: An integer variable or value that indicates an element of a list.
element: One of the values in a list (or other sequence). The bracket operator selects elements of a list.
sequence: Any of the data types that consist of an ordered set of elements, with each element identiﬁed by
an index.
nested list: A list that is an element of another list.
step size: The interval between successive elements of a linear sequence. The third (and optional argu-
ment) to the range function is called the step size. If not speciﬁed, it defaults to 1.
list traversal: The sequential accessing of each element in a list.
mutable type: A data type in which the elements can be modiﬁed. All mutable types are compound types.
Lists are mutable data types; strings are not.
object: A thing to which a variable can refer.
124
13.12 Laboratory exercises
1. Write a loop that traverses:
["spam!", 1, ["Brie", "Roquefort", "Pol le Veq"], [1, 2, 3]]
and prints the length of each element. What happens if you send an integer to len? Change 1to
"one" and run your solution again.
2. What is the Python interpreter’s response to the following?
>>> range(10, 0, -2)
The three arguments to the range function are start ,stop , andstep , respectively. In this example,
start is greater than stop . What happens if start<stop andstep<0? Write a rule for the
relationships among start ,stop , andstep .
3. Write a function addlists(a, b) that takes two lists of numbers of the same length, and returns a
new list containing the sums of the corresponding elements of each. The original lists should remain
unchanged.
defadd_lists(a, b):
"""
>>> add_lists([1, 1], [1, 1])
[2, 2]
>>> add_lists([1, 2], [1, 4])
[2, 6]
>>> add_lists([1, 2, 1], [1, 4, 3])
[2, 6, 4]
>>> list1 = [1, 2, 1]
>>> list2 = [1, 4, 3]
>>> sum = add_lists(list1, list2)
>>> list1 == [1, 2, 1]
True
>>> list2 == [1, 4, 3]
True
"""
addlists should pass the doctests above.
4. Write a function multlists(a, b) that takes two lists of numbers of the same length, and returns
the sum of the products of the corresponding elements of each.
defmult_lists(a, b):
"""
>>> mult_lists([1, 1], [1, 1])
2
>>> mult_lists([1, 2], [1, 4])
9
>>> mult_lists([1, 2, 1], [1, 4, 3])
12
"""
Verify that multlists passes the doctests above.
125
5.Extension Exercise: Write a function called flatten list that takes as input a list which may be
nested, and returns a non-nested list with all the elements of the input list.
defflatten_list(alist):
'''
>>> flatten_list([1,2,3])
[1, 2, 3]
>>> flatten_list([1, [2,3], [4, 5], 6])
[1, 2, 3, 4, 5, 6]
'''
Is your solution general enough to allow any level of nesting? If not, can you make it so?
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
126
Lecture 14
Lists part 2
14.1 Objects and values
If we execute these assignment statements,
a = "banana"
b = "banana"
we know that aandbwill refer to a string with the letters ‘‘banana’’ . But we can’t tell whether they
point to the same string. There are two possible states:
a
ba
b"banana"
"banana""banana"
In one case, aandbrefer to two different things that have the same value. In the second case, they refer to
the same thing. These things have names—they are called objects . An object is something a variable can
refer to. Every object has a unique identiﬁer , which we can obtain with the id function. By printing the
identiﬁer of aandb, we can tell whether they refer to the same object.
>>> id(a)
135044008
>>> id(b)
135044008
In fact, we get the same identiﬁer twice, which means that Python only created one string, and both aandb
refer to it. If you try this, your actual idvalue will probably be different. Python does this because strings
are immutable and it is more space efﬁcient to maintain only one copy of a string in memory.
Interestingly, lists behave differently. When we create two lists, we get two objects:
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> id(a)
135045528
>>> id(b)
135041704
127
So the state diagram looks like this:
a
b[ 1, 2, 3 ]
[ 1, 2, 3 ]
aandbhave the same value but do not refer to the same object.
14.2 Aliasing
Since variables refer to objects, if we assign one variable to another, both variables refer to the same object:
>>> a = [1, 2, 3]
>>> b = a
>>> id(a) == id(b)
True
In this case, the state diagram looks like this:
a
b[ 1, 2, 3 ]
Because the same list has two different names, aandb, we say that it is aliased . Changes made with one
alias affect the other:
>>> b[0] = 5
>>> print a
[5, 2, 3]
Although this behaviour can be useful, it is sometimes unexpected or undesirable. In general, it is safer to
avoid aliasing when you are working with mutable objects. Of course, for immutable objects, there’s no
problem. That’s why Python is free to alias strings when it sees an opportunity to economize.
14.3 Cloning lists
If we want to modify a list and also keep a copy of the original, we need to be able to make a copy of the list
itself, not just the reference. This process is sometimes called cloning , to avoid the ambiguity of the word
copy. The easiest way to clone a list is to use the slice operator:
>>> a = [1, 2, 3]
>>> b = a[:]
>>> print b
[1, 2, 3]
Taking any slice of acreates a new list. In this case the slice happens to consist of the whole list. Now we
are free to make changes to bwithout worrying about a:
>>> b[0] = 5
>>> print a
[1, 2, 3]
128
14.4 List parameters
Passing a list as an argument actually passes a reference to the list, not a copy of the list. Since lists are
mutable, changes made to the parameter change the argument as well. For example, the function below
takes a list as an argument and multiplies each element in the list by 2:
defdouble_stuff(a_list):
forindex, value inenumerate(a_list):
a_list[index] = 2 *value
If we putdoublestuff in a ﬁle named doublestuff.py , we can test it out like this:
>>> from double_stuff import double_stuff
>>> things = [2, 5, "Spam", 9.5]
>>> double_stuff(things)
>>> things
[4, 10, ’SpamSpam’, 19.0]
>>>
The parameter alist and the variable things are aliases for the same object. The state diagram looks like
this:
things __main__[2, 5, ’Spam’, 9.5]double_stuff a_list
Since the list object is shared by two frames, we drew it between them. If a function modiﬁes a list parame-
ter, the caller sees the change.
14.5 Pure functions and modiﬁers
Functions which take lists as arguments and change them during execution are called modiﬁers and the
changes they make are called side effects . Apure function does not produce side effects. It communicates
with the calling program only through parameters, which it does not modify, and a return value. Here is
doublestuff written as a pure function:
defdouble_stuff(a_list):
new_list = []
forvalue ina_list:
new_list += [2 *value]
returnnew_list
129
This version of doublestuff does not change its arguments:
>>> from double_stuff import double_stuff
>>> things = [2, 5, "Spam", 9.5]
>>> double_stuff(things)
[4, 10, ’SpamSpam’, 19.0]
>>> things
[2, 5, "Spam", 9.5]
>>>
To use the pure function version of doublestuff to modify things , you would assign the return value
back tothings :
>>> things = double_stuff(things)
>>> things
[4, 10, ’SpamSpam’, 19.0]
>>>
14.6 Which is better?
Anything that can be done with modiﬁers can also be done with pure functions. In fact, some program-
ming languages only allow pure functions. There is some evidence that programs that use pure functions
are faster to develop and less error-prone than programs that use modiﬁers. Nevertheless, modiﬁers are
convenient at times, and in some cases, functional programs are less efﬁcient. In general, we recommend
that you write pure functions whenever it is reasonable to do so and resort to modiﬁers only if there is a
compelling advantage. This approach might be called a functional programming style .
14.7 Nested lists
A nested list is a list that appears as an element in another list. In this list, the element with index 3 is a
nested list:
>>> nested = ["hello", 2.0, 5, [10, 20]]
If we print nested[3] , we get[10, 20] . To extract an element from the nested list, we can proceed in
two steps:
>>> elem = nested[3]
>>> elem[0]
10
Or we can combine them:
>>> nested[3][1]
20
Bracket operators evaluate from left to right, so this expression gets the third element of nested and ex-
tracts the ﬁrst element from it.
130
14.8 Matrices
Nested lists are often used to represent matrices. For example, the matrix:
1   2   3
7   8   94   5   6
might be represented as:
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
matrix is a list with three elements, where each element is a row of the matrix. We can select an entire row
from the matrix in the usual way:
>>> matrix[1]
[4, 5, 6]
Or we can extract a single element from the matrix using the double-index form:
>>> matrix[1][1]
5
The ﬁrst index selects the row, and the second index selects the column. Although this way of representing
matrices is common, it is not the only possibility. A small variation is to use a list of columns instead of a
list of rows.
14.9 Strings and lists
Python has a command called list that takes a sequence type as an argument and creates a list out of its
elements.
>>> list("Crunchy Frog")
[’C’, ’r’, ’u’, ’n’, ’c’, ’h’, ’y’, ’ ’, ’F’, ’r’, ’o’, ’g’]
There is also a str command that takes any Python value as an argument and returns a string representa-
tion of it.
>>> str(5)
’5’
>>> str(None)
’None’
>>> str(list("nope"))
"[’n’, ’o’, ’p’, ’e’]"
131
As we can see from the last example, str can’t be used to join a list of characters together. To do this we
could use the string method join :
>>> char_list = list("Frog")
>>> char_list
[’F’, ’r’, ’o’, ’g’]
>>> "".join(char_list)
’Frog’
To go in the opposite direction, the split method breaks a string into a list of words. By default, any
number of whitespace characters is considered a word boundary:
>>> song = "The rain in Spain..."
>>> song.split()
[’The’, ’rain’, ’in’, ’Spain...’]
An optional argument called a delimiter can be used to specify which characters to use as word boundaries.
The following example uses the string aias the delimiter (which doesn’t appear in the result):
>>> song.split("ai")
[’The r’, ’n in Sp’, ’n...’]
14.10 Glossary
modiﬁer: A function which changes its arguments inside the function body. Only mutable types can be
changed by modiﬁers.
side effect: A change in the state of a program made by calling a function that is not a result of reading the
return value from the function. Side effects can only be produced by modiﬁers.
pure function: A function which has no side effects. Pure functions only make changes to the calling
program through their return values.
delimiter: A character or string used to indicate where a string should be split.
aliases: Multiple variables that contain references to the same object.
clone: To create a new object that has the same value as an existing object. Copying a reference to an object
creates an alias but doesn’t clone the object.
132
14.11 Laboratory exercises
1. Consider the following code:
a = [1, 2, 3]
b = a[:]
b[0] = 5
Draw a state diagram for aandbbefore and after the third line is executed.
2.
song = "The rain in Spain..."
Describe the relationship between " ".join(song.split()) andsong . Are they the same for all
strings? When would they be different?
3. What will be the output of the following program?
this = ["I", "am", "not", "a", "crook"]
that = ["I", "am", "not", "a", "crook"]
print"Test 1: {}".format(id(this) == id(that))
that = this
print"Test 2: {}".format(id(this) == id(that))
Provide a detailed explanation of the results.
4. Exercise 3 in Section 13.12 asked you to write a function to add two lists without modifying the original
lists. Suppose you had written the following function (with a little bit of test code):
defadd_lists(a, b):
foriinrange(len(a)):
a[i] += b[i]
returna
list1 = [1,2,3]
list2 = [3,4,6]
list3 = add_lists(list1, list2)
printlist1
printlist2
printlist3
What is the output of the print statements and why? This is an example of a side-effect. How can we write
our code to avoid side-effects?
133
5. Write a function myreplace(s, old, new) that returns a string with all occurrences of old replaced
withnew in the string s.
defmyreplace(s, old, new):
"""
>>> myreplace("Mississippi", "i", "I")
'MIssIssIppI'
>>> s = "I love spom! Spom is my favorite food. Spom, spom, spom, yum!"
>>> myreplace(s, "om", "am")
'I love spam! Spam is my favorite food. Spam, spam, spam, yum!'
>>> myreplace(s, "o", "a")
'I lave spam! Spam is my favarite faad. Spam, spam, spam, yum!'
"""
Your solution should pass the doctests above, but don’t use the existing string replace method (make
use of loops instead). Instead of trying to solve the whole problem, use incremental development
with the following intermediate goals:
(a) loop through sand print out all substrings of size len(old) .
(b) loop through sand print all substrings that match old.
(c) loop through sand print all substrings of size len(old) , except replace those substrings that
matchold with the string new.
6. Matrix multiplication. If you don’t know how to do matrix multiplication, spend some time learning
how to do it (the web is a good place to start - try
http://www.intmath.com/matrices-determinants/4-multiplying-matrices.php or
http://www.youtube.com/watch?v=qiLjdujcI2w&feature=related ). Complete the body
of thematrixmultiply 2x2 function below, so that it passes the doctests.
defmatrix_multiply_2x2(amatrix, bmatrix):
"""
Return a matrix which is the result of multiplying amatrix by bmatrix.
Assume that both matrices are of size 2x2. The resultant matrix should
also be 2x2.
>>> matrix_multiply_2x2([[1,0],[0,1]], [[2,3],[4,5]])
[[2, 3], [4, 5]]
>>> matrix_multiply_2x2([[2,3],[4,5]], [[1,0],[0,1]])
[[2, 3], [4, 5]]
>>> matrix_multiply_2x2([[1,2],[3,4]], [[5,6],[7,8]])
[[19, 22], [43, 50]]
"""
134
7.Extension Exercise Develop a function which returns a 0-ﬁlled matrix of given size. The function should pass
the following doctests:
defzeros(n,m):
"""
Return an n by m matrix of zeros. Each element should be unique.
>>> A = zeros(3,2)
>>> A
[[0,0],[0,0],[0,0]]
>>> A[0][1] = 1
>>> A
[[1,0],[0,0],[0,0]]
"""
8.Extension Exercise Extend your solution to the previous exercise so that matrixmultiply can accept ma-
trices of any size (assuming they are compatible). You will need three nested loops.
defmatrix_multiply(amatrix, bmatrix):
"""
Return a matrix which is the result of multiplying amatrix and bmatrix.
Assume that amatrix is an NxM matrix and bmatrix is an MxP matrix
(this means amatrix has N rows and M columns, while bmatrix has M
rows and P columns). The resulting matrix will be an NxP matrix.
A matrix is represented as a list of lists as shown below.
[1 4]
The matrix [2 5] is represented by this list [[1,4],[2,5],[3,6]]
[3 6]
>>> matrix_multiply([[1,2]],[[3],[4]])
[[11]]
>>> matrix_multiply([[1],[2]], [[3,4]])
[[3, 4], [6, 8]]
>>> matrix_multiply([[1,2,3],[4,5,6]], [[1,4],[2,5],[3,6]])
[[14, 32], [32, 77]]
>>> matrix_multiply([[1,2,3],[4,5,6]], [[1,4,7,10],[2,5,8,11],[3,6,9,12]])
[[14, 32, 50, 68], [32, 77, 122, 167]]
"""
9.Extension Exercise: Create a function called insertsorted that inserts a new element into a list in
order:
definsert_sorted(lst, element):
'''
>>> insert_sorted([1,3,5], 4)
[1,3,4,5]
>>> insert_sorted([1,2,3], 0)
[0,1,2,3]
>>> insert_sorted([1,2,3],4)
[1,2,3,4]
'''
10.Extension Exercise: Dealing with dates is a common problem with web-form processing (how many
times have you had to enter the date in a web form?). Read a date in from the user and convert it to
the standard date format: DD/MM/YYYY.
135
Users are likely to enter the date using several formats: E.g.
12/6/07
13-2-09
13 May 1996
This is quite a difﬁcult problem. Start off with some of the simpler conversions, then add more as you
go. Think about what you should do if the user enters an invalid date.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
136
Lecture 15
T uples, Sets and Dictionaries
15.1 T uples and mutability
So far, you have seen two compound types: strings, which are made up of characters; and lists, which
are made up of elements of any type. One of the differences we noted is that the elements of a list can be
modiﬁed, but the characters in a string cannot. In other words, strings are immutable and lists are mutable .
Atuple , like a list, is a sequence of items of any type. Unlike lists, however, tuples are immutable. Syntac-
tically, a tuple is a comma-separated sequence of values:
>>> tup = 2, 4, 6, 8, 10
Although it is not necessary, it is conventional to enclose tuples in parentheses:
>>> tup = (2, 4, 6, 8, 10)
To create a tuple with a single element, we have to include the ﬁnal comma:
>>> tup = (5,)
>>> type(tup)
<type ’tuple’>
Without the comma, Python treats (5) as an integer in parentheses:
>>> tup = (5)
>>> type(tup)
<type ’int’>
Syntax issues aside, tuples support the same sequence operations as strings and lists. The index operator
selects an element from a tuple.
>>> tup = ("a", "b", "c", "d", "e")
>>> tup[0]
’a’
137
And the slice operator selects a range of elements:
>>> tup[1:3]
(’b’, ’c’)
But if we try to use item assignment to modify one of the elements of the tuple, we get an error:
>>> tup[0] = "X"
TypeError: 'tuple' object does notsupport item assignment
Of course, even if we can’t modify the elements of a tuple, we can replace it with a different tuple:
>>> tup = ("X",) + tup[1:]
>>> tup
(’X’, ’b’, ’c’, ’d’, ’e’)
Alternatively, we could ﬁrst convert it to a list, modify it, and convert it back into a tuple:
>>> tup = ("X", "b", "c", "d", "e")
>>> tup = list(tup)
>>> tup
[’X’, ’b’, ’c’, ’d’, ’e’]
>>> tup[0] = "a"
>>> tup = tuple(tup)
>>> tup
(’a’, ’b’, ’c’, ’d’, ’e’)
15.2 T uple assignment
Once in a while, it is useful to perform multiple assignments in a single statement and this can be done with
tuple assignment :
>>> a,b = 3,4
>>> print a
3
>>> print b
4
>>> a,b,c = (1,2,3),5,6
>>> print a
(1, 2, 3)
>>> print b
5
>>> print c
6
The left side is a tuple of variables; the right side is a tuple of values. Each value is assigned to its respective
variable. All the expressions on the right side are evaluated before any of the assignments. This feature
makes tuple assignment quite versatile. Naturally, the number of variables on the left and the number of
values on the right have to be the same:
>>> a, b, c, d = 1, 2, 3
ValueError: need more than 3 values to unpack
138
Such statements can be useful shorthand for multiple assignment statements, but care should be taken that
it doesn’t make the code more difﬁcult to read.
One example of tuple assignment that improves readibility is when we want to swap the values of two
variables. With conventional assignment statements, we have to use a temporary variable. For example, to
swapaandb:
temp = a
a = b
b = temp
If we have to do this often, such an approach becomes cumbersome. Python provides a form of tuple
assignment that solves this problem neatly:
a, b = b, a
15.3 T uples as return values
Functions can return tuples as return values. For example, we could write a function that swaps two
parameters:
defswap(x, y):
returny, x
Then we can assign the return value to a tuple with two variables:
a, b = swap(a, b)
In this case, there is no great advantage in making swap a function. In fact, there is a danger in trying to
encapsulate swap , which is the following tempting mistake:
defswap(x, y): # incorrect version
x, y = y, x
If we callswap like this:
swap(a, b)
thenaandxare aliases for the same value. Changing xinsideswap makesxrefer to a different value,
but it has no effect on ainmain . Similarly, changing yhas no effect on b. This function runs without
producing an error message, but it doesn’t do what we intended. This is an example of a semantic error.
15.4 Why tuples?
There is considerable debate (and some confusion) about why Python has tuples at all. It hardly seems
worth having a type with very similar functionality to lists, without some of the advantages. So why have
tuples at all? The answer to that question is rather subtle and requires some not insigniﬁcant programming
experience to fully understand. Here are some reasons why tuples are useful:
139
• Tuples are more efﬁcient to use than lists. Admittedly, the difference is likely to be small for most
applications, but in some cases can be signiﬁcant.
• Tuple assignment is just cool, since many programming languages won’t allow you to do this (note
the swap syntax above).
• In some situations, tuples can be used as dictionary keys (more on dictionaries in section 15.7).
15.5 When should you use tuples?
You should use tuples in preference to lists when:
• the tuple represents a value. For example, if you want to represent a point in two-dimensions, then
a tuple is probably what you want. The tuple (2,5) represents the point (2;5)and that point will
never change its value (it’s a constant). This is similar to the notion of integers — you wouldn’t want
to change the value of the integer 2to represent anything other than the number 2;
• you want a sequence that won’t change;
• you want to return multiple values from a pure function.
15.6 Sets
Another useful builtin type is the set. A set is an unordered collection of items with no duplication. Set
objects also support basic mathematical set operations such as union, intersection and difference. Sets can
be constructed from any sequence type (string, list, tuple). Following is a quick demonstration of sets:
>>> a = set("hello there")
>>> b = set("goodbye")
>>> a
set([’ ’, ’e’, ’h’, ’l’, ’o’, ’r’, ’t’])
>>> b
set([’b’, ’e’, ’d’, ’g’, ’o’, ’y’])
>>> len(a)
7
>>> len(b)
6
>>> "b" in a # set membership
False
>>> "b" in b
True
>>> a - b # characters in a that aren’t in b
set([’ ’, ’t’, ’r’, ’l’, ’h’])
>>> a | b # characters in either a or b
set([’ ’, ’b’, ’e’, ’d’, ’g’, ’h’, ’l’, ’o’, ’r’, ’t’, ’y’])
>>> a & b # characters in both a and b
set([’e’, ’o’])
>>> a ˆ b # characters in a or b but not in both
set([’ ’, ’b’, ’d’, ’g’, ’h’, ’l’, ’r’, ’t’, ’y’])
140
15.7 Dictionaries
Strings, lists and tuples are sequence types which use integers as indices to access the multiple values they
contain. Sets are an unordered type and rather than index into the set, the set can be checked for member-
ship. Dictionaries have behaviours that are somewhere between the behaviour of sets and sequence types.
On the one hand, they can be indexed, but on the other hand they are unordered (the indicies need not
be consecutive. They are Python’s mapping type . They map keys which can be of any immutable type to
values which can be of any type.
As an example, we will create a dictionary to translate English words into Spanish. For this dictionary, the
keys are strings. One way to create a dictionary is to start with the empty dictionary and add key-value
pairs . The empty dictionary is denoted fg:
>>> eng2sp = {}
>>> eng2sp["one"] = "uno"
>>> eng2sp["two"] = "dos"
The ﬁrst assignment creates a dictionary named eng2sp ; the other assignments add new key-value pairs
to the dictionary. We can print the current value of the dictionary in the usual way:
>>> print eng2sp
{’two’: ’dos’, ’one’: ’uno’}
The key-value pairs of the dictionary are separated by commas. Each pair contains a key and a value sep-
arated by a colon. The order of the pairs may not be what you expected. Python uses complex algorithms
to determine where the key-value pairs are stored in a dictionary. For our purposes we can think of this
ordering as unpredictable.
Another way to create a dictionary is to provide a list of key-value pairs using the same syntax as the
previous output:
>>> eng2sp = {"one": "uno", "two": "dos", "three": "tres"}
It doesn”t matter what order we write the pairs. The values in a dictionary are accessed with keys, not with
indices, so there is no need to care about ordering. Here is how we use a key to look up the corresponding
value:
>>> print eng2sp["two"]
’dos’
The key"two" yields the value "dos" .
15.8 Dictionary operations
Thedel statement removes a key-value pair from a dictionary. For example, the following dictionary
contains the names of various fruits and the number of each fruit in stock:
>>> inventory = {"apples": 430, "bananas": 312, "oranges": 525, "pears": 217}
>>> print inventory
{’oranges’: 525, ’apples’: 430, ’pears’: 217, ’bananas’: 312}
If someone buys all of the pears, we can remove the entry from the dictionary:
141
>>> del inventory["pears"]
>>> print inventory
{’oranges’: 525, ’apples’: 430, ’bananas’: 312}
Or if we’re expecting more pears soon, we might just change the value associated with pears:
>>> inventory["pears"] = 0
>>> print inventory
{’oranges’: 525, ’apples’: 430, ’pears’: 0, ’bananas’: 312}
Thelen function also works on dictionaries; it returns the number of key-value pairs:
>>> len(inventory)
4
15.9 Dictionary methods
Dictionaries have a number of useful built-in methods The keys method takes a dictionary and returns a
list of the keys that appear, but instead of the function syntax keys(eng2sp) , we use the method syntax
eng2sp.keys() .
>>> eng2sp.keys()
[’one’, ’three’, ’two’]
This form of dot notation speciﬁes the name of the method, keys , and the name of the object on which
to apply the method, eng2sp . The parentheses indicate that this method takes no parameters. A method
call is called an invocation ; in this case, we would say that we are invoking the keys method on the object
eng2sp .
Thevalues method is similar; it returns a list of the values in the dictionary:
>>> eng2sp.values()
[’uno’, ’tres’, ’dos’]
The items method returns both, in the form of a list of tuples—one for each key-value pair:
>>> eng2sp.items()
[(’one’,’uno’), (’three’, ’tres’), (’two’, ’dos’)]
The syntax provides useful type information. The square brackets indicate that this is a list. The parentheses
indicate that the elements of the list are tuples.
If a method takes an argument, it uses the same syntax as a function call. For example, the method haskey
takes a key and returns true if the key appears in the dictionary:
>>> eng2sp.has_key("one")
True
>>> eng2sp.has_key("deux")
False
If you try to call a method without specifying an object, you get an error. In this case, the error message is
not very helpful:
142
>>> has_key("one")
NameError: name ’has_key’ is not defined
15.10 Aliasing and copying
Because dictionaries are mutable, you need to be aware of aliasing. Whenever two variables refer to the
same object, changes to one affect the other. If you want to modify a dictionary and keep a copy of the
original, use the copy method. For example, opposites is a dictionary that contains pairs of opposites:
>>> opposites = {"up": "down", "right": "wrong", "true": "false"}
>>> alias = opposites
>>> copy = opposites.copy()
alias andopposites refer to the same object; copy refers to a fresh copy of the same dictionary. If we
modifyalias ,opposites is also changed:
>>> alias["right"] = "left"
>>> opposites["right"]
’left’
If we modify copy ,opposites is unchanged:
>>> copy["right"] = "privilege"
>>> opposites["right"]
'left'
These behaviours are perhaps best explained as part of a state diagram:
opposites
alias
copyopposites
alias
copy                      {"up": "down", "right": "wrong", "true": "false"}
                      {"up": "down", "right": "wrong", "true": "false"}
                      {"up": "down", "right": "privilege", "true": "false"}                      {"up": "down", "right": "left", "true": "false"}
143
15.11 Counting letters
In Lecture 8, we wrote a function that counted the number of occurrences of a letter in a string. A more
general version of this problem is to form a histogram of the letters in the string, that is, how many times
each letter appears. Such a histogram might be useful for compressing a text ﬁle. Because different letters
appear with different frequencies, we can compress a ﬁle by using shorter codes for common letters and
longer codes for letters that appear less frequently.
Dictionaries provide an elegant way to generate a histogram:
>>> letter_counts = {}
>>> for letter in "Mississippi":
... letter_counts[letter] = letter_counts.get(letter, 0) + 1
...
>>> letter_counts
{’M’: 1, ’s’: 4, ’p’: 2, ’i’: 4}
We start with an empty dictionary. For each letter in the string, we ﬁnd the current count (possibly zero)
using theget method and then increment it. The get method for dictionaries will check to see if its ﬁrst
argument is a key in the dictionary. If it is, then get will return the value associated with that key. If not,
thenget will return its second argument (in this case, 0). After the for loop, the dictionary contains pairs
of letters and their frequencies. It might be more appealing to display the histogram in alphabetical order.
We can do that with the items method which returns a list, and then sort the resulting list:
>>> letter_items = letter_counts.items()
>>> letter_items.sort()
>>> print letter_items
[(’M’, 1), (’i’, 4), (’p’, 2), (’s’, 4)]
Thesort method is one of several that can be applied to lists, others include append ,extend , and
reverse . Consult the Python documentation for details.
15.12 Glossary
immutable A value that cannot be changed.
mutable A value that can be changed.
tuple An immutable sequence data structure.
tuple assignment An extremely cool way of assigning multiple values to multiple variables:
x, y = 1, 2
dictionary: A collection of key-value pairs that maps from keys to values. The keys can be any immutable
type, and the values can be any type.
key: A value that is used to look up an entry in a dictionary. Keys must be of an immutable type (e.g.
integer, ﬂoat, string, tuple).
key-value pair: One of the items in a dictionary.
invoke: To call a method.
144
15.13 Laboratory exercises
1. Here are some tuples representing people using the Owheo lab, using their ﬁrst and last names.
brendan = "Brendan","McCane"
sandy = "Sandy","Garner"
nick = "Nick","Meek"
student1 = "Allan", "Anderson"
student2 = "Barry", "Byars"
student3 = "Christine", "Carver"
student4 = "Delia","de Wattinger"
(a) Put the tuples in a list, then use a for loop to print just each last name.
(b) Allocate all the names to a set variable called owheo .
(c) Allocate the ﬁrst 3 tuples to a set variable called teachers .
(d) Allocate the remainder to a set variable called students .
(e) Use a for loop to print each student’s name, properly formatted e.g. Allan Anderson
(f) Use a for loop to print each teacher’s name just using the ﬁrst initial of the ﬁrst name e.g. B.
McCane
2. Write a function that takes a list of items and returns the number of unique items in the list. The
function should pass the following doctests:
defnum_unique(a_list):
"""
>>> num_unique([1, 2])
2
>>> num_unique([1, 2, 2, 2, 1, 2, 1, 2, 2, 1])
2
>>> num_unique([1, 1, 1, 1, 1])
1
>>> num_unique([1, 2, 3, 4, 5])
5
"""
Hint: Use a set.
3. Write a function that takes a list of numbers and returns the mean and the median of the list as a tuple.
For the median, if there are an even number of numbers in the list, then return the average of the two
middle numbers. The function should pass the following doctests:
defmean_median(number_list):
"""
>>> mean_median([1, 2, 3])
(2.0, 2.0)
>>> mean_median([1, 2, 9])
(4.0, 2.0)
>>> mean_median([8, 2, 2])
(4.0, 2.0)
>>> mean_median([2, 8, 1, 1])
(3.0, 1.5)
"""
145
4. Write a program that reads in a string and prints a table of the letters of the alphabet that occur in
the string together with the number of times each letter occurs. The table should be arranged in
alphabetical order. You should use a dictionary for this problem. Case should be ignored. A sample
run of the program would look this this:
Enter a string: > ThiS is String with Upper and lower case Letters.
a 2
c 1
d 1
e 5
g 1
h 2
i 4
l 2
n 2
o 1
p 2
r 4
s 5
t 5
u 1
w 2
5. Write another program that reads the text from a ﬁle and produces a similar output to that in question
4.
6. Write a program that reads in a string and returns a table of letter-pairs that occur in the string and
how often they occur. A sample run of the program would look like this (the order of the table is not
important):
Enter a string: > banana
ba 1
an 2
na 2
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
146
Lecture 16
No Lecture Today
There is no lecture on Wednesday 16th April.
16.1 No Lab This Session
There is no laboratory this session because of Easter.
147
148
Lecture 17
Classes and objects - Part 1
17.1 Object-oriented programming
Python is an object-oriented programming language , which means that it provides features that support
object-oriented programming (OOP ). Object-oriented programming has its roots in the 1960s, but it wasn’t
until the mid 1990s that it became the main programming paradigm used in the creation of new software.
It was developed as a way to handle the rapidly increasing size and complexity of software systems, and to
make it easier to modify these large and complex systems over time. Up to this point we have been writing
programs using a procedural programming paradigm. In procedural programming the focus is on writing
functions or procedures which operate on data. In object-oriented programming the focus is on the creation
ofobjects which contain both data and functionality together. This lecture is just a very brief introduction
to object-oriented programming and many of the issues are skipped over or touched on only very lightly. If
you want to know more about object-oriented programming (and it is the dominant form of programming
today), then you should do COMP160 in semester 2.
17.2 User-deﬁned compound types
A class in essence deﬁnes a new data type . We have been using several of Python’s built-in types through-
out this book (Integers, Reals, Strings, Lists, Dictionaries etc), but we can also deﬁne new types if we wish.
Deﬁning a new type in Python is very easy:
classCLASSNAME:
<statement 1>
<statement 2>
...
<statement n>
Class deﬁnitions can appear anywhere in a program, but they are usually near the beginning (after the
import statements). The syntax rules for a class deﬁnition are the same as for other compound statements.
There is a header which begins with the keyword, class , followed by the name of the class, and ending
with a colon. In most cases, the statements inside a class deﬁnition should be function deﬁnitions. Functions
deﬁned inside a class have a special name — they are called methods of the class. Although not required
by Python, <statement 1> should be a docstring describing the class and <statement 2> should be
aninitialization method. The init method is a special method that is called just after a variable of the
class type is constructed orinstantiated . Variables of the class type are also called instances orobjects of
149
that type.
We are now ready to create our own user-deﬁned type: the Point . Consider the concept of a mathematical
point. In two dimensions, a point is two numbers (coordinates) that are treated collectively as a single
object. In mathematical notation, points are often written in parentheses with a comma separating the
coordinates. For example, (0;0)represents the origin, and (x;y)represents the point xunits to the right and
yunits up from the origin. A natural way to represent a point in Python is with two numeric values. The
question, then, is how to group these two values into a compound object. The quick and dirty solution is
to use a list or tuple, and for some applications that might be the best choice. An alternative is to deﬁne a
new user-deﬁned compound type, also called a class . This approach involves a bit more effort, but it has
advantages that will become apparent soon.
Here’s a simple deﬁnition of Point which we can put into a ﬁle called Point.py :
classPoint:
"""A class to represent a two-dimensional point"""
def__init__(self, x=0, y=0):
self.x = x
self.y = y
You may have noticed the special form of some of the init method’s parameters. Parameters speciﬁ-
cations such as x=0, create a parameter that has a default value and is called a named parameter that has a
default parameter value .
Here’s a different example:
defread_value_type(prompt='Enter a value> ', convert=float):
val = input(prompt)
returnconvert(val)
printread_value_type()
printread_value_type(prompt='Enter a float> ')
printread_value_type(convert=int)
printread_value_type(prompt='Enter a boolean> ', convert=bool)
The only limitation on default parameters is that they must come after non-default parameters in the func-
tion deﬁnition.
17.3 The init Method and self
You will see from the class deﬁnition above the special method called init . This method is called when
aPoint object is instantiated. To instantiate a Point object, we call a function named (you guessed it)
Point :
>>> type(Point)
<type ’classobj’>
>>> p = Point()
>>> type(p)
<type ’instance’>
The function Point() is called the class constructor . The variable pis assigned a reference to a new Point
object. When calling the function Point() , Python performs some magic behind the scenes and calls the
init method from within the class constructor.
Theinit method has a parameter called self . Every class method must have at least one parameter
150
and that parameter should be called self . Theself parameter is a reference to the object on which the
method is being called (more on this below).
17.4 Attributes
Theinit method above contains the deﬁnition of two object variables xandy. Object variables are
also called attributes of the object. Once a Point object has been instantiated, it is now valid to refer to its
attributes:
>>> p = Point()
>>> print p.x, p.y
0 0
>>> p.x = 3
>>> p.y = 4
>>> print p.x, p.y
3 4
This syntax is similar to the syntax for selecting a variable from a module, such as math.pi orstring.uppercase .
Both modules and instances create their own namespaces, and the syntax for accessing names contained in
each, called attributes , is the same. In this case the attribute we are selecting is a data item from an instance.
The following state diagram shows the result of these assignments:
x
yPoint
p
43
The variable prefers to a Point object, which contains two attributes. Each attribute refers to a number.
The expression p.x means, Go to the object prefers to and get the value of x. The purpose of dot notation
is to identify which variable you are referring to unambiguously. You can use dot notation as part of any
expression, so the following statements are legal:
print"({:d}, {:d})".format(p.x, p.y)
distanceSquared = p.x *p.x + p.y *p.y
The ﬁrst line outputs (3, 4) ; the second line calculates the value 25.
17.5 Methods
init is an example of a class function or method . We can add as many methods as we like to a class,
and this is one of the reasons OOP is so powerful. It’s quite a different way of thinking about programming.
Rather than having functions that act on any old data, in OOP , the data carries the required functionality
around with it.
151
Let’s add a few methods to our Point class:
importmath
classPoint:
"""A class to represent a two-dimensional point"""
def__init__(self, x=0, y=0):
self.x = x
self.y = y
defmove(self, dx, dy):
self.x += dx
self.y += dy
defdistance(self, p2):
dx = self.x - p2.x
dy = self.y - p2.y
returnmath.sqrt(dx *dx+dy*dy)
p1 = Point()
p1.move(2,3)
p2 = Point()
p2.move(5,7)
printp1.distance(p2)
If we run the above program, we should get 5:0as the output.
17.6 Sameness
The meaning of the word same seems perfectly clear until you give it some thought, and then you realize
there is more to it than you expected. For example, if you say, “Chris and I have the same car”, you mean
that his car and yours are the same make and model, but that they are two different cars. If you say, “Chris
and I have the same mother”, you mean that his mother and yours are the same person. When you talk
about objects, there is a similar ambiguity. For example, if two Points are the same, does that mean they
contain the same data (coordinates) or that they are actually the same object? To ﬁnd out if two references
refer to the same object, use the ==operator. For example:
>>> p1 = Point()
>>> p1.x = 3
>>> p1.y = 4
>>> p2 = Point()
>>> p2.x = 3
>>> p2.y = 4
>>> p1 == p2
False
Even though p1andp2contain the same coordinates, they are not the same object.
152
If we assign p1top2, then the two variables are aliases of the same object:
>>> p2 = p1
>>> p1 == p2
True
This type of equality is called shallow equality because it compares only the references, not the contents of
the objects. To compare the contents of the objects— deep equality —we can add a method called equals
to our class deﬁnition:
importmath
classPoint:
"""A class to represent a two-dimensional point"""
def__init__(self, x=0, y=0):
self.x = x
self.y = y
defmove(self, dx, dy):
self.x += dx
self.y += dy
defdistance(self, p2):
dx = self.x - p2.x
dy = self.y - p2.y
returnmath.sqrt(dx *dx+dy*dy)
defequals(self, p2):
return(self.x == p2.x) and(self.y == p2.y)
p1 = Point(2, 3)
p2 = Point(2, 3)
printp1 == p2
printp1.equals(p2)
The output of the above program is:
False
True
Of course, if the two variables refer to the same object, they have both shallow and deep equality.
17.7 Interface and Representation
One of the beneﬁts of OOP is that it is very easy to separate how a program interacts with an object (by
calling methods of the object), with how the particular class is implemented. If such a separation is made,
then the programmer can easily change the implementation without affecting all the code that uses that
class. This is a very powerful notion because we might later discover a much better way of implementing
a particular data structure. For example, I might decide to implement the point using a list rather than as
two variables:
153
importmath
classPoint:
"""A class to represent a two-dimensional point"""
def__init__(self, x=0, y=0):
self.pt = [x, y]
defmove(self, dx, dy):
self.pt[0] += dx
self.pt[1] += dy
defdistance(self, p2):
dx = self.pt[0] - p2.pt[0]
dy = self.pt[1] - p2.pt[1]
returnmath.sqrt(dx *dx+dy*dy)
defequals(self, p2):
return(self.pt[0] == p2.pt[0]) and(self.pt[1] == p2.pt[1])
p1 = Point(2, 3)
p2 = Point(2, 3)
printp1 == p2
printp1.equals(p2)
Note that although the implementation of the Point class changed, the code that used Point did not.
This is because the interface did not change (that is, the method arguments and return values remained
consistent).
This separation of interface and representation allows us to access objects independent of the class imple-
mentation. For example, an equally valid representation of a point is as an angle from horizontal and a
distance from the origin. These are called polar coordinates or (r;)coordinates ( rfor radius, for the an-
gle). Rather than having two different classes for each representation, we can use a single class and provide
(r;)coordinates as derived values via a method:
importmath
classPoint:
...
defget_polar_coordinates(self):
r = math.sqrt(self.x *self.x+self.y *self.y)
theta = math.atan2(self.y, self.x)
return(r, theta)
...
p1 = Point()
p1.move(0,2)
printp1.get_polar_coordinates()
154
Which, when run, produces:
(2.0, 1.5707963267948966)
Note thatis represented in radians and not degrees.
17.8 Glossary
abstraction: Hiding details of implementation behind a programming structure such as a class. Essentially
abstracting away the details.
attribute: One of the named data items that makes up an instance.
class: A user-deﬁned compound type. A class can also be thought of as a template for the objects that are
instances of it.
constructor: A method used to create new objects.
deep equality: Equality of values, or two references that point to objects that have the same value.
information hiding: See abstraction.
initialization: Theinit method is used to initialize an object when it is created.
instantiate: To create an instance of a class.
instance: An object that belongs to a class.
interface: The public face of a class. That is, the methods used and the method signatures (parameters and
return types).
method: A function that belongs to a class.
object: A variable whose type is deﬁned by its class.
object oriented programming: Programming by deﬁning classes and instantiating objects. Classes contain
data and functions.
procedural programming: Programming where functions and data are represented separately. This book
(but not this chapter) has been concerned mostly with procedural programming.
shallow equality: Equality of references, or two references that point to the same object.
named parameter: When making a function call it is possible to explicitly name the parameters as in
readvaluetype(prompt="Enter a float> ") .
default parameter: A parameter which is assigned a default value in a function deﬁnition.
155
17.9 Laboratory exercises
1. Astr object can be constructed by passing any object to str constructor.
(a) Write code that calls str on a Point object. Record the output below:
(b) The answer to the previous question is generally not what we want. To get str to produce
something sensible, we can deﬁne a str method that returns any string we like. Add a
str method to Point that returns for example, “(5, 3)” for a Point whosexvalue is 5andy
value is 3.
(c) Add a str method to Rectangle so that it returns something sensible.
2. Python includes the very convenient notion of operator overloading which allows the programmer to add
operators to classes (e.g. the plus operator, ’+’). This is very convenient for classes that represent numerical
types, but can also be useful for non-numerical types (e.g. strings). For example, if I were to deﬁne a
two-dimensional vector (a mathematical object a bit like a point), then I might deﬁne it as follows with an
add method:
classVec2D:
def__init__(self):
self.x = 0
self.y = 0
def__add__(self, other):
val = Vec2D()
val.x = self.x + other.x
val.y = self.y + other.y
return(val)
Theadd method allows us to use the ’+’ operator to add two vectors:
>>> a = Vec2D()
>>> a.x = 2
>>> a.y = 3
>>> b = Vec2D()
>>> b.x = 4
>>> b.y = 5
>>> c = a+b
>>> print c.x, c.y
6 8
(a) Add a sub method for the operator ’-’ to the Vec2D class.
(b) A vector can be multiplied by a scalar value (e.g. a ﬂoat), which simply multiplies each compo-
nent with the scalar. Add a mul method to implement scalar multiplication. Make sure you
test your method.
3.Extension Exercise: Generalise the Vec2D class so that it can be a vector of any dimension.
4.Extension Exercise: In Lecture 14, we used lists of lists to represent a matrix. Using Test Driven Devel-
opment, implement a matrix class that includes the following methods:
•get(i,j) : returns the matrix element (i;j).
• ’+’: adds two matrices
156
• ’*’: multiplies two matrices
•str : converts the matrix to a nice string representation.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
157
158
Lecture 18
Classes and objects - Part 2
18.1 Rectangles
Let’s say that we want a class to represent a rectangle. The question is, what information do we have to
provide in order to specify a rectangle? To keep things simple, assume that the rectangle is oriented either
vertically or horizontally, never at an angle. There are a few possibilities: we could specify the center of
the rectangle (two coordinates) and its size (width and height); or we could specify one of the corners
and the size; or we could specify two opposing corners. A conventional choice is to specify the upper-left
corner of the rectangle and the size. Again, we’ll deﬁne a new class called Rectangle in a new ﬁle called
Rectangle.py :
fromPoint import*
classRectangle:
def__init__(self):
self.corner = Point()
self.width = 100
self.height = 100
box = Rectangle()
printbox.corner.x, box.corner.y, box.width, box.height
Which, when run, produces the following output:
0 0 100 100
Note that within a Rectangle we have created a member attribute which is itself an object — in this case
aPoint . The dot operator composes. The expression box.corner.x means, Go to the object box refers to
and select the attribute named corner; then go to that object and select the attribute named x. The ﬁgure shows the
state of this object:
y0 x
0width
height
cornerPointRectangle
box
100100
159
Classes (and hence objects) can be made as complex as we like, and as programs become larger, hiding
this data complexity becomes increasingly important. This is the notion of abstraction and information
hiding . The power of using classes and objects arises because the objects can be viewed abstractly with
little thought to how the class is actually implemented. Just like we have been using strings, lists and
dictionaries without thinking about how they have been implemented, we can also create our own types
for later use, without worrying about their internals.
18.2 Instances as return values
Functions and methods can also return instances. For example, we may want to calculate the centre of the
rectangle. We can do that by adding a centre method to our class deﬁnition:
fromPoint import*
classRectangle:
def__init__(self):
self.corner = Point()
self.width = 100
self.height = 100
defcentre(self):
c = Point()
c.x = self.corner.x + self.width/2.0
c.y = self.corner.y + self.height/2.0
returnc
box = Rectangle()
printbox.corner.x, box.corner.y, box.width, box.height
c = box.centre()
printc.x, c.y
If we execute this program, we get:
0 0 100 100
50.0 50.0
18.3 Objects are mutable
We can change the state of an object by making an assignment to one of its attributes. For example, to
change the size of a rectangle without changing its position, we could modify the values of width and
height :
box.width = box.width + 50
box.height = box.height + 100
160
18.4 Copying
Aliasing can make a program difﬁcult to read because changes made in one place might have unexpected
effects in another place. It is hard to keep track of all the variables that might refer to a given object.
Copying an object is often an alternative to aliasing. The copy module contains a function called copy that
can duplicate any object:
>>> import copy
>>> p1 = Point()
>>> p1.x = 3
>>> p1.y = 4
>>> p2 = copy.copy(p1)
>>> p1 == p2
False
>>> p1.equals(p2)
True
Once we import the copy module, we can use the copy method to make a new Point .p1andp2are not
the same point, but they contain the same data. To copy a simple object like a Point , which doesn’t contain
any embedded objects, copy is sufﬁcient. This is called shallow copying . For something like a Rectangle ,
which contains a reference to a Point , copy doesn’t do quite the right thing. It copies the reference to the
Point object, so both the old Rectangle and the new one refer to a single Point.
If we create a box, b1, in the usual way and then make a copy, b2, using copy, the resulting state diagram
looks like this:
y0 x
0100width
height
cornerwidth
height
cornerb1 b2
100100 100
This is almost certainly not what we want. Can you think why?
 
zend
 
Fortunately, the copy module contains a method named deepcopy that copies not only the object but also
any embedded objects. You will not be surprised to learn that this operation is called a deep copy .
>>> b2 = copy.deepcopy(b1)
Nowb1andb2are completely separate objects.
18.5 A Polygon Class
As a further example, let’s write a class for a polygon. A polygon has an arbitrary number of vertices that
come in a speciﬁc order, so it makes sense to represent polygons as a list of Point s. We could just use a list
161
ofPoint s and leave it at that, but there is also certain functionality that would be useful to associate with
the polygon such as adding a point, removing a point, moving the polygon, and an equality method. Using
a class allows us to package up the representation and the functionality into a convenient single piece of
Python (I’ve left out doctests for the sake of brevity):
fromPoint importPoint
importcopy
classPolygon:
"""
A polygon class with any number of points.
"""
def__init__(self):
self.points = []
defadd_point(self, x, y):
self.points.append(Point(x, y))
defget_point(self, index):
if0 < index < len(self.points):
returnself.points[index]
else:
returnNone
defremove_point(self, index):
if0 < index < len(self.points):
delself.points[index]
defmove(self, dx, dy):
forpinself.points:
p.move(dx, dy)
defget_point_index(self, pt):
"""
Search through the points in the polygon and return the index
if the passed in point is found, or -1 otherwise.
"""
index = -1
fori,p inenumerate(self.points):
ifp.equals(pt):
index = i
returnindex
def__str__(self):
s = ""
forpinself.points:
s += str(p) + "; "
returns
defequals(self, p2):
eq = len(self.points)==len(p2.points)
forp1,p2 inzip(self.points, p2.points):
eq = eq andp1.equals(p2)
returneq
162
And here is a little bit of code using the Polygon class:
>>> poly = Polygon()
>>> poly.add_point(0,0)
>>> poly.add_point(0,1)
>>> poly.add_point(0,2)
>>> poly.add_point(1,1)
>>> str(poly)
’0, 0; 0, 1; 0, 2; 1, 1; ’
>>> poly.move(1, 1)
’1, 1; 1, 2; 1, 3; 2, 2; ’
18.6 Glossary
deep copy: To copy the contents of an object as well as any embedded objects, and any objects embedded
in them, and so on; implemented by the deepcopy function in the copy module.
shallow copy: To copy the contents of an object, including any references to embedded objects; imple-
mented by the copy function in the copy module.
163
18.7 Laboratory exercises
1. Add an equals method to the Rectangle class. The method should do a deep equality check. Recall
that deep equality means that equals should return True if the contents of the structure are equal
andFalse otherwise. Here is the skeleton and two doctests for the method:
defequals(self, otherRect):
"""
Test if this rectangle is equal to otherRect. Deep
equality should be tested.
>>> r1 = Rectangle()
>>> r1.corner.x = 50
>>> r1.corner.y = 40
>>> r1.width = 200
>>> r2 = Rectangle()
>>> r2.corner.x = 50
>>> r2.corner.y = 40
>>> r2.width = 200
>>> r1.equals(r2)
True
>>> r2.height = 200
>>> r1.equals(r2)
False
"""
2. Add a method called move toRectangle that has the effect of moving the location of the rectangle.
3. Add a method called insertpointat(self, pt, index) toPolygon that inserts a new point
after the given index. If the index is -1, then it should insert the point at the beginning of the list of
points. If the index is greater than or equal to the length of the list, it should insert the point at the
end. Write several doctests to test your method.
4. Write a method that will compute the centroid of the polygon. The centroid is computed by indepen-
dently averaging the x and y coordinates of each of the vertices in the polygon.
5. Write a method that will rotate the polygon around the origin. To rotate a point by an angle , the
following formulae can be used:
x0=xcos() ysin()
y0=xsin() +ycos();
wherex0andy0are the new coordinates of the point.
6.Extension Exercise: Write a method that will rotate the polygon around its centroid. The easiest way
to do this is to ﬁrst move the polygon so its centroid is at (0;0), then do the rotation, then move the
polygon back to its original centroid location.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
164
Lecture 19
Graphical user interface programming
19.1 Event driven programming
Graphical User Interface (GUI) programming is very different from the kind of programming we’ve been
discussing so far. We might call the programming we’ve done so far Sequence Driven Programming . In this
style of program, the computer does something, then does something else, perhaps waiting for the user to
type something in, or getting input from somewhere else, but essentially it proceeds in a sequential fashion.
GUI programs are different because they are usually Event Driven . In this sort of program, there is usually
a lot more user interaction, and the program almost always has to do something (redrawing itself on the
screen if nothing else).
Before looking at actual GUI programs, it’s worthwhile seeing how we might simulate event driven pro-
gramming using sequence driven programming. After all, underneath the hood, at the system level, it
really is sequence driven programming that is happening. Consider the Python program displayed in Fig-
ure 19.1.
The program in Figure 19.1 contains all the elements of an event-driven program. It has an event loop that
runs forever, a way of getting events from the user, a function that processes events, and a function that
redraws the screen. Note also that we used a class for our simulated event loop. This is not completely
necessary, but generally makes writing GUI applications a little easier.
19.2 TkInter introduction
Tkinter (Tk interface) is Python’s default GUI toolkit, although there are many others. It is reasonably
simple and lightweight and should be perfectly adequate for GUI programs of small to medium complexity.
Let’s have a look at a simple Tkinter program:
165
classEventLoop:
"""
A non-gui simulated event loop class.
"""
def__init__(self):
self.text = ""
defdraw_screen(self):
foriinrange(20):
print
printself.text
defget_event(self):
returnraw_input()
defprocess_event(self, event):
if(event == "quit"):
quit()
elif(event == "hello"):
self.text = "Hello to you too"
elif(event == "goodbye"):
self.text = "Goodbye"
self.draw_screen()
self.process_event("quit")
else:
self.text = "I don't know that event"
defmainloop(self):
# start the event loop
whileTrue:
event = self.get_event();
self.process_event(event);
self.draw_screen();
event = EventLoop()
event.mainloop()
Figure 19.1: A simulated event loop.
166
fromTkinter import*
classHelloWorld:
"""
A Hello World App.
"""
def__init__(self, parent):
self.label = Label(parent, text="Hello World")
self.label.grid(column=0,row=0)
# create the root window
root = Tk();
# create the application
app = HelloWorld(root)
# enter the main loop
root.mainloop()
If you run1the above program, you should see a window which looks like Figure 19.2.
Figure 19.2: Tkinter Hello World
.
The structure of the program above is typical of a Tkinter program and has the following general steps:
1. deﬁne a class which encapsulates the user interface components of the application:
(a) create the speciﬁc user interface components
(b) specify where in the interface the elements should go (by calling the grid method),
2. create the root window ( root = Tk() ),
3. instantiate a member of the application class
4. enter the main loop.
Note that root andlabel are objects of class TkandLabel respectively. These classes are deﬁned by
Tkinter.
One piece of notation you should be familiar with is the term widget . A widget is a GUI element. Every
GUI element can be called a widget. Tkinter has several different types of widgets. The most useful ones
are:
Tk:the root widget,
1Problems can arise when running TkInter programs from within Idle as Idle is also a TkInter program. However, the example
code in this book should run ﬁne.
167
Label :a widget containing ﬁxed text,
Button :a button widget,
Entry :a widget for entry of single lines of text,
Canvas :a widget for drawing shapes onto the screen.
19.3 Introducing callbacks
To do anything really useful with GUI programming, we need some way of associating an action with a
widget. Usually, when the user presses a button on a GUI she expects something to happen as a result.
Let’s make our Hello World program a bit more complex, by adding two buttons:
fromTkinter import*
classHelloWorld:
"""
A Hello World App with a callback
"""
def__init__(self, parent):
self.hello_button = Button(parent, text="Hello", command = self.say_hi)
self.hello_button.grid(column=0, row=0)
self.quit_button = Button(parent, text="Quit", fg="red", command=parent.destroy)
self.quit_button.grid(column=1,row=0)
defsay_hi(self):
print"hi there";
root = Tk()
app = HelloWorld(root)
root.mainloop()
If we run the above program, we will get a window that looks like Figure 19.3. In both calls to the function
Button , there is a parameter called command . The value of the command parameter is the callback or
function associated with the action of pressing the button. So, if we press the Hello button, it should print
‘hi there’ to the system console because that’s what the function sayhidoes. If we press the Quit button,
then the special function parent.destroy will be called which, unsurprisingly, causes the window to be
destroyed.
Figure 19.3: Tkinter Buttons
.
Since we’re writing a GUI program, it would be very unusual (and quite disconcerting) to make use of the
console at all. When we want to give a message to the user, it is more usual to use a dialog widget. The
168
moduletkMessageBox includes numerous useful dialogs. The above program can be modiﬁed to use a
showinfo dialog box instead:
fromTkinter import*
fromtkMessageBox import*
classHelloWorld:
"""
A Hello World app with a message box
"""
def__init__(self, parent):
self.hello_button = Button(parent, text="Hello", command = self.say_hi)
self.hello_button.grid(column=0, row=0)
self.quit_button = Button(parent, text="Quit", fg="red",
command=parent.destroy)
self.quit_button.grid(column=1,row=0)
defsay_hi(self):
showinfo(message="Hi there")
root = Tk()
app = HelloWorld(root)
root.mainloop()
Now when we press the Hello button, we should see something similar to Figure 19.4.
Figure 19.4: Tkinter Hello World Dialog
.
19.4 User input
Tkinter has several widgets available for getting input from the user. Dialog boxes allow one sort of input,
but most interfaces have some form of input on the main window. There are two main widgets for doing
this:Entry andText . We will use the Entry widget for our simple application.
To make use of user input widgets, we need a mechanism for getting information back out of the widget.
The easiest way to do that is to use the get method from the widget and subsequently convert the string to
the appropriate variable if needed.
169
Let’s have a look at an example of how to use an Entry widget:
fromTkinter import*
fromtkMessageBox import*
classHelloInput:
"""
An app that gets input from the user and associates Tkinter variables with
the input.
"""
def__init__(self, parent):
self.hello_button = Button(parent, text="Hello", command = self.say_hi)
self.hello_button.grid(column=2, row=0)
self.quit_button = Button(parent, text="Quit", fg="red", command=parent.destroy)
self.quit_button.grid(column=3,row=0)
self.input = Entry(parent)
self.input.grid(column=1,row=0)
self.label = Label(parent, text="Enter your name: ")
self.label.grid(column=0, row=0)
defsay_hi(self):
showinfo(message="Hi there "+self.input.get())
root = Tk()
app = HelloInput(root)
root.mainloop()
Note that when the callback sayhiis called, the string associated with the Entry widget is retrieved and
included as part of the dialog message. The main window for this program can be seen in Figure 19.5.
Figure 19.5: Tkinter Entry Example
.
19.5 Mini-case study
Let’s write a simple GUI program that can convert from Fahrenheit to Celsius. The conversion equation is
quite simple:
c=5
9(f 32); (19.1)
wherefis the temperature in Fahrenheit and cis the temperature in Celsius.
For this program, we’ll need an Entry widget, an output Label widget, aButton widget to do the con-
version and a Button widget to quit the application. The program, tkconverter1.py , is shown below:
170
fromTkinter import*
classTempConverter:
"""
A simple app for converting from Fahrenheit to Celsius
"""
def__init__(self, parent):
self.celsius_val = Label(parent, text="", width=20)
self.celsius_val.grid(column=1,row=1)
self.celsius_label = Label(parent, text="Celsius", width=20)
self.celsius_label.grid(column=1, row=0)
self.fahr_input = Entry(parent)
self.fahr_input.grid(column=0,row=1)
self.fahr_label = Label(parent, text="Fahrenheit")
self.fahr_label.grid(column=0, row=0)
self.convert_button = Button(parent, text="Convert", command=self.convert)
self.convert_button.grid(row=2, column=0)
self.quit_button = Button(parent, text="Quit", command=parent.destroy)
self.quit_button.grid(row=2, column=1)
defconvert(self):
# get the fahrenheit value from the widget and convert it from
# a string to a float number
dfahr = float(self.fahr_input.get())
# calculate the celsius value as a float
celsius = (dfahr-32) *5.0/9.0
# update the celsius widget with the celsius value by
# converting from a float to a string
self.celsius_val.configure(text = str(celsius))
root = Tk()
app = TempConverter(root)
root.mainloop()
The function convert does the conversion. Notice how it ﬁrst gets the value from self.fahr input
which is what the user entered into the entry ﬁeld. Then it does the conversion, and ﬁnally, it changes the
text on the output ﬁeld by calling the configure method. If you type in and run the above program, you
should get an application that looks like Figure 19.6.2
19.6 Glossary
Graphical User Interface (GUI): a program interface using graphical output and input is often taken di-
rectly from the keyboard and mouse.
Event Driven: A programming style where the ﬂow of control of the program is determined by external
events such as mouse-clicks, keyboard presses, etc.
Global variables: Variables that can be accessed from anywhere within a program. The use of global vari-
ables should be limited as much as possible.
2Note that if the user enters something that isn’t a number an error will occur (actually an exception). To be thorough, we should
encase the conversion in a try-except block. Unfortunately, we don’t have the time to cover exceptions in COMP150.
171
Figure 19.6: Fahrenheit to Celsius Converter
.
Objects: A special type of compound variable that has speciﬁc functions (called methods) associated with
that variable type.
Object-Oriented Programming: Programming in a language that supports objects.
Widget: A GUI element such as a window, button, label, etc.
Dialog: A transient widget often used for alerting the user or getting information from the user.
172
19.7 Laboratory exercises
1. Add a function called convert ftoctotkconverter1.py .convert ftocshould take the
temperature in Fahrenheit as input and return the temperature in Celsius. It should pass the following
doctests:
defconvert_f_to_c(self, fahr):
"""
Convert from fahrenheit to celsius. The variable self is the
object parameter.
Note: when comparing floating values, == is usually inadequate. You
normally have to test whether two floats are close enough.
>>> testConvert = TempConverter(Tk())
>>> c = testConvert.convert_f_to_c(-40)
>>> abs(c+40.0)<1e-8
True
>>> c = testConvert.convert_f_to_c(100)
>>> abs(c-37.7777777777)<1e-8
True
"""
Note that this is the correct way to test equality of real numbers, you should never use a direct com-
parison. You can have the doctests tested each time you run the program by including the following
code just before the call to root.mainloop :
importdoctest
doctest.testmod()
2. Modify the function convert so that it makes use of the new function convert ftoc.
3. Create a new function called convert ctofand devise appropriate doctests to test it.
4. In theconvert function, use a class attribute called forwardConvert which can be either True or
False . Modifyconvert to use anif-else statement to call convert ftocifforwardConvert
isTrue andconvert ctofifforwardConvert isFalse .
5. Add aCheckbutton button to your interface with the following code:
self.forward_button = Checkbutton(parent, text="do forward conversion",
command=self.toggle_convert)
self.forward_button.grid(column=0,row=3)
You will also need to add a method called toggleconvert that allows the program to keep track of
whether the converter should do a forward convert or a backwards convert (do this using a boolean
variable). Finally, modify the convert method so that the appropriate conversion function is used
(eitherconvert ftocorconvert ctof).
6.Extension Exercise: Extend your temperature converter so that other conversions are also handled.
E.g. miles to kilometres, pounds to kilograms, litres to gallons etc. You’ll need to look up the conver-
sion equations on the web. Also, this exercise requires a bit of creativity in how you structure your
interface. See if you can come up with several options before deciding on a particular look.
7.Extension Exercise: Using the code from section 19.4 as a starting point write a program which reads
mathematical expressions from the user and displays a message box containing the result.
173
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
174
Lecture 20
Case study: Catch
20.1 Graphics
The Tkinter canvas widget can be used to draw shapes to a window. We are going to spend the next two
lectures building a simple computer game. The game is called catch — the game tosses the ball across the
screen, and the player has to catch the ball with their mitt. The game is just for a bit of fun, but it will make
use of several important concepts we’ve introduced so far in the course. Let’s start by creating a canvas in
a ﬁle called circle.py and drawing a circle onto it:
fromTkinter import*
classCatchGame:
"""
A circle in a window.
"""
def__init__(self, parent):
self.canvas = Canvas(parent, width=200, height=200)
self.canvas.grid(column=0,row=0)
self.ball = self.canvas.create_oval(90,90,110,110,fill="blue")
root = Tk()
app = CatchGame(root)
root.mainloop()
If you run the above program, you should get output similar to Figure 20.1. The important line in circle.py
is the call to createoval which can produce an ellipse shape (circles are a type of ellipse). The createoval
function returns a variable which we can use later to modify various aspects of the display.
20.2 Moving the ball
To change the coordinates of a shape on the canvas, we can use the coords function. However, if we
want to move a shape whilst the canvas is displayed, then we need to use some form of callback. In
tkmovecircle.py below, we add a callback called move which is called after 1 second by using the
functionafter :
175
Figure 20.1: Tkinter Canvas Program.
fromTkinter import*
classCatchGame:
"""
A moving circle in a window.
"""
def__init__(self, parent):
self.canvas = Canvas(parent, width=200, height=200)
self.canvas.grid(column=0,row=0)
self.ball = self.canvas.create_oval(90,90,110,110,fill="blue")
self.canvas.after(1000, self.move)
defmove(self):
self.canvas.coords(self.ball, 150, 150, 170, 170)
root = Tk()
game = CatchGame(root)
root.mainloop()
Theself.canvas.after(1000, self.move) function call does some magic under the hood of Tkinter
and causes the function CatchGame.move to be called after 1000 milliseconds (or 1 second).
That’s all well and good, but a little limiting. For a catch game, we really need the ball to be moving
continuously across the screen. Before having a look at the solution below, it is worthwhile spending some
time to see if you can ﬁgure out how to do this yourself.
The solution is quite simple and rather ingenious. All we need to do is call the Canvas.after function at
the end of every move function. Well, not quite, we also need to do some housekeeping to keep track of the
current coordinates of the ball, and change them at each call to move . Type the following code into a ﬁle
calledtkmovecircle2.py and see what happens:
176
fromTkinter import*
importrandom
classCatchGame:
"""
A random moving circle in a window.
"""
def__init__(self, parent):
self.canvas = Canvas(parent, width=200, height=200)
self.canvas.grid(column=0,row=0)
self.x = 10
self.y = 100
self.dx = 2
self.dy = 2
self.ball = self.canvas.create_oval(self.x,self.y,self.x+20,self.y+20,fill="blue")
self.canvas.after(100, self.move)
defmove(self):
self.x = self.x+self.dx
self.y = self.y+self.dy
self.canvas.coords(self.ball, self.x, self.y, self.x+20, self.y+20)
self.canvas.after(100, self.move)
root = Tk()
game = CatchGame(root)
root.mainloop()
When running the program you should see the ball move from the top left of the canvas towards the bottom
right and then off the screen forever.
20.3 Adding randomness
A game that has the ball starting in the same position is going to be pretty boring, so let’s add some
randomness to the start position and direction. We can do that by using the random module. Here is
tkmovecircle2.py where I’ve shown only the modiﬁed lines.
fromTkinter import*
importrandom
...
self.x = 10
self.y = random.randint(10,190)
self.dx = 2
self.dy = random.randint(-5,5)
...
Now we have a ball that’s a bit more interesting — it starts on the left hand side of the window, and heads
off in a random direction. Unfortunately, it often quickly disappears from the window, never to return.
What we really need is to have the ball bounce off the top and bottom of the window. This is another
situation where it’s worth spending some time thinking about how to make the ball bounce. So before you
look on ahead, see if you can come up with a reasonable scheme.
The solution is actually quite simple. A perfect bounce that loses no energy in the collision should leave the
bounce at the same angle as it entered. If the ball is bouncing off a horizontal surface, its velocity in the x
177
direction will stay the same, and it’s velocity in the ydirection will be opposite to what it was before. This
can be achieved fairly easily with an if-elif statement. The move function becomes:
fromTkinter import*
importrandom
classCatchGame:
"""
A bouncing random moving circle in a window.
"""
def__init__(self, parent):
self.canvas = Canvas(parent, width=200, height=200)
self.canvas.grid(column=0,row=0)
self.x = 10
self.y = random.randint(10,190)
self.dx = 2
self.dy = random.randint(-5,5)
self.ball = self.canvas.create_oval(self.x,self.y,self.x+20,self.y+20,
fill="blue")
self.canvas.after(100, self.move)
defmove(self):
self.x = self.x+self.dx
self.y = self.y+self.dy
ifself.y<0:
self.y = 0
self.dy = -self.dy
elifself.y>180:
self.y = 180
self.dy = -self.dy
self.canvas.coords(self.ball, self.x, self.y, self.x+20, self.y+20)
self.canvas.after(100, self.move)
root = Tk()
game = CatchGame(root)
root.mainloop()
The ball should now bounce off the top and the bottom of the screen. I’m a little concerned that there are a
lot of magic numbers (0, 180, 100, 20 etc) creeping into the code. All these numbers make the code a bit hard
to read, and can make code hard to modify. Generally, if you ﬁnd that you use the same number in more
than one place, it is good practice to put it in a constant variable — that way you can modify the constants
in your program at a later date by just changing one number and not several. Notice that I’ve introduced
initialization parameters to specify the values of these numbers, but I’ve also provided sensible defaults
using named parameters. This is generally good practice as it allows the programmer to initiallize a game
with a minimum of effort. Also, with GUI widgets, we can often discover their state (such as their width
and height), by using the widget’s query method. To discover the width of a widget in Tkinter, we can use
thewinfowidth() method. Why do you think that’s preferable than specifying a program constant? If
we make those changes, our bouncing ball program eventually looks like bounce.py :
178
fromTkinter import*
importrandom
classCatchGame:
"""
A random bouncing circle in a window with constant variables.
"""
def__init__(self, parent, width=200, height=200, ball_size=20, wait_time=100):
self.ball_size = ball_size
self.wait_time = wait_time
self.canvas = Canvas(parent, width=width, height=height)
self.canvas.grid(column=0,row=0)
self.x = 10
self.y = random.randint(10,height-ball_size)
self.dx = 2
self.dy = random.randint(-5,5)
self.ball = self.canvas.create_oval(self.x,self.y,
self.x+ball_size,self.y+ball_size,
fill="blue")
self.canvas.after(wait_time, self.move)
defmove(self):
self.x = self.x+self.dx
self.y = self.y+self.dy
ifself.y<0:
self.y = 0
self.dy = -self.dy
elifself.y>self.canvas.winfo_height()-self.ball_size:
self.y = self.canvas.winfo_height()-self.ball_size
self.dy = -self.dy
self.canvas.coords(self.ball, self.x, self.y,
self.x+self.ball_size, self.y+self.ball_size)
self.canvas.after(self.wait_time, self.move)
root = Tk()
game = CatchGame(root, width=400, height=400, ball_size=5, wait_time=10)
root.mainloop()
20.4 Glossary
random: Having no speciﬁc pattern. Unpredictable. Computers are designed to be predictable, and it is
not possible to get a truly random value from a computer. Certain functions produce sequences of
values that appear as if they are random, and it is these pseudo-random values that we get from Python.
179
20.5 Laboratory exercises
1. The following Tkinter script draws a simple house on a Tkinter canvas:
fromTkinter import*
root = Tk()
houseCanvas = Canvas(root, width=400, height=400)
houseCanvas.grid(row=0, column=0)
houseCanvas.create_rectangle(20, 380, 120, 280) # the house
houseCanvas.create_rectangle(55, 380, 85, 330) # the door
houseCanvas.create_rectangle(40, 320, 60, 300) # left window
houseCanvas.create_rectangle(80, 320, 100, 300) # right window
houseCanvas.create_line(20, 280, 70, 240, 120, 280) # the roof
root.mainloop()
(a) Create a ﬁle called, house.py , and type in the above code. Run this script and conﬁrm that you
get a window that looks like this:
(b) Wrap the house code in a function named drawhouse() .
(c) Run the script now. Do you see a house? Why not?
(d) Add a call to drawhouse() at the bottom of the script so that the house returns to the screen.
(e)Parameterize the function with x,y, andcolour parameters — the header should then become
defdraw_house(x, y, colour):
so that you can pass in the location of the house on the canvas and a colour for the main body of
the house.
(f) Usedrawhouse to place ﬁve houses on the canvas in different locations, each with a different
colour.
180
(g) Create a House class that incorporates all the necessary attributes to draw a house on a can-
vas. For example, position (x, y), colour, width and height (and any other attributes it needs).
The class should have an init method that initialises all the necessary attributes. Add a
draw method to the class that actually does the drawing. Redo the previous exercise (5 different
houses) using 5 different objects of the House class.
2. Modify the code in bounce.py , to make the ball go faster.
3. Modify the code in bounce.py so that the bounce is a little bit random. This should make the catch
game we develop in the next lecture a bit more interesting.
4.Extension Exercise: Modify your bounce code so the ball bounces off all the walls.
5.Extension Exercise: Add ﬁxed rectangles to the bounce canvas. Arrange it so the moving ball also
bounces off the rectangles.
6.Extension Exercise: Add ﬁxed circles to the board. You will have to ﬁgure out what the direction of the
bounce should be in the case of the ball hitting a circle.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
181
182
Lecture 21
Case study: Catch continued
21.1 Keyboard input
To be able to respond to input from the user, Tkinter and most GUI toolkits use the notion of an event. To
get a program to respond to events, we need to bind an event to a callback function. Here is how we can
implement a mitt for the catch game that moves the mitt up or down depending on the key pressed:
fromTkinter import*
classCatchGame:
"""
A moving mitt in a window.
"""
def__init__(self, parent, width=200, height=200, mitt_size=20):
self.canvas = Canvas(parent, width=width, height=height)
self.canvas.grid(column=0,row=0)
self.mittx = width-30
self.mitty = height/2
self.mitt_size = mitt_size
self.mitt = self.canvas.create_oval(self.mittx, self.mitty,
self.mittx+self.mitt_size,
self.mitty+self.mitt_size,
fill="blue")
parent.bind("k", self.move_mitt)
parent.bind("j", self.move_mitt)
defmove_mitt(self, event):
ifevent.char=="j":
self.mitty = self.mitty+10
elifevent.char=="k":
self.mitty = self.mitty-10
self.canvas.coords(self.mitt, self.mittx, self.mitty,
self.mittx+self.mitt_size,
self.mitty+self.mitt_size)
root = Tk()
catch = CatchGame(root)
root.mainloop()
183
The callback function, movemitt takes the variable event as a parameter. This variable is of type Event .
Each event we want the program to respond to must be bound with a bind call. You can bind as many
events as you like, and they can also be bound to different callbacks if desired. In movemitt , the particular
event is checked by testing the char attribute of the Event type. Type in help(Event) at the python
prompt to ﬁnd out what other attributes an Event variable has.
21.2 Checking for collisions
We can merge the code from movemitt.py andbounce.py , from Lecture 20, into a new program called
bounceandmitt.py to produce an almost functioning game:
fromTkinter import*
importrandom
classCatchGame:
"""
An almost complete catch game with a ball and a mitt.
"""
def__init__(self, parent, width=200, height=200, ball_size=5,
wait_time=100, mitt_size=20):
self.canvas = Canvas(parent, width=width, height=height)
self.canvas.grid(column=0,row=0)
# mitt stuff
self.mittx = width-30
self.mitty = height/2
self.mitt_size = mitt_size
self.mitt = self.canvas.create_oval(self.mittx, self.mitty,
self.mittx+self.mitt_size,
self.mitty+self.mitt_size, fill="red")
parent.bind("k", self.move_mitt)
parent.bind("j", self.move_mitt)
# ball stuff
self.ball_size = ball_size
self.wait_time = wait_time
self.x = 10
self.y = random.randint(10,height-ball_size)
self.dx = 2
self.dy = random.randint(-5,5)
self.ball = self.canvas.create_oval(self.x,self.y,
self.x+ball_size,self.y+ball_size,
fill="blue")
self.canvas.after(wait_time, self.move)
defmove_mitt(self, event):
ifevent.char=="j":
self.mitty = self.mitty+10
elifevent.char=="k":
self.mitty = self.mitty-10
self.canvas.coords(self.mitt, self.mittx, self.mitty,
self.mittx+self.mitt_size, self.mitty+self.mitt_size)
184
defmove(self):
self.x = self.x+self.dx
self.y = self.y+self.dy
ifself.y<0:
self.y = 0
self.dy = -self.dy
elifself.y>self.canvas.winfo_height()-self.ball_size:
self.y = self.canvas.winfo_height()-self.ball_size
self.dy = -self.dy
self.canvas.coords(self.ball, self.x, self.y,
self.x+self.ball_size, self.y+self.ball_size)
self.canvas.after(self.wait_time, self.move)
root = Tk()
catch = CatchGame(root)
root.mainloop()
Which is all very nice, but since the ball and mitt don’t interact, it doesn’t make for much of a game. What
we need to do is check for collisions between the ball and the mitt. Take a bit of time to think about how
that might be achieved before looking at the answer below.
What we need to do is check if the ball is located near the mitt. With circles, this is fairly easy — we just
need to check if the distance between the circle centres is smaller than the sum of the two radii (draw a few
pictures to convince yourself of the correctness of that statement). I’m sure you will remember from basic
geometry that d(p1;p2) =p
(x1 x2)2+ (y1 y2)2, wherep1= (x1;y1)andp2= (x2;y2)are two points,
andd(p1; p2)is the distance between them. That function would be easy enough to implement, but we have
a slight hiccup since createoval uses the top-left corner of a bounding box, rather than the circle centre to
represent a circle, so we need to calculate the centre coordinates of the ball and mitt ﬁrst. We can add catch
functionality to the game by replacing the line self.canvas.after(self.wait time, self.move)
in themove function with the following code:
ball_centre_x = self.x + self.ball_size/2.0
ball_centre_y = self.y + self.ball_size/2.0
mitt_centre_x = self.mittx + self.mitt_size/2.0
mitt_centre_y = self.mitty + self.mitt_size/2.0
distance = sqrt((ball_centre_x-mitt_centre_x) **2+
(ball_centre_y-mitt_centre_y) **2)
# did we catch the ball?
ifdistance<=(self.ball_size+self.mitt_size)/2.0:
print"Good Catch"
self.x = 0
self.y=random.randint(0,self.canvas.winfo_height()-self.ball_size)
self.dy=random.randint(-5,5)
self.canvas.after(self.wait_time *10, self.move)
# or have we totally missed it
elifself.x>self.canvas.winfo_width():
print"You missed"
self.x = 0
self.y=random.randint(0,self.canvas.winfo_height()-self.ball_size)
self.dy=random.randint(-5,5)
self.canvas.after(self.wait_time *10, self.move)
# or hasn't it got to us yet
else:
# make sure we're called again
self.canvas.after(self.wait_time, self.move)
185
Note the structure of the new code. There are three mutually exclusive options: we caught the ball; we
missed the ball (and it’s gone off screen); or the ball hasn’t reached us yet. The perfect structure for an
if-elif-else statement. But even this code is getting a bit complex. Can you see an easy way to simplify
it?
Essentially the same code is part of the statements for the ifpart as well as the elif part. There is also very
similar code at the start of the program as well. It makes sense to abstract that code away into a function.
We might deﬁne the restart function as follows:
self.x = 0
self.dx = 2
self.y = random.randint(0,self.canvas.winfo_height()-self.ball_size)
self.dy = random.randint(-5,5)
self.canvas.after(self.wait_time *10, self.move)
I can then reduce the size of the code by replacing the ifstatement with the following:
ifdistance<=(self.ball_size+self.mitt_size)/2.0:
print"Good Catch"
self.restart()
# or have we totally missed it
elifself.x>self.canvas.winfo_width():
print"You missed"
self.restart()
# or hasn't it got to us yet
else:
# make sure we're called again
self.canvas.after(self.wait_time, self.move)
I also had to make one other minor change. In the init method, I added the following line of code after
the call to self.canvas.grid :
self.canvas.wait_visibility()
This function ensures that the window has been created and is visible before doing anything else. If the win-
dow wasn’t yet visible, then any call to self.canvas.winfo width() orself.canvas.winfo height()
would return 0and that could cause other parts of the code to fail.
21.3 Keeping score
The last thing to do for our game is keep track of who is winning. We can do that fairly easily by adding
aLabel widget and updating the scores after each round. This results in the following completed game,
catchfinal.py :
fromTkinter import*
importrandom
frommath importsqrt
classCatchGame:
"""
A catch game. Catch the ball with the mitt. To move the mitt, press k to
move up, j to move down.
"""
186
def__init__(self, parent, width=200, height=200, ball_size=5,
wait_time=100, mitt_size=20):
# canvas is the field on which the game is played
self.canvas = Canvas(parent, width=width, height=height)
# set the position of the canvas
self.canvas.grid(column=0,row=0)
# have to wait until the canvas is visible before we can do
# other stuff.
self.canvas.wait_visibility()
# mitt stuff
# position
self.mittx = width-30
self.mitty = height/2
# size
self.mitt_size = mitt_size
# visual representation of mitt
self.mitt = self.canvas.create_oval(self.mittx, self.mitty,
self.mittx+self.mitt_size,
self.mitty+self.mitt_size,
fill="red")
# bind k, j keys to the method move_mitt
parent.bind("k", self.move_mitt)
parent.bind("j", self.move_mitt)
# ball stuff
# size
self.ball_size = ball_size
# wait_time effectively controls the speed of the ball but is
# the time between successive calls to move. Hence, a larger
# wait_time means a slower ball and vice versa.
self.wait_time = wait_time
# this sets the ball position back to the left hand side and
# initiallises speed and direction.
self.restart()
# visual representation of the ball
self.ball = self.canvas.create_oval(self.x,self.y,
self.x+ball_size,self.y+ball_size,
fill="blue")
# scoring stuff
self.scores = Label(parent, text="Computer 0: Player 0")
# put the score below the canvas
self.scores.grid(column=0,row=1)
# reset the scores
self.computer_score = 0
self.player_score = 0
defrestart(self):
# start at left hand side
self.x = 0
# move ball by 4 pixels with each call to move. Changing this
# value can be used to make the ball go faster or slower
self.dx = 4
# start y position of ball is anywhere within bounds of canvas
self.y = random.randint(0,self.canvas.winfo_height()-self.ball_size)
187
# sets the direction of the ball. Making the numbers higher
# means allowing a bigger change in the y velocity.
self.dy = random.randint(-5,5)
# this is what causes the ball to be continuously updated.
# Effectively puts a vall to move onto a queue.
self.canvas.after(self.wait_time *10, self.move)
defmove_mitt(self, event):
# use j to move the mitt up by 10 pixels, k to move down
ifevent.char=="j":
self.mitty = self.mitty+10
elifevent.char=="k":
self.mitty = self.mitty-10
# redraw the mitt with the new position
self.canvas.coords(self.mitt, self.mittx, self.mitty,
self.mittx+self.mitt_size,
self.mitty+self.mitt_size)
defmove(self):
# position is changed based on velocity (dx, dy) of ball
self.x = self.x+self.dx
self.y = self.y+self.dy
# if out of bounds, bounce the ball
ifself.y<0:
self.y = 0
self.dy = -self.dy
elifself.y>self.canvas.winfo_height()-self.ball_size:
self.y = self.canvas.winfo_height()-self.ball_size
self.dy = -self.dy
# redraw the ball at its new position
self.canvas.coords(self.ball, self.x, self.y,
self.x+self.ball_size, self.y+self.ball_size)
# check if we've caught the ball
# calculate the centre of the ball
ball_centre_x = self.x + self.ball_size/2.0
ball_centre_y = self.y + self.ball_size/2.0
# calculate the centre of the mitt
mitt_centre_x = self.mittx + self.mitt_size/2.0
mitt_centre_y = self.mitty + self.mitt_size/2.0
# calculate the distance between the centres
distance = sqrt((ball_centre_x-mitt_centre_x) **2+
(ball_centre_y-mitt_centre_y) **2)
# did we catch the ball?
ifdistance<=(self.ball_size+self.mitt_size)/2.0:
# update the scores
self.player_score += 1
self.scores.configure(text="Computer " + str(self.computer_score) +
": Player " + str(self.player_score))
# start again
self.restart()
# or have we totally missed it
elifself.x>self.canvas.winfo_width():
# update scores
self.computer_score += 1
self.scores.configure(text="Computer " + str(self.computer_score) +
": Player " + str(self.player_score))
188
# start again
self.restart()
# or hasn't it got to us yet
else:
# make sure we're called again
self.canvas.after(self.wait_time, self.move)
root = Tk()
catch = CatchGame(root)
root.mainloop()
This is a reasonable sized program, and minimising the complexity of programs of this size and bigger can
be quite difﬁcult. There are several techniques you can use to make this easier:
• Use symbolic constants,
• Wrap code segments into functions,
• Whenever you see how to simplify your code, do it. Simplify as often as possible. This is called
refactoring .
• If the problem seems too big to know where to start, break it up into smaller milestones and build the
program bit-by-bit.
21.4 Glossary
abstraction: Generalization by reducing the information content of a concept. Functions in Python can be
used to group a number of program statements with a single name, abstracting out the details and
making the program easier to understand.
bind: The process of associating a widget event with a function.
constant: A numerical value that does not change during the execution of a program. It is conventional
to use names with all uppercase letters to represent constants, though Python programs rely on the
discipline of the programmers to enforce this, since there is no language mechanism to to support true
constants in Python.
refactoring: The process of reorganising code to make it easier to understand, read and maintain.
189
21.5 Laboratory exercises
1. Type in catchfinal.py and run it to make sure it works. Rather than typing it all in one go, follow
the incremental development scheme I used in lectures. That way, you will have less debugging to do
at each stage.
2. Move the code that calculates the distance from the ball to the mitt into a function called
distance circles . Do not use any class variables in the function (only parameters). Include sev-
eral doctest tests to ensure the function is correct.
3. At the moment, the program will keep going forever, or until you close the window. Add code that
will stop the program when either the player or computer score reaches 10. Announce the winner
using atkMessageBox .
4. Modify catchfinal.py so that after a player catches the ball, the computer pitches faster, and after
a player misses, the computer pitches slower.
21.6 Optional extension project: pong.py
Pong was one of the ﬁrst commercial video games. With a capital P it is a registered trademark, but pong
is used to refer to any of the table tennis like paddle and ball video games. catchfinal.py already
contains all the programming tools you need to develop our own version of pong. Incrementally changing
catchfinal.py intopong.py is the goal of this project, which you will accomplish by completing the
following series of exercises:
1. Copycatchfinal.py topong1.py and change the mitt into a paddle by using createrectangle
instead of the createoval . Make the adjustments needed to keep the paddle on the screen.
2. Copypong1.py topong2.py . Replace the distance function with a boolean function
hit(bx, by, r, px, py, h) that returns True when the vertical coordinate of the ball ( by) is
between the bottom and top of the paddle, and the horizontal location of the ball ( bx) is less than or
equal to the radius ( r) away from the front of the paddle. Use hit to determine when the ball hits the
paddle, and make the ball bounce back in the opposite horizontal direction when hit returnsTrue .
Your completed function should pass these doctests:
defhit(bx, by, r, px, py, h):
"""
>>> hit(760, 100, 10, 780, 100, 100)
False
>>> hit(770, 100, 10, 780, 100, 100)
True
>>> hit(770, 200, 10, 780, 100, 100)
True
>>> hit(770, 210, 10, 780, 100, 100)
False
"""
Finally, change the scoring logic to give the player a point when the ball goes off the screen on the left.
3. Copypong2.py topong3.py . Add a new paddle on the left side of the screen which moves up
when’a’ is pressed and down when ’s’ is pressed. Change the starting point for the ball to the
center of the screen, (400, 300) , and make it randomly move to the left or right at the start of each
round.
190
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
191
192
Lecture 22
System programming
22.1 The sys module and argv
Thesys module contains functions and variables which provide access to the environment in which the
python interpreter runs. The following example shows the values of a few of these variables on one of our
systems:
>>> importsys
>>> sys.platform
'darwin'
>>> sys.path
['/',
'/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python25.zip',
'/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5',
'/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/plat-darwin',
'/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/plat-mac',
'/System/Library/Frameworks/Python.framework/Versions/2.5/Extras/lib/python',
'/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/lib-tk',
'/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/lib-dynload',
'/Library/Python/2.5/site-packages',
'/System/Library/Frameworks/Python.framework/Versions/2.5/Extras/lib/python/PyObjC']
>>> sys.version
'2.5.1 (r251:54863, Jan 13 2009, 10:26:13) \n[GCC 4.0.1 (Apple Inc. build 5465)]'
Starting Jython on vex produces different values for the same variables:
>>> importsys
>>> sys.platform
'java1.6.0_04'
>>> sys.path
['', '.', '/usr/share/jython/Lib', '__classpath__']
>>> sys.version
'2.2b1'
The results will be different on your machine.
193
Theargv variable holds a list of strings read in from the command line when a Python script is run. These
command line arguments can be used to pass information into a program at the same time it is invoked:
#
# demo_argv.py
#
importsys
printsys.argv
Running this program from the unix command prompt demonstrates how sys.argv works:
$ python demo_argv.py this andthat 1 2 3
['demo_argv.py', 'this', 'and', 'that', '1', '2', '3']
$
argv is a list of strings. Notice that the ﬁrst element is the name of the program. Arguments are separated
by white space, and separated into a list in the same way that string.split operates. If you want an
argument with white space in it, use quotes:
$ python demo_argv.py "this and" that "1 2" 3
['demo_argv.py', 'this and', 'that', '1 2', '3']
$
Withargv we can write useful programs that take their input directly from the command line. For example,
here is a program that ﬁnds the sum of a series of numbers:
#
# sum.py
#
fromsys importargv
nums = argv[1:]
forindex, value inenumerate(nums):
nums[index] = float(value)
printsum(nums)
In this program we use the from<module>import<attribute >style of importing, so argv is
brought into the module’s main namespace. We can now run the program from the command prompt like
this:
$ python sum.py 3 4 5 11
23
$ python sum.py 3.5 5 11 100
119.5
You will be asked to write similar programs in the lab exercises.
194
22.2 The osandglob module
Theosmodule contains functions for interacting with the underlying operating system. It includes many
standard operating system functions including, but not limited to:
• directory listings ( os.listdir )
• moving to a different directory ( os.chdir )
• executing other processes ( os.execv andos.system )
• moving ﬁles ( os.rename )
• deleting ﬁles ( os.remove )
• getting information about a ﬁle ( os.stat )
Let’s have a look at a simple example:
>>> importos
>>> photos =
os.listdir('/home/cshome/coursework/COMP150/coursefiles150/Photos/')
>>> photos
['112_1286.jpg', '112_1287.jpg', '112_1284.jpg', '112_1285.jpg',
'112_1282.jpg', '112_1283.jpg', '112_1280.jpg', '112_1281.jpg',
'112_1288.jpg', '112_1276.jpg', '112_1277.jpg', '112_1274.jpg',
'112_1275.jpg', '112_1272.jpg', '112_1273.jpg', '112_1271.jpg',
'112_1278.jpg', '112_1279.jpg']
>>> os.stat('/home/cshome/coursework/COMP150/coursefiles150/Photos/' + photos[0])
(33216, 597894501L, 436207622L, 1, 15391, 1026, 1089680L, 1239768034,
1239768034, 1239768034)
Theos.stat command returns several pieces of information about the ﬁle in question, including its size
(1089680L ).
Theglob module is another useful module that contains several functions, but the most important one is
theglob function. Globbing is a term for converting a generic name which includes wildcard characters,
into speciﬁc names of ﬁles or directories that match the generic name. Here are some simple examples:
195
>>> importglob
>>> glob.glob("/home/cshome/coursework/COMP150/coursefiles150/Photos/ *.jpg")
['/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1272.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1286.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1280.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1274.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1275.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1281.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1287.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1288.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1273.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1285.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1271.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1277.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1278.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1283.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1282.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1276.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1279.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1284.jpg']
>>> glob.glob("/home/cshome/coursework/COMP150/coursefiles150/Photos/ *2.jpg")
['/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1272.jpg',
'/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1282.jpg']
The combination of a little bit of programming knowledge, plus the osandglob modules really allows us
to remove the drudgery from a lot of mundane and laborious computer tasks.
22.3 A mini-case study
In this mini-case study, we are going to look at using osandglob and the external ImageMagick program
calledconvert to do some useful work. Our original photos are rather large, and I’d like to convert them
to smaller versions and thumbnails so I can make a visual directory to put on the web. First, let’s have a
look at some of the capabilities of ImageMagick.
22.3.1 ImageMagick
ImageMagick is a suite of stand-alone programs that are often run from the command line which makes
them ideal for scripting or batch processing. The most useful of the programs is the utility called convert .
If you open a terminal shell and type convert at the prompt, you will be greeted with a dizzying array
of options (not reproduced here for space reasons). There are lots of things you can do with images using
convert . Let’s try out a few simple ones.
To convert one of our pictures to a charcoal drawing, try the following command1:
$ convert \\
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1286.jpg \\
-charcoal 5 charcoal.jpg
In a ﬁnder window, double-click on charcoal.jpg to see the result. The result should look similar to
Figure 22.1.
1You can type the whole command on a single line without the nns.
196
Figure 22.1: A charcoaled image
Figure 22.2: A swirled image
How about adding a little swirl to a picture:
$ convert \\
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1271.jpg \\
-swirl 90 swirl.jpg
The result should look similar to Figure 22.2. Too much to drink perhaps? A bad trip maybe?
Try out a few other operations if you feel so inclined. However, enough frivolity, on to the real work.
22.3.2 Scripting ImageMagick
First, create a ﬁle called magick.py . Let’s start with listing all the photos in the shared Photos folder. Add
the following code to magick.py and execute it.
197
importos, glob
photos = glob.glob("/home/cshome/coursework/COMP150/coursefiles150/Photos/ *.jpg")
forpinphotos:
print(p)
print("Done")
The output should look something like the following:
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1272.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1286.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1280.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1274.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1275.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1281.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1287.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1288.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1273.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1285.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1271.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1277.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1278.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1283.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1282.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1276.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1279.jpg
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1284.jpg
Done
That’s a good start because now we know we can specify the input ﬁlenames. What about the output
ﬁles? Well, we can’t just use the input ﬁlenames as the output ﬁlenames for two reasons: we don’t want
to overwrite the original ﬁles; and you don’t have write access to the above directory/folder. So, we need
to do some processing on the ﬁlenames. To do this, the re(forregular expressions ) package is useful. We
could spend several lectures on regular expressions, but we won’t. We’ll try to give you a little taste of them
here — if you don’t fully understand what’s going on, don’t panic, the most important thing is that you
recognise that regular expressions are an incredibly powerful way of manipulating strings.
Regular expressions are a bit like globbing, except the rules are a bit different. Have a close look at the
format of the ﬁlenames listed above. What we would like to do is maintain the ﬁlename part of the output
ﬁle so it’s easy to associate the input and output, but save the ﬁle in the current directory. To do that, we
need to chop out all the leading directory names and structure. To do that, we use the re.sub command.
Here’s how:
importos, glob, re
photos = glob.glob("/home/cshome/coursework/COMP150/coursefiles150/Photos/ *.jpg")
forpinphotos:
newp = re.sub(". */([a-z_0-9]+)\.jpg", r"\1", p)
print("input name: " + p + ", output name: " + newp)
print("Done")
198
There.sub command (sub is short for substitute) is performing a bit of regular expression magic. Let’s
have a quick look at what all those parts are doing. The ﬁrst parameter is a regular expression (RE), the
second a replacement string, and the third, the string to do the matching and replacing on. The RE in this
case is.*/([a-z_0-9]+)\.jpg . Let’s look at different parts of the RE:
•jpg:Characters that occur unadorned are simply matched directly to the input string. So in this case,
the characters jpg will only match to the end of the input strings (the ﬁle type).
•\.:A.is a special character (described below). When we actually want to match with a .in the
input string, we need to precede it with a \. So the ﬁnal part of the RE, \.jpg , matches the end of the
ﬁlenames.
•[a-z_0-9] :Square braces indicate that the RE should match any of the characters inside the braces.
Rather than typing out all the characters in the alphabet and all the numerals, we can abbreviate those
with the range operator -. Soa-z matches all lowercase characters, 0-9 matches all numerals, and
_matches the underscore character. The sub-expression [a-z_0-9] therefore matches any single
lower case character, underscore or numeral. If we add a +to the end, then we can match any sequence
of one or more of those characters.
•([a-z_0-9]+) :The round brackets around this sub-expression, essentially saves the matched part
to a variable for later use. In this case, the ﬁrst part of the ﬁlename is saved to the special variable \1.
•.*/:In the ﬁrst part of the RE, the .is a special character that matches any character, and the *is
a special character that says to match 0 or more instances of the previous matched character. So, .*
matches any sequence of characters. If we add a /, then.*/matches any sequence of characters
followed by a /. In other words, all the leading directory information.
The ﬁnal result of the RE is that we’ll match the complete ﬁlename (including the directory structure) of
each ﬁle, and more importantly, the ﬁlename, minus the directory structure and ﬁle type, will be saved in
the special variable \1. We then use the special variable in the replacement parameter (in this case, r’\1’
of the function. The ﬁnal result is that we replace the entire name, with just the important part of the
ﬁlename.
Now that we have useful input and output names, it is a simple matter to create a customised command to
pass to the os.system function:
importos, glob, re
photos = glob.glob("/home/cshome/coursework/COMP150/coursefiles150/Photos/ *.jpg")
forpinphotos:
newp = re.sub('. */([a-z_0-9]+)\.jpg', r'\1', p)
print("input name: " + p + ", output name: " + newp)
command = "convert " + p + " -resize 50x50 " + newp + "_50.jpg"
print("doing: " + command)
os.system(command)
print("Done")
Which should produce output that looks similar to:
199
input name:
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1272.jpg,
output name: 112_1272
doing: convert
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1272.jpg
-resize 50x50 112_1272_50.jpg
input name:
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1286.jpg,
output name: 112_1286
doing: convert
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1286.jpg
-resize 50x50 112_1286_50.jpg
input name:
/home/cshome/coursework/COMP150/coursefiles150/Photos/112_1280.jpg,
output name: 112_1280
...
Done
For this particular problem, application programs, such as PhotoShop, offer a batch processing alternative
within the application. However, the power of such approaches is limited to what the application provides
— which depends on what the programmer thinks the user might need. The power of the scripting ap-
proach is that it is limited only by the users skill and imagination — all command line driven programs can
be scripted and many GUI programs too.
22.4 Glossary
environment: The operating context in which a program runs. This would include things such as the ﬁle
system, current working directory, network environment etc.
Jython: An implementation of Python for the Java Virtual Machine.
command line: Many programs can be executed by typing in a command in a system interpreter rather
than by double clicking. Such a system interpreter is a command line system. The “command line”
then is the text you type in to execute a command.
command line arguments: Any arguments passed to a program from the command line.
glob: A common method for selecting multiple ﬁles from the command line.
regular expression: A special type of expression that is used for string matching.
200
22.5 Laboratory exercises
1. Write a program named mean.py that takes a sequence of numbers on the command line and returns
the mean of their values.
$ python mean.py 3 4
3.5
$ python mean.py 3 4 5
4.0
$ python mean.py 11 15 94.5 22
35.625
A session of your program running on the same input should produce the same output as the sample
session above.
2. Write a program named median.py that takes a sequence of numbers on the command line and
returns the median of their values.
$ python median.py 3 7 11
7
$ python median.py 19 85 121
85
$ python median.py 11 15 16 22
15.5
A session of your program running on the same input should produce the same output as the sample
session above.
3. Modify the program you wrote for Exercise 5 in Section 15.13 so that it takes the ﬁle to open as a
command line argument.
4. Write a program that will list all the python programs (that is, ﬁles that end in .py) in a given directory,
where the directory name is speciﬁed on the command line.
5. Extend the program from the previous exercise so that all functions deﬁned in the python programs
are printed to the screen. The output should look something like this ( pythonfuncs is the program,
dir is the directory to scan):
$ python python_funcs dir
median.py:
median
mean.py:
sum
mean
6.Extension Exercise: Modify the ﬁnal version of magick.py , so that it ﬁrst resizes each input image to
200x200, then produces a morph sequence between each pair of input images. To morph between two
input images you can use the convert program as follows:
$ convert -morph 5 image1.jpg image2.jpg out.jpg
The parameter 5indicates how many in between frames to use.
201
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
202
Lecture 23
Case study 2 Part 1
To wrap-up this course, we are going to look at a case study in which we implement a simple cryptography
encoder and editor for text ﬁles. This case study will bring together several aspects of the topics you have
been learning over the past several weeks including: ﬁles, strings, GUI programming, and dictionaries.
And, along the way, we’re going to see what it’s like to really think like a computer scientist.
23.1 Program Design
Whenever we come across a new programming task, the ﬁrst decision to be made is always to decide
on the design methodology — in other words, how are you going to design the program. There are many
different methodologies, but I am fond of following the open source mantra: “Release Early, Release Often”.
In this methodology, you start with a working program, continuously make small changes, all the while
maintaining a working program. This sort of method is good for small projects, but can be hopeless for
very large projects. One of the limitations is that the complexity of the program often spirals out of control
and the design degenerates into a hopeless mess. For this reason, it is also important that you refactor the
code often. Refactoring means reorganising the code so that it is easier to understand and maintain.
Even given a design methodology, there are at least two ways of approaching the solution strategy: user-
driven or programmer-driven. In a user-driven solution, the programmer is always thinking about what
the user wants and not necessarily what’s easiest for the programmer. Programmer-driven is the reverse,
focusing on what is easiest for the programmer, rather than what is most useful for the user. Generally, user-
driven solutions produce useful programs for users, and programmer-driven solutions produce a program
that only the programmer can use.
So, let’s think about the sort of things a user would want from a program for encrypting and editing text
ﬁles:
• open a ﬁle
• encrypt or decrypt a ﬁle
• edit a ﬁle
• save the ﬁle to disk
• quit the program
203
Is there anything else a user might be concerned about?
 
zend
 
That’s pretty much it for a bare-bones text editor and encryptor. Let’s get coding.
23.2 The Initial Program
Before actually starting to code, there is another decision to be made. Should we develop the GUI ﬁrst and
add the functionality later, or the functionality ﬁrst and the GUI later? There’s no hard and fast rule for this
question, and in many cases it depends on the task at hand. For this problem it probably makes sense to
develop in a GUI ﬁrst manner.
First, let’s get a basic text window up and running. Tkinter has a text widget called Text which we
could use. But with larger documents we will need to be able to scroll the text and the Text widget doesn’t
supply that functionality. Luckily, there is a slightly more advanced widget in the ScrolledText module.
Following is code for creating a basic scrolled text window.
importTkinter
importScrolledText
if__name__ == "__main__":
root = Tkinter.Tk()
textWidget = ScrolledText.ScrolledText(root, width=80, height=50)
textWidget.pack()
root.mainloop()
Notice how we’re using the “Release Early, Release Often” method. We already have a working program!
23.3 Opening a File
The next step is to add an option for opening and loading in a ﬁle. The usual way of providing ﬁle opening
operations is via a menu bar. We haven’t met menu bars in Tkinter as yet, but they are quite straightfor-
ward. In the following code we add a menu bar with a ﬁle option.
204
importTkinter
importScrolledText
classTextEdit:
"""
A simple text editor using a ScrolledText widget.
"""
def__init__(self, parent):
self.parent = parent
self.textWidget = ScrolledText.ScrolledText(parent, width=80, height=50)
self.textWidget.pack()
self.menuBar = Tkinter.Menu(parent, tearoff=0)
self.fileMenu = Tkinter.Menu(self.menuBar, tearoff=0)
self.fileMenu.add_command(label="Open", command=self.open_command)
self.menuBar.add_cascade(label="File", menu=self.fileMenu)
parent.config(menu=self.menuBar)
defopen_command(self):
print"hello"
if__name__ == "__main__":
root = Tkinter.Tk()
textApp = TextEdit(root)
root.mainloop()
You will notice several things about the above program. First, a top-level menu bar (called menuBar ) is
created. This is followed by the creation of a second level menu bar (called fileMenu ). We can add as
many menus as we like, but in this application, only one is needed. To fileMenu we added a command
which is simply a Python function. So far, the command doesn’t do anything very interesting, but we still
have a working program.
To open a ﬁle, we can use a tkFileDialog :
importtkFileDialog
defopen_command(self):
file = tkFileDialog.askopenfile()
iffile != None:
contents = file.read()
self.textWidget.delete("1.0", Tkinter.END)
self.textWidget.insert(Tkinter.END, contents)
This function now does several things. It gets a ﬁle via the tkFileDialog.askopenfile() method,
reads the contents of the ﬁle into a string, deletes any text currently in the main window and then inserts
the text from the ﬁle into the window. The textWidget.delete andtextWidget.insert methods
deserve some extra attention.
ThetextWidget.delete method takes two indexes and deletes all the text between the ﬁrst index and
up to but not including the last index. The string "1.0" is a specially formatted index string of the form
LINENUMBER.CHARACTER . So,"1.0" refers to line 1, character 01. The constant Tkinter.END refers to
the end of the text.
ThetextWidget.insert method takes just one index and inserts its second parameter just before the
character speciﬁed by the ﬁrst parameter. The result of the whole function is to read all the text in from a
1Curiously, line numbers start at 1 and character numbers start at 0
205
ﬁle and replace the text in textWidget with the ﬁle contents.
23.4 Saving to a File
To save to a ﬁle, we essentially reverse the process, again using the tkFileDialog :
defsave_command(self):
file = tkFileDialog.asksaveasfile()
iffile != None:
# slice off the last character from get, as an extra return is added
contents = self.textWidget.get("1.0", Tkinter.END)[:-1]
file.write(contents)
file.close()
At this point, we have a quite usable text editor. You could even use it to write Python programs if you
wanted to. The full listing is given in Figure 23.1. (I’ve added a Quit menu option as well):
23.5 Adding a Command Bar
Many GUI applications have a command bar as well as a menu system. These are relatively easy to add
to an application. The only real difﬁculty is that we want all the commands to be grouped together in a
command bar, and the main window to sit under the command bar. It’s hard to do that using the grid
layout mechanism without adding a grouping widget. Luckily, Tkinter has a grouping widget called a
Frame .
Here’s how the init method can be modiﬁed to include a command bar with a single button:
def__init__(self, parent):
self.parent = parent
self.commandBar = Tkinter.Frame(parent)
self.commandBar.grid(row=0,column=0)
self.openButton = Tkinter.Button(self.commandBar, text="Open",
command=self.open_command)
self.openButton.grid(row=0,column=0)
self.textWidget = ScrolledText.ScrolledText(parent, width=80, height=50)
self.textWidget.grid(row=1,column=0)
Note that commandBar andtextWidget are both children of the parent window. The openButton
widget, however, is a child of commandBar (and therefore a grandchild of parent ). This hierarchical
organisation of the GUI is a very common mechanism for more complicated layouts. To add more buttons
to the command bar, we just need to make the new buttons children of commandBar .
206
importTkinter
importScrolledText
importtkFileDialog
classTextEdit:
"""
A simple text editor using a ScrolledText widget.
"""
def__init__(self, parent):
self.parent = parent
self.textWidget = ScrolledText.ScrolledText(parent, width=80, height=50)
self.textWidget.pack()
self.menuBar = Tkinter.Menu(parent, tearoff=0)
self.fileMenu = Tkinter.Menu(self.menuBar, tearoff=0)
self.fileMenu.add_command(label="Open", command=self.open_command)
self.fileMenu.add_command(label="Save", command=self.save_command)
self.fileMenu.add_separator()
self.fileMenu.add_command(label="Quit", command=self.exit_program)
self.menuBar.add_cascade(label="File", menu=self.fileMenu)
parent.config(menu=self.menuBar)
defopen_command(self):
file = tkFileDialog.askopenfile()
iffile != None:
contents = file.read()
self.textWidget.delete("1.0", Tkinter.END)
self.textWidget.insert(Tkinter.END, contents)
defsave_command(self):
file = tkFileDialog.asksaveasfile()
iffile != None:
contents = self.textWidget.get("1.0", Tkinter.END)[:-1]
file.write(contents)
file.close()
defexit_program(self):
self.parent.destroy()
if__name__ == "__main__":
root = Tkinter.Tk()
textApp = TextEdit(root)
root.mainloop()
Figure 23.1: A program for loading, editing and saving a ﬁle .
207
23.6 Laboratory Exercises
1. Add to the command bar buttons for saving and quitting.
2. It is possible to use images instead of words for displaying buttons. All icons you see on toolbars in
applications are simply images attached to buttons. Tkinter uses the PhotoImage class to load images
and icons. For example, to replace the word “Open” on the command bar with an icon from a ﬁle
called “open.gif”, we can use the following code:
self.openIcon = Tkinter.PhotoImage(file="open.gif")
self.openButton = Tkinter.Button(self.commandBar, image=self.openIcon,
command=self.open_command)
On blackboard, there are several example icon ﬁles. Replace all of the words on the command bar
with icon buttons instead. Experiment with using different images. You can even use images that you
created (either through an image creation program like GIMP , or just use a photo that you’ve taken).
3. Write a simple spell checker program. Your program should ask the user to enter a word to check (use
a dialog box or an Entry widget). If it is spelled correctly, the program should say OK. If it is spelled
incorrectly, the program should say so and make some suggestions regarding correct spelling. The
ﬁle/usr/share/dict/words contains a good list of words for English. The steps to follow in your
program are to load the list of words into memory, then search that list for the word from the user. If
it’s there, then OK, but if not, then it’s a misspelling.
4. Add a spell checker to your text editor program from the ﬁrst two questions.
Remember to have your attendance recorded by showing a demonstrator the work you
have done, and they will submit your lab work electronically. All written answers
should be typed into a ﬁle for electronic submission.
208
Lecture 24
Case study 2 Part 2
In the last lecture we saw how to write a simple text editor using Python. In this lecture we are going to
extend that editor to optionally encrypt the contents of the document.
24.1 Encrypting the Contents
Our next task is to encrypt the contents and to do this we are going to use a very simple encryption algo-
rithm called a Vigenere cipher1. A Vigenere cipher is a variant of a Caesar cipher, so let’s look at the Caesar
cipher ﬁrst. As you might have guessed, the Caesar cipher was invented by Julius Caesar to communicate
with his generals. The Caesar cipher is very simple and involves replacing any given character by a dif-
ferent character using a substitution. The most common substitution is a “rotation” where each character
is replaced by a character ncharacters away in the alphabet. For example, if I apply a rotation of 1 or 2
characters to all upper case characters, I get the following substitution table:
Rotate A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
1 B C D E F G H I J K L M N O P Q R S T U V W X Y Z A
2 C D E F G H I J K L M N O P Q R S T U V W X Y Z A B
The top row of the table indicates the input character, and the subsequent rows indicates the output char-
acter based on a rotation of 1 or 2 characters. Can you see why we call it a rotation? What is the maximum
rotation we can perform?
How can we represent the rotation in Python? Well, we could use a dictionary which has a character as the
key and another character as the value like so:
caesar = dict()
caesar["A"] = "B"
caesar["B"] = "C"
caesar["C"] = "D"
caesar["D"] = "E"
caesar["E"] = "F"
...
And then when we wanted to encrypt a character we could simply say:
1Cipher is another word for encryption algorithm.
209
newchar = caesar[oldchar]
or something similar.
However, there is a simpler way involving the use of the functions ord andchr. Theord function returns
the integer representation of a character:
>>> ord("a")
97
>>> ord("A")
65
>>>
This example explains why "Apple"<"apple" evaluates to True . The problem of using numbers to
encode alphabets is a fairly complex one. The ord function uses a character set called ASCII (American
Standard Code for Information Interchange) which is a simple and commonly used character set, but is
neither universal nor particularly versatile. It is often used to encode English text, but is hopeless for other
languages (including Latin languages such as French). The Unicode character set is rather more versatile
and is a global standard, but due to its complexity, we won’t use it here. ASCII uses the numbers from 32 to
126 to represent printable characters, and some of the numbers from 0 to 31 for various control codes (such
as end of line). The chr function is the inverse of the ord function. If you pass it a number between 32 and
126, it will return a printable character:
>>> chr(35)
'#'
>>> chr(90)
'Z'
Now we can convert characters into numbers and vice versa, so we might be tempted to implement a
Caesar cipher like this:
defcaesarEncrypt(char, rotateBy):
returnchr(ord(char)+rotateBy)
What is wrong with that function?
What we really want to do is limit the results of ord(char)+rotateBy to be between 0and126which we
can do by using modulo arithmetic . We’ve seen the modulus operator in Lecture 2. A more correct Caesar
cipher can be written as:
defcaesarEncrypt(char, rotateBy):
returnchr((ord(char)+rotateBy)%127)
Actually, there is a technical issue with chr(0) and theScrolledText widget that is singularly unin-
teresting. Sufﬁce to say that we need to use a modiﬁed version to get the Caesar cipher to work with the
ScrolledText widget:
defcaesarEncrypt(char, rotateBy):
returnchr((ord(char)+rotateBy)%126+1)
Can you tell what the difference between the two functions is?
To decrypt, we can simply invert the Caesar cipher function:
210
defcaesarDecrypt(char, rotateBy):
returnchr((ord(char)-rotateBy-1)%126)
We could, if we wished, use caesarEncrypt andcaesarDecrypt to encrypt our ﬁles, but such an en-
cryption algorithm is trivially easy to break (see the laboratory exercises below). A Vigenere cipher makes
use of a Caesar cipher but is much more difﬁcult to break (although not impossible, except in very limiting
circumstances). The Vigenere cipher simply encrypts each character in the input string with a potentially
differentrotateBy value. Since rotateBy values are limited to between 0and 126anyway, it makes
sense to use a string representation of the rotateBy values. In other words, a password:
defencrypt(inString, password):
outString = ""
index = 0
forchininString:
ch = caesarEncrypt(ch, ord(password[index]))
outString = outString + ch
index = (index+1)%len(password)
returnoutString
defdecrypt(inString, password):
outString = ""
index = 0
forchininString:
ch = caesarDecrypt(ch, ord(password[index]))
outString = outString + ch
index = (index+1)%len(password)
returnoutString
Take some time to look at these functions and make sure you understand what is going on.
24.2 Putting it All Together
It’s now a fairly simple matter to put the encryption algorithm into our program. We simply add another
drop-down menu which includes the encryption options, and make use of the tkSimpleDialog.askstring
method which can get a string from the user, resulting in the following completed program:
importTkinter
importScrolledText
importtkFileDialog
importtkSimpleDialog
importrandom
classEncryptTextEdit:
"""
A simple text editor that allows encryption and decryption of files for saving.
"""
def__init__(self, parent):
self.parent = parent
self.textWidget = ScrolledText.ScrolledText(parent, width=80, height=50)
self.textWidget.pack()
self.menuBar = Tkinter.Menu(parent, tearoff=0)
self.fileMenu = Tkinter.Menu(self.menuBar, tearoff=0)
211
self.fileMenu.add_command(label="Open", command=self.open_command)
self.fileMenu.add_command(label="Save", command=self.save_command)
self.fileMenu.add_separator()
self.fileMenu.add_command(label="Quit", command=self.exit_program)
self.menuBar.add_cascade(label="File", menu=self.fileMenu)
self.encryptMenu = Tkinter.Menu(self.menuBar, tearoff=0)
self.encryptMenu.add_command(label="Encrypt", command=self.encrypt_command)
self.encryptMenu.add_command(label="Decrypt", command=self.decrypt_command)
self.menuBar.add_cascade(label="Encrypt", menu=self.encryptMenu)
parent.config(menu=self.menuBar)
defopen_command(self):
file = tkFileDialog.askopenfile()
iffile != None:
contents = file.read()
self.textWidget.delete("1.0", Tkinter.END)
self.textWidget.insert(Tkinter.END, contents)
defsave_command(self):
file = tkFileDialog.asksaveasfile()
iffile != None:
contents = self.textWidget.get("1.0", Tkinter.END)[:-1]
file.write(contents)
file.close()
defexit_program(self):
self.parent.destroy()
defcaesarEncrypt(self, char, rotateBy):
"""encrypt a single character"""
returnchr((ord(char)+rotateBy)%126+1)
defcaesarDecrypt(self, char, rotateBy):
"""decrypt a single character"""
returnchr((ord(char)-rotateBy-1)%126)
defencrypt(self, inString, password):
"""encrypt a string"""
outString = ""
index = 0
forchininString:
ch = self.caesarEncrypt(ch, ord(password[index]))
outString = outString + ch
index = (index+1)%len(password)
returnoutString
defdecrypt(self, inString, password):
"""decrypt a string"""
outString = ""
index = 0
forchininString:
ch = self.caesarDecrypt(ch, ord(password[index]))
outString = outString + ch
index = (index+1)%len(password)
returnoutString
212
defencrypt_command(self):
password = tkSimpleDialog.askstring("Password", "Please Enter your Password")
ifpassword != None:
contents = self.textWidget.get("1.0", Tkinter.END)[:-1]
encrypted = self.encrypt(contents, password)
self.textWidget.delete("1.0", Tkinter.END)
self.textWidget.insert(Tkinter.END, encrypted)
defdecrypt_command(self):
password = tkSimpleDialog.askstring("Password", "Please Enter your Password")
ifpassword != None:
contents = self.textWidget.get("1.0", Tkinter.END)[:-1]
encrypted = self.decrypt(contents, password)
self.textWidget.delete("1.0", Tkinter.END)
self.textWidget.insert(Tkinter.END, encrypted)
if__name__ == "__main__":
root = Tkinter.Tk()
textApp = EncryptTextEdit(root)
root.mainloop()
24.3 Glossary
cipher: An encryption algorithm.
ASCII: American Standard Code for Information Interchange. A common representation of text characters.
Unicode: A more modern representation of text characters that allows for a much larger range of characters
and includes characters from many different languages.
modulo arithmetic: arithmetic performed on a limited range of numbers.
213
24.4 Laboratory Exercises
1. A Caesar cipher is trivially easy to break as there are only Ndifferent ways of encrypting a given
text, where Nis the number of characters in the alphabet. From the Blackboard page, download
caesarcrypt.txt and save it to your home directory. caesarcrypt.txt has been encrypted
using thecaesarEncrypt function. Using the program above as a starting point, write a function
that tests each possible rotateBy value to decrypt the text.
2. A Caesar cipher is the simplest of substitution ciphers. A more general substitution cipher allows any
mapping from input character to output character, not just a rotation. So, for example, I might use the
following substitution map:
Source A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
Target P J T Y Q R C K L E W D U A X O B V S G H I M N F Z
The number of different possible mappings is N(N 1)(N 2):::1. You can see this is true
by noting that there are Npossible substitutions for the ﬁrst character (e.g. can choose any of A to
Z),N 1for the second character (e.g. any of A to Z except for the ﬁrst substitution) and so on. As
you probably know, this function is called factorial. Implement a factorial function and work out the
number of different possible mappings when N= 126 . Make sure you remember to include doctests
to test your function.
Do you think the method you used in Question 1 will work for this case?
3. One way of implementing a substitution cipher is to use a dictionary that maps from an input char-
acter randomly to an output character. The following code can be used to construct the dictionary:
importrandom
keys = range(1,127)
values = range(1,127)
random.seed("SomePassword")
random.shuffle(values)
encrypt = dict()
decrypt = dict()
for(i,j) inzip(keys,values):
encrypt[chr(i)] = chr(j)
decrypt[chr(j)] = chr(i)
Encryption and decryption are then trivial. Instead of the call to caesarEncrypt orcaesarDecrypt
in the encryption program, we can have the following code:
ch = encrypt[ch]
Using the above code, or code of your own design, incorporate a random substitution cipher into the
encryption program.
Note: The zip function takes two sequences and returns a list of tuples. The above for loop is a
typical way of iterating through two equal length sequences.
4. The statement random.seed("SomePassword") seeds the random number generator so that random.shuffle
produces the same shufﬂe each time the program is run. I have used a string constant as a seed in
the code for the previous question, but this means that all documents encrypted with a substitution
cipher will use the same substitution. Modify your answer to the previous question to allow the user
to enter a password for specifying the seed value.
214
Extension Exercises
1. Substitution ciphers can be broken using frequency analysis. Frequency analysis examines the num-
ber of times each character occurs in the encrypted text and makes guesses regarding the identity
of the character based on its relative frequency. For example, “e” is the most common letter in En-
glish prose, therefore we would guess that the most common character in the encrypted text is “e”.
For more details about frequency analysis, have a look at: http://en.wikipedia.org/wiki/
Frequency_analysis . From the Blackboard page, download the cipher text substitution encrypt.txt
and see if you can decrypt it using frequency analysis.
215
216
Lecture 25
The last lecture
In this lecture, I will be giving a summary of the course, outlining various aspects of the exam, and giving
you an idea of some typical sort of exam questions.
25.1 Stuff we haven’t covered
There is a lot of general programming concepts and Python programming concepts in particular that we
haven’t had time to cover in this paper. Some things that are very useful to know include:
• recursion
• exceptions
• lambda functions
• list comprehensions
• heaps of stuff from the standard library
I would encourage all of you to ﬁnd out as much about those things as you can.
25.2 What you can expect from COMP160 and Computer Science
If you enjoyed COMP150 then I would encourage you to continue on to COMP160 and even a major or
minor in Computer Science. There has been a shortage of skilled computer scientists in the work-force for
some time now, and that seems unlikely to change in the foreseeable future. There are plenty of jobs, and
let’s face it, programming is just fun! I’m often amazed that people get paid doing this stuff.
COMP160 has quite a different focus to COMP150. For a start, it uses the programming language, Java.
Java is currently the most popular programming language in use according to the TIOBE Programming
Community Index, and has been for some time. Aside from learning how to program in Java, COMP160
focuses less on using high level language tools (such as lists and dictionaries), and more on fundamental
problem solving in an Object-Oriented language. This process continues into second and third year with
the focus on fundamental concepts of computing. So if you want to know how to implement a list or a
dictionary efﬁciently, or how artiﬁcial intelligence, computer graphics or databases work, then Computer
Science is a good option for you.
217
218
GNU Free Documentation License
Version 1.2, November 2002
Copyright © 2000,2001,2002 Free Software Foundation, Inc.
51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is
not allowed.
Preamble
The purpose of this License is to make a manual, textbook, or other functional and useful document “free”
in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without
modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author
and publisher a way to get credit for their work, while not being considered responsible for modiﬁcations
made by others.
This License is a kind of “copyleft”, which means that derivative works of the document must themselves
be free in the same sense. It complements the GNU General Public License, which is a copyleft license
designed for free software.
We have designed this License in order to use it for manuals for free software, because free software needs
free documentation: a free program should come with manuals providing the same freedoms that the
software does. But this License is not limited to software manuals; it can be used for any textual work,
regardless of subject matter or whether it is published as a printed book. We recommend this License
principally for works whose purpose is instruction or reference.
1. APPLICABILITY AND DEFINITIONS
This License applies to any manual or other work, in any medium, that contains a notice placed by the
copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-
wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The
“Document ”, below, refers to any such manual or work. Any member of the public is a licensee, and is
addressed as “ you”. You accept the license if you copy, modify or distribute the work in a way requiring
permission under copyright law.
A “Modiﬁed Version ” of the Document means any work containing the Document or a portion of it, either
copied verbatim, or with modiﬁcations and/or translated into another language.
A “Secondary Section ” is a named appendix or a front-matter section of the Document that deals exclu-
sively with the relationship of the publishers or authors of the Document to the Document’s overall subject
(or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the
219
Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.)
The relationship could be a matter of historical connection with the subject or with related matters, or of
legal, commercial, philosophical, ethical or political position regarding them.
The “ Invariant Sections ” are certain Secondary Sections whose titles are designated, as being those of
Invariant Sections, in the notice that says that the Document is released under this License. If a section does
not ﬁt the above deﬁnition of Secondary then it is not allowed to be designated as Invariant. The Document
may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there
are none.
The “ Cover Texts ” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover
Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be
at most 5 words, and a Back-Cover Text may be at most 25 words.
A “Transparent ” copy of the Document means a machine-readable copy, represented in a format whose
speciﬁcation is available to the general public, that is suitable for revising the document straightforwardly
with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some
widely available drawing editor, and that is suitable for input to text formatters or for automatic translation
to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent
ﬁle format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent
modiﬁcation by readers is not Transparent. An image format is not Transparent if used for any substantial
amount of text. A copy that is not “Transparent” is called “ Opaque ”.
Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input
format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming sim-
ple HTML, PostScript or PDF designed for human modiﬁcation. Examples of transparent image formats
include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only
by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not gen-
erally available, and the machine-generated HTML, PostScript or PDF produced by some word processors
for output purposes only.
The “ Title Page ” means, for a printed book, the title page itself, plus such following pages as are needed
to hold, legibly, the material this License requires to appear in the title page. For works in formats which
do not have any title page as such, “Title Page” means the text near the most prominent appearance of the
work’s title, preceding the beginning of the body of the text.
A section “ Entitled XYZ ” means a named subunit of the Document whose title either is precisely XYZ or
contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a
speciﬁc section name mentioned below, such as “ Acknowledgements ”, “Dedications ”, “Endorsements ”,
or “History ”.) To “ Preserve the Title ” of such a section when you modify the Document means that it
remains a section “Entitled XYZ” according to this deﬁnition.
The Document may include Warranty Disclaimers next to the notice which states that this License applies
to the Document. These Warranty Disclaimers are considered to be included by reference in this License,
but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may
have is void and has no effect on the meaning of this License.
2. VERBATIM COPYING
You may copy and distribute the Document in any medium, either commercially or noncommercially, pro-
vided that this License, the copyright notices, and the license notice saying this License applies to the
Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this
License. You may not use technical measures to obstruct or control the reading or further copying of the
copies you make or distribute. However, you may accept compensation in exchange for copies. If you
distribute a large enough number of copies you must also follow the conditions in section 3.
You may also lend copies, under the same conditions stated above, and you may publicly display copies.
220
3. COPYING IN QUANTITY
If you publish printed copies (or copies in media that commonly have printed covers) of the Document,
numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover,
and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the
publisher of these copies. The front cover must present the full title with all words of the title equally
prominent and visible. You may add other material on the covers in addition. Copying with changes
limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be
treated as verbatim copying in other respects.
If the required texts for either cover are too voluminous to ﬁt legibly, you should put the ﬁrst ones listed (as
many as ﬁt reasonably) on the actual cover, and continue the rest onto adjacent pages.
If you publish or distribute Opaque copies of the Document numbering more than 100, you must either
include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque
copy a computer-network location from which the general network-using public has access to download
using public-standard network protocols a complete Transparent copy of the Document, free of added
material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution
of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an Opaque copy (directly or through your
agents or retailers) of that edition to the public.
It is requested, but not required, that you contact the authors of the Document well before redistributing
any large number of copies, to give them a chance to provide you with an updated version of the Document.
4. MODIFICATIONS
You may copy and distribute a Modiﬁed Version of the Document under the conditions of sections 2 and 3
above, provided that you release the Modiﬁed Version under precisely this License, with the Modiﬁed Ver-
sion ﬁlling the role of the Document, thus licensing distribution and modiﬁcation of the Modiﬁed Version
to whoever possesses a copy of it. In addition, you must do these things in the Modiﬁed Version:
A. Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from
those of previous versions (which should, if there were any, be listed in the History section of the
Document). You may use the same title as a previous version if the original publisher of that version
gives permission.
B. List on the Title Page, as authors, one or more persons or entities responsible for authorship of the
modiﬁcations in the Modiﬁed Version, together with at least ﬁve of the principal authors of the Doc-
ument (all of its principal authors, if it has fewer than ﬁve), unless they release you from this require-
ment.
C. State on the Title page the name of the publisher of the Modiﬁed Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modiﬁcations adjacent to the other copyright notices.
F. Include, immediately after the copyright notices, a license notice giving the public permission to use
the Modiﬁed Version under the terms of this License, in the form shown in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the
Document’s license notice.
H. Include an unaltered copy of this License.
221
I. Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the
title, year, new authors, and publisher of the Modiﬁed Version as given on the Title Page. If there is no
section Entitled “History” in the Document, create one stating the title, year, authors, and publisher
of the Document as given on its Title Page, then add an item describing the Modiﬁed Version as stated
in the previous sentence.
J. Preserve the network location, if any, given in the Document for public access to a Transparent copy
of the Document, and likewise the network locations given in the Document for previous versions it
was based on. These may be placed in the “History” section. You may omit a network location for a
work that was published at least four years before the Document itself, or if the original publisher of
the version it refers to gives permission.
K. For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section,
and preserve in the section all the substance and tone of each of the contributor acknowledgements
and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section
numbers or the equivalent are not considered part of the section titles.
M. Delete any section Entitled “Endorsements”. Such a section may not be included in the Modiﬁed
Version.
N. Do not retitle any existing section to be Entitled “Endorsements” or to conﬂict in title with any Invari-
ant Section.
O. Preserve any Warranty Disclaimers.
If the Modiﬁed Version includes new front-matter sections or appendices that qualify as Secondary Sections
and contain no material copied from the Document, you may at your option designate some or all of these
sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modiﬁed Version’s
license notice. These titles must be distinct from any other section titles.
You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your
Modiﬁed Version by various parties–for example, statements of peer review or that the text has been ap-
proved by an organization as the authoritative deﬁnition of a standard.
You may add a passage of up to ﬁve words as a Front-Cover Text, and a passage of up to 25 words as a Back-
Cover Text, to the end of the list of Cover Texts in the Modiﬁed Version. Only one passage of Front-Cover
Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If
the Document already includes a cover text for the same cover, previously added by you or by arrangement
made by the same entity you are acting on behalf of, you may not add another; but you may replace the old
one, on explicit permission from the previous publisher that added the old one.
The author(s) and publisher(s) of the Document do not by this License give permission to use their names
for publicity for or to assert or imply endorsement of any Modiﬁed Version.
5. COMBINING DOCUMENTS
You may combine the Document with other documents released under this License, under the terms de-
ﬁned in section 4 above for modiﬁed versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodiﬁed, and list them all as Invariant Sections of
your combined work in its license notice, and that you preserve all their Warranty Disclaimers.
The combined work need only contain one copy of this License, and multiple identical Invariant Sections
may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different
contents, make the title of each such section unique by adding at the end of it, in parentheses, the name
222
of the original author or publisher of that section if known, or else a unique number. Make the same
adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.
In the combination, you must combine any sections Entitled “History” in the various original documents,
forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and
any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements”.
6. COLLECTIONS OF DOCUMENTS
You may make a collection consisting of the Document and other documents released under this License,
and replace the individual copies of this License in the various documents with a single copy that is in-
cluded in the collection, provided that you follow the rules of this License for verbatim copying of each of
the documents in all other respects.
You may extract a single document from such a collection, and distribute it individually under this License,
provided you insert a copy of this License into the extracted document, and follow this License in all other
respects regarding verbatim copying of that document.
7. AGGREGATION WITH INDEPENDENT WORKS
A compilation of the Document or its derivatives with other separate and independent documents or works,
in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting
from the compilation is not used to limit the legal rights of the compilation’s users beyond what the indi-
vidual works permit. When the Document is included in an aggregate, this License does not apply to the
other works in the aggregate which are not themselves derivative works of the Document.
If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Doc-
ument is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers
that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is
in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.
8. TRANSLATION
Translation is considered a kind of modiﬁcation, so you may distribute translations of the Document under
the terms of section 4. Replacing Invariant Sections with translations requires special permission from their
copyright holders, but you may include translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections. You may include a translation of this License, and all the
license notices in the Document, and any Warranty Disclaimers, provided that you also include the original
English version of this License and the original versions of those notices and disclaimers. In case of a
disagreement between the translation and the original version of this License or a notice or disclaimer, the
original version will prevail.
If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement
(section 4) to Preserve its Title (section 1) will typically require changing the actual title.
9. TERMINATION
You may not copy, modify, sublicense, or distribute the Document except as expressly provided for under
this License. Any other attempt to copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License. However, parties who have received copies, or
rights, from you under this License will not have their licenses terminated so long as such parties remain
in full compliance.
223
10. FUTURE REVISIONS OF THIS LICENSE
The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License
from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail
to address new problems or concerns. See http://www.gnu.org/copyleft/.
Each version of the License is given a distinguishing version number. If the Document speciﬁes that a
particular numbered version of this License “or any later version” applies to it, you have the option of
following the terms and conditions either of that speciﬁed version or of any later version that has been
published (not as a draft) by the Free Software Foundation. If the Document does not specify a version
number of this License, you may choose any version ever published (not as a draft) by the Free Software
Foundation.
ADDENDUM: How to use this License for your documents
To use this License in a document you have written, include a copy of the License in the document and put
the following copyright and license notices just after the title page:
Copyright © YEAR YOUR NAME. Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover
Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled “GNU
Free Documentation License”.
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with . . . Texts.” line
with this:
with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts being LIST,
and with the Back-Cover Texts being LIST.
If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those
two alternatives to suit the situation.
If your document contains nontrivial examples of program code, we recommend releasing these examples
in parallel under your choice of free software license, such as the GNU General Public License, to permit
their use in free software.
224
Index
for, 130
abstraction, 154
algorithm, 111
algorithms, 3
aliased, 138
argument, 27, 41
ASCII, 220
assignment operator, 18
assignment statement, 18
attributes, 73, 150, 151
bind, 179
block, 51
body, 38, 51
boolean expression, 52
boolean functions, 65
boolean values, 52
branches, 53
bugs, 4
byte code, 2
chained conditional, 54
cipher, 218
class, 150
cloning, 138
command line, 206
command line arguments, 206
comments, 47
comparison operators, 52
compilers, 2
compose, 37
composed, 41
composition, 64
compound statements, 38
compound data types, 81
computer scientist, 1
concatenation, 22
condition, 51
Conditional statements, 51
constructed, 149
constructor, 150
counter, 103
cursor, 104data type, 149
dead code, 62
debugging, 4
decrement, 100
deep copy, 156
deep equality, 153
default parameter values, 163
default value, 123
delimiter, 94, 142
development plan, 108
dialog, 165
Dictionaries, 189
directories, 94
docstring, 86
dot operator, 73, 77
dot notation, 86
elements, 127
encapsulate, 107
environment, 205
escape sequence, 104
evaluates, 20
even number, 68
Event Driven, 161
exceptions, 4
executable, 2
expression, 20
ﬁle system, 94
ﬁles, 91
ﬂoat, 17
ﬂow of execution, 40
Formal languages, 5
format ﬁelds, 119
format string, 119
frame, 46
fruitful functions, 61
function, 37
function call, 27, 38
function deﬁnition, 37
functional programming style, 140
generalize, 107
glob, 207
225
Graphical User Interface (GUI), 161
header, 38
high-level language, 1
IDE, 11
identiﬁer, 137
IDLE, 11
if statement, 51
immutable, 83, 195
increment, 100
incremental development, 63
index, 81
inﬁnite loop, 101
information hiding, 154
initialization, 149
initialize, 100
instances, 149
instantiated, 149
int, 17
integer, 17
integer division, 21
interpreters, 2
invocation, 190
item assignment, 132
iteration, 101
Jython, 205
key-value pairs, 189
keys, 189
keywords, 19
len, 27
list, 127
list traversal, 129
local, 109
local variable, 45
logical operators, 52
loop, 101
loop variable, 107
low-level languages, 1
mapping type, 189
method, 151
methods, 149
mode, 91
modiﬁers, 139
module, 71
modulo arithmetic, 220
modulus operator, 21
multiple assignment, 99
mutable, 132, 195named parameter, 163
namespace, 72
naming collision, 73
Natural languages, 5
nested, 54, 127
newline, 104
non-volatile, 91
None, 62
object code, 2
object-oriented programming, 149
object-oriented programming language, 149
objects, 137, 149
odd, 68
OOP , 149
operands, 21
Operators, 21
optional parameter, 123
parameters, 40
parsing, 5
path, 94
portable, 1
prime number, 106
print statement, 6
problem solving, 1
procedural programming, 149
program, 3
programming paradigm, 149
pure function, 139
Python prompt, 2
Python shell, 2
RAM, 91
refactoring, 185
regular expressions, 210
Remember: you should submit all ﬁles you create
during a lab at the end of that lab. For the
written answers, create a new ﬁle in IDLE
called “Lab1.txt” and type your answers in
there., 13
return value, 27, 62
rules of precedence, 22
scaffolding, 64
script, 3
semantic error, 4
sequences, 127
shallow equality, 153
shallow copying, 156
side effects, 139
slice, 82
source code, 2
226
stack diagram, 46
state diagram, 18
statement, 20
step size, 129
str, 17
string, 17
Syntax, 4
syntax error, 4
tab, 104
temporary variables, 62
tokens, 5
trace, 102
traceback, 47
traversal, 83
tuple, 189, 195
tuple assignment, 196
types, 17
Unicode, 220
unit testing, 74
value, 17
Variable names, 19
variables, 18
virtual machine, 2
volatile, 91
widget, 164
227

2550 Garcia Avenue
Mountain View, CA 94043 USA
415 960-1300 fax 415 969-9131A Sun Microsystems, Inc. BusinessPascal Language Reference
Part No.: 802-5762-10
Revision A, December 1996SunSoft, Inc.
Please
RecycleCopyright 1996 Sun Microsystems, Inc., 2550 Garcia Avenue, Mountain View, California 94043-1100 U.S.A. All rights reserved.
This product or document is protected by copyright and distributed under licenses restricting its use, copying, distribution, a nd
decompilation. No part of this product or document may be reproduced in any form by any means without prior writtenauthorization of Sun and its licensors, if any.
Portions of this product may be derived from the UNIX
® system, licensed from Novell, Inc., and from the Berkeley 4.3 BSD
system, licensed from the University of California. UNIX is a registered trademark in the United States and other countries and  is
exclusively licensed by X/Open Company Ltd. Third-party software, including font technology in this product, is protected bycopyright and licensed from Sun’s suppliers.
RESTRICTED RIGHTS: Use, duplication, or disclosure by the U.S. Government is subject to restrictions of FAR 52.227-
14(g)(2)(6/87) and FAR 52.227-19(6/87), or DFAR 252.227-7015(b)(6/95) and DFAR 227.7202-3(a).
Sun, Sun Microsystems, the Sun logo, SunSoft, Solaris, the Sun Microsystems Computer Corporation logo, the SunSoft logo,
ProWorks, ProWorks/TeamWare, ProCompiler, Sun-4, SunOS, ONC, ONC+, NFS, OpenWindows, DeskSet, ToolTalk, SunView,XView, X11/NeWS, AnswerBook are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States andother countries. All SPARC trademarks are used under license and are trademarks or registered trademarks of SPARCInternational, Inc. in the United States and other countries. Products bearing SPARC trademarks are based upon an architecturedeveloped by Sun Microsystems, Inc. PostScript and Display PostScript are trademarks of Adobe Systems, Inc. PowerPC™ is atrademark of International Business Machines Corporation. HP
® and HP-UX® are registered trademarks of Hewlett-Packard
Company.
The OPEN LOOK® and Sun™ Graphical User Interfaces were developed by Sun Microsystems, Inc. for its users and licensees.
Sun acknowledges the pioneering efforts of Xerox in researching and developing the concept of visual or graphical userinterfaces for the computer industry. Sun holds a non-exclusive license from Xerox to the Xerox Graphical User Interface, whichlicense also covers Sun’s licensees who implement OPEN LOOK GUIs and otherwise comply with Sun’s written licenseagreements.
THIS PUBLICATION IS PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR APARTICULAR PURPOSE, OR NON-INFRINGEMENT.
iiiContents
Preface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix
1. Lexical Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Character Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1Special Symbols. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2Reserved Words  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3Identiﬁers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2. Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
Summary of Data Format Differences . . . . . . . . . . . . . . . . . . . 10
Default Data Alignments and Padding . . . . . . . . . . . . . . . 10Data Formats with -calign . . . . . . . . . . . . . . . . . . . . . . . . 11
Data Formats with -xl  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
Data Formats with -calign  and-xl . . . . . . . . . . . . . . . . 12
real . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
real  Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
iv Pascal Language Referencereal  Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
real  Constants. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
Data Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
Integer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
Integer Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17Integer Initialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18Integer Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18Data Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
boolean  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
boolean  Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
boolean  Initialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
boolean  Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Data Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Character . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
Character Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22Character Initialization  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22Character Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23Data Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Enumerated Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Enumerated Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24Data Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
Subrange  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
 Subrange Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 Data Representation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
Contents vRecord  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
Record Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27Record Initialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27Data Representation of Unpacked Records. . . . . . . . . . . . 30Data Representation of Packed Records  . . . . . . . . . . . . . . 30
Array  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
Array Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34Array Initialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36Packed Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37Data Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Set  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
Set Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38Set Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38Packed Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39Data Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
File  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41Pointer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
Standard Pointer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41Universal Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42Procedure and Function Pointers . . . . . . . . . . . . . . . . . . . . 43Pointer Initialization  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45Data Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
3. Statements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
Standard Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
vi Pascal Language ReferenceStatements Speciﬁc to Pascal . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
assert  Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
case  Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
exit  Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
goto  Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
next  Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
otherwise  Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
return  Statement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
with  Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4. Assignments and Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
Data Type Assignments and Compatibility. . . . . . . . . . . . . . . 63String Assignments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
Fixed- and Variable-Length Strings . . . . . . . . . . . . . . . . . . 64Null Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65String Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
Arithmetic Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66Themod Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
Bit Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68boolean  Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
Theand then Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Theor else Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
Set Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71Relational Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
Contents viiRelational Operators on Sets . . . . . . . . . . . . . . . . . . . . . . . . 72
The= and<> Operators on Records and Arrays . . . . . . . 73
String Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
 Precedence of Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
5. Program Declarations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Declarations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Label Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77Constant Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79Type Declaration. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79Variable Declaration. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80Deﬁne Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Procedure and Function Headings . . . . . . . . . . . . . . . . . . . . . . 84
Visibility. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84Parameter List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85Type Identiﬁer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89Functions Returning Structured-Type Results . . . . . . . . . 89Options  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
6. Built-In Procedures and Functions  . . . . . . . . . . . . . . . . . . . . . . 95
Standard Procedures and Functions. . . . . . . . . . . . . . . . . . . . . 95Routines Speciﬁc to Pascal (Summary)  . . . . . . . . . . . . . . . . . . 96Routines Speciﬁc to Pascal (Details). . . . . . . . . . . . . . . . . . . . . 99
addr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
append  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
argc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
viii Pascal Language Referenceargv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
arshft  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
asl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
asr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
card . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
close . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
concat  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
date . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
discard  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
expo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
filesize  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
firstof  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
flush . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
getenv  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
getfile  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
halt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
in_range  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
land . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
lastof  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
length  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
linelimit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
lnot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
Contents ixlor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
lshft . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
lsl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
lsr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
max . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
message  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
min . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
null . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
open . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
pcexit  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
random  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
read  andreadln  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
remove  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
rewrite  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
rshft . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
seed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
seek . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
sizeof  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
stlimit  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
stradd  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
substr  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
sysclock  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
tell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
x Pascal Language Referencetime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
trace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
trim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
Type Transfer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193wallclock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
write and writeln . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
xor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
7. Input and Output  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
Input and Output Routines . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203eof andeoln  Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
More About eoln . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
External Files and Pascal File Variables . . . . . . . . . . . . . . . . . . 210
Permanent Files  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210Temporary Files  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
input ,output , anderrout  Variables  . . . . . . . . . . . . . . . . . 211
Properties of input ,output , anderrout  Variables. . . 211
Associating input  with a File Other Than stdin  . . . . . 212
Associating output  with a File Other Than stdout  . . . 212
Associating errout  with a File Other Than stderr  . . . 212
Pascal I/O Library  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213Buffering of File Output. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213I/O Error Recovery. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
A. Overview of Pascal Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . 219
Lexical Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
Contents xiData Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221Assignments and Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . 221Headings and Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221Procedures and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222Built-In Routines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222Input and Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225Program Compilation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
B. Pascal and DOMAIN Pascal . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
The–xl Option. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
DOMAIN Pascal Features Accepted but Ignored. . . . . . . . . . 228DOMAIN Pascal Features Not Supported. . . . . . . . . . . . . . . . 229
C. Implementation Restrictions  . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
Identiﬁers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
real . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
Integer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232Character . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232Record  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232Array  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232Set  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
Nested Routines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235Default Field Widths  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
xii Pascal Language ReferenceD. Pascal Validation Summary Report . . . . . . . . . . . . . . . . . . . . . . 237
Test Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237Manufacturer’s Statement of Compliance . . . . . . . . . . . . . . . . 237
Implementation-Deﬁned Features . . . . . . . . . . . . . . . . . . . 238Reporting of Errors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239Implementation-Dependent Features  . . . . . . . . . . . . . . . . 240Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
xiiiFigures
Figure 2-1 32-Bit Floating-Point Number . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
Figure 2-2 64-Bit Floating-Point Number . . . . . . . . . . . . . . . . . . . . . . . . . . . 15Figure 2-3 16-Bit Integer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20Figure 2-4 32-Bit Integer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20Figure 2-5 true boolean  Variable  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Figure 2-6 false boolean  Variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
Figure 2-7 16-Bit Enumerated Variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24Figure 2-8 Sample Enumerated Representation  . . . . . . . . . . . . . . . . . . . . . 25Figure 2-9 16-Bit Subrange  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26Figure 2-10 32-Bit Subrange  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26Figure 2-11 Sample Packed Record (Without -xl). . . . . . . . . . . . . . . . . . . . 33
Figure 2-12 Small Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40Figure 2-13 Large Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41Figure 2-14 Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
xiv Pascal Language Reference
xvTables
Table 1-1 Nonstandard Special Symbols. . . . . . . . . . . . . . . . . . . . . . . . . . . 2
Table 1-2 Standard Reserved Words . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3Table 1-3 Nonstandard Reserved Words  . . . . . . . . . . . . . . . . . . . . . . . . . . 4Table 1-4 Predeclared Standard Identifiers. . . . . . . . . . . . . . . . . . . . . . . . . 4Table 1-5 Predeclared Nonstandard Identifiers . . . . . . . . . . . . . . . . . . . . . 5Table 2-1 real  Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Table 2-2 Representation of Extreme Exponents . . . . . . . . . . . . . . . . . . . . 15Table 2-3 Hexadecimal Representation of Selected Numbers . . . . . . . . . 16Table 2-4 Integer Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17Table 2-5 Values for maxint  andminint . . . . . . . . . . . . . . . . . . . . . . . . . 19
Table 2-6 Nonstandard Predeclared Character Constants . . . . . . . . . . . . 23Table 2-7 Subrange Data Representation  . . . . . . . . . . . . . . . . . . . . . . . . . . 26Table 2-8 Packed Record Storage Without –xl . . . . . . . . . . . . . . . . . . . . 31
Table 2-9 Packed Record Storage with  –xl . . . . . . . . . . . . . . . . . . . . . . . . 32
Table 2-10 Packed Record Storage with -calign  . . . . . . . . . . . . . . . . . . . 32
Table 2-11 Sample Sizes and Alignment of Packed Record . . . . . . . . . . . . 33
xvi Pascal Language ReferenceTable 2-12 Array Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
Table 2-13 Data Representation of Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40Table 3-1 Nonstandard Pascal Statements  . . . . . . . . . . . . . . . . . . . . . . . . . 48Table 4-1 Data Type Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64Table 4-2 Fixed- and Variable-Length String Assignments . . . . . . . . . . . 65Table 4-3 Null String Assignments  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65Table 4-4 Arithmetic Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66Table 4-5 Bit Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68Table 4-6 boolean  Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Table 4-7 Set Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71Table 4-8 Relational Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72Table 4-9 Precedence of Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76Table 6-1 Standard Procedures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95Table 6-2 Standard Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96Table 6-3 Nonstandard Arithmetic Routines . . . . . . . . . . . . . . . . . . . . . . . 96Table 6-4 Nonstandard Bit Shift Routines. . . . . . . . . . . . . . . . . . . . . . . . . . 97Table 6-5 Nonstandard Character String Routines . . . . . . . . . . . . . . . . . . 97Table 6-6 Nonstandard Input and Output Routines . . . . . . . . . . . . . . . . . 98Table 6-7 Extensions to Standard Input and Output Routines  . . . . . . . . 98Table 6-8 Miscellaneous Nonstandard Routines . . . . . . . . . . . . . . . . . . . . 99Table 6-9 firstof  Return Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
Table 6-10 land  Truth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
Table 6-11 lastof  Return Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
Table 6-12 lnot  Truth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
Table 6-13 lor Truth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
Tables xviiTable 6-14 open  Error Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
Table 6-15 Default Field Widths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199Table 6-16 xor Truth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
Table 7-1 Extensions to Input/Output Routines . . . . . . . . . . . . . . . . . . . . 204Table 7-2 Pascal File Variable with a Permanent File . . . . . . . . . . . . . . . . 210Table 7-3 Pascal File Variable with a Temporary File . . . . . . . . . . . . . . . . 211Table A-1 Nonstandard Identifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220Table B-1 Differences Between Programs Compiled with and without –xl 227
Table C-1 Values for single  anddouble  . . . . . . . . . . . . . . . . . . . . . . . . . . 232
Table C-2 maxint  andminint  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
Table C-3 Internal Representation of Data Types without –xl . . . . . . . . . . 234
Table C-4 Internal Representation of Data Types with -xl . . . . . . . . . . . . . 235
Table C-5 Default Field Widths. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
xviii Pascal Language Reference
xixPreface
The Sun Workshop Compiler Pascal 4.2 is an implementation of the Pascal
language that includes all the standard language elements and manyextensions.  These extensions allow greater ﬂexibility in  programs include:
•Separate compilation of programs and modules
•dbx (symbolic debugger) support, including  ﬁx-and-continue functionality
•Optimizer support
•Multiple label ,const ,type , andvar declarations
•Variable-length character strings
•Compile-time initializations
•static  andextern  declarations
•Additional sizes of integer and real data types
•Integers in any base from 2 to 16
•Extended input/output facilities
•Extended library of built-in functions and procedures
•Universal and function and procedure pointer types
•Speciﬁcation of the direction of parameter passing as one of the following:
°Into a routine
°Out of a routine
°Both into and out of a routine
xx Pascal Language ReferenceIn addition, Pascal 4.2 contains a compiler switch, -xl, to provide
compatibility with Apollo® DOMAIN® Pascal to ease the task of porting your
Apollo Pascal applications to workstations.
Note – All references to Pascal in this manual refer to the Sun Workshop
Compiler Pascal 4.2 unless otherwise indicated.
Audience
This manual provides reference material for the Pascal 4.2 compiler. To use this
manual, you should be familiar with ISO standard Pascal and with Solariscommands and concepts.
Operating Environment
The Sun Workshop Compiler Pascal 4.2 runs on Solaris™ 2.x systems.
For other release-speciﬁc information, see the README  ﬁle.
Installation
Instructions for installing Pascal and other software on your SPARCstation are
given in the Sun  WorkShop Installation and Licensing Guide , which includes
information on installing the online documentation.
How This Manual Is Organized
This manual is a reference manual for Pascal extensions to Standard Pascal.Chapters 1 through 7 describe extensions to the elements of a Pascal program:
•Chapter 1, “Lexical Elements”
•Chapter 2, “Data Types”
•Chapter 3, “Statements”
•Chapter 4, “Assignments and Operators”
•Chapter 5, “Program Declarations”
•Chapter 6, “Built-In Procedures and Functions”
Preface xxi•Chapter 7, “Input and Output”
As each extension is presented, a complete example is provided to illustrate
that extension.
This manual also has four appendixes:
•Appendix A,  “Overview of Pascal Extensions,”  summarizes the Pascal
extensions to standard Pascal, and serves as a quick reference guide to thedifferences between Pascal and standard Pascal.
•Appendix B,  “Pascal and DOMAIN Pascal,”  lists the differences between
Pascal and Apollo DOMAIN  Pascal.
•Appendix C,  “Implementation Restrictions,”  describes Pascal features that
are implementation-deﬁned.
•Appendix D,  “Pascal Validation Summary Report,”  summarizes the
features, errors, and extensions in the manufacturer’s statement ofcompliance for the validation of the Pascal Version 4.2 compiler.
A glossary and an index are included at the end of the manual.
xxii Pascal Language ReferenceConventions Used in This Manual
This manual contains syntax diagrams of the Pascal language in extended
Backus-Naur Formalism (BNF) notation. It uses the following meta symbols:
The following table describes the type styles and symbols used in this manual:Table P-1 BNF Meta Symbols
Meta Symbol Description
::= Deﬁned as| Can be used as an alternative (a |b) Either aorb
 [a ] Zero or one instance of
a
{a } Zero or more instances of a
'abc ' The characters abc
Table P-2 Typographic Conventions
Typeface or
Symbol Meaning Example
AaBbCc123 The names of commands, ﬁles, and
directories; on-screen computeroutputEdit your .login  ﬁle.
Usels -a to list all ﬁles.
hostname% You have mail.
AaBbCc123 What you type, contrasted with on-
screen computer outputhostname%su
Password:
AaBbCc123 Command-line placeholder:
replace with a real name or valueTo delete a ﬁle, type rmﬁlename.
AaBbCc123 Book titles, new words or terms, or
words to be emphasizedRead the User’s Guide .
These are called class  options.
You must  be root to do this.
Preface xxiiiShell Prompts in Command Examples
The following table shows the default system prompt and superuser prompt
for the C shell, Bourne shell, and Korn shell.
Related Documentation
This manual is designed to accompany the following documents:
•The Pascal User’s Guide , which describes how to use the Pascal 4.2 compiler
•The Pascal Quick Reference Card , which summarizes the compiler options
Both this manual and the Pascal User’s Guide  are available in the AnswerBook®
system, an online documentation viewing tool that takes advantage of
dynamically linked headings and cross-references.  The Sun  WorkShop
Installation and Licensing Guide  shows you how to install AnswerBook.
Manual Page
Pascal 4.2 provides an online manual page (also known as a man page), on
pc(1), that describes the Pascal compiler.  This document is included in the
Pascal package and must be installed with the rest of the software.
After you install the documentation, you can read about pc by entering the
man command followed by the command name, as in:
hostname%man pc
README  Files
TheREADME  default directory is: /opt/SUNWspro/READMEsTable P-3 Shell Prompts
Shell Prompt
C shell prompt machine_name%
C shell superuser prompt machine_name#
Bourne shell and Korn shell prompt $
Bourne shell and Korn shell superuser prompt #
xxiv Pascal Language ReferenceThis directory contains the following ﬁles:
•A Pascal 4.2 README , called pascal , which describes the new features,
software incompatibilities, and software bugs of Pascal 4.2.
•A ﬂoating-point white paper,  “What Every Scientist Should Know About
Floating-Point Arithmetic ,” by David Goldberg, in PostScript™ format.  The
ﬁle is called floating-point.ps , and can be printed on any PostScript-
compatible printer that has Palatino font.  It can be viewed online by usingtheimagetool  command:
hostname%imagetool floating-point.ps
This paper is also available in the AnswerBook system.
Other Related Documentation
Other reference material includes:
Incremental Link Editor ( ild)
Numerical Computation GuidePerformance Proﬁling Tools
Documents in Hard Copy and in AnswerBook
The following table shows what documents are online, in hard copy, or both:
Table P-4 Documents in Hard Copy and in AnswerBook
Title Hard Copy Online
Pascal User’s Guide X X (AnswerBook)
Pascal Language Reference X X (AnswerBook)
Pascal Quick Reference Card X
Incremental Link Editor ( ild) X X (AnswerBook)
Numerical Computation Guide X X (AnswerBook)
Performance Proﬁling Tools X X (AnswerBook)
pascal [README ﬁle] X (CD-ROM)
What Every Scientist Should Know About Floating-Point Arithmetic X (AnswerBook and CD-ROM)
1Lexical Elements 1
This chapter describes the symbols and words of a Pascal program.  It contains
the following sections:
Character Set
Pascal uses the standard seven-bit ASCII character set, and the compilerdistinguishes between uppercase and lowercase characters.  For example, thefollowing seven words are distinct from the predeﬁned type integer :
If you change the case of characters used in a word, the compiler does not
recognize the word and gives an error.Character Set page 1
Special Symbols page 2Reserved Words page 3Identiﬁers page 4Comments page 6
Integer INTEGer
INteger INTEGErINTeger INTEGERINTEger
2 Pascal Language Reference1
The Pascal keywords and built-in procedure and function names are all in
lowercase.
To map all keywords and identiﬁers to lowercase when you compile your
program, use the following pc options:
See the Pascal 4.2 User’s Guide  for a complete description of pc and its options.
Special Symbols
Pascal recognizes the following standard Pascal symbols and the nonstandard
special symbols listed in Table 1-1.–L Maps all uppercase letters in keywords and identiﬁers to lowercase.
–s Performs the same action as –L and also produces warning diagnostics
for nonstandard constructs and extensions.
+ - * / = < > [ ] . , :=
: ; ( ) <> <= >= .. ^
Table 1-1 Nonstandard Special Symbols
Symbol Description Example
~ Bitwise not operator ~4
& Bitwise and operator 4&3
| Bitwise or operator 4|3
! Bitwise or operator 4!3
# Speciﬁes an integer value in a base
other than base 10.p := 2#10111; { base 2 }
f := 8#76543; { base 8 }
Includes a ﬁle in the program. #include  "globals.h"
#include "math_p.h"
Indicates a preprocessor command #ifdef DEBUGGING
writeln('Total :',i,sum);#endif
% Indicates a cppas  compiler directive %var one, two
%enable two
Lexical Elements 31
Reserved Words
Pascal reserves the standard words in Table 1-2.  You cannot redeﬁne a
reserved word to represent another item.
Pascal also reserves the nonstandard words in Table 1-3.  These words are not
treated as reserved words when you compile your program with any of the –s,
–s0,–s1,–V0 or–V1 options.Table 1-2 Standard Reserved Words
Pascal Standard Reserved Words
and file mod repeatarray for nil setbegin forward not thencase function of toconst goto or typediv if packed untildo in procedure vardownto label program whileelse main record with
4 Pascal Language Reference1
Identiﬁers
In Pascal, you can include a dollar sign ( $) and underscore ( _) in an identiﬁer
name.  The $ and_ can occur in any position of the identiﬁer name.  However,
you should avoid using these characters in the ﬁrst position because they mayconﬂict with system names.
Pascal predeclares the standard identiﬁers in Table 1-4 and the nonstandard
identiﬁers in Table 1-5.Table 1-3 Nonstandard Reserved Words
Pascal Nonstandard Reserved Words
define privateextern publicexternal staticmodule univotherwise
Table 1-4 Predeclared Standard Identiﬁers
Pascal Predeclared Standard Identiﬁers
abs false page sinarctan get pred sqrboolean input put sqrtchar integer read succchr ln readln textcos maxint real truedispose new reset trunceof odd rewrite writeeoln ord round writelnexp output
Lexical Elements 51
You can redeﬁne a predeclared identiﬁer to represent another item.  For
example, you could redeﬁne the predeﬁned identiﬁer next , a statement that
causes the program to skip to the next iteration of the current loop, as avariable.
Once you redeﬁne an identiﬁer, you cannot use it as originally deﬁned in the
program, as shown in the following example:Table 1-5 Predeclared Nonstandard Identiﬁers
Pascal Predeclared Nonstandard Identiﬁers
FALSE exit lor seekTRUE expo lshft shortrealaddr filesize lsl singlealfa firstof lsr sizeofappend flush max stlimitargc getenv maxchar straddargv getfile message stringarshft halt min substrasl in_range minchar sysclockasr index minint tabassert integer16 next tellbell integer32 null timecard intset open traceclock land pack trimclose lastof random univ_ptrconcat length remove unpackdate linelimit return varyingdiscard lnot rshft wallclockdouble longreal seed xor
6 Pascal Language Reference1
Comments
In Pascal, you can specify a comment in either braces, quotation marks, a
parenthesis/asterisk pair, or a slash/asterisk pair:
{  This is a comment. }
(* This is a comment. *)"  This is a comment. "/* This is a comment. */
The symbols used to delimit a comment must match.  For example, a comment
that starts with { must end with }, and a comment that starts with (* must
end with *).The Pascal program,
pred_iden.p , redeﬁnes the
predeclared identiﬁer next as an
integer variable.program predefined_identifier;
var
    i: integer;    next: integer;
begin
    for i := 1 to 10 do begin      if i > 5 then begin          next      end    endend. { predefined_identifier }
This program does not compile
because next is declared as a
variable, but used in its originaldeﬁnition as a statement.hostname%pc pred_iden.p
Mon Feb 20 15:13:17 1995  pred_iden.p:          10            nextE 18470-----------------^---  Replaced variable id with aprocedure idIn program predefined_identifier:E 18250 next improperly used on line 10
Lexical Elements 71
You can nest comments in Pascal, that is, include one type of comment
delimiter inside another:
{ This is a valid (* comment within a comment. *) }
(* This is a valid " comment within a comment. " *)
You cannot nest the same kind of comments.  The following comments result in
a compile-time error:
{  This is not a valid { comment within a comment. } }
(* This is not a valid (* comment within a comment. *) *)"  This is not a valid " comment within a comment. " "/* This is not a valid /* comment within a comment. */ */
8 Pascal Language Reference1
9Data Types 2
This chapter describes the Pascal data types.  Some data types represent
different values when you compile your program with or without the –xl
option, and with or without the –calign  option.  The intent of the –xl option
is to guarantee binary data compatibility between the operating system andApollo MC680x0-based workstations.  The intent of the -calign  option is to
improve compatibility with C language data structures.
This chapter contains the following sections:
Summary of Data Format Differences page 10
real page 13Integer page 16boolean page 20Character page 22Enumerated Types page 23Subrange page 25Record page 26Array page 34Set page 38File page 41Pointer page 41
10 Pascal Language Reference2
Summary of Data Format Differences
A few data formats, particularly of structured types, change when you use the
Pascal compiler -calign  option, when you use the -xl option, and when you
use the -calign  with the -xl option.  This section describes the data
alignments and sizes that change with these options.  See the remainder of thechapter for information on types that do not change when you use theseoptions.
All simple data types take their natural alignments.  For example, real
numbers, being four-byte values, have four-byte alignment.  Naturally, nopadding is needed for simple types.
Default Data Alignments and Padding
Here is a summary of the default data alignments and padding.
Records
The alignment of a record is always four bytes.  Elements take their naturalalignment, but the total size of a record is always a multiple of four bytes.
Packed Records
Elements of types enumerated, subrange, integer16 , and sets with a cardinal
number less than 32 are bit-aligned in packed records.
Variant Records
The alignment of each variant in a record is the maximum alignment of allvariants.
Arrays
The alignment of a array is equal to the alignment of the elements, and the sizeof most arrays is simply the size of each element times the number of elements.The one exception to this rule is that the arrays of aggregates always have asize that is a multiple of four bytes.
Data Types 112
Sets
Sets have an alignment of four bytes when they are longer than 16 bits;
otherwise, their alignment is two bytes.  The size of a set is always a multipleof two bytes.
Enumerated Types
The size and alignment of enumerated types can be one byte or two,depending on the number of elements deﬁned for the type.
Subranges
The size and alignment of subrange types varies from one to four bytes,depending on the number of bits requires for its minimum and maximumvalues.  See Table 2-7 on page 26 for examples.
Data Formats with -calign
With the -calign  option, the data formats are:
Records
The alignment of a record is equal to the alignment of the largest element.
Packed Records
Packed records are the same as the default, except integer elements are not bit-
aligned.
Arrays
The size of all arrays is the size of each element times the number of elements.
Sets
Sets have an alignment of two bytes.  The size is the same as the default.
12 Pascal Language Reference2
Data Formats with -xl
In addition to the structured types discussed below, two simple data types
change their sizes with the -xl option:
•Typereal  is eight bytes by default; with -xl, it is four bytes.
•Typeinteger  is four bytes by default; with -xl, it is two bytes.
Packed Records
Values of type real  have four-byte sizes and alignment.  Values of type
integer  have a size of two bytes and are bit-aligned.
Enumerated Types
The size and alignment of enumerated types is always two bytes.
Subranges
The size and alignment of subrange types varies from two to four bytes,
depending on the number of bits requires for its minimum and maximumvalues.  See Table 2-7 for examples.
Data Formats with -calign  and-xl
When you use -xl with-calign , alignments and padding are the same as
with-xl alone, with the following differences:
Arrays
Arrays are the same as with -calign  alone, except the size of an array of
boolean s is always a multiple of two.
Varying Arrays
Varying arrays have an alignment of four bytes.  The size is a multiple of four.
Data Types 132
real
Pascal supports the standard predeclared real  data type.  As extensions to the
standard, Pascal also supports:
•single ,shortreal ,double , andlongreal  data types
•real  initialization in the variable declaration
•real  constants without a digit after the decimal point
real  Variables
The minimum and maximum values of the real  data types are shown in
Table 2-1.
 This example declares ﬁve real  variables:
real  Initialization
To initialize a real  variable when you declare it in the var declaration of your
program, create an assignment statement as follows:Table 2-1 real  Data Types
Type Bits Maximum Value Minimum Value
real  (with –xl option) 32 3.402823e+38 1.401298e-45
real (without –xl option) 64 1.79769313486231470e+308 4.94065645841246544e-324
single 32 3.402823e+38 1.401298e-45
shortreal 32 3.402823e+38 1.401298e-45
double 64 1.79769313486231470e+308 4.94065645841246544e-324
longreal 64 1.79769313486231470e+308 4.94065645841246544e-324
var x: real;
y: shortreal;z: longreal;weight: single;volume: double;
14 Pascal Language Reference2
You can also initialize real  variables in the var declaration of a procedure or
function; however, when you do so, you must also declare the variable asstatic :
The example in the following section deﬁnes six valid real  constants, two of
which do not have a digit after the decimal point.
real  Constants
Here is an example that of a real  constant:This example initializes the
variable ph to 4.5 and y to
2.71828182845905e+00.var
ph: single := 4.5;y: longreal := 2.71828182845905e+00;
This example initializes the
variable sum to 5.0, which
has been declared asstatic single .procedure foo (in x : single;
out y: single);
 var
sum: static single := 5.0;
const
n = 42.57;n2 = 4E12;n3 = 567.;n4 = 83.;n5 = cos(567.)/2;
n6 = succ(sqrt(5+4));
Data Types 152
Data Representation
Pascal represents real ,single ,shortreal ,double , andlongreal  data
types according to the IEEE standard, A Standard for Binary Floating-Point
Arithmetic. Figure 2-1 shows the representation of a 32-bit ﬂoating point
number; Figure 2-2 shows the representation of a 64-bit ﬂoating point number.
Figure 2-1 32-Bit Floating-Point Number
Figure 2-2 64-Bit Floating-Point Number
Areal  number is represented by this form:
(-1)sign * 2exponent-bias  *1.f
f is the bits in the fraction.  Extreme exponents are represented as shown in
Table 2-2.
Table 2-2 Representation of Extreme Exponents
Normalized real  numbers have an implicit leading bit that provides one more
bit of precision than usual.Exponent Description
zero (signed) Represented by an exponent of zero and a fraction of zero.Subnormal number Represented by (-1)
sign *21-bias *0.f, where fis the bits in the
signiﬁcand.
Not a Number (NaN) Represented by the largest value that the exponent an assume
(all ones), and a nonzero fraction.SExponent + 127 Mantissa
3 1 3 0 2 9 2 8 2 7 2 6 2 5 2 4 2 3 2 2 2 1 2 0 1 9 1 8 1 7 1 6 1 5 1 4 1 3 1 2 1 1 1 0 9876543210
SExponent + 1023 Mantissa
3 1 3 0 2 9 2 8 2 7 2 6 2 5 2 4 2 3 2 2 2 1 2 0 1 9 1 8 1 7 1 6 1 5 1 4 1 3 1 2 1 1 1 0 9876543210Mantissa (continued)63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32
16 Pascal Language Reference2
Table 2-3 shows the hexadecimal representation of several numbers.
Table 2-3 Hexadecimal Representation of Selected Numbers
Integer
Pascal supports the standard predeclared integer  data type.  As extensions to
the standard, Pascal also supports the integer16  andinteger32  data types,
integer initialization in the variable declaration, and integer constants in a baseother than base 10.Value 32-bit Floating-Point Number 64-bit Floating-Point Number
+0 00000000 0000000000000000-0 80000000 8000000000000000+1.0 3F800000 3FF0000000000000-1.0 BF800000 BFF0000000000000+2.0 40000000 4000000000000000+3.0 40400000 4008000000000000+Inﬁnity 7F800000 7FF0000000000000-Inﬁnity FF800000 FFF0000000000000NaN 7Fxxxxxx 7FFxxxxxxxxxxxxx
Data Types 172
Integer Variables
Table 2-4 lists the minimum and maximum values of the integer data types.
Table 2-4 Integer Data Types
 This example declares three integer variables:
To deﬁne an unsigned  integer in Pascal, use a subrange declaration.  The
subrange syntax indicates the lower and upper limits of the data type, asfollows:Type Number of Bits Maximum Value Minimum Value
integer (without
–xl option)32 2,147,483,647 -2,147,483,648
integer  (with
–xl option)16 32,767 -32,768
integer16 16 32,767 -32,768
integer32 32 2,147,483,647 -2,147,483,648
var
i: integer;score: integer16;number: integer32;
This code limits the legal values
for the variable unsigned_int
to 0 through 65536.type
unsigned_int = 0..65536;
var
u: unsigned_int;
18 Pascal Language Reference2
Integer Initialization
To initialize integer variables when you declare them in the var declaration
part of your program, put an assignment statement in the declaration, asfollows:
You can also initialize integer variables in the var declaration of a procedure
or function; however, when you do so, you must also declare the variable asstatic :
Integer Constants
You deﬁne integer constants in Pascal the same as you do as in standard
Pascal.
Here is an example:This example initializes the
variables a andb to 50 and c to
10000. var a, b: integer32 := 50;
c: integer16 := 10000;
This code initializes the variable
sum to 50, which has been
declared as static
integer16.procedure show (in x : integer16;
out y: integer16);
 var
sum: static integer16 := 50;
const
x = 10;y = 15;n1 = sqr(x);n2 = trunc((x+y)/2);n3 = arshft(8, 1);
Data Types 192
maxint andminint
The value Pascal assigns to the integer constants maxint  andminint  is
shown in Table 2-5.
Table 2-5 Values for maxint  andminint
In Another Base
To specify an integer constant in another base, use the following format:
base#number
base is an integer from 2 to 36. number  is a value in that base.  To express
number , use the digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and then use the letters a toz.
Case is insigniﬁcant; a is equivalent to A.
You can optionally put a positive sign ( +) or negative sign ( -) before base.  The
sign applies to the entire number, not the base.
Data Representation
Pascal represents integer ,integer16 , andinteger32  data types in twos
complement format. Figure 2-3 shows the representation of a 16-bit integer.Similarly, Figure 2-4 shows the representation of a 32-bit integer.Without -xl With-xl
Constant Bits Value Bits Valuemaxint 32 2,147,483,647 16 32,767
minint 32 -2,147,483,648 16 -32,768
This code speciﬁes integers in
binary, octal, and hexadecimalnotation.power := 2#10111; (* binary (base 2) *)
fraction_of_c := -8#76543; (* octal (base 8) *)percentage := +16#fd9c; (* hexadecimal (base 16) *)
20 Pascal Language Reference2
Figure 2-3 16-Bit Integer
Figure 2-4 32-Bit Integer
boolean
Pascal supports the standard predeclared data type boolean .  As an extension
to the standard, Pascal permits you to initialize boolean  variables in the
variable declaration.
boolean  Variables
In Pascal, you declare boolean  variables the same as in standard Pascal.  Both
of the following are valid boolean  variables:
boolean  Initialization
To initialize a boolean  variable when you declare it in the var declaration of
your program, use an assignment statement, as follows:This example declares the
variables cloudy andsunny as
boolean . var
cloudy: boolean;sunny: boolean;
This example initializes cloudy
totrue andsunny tofalse.var
cloudy: boolean := true;sunny: boolean := false;Byte 0 Byte 1
1 5 1 4 1 3 1 2 1 1 1 0 9876543210
3 1 3 0 2 9 2 8 2 7 2 6 2 5 2 4 2 3 2 2 2 1 2 0 1 9 1 8 1 7 1 6 1 5 1 4 1 3 1 2 1 1 1 0 9876543210Byte 0 Byte 1 Byte 2 Byte 3
Data Types 212
You can also initialize boolean  variables in the var declaration of a procedure
or function; however, when you do so, you must also declare the variable asstatic :
boolean  Constants
You declare boolean  constants in Pascal the same as in standard Pascal.
Three valid boolean  constants follow:
Data Representation
Pascal allocates one byte for each boolean  variable. Figure 2-5 shows how
Pascal internally represents a true boolean  variable; Figure 2-6 shows how
Pascal represents a false boolean  variable.
Figure 2-5 true boolean  VariableThis code initializes the variable
rainy tofalse, which has
been declared as static
boolean .function weather (x: integer): boolean;
var
rainy: static boolean := false;
This example declares the
constants a astrue andb as
false.  It also declares n as the
valueodd(y).const
a = true;b = false;y = 15;n = odd(y);
7654321000000001
22 Pascal Language Reference2
Figure 2-6 false boolean  Variable
Character
Pascal supports the standard predeclared data type char .  As extensions to the
standard, Pascal supports character initialization in the variable declarationand four nonstandard character constants.
Character Variables
You declare character variables in Pascal the same as you do in standardPascal.  Each of the following is a valid character variable:
Character Initialization
To initialize a character variable when you declare it in the var declaration of
your program, create an assignment statement, as follows:var
current_character: char;largest: char;smallest: char;
This example initializes the
variable pass to A and fail to F.var
pass: char := 'A';fail: char := 'F';7654321000000000
Data Types 232
You can also initialize character variables in the var declaration of a procedure
or function; however, when you do so, you must also declare the variable asstatic :
Character Constants
Pascal extends the standard deﬁnition of character constants by predeclaring
the four character constants in Table 2-6.
Table 2-6 Nonstandard Predeclared Character Constants
Data Representation
Pascal allocates one byte for each character variable.
Enumerated Types
Pascal supports enumerated data types with extensions that allow you to input
enumerated types with the read  andreadln  procedures and output them
with the write  andwriteln  procedures.  See the listings on read  andwrite
in Chapter 7, “Input and Output,” for details.This example initializes the
variable grade1 to A,grade2 to
B, and grade3 to C.  All three
variables are declared asstatic char .procedure grades;
var
grade1: static char := 'A';grade2: static char := 'B';grade3: static char := 'C';
Constant Description
minchar Equal to char(0)
maxchar Equal to char(255)
bell Equal to char(7)  (which makes your terminal beep)
tab Equal to char(9)  (which makes a tab character)
24 Pascal Language Reference2
Enumerated Variables
You declare enumerated data types in Pascal the same as in standard Pascal.
Data Representation
When you compile your program without the –xl option, Pascal represents
enumerated types as either 8 or 16 bits, depending on the number of elementsdefined for that type.  With -xl, Pascal represents variables of enumerated
type as 16 bits.  Pascal stores enumerated types as integers corresponding totheir ordinal value.
Figure 2-7 shows the representation of a 16-bit enumerated variable.
Figure 2-7 16-Bit Enumerated Variable
As an example, suppose you deﬁned a group of colors, as follows:
colors = (red, green, blue, orange);
Pascal represents each value as shown in Figure 2-8.type
continents =(North_America, South_America,             Asia, Europe, Africa, Australia,             Antartica);gem_cuts = (marquis, emerald, round, pear_shaped);
var
x: gem_cuts;index: continents;
Byte 0 Byte 1
1 5 1 4 1 3 1 2 1 1 1 0 9876543210
Data Types 252
Figure 2-8 Sample Enumerated Representation
Subrange
Pascal supports a subrange of integer, boolean , character, and enumerated
data types.
The Pascal subrange type is extended to allow constant expressions in both the
lower and upper bound of the subrange.  The lower bound expression isrestricted by requiring that the expression not begin with a left parenthesis.
 Subrange Variables
See “Integer Variables” on page 17 for an example of a subrange declaration.
 Data Representation
The Pascal subrange takes up the number of bits required for its minimum and
maximum values. Table 2-7 shows the space allocation of six subranges. 0 0 0 0 0 0 0 0
7654321 0
Red 0 0 0 0 0 0 0 1
7654321 0
Green
 0 0 0 0 0 0 1 0
7654321 0
Blue 0 0 0 0 0 0 1 1
7654321 0
Orange
26 Pascal Language Reference2
Table 2-7 Subrange Data Representation
Figure 2-9 shows how Pascal represents a 16-bit subrange.  Similarly,
Figure 2-10 shows how Pascal represents a 32-bit subrange.
Figure 2-9 16-Bit Subrange
Figure 2-10 32-Bit Subrange
Record
Pascal supports the standard record  andpacked record  data types.  As an
extension, Pascal permits you to initialize a record variable when you declare itin the variable declaration.Minimum/Maximum  Range Without –xl (Bits) With –xl (Bits)
0..127 8 16-128..127 8 160..255 16 16-32768..32767 16 160...65536 32 32-2,147,483,648..2,147,483,647 32 32
Byte 0 Byte 1
1 5 1 4 1 3 1 2 1 1 1 0 9876543210
3 1 3 0 2 9 2 8 2 7 2 6 2 5 2 4 2 3 2 2 2 1 2 0 1 9 1 8 1 7 1 6 1 5 1 4 1 3 1 2 1 1 1 0 9876543210Byte 0 Byte 1 Byte 2 Byte 3
Data Types 272
Record Variables
You declare records in Pascal the same as in standard Pascal, as shown in the
following example:
Record Initialization
To initialize a ﬁeld in a record when you declare it in the var declaration of
your program, use either of the following two formats:
•Specify the record ﬁeld name followed by an assignment operator andinitial value.
•List the initial value without the ﬁeld name.  In this case, Pascal assigns theinitial value to the next ﬁeld name in the record deﬁnition.type
MonthType = (Jan, Feb, Mar, Apr, May, Jun, Jul,Aug, Sep, Oct, Nov, Dec);DateType = record
Month : MonthType;Day : 1..31;Year : 1900..2000;
end;
Appointment = record
Date : DateType;Hour : 0..2400;
end;
 [a := FALSE ,
 b := TRUE ]
[  FALSE  ,
TRUE   ]
28 Pascal Language Reference2
You can also initialize record variables in the var declaration of a procedure or
function; however, when you do so, you must also declare the variable asstatic .
Initializing Record Variables (Screen 1 of 2)The Pascal program,
init_rec.p .  This example
shows a record initialization byname, by position, and by nameand position.program init_rec(output);
{ This program initializes a record. }type
    enumerated_type = (red, green, blue, orange, white);    record_type =      record          c: char;          st: set of char;          z: array [1..10] of char;          case colors: enumerated_type of              red: ( b: boolean;                     s: single );              green: ( i16: integer16;                       d: double )      end;var    { Initialization by name. }    rec1: record_type :=      [st := ['a', 'b', 'c'],      c := 'A',      z := 'ARRAY1',      colors := green,      i16 := 32767];
Data Types 292
Initializing Record Variables (Screen 2 of 2)    { Initialization by position. }
    rec2: record_type :=      ['X',      ['x', 'y', 'z'],      'ARRAY2',      red,      true];    { Initialization by name and position. }    rec3: record_type :=      [colors := red,      true,      1.16,      st := ['m', 'n', 'o'],      'ARRAY3'];
begin
    writeln('char       ', rec1.c);    writeln('char array ', rec1.z);    writeln('integer    ', rec1.i16);    writeln;    writeln('char       ', rec2.c);    writeln('char array ', rec2.z);    writeln('boolean    ', rec2.b);    writeln;    writeln('char array ', rec3.z);    writeln('boolean    ', rec3.b);    writeln('single     ', rec3.s)end. { record_example }
30 Pascal Language Reference2
Data Representation of Unpacked Records
This section describes the data representations of unpacked ﬁxed and variant
records.
Fixed Records
Pascal allocates ﬁelds in a ﬁxed record so that they assume the naturalalignment of the ﬁeld type.  The alignment of a record is equal to the alignmentof the largest element.  The size of the record is a multiple of the alignment.
Variant Records
The space Pascal allocates for a variant record is the same with or without the–xl option.
Data Representation of Packed Records
Table 2-8, Table 2-9, and Table 2-10 show how Pascal aligns ﬁelds in a packed
record.
Note – In packed records, bit-aligned ﬁelds do not cross word boundaries.The commands to compile and
execute init_rec.phostname%pc init_rec.p
hostname%a.out
char       Achar array ARRAY1integer         32767
char       X
char array ARRAY2boolean    true
char array ARRAY3
boolean    truesingle      1.160000e+00
Data Types 312
Packed Record Storage Without the -xl Option
Table 2-8 Packed Record Storage Without –xl
Data Type Size Alignment
integer 4 bytes 4 bytes
integer16 2 bytes Bit-aligned
integer32 4 bytes 4 bytes
real 8 bytes 8 bytes
single 4 bytes 4 bytes
shortreal 4 bytes 4 bytes
double 8 bytes 8 bytes
longreal 8 bytes 8 bytes
boolean 1 bit Bit-aligned
char 1 byte 1 byte
enumerated Number of bits required to
represent the highest ordinal valueBit-aligned
subrange of char 1 byte 1 byte
all other subrange Number of bits required to
represent the highest ordinal valueBit-aligned
set of cardinality <= 32 One bit per element Bit-aligned
set of cardinality > 32 Same as if unpacked 4 bytesarray Requires the same space required
by the base type of the arraySame as element type
32 Pascal Language Reference2
Packed Record Storage with the -xl Option
Table 2-9 Packed Record Storage with –xl
Packed Record Storage with the -calign  Option
Table 2-10 Packed Record Storage with -calign
The following example declares a packed record. Table 2-11 shows the
alignment and sizes of the ﬁelds of the record. Figure 2-11 shows therepresentation of this record.Data Type Size Alignment
real 4 bytes 4 bytes
integer 2 bytes Bit-aligned
Data Type Size Alignment
integer16 2 bytes 2 bytes
type
small = 0..128;medium = 0..255;large = 0..65535;colors = (green, blue, orange, white, black, magenta, gray);sets = (autumn, summer, winter, fall);vrec1 = packed record
a: integer16;b: boolean;e: colors;sm: small;med: medium;lg: large;se: sets;x: integer32;
end;
Data Types 332
Table 2-11 Sample Sizes and Alignment of Packed Record
Figure 2-11 Sample Packed Record (Without -xl )Field Size (Bits) Alignment
a 16 16 bit-aligned
b 1 Bit-aligned
e 3 Bit-aligned
sm 8 Bit-aligned
med 16 Bit-aligned
lg (without -xl) 32 32 bit-aligned
lg ( with-xl) 16 16 bit-aligned
se 4 Bit-aligned
x 32 32 bit-aligned
1 5 1 4 1 3 1 2 1 1 1 0 9876543210a
be s m
med
lgmed
lg se
x
x
34 Pascal Language Reference2
Array
Pascal supports the standard array  data type.  As extensions to the standard,
Pascal supplies the predeclared character array types alfa ,string , and
varying  and permits you to initialize an array variable when you declare it in
the variable declaration.
Array Variables
In addition to the standard array data types, this compiler supports the threedata types in Table 2-12, which include a variable-length string.
Table 2-12 Array Data Types
You can assign a variable-length string a string of any length, up to the
maximum length you specify in the declaration.  Pascal ignores any charactersyou specify over the maximum.  It does not pad the unassigned elements withspaces if you specify a string under the maximum.  When you output avariable-length string with write  orwriteln , the procedure writes only the
characters included in the string’s current length.
You also can assign a variable-length string to a ﬁxed-length string.  If the
variable-length string is shorter than the ﬁxed-length string, the ﬁxed-lengthstring is padded with blanks.  If the variable-length string is longer than theﬁxed-length string, the string is truncated.Type Description
alfa An array of char 10 characters long.
string An array of char 80 characters long.
varying A string of variable length.  You declare a varying string as follows:
varying [upper_bound ]of char ;upper_bound  is an integer
between 0 and 65,535
Data Types 352
The following program demonstrates the differences between the ﬁxed-length
andvarying  data types:
The Pascal program, varying.p program varying_example(output);
{ This program demonstrates the differences
  between fixed- and variable-length strings. }
var
name1: array [1..25] of char;    { String of size 25. }name2: array [76..100] of char;  { String of size 25. }name3: alfa;                     { String of size 10. }name4: string;                   { String of size 80. }name5: varying [25] of char;     { Varying string. }name6: varying [25] of char;     { Varying string. }
begin
name1 := 'van Gogh';name2 := 'Monet';name3 := 'Rembrandt';name4 := 'Breughel';name5 := 'Matisse';name6 := 'Cezanne';writeln(name1, ' and ', name2, '.');writeln(name3, ' and ', name4, '.');writeln(name5, ' and ', name6, '.')
end. { varying_example }
The commands to compile and
execute varying.phostname% pc varying.p
hostname% a.outvan Gogh                  and Monet                    .Rembrandt  andBreughel                                                                        .Matisse and Cezanne.
36 Pascal Language Reference2
Array Initialization
To initialize an array variable when you declare it in the var declaration of
your main program, use an assignment statement after the declaration.  Pascaloffers you the following four different formats:
•Supply the lower and upper bounds in the initialization.
•Put an asterisk in place of the upper bound, and let the compiler determinethe upper bound once it counts the initial values.  You can use this formatonly when you also supply the initial values.
•Use the repeat count feature nofconstant  to initialize n array elements to
the value constant .n must be an integer or an expression that evaluates to
an integer constant.This code initializes the ﬁrst ﬁve
elements of int tomaxint,
 1, -32767, 5, and 20.  The ﬁrst sixelements of c1 are assigned the
characters 1 through 6.  Because
c1 is a ﬁxed-length string, the last
four characters are padded withblanks.var
int : array[1..10] of integer := [maxint, 1 ,-327,5, 20];
c1 :  array[1..10] of char := '123456';
In this example, the compiler
assigns the upper bound of 5 to
int and of 6 toc1.var
i : integer;int : array[1..*] of integer := [maxint ,1,-32767, 5 ,20];
c1 : array[1..*] of char := '123456';
This code initializes all the ﬁrst 50
values of int2 to1 and the
second 50 values to 2.var
int2 : array[1..100] of integer := [50 of 1 ,50 of 2];
Data Types 372
•Use the repeat count feature * of constant  to initialize all remaining array
elements to the value of constant .
When you initialize an array in the var declaration, the compiler sets those
elements for which it doesn’t ﬁnd data to zero.
You can also initialize array variables in the var declaration of a procedure or
function; however, you must also declare the variable as static .
Packed Arrays
Although you can deﬁne an array as packed , it has no effect on how the
Pascal compiler allocates the array data space.
Data Representation
The elements of an array require the same space as that required by the basetype of the array.  However, there are two exceptions to this.  With the-calign  option, the size of all arrays is the size of each element times the
number of elements.  When you use the -calign  and-xl options together,
arrays are the same as with -calign  alone, except the size of an array of
boolean s is always a multiple of two.This example initializes all 100
elements of int4 to327.  The
example also initializes themultidimensional array int5 to
an array of 10 rows and columns.The compiler initializes all 10elements in the ﬁrst row to 327,
the ﬁrst three elements of thesecond row to 8, and all 10
elements of the third row to 88.var
int4 : array[1..100] of integer := [* of 327];int5 : array[1..10,1..10] of integer := [
[* of 327],[3 of 8],[10 of 88],
    ];
38 Pascal Language Reference2
Set
Pascal supports sets of elements of integer, boolean , character, and
enumerated data types.  As extensions to the standard, Pascal predeﬁnes a setofintset ; you can then initialize a set variable when you declare it in the var
declaration of your program.
Set Variables
In Pascal, you declare set variables the same as you do in standard Pascal.  Thefollowing is a valid set variable:
Pascal predeﬁnes the set intset  as the set of [0..127].
Set Initialization
To initialize a set variable when you declare it in the var declaration of your
program, create an assignment statement, as follows:type
character_set = set of char;
var
letters: character_set;
This code initializes citrus
to the set of orange,lemon,
andlime.type
fruit = (orange, lemon, lime, apple, banana);
var
citrus: set of fruit := [orange, lemon, lime];
Data Types 392
You can also initialize set variables in the var declaration of a procedure or
function; however, when you do so, you must also declare the variable asstatic :
Packed Sets
Although you can deﬁne a set as packed , it has no effect on how the compiler
allocates the set data space.
Data Representation
Pascal implements sets as bit vectors, with one bit representing each element ofa set.  The maximum ordinal value of a set element is 32,768.
The size of a set is determined by the size of the ordinal value of maximal
element of the set plus one.  Sets are allocated in multiples of 16 bits; therefore,the smallest set has size 16 bits.  The ordinal value of the minimal elementmust be equal to or greater than 0.  Sets have an alignment of four bytes whenthey are longer than 16 bits; otherwise their alignment is two bytes.  Forexample, 'set of 1..20' has a four-byte alignment and 'set of 1..15' has a two-bytealignment.
With the -calign  option, sets have an alignment of two bytes.  The size is the
same as the default.This example initializes primary
to the set of red,yellow, and
blue.  It also initializes grays to
the set of white andblack.procedure assign_colors;
type
colors = (white, beige, black, red, blue,
yellow, green);
var
primary: static set of colors := [red, yellow,
blue];
grays: static set of colors := [white, black];
40 Pascal Language Reference2
Table 2-13 shows the data representation of four sets.
Table 2-13 Data Representation of Sets
You can visualize the bit vector representation of a set as an array of bits
starting from the highest element to the lowest element.  For example, therepresentation of the following set is shown in Figure 2-12.
Figure 2-12 Small SetSet Description
set of 0..15 This set requires 16 bits because 15 is the maximal element, and
15 + 1 = 16.
set of 0..16 This set requires 32 bits because 16 is the maximal element.  16 + 1 = 17,
and the next multiple of 16 above 17 is 32.
set of 14..15 This set requires 16 bits because 15 is the element, and 15 + 1 = 16.set of char This set requires 256 bits because the range of char  is
chr(0)..chr(255) .   The ordinal value of the maximal element is 255,
and 255+1 = 256, which is divisible by 16.
var
smallset: set of 2..15 := [7,4,3,2];
1 5 1 4 1 3 1 2 1 1 1 0 98765432100000000010011100
Data Types 412
The representation of this larger set is shown in Figure 2-13.
Figure 2-13 Large Set
File
Pascal treats ﬁles declared as file of char  the same as ﬁles declared as
text , except when you use the –s –s0 ,–s1,–V0, or–V1 options.  In this case,
the compiler treats the two data types differently, as required by standardPascal.
Pointer
Pascal supports the standard Pascal pointer and the nonstandard universalpointer and procedure and function pointer.
Standard Pointer
The standard pointer is the same in Pascal and standard Pascal.var
largeset: set of 2..255 := [7,4,3,2];
3 1 3 0 2 9 2 8 2 7 2 6 2 5 2 4 2 3 2 2 2 1 2 0 1 9 1 8 1 7 1 6 1 5 1 4 1 3 1 2 1 1 1 0 98765432103 1 3 0 2 9 2 8 2 7 2 6 2 5 2 4 2 3 2 2 2 1 2 0 1 9 1 8 1 7 1 6 1 5 1 4 1 3 1 2 1 1 1 0 9876543210
00000000100111000000000000000000 0000000000000000
0000000000000000255 247 239 231 224
Loc +1Loc +0 Loc +1
42 Pascal Language Reference2
Universal Pointer
The universal pointer data type, univ_ptr , is compatible with any pointer
type.  Use univ_ptr  to compare a pointer of one type to another, to assign a
pointer of one type to another, or to weaken type checking when passingparameters of pointer types.
When the type of a formal parameter is univ_ptr , the type of the
corresponding actual parameter can be of any pointer type, or vice versa.
You cannot dereference a univ_ptr  variable: you cannot ﬁnd the contents of
the address to which univ_ptr  points.
The Pascal program,
univ_ptr.p , which prints the
value of the ﬂoating-point variabler in hexadecimal format.program univ_ptr_example;
{ This program demonstrates how to use
  universal pointers. }
var
    i: integer32;    r: single;    ip: ^ integer32;    rp: ^ single := addr(r);    up: univ_ptr;
begin
    r := 10.0;    { The next two statements are equivalent to rp := ip.      However, rp := ip is not legal since they are      different types. }    up := rp;    ip := up;    writeln(ip^ hex);    { This will do the same thing but uses transfer functions. }    writeln(integer32(r) hex)end. { univ_ptr_example }
Data Types 432
Procedure and Function Pointers
The following is an example that shows how to use procedure and function
pointers in Pascal.The commands to compile and
execute univ_ptr.phostname%pc univ_ptr.p
hostname%a.out
4120000041200000
44 Pascal Language Reference2
The Pascal program, pointer.p ,
which demonstrates how to printout enumerated values usingprocedure pointers.program pointer_example;
type
    colors = (red, white, blue);    procptr = ^ procedure; { Procedure pointer type. }
procedure printred;begin
    writeln('RED')end; { printred }
procedure printwhite;begin
    writeln('WHITE')end; { printwhite }
procedure printblue;begin
    writeln('BLUE')end; { printblue }
var
    { Array of procedure pointers. }    colorprinter: array [colors] of procptr :=              [addr(printred),              addr(printwhite),              addr(printblue)];    c: colors;    desc_proc: procptr;
begin
    write('Enter red, white, or blue:  ');    readln(c);    desc_proc := colorprinter[c];    desc_proc^end. { pointer_example }
Data Types 452
Pointer Initialization
To initialize a pointer variable when you declare it in the var declaration of
your program, use an assignment statement, as follows:
You can also initialize pointer variables in the var declaration of a procedure
or function; however, when you do so, you must also declare the variable asstatic .
Data Representation
Pascal represents a pointer as shown in Figure 2-14.
Figure 2-14 PointerThe commands to compile and
execute pointer.phostname%pc pointer.p
hostname%a.out
Enter red, white, or blue: red
RED
This example initializes the
variable rp toaddr(r) .  Legal
values for compile-timeinitializations are NIL,addr(0)
of variables, procedures, strings,and set constants, andpreviously declared constants ofthe same pointer type. var
rp : ^single := addr(r);pp : ^procedure := NIL;sp : ^string := addr('Title');
3 1 3 0 2 9 2 8 2 7 2 6 2 5 2 4 2 3 2 2 2 1 2 0 1 9 1 8 1 7 1 6 1 5 1 4 1 3 1 2 1 1 1 0 9876543210Address
46 Pascal Language Reference2
47Statements 3
This chapter describes Pascal statements in the following sections:
Standard Statements
Pascal supports all standard statements.  Pascal also supports extensions to:
Statements Speciﬁc to Pascal
Table 3-1 summarizes the nonstandard Pascal statements and standard
statements with nonstandard features.  Detailed descriptions and examples ofeach statement follow.Standard Statements page 47
Statements Speciﬁc to Pascal page 47
assert next
case otherwise
exit return
goto with
48 Pascal Language Reference3
Table 3-1 Nonstandard Pascal Statements
assert  Statement
Theassert  statement causes a boolean  expression to be evaluated each time
the statement is executed.
If your program contains an assert  statement, you must compile it with the
–C option, which enables runtime tests.  Otherwise, the compiler treats
assert  as a comment.
A runtime error results if the expression in the assert  statement evaluates to
false .
assert  is a shorthand for using the if statement.Statement Description
assert Causes a boolean  expression to be evaluated each time the
statement is executed.
case Accepts ranges of constants and an otherwise  statement.
exit Transfers program control to the ﬁrst statement after the end of a
for,while , orrepeat  loop .
goto Accepts an identiﬁer as the target of goto .
next Causes the program to skip to the next iteration of the enclosing for,
while , orrepeat  loop.
otherwise An extension to the case statement .If the expression in a case
statement does not match any of the case  values, the compiler
executes the statements under the otherwise statement.
return Prematurely ends a procedure or a function.
with An alternative format to the standard with  statement.
Statements 493
For example, the following code uses an assert  statement to test whether num
is greater than 0 and less than or equal to MAX_STUDENTS :
The following if statement is equivalent to the assert  statement in the
preceding program:assert((num > 0) and (num <= MAX_STUDENTS));
for i := 1 to num do begin
write('Enter grade for student ', i: 3, ': ');readln(grades[i])
end.
if (num > 0) and (num <= MAX_STUDENTS) then begin
for i := 1 to num do begin
write('Enter grade for student ', i: 3, ': ');readln(grades[i])
end
end else begin
writeln('Error message.');halt
end
50 Pascal Language Reference3
The Pascal program,
assert.p , which tests whether
num is greater than 0 and less
than or equal to MAX_STUDENTS
before reading in the grades.program assert_example;
const
    MAX_STUDENTS = 4;
var
    num: integer;    i: integer;    grades: array [1..MAX_STUDENTS] of char;
begin
    num := 6;    assert((num > 0) and (num <= MAX_STUDENTS));    for i := 1 to num do begin        write('Enter grade for student ', i: 3, ':  ');        readln(grades[i])    endend. { assert_example }
The commands to compile and
execute assert.p  without the
–C option.  The compiler treats
assert as a comment.hostname%pc assert.p
hostname%a.out
Enter grade for student   1: A
Enter grade for student   2: B
Enter grade for student   3: C
Enter grade for student   4: D
Enter grade for student   5: F
Enter grade for student   6: A
Statements 513
case  Statement
Pascal supports the standard case  statement with extensions for an
otherwise  clause and ranges of constants.
Ifexpression  does not match any of the case values,  the compiler executes the
otherwise statement list. The reserved word otherwise  is not a case label,
so it is not followed by a colon ( :).  Also, the begin/end  pair is optional in an
otherwise  statement.
You can use a range of constants instead of a single case  value.  A case  range
must be in ascending order.
Thecase  statement operates differently when you compile your program with
and without the –xl option.  Without –xl, if the value of the expression is not
equal to one of the case  labels and you omit the otherwise  statement, the
program generates an error and halts.
If this situation occurs and you compile your program with –xl, the program
falls through and does not generate an error; program execution continueswith the statement immediately following the case  statement.The result when you compile
assert.p  with the –C and–g
option.  The expression evaluatestofalse, so the compiler
generates an error and halts.hostname%pc -C assert.p
hostname%a.out
Assertion #1 failed
Trace/BPT trap (core dumped)
hostname%pc -C -g assert.p
hostname%a.out
Assertion #1 failed
Trace/BPT trap (core dumped)
52 Pascal Language Reference3
exit  Statement
Theexit  statement, which you can use in a for,while , orrepeat  loop,
transfers program control to the ﬁrst statement after the end of the currentloop.
If used in a nested loop, exit  only breaks out of the innermost loop.
You receive a compile-time error if you use this statement anywhere but in a
for,while , orrepeat  loop.The Pascal program,
otherwise.p , which  reads a
character from the terminal.  If thevalue of the character is not in therange 0 - 9, the compiler executesthe statement in the otherwise
statement.  The program speciﬁesall digits between 0 and 9 as therange'0'..'9' .program otherwise_example(input, output);
{ This program demonstrates the otherwise
  clause and ranges in the case statement. }
var
    ch: char;
begin
    write('Please enter one character:  ');
{More than one character will produce erroneous results.}
    readln(ch);    case ch of      '0'..'9':        writeln('The character you input is a digit.'); otherwise             writeln('The character you input is not a digit.')    endend. { otherwise_example }
The commands to compile and
execute otherwise.p without
–xl
.This example shows your
output when you input thecharacters 3 andB.hostname%pc otherwise.p
hostname%a.out
Please enter one character: 3
The character you input is a digit.hostname%a.out
Please enter one character: B
The character you input is not a digit.
Statements 533
The Pascal program, exit.p program exit_example(input, output);
{ This program demonstrates the use of the
  exit statement in for, while, and repeat loops. }
const
    MAX = 10;
type
    integer_type = array [1..MAX] of integer16;
var
    i: integer16;    i_array: integer_type := [1, 99, 13, 45, 69, 18, 32, -6];    number: integer16;    flag: boolean := false;
begin
    write('Enter a number:  ');    readln(number);    for i := 1 to MAX do begin      if number = i_array[i] then begin          flag := true;          exit      end    end;    if flag then      writeln('Number WAS found:  ', number)    else      writeln('Number WAS NOT found:  ', number)end. { exit_example }
The commands to compile and
execute exit.p.  This example
shows the program output whenyou input the number 13.hostname%pc exit.p
hostname%a.out
Enter a number: 13
Number WAS found:          13
54 Pascal Language Reference3
goto  Statement
Pascal supports the standard format of the goto  statement with two
extensions.
In Pascal, you can use an identiﬁer as the target of a goto .  Standard Pascal
allows only integers as targets of goto s.
If you use a goto  to jump out of the current block, Pascal closes all open ﬁles
in the intervening blocks between the goto  statement and the target of the
goto .
Statements 553
Identiﬁers as Targets (Screen 1 of 2)The Pascal program, goto.p,
which uses an identiﬁer as atarget of a goto statement.program goto_example;
{ This program uses an identifier as a target
  of a goto statement. }
label
    skip_subtotal;
const
    MAX_STUDENTS = 100;
var
    i: integer;    grades: array [1..MAX_STUDENTS] of char;    num: 1..MAX_STUDENTS;    sum: real;    points: real;
begin
    { Read in number of students and their grades. }    write('Enter number of students:  ');    readln(num);    assert((num > 0) and (num < MAX_STUDENTS));    for i := 1 to num do begin      write('Enter grade for student ', i: 3, ': ');      readln(grades[i])    end;    writeln; { Now calculate the average GPA for all students. }    sum := 0;    for i := 1 to num do begin      if grades[i] = 'I' then begin          goto skip_subtotal      end else begin          case grades[i] of              'A': points := 4.0;              'B': points := 3.0;              'C': points := 2.0;              'D': points := 1.0;              'F': points := 0.0;
56 Pascal Language Reference3
Identiﬁers as Targets (Screen 2 of 2)
next  Statement
Thenext  statement, which you can only use in a for,while , orrepeat  loop,
causes the program to skip to the next iteration of the current loop, thusskipping the rest of the statements in the loop.
Thenext  statement has the same effect as a goto  to the end of the loop.  If
you use next  in afor loop, Pascal increments the index variable as normal.
When you use next  in a nested loop, it goes to the end of the innermost loop
containing the next  statement.
You receive a compile-time error if you use this statement anywhere but in a
for,while , orrepeat  loop.otherwise
              writeln('Unknown grade:  ', grades[i]);              points := 0.0         end      end;      sum := sum + points;      skip_subtotal:    end;    writeln('GPA for all students is ', sum / num: 6: 2, '.')end. { goto_example }
You must compile goto.p with
the–C option to execute the
assert statement; otherwise,
the compiler treats assert as a
comment.  This example returnsthe collective GPA of fourstudents.hostname%pc -C goto.p
hostname%a.out
Enter number of students: 4
Enter grade for student   1: B
Enter grade for student   2: B
Enter grade for student   3: C
Enter grade for student   4: A
GPA for all students is   3.00.
Statements 573
Thenext  Statement (Screen 1 of 2)The Pascal program, next.p,
which also uses the otherwise
statement.program next_example;
{ This program demonstrates the use of the next
  statement in for, while, and repeat loops. }
const
    MAX_STUDENTS = 100;
var
    i: integer;    grades: array [1..MAX_STUDENTS] of char;    num: 1..MAX_STUDENTS;    sum: real;    points: real;
begin
    { Read in number of students and their grades. }    write('Enter number of students:  ');    readln(num);    assert((num > 0) and (num <= MAX_STUDENTS));    for i := 1 to num do begin      write('Enter grade for student ', i: 3, ':  ');      readln(grades[i])    end;    writeln;
58 Pascal Language Reference3
Thenext  Statement (Screen 2 of 2)
otherwise  Statement
Theotherwise  statement is a Pascal extension to the standard Pascal case
statement.  If speciﬁed, otherwise  must be at the end of the case  statement.
See the listing in “case Statement” on page 51 for additional information.    { Now calculate the average GPA for all students. }
    sum := 0;    for i := 1 to num do begin      if grades[i] = 'I' then begin          next      end else begin          case grades[i] of              'A': points := 4.0;              'B': points := 3.0;              'C': points := 2.0;              'D': points := 1.0;              'F': points := 0.0;              otherwise                  writeln('Unknown grade:  ', grades[i]);                points := 0.0
end
      end;      sum := sum + points    end;     writeln('GPA for all students is:  ', sum / num: 6: 2)end. { next_example }
You must compile next.p with
the–C option to execute the
assert statement; otherwise,
the compiler treats assert as a
comment.  This example outputsthe collective GPA of threestudents.hostname%pc -C next.p
hostname%a.out
Enter number of students: 3
Enter grade for student   1: A
Enter grade for student   2: A
Enter grade for student   3: C
GPA for all students is:    3.33
Statements 593
return  Statement
Thereturn  statement prematurely ends a procedure or a function.
Program control transfers to the calling routine.  This has the same effect as a
goto  to the end of the routine.  If used in the main program, return  causes
the program to terminate.
The Pascal program, return.p .
The compiler prematurelyreturns from the procedure test
if you input 1 or any integer from4 through 99.  The program alsouses identiﬁers as the target of agoto.program return_example;
{ This program demonstrates the use of the
  return statement in a procedure. }
var
    i: integer;
procedure test;
label    error_negative_value, error_bad_values, error_value_too_big;begin    if i < 0 then      goto error_negative_value    else if (i = 2) or (i = 3) then      goto error_bad_values    else if i > 100 then      goto error_value_too_big;    return;error_negative_value:    writeln('Value of i must be greater than 0.');    return;error_bad_values:    writeln('Illegal value of i:  2 or 3.');    return;error_value_too_big:    writeln('Value of i too large.');    returnend; { test }
begin { main procedure }
    write('Enter value for i:  ');    readln(i);    testend. { return_example }
60 Pascal Language Reference3
with  Statement
Pascal supports the standard with  statement plus an alternative format.
The following is an example that illustrates how to use a with  statement in
Pascal.The commands to compile and
execute return.phostname%pc return.p
hostname%a.out
Enter value for i: -1
Value of i must be greater than 0.hostname%a.out
Enter value for i: 2
Illegal value of i:  2 or 3.hostname%a.out
Enter value for i: 101
Value of i too large.hostname%a.out
Enter value for i: 5
Statements 613
The Pascal program, with.p,
which uses the alternate form ofthewith statement.program with_example(output);
{ Sample program using the extension to the
  with statement. }
const
    MAX = 12;
type
    name_type = varying [MAX] of char;    Patient =      record          LastName: name_type;          FirstName: name_type;          Sex: (Male, Female)      end;
var
    new_patient: Patient;    old_patient: Patient;
begin
    with new_patient: new, old_patient: old do begin      new.LastName := 'Smith';      new.FirstName := 'Abby';      new.Sex := Female;
      old.LastName := 'Brown';
      old.FirstName := 'Henry';      old.Sex := Male    end;    write('The new patient is ');    write(new_patient.FirstName: 10);    writeln(new_patient.LastName: 10, '.');    write('The old patient is ');    write(old_patient.FirstName: 10);    writeln(old_patient.LastName: 10, '.')end. { with_example }
62 Pascal Language Reference3
The commands to compile and
execute with.phostname%pc with.p
hostname%a.out
The new patient is       Abby     Smith.The old patient is      Henry     Brown.
63Assignments and Operators 4
This chapter describes the different types of  assignments and operators in
Pascal.  It contains the following sections:
Data Type Assignments and Compatibility
Table 4-1 lists the assignment compatibility rules for real ,integer ,
boolean , character, enumerated, subrange, record, set, and pointer data types.Data Type Assignments and Compatibility page 63
String Assignments page 64Operators page 66Precedence of Operators page 76
64 Pascal Language Reference4
Table 4-1 Data Type Assignment
† Pascal implicitly converts the integer to the real  type, if necessary.
String Assignments
Pascal has special rules for assigning ﬁxed- and variable-length strings, null
strings, and string constants.
Fixed- and Variable-Length Strings
When you make an assignment to a ﬁxed-length string, and the source string isshorter than the destination string, the compiler pads the destination stringwith blanks.  If the source string is larger than the destination string, thecompiler truncates the source string to ﬁt the destination.
When you make an assignment to a variable-length string, and the source
string is longer than the destination string, the compiler truncates the source toﬁt the destination.
The valid ﬁxed- and variable-length string assignments are given in Table 4-2.Type of Variable/Parameter Type of Assignment-Compatible Expression
real ,single ,shortreal real ,single ,shortreal ,double ,longreal ,
any integer type†
double ,longreal real ,single ,shortreal ,double ,longreal ,
any integer type
integer ,integer16,integer32 integer ,integer16,integer32
boolean booleanchar charenumerated Same enumerated typesubrange Base type of the subrangerecord Record of the same typearray Array with the same typeset Set with compatible base typepointer Pointer to an identical type, univ_ptr
Assignments and Operators 654
Table 4-2 Fixed- and Variable-Length String Assignments
Null Strings
Pascal treats null strings as constant strings of length zero. Table 4-3 shows the
null string assignments.
Table 4-3 Null String Assignments
String Constants
When assigning a constant string to a packed array of char , standard
Pascal requires that the strings be the same size.
Pascal allows the constant string and packed array of char  to be unequal
in size, truncating the constant string if it is longer or padding it with blanks ifit is shorter.Type of String Type of Assignment-Compatible Expression
array of char varying  string, constant string, and array of char   if the
arrays have the same length
varying varying  string, constant string, array of char , andchar
Assignment Description
varying := ''; The compiler assigns the null string to the variable-
length string.  The length of the variable-length stringequals zero.
array of char := ''; The compiler assigns a string of blanks to the character
array.  The length of the resulting string is the numberof elements in the source character array.
char := ''; It is illegal to assign a null string to a char   variable.
Usechr(0)  instead.
String concatenation In a string concatenation expression such as:
S := 'hello' + '' + S;
'' is treated as the additive identity (as nothing).
66 Pascal Language Reference4
Operators
Pascal supplies six classes of operators:
•Arithmetic operators
•Bit operators
•boolean  operators
•Set operators
•Relational operators
•String operators
Arithmetic Operators
The arithmetic operators are summarized in Table 4-4.
Table 4-4 Arithmetic Operators
Themod Operator
Pascal extends the standard deﬁnition of the mod operator as follows.
In the expression i mod j,  when i is positive, Pascal and standard Pascal
produce the same results.  However, when i is negative, and you do not
compile your program with a standard option ( –s,–s0,–s1,–V0, or–V1), the
following is true :
i mod j
equals:
-1 * remainder of |i| divided by |j|Operator Operation Operands Result
+ addition integer  orreal integer  orreal
- subtraction integer  orreal integer  orreal
* multiplication integer  orreal integer  orreal
/ division integer  orreal real
div truncated division integer integer
mod modulo integer integer
Assignments and Operators 674
The Pascal program, mod.p,
which computes i mod jprogram modexample(output);
{ This program demonstrates the nonstandard
  mod function. }
var
    i: integer;    j: integer;
begin
    for i := -3 to -1 do      for j := 1 to 3 do          if j <> 0 then              writeln(i: 4, j: 4, i mod j: 4)end. { mod_example }
The commands to compile and
execute mod.p without any
optionshostname%pc mod.p
hostname%a.out
  -3   1   0  -3   2  -1  -3   3   0  -2   1   0  -2   2   0  -2   3  -2  -1   1   0  -1   2  -1  -1   3  -1
68 Pascal Language Reference4
Bit Operators
Table 4-5 shows the bit operators.  The ~ operator produces the same results as
the built-in Pascal function, lnot .  Similarly, & is equivalent to the function,
land ;| and! are equivalent to lor.  See Chapter 7, “Input and Output,” for
descriptions of these functions and the truth tables that both the functions andthe operators use.
Table 4-5 Bit Operators
boolean  Operators
The boolean operators, which include the nonstandard and then  andor else
operators, are summarized in Table 4-6.The results negative i produces
when you compile mod.p with
the–s optionhostname%pc -s mod.p
hostname%a.out
  -3   1   0  -3   2   1  -3   3   0  -2   1   0  -2   2   0  -2   3   1  -1   1   0  -1   2   1  -1   3   2
Operator Operation Operands Result
~  bitwise not integer integer&  bitwise and integer integer|  bitwise or integer integer! bitwise or  (same as |)integer integer
Assignments and Operators 694
Table 4-6 boolean  Operators
Theand then Operator
Theand then  operator differs from the standard and operator in that it
guarantees the order in which the compiler evaluates the logical expression.Left to right and the right operands are evaluated only when necessary.  Forexample, when you write the following syntax, the compiler may evaluateodd(y)  before it evaluates odd(x) :
odd(x) and odd(y)
However, when you use the following syntax, the compiler always evaluates
odd(x)  ﬁrst:
odd(x) and then odd(y)
Ifodd(x)  isfalse ,odd(y)  is not evaluated.
Note – You cannot insert comments between the and and the then  operators.Operator Operation Operands Result
and Conjunction boolean boolean
and then Similar to boolean and boolean boolean
not Negation boolean boolean
or Disjunction boolean boolean
or else Similar to boolean or boolean boolean
70 Pascal Language Reference4
Theor else Operator
Theor else  operator is similar to the and then  operator.  In the following
expression, the compiler evaluates odd(x)  ﬁrst, and if the result is true , does
not evaluate odd(y ):
odd(x) or else odd(y)
Note – You cannot insert comments between the or and the else  operators.The Pascal program,
and_then.p,  which  uses
and then  to test if two numbers
are oddprogram and_then(input, output);
{ This program demonstrates the use
  of the operator and then. }
var
    x, y: integer16;
begin
    write('Please enter two integers:  ');    readln(x, y);    if odd(x) and then odd(y) then      writeln('Both numbers are odd.')    else      writeln('Both numbers are not odd.');end. { and_then }
The commands to compile and
execute and_then.p .  This
example shows the output whenyou input the numbers 45 and6.hostname%pc and_then.p
hostname%a.out
Please enter two integers: 45 6
Both numbers are not odd.
Assignments and Operators 714
Set Operators
The set operators in Table 4-7 accept different set types as long as the base
types are compatible.  The relational operators can also be used to compareset-type values.
Table 4-7 Set OperatorsThe Pascal program,
or_else.p , which  uses
or else to test if two numbers
are less than 10.program or_else(input, output);
{ This program demonstrates the use
  of the operator or else. }
var
    x, y: integer16;
begin
    write('Please enter two integers:  ');    readln(x, y);    if (x < 10) or else (y < 10) then      writeln('At least one number is less than 10.')    else      writeln('Both numbers are greater than or equal to 10.');end. { or_else }
The commands to compile and
execute or_else.p .  This
example shows the output whenyou input the numbers 101 and3.hostname%pc or_else.p
hostname%a.out
Please enter two integers: 101 3
At least one number is less than 10.
Operator Operation Operands Result
+ Set union Any set type Same as operands
- Set difference Any set type Same as operands
* Set intersection Any set type Same as operands
in Member of a speciﬁed set 2nd arg:any set type
1st arg:base type of 2nd argboolean
72 Pascal Language Reference4
Relational Operators
The relational operators are given in Table 4-8.  In Pascal, you can apply all
relational operators to sets and the equality ( =) and inequality (<>) operators
on records and arrays.
Table 4-8 Relational Operators
Relational Operators on Sets
Use the relational operators to compare sets of identical types.  The result is a
boolean  (true  orfalse ) value.Operator Operation Operand Results
= Equal Any real, integer ,
boolean, char , record,
array, set, or pointer typeboolean
<> Not equal Any real ,integer ,
boolean ,char , record,
array, set, or pointer typeboolean
< Less than Any real ,integer ,
boolean ,char , string,
or set typeboolean
<= Less than or equal Any real ,integer ,
boolean ,char , string,
or set typeboolean
> Greater than Any real ,integer ,
boolean ,char , string,
or set typeboolean
>= Greater than or equal Any real ,integer ,
boolean ,char , string,
or set typeboolean
Assignments and Operators 734
The=and<> Operators on Records and Arrays
Use the = and<> operators to compare character arrays of the same size.  For
example:
•You can compare a varying[10]  string with an alfa  string.
•You cannot compare an alfa  string with an array[1..15] .
In making comparisons, between arrays and records, make sure the operands
are of the same type.The Pascal program, sets.p,
which applies the < and>
operators to two sets of colors.The< operator tests if a set is a
subset of another set.  The >
operator tests if a set is a propersubset of another set.program set_example(output);
{ This program demonstrates the use of relational
  operators on sets. }
var
    set1, set2: set of (red, orange, yellow, green);
begin
    set1 := [orange, yellow];    set2 := [red, orange, yellow];    writeln(set1 > set2);    writeln(set1 < set2)end. { set_example }
The commands to compile and
execute sets.phostname%pc sets.p
hostname%a.out
falsetrue
74 Pascal Language Reference4
Comparing Records (Screen 1 of 2)The Pascal program,
compare.p , which makes
comparisons among recordsprogram record_example(output);
const
    MAX = 10;
type
    Shape = (Square, Trapezoid, Rectangle);    variant_record =      record          case Shape_type: Shape of              Square: ( side1: real );              Trapezoid: ( top1: real;                           bottom: real;                           height: real );              Rectangle: ( length: real;                           width: real )      end;
    normal_record =
      record          name: array [1..MAX] of char;          avg: integer;          grade: char      end;
var
    class1: normal_record := ['Susan', 100];    class2: normal_record := ['John', 99];    shapes1: variant_record;    shapes2: variant_record;
Assignments and Operators 754
Comparing Records (Screen 2 of 2)
String Operators
With the string concatenation operator, the plus sign ( +), you can concatenate
any combination of varying, array of char,  constant strings, and single
characters. begin
    { Should PASS. }    if class1 <> class2 then      writeln('PASSED')    else      writeln('FAIL');
    shapes1.Shape_type := Rectangle;
    shapes2.Shape_type := Square;    { Should PASS }    if shapes1 = shapes2 then
 writeln('FAIL')
    else      writeln('PASSED');
    shapes1.Shape_type := Trapezoid;
    shapes2.Shape_type := Trapezoid;
    { Should PASS. }
    if shapes1 = shapes2 then      writeln('PASSED')    else      writeln('FAIL')end. { record_example }
The commands to compile and
execute compare.phostname%pc compare.p
hostname%a.out
PASSEDPASSEDPASSED
76 Pascal Language Reference4
Precedence of Operators
Table 4-9 lists the order of precedence of Pascal operators, from the highest to
the lowest.
Table 4-9 Precedence of OperatorsThe Pascal program,
concate.p , which concatenates
four types of stringsprogram string_example(output);
{ This program demonstrates the use of
  the string concatenation operator. }
var
    col: varying [10] of char := 'yellow';    fish: array [1..4] of char := 'tail';    n1: char := 'o';    n2: char := 'r';
begin
    write(fish + n1 + n2 + 'bird ', col + 'bird ');    writeln(col + fish)end. { string_example }
The commands to compile and
execute concate.phostname%pc concate.p
hostname%a.out
tailorbird yellowbird yellowtail
Operators Precedence
~,not, Highest
*,/,div,mod,and,&,   .
|,!,+,-,or,  .
=,<>,<,<=,>,>=,in,  .
or else ,and then Lowest
77Program Declarations 5
This chapter describes Pascal program declarations.  It contains the following
sections:
Declarations
This section describes the label, constant, type, variable, and deﬁnedeclarations.  Procedure and function declarations are described in Chapter 6,“Built-In Procedures and Functions.”
Label Declaration
Thelabel  declaration deﬁnes labels, which are used as the target of goto
statements.
Comments
In Pascal, you can use both identiﬁers and integers as labels.  Using identiﬁersas labels makes your code easier to read.Declarations page 77
Procedure and Function Headings page 84
78 Pascal Language Reference5
Example
The Pascal program, label.p program return_example;
{ This program demonstrates the use of the
  label declaration. }
var
    i: integer;
procedure test;
label    error_negative_value ,error_bad_values ,error_value_too_big;
begin    if i < 0 then      goto error_negative_value    else if (i = 2) or (i = 3) then      goto error_bad_values    else if i > 100 then      goto error_value_too_big;    return;error_negative_value:    writeln('Value of i must be greater than 0.');    return;error_bad_values:    writeln('Illegal value of i:  2 or 3.');    return;error_value_too_big:    writeln('Value of i too large.');    returnend; { test }
begin { main procedure }
    write('Enter value for i:  ');    readln(i);    testend. { return_example }
Program Declarations 795
Constant Declaration
The constant declaration deﬁnes constants, values that do not change during
program execution.
The value of expression  can be a compile-time evaluable expression.  It can
contain any of the following:
•Areal ,integer ,boolean ,character ,set, orstring  value.
•The pointer constant nil.
•Another previously deﬁned constant.
•Predeﬁned Pascal routines (see Chapter 7, “Input and Output”) called with
constant expression arguments, if applicable.
•An operator (see Chapter 4, “Assignments and Operators”).
Example
Type Declaration
The type declaration describes and names types used in variable, parameter,and function declarations.The commands to compile and
execute label.phostname%pc label.p
hostname%a.out
Enter value for i: 101
Value of i too large.
This constant declaration
deﬁnes six valid constants.const
x = 75;y = 85;month = 'November';lie = false;result = (x + y) / 2.0;answer = succ(sqrt(5+4));
80 Pascal Language Reference5
Unlike standard Pascal, in Pascal, you can deﬁne universal pointer types and
procedure and function pointer types in the type  declaration.
Example
Variable Declaration
The variable declaration declares variables.
In the variable declaration, you can specify the variable scope, attributes, and
initial values.  In most cases, you do not have a variable declaration that hasboth a variable scope and a variable attribute, because these are different waysfor doing similar things.
Scope
The scope of a variable is either private  orpublic .
•Aprivate  variable is visible in the current compilation unit only.
•Apublic  variable is visible across multiple programs and modules.
You can also use the define/extern  declaration to declare a variable as
public , and the static  attribute to declare a variable as private .  See
Appendix A, “Overview of Pascal Extensions,” for information ondefine/extern .Thistypedeclarationdeﬁnes
opaque_pointers  as a
universal pointer and routines
as a function pointer.type
lowints = 0..100;primary_colors = (red, yellow, blue);opaque_pointers = univ_ptr;routines = function(i: integer): boolean;capital_letters = set of 'A'..'Z';digits = set of lowints;char_array = array[1..10] of char;record_type = record
name: char_array;age : integer;
end;
Program Declarations 815
Variables in the var declaration section of a program default to public  when
you compile your program without the –xl option.  When you compile your
program with –xl, variables default to private .
Attributes
The variable attributes determine how to allocate the variable and its scope.
They include static ,extern , anddefine .
static
Astatic  variable is a variable that is private  in scope and which is
allocated statically.  A global variable declared as static  is equivalent to a
variable that has been declared private .  Pascal generates a compile-time
error if you attempt to declare a global variable as both static  andpublic .
When you declare a local variable as static , the variable retains its value
after the program exits the procedure in which it is declared.  You can onlyinitialize a local variable, that is, a variable declared in a procedure, in the var
declaration if you also declare it as static .This code declares both public
andprivate  variables.public var
total: single := 100.00;quantity: integer16 := 25;
private var
score: integer16 := 99;
82 Pascal Language Reference5
extern
Theextern  attribute is used to declare a variable that is not allocated in the
current module or program unit, but is a reference to a variable allocated inanother unit.  You cannot initialize extern  variables.  See the Pascal 4.2 User’s
Guide , which describes separately compiled programs and modules; it also
contains examples of the extern  attribute.The Pascal program, static.p program static_example;
{ This program demonstrates the use of the
  static variable attribute. }
var
    i: integer;
procedure count;var
    number_of_times_called: static integer := 0;
begin
    number_of_times_called := number_of_times_called + 1;   writeln('Call number: ', number_of_times_called)end; { count }
begin { main program }
    for i := 1 to 4 do begin      count    endend. { static_example }
The commands to compile and
execute static.phostname%pc static.p
hostname%a.out
Call number: 1Call number: 2Call number: 3Call number: 4
Program Declarations 835
define
Thedefine  attribute is used to declare a variable that is allocated in the
current module and whose scope is public .define  is especially useful for
declaring variables with the –xl option, which makes global variables
private  by default.  See the Pascal 4.2 User’s Guide  for an example of this
attribute.
Initialization
You can initialize real ,integer ,boolean , character, set, record, array, and
pointer variables in the var declaration.  You cannot initialize a local variable
(a variable in the var declaration of a procedure or function) unless you
declare it as static .
Deﬁne Declaration
The deﬁne declaration controls the allocation of variables.This example shows how to
initialize a variable in the var
declaration .var
x: array[1..5, 1..3] of real := [[* of 0.0] ,[* of 0.0]];
year, zeta: integer := 0;sunny: boolean := false;c1: char := 'g';citrus: set of fruit := [orange, lemon, lime];name: array[1..11] of char := 'Rembrandt';
This code correctly declares the
variables x,y,windy , and
grade in procedure
miscellaneous as static.procedure miscellaneous;
var
x: static integer16 := maxint;y: static single := 3.9;windy: static boolean := true;grade: static char := 'C';
84 Pascal Language Reference5
Comments
The value of identiﬁer  must correspond to either a variable or procedure or
function identiﬁer.  If identiﬁer  corresponds to a variable, it must have a
matching variable declaration with the extern  attribute.  The define
declaration nulliﬁes the meaning of extern : it allocates the variable in the
current program or module unit.
Ifidentiﬁer  corresponds to a procedure or a function, it nulliﬁes a previous
extern  procedure/function declaration; this means that you must deﬁne the
procedure/function thereafter.
You can initialize variables, but not procedures and functions, in the define
declaration.  Identiﬁers in the define  declaration are always public .
Example
See the chapter on separate compilation in the Pascal 4.2 User’s Guide  for
examples of the define  declaration.
Procedure and Function Headings
This section discusses the visibility, parameters, the type identiﬁer, functions,
and options for procedure and function headings.
Visibility
You can declare a procedure or function at the outer block level as eitherpublic  orprivate .
When a procedure or function is public , you can reference that routine in
another program or module unit.  Declaring a routine as private  restricts its
accessibility to the current compilation unit.
You can also use the define/extern  declaration to declare a procedure or
function as public , and the internal  routine option to declare a routine as
private .  For more information on the define/extern  declaration, see
Appendix A, “Overview of Pascal Extensions.”
Program Declarations 855
Top-level procedures and functions declared in a program default to public
when you compile your program without the –xl option.  When you compile
your program with –xl, all top-level routines declared in the program become
private .
Nested procedures and functions are always private ; it is illegal to declare a
nested routine as public .
Procedures and functions declared within a module unit are always public .
For additional information on modules, see the Pascal 4.2 User’s Guide .
Parameter List
Pascal supplies the parameter types in,out,in out, var ,value , anduniv .
Parameters : in ,out, andin out
Thein,out, andin out  parameters are extensions to the standard, which are
used to specify the direction of parameter passing:This code fragment declares
bothpublic andprivate
functions and procedures.public procedure average(s,t: single);
private procedure evaluate(n : integer);public function big (quart : integer16;
    cost : single) : single;
private function simple (x, y : boolean) : integer16;
86 Pascal Language Reference5
in Indicates that the parameter can only pass a value into the routine.  The
parameter is, in effect, a read-only variable.  You cannot assign a value toanin parameter, nor can you pass an in parameter as an argument to
another procedure that expects a var,out, orin out  argument.
out Indicates that the parameter is used to pass values out of the routine.  In
effect, declaring a parameter as out informs the compiler that the
parameter has no initial value, and that assignments to the parameter areretained by the caller.
in out Indicates that the parameter can both take in values and pass them  back
out.  An in out  parameter is equivalent to a var parameter.
Program Declarations 875
Example
The Pascal program,
in_out.p .The procedure
compute_area reads in the
length andwidth and outputs
result.  The procedure
multiply_by_two reads in
result, multiplies it by two and
returns the modiﬁed value.program in_out_example(input, output);
{ This program, which finds the area of a rectangle,
  demonstrates the use of the in, out, and in out  parameters. }
var
    length, width, result: real;
{ Find area given length and width. }
procedure compute_area(in length: real; in width: real;                       out result: real);
begin
    result := length * widthend; { compute_area } { compute_area }
{ Multiply the area by two. }
procedure multiply_by_two(in out result: real);
begin
    result := result * 2end; { multiply_by_two } { multiply_by_two }
begin { main program }
    write('Enter values for length and width:  ');    readln(length, width);    compute_area(length, width, result);    writeln('The area is ', result: 5: 2, '.');    multiply_by_two(result);    writeln('Twice the area is ', result: 5: 2, '.')end. { in_out_example }
88 Pascal Language Reference5
var Parameters
With standard conformance options ( -s,-V0,-V1),var parameters are the
same in standard Pascal and Pascal. By default, the Apollo-like var
compatibility approach applies: actual and formal records and arrays shouldbe of the same type; other types of var must be of the same length.
For example, all pointer types are compatible to univ_ptr , and vice versa.
See “Universal Pointer” on page 42.  Subranges -128...127  and0...127  are
alsovar-compatible.
Value Parameters
Value parameters are the same in standard Pascal and Pascal.
univ  Parameters
The nonstandard univ  parameter type is actually a modiﬁer used before data
types in formal parameter lists to turn off type checking for that parameter.You can use it with any type of parameter except conformant array, procedure,or function parameters.
univ  is used as follows:
You could then call this procedure with a parameter of any type.  You should
always declare a univ  parameter as either in,out,in out , orvar.The commands to compile and
execute in_out.p .  This
example shows the programoutput when you input a lengthof4 and a width of 5.hostname%pc in_out.p
hostname%a.out
Enter values for length and width: 4 5
The area is 20.00.Twice the area is 40.00.
procedure somename  (var ﬁrstparam : univ integer);
Program Declarations 895
univ  is most often used for passing arrays, where you can call a procedure or
function with different array sizes.  In that case, you generally would passanother parameter that gives the actual size of the array, as follows:
Type Identiﬁer
In Pascal, a function may represent a structure, such as a set, array, or record.In standard Pascal, a function can only represent the simple types of value,ordinal, or real .
Functions Returning Structured-Type Results
If a Pascal function returns the result of a structured type, for example, an
array, a record, a string, or some combination of these, you can construct orupdate the result, component-by-component, using assignments of the form:
F S1 ... SN := E
where:
•F is the function name
•S1, ..., SN  are appropriate component selectors
•E is the result component valuetype
real_array = array[1..100] of real;
procedure receive(size: integer;
var theArray: univ real_array);
var
n: integer;
begin
 for n:= 1 to size do
...
90 Pascal Language Reference5
Standard Pascal allows assignments to the whole function result variable only,
that is, F:= E , which may not be feasible or efﬁcient enough, since you may
have to declare and initialize extra structured-type variables.
Example 1: A Function That Returns Strings
When declaring functions that return strings (arrays of chars) and varyingstrings, you can specify the result by an assignment.  For example:
F:= 'The answer: 12 miles'
where F is the function.  However, sometimes you may want to obtain the
string result by modifying some of the characters of an existing string (variableor parameter).  In the following example, you may want to substitute a stringfor the string XX.
In general, an identiﬁer of a function f returning a string can be used in an
assignment of the kind:
f[i]:=c
for specifying the i'th byte of the function result.  This Pascal extension can beused both for strings and varying strings.program String_Function_Example;
type s1 = array [1..20] of char;    s2 = array [1..2 ] of char;
function f(x:s2):s1;
begin  f := 'The answer: XX miles';  f[13]:=x[1];  f[14]:=x[2];end;
var r: s2;
    s: s1;begin   r:='12';   s:=f(r);
   writeln(s)
end.
Program Declarations 915
Example 2: A Function that Returns Arrays of Records
(Complex Vector Addition)
Options
Pascal supplies the standard forward  routine option and the nonstandard
options, extern ,external ,internal ,variable , andnonpascal .
forward
Theforward  option is the same in Pascal and standard Pascal.program complex_vectors;
type
complex = record re, im: real end;compl_vect = array [1..10] of complex;
function add (var a, b: compl_vect): compl_vect;
var i: integer;begin
for i:= 1 to 10 dobegin
add[i].re:= a[i].re + b[i].re;add[i].im:= a[i].im + b[i].im;
end;
end; { add }
var V1, V2, V3: compl_vect;
begin
...V1:= add (V2, V3);...
end. { complex_vectors }
92 Pascal Language Reference5
extern  andexternal
Theextern  andexternal  options indicate that the procedure or function is
deﬁned in a separate program or module. extern  andexternal  allow the
optional speciﬁcation of the source language of the procedure or function.  Formore information on these options, see the chapter on separate compilation inthePascal 4.2 User’s Guide .
internal
Theinternal  option makes the procedure or function local to that module.
Specifying the internal  option is the same as declaring the procedure or
function as private .  Pascal generates an error message if you attempt to
declare a public  procedure or function as internal .
variable
Using the variable  option, you can pass a procedure or function a smaller
number of actual arguments than the number of formal arguments deﬁned inthe routine.  The actual arguments must match the formal parameters types.You cannot pass a larger number of actual arguments than formal arguments.
Program Declarations 935
Example
The Pascal program,
variable.p ,passes either two
or three actual arguments to theprocedure ,calculate_total ,
depending on the user input .program variable_example(input, output);
{ This program demonstrates the use of the
  variable routine option. }
const
    tax_rate = 0.07;    shipping_fee = 2.50;
var
    price: single;    resident: char;    total: single;
function calculate(count: integer16; price: single;
                   tax: single): single;                   options(variable);
begin
    if count = 2 then      calculate := price + tax + shipping_fee    else      calculate := price + shipping_feeend; { calculate }
begin { main program }
    write('Please enter the price:  ');    readln(price);
writeln('California residents must add local sales tax.');
     write('Are you a California resident?  Enter y or n:  ');    readln(resident);    if resident = 'y' then      total := calculate(2, price, tax_rate * price)    else      total := calculate(1, price);    writeln('Your purchase amounts to $', total: 5: 2, '.')end. { variable_example }
94 Pascal Language Reference5
nonpascal
Pascal supports nonpascal  as a routine option when you compile your
program with the –xl option. nonpascal  declares non-Pascal routines when
you are porting Apollo DOMAIN  programs written in DOMAIN  Pascal,
FORTRAN , or C.
nonpascal  passes arguments by reference.  If the argument is a variable,
nonpascal  passes its address.  If the argument is a constant or expression,
nonpascal  makes a copy on the caller’s stack and passes the address of the
copy.The commands to compile and
execute variable.phostname%pc variable.p
hostname%a.out
Please enter the price: 10.00
California residents must add local sales tax.Are you a California resident? Enter y or n: y
Your purchase amounts to $13.20.hostname%a.out
Please enter the price: 10.00
California residents must add local sales tax.Are you a California resident? Enter y or n: n
Your purchase amounts to $12.50.
95Built-In Procedures and Functions 6
This chapter describes the built-in procedures and functions Pascal supports.
It starts with two major sections:
The third section, beginning on page 99, lists the nonstandard routines
alphabetically and contains detailed descriptions and examples of each routine.
Standard Procedures and Functions
Pascal supplies the standard procedures listed in Table 6-1, and the standardfunctions listed in Table 6-2.Standard Procedures and Functions page 95
Routines Speciﬁc to Pascal (Summary) page 96Routines Speciﬁc to Pascal (Details) page 99
Table 6-1 Standard Procedures
dispose page readln unpack
get put reset writenew read rewrite writelnpack
96 Pascal Language Reference6
Routines Speciﬁc to Pascal (Summary)
This section lists the nonstandard Pascal procedures and functions according to
the following categories:
•Arithmetic routines
•Bit-shift routines
•Character string routines
•Input and output routines
•Miscellaneous routines
Table 6-3 through Table 6-8 summarize these Pascal routines.Table 6-2 Standard Functions
abs eof odd round sqrt
arctan eoln ord sin succchr exp pred sqr trunccos ln
Table 6-3 Nonstandard Arithmetic Routines
Routine Description
addr Returns the address of a variable, constant, function, or procedure.
card Returns the cardinality of a set.
expo Calculates the exponent of a variable.
firstof Returns the ﬁrst possible value of a type or variable.
in_range Determines whether a value is in the deﬁned integer subrange.
lastof Returns the last possible value of a type or variable.
max Returns the larger of two expressions.
min Returns the smaller of two expressions.
random Generates a random number between 0.0 and 1.0.
seed Resets the random number generator.
sizeof Returns the size of a designated type or variable.
Built-In Procedures and Functions 976
Table 6-4 Nonstandard Bit Shift Routines
Table 6-5 Nonstandard Character String RoutinesRoutine Description
arshft Does an arithmetic right shift of an integer.
asl Does an arithmetic left shift of an integer.
asr Identical to arshft .
land Returns the bitwise and of two integers.
lnot Returns the bitwise not of an integer.
lor Returns the inclusive or of two integers.
lshft Does a logical left shift of an integer.
lsl Identical to lshft .
lsr Identical to rshft .
rshft Does a logical right shift of an integer.
xor Returns the exclusive or of two integers.
Routine Description
concat Concatenates two strings.
index Returns the position of the ﬁrst occurrence of a string or character
inside another string.
length Returns the length of a string.
stradd Adds a string to another string.
substr Extracts a substring from a string.
trim Removes all trailing blanks in a character string.
98 Pascal Language Reference6
Table 6-6 Nonstandard Input and Output Routines
Table 6-7 Extensions to Standard Input and Output RoutinesRoutine Description
append Opens a ﬁle for modiﬁcation at its end.
close Closes a ﬁle.
filesize Returns the current size of a ﬁle.
flush Writes the output buffered for a Pascal ﬁle into the associated
operating system ﬁle.
getfile Returns a pointer to the C standard I/O descriptor associated with a
Pascal ﬁle.
linelimit Terminates program execution after a speciﬁed number of lines has
been written into a text ﬁle.
message Writes the speciﬁed information on stderr .
open Associates an external ﬁle with a ﬁle variable.
remove Removes the speciﬁed ﬁle.
seek Performs random access to a ﬁle, changing its current position.
tell Returns the current position of a ﬁle.
Routine Description
read  and
readlnReads in boolean  variables, ﬁxed- and variable-length strings, and
enumerated types from the standard input.
reset and
rewriteAccepts an optional second argument, an operating system ﬁle name.
write  and
writelnOutputs enumerated type values to the standard output.
Outputs expressions in octal or hexadecimal.Allows negative ﬁeld widths.
Built-In Procedures and Functions 996
Table 6-8 Miscellaneous Nonstandard Routines
Routines Speciﬁc to Pascal (Details)
Described in this section are the detailed descriptions for each of the Pascal-
speciﬁc routines: its syntax, arguments, and return value.  Comments and anexample are also included.
addr
Theaddr  function returns the address of a variable, constant, function, or
procedure.Routine Description
argc Returns the number of arguments passed to the program.
argv Assigns the speciﬁed program arguments a string variable.
clock Returns the user time consumed by this process.
date Fetches the current date.
discard Explicitly discards the return value of a function.
getenv Returns the value associated with an environment name.
halt Terminates program execution.
null Performs no operation.
pcexit Terminates the program and returns an exit code.
stlimit Terminates program execution if a speciﬁed number of statements have
been executed in the current loop
sysclock Returns the system time consumed by this process.
time Retrieves the current time.
trace Prints a stack traceback.
Type transfer Changes the data type of a variable or expression.wallclock Returns the elapsed number of seconds since
00:00:00 GMT January 1, 1970.
100 Pascal Language Reference6
Syntax
addr (x)
Arguments
x is either a variable, a constant string, a function, or a procedure.
Return Value
The return value of addr  is the address in which the variable or a constant
string is stored.  For function or procedural arguments, addr  returns the
starting address of the function or procedure.  In each case, addr  returns a
value of type univ_ptr .
Comments
In Pascal, you can apply addr  to a variable, function, or procedure with
dynamic extent such as local variables and nested functions or procedures.Exercise caution in doing so and then dereferencing the resulting pointer value.In the case of local variables, dereferencing these pointers outside the scope inwhich the variable is active results in a meaningless value.
The compiler passes a static link to nested functions and procedures when it
calls them.  The compiler does not generate this link when dereferencingpointer values to procedures or functions.  Consequently, Pascal generates awarning if the argument to addr  is any of these objects.
addr  cannot be applied to bit-aligned ﬁelds of aggregates.
Note – If you use the addr ( )  function, do not use the –H option.  The –H
option makes sure that all pointers used point into the heap.
Built-In Procedures and Functions 1016
Example
The Pascal program, addr.p program addr_example(output);
{ This program demonstrates the use of the
  addr function. }
const
    name = 'Gail';
type
    ptr = ^ integer;    ptr_char = ^ alfa;
var
    ptr_address: ptr;    ptr_address_char: ptr_char;    x: integer;    y: integer;    c: alfa;
begin
    x := maxint;
    { Get the address of x. }
    ptr_address := addr(x);
    { Get the contents of ptr_address. }
    y := ptr_address^;    writeln('The address of x is  ', ptr_address: 3, '.');    writeln('The contents of x is ', y: 3, '.');
    { Get the address of the constant name. }
    ptr_address_char := addr(name);
    { Get the contents of ptr_address_char. }
    c := ptr_address_char^;
    writeln('The address of c is  ', ptr_address_char: 3, '.');
    writeln('The contents of c is ', c: 4, '.')end. { addr_example }
102 Pascal Language Reference6
append
Theappend  function allows a ﬁle to be modiﬁed, and sets the current position
to the end of the ﬁle.
Syntax
append (ﬁle,ﬁlename )
Arguments
ﬁle is a variable with the text  orfile  data type.
ﬁlename , which is optional, is a string of ﬁxed or variable length, or a string
constant.
Return Value
append  does not return any values.
Comments
For example, this code associates the Pascal ﬁle data with the operating system
ﬁle,existent :
append(data, 'existent');
If you do not pass an optional second argument, Pascal creates a new
temporary ﬁle, which is deleted when the program is terminated.
See also the sections: “reset,” “rewrite,” and “close.”The commands to compile and
execute addr.phostname%pc addr.p
hostname%a.out
The address of x is 38764.The contents of x is 2147483647.The address of c is 33060.The contents of c is Gail.
Built-In Procedures and Functions 1036
Example
The example that follows shows how to use append .
104 Pascal Language Reference6
The Pascal program, files.p program files_example(input, output);
const  MaxLength = 80;var  f: text;  line: varying [MaxLength] of char;begin  rewrite(f, 'poem.txt');  writeln('Enter a lines of text and hit Control+D to end thejob.');  while not eof do begin    readln(line);    writeln(f, line);  end;  close(f);  writeln;  writeln('There are the lines of text you input:');  reset(f, 'poem.txt');  while not eof(f) do begin    readln(f, line);    writeln(line);  end;  close(f);
  reset(input); { Because Control+D close input }
  append(f, 'poem.txt');  writeln('Append a lines of text and hit Control+D to end thejob.');  while not eof do begin    readln(line);    writeln(f, line);  end;  close(f);  writeln;  writeln('There are the lines of all text you input:');  reset(f, 'poem.txt');  while not eof(f) do begin    readln(f, line);    writeln(line);  end;  close(f);end.
Built-In Procedures and Functions 1056
argc
Theargc  function returns the number of arguments passed to the program.
Syntax
argc
Arguments
argc  does not take any arguments.
Return Value
argc  returns an integer value.
Comments
The return value of argc  is always at least 1, the name of the program.
argc  is normally used in conjunction with the built-in procedure, argv .   See
theargv  listing on page 105.
Example
See the example in the argv  listing page 105.
argv
Theargv  procedure assigns the speciﬁed program argument to a string
variable.
Syntax
argv (i, a)
106 Pascal Language Reference6
Arguments
i is an integer value.
a is a ﬁxed- or variable-length string.
Return Value
argv  returns a string variable.
Comments
argv  returns the i'th argument of the current process to the string variable a.  i
ranges from 0, the program name, to argc -1.
argc  is a predeclared function that tells you how many arguments are being
passed to the program. argv  is normally used in conjunction with argc .
Built-In Procedures and Functions 1076
Example
arshft
Thearshft  function does an arithmetic right shift of an integer value.
Syntax
arshft (num , sh)The Pascal program, argv.p program argv_example(output);
{ This program demonstrates the use of
  argc and argv. }
var
    i: integer32;    name: varying [30] of char;
begin
    { Argument number 0 is the name of the program. }    argv(0, name);    writeln('The name of the program is ', name, '.');    i := 1;    while i <= argc - 1 do begin      argv(i, name);      writeln('Argument number ', i: 1, ' is ', name, '.');      i := i + 1    endend. { argv_example }
The commands to output and
execute argv.phostname%pc argv.p
hostname%a.out
The name of the program is a.out.hostname%a.out one two three
The name of the program is a.out.Argument number 1 is one.Argument number 2 is two.Argument number 3 is three.
108 Pascal Language Reference6
Arguments
num  and sh are integer expressions.
Return Value
arshft  returns a 32-bit integer value.
Comments
arshft  shifts the bits in num sh  places to the right. arshft  preserves the sign
bit of num .arshft  does not wrap bits around from left to right.  The sign bit
is the most signiﬁcant (leftmost) bit in the number.  Pascal uses two'scomplement to represent negative integers.  For example, -8 as a 16-bit integeris represented as:
1111 1111 1111 1000
If you shift this number to the right by 1:
(arshft (-8, 1) )
your result is:
1111 1111 1111 1100
The result arshft  returns is machine-dependent, and is unspeciﬁed unless the
following is true :
0< = sh <= 32
Built-In Procedures and Functions 1096
Example
asl
Theasl function does an arithmetic left shift of an integer value.The Pascal program, arshft.p program arshft_example(input, output);
{ This program demonstrates the arithmetic right shift. }const
    SIZE = 8;
var
    i: integer32;    i32: integer32;    loop: integer32;
begin
    write('Enter a positive or negative integer:  ');    readln(i);    for loop := 1 to SIZE do begin      i32 := arshft(i, loop);      write('Arithmetic right shift ', loop: 2);      writeln(' bit(s):  ', i32 hex)    endend. { arshft_example }
The commands to compile and
execute arshft.p .  The value
the bit-shift routines return maydepend upon the architecture ofyour system.hostname%pc arshft.p
hostname%a.out
Enter a positive or negative integer: -2
Arithmetic right shift 1 bit(s): FFFFFFFFArithmetic right shift 2 bit(s): FFFFFFFFArithmetic right shift 3 bit(s): FFFFFFFFArithmetic right shift 4 bit(s): FFFFFFFFArithmetic right shift 5 bit(s): FFFFFFFFArithmetic right shift 6 bit(s): FFFFFFFFArithmetic right shift 7 bit(s): FFFFFFFFArithmetic right shift 8 bit(s): FFFFFFFF
110 Pascal Language Reference6
Syntax
asl(num ,sh)
Arguments
num  and sh are integer expressions.
Return Value
asl returns a 32-bit integer value.
Comments
asl shifts the bits in num sh  places to the left. asl preserves the sign bit of
num  and does not wrap bits from left to right.
The result asl returns is machine-dependent and is unspeciﬁed unless the
following is true :
0 <= sh <= 32
Built-In Procedures and Functions 1116
Example
asr
Theasr function is identical to the arshft  function.  See the arshft  listing.The Pascal program, asl.p program asl_example(input, output);
{ This program demonstrates the arithmetic left shift. }const
    SIZE = 8;
var
    i: integer32;    i32: integer32;    loop: integer32;
begin
    write('Enter a positive or negative integer:  ');    readln(i);    for loop := 1 to SIZE do begin      i32 := asl(i, loop);      write('Arithmetic left shift ', loop: 2);      writeln(' bit(s):  ', i32 hex)    endend. { asl_example }
The commands to compile and
execute asl.phostname%pc asl.p
hostname%a.out
Enter a positive or negative integer: 19
Arithmetic left shift 1 bit(s): 26Arithmetic left shift 2 bit(s): 4CArithmetic left shift 3 bit(s): 98Arithmetic left shift 4 bit(s): 130Arithmetic left shift 5 bit(s): 260Arithmetic left shift 6 bit(s): 4C0Arithmetic left shift 7 bit(s): 980Arithmetic left shift 8 bit(s): 1300
112 Pascal Language Reference6
card
Thecard  function returns the number of elements in a set variable.
Syntax
card (x)
Arguments
x must be a set variable.
Return Value
card  returns an integer value.
Comments
card  returns the number of elements in the actual set variable, not the size of
the set type.
Built-In Procedures and Functions 1136
Example
clock
Theclock  function returns the user time consumed by the process.The Pascal program, card.p program card_example(output);
{ This program demonstrates the use of the card function. }
type    lowints = 0..100;    primary_colors = set of (red, yellow, blue);    possibilities = set of boolean;    capital_letters = set of 'A'..'Z';    digits = set of lowints;
var
    pri: primary_colors;    pos: possibilities;    cap: capital_letters;    dig: digits;
begin
    pri := [red, yellow, blue];    pos := [true, false];    cap := ['A'..'Z'];    dig := [0..100];
writeln('There are ',card(pri): 4, ' primary colors.');writeln('There are ',card(pos): 4, ' possibilities.');writeln('There are ',card(cap): 4, ' capital letters.');writeln('There are ',card(dig): 4, ' digits.')
end. { card_example }
The commands to output and
execute card.phostname%pc card.p
hostname%a.out
There are     3 primary colors.There are     2 possibilities.There are    26 capital letters.There are   101 digits.
114 Pascal Language Reference6
Syntax
clock
Arguments
clock  does not take any arguments.
Return Value
clock  returns an integer value.
Comments
clock  returns the user time in milliseconds.
See also the sysclock  function, which returns the system time the process
uses.
Built-In Procedures and Functions 1156
Example
clock.p  Program (Screen 1 of 2)The Pascal program, clock.p program clock_example(input, output);
{ This program times how long it takes to run the
  towers of hanoi. }
const
    DISK = 16;
var
    num: array [1..3] of integer;    counts: integer32;    before_user: integer;    before_sys: integer;    after_user: integer;    after_sys: integer;
procedure moves(number, f, t: integer);var
    o: integer;
begin
    if number = 1 then begin      num[f] := num[f] - 1;      num[t] := num[t] - 1;      counts := counts + 1    end else begin      o := 6 - (f + t);      moves(number - 1, f, o);      moves(1, f, t);      moves(number - 1, o, t)    endend; { moves } { moves }
116 Pascal Language Reference6
clock.p  Program (Screen 2 of 2)
close
Theclose  procedure closes a ﬁle.
Syntax
close (ﬁle)
Arguments
ﬁle is a ﬁle having the text  orfile  data type.
Return Value
close  does not return any values.begin { main program }
    before_user := clock;    before_sys := sysclock;    moves(DISK, 1, 3);    after_sys := sysclock;    after_user := clock;    write('For ', DISK: 1, ' disks, there were ');    writeln(counts: 1, ' steps.');    write('Elapsed system time:  ');    writeln(after_sys - before_sys: 1, ' milliseconds.');    write('Elapsed user time:  ');    writeln(after_user - before_user: 1, ' milliseconds.')end. { clock_example }
The commands to compile and
execute clock.p .  The time
clock andsysclock  return is
system-dependent.hostname%a.out
For 16 disks, there were 65535 steps.Elapsed system time: 16 milliseconds.Elapsed user time: 583 milliseconds.
Built-In Procedures and Functions 1176
Comments
close  closes the open ﬁle named ﬁle.close  is optional; Pascal closes all ﬁles
either when the program terminates or when it leaves the procedure in whichthe ﬁle variable is associated with the open ﬁle.
Pascal generates a runtime error if ﬁle is not an open ﬁle.  You can trap this
error with the I/O error recovery mechanism, described in “I/O ErrorRecovery” on page 214.
In Pascal, you cannot close the predeclared ﬁles input  andoutput .  If you
redirect input  oroutput , the associated streams are automatically closed.
See also the open ,reset , andrewrite  procedures, which open a ﬁle.
Example
See the example in the open  listing in this chapter.
concat
Theconcat  function returns the concatenation of two strings.
Syntax
concat (str1,str2)
Arguments
str1 is a variable-length string, a character array, or a character-string constant.
str2 is a variable-length string, a character array, or a character-string constant.
Return Value
concat  returns a variable-length string.
118 Pascal Language Reference6
Comments
concat  returns a concatenation of str1 and str2.  You can concatenate any
combination of varying, array of char , constant strings, and single characters.
The string plus ( +) operator returns the same result as the concat function.
If the resulting string is longer than the maximum length of the destination
varying string, it is truncated to this maximum length.  If the resulting string islonger than 65,535 characters, it is truncated to this length.
See also the section: “stradd.”
Example
date
Thedate  procedure takes the current date (as assigned when the operating
system was initialized) and assigns it to a string variable.
Syntax
date (a)The Pascal program, concat.p program concat_example(output);
var  color: varying [10] of char := ' Black';
begin
  writeln(concat(color, 'bird' + '.'));end.
The commands to compile and
execute concat.phostname%pc concat.p
hostname%a.out
 Blackbird.
Built-In Procedures and Functions 1196
Arguments
a is a variable that can be either a character array that is 8 elements long for the
"C" locale, or a variable-length string.
Return Value
date  returns a character string in the form traditional for a given locale.  For
the"C" locale, the form is mm-dd-yy , where dd is the day, mm is the month,
andyy is the year.
Comments
date  puts a zero in front of the day and the year, so that they always consist of
two digits.
Use the environment variable LC_TIME  to set the necessary locale.
See also the section: “time.”
Example
The Pascal program, date.p program date_example(output);
var
  s1: alfa;  s2: array[1..8] of char;  s3: array[89..96] of char;  s4: varying[100] of char;
begin
  date(s1);  date(s2);  date(s3);  date(s4);  writeln('The date is ', s1, '.');  writeln('The date is ', s2, '.');  writeln('The date is ', s3, '.');  writeln('The date is ', s4, '.');end.
120 Pascal Language Reference6
discard
Thediscard  procedure removes the value of an expression.
Syntax
discard (expr)
Arguments
expr is any expression including a function call.
Return Value
discard  does not return any values.The commands to compile and
execute date.phostname%pc date.p
hostname%a.out
The date is 12/19/94.The date is 12/19/94.The date is 12/19/94.The date is 12/19/94.hostname% setenv LC_TIME ruhostname% a.outThe date is 19.12.94.The date is 19.12.94.The date is 19.12.94.The date is 19.12.94.hostname% setenv LC_TIME Chostname% a.outThe date is 12/19/94.The date is 12/19/94.The date is 12/19/94.The date is 12/19/94.
Built-In Procedures and Functions 1216
Comments
Usediscard  to call a function or evaluate an expression whose value you do
not need to continue program execution.  For example, you can use discard
to execute a function whose return value you do not need.
122 Pascal Language Reference6
Example
The Pascal program,
discard.pprogram discard_example(output);
{ This program computes a discount if the total amount
  is over DISC_AMOUNT. }
const
    RATE = 0.15;    DISC_AMOUNT = 100.00;
var
    amount: single;    discount: single;
function compute(amount: single): single;begin
    compute := amount * RATEend; { compute }
begin { main program }
    write('Enter sale amount:  ');    readln(amount);    if amount < DISC_AMOUNT then begin      discard(compute(amount));      write('No discount applied; total charge amount');
writeln(' must be more than ', DISC_AMOUNT: 2: 2, '.')
    end else begin      discount := compute(amount);      write('The amount of discount on ');      writeln(amount: 2: 2, ' is ', discount: 2: 2, '.')    endend. { discard_example }
The commands to compile and
execute discard.phostname%pc discard.p
hostname%a.out
Enter sale amount: 125.00
The amount of discount on 125.00 is 18.75.
Built-In Procedures and Functions 1236
expo
Theexpo  function calculates the integer-valued exponent of a speciﬁed
number.
Syntax
expo (x)
Arguments
x is either a real  or integer value.
Return Value
expo  returns an integer value.
Comments
expo  returns an integer that represents the integer-valued exponent of a real
number.
124 Pascal Language Reference6
Example
filesize
Thefilesize  function returns the size of a given ﬁle. The Pascal program, expo.p program expo_example(output);
{ This program demonstrates the expo function. }const
    MAX = 10;
var
    i: integer;    r: real;
begin
    writeln(' x   r := exp(x)              expo(r)');    writeln(' -   -----------              -------');    for i := 1 to MAX do begin      r := exp(i);      writeln(i: 2, '  ', r, '  ', expo(r))    endend. { expo_example }
The value expo returns may
depend upon the architecture ofyour system.hostname%pc expo.p
hostname%a.out
 x  r := exp(x) expo(r) -  ------------------ 1  2.71828182845905e+00     0 2  7.38905609893065e+00     0 3  2.00855369231877e+01     1 4  5.45981500331442e+01     1 5  1.48413159102577e+02     2 6  4.03428793492735e+02     2 7  1.09663315842846e+03     3 8  2.98095798704173e+03     3 9  8.10308392757538e+03     310  2.20264657948067e+04     4
Built-In Procedures and Functions 1256
Syntax
filesize (ﬁle)
Arguments
ﬁle is a variable with the text  orfile  data type.
Return Value
filesize  returns an integer value.
Comments
The argument can be either a text ﬁle of text  type, or a binary ﬁle of a certain
file of T  type.  It must be associated with an open ﬁle, otherwise an error
occurs.
For a text ﬁle, filesize  returns the number of bytes in the ﬁle.
For a binary ﬁle of type file of T ,filesize  returns the number of
elements of type T in the ﬁle.
See also the sections, “seek,” and “tell.”
126 Pascal Language Reference6
Example
firstof
Thefirstof  function returns the value of the lower bound when its
argument is or has an ordinal type.  For array types, firstof  returns the
lower bound for the subrange deﬁning the array index.  For set types, itreturns the lower bound of the set base type.
Syntax
firstof (x)The Pascal program,
filesize.pprogram filesize_example;
var  ft: text;  fi: file of integer;  i:  integer;begin  rewrite(ft);  rewrite(fi);  i := 10;  write(ft, i, i);  write(fi, i, i);  writeln('size of a text of an integer =', filesize(ft):3, ' bytes');  writeln('size of a file of an integer =', filesize(fi):3, ' elements');  close(ft);  close(fi)end. { filesize_example }
The commands to compile and
execute filesize.phostname%pc filesize.p
hostname%a.out
size of a text of an integer = 20 bytessize of a file of an integer =  2 elements
Built-In Procedures and Functions 1276
Arguments
x is either a variable, a constant, an expression, or the name of a user-deﬁned
or predeclared Pascal data type. x cannot be a record, a ﬁle, a pointer type, a
conformant array, a procedure or function parameter, or a string literal.
Return Value
The return value depends on the type that x is.
Comments
Pascal follows the rules in Table 6-9 when returning the value of x.When x is ... The value firstof  returns ...
An ordinal type, a constant,
an expression, or variableHas the same data type as its argument.
An array Has the same data type as the type of the array index.
A set type Has the same data type as the base type of the set.
128 Pascal Language Reference6
Table 6-9 firstof  Return Values
Example
See the examples that follow.Type of Argument Return Value
integer  (without –xl option) -2,147,483,648
integer  (with –xl option) -32,768
integer16 -32,768
integer32 -2,147,483,648
char chr(0)boolean falseEnumerated The ﬁrst element in the enumeration type declaration.
array The lower bound of the subrange that deﬁnes the
array size.
varying 1set of'A'..'Z ' A (the character A).
Built-In Procedures and Functions 1296
The Pascal program,
firstof.pprogram firstof_example(output);
{  This program illustrates the use of firstof and lastof
   used with arrays and enumerated types. }
const
    dollars_per_tourist = 100;
type
     continents = (North_America, South_America, Asia, Europe,     Africa, Australia, Antarctica);
var
    i: continents;    major_targets: array [continents] of integer :=    [20, 3, 15, 25, 5, 1, 0];    planned_targets: array [continents] of integer := [* of 0];
begin
    for i := firstof(planned_targets) to    lastof(planned_targets) do begin      planned_targets[i] := major_targets[i] * dollars_per_tourist    end;
    for i := firstof(continents) to lastof(continents) do begin
        writeln(i, ' is the goal of ', planned_targets[i]: 1,                ' dollars per tourist.')    end
end. { firstof_example }
The commands to compile and
execute firstof.phostname%pc firstof.p
hostname%a.out
North_America is the goal of 2000 dollars per tourist.South_America is the goal of 300 dollars per tourist.Asia is the goal of 1500 dollars per tourist.Europe is the goal of 2500 dollars per tourist.Africa is the goal of 500 dollars per tourist.Australia is the goal of 100 dollars per tourist.Antarctica is the goal of 0 dollars per tourist.
130 Pascal Language Reference6
flush
Theflush  procedure writes the output buffer for the speciﬁed Pascal ﬁle into
the associated ﬁle.
Syntax
flush (ﬁle)
Arguments
ﬁle is a ﬁle having the text  orfile  data type.
Return Value
flush  does not return any values.
Comments
Theflush  procedure causes the compiler to write all characters buffered for
output to the speciﬁed ﬁle.
For example, in the following code fragment, the compiler writes the output
integer i to the ﬁle f when it encounters flush :
flush  does not append a newline character after writing the data.  See also the
output procedures, message ,write , andwriteln .for i := 1 to 5 do begin
write(f,i);Compute a lot with no output
 end;flush(f);
Built-In Procedures and Functions 1316
Example
flush.p  (Screen 1 of 2)The Pascal program, flush.p program flush_example(output);
{ This program demonstrates the use of the
  flush procedure. }
const
    NAME = 'flush.txt';var    i: integer;    f1, f2: text;
procedure read_file;
var    i: integer;begin    reset(f2, NAME);    writeln('Beginning of file.');    while not eof(f2) do begin      while not eoln(f2) do begin          read(f2, i);          writeln(i)      end;      readln(f2)    end;    writeln('End of file.');    writelnend; { read_file }
132 Pascal Language Reference6
flush.p  (Screen 2 of 2)
getenv
Thegetenv  function returns the value associated with an environment name.begin { main program }
    rewrite(f1, NAME);    for i := 1 to 10 do      write(f1, i);
    { At this point the file is still empty. }
    read_file;
    flush(f1);    { Now the file contains data after the flush. }
    read_fileend. { flush_example }
The commands to compile and
execute flush.phostname%pc flush.p
hostname%a.out
Beginning of file.End of file.
Beginning of file.
 1 2 3 4 5 6 7 8 910
End of file.
Built-In Procedures and Functions 1336
Syntax
getenv (string ,string_variable )
Arguments
string  is either a constant string, a variable-length string, or a character array .
string_variable  is a variable-length string or a character array.
Return Value
getenv  returns a variable-length string or a character array.
Comments
The variable string  is an environment name.  Pascal returns the value for the
environment name through the parameter, string_variable .
string  must match the environment exactly, and trailing blanks are signiﬁcant.
Ifstring  is a character array, you may want to use the trim  function.
If there are no environment names with the value string , the value of
string_variable  is the null string if string_variable  is a variable-length string.  If
string_variable  is a character array, it is padded with blanks.
See the Solaris documentation for a complete description of environment
variables.
134 Pascal Language Reference6
Example
getfile
Thegetfile  function returns a pointer to the C standard I/O descriptor
associated with a Pascal ﬁle.
Syntax
getfile (ﬁle)
Arguments
ﬁle is a ﬁle having the text  orfile  data type. ﬁle must be associated with an
open ﬁle; otherwise, getfile  returns nil.The Pascal program, getenv.p program getenv_example;
{ This program demonstrates the use of the
  getenv function. }
var
    namev: varying [10] of char := 'EDITOR';    names: array [1..10] of char := 'EDITOR';    valv: varying [20] of char;
begin
    getenv(namev, valv);    writeln(namev, ' = ', valv);    getenv(trim(names), valv);    writeln(names, ' = ', valv)end. { getenv_example }
The commands to compile and
execute getenv.phostname%pc getenv.p
hostname%a.out
EDITOR = /usr/ucb/viEDITOR = /usr/ucb/vi
Built-In Procedures and Functions 1356
Return Value
getfile  returns a value of type univ_ptr .
Comments
You can use the result of getfile  for ﬁles opened with either the reset ,
rewrite , oropen  procedures, placing the return value as a parameter to a C
I/O routine.  Use extreme caution when you call getfile ; directly calling C
I/O routines circumvents bookkeeping data structures in the Pascal I/Olibrary.
As a general rule, calling C routines for writing is safe.  Using the return value
for calling C routines for reading may cause subsequent eoln ,eof, orreadln
calls to produce errors for that ﬁle.
Example
The Pascal program,
getfile.pprogram getfile_example;
{ This program demonstrates the use of the getfile function. }type
    char_array = array [1..30] of char;
var
    f: text;    cfile: univ_ptr;
procedure fprintf(cf: univ_ptr; in format: char_array;
                  in year: integer); external c;
begin { main program }
    rewrite(f, 'output.data');    cfile := getfile(f);    fprintf(cfile, 'Hello, world, in the year %d .', 1996)end. { getfile_example }
136 Pascal Language Reference6
halt
Thehalt  procedure terminates program execution.
Syntax
halt
Arguments
halt  does not take any arguments.
Return Values
halt  does not return any values.
Comments
You can use halt  anywhere in a program to terminate execution.  When
execution of a program encounters a halt , it prints the following message:
Call to procedure halt
Pascal returns to command level after it executes halt .The commands to compile and
execute getfile.phostname%pc getfile.p
hostname%a.out
hostname%more output.data
Hello, world, in the year 1996 .
Built-In Procedures and Functions 1376
Example
The Pascal program, halt.p program halt_example(input, output);
{ This program calculates a factorial. }var
    x, y: integer;
function factorial(n: integer): integer;begin
    if n = 0 then      factorial := 1    else      factorial := n * factorial(n - 1)end; { factorial } { factorial }
begin { main program }
    write('Enter a positive integer from 0 to 16:  ');    readln(x);    if (x >= 0) and (x <= 16) then begin      y := factorial(x);      write('The factorial of ', x: 1);      writeln(' is ', y: 1, '.')    end else begin      writeln('Illegal input.');      halt    endend. { halt_example }
The commands to compile and
execute halt.phostname%pc halt.p
hostname%a.out
Enter a positive integer from 0 to 16: 8
The factorial of 8 is 40320.hostname%a.out
Enter a positive integer from 0 to 16: 20
Illegal input.Call to procedure halt
138 Pascal Language Reference6
in_range
Thein_range  function checks if a value is in the deﬁned subrange.
Syntax
in_range (x)
Arguments
x is an integer, boolean , character, enumerated, or subrange data type.
Return Value
in_range  returns a boolean  value.
Comments
in_range  returns true  ifx is in the deﬁned range, false  ifx is outside the
range.
in_range  is useful for doing a runtime check to see if x has a valid value.
in_range  is especially helpful for checking enumerated and subrange types.
However, this feature does not work for 32-bit integer values.
If you compile your program with the –C option, the compiler also generates
code that does range checking.  However, if the variable is out of range, theprogram terminates.  By using in_range  instead, you can control subsequent
execution of your program.
Built-In Procedures and Functions 1396
Example
index
Theindex  function returns the position of the ﬁrst occurrence of a string or
character within another string.
Syntax
index (target_string ,pattern_string )The Pascal program,
in_range.pprogram in_range_example(input, output);
{ This program demonstrates the use of the in_range function .}
type
    positive = 1..maxint;
var
    base, height: positive;    area: real;
begin
    write('Enter values for triangle base and height:  ');   readln(base, height);    if in_range(base) and in_range(height) then begin      area := base * height / 2;      writeln('Area is ', area: 5: 2, '.')   end else      writeln('Cannot compute negative areas.')end. { in_range_example }
The commands to compile and
execute in_range.phostname%pc in_range.p
hostname%a.out
Enter values for triangle base and height: 4 5
Area is 10.00.
140 Pascal Language Reference6
Arguments
target_string  is a constant string, variable-length string, or an array of character.
pattern_string  is a constant string, variable-length string, an array of character,
or a character.
Return Value
index  returns an integer value that represents the position of the ﬁrst
occurrence of pattern_string  within target_string .  If the ﬁrst occurrence is at the
starting position of the original string, the returned index  value is 1.
Comments
The leftmost occurrence of the pattern-string  is considered the ﬁrst occurrence.
If the pattern_string  is not found in the target_string ,index  returns 0.  If
pattern_string  is the null string, index  returns –1.
Example
See the example that follows.
Built-In Procedures and Functions 1416
The Pascal program, index.p program index_example;
{ This program demonstrates the use of
  the index function. }
const
    MAX = 20;    STRING = 'FOO';
type
    char_array = varying [MAX] of char;
var
    s1: char_array := 'INDEX_EXAMPLE';    s2: char_array := 'EXAMPLE';    i: integer16;
procedure print(index: integer; s1: char_array;
                s2: char_array);
begin
    if index = 0 then begin      write('The string ', s2, ' is not');      writeln(' in the string ', s1, '.')    end else begin      write('The string ', s2, ' is at index ', i: 1);      writeln(' in the string ', s1, '.')    endend; { print } { print } { print }
begin { main program }
    i := index(s1, s2);    print(i, s1, s2);    i := index(s1, STRING);    print(i, s1, STRING)end. { index_example }
The commands to compile and
execute index.phostname%pc index.p
hostname%a.out
The string EXAMPLE is at index 7 in the string INDEX_EXAMPLE.The string FOO is not in the string INDEX_EXAMPLE.
142 Pascal Language Reference6
land
Theland  function returns the bitwise and of two integer values.
Syntax
land (int1, int2 )
Arguments
int1 and int2 are integer expressions.
Return Value
land  returns an integer value.
Comments
land  performs a bit-by-bit and operation, as shown in Table 6-10.
Table 6-10 land  Truth
Ifint1 and int2 are different size integers, Pascal converts the smaller integer to
the larger integer before it performs the land  operation.
land  produces the same results as the bitwise operator &.  Do not confuse
land  with the boolean  operator and, which ﬁnds the logical and of two
boolean  expressions.Value of Bit in int1 Value of Bit in int2 Value of Bit in result
00 001 010 011 1
Built-In Procedures and Functions 1436
Example
The Pascal program, land.p program land_example;
{  This program demonstrates the use of the land, lor,
   lor, and xor functions. }
procedure BinaryOutput(intval: integer32);var
    i: integer32;
begin
    write(' Decimal : ', intval, ' Binary : ');    for i := 31 downto 0 do begin      if lsr(intval, i) mod 2 = 0 then          write('0')      else          write('1')    end;    writelnend; { BinaryOutput }
var
    ival1, ival2: integer32;
begin
    ival1 := 2#00000000000000000000000000001111;    ival2 := 2#00000000000000000000000011111111;    writeln('IVAL1');    BinaryOutput(ival1);    writeln('IVAL2');    BinaryOutput(ival2);    writeln('LNOT(IVAL1)');    BinaryOutput(lnot(ival1));    writeln('LAND(IVAL1,IVAL2)');    BinaryOutput(land(ival1, ival2));    writeln('LOR(IVAL1,IVAL2)');    BinaryOutput(lor(ival1, ival2));    writeln('XOR(IVAL1,IVAL2)');    BinaryOutput(xor(ival1, ival2))end. { land_example }
144 Pascal Language Reference6
lastof
Thelastof  function returns the value of the upper bound when its argument
is or has an ordinal type.  For array types, lastof  returns the upper bound for
the subrange deﬁning the array index.  For set types, it returns the upperbound of the set base type.
Syntax
lastof (x)
Arguments
x is either a variable, a constant, an expression, or the name of a user-deﬁned
or predeclared Pascal data type. x cannot be a record, a ﬁle, a pointer type, a
conformant array, a procedure or function parameter, or a string literal.
Return Value
When x is an ordinal type, a constant, an expression, or variable, the value
lastof  returns has the same data type as its argument.
When x is an array, the value lastof  returns has the same data type as the
type of the array index.The commands to compile and
execute land.p.  The value the
bit-shift routines return maydepend upon the architecture ofyour system.hostname%pc land.p
hostname%a.out
IVAL1 Decimal : 15 Binary : 00000000000000000000000000001111IVAL2 Decimal : 255 Binary :00000000000000000000000011111111LNOT(IVAL1) Decimal : -16 Binary :11111111111111111111111111110000LAND(IVAL1,IVAL2) Decimal : 15 Binary : 00000000000000000000000000001111LOR(IVAL1,IVAL2) Decimal : 255 Binary :00000000000000000000000011111111XOR(IVAL1,IVAL2) Decimal : 240 Binary :00000000000000000000000011110000
Built-In Procedures and Functions 1456
When x is a set type, the value lastof  returns has the same data type as the
base type of the set.
Comments
Pascal follows the rules in Table 6-11 when returning the value of x.
Table 6-11 lastof  Return Values
Example
See the example under firstof  on page 126.
length
Thelength  function returns the length of a string.
Syntax
length (str)Type of Argument Return Value
integer  (without –xl) 2,147,483,647
integer  (with –xl) 32,767
integer16 32,767
integer32 2,147,483,647
char chr(255)boolean trueenumerated The last element in the enumeration type declaration.array The upper bound of the subrange that deﬁnes the array size.
varying The upper bound of the varying  string.
set of'A'..'Z' The character Z.
146 Pascal Language Reference6
Arguments
str is a variable-length string, a character array, or a character-string constant.
Return Value
length  returns an integer value.
Comments
length  returns a value that speciﬁes the length of str.
Example
The Pascal program, length.p program length_example(output);
{ This program demonstrates the use of the length function. }var
   s1: array [1..15] of char;   s2: varying [20] of char;begin   s1 := 'San Francisco ';   s2 := 'California';   writeln('The length of string one is ', length(s1): 2, '.');   writeln('The length of string two is ', length(s2): 2, '.');   writeln('The combined length is ', length(s1 + s2): 2, '.')end. { length_example }
The commands to compile and
execute length.phostname%pc length.p
hostname%a.out
The length of string one is 15.The length of string two is 10.The combined length is 25.
Built-In Procedures and Functions 1476
linelimit
Thelinelimit  procedure terminates execution of a program after a speciﬁed
number of lines has been written into a text ﬁle.
Syntax
linelimit (ﬁle,n)
Arguments
ﬁle is a ﬁle having the text  orfile  data type.
n is a positive integer expression.
Return Value
linelimit  does not return any values.
Comments
linelimit  terminates program execution if more than n lines are written to
ﬁlef.  If n is less than zero, no limit is imposed.
linelimit  has no effect unless you compile your program with the –C
option.
148 Pascal Language Reference6
Example
The Pascal program,
linelimit.pprogram linelimit_example;
{ This program demonstrates the use of the
  linelimit procedure. }
const
    FILE = 'linelimit.dat';
var
    infile: text;    error: integer32;    name: array [1..20] of char;
begin
    open(infile, FILE, 'unknown', error);    rewrite(infile, FILE);    if error = 0 then begin      writeln('Enter the names of your children.');      writeln('The last entry should be "0".');      repeat          readln(name);          writeln(infile, name);          linelimit(infile, 10)      until name = '0';      close(infile)    end else begin      writeln('Difficulty opening file.');      writeln('Error code = ', error, '.')    endend. { linelimit_example }
Built-In Procedures and Functions 1496
lnot
Thelnot  function returns the bitwise not of an integer value.
Syntax
lnot (int)
Arguments
int is an integer expression.
Return Value
lnot  returns an integer value.
Comments
lnot  performs a bit-by-bit not operation, as shown in Table 6-12.The commands to compile and
execute linelimit.phostname%pc -C linelimit.p
hostname%a.out
Enter the names of your children.The last entry should be "0".RyanMatthewJenniferLynneLisaAnnKatherineDevonGeoffreyBria
linelimit.dat : Line limit exceeded
*** a.out terminated by signal 5: SIGTRAP*** Traceback being written to a.out.traceAbort (core dumped)
150 Pascal Language Reference6
Table 6-12 lnot  Truth
lnot  produces the same results as the bitwise operator ~.  Do not confuse
lnot  with the boolean  operator not, which evaluates the logical not of a
boolean  expression.
Example
See the example under land  on page 142.
lor
Thelor function returns the inclusive or of two integer values.
Syntax
lor(int1,int2)
Argument
int1 and int2 are integer expressions.
Return Value
lor returns an integer value.
Comments
lor performs an inclusive or, as shown in Table 6-13.Value of Bit in int Value of Bit in result
0110
Built-In Procedures and Functions 1516
Table 6-13 lor Truth
Ifint1 and int2 are different size integers, Pascal converts the smaller integer to
the larger integer before it performs the lor operation.
lor produces the same results as the bitwise operators ! and|.  Do not
confuse lor with the boolean  operator or, which evaluates the logical or of
aboolean  expression.
Example
See the example under land  on page 142.
lshft
Thelshft  function does a logical left shift of an integer value.
Syntax
lshft (num , sh)
Argument
num  and sh are integer expressions.
Return Value
lshft  returns a 32-bit integer value.Value of Bit in intl1 Value of Bit in int2 Value of Bit in result
00 001 110 111 1
152 Pascal Language Reference6
Comments
lshft  shifts all bits in num sh  places to the left. lshft  does not wrap bits
from the left to right.  The value lshft  returns is machine-dependent and is
unspeciﬁed unless 0 <= sh<= 32 .
Do not confuse lshft  with the arithmetic left shift functions which preserve
the sign bit.
The Pascal program, lshft.p program lshft_example(input, output);
{ This program does a logical left shift. }const
    SIZE = 8;
var
    i: integer32;    i32: integer32;    loop: integer32;
begin
    write('Enter a positive or negative integer:  ');    readln(i);    for loop := 1 to SIZE do begin      i32 := lshft(i, loop);      write('Logical left shift ', loop: 2);      writeln(' bit(s):  ', i32 hex)    endend. { lshft_example }
Built-In Procedures and Functions 1536
lsl
Thelsl function is identical to the lshft  function.  See the lshft  listing on
page 151.
lsr
Thelsr function is identical to the rshft  function.  See the rshft  listing on
page 171.
max
Themax function evaluates two scalar expressions and returns the larger one.
Syntax
max(exp1 ,exp2 )
Arguments
exp1  and exp2  are any valid scalar expressions that are assignment-compatible.
Return Value
max returns the same or the converted type of exp1  and exp2 .The commands to compile and
execute lshft.p .  The value
the bit-shift routines return maydepend upon the architecture ofyour system.hostname%pc lshft.p
hostname%a.out
Enter a positive or negative integer: 3
Logical left shift 1 bit(s):   6Logical left shift 2 bit(s):   CLogical left shift 3 bit(s):  18Logical left shift 4 bit(s):  30Logical left shift 5 bit(s):  60Logical left shift 6 bit(s):  C0Logical left shift 7 bit(s): 180Logical left shift 8 bit(s): 300
154 Pascal Language Reference6
See also the min listing on page 156.
Example
The Pascal program, max.p program max_example(input, output);
{ This program reads in 10 positive integers
  in the range 1 through 501 and determines  the largest even and smallest odd.Out of range numbers  are rejected. }
var
   smallest_odd: integer := 501;   largest_even: integer := 0;   number, counter: integer;
begin
 writeln('Please enter 10 integers between 0 and 501:'); for counter := 1 to 10 do begin  read(number);  if (number < 0) or (number > 501)    then writeln ('The number is out of range ')    else if odd(number)      then smallest_odd := min(number, smallest_odd)      else          largest_even := max(number, largest_even)   end;   writeln('The smallest odd number is ', smallest_odd: 1, '.');   writeln('The largest even number is ', largest_even: 1, '.')end. { max_example }
Built-In Procedures and Functions 1556
message
Themessage  procedure writes the speciﬁed information on stderr  (usually
the terminal).
Syntax
message (x1,...,xN)
Arguments
x is one or more expressions separated by commas. x can be a variable,
constant, or expression of a type that write  accepts (such as integer, real ,
character, boolean , enumerated, or string). x cannot be a set variable.
Return Value
message  does not return any values.
Comments
message  is an output procedure similar to write  andwriteln .  Whereas
write  andwriteln  send the output to standard output or the speciﬁed ﬁle,
message  sends the output to standard error. message  also appends a
carriage return to the message.
message  ﬂushes all buffers both before and after writing the message.
message( x1,...,xN) is equivalent to the following code:The commands to compile and
execute max.phostname%pc max.p
hostname%a.out
Please enter 10 integers between 0 and 501:56 431 23 88 222 67 131 337 401 99The smallest odd number is 23.The largest even number is 222.
156 Pascal Language Reference6
Example
min
Themin function evaluates two scalar expressions and returns the smaller one.
Syntax
min(exp1 ,exp2 )writeln(errout, x1, ..., xN);
flush(errout);flush(output);    .    . { Flush all open files. }
The Pascal program,
message.pprogram message_example(output);
{ This program demonstrates the use of the
  message function. }
begin
    writeln('This message will go to standard output.');    message('This message will go to standard error.')end. { message_example }
The commands to compile and
execute message.phostname%pc message.p
hostname%a.out > temp_file
This message will go to standard error.hostname%cat temp_file
This message will go to standard output.hostname%a.out >& temp_file
hostname%cat temp_file
This message will go to standard output.This message will go to standard error.
Built-In Procedures and Functions 1576
Arguments
exp1  and exp2  are any valid scalar expressions that are assignment-compatible.
Return Value
min returns the same or the converted type of exp1  and exp2 .
Comments
See also the max listing on page 153.
Example
See the example under the max listing on page 153.
null
Thenull  procedure performs no operation.
Syntax
null
Arguments
null  does not take any arguments.
Return Value
null  does not return any values.
Comments
null  does absolutely nothing; it is useful as a placeholder.  For example,
suppose you are developing a program, and you are uncertain about aparticular case  statement, you could put null  in place of the case  statement,
then replace it later with an actual function or procedure.
158 Pascal Language Reference6
open
Theopen  procedure associates an external ﬁle with a ﬁle variable.
Syntax
open (ﬁle,pathname ,history ,error ,buffer )
Arguments
open  takes the following arguments:
•ﬁle is a variable having the text  orfile  data type.
•pathname  is a string constant or string variable.
•history  is a string variable.
•error  is aninteger32  variable.  This argument is optional.
•buffer  is an optional integer variable.  This argument is currently ignored.
Return Value
open  does not return any values.
Comments
open  associates the permanent ﬁle ﬁle with a ﬁle variable for reading or
writing. open  does not actually open the ﬁle; you must call reset  or
rewrite  before reading or writing to that ﬁle.
pathname  must be one of the following:
•An operating system path name.
•A string of '^n', where n is an integer from 1 to 9. n represents the nth
argument passed to the program. ^n is equivalent to argv(n, file) .
•A prompt string.  The string must begin with the character ' *'.  Pascal prints
the prompt string on the standard output at runtime.
•The string '-STDIN'  or'-STDOUT.'
•A variable or constant that contains any of the above items.
Built-In Procedures and Functions 1596
history  instructs the compiler whether to create the ﬁle or what to do with it if
it exists. history  must be one of these values:
Pascal returns an integer error code through error , as shown in Table 6-14.
Table 6-14 open  Error Codes
Pascal automatically closes all open ﬁles when your program terminates or
when the program exits the scope in which the ﬁle variable for the open ﬁle isallocated.  See also the close ,reset , andrewrite  procedures.'new' Associates the operating system ﬁle with a new ﬁle.  The compiler
generates an error if the ﬁle already exists.
'old' Associates the operating system ﬁle with an existing ﬁle.  The
compiler generates an error if the ﬁle does not exist.   This optionﬁrst tries to open the ﬁle for writing.  Failing to do so, it tries toopen it for reading only.
'unknown' Searches for an existing ﬁle and associate it with the operating
system ﬁle.  The compiler creates the ﬁle if it does not exist.
Number Description
0 open  is successful.
1 File not speciﬁed on the command-line.  For example, this error is
generated for the following line when argument one is not speciﬁed:
open(infile,'^1','new',Error);
2 Unable to open ﬁle.
3 Invalid history  speciﬁed. history  must be either ' new', 'old', or
'unknown '.
160 Pascal Language Reference6
The Pascal program, open.p program open_example;
{ This program demonstrates the use of the open procedure. }const
    name_of_file = 'open1.txt';    file3 = '*Enter_a_filename-- ';
type
    char_array = varying [50] of char;
var
    infile: text;    error: integer32;    name: char_array;
begin
    { Open an existing file. }    open(infile, name_of_file, 'old', error);    if error = 0 then begin      writeln('Opened ', name_of_file, ' for reading.');      close(infile)    end else      writeln('Error opening file', name_of_file, error);
    { Open a file specified by a command line argument. }
    open(infile, '^1', 'unknown', error);    if error = 0 then begin      argv(1, name);      writeln('Opened ', name, ' for reading.');      close(infile)    end else      writeln('No command line argument; error code =', error);
    { Open a file that may or may not exist. }
    { Prompt user for name of file at runtime. }    open(infile, file3, 'unknown', error);    if error = 0 then begin      writeln('Opened file for reading.');      close(infile)    end else      writeln('Error opening file', error)end. { open_example }
Built-In Procedures and Functions 1616
pcexit
Thepcexit  function:
•Checks whether any imposed statement count has been exceeded.
•Calls the ieee_retrospective ( )  routine.  See the Solaris
documentation for details.
•Terminates the program with the speciﬁed return value (similar to the Cexit()  function).
Syntax
pcexit (x)
Arguments
x is an integer variable or constant.
Return Value
pcexit  does not return any values.
Comments
The C function exit (3C) calls any functions registered through the
atexit (3C) function in the reverse order of their registration.The commands to compile and
execute open.phostname%pc open.p
hostname%a.out
Opened open1.txt for reading.No command line argument; error code =     1Enter_a_filename-- test.txt
Opened file for reading.
162 Pascal Language Reference6
random
Therandom  function generates a random number between 0.0 and 1.0.
Syntax
random (x)
Arguments
x has no signiﬁcance and is ignored.
Return Value
random  returns a real  value.
Comments
random  generates the same sequence of numbers each time you run the
program.  See the seed  function on page 172 to reseed the number generator.
Built-In Procedures and Functions 1636
Example
read  andreadln
Pascal supports the standard form of read  andreadln  with three extensions:
•Read in boolean  variables.
•Read in ﬁxed- and variable-length strings.
•Read in enumerated type values from a text ﬁle.
Syntax
read (ﬁle,var1 ...,varN );
readln (ﬁle,var1 ...,varN );The Pascal program, random.p program random_example(output);
{ This program demonstrates the use of
  the random function. }
var
    i: integer;    x: integer;
begin
    writeln('These numbers were generated at random:');    for i := 1 to 5 do begin      write(trunc(random(x) * 101))    end;    writelnend. { random_example }
The commands to compile and
execute random.phostname%pc random.p
hostname%a.out
These numbers were generated at random:    97    6    48    91    35
164 Pascal Language Reference6
Arguments
ﬁle is an optional variable having either the text  orfile  data type.
var can be any real , integer, character, boolean , subrange, enumerated, or
array variable or a ﬁxed- or variable-length string variable.  If read  orreadln
is used in a function to deﬁne the function result, var can also be an identiﬁer
of that function.
Return Value
read  andreadln  do not return any values.
Comments
Ifvar is a variable-length string, read  andreadln  try to read in as many
characters as indicated by the current length, up to the ﬁrst newline character.read  andreadln  do not pad the string with blanks if the length of the string
is less than the current length.
With both variable- and ﬁxed-length strings, if the number of characters on a
line is more than the maximum length of the string, the next read  picks up
where the last read  left off.  With readln , the rest of the line is discarded, so
the next read  orreadln  begins at the next line.
Ifvar is an enumerated type, read  andreadln  attempt to read a value that is
included in the type deﬁnition.  If the value is not in the type deﬁnition, thecompiler terminates program execution and prints the following errormessage:
Unknown name " value" found on enumerated type read
Trace/BPT trap (core dumped)
You can trap this error with the I/O error recovery mechanism, described in
“I/O Error Recovery” on page 214.  Using read  orreadln  in the block of a
function in the form:
read (..., f, ...)
is treated as if it were an assignment of the form:
f:=e
Built-In Procedures and Functions 1656
where e is the input value.  This feature is an extension of the Pascal Standard,
and so cannot be used with the -s option.
Example
The Pascal program, read.p program read_example(input, output);
{ This program uses readln to input strings,
  boolean data, and enumerated data. }
type
    gem_cuts = (marquis, emerald, round, pear_shaped);
var
    x: gem_cuts;    gem: varying [10] of char;    gift: boolean;
begin
    write('Enter type of gem:  ');    readln(gem);    write('Enter cut: ');    write('marquis, emerald, round, pear_shaped:  ');    readln(x);     write('Enter true if this a gift, false if it is not:  ');    readln(gift);    write('You have selected a ', gem);    writeln(' with a ', x, ' cut.');    if gift then      writeln('We will gift wrap your purchase for you.')end. { read_example }
The commands to compile and
execute read.phostname%pc read.p
hostname%a.out
Enter type of gem: diamond
Enter cut: marquis, emerald, round, pear_shaped: pear_shaped
Enter true if this a gift, false if it is not: true
You have selected a diamond with a pear_shaped cut.We will gift wrap your purchase for you.
166 Pascal Language Reference6
remove
Theremove  procedure removes the speciﬁed ﬁle.
Syntax
remove (ﬁle)
Arguments
ﬁle is either a ﬁxed- or variable-length string that indicates the name of the ﬁle
to be removed. ﬁle cannot be a text  orfile  variable.
Return Value
remove  does not return any values.
Comments
Pascal generates an I/O error if the ﬁle does not exist.  You can trap this error
with the I/O error recovery mechanism, described in “I/O Error Recovery” onpage 214.
Built-In Procedures and Functions 1676
Example
reset
Pascal supports an optional second argument to the reset  procedure.  This
argument gives an operating system ﬁle name.
Syntax
reset (ﬁle,ﬁlename )The Pascal program, remove.p program remove_example;
{ This program demonstrates the use of the
  remove procedure. }
var
    name: varying [10] of char;
begin
    if argc <> 2 then      writeln('Usage is : rm <file>')    else begin      argv(1, name);      remove(name)    endend. { remove_example }
The commands to compile and
execute remove.phostname%pc remove.p
hostname%touch rmc
hostname%ls rmc
rmchostname%a.out rmc
hostname%ls rmc
rmc not found
168 Pascal Language Reference6
Arguments
ﬁle is a variable having the text  orfile  data type.
ﬁlename  is a ﬁxed- or variable-length string, or a string constant.
Return Value
reset  does not return any values.
Comments
reset  gives you permission to read from the ﬁle, but not to write to the ﬁle.
In standard Pascal, reset  takes only one argument, a ﬁle variable.  In Pascal,
reset  can take an optional second argument, an operating system ﬁle name.
If you give the optional ﬁle name, the compiler opens the ﬁle with that nameon the current path and associates it with the given ﬁle variable.
For example, this code associates the Pascal ﬁle data  with the operating
system ﬁle primes :
reset(data, 'primes');
reset  does an implicit close on the ﬁle, hence you can reuse its ﬁle variable
with a different ﬁle.  Similarly, if input  oroutput  is reset, the current
implementation of the product also implicitly closes stdin  and stdout .
reset  normally generates an error and halts if the ﬁle speciﬁed in the two
argument form does not exist.  You can trap this error with the I/O errorrecovery mechanism, described in “I/O Error Recovery” on page 214.
See also the section on “rewrite,” which opens a ﬁle for writing.
Example
See the example in the rewrite  listing that follows.
rewrite
Pascal supports an optional second argument to the rewrite  procedure.  This
argument gives an operating system ﬁle name.
Built-In Procedures and Functions 1696
Syntax
rewrite (ﬁle,ﬁlename )
Arguments
ﬁle is a variable having the text  orfile  data type.
ﬁlename  is a ﬁxed- or variable-length string, or a string constant.
Return Value
rewrite  does not return any values.
Comments
rewrite  gives you permission to modify a ﬁle.
•In standard Pascal, rewrite  takes only one argument—a ﬁle variable.
•In Pascal, rewrite  can take an optional second argument, an operating
system ﬁle name.
In Pascal, if you give the optional ﬁle name, the compiler opens the ﬁle with
that name on the current path and associates it with the given ﬁle variable.  Forexample, this code associates the Pascal ﬁle data  with the operating system
ﬁleprimes :
rewrite(data, 'primes');
If you do not give an optional second argument, Pascal creates a physical
operating system ﬁle for you.  This ﬁle has the same name as the ﬁle variable if
the ﬁle variable is listed in the program header.  If the ﬁle variable is not listed
in the program header, Pascal creates a temporary ﬁle with the name#tmp. sufﬁx .  The temporary ﬁle is deleted when the program terminates.
If the ﬁle variable is output , and the second argument is not given, Pascal
creates a temporary ﬁle, but does not delete it after the program exits.
rewrite  does an implicit close on the ﬁle, thus you can reuse its ﬁle variable
with a different ﬁle.
See also the section on “reset,” which opens a ﬁle for reading.
170 Pascal Language Reference6
Example
The Pascal program, rewrite.p program rewrite_example(input, output);
{ This program demonstrates the use of rewrite
  and reset.}
const
    MAX = 80;
var
    f: text;    line: varying [MAX] of char;
begin
    rewrite(f, 'poem.txt');    write('Enter a line of text.');    writeln('  Hit Control-D to end the job.');    while not eof do begin      readln(line);      writeln(f, line)    end;    close(f);    writeln;    writeln;    writeln('These are the lines of text you input:');    reset(f, 'poem.txt');    while not eof(f) do begin      readln(f, line);      writeln(line)    end;    close(f)end. { rewrite_example }
Built-In Procedures and Functions 1716
rshft
Thershft  function does a logical right shift of an integer value.
Syntax
rshft (num ,sh)
Arguments
num  and sh are integer expressions.
Return Value
rshft  returns a 32-bit integer value.
Comments
rshft  shifts the bits in num sh  spaces to the right. rshft  does not preserve
the sign bit (leftmost) bit of a number and does not wrap bits from right to left.The value rshft  returns is machine-dependent, and is unspeciﬁed unless
0< = sh<= 32 .  Do not confuse rshft  with the arithmetic right shift
functions asr andarshft , which preserve the sign bit.The commands to compile and
execute rewrite.phostname%pc rewrite.p
hostname% a.out
Enter a line of text. Hit Control-D to end the job.Hello, how are you?Please keep in touch ^D
These are the lines of text you input:
Hello, how are you?Please keep in touch.
172 Pascal Language Reference6
seed
Theseed  function reseeds the random number generator.The Pascal program, rshft.p program rshft_example(input, output);
{ This program demonstrates the logical right shift. }const
    SIZE = 8;
var
    i: integer32;    i32: integer32;    loop: integer32;
begin
    write('Enter a positive or negative integer:  ');    readln(i);    for loop := 1 to SIZE do begin      i32 := rshft(i, loop);      write('Logical right shift ', loop: 2);      writeln(' bit(s):  ', i32 hex)    endend. { rshft_example }
The commands to compile and
execute rshft.p .  The value
the bit-shift routines return maydepend upon the architecture ofyour system.hostname%pc rshft.p
hostname%a.out
Enter a positive or negative integer: 32Logical right shift 1 bit(s):     10Logical right shift 2 bit(s):      8Logical right shift 3 bit(s):      4Logical right shift 4 bit(s):      2Logical right shift 5 bit(s):      1Logical right shift 6 bit(s):      0Logical right shift 7 bit(s):      0Logical right shift 8 bit(s):      0
Built-In Procedures and Functions 1736
Syntax
seed (x)
Arguments
x is an integer value.
Return Value
seed  returns an integer value.
Comments
seed  sets the random number generator to x and returns the previous seed.  If
you do not reseed the random number generator, the random  function returns
the same sequence of random numbers each time you run the program.  Toproduce a different random number (sequence each time the program is run),set the seed with the following statement:
x := seed(wallclock);
Example
See the example that follows.
174 Pascal Language Reference6
seek
Theseek  procedure changes the current position in the ﬁle.
Syntax
seek (ﬁle,pos)
Arguments
ﬁle is a variable with the text  orfile  data type.
pos is a positive integer.The Pascal program, seed.p program seed_example(output);
{ This program demonstrates the use of the
  seed function. }
var
    i: integer;    x: integer;begin    x := seed(wallclock);    writeln('These numbers were generated at random:');    for i := 1 to 5 do begin      write(trunc(random(i) * (i * 101)))    end;    writelnend. { seed_example }
The commands to compile and
execute seed.phostname%pc seed.p
hostname%a.out
These numbers were generated at random:   75   175   186   260   178
Built-In Procedures and Functions 1756
Return Value
seek  does not return any values.
Comments
Theseek  procedure is a facility to support random access input/output.  It
changes the position of a given ﬁle that is open for reading or writing.
You can use seek  with text ﬁles of text  type, or binary ﬁles of a certain file
of T  type.
For a binary ﬁle of type file of T , the argument pos denotes the number of
the element of type T, which becomes the new position of ﬁle.  Elements are
numbered from 0.  The argument pos can have an arbitrary non-negative value.
Ifﬁle is open for writing, and pos exceeds the size of the ﬁle, the ﬁle is
appended by the corresponding number of elements of type T with undeﬁned
values.  For example, if filesize(f) = 0 , then after seek(f,100)  and
write(f,x) , the result is: filesize(f) = 101 .
Ifﬁle is open for reading, seek  does not detect an error in seeking an element
with a non-existing number.  The compiler may detect this error later, however,when it performs the read  procedure.
For a text ﬁle, you can use seek  only in the following forms:
seek( ﬁle, 0)  or seek( ﬁle, tell( ﬁle))
That is, seek  can only set the current position to the beginning of the ﬁle or
have it stay “as is,” otherwise an error occurs.  Hence, the only correct way ofprocessing a text ﬁle in Pascal is reading or writing it successively, line by line.
See also the sections: “ﬁlesize,” and “tell.”
176 Pascal Language Reference6
Example
sizeof
sizeof  returns the number of bytes the program uses to store a data object.
Syntax
sizeof (x,tag1, ...tagN )The Pascal program, seek.p program seek_example;
var  f: file of integer;  i: integer;begin  rewrite(f);  for i:= 0 to 9 do    write(f, i);  writeln('Initial size of f =', filesize(f) :3, ' elements');  reset(f);  seek(f, 4);  read(f, i);  writeln('The 4th element of f =', i :3);  rewrite(f);  write(f, i);  seek(f, 100);  write(f, i);  writeln('Final size of f =', filesize(f):3, ' elements');  close(f);end. { seek_example }
The commands to compile and
execute seek.phostname%pc seek.p
hostname%a.out
Initial size of f = 10 elementsThe 4th element of f =  4Final size of f =101 elements
Built-In Procedures and Functions 1776
Arguments
x is any predeclared or user-deﬁned Pascal data type, a variable, a constant, or
a string.
tag is a constant.  This argument is optional.
Return Value
sizeof  returns an integer value.
Comments
sizeof  returns the number of bytes in the data object x.tags correspond to
the ﬁelds in a variant record. tags are effectively ignored because Pascal
allocates records according to the largest variant.
You cannot use sizeof  to determine the size of a conformant array parameter
because the array size is not known until runtime.  The difference between thesize of a constant string and that of a varying  string variable to which the
string is assigned.  For example:
sizeof ('') = 0
However, if S is deﬁned as follows:
then sizeof (S) = 16 .  Moreover,
sizeof (''+'') = 4
because the '+' string operator returns a varying  string object.var S: varying [12] of char;
begin    S:='';
178 Pascal Language Reference6
Example
sizeof.p  Program (Screen 1 of 2)The Pascal program, sizeof.p program sizeof_example(output);
{ This program demonstrates the use of the
  sizeof function. }
const
    MAX = 5;
type
    subB = false..true;    sub1 = 0..7;    sub2 = 0..127;    sub3 = 0..255;    color1 = (re, gree, blu, whit);    color2 = (red, green, blue, white, orange, purple, black);    rec_type =      record          i: integer;          ar: array [1..MAX] of single;          d: double      end;
var
    b: boolean;    c: char;    f: text;    i: integer;    i16: integer16;    i32: integer32;    s: shortreal;    r: real;    l: longreal;    rec: rec_type;    u: univ_ptr;
Built-In Procedures and Functions 1796
sizeof.p  Program (Screen 2 of 2)begin
    writeln('The size of boolean is    ', sizeof(b), '.');    writeln('The size of char is       ', sizeof(c), '.');    writeln('The size of color1 is     ', sizeof(color1), '.');    writeln('The size of color2 is     ', sizeof(color2), '.');    writeln('The size of file is       ', sizeof(f), '.');    writeln('The size of integer is    ', sizeof(i), '.');    writeln('The size of integer16 is  ', sizeof(i16), '.');    writeln('The size of integer32 is  ', sizeof(i32), '.');    writeln('The size of longreal is   ', sizeof(l), '.');    writeln('The size of shortreal is  ', sizeof(s), '.');    writeln('The size of real is       ', sizeof(r), '.');     writeln('The size of rec_type is  ', sizeof(rec_type), '.');    writeln('The size of rec_type.ar is ', sizeof(rec.ar), '.');    writeln('The size of subB is       ', sizeof(subB), '.');    writeln('The size of sub1 (8) is   ', sizeof(sub1), '.');    writeln('The size of sub2 (128) is ', sizeof(sub2), '.');    writeln('The size of sub3 (256) is ', sizeof(sub3), '.');    writeln('The size of univ_ptr is   ', sizeof(u), '.')end. { sizeof_example }
180 Pascal Language Reference6
stlimit
Thestlimit  procedure terminates program execution if a speciﬁed number
of statements have been executed in the current loop.
Syntax
stlimit (x)
Arguments
x is an integer value.
Return Value
stlimit  does not return any values.The commands to compile and
execute sizeof.p .  The value
sizeof returns may depend
upon the architecture of yoursystem.hostname%pc sizeof.p
hostname%a.out
The size of boolean is1.The size of char is1.The size of color1 is1.The size of color2 is1.The size of file is2089.The size of integer is 4.The size of integer16 is 2.The size of integer32 is 4.The size of longreal is 8.The size of shortreal is 4.The size of real is 8.The size of rec_type is 32.The size of rec_type.ar is20.The size of subB is1.The size of sub1 (8) is1.The size of sub2 (128) is1.The size of sub3 (256) is2.The size of univ_ptr is4.
Built-In Procedures and Functions 1816
Comments
To use stlimit , you must include the following code in your source program:
{$p+}
When you call stlimit , it tests if x number of statements have been executed
in the current loop.  If the number of statements executed equals or exceeds x,
stlimit  stops the program, dumps core, and prints the following message:
Statement count limit of x exceeded
Trace/BPT trap (core dumped)
Ifstlimit  is used without a loop, it reports the number of statements
executed and the CPU time utilized.
To check the statement limit after each statement, you can turn on runtime
checks using the –C command-line option or the C ort program text options.
When runtime checks are turned on and the compiler encounters a stlimit
statement, the compiler inserts a statement limit check after each subsequentstatement.
Example
The Pascal program,
stlimit.pprogram stlimit_example;
{$p+}
{ This program demonstrates the use
  of the stlimit procedure. }
begin
    repeat      writeln('Hello.');      stlimit(10)    until falseend. { stlimit_example }
182 Pascal Language Reference6
stradd
Thestradd  procedure adds a string to another string.
Syntax
stradd (strdest ,strsrc )
Arguments
strdest  is a variable-length string.
strsrc  is a variable-length string, a character array, or a character-string
constant.
Return Value
stradd  does not return any values.
Comments
stradd  adds strsrc  tostrdest , and is a more efﬁcient operator for the
concatenation of strings.  Use stradd  when a string is constructed by multiple
concatenation, with other strings to its end.
stradd  avoids allocating temporary storage.  An example is the assignment
str1 := str1 + str2, in which the compiler copies str1 into some temporary
storage, appends str2, and copies the result back into str1.The commands to compile and
execute stlimit.phostname%pc stlimit.p
hostname%a.out
Hello.Hello.Hello.Hello.
Statement count limit of 11 exceeded
Trace/BPT trap (core dumped)
Built-In Procedures and Functions 1836
If the resulting string is longer than the maximum length of strdest , it is
truncated to this maximum length.
See also the section: “concat.”
Example
substr
Thesubstr  function takes a substring from a string.
Syntax
substr (str,p,n)
Arguments
str is a variable-length string, a character array, or a character-string constant.
p is a positive integer.
n is a positive integer or zero.The Pascal program, stradd.p program stradd_example(output);
var  greeting: varying [20] of char := ' Hello';
begin
  stradd(greeting, ',');  stradd(greeting, ' world');  stradd(greeting, '!');  writeln(greeting);end.
The commands to compile and
execute stradd.phostname%pc stradd.p
hostname%a.out
 Hello, world!
184 Pascal Language Reference6
Return Value
substr  returns a variable-length string.
Comments
substr  returns a substring beginning at position p and continuing for n
characters.  If the values of either p orn indicate a character outside the
bounds of the string size, Pascal returns a null string.
Example
sysclock
Thesysclock  function returns the system time consumed by the process.The Pascal program, substr.p program substr_example(output);
{ This program demonstrates the use of the
  substr function. }
var
    string1: array [1..15] of char;    string2: varying [25] of char;
begin
    string1 := 'Paris, Texas';    string2 := 'Versailles, France';    write(substr(string1, 1, 6));    writeln(substr(string2, 12, 7))end. { substr_example }
The commands to compile and
execute substr.phostname%pc substr.p
hostname%a.out
Paris, France
Built-In Procedures and Functions 1856
Syntax
sysclock
Arguments
sysclock  does not take any arguments.
Return Value
sysclock  returns an integer value.
Comments
sysclock  returns the system time in milliseconds.  See also the clock
function, which returns the user time the process consumes.
Example
See the example in the clock  listing earlier in this chapter.
tell
Thetell  function returns the current position of a given ﬁle.
Syntax
tell (ﬁle)
Arguments
ﬁle is a variable with the text  orfile  data type.
Return Value
tell  returns an integer value.
186 Pascal Language Reference6
Comments
The argument can be either a text ﬁle of text  type, or a binary ﬁle of a certain
file of T  type.  It must be associated with an open ﬁle, otherwise an error
occurs.
For a text ﬁle, the tell  function returns the byte number that corresponds to
the current position in the ﬁle.
For a binary ﬁle of type file of T , thetell  function returns the number of
the element of type T that corresponds to the current position in the ﬁle.
Elements are numbered from 0.
See also the sections on: “ﬁlesize,” “seek.”
Example
The Pascal program, tell.p program tell_example;
var  ft: text;  fi: file of integer;  i: integer;begin  rewrite(ft);  rewrite(fi);  for i:= 1 to 3 do begin    writeln('tell(ft) =', tell(ft) :3);    writeln('tell(fi) =', tell(fi) :3);    writeln(ft, i :3);    write(fi, i);  end;  close(ft);  close(fi)end. { tell_example }
Built-In Procedures and Functions 1876
time
Thetime  procedure retrieves the current time.
Syntax
time (a)
Arguments
a is a variable that can be either a character array that is 8 elements long for the
"C" locale, or a variable-length string.
Return Value
time  returns a character string in the form traditional for a given locale.  For
the"C" locale, the form is hh:mm:ss , where hh is the hour (0 through 23); mm
is the minutes (0 through 59); and ss is the seconds (0 through 59).
Comments
time  uses a 24-hour clock.  It puts a zero in front of the hours, minutes, and
seconds, so that they always consist of two digits.
Use the environment variable LC_TIME  to set the necessary locale.
See also the section: “date.”The commands to compile and
execute tell.phostname%pc tell.p
hostname%a.out
tell(ft) =  0tell(fi) =  0tell(ft) =  4tell(fi) =  1tell(ft) =  8tell(fi) =  2
188 Pascal Language Reference6
Example
The Pascal program, time.p program time_example(output);
var
  s1: alfa;  s2: array[1..8] of char;  s3: array[89..96] of char;  s4: varying[100] of char;
begin
  time(s1);  time(s2);  time(s3);  time(s4);  writeln('The time is ', s1, '.');  writeln('The time is ', s2, '.');  writeln('The time is ', s3, '.');  writeln('The time is ', s4, '.');end.
Built-In Procedures and Functions 1896
trace
Thetrace  routine prints stack traceback without terminating a program.
Syntax
trace
Arguments
trace  does not take any arguments.
Return Value
trace  does not return any values.The commands to compile and
execute time.phostname%pc time.p
hostname%a.out
The time is 14:02:49.The time is 14:02:49.The time is 14:02:49.The time is 14:02:49.hostname% setenv LC_TIME ruhostname% a.outThe time is 14:02:56.The time is 14:02:56.The time is 14:02:56.The time is 14:02:56.hostname% setenv LC_TIME Chostname% a.outThe time is 14:03:21.The time is 14:03:21.The time is 14:03:21.The time is 14:03:21.
190 Pascal Language Reference6
Comments
You can use the trace  routine for debugging.  This routine prints stack
traceback information to a ﬁle without terminating your program.  The nameof the traceback ﬁle is p.trace , where p is the name of your executable.  For
example, if the executable is called a.out , then the name of the traceback ﬁle
isa.out.trace .
Thetrace  routine can be called several times during program execution, if
necessary.  In this case, traceback information is appended to the traceback ﬁle.
Thetrace  routine uses dbx, so be sure that dbx is in your path.
To print the traceback output in a clearer format, use the -g option to compile
your program.
Example
The Pascal program, trace.p program trace_example;
procedure subr(count: integer);
begin  if (count > 0 ) then    subr(count - 1)  else    trace;end;
begin
  subr(5);end.
Built-In Procedures and Functions 1916
trim
Thetrim  function removes the trailing blanks in a character string.
Syntax
trim (input_string )
Arguments
input_string  is a constant string, a variable-length string, a character array, or a
character.
Return Value
trim  returns a variable-length string equal to the input string without any
trailing blanks.  If input_string  is anull  string or contains only blanks, trim
returns a null  string of length 0.
Comments
trim  has no effect if its result value is assigned to a ﬁxed-length character
string variable.  Fixed-length characters are always padded with blanks duringassignments.The commands to compile and
execute trace.phostname%pc trace.p -g
hostname%a.out
hostname%cat a.out.trace
### Stacktrace of a.out
  [4] subr(count = 0), line 8 in "trace.p"  [5] subr(count = 1), line 6 in "trace.p"  [6] subr(count = 2), line 6 in "trace.p"  [7] subr(count = 3), line 6 in "trace.p"  [8] subr(count = 4), line 6 in "trace.p"  [9] subr(count = 5), line 6 in "trace.p"  [10] program(), line 12 in "trace.p"detaching from process 28226
192 Pascal Language Reference6
Example
The Pascal program, trim.p program trim_example;
{ This program demonstrates the use of the trim function. }
const    TEN = '          ';    MAX = 10;type    large = varying [100] of char;    s_type = array [1..MAX] of char;    v_type = varying [MAX] of char;var    c1: char := ' ';    st1: s_type := '123456    ';    st2: s_type := '          ';    st3: s_type := '0123456789';    v1: v_type := '01234     ';    v2: v_type := '          ';    v3: v_type := '0123456789';    l: large;
begin
    l := trim(st1) + trim(st2) + trim(st3) + trim(c1);    writeln(l, length(l));    l := substr(trim(st1) + trim(st2) + trim(st3), 3, 5);    writeln(l, length(l));    l := trim(v1) + trim(TEN) + trim(v2) + trim(v3) + trim(st1)    + trim(st2) + trim(st3);    writeln(l, length(l))end. { trim_example }
The commands to compile and
execute trim.phostname%pc trim.p
hostname%a.out
1234560123456789         1634560         50123401234567891234560123456789         31
Built-In Procedures and Functions 1936
Type Transfer
The type transfer function changes the data type of a variable, constant, or
expression.
Syntax
transfer_function (x)
Arguments
transfer_function  is a predeclared or user-deﬁned Pascal data type.
x is a variable, constant, or expression.
Return Value
A type transfer function returns its argument unchanged in internal value, but
with a different apparent type.
Comments
Suppose your program contains the following data type declarations:
To transfer the value of variable x to a ﬂoating-point number, you would write:var
  x: integer32;  y: single;
y := single(x);
194 Pascal Language Reference6
When the argument of a type transfer function is a variable, the size of the
argument must be the same as the size of the destination type.  However, if theargument to a transfer function is a constant or an expression, Pascal attemptsto convert the argument to the destination type because constants andexpressions do not have explicit types.
The type transfer functions copy, but do not convert, a value.  Do not confuse
the type transfer functions with functions that actually convert the value of thevariable, such as ord,chr, andtrunc .
Example
The Pascal program, type.p program type_transfer_example(output);
{ This program uses transfer functions to
  convert integer to character. }
type
    range = 65..90;
var
    i: range;    c: char;
begin
    for i := firstof(i) to lastof(i) do begin      write('The character value of ', i: 1);      writeln(' is ', char(i), '.')    endend. { type_transfer_example }
Built-In Procedures and Functions 1956
wallclock
Thewallclock  function returns the elapsed number of seconds since
00:00:00 GMT January 1, 1970.
Syntax
wallclockThe commands to compile and
execute type.phostname%pc type.p
hostname%a.out
The character value of 65 is A.The character value of 66 is B.The character value of 67 is C.The character value of 68 is D.The character value of 69 is E.The character value of 70 is F.The character value of 71 is G.The character value of 72 is H.The character value of 73 is I.The character value of 74 is J.The character value of 75 is K.The character value of 76 is L.The character value of 77 is M.The character value of 78 is N.The character value of 79 is O.The character value of 80 is P.The character value of 81 is Q.The character value of 82 is R.The character value of 83 is S.The character value of 84 is T.The character value of 85 is U.The character value of 86 is V.The character value of 87 is W.The character value of 88 is X.The character value of 89 is Y.The character value of 90 is Z.
196 Pascal Language Reference6
Arguments
wallclock  does not take any arguments.
Return Value
wallclock  returns an integer value.
Comments
wallclock  can be used with the seed  function to generate a random number.
It can also be used to time programs or parts of programs.
Example
See the example that follows.
Built-In Procedures and Functions 1976
The Pascal program,
wallclock.pprogram wallclock_example(output);
{ This program demonstrates the use of the
  wallclock function. }
const
    NTIMES = 20;  { Number of times to compute Fib value. }    NUMBER = 24;  { Biggest one we can compute with 16 bits. }
var
    start: integer;    finish: integer;    i: integer;    value: integer;
{ Compute fibonacci number recursively. }
function fib(number: integer): integer;
begin
    if number > 2 then      fib := fib(number - 1) + fib(number - 2)    else      fib := 1end; { fib }
begin { main program }
    writeln('Begin computing fibonacci series.');    write(NTIMES, ' Iterations:  ');    start := wallclock;    for i := 1 to NTIMES do      value := fib(NUMBER);    finish := wallclock;    writeln('Fibonacci(', NUMBER: 2, ') = ', value: 4, '.');    writeln('Elapsed time is ', finish - start: 3, ' seconds.')end. { wallclock_example }
The commands to compile and
execute wallclock.phostname%pc wallclock.p
hostname%a.out
Begin computing fibonacci series.    20 Iterations: Fibonacci(24) = 46368.Elapsed time is   5 seconds.
198 Pascal Language Reference6
write  andwriteln
Pascal supports the standard form of write  andwriteln  with the following
extensions:
•Output enumerated type values to a text ﬁle.
•Write the internal representation of an expression in octal or hexadecimal.
•Specify a negative ﬁeld width.
Syntax
write (ﬁle,exp1:width  ...,expN:width )
writeln (ﬁle,exp1:width  ...,expN:width )
Arguments
ﬁle is a variable having either the text  orfile  data type. ﬁle is optional; it
defaults to output .
exp is a variable, constant, or expression of type integer, real , character,
boolean , enumerated, or string. exp cannot be a set variable.
width  is an integer. width  is optional.
Return Value
write  andwriteln  do not return any values.
Comments
Ifexp is an enumerated type, write  andwriteln  attempt to write a value
that is included in the type deﬁnition.  If the value is not in the type deﬁnition,the compiler terminates program execution and prints an error message.
To write the internal representation of an expression in octal, use this form:
write(x oct);
x is a boolean, character, integer, pointer, or user-deﬁned type.  It can also be a
constant, expression, or variable.
Built-In Procedures and Functions 1996
To write an expression in hexadecimal, use this form:
write(x hex);
When you specify a negative ﬁeld width of a parameter, Pascal truncates all
trailing blanks in the array. write  andwriteln  assume the default values in
Table 6-15 if you do not specify a minimum ﬁeld length.
Table 6-15 Default Field Widths
Data Type Default Width without -xl Option Default Width with -xl Option
array of char Declared length of the array Declared length of the array
boolean Length of true  orfalse 15
char 11
double 21 21
enumerated Length of type 15hexadecimal 10 10integer 10 10
integer16 10 10
integer32 10 10
longreal 21 21
octal 10 10
real 21 13
shortreal 13 13
single 13 13
string constant Number  of characters in string Number of characters in stringvariable-length string Current length of the string Current length of the string
200 Pascal Language Reference6
Example
xor
Thexor function returns the exclusive or of two integer values.
Syntax
xor(int1,int2)
Arguments
int1 and int2 are integer expressions.The Pascal program, octal.p program octal_example(output);
{ This program writes a number in octal
  and hexadecimal format. }
var
    x: integer16;
begin
    write('Enter an integer:  ');    readln(x);    writeln(x: 5, ' is ', x oct, ' in octal.');    writeln(x: 5, ' is ', x hex, ' in hexadecimal.')end. { octal_example }
The commands to compile and
execute octal.phostname%pc octal.p
hostname%a.out
Enter an integer: 10 10 is       12 in octal. 10 is       A in hexadecimal.
Built-In Procedures and Functions 2016
Return Value
xor returns an integer value.
Comments
Pascal uses Table 6-16 to return the bitwise exclusive or ofint1 and int2.
Ifint1 and int2 are different size integers, Pascal converts the smaller integer to
the larger integer before it performs the xor operation.
xor is a bitwise operator similar to &,!, and~.  Do not confuse it with the
boolean  operators, and,or, andnot.
Example
See the example in the land  listing on page 142.Table 6-16 xor Truth
Value of Bit in int1 Value of Bit in int2 Value of Bit in result
00 001 110 111 1
202 Pascal Language Reference6
203Input and Output 7
This chapter describes the Pascal input and output environments, with
emphasis on interactive programming.  It contains the following sections:
Input and Output Routines
Pascal supports all standard input and output routines, plus the extensionslisted in Table 7-1.  For a complete description of the routines, refer toChapter 6, “Built-In Procedures and Functions.”Input and Output Routines page 203
eof and eoln Functions page 204More About eoln page 208External Files and Pascal File Variables page 210input, output, and errout Variables page 211Pascal I/O Library page 213Buffering of File Output page 213I/O Error Recovery page 214
204 Pascal Language Reference7
Table 7-1 Extensions to Input/Output Routines
eof andeoln  Functions
A common problem encountered by new users of Pascal, especially in the
interactive environment of the operating system, relates to eof andeoln .
These functions are supposed to be deﬁned at the beginning of execution of aPascal program, indicating whether the input device is at the end of a line(eoln ) or the end of a ﬁle ( eof).Routine Description
append Opens a ﬁle for writing at its end.
close Closes a ﬁle.
filesize Returns the current size of a ﬁle.
flush Writes the output buffer for the speciﬁed Pascal ﬁle into the
associated operating system ﬁle.
getfile Returns a pointer to the C standard I/O descriptor
associated with the speciﬁed Pascal ﬁle.
linelimit Terminates program execution after a speciﬁed number of
lines has been written into a text ﬁle.
message Writes the speciﬁed information to stderr .
open Associates an external ﬁle with a ﬁle variable.
read  andreadln Read in boolean , integer and ﬂoating-point variables,
ﬁxed- and variable-length strings, enumerated types, andpointers.
remove Removes the speciﬁed ﬁle.
reset  andrewrite Accepts an optional second argument.
seek Resets the current position of a ﬁle for random access I/O.
tell Returns the current position of a ﬁle.
write  andwriteln Outputs boolean  integer and ﬂoating-point variables,
ﬁxed- and variable-length strings, enumerated types, andpointers; output expressions in octal or hexadecimal; allowsnegative ﬁeld widths.
Input and Output 2057
Setting eof oreoln  actually corresponds to an implicit read in which the
input is inspected, but not “used up.”  In fact, the system cannot detectwhether the input is at the end of a ﬁle or the end of a line unless it attempts toread a line from it.
If the input is from a previously created ﬁle, then this reading can take place
without runtime action by you.  However, if the input is from a terminal, thenthe input is what you type.  If the system does an initial read automatically atthe beginning of program execution, and if the input is a terminal, you musttype some input before execution can begin.  This makes it impossible for theprogram to begin by prompting for input.
Pascal has been designed so that an initial read is not necessary.  At any given
time, Pascal may or may not know whether the end-of-ﬁle and end-of-lineconditions are true .
Thus, internally, these functions can have three values: true ,false , and,
“I don't know yet; if you ask me I'll have to ﬁnd out.”  All ﬁles remain in thislast, indeterminate state until the program requires a value for eof oreoln ,
either explicitly or implicitly; for example, in a call to read .  If you force Pascal
to determine whether the input is at the end of the ﬁle or the end of the line, itmust attempt to read from the input.
Consider the following example:
206 Pascal Language Reference7
At ﬁrst glance, this may appear to be a correct program for requesting, reading,
and echoing numbers.  However, the while  loop asks whether eof istrue
before the request is printed.  Thus, this system is forced to decide whether theinput is at the end of the ﬁle.  It gives no messages; it simply waits for the userto type a line, as follows:
The following code avoids this problem by prompting before testing eof:The Pascal program,
eof_example1.p , which shows
the improper use of the eof
functionprogram eof_example1;
var
    i: integer;
begin
    while not eof do begin      write('Number, please?  ');      read(i);      writeln('That was a ', i: 2, '.');      writeln    endend. { eof_example1 }
The commands to compile and
execute eof_example1.phostname%pc eof_example1.p
hostname%a.out
23Number, please? That was a 23.
Number, please? ^D
standard input: Tried to read past end of filea.out terminated by signal 5: SIGTRAPTraceback being written to a.out.traceAbort (core dumped)
Input and Output 2077
You must still type a line before the while  test is completed, but the prompt
asks for it.  This example, however, is still not correct, because it is ﬁrstnecessary to know that there is an end-of-line character at the end of each linein a Pascal text ﬁle.  Each time you test for the end of the ﬁle, eof ﬁnds the
end-of-line character.  Then, when read  attempts to read a character, it skips
past the end-of-line character, and ﬁnds the end of the ﬁle, which is illegal.
Thus, the modiﬁed code still results in the following error message at the end
of a session:
The simplest way to correct the problem in this example is to use the procedure
readln  instead of read .readln  also reads the end-of-line character, and
eof ﬁnds the end of the ﬁle:The Pascal program,
eof_example2.p , which also
shows the improper use of theeof function.program eof_example2;
var
    i: integer;
begin
    write('Number, please?  ');    while not eof do begin      read(i);      writeln('That was a ', i: 2, '.');      writeln;      write('Number, please?  ')    endend. { eof_example2 }
The commands to compile and
execute eof_example2.phostname%pc eof_example2.p
hostname%a.out
Number, please? 23
That was a 23.
Number, please? ^D
standard input: Tried to read past end of fileTraceback being written to a.out.traceAbort (core dumped)
208 Pascal Language Reference7
In general, unless you test the end-of-ﬁle condition both before and after calls
toread  orreadln , there may be input that causes your program to attempt to
read past the end-of-ﬁle.
More About eoln
To have a good understanding of when eoln  istrue , remember that in any
ﬁle text, there is a special character indicating end-of-line.  In effect, Pascalalways reads one character ahead of the read  command.
For instance, in response to read(ch) , Pascal sets ch to the current input
character and gets the next input character.  If the current input character is thelast character of the line, then the next input character from the ﬁle is thenewline character, the normal operating system line separator.The Pascal program,
eof_example3.p , which shows
the proper use of the eof
function.program eof_example3;
var
    i: integer;
begin
    write('Number, please?  ');    while not eof do begin      readln(i);      writeln('That was a ', i: 2, '.');      writeln;      write('Number, please? ')    endend. { eof_example3 }
The commands to compile and
execute eof_example3.phostname%pc eof_example3.p
hostname%a.out
Number, please? 23
That was a 23.
Number, please? ^D
Input and Output 2097
When the read  routine gets the newline character, it replaces that character by
a blank (causing every line to end with a blank) and sets eoln  totrue .eoln
istrue  as soon as you read the last character of the line and before you read
the blank character corresponding to the end of line.  Thus, it is almost alwaysa mistake to write a program that deals with input in the following way:
This program almost always has the effect of ignoring the last character in the
line.  The read(ch)  belongs as part of the normal processing.  In Pascal terms,
read(ch)  corresponds to ch := input^; get(input) .
Given this framework, the function of a readln  call is deﬁned as follows:
This code advances the ﬁle until the blank corresponding to the end of line is
the current input symbol and then discards this blank.  The next characteravailable from read  is the ﬁrst character of the next line, if one exists.This code shows the improper
use of the eoln function.read(ch);
if eoln then
Done with line
 else
Normal processing
This code shows the proper
use ofeoln.read(ch);
if eoln then
Done with line
else begin
read(ch);Normal processingend
while not eoln do
get(input);
get(input);
210 Pascal Language Reference7
External Files and Pascal File Variables
In Pascal, most input and output routines have an argument that is a ﬁle
variable.  This system associates these variables with either a permanent ortemporary ﬁle at compile-time.
Permanent Files
Table 7-2 shows how to associate a Pascal ﬁle variable with a permanent ﬁle.
Table 7-2 Pascal File Variable with a Permanent File
Association Description
With the open  function open  associates a permanent ﬁle with a ﬁle
variable for reading or writing. open  can also
determine if a ﬁle actually exists.
With the reset  andrewrite
functionsIn Pascal, reset  andrewrite  take an optional
second argument, a ﬁle name.  If you specify theﬁle name, the compiler opens the ﬁle and associatesit with the given ﬁle variable.  Any previous ﬁleassociated with the ﬁle variable is lost.
With the program header If you call reset  orrewrite  with a ﬁle variable
f1, which is bound to a ﬁle variable declared f2 in
the program header and do not specify the ﬁlename, Pascal opens a ﬁle with the same name asthe variable f2.reset  gives a runtime error if the
ﬁle does not exist. rewrite  creates the ﬁle if it
does not exist.
Input and Output 2117
Temporary Files
Table 7-3 shows how to associate a Pascal ﬁle variable with a temporary ﬁle.
Table 7-3 Pascal File Variable with a Temporary File
input ,output , anderrout  Variables
Theinput ,output , anderrout  variables are special predeﬁned ﬁle
variables.
•input  is equivalent to the operating system standard input ﬁle, stdin .
•output  is equivalent to the operating system standard output ﬁle, stdout .
•errout  is equivalent to the operating system standard error ﬁle, stderr .
Properties of input ,output , anderrout  Variables
Theinput, output,  anderrout  variables are of the type text  and have
the following special properties:
•input ,output , anderrout  are optional in the program header.
•You can redirect input ,output , anderrout  to ﬁles or pipe them to other
programs.
•You can redeﬁne input ,output , anderrout .
•You do not have to name input  andoutput  as explicit arguments to the
read ,readln ,write , andwriteln  procedures.Association Description
With the procedure:
rewrite(file_variable )file_variable  must not be declared in the program
statement.  This procedure creates a temporary ﬁlecalled#tmp. sufﬁx , where sufﬁx  is unique to that
temporary ﬁle.  When the program exits or leaves thescope in which ﬁle_variable  is declared, the ﬁle is
deleted.
With the procedure:
rewrite(output)The procedure creates the temporary ﬁle called
#tmp .sufﬁx , where sufﬁx  is unique to that temporary ﬁle.
This ﬁle is not deleted after program execution .
212 Pascal Language Reference7
•In the initial state of input, eoln  istrue  andeof isfalse .input↑ is
not initially deﬁned when it is associated with stdin  until the ﬁrst read  or
readln .  Foroutput ,eoln  is initially undeﬁned, and eof istrue .
Associating input  with a File Other Than stdin
To associate input  with a ﬁle other than stdin,  callreset(input ,ﬁlename ).
Pascal opens ﬁlename  and associates it with input .read  andreadln  read
from that ﬁle.  For example, this line opens the ﬁle, some/existing/file,
and associates it with input :
reset(input,'some/existing/file');
You must supply a ﬁle name for the association to work.
Associating output  with a File Other Than stdout
To associate output  with a ﬁle other than stdout , callrewrite(output,
ﬁlename ).  Pascal opens ﬁlename  and associates it with output .  For example,
this line associates /home/willow/test  withoutput :
rewrite(output, '/home/willow/test');
Now, whenever you direct write  orwriteln  tooutput , the output is sent to
/home/willow/test .  This includes the default case, when you write
without giving a ﬁle variable.
If you call rewrite  onoutput  and you haven't associated output  with an
external ﬁle, the program creates a ﬁle with a name of the form #tmp. sufﬁx ,
where sufﬁx  is unique to that ﬁle.  Pascal does not delete this ﬁle after the
program exits.
Associating errout  with a File Other Than stderr
To associate errout  with a ﬁle other than stderr , call:
rewrite (errout, '/some/new/file');
Subsequently, whenever you direct write  orwriteln  toerrout , the output
is sent to /some/new/file .  You obtain the same results when you write a
string to errout  implicitly, using the message  function.  See “message” on
page 155 for details.
Input and Output 2137
Pascal I/O Library
Each ﬁle variable in Pascal is associated with a data structure.  The data
structure deﬁnes the physical Solaris 2.x operating system ﬁle with which thevariable is associated.  It also contains ﬂags that indicate whether the ﬁlevariable is in an eoln  oreof state.
The data structure also includes the buffer.  The buffer normally contains a
single component that is the same type as the type of the ﬁle.  For example, afile of char  has one character buffer, and a file of integer  has one
integer buffer.
Buffering of File Output
It is extremely inefﬁcient for Pascal to send each character to a terminal as itgenerates it for output.  It is even less efﬁcient if the output is the input ofanother program, such as the line printer daemon, lpr(1).
To gain efﬁciency, Pascal buffers output characters; it saves the characters in
memory until the buffer is full and then outputs the entire buffer in one systeminteraction.
For interactive prompting to work, Pascal must print the prompt before
waiting for the response.  For this reason, Pascal normally prints all the outputthat has been generated for output  whenever one of the following conditions
occurs:
•The program calls a writeln .
•The program reads from the terminal.
•The program calls either the message  orflush  procedure.
In the following code sequence, the output integer does not print until the
writeln  occurs:
214 Pascal Language Reference7
Pascal performs line buffering by default.  To change the default, you can
compile your program with –b option.  When you specify the –boption on the
command-line, the compiler turns on block-buffering with a block size of 1,024.You can specify this option in a program comment using one of these formats:
This option only has an effect in the main program.  The value of the option in
effect at the end statement of the main program is used for the entire program.
I/O Error Recovery
When an I/O routine encounters an error, it normally does the following:
1. Generates an error message.2. Flushes its buffers.3. Terminates with a
SIGTRAP .
Although you can set up a signal handler to trap this signal, you cannot
determine which routine called the signal or the reason it was called.
With Pascal, you can set I/O trap handlers dynamically in your program.  The
handler is a user-deﬁned Pascal function.
When an I/O error occurs, Pascal runtime library checks if there is a current
active I/O handler.  If one does not exist, Pascal prints an error message,invokes a SIGTRAP signal, and terminates.for i := 1 to 5 do begin
write(i);Compute a lot with no output
end;writeln;
{$b0} No buffering.
{$b1} Line buffering.  This is the default.
{$b2} Block buffering.  The block size is 1,024.  Any number greater
than 2, for example, {$b5} , is treated as {$b2} .
Input and Output 2157
If a handler is present, the handler is passed the values err_code  andfilep
asin parameters.  The parameter err_code  is bound to the error value that
caused the I/O routine to fail.  The parameter filep  is bound to the I/O
descriptor that getfile  returned for the ﬁle in which the error occurred.  If
filep  equals nil, no ﬁle was associated with the ﬁle variable when the error
occurred.
The handler returns a boolean  value.  If the value is false , the program
terminates.  If the value is true , program execution continues with the
statement immediately following the I/O routine that called the trap.  Theresults of the I/O call remain undeﬁned.
You can set the handler to nil to return it to its default state.
The scope of the active handler is determined dynamically.  Pascal has
restrictions as to the lexical scoping when you declare the handler.  Thecompiler assumes that the handler is a function declared at the outermost level.Providing a nested function as the handler may cause unexpected results.  Thecompiler issues a warning if it attempts to take the address of a nestedprocedure.
To set an I/O trap handler, you must include the ﬁle ioerr.h  in your Pascal
source ﬁle. ioerr.h  consists of an enumeration type of all possible I/O error
values, a type declaration of an io_handler  procedure pointer type, and an
external declaration of the set_io_handler  routine.
This ﬁle resides in the following directory:
If the compiler is installed in a non-default location, change /opt/SUNWspro
to the location where the compiler is installed.
/opt/SUNWspro/SC4.2/include/pascal
216 Pascal Language Reference7
Theinclude  ﬁle,ioerr.h /* Copyright 1989 Sun Microsystems, Inc. */
type
      IOerror_codes = (              IOerr_no_error,              IOerr_eoln_undefined,              IOerr_read_open_for_writing,              IOerr_write_open_for_reading,              IOerr_bad_data_enum_read,              IOerr_bad_data_integer_read,              IOerr_bad_data_real_read,              IOerr_bad_data_string_read,              IOerr_bad_data_varying_read,              IOerr_close_file,              IOerr_close_null_file,              IOerr_open_null_file,              IOerr_create_file,              IOerr_open_file,              IOerr_remove_file,              IOerr_reset_file,              IOerr_seek_file,              IOerr_write_file,              IOerr_file_name_too_long,              IOerr_file_table_overflow,              IOerr_line_limit_exceeded,              IOerr_overflow_integer_read,              IOerr_inactive_file,              IOerr_read_past_eof,              IOerr_non_positive_format              );
io_handler = ^function( in err_code : IOerror_codes;
                      in fileptr  : univ_ptr) :                      boolean;
procedure set_ioerr_handler(handler : io_handler); extern c;
Input and Output 2177
The following program illustrates how to set an I/O trap routine.
The Pascal program ioerr.p ,
which  deﬁnes the I/O traproutine, test_handler .  This
routine is called each time aruntime error occurs during anI/O operation.  The #include
statement includes ioerr.h  in
the program.{$w-}
program ioerr_example(output);{ This program sets and uses an I/O trap routine. }
#include "ioerr.h"
const    NAME = 'rmc.dat';
var
    f: text;    IO_ERROR: IOerror_codes;    str: array [1..10] of char := 'Testing';
function test_handler(in code: IOerror_codes;
                      in fileptr: univ_ptr): boolean;
begin
    if code = IO_ERROR then begin      writeln('ERROR HANDLER ', code);      test_handler := true    end else      test_handler := falseend; { test_handler }
begin { main program }
    set_ioerr_handler(addr(test_handler));    { Write to an unopened file. }    IO_ERROR := IOerr_inactive_file;    write(f, 'This file is not open.');    { Read a file open for writing. }    rewrite(f, NAME);    IO_ERROR := IOerr_read_open_for_writing;    readln(f, str);    remove(NAME);    { Remove a nonexistent file. }    IO_ERROR := IOerr_remove_file;    remove('nonexistent.dat')end. { ioerr_example }
218 Pascal Language Reference7
The commands to compile and
execute ioerr.p .  When you use
an I/O error recovery routine, youshould compile your program withthe–C option.hostname%pc -C ioerr.p
hostname%a.out
ERROR HANDLER IOerr_inactive_fileERROR HANDLER IOerr_read_open_for_writingERROR HANDLER IOerr_remove_file
219Overview of Pascal Extensions A
This Appendix gives an overview of the Pascal extensions to ISO/ANSI
standard Pascal.
Lexical Elements
Pascal supports the following extensions to the lexical elements of standard
Pascal:
•Uppercase- and lowercase-sensitive
•The special symbols ~,&,|,!,#, and%
•The reserved words external ,otherwise ,private ,public , anduniv
•The reserved words define ,extern ,module , andstatic
•The identiﬁers in Table A-1
•Anunderscore (_)  anddollar_sign($)  in identiﬁer names
•The comment delimiters /* */ . in addition to the standard (* *)  and{ }
•The comment delimiters " "
220 Pascal Language ReferenceA
Table A-1 Nonstandard Identiﬁers
Data Types
Pascal supports the following extensions to the standard Pascal data types:
•Thereal  data types shortreal  andlongreal
•Thereal  data types single  anddouble
•Areal  constant without a digit after the decimal point
•The integer data types integer16  andinteger32
•An integer constant in another base
•Character constants minchar ,maxchar ,bell , andtab
•Fixed-length and variable-length character strings
•Array initialization using a default upper bound or a repeat count
•A set of type intset , which contains the elements 0 through 127Nonstandard Identiﬁers
FALSE close index lsr returnTRUE concat integer16 max rshftaddr date integer32 maxchar seedalfa discard intset message seekappend double land min shortrealargc exit lastof minchar singleargv expo length minint sizeofarshft filesize linelimit next straddasl firstof lnot null substrasr flush longreal open tellassert getfile lor pack tracebell getenv lshft random trimcard halt lsl remove univ_ptrclock in_range
Overview of Pascal Extensions 221A
•A pointer type to procedures and functions
•A universal pointer type that holds a pointer to a variable of any data type
Statements
Pascal extends the standard deﬁnition of statements, as follows:
•Theand then  andor else  operators in the if statement
•Theassert  statement
•Theotherwise  statement in a case  statement
•Constant ranges in a case  statement
•Theexit  statement in a for,while , orrepeat  loop
•Thenext  statement in a for,while , orrepeat  loop
•An identiﬁer as the target of a goto  statement
•Thereturn  statement in a procedure or function
•An alternative format of the with  statement
Assignments and Operators
Pascal supports the following extensions to standard Pascal operators:
•The bitwise operators ~(not),&(and),|(or), and!(or)
•Theboolean  operators and then  andor else
•The relational operators on sets
•The equality ( =) and inequality <> ) ( operators on records and arrays
•The concatenation operator, the plus sign ( +), on any combination of ﬁxed-
and variable-length strings
Headings and Declarations
Pascal supplies the following extensions to the standard program heading anddeclarations:
•Identiﬁers as labels
222 Pascal Language ReferenceA
•A constant equal to a set expression
•public  andprivate  variable declarations
•Thestatic ,extern , anddefine  variable attributes
•real , integer, boolean , character, set, record, array, and pointer variable
initialization in the var declaration
•Thedefine  declaration
•Thelabel ,const ,type ,var, anddefine  declaration in any order and
any number of times
Procedures and Functions
Pascal supports the following extensions to the standard Pascal deﬁnition ofprocedures and functions:
•public  andprivate  procedure and function declarations
•Thein,in out,  andout parameter types
•Theuniv  keyword parameter type
•Theextern ,external ,internal ,variable , andnonpascal  routine
options
•Functions returning structured types
Built-In Routines
Pascal supports the following nonstandard built-in routines:
•Theaddr  function, which returns the address of a speciﬁed variable
•Theappend  procedure, which opens a ﬁle for writing at its end
•Theargc  function, which returns the number of arguments passed to the
program
•Theargv  procedure, which assigns the speciﬁed program argument to a
string variable
•Thearshft  function, which does an arithmetic right shift of an integer
•Theasl function, which does an arithmetic left shift of an integer
Overview of Pascal Extensions 223A
•Theasr function, which is identical to arshft
•Theconcat  function, which concatenates two strings
•Thecard  function, which returns the cardinality of a set
•Theclock  function, which returns the user time used by the process
•Theclose  procedure, which closes the speciﬁed ﬁle
•Thedate  procedure, which fetches the current date
•Thediscard  procedure, which explicitly discards the return value of a
function
•Theexpo  function, which calculates the exponent of a speciﬁed variable
•Thefilesize  function, which returns the current size of a ﬁle
•Thefirstof  function, which returns the ﬁrst possible value of a type or
variable
•Theflush  procedure, which writes the output buffered for the speciﬁed
Pascal ﬁle into the associated operating system ﬁle
•Thegetenv  function, which returns the value associated with an
environment name
•Thegetfile  function, which returns a pointer to the C standard I/O
descriptor associated with the speciﬁed Pascal ﬁle
•Thehalt  procedure, which terminates program execution
•Theindex  function, which returns the position of the ﬁrst occurrence of a
string or character within another string
•Thein_range  function, which determines whether a speciﬁed value is in
the deﬁned integer subrange
•Theland  function, which returns the bitwise and of two integer values
•Thelastof  function, which returns the last possible value of a type or
variable
•Thelength  function, which returns the length of a string
•Thelinelimit  function, which terminates execution of a program after a
speciﬁed number of lines have been written into a text ﬁle
•Thelnot  function, which returns the bitwise not of an integer value
224 Pascal Language ReferenceA
•Thelor function, which returns the inclusive or of two integer values
•Thelshft  function, which does a logical left shift of an integer
•Thelsl function, which is identical to lshft
•Thelsr function, which is identical to rshft
•Themax function, which returns the larger of two expressions
•Themessage  procedure, which writes the speciﬁed information to stderr
•Themin function, which returns the smaller of two expressions
•Thenull  procedure, which performs no operation
•Theopen  procedure, which associates an external ﬁle with a ﬁle variable
•Therandom  function, which generates a random number between 0.0 and
1.0
•Theread  andreadln  procedures, which read in boolean  variables, ﬁxed-
and variable-length strings, enumerated types, and pointers from thestandard input
•Theremove  procedure, which removes the speciﬁed ﬁle
•Thereset  andrewrite  procedures, which accept an optional second
argument, a Solaris 2.0 operating system ﬁle name
•Thershft  function, which does a logical right shift of an integer
•Theseed  function, which reseeds the random number generator
•Theseek  procedure, which resets the current position of a ﬁle
•Thesizeof  function, which returns the size of a speciﬁed type, variable,
constant, or string
•Thestlimit  procedure, which terminates program execution if a speciﬁed
number of statements have been executed in the current loop
•Thestradd  procedure, which adds a string to the end of another string
•Thesubstr  function, which extracts a substring from a string
•Thesysclock  function, which returns the system time used by the process
•Thetell  function, which returns the current position of a ﬁle
•Thetime  procedure, which retrieves the current time
Overview of Pascal Extensions 225A
•Thetrace  procedure, which prints stack traceback
•Thetrim  function, which removes the trailing blanks in a character string
•The type_transfer  function, which changes the data type of a variable or
expression
•Thewallclock  function, which returns the elapsed number of seconds
since 00:00:00 GMT January 1, 1970
•Thewrite  andwriteln  procedures, which output enumerated type values
to the standard output and allow output expressions in octal or hexadecimal
•Thewrite  andwriteln  procedures, which allow negative ﬁeld widths
•Thexor function, which returns the exclusive or of two integer values
Input and Output
Pascal supports the following extensions to standard Pascal input and output:
•Association of a Pascal ﬁle with either a permanent or temporary Solaris
operating system ﬁle
•The special predeﬁned ﬁle variables, input  andoutput , that need not be
speciﬁed in the program statement
•The special predeﬁned ﬁle variable, errout
•An I/O error recovery mechanism
Program Compilation
Pascal supports the following extensions to program compilation:
•Sharing variable, procedure, and function declarations across multiple units
usinginclude  ﬁles
•Sharing variable, procedure, and function declarations across multiple units
using multiple declarations
•Sharing variable, procedure, and function declarations across multiple unitsusing the extern  anddefine  variable declarations
•Sharing variable, procedure, and function declarations between units of
different languages using the extern  andexternal  routine options
226 Pascal Language ReferenceA
227Pascal and DOMAIN  Pascal B
This Appendix describes the differences between Pascal and Apollo DOMAIN
Pascal, and how the -xl option can be used to get around most of these
differences.
The–xl Option
The–xl option to the pc command makes the language accepted by the
Pascal compiler similar to DOMAIN  Pascal. Table B-1 lists the differences in
your program when you compile it with and without the –xl option.
Table B-1 Differences Between Programs Compiled with and without –xl
With–xl Without –xl
The default integer size is 16 bits . The default is 32 bits.
The default real size is 32 bits . The default is 64 bits.
The default enumerated type size is 16 bits. The default is either 8 or 16 bits, depending on the number
of elements in the enumerated set.
The source ﬁle is run through the preprocessor cppas
before it is processed by the compiler.The source ﬁle is run through the preprocessor cpp.
Pascal supports nonpasca l as a routine option. nonpascal is not supported.
228 Pascal Language ReferenceB
DOMAIN  Pascal Features Accepted but Ignored
Pascal accepts these DOMAIN  Pascal features, but otherwise ignores them,
with a warning message as appropriate:
•Thevolatile ,device , andaddress  extensions for attributes of variables
and types
•Routine attribute lists
•The routine options abnormal ,nosave ,noreturn ,val_param , and
d0_return ,a0_return,  andc_paramThe– L  option, which maps all identiﬁers to lowercase, is
on by default.–L is off by default.
If the value of the expression in a case statement does
not match any of the case values, the program falls
through and does not generate an error.  The programcontinues execution in the statement immediatelyfollowing the case statement.The compiler generates an error and halts.
The writing of enumerated and boolean  variables
defaults to uppercase and 15-character width format.Enumerated variables default to the length of the type.
boolean  variables default to the length of true  orfalse .
Integer or real  constant literals that overﬂow
implementation limits do not cause an error.  Theresulting action is undeﬁned.An error is generated.
No warning is generated when the argument to the addr
function is a local or private variable.A warning is generated.
Top-level variables, procedures, and functions in
programs default to private .Variables, procedures, and functions in programs default to
public .
Top-level variables in modules default to private . Variables in modules default to public .
Modules compiled with –xl arenotcompatible with
modules compiled without –xl
.These two types of modules are not linked together.Table B-1 Differences Between Programs Compiled with and without –xl  (Continued)
With–xl Without –xl
Pascal and DOMAIN Pascal 229B
DOMAIN  Pascal Features Not Supported
Pascal does not support the following features of DOMAIN  Pascal:
•Alignment speciﬁc to the DN10000 in DOMAIN  Pascal SR10
•Allocation of variables into named sections
•Calls to the DOMAIN  system libraries
•Compiler directives inside comments
•The functions append ,ctop ,find ,ptoc ,replace , andundefined
•Special characters embedded in string literals
•The system programming routines, disable ,enable , andset_sr
230 Pascal Language ReferenceB
231Implementation Restrictions C
This Appendix describes the Pascal features that are implementation-deﬁned.
Identiﬁers
Pascal restricts the maximum length of an identiﬁer to 1,024 characters.  All
characters are signiﬁcant.
Identiﬁers in a nested procedure are concatenated with the identiﬁer of the
containing procedure.  Thus, an identiﬁer in a deeply nested procedure maybecome several hundred characters when concatenated and may causeproblems with the compiler.  Pascal generates an error when this situationoccurs.
Data Types
This section describes the restrictions Pascal places on the following data types:
•real
•Integer
•Character
•Record
•Array
•Set
•Alignment
232 Pascal Language ReferenceC
real
Table C-1 lists the minimum and maximum values Pascal assigns to the real
data types, single  anddouble .
Table C-1 Values for single  anddouble
Integer
The value Pascal assigns to the integer constants maxint  andminint  depends
on whether or not you compile your program with the –xl option, as shown in
Table C-2.
Table C-2 maxint  andminint
Character
Pascal deﬁnes the maximum range of characters as 0 to 255.
Record
Pascal restricts the maximum size of a record to 2,147,483,647 bytes.
Array
Pascal restricts the maximum size of an array to 2,147,483,647 bytes.Type Bits Maximum Value Minimum Value
single 32 3.402823e+38 1.401298e-45
double 64 1.79769313486231470e+308 4.94065645841246544e-324
Option maxint minint
-xl off 2,147,483,647 -2,147,483,648
-xl on 32,767 -32,768
Implementation Restrictions 233C
Set
Pascal restricts the maximum size of a set to 32,767 elements.
Alignment
The size and alignment of data types depends on whether or not you compile
your program with the –xl option. Table C-3 shows the representation of data
types without –xl, and Table C-4 shows the representation with –xl.
234 Pascal Language ReferenceC
Table C-3 Internal Representation of Data Types without –xl
Data Type Size Alignment
integer Four bytes Four bytes
integer16 Two bytes Two bytes
integer32 Four bytes Four bytes
real Eight bytes Eight bytes
single Four bytes Four bytes
shortreal Four bytes Four bytes
double Eight bytes Eight bytes
longreal Eight bytes Eight bytes
boolean One byte One byte
char One byte One byte
enumerated One or two bytes, depending on the
number of elements in the enumerated setOne or two bytes
subrange One, two, or four bytes One, two, or four bytes
record Depends upon the base type of that ﬁeld. Four bytesarray Requires the same space required by the
base type of the array.Same as element type
set Pascal implements vector, with one bit
representing each element of a set.  Thesize is determined by the size of the ordinalvalue of the maximal element of the setplus one.  It is a minimum of two bytes andalways in two-byte multiples.Two bytes if size = 2;
otherwise, four bytes
pointer Four bytes Four bytes
Implementation Restrictions 235C
Table C-4 Internal Representation of Data Types with -xl
Nested Routines
Pascal allows a maximum of 20 levels of procedure and function nesting.Data Type Size Alignment
integer Two bytes Four bytes
integer16 Two bytes Two bytes
integer32 Four bytes Four bytes
real Four bytes Eight bytes
single Four bytes Four bytes
shortreal Four bytes Four bytes
double Eight bytes Eight bytes
longreal Eight bytes Eight bytes
boolean One byte One byte
char One byte One byte
enumerated Two bytes Two bytessubrange Two or four bytes Two or four bytesrecord Depends on the base type of that ﬁeld. Four bytesarray Needs the same space required by the base
type of the array.Same as element type
set Pascal implements sets as a bit vector, with
one bit representing each element of a set.The size is determined by the size of theordinal value of maximal element of the setplus one.  It is a minimum of two bytes andalways in two-byte multiples.Two bytes if size = 2;
otherwise, four bytes
pointer Four bytes Four bytes
236 Pascal Language ReferenceC
Default Field Widths
Thewrite  andwriteln  statements assume the default values in Table C-5 if
you do not specify the minimum ﬁeld length of a parameter.
Table C-5 Default Field Widths
Data Type Default Width without -xl Option Default Width with -xl Option
array of char Declared length of the array Declared length of the array
boolean Length of true  orfalse 15
char 11
double 21 21
enumerated Length of type 15hexadecimal 10 10integer 10 10
integer16 10 10
integer32 10 10
longreal 21 21
octal 10 10
real 21 13
shortreal 13 13
single 13 13
string constant Number of characters in the string Number of characters in the stringvariable-length string Current length of the string Current length of the string
237Pascal Validation Summary Report D
The Pascal Version 4.2 compiler has been validated using Version 5.5 of the
Pascal Validation Suite.  It complies with FIPS PUB 109 ANSI/IEEE 770 X3.97-1983 and BS6192/ISO7185 at both level 0 and level 1.  This appendix is asummary of the validation.
Test Conditions
The Pascal Version 4.2 compiler was validated under the Solaris 2.5 operatingsystem on a SPARCstation™ 10 machine.
The following compiler options were used during each validation:
•Level 1 mode
•All checks
•Runtime trace
•All other default options
The following manufacturer’s statement of compliance is included in the
Validation Summary Report  for the architecture.
Manufacturer’s Statement of Compliance
The above processor complies with the requirements of both level 0 and level 1
(by means of a compiler switch) of BS 6192/ISO 7185, with no exceptions.
238 Pascal Language ReferenceD
Implementation-Deﬁned Features
The implementation-deﬁned features are as follows:
E.1 The value of each char-type corresponding to each allowed string-
character is the corresponding ISO 8859/1 (ASCII) character.
E.2 The subset of real  numbers denoted by signed- real  are the values
representable in the single precision (32-bit) format of the IEC559:1982Standard Binary Floating Point Arithmetic for Microprocessor Systems , which
is the same format as in the IEEE standard P754.
E.3 The values of char-type are the ISO 8859/1 (ASCII) character set.E.4 The ordinal numbers of each value of char-type are the corresponding
ISO 8859/1 (ASCII) code value.
E.5 All ﬁle operations are performed at the point where they are encountered
at execution time, with the exception of get (both explicit and where
implied by reset  andread ), which is delayed in its execution to the
point at which the ﬁle is next referenced—a technique known as “lazyI/O.”
E.6 The value of maxint  is 2,147,483,647.
E.7 The accuracy of the approximations of the real  operations and
functions is determined by the representation (see E.2) and by therounding of intermediate results.  This gives approximately 16-decimaldigits of precision.
E.8 The default value of TotalWidth  for integer-type is 10.
E.9 The default value of TotalWidth  forreal -type is 21.
E.10 The default value of TotalWidth  forboolean -type is 5.
E.11 The value of ExpDigits  is 2.
E.12 The exponent character is e.
E.13 The case in the output of the value of boolean -type is uppercase for the
initial letter, and lowercase for the remaining letters.
Pascal Validation Summary Report 239D
E.14 The procedure Page  causes the contents of the output buffer (if any) to
be written, and then outputs the ISO 8859/1 (ASCII) form-feed character.The effect on any device depends on that device.
E.15 There is no binding between physical ﬁles and program parameters of
ﬁle-type.  Variables of ﬁle-type are associated with physical ﬁles ordevices automatically by the processor.
E.16 The effects of reset  andrewrite  on the standard ﬁles input  and
output  depend on the binding of these ﬁles speciﬁed at the invocation
of the program.  In general, reset  andrewrite  have the effects
described in clause 6.6.5.2 of the Pascal Standard
1 when input  and output
have been bound to permanent ﬁles.  When the binding is to a device,reset(input)  has no effect other than discarding any partially
processed line. rewrite(output)  terminates any partially complete
line but has no other effect. rewrite(input)  andreset(output)  are
treated as errors.
E.17 This implementation supports the alternative representation of symbols
permitted by the Standard.
Reporting of Errors
The following errors are detected prior to, or during, execution of a program:
D.1, D.3, D.7, D.9, D.10, D.11, D.14, D.15, D.16, D.17, D.18, D.23, D.26, D.29,
D.33, D.34, D.35, D.36, D.37, D.40, D.41, D.42, D.45, D.46, D.47, D.49, D.51,D.52, D.53, D.54, D.55, D.56, D.57, D.58, D.59
The following errors are not, in general, reported:
D.2, D.4, D.5, D.6, D.8, D.12, D.13, D.19, D.20, D.21, D.22, D.24, D.25, D.27,
D.28, D.30, D.31, D.32, D.38, D.39, D.43, D.44, D.48, D.50
1. The American National Standard Pascal Computer Programming Language , ANSI/IEE 770 X3.97-1983,
published by the Institute of Electrical and Electronics Engineers, Inc., 345 East 47th Street, New York,NY 10017, c. 1983.
240 Pascal Language ReferenceD
Implementation-Dependent Features
Implementation-dependent features F.1 to F.11 of Pascal are treated as
undetected errors.
Extensions
The processor does not contain any extensions to BS6192/ISO 7185.  Suchextensions must be enabled by means of a compiling option, not the subject ofvalidation.
241Glossary
This glossary deﬁnes some general programming terms, as well as terms that
are speciﬁc to Pascal.
|
The bitwise or operator.
~
The bitwise not operator.
!
The bitwise or operator.
#
A programming symbol that speciﬁes an integer value in a base other than 10,
includes a ﬁle in your program, or indicates a preprocessor command.
%
A programming symbol used with the –xl option for special cppas  directives.
&
The bitwise and operator.
adb
An interactive, general-purpose, assembly-level debugger.
addr
A built-in function that returns the address of a speciﬁed variable.
242 Pascal Language Referencealfa
Anarray of char  10 characters long.
and then
An operator similar to the standard and operator.  The difference is that
and then  enforces left-to-right evaluation and evaluates the right operand
only if the left operand is true .
append
A built-in procedure that opens a ﬁle for writing at its end.
argc
A built-in function that returns the number of arguments passed to the
program.
argv
A built-in procedure that assigns the speciﬁed program argument to a string
variable.
arshft
A built-in function that does an arithmetic right shift of an integer value.
asl
A built-in function that does an arithmetic left shift of an integer value.
asr
A built-in function that does an arithmetic right shift of an integer value.  Same
asarshft .
assert
A statement which causes a boolean  expression to be evaluated and aborts
the program if false , provided that the –C option is speciﬁed.
bell
A predeclared character constant equal to char(7) , which makes the terminal
beep.
block buffering
Output buffering with a block size of 1,024.
card
A built-in function that returns the number of elements of a set variable.
clock
A built-in function that returns the user time consumed by the process.
Glossary 243close
A built-in procedure that closes a ﬁle.
compiler directive
A percent sign ( %) followed by a name indicating an action for the cppas
preprocessor to take.  Programs that contain compiler directives must becompiled with the –xl option.
concat
A built-in function that concatenates two strings.
conditional variable
A variable, either deﬁned or undeﬁned, handled by the cppas  preprocessor.  A
conditional variable is deﬁned when it appears in a %var  directive.  Programs
that contain conditional variables must be compiled with the –xl option.
%config
A compiler directive that is a special predeﬁned conditional variable with a
value of either true  orfalse .  Programs that contain the %config  directive
must be compiled with the –xl option.
cppas
The preprocessor that handles the Pascal conditional variables and compiler
directives when the -xl option is speciﬁed.
date
A built-in procedure that fetches the current date (as assigned when the
operating system was initialized) and assigns it to a string variable.
dbx
A symbolic debugger that understands Pascal, Modula-2, C, and
FORTRAN
programs.
%debug
A compiler directive that works with the -cond  compiler option.
-cond  instructs pc, the Pascal compiler, to compile the lines in your program
that begin with %debug .  Programs that contain the %debug  directive must be
compiled with the –xl option.
define  attribute
An attribute used to declare a variable that is allocated in the current module
and whose scope is public .
244 Pascal Language Referencedefine  declaration
A declaration used to declare a variable that is allocated in the current module
and whose scope is public .
discard
A built-in procedure that throws away the value a function returns.
double
Areal  data type that represents a 64-bit ﬂoating-point number.  Same as
longreal .
%else
A compiler directive that provides an alternative action to the %if directive.  If
the expression in %if isfalse , the compiler skips over the %then  part and
executes the %else  part instead.  Programs that contain the %else  directive
must be compiled with the –xl option.
%elseif
A compiler directive that provides another alternative action to the %if
directive.  If the expression in %if isfalse , the compiler skips over the %then
part and executes the %elseif  part instead.  Programs that contain the
%elseif  directive must be compiled with the –xl option.
%elseifdef
A compiler directive that provides an alternative action to the %ifdef
directive.  If the expression in %ifdef  isfalse , the compiler skips over the
%then  part and executes the %elseifdef  part instead.  Programs that contain
the%elseifdef  directive must be compiled with the –xl option.
%enable
A compiler directive that sets a conditional variable to true .  Programs that
contain the %enable  directive must be compiled with the –xl option.
%endif
A compiler directive that indicates the end of the %if or%ifdef  directive.
Programs that contain the %endif  directive must be compiled with the –xl
option.
%error
A compiler directive that prints a string on the standard output and treats it as
an error.  Programs that contain the %error  directive must be compiled with
the–xl option.
Glossary 245errout
A special predeﬁned ﬁle variable equivalent to the operating system standard
error ﬁle, stderr .
exit
A statement used in a for,while , orrepeat  loop to transfer program control
to the ﬁrst statement after the loop.
%exit
A compiler directive that causes the compiler to stop processing the current
Pascal source ﬁle.  Programs that contain the %exit  directive must be
compiled with the –xl option.
expo
A built-in function that calculates the integer-valued exponent of a speciﬁed
number.
extern  attribute
An attribute used to declare a variable that is not allocated in the current
program or module unit, but is a reference to a variable allocated in anotherunit.
extern  option
A procedure and function option that indicates the procedure or function is
deﬁned in a separate program or module unit, and possibly in a differentsource language.  Same as external .
external
A procedure and function option that indicates the procedure or function is
deﬁned in a separate program or module unit, and possibly in a differentsource language.  Same as extern .
filesize
A built-in function that returns the current size of a ﬁle.
firstof
A built-in function that returns the ﬁrst possible value of a type or variable.
flush
A built-in procedure that writes the output buffered for the speciﬁed Pascal ﬁle
into the associated operating system ﬁle.
246 Pascal Language Referencegetenv
A built-in function that returns the value associated with an environment
name.
getfile
A built-in function that returns a pointer to the C standard I/O descriptor
associated with a Pascal ﬁle.
halt
A built-in procedure that terminates program execution.
%if
A compiler directive.  When the compiler encounters a %if expression %then
directive, it evaluates expression .  If expression  istrue , the compiler executes
the statements after %then .  If expression  isfalse , the compiler skips over
%then .  Programs that contain the %if directive must be compiled with the –
xl option.
%ifdef
A compiler directive that determines whether or not a conditional variable in a
%var  directive has been previously deﬁned.  Programs that contain the
%ifdef  directive must be compiled with the –xl option.
I/O handler
A Pascal function that is passed the values err_code  andfilep  when an I/O
error occurs.  The handler returns false  to terminate the program, or true  to
continue program execution.
in
A parameter type indicating the parameter can only pass a value into a
procedure or function.
in out
A parameter type indicating the parameter can both take in values and pass
them back out.
in_range
A built-in function that checks if a value is in a deﬁned subrange.
%include
A compiler directive that instructs cppas  to insert the lines from the speciﬁed
ﬁle in the input stream.  Programs that contain the %include  directive must
be compiled with the –xl option.
Glossary 247include  ﬁle
A ﬁle that is inserted into a source ﬁle with the %include  or#include
directive.
index
A built-in function that returns the position of the ﬁrst occurrence of a string or
character in another string.
input
A special predeﬁned ﬁle variable equivalent to the standard input ﬁle, stdin .
integer16
An integer data type that represents a 16-bit value.
integer32
An integer data type that represents a 32-bit value.
internal
A procedure and function option that makes the procedure or function local to
a module.
intset
A predeﬁned set of [0..127] .
land
A built-in function that returns the bitwise and of two integers.
lastof
A built-in function that returns the last possible value of a type or variable.
length
A built-in function that returns the length of a string.
line buffering
The buffering of output line-by-line.
linelimit
A built-in procedure that terminates execution of a program after a speciﬁed
number of lines have been written into a text ﬁle.
%list
A compiler directive that enables a listing of the program.  Programs that
contain the %list  directive must be compiled with the –xl option.
248 Pascal Language Referencelnot
A built-in function that returns the bitwise not of an integer value.
longreal
Areal  data type that represents a 64-bit ﬂoating-point number.  Same as
double .
lor
A built-in function that returns the inclusive or of two integer values.
lshft
A built-in function that does a logical left shift of an integer value.
lsl
A built-in function that does a logical left shift of an integer value.  Same as
lshft .
lsr
A built-in function that does a logical right shift of an integer value.  Same as
rshft .
max
A built-in function that evaluates two scalar expression and returns the larger
one.
maxchar
A predeclared character constant equal to char(255) .
maxint
An integer constant that represents the 16-bit value 32,767 when you compile
your program with the –xl option; otherwise, maxint  represents the 32-bit
value 2,147,483,647.
message
A built-in procedure that writes the speciﬁed information on stderr , usually
the terminal.
min
A built-in function that evaluates two scalar expressions and returns the
smaller one.
minchar
A predeclared character constant equal to char(0) .
Glossary 249minint
An integer constant that represents the 16-bit value -32,768 when you compile
your program with the –xl option; otherwise, minint  represents the 32-bit
value, -2,147,483,648.
module heading
A heading that contains the reserved word module  followed by an identiﬁer.
For example, module sum;  is a legal module heading.
module unit
A source program that does not have a program header.
next
A statement used in a for,while , orrepeat  loop to skip to the next iteration
of the current loop.
%nolist
A compiler directive that disables the program listing.  Programs that contain
the%nolist  directive must be compiled with the –xl option.
nonpascal
A procedure and function option that declares non-Pascal routines when you
are porting Apollo DOMAIN  programs written in DOMAIN  Pascal,
FORTRAN , C, and C++.
null
A built-in procedure that performs no operation.
open
A built-in procedure that associates an external ﬁle with a ﬁle variable.
or else
An operator similar to the standard or operator.  The difference is that
or else  enforces left-to-right evaluation and evaluates the right operand only
if the left operand is false .
otherwise
A Pascal extension to the standard Pascal case  statement.  If the value of the
case selector is not in the case label list, Pascal executes the statements in theotherwise  clause.
out
A parameter indicating that the parameter is used to pass values out of the
routine.
250 Pascal Language Referenceoutput
A special predeﬁned ﬁle variable equivalent to the standard output ﬁle,
stdout .
private
A variable, procedure, or function declaration that restricts its accessibility to
the current compilation unit.
procedure and
function pointer
A pointer that has the address of a procedure or function as its value.
public
A variable, procedure, or function declaration that is visible across multiple
programs and modules.
random
A built-in function that generates a random number between 0.0 and 1.0.
remove
A built-in procedure that removes the speciﬁed ﬁle.
return
A statement used in a procedure or function to prematurely end the procedure
or function.
rshft
A built-in function that does a logical right shift of an integer value.
seed
A built-in function that reseeds the random number generator.
seek
A built-in procedure that resets the current position of a ﬁle.
shortreal
Areal  data type that represents a 32-bit ﬂoating point number.  Same as
single .
single
Areal  data type that represents a 32-bit ﬂoating point number.  Same as
shortreal .
Glossary 251sizeof
A built-in function that returns the number of bytes the program uses to store
a data object.
%slibrary
A compiler directive that directs cppas  to insert the lines from the speciﬁed
ﬁle in the input stream.  Same as %include .  Programs that contain the
%slibrary  directive must be compiled with the –xl option.
stradd
A built-in procedure that adds a string to the end of another string.
static
A variable attribute that declares the variable private  in scope.
stderr
The standard operating system error ﬁle.
stdin
The standard operating system input ﬁle.
stdout
The standard operating system output ﬁle.
stlimit
A built-in procedure that terminates program execution if a speciﬁed number
of statements have been executed in the current loop.
string
Anarray of char  80 characters long.
substr
A built-in function that extracts a substring from a string.
sysclock
A built-in function that returns the system time consumed by the process.
tab
A predeclared character constant equal to char(9) , which makes a tab
character.
tell
A built-in function that returns the current position of a ﬁle.
252 Pascal Language Referencetime
A built-in procedure that retrieves the current time.
trace
A built-in procedure that prints stack traceback.
trim
A built-in function that removes trailing blanks in a character string.
type transfer function
A built-in function that changes the data type of a variable, constant, or
expression.
unit
Either a program or a module.
univ
A modiﬁer used before data types in formal parameter lists to turn off type
checking for that parameter.
univ_ptr
See universal pointer.
universal pointer
A pointer used to compare a pointer of one type to another or to assign a
pointer of one type to another.
%var
A compiler directive that deﬁnes conditional variables for the preprocessor.
Programs that contain the %var  directive must be compiled with the –xl
option.
variable attribute
An attribute that determines how to allocate the variable.  Variable attributes
include static ,extern , anddefine .
variable initialization
The initialization of a real , integer, boolean , character, set, record, array, or
pointer variable in the var declaration of the program.
variable  routine option
A routine option that is used to pass a routine a smaller number of actual
arguments than the number of formal arguments deﬁned in the routine.
Glossary 253variable scope
Either private  orpublic .  Visibility of a private  variable is restricted to
the current compilation unit.  A public  variable can be referenced across
multiple programs and modules.
variable-length string
A string of variable length.  A variable-length string can be assigned a string of
any length, up to the maximum length speciﬁed in the declaration.  Pascalignores any characters speciﬁed over the maximum.
varying
A string of variable length.
wallclock
A built-in function that returns the elapsed number of seconds since
00.00.00 GMT January 1, 1970.
%warning
A compiler directive that tells the compiler to print a string on the standard
output as a warning.  Programs that contain the %warning  directive must be
compiled with the –xl option.
–xl option
An option of the pc command that causes the compiler to implement Pascal as
DOMAIN  Pascal.
xor
A built-in function that returns the exclusive or of two integers.
254 Pascal Language Reference
255Index
A
addr  function, 99, 222
alfa  data type, 34
alignment of data types, 233and operator, 2, 221
and then  operator, 69 to 70
AnswerBook, xxiiiApollo DOMAIN Pascal, 227 to 229append  function, 102, 222
argc
function, 99, 105, 222procedure, 105
argv  procedure, 99, 105, 222
arithmetic
left shift, 109operators, 66right shift, 108routines, 95
array data types, 34 to 37
alfa ,3 4
as function return value, 89conformant, 89data representation, 37declaring variables, 34initializing variables, 36string ,3 4
univ  parameter type, 89varying ,3 4
arrays, 73arshft  function, 97, 107, 171, 222
ASCII character set, 1asl function, 97, 109, 222
asr function, 97, 111, 171, 223
assert  statement, 48, 221
assignment statement, 13, 18, 20, 22assignments, 63 to 65
compatibility rules, 64data types, 63extensions, 221null strings, 65string constants, 65strings, to and from, 64
B
–b option to pc command, 214
bell  character, 23, 220
bit operators, 66bitwise operators, 151
and, 2, 221
not, 201, 221
or, 2, 201, 221
block buffering, 214boolean
expression, 48
256 Pascal Language Referenceoperators, 66
and then , 69 to 70
or else ,7 1
boolean  data types, 20 to 21
assignment compatibility rules, 63declaring constants, 21declaring variables, 20initializing variables, 20
buffering
block, 214ﬁle output, 213line, 214
built-in procedures and functions, 2
nonstandard, 95 to 201, 203, 222standard, 95, 203
C
–C option to pc command, 48, 218
C programming language, 94, 204card  function, 96, 112, 223
case  statement, 48, 51 to 52, 157, 221
otherwise  clause, 51, 58
range of constants, 52with–xl option, 51
character
data type, 23
assignment compatibility
rules, 63
bell , 23, 220
data representation, 23declaring constants, 23declaring variables, 22maxchar , 23, 220
minchar , 23, 220
tab, 23, 220
set, 1string routines, 97
clock  function, 99, 113, 223
close  procedure, 98, 116, 204, 223
comments, 6, 48, 214, 219concat  function, 117, 223
conformant array, 89const  declaration, 77, 79, 222conventions, typographical, xxii
D
data structure, 213
data types
alignment, 233array, 34 to 37assignments, 63boolean , 20 to 22
enumerated, 24extensions, 220ﬁle, 41integer, 232internal representation
with–xl, 235
without –xl, 234
pointer, 41 to 45, 80real, 231real , 13 to 15
record, 27 to 33set, 38 to 39size restrictions, 232space allocation, 232subrange, 25
date  procedure, 99, 118, 223
declarations, 77 to 84
const , 79, 222
define , 222
extensions, 221label , 222
type , 222
var, 14, 18, 27, 80 to 83
default ﬁeld widths, 236define
declaration, 83, 222variable, 80, 222
discard  procedure, 99, 120, 223
documentation, xxiii to xxivDOMAIN Pascal, 227 to 229
features accepted but ignored, 227,
228
features not supported, 229–xl option, 227
Index 257double  data type, 13, 220, 232
E
enumerated data, 23, 24
assignment compatibility rules, 63data representation, 24withread  andreadln
procedures, 23
withwrite  andwriteln
procedures, 23
eof function, 135, 204 to 207
eoln  function, 135, 204 to 209
error
ﬁle,stderr , 212
recovery of input and output, 214
errout  ﬁle variable, 211
exit  statement, 52 to 53, 221
expo  function, 96, 123, 223
extensions, 219 to 225
assignments and operators, 221built-in routines, 222data types, 220heading and declarations, 221input and output, 225lexical elements, 219procedures and functions, 222program compilation, 225statements, 221
extern
option, 92, 222variable, 82, 84, 222
external  option, Seeextern  option
F
ﬁeld widths, default, 236
ﬁle
permanent, 210stderr ,2 1 1
stdin , 212
stdout ,2 1 1
temporary, 211
ﬁle data type, 41with–s option, 41
with–V0 and–V1 options, 41
ﬁle identiﬁers
input ,1 1 7
output ,1 1 7
ﬁle variable, 210
errout ,2 1 1
input ,2 1 1
output ,2 1 1
ﬁles
external and Pascal ﬁle variables, 210how to close, 117permanent and temporary, 210
filesize  function, 124, 223
firstof  function, 96, 126, 223
flush  procedure, 98, 130, 204, 213, 223
for statement, 52, 56, 221
formal parameter, 88, 92FORTRAN programming language, 94forward  option, 91
function
addr ,9 9
append , 102
argc , 99, 105
arshft , 97, 107, 171
asl, 97, 109
asr, 97, 111, 171
association with define
declaration, 84
built-in, 95card , 96, 112
clock , 99, 113
concat ,1 1 7
declarations, 77eof, 135, 204 to 207
eoln , 135, 204 to 209
expo , 96, 123
extensions, 222extern  option, 92
external  option, 92
filesize , 124, 223
firstof , 96, 126
forward  option, 92
getenv , 99, 132
258 Pascal Language Referencegetfile , 98, 134, 204, 215
in_range , 138
index , 97, 139
internal  option, 92
land , 97, 142
lastof , 144
length , 97, 145
lnot , 97, 149
lor, 97, 150
lshft , 97, 152
lsl, 97, 153
lsr, 97, 153
max, 96, 153
min, 96, 156
nonpascal  option, 94
parameters, 85 to 88private , 84, 92, 222
public , 84, 222
random , 96, 162
return  statement, 59 to 60
return value, 89, 121returning structured types, 222rshft , 97, 171
seed , 96, 172
sizeof , 96, 176
substr , 97, 183
sysclock , 99, 114, 184
tell , 224
time , 185
trim , 97, 191, 225
type transfer, 99, 193var declaration, 14, 18, 21, 23, 28
variable  option, 92
wallclock , 99, 195
xor, 97, 200
G
getenv  function, 99, 132, 223
getfile  function, 98, 134, 204, 215, 223
global variable, 81goto  statement, 48, 54, 59, 221
exiting current block, 54use of identiﬁer in, 54H
halt  procedure, 99, 136, 223
headings
extensions, 221function, 84program, 210
I
identiﬁers, 2, 4, 54, 59
aslabels ,7 7
indefine  declaration, 83
nonstandard predeclared, 4, 220restrictions to, 231standard predeclared, 4, 220
if statement, 48, 208, 221
implementation restrictions, 231 to 236in out  parameter, 85, 88
in parameter, 85, 88, 215
in_range  function, 138, 223
include  directive and statement, 216
index  function, 97, 139, 223
initializing variables, 83input
environment, 203 to 218error recovery, 214extensions, 225ﬁle
stdin , 212
variable, 211
input and output
library, 212routines, nonstandard and
standard, 204
trap handler, 215
integer data types, 16 to 20
assignment compatibility rules, 63data representation, 19declaring constants, 18integer ,1 7
integer16 , 17, 220
integer32 , 220
maxint , 232
minint , 19, 232
Index 259specifying in another base, 19
unsigned  integer, 17
integer16 , 20, 220
integer32 , 17, 20, 220
interactive programming, 203internal  option, 92, 222
ioerr.h  ﬁle, 215
K
keywords, 2
L
–L option to pc command, 2, 228
label  declaration, 77, 222
land  function, 97, 142, 223
lastof  function, 144, 223
length  function, 97, 145, 223
lexical
characters, 1elements, 1
line buffering, 214linelimit  procedure, 98, 147, 204, 223
lnot  function, 97, 149, 223
local variable, 80, 81, 100longreal , 220
lor function, 97, 150, 224
lowercase characters, mapping, 2lshft  function, 97, 151, 224
lsl function, 97, 153
lsr function, 97, 153, 224
M
manuals, See documentation
mapping to lowercase characters, 2max function, 153, 224
maxchar , 23, 220
message  procedure, 98, 155, 204, 213, 224
min function, 96, 156, 224
minchar , 23, 220mod operators, 66
modules
extern  orexternal  option, 92, 222
extern  variables, 82, 84
public  andprivate  routines, 84
scope of variables, 80
N
nested routines, 235
next  statement, 56
nil,7 9
nonpascal  option, 94, 222
nonstandard special symbols
!, 2, 219
#, 2, 219
%, 2, 219
&, 2, 219
|, 2, 219
~, 2, 219
not operator, 2, 201, 221
null  procedure, 99, 157, 224
null string assignments, 65
O
open  procedure, 98, 117, 158, 204, 210, 224
operators, 66 to 76, 79
and, 2, 221
and then , 69 to 70
arithmetic, 66bit, 66, 68boolean , 66, 68
extensions, 221mod,6 6
not, 2, 201, 221
or, 2, 201, 221
or else ,7 0
precedence of, 76relational, 66, 72set, 66, 71string, 66, 75
options for routines, 91 to 94
extern  orexternal , 92, 222
internal ,9 2
260 Pascal Language Referencenonpascal , 94, 227
variable ,9 2
or else  operator, 70
or operator, 2, 201, 221
otherwise  clause in case  statement, 51,
58
out parameter, 85, 88
output
environment, 203 to 218error recovery, 214extensions, 225ﬁle
buffering, 213stdout , 212
variable, 211
P
packed records, 30
parameters, 84 to 89
formal, 86, 88, 92in, 85, 88, 215
in out , 85, 88
out, 85, 88
passing conventions, 86type checking, 88univ  type, 88
value, 86var, 86, 88
Pascal
extensions in the compiler, xixsymbols, 2validation summary, 237 to 240
pc command
–b option, 214
–C option, 48, 218
document reference, 2–L option, 2, 228
–s option, 2, 3
–V0 option, 3
–V1 option, 3
–xl option, 9, 17, 24, 94, 227, 234
pcexit  procedure, 99
pointer data type, 41 to 45assignment compatibility rules, 63
data representation, 45declaring variables, 42initializing variables, 45procedure and function, 43, 80univ_ptr ,4 2
universal, 80
precedence of operators, 76private
function, 84procedure, 84variable, 81, 222
procedure
append , 222
argc , 105
argv , 99, 105
association with define
declaration, 84
built-in, 95close , 98, 116, 204
date , 99, 118
declarations, 77discard , 99, 120
extensions, 222extern  option, 92
external  option, 92
flush , 98, 130, 204, 213
forward  option, 92
halt , 99, 136
internal  option, 92
linelimit , 98, 147, 204
message , 98, 155, 204, 213
nonpascal  option, 94
null , 99, 157
open , 98, 117, 158, 204, 210
parameters, 85 to 89pcexit ,9 9
private , 92, 222
public , 222
read , 23, 98, 163, 204, 205, 207, 209,
211
readln , 23, 98, 135, 163, 204, 207, 209,
211
remove , 98, 166, 204
reset , 98, 117, 135, 167, 204, 212
Index 261return  statement, 59
rewrite , 98, 135, 168, 204, 211
seek , 174, 224
stlimit , 99, 180
stradd , 182, 224
time , 99, 187
trace , 225
var declaration, 14, 21, 23, 28, 36, 39,
83
variable  option, 92
write , 24, 98, 155, 198, 204, 211, 212
writeln , 24, 98, 155, 198, 204, 211,
212
program
compilation extensions, 225headings, 210unit, 84
public
function, 84procedure, 84variable, 81, 84, 222
R
random  function, 162, 224
read  procedure, 23, 98, 163, 204, 205, 207,
209, 211, 224
readln  procedure, 23, 98, 135, 163, 207,
209, 211, 224
real  data types, 13 to 15
as function return value, 89data representation, 15declaring
constants, 14variables, 13
double , 13, 220, 232
longreal , 13, 220
real , 13, 15
shortreal , 13, 15, 220
single , 13, 15, 220, 232
with–xl option, 13, 17
record data type, 26 to 33
as function return value, 89assignment compatibility rules, 63declaring variables, 26initializing
data, 27variables, 83
representation of unpacked
records, 30
records, 73relational operators, 66, 72remove  procedure, 98, 166, 204, 224
repeat  statement, 52, 56, 221
reserved words, 3
nonstandard extensions, 4standard, 3
reset  procedure, 98, 117, 135, 167, 204,
212, 224
return  statement, 59, 221
rewrite  procedure, 98, 117, 135, 168, 204,
211, 225
routine
addr , 96, 99, 222
append , 98, 102
argc , 99, 105, 222
argv , 99, 105, 222
arithmetic, 95arshft , 97, 108, 171, 222
asl, 97, 110, 222
asr, 97, 171, 223
built-in, 95 to 201card , 96, 112, 223
clock , 99, 114, 223
close , 98, 116, 204, 223
concat , 97, 223
date , 99, 118, 223
discard , 121, 223
eof, 135, 204 to 207
eoln , 135, 204 to 209
expo , 96, 123, 223
extern  option, 92
external  option, 92
filesize ,9 8
firstof , 96, 126, 223
flush , 98, 130, 204, 213, 223
forward  option, 91
getenv , 99, 223
getfile , 98, 135, 204, 215, 223
262 Pascal Language Referencehalt , 99, 136, 223
in_range , 96, 138, 223
index , 97, 139, 140, 223
input and output, 203internal  option, 92
land , 97, 142, 223
lastof , 96, 144, 223
length , 97, 146, 223
linelimit , 98, 147, 204, 223
lnot , 97, 149, 223
lor, 97, 150, 224
lshft , 97, 152, 224
lsl, 97, 153
lsr, 97, 153, 224
max, 96, 224
message , 98, 155, 204, 213, 224
min, 96, 157, 224
nonpascal  option, 94
null , 99, 157, 224
open , 98, 117, 158, 204, 210, 224
parameters, 85 to 89private , 84, 92
public ,8 4
random , 96, 162, 224
read , 98, 163, 204, 205, 207, 209, 211,
224
readln , 98, 135, 163, 204, 207, 209,
211, 224
remove , 98, 166, 204, 224
reset , 98, 117, 135, 167, 204, 212, 224
return  statement, 59
rewrite , 98, 117, 135, 169, 204, 211,
225
rshft , 97, 171, 224
seed , 96, 172, 224
seek ,9 8
sizeof , 96, 176, 224
stlimit , 99, 180, 224
stradd ,9 7
substr , 97, 183, 224
sysclock , 99, 114, 184, 224
tell , 98, 185, 224
time , 99, 187, 224
trace , 99, 189, 225
trim , 97, 191, 225
type transfer, 99, 193, 225var declaration, 36, 39
variable  option, 92
wallclock , 99, 195, 225
write , 98, 155, 198, 204, 211, 212, 225
writeln , 98, 155, 198, 204, 211, 212,
225
xor, 97, 200, 225
routine parameters, 85 to 89routines, 79rshft  function, 97, 171, 224
S
–s option to pc command, 2, 3
scope of variables
private ,8 0
public ,8 0
seed  function, 162, 172, 224
seek  procedure, 174, 224
set
data types, 38 to 39
as function return value, 91assignment compatibility
rules, 63
data representation, 39declaring variables, 38returning number of
elements, 112
initializing variables, 83operators, 66, 71
shortreal , 13, 15, 220
signal handler, 214single , 13, 15, 220, 232
sizeof  function, 176, 224
space allocation of data types, 233special symbols, nonstandard and
standard, 2
standard ﬁles
error, 212input, 212output, 212
statements, 47 to 62
assert , 48, 221
case , 47, 51 to 52, 157, 221
Index 263exit , 52 to 53, 221
extensions, 221for, 52, 56, 221
goto , 48, 54, 59, 221
if, 48, 208, 221
next ,5 6
repeat , 52, 56, 221
return , 59, 221
while , 52, 56, 206, 209, 221
with , 47, 60, 221
static  variable, 14, 18, 21, 23, 28, 37, 39,
83, 222
stderr , 204, 211
stdin , 212
stdout ,2 1 1
stlimit  procedure, 99, 180, 224
stradd  procedure, 182, 224
string
assignments, 64constants, assignments, 65data type, 34operators, 66, 75
subrange data, 17, 25 to 26
assignment compatibility rules, 63data representation, 25declaring variables, 25with–xl option, 26
substr  function, 97, 183, 224
symbols, 2sysclock  function, 99, 114, 184, 224
T
tab character, 23, 220
tell  function, 185, 224
time  procedure, 99, 187, 224
trace  procedure, 225
trace  routine, 189
trim  function, 97, 191, 225
type checking of parameters, 88type  declaration, 222
type transfer function, 193, 225typographical conventions, xxiiU
univ  parameter, 85
univ  parameter type, 88
univ_ptr , 42, 100, 135
unpacked records
ﬁxed, 30variant, 30
unsigned  integer, 17
V
–V0 option to pc command, 3
–V1 option to pc command, 3
value parameter, 86, 88value  parameter, 85
var
declaration, 14, 18, 20, 22, 27, 36, 80 to
83, 222
attributes, 80initialization, 83scope, 80
parameter, 86, 88
var parameter, 85
variable
attributes, 80define , 81, 83, 222
extern , 81, 82, 84, 222
global, 80initialization, 83local, 80, 83, 100option, 92, 222private , 80, 222
public , 80, 81, 83, 222
scope, 80static , 81, 222
varying  data type, 34
W
wallclock  function, 99, 195, 225
while  statement, 52, 56, 206, 209, 221
with
alternate form, 60 to 62statement, 48, 221
264 Pascal Language Referencewrite  procedure, 23, 98, 155, 198, 204,
211, 212, 225
writeln  procedure, 23, 98, 155, 198, 204,
211, 212, 225
X
–xl option to pc command, 9, 17, 24, 227
withdefine  attribute, 83
withnonpascal  routine option, 94
xor function, 97, 200, 225
Copyright 1996 Sun Microsystems, Inc., 2550 Garcia Avenue, Mountain View, Californie 94043-1100, U.S.A. Tous droits
réservés.
Ce produit ou document est protégé par un copyright et distribué avec des licences qui en restreignent l’utilisation, la copie,
la distribution, et la décompilation. Aucune partie de ce produit ou de sa documentation associée ne peut être reproduite sousaucune forme, par quelque moyen que ce soit, sans l’autorisation préalable et écrite de Sun et de ses bailleurs de licence, s’i l
y en a.
Des parties de ce produit pourront être dérivées du système UNIX
® licencié par Novell, Inc. et du système Berkeley 4.3 BSD
licencié par l’Université de Californie. UNIX est une marque enregistrée aux Etats-Unis et dans d’autres pays et licenciéeexclusivement par X/Open Company Ltd. Le logiciel détenu par des tiers, et qui comprend la technologie relative aux policesde caractères, est protégé par un copyright et licencié par des fournisseurs de Sun.
Sun, Sun Microsystems, le logo Sun, SunSoft, Solaris, le Sun Microsystems Computer Corporation logo, le SunSoft logo,
ProWorks, ProWorks/TeamWare, ProCompiler, Sun-4, SunOS, ONC, ONC+, NFS, OpenWindows, DeskSet, ToolTalk, SunView,XView, X11/NeWS, et AnswerBook sont des marques déposées ou enregistrées de Sun Microsystems, Inc. aux Etats-Unis et dansd’autres pays. Toutes les marques SPARC, utilisées sous licence, sont des marques déposées ou enregistrées de SPARCInternational, Inc. aux Etats-Unis et dans d’autres pays. Les produits portant les marques SPARC sont basés sur une architectur e
développée par Sun Microsystems, Inc. PostScript et Display PostScript sont des marques déposées de Adobe Systems, Inc.PowerPC™ est une marque déposée de International Business Machines Corporation. HP
® and HP-UX® sont des marques
enregistrées de Hewlett-Packard Company.
Les interfaces d’utilisation graphique OPEN LOOK® et Sun™ ont été développées par Sun Microsystems, Inc. pour ses
utilisateurs et licenciés. Sun reconnaît les efforts de pionniers de Xerox pour la recherche et le développement du concept desinterfaces d’utilisation visuelle ou graphique pour l’industrie de l’informatique. Sun détient une licence non exclusive deXerox sur l’interface d’utilisation graphique Xerox, cette licence couvrant aussi les licenciés de Sun qui mettent en placel’interface d’utilisation graphique OPEN LOOK et qui en outre se conforment aux licences écrites de Sun.
CETTE PUBLICATION EST FOURNIE “EN L’ETAT” SANS GARANTIE D’AUCUNE SORTE, NI EXPRESSE NI IMPLICITE,
Y COMPRIS, ET SANS QUE CETTE LISTE NE SOIT LIMITATIVE, DES GARANTIES CONCERNANT LA VALEURMARCHANDE, L’APTITUDE DES PRODUITS A RÉPONDRE A UNE UTILISATION PARTICULIERE, OU LE FAIT QU’ILSNE SOIENT PAS CONTREFAISANTS DE PRODUITS DE TIERS.


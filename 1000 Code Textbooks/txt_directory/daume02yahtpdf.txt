YetAnotherHaskellTutorial
HalDaum ¬¥eIII
Copyright (c)HalDaume III,2002-2006. The preprint version ofthistutorial is
intended tobefreetotheentire Hask ellcommunity ,sowegrant permission tocopy
anddistrib uteitforanypurpose, provided thatitisreproduced initsentirety ,in-
cluding thisnotice. ModiÔ¨Åed versions may notbedistrib uted without prior concent
oftheauthor ,andmust stillmaintain acopyofthisnotice. Theauthor retains the
right tochange ormodify thiscopyright atanytime, aswell astomakethebook no
longer freeofcharge.
AboutThisReport
The goal oftheYetAnother Hask ellTutorial istoprovide acomplete intoduction to
theHask ellprogramming language. Itassumes noknowledge oftheHask elllanguage
orfamiliarity with functional programming ingeneral. However,general familiarity
with programming concepts (such asalgorithms) willbehelpful. This isnotintended
tobeanintroduction toprogramming ingeneral; rather ,toprogramming inHask ell.
SufÔ¨Åcient familiarity with your operating system andatexteditor isalso necessary
(this report only discusses installation onconÔ¨Åguration onWindowsand*Nix system;
other operating systems may besupported ‚Äìconsult thedocumentation ofyour chosen
compiler formore information oninstalling onother platforms).
What isHask ell?
Hask elliscalled alazy,pure functional programming language. Itiscalled lazy be-
cause expressions which arenotneeded todetermine theanswer toaproblem arenot
evaluated. The opposize oflazy isstrict ,which istheevaluation strate gryofmost
common programming languages (C,C++, Java,evenML). Astrict language isonein
which everyexpression isevaluated, whether theresult ofitscomputation isimportant
ornot. (This isprobably notentirely trueasoptimizing compilers forstrict languages
often dowhat‚Äô scalled ‚Äúdead code elmination‚Äù ‚Äìthisremo vesunused expressions from
theprogram.) Itiscalled purebecause itdoes notallowside effects (Aside effect
issomething thataffects the‚Äústate‚Äù oftheworld. Forinstance, afunction thatprints
something tothescreen issaid tobeside-ef fecting, asisafunction which affects the
value ofaglobal variable.) ‚Äìofcourse, aprogramming language without side effects
would behorribly useless; Hask elluses asystem ofmonads toisolate allimpure com-
putations from therestoftheprogram andperform them inthesafeway(seeChapter 9
foradiscussion ofmonads proper orChapter 5forhowtodoinput/output inapure
language).
Hask elliscalled afunctional language because theevaluation ofaprogram is
equivalent toevaluating afunction inthepure mathematical sense. This also differs
from standard languages (likeCandJava)which evaluate asequence ofstatements,
oneafter theother (this istermed animper ative langauge).
i
ii
The History ofHask ell
Thehistory ofHask ellisbestdescribed using thewords oftheauthors. Thefollowing
textisquoted from thepublished version oftheHask ell98Report:
InSeptember of1987 ameeting washeld attheconference onFunctional
Programming Languages andComputer Architecture (FPCA ‚Äô87) inPort-
land, Oregon, todiscuss anunfortunate situation inthefunctional pro-
gramming community: there hadcome intobeing more than adozen non-
strict, purely functional programming languages, allsimilar inexpressi ve
powerandsemantic underpinnings. There wasastrong consensus atthis
meeting thatmore widespread useofthisclass offunctional languages was
being hampered bythelack ofacommon language. Itwasdecided thata
committee should beformed todesign such alanguage, providing faster
communication ofnewideas, astable foundation forrealapplications de-
velopment, andavehicle through which others would beencouraged to
usefunctional languages. This document describes theresult ofthatcom-
mittee‚Äô sefforts: apurely functional programming language called Hask ell,
named after thelogician Hask ellB.Curry whose workprovides thelogical
basis formuch ofours.
Thecommittee‚Äô sprimary goal wastodesign alanguage thatsatisÔ¨Åed these
constraints:
1.Itshould besuitable forteaching, research, andapplications, includ-
ingbuilding largesystems.
2.Itshould becompletely described viathepublication ofaformal
syntax andsemantics.
3.Itshould befreely available. Anyone should bepermitted toimple-
ment thelanguage anddistrib uteittowhome vertheyplease.
4.Itshould bebased onideas thatenjoyawide consensus.
5.Itshould reduce unnecessary diversity infunctional programming
languages.
The committee intended that Hask ellwould serveasabasis forfuture
research inlanguage design, andhoped thatextensions orvariants ofthe
language would appear ,incorporating experimental features.
Hask ellhasindeed evolvedcontinuously since itsoriginal publication. By
themiddle of1997, there hadbeen four iterations ofthelanguage design
(thelatest atthatpoint being Hask ell1.4). Atthe1997 Hask ellWorkshop
inAmsterdam, itwasdecided thatastable variant ofHask ellwasneeded;
thisstable language isthesubject ofthisReport, andiscalled ‚ÄúHask ell
98‚Äù.
Hask ell98wasconcei vedasarelati velyminor tidy-up ofHask ell1.4,
making some simpliÔ¨Åcations, andremo ving some pitfallsfortheunwary.
iii
Itisintended tobea‚Äústable‚Äù language insense theimplementor sarecom-
mitted tosupporting Hask ell98exactly asspeciÔ¨Åed, fortheforeseeable
futur e.
The original Hask ellReport covered only thelanguage, together with a
standard library called thePrelude. Bythetime Hask ell98wasstabilised,
ithadbecome clear thatmanyprograms need access toalargersetofli-
brary functions (notably concerning input/output andsimple interaction
with theoperating system). Ifthese program were tobeportable, asetof
libraries would havetobestandardised too. Aseparate effortwasthere-
forebegunbyadistinct (butoverlapping) committee toÔ¨ÅxtheHask ell98
Libraries.
WhyUseHask ell?
Clearly you‚Äôreinterested inHask ellsince you‚Äôrereading thistutorial. There aremany
motivations forusing Hask ell. Mypersonal reason forusing Hask ellisthatIhave
found thatIwrite more bug-free code inlesstime using Hask ellthan anyother lan-
guage. IalsoÔ¨Ånditveryreadable andextensible.
Perhaps most importantly ,however,Ihaveconsistently found theHask ellcommu-
nity tobeincredibly helpful. The language isconstantly evolving (that‚Äô snottosay
it‚Äôsinstable; rather thatthere arenumerous extensions thathavebeen added tosome
compilers which IÔ¨Åndveryuseful) anduser suggestions areoften heeded when new
extensions aretobeimplemented.
WhyNotUseHask ell?
Mytwobiggest complaints, andthecomplaints ofmost Hask ellers Iknow,are:(1)the
generated code tends tobeslowerthan equivalent programs written inalanguage like
C;and(2)ittends tobedifÔ¨Åcult todebug.
Thesecond problem tends notbetoaverybigissue: most ofthecode I‚Äôvewritten
isnotbuggy ,asmost ofthecommon sources ofbugsinother languages simply don‚Äôt
existinHask ell.TheÔ¨Årstissue certainly hascome upafewtimes inmyexperience;
however,CPU time isalmost alwayscheaper than programmer time andifIhaveto
waitalittle longer formyresults after having savedafewdays programming and
debugging.
Ofcourse, thisisn‚Äôtthecase ofallapplications. Some people may Ô¨Ånd thatthe
speed hittakenforusing Hask ellisunbearable. However,Hask ellhasastandardized
foreign-function interface which allowyoutolinkincode written inother languages,
forwhen you need togetthemost speed outofyour code. Ifyou don‚ÄôtÔ¨Ånd this
sufÔ¨Åcient, Iwould suggest taking alook atthelanguage O‚ÄôCaml, which often out-
performs evenC++, yetalsohasmanyofthebeneÔ¨Åts ofHask ell.
iv
TargetAudience
There havebeen manybooks andtutorials written about Hask ell;fora(nearly) com-
plete list,visit thehttp://haskell.org/bookshelf (Hask ellBookshelf) atthe
Hask ellhomepage. Abrief surveyofthetutorials available yields:
AGentle Introduction toHask ellisanintroduction toHask ell,giventhatthe
reader isfamiliar with functional programming enlarge.
Hask ellCompanion isashort reference ofcommon concepts anddeÔ¨Ånitions.
Online Hask ellCour seisashort course (inGerman) forbeginning with Hask ell.
TwoDozen Short Lessons inHask ellisthedraft ofanexcellent textbook that
emphasizes user involvement.
Hask ellTutorial isbased onacourse givenatthe3rdInternational Summer
School onAdvanced Functional Programming.
Hask ellforMiranda Programmer sassumes knowledge ofthelanguage Miranda.
PLEA C-Hask ellisatutorial inthestyle ofthePerlCookbook.
Though allofthese tutorials isexcellent, theyareontheir ownincomplete: The
‚ÄúGentle Introduction‚Äù isfartooadvanced forbeginning Hask ellers andtheothers tend
toendtooearly ,ornotcovereverything. Hask ellisfullofpitfallsfornewprogrammers
andexperienced non-functional programmers alike,ascanbewitnessed byreading
through thearchi vesoftheHask ellmailing list.
Itbecame clear thatthere isastrong need foratutorial which isintroductory inthe
sense thatitdoes notassume knowledge offunctional programming, butwhich isad-
vanced inthesense thatitdoes assume some background inprogramming. Moreo ver,
none oftheknowntutorials introduce input/output anditeracti vitysoon enough (Paul
Hudak‚Äô sbook isanexception inthatitdoes introduce IObypage 35,though thefocus
andaimofthatbook andthistutorial areverydifferent). This tutorial isnotforbegin-
ning programmers; some experience andknowledge ofprogramming andcomputers is
assumed (though theappendix does contain some background information).
TheHask elllanguage underwent astandardization process andtheresult iscalled
Hask ell98.The majority ofthisbook will covertheHask ell98standard. Anyde-
viations from thestandard will benoted (forinstance, manycompilers offercertain
extensions tothestandard which areuseful; some ofthese may bediscussed).
Thegoals ofthistutorial are:
tobepractical aboveallelse
toprovide acomprehensi ve,freeintroduction totheHask elllanguage
topoint outcommon pitfallsandtheir solutions
toprovide agood sense ofhowHask ellcanbeused intherealworld
v
Additional Online Sour cesofInformation
AShort Introduction toHask ell:
http://haskell.org/aboutHaskell.html
Hask ellWiki:
http://haskell.org/hawiki/
Hask ell-T utorial :
ftp://ftp.geoinfo.tuwien.ac.at/navratil/HaskellTutorial.
pdf
TouroftheHask ellPrelude :
http://www.cs.uu.nl/Àúafie/haskell/tourofprelude.html
Courses inHask ell:
http://haskell.org/classes/
Ackno wledgements
Itwould beinappropriate nottogivecredit also totheoriginal designers ofHask ell.
Those are: Arvind, Lennart Augustsson, DaveBarton, Brian Boutel, Warren Burton,
JonFairbairn, Joseph Fasel, Andy Gordon, Maria Guzman, KevinHammond, Ralf
Hinze, PaulHudak, John Hughes, Thomas Johnsson, Mark Jones, Dick Kieb urtz, John
Launchb ury,Erik Meijer ,Rishiyur Nikhil, John Peterson, Simon Peyton Jones, Mike
Reeve,Alastair Reid, Colin Runciman, Philip Wadler ,DavidWise,Jonathan Young.
Finally ,Iwould liketospeciÔ¨Åcally thank Simon Peyton Jones, Simon Marlo w,
John Hughes, Alastair Reid, KoenClassen, Manuel Chakra varty,Sigbjorn Finne and
SvenPanne, allofwhom havemade mylifelearning Hask ellallthemore enjoyable by
alwaysbeing supporti ve.There were doubtless others who helped andarenotlisted,
butthese arethose who come tomind.
Also thanks tothemanypeople who havereported ‚Äúbugs‚Äù intheÔ¨Årstedition.
-HalDaum ¬¥eIII
vi
Contents
1Introduction 3
2Getting Started 5
2.1 Hugs ................................... 5
2.1.1 Where togetit......................... 6
2.1.2 Installation procedures ..................... 6
2.1.3 Howtorunit.......................... 6
2.1.4 Program options ........................ 7
2.1.5 Howtogethelp ......................... 7
2.2 Glasgo wHask ellCompiler ....................... 7
2.2.1 Where togetit......................... 7
2.2.2 Installation procedures ..................... 8
2.2.3 Howtorunthecompiler .................... 8
2.2.4 Howtoruntheinterpreter ................... 8
2.2.5 Program options ........................ 9
2.2.6 Howtogethelp ......................... 9
2.3 NHC ................................... 9
2.3.1 Where togetit......................... 9
2.3.2 Installation procedures ..................... 9
2.3.3 Howtorunit.......................... 9
2.3.4 Program options ........................ 9
2.3.5 Howtogethelp ......................... 9
2.4 Editors .................................. 9
3Language Basics 11
3.1 Arithmetic ................................13
3.2 Pairs, Triples andMore .........................14
3.3 Lists ...................................15
3.3.1 Strings .............................17
3.3.2 Simple ListFunctions .....................18
3.4 Source Code Files ............................20
3.5 Functions ................................22
3.5.1 LetBindings ..........................27
3.5.2 InÔ¨Åx ...............................28
vii
viii CONTENTS
3.6 Comments ................................28
3.7 Recursion ................................29
3.8 Interacti vity ...............................31
4TypeBasics 37
4.1 Simple Types ..............................37
4.2 Polymorphic Types ...........................39
4.3 TypeClasses ..............................40
4.3.1 Moti vation ...........................40
4.3.2 Equality Testing ........................41
4.3.3 TheNum Class .........................41
4.3.4 TheShowClass .........................41
4.4 Function Types .............................42
4.4.1 Lambda Calculus ........................42
4.4.2 Higher -Order Types ......................42
4.4.3 That PeskyIOType.......................44
4.4.4 Explicit TypeDeclarations ...................45
4.4.5 Functional Arguments .....................46
4.5 Data Types ...............................47
4.5.1 Pairs...............................47
4.5.2 Multiple Constructors .....................49
4.5.3 Recursi veDatatypes ......................51
4.5.4 Binary Trees ..........................51
4.5.5 Enumerated Sets ........................52
4.5.6 TheUnit type ..........................53
4.6 Continuation Passing Style .......................53
5Basic Input/Output 57
5.1 TheRealW orldSolution ........................57
5.2 Actions .................................58
5.3 TheIOLibrary .............................62
5.4 AFileReading Program ........................64
6Modules 67
6.1 Exports .................................67
6.2 Imports .................................69
6.3 Hierarchical Imports ..........................70
6.4 Literate Versus Non-Literate ......................71
6.4.1 Bird-scripts ...........................71
6.4.2 LaTeX-scripts ..........................72
7Advanced Featur es 73
7.1 Sections andInÔ¨Åx Operators ......................73
7.2 Local Declarations ...........................74
7.3 Partial Application ...........................76
7.4 Pattern Matching ............................80
CONTENTS ix
7.5 Guards ..................................83
7.6 Instance Declarations ..........................85
7.6.1 TheEqClass ..........................85
7.6.2 TheShow Class ........................86
7.6.3 Other Important Classes ....................87
7.6.4 Class Conte xts .........................89
7.6.5 Deriving Classes ........................89
7.7 Datatypes Revisited ...........................90
7.7.1 Named Fields ..........................90
7.8 More Lists ................................92
7.8.1 Standard ListFunctions ....................92
7.8.2 ListComprehensions ......................94
7.9 Arrays ..................................96
7.10 Finite Maps ...............................97
7.11 Layout ..................................99
7.12 TheFinal WordonLists ........................99
8Advanced Types 103
8.1 TypeSynon yms .............................103
8.2 Newtypes ................................104
8.3 Datatypes ................................105
8.3.1 Strict Fields ...........................105
8.4 Classes .................................108
8.4.1 Pong ..............................108
8.4.2 Computations ..........................109
8.5 Instances ................................113
8.6 Kinds ..................................115
8.7 Class Hierarchies ............................117
8.8 Default .................................117
9Monads 119
9.1 DoNotation ...............................120
9.2 DeÔ¨Ånition ................................122
9.3 ASimple State Monad .........................124
9.4 Common Monads ............................130
9.5 Monadic Combinators .........................134
9.6 MonadPlus ...............................137
9.7 Monad Transformers ..........................139
9.8 Parsing Monads .............................144
9.8.1 ASimple Parsing Monad ....................144
9.8.2 Parsec ..............................151
CONTENTS 1
10Advanced Techniques 157
10.1 Exceptions ................................157
10.2 Mutable Arrays .............................157
10.3 Mutable References ...........................157
10.4 TheSTMonad .............................157
10.5 Concurrenc y...............................157
10.6 Regular Expressions ..........................157
10.7 Dynamic Types .............................157
ABrief Complexity Theory 159
BRecursion andInduction 161
CSolutions ToExer cises 163
2 CONTENTS
Chapter1
Introduction
This tutorial contains awhole host ofexample code, allofwhich should havebeen
included initsdistrib ution. Ifnot,please refer tothelinks offoftheHask ellweb site
(haskell.org )togetit.This book isformatted tomakeexample code stand out
from therestofthetext.
Codewilllooklikethis.
Occasionally ,wewill refer tointeraction betwen you andtheoperating system
and/or theinteracti veshell (more onthisinSection 2).
Interaction willlooklikethis.
Strewnthroughout thetutorial, wewilloften makeadditional notes tosomething
written. These areoften formaking comparisons toother programming languages or
adding helpful information.
NOTE Notes willappear likethis.
Ifwe‚Äôrecovering adifÔ¨Åcult orconfusing topic andthere issomething youshould
watch outfor,wewillplace awarning.
WARNING Warnings willappear likethis.
Finally ,wewillsometimes makereference tobuilt-in functions (so-called Prelude-
functions). This willlook something likethis:
map::(a >b) >[a] >[b]
Within thebody text,Hask ellkeywords willappear likethis: wher e,identiÔ¨Åers as
map,types asString andclasses asEq.
3
4 CHAPTER 1.INTRODUCTION
Chapter2
GettingStarted
There arethree well knownHask ellsystem: Hugs, GHC andNHC. Hugs isexclusi vely
aninterpreter ,meaning thatyoucannot compile stand-alone programs with it,butcan
testanddebugprograms inaninteracti veenvironment. GHC isboth aninterpreter (like
Hugs) andacompiler which willproduce stand-alone programs. NHC isexclusi velya
compiler .Which youuseisentirely uptoyou. I‚Äôvetried tomakealistofsome ofthe
differences inthefollowing listbutofcourse thisisfarfrom exhausti ve:
Hugs -veryfast;implements almost allofHask ell98(thestandard) andmost exten-
sions; built-in support formodule browsing; cannot create stand-alones; written
inC;works onalmost everyplatform; buildingraphics library .
GHC -interacti veenvironment isslowerthan Hugs, butallowsfunction deÔ¨Ånitions
intheenvironment (inHugs youhavetoputthem inaÔ¨Åle); implements allof
Hask ell98andextensions; good support forinterf acing with other languages; in
asense the‚Äúdefacto‚Äù standard.
NHC -lessused andnointeracti veenvironment, butproduces smaller andoften faster
executables than does GHC; supports Hask ell98andsome extensions.
I,personally ,haveallofthem installed andusethem fordifferent purposes. Itend
touseGHC tocompile (primarily because I‚Äômmost familiar with it)andtheHugs
interacti veenvironment, since itismuch faster.Assuch, thisiswhat Iwould suggest.
However,thatisafairamount todownload aninstall, soifyouhadtogowith justone,
I‚ÄôdgetGHC, since itcontains both acompiler andinteracti veenvironment.
Following isadescrition ofhowtodownload andinstall each ofthisasofthetime
thistutorial waswritten. Itmay havechanged ‚Äìseehttp://haskell.org (the
Hask ellwebsite) forup-to-date information.
2.1 Hugs
Hugs supports almost alloftheHask ell98standard (itlacks some ofthelibraries),
aswell asanumber ofadvanced/e xperimental extensions, including: multi-parameter
5
6 CHAPTER 2.GETTING STARTED
type classes, extensible records, rank-2 polymorphism, existentials, scoped type vari-
ables, andrestricted type synon yms.
2.1.1 Wher etogetit
TheofÔ¨Åcial Hugs web page isat:
http://haskell.org/hugs (http://hask ell.or g/hugs)
Ifyougothere, there isalink titled ‚Äúdownloading‚Äù which will send youtothe
download page. From thatpage, youcandownload theappropriate version ofHugs for
your computer .
2.1.2 Installation procedur es
Once you‚Äôvedownloaded Hugs, installation differsdepending onyour platform, how-
ever,installation forHugs ismore oflessidentical toinstallation foranyprogram on
your platform.
ForWindo wswhen youclick onthe‚Äúmsi‚Äù Ô¨Åletodownload, simply choose ‚ÄúRun This
Program‚Äù andtheinstallation willbeginautomatically .From there, justfollow
theon-screen instructions.
ForRPMs usewhate verRPM installation program youknowbest.
ForsourceÔ¨Årst gunzip theÔ¨Åle, then untar it.Presumably ifyou‚Äôreusing asystem
which isn‚Äôtotherwise supported, youknowenough about your system tobeable
torunconÔ¨Ågure scripts andmakethings byhand.
2.1.3 Howtorunit
OnUnix machines, theHugs interpreter isusually started with acommand lineofthe
form: hugs [option ‚ÄîÔ¨Åle]...
OnWindows,Hugs may bestarted byselecting itfrom thestart menu orbydouble
clicking onaÔ¨Ålewith the.hsor.lhsextension. (This manual assumes thatHugs has
already been successfully installed onyour system.)
Hugs uses options tosetsystem parameters. These options aredistinguished bya
leading +or-andareused tocustomize thebehaviour oftheinterpreter .When Hugs
starts, theinterpreter performs thefollowing tasks:
Options intheenvironment areprocessed. The variable HUGSFLA GSholds
these options. OnWindows95/NT ,theregistry isalso queried forHugs option
settings.
Command lineoptions areprocessed.
Internal data structures areinitialized. Inparticular ,theheap isinitialized, and
itssizeisÔ¨Åxedatthispoint; ifyouwanttoruntheinterpreter with aheap size
other than thedefault, then thismust bespeciÔ¨Åed using options onthecommand
line, intheenvironment orintheregistry .
2.2.GLASGO WHASKELL COMPILER 7
Theprelude Ô¨Åleisloaded. Theinterpreter willlook fortheprelude Ô¨Åleonthe
path speciÔ¨Åed bythe-Poption. Iftheprelude, located intheÔ¨ÅlePrelude.hs,
cannot befound inoneofthepath directories orinthecurrent directory ,then
Hugs willterminate; Hugs willnotrunwithout theprelude Ô¨Åle.
Program Ô¨Åles speciÔ¨Åed onthecommand lineareloaded. The effectofacom-
mand hugs f1...fnisthesame asstarting upHugs with thehugs command and
then typing :load f1...fn.Inparticular ,theinterpreter will notterminate ifa
problem occurs while itistrying toload oneofthespeciÔ¨Åed Ô¨Åles, butitwill
abort theattempted load command.
Theenvironment variables andcommand lineoptions used byHugs aredescribed
inthefollowing sections.
2.1.4 Program options
Tolistalloftheoptions would taketoomuch space. Themost important option atthis
point is‚Äú+98‚Äù or‚Äú-98‚Äù. When youstart hugs with ‚Äú+98‚Äù itisinHask ell98mode,
which turns offallextensions. When youstart in‚Äú-98‚Äù, youareinHugs mode andall
extensions areturned on.Ifyou‚Äôvedownloaded someone elses code andyou‚Äôrehaving
trouble loading it,Ô¨Årstmakesure youhavethe‚Äú98‚Äù Ô¨Çagsetproperly .
Further information ontheHugs options isinthemanual:
http://cvs.haskell.org/Hugs/pages/hugsman/started.html ().
2.1.5 Howtogethelp
TogetHugs speciÔ¨Åc help, gototheHugs web page. Togetgeneral Hask ellhelp, goto
theHask ellweb page.
2.2 Glasgo wHask ellCompiler
TheGlasgo wHask ellCompiler (GHC) isarobust,fully-featured, optimising compiler
andinteracti veenvironment forHask ell98;GHC compiles Hask elltoeither native
code orC.Itimplements numerous experimental language extensions toHask ell98;
forexample: concurrenc y,aforeign language interf ace, multi-parameter type classes,
scoped type variables, existential anduniversal quantiÔ¨Åcation, unbox edtypes, excep-
tions, weak pointers, andsoon.GHC comes with agenerational garbage collector ,and
aspace andtime proÔ¨Åler .
2.2.1 Wher etogetit
GototheofÔ¨Åcial GHC web pagehttp://haskell.org/ghc (GHC) todownload
thelatest release. Thecurrent version asofthewriting ofthistutorial is5.04.2 andcan
bedownloaded offoftheGHC download page (follo wthe‚ÄúDownload‚Äù link). From
thatpage, youcandownload theappropriate version ofGHC foryour computer .
8 CHAPTER 2.GETTING STARTED
2.2.2 Installation procedur es
Once you‚Äôvedownloaded GHC, installation differsdepending onyour platform; how-
ever,installation forGHC ismore oflessidentical toinstallation foranyprogram on
your platform.
ForWindo wswhen youclick onthe‚Äúmsi‚Äù Ô¨Åletodownload, simply choose ‚ÄúRun This
Program‚Äù andtheinstallation willbeginautomatically .From there, justfollow
theon-screen instructions.
ForRPMs usewhate verRPM installation program youknowbest.
ForsourceÔ¨Årst gunzip theÔ¨Åle, then untar it.Presumably ifyou‚Äôreusing asystem
which isn‚Äôtotherwise supported, youknowenough about your system tobeable
torunconÔ¨Ågure scripts andmakethings byhand.
Foramore detailed description oftheinstallation procedure, look attheGHC users
manual under ‚ÄúInstalling GHC‚Äù.
2.2.3 Howtorunthecompiler
Running thecompiler isfairly easy.Assuming thatyouhaveaprogram written with a
main function inaÔ¨ÅlecalledMain.hs ,youcancompile itsimply bywriting:
%ghc--makeMain.hs -omain
The‚Äú‚Äìmak e‚Äùoption tells GHC thatthisisaprogram andnotjustalibrary andyou
wanttobuilditandallmodules itdepends on.‚ÄúMain.hs‚Äù stipulates thename ofthe
Ô¨Åletocompile; andthe‚Äú-omain‚Äù means thatyouwanttoputtheoutput inaÔ¨Ålecalled
‚Äúmain‚Äù.
NOTE InWindows,youshould say‚Äú-omain.e xe‚ÄùtotellWindows
thatthisisanexecutable Ô¨Åle.
Youcanthen runtheprogram bysimply typing ‚Äúmain‚Äù attheprompt.
2.2.4 Howtoruntheinter preter
GHCi isinvokedwith thecommand ‚Äúghci‚Äù or‚Äúghc ‚Äìinteracti ve‚Äù.Oneormore modules
orÔ¨Ålenames canalsobespeciÔ¨Åed onthecommand line; thisinstructs GHCi toload the
speciÔ¨Åed modules orÔ¨Ålenames (and allthemodules theydepend on),justasifyouhad
said:load modules attheGHCi prompt.
2.3.NHC 9
2.2.5 Program options
Tolistalloftheoptions would taketoomuch space. The most important option at
thispoint is‚Äú-fglasgo w-exts‚Äù. When youstart GHCi without ‚Äú-fglasgo w-exts‚Äù itis
inHask ell98mode, which turns offallextensions. When youstart with ‚Äú-fglasgo w-
exts‚Äù, allextensions areturned on. Ifyou‚Äôvedownloaded someone elses code and
you‚Äôrehaving trouble loading it,Ô¨Årstmakesure youhavethisÔ¨Çagsetproperly .
Further information ontheGHC andGHCi options areinthemanual offofthe
GHC web page.
2.2.6 Howtogethelp
TogetGHC(i) speciÔ¨Åc help, gototheGHC web page. Togetgeneral Hask ellhelp, go
totheHask ellweb page.
2.3 NHC
About NHC. ..
2.3.1 Wher etogetit
2.3.2 Installation procedur es
2.3.3 Howtorunit
2.3.4 Program options
2.3.5 Howtogethelp
2.4 Editors
Withgood texteditor ,programming isfun.Ofcourse, youcangetalong with simplistic
editor capable ofjustcut-n-paste, butgood editor iscapable ofdoing most ofthechores
foryou, letting youconcentrate onwhat youarewriting. Withrespect toprogramming
inHask ell,good texteditor should haveasmuch aspossible ofthefollowing features:
Syntax highlighting forsource Ô¨Åles
Indentation ofsource Ô¨Åles
Interaction with Hask ellinterpreter (beitHugs orGHCi)
Computer -aided code navigation
Code completion
10 CHAPTER 2.GETTING STARTED
Atthetime ofwriting, several options were available: Emacs/XEmacs support
Hask ellviahaskell-mode andaccompan ying Elist code (available fromhttp://www.haskell.org/haskell-mode
()),and....
What‚Äô selseavailable?. ..
(X)Emacs seem todothebestjob,having allthefeatures listed above.Indentation
isawareabout Hask ell‚Äôs2-dimensional layout rules (see Section 7.11, verysmart and
havetobeseen inaction tobebelie ved.Youcanquickly jump tothedeÔ¨Ånition of
chosen function with thehelp of‚ÄùDeÔ¨Ånitions‚Äù menu, andname ofthecurrently edited
function isalwaysdisplayed inthemodeline.
Chapter3
Language Basics
Inthischapter wepresent thebasic concepts ofHask ell.Inaddition tofamiliarizing you
with theinteracti veenvironments andshowing youhowtocompile abasic program,
weintroduce thebasic syntax ofHask ell,which willprobably bequite alien ifyouare
used tolanguages likeCandJava.
However,before wetalkabout speciÔ¨Åcs ofthelanguage, weneed toestablish some
general properties ofHask ell. Most importantly ,Hask ellisalazy language, which lazy
means thatnocomputation takesplace unless itisforced totakeplace when theresult
ofthatcomputation isused.
This means, forinstance, thatyoucandeÔ¨Åne inÔ¨Ånitely largedata structures, pro-
vided that you neverusetheentire structure. Forinstance, using imperati ve-esque
psuedo-code, wecould create aninÔ¨Ånite listcontaining thenumber 1ineach position
bydoing something like:
ListmakeList()
{
Listcurrent =newList();
current.value =1;
current.next =makeList();
returncurrent;
}
Bylooking atthiscode, wecanseewhat it‚Äôstrying todo:itcreates anewlist,sets
itsvalue to1andthen recursi velycalls itself tomaketherestofthelist.Ofcourse, if
youactually wrote thiscode andcalled it,theprogram would neverterminate, because
makeList would keepcalling itself adinÔ¨Ånitum.
This isbecause weassume thisimperati ve-esque language isstrict ,theopposite of strict
lazy.Strict languages areoften referred toas‚Äúcall byvalue,‚Äùwhile lazy languages are
referred toas‚Äúcall byname. ‚ÄùIntheabovepsuedo-code, when we‚Äúrun‚ÄùmakeList
ontheÔ¨Åfth line, weattempt togetavalue outofit.This leads toaninÔ¨Ånite loop.
Theequivalent code inHask ellis:
11
12 CHAPTER 3.LANGUAGEBASICS
makeList =1:makeList
This program reads: we‚ÄôredeÔ¨Åning something calledmakeList (this iswhat goes
ontheleft-hand sideoftheequals sign). Ontheright-hand side, wegivethedeÔ¨Ånition
ofmakeList .InHask ell,thecolon operator isused tocreate lists (we‚Äôlltalkmore
about thissoon). This right-hand sidesays thatthevalue ofmakeList istheelement
1stuck ontothebeginning ofthevalue ofmakeList .
However,since Hask ellislazy (or‚Äúcall byname‚Äù), wedonotactually attempt to
evaluate whatmakeList isatthispoint: wesimply remember thatifeverinthefuture
weneed thesecond element ofmakeList ,weneed tojustlook atmakeList .
Now,ifyouattempt towritemakeList toaÔ¨Åle,print ittothescreen, orcalculate
thesumofitselements, theoperation won‚Äôtterminate because itwould havetoevaluate
aninÔ¨Ånitely long list. However,ifyousimply useaÔ¨Ånite portion ofthelist(say the
Ô¨Årst10elements), thefactthatthelistisinÔ¨Ånitely long doesn‚Äô tmatter .Ifyouonly use
theÔ¨Årst10elements, only theÔ¨Årst10elements areevercalculated. This islaziness.
Second, Hask elliscase-sensiti ve.Manylanguages are,butHask ellactually uses case-sensitiv e
case togivemeaning. Hask elldistinguishes between values (forinstance, numbers: values
1;2;3;:::);strings: ‚Äúabc‚Äù, ‚Äúhello‚Äù, ...;characters: ‚Äòa‚Äô,‚Äòb‚Äô,‚Äò‚Äô,...;evenfunctions:
forinstance, thefunction squares avalue, orthesquare-root function); andtypes (the types
categories towhich values belong).
Byitself, thisisnotunusual. Most languages havesome system oftypes. What is
unusual isthatHask ellrequir esthatthenames giventofunctions andvalues beginwith
alower-case letter andthatthenames giventotypes beginwith anupper -case letter .
The moral is:ifyour otherwise correct program won‚Äôtcompile, besure youhaven‚Äôt
named your functionFoo,orsomething elsebeginning with acapital letter .
Being afunctional language, Hask ellesche wsside effects. Aside effectisessen- side effects
tially something thathappens inthecourse ofexecuting afunction thatisnotrelated to
theoutput produced bythatfunction.
Forinstance, inalanguage likeCorJava,youareable tomodify ‚Äúglobal‚Äù variables
from within afunction. This isaside effectbecause themodiÔ¨Åcation ofthisglobal
variable isnotrelated totheoutput produced bythefunction. Furthermore, modifying
thestate oftherealworldisconsidered asideeffect: printing something tothescreen,
reading aÔ¨Åle,etc., areallsideeffecting operations.
Functions thatdonothavesideeffects arecalled pure.Aneasy testforwhether or pure
notafunction ispure istoaskyourself asimple question: ‚ÄúGiventhesame arguments,
willthisfunction alwaysproduce thesame result?‚Äù.
Allofthismeans thatifyou‚Äôreused towriting code inanimperati velanguage (like
CorJava),you‚Äôregoing tohavetostart thinking differently .Most importantly ,ifyou
haveavaluex,youmust notthink ofxasaregister ,amemory location oranything
elseofthatnature.xissimply aname, justas‚ÄúHal‚Äù ismyname. Youcannot arbitrarily
decide tostore adifferent person inmyname anymore than youcanarbitrarily decide
tostore adifferent value inx.This means thatcode thatmight look likethefollowing
Ccode isinvalid(and hasnocounterpart) inHask ell:
intx=5;
3.1.ARITHMETIC 13
x=x+1;
Acalllikex=x+1iscalled destructive update because wearedestro ying destr uctiveupdate
whate verwasinxbefore andreplacing itwith anewvalue. Destructi veupdate does
notexistinHask ell.
Bynotallowing destructi veupdates (oranyother such side effecting operations),
Hask ellcode isveryeasy tocomprehend. That is,when wedeÔ¨Åne afunctionf,and
callthatfunction with aparticular argumentainthebeginning ofaprogram, andthen,
attheendoftheprogram, againcallfwith thesame argumenta,weknowwewill
getoutthesame result. This isbecause weknowthatacannot havechanged and
because weknowthatfonly depends ona(forinstance, itdidn‚Äô tincrement aglobal
counter). This property iscalled referential transpar ency andbasically states thatif referential transparency
twofunctionsfandgproduce thesame values forthesame arguments, then wemay
replacefwithg(and vice-v ersa).
NOTE There isnoagreed-upon exact deÔ¨Ånition ofreferential trans-
parenc y.ThedeÔ¨Ånition givenaboveistheoneIlikebest. Theyallcarry
thesame interpretation; thedifferences lieinhowtheyareformalized.
3.1 Arithmetic
Let‚Äôsbeginourforay intoHask ellwith simple arithmetic. Start upyour favorite inter-
activeshell (Hugs orGHCi; seeChapter 2forinstallation instructions). Theshell will
output tothescreen afewlines talking about itself andwhat it‚Äôsdoing andthen should
Ô¨Ånish with thecursor onalinereading:
Prelude>
From here, youcanbegintoevaluate expressions .Anexpression isbasically some- expressions
thing thathasavalue. Forinstance, thenumber 5isanexpression (itsvalue is5).Val-
uescanbebuiltupfrom other values; forinstance, 5+6isanexpression (itsvalue is
11).Infact,most simple arithmetic operations aresupported byHask ell,including plus
(+),minus (-),times (*),divided-by (/),exponentiation (ÀÜ)andsquare-root (sqrt ).
Youcanexperiment with these byasking theinteracti veshell toevaluate expressions
andtogiveyoutheir value. Inthisway,aHask ellshell canbeused asapowerful
calculator .Trysome ofthefollowing:
Prelude> 5*4+3
23
Prelude> 5ÀÜ5-2
3123
Prelude> sqrt2
1.4142135623730951
14 CHAPTER 3.LANGUAGEBASICS
Prelude> 5*(4+3)
35
Wecanseethat, inaddition tothestandard arithmetic operations, Hask ellalso
allowsgrouping byparentheses, hence thedifference between thevalues of5*4+3 and
5*(4+3) .Thereason forthisisthatthe‚Äúunderstood‚Äù grouping oftheÔ¨Årstexpression is
(5*4)+3 ,duetooperator precedence . operatorprecedence
Also note thatparentheses aren‚Äô trequired around function arguments. Forinstance,
wesimply wrotesqrt2,notsqrt(2) ,aswould berequired inmost other lan-
guages. Youcould write itwith theparentheses, butinHask ell,since function applica-
tionissocommon, parentheses aren‚Äô trequired.
WARNING Eventhough parentheses arenotalwaysneeded, some-
times itisbetter toleavethem inanyway;other people will probably
havetoread your code, andifextraparentheses maketheintent ofthe
code clearer ,usethem.
Nowtryentering 2ÀÜ5000 .Does itwork?
NOTE Ifyou‚Äôrefamiliar with programming inother languages, you
may Ô¨Ånd itoddthatsqrt 2comes back with adecimal point (i.e., isa
Ô¨Çoating point number) eventhough theargument tothefunction seems to
beaninteger.This interchang ability ofnumeric types isduetoHask ell‚Äôs
system oftype classes andwillbediscussed indetail inSection 4.3).
Exer cises
Exer cise3.1We‚Äôveseen thatmultiplication binds moretightly than division. Can you
think ofaway todetermine whether function application binds moreorlesstightly
than multiplication?
3.2 Pairs, Triples andMore
Inaddition tosingle values, weshould also address multiple values. Forinstance, we
may wanttorefer toaposition byitsx/ycoordinate, which would beapairofintegers.
Tomakeapairofintegers issimple: youenclose thepairinparenthesis andseparate
them with acomma. Trythefollowing:
Prelude> (5,3)
(5,3)
3.3.LISTS 15
Here, wehaveapair ofintegers,5and3.InHask ell,theÔ¨Årst element ofapair
need nothavethesame type asthesecond element: thatis,pairs areallowed tobe
heterogeneous. Forinstance, youcanhaveapair ofanintegerwith astring. This heterogeneous
contrasts with lists, which must bemade upofelements ofallthesame type (wewill
discuss listsfurther inSection 3.3).
There aretwopredeÔ¨Åned functions thatallowyoutoextract theÔ¨Årst andsecond
elements ofapair.Theyare,respecti vely,fst andsnd.Youcanseehowtheywork
below:
Prelude> fst(5,"hello")
5
Prelude> snd(5,"hello")
"hello"
Inaddition topairs, youcandeÔ¨Åne triples, quadruples etc.TodeÔ¨Åne atriple anda
quadruple, respecti vely,wewrite:
Prelude> (1,2,3)
(1,2,3)
Prelude> (1,2,3,4)
(1,2,3,4)
And soon.Ingeneral, pairs, triples, andsoonarecalled tuples andcanstore Ô¨Åxed tuples
amounts ofheterogeneous data.
NOTE Thefunctionsfst andsnd won‚Äôtworkonanything longer
than apair; ifyoutrytousethem onalargertuple, youwillgetamessage
stating thatthere wasatype error .Themeaning ofthiserror message will
beexplained inChapter 4.
Exer cises
Exer cise3.2Useacombination offstandsndtoextractthecharacter outofthetuple
((1,‚Äôa‚Äô),"foo") .
3.3 Lists
The primary limitation oftuples isthattheyhold only aÔ¨Åxednumber ofelements:
pairs hold two,triples hold three, andsoon.Adata structure thatcanhold anarbitrary
number ofelements isalist.Lists areassembled inaverysimilar fashion totuples,
except thattheyusesquare brack etsinstead ofparentheses. WecandeÔ¨Åne alistlike:
16 CHAPTER 3.LANGUAGEBASICS
Prelude> [1,2]
[1,2]
Prelude> [1,2,3]
[1,2,3]
Lists don‚Äôtneed tohaveanyelements. Theempty listissimply[].
Unlik etuples, wecanveryeasily addanelement ontothebeginning ofthelist
using thecolon operator .Thecolon iscalled the‚Äúcons‚Äù operator; theprocess ofadding cons operator
anelement iscalled ‚Äúconsing. ‚ÄùThe etymology ofthisisthatweareconstructing a
newlistfrom anelement andanoldlist.Wecanseethecons operator inaction inthe
following examples:
Prelude> 0:[1,2]
[0,1,2]
Prelude> 5:[1,2,3,4]
[5,1,2,3,4]
Wecanactually buildanylistbyusing thecons operator (thecolon) andtheempty
list:
Prelude> 5:1:2:3:4:[]
[5,1,2,3,4]
Infact,the[5,1,2,3,4] syntax is‚Äúsyntactic sugar‚Äùfortheexpression using the syntactic sugar
explicit cons operators andempty list.Ifwewrite something using the[5,1,2,3,4]
notation, thecompiler simply translates ittotheexpression using(:) and[].
NOTE Ingeneral, ‚Äúsyntactic sugar‚Äùisastrictly unnecessary language
feature, which isadded tomakethesyntax nicer .
One further difference between lists andtuples isthat, while tuples areheteroge-
neous, lists must behomogenous. This means thatyoucannot havealistthatholds homogenous
both integers andstrings. Ifyoutryto,atype error willbereported.
Ofcourse, lists don‚Äôthavetojustcontain integers orstrings; theycanalso contain
tuples orevenother lists. Tuples, similarly ,cancontain listsandother tuples. Trysome
ofthefollowing:
Prelude> [(1,1),(2,4),(3,9),(4,16)]
[(1,1),(2,4),(3,9),(4,16)]
Prelude> ([1,2,3,4],[5,6,7])
([1,2,3,4],[5,6,7])
3.3.LISTS 17
There aretwobasic listfunctions:head andtail .Thehead function returns
theÔ¨Årstelement ofa(non-empty) list,andthetail function returns allbuttheÔ¨Årst
element ofa(non-empty) list.
Togetthelength ofalist,youusethelength function:
Prelude> length[1,2,3,4,10]
5
Prelude> head[1,2,3,4,10]
1
Prelude> length(tail[1,2,3,4,10])
4
3.3.1 Strings
InHask ell,aString issimply alistofChars.So,wecancreate thestring ‚ÄúHello‚Äù as:
Prelude> ‚ÄôH‚Äô:‚Äôe‚Äô:‚Äôl‚Äô:‚Äôl‚Äô:‚Äôo‚Äô:[]
"Hello"
Lists (and, ofcourse, strings) canbeconcatenated using the++operator:
Prelude> "Hello"++"World"
"HelloWorld"
Additionally ,non-string values canbeconverted tostrings using theshow func-
tion, andstrings canbeconverted tonon-string values using theread function. Of
course, ifyoutrytoread avalue that‚Äôsmalformed, anerror willbereported (note that
thisisarun-time error ,notacompile-time error):
Prelude> "Fivesquared is"++show(5*5)
"Fivesquared is25"
Prelude> read"5"+3
8
Prelude> read"Hello" +3
Program error:Prelude.read: noparse
Above,theexact error message isimplementation dependent. However,theinter-
preter hasinferred thatyou‚Äôretrying toaddthree tosomething. This means thatwhen
weexecuteread"Hello" ,weexpect tobereturned anumber .However,"Hello"
cannot beparsed asanumber ,soanerror isreported.
18 CHAPTER 3.LANGUAGEBASICS
3.3.2 Simple List Functions
Much ofthecomputation inHask ellprograms isdone byprocessing lists. There are
three primary list-processing functions:map,filter andfoldr (alsofoldl ).
Themap function takesasarguments alistofvalues andafunction thatshould be
applied toeach ofthevalues. Forinstance, there isabuilt-in functionChar.toUpper
thattakesasinput aCharandproduces aCharthatistheupper -case version ofthe
original argument. So,tocovertanentire string (which issimply alistofcharacters)
toupper case, wecanmap thetoUpper function across theentire list:
Prelude> mapChar.toUpper "HelloWorld"
"HELLOWORLD"
WARNING Hugs users: Hugs doesn‚Äô tlikequaliÔ¨Åed names like
Char.toUpper .InHugs, simply usetoUpper .
When youmap across alist,thelength ofthelistneverchanges ‚Äìonly theindivid-
ualvalues inthelistchange.
Toremo veelements from thelist,youcanusethefilter function. This function
allowsyoutoremo vecertain elements from alistdepending ontheir value, butnoton
their conte xt.Forinstance, thefunctionChar.isLower tells youwhether agiven
character islowercase. WecanÔ¨Ålter outallnon-lo wercase characters using this:
Prelude> filterChar.isLower "HelloWorld"
"elloorld"
Thefunctionfoldr takesalittle more getting used to.foldr takesthree argu-
ments: afunction, aninitial value andalist. Thebest waytothink aboutfoldr is
thatitreplaces occurences ofthelistcons operator (:)with thefunction parameter and
replaces theempty listconstructor ([])with theinitial value. Thus, ifwehavealist:
3:8:12:5:[]
andweapplyfoldr(+)0toit,weget:
3+8+12+5+0
which sums thelist.Wecantestthis:
Prelude> foldr(+)0[3,8,12,5]
28
Wecanperform thesame sortofoperation tocalculate theproduct ofalltheele-
ments onalist:
Prelude> foldr(*)1[4,8,5]
160
3.3.LISTS 19
Wesaidearlier thatfolding islikereplacing (:)with aparticular function and([])
with aninitial element. This raises aquestion astowhat happens when thefunction
isn‚Äôtassociati ve(afunction ()isassociati veifa(bc)=(ab)c).When wewrite
4851,weneed tospecify where toputtheparentheses. Namely ,dowemean
((48)5)1or4(8((51))?foldr assumes thefunction isright-associati ve(i.e.,
thecorrect brack eting isthelatter). Thus, when weuseitonanon-associti vefunction
(likeminus), wecanseetheeffect:
Prelude> foldr(-)1[4,8,5]
0
Theexact derivation ofthislooks something like:
foldr(-)1[4,8,5]
==>4-(foldr(-)1[8,5])
==>4-(8-foldr(-)1[5])
==>4-(8-(5-foldr(-)1[]))
==>4-(8-(5-1))
==>4-(8-4)
==>4-4
==>0
Thefoldl function goes theother wayandeffectivelyproduces theopposite
brack eting.foldl looks thesame when applied, sowecould havedone summing
justaswell withfoldl :
Prelude> foldl(+)0[3,8,12,5]
28
However,wegetdifferent results when using thenon-associati vefunction minus:
Prelude> foldl(-)1[4,8,5]
-16
This isbecausefoldl uses theopposite brack eting. Thewayitaccomplishes this
isessentially bygoing allthewaydownthelist,taking thelastelement andcombining
itwith theinitial value viatheprovided function. Itthen takesthesecond-to-last ele-
ment inthelistandcombines ittothisnewvalue. Itdoes sountil there isnomore list
left.
Thederivation here proceeds intheopposite fashion:
foldl(-)1[4,8,5]
==>foldl(-)(1-4)[8,5]
==>foldl(-)((1-4)-8)[5]
==>foldl(-)(((1-4)-8)-5)[]
20 CHAPTER 3.LANGUAGEBASICS
==>((1-4)-8)-5
==>((-3)-8)-5
==>(-11)-5
==>-16
Note thatonce thefoldl goes away,theparenthesization isexactly theopposite
ofthefoldr .
NOTEfoldl isoften more efÔ¨Åcient thanfoldr forreasons that
wewill discuss inSection 7.8. However,foldr canworkoninÔ¨Ånite
lists, whilefoldl cannot. This isbecause beforefoldl does any-
thing, ithastogototheendofthelist. Ontheother hand,foldr
starts producing output immediately .Forinstance,foldr(:)[]
[1,2,3,4,5] simply returns thesame list. Evenifthelistwere in-
Ô¨Ånite, itwould produce output. Asimilar function usingfoldl would
failtoproduce anyoutput.
Ifthisdiscussion ofthefolding functions isstillsome what unclear ,that‚Äôsokay.
We‚Äôlldiscuss them further inSection 7.8.
Exer cises
Exer cise3.3Usemap toconvertastring intoalistofbooleans, eachelement inthe
newlistrepresenting whether ornottheoriginal element wasalower -case character .
That is,itshould takethestring ‚ÄúaBCde‚Äù andreturn [True,False,False,True,True].
Exer cise3.4Usethefunctions mentioned inthissection (you willneed twoofthem)
tocompute thenumber oflower -case letter sinastring .Forinstance ,on‚ÄúaBCde‚Äù it
should return 3.
Exer cise3.5We‚Äôveseen how tocalculate sums andproducts using folding functions.
Given that thefunctionmax returns themaximum oftwonumber s,write afunction
using afoldthatwillreturn themaximum value inalist(and zeroifthelistisempty).
So,when applied to[5,10,2,8,1] itwillreturn 10.Assume thatthevalues inthelistare
always 0.Explain toyourselfwhyitworks.
Exer cise3.6Write afunction that takesalistofpairsoflength atleast 2and re-
turns theÔ¨Årstcomponent ofthesecond element inthelist. So,when provided with
[(5,‚Äôb‚Äô),(1, ‚Äôc‚Äô),(6, ‚Äôa‚Äô)], itwillreturn 1.
3.4 Sour ceCode Files
Asprogrammers, wedon‚Äôtwanttosimply evaluate small expressions likethese ‚Äìwe
wanttositdown,write code inoureditor ofchoice, saveitandthen useit.
Wealready sawinSections 2.2and2.3howtowrite aHello World program and
howtocompile it.Here, weshowhowtousefunctions deÔ¨Åned inasource-code Ô¨Åle
intheinteracti veenvironment. Todothis, create aÔ¨ÅlecalledTest.hs andenter the
following code:
3.4.SOURCE CODEFILES 21
moduleTest
where
x=5
y=(6,"Hello")
z=x*fsty
This isaverysimple ‚Äúprogram‚Äù written inHask ell. ItdeÔ¨Ånes amodule called
‚ÄúTest‚Äù(ingeneral module names should match Ô¨Ålenames; seeSection 6formore on
this). Inthismodule, there arethree deÔ¨Ånitions: x,yandz.Once you‚Äôvewritten
andsavedthisÔ¨Åle, inthedirectory inwhich yousavedit,load thisinyour favorite
interpreter ,byexecuting either ofthefollowing:
%hugsTest.hs
%ghciTest.hs
This willstart Hugs orGHCi, respecti vely,andload theÔ¨Åle. Alternati vely,ifyou
already haveoneofthem loaded, youcanusethe‚Äú:load‚Äù command (orjust‚Äú:l‚Äù) to
load amodule, as:
Prelude> :lTest.hs
...
Test>
Between theÔ¨Årstandlastline, theinterpreter willprint various data toexplain what
itisdoing. Ifanyerrors appear ,youprobably mistyped something intheÔ¨Åle;double
check andthen tryagain.
You‚Äôllnotice thatwhere itused tosay‚ÄúPrelude‚Äù itnowsays ‚ÄúTest.‚ÄùThat means
thatTestisthecurrent module. You‚Äôreprobably thinking that‚ÄúPrelude‚Äù must also be
amodule. Exactly correct. The Prelude module (usually simply referred toas‚Äúthe
Prelude‚Äù) isalwaysloaded andcontains thestandard deÔ¨Ånitions (forinstance, the(:) thePrelude
operator forlists, or(+)or(*),fst,snd andsoon).
Nowthatwe‚Äôveloaded Test,wecanusethings thatwere deÔ¨Åned init.Forexample:
Test>x
5
Test>y
(6,"Hello")
Test>z
30
Perfect, justasweexpected!
One Ô¨Ånal issue regarding howtocompile programs tostand-alone executables re-
mains. Inorder foraprogram tobeanexecutable, itmust havethemodule name
22 CHAPTER 3.LANGUAGEBASICS
‚ÄúMain‚Äù andmust contain afunction calledmain .So,ifyougointoTest.hs andre-
name itto‚ÄúMain‚Äù (change thelinethatreadsmoduleTest tomoduleMain ),we
simply need toaddamain function. Trythis:
main=putStrLn "HelloWorld"
Now,savetheÔ¨Åle,andcompile it(refer back toSection 2forinformation onhow
todothisforyour compiler). Forexample, inGHC, youwould say:
%ghc--makeTest.hs -otest
NOTE ForWindows,itwould be‚Äú-otest.e xe‚Äù
This willcreate aÔ¨Ålecalled ‚Äútest‚Äù (oronWindows,‚Äútest.e xe‚Äù)thatyoucanthen
run.
%./test
HelloWorld
NOTE Or,onWindows:
C:\>test.exe
HelloWorld
3.5 Functions
Nowthatwe‚Äôveseen howtowrite code inaÔ¨Åle,wecanstart writing functions. Asyou
might haveexpected, functions arecentral toHask ell,asitisafunctional language.
This means thattheevaluation ofaprogram issimply theevaluation ofafunction.
Wecanwrite asimple function tosquare anumber andenter itintoourTest.hs
Ô¨Åle.Wemight deÔ¨Åne thisasfollows:
squarex=x*x
Inthisfunction deÔ¨Ånition, wesaythatwe‚ÄôredeÔ¨Åning afunctionsquare thattakes
oneargument (aka parameter), which wecallx.Wethen saythatthevalue ofsquare
xisequal tox*x.
Hask ellalso supports standard conditional expressions. Forinstance, wecould
deÔ¨Åne afunction thatreturns  1ifitsargument islessthan0;0ifitsargument is0;
and1ifitsargument isgreater than0(this iscalled thesignum function):
3.5.FUNCTIONS 23
signumx=
ifx<0
then-1
elseifx>0
then1
else0
Youcanexperiment with thisas:
Test>signum5
1
Test>signum0
0
Test>signum(5-10)
-1
Test>signum(-1)
-1
Note thattheparenthesis around ‚Äú-1‚Äù inthelastexample arerequired; ifmissing,
thesystem willthink youaretrying tosubtract thevalue ‚Äú1‚Äùfrom thevalue ‚Äúsignum, ‚Äù
which isilltyped.
Theif/then/else construct inHask ellisverysimilar tothatofmost other program-
ming languages; however,youmust haveboth athen andanelseclause. Itevaluates if/then /else
thecondition (inthiscasex<0and, ifthisevaluates toTrue ,itevaluates thethen
condition; ifthecondition evaluated toFalse ,itevaluates theelsecondition).
Youcantestthisprogram byediting theÔ¨Åleandloading itback intoyour interpreter .
IfTest isalready thecurrent module, instead oftyping:lTest.hs again,youcan
simply type:reload orjust:rtoreload thecurrent Ô¨Åle.This isusually much faster.
Hask ell,likemanyother languages, also supports case constructions. These are case /of
used when there aremultiple values thatyouwanttocheck against (case expressions
areactually quite abitmore powerful than this‚ÄìseeSection 7.4forallofthen details).
Suppose wewanted todeÔ¨Åne afunction thathadavalue of1ifitsargument were
0;avalue of5ifitsargument were1;avalue of2ifitsargument were2;andavalue of
 1inallother instances. Writing thisfunction using ifstatements would belong and
veryunreadable; sowewrite itusing acase statement asfollows(wecallthisfunction
f):
fx=
casexof
0->1
1->5
2->2
_->-1
24 CHAPTER 3.LANGUAGEBASICS
Inthisprogram, we‚ÄôredeÔ¨Åningftotakeanargumentxandthen inspect thevalue
ofx.Ifitmatches 0,thevalue offis1.Ifitmatches 1,thevalue offis5.Ifitmaches
2,then thevalue offis2;andifithasn‚Äô tmatched anything bythatpoint, thevalue of
fis 1(theunderscore canbethought ofasa‚Äúwildcard‚Äù ‚Äìitwillmatch anything) . wildcard
Theindentation here isimportant. Hask elluses asystem called ‚Äúlayout‚Äù tostruc-
ture itscode (the programming language Python uses asimilar system). The layout
system allowsyoutowrite code without theexplicit semicolons andbraces thatother
languages likeCandJavarequire.
WARNING Because whitespace matters inHask ell,youneed tobe
careful about whether youareusing tabsorspaces. IfyoucanconÔ¨Ågure
your editor toneverusetabs, that‚Äôsprobably better .Ifnot, makesure
your tabsarealways8spaces long, oryou‚Äôrelikelytorunintoproblems.
The general rule forlayout isthat anopen-brace isinserted after thekeywords
wher e,let,doandof,andthecolumn position atwhich thenextcommand appears
isremembered. From then on,asemicolon isinserted before everynewlinethatis
indented thesame amount. Ifafollowing lineisindented less, aclose-brace isinserted.
This may sound complicated, butifyoufollowthegeneral ruleofindenting after each
ofthose keywords, you‚Äôllneverhavetoremember it(see Section 7.11 foramore
complete discussion oflayout).
Some people prefer nottouselayout andwrite thebraces andsemicolons explicitly .
This isperfectly acceptable. Inthisstyle, theabovefunction might look like:
fx=casexof
{0->1;1->5;2->2;_->1}
Ofcourse, ifyouwrite thebraces andsemicolons explicitly ,you‚Äôrefreetostructure
thecode asyouwish. Thefollowing isalsoequally valid:
fx=
casexof{0->1;
1->5;2->2
;_->1}
However,structuring your code likethisonly servestomakeitunreadable (inthis
case).
Functions canalso bedeÔ¨Åned piece-wise, meaning thatyoucanwrite oneversion
ofyour function forcertain parameters andthen another version forother parameters.
Forinstance, theabovefunctionfcould alsobewritten as:
f0=1
f1=5
f2=2
f_=-1
3.5.FUNCTIONS 25
Here, theorder isimportant. IfwehadputthelastlineÔ¨Årst, itwould havematched
everyargument, andfwould return-1,regardless ofitsargument (most compilers
willwarnyouabout this, though, saying something about overlapping patterns). Ifwe
hadnotincluded thislastline,fwould produce anerror ifanything other than 0,1or
2were applied toit(most compilers willwarnyouabout this, too,saying something
about incomplete patterns). This style ofpiece-wise deÔ¨Ånition isverypopular andwill
beused quite frequently throughout thistutorial. These twodeÔ¨Ånitions offareactually
equivalent ‚Äìthispiece-wise version istranslated intothecase expression.
More complicated functions canbebuiltfrom simpler functions using function
composition .Function composition issimply taking theresult oftheapplication ofone
function andusing thatasanargument foranother .We‚Äôvealready seen thiswayback
inarithmetic (Section 3.1), when wewrote5*4+3 .Inthis, wewere evaluating 54
andthen applying +3totheresult. Wecandothesame thing with oursquare andf
functions:
Test>square(f1)
25
Test>square(f2)
4
Test>f(square 1)
5
Test>f(square 2)
-1
The result ofeach ofthese function applications isfairly straightforw ard. The
parentheses around theinner function arenecessary; otherwise, intheÔ¨Årst line, the
interpreter would think thatyouwere trying togetthevalue of‚Äúsquaref,‚Äùwhich
hasnomeaning. Function application likethisisfairly standard inmost programming
languages. There isanother ,more mathematically oriented, waytoexpress function
composition, using the(.)(just asingle period) function. This (.)function issupposed
tolook likethe()operator inmathematics.
NOTE Inmathematics wewritefgtomean ‚Äúffollowing g,‚Äùin
Hask ellwewritef.galsotomean ‚Äúffollowing g.‚Äù
The meaning offgissimply that(fg)(x)=f(g(x)).That is,
applying thevaluextothefunction fgisthesame asapplying ittog,
taking theresult, andthen applying thattof.
The (.)function (called thefunction composition function), takestwofunctions function composition
andmakesthem intoone. Forinstance, ifwewrite(square .f),thismeans that
itcreates anewfunction thattakesanargument, appliesftothatargument andthen
appliessquare totheresult. Conversely ,(f.square) means thatitcreates
anewfunction that takesanargument, appliessquare tothat argument andthen
appliesftotheresult. Wecanseethisbytesting itasbefore:
Test>(square .f)1
25
26 CHAPTER 3.LANGUAGEBASICS
Test>(square .f)2
4
Test>(f.square) 1
5
Test>(f.square) 2
-1
Here, wemust enclose thefunction composition inparentheses; otherwise, the
Hask ellcompiler willthink we‚Äôretrying tocomposesquare with thevaluef1in
theÔ¨Årstline, which makesnosense sincef1isn‚Äôtevenafunction.
Itwould probably bewise totakealittle time-out tolook atsome ofthefunctions
that aredeÔ¨Åned inthePrelude. Undoubtedly ,atsome point, you will accidentally
rewrite some already-e xisting function (I‚Äôvedone itmore times than Icancount), but
ifwecankeepthistoaminimum, thatwould savealotoftime. Here aresome simple
functions, some ofwhich we‚Äôvealready seen:
sqrt thesquare rootfunction
id theidentity function:idx=x
fst extracts theÔ¨Årstelement from apair
snd extracts thesecond element from apair
null tells youwhether ornotalistisempty
head returns theÔ¨Årstelement onanon-empty list
tail returns everything buttheÔ¨Årstelement ofanon-empty list
++ concatenates twolists
== checks toseeiftwoelements areequal
/= checks toseeiftwoelements areunequal
Here, weshowexample usages ofeach ofthese functions:
Prelude> sqrt2
1.41421
Prelude> id"hello"
"hello"
Prelude> id5
5
Prelude> fst(5,2)
5
Prelude> snd(5,2)
2
Prelude> null[]
True
Prelude> null[1,2,3,4]
False
Prelude> head[1,2,3,4]
1
Prelude> tail[1,2,3,4]
[2,3,4]
Prelude> [1,2,3] ++[4,5,6]
3.5.FUNCTIONS 27
[1,2,3,4,5,6]
Prelude> [1,2,3] ==[1,2,3]
True
Prelude> ‚Äôa‚Äô/=‚Äôb‚Äô
True
Prelude> head[]
Program error:{head[]}
Wecanseethatapplyinghead toanempty listgivesanerror (the exact error
message depends onwhether you‚Äôreusing GHCi orHugs ‚Äìtheshownerror message is
from Hugs).
3.5.1 LetBindings
Often wewish toprovide local declarations foruseinourfunctions. Forinstance, if
youremember back toyour grade school mathematics courses, thefollowing equation
isused toÔ¨Åndtheroots (zeros) ofapolynomial oftheformax2+bx+c=0:x=
( bp
b2 4ac)=2a.Wecould write thefollowing function tocompute thetwo
values ofx:
rootsabc=
((-b+sqrt(b*b -4*a*c)) /(2*a),
(-b-sqrt(b*b -4*a*c)) /(2*a))
Toremedy thisproblem, Hask ellallowsforlocal bindings. That is,wecancreate
values inside ofafunction that only that function cansee. Forinstance, wecould
create alocal binding forsqrt(b*b-4*a*c) andcallit,say,det andthen usethat
inboth places wheresqrt(b*b -4*a*c) occurred. Wecandothisusing alet/in
declaration:
rootsabc=
letdet=sqrt(b*b-4*a*c)
in((-b+det)/(2*a),
(-b-det)/(2*a))
Infact,youcanprovide multiple declarations inside alet.Justmakesure they‚Äôre
indented thesame amount, oryouwillhavelayout problems:
rootsabc=
letdet=sqrt(b*b-4*a*c)
twice_a =2*a
in((-b+det)/twice_a,
(-b-det)/twice_a)
28 CHAPTER 3.LANGUAGEBASICS
3.5.2 InÔ¨Åx
InÔ¨Åx functions areones thatarecomposed ofsymbols, rather than letters. Forinstance,
(+),(*),(++) areallinÔ¨Åx functions. Youcanusethem innon-inÔ¨Åx mode by
enclosing them inparentheses. Hence, thetwofollowing expressions arethesame:
Prelude> 5+10
15
Prelude> (+)510
15
Similarly ,non-inÔ¨Åx functions (likemap)canbemade inÔ¨Åx byenclosing them in
backquotes (theticks onthetilde keyonAmerican keyboards):
Prelude> mapChar.toUpper "HelloWorld"
"HELLOWORLD"
Prelude> Char.toUpper ‚Äòmap‚Äò"HelloWorld"
"HELLOWORLD"
WARNING Hugs users: Hugs doesn‚Äô tlikequaliÔ¨Åed names like
Char.toUpper .InHugs, simply usetoUpper .
3.6 Comments
There aretwotypes ofcomments inHask ell:linecomments andblock comments.
Line comments beginwith thetoken--andextend until theendoftheline. Block
comments beginwithf-andextend toacorresponding -g.Block comments canbe
nested.
NOTE The--inHask ellcorresponds to//inC++ orJava,andf-
and-gcorrespond to/*and*/.
Comments areused toexplain your program inEnglish andarecompletely ignored
bycompilers andinterpreters. Forexample:
moduleTest2
where
main=
putStrLn "HelloWorld" --writeastring
--tothescreen
{-fisafunction whichtakesaninteger and
produces integer. {-thisisanembedded
3.7.RECURSION 29
comment -}theoriginal comment extends tothe
matching end-comment token:-}
fx=
casexof
0->1--0mapsto1
1->5--1mapsto5
2->2--2mapsto2
_->-1--everything elsemapsto-1
This example program showstheuseofboth linecomments and(embedded) block
comments.
3.7 Recursion
Inimperati velanguages likeCandJava,themost basic control structure isaloop (like
aforloop). However,forloops don‚Äôtmakemuch sense inHask ellbecause theyrequire
destructi veupdate (the indexvariable isconstantly being updated). Instead, Hask ell
uses recursion.
Afunction isrecursiveifitcalls itself (seeAppendix Bformore). Recursi vefunc-
tions existalso inCandJavabutareused lessthan theyareinfunctional languages.
Theprototypical recursi vefunction isthefactorial function. Inanimperati velanguage,
youmight write thisassomething like:
intfactorial(int n){
intfact=1;
for(inti=2;i<=n;i++)
fact=fact*i;
returnfact;
}
While thiscode fragment willsuccessfully compute factorials forpositi veintegers,
itsomeho wignores thebasic deÔ¨Ånition offactorial, usually givenas:
n!=1 n=1
n(n 1)! otherwise
This deÔ¨Ånition itself isexactly arecursi vedeÔ¨Ånition: namely thevalue ofn!de-
pends onthevalue of(n 1)!.Ifyouthink of!asafunction, then itiscalling itself.
Wecantranslate thisdeÔ¨Ånition almost verbatim intoHask ellcode:
factorial 1=1
factorial n=n*factorial (n-1)
This islikelythesimplest recursi vefunction you‚Äôlleversee,butitiscorrect.
30 CHAPTER 3.LANGUAGEBASICS
NOTE Ofcourse, animperati verecursi veversion could bewritten:
intfactorial(int n){
if(n==1)
return1;
else
returnn*factorial(n-1);
}
butthisislikelytobemuch slowerthan theloop version inC.
Recursion canbeadifÔ¨Åcult thing tomaster .Itiscompletely analogous tothe
concept ofinduction inmathematics (see Chapter Bforamore formal treatment of
this). However,usually aproblem canbethought ofashaving oneormore base cases
andoneormore recursi ve-cases. Inthecase offactorial ,there isonebase case
(when n=1)andonerecursi vecase (when n>1).Fordesigning your ownrecusi ve
algorithms, itisoften useful totrytodifferentiate these twocases.
Turning nowtothetask ofexponentiation, suppose thatwehavetwopositi vein-
tegersaandb,andthatwewanttocalculate ab.This problem hasasingle base case:
namely whenbis1.Therecursi vecase iswhenb>1.Wecanwrite ageneral form as:
ab=a b=1
aab 1otherwise
Again,thistranslates directly intoHask ellcode:
exponent a1=a
exponent ab=a*exponent a(b-1)
Just aswecandeÔ¨Åne recursi vefunctions onintegers, socanwedeÔ¨Åne recursi ve
functions onlists. Inthiscase, usually thebase case istheempty list[],andthe
recursi vecase isacons list(i.e., avalue consed ontoanother list).
Consider thetask ofcalculating thelength ofalist.Wecanagainbreak thisdown
intotwocases: either wehaveanempty listorwehaveanon-empty list. Clearly the
length ofanempty listiszero. Furthermore, ifwehaveacons list,then thelength of
thislistisjustthelength ofitstailplus one. Thus, wecandeÔ¨Åne alength function as:
my_length []=0
my_length (x:xs)=1+my_length xs
NOTE Whene verweprovide alternati vedeÔ¨Ånitions forstandard
Hask ellfunctions, wepreÔ¨Åx them withmysothecompiler doesn‚Äô tbe-
come confused.
3.8.INTERACTIVITY 31
Similarly ,wecanconsider thefilter function. Again,thebase case istheempty
list,andtherecursi vecase isacons list. However,thistime, we‚Äôrechoosing whether
tokeepanelement, depending onwhether ornotaparticular predicate holds. Wecan
deÔ¨Åne theÔ¨Ålter function as:
my_filter p[]=[]
my_filter p(x:xs)=
ifpx
thenx:my_filter pxs
elsemy_filter pxs
Inthiscode, when presented with anempty list,wesimply return anempty list.
This isbecause Ô¨Ålter cannot addelements; itcanonly remo vethem.
When presented with alistoftheform(x:xs) ,weneed todecide whether ornot
tokeepthevaluex.Todothis, weuseanifstatement andthepredicatep.Ifpxis
true, then wereturn alistthatbegins withxfollowed bytheresult ofÔ¨Åltering thetail
ofthelist.Ifpxisfalse, then weexcludexandreturn theresult ofÔ¨Åltering thetailof
thelist.
Wecanalso deÔ¨Ånemap andboth fold functions using explicit recursion. Seethe
exercises forthedeÔ¨Ånition ofmap andChapter 7forthefolds.
Exer cises
Exer cise3.7TheÔ¨Åbonacci sequence isdeÔ¨Åned by:
Fn=
1 n=1orn=2
Fn 2+Fn 1otherwise
Write arecursive functionfib that takesapositive integernasaparameter and
calculates Fn.
Exer cise3.8DeÔ¨Åne arecursivefunctionmult thattakestwopositive integersaand
bandreturnsa*b,butonly uses addition (i.e.,nofairjustusing multiplication). Begin
bymaking amathematical deÔ¨Ånition inthestyle oftheprevious exerciseandtherestof
thissection.
Exer cise3.9DeÔ¨Åne arecursivefunctionmymap thatbehaves identically tothestan-
dardfunctionmap.
3.8 Interacti vity
Ifyouarefamiliar with books onother (imperati ve)languages, youmight bewonder -
ingwhyyouhaven‚Äôtseen manyofthestandard programs written intutorials ofother
languages (likeones thatasktheuser forhisname andthen says ‚ÄúHi‚Äù tohimbyname).
Thereason forthisissimple: Being apure functional language, itisnotentirely clear
howoneshould handle operations likeuser input.
32 CHAPTER 3.LANGUAGEBASICS
After all,suppose youhaveafunction thatreads astring from thekeyboard. If
youcallthisfunction twice, andtheuser types something theÔ¨Årsttime andsomething
else thesecond time, then younolonger haveafunction, since itwould return two
different values. The solution tothiswasfound inthedepths ofcategory theory ,a
branch offormal mathematics: monads. We‚Äôrenotyetready totalkabout monads monads
formally ,butfornow,think ofthem simply asaconvenient waytoexpress operations
likeinput/output. We‚Äôlldiscuss them inthisconte xtmuch more inChapter 5andthen
discuss monads formonads‚Äô sakeinChapter 9.
Suppose wewanttowrite afunction that‚Äôsinteracti ve.The waytodothisisto
usethedokeyword. This allowsustospecify theorder ofoperations (remember that donotation
normally ,since Hask ellisalazy language, theorder inwhich operations areevaluated
initisunspeciÔ¨Åed). So,towrite asimple program thatasks auser forhisname and
then address himdirectly ,enter thefollowing code into‚ÄúName.hs‚Äù:
moduleMain
where
importIO
main=do
hSetBuffering stdinLineBuffering
putStrLn "Please enteryourname:"
name<-getLine
putStrLn ("Hello, "++name++",howareyou?")
NOTE The parentheses arerequired onthesecond instance of
putStrLn butnottheÔ¨Årst. This isbecause++binds more tightly than
function application, sowithout theparenthesis, thesecond would be
interpreted as(putStrLn "Hello, ")++name++....
Youcanthen either load thiscode inyour interpreter andexecutemain bysimply
typing ‚Äúmain ,‚Äùoryoucancompile itandrunitfrom thecommand line. I‚Äôllshowthe
results oftheinteracti veapproach:
Main>main
Pleaseenteryourname:
Hal
Hello,Hal,howareyou?
Main>
And there‚Äô sinteracti vity.Let‚Äôsgoback andlook atthecode alittle, though. We
name themodule ‚ÄúMain, ‚Äùsothatwecancompile it.Wename theprimary function
‚Äúmain ,‚Äùsothatthecompile knowsthatthisisthefunction torunwhen theprogram
isrun. Onthefourth line, weimport theIOlibrary ,sothatwecanaccess theIO
3.8.INTERACTIVITY 33
functions. Ontheseventh line, westart with do,telling Hask ellthatwe‚Äôreexecuting a
sequence ofcommands.
TheÔ¨Årstcommand ishSetBuffering stdinLineBuffering ,which you
should probably ignore fornow(incidentally ,thisisonly required byGHC ‚ÄìinHugs
youcangetbywithout it).Thenecessity forthisisbecause, when GHC reads input, it
expects toread itinrather largeblocks. Atypical person‚Äô sname isnowhere near large
enough toÔ¨Ållthisblock. Thus, when wetrytoread fromstdin ,itwaitsuntil it‚Äôs
gotten awhole block. Wewanttogetridofthis, sowetellittouseLineBuffering
instead ofblock buffering.
The nextcommand isputStrLn ,which prints astring tothescreen. Onthe
ninth line, wesay‚Äúname<-getLine .‚ÄùThis would normally bewritten ‚Äúname=
getLine ,‚Äùbutusing thearrowinstead oftheequal sign showsthatgetLine isn‚Äôt
arealfunction andcanreturn different values. This command means ‚Äúrun theaction
getLine ,andstore theresults inname .‚Äù
Thelastlineconstructs astring using what weread intheprevious lineandthen
prints ittothescreen.
Another example ofafunction thatisn‚Äôtreally afunction would beonethatreturns
arandom value. Inthisconte xt,afunction thatdoes thisiscalledrandomRIO .Us-
ingthis, wecanwrite a‚Äúguess thenumber‚Äù program. Enter thefollowing code into
‚ÄúGuess.hs‚Äù:
moduleMain
where
importIO
importRandom
main=do
hSetBuffering stdinLineBuffering
num<-randomRIO (1::Int, 100)
putStrLn "I‚Äômthinking ofanumberbetween 1and100"
doGuessing num
doGuessing num=do
putStrLn "Enteryourguess:"
guess<-getLine
letguessNum =readguess
ifguessNum <num
thendoputStrLn "Toolow!"
doGuessing num
elseifreadguess>num
thendoputStrLn "Toohigh!"
doGuessing num
elsedoputStrLn "YouWin!"
Let‚Äôsexamine thiscode. OntheÔ¨Åfth linewewrite ‚Äúimport Random‚Äù totellthe
34 CHAPTER 3.LANGUAGEBASICS
compiler thatwe‚Äôregoing tobeusing some random functions (these aren‚Äô tbuiltinto
thePrelude). IntheÔ¨Årst line ofmain ,weaskforarandom number intherange
(1;100) .Weneed towrite::Int totellthecompiler thatwe‚Äôreusing integers here ‚Äì
notÔ¨Çoating point numbers orother numbers. We‚Äôlltalkmore about thisinSection 4.
Onthenextline, wetelltheuser what‚Äô sgoing on,andthen, onthelastlineofmain ,
wetellthecompiler toexecute thecommanddoGuessing .
ThedoGuessing function takesthenumber theuser istrying toguess asan
argument. First, itasks theuser toguess andthen accepts their guess (which isa
String )from thekeyboard. The ifstatement checks Ô¨Årst toseeiftheir guess istoo
low.However,sinceguess isastring, andnum isaninteger,weÔ¨Årstneed toconvert
guess toanintegerbyread ingit.Since ‚Äúreadguess ‚Äùisaplain, pure function
(and notanIOaction), wedon‚Äôtneed tousethe<-notation (infact,wecannot); we
simply bind thevalue toguessNum .Note thatwhile we‚Äôreindonotation, wedon‚Äôt
need insforlets.
Iftheyguessed toolow,weinform them andthen startdoGuessing overagain.
Iftheydidn‚Äô tguess toolow,wecheck toseeiftheyguessed toohigh. Iftheydid,
wetellthem andstartdoGuessing again.Otherwise, theydidn‚Äô tguess toolowand
theydidn‚Äô tguess toohigh, sotheymust havegotten itcorrect. Wetellthem thatthey
wonandexit.Thefactthatweexitisimplicit inthefactthatthere arenocommands
following this. Wedon‚Äôtneed anexplicitreturn()statement.
Youcaneither compile thiscode orload itintoyour interpreter ,andyouwillget
something like:
Main>main
I‚Äômthinking ofanumberbetween 1and100
Enteryourguess:
50
Toolow!
Enteryourguess:
75
Toolow!
Enteryourguess:
85
Toohigh!
Enteryourguess:
80
Toohigh!
Enteryourguess:
78
Toolow!
Enteryourguess:
79
YouWin!
Therecursi veaction thatwejustsawdoesn‚Äô tactually return avalue thatweusein
anyway.Inthecase when itdoes, the‚Äúobvious‚Äù waytowrite thecommand isactually
3.8.INTERACTIVITY 35
incorrect. Here, wewillgivetheincorrect version, explain whyitiswrong, then give
thecorrect version.
Let‚Äôssaywe‚Äôrewriting asimple program thatrepeatedly asks theuser totype ina
fewwords. Ifatanypoint theuser enters theempty word(i.e., hejusthitsenter without
typing anything), theprogram prints outeverything he‚Äôstyped upuntil thatpoint and
then exits. Theprimary function (actually ,anaction) inthisprogram isonethatasks
theuser foraword,checks toseeifit‚Äôsempty ,andthen either continues orends. The
incorr ectformulation ofthismight look something like:
askForWords =do
putStrLn "Please enteraword:"
word<-getLine
ifword==""
thenreturn[]
elsereturn(word:askForWords)
Before reading ahead, seeifyoucanÔ¨Ågure outwhat iswrong with theabovecode.
Theerror isonthelastline, speciÔ¨Åcally with thetermword:askForWords .
Remeber thatwhen using (:),wearemaking alistoutofanelement (inthiscase
word )andanother list(inthiscase,askForWords ).However,askForWords is
notalist;itisanaction that, when run,willproduce alist.That means thatbefore we
canattach anything tothefront, weneed toruntheaction andtaketheresult. Inthis
case, wewanttodosomething like:
askForWords =do
putStrLn "Please enteraword:"
word<-getLine
ifword==""
thenreturn[]
elsedo
rest<-askForWords
return(word:rest)
Here, weÔ¨ÅrstrunaskForWords ,taketheresult andstore itinthevariablerest .
Then ,wereturn thelistcreated fromword andrest .
Bynow,youshould haveagood understanding ofhowtowrite simple functions,
compile them, testfunctions andprograms intheinteracti veenvironment, andmanip-
ulate lists.
Exer cises
Exer cise3.10 Write aprogramthatwillrepeatedly asktheuser fornumber suntil she
types inzero,atwhichpoint itwilltellherthesum ofallthenumber s,theproduct of
allthenumber s,and, foreachnumber ,itsfactorial. Forinstance ,asession might look
like:
36 CHAPTER 3.LANGUAGEBASICS
Give meanumber (or0tostop):
5
Give meanumber (or0tostop):
8
Give meanumber (or0tostop):
2
Give meanumber (or0tostop):
0
Thesumis15
Theproduct is80
5factorial is120
8factorial is40320
2factorial is2
Hint: write anIOaction thatreads anumber and, ifit‚Äôszero,returns theempty list.If
it‚Äôsnotzero,itrecursesitself andthen makesalistoutofthenumber itjustreadand
theresult oftherecursivecall.
Chapter4
TypeBasics
Hask elluses asystem ofstatic type checking.This means thateveryexpression in
Hask ellisassigned atype.Forinstance ‚Äôa‚Äôwould havetypeChar,for‚Äúcharacter .‚Äù
Then, ifyouhaveafunction which expects anargument ofacertain type andyougive
itthewrong type, acompile-time error willbegenerated (that is,youwillnotbeable
tocompile theprogram). This vastly reduces thenumber ofbugsthatcancreep into
your program.
Furthermore, Hask elluses asystem oftype inference.This means thatyoudon‚Äôt
evenneed tospecify thetype ofexpressions. Forcomparison, inC,when youdeÔ¨Åne
avariable, youneed tospecify itstype (forinstance, int,char,etc.). InHask ell,you
needn‚Äô tdothis‚Äìthetype willbeinferred from conte xt.
NOTE Ifyouwant,youcertainly areallowed toexplicitely specify
thetype ofanexpression; thisoften helps debugging. Infact,itissome-
times considered good style toexplicitly specify thetypes ofoutermost
functions.
Both Hugs andGHCi allowyoutoapply type inference toanexpression toÔ¨Åndits
type. This isdone byusing the:tcommand. Forinstance, start upyour favorite shell
andtrythefollowing:
Prelude> :t‚Äôc‚Äô
‚Äôc‚Äô::Char
This tells usthat theexpression ‚Äôc‚ÄôhastypeChar(the double colon ::isused
throughout Hask elltospecify types).
4.1 Simple Types
There areaslewofbuilt-in types, including Int(forintegers, both positi veandneg-
ative),Double (forÔ¨Çoating point numbers), Char(forsingle characters), String (for
37
38 CHAPTER 4.TYPEBASICS
strings), andothers. Wehavealready seen anexpression oftypeChar;let‚Äôsexamime
oneoftypeString :
Prelude> :t"Hello"
"Hello" ::String
Youcanalsoenter more complicated expressions, forinstance, atestofequality:
Prelude> :t‚Äôa‚Äô==‚Äôb‚Äô
‚Äôa‚Äô==‚Äôb‚Äô::Bool
Youshould note than eventhough thisexpression isfalse, itstillhasatype, namely
thetypeBool.
NOTEBoolisshort forBoolean (usually pronounced ‚Äúboo-lee-uhn‚Äù,
though I‚Äôveheard ‚Äúboo-leen‚Äù once ortwice) andhastwopossible values:
True andFalse .
Youcanobserv etheprocess oftype checking andtype inference bytrying toget
theshell togiveyouthetype ofanill-typed expression. Forinstance, theequality
operator requires thatthetype ofboth ofitsarguments areofthesame type. Wecan
seethatCharandString areofdifferent types bytrying tocompare acharacter toa
string:
Prelude> :t‚Äôa‚Äô=="a"
ERROR-Typeerrorinapplication
***Expression :‚Äôa‚Äô=="a"
***Term :‚Äôa‚Äô
***Type :Char
***Doesnotmatch:[Char]
TheÔ¨Årstlineoftheerror (thelinecontaining ‚ÄúExpression‚Äù) tells ustheexpression
inwhich thetype error occured. Thesecond linetells uswhich partofthisexpression
isill-typed. The third linetells ustheinferred type ofthisterm andthefourth line
tells uswhat itneeds tohavematched. Inthiscase, itsays thattype typeChardoesn‚Äô t
match thetype[Char](alistacharacters ‚Äìastring inHask ellisrepresented asalistof
characters).
Asmentioned before, youcanexplicitely specify thetype ofanexpression using
the::operator .Forinstance, instead of‚Äùa‚Äùintheprevious example, wecould have
written (‚Äùa‚Äù::String). Inthiscase, thishasnoeffectsince there‚Äô sonly onepossible
interpretation of‚Äùa‚Äù. However,consider thecase ofnumbers. Youcantry:
Prelude> :t5::Int
5::Int
Prelude> :t5::Double
5::Double
4.2.POLYMORPHIC TYPES 39
Here, wecanseethatthenumber 5canbeinstantiated aseither anIntouraDouble .
What ifwedon‚Äôtspecify thetype?
Prelude> :t5
5::Numa=>a
Notquite what youexpected? What thismeans, brieÔ¨Çy ,isthatifsome type ais
aninstance oftheNum class, then type type oftheexpression 5canbeoftype a.
Ifthatmade nosense, that‚Äôsokay fornow.InSection 4.3wetalkextensi velyabout
type classes (which iswhat thisis).Thewaytoread this, though, istosay‚Äúabeing an
instance ofNum implies a.‚Äù
Exer cises
Exer cise4.1Figureoutforyourself,andthen verify thetypes ofthefollowing expres-
sions, iftheyhave atype.Also note iftheexpression isatype error:
1.‚Äôh‚Äô:‚Äôe‚Äô:‚Äôl‚Äô:‚Äôl‚Äô:‚Äôo‚Äô:[]
2.[5,‚Äôa‚Äô]
3.(5,‚Äôa‚Äô)
4.(5::Int) +10
5.(5::Int) +(10::Double)
4.2 Polymor phic Types
Hask ellemplo ysapolymorhpic type system. This essentially means thatyoucanhave
type variables ,which wehavealluded tobefore. Forinstance, note thatafunction like
tail doesn‚Äô tcare what theelements inthelistare:
Prelude> tail[5,6,7,8,9]
[6,7,8,9]
Prelude> tail"hello"
"ello"
Prelude> tail["the","man","is","happy"]
["man","is","happy"]
This ispossible becausetail hasapolymorphic type:[]![].That means it
cantakeasanargument anylistandreturn avalue which isalistofthesame type.
Thesame analysis canexplain thetype offst:
Prelude> :tfst
forallab.(a,b)->a
40 CHAPTER 4.TYPEBASICS
Here, GHCi hasmade explicit theuniver salquantiÔ¨Åcation ofthetype values. That
is,itissaying thatforalltypesaandb,fst isafunction from(a;b)toa.
Exer cises
Exer cise4.2Figureoutforyourself,andthen verify thetypes ofthefollowing expres-
sions, iftheyhave atype.Also note iftheexpression isatype error:
1.snd
2.head
3.null
4.head.tail
5.head.head
4.3 TypeClasses
Wesawlastsection some strange typing having todowith thenumber Ô¨Åve.Before we
delvetoodeeply intothesubject oftype classes, let‚Äôstakeastepback andseesome of
themotivation.
4.3.1 Moti vation
Inmanylanguages (C++, Java,etc.), there exists asystem ofoverloading. That is,
afunction canbewritten thattakesparameters ofdiffering types. Forinstance, the
cannonical example istheequality function. Ifwewanttocompare twointegers, we
should useanintegercomparison; ifwewanttocompare twoÔ¨Çoating point numbers,
weshould useaÔ¨Çoating point comparison; ifwewanttocompare twocharacters,
weshould useacharacter comparison. Ingeneral, ifwewanttocompare twothings
which havetype,wewanttousean-compare. Wecallatype variable since itis
avariable whose value isatype.
NOTE Ingeneral, type variables willbewritten using theÔ¨Årstpartof
theGreek alphabet: ;;;;:::.
Unfortunately ,thispresents some problems forstatic type checking, since thetype
check erdoesn‚Äô tknowwhich types acertain operation (forinstance, equality testing)
willbedeÔ¨Åned for.There areasmanysolutions tothisproblem asthere arestatically
typed languages (perhaps aslight exageration, butnotsomuch so). Theonechosen
inHask ellisthesystem oftype classes. Whether thisisthe‚Äúcorrect‚Äù solution orthe
‚Äúbest‚Äù solution ofcourse depends onyour application domain. Itis,however,theone
wehave,soyoushould learn toloveit.
4.3.TYPECLASSES 41
4.3.2 Equality Testing
Returning totheissue ofequality testing, what wewanttobeable todoisdeÔ¨Åne a
function ==(theequality operator) which takestwoparameters, each ofthesame type
(call it),andreturns aboolean. Butthisfunction may notbedeÔ¨Åned forevery type;
justforsome. Thus, weassociate thisfunction ==with atype class, which wecall
Eq.IfaspeciÔ¨Åc typebelongs toacertain type class (that is,allfunctions associated
with thatclass areimplemented for),wesaythatisaninstance ofthatclass. For
instance, Intisaninstance ofEqsince equality isdeÔ¨Åned overintegers.
4.3.3 The Num Class
Inaddition tooverloading operators like==,Hask ellhasoverloaded numeric constants
(i.e., 1,2,3,etc.). This wasdone sothat when you type inanumber like5,the
compiler isfreetosay5isanintegerorÔ¨Çoating point number asitsees Ô¨Åt.ItdeÔ¨Ånes
theNum class tocontain allofthese numbers andcertain minimal operations over
them (addition, forinstance). Thebasic numeric types (Int, Double) aredeÔ¨Åned tobe
instances ofNum .
Wehaveonly skimmed thesurfaceofthepower(and comple xity) oftype classes
here. There willbemuch more discussion ofthem inSection 8.4,butweneed some
more background before wecangetthere. Before wedothat, weneed totalkalittle
more about functions.
4.3.4 The ShowClass
Another ofthestandard classes inHask ellistheShowclass. Types which aremem-
bers oftheShowclass havefunctions which convertvalues ofthattype toastring.
This function iscalledshow .Forinstanceshow applied totheinteger5isthestring
‚Äú5‚Äù;show applied tothecharacter ‚Äôa‚Äôisthethree-character string ‚Äú‚Äôa‚Äù‚Äô (theÔ¨Årstand
lastcharacters areapostrophes). show applied toastring simply puts quotes around it.
Youcantestthisintheinterpreter:
Prelude> show5
"5"
Prelude> show‚Äôa‚Äô
"‚Äôa‚Äô"
Prelude> show"HelloWorld"
"\"Hello World\""
NOTE Thereason thebackslashes appear inthelastlineisbecause
theinterior quotes are‚Äúescaped‚Äù, meaning thattheyarepartofthestring,
notpart oftheinterpreter printing thevalue. The actual string doesn‚Äô t
contain thebackslashes.
Some types arenote instances ofShow;functions forexample. Ifyoutrytoshowa
function (likesqrt ),thecompiler orinterpreter willgiveyousome cryptic error mes-
42 CHAPTER 4.TYPEBASICS
sage, complaining about amissing instance declaration oranillegalclass constraint.
4.4 Function Types
InHask ell,functions areÔ¨Årstclass values ,meaning thatjustas1or‚Äôc‚Äô arevalues
which haveatype, soarefunctions likesquare or++.Before wetalktoomuch about
functions, weneed tomakeashort diversion into verytheoretical computer science
(don‚Äô tworry,itwon‚Äôtbetoopainful) andtalkabout thelambda calculus.
4.4.1 Lambda Calculus
Thename ‚ÄúLambda Calculus‚Äù, while perhaps daunting, describes afairly simple sys-
temforrepresenting functions. Thewaywewould write asquaring function inlambda
calculus is:x:xx,which means thatwetakeavalue, which wewillcallx(that‚Äô swhat
‚Äúx:means) andthen multiply itbyitself. Theiscalled ‚Äúlambda abstraction. ‚ÄùIn
general, lambdas canonly haveoneparameter .Ifwewanttowrite afunction thattakes
twonumbers, doubles theÔ¨Årstandadds ittothesecond, wewould write: xy:2x+y.
When weapply avalue toalambda expression, weremo vetheoutermost andreplace
everyoccurrence ofthelambda variable with thevalue. Forinstance, ifweevaluate
(x:xx)5,weremo vethelambda andreplace everyoccurrence ofxwith5,yielding
(55)which is25.
Infact,Hask ellislargely based onanextension ofthelambda calculus, andthese
twoexpressions canbewritten directly inHask ell(wesimply replace thewith a
backslash andthe:with anarrow;also wedon‚Äôtneed torepeat thelambdas; and, of
course, inHask ellwehavetogivethem names ifwe‚ÄôredeÔ¨Åning functions):
square=\x->x*x
f=\xy->2*x+y
Youcanalsoevaluate lambda expressions inyour interacti veshell:
Prelude> (\x->x*x)5
25
Prelude> (\xy->2*x+y)54
14
Wecanseeinthesecond example thatweneed togivethelambda abstraction two
arguments, onecorresponding toxandtheother corresponding toy.
4.4.2 Higher -Order Types
‚ÄúHigher -Order Types‚Äù isthename giventofunctions. Thetype giventofunctions mim-
icksthelambda calculus representation ofthefunctions. Forinstance, thedeÔ¨Ånition of
square givesx:xx.Togetthetype ofthis, weÔ¨Årstaskourselv eswhat thetype ofx
4.4.FUNCTION TYPES 43
is.SaywedecidexisanInt.Then, wenotice thatthefunctionsquare takesanInt
andproduces avaluex*x.Weknowthatwhen wemultiply twoIntstogether ,weget
another Int,sothetype oftheresults ofsquare isalsoanInt.Thus, wesaythetype
ofsquare isInt!Int.
Wecanapply asimilar analysis tothefunctionfabove.Thevalue ofthisfunction
(remember ,functions arevalues) issomething which takesavaluexandgiventhat
value, produces anewvalue, which takesavalueyandproduces2*x+y .Forinstance,
ifwetakefandapply only onenumber toit,weget(xy:2x+y)5which becomes
ournewvaluey:2(5)+y,where alloccurances ofxhavebeen replaced with the
applied value,5.
SoweknowthatftakesanIntandproduces avalue ofsome type, ofwhich we‚Äôre
notsure. Butweknowthetype ofthisvalue isthetype ofy:2(5)+y.Weap-
plytheaboveanalysis andÔ¨Ånd outthatthisexpression hastypeInt!Int.Thus,f
takesanIntandproduces something which hastypeInt!Int.Sothetype offis
Int!(Int!Int).
NOTE The parentheses arenotnecessary; infunction types, ifyou
have!!itisassume that!isgrouped. Ifyouwantthe
other way,with!grouped, youneed toputparentheses around
them.
This isn‚Äôtentirely accurate. Aswesawbefore, numbers like5aren‚Äô treally oftype
Int,theyareoftypeNuma)a.
Wecaneasily Ô¨Åndthetype ofPrelude functions using ‚Äú:t‚Äùasbefore:
Prelude> :thead
head::[a]->a
Prelude> :ttail
tail::[a]->[a]
Prelude> :tnull
null::[a]->Bool
Prelude> :tfst
fst::(a,b)->a
Prelude> :tsnd
snd::(a,b)->b
Weread thisas:‚Äúhead‚Äù isafunction thattakesalistcontaining values oftype ‚Äúa‚Äù
andgivesback avalue oftype ‚Äúa‚Äù;‚Äútail‚Äù takesalistof‚Äúa‚Äùs andgivesback another list
of‚Äúa‚Äùs; ‚Äúnull‚Äù takesalistof‚Äúa‚Äùs andgivesback aboolean; ‚Äúfst‚Äù takesapairoftype
‚Äú(a,b)‚Äù andgivesback something oftype ‚Äúa‚Äù,andsoon.
NOTE Saying thatthetype offst is(a;b)!adoes notnecessarily
mean thatitsimply givesback theÔ¨Årst element; itonly means thatit
givesback something with thesame type astheÔ¨Årstelement.
44 CHAPTER 4.TYPEBASICS
Wecanalsogetthetype ofoperators like+and*and++and:;however,inorder
todothisweneed toputthem inparentheses. Ingeneral, anyfunction which isused
inÔ¨Åx (meaning inthemiddle oftwoarguments rather than before them) must beputin
parentheses when getting itstype.
Prelude> :t(+)
(+)::Numa=>a->a->a
Prelude> :t(*)
(*)::Numa=>a->a->a
Prelude> :t(++)
(++)::[a]->[a]->[a]
Prelude> :t(:)
(:)::a->[a]->[a]
Thetypes of+and*arethesame, andmean that+isafunction which, forsome
typeawhich isaninstance ofNum ,takesavalue oftypeaandproduces another
function which takesavalue oftypeaandproduces avalue oftypea.Inshort hand,
wemight saythat+takestwovalues oftypeaandproduces avalue oftypea,butthis
islessprecise.
Thetype of++means, inshorthand, that, foragiventypea,++takestwolists of
asandproduces anewlistofas.Similarly ,:takesavalue oftypeaandanother value
oftype[a](listofas)andproduces another value oftype[a].
4.4.3 That PeskyIOType
Youmight betempted totrygetting thetype ofafunction likeputStrLn :
Prelude> :tputStrLn
putStrLn ::String->IO()
Prelude> :treadFile
readFile ::FilePath ->IOString
What intheworld isthatIOthing? It‚Äôsbasically Hask ell‚Äôswayofrepresenting
thatthese functions aren‚Äô treally functions. They‚Äôrecalled ‚ÄúIOActions‚Äù (hence the
IO).The immediate question which arises is:okay,sohowdoIgetridoftheIO.
Inbrief, youcan‚Äôtdirectly remo veit.That is,youcannot write afunction with type
IOString !String .Theonly waytousethings with anIOtype istocombine them
with other functions using (forexample), thedonotation.
Forexample, ifyou‚Äôrereading aÔ¨ÅleusingreadFile ,presumably youwant todo
something with thestring itreturns (otherwise, whywould youread theÔ¨ÅleintheÔ¨Årst
place). Suppose youhaveafunctionfwhich takesaString andproduces anInt.You
can‚Äôtdirectly applyftotheresult ofreadFile since theinput tofisString andthe
output ofreadFile isIOString andthese don‚Äôtmatch. However,youcancombine
these as:
4.4.FUNCTION TYPES 45
main=do
s<-readFile "somefile"
leti=fs
putStrLn (showi)
Here, weusethearrowconvention to‚Äúget thestring outoftheIOaction‚Äù andthen
applyftothestring (calleds).Wethen, forexample, printitothescreen. Note that
thelethere doesn‚Äô thaveacorresponding in.This isbecause weareinadoblock.
Also note thatwedon‚Äôtwritei<-fsbecausefisjustanormal function, notan
IOaction.
4.4.4 Explicit TypeDeclarations
Itissometimes desirable toexplicitly specify thetypes ofsome elements orfunctions,
forone(ormore) ofthefollowing reasons:
Clarity
Speed
Debugging
Some people consider itgood softw areengineering tospecify thetypes ofalltop-
levelfunctions. Ifnothing else, ifyou‚Äôretrying tocompile aprogram andyougettype
errors thatyoucannot understand, ifyoudeclare thetypes ofsome ofyour functions
explicitly ,itmay beeasier toÔ¨Ågure outwhere theerror is.
Typedeclarations arewritten separatly from thefunction deÔ¨Ånition. Forinstance,
wecould explicitly type thefunctionsquare asinthefollowing code (anexplicitly
declared type iscalled atype signatur e):
square::Numa=>a->a
squarex=x*x
These twolines donotevenhavetobenexttoeachother .However,thetype thatyou
specify must match theinferred type ofthefunction deÔ¨Ånition (orbemore speciÔ¨Åc).
InthisdeÔ¨Ånition, youcould applysquare toanything which isaninstance ofNum :
Int,Double ,etc. However,ifyouknewapriori thatsquare were only going tobe
applied tovalue oftypeInt,youcould reÔ¨Åne itstype as:
square::Int->Int
squarex=x*x
Now,youcould only applysquare tovalues oftypeInt.Moreo ver,with thisdef-
inition, thecompiler doesn‚Äô thavetogenerate thegeneral code speciÔ¨Åed intheoriginal
46 CHAPTER 4.TYPEBASICS
function deÔ¨Ånition since itknowsyouwillonly applysquare toInts,soitmay be
able togenerate faster code.
Ifyouhaveextensions turned on(‚Äú-98‚Äù inHugs or‚Äú-fglasgo w-exts‚Äù inGHC(i)),
youcanalso addatype signature toexpressions andnotjustfunctions. Forinstance,
youcould write:
square(x::Int)=x*x
which tells thecompiler thatxisanInt;however,itleavesthecompiler alone
toinfer thetype oftherestoftheexpression. What isthetype ofsquare inthis
example? Makeyour guess then youcancheck iteither byentering thiscode intoaÔ¨Åle
andloading itintoyour interpreter orbyasking forthetype oftheexpression:
Prelude> :t(\(x::Int)->x*x)
since thislambda abstraction isequivalent totheabovefunction declaration.
4.4.5 Functional Arguments
InSection 3.3wesawexamples offunctions taking other functions asarguments. For
instance,map took afunction toapply toeach element inalist,filter took afunc-
tionthattolditwhich elements ofalisttokeep,andfoldl took afunction which told
ithowtocombine listelements together .Aswith everyother function inHask ell,these
arewell-typed.
Let‚ÄôsÔ¨Årst think about themap function. It‚Äôsjobistotakealistofelements and
produce another listofelements. These twolists don‚Äôtnecessarily havetohavethe
same types ofelements. Somap willtakeavalue oftype[a]andproduce avalue of
type[b].Howdoes itdothis? Ituses theuser-supplied function toconvert.Inorder
toconvertanatoab,thisfunction must havetypea!b.Thus, thetype ofmap is
(a!b)![a]![b],which youcanverify inyour interpreter with ‚Äú:t‚Äù.
Wecanapply thesame sortofanalysis tofilter anddiscern thatithastype
(a!Bool)![a]![a].Aswepresented thefoldl function, youmight betempted
togiveittype(a!a!a)!a![a]!a,meaning thatyoutakeafunction which
combines twoasintoanother one, aninitial valueoftypea,alistofastoproduce aÔ¨Ånal
valueoftypea.Infact,foldl hasamore general type:(a!b!a)!a![b]!a.
Soittakesafunction which turnanaandabintoana,aninitial value oftypeaanda
listofbs.Itproduces ana.
Toseethis, wecanwrite afunctioncount which counts howmanymembers ofa
listsatisfy agivenconstraint. Youcanofcourse youfilter andlength todothis,
butwewillalsodoitusingfoldr :
moduleCount
where
importChar
4.5.DATATYPES 47
count1pl=length(filter pl)
count2pl=foldr(\xc->ifpxthenc+1elsec)0l
Thefunctioning ofcount1 issimple. ItÔ¨Ålters thelistlaccording tothepredicate
p,then takesthelength oftheresulting list.Ontheother hand,count2 uses theintial
value (which isaninteger) tohold thecurrent count. Foreach element inthelistl,
itapplies thelambda expression shown.This takestwoarguments,cwhich holds the
current count andxwhich isthecurrent element inthelistthatwe‚Äôrelooking at.It
checks toseeifpholds aboutx.Ifitdoes, itreturns thenewvaluec+1,increasing the
count ofelements forwhich thepredicate holds. Ifitdoesn‚Äô t,itjustreturnsc,theold
count.
Exer cises
Exer cise4.3Figureoutforyourself,andthen verify thetypes ofthefollowing expres-
sions, iftheyhave atype.Also note iftheexpression isatype error:
1.nx->[x]
2.nxyz->(x,y:z:[])
3.nx->x+5
4.nx->"hello, world"
5.nx->x‚Äôa‚Äô
6.nx->xx
7.nx->x+x
4.5 Data Types
Tuples andlists arenice, common waystodeÔ¨Åne structured values. However,itis
often desirable tobeable todeÔ¨Åne ourowndata structures andfunctions overthem.
So-called ‚Äúdatatypes‚Äù aredeÔ¨Åned using thedata keyword.
4.5.1 Pairs
Forinstance, adeÔ¨Ånition ofapairofelements (much likethestandard, build-in pair
type) could be:
dataPairab=Pairab
48 CHAPTER 4.TYPEBASICS
Let‚Äôswalkthrough thiscode onewordatatime. First wesay‚Äúdata‚Äù meaning that
we‚ÄôredeÔ¨Åning adatatype. Wethen givethename ofthedatatype, inthiscase, ‚ÄúPair.‚Äù
The‚Äúa‚Äùand‚Äúb‚Äùthatfollow‚ÄúPair‚Äùaretype parameters, justlikethe‚Äúa‚Äùisthetype of
thefunctionmap.Soupuntil thispoint, we‚Äôvesaid thatwe‚Äôregoing todeÔ¨Åne adata
structure called ‚ÄúPair‚Äùwhich isparameterized overtwotypes, aandb.
After theequals sign, wespecify theconstructor softhisdata type. Inthiscase,
there isasingle constructor ,‚ÄúPair‚Äù(this doesn‚Äô tnecessarily havetohavethesame
name asthetype, butinthiscase itseems tomakemore sense). After thispair,we
againwrite ‚Äúab‚Äù,which means thatinorder toconstruct aPair weneed twovalues,
oneoftypeaandoneoftypeb.
This deÔ¨Ånition introduces afunction,Pair::a->b->Pairabthat
youcanusetoconstructPair s.Ifyouenter thiscode intoaÔ¨Åleandload it,youcan
seehowthese areconstructed:
Datatypes> :tPair
Pair::a->b->Pairab
Datatypes> :tPair‚Äôa‚Äô
Pair‚Äôa‚Äô::a->PairChara
Datatypes> :tPair‚Äôa‚Äô"Hello"
:tPair‚Äôa‚Äô"Hello"
Pair‚Äôa‚Äô"Hello" ::PairChar[Char]
So,bygivingPair twovalues, wehavecompletely constructed avalue oftype
Pair.Wecanwrite functions involving pairs as:
pairFst (Pairxy)=x
pairSnd (Pairxy)=y
Inthis, we‚Äôveused thepattern matc hing capabilities ofHask elltolook atapair
anextract values from it.InthedeÔ¨Ånition ofpairFst wetakeanentirePair and
extract theÔ¨Årst element; similarly forpairSnd .We‚Äôlldiscuss pattern matching in
much more detail inSection 7.4.
Exer cises
Exer cise4.4Write adata type declar ation forTriple ,atype whichcontains three
elements, allofdifferenttypes. Write functionstripleFst ,tripleSnd andtripleThr
toextractrespectively theÔ¨Årst,second andthirdelements.
Exer cise4.5Write adatatypeQuadruple whichholds four elements. Howe ver,the
Ô¨Årsttwoelements must bethesame type andthelasttwoelements must bethesame
type.Write afunctionfirstTwo whichreturns alistcontaining theÔ¨Årsttwoelements
andafunctionlastTwo whichreturns alistcontaining thelasttwoelements. Write
type signatur esforthese functions
4.5.DATATYPES 49
4.5.2 Multiple Constructors
Wehaveseen anexample ofthedata type with oneconstructor: Pair .Itisalso
possible (and extremely useful) tohavemultiple constructors.
Letusconsider asimple function which searches through alistforanelement
satisfying agivenpredicate andthen returns theÔ¨Årstelement satisfying thatpredicate.
What should wedoifnone oftheelements inthelistsatisfy thepredicate? Afew
options arelisted below:
Raise anerror
Loop indeÔ¨Ånitely
Write acheck function
Return theÔ¨Årstelement
:::
Raising anerror iscertainly anoption (see Section 10.1 toseehowtodothis).
The problem isthat itisdifÔ¨Åcult/impossible torecoverfrom such errors. Looping
indeÔ¨Ånitely ispossible, butnotterribly useful. Wecould write asister function which
checks toseeifthelistcontains anelement satisfying apredicate andleaveituptothe
user toalwaysusethisfunction Ô¨Årst. Wecould return theÔ¨Årstelement, butthisisvery
ad-hoc anddifÔ¨Åcult toremember .
Thefactthatthere isnobasic option tosolvethisproblem simply means wehaveto
think about italittle more. What arewetrying todo?We‚Äôretrying towrite afunction
which might succeed andmight not. Furthermore, ifitdoes succeed, itreturns some
sortofvalue. Let‚Äôswrite adatatype:
dataMaybea=Nothing
|Justa
This isoneofthemost common datatypes inHask ellandisdeÔ¨Åned inthePrelude.
Here, we‚Äôresaying thatthere aretwopossible waystocreate something oftype
Maybea.The Ô¨Årst istousethenullary constructor Nothing ,which takesnoar-
guments (this iswhat ‚Äúnullary‚Äù means). Thesecond istousetheconstructor Just ,
together with avalue oftypea.
TheMaybe type isuseful inallsorts ofcircumstances. Forinstance, suppose
wewanttowrite afunction (likehead )which returns theÔ¨Årst element ofagiven
list. However,wedon‚Äôtwanttheprogram todieifthegivenlistisempty .Wecan
accomplish thiswith afunction like:
firstElement ::[a]->Maybea
firstElement []=Nothing
firstElement (x:xs)=Justx
50 CHAPTER 4.TYPEBASICS
Thetype signature here says thatfirstElement takesalistofasandproduces
something with typeMaybea.IntheÔ¨Årstlineofcode, wematch against theempty
list[].Ifthismatch succeeds (i.e., thelistis,infact,empty), wereturnNothing .If
theÔ¨Årstmatch fails, then wetrytomatch againstx:xs which must succeed. Inthis
case, wereturnJustx.
ForourfindElement function, werepresent failure bythevalueNothing and
success with valueabyJusta.Ourfunction might look something likethis:
findElement ::(a->Bool)->[a]->Maybea
findElement p[]=Nothing
findElement p(x:xs)=
ifpxthenJustx
elsefindElement pxs
The Ô¨Årst linehere givesthetype ofthefunction. Inthiscase, ourÔ¨Årst argument
isthepredicate (and takesanelement oftypeaandreturnsTrue ifandonly ifthe
element satisÔ¨Åes thepredicate); thesecond argument isalistofas.Ourreturn value
ismaybe ana.That is,ifthefunction succeeds, wewill returnJustaandifnot,
Nothing .
Another useful datatype istheEither type, deÔ¨Åned as:
dataEitherab=Lefta
|Rightb
This isawayofexpressing alternation. That is,something oftypeEitherab
iseither avalue oftypea(using theLeft constructor) oravalue oftypeb(using the
Right constructor).
Exer cises
Exer cise4.6Write adatatypeTuple whichcanhold one,two, threeorfourelements,
depending ontheconstructor (that is,thereshould befour constructor s,oneforeach
number ofarguments). Also provide functionstuple1 throughtuple4 whichtakea
tuple andreturnJust thevalue inthatposition, orNothing ifthenumber isinvalid
(i.e.,youaskforthetuple4 onatuple holding only twoelements).
Exer cise4.7Based onourdeÔ¨Ånition ofTuple fromtheprevious exercise,write a
function whichtakesaTuple and returns either thevalue (ifit‚Äôsaone-tuple), a
Hask ell-pair (i.e.,(‚Äôa‚Äô,5) )ifit‚Äôsatwo-tuple ,aHask ell-triple ifit‚Äôsathree-tuple
oraHask ell-quadruple ifit‚Äôsafour-tuple .Youwillneed tousetheEither type to
represent this.
4.5.DATATYPES 51
4.5.3 Recursi veDatatypes
Wecanalso deÔ¨Åne recursive datatypes. These aredatatypes whose deÔ¨Ånitions are
based onthemselv es.Forinstance, wecould deÔ¨Åne alistdatatype as:
dataLista=Nil
|Consa(Lista)
InthisdeÔ¨Ånition, wehavedeÔ¨Åned what itmeans tobeoftypeLista.Wesaythata
listiseither empty (Nil)orit‚ÄôstheCons ofavalue oftypeaandanother value oftype
Lista.This isalmost identical totheactual deÔ¨Ånition ofthelistdatatype inHask ell,
except thatuses special syntax where[]corresponds toNil and:corresponds to
Cons .Wecanwrite ourownlength function forourlistsas:
listLength Nil=0
listLength (Consxxs)=1+listLength xs
This function isslightly more complicated and uses recursion tocalculate the
length ofaList .The Ô¨Årst linesays thatthelength ofanempty list(aNil)is0.
This much isobvious. Thesecond linetells ushowtocalculate thelength ofanon-
empty list. Anon-empty listmust beoftheformConsxxsforsome values ofx
andxs.Weknowthatxsisanother listandweknowthatwhate verthelength ofthe
current listis,it‚Äôsthelength ofitstail(thevalue ofxs)plus one(toaccount forx).
Thus, weapply thelistLength function toxsandaddonetotheresult. This gives
usthelength oftheentire list.
Exer cises
Exer cise4.8Write functionslistHead ,listTail ,listFoldl andlistFoldr
whichareequivalent totheir Prelude twins, butfunction onourList datatype .Don‚Äô t
worry about exceptional conditions ontheÔ¨Årsttwo.
4.5.4 Binary Trees
WecandeÔ¨Åne datatypes that aremore complicated that lists. Suppose wewantto
deÔ¨Åne astructure thatlooks likeabinary tree. Abinary treeisastructure thathasa
single root node; each node inthetreeiseither a‚Äúleaf ‚Äùora‚Äúbranch. ‚ÄùIfit‚Äôsaleaf, it
holds avalue; ifit‚Äôsabranch, itholds avalue andaleftchild andaright child. Each of
these children isanother node. WecandeÔ¨Åne such adata type as:
dataBinaryTree a
=Leafa
|Branch(BinaryTree a)a(BinaryTree a)
Inthisdatatype declaration wesaythataBinaryTree ofasiseither aLeaf
which holds ana,orit‚Äôsabranch with aleftchild (which isaBinaryTree ofas),a
52 CHAPTER 4.TYPEBASICS
node value (which isana),andaright child (which isalsoaBinaryTree ofas).Itis
simple tomodify thelistLength function sothatinstead ofcalculating thelength
oflists, itcalculates thenumber ofnodes inaBinaryTree .CanyouÔ¨Ågure outhow?
WecancallthisfunctiontreeSize .Thesolution isgivenbelow:
treeSize (Leafx)=1
treeSize (Branch leftxright)=
1+treeSize left+treeSize right
Here, wesaythatthesizeofaleafis1andthesizeofabranch isthesizeofitsleft
child, plus thesizeofitsright child, plus one.
Exer cises
Exer cise4.9Write afunctionelements whichreturns theelements inaBinaryTree
inabottom-up, left-to-right manner (i.e.,theÔ¨Årstelement returned intheleft-most leaf,
followed byitsparent‚Äôsvalue ,followed bytheother child‚Äôsvalue ,andsoon). There-
sulttype should beanormal Hask elllist.
Exer cise4.10 Write afold function forBinaryTree sandrewriteelements in
terms ofit(call thenewoneelements2 ).
4.5.5 Enumerated Sets
Youcanalso usedatatypes todeÔ¨Åne things likeenumerated sets, forinstance, atype
which canonly haveaconstrained number ofvalues. Wecould deÔ¨Åne acolor type:
dataColor
=Red
|Orange
|Yellow
|Green
|Blue
|Purple
|White
|Black
This would besufÔ¨Åcient todeal with simple colors. Suppose wewere using thisto
write adrawing program, wecould then write afunction toconvertbetween aColor
andaRGB triple. Wecanwrite acolorToRGB function, as:
colorToRGB Red=(255,0,0)
colorToRGB Orange=(255,128,0)
colorToRGB Yellow=(255,255,0)
colorToRGB Green=(0,255,0)
colorToRGB Blue=(0,0,255)
4.6.CONTINU ATIONPASSING STYLE 53
colorToRGB Purple=(255,0,255)
colorToRGB White=(255,255,255)
colorToRGB Black=(0,0,0)
Ifwewanted also toallowtheuser todeÔ¨Åne hisowncustom colors, wecould
change theColordatatype tosomething like:
dataColor
=Red
|Orange
|Yellow
|Green
|Blue
|Purple
|White
|Black
|CustomIntIntInt--RGBcomponents
And addaÔ¨Ånal deÔ¨Ånition forcolorToRGB :
colorToRGB (Custom rgb)=(r,g,b)
4.5.6 The Unit type
AÔ¨Ånal useful datatype deÔ¨Åned inHask ell(from thePrelude) istheunit type. It‚Äôs
deÔ¨Ånition is:
data()=()
Theonly truevalue ofthistype is().This isessentially thesame asavoid type in
alangauge likeCorJavaandwillbeuseful when wetalkabout IOinChapter 5.
We‚Äôlldwell much more ondata types inSections 7.4and8.3.
4.6 Continuation Passing Style
There isastyle offunctional programming called ‚ÄúContinuation Passing Style‚Äù (also
simply ‚ÄúCPS‚Äù). Theidea behind CPS istopass around asafunction argument what to
donext.Iwillhandw avethrough anexample which istoocomple xtowrite outatthis
point andthen givearealexample, though onewith lessmotivation.
Consider theproblem ofparsing. The idea here isthat wehaveasequence of
tokens(words, letters, whate ver)andwewanttoascribe structure tothem. Thetask
ofconverting astring ofJavatokenstoaJavaabstract syntax treeisanexample ofa
54 CHAPTER 4.TYPEBASICS
parsing problem. Soisthetaskoftaking anEnglish sentence andcreating aparse tree
(though thelatter isquite abitharder).
Suppose we‚Äôreparsing something likeCorJavawhere functions takearguments
inparentheses. Butforsimplicity ,assume theyarenotseparated bycommas. That
is,afunction calllooks likemyFunction(x yz).Wewanttoconvertthisinto
something likeapaircontaining Ô¨Årstthestring ‚ÄúmyFunction‚Äù andthen alistwith three
string elements: ‚Äúx‚Äù, ‚Äúy‚Äùand‚Äúz‚Äù.
The general approach tosolving thiswould betowrite afunction which parses
function calls likethisone. First itwould look foranidentiÔ¨Åer (‚ÄúmyFunction‚Äù), then
foranopen parenthesis, then forzero ormore identiÔ¨Åers, then foraclose parenthesis.
One waytodothiswould betohavetwofunctions:
parseFunction ::
[Token] ->Maybe((String, [String]), [Token])
parseIdentifier ::
[Token] ->Maybe(String, [Token])
Theideawould bethatifwecallparseFunction ,ifitdoesn‚Äô treturnNothing ,
then itreturns thepairdescribed earlier ,together with whate verisleftafter parsing the
function. Similarly ,parseIdentifier willparse oneofthearguments. Ifitreturns
Nothing ,then it‚Äôsnotanargument; ifitreturnsJust something, then thatsomething
istheargument paired with therestofthetokens.
What theparseFunction function would doistoparse anidentiÔ¨Åer .Ifthis
fails, itfailsitself. Otherwise, itcontinues andtries toparse aopen parenthesis. Ifthat
succeeds, itrepeatedly callsparseIdentifier until thatfails. Itthen tries toparse
aclose parenthesis. Ifthatsucceeds, then it‚Äôsdone. Otherwise, itfails.
There is,however,another waytothink about thisproblem. Theadvantage tothis
solution isthatfunctions nolonger need toreturn theremaining tokens(which tends to
getugly). Instead oftheabove,wewrite functions:
parseFunction ::
[Token] ->((String, [String]) ->[Token] ->a)->
([Token] ->a)->a
parseIdentifier ::
[Token] ->(String ->[Token] ->a)->
([Token] ->a)->a
Let‚ÄôsconsiderparseIdentifier .This takesthree arguments: alistoftokens
andtwocontinuations .The Ô¨Årst continuation iswhat todowhen yousucceed. The
second continuation iswhat todoifyoufail.WhatparseIdentifier does, then,
istrytoread anidentiÔ¨Åer .Ifthissucceeds, itcalls theÔ¨Årst continuation with that
identiÔ¨Åer andtheremaining tokensasarguments. Ifreading theidentiÔ¨Åer fails, itcalls
thesecond continuation with allthetokens.
4.6.CONTINU ATIONPASSING STYLE 55
NowconsiderparseFunction .Recall that itwants toread anidentiÔ¨Åer ,an
open parenthesis, zero ormore identiÔ¨Åers andaclose parenthesis. Thus, theÔ¨Årstthing
itdoes iscallparseIdentifier .TheÔ¨Årstargument itgivesisthelistoftokens.
TheÔ¨Årstcontinuation (which iswhatparseIdentifier should doifitsucceeds)
isinturn afunction which willlook foranopen parenthesis, zero ormore arguments
andaclose parethesis. Thesecond argument (thefailure argument) isjustgoing tobe
thefailure function giventoparseFunction .
Now,wesimply need todeÔ¨Åne thisfunction which looks foranopen parenthesis,
zero ormore arguments andaclose parethesis. This iseasy.Wewrite afunction which
looks fortheopen parenthesis andthen callsparseIdentifier with asuccess
continuation thatlooks formore identiÔ¨Åers, anda‚Äúfailure‚Äù continuation which looks
fortheclose parenthesis (note thatthisfailure doesn‚Äô treally mean failure ‚Äìitjustmeans
there arenomore arguments left).
Irealize thisdiscussion hasbeen quite abstract. Iwould willingly givecode forall
thisparsing, butitisperhaps toocomple xatthemoment. Instead, consider theproblem
offolding across alist.Wecanwrite aCPS foldas:
cfold‚Äôfz[]=z
cfold‚Äôfz(x:xs)=fxz(\y->cfold‚Äôfyxs)
Inthiscode,cfold‚Äô takeafunctionfwhich takesthree arguments, slightly dif-
ferent from thestandard folds. TheÔ¨Årstisthecurrent listelement,x,thesecond isthe
accumulated element,z,andthethird isthecontinuation: basicially ,what todonext.
Wecanwrite awrapper function forcfold‚Äô thatwillmakeitbehavemore likea
normal fold:
cfoldfzl=cfold‚Äô(\xtg->fx(gt))zl
Wecantestthatthisfunction behavesaswedesire:
CPS>cfold(+)0[1,2,3,4]
10
CPS>cfold(:)[][1,2,3]
[1,2,3]
One thing that‚Äôsnice about formulating cfold interms ofthehelper function
cfold‚Äô isthatwecanusethehelper function directly .This enables ustochange, for
instance, theevaluation order ofthefoldveryeasily:
CPS>cfold‚Äô(\xtg->(x:gt))[][1..10]
[1,2,3,4,5,6,7,8,9,10]
CPS>cfold‚Äô(\xtg->g(x:t))[][1..10]
[10,9,8,7,6,5,4,3,2,1]
56 CHAPTER 4.TYPEBASICS
Theonly difference between these calls tocfold‚Äô iswhether wecallthecontinu-
ation before orafter constructing thelist.Asitturns out,thisslight difference changes
thebehaviorforbeing likefoldr tobeing likefoldl .Wecanevaluate both ofthese
calls asfollows(letfbethefolding function):
cfold‚Äô(\xtg->(x:gt))[][1,2,3]
==>cfold‚Äôf[][1,2,3]
==>f1[](\y->cfold‚Äôfy[2,3])
==>1:((\y->cfold‚Äôfy[2,3])[])
==>1:(cfold‚Äô f[][2,3])
==>1:(f2[](\y->cfold‚Äôfy[3]))
==>1:(2:((\y->cfold‚Äôfy[3])[]))
==>1:(2:(cfold‚Äô f[][3]))
==>1:(2:(f3[](\y->cfold‚Äôfy[])))
==>1:(2:(3:(cfold‚Äô f[][])))
==>1:(2:(3:[]))
==>[1,2,3]
cfold‚Äô(\xtg->g(x:t))[][1,2,3]
==>cfold‚Äôf[][1,2,3]
==>(\xtg->g(x:t))1[](\y->cfold‚Äôfy[2,3])
==>(\g->g[1])(\y->cfold‚Äôfy[2,3])
==>(\y->cfold‚Äôfy[2,3])[1]
==>cfold‚Äôf[1][2,3]
==>(\xtg->g(x:t))2[1](\y->cfold‚Äôfy[3])
==>cfold‚Äôf(2:[1]) [3]
==>cfold‚Äôf[2,1][3]
==>(\xtg->g(x:t))3[2,1](\y->cfold‚Äôfy[])
==>cfold‚Äôf(3:[2,1]) []
==>[3,2,1]
Ingeneral, continuation passing style isaverypowerful abstraction, though itcan
bedifÔ¨Åcult tomaster .Wewillrevisit thetopic more thoroughly later inthebook.
Exer cises
Exer cise4.11 Testwhether theCPS-style foldmimic kseither offoldr andfoldl .
Ifnot,wher eisthedifference?
Exer cise4.12 Writemap andfilter using continuation passing style.
Chapter5
BasicInput/Output
Aswementioned earlier ,itisdifÔ¨Åcult tothink ofagood, clean waytointegrate oper-
ations likeinput/output intoapure functional language. Before wegivethesolution,
let‚Äôstakeastepback andthink about thedifÔ¨Åculties inherent insuch atask.
AnyIOlibrary should provide ahost offunctions, containing (ataminimum) op-
erations like:
print astring tothescreen
read astring from akeyboard
write data toaÔ¨Åle
read data from aÔ¨Åle
There aretwoissues here. Let‚ÄôsÔ¨Årstconsider theinitial twoexamples andthink
about what their types should be.Certainly theÔ¨Årst operation (Ihesitate tocallita
‚Äúfunction‚Äù) should takeaString argument andproduce something, butwhat should it
produce? Itcould produce aunit(),since there isessentially noreturn value from
printing astring. Thesecond operation, similarly ,should return aString ,butitdoesn‚Äô t
seem torequire anargument.
Wewantboth ofthese operations tobefunctions, buttheyarebydeÔ¨Ånition not
functions. Theitem thatreads astring from thekeyboard cannot beafunction, asit
willnotreturn thesameString everytime. And iftheÔ¨Årstfunction simply returns()
everytime, there should benoproblem with replacing itwith afunctionf=(),
duetoreferential transparenc y.Butclearly thisdoes nothavethedesired effect.
5.1 The RealW orld Solution
Inasense, thereason thatthese items arenotfunctions isthattheyinteract with the
‚Äúreal world.‚ÄùTheir values depend directly ontherealworld. Supposing wehadatype
RealW orld,wemight write these functions ashaving type:
57
58 CHAPTER 5.BASICINPUT/OUTPUT
printAString ::RealWorld ->String->RealWorld
readAString ::RealWorld ->(RealWorld, String)
That is,printAString takesacurrent state oftheworld andastring toprint;
itthen modiÔ¨Åes thestate oftheworld insuch awaythatthestring isnowprinted and
returns thisnewvalue. Similarly ,readAString takesacurrent state oftheworld
andreturns anewstate oftheworld, paired with theString thatwastyped.
This would beapossible waytodoIO,though itismore than some what unweildy .
Inthisstyle (assuming aninitial RealW orldstate were anargument tomain ),our
‚ÄúName.hs‚Äù program from Section 3.8would look something like:
mainrW=
letrW‚Äô=printAString rW"Please enteryourname:"
(rW‚Äô‚Äô,name) =readAString rW‚Äô
inprintAString rW‚Äô‚Äô
("Hello, "++name++",howareyou?")
This isnotonly hard toread, butprone toerror ,ifyouaccidentally usethewrong
version oftheRealW orld.Italsodoesn‚Äô tmodel thefactthattheprogram belowmakes
nosense:
mainrW=
letrW‚Äô=printAString rW"Please enteryourname:"
(rW‚Äô‚Äô,name) =readAString rW‚Äô
inprintAString rW‚Äô --OOPS!
("Hello, "++name++",howareyou?")
Inthisprogram, thereference torW‚Äô‚Äô onthelastlinehasbeen changed toaref-
erence torW‚Äô.Itiscompletely unclear what thisprogram should do.Clearly ,itmust
read astring inorder tohaveavalue forname tobeprinted. Butthatmeans thatthe
RealW orldhasbeen updated. However,then wetrytoignore thisupdate byusing an
‚Äúold version‚Äù oftheRealW orld.There isclearly something wrong happening here.
SufÔ¨Åceittosaythatdoing IOoperations inapure lazy functional language isnot
trivial.
5.2 Actions
Thebreakthrough forsolving thisproblem came when Phil Wadler realized thatmon-
adswould beagood waytothink about IOcomputations. Infact,monads areable to
express much more than justthesimple operations described above;wecanusethem
toexpress avariety ofconstructions likeconcurrence, exceptions, IO,non-determinism
andmuch more. Moreo ver,there isnothing special about them; theycanbedeÔ¨Åned
within Hask ellwith nospecial handling from thecompiler (though compilers often
choose tooptimize monadic operations).
5.2.ACTIONS 59
Aspointed outbefore, wecannot think ofthings like‚Äúprint astring tothescreen‚Äù or
‚Äúread data from aÔ¨Åle‚Äù asfunctions, since theyarenot(inthepure mathematical sense).
Therefore, wegivethem another name: actions .Notonly dowegivethem aspecial
name, wegivethem aspecial type. Oneparticularly useful action isputStrLn ,which
prints astring tothescreen. This action hastype:
putStrLn ::String->IO()
Asexpected,putStrLn takesastring argument. What itreturns isoftypeIO
().This means thatthisfunction isactually anaction (that iswhat theIOmeans).
Furthermore, when thisaction isevaluated (or‚Äúrun‚Äù) ,theresult willhavetype().
NOTE Actually ,thistype means thatputStrLn isanaction within
theIOmonad ,butwewillgloss overthisfornow.
Youcanprobably already guess thetype ofgetLine :
getLine ::IOString
This means thatgetLine isanIOaction that, when run,willhavetypeString .
Thequestion immediately arises: ‚Äúhowdoyou‚Äòrun‚Äô anaction?‚Äù. This issomething
thatisleftuptothecompiler .Youcannot actually runanaction yourself; instead, a
program is,itself, asingle action thatisrunwhen thecompiled program isexecuted.
Thus, thecompiler requires thatthemain function havetypeIO(),which means that
itisanIOaction thatreturns nothing. Thecompiled code then executes thisaction.
However,while youarenotallowed torunactions yourself, youareallowed to
combine actions. Infact,wehavealready seen onewaytodothisusing thedo
notation (howtoreally dothiswillberevealed inChapter 9).Let‚Äôsconsider theoriginal
name program:
main=do
hSetBuffering stdinLineBuffering
putStrLn "Please enteryourname:"
name<-getLine
putStrLn ("Hello, "++name++",howareyou?")
Wecanconsider thedonotation asawaytocombine asequence ofactions. More-
over,the<-notation isawaytogetthevalue outofanaction. So,inthisprogram,
we‚Äôresequencing four actions: setting buffering, aputStrLn ,agetLine andan-
otherputStrLn .TheputStrLn action hastypeString !IO(),soweprovide ita
String ,sothefully applied action hastypeIO().This issomething thatweareallowed
toexecute.
ThegetLine action hastypeIOString ,soitisokay toexecute itdirectly .How-
ever,inorder togetthevalue outoftheaction, wewritename<-getLine ,which
basically means ‚ÄúrungetLine ,andputtheresults inthevariable calledname .‚Äù
60 CHAPTER 5.BASICINPUT/OUTPUT
Normal Hask ellconstructions likeif/then/else andcase/of canbeused within the
donotation, butyouneed tobesome what careful. Forinstance, inour‚Äúguess the
number‚Äù program, wehave:
do...
if(readguess)<num
thendoputStrLn "Toolow!"
doGuessing num
elseifreadguess>num
thendoputStrLn "Toohigh!"
doGuessing num
elsedoputStrLn "YouWin!"
Ifwethink about howtheif/then/else construction works, itessentially takesthree
arguments: thecondition, the‚Äúthen‚Äù branch, andthe‚Äúelse‚Äù branch. The condition
needs tohavetypeBool,andthetwobranches canhaveanytype, provided thatthey
havethesame type. Thetype oftheentire if/then/else construction isthen thetype of
thetwobranches.
Intheoutermost comparison, wehave(readguess)<num asthecondition.
This clearly hasthecorrect type. Let‚Äôsjustconsider the‚Äúthen‚Äù branch. Thecode here
is:
doputStrLn "Toolow!"
doGuessing num
Here, wearesequencing twoactions:putStrLn anddoGuessing .The Ô¨Årst
hastypeIO(),which isÔ¨Åne. Thesecond also hastypeIO(),which isÔ¨Åne. Thetype
result oftheentire computation isprecisely thetype oftheÔ¨Ånal computation. Thus, the
type ofthe‚Äúthen‚Äù branch isalsoIO().Asimilar argument showsthatthetype ofthe
‚Äúelse‚Äù branch isalsoIO().This means thetype oftheentire if/then/else construction
isIO(),which isjustwhat wewant.
NOTE Inthiscode, thelastlineis‚ÄúelsedoputStrLn "You
Win!" ‚Äù.This issome what overlyverbose. Infact,‚ÄúelseputStrLn
"YouWin!" ‚Äùwould havebeen sufÔ¨Åcient, since doisonly necessary to
sequence actions. Since wehaveonly oneaction here, itissuperÔ¨Çuous.
Itisincorr ecttothink toyourself ‚ÄúWell,Ialready started adoblock; Idon‚Äôtneed
another one,‚Äùandhence write something like:
doif(readguess)<num
thenputStrLn "Toolow!"
doGuessing num
else...
5.2.ACTIONS 61
Here, since wedidn‚Äô trepeat thedo,thecompiler doesn‚Äô tknowthattheputStrLn
anddoGuessing calls aresupposed tobesequenced, andthecompiler will think
you‚Äôretrying tocallputStrLn with three arguments: thestring, thefunctiondoGuessing
andtheintegernum.Itwillcertainly complain (though theerror may besome what dif-
Ô¨Åcult tocomprehend atthispoint).
Wecanwrite thesamedoGuessing function using acase statement. Todothis,
weÔ¨Årstintroduce thePrelude functioncompare ,which takestwovalues ofthesame
type (intheOrd class) andreturns oneofGT,LT,EQ,depending onwhether theÔ¨Årst
isgreater than, lessthan orequal tothesecond.
doGuessing num=do
putStrLn "Enteryourguess:"
guess<-getLine
casecompare (readguess)numof
LT->doputStrLn "Toolow!"
doGuessing num
GT->doputStrLn "Toohigh!"
doGuessing num
EQ->putStrLn "YouWin!"
Here, again,thedosafter the->sarenecessary ontheÔ¨Årsttwooptions, because
wearesequencing actions.
Ifyou‚Äôreused toprogramming inanimperati velanguage likeCorJava,youmight
think thatreturnwill exityoufrom thecurrent function. This isnotsoinHask ell.
InHask ell,returnsimply takesanormal value (forinstance, oneoftypeIOInt)and
makesitintoanaction thatreturns thegivenvalue (forinstance, thevalue oftypeInt).
Inparticular ,inanimperati velanguage, youmight write thisfunction as:
voiddoGuessing(int num){
print"Enteryourguess:";
intguess=atoi(readLine());
if(guess==num){
print"Youwin!";
return();
}
//wewon‚Äôtgethereifguess==num
if(guess<num){
print"Toolow!";
doGuessing(num);
}else{
print"Toohigh!";
doGuessing(num);
}
}
62 CHAPTER 5.BASICINPUT/OUTPUT
Here, because wehavethereturn()intheÔ¨Årstifmatch, weexpect thecode
toexitthere (and inmode imperati velanguages, itdoes). However,theequivalent code
inHask ell,which might look something like:
doGuessing num=do
putStrLn "Enteryourguess:"
guess<-getLine
casecompare (readguess)numof
EQ->doputStrLn "Youwin!"
return()
--wedon‚Äôtexpecttogethereunlessguess==num
if(readguess<num)
thendoprint"Toolow!";
doGuessing
elsedoprint"Toohigh!";
doGuessing
willnotbehaveasyouexpect. First ofall,ifyouguess correctly ,itwillÔ¨Årstprint ‚ÄúYou
win!, ‚Äùbutitwon‚Äôtexit,anditwillcheck whetherguess islessthannum.Ofcourse
itisnot,sotheelsebranch istaken,anditwillprint ‚ÄúToohigh!‚Äù andthen askyouto
guess again.
Ontheother hand, ifyouguess incorrectly ,itwilltrytoevaluate thecase statement
andgeteitherLTorGTastheresult ofthecompare .Ineither case, itwon‚Äôthavea
pattern thatmatches, andtheprogram willfailimmediately with anexception.
Exer cises
Exer cise5.1Write aprogramthatasks theuser forhisorhername .Ifthename is
oneofSimon, JohnorPhil, telltheuser thatyouthink Hask ellisagreatprogramming
langua ge.Ifthename isKoen, tellthem thatyouthink debugging Hask ellisfun(Koen
Classen isoneofthepeople who works onHask elldebugging); otherwise ,telltheuser
thatyoudon‚Äôtknow who heorsheis.
Write twodifferentversions ofthisprogram,oneusingifstatements, theother using a
case statement.
5.3 The IOLibrary
TheIOLibrary (available byimport ingtheIOmodule) contains manydeÔ¨Ånitions, the
most common ofwhich arelisted below:
dataIOMode =ReadMode |WriteMode
|AppendMode |ReadWriteMode
openFile ::FilePath ->IOMode->IOHandle
5.3.THEIOLIBRARY 63
hClose ::Handle->IO()
hIsEOF ::Handle->IOBool
hGetChar ::Handle->IOChar
hGetLine ::Handle->IOString
hGetContents ::Handle->IOString
getChar ::IOChar
getLine ::IOString
getContents ::IOString
hPutChar ::Handle->Char->IO()
hPutStr ::Handle->String->IO()
hPutStrLn ::Handle->String->IO()
putChar ::Char->IO()
putStr ::String->IO()
putStrLn ::String->IO()
readFile ::FilePath ->IOString
writeFile ::FilePath ->String->IO()
bracket ::
IOa->(a->IOb)->(a->IOc)->IOc
NOTE The typeFilePathisatype synonym forString .That is,
there isnodifference between FilePathandString .So,forinstance,
thereadFile function takesaString (theÔ¨Åletoread) andreturns an
action that, when run,produces thecontents ofthatÔ¨Åle.SeeSection 8.1
formore about type synon yms.
Most ofthese functions areself-e xplanatory .TheopenFile andhClose func-
tions open andclose aÔ¨Åle,respecti vely,using theIOModeargument asthemode for
opening theÔ¨Åle.hIsEOF tests forend-of Ô¨Åle.hGetChar andhGetLine read
acharacter orline(respecti vely) from aÔ¨Åle.hGetContents reads theentire Ô¨Åle.
ThegetChar ,getLine andgetContents variants read from standard input.
hPutChar prints acharacter toaÔ¨Åle;hPutStr prints astring; andhPutStrLn
prints astring with anewline character attheend. Thevariants without thehpreÔ¨Åx
workonstandard output. ThereadFile andwriteFile functions read anentire
Ô¨Ålewithout having toopen itÔ¨Årst.
Thebracket function isused toperform actions safely .Consider afunction that
opens aÔ¨Åle, writes acharacter toit,andthen closes theÔ¨Åle. When writing such a
function, oneneeds tobecareful toensure that, ifthere were anerror atsome point,
theÔ¨Åleisstillsuccessfully closed. Thebracket function makesthiseasy.Ittakes
64 CHAPTER 5.BASICINPUT/OUTPUT
three arguments: TheÔ¨Årstistheaction toperform atthebeginning. Thesecond isthe
action toperform attheend, regardless ofwhether there‚Äô sanerror ornot. Thethird is
theaction toperform inthemiddle, which might result inanerror .Forinstance, our
character -writing function might look like:
writeChar ::FilePath ->Char->IO()
writeChar fpc=
bracket
(openFile fpReadMode)
hClose
(\h->hPutChar hc)
This will open theÔ¨Åle, write thecharacter andthen close theÔ¨Åle. However,if
writing thecharacter fails,hClose will stillbeexecuted, andtheexception will be
reraised afterw ards. That way,youdon‚Äôtneed toworry toomuch about catching the
exceptions andabout closing allofyour handles.
5.4 AFileReading Program
Wecanwrite asimple program thatallowsauser toread andwrite Ô¨Åles. Theinterf ace
isadmittedly poor,anditdoes notcatch allerrors (tryreading anon-e xistant Ô¨Åle).
Nevertheless, itshould giveafairly complete example ofhowtouseIO.Enter the
following code into‚ÄúFileRead.hs, ‚Äùandcompile/run:
moduleMain
where
importIO
main=do
hSetBuffering stdinLineBuffering
doLoop
doLoop=do
putStrLn "Enteracommand rFNwFNorqtoquit:"
command <-getLine
casecommand of
‚Äôq‚Äô:_->return()
‚Äôr‚Äô:filename ->doputStrLn ("Reading "++filename)
doReadfilename
doLoop
‚Äôw‚Äô:filename ->doputStrLn ("Writing "++filename)
doWrite filename
doLoop
_ ->doLoop
5.4.AFILEREADING PROGRAM 65
doReadfilename =
bracket (openFile filename ReadMode) hClose
(\h->docontents <-hGetContents h
putStrLn "Thefirst100chars:"
putStrLn (take100contents))
doWrite filename =do
putStrLn "Entertexttogointothefile:"
contents <-getLine
bracket (openFile filename WriteMode) hClose
(\h->hPutStrLn hcontents)
What does thisprogram do?First, itissues ashort string ofinstructions andreads
acommand. Itthen performs acase switch onthecommand andchecks Ô¨Årsttoseeif
theÔ¨Årstcharacter isa‚Äòq.‚ÄôIfitis,itreturns avalue ofunittype.
NOTE Thereturn function isafunction thattakesavalue oftype
aandreturns anaction oftypeIOa.Thus, thetype ofreturn()is
IO().
IftheÔ¨Årstcharacter ofthecommand wasn‚Äôta‚Äòq,‚Äôtheprogram checks toseeifit
wasan‚Äôr‚Äôfollowed bysome string thatisbound tothevariablefilename .Itthen
tells youthatit‚Äôsreading theÔ¨Åle,does theread andrunsdoLoop again. Thecheck
for‚Äòw‚Äôisnearly identical. Otherwise, itmatches ,thewildcard character ,andloops
todoLoop .
ThedoRead function uses thebracket function tomakesure there arenoprob-
lems reading theÔ¨Åle.Itopens aÔ¨ÅleinReadMo de,reads itscontents andprints theÔ¨Årst
100characters (thetake function takesanintegernandalistandreturns theÔ¨Årstn
elements ofthelist).
ThedoWrite function asks forsome text,reads itfrom thekeyboard, andthen
writes ittotheÔ¨ÅlespeciÔ¨Åed.
NOTE BothdoRead anddoWrite could havebeen made simpler
byusingreadFile andwriteFile ,buttheywere written intheex-
tended fashion toshowhowthemore comple xfunctions areused.
Theonly major problem with thisprogram isthatitwilldieifyoutrytoread aÔ¨Åle
thatdoesn‚Äô talready exists orifyouspecify some badÔ¨Ålename like*nÀÜ#@.Youmay
think thatthecalls tobracket indoRead anddoWrite should takecare ofthis,
buttheydon‚Äôt.Theyonly catch exceptions within themain body ,notwithin thestartup
orshutdo wnfunctions (openFile andhClose ,inthese cases). Wewould need to
catch exceptions raised byopenFile ,inorder tomakethiscomplete. Wewilldothis
when wetalkabout exceptions inmore detail inSection 10.1.
66 CHAPTER 5.BASICINPUT/OUTPUT
Exer cises
Exer cise5.2Write aprogramthatÔ¨Årstasks whether theuser wants toreadfromaÔ¨Åle,
write toaÔ¨Åleorquit. Iftheuser responds quit, theprogramshould exit.Ifheresponds
read, theprogramshould askhimforaÔ¨Ålename andprint thatÔ¨Åletothescreen(ifthe
Ô¨Åledoesn‚Äô texist, theprogrammay crash). Ifheresponds write ,itshould askhimfora
Ô¨Ålename andthen askhimfortexttowrite totheÔ¨Åle,with ‚Äú.‚Äùsignaling completion.
Allbutthe‚Äú.‚Äùshould bewritten totheÔ¨Åle.
Forexample ,running thisprogrammight produce:
Doyouwant to[read] afile, [write] afile or[quit]?
read
Enter afile name toread:
foo
...contents offoo...
Doyouwant to[read] afile, [write] afile or[quit]?
write
Enter afile name towrite:
foo
Enter text (dot onaline byitself toend):
this issome
text for
foo
.
Doyouwant to[read] afile, [write] afile or[quit]?
read
Enter afile name toread:
foo
this issome
text for
foo
Doyouwant to[read] afile, [write] afile or[quit]?
read
Enter afile name toread:
foof
Sorry, that file does notexist.
Doyouwant to[read] afile, [write] afile or[quit]?
blech
Idon't understand thecommand blech.
Doyouwant to[read] afile, [write] afile or[quit]?
quit
Goodbye!
Chapter6
Modules
InHask ell,program subcomponents aredivided intomodules. Each module sitsinits
ownÔ¨Åleandthename ofthemodule should match thename oftheÔ¨Åle(without the
‚Äú.hs‚Äù extension, ofcourse), ifyouwish toeverusethatmodule inalargerprogram.
Forinstance, suppose Iamwriting agame ofpoker.Imay wish tohaveaseparate
module called ‚ÄúCards‚Äù tohandle thegeneration ofcards, theshufÔ¨Çing andthedealing
functions, andthen usethis‚ÄúCards‚Äù module inmy‚ÄúPok er‚Äùmodules. That way,ifI
evergoback andwanttowrite ablackjack program, Idon‚Äôthavetorewrite allthecode
forthecards; Icansimply import theold‚ÄúCards‚Äù module.
6.1 Exports
Suppose assuggested wearewriting acards module. Ihaveleftouttheimplementation
details, butsuppose theskeleton ofourmodule looks something likethis:
moduleCards
where
dataCard=...
dataDeck=...
newDeck ::...->Deck
newDeck =...
shuffle ::...->Deck->Deck
shuffle =...
--‚Äôdealdeckn‚Äôdeals‚Äôn‚Äôcardsfrom‚Äôdeck‚Äô
deal::Deck->Int->[Card]
dealdeckn=dealHelper deckn[]
67
68 CHAPTER 6.MODULES
dealHelper =...
Inthiscode, thefunctiondeal calls ahelper functiondealHelper .The im-
plementation ofthishelper function isverydependent ontheexact data structures you
used forCard andDeck sowedon‚Äôtwantother people tobeable tocallthisfunction.
Inorder todothis, wecreate anexport list,which weinsert justafter themodule name
declaration:
moduleCards(Card(),
Deck(),
newDeck,
shuffle,
deal
)
where
...
Here, wehavespeciÔ¨Åed exactly what functions themodule exports, sopeople who
usethismodule won‚Äôtbeable toaccess ourdealHelper function. The()after
Card andDeck specify thatweareexporting thetype butnone oftheconstructors.
Forinstance ifourdeÔ¨Ånition ofCard were:
dataCard=CardSuitFace
dataSuit=Hearts
|Spades
|Diamonds
|Clubs
dataFace=Jack
|Queen
|King
|Ace
|NumberInt
Then users ofourmodule would beable tousethings oftypeCard ,butwouldn‚Äô t
beabletoconstruct their ownCard sandwouldn‚Äô tbeabletoextract anyofthesuit/f ace
information stored inthem.
Ifwewanted users ofourmodule tobeable toaccess allofthisinformation, we
would havetospecify itintheexport list:
moduleCards(Card(Card),
Suit(Hearts,Spades,Diamonds,Clubs),
Face(Jack,Queen,King,Ace,Number),
...
)
6.2.IMPORTS 69
where
...
This cangetfrustrating ifyou‚Äôreexporting datatypes with manyconstructors, soif
youwanttoexport them all,youcansimply write(..) ,asin:
moduleCards(Card(..),
Suit(..),
Face(..),
...
)
where
...
And thiswillautomatically export alltheconstructors.
6.2 Imports
There areafewidiosyncracies inthemodule import system, butaslong asyoustay
awayfrom thecorner cases, you should beÔ¨Åne. Suppose, asbefore, you wrote a
module called ‚ÄúCards‚Äù which yousavedintheÔ¨Åle‚ÄúCards.hs‚Äù. Youarenowwriting
your pokermodule andyouwanttoimport allthedeÔ¨Ånitions from the‚ÄúCards‚Äù module.
Todothis, allyouneed todoiswrite:
modulePoker
where
importCards
This willenable toyouuseanyofthefunctions, types andconstructors exported
bythemodule ‚ÄúCards‚Äù. Youmay refer tothem simply bytheir name inthe‚ÄúCards‚Äù
module (as,forinstance,newDeck ),oryoumay refer tothem explicitely asimported
from ‚ÄúCards‚Äù (as,forinstance,Cards.newDeck ).Itmay bethecase thattwomodule
export functions ortypes ofthesame name. Inthese cases, youcanimport oneof
themodules qualiÔ¨Åed which means thatyouwould nolonger beable tosimply use
thenewDeck format butmust usethelongerCards.newDeck format, toremo ve
ambiguity .Ifyouwanted toimport ‚ÄúCards‚Äù inthisqualiÔ¨Åed form, youwould write:
importqualified Cards
Another waytoavoidproblems with overlapping function deÔ¨Ånitions istoimport
only certain functions from modules. Suppose weknewtheonly function from ‚ÄúCards‚Äù
thatwewanted wasnewDeck ,wecould import only thisfunction bywriting:
70 CHAPTER 6.MODULES
importCards(newDeck)
Ontheother hand, suppose weknewthatthatthedeal function overlapped with
another module, butthatwedidn‚Äô tneed the‚ÄúCards‚Äù version ofthatfunction. Wecould
hide thedeÔ¨Ånition ofdeal andimport everything elsebywriting:
importCardshiding(deal)
Finally ,suppose wewanttoimport ‚ÄúCards‚Äù asaqualiÔ¨Åed module, butdon‚Äôtwant
tohavetotypeCards. outallthetime andwould rather justtype, forinstance,C.‚Äì
wecould dothisusing theaskeyword:
importqualified CardsasC
These options canbemixedandmatched ‚Äìyoucangiveexplicit import lists on
qualiÔ¨Åed/as imports, forinstance.
6.3 Hierar chical Imports
Though technically notpartoftheHask ell98standard, most Hask ellcompilers support
hierarchical imports. This wasdesigned togetridofclutter inthedirectories inwhich
modules arestored. Hierarchical imports allowyoutospecify (toacertain degree)
where inthedirectory structure amodule exists. Forinstance, ifyouhavea‚Äúhask ell‚Äù
directory onyour computer andthisdirectory isinyour compiler‚Äô spath (see your
compiler notes forhowtosetthis; inGHC it‚Äôs‚Äú-i‚Äù, inHugs it‚Äôs‚Äú-P‚Äù), then youcan
specify module locations insubdirectories tothatdirectory .
Suppose instead ofsaving the‚ÄúCards‚Äù module inyour general haskelldirectory ,
youcreated adirectory speciÔ¨Åcally foritcalled ‚ÄúCards‚Äù. Thefullpath oftheCards.hs
Ô¨Åleisthenhaskell/Cards/Cards.hs (or,forWindowshaskell nCards nCards.hs ).
Ifyouthen change thename oftheCards module to‚ÄúCards.Cards‚Äù, asin:
moduleCards.Cards(...)
where
...
Youcould them import itinanymodule, regardless ofthismodule‚Äô sdirectory ,as:
importCards.Cards
Ifyoustart importing these module qualiÔ¨Åed, Ihighly recommend using theas
keywordtoshorten thenames, soyoucanwrite:
6.4.LITERATEVERSUS NON-LITERA TE 71
importqualified Cards.Cards asCards
...Cards.newDeck ...
instead of:
importqualified Cards.Cards
...Cards.Cards.newDeck ...
which tends togetugly.
6.4 Literate Versus Non-Literate
Theidea ofliterate programming isarelati velysimple one, buttook quite awhile to
become popularized. When wethink about programming, wethink about thecode
being thedefaultmode ofentry andcomments being secondary .That is,wewrite code
without anyspecial annotation, butcomments areannotated with either--orf-...
-g.Literate programming swapsthese preconceptions.
There aretwotypes ofliterate programs inHask ell;theÔ¨Årstuses so-called Bird-
scripts andthesecond uses LATEX-style markup. Each willbediscussed individually .
Nomatter which youuse, literate scripts must havetheextension lhsinstead ofhsto
tellthecompiler thattheprogram iswritten inaliterate style.
6.4.1 Bird-scripts
InaBird-style literate program, comments aredefaultandcode isintroduced with a
leading greater -than sign (‚Äú>‚Äù).Everything elseremains thesame. Forexample, our
Hello Worldprogram would bewritten inBird-style as:
Thisisasimple(literate!) HelloWorldprogram.
>moduleMain
>where
Allourmainfunction doesisprintastring:
>main=putStrLn "HelloWorld"
Note thatthespaces between thelines ofcode andthe‚Äúcomments‚Äù arenecessary
(your compiler willprobably complain ifyouaremissing them). When compiled or
loaded inaninterpreter ,thisprogram willhavetheexact same properties asthenon-
literate version from Section 3.4.
72 CHAPTER 6.MODULES
6.4.2 LaTeX-scripts
LATEXisatext-markup language verypopular intheacademic community forpublish-
ing.Ifyouareunfamiliar with LATEX,youmay notÔ¨Åndthissection terribly useful.
Again,aliterate Hello Worldprogram written inLATEX-style would look like:
Thisisanother simple(literate!) HelloWorldprogram.
\begin{code}
moduleMain
where
\end{code}
Allourmainfunction doesisprintastring:
\begin{code}
main=putStrLn "HelloWorld"
\end{code}
InLATEX-style scripts, theblank lines arenotnecessary .
Chapter7
AdvancedFeatures
Discussion
7.1 Sections andInÔ¨Åx Operators
We‚Äôvealready seen howtodouble thevalues ofelements inalistusingmap:
Prelude> map(\x->x*2)[1,2,3,4]
[2,4,6,8]
However,there isamore concise waytowrite this:
Prelude> map(*2)[1,2,3,4]
[2,4,6,8]
This type ofthing canbedone foranyinÔ¨Åx function:
Prelude> map(+5)[1,2,3,4]
[6,7,8,9]
Prelude> map(/2)[1,2,3,4]
[0.5,1.0,1.5,2.0]
Prelude> map(2/)[1,2,3,4]
[2.0,1.0,0.666667,0.5]
Youmight betempted totrytosubtract values from elements inalistbymapping
-2across alist. This won‚Äôtwork, though, because while the+in+2isparsed as
thestandard plus operator (asthere isnoambiguity), the-in-2isinterpreted asthe
unary minus, notthebinary minus. Thus-2here isthenumber  2,notthefunction
x:x 2.
Ingeneral, these arecalled sections. Forbinary inÔ¨Åx operators (like+),wecan
cause thefunction tobecome preÔ¨Åx byenclosing itinparetheses. Forexample:
73
74 CHAPTER 7.ADVANCEDFEATURES
Prelude> (+)53
8
Prelude> (-)53
2
Additionally ,wecanprovide either ofitsargument tomakeasection. Forexample:
Prelude> (+5)3
8
Prelude> (/3)6
2.0
Prelude> (3/)6
0.5
Non-inÔ¨Åx functions canbemade inÔ¨Åx byenclosing them inbackquotes (‚Äú`‚Äô‚Äô).For
example:
Prelude> (+2)‚Äòmap‚Äò[1..10]
[3,4,5,6,7,8,9,10,11,12]
7.2 Local Declarations
Recall back from Section 3.5,there aremanycomputations which require using the
result ofthesame computation inmultiple places inafunction. There, weconsidered
thefunction forcomputing theroots ofaquadratic polynomial:
rootsabc=
((-b+sqrt(b*b -4*a*c)) /(2*a),
(-b-sqrt(b*b -4*a*c)) /(2*a))
Inaddition totheletbindings introduced there, wecandothisusing awher eclause.
where clauses come immediately after function deÔ¨Ånitions andintroduce anewlevel
oflayout (seeSection 7.11). Wewrite thisas:
rootsabc=
((-b+det)/(2*a),(-b-det)/(2*a))
wheredet=sqrt(b*b-4*a*c)
Anyvalues deÔ¨Åned inawher eclause shadow anyother values with thesame name.
Forinstance, ifwehadthefollowing code block:
7.2.LOCALDECLARA TIONS 75
det="HelloWorld"
rootsabc=
((-b+det)/(2*a),(-b-det)/(2*a))
wheredet=sqrt(b*b-4*a*c)
f_=det
The value ofroots doesn‚Äô tnotice thetop-le veldeclaration ofdet,since itis
shado wed bythelocal deÔ¨Ånition (the factthatthetypes don‚Äôtmatch doesn‚Äô tmatter
either). Furthermore, sincefcannot ‚Äúsee inside‚Äù ofroots ,theonly thing itknows
aboutdet iswhat isavailable atthetoplevel,which isthestring ‚ÄúHello World.‚ÄùThus,
fisafunction which takesanyargument tothatstring.
Where clauses cancontain anynumber ofsubexpressions, buttheymust bealigned
forlayout. Forinstance, wecould also pull outthe2*a computation andgetthe
following code:
rootsabc=
((-b+det)/(a2),(-b-det)/(a2))
wheredet=sqrt(b*b-4*a*c)
a2=2*a
Sub-e xpressions inwher eclauses must come after function deÔ¨Ånitions. Some-
times itismore convenient toputthelocal deÔ¨Ånitions before theactual expression
ofthefunction. This canbedone byusing let/inclauses. Wehavealready seen let
clauses; wher eclauses arevirtually identical totheir letclause cousins except fortheir
placement. Thesameroots function canbewritten using letas:
rootsabc=
letdet=sqrt(b*b-4*a*c)
a2=2*a
in((-b+det)/a2,(-b-det)/a2)
Using awher eclause, itlooks like:
rootsabc=((-b+det)/a2,(-b-det)/a2)
where
det=sqrt(b*b-4*a*c)
a2=2*a
These twotypes ofclauses canbemixed(i.e., youcanwrite afunction which has
both aletcause andawher eclause). This isstrongly advised against ,asittends to
makecode difÔ¨Åcult toread. However,ifyouchoose todoit,values intheletclause
shado wthose inthewher eclause. SoifyoudeÔ¨Åne thefunction:
76 CHAPTER 7.ADVANCEDFEATURES
fx=
lety=x+1
iny
wherey=x+2
The value off5is6,not7.Ofcourse, Iplead with youtonevereverwrite
code thatlooks likethis. Nooneshould havetoremember thisruleandbyshado wing
wher e-deÔ¨Åned values inaletclause only makesyour code difÔ¨Åcult tounderstand.
Ingeneral, whether youshould useletclauses orwher eclauses islargely amatter
ofpersonal preference. Usually ,thenames yougivetothesubexpressions should be
sufÔ¨Åciently expressi vethatwithout reading their deÔ¨Ånitions anyreader ofyour code
should beable toÔ¨Ågure outwhat theydo.Inthiscase, wher eclauses areprobably
more desirable because theyallowthereader toseeimmediately what afunction does.
However,inreallife, values areoften givencryptic names. Inwhich case letclauses
may bebetter .Either isprobably okay,though Ithink wher eclauses aremore common.
7.3 Partial Application
Partial application iswhen youtakeafunction which takesnarguments andyousupply
itwith<nofthem. When discussing sections inSection 7.1, wesawaform of
‚Äúpartial application‚Äù inwhich functions like+were partially applied. Forinstance, in
theexpressionmap(+1)[1,2,3] ,thesection(+1) isapartial application of+.
This isbecause+really takestwoarguments, butwe‚Äôveonly givenitone.
Partial application isverycommon infunction deÔ¨Ånitions andsometimes goes by
thename ‚Äúetareduction‚Äù. Forinstance, suppose wearewritting afunctionlcaseString etareduction
which convertsawhole string intolowercase. Wecould write thisas:
lcaseString s=maptoLower s
Here, there isnopartial application (though youcould arguethatapplying noargu-
ments totoLower could beconsidered partial application). However,wenotice that
theapplication ofsoccurs attheendofbothlcaseString andofmaptoLower .
Infact,wecanremo veitbyperforming etareduction, toget:
lcaseString =maptoLower
Now,wehaveapartial application ofmap:itexpects afunction andalist,but
we‚Äôveonly givenitthefunction.
This allisrelated totype type ofmap,which is(a!b)!([a]![b]),when
parentheses areallincluded. Inourcase,toLower isoftypeChar!Char.Thus, if
wesupply thisfunction tomap,wegetafunction oftype[Char]![Char],asdesired.
Now,consider thetaskofconverting astring tolowercase andremo veallnonletter
characters. Wemight write thisas:
7.3.PARTIALAPPLICA TION 77
lcaseLetters s=maptoLower (filter isAlpha s)
Butnote thatwecanactually write thisinterms offunction composition:
lcaseLetters s=(maptoLower .filterisAlpha) s
And again,we‚Äôreleftwith anetareducible function:
lcaseLetters =maptoLower .filterisAlpha
Writing functions inthisstyle isverycommon among advanced Hask ellusers. In
factithasaname: point-free programming (nottobeconfused with pointless program- point-free programming
ming). Itiscallpoint freebecause intheoriginal deÔ¨Ånition oflcaseLetters ,we
canthink ofthevaluesasapoint onwhich thefunction isoperating. Byremo ving the
point from thefunction deÔ¨Ånition, wehaveapoint-free function.
Afunction similar to(.) is($).Whereas(.) isfunction composition, ($) is $
function application. ThedeÔ¨Ånition of($) from thePrelude isverysimple: function application
f$x=fx
However,thisfunction isgivenverylowÔ¨Åxity ,which means thatitcanbeused to
replace parentheses. Forinstance, wemight write afunction:
fooxy=bary(baz(fluff(orkx)))
However,using thefunction application function, wecanrewrite thisas:
fooxy=bary$baz$fluff$orkx
This moderately resembles thefunction composition syntax. The($) function is
alsouseful when combined with other inÔ¨Åx functions. Forinstance, wecannot write:
Prelude> putStrLn "5+3="++show(5+3)
because thisisinterpreted as(putStrLn "5+3=") ++(show(5+3)) ,which
makesnosense. However,wecanÔ¨Åxthisbywriting instead:
Prelude> putStrLn $"5+3="++show(5+3)
Which works Ô¨Åne.
Consider nowthetask ofextracting from alistoftuples alltheones whose Ô¨Årst
component isgreater than zero. One waytowrite thiswould be:
78 CHAPTER 7.ADVANCEDFEATURES
fstGt0l=filter(\(a,b)->a>0)l
WecanÔ¨Årstapply etareduction tothewhole function, yielding:
fstGt0=filter(\(a,b)->a>0)
Now,wecanrewrite thelambda function tousethefst function instead ofthe
pattern matching:
fstGt0=filter(\x->fstx>0)
Now,wecanusefunction composition betweenfst and>toget:
fstGt0=filter(\x->((>0).fst)x)
And Ô¨Ånally wecanetareduce:
fstGt0=filter((>0).fst)
This deÔ¨Ånition issimultaneously shorter andeasier tounderstand than theoriginal.
Wecanclearly seeexactly what itisdoing: we‚ÄôreÔ¨Åltering alistbychecking whether
something isgreater than zero. What arewechecking? Thefst element.
While converting topoint freestyle often results inclearer code, thisisofcourse
notalwaysthecase. Forinstance, converting thefollowing map topoint free style
yields something nearly uninterpretable:
foo=map(\x->sqrt(3+4*(xÀÜ2)))
foo=map(sqrt.(3+).(4*).(ÀÜ2))
There areahandful ofcombinators deÔ¨Åned inthePrelude which areuseful forpoint
freeprogramming:
uncurry takesafunction oftypea!b!candconvertsitintoafunction of
type(a;b)!c.This isuseful, forexample, when mapping across alistofpairs:
Prelude> map(uncurry (*))[(1,2),(3,4),(5,6)]
[2,12,30]
curry istheopposite ofuncurry andtakesafunction oftype(a;b)!cand
produces afunction oftypea!b!c.
flip reversetheorder ofarguments toafunction. That is,ittakesafunction of
typea!b!candproduces afunction oftypeb!a!c.Forinstance, we
cansortalistinreverseorder byusingflipcompare :
7.3.PARTIALAPPLICA TION 79
Prelude> List.sortBy compare [5,1,8,3]
[1,3,5,8]
Prelude> List.sortBy (flipcompare) [5,1,8,3]
[8,5,3,1]
This isthesame assaying:
Prelude> List.sortBy (\ab->compare ba)[5,1,8,3]
[8,5,3,1]
only shorter .
Ofcourse, notallfunctions canbewritten inpoint freestyle. Forinstance:
squarex=x*x
Cannot bewritten inpoint freestyle, without some other combinators. Forinstance,
ifwecandeÔ¨Åne other functions, wecanwrite:
pairx=(x,x)
square=uncurry (*).pair
Butinthiscase, thisisnotterribly useful.
Exer cises
Exer cise7.1Convertthefollowing functions intopoint-fr eestyle,ifpossible .
func1 xl=map(\y->y*x) l
func2 fgl=filter f(map gl)
func3 fl=l++mapfl
func4 l=map(\y->y+2)
(filter (\z->z`elem` [1..10])
(5:l))
func5 fl=foldr (\xy->f(y,x)) 0l
80 CHAPTER 7.ADVANCEDFEATURES
7.4 Patter nMatching
Pattern matching isoneofthemost powerful features ofHask ell(and most functional
programming languages). Itismost commonly used inconjunction with case expres-
sions, which wehavealready seen inSection 3.5. Let‚Äôsreturn toourColorexample
from Section 4.5.I‚Äôllrepeat thedeÔ¨Ånition wealready hadforthedatatype:
dataColor
=Red
|Orange
|Yellow
|Green
|Blue
|Purple
|White
|Black
|CustomIntIntInt--RGBcomponents
deriving (Show,Eq)
Wethen wanttowrite afunction thatwillconvertbetween something oftypeColor
andatriple ofInts,which correspond totheRGB values, respecti vely.SpeciÔ¨Åcally ,if
weseeaColorwhich isRed,wewanttoreturn(255,0,0) ,since thisistheRGB
value forred. Sowewrite that(remember thatpiece wise function deÔ¨Ånitions arejust
case statements):
colorToRGB Red=(255,0,0)
IfweseeaColorwhich isOrange ,wewanttoreturn(255,128,0) ;andifwe
seeYellow ,wewanttoreturn(255,255,0) ,andsoon.Finally ,ifweseeacustom
color ,which iscomprised ofthree components, wewanttomakeatriple outofthese,
sowewrite:
colorToRGB Orange=(255,128,0)
colorToRGB Yellow=(255,255,0)
colorToRGB Green=(0,255,0)
colorToRGB Blue=(0,0,255)
colorToRGB Purple=(255,0,255)
colorToRGB White=(255,255,255)
colorToRGB Black=(0,0,0)
colorToRGB (Custom rgb)=(r,g,b)
Then, inourinterpreter ,ifwetype:
Color>colorToRGB Yellow
(255,255,0)
7.4.PATTERNMATCHING 81
What ishappening isthis: wecreate avalue, callitx,which hasvalueRed.We
then apply thistocolorToRGB .Wecheck toseeifwecan‚Äúmatch‚Äù xagainstRed.
This match failsbecause according tothedeÔ¨Ånition ofEqColor,Red isnotequal
toYellow .Wecontinue downthedeÔ¨Ånitions ofcolorToRGB andtrytomatch
Yellow againstOrange .This fails, too. WethetrytomatchYellow against
Yellow ,which succeeds, soweusethisfunction deÔ¨Ånition, which simply returns
thevalue(255,255,0) ,asexpected.
Suppose instead, weused acustom color:
Color>colorToRGB (Custom 50200100)
(50,200,100)
Weapply thesame matching process, failing onallvalues fromRed toBlack .
Wethen gettotrytomatchCustom50200100 againstCustomrgb.We
canseethattheCustom partmatches, sothen wegoseeifthesubelements match. In
thematching, thevariablesr,gandbareessentially wild cards, sothere isnotrouble
matchingrwith 50,gwith 200andbwith 100. Asa‚Äúside-ef fect‚Äù ofthismatching,r
gets thevalue 50,ggets thevalue 200andbgets thevalue 100. Sotheentire match
succeeded andwelook atthedeÔ¨Ånition ofthispartofthefunction andbundle upthe
triple using thematched values ofr,gandb.
Wecanalsowrite afunction tocheck toseeifaColor isacustom color ornot:
isCustomColor (Custom ___)=True
isCustomColor _=False
When weapply avalue toisCustomColor ittries tomatch thatvalue against
Custom .This match willsucceed ifthevalue isCustomxyzforanyx,
yandz.The (underscore) character isa‚Äúwildcard‚Äù andwillmatch anything, butwill
notdothebinding thatwould happen ifyouputavariable name there. Ifthismatch
succeeds, thefunction returnsTrue ;however,ifthismatch fails,itgoes ontothenext
line, which willmatch anything andthen returnFalse .
Forsome reason wemight wanttodeÔ¨Åne afunction which tells uswhether agiven
color is‚Äúbright‚Äù ornot,where mydeÔ¨Ånition of‚Äúbright‚Äù isthatoneofitsRGB compo-
nents isequal to255(admittedly andarbitrary deÔ¨Ånition, butit‚Äôssimply anexample).
Wecould deÔ¨Åne thisfunction as:
isBright =isBright‚Äô .colorToRGB
whereisBright‚Äô (255,_,_) =True
isBright‚Äô (_,255,_) =True
isBright‚Äô (_,_,255) =True
isBright‚Äô _ =False
Let‚Äôsdwell onthisdeÔ¨Ånition forasecond. TheisBright function isthecompo-
sition ofourpreviously deÔ¨Åned functioncolorToRGB andahelper functionisBright‚Äô ,
which tells usifagivenRGB value isbright ornot.Wecould replace theÔ¨Årstlinehere
82 CHAPTER 7.ADVANCEDFEATURES
withisBright c=isBright‚Äô (colorToRGB c)butthere isnoneed toex-
plicitly write theparameter here, sowedon‚Äôt.Again,thisfunction composition style
ofprogramming takessome getting used to,soIwill trytouseitfrequently inthis
tutorial.
TheisBright‚Äô helper function takestheRGB triple produced bycolorToRGB .
ItÔ¨Årst tries tomatch itagainst(255,,)which succeeds ifthevalue has255in
itsÔ¨Årst position. Ifthismatch succeeds,isBright‚Äô returnsTrue andsodoes
isBright .Thesecond andthird lineofdeÔ¨Ånition check for255inthesecond and
third position inthetriple, respecti vely.Thefourth line, thefallthr ough ,matches ev-
erything elseandreports itasnotbright.
Wemight wanttoalsowrite afunction toconvertbetween RGB triples andColors.
Wecould simple stick everything inaCustom constructor ,butthiswould defeat the
purpose; wewanttousetheCustom slotonly forvalues which don‚Äôtmatch thepre-
deÔ¨Åned colors. However,wedon‚Äôtwanttoallowtheuser toconstruct custom colors
like(600,-40,99) since these areinvalidRGB values. Wecould throwanerror ifsuch
avalue isgiven,butthiscanbedifÔ¨Åcult todeal with. Instead, weusetheMaybe
datatype. This isdeÔ¨Åned (inthePrelude) as:
dataMaybea=Nothing
|Justa
Thewayweusethisisasfollows:ourrgbToColor function returns avalue of
typeMaybeColor .IftheRGB value passed toourfunction isinvalid ,wereturn
Nothing ,which corresponds toafailure. If,ontheother hand, theRGB value is
valid, wecreate theappropriate Colorvalue andreturnJust that. Thecode todothis
is:
rgbToColor 25500=JustRed
rgbToColor 2551280=JustOrange
rgbToColor 2552550=JustYellow
rgbToColor 02550=JustGreen
rgbToColor 00255=JustBlue
rgbToColor 2550255=JustPurple
rgbToColor 255255255=JustWhite
rgbToColor 000=JustBlack
rgbToColor rgb=
if0<=r&&r<=255&&
0<=g&&g<=255&&
0<=b&&b<=255
thenJust(Custom rgb)
elseNothing --invalid RGBvalue
TheÔ¨Årsteight lines match theRGB arguments against thepredeÔ¨Åned values and,
iftheymatch,rgbToColor returnsJust theappropriate color .Ifnone ofthese
matches, thelastdeÔ¨Ånition ofrgbToColor matches theÔ¨Årstargument againstr,the
7.5.GUARDS 83
second againstgandthethird againstb(which causes theside-ef fectofbinding these
values). Itthen checks toseeifthese values arevalid(each isgreater than orequal to
zero andlessthan orequal to255). Ifso,itreturnsJust(Custom rgb);ifnot,
itreturnsNothing corresponding toaninvalidcolor .
Using this, wecanwrite afunction thatchecks toseeifaright RGB value isvalid:
rgbIsValid rgb=rgbIsValid‚Äô (rgbToColor rgb)
wherergbIsValid‚Äô (Just_)=True
rgbIsValid‚Äô _ =False
Here, wecompose thehelper functionrgbIsValid‚Äô with ourfunctionrgbToColor .
Thehelper function checks toseeifthevalue returned byrgbToColor isJust any-
thing (the wildcard). Ifso,itreturnsTrue .Ifnot, itmatches anything andreturns
False .
Pattern matching isn‚Äôtmagic, though. Youcanonly match against datatypes; you
cannot match against functions. Forinstance, thefollowing isinvalid:
fx=x+1
g(fx)=x
Eventhough theintended meaning ofgisclear (i.e.,gx=x-1),thecom-
piler doesn‚Äô tknowingeneral thatfhasaninversefunction, soitcan‚Äôtperform matches
likethis.
7.5 Guards
Guards canbethought ofasanextension tothepattern matching facility .Theyenable
youtoallowpiece wise function deÔ¨Ånitions tobetakenaccording toarbitrary boolean
expressions. Guards appear after allarguments toafunction butbefore theequals sign,
andarebegunwith avertical bar.Wecould useguards towrite asimple function which
returns astring telling youtheresult ofcomparing twoelements:
comparison xy|x<y="Thefirstisless"
|x>y="Thesecondisless"
|otherwise ="Theyareequal"
Youcanread thevertical baras‚Äúsuch that.‚ÄùSowesaythatthevalueofcomparison
xy‚Äúsuch that‚Äù xislessthan yis‚ÄúThe Ô¨Årstisless.‚ÄùThevalue such thatxisgreater
than yis‚ÄúThe second isless‚Äù andthevalue otherwise is‚ÄúThe yareequal‚Äù. Thekey-
wordotherwise issimply deÔ¨Åned tobeequal toTrue andthus matches anything
thatfallsthrough thatfar.So,wecanseethatthisworks:
84 CHAPTER 7.ADVANCEDFEATURES
Guards> comparison 510
"Thefirstisless"
Guards> comparison 105
"Thesecondisless"
Guards> comparison 77
"Theyareequal"
One thing tonote about guards isthattheyaretested after pattern matching, notin
conjunction with pattern matching. This means thatonce apattern matches, ifnone of
theguards succeed, further pattern matches willnotbeattempted. So,ifwehadinstead
deÔ¨Åned:
comparison2 xy|x<y="Thefirstisless"
|x>y="Thesecondisless"
comparison2 __="Theyareequal"
Theintention would bethatifboth oftheguards failed, itwould ‚Äúfallthrough‚Äù to
theÔ¨Ånal match andsaythattheywere equal. This isnotwhat happens, though.
Guards> comparison2 77
***Exception: Guards.hs:8: Non-exhaustive patterns
infunction comparison2
Ifwethink about what ishappening inthecompiler thismakessense. When we
apply twosevenstocomparison2 ,theyarematched againstxandy,which suc-
ceeds andthevalues arebound. Pattern matching then stops completely ,since ithas
succeeded. Theguards arethen activated andxandyarecompared. Neither ofthe
guards succeeds, soanerror israised.
Onenicety about guards isthatwher eclauses arecommon toallguards. Soanother
possible deÔ¨Ånition forourisBright function from theprevious section would be:
isBright2 c|r==255=True
|g==255=True
|b==255=True
|otherwise =False
where(r,g,b) =colorToRGB c
The function isequivalent totheprevious version, butperforms itscalculation
slightly differently .Ittakesacolor ,c,andappliescolorToRGB toit,yielding an
RGB triple which ismatched (using pattern matching!) against(r,g,b) .This match
succeeds andthevaluesr,gandbarebound totheir respecti vevalues. TheÔ¨Årstguard
checks toseeifris255and, ifso,returns true. Thesecond andthird guard checkg
andbagainst 255, respecti velyandreturn trueiftheymatch. Thelastguard Ô¨Åres asa
lastresort andreturnsFalse .
7.6.INSTANCEDECLARA TIONS 85
7.6 Instance Declarations
Inorder todeclare atype tobeaninstance ofaclass, youneed toprovide aninstance
declaration forit.Most classes provide what‚Äô scalled a‚Äúminimal complete deÔ¨Ånition. ‚Äù
This means thefunctions which must beimplemented forthisclass inorder forits
deÔ¨Ånition tobesatisÔ¨Åed. Once you‚Äôvewritten these functions foryour type, youcan
declare itaninstance oftheclass.
7.6.1 TheEqClass
TheEqclass hastwomembers (i.e., twofunctions):
(==)::Eqa=>a->a->Bool
(/=)::Eqa=>a->a->Bool
TheÔ¨Årstofthese type signatures reads thatthefunction==isafunction which takes
twoaswhich aremembers ofEqandproduces aBool .Thetype signature of/=(not
equal) isidentical. Aminimal complete deÔ¨Ånition fortheEqclass requires thateither
oneofthese functions bedeÔ¨Åned (ifyoudeÔ¨Åne==,then/=isdeÔ¨Åned automatically by
negating theresult of==,andvice versa). These declarations must beprovided inside
theinstance declaration.
This isbest demonstrated byexample. Suppose wehaveourcolor example, re-
peded here forconvenience:
dataColor
=Red
|Orange
|Yellow
|Green
|Blue
|Purple
|White
|Black
|CustomIntIntInt--RGBcomponents
WecandeÔ¨Åne Colortobeaninstance ofEqbythefollowing declaration:
instance EqColorwhere
Red==Red=True
Orange==Orange=True
Yellow==Yellow=True
Green==Green=True
Blue==Blue=True
Purple==Purple=True
White==White=True
86 CHAPTER 7.ADVANCEDFEATURES
Black==Black=True
(Custom rgb)==(Custom r‚Äôg‚Äôb‚Äô)=
r==r‚Äô&&g==g‚Äô&&b==b‚Äô
_==_=False
TheÔ¨Årstlinehere begins with thekeywordinstance telling thecompiler thatwe‚Äôre
making aninstance declaration. Itthen speciÔ¨Åes theclass,Eq,andthetype,Color
which isgoing tobeaninstance ofthisclass. Following that, there‚Äô sthewher ekey-
word. Finally there‚Äô sthemethod declaration.
TheÔ¨Årsteight lines ofthemethod declaration arebasically identical. TheÔ¨Årstone,
forinstance, says thatthevalue oftheexpressionRed==Red isequal toTrue .
Lines twothrough eight areidentical. Thedeclaration forcustom colors isabitdiffer-
ent.Wepattern matchCustom onboth sides of==.Onthelefthand side, webindr,
gandbtothecomponents, respecti vely.Ontheright hand side, webindr‚Äô,g‚Äôand
b‚Äôtothecomponents. Wethen saythatthese twocustom colors areequal precisely
whenr==r‚Äô,g==g‚Äôandb==b‚Äôareallequal. Thefallthrough says thatany
pairwehaven‚Äôtpreviously declared asequal areunequal.
7.6.2 TheShow Class
TheShowclass isused todisplay arbitrary values asstrings. This class hasthree
methods:
show::Showa=>a->String
showsPrec ::Showa=>Int->a->String->String
showList ::Showa=>[a]->String->String
Aminimal complete deÔ¨Ånition iseithershow orshowsPrec (wewilltalkabout
showsPrec later ‚Äìit‚Äôsinthere forefÔ¨Åcienc yreasons). WecandeÔ¨Åne ourColor
datatype tobeaninstance ofShowwith thefollowing instance declaration:
instance ShowColorwhere
showRed="Red"
showOrange="Orange"
showYellow="Yellow"
showGreen="Green"
showBlue="Blue"
showPurple="Purple"
showWhite="White"
showBlack="Black"
show(Custom rgb)=
"Custom "++showr++""++
showg++""++showb
This declaration speciÔ¨Åes exactly howtoconvertvalues oftypeColortoString s.
Again,theÔ¨Årsteight lines areidentical andsimply takeaColorandproduce astring.
7.6.INSTANCEDECLARA TIONS 87
Thelastlineforhandling custom colors matches outtheRGB components andcreates
astring byconcattenating theresult ofshow ingthecomponents individually (with
spaces inbetween and‚ÄúCustom‚Äù atthebeginning).
7.6.3 Other Important Classes
There areafewother important classes which Iwillmention brieÔ¨Çy because either they
arecommonly used orbecause wewillbeusing them shortly .Iwon‚Äôtprovide example
instance declarations; howyoucandothisshould beclear bynow.
TheOrd Class
Theordering class, thefunctions are:
compare ::Orda=>a->a->Ordering
(<=)::Orda=>a->a->Bool
(>)::Orda=>a->a->Bool
(>=)::Orda=>a->a->Bool
(<)::Orda=>a->a->Bool
min::Orda=>a->a->a
max::Orda=>a->a->a
Thealmost anyofthefunctions alone isaminimal complete deÔ¨Ånition; itisrec-
ommended thatyouimplement compare ifyouimplement only one, though. This
function returns avalue oftypeOrdering which isdeÔ¨Åned as:
dataOrdering =LT|EQ|GT
So,forinstance, weget:
Prelude> compare 57
LT
Prelude> compare 66
EQ
Prelude> compare 75
GT
Inorder todeclare atype tobeaninstance ofOrd youmust already havedeclared
itaninstance ofEq(inother words,Ord isasubclass ofEq‚Äìmore about thisin
Section 8.4).
TheEnum Class
TheEnum class isforenumerated types; thatis,fortypes where each element hasa
successor andapredecessor .It‚Äôsmethods are:
88 CHAPTER 7.ADVANCEDFEATURES
pred::Enuma=>a->a
succ::Enuma=>a->a
toEnum::Enuma=>Int->a
fromEnum ::Enuma=>a->Int
enumFrom ::Enuma=>a->[a]
enumFromThen ::Enuma=>a->a->[a]
enumFromTo ::Enuma=>a->a->[a]
enumFromThenTo ::Enuma=>a->a->a->[a]
The minimal complete deÔ¨Ånition contains bothtoEnum andfromEnum ,which
convertsfrom andtoInts.Thepred andsucc functions givethepredecessor and
successor ,respecti vely.Theenum functions enumerate listsofelements. Forinstance,
enumFrom xlistsallelements afterx;enumFromThen xstep listsallelements
starting atxinsteps ofsizestep .TheTofunctions endtheenumeration atthegiven
element.
TheNum Class
TheNum class provides thestandard arithmetic operations:
(-)::Numa=>a->a->a
(*)::Numa=>a->a->a
(+)::Numa=>a->a->a
negate::Numa=>a->a
signum::Numa=>a->a
abs::Numa=>a->a
fromInteger ::Numa=>Integer ->a
Allofthese areobvious except forperhapsnegate which istheunary minus.
That is,negatexmeans  x.
TheRead Class
TheRead class istheopposite oftheShowclass. Itisawaytotakeastring andread
infrom itavalue ofarbitrary type. Themethods forRead are:
readsPrec ::Reada=>Int->String->[(a,String)]
readList ::String->[([a],String)]
The minimal complete deÔ¨Ånition isreadsPrec .The most important function
related tothisisread ,which usesreadsPrec as:
reads=fst(head(readsPrec 0s))
7.6.INSTANCEDECLARA TIONS 89
This willfailifparsing thestring fails. Youcould deÔ¨Åne amaybeRead function
as:
maybeRead s=
casereadsPrec 0sof
[(a,_)] ->Justa
_->Nothing
Howtowrite andusereadsPrec directly willbediscussed further intheexam-
ples.
7.6.4 Class Contexts
Suppose wearedeÔ¨Ånition theMaybedatatype from scratch. ThedeÔ¨Ånition would be
something like:
dataMaybea=Nothing
|Justa
Now,when wegotowrite theinstance declarations, for,say,Eq,weneed toknow
thataisaninstance ofEqotherwise wecan‚Äôtwrite adeclaration. Weexpress thisas:
instance Eqa=>Eq(Maybea)where
Nothing ==Nothing =True
(Justx)==(Justx‚Äô)==x==x‚Äô
This Ô¨Årstlinecanberead ‚ÄúThat aisaninstance ofEqimplies (=>)thatMaybea
isaninstance ofEq.‚Äù
7.6.5 Deri ving Classes
Writing obviousEq,Ord ,Read andShowclasses likethese istedious andshould be
automated. Luckily forus,itis.Ifyouwrite adatatype that‚Äôs‚Äúsimple enough‚Äù (almost
anydatatype you‚Äôllwrite unless youstart writing Ô¨Åxedpoint types), thecompiler can
automatically derive some ofthemost basic classes. Todothis, yousimply adda
deriving clause toafter thedatatype declaration, asin:
dataColor
=Red
|...
|CustomIntIntInt--RGBcomponents
deriving (Eq,Ord,Show,Read)
This willautomatically create instances oftheColordatatype ofthenamed classes.
Similarly ,thedeclaration:
90 CHAPTER 7.ADVANCEDFEATURES
dataMaybea=Nothing
|Justa
deriving (Eq,Ord,ShowRead)
derivesthese classes justwhenaisappropriate.
Allinall,youareallowed toderiveinstances ofEq,Ord ,Enum,Bounded ,
ShowandRead .There isconsiderable workinthearea of‚Äúpolytypic programming‚Äù
or‚Äúgeneric programming‚Äù which, among other things, would allowforinstance dec-
larations foranyclass tobederived.This ismuch beyond thescope ofthistutorial;
instead, Irefer youtotheliterature.
7.7 Datatypes Revisited
Iknowbythispoint you‚Äôreprobably terribly tired ofhearing about datatypes. They
are,however,incredibly important, otherwise Iwouldn‚Äô tdevotesomuch time tothem.
Datatypes offerasortofnotational convenience ifyouhave,forinstance, adatatype
thatholds manymanyvalues. These arecalled named Ô¨Åelds.
7.7.1 Named Fields
Consider adatatype whose purpose istohold conÔ¨Åguration settings. Usually when
youextract members from thistype, youreally only care about oneorpossibly twoof
themanysettings. Moreo ver,ifmanyofthesettings havethesame type, youmight
often Ô¨Åndyourself wondering ‚Äúwait,wasthisthefourth orÔ¨Åfthelement?‚Äù One thing
youcould dowould betowrite accessor functions. Consider thefollowing made-up
conÔ¨Åguration type foraterminal program:
dataConfiguration =
Configuration String --username
String --localhost
String --remotehost
Bool --isguest?
Bool --issuperuser?
String --current directory
String --homedirectory
Integer --timeconnected
deriving (Eq,Show)
Youcould then write accessor functions, like(I‚Äôveonly listed afew):
getUserName (Configuration un_______)=un
getLocalHost (Configuration _lh______)=lh
getRemoteHost (Configuration __rh_____)=rh
7.7.DATATYPESREVISITED 91
getIsGuest (Configuration ___ig____)=ig
...
Youcould also write update functions toupdate asingle element. Ofcourse, now
ifyouaddanelement totheconÔ¨Åguration, orremo veone, allofthese functions now
havetotakeadifferent number ofarguments. This ishighly anno ying andisaneasy
place forbugstoslipin.However,there‚Äô sasolution. Wesimply givenames tothe
Ô¨Åelds inthedatatype declaration, asfollows:
dataConfiguration =
Configuration {username ::String,
localhost ::String,
remotehost ::String,
isguest ::Bool,
issuperuser ::Bool,
currentdir ::String,
homedir ::String,
timeconnected ::Integer
}
This willautomatically generate thefollowing accessor functions forus:
username ::Configuration ->String
localhost ::Configuration ->String
...
Moreo ver,itgivesusveryconvenient update methods. Here isashort example
fora‚Äúpost working directory‚Äù and‚Äúchange directory‚Äù likefunctions that workon
Conguration s:
changeDir ::Configuration ->String->Configuration
changeDir cfgnewDir=
--makesurethedirectory exists
ifdirectoryExists newDir
then--changeourcurrent directory
cfg{currentdir =newDir}
elseerror"directory doesnotexist"
postWorkingDir ::Configuration ->String
--retrieve ourcurrent directory
postWorkingDir cfg=currentdir cfg
So,ingeneral, toupdate theÔ¨Åeldxinadatatype ytoz,youwriteyfx=zg.You
canchange more than one; each should beseparated bycommas, forinstance,yfx=z,
a=b,c=dg.
92 CHAPTER 7.ADVANCEDFEATURES
Youcanofcourse continue topattern match againstConguration sasyou did
before. Thenamed Ô¨Åelds aresimply syntactic sugar;youcanstillwrite something like:
getUserName (Configuration un_______)=un
Butthere islittle reason to.Finally ,youcanpattern match against named Ô¨Åelds as
in:
getHostData (Configuration {localhost=lh,remotehost=rh})
=(lh,rh)
This matches thevariablelhagainst thelocalhost Ô¨Åeld ontheConguration
andthevariablerhagainst theremotehost Ô¨Åeld ontheConguration .These
matches ofcourse succeed. Youcould also constrain thematches byputting values
instead ofvariable names inthese positions, asyouwould forstandard datatypes.
Youcancreate values ofConguration intheoldwayasshownintheÔ¨ÅrstdeÔ¨Ånition
below,orinthenamed-Ô¨Åeld‚Äô stype, asshowninthesecond deÔ¨Ånition below:
initCFG =
Configuration "nobody" "nowhere" "nowhere"
FalseFalse"/""/"0
initCFG‚Äô =
Configuration
{username="nobody",
localhost="nowhere",
remotehost="nowhere",
isguest=False,
issuperuser=False,
currentdir="/",
homedir="/",
timeconnected=0 }
Though thesecond isprobably much more understandable unless youlitter your
code with comments.
7.8 MoreLists
todo: putsomething here
7.8.1 Standard List Functions
Recall thatthedeÔ¨Ånition ofthebuilt-in Hask elllistdatatype isequivalent to:
dataLista=Nil
|Consa(Lista)
7.8.MORELISTS 93
Withtheexception thatNil iscalled[]andConsxxsiscalledx:xs .This is
simply tomakepattern matching easier andcode smaller .Let‚Äôsinvestig atehowsome
ofthestandard listfunctions may bewritten. Considermap.AdeÔ¨Ånition isgiven
below:
map_[]=[]
mapf(x:xs)=fx:mapfxs
Here, theÔ¨Årstlinesays thatwhen youmap across anempty list,nomatter what the
function is,yougetanempty listback. Thesecond linesays thatwhen youmap across
alistwithxasthehead andxsasthetail,theresult isfapplied toxconsed onto the
result ofmappingfonxs.
Thefilter canbedeÔ¨Åned similarly:
filter_[]=[]
filterp(x:xs)|px=x:filterpxs
|otherwise =filterpxs
Howthisworks should beclear .Foranempty list,wereturn anempty list. For
anonempty list,wereturn theÔ¨Ålter ofthetail, perhaps with thehead onthefront,
depending onwhether itsatisÔ¨Åes thepredicatepornot.
WecandeÔ¨Ånefoldr as:
foldr_z[]=z
foldrfz(x:xs)=fx(foldrfzxs)
Here, thebest interpretation isthatwearereplacing theempty list([])with a
particular value andthelistconstructor (:)with some function. OntheÔ¨Årstline, we
canseethereplacement of[]forz.Using backquotes tomakefinÔ¨Åx, wecanwrite
thesecond lineas:
foldrfz(x:xs)=x‚Äòf‚Äò(foldrfzxs)
From this, wecandirectly seehow:isbeing replaced byf.
Finally ,foldl :
foldl_z[]=z
foldlfz(x:xs)=foldlf(fzx)xs
This isslightly more complicated. Remember ,zcanbethought ofasthecurrent
state. Soifwe‚Äôrefolding across alistwhich isempty ,wesimply return thecurrent
state. Ontheother hand, ifthelistisnotempty ,it‚Äôsoftheformx:xs .Inthiscase, we
getanewstate byapplingftothecurrent statezandthecurrent listelementxand
then recursi velycallfoldl onxswith thisnewstate.
There isanother class offunctions: thezip andunzip functions, which respec-
tivelytakemultiple lists andmakeoneortakeonelists andsplit them apart. For
instance,zip does thefollowing:
94 CHAPTER 7.ADVANCEDFEATURES
Prelude> zip"hello" [1,2,3,4,5]
[(‚Äôh‚Äô,1),(‚Äôe‚Äô,2),(‚Äôl‚Äô,3),(‚Äôl‚Äô,4),(‚Äôo‚Äô,5)]
Basically ,itpairs theÔ¨Årstelements ofboth listsandmakesthattheÔ¨Årstelement of
thenewlist.Itthen pairs thesecond elements ofboth lists andmakesthatthesecond
element, etc. What ifthelists haveunequal length? Itsimply stops when theshorter
onestops. Areasonable deÔ¨Ånition forzip is:
zip[]_=[]
zip_[]=[]
zip(x:xs)(y:ys)=(x,y):zipxsys
Theunzip function does theopposite. Ittakesazipped listandreturns thetwo
‚Äúoriginal‚Äù lists:
Prelude> unzip[(‚Äôf‚Äô,1),(‚Äôo‚Äô,2),(‚Äôo‚Äô,3)]
("foo",[1,2,3])
There areawhole slewofzip andunzip functions, namedzip3 ,unzip3 ,
zip4 ,unzip4 andsoon;the...3 functions usetriples instead ofpairs; the...4
functions use4-tuples, etc.
Finally ,thefunctiontake takesanintegernandalistandreturns theÔ¨Årstn
elements offthelist. Correspondingly ,drop takesanintegernandalistandreturns
theresult ofthrowing awaytheÔ¨Årstnelements offthelist.Neither ofthese functions
produces anerror; ifnistoolarge,theyboth willjustreturn shorter lists.
7.8.2 List Compr ehensions
There issome syntactic sugarfordealing with listswhose elements aremembers ofthe
Enumclass (seeSection 7.6), such asIntorChar.Ifwewanttocreate alistofallthe
elements from1to10,wecansimply write:
Prelude> [1..10]
[1,2,3,4,5,6,7,8,9,10]
Wecanalsointroduce anamount tostepby:
Prelude> [1,3..10]
[1,3,5,7,9]
Prelude> [1,4..10]
[1,4,7,10]
These expressions areshort hand forenumFromTo andenumFromThenTo ,re-
specti vely.Ofcourse, youdon‚Äôtneed tospecify anupper bound. Trythefollowing
(butbeready tohitControl+C tostop thecomputation!):
7.8.MORELISTS 95
Prelude> [1..]
[1,2,3,4,5,6,7,8,9,10,11,12{Interrupted!}
Probably yours printed afewthousand more elements than this. Aswesaidbefore,
Hask ellislazy.That means thatalistofallnumbers from 1onisperfectly well formed
andthat‚Äôsexactly what thislistis.Ofcourse, ifyouattempt toprint thelist(which
we‚Äôreimplicitly doing bytyping itintheinterpreter), itwon‚Äôthalt. Butifweonly
evaluate aninitial segment ofthislist,we‚ÄôreÔ¨Åne:
Prelude> take3[1..]
[1,2,3]
Prelude> take3(drop5[1..])
[6,7,8]
This comes inuseful if,say,wewanttoassign anIDtoeach element inalist.
Without laziness we‚Äôdhavetowrite something likethis:
assignID ::[a]->[(a,Int)]
assignID l=zipl[1..length l]
Which means thatthelistwillbetraversed twice. However,because oflaziness,
wecansimply write:
assignID l=zipl[1..]
And we‚Äôllgetexactly what wewant.Wecanseethatthisworks:
Prelude> assignID "hello"
[(‚Äôh‚Äô,1),(‚Äôe‚Äô,2),(‚Äôl‚Äô,3),(‚Äôl‚Äô,4),(‚Äôo‚Äô,5)]
Finally ,there issome useful syntactic sugarformap andfilter ,based onstan-
dard set-notation inmathematics. Inmath, wewould write something likeff(x)jx2
s^p(x)gtomean thesetofallvalues offwhen applied toelements ofswhich satisfy
p.This isequivalent totheHask ellstatementmapf(filter ps).However,we
canalsousemore math-lik enotation andwrite[fx|x<-s,px].While in
math theordering ofthestatements ontheside after thepipe isfree, itisnotsoin
Hask ell.Wecould nothaveputpxbeforex<-sotherwise thecompiler wouldn‚Äô t
knowyetwhatxwas.Wecanusethistodosimple string processing. Suppose we
wanttotakeastring, remo veallthelower-case letters andconverttherestoftheletters
toupper case. Wecould dothisineither ofthefollowing twoequivalent ways:
Prelude> maptoLower (filter isUpper "HelloWorld")
"hw"
Prelude> [toLower x|x<-"HelloWorld", isUpper x]
"hw"
96 CHAPTER 7.ADVANCEDFEATURES
These twoareequivalent, and, depending ontheexact functions you‚Äôreusing, one
might bemore readable than theother .There‚Äô smore youcandohere, though. Suppose
youwanttocreate alistofpairs, oneforeach point between (0,0) and(5,7) belowthe
diagonal. Doing thismanually with listsandmaps would becumbersome andpossibly
difÔ¨Åcult toread. Itcouldn‚Äô tbeeasier than with listcomprehensions:
Prelude> [(x,y)|x<-[1..5], y<-[x..7]]
[(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(2,2),( 2,3),
(2,4),(2,5),(2,6),(2,7),(3,3),(3,4),(3,5),(3,6),(3 ,7),
(4,4),(4,5),(4,6),(4,7),(5,5),(5,6),(5,7)]
Ifyoureverse theorder ofthex<-andy<-clauses, theorder inwhich the
space istraversed willbereversed (ofcourse, inthatcase,ycould nolonger depend
onxandyouwould need tomakexdepend onybutthisistrivial).
7.9 Arrays
Lists arenice formanythings. Itiseasy toaddelements tothebeginning ofthem and
tomanipulate them invarious waysthatchange thelength ofthelist.However,theyare
badforrandom access, having average comple xityO(n)toaccess anarbitrary element
(ifyoudon‚ÄôtknowwhatO(:::)means, youcaneither ignore itortakeaquick detour
andread Appendix A,atwo-page introduction tocomple xity theory). So,ifyou‚Äôre
willing togiveupfastinsertion anddeletion because youneed random access, you
should usearrays instead oflists.
Inorder tousearrays you must import theArray module. There areafew
methods forcreating arrays, thearray function, thelistArray function, andthe
accumArray function. Thearray function takesapair which isthebounds of
thearray ,andanassociation listwhich speciÔ¨Åes theinitial values ofthearray .The
listArray function takesbounds andthen simply alistofvalues. Finally ,the
accumArray function takesanaccumulation function, aninitial value andanassoci-
ation listandaccumulates pairs from thelistintothearray .Here aresome examples of
arrays being created:
Arrays> array(1,5)[(i,2*i) |i<-[1..5]]
array(1,5)[(1,2),(2,4),(3,6),(4,8),(5,10)]
Arrays> listArray (1,5)[3,7,5,1,10]
array(1,5)[(1,3),(2,7),(3,5),(4,1),(5,10)]
Arrays> accumArray (+)2(1,5)[(i,i)|i<-[1..5]]
array(1,5)[(1,3),(2,4),(3,5),(4,6),(5,7)]
When arrays areprinted out(viatheshowfunction), theyareprinted with anasso-
ciation list.Forinstance, intheÔ¨Årstexample, theassociation listsays thatthevalue of
thearray at1is2,thevalue ofthearray at2is4,andsoon.
Youcanextract anelement ofanarray using the!function, which takesanarray
andanindex,asin:
7.10.FINITEMAPS 97
Arrays> (listArray (1,5)[3,7,5,1,10]) !3
5
Moreo ver,youcanupdate elements inthearray using the//function. This takes
anarray andanassociation listandupdates thepositions speciÔ¨Åed inthelist:
Arrays> (listArray (1,5)[3,7,5,1,10]) //
[(2,99),(3,-99)]
array(1,5)[(1,3),(2,99),(3,-99),(4,1),(5,10)]
There areafewother functions which areofinterest:
bounds returns thebounds ofanarray
indices returns alistofallindices ofthearray
elems returns alistofallthevalues inthearray inorder
assocs returns anassociation listforthearray
IfwedeÔ¨Ånearr tobelistArray (1,5)[3,7,5,1,10] ,theresult of
these functions applied toarr are:
Arrays> boundsarr
(1,5)
Arrays> indices arr
[1,2,3,4,5]
Arrays> elemsarr
[3,7,5,1,10]
Arrays> assocsarr
[(1,3),(2,7),(3,5),(4,1),(5,10)]
Note thatwhile arrays areO(1)access, theyarenotO(1)update. Theyarein
factO(n)update, since inorder tomaintain purity ,thearray must becopied inorder to
makeanupdate. Thus, functional arrays arepretty much only useful when you‚ÄôreÔ¨Ålling
them uponce andthen only reading. Ifyouneed fastaccess andupdate, youshould
probably useFiniteMap s,which arediscussed inSection 7.10 andhaveO(logn)
access andupdate.
7.10 Finite Maps
TheFiniteMap datatype (which isavailable intheFiniteMap module, orData.FiniteMap
module inthehierarchical libraries) isapurely functional implementation ofbalanced
trees. Finite maps canbecompared tolists arearrays interms ofthetime ittakesto
perform various operations onthose datatypes ofaÔ¨Åxedsize,n.Abrief comparison
is:
98 CHAPTER 7.ADVANCEDFEATURES
List Array FiniteMap
insert O(1) O(n)O(logn)
update O(n)O(n)O(logn)
delete O(n)O(n)O(logn)
Ô¨Ånd O(n)O(1) O(logn)
map O(n)O(n)O(nlogn)
Aswecansee,lists provide fastinsertion (butsloweverything else), arrays pro-
vide fastlookup (butsloweverything else) andÔ¨Ånite maps provide moderately fast
everything (except mapping, which isabitslowerthan listsorarrays).
Thetype ofaÔ¨Ånite map isfortheformFiniteMapk eyeltwhere keyisthetype of
thekeysandeltisthetype oftheelements. That is,Ô¨Ånite maps arelookup tables from
typekeytotypeelt.
Thebasic Ô¨Ånite map functions are:
emptyFM ::FiniteMap keyelt
addToFM ::FiniteMap keyelt->key->elt->
FiniteMap keyelt
delFromFM ::FiniteMap keyelt->key->
FiniteMap keyelt
elemFM ::key->FiniteMap keyelt->Bool
lookupFM ::FiniteMap keyelt->key->Maybeelt
Inallthese cases, thetypekeymust beaninstance ofOrd (and hence also an
instance ofEq).
There arealso functionlistToFM andfmToList toconvertlists toandfrom
Ô¨Ånite maps. Trythefollowing:
Prelude> :mFiniteMap
FiniteMap> letfm=listToFM
[(‚Äôa‚Äô,5),(‚Äôb‚Äô,10),(‚Äôc‚Äô,1),(‚Äôd‚Äô,2)]
FiniteMap> letmyFM=addToFM fm‚Äôe‚Äô6
FiniteMap> fmToList fm
[(‚Äôa‚Äô,5),(‚Äôb‚Äô,10),(‚Äôc‚Äô,1),(‚Äôd‚Äô,2)]
FiniteMap> fmToList myFM
[(‚Äôa‚Äô,5),(‚Äôb‚Äô,10),(‚Äôc‚Äô,1),(‚Äôd‚Äô,2),(‚Äôe‚Äô,6)]
FiniteMap> lookupFM myFM‚Äôe‚Äô
Just6
FiniteMap> lookupFM fm‚Äôe‚Äô
Nothing
Youcanalso experiment with theother commands. Note thatyoucannotshow a
Ô¨Ånite map, astheyarenotinstances ofShow:
FiniteMap> showmyFM
7.11.LAYOUT 99
<interactive>:1:
Noinstance for(Show(FiniteMap CharInteger))
arising fromuseof‚Äòshow‚Äôat<interactive>:1
Inthedefinition of‚Äòit‚Äô:showmyFM
Inorder toinspect theelements, youÔ¨Årstneed tousefmToList .
7.11 Layout
7.12 The Final WordonLists
Youarelikelytired ofhearing about lists atthispoint, buttheyaresofundamental to
Hask ell(and really alloffunctional programming) thatitwould beterrible nottotalk
about them some more.
Itturns outthatfoldr isactually quite apowerful function: itcancompute an
primitive recursive function. Aprimiti verecursi vefunction isessentially onewhich primitiv erecursiv e
canbecalculated using only ‚Äúfor‚Äù loops, butnot‚Äúwhile‚Äù loops.
Infact,wecanfairly easily deÔ¨Ånemap interms offoldr :
map2f=foldr(\ab->fa:b)[]
Here,bistheaccumulator (i.e., theresult list)andaistheelement being currently
considered. Infact,wecansimplify thisdeÔ¨Ånition through asequence ofsteps:
foldr(\ab->fa:b)[]
==>foldr(\ab->(:)(fa)b)[]
==>foldr(\a->(:)(fa))[]
==>foldr(\a->((:).f)a)[]
==>foldr((:).f)[]
This isdirectly related tothefactthatfoldr(:)[]istheidentity function on
lists. This isbecause, asmentioned before,foldrfzcanbethought ofasreplacing
the[]inlists byzandthe:byf.Inthiscase, we‚Äôrekeeping both thesame, soitis
theidentity function.
Infact,youcanconvertanyfunction ofthefollowing style intoafoldr :
myfunc[]=z
myfunc(x:xs)=fx(myfunc xs)
Bywriting thelastlinewithfininÔ¨Åx form, thisshould beobvious:
myfunc[]=z
myfunc(x:xs)=x‚Äòf‚Äò(myfunc xs)
100 CHAPTER 7.ADVANCEDFEATURES
Clearly ,wearejustreplacing[]withzand:withf.Consider thefilter
function:
filterp[]=[]
filterp(x:xs)=
ifpx
thenx:filterpxs
elsefilterpxs
This function also followstheform above.Based ontheÔ¨Årstline, wecanÔ¨Ågure
outthatzissupposed tobe[],justlikeinthemap case. Now,suppose thatwecall
theresult ofcallingfilterpxssimplyb,then wecanrewrite thisas:
filterp[]=[]
filterp(x:xs)=
ifpxthenx:belseb
Giventhis, wecantransformfilter intoafold:
filterp=foldr(\ab->ifpathena:belseb)[]
Let‚Äôsconsider aslightly more complicated function:++.ThedeÔ¨Ånition for++is:
(++)[]ys=ys
(++)(x:xs)ys=x:(xs++ys)
Now,thequestion iswhether wecanwrite thisinfoldnotation. First, wecanapply
etareduction totheÔ¨Årstlinetogive:
(++)[]=id
Through asequence ofsteps, wecanalsoeta-reduce thesecond line:
(++)(x:xs)ys=x:((++)xsys)
==>(++)(x:xs)ys=(x:)((++)xsys)
==>(++)(x:xs)ys=((x:).(++)xs)ys
==>(++)(x:xs)=(x:).(++)xs
Thus, wegetthataneta-reduced deÔ¨Åntion of++is:
(++)[]=id
(++)(x:xs)=(x:).(++)xs
Now,wecantrytoputthisintofold notation. First, wenotice thatthebase case
converts[]intoid.Now,ifweassume(++)xsiscalledbandxiscalleda,we
cangetthefollowing deÔ¨Ånition interms offoldr :
7.12.THEFINALWORDONLISTS 101
(++)=foldr(\ab->(a:).b)id
This actually makessense intuiti vely.Ifweonly think about applying++toone
argument, wecanthink ofitasafunction which takesalistandcreates afunction
which, when applied, willprepend thislisttoanother list.Inthelambda function, we
assume wehaveafunctionbwhich willdothisfortherestofthelistandweneed to
create afunction which willdothisforbaswell asthesingle elementa.Inorder to
dothis, weÔ¨Årstapplybandthen further addatothefront.
Wecanfurther reduce thisexpression toapoint-free style through thefollowing
sequence:
==>(++)=foldr(\ab->(a:).b)id
==>(++)=foldr(\ab->(.)(a:)b)id
==>(++)=foldr(\a->(.)(a:))id
==>(++)=foldr(\a->(.)((:)a))id
==>(++)=foldr(\a->((.).(:))a)id
==>(++)=foldr((.).(:))id
This Ô¨Ånal version ispoint free, though notnecessarily understandable. Presum-
bably theoriginal version isclearer .
AsaÔ¨Ånal example, considerconcat .Wecanwrite thisas:
concat[]=[]
concat(x:xs)=x++concatxs
Itshould beimmediately clear thatthezelement forthefold is[]andthatthe
recursi vefunction is++,yielding:
concat=foldr(++)[]
Exer cises
Exer cise7.2Thefunctionand takesalistofbooleans andreturnsTrue ifandonly
ifallofthem areTrue .Italso returnsTrue ontheempty list.Write thisfunction in
terms offoldr .
Exer cise7.3ThefunctionconcatMap behaves suchthatconcatMap fisthesame
asconcat.mapf.Write thisfunction interms offoldr .
102 CHAPTER 7.ADVANCEDFEATURES
Chapter8
AdvancedTypes
Asyou‚Äôveprobably ascertained bythispoint, thetype system isintegral toHask ell.
While thischapter iscalled ‚ÄúAdvanced Types‚Äù, youwill probably Ô¨Ånd ittobemore
general than thatanditmust notbeskipped simply because you‚Äôrenotinterested inthe
type system.
8.1 TypeSynonyms
Typesynon yms existinHask ellsimply forconvenience: their remo valwould notmake
Hask ellanylesspowerful.
Consider thecase when youareconstantly dealing with lists ofthree-dimensional
points. Forinstance, youmight haveafunction with type[(Double ;Double ;Double )]!Double ![(Double ;Double ;Double )].
Since youareagood softw areengineer ,youwanttoplace type signatures onallyour
top-le velfunctions. However,typing [(Double ;Double ;Double )]allthetime getsvery
tedious. Togetaround this, youcandeÔ¨Åne atype synon ym:
typeList3D=[(Double,Double,Double)]
Now,thetype signature foryour functions may bewritten List3D !Double !List3D .
Weshould note thattype synon yms cannot beself-referential. That is,youcannot
have:
typeBadType =Int->BadType
This isbecause thisisan‚ÄúinÔ¨Ånite type. ‚ÄùSince Hask ellremo vestype synon yms
veryearly on,anyinstance ofBadTypewill bereplaced byInt!BadType,which
willresult inaninÔ¨Ånite loop.
Typesynon yms canalsobeparameterized. Forinstance, youmight wanttobeable
tochange thetypes ofthepoints inthelistof3Dpoints. Forthis, youcould deÔ¨Åne:
typeList3Da=[(a,a,a)]
103
104 CHAPTER 8.ADVANCEDTYPES
Then your references to[(Double ;Double ;Double )]would become List3D Double .
8.2 Newtypes
Consider theproblem inwhich youneed tohaveatype which isverymuch likeInt,but
itsordering isdeÔ¨Åned differently .Perhaps youwish toorderIntsÔ¨Årstbyevennumbers
then byoddnumbers (that is,alloddnumbers aregreater than anyevennumber and
within theodd/e vensubsets, ordering isstandard).
Unfortunately ,you cannot deÔ¨Åne anewinstance ofOrd forIntbecause then
Hask ellwon‚Äôtknowwhich onetouse. What youwantistodeÔ¨Åne atype which is
isomorphic toInt.
NOTE ‚ÄúIsomorphic‚Äù isacommon term inmathematics which basi-
cally means ‚Äústructurally identical. ‚ÄùForinstance, ingraph theory ,ifyou
havetwographs which areidentical except theyhavedifferent labels on
thenodes, theyareisomorphic. Inourconte xt,twotypes areisomorphic
iftheyhavethesame underlying structure.
One waytodothiswould betodeÔ¨Åne anewdatatype:
dataMyInt=MyIntInt
Wecould then write appropriate code forthisdatatype. Theproblem (and thisis
verysubtle) isthatthistype isnottruly isomorphic toInt:ithasonemore value. When
wethink ofthetypeInt,weusually think thatittakesallvalues ofintegers, butitreally
hasonemore value: j(pronounced ‚Äúbottom‚Äù), which isused torepresent erroneous or
undeÔ¨Åned computations. Thus, MyInt hasnotonly valuesMyInt0,MyInt1and
soon,butalsoMyInt j.However,since datatypes canthemselv esbeundeÔ¨Åned, it
hasanadditional value: jwhich differsfromMyInt jandthismakesthetypes
non-isomorphic. (See Section ??formore information onbottom.)
Disre garding thatsubtlety ,there may beefÔ¨Åcienc yissues with thisrepresentation:
now,instead ofsimply storing aninteger,wehavetostore apointer toanintegerand
havetofollowthatpointer whene verweneed thevalue ofaMyInt .
Togetaround these problems, Hask ellhasanewtype construction. Anewtype isa
cross between adatatype andatype synon ym: ithasaconstructor likeadatatype, but
itcanhaveonly oneconstructor andthisconstructor canhaveonly oneargument. For
instance, wecandeÔ¨Åne:
newtype MyInt=MyIntInt
Butwecannot deÔ¨Åne anyof:
newtype Bad1=Bad1aInt|Bad1bDouble
newtype Bad2=Bad2IntDouble
8.3.DATATYPES 105
Ofcourse, thefactthatwecannot deÔ¨Åne Bad2 asaboveisnotabigissue: wecan
simply deÔ¨Åne thefollowing bypairing thetypes:
newtype Good2=Good2(Int,Double)
Now,suppose we‚ÄôvedeÔ¨Åned MyInt asanewtype .This enables usetowrite our
desired instance ofOrd as:
instance OrdMyIntwhere
MyInti<MyIntj
|oddi&&oddj=i<j
|eveni&&evenj=i<j
|eveni =True
|otherwise =False
whereoddx=(x‚Äòmod‚Äò2)==0
even=not.odd
Likedatatype, wecanstillderiveclasses likeShowandEqovernewtypes (infact,
I‚Äômimplicitly assuming wehavederivedEqoverMyInt ‚Äìwhere ismyassumption in
theabovecode?).
Moreo ver,inrecent versions ofGHC (see Section 2.2), onnewtypes, youareal-
lowed toderiveanyclass ofwhich thebase type (inthiscase,Int)isaninstance. For
example, wecould deriveNum onMyInt toprovide arithmetic functions overit.
Pattern matching overnewtypes isexactly asindatatypes. Wecanwrite constructor
anddestructor functions forMyInt asfollows:
mkMyInt i=MyInti
unMyInt (MyInti)=i
8.3 Datatypes
We‚Äôvealready seen datatypes used inavariety ofconte xts. This section concludes
some ofthediscussion andintroduces some ofthecommon datatypes inHask ell.It
alsoprovides amore theoretical underpinning towhat datatypes actually are.
8.3.1 Strict Fields
One ofthegreat things about Hask ellisthatcomputation isperformed lazily .However,
sometimes thisleads toinefÔ¨Åciencies. One wayaround thisproblem istousedatatypes
with strict Ô¨Åelds. Before wetalkabout thesolution, let‚Äôsspend some time togeta
bitmore comfortable with howbottom works intothepicture (formore theory ,see
Section ??).
Suppose we‚ÄôvedeÔ¨Åned theunitdatatype (this oneofthesimplest datatypes youcan
deÔ¨Åne):
106 CHAPTER 8.ADVANCEDTYPES
dataUnit=Unit
This datatype hasexactly oneconstructor ,Unit ,which takesnoarguments. Ina
strict language likeML, there would beexactly onevalue oftypeUnit:namely ,Unit .
This isnotquite soinHask ell.Infact,there aretwovalues oftypeUnit.One ofthem
isUnit .Theother isbottom (written j).
Youcanthink ofbottom asrepresenting acomputation which won‚Äôthalt. Forin-
stance, suppose wedeÔ¨Åne thevalue:
foo=foo
This isperfectly validHask ellcode andsimply says thatwhen youwanttoevaluate
foo,allyouneed todoisevaluatefoo.Clearly thisisan‚ÄúinÔ¨Ånite loop. ‚Äù
What isthetype offoo?Simply a.Wecannot sayanything more about itthan
that. The factthatfoo hastypeainfacttells usthatitmust beaninÔ¨Ånite loop (or
some other such strange value). However,sincefoo hastypeaandthus canhaveany
type, itcanalsohavetypeUnit.Wecould write, forinstance:
foo::Unit
foo=foo
Thus, wehavefound asecond value with typeUnit.Infact,wehavefound all
values oftypeUnit.Anyother non-terminating function orerror -producing function
willhaveexactly thesame effectasfoo (though Hask ellprovides some more utility
with thefunctionerror ).
This mean, forinstance, thatthere areactually four values with typeMaybeUnit.
Theyare:j,Nothing ,Just jandJustUnit .However,itcould bethefact
thatyou, asaprogrammer ,knowthatyouwill nevercome across thethird ofthese.
Namely ,youwanttheargument toJust tobestrict .This means thatiftheargument
toJust isbottom, then theentire structure becomes bottom. Youuseanexclamation
point tospecify aconstructor asstrict. WecandeÔ¨Åne astrict version ofMaybeas:
dataSMaybea=SNothing |SJust!a
There arenowonly three values ofSMaybe.Wecanseethedifference bywriting
thefollwing program:
moduleMainwhere
importSystem
dataSMaybea=SNothing |SJust!aderiving Show
8.3.DATATYPES 107
main=do
[cmd]<-getArgs
casecmdof
"a"->printJust undefined
"b"->printJust Nothing
"c"->printJust (Justundefined)
"d"->printJust (Just())
"e"->printSJust undefined
"f"->printSJust SNothing
"g"->printSJust (SJustundefined)
"h"->printSJust (SJust())
printJust ::Maybe()->IO()
printJust Nothing =putStrLn "Nothing"
printJust (Justx)=doputStr"Just";printx
printJust ::SMaybe()->IO()
printSJust SNothing =putStrLn "Nothing"
printSJust (SJustx)=doputStr"Just";printx
Here, depending onwhat command lineargument ispassed, wewilldosomething
different. Theoutputs forthevarious options are:
\%./strict a
Fail:Prelude.undefined
\%./strict b
Nothing
\%./strict c
Just
Fail:Prelude.undefined
\%./strict d
Just()
\%./strict e
Fail:Prelude.undefined
\%./strict f
Nothing
\%./strict g
Fail:Prelude.undefined
108 CHAPTER 8.ADVANCEDTYPES
\%./strict h
Just()
The thing worth noting here isthedifference between cases ‚Äúc‚Äùand‚Äúg‚Äù. Inthe
‚Äúc‚Äùcase, theJust isprinted, because thisisprinted befor etheundeÔ¨Åned value is
evaluated. However,inthe‚Äúg‚Äùcase, since theconstructor isstrict, assoon asyou
match theSJust ,youalsomatch thevalue. Inthiscase, thevalue isundeÔ¨Åned, sothe
whole thing failsbefore itgetsachance todoanything .
8.4 Classes
Wehavealready encountered type classes afewtimes, butonly intheconte xtofpre-
viously existing type classes. This section isabout howtodeÔ¨Åne your own. Wewill
beginthediscussion bytalking about Pong andthen moveontoauseful generalization
ofcomputations.
8.4.1 Pong
Thediscussion here willbemotivated bytheconstruction ofthegame Pong (see Ap-
pendix ??forthefullcode). InPong, there arethree things drawnonthescreen: the
twopaddles andtheball. While thepaddles andtheballaredifferent inafewrespects,
theyshare manycommonalities, such asposition, velocity ,acceleration, color ,shape,
andsoon.Wecanexpress these commonalities bydeÔ¨Åning aclass forPong entities,
which wecallEntity.Wemakesuch adeÔ¨Ånition asfollows:
classEntityawhere
getPosition ::a->(Int,Int)
getVelocity ::a->(Int,Int)
getAcceleration ::a->(Int,Int)
getColor ::a->Color
getShape ::a->Shape
This code deÔ¨Ånes atypeclass Entity.This class hasÔ¨Åvemethods:getPosition ,
getVelocity ,getAcceleration ,getColor andgetShape with thecorre-
sponding types.
The Ô¨Årst linehere uses thekeywordclass tointroduce anewtypeclass. Wecan
read thistypeclass deÔ¨Ånition as‚ÄúThere isatypeclass ‚ÄôEntity‚Äô; atype ‚Äôa‚Äôisaninstance
ofEntity ifitprovides thefollowing Ô¨Åvefunctions: ...‚Äù.Toseehowwecanwrite an
instance ofthisclass, letusdeÔ¨Åne aplayer (paddle) datatype:
dataPaddle=
Paddle{paddlePosX, paddlePosY,
paddleVelX, paddleVelY,
paddleAccX, paddleAccY ::Int,
paddleColor ::Color,
8.4.CLASSES 109
paddleHeight ::Int,
playerNumber ::Int}
Giventhisdata declaration, wecandeÔ¨Åne Paddle tobeaninstance ofEntity:
instance EntityPaddlewhere
getPosition p=(paddlePosX p,paddlePosY p)
getVelocity p=(paddleVelX p,paddleVelY p)
getAcceleration p=(paddleAccX p,paddleAccY p)
getColor =paddleColor
getShape =Rectangle 5.paddleHeight
Theactual Hask elltypes oftheclass functions allhaveincluded theconte xtEntity
a=>.Forexample,getPosition hastypeEntitya)a!(Int;Int).However,
itwillturn outthatmanyofourroutines willneed entities toalso beinstances ofEq.
Wecantherefore choose tomakeEntityasubclass ofEq:namely ,youcanonly be
aninstance ofEntityifyouarealready aninstance ofEq.Todothis, wechange the
Ô¨Årstlineoftheclass declaration to:
classEqa=>Entityawhere
Now,inorder todeÔ¨Åne Paddle stobeinstances ofEntitywewillÔ¨Årstneed them
tobeinstances ofEq‚Äìwecandothisbyderiving theclass.
8.4.2 Computations
Let‚Äôsthink back toouroriginal motivation fordeÔ¨Åning theMaybedatatype from Sec-
tion??.Wewanted tobeable toexpress thatfunctions (i.e., computations) canfail.
Letusconsider thecase ofperforming search onagraph. Allowustotakeasmall
aside tosetupasmall graph library:
dataGraphve=Graph[(Int,v)] [(Int,Int,e)]
TheGraph datatype takestwotype arguments which correspond tovertexandedge
labels. TheÔ¨Årstargument totheGraph constructor isalist(set) ofvertices; thesecond
isthelist(set) ofedges. Wewill assume these lists arealwayssorted andthateach
vertexhasaunique idandthatthere isatmost oneedge between anytwovertices.
Suppose wewanttosearch forapath between twovertices. Perhaps there isno
path between those vertices. Torepresent this, wewill usetheMaybedatatype. If
itsucceeds, itwill return thelistofvertices traversed. Our search function could be
written (naively)asfollows:
search::Graphve->Int->Int->Maybe[Int]
searchg@(Graph vlel)srcdst
|src==dst=Just[src]
110 CHAPTER 8.ADVANCEDTYPES
|otherwise =search‚Äô el
wheresearch‚Äô []=Nothing
search‚Äô ((u,v,_):es)
|src==u=
casesearchgvdstof
Justp->Just(u:p)
Nothing ->search‚Äô es
|otherwise =search‚Äô es
This algorithm works asfollows(trytoread along): tosearch inagraphgfrom
src todst,Ô¨Årstwecheck toseeifthese areequal. Iftheyare,wehavefound our
wayandjustreturn thetrivialsolution. Otherwise, wewanttotraverse theedge-list.
Ifwe‚Äôretraversing theedge-list anditisempty ,we‚Äôvefailed, sowereturnNothing .
Otherwise, we‚Äôrelooking atanedge fromutov.Ifuisoursource, then weconsider
thisstepandrecursi velysearch thegraph fromvtodst.Ifthisfails, wetrytherestof
theedges; ifthissucceeds, weputourcurrent position before thepath found andreturn.
Ifuisnotoursource, thisedge isuseless andwecontinue traversing theedge-list.
This algorithm isterrible: namely ,ifthegraph contains cycles, itcanloop indeÔ¨Å-
nitely .Nevertheless, itissufÔ¨Åcent fornow.Besure youunderstand itwell: things only
getmore complicated.
Now,there arecases where theMaybedatatype isnotsufÔ¨Åcient: perhaps wewish
toinclude anerror message together with thefailure. Wecould deÔ¨Åne adatatype to
express thisas:
dataFailable a=Success a|FailString
Now,failures come with afailure string toexpress what went wrong. Wecan
rewrite oursearch function tousethisdatatype:
search2 ::Graphve->Int->Int->Failable [Int]
search2 g@(Graph vlel)srcdst
|src==dst=Success [src]
|otherwise =search‚Äô el
wheresearch‚Äô []=Fail"Nopath"
search‚Äô ((u,v,_):es)
|src==u=
casesearch2 gvdstof
Success p->Success (u:p)
_ ->search‚Äô es
|otherwise =search‚Äô es
This code isastraightforw ardtranslation oftheabove.
There isanother option forthiscomputation: perhaps wewantnotjustonepath,
butallpossible paths. Wecanexpress thisasafunction which returns alistoflists of
vertices. Thebasic idea isthesame:
8.4.CLASSES 111
search3 ::Graphve->Int->Int->[[Int]]
search3 g@(Graph vlel)srcdst
|src==dst=[[src]]
|otherwise =search‚Äô el
wheresearch‚Äô []=[]
search‚Äô ((u,v,_):es)
|src==u=
map(u:)(search3 gvdst)++
search‚Äô es
|otherwise =search‚Äô es
Thecode here hasgotten alittle shorter ,thanks tothestandard preludemap func-
tion, though itisessentially thesame.
Wemay askourselv eswhat allofthese haveincommon andtrytogobble up
those commonalities inaclass. Inessense, weneed some wayofrepresenting success
andsome wayofrepresenting failure. Furthermore, weneed awaytocombine two
successes (intheÔ¨Årsttwocases, theÔ¨Årstsuccess ischosen; inthethird, theyarestrung
together). Finally ,weneed tobeable toaugment aprevious success (ifthere wasone)
with some newvalue. WecanÔ¨Åtthisallintoaclass asfollows:
classComputation cwhere
success ::a->ca
failure ::String->ca
augment ::ca->(a->cb)->cb
combine ::ca->ca->ca
Inthisclass declaration, we‚Äôresaying thatcisaninstance oftheclassComputation
ifitprovides four functions:success ,failure ,augment andcombine .The
success function takesavalue oftypeaandreturns itwrapped upinc,representing
asuccessful computation. Thefailure function takesaString andreturns acompu-
tation representing afailure. Thecombine function takestwoprevious computation
andproduces anewonewhich isthecombination ofboth. Theaugment function is
abitmore comple x.
Theaugment function takessome previously givencomputation (namely ,ca)
andafunction which takesthevalue ofthatcomputation (thea)andreturns aband
produces abinside ofthat computation. Note that inourcurrent situation, giving
augment thetypeca!(a!a)!cawould havebeen sufÔ¨Åcient, sinceaisalways
[Int],butwemakeitthismore general time justforgenerality .
Howaugment works isprobably bestshownbyexample. WecandeÔ¨Åne Maybe,
Failable and[]tobeinstances ofComputation as:
instance Computation Maybewhere
success =Just
failure =constNothing
112 CHAPTER 8.ADVANCEDTYPES
augment (Justx)f=fx
augment Nothing _=Nothing
combine Nothing y=y
combine x_=x
Here, success isrepresented withJust andfailure ignores itsargument and
returnsNothing .Thecombine function takestheÔ¨Årstsuccess wefound andignores
therest. Thefunctionaugment checks toseeifwesucceeded before (and thus had
aJust something) and, ifwedid,appliesftoit.Ifwefailed before (and thus hada
Nothing ),weignore thefunction andreturnNothing .
instance Computation Failable where
success =Success
failure =Fail
augment (Success x)f=fx
augment (Fails)_=Fails
combine (Fail_)y=y
combine x_=x
These deÔ¨Ånitions areobvious. Finally:
instance Computation []where
success a=[a]
failure =const[]
augment lf=concat(mapfl)
combine =(++)
Here, thevalue ofasuccessful computation isasingleton listcontaining thatvalue.
Failure isrepresented with theempty listandtocombine previous successes wesimply
catentate them. Finally ,augmenting acomputation amounts tomapping thefunction
across thelistofprevious computations andconcatentate them. weapply thefunction
toeach element inthelistandthen concatenate theresults.
Using these computations, wecanexpress alloftheaboveversions ofsearch as:
searchAll g@(Graph vlel)srcdst
|src==dst=success [src]
|otherwise =search‚Äô el
wheresearch‚Äô []=failure "nopath"
search‚Äô ((u,v,_):es)
|src==u=(searchAll gvdst‚Äòaugment‚Äò
(success .(u:)))
‚Äòcombine‚Äò search‚Äô es
|otherwise =search‚Äô es
8.5.INSTANCES 113
Inthis, weseetheuses ofallthefunctions from theclassComputation .
Ifyou‚Äôveunderstood thisdiscussion ofcomputations, youareinaverygood posi-
tionasyouhaveunderstood theconcept ofmonads ,probably themost difÔ¨Åcult concept
inHask ell.Infact,theComputation class isalmost exactly theMonad class, ex-
cept thatsuccess iscalledreturn ,failure iscalledfail andaugment is
called>>= (read ‚Äúbind‚Äù). Thecombine function isn‚Äôtactually required bymonads,
butisfound intheMonadPlus class forreasons which willbecome obvious later.
Ifyoudidn‚Äô tunderstand everything here, read through itagainandthen waitfor
theproper discussion ofmonads inChapter 9.
8.5 Instances
Wehavealready seen howtodeclare instances ofsome simple classes; allowusto
consider some more advanced classes here. There isaFunctor class deÔ¨Åned inthe
Functor module.
NOTE Thename ‚Äúfunctor‚Äù, like‚Äúmonad‚Äù comes from category the-
ory.There, afunctor islikeafunction, butinstead ofmapping elements
toelements, itmaps structures tostructures.
ThedeÔ¨Ånition ofthefunctor class is:
classFunctor fwhere
fmap::(a->b)->fa->fb
Thetype deÔ¨Ånition forfmap (nottomention itsname) isverysimilar tothefunc-
tionmap overlists. Infact,fmap isessentially ageneralization ofmap toarbitrary
structures (and, ofcourse, lists arealready instances ofFunctor ).However,wecan
alsodeÔ¨Åne other structures tobeinstances offunctors. Consider thefollowing datatype
forbinary trees:
dataBinTree a=Leafa
|Branch(BinTree a)(BinTree a)
Wecanimmediately identify thattheBinTreetype essentially ‚Äúraises‚Äù atypeainto
trees ofthattype. There isanaturally associated functor which goes along with this
raising. Wecanwrite theinstance:
instance Functor BinTree where
fmapf(Leafa)=Leaf(fa)
fmapf(Branch leftright)=
Branch(fmapfleft)(fmapfright)
114 CHAPTER 8.ADVANCEDTYPES
Now,we‚Äôveseen howtomakesomething likeBinTreeaninstance ofEqbyusing
thederiving keyword, buthere wewilldoitbyhand. WewanttomakeBinTreeas
instances ofEqbutobviously wecannot dothisunless aisitself aninstance ofEq.
Wecanspecify thisdependence intheinstance declaration:
instance Eqa=>Eq(BinTree a)where
Leafa==Leafb=a==b
Branchlr==Branchl‚Äôr‚Äô=l==l‚Äô&&r==r‚Äô
_==_=False
TheÔ¨Årstlineofthiscanberead ‚Äúifaisaninstance ofEq,thenBinTreeaisalso
aninstance ofEq‚Äù.Wethen provide thedeÔ¨Ånitions. Ifwedidnotinclude the‚ÄúEqa
=>‚Äùpart, thecompiler would complain because we‚Äôretrying tousethe==function on
asinthesecond line.
The‚ÄúEqa=>‚ÄùpartofthedeÔ¨Ånition iscalled the‚Äúconte xt.‚ÄùWeshould note that
there aresome restrictions onwhat canappear intheconte xtandwhat canappear in
thedeclaration. Forinstance, we‚Äôrenotallowed tohaveinstance declarations thatdon‚Äôt
contain type constructors ontheright hand side. Toseewhy,consider thefollowing
declarations:
classMyEqawhere
myeq::a->a->Bool
instance Eqa=>MyEqawhere
myeq=(==)
Asitstands, there doesn‚Äô tseem tobeanything wrong with thisdeÔ¨Ånition. However,
ifelsewhere inaprogram wehadthedeÔ¨Ånition:
instance MyEqa=>Eqawhere
(==)=myeq
Inthiscase, ifwe‚Äôretrying toestablish ifsome type isaninstance ofEq,wecould
reduce ittotrying toÔ¨Ånd outifthattype isaninstance ofMyEq ,which wecould
inturn reduce totrying toÔ¨Ånd outifthattype isaninstance ofEq,andsoon.The
compiler protects itself against thisbyrefusing theÔ¨Årstinstance declaration.
This iscommonly knownastheclosed-world assumption .That is,we‚Äôreassuming,
when wewrite adeÔ¨Ånition liketheÔ¨Årstone, thatthere won‚Äôtbeanydeclarations like
thesecond. However,thisassumption isinvalidbecause there‚Äô snothing topreventthe
second declaration (orsome equally evildeclaration). The closed world assumption
canalsobiteyouincases like:
classOnlyInts awhere
foo::a->a->Bool
8.6.KINDS 115
instance OnlyInts Intwhere
foo==(==)
bar::OnlyInts a=>a->Bool
bar=foo5
We‚Äôveagainmade theclosed-w orld assumption: we‚Äôveassumed thattheonly in-
stance ofOnlyIn tsisInt,butthere‚Äô snoreason another instance couldn‚Äô tbedeÔ¨Åned
elsewhere, ruining ourdeÔ¨Åntion ofbar.
8.6 Kinds
Letustakeamoment andthink about what types areavailable inHask ell.Wehave
simple types, likeInt,Char,Double andsoon.Wethen havetype constructors like
Maybewhich takeatype (likeChar)andproduce anewtype,MaybeChar.Similarly ,
thetype constructor [](lists) takesatype (likeInt)andproduces [Int].Wehavemore
comple xthings like!(function arrow)which takestwotypes (sayIntandBool)and
produces anewtypeInt!Bool.
Inasense, these types themselv eshavetype. Types likeInthavesome sortofbasic
type. Types likeMaybehaveatype which takessomething ofbasic type andreturns
something ofbasic type. And soforth.
Talking about thetypes oftypes becomes unwieldy andhighly ambiguous, sowe
callthetypes oftypes ‚Äúkinds. ‚ÄùWhat wehavebeen calling ‚Äúbasic types‚Äù havekind
‚Äú*‚Äù.Something ofkind*issomething which canhaveanactual value. There isalsoa
single kind constructor ,!with which wecanbuildmore comple xkinds.
Consider Maybe.This takessomething ofkind*andproduces something ofkind
*.Thus, thekind ofMaybeis*->*.Recall thedeÔ¨Ånition ofPair from Sec-
tion4.5.1:
dataPairab=Pairab
Here, Pairisatype constructor which takestwoarguments, each ofkind*and
produces atype ofkind*.Thus, thekind ofPairis*->(*->*).However,we
againassume associati vitysowejustwrite*->*->*.
Letusmakeaslightly strange datatype deÔ¨Ånition:
dataStrange cab=
MkStrange (ca)(cb)
Before weanalyze thekind ofStrange ,let‚Äôsthink about what itdoes. Itisessen-
tially apairing constructor ,though itdoesn‚Äô tpairactual elements, butelements within
another constructor .Forinstance, think ofcasMaybe.ThenMkStrange pairsMaybes
ofthetwotypesaandb.However,cneed notbeMaybebutcould instead by[],or
manyother things.
116 CHAPTER 8.ADVANCEDTYPES
What doweknowaboutc,though? Weknowthatitmust havekind*->*.This
isbecause wehavecaontheright hand side. Thetype variables aandbeach have
kind*asbefore. Thus, thekind ofStrange is(*->*)->*->*->*.That
is,ittakesaconstructor (c)ofkind*->*together with twotypes ofkind*and
produces something ofkind*.
Aquestion may arise regarding howweknowahaskind*andnotsome other
kindk.Infact,theinferred kind forStrange is(k->*)->k->k->*.
However,thisrequires polymorphism onthekind level,which istoocomple x,sowe
makeadefaultassumption thatk=*.
NOTE There areextensions toGHC which allowyoutospecify the
kind ofconstructors directly .Forinstance, ifyouwanted adifferent kind,
youcould write thisexplicitly:
dataStrange (c::(*->*)->*)ab=MkStrange (ca)(cb)
togiveadifferent kind toStrange .
Thenotation ofkinds suggests thatwecanperform partial application, aswecan
forfunctions. And, infact,wecan. Forinstance, wecould have:
typeMaybePair =Strange Maybe
Thekind ofMaybePairis,notsurprisingly ,*->*->*.
Weshould note here thatallofthefollowing deÔ¨Ånitions areacceptable:
typeMaybePair1 =Strange Maybe
typeMaybePair2 a=Strange Maybea
typeMaybePair3 ab=Strange Maybeab
These allappear tobethesame, buttheyareinfactnotidentical asfarasHask ell‚Äôs
type system isconcerned. Thefollowing areallvalidtype deÔ¨Ånitions using theabove:
typeMaybePair1a =MaybePair1
typeMaybePair1b =MaybePair1 Int
typeMaybePair1c =MaybePair1 IntDouble
typeMaybePair2b =MaybePair2 Int
typeMaybePair2c =MaybePair2 IntDouble
typeMaybePair3c =MaybePair3 IntDouble
Butthefollowing arenotvalid:
8.7.CLASSHIERARCHIES 117
typeMaybePair2a =MaybePair2
typeMaybePair3a =MaybePair3
typeMaybePair3b =MaybePair3 Int
This isbecause while itispossible topartially apply type constructors ondatatypes,
itisnotpossible ontype synon yms. Forinstance, thereason MaybePair2a isinvalid
isbecause MaybePair2isdeÔ¨Åned asatype synon ymwith oneargument andwehave
givenitnone. Thesame applies fortheinvalidMaybePair3deÔ¨Ånitions.
8.7 Class Hierar chies
8.8 Default
what isit?
118 CHAPTER 8.ADVANCEDTYPES
Chapter9
Monads
Themost difÔ¨Åcult concept tomaster ,while learning Hask ell,isthatofunderstanding
andusing monads. Wecandistinguish twosubcomponents here: (1)learning how
touseexisting monads and(2)learning howtowrite newones. Ifyouwanttouse
Hask ell,youmust learn touseexisting monads. Ontheother hand, youwillonly need
tolearn towrite your ownmonads ifyouwanttobecome a‚Äúsuper Hask ellguru. ‚ÄùStill,
ifyoucangrasp writing your ownmonads, programming inHask ellwillbemuch more
pleasant.
Sofarwe‚Äôveseen twouses ofmonads. TheÔ¨ÅrstusewasIOactions: We‚Äôveseen
that, byusing monads, wecanabstract getawayfrom theproblems plaguing theReal-
Worldsolution toIOpresented inChapter 5.Thesecond usewasrepresenting different
types ofcomputations inSection 8.4.2. Inboth cases, weneeded awaytosequence
operations andsawthatasufÔ¨Åcient deÔ¨Ånition (atleast forcomputations) was: computations
classComputation cwhere
success ::a->ca
failure ::String->ca
augment ::ca->(a->cb)->cb
combine ::ca->ca->ca
Let‚ÄôsseeifthisdeÔ¨Ånition willenable ustoalso perform IO.Essentially ,weneed
awaytorepresent taking avalue outofanaction andperforming some newoperation
onit(asintheexample from Section 4.4.3, rephrased slightly):
main=do
s<-readFile "somefile"
putStrLn (show(fs))
Butthisisexactly whataugment does. Usingaugment ,wecanwrite theabove
code as:
119
120 CHAPTER 9.MONADS
main=--notethelackofa"do"
readFile "somefile" ‚Äòaugment‚Äò \s->
putStrLn (show(fs))
This certainly seems tobesufÔ¨Åcient. And, infact,itturns outtobemore than
sufÔ¨Åcient.
ThedeÔ¨Ånition ofamonad isaslightly trimmed-do wnversion ofourComputation
class. TheMonad class hasfour methods (butthefourth method canbedeÔ¨Åned in
terms ofthethird):
classMonadmwhere
return ::a->ma
fail ::String->ma
(>>=) ::ma->(a->mb)->mb
(>>) ::ma->mb->mb
InthisdeÔ¨Ånition,return isequivalent tooursuccess ;fail isequivalent to
ourfailure ;and>>= (read: ‚Äúbind‚Äù )isequivalent toouraugment .The>>(read: bind
‚Äúthen‚Äù )method issimply aversion of>>= thatignores thea.This willturnouttobe then
useful; although, asmentioned before, itcanbedeÔ¨Åned interms of>>=:
a>>x=a>>=\_->x
9.1 DoNotation
Wehavehinted thatthere isaconnection between monads andthedonotation. Here,
wemakethat relationship concrete. There isactually nothing magic about thedo
notation ‚Äìitissimply ‚Äúsyntactic sugar‚Äùformonadic operations. syntactic sugar
Aswementioned earlier ,using ourComputation class, wecould deÔ¨Åne our
aboveprogram as:
main=
readFile "somefile" ‚Äòaugment‚Äò \s->
putStrLn (show(fs))
Butwenowknowthataugment iscalled>>= inthemonadic world. Thus, this
program really reads:
main=
readFile "somefile" >>=\s->
putStrLn (show(fs))
9.1.DONOTATION 121
And thisiscompletely validHask ellatthispoint: ifyoudeÔ¨Åned afunctionf::
Showa=>String->a,youcould compile andrunthisprogram)
This suggests thatwecantranslate:
x<-f
gx
intof>>=nx->gx.This isexactly what thecompiler does. Talking about
dobecomes easier ifwedonotuseimplicit layout (seeSection ??forhowtodothis).
There arefour translation rules:
1.dofeg!e
2.dofe;esg!e>>dofesg
3.dofletdecls;esg!letdeclsindofesg
4.dofp<-e;esg!letokp=dofesg;ok=fail"..."
ine>>=ok
Again,wewillelaborate onthese oneatatime:
Translation Rule 1
The Ô¨Årst translation rule,dofeg!e,states (aswehavestated before) thatwhen
performing asingle action, having adoornotisirrele vant.This isessentially thebase
case foraninducti vedeÔ¨Ånition ofdo.Thebase case hasoneaction (namelyehere);
theother three translation rules handle thecases where there ismore than oneaction.
Translation Rule 2
This states thatdofe;esg!e>>dofesg.This tells uswhat todoifwehave
anaction (e)followed byalistofactions (es).Here, wemakeuseofthe>>function,
deÔ¨Åned earlier .This rulesimple states thattodofe;esg,weÔ¨Årstperform theaction
e,throwawaytheresult, andthen does.
Forinstance, ifeisputStrLn sforsome strings,then thetranslation ofdo
fe;esgistoperforme(i.e., print thestring) andthen does.This isclearly what
wewant.
Translation Rule 3
This states thatdofletdecls;esg!letdeclsindofesg.This rule
tells ushowtodeal with letsinside ofadostatement. Weliftthedeclarations within let
theletoutanddowhate vercomes after thedeclarations.
122 CHAPTER 9.MONADS
Translation Rule 4
This states thatdofp<-e;esg!letokp=dofesg;ok=fail
"..."ine>>=ok.Again,itisnotexactly obvious what isgoing onhere. How-
ever,analternate formulation ofthisrule, which isroughly equivalent, is:dofp<-
e;esg!e>>=np->es.Here, itisclear what ishappening. Werunthe
actione,andthen send theresults intoes,butÔ¨Årstgivetheresult thenamep.
Thereason forthecomple xdeÔ¨Ånition isthatpdoesn‚Äô tneed tosimply beavariable;
itcould besome comple xpattern. Forinstance, thefollowing isvalidcode:
foo=do(‚Äôa‚Äô:‚Äôb‚Äô:‚Äôc‚Äô:x:xs) <-getLine
putStrLn (x:xs)
Inthis, we‚Äôreassuming thattheresults oftheactiongetLine will beginwith
thestring ‚Äúabc‚Äù andwill haveatleast onemore character .The question becomes
what should happen ifthispattern match fails. The compiler could simply throwan
error ,likeusual, forfailed pattern matches. However,since we‚Äôrewithin amonad, we
haveaccess toaspecialfail function, andwe‚Äôdprefer tofailusing thatfunction,
rather than the‚Äúcatch all‚Äùerror function. Thus, thetranslation, asdeÔ¨Åned, allows
thecompiler toÔ¨Ållinthe... with anappropriate error message about thepattern
matching having failed. Apart from this, thetwodeÔ¨Ånitions areequivalent.
9.2 DeÔ¨Ånition
There arethree rules thatallmonads must obeycalled the‚ÄúMonad Laws‚Äù(and itisup monad laws
toyoutoensure thatyour monads obeythese rules) :
1.returna>>=ffa
2.f>>=return f
3.f>>=(nx->gx>>=h)(f>>=g)>>=h
Let‚Äôslook ateach ofthese individually:
Law 1
This states thatreturna>>=ffa.Suppose wethink about monads ascom-
putations. This means thatifwecreate atrivialcomputation thatsimply returns the
valuearegardless ofanything else(this isthereturnapart); andthen bind itto-
gether with some other computation f,then thisisequivalent tosimply performing the
computation fonadirectly .
Forexample, supposefisthefunctionputStrLn andaisthestring ‚ÄúHello
World.‚ÄùThis rule states thatbinding acomputation whose result is‚ÄúHello World‚Äù
toputStrLn isthesame assimply printing ittothescreen. This seems tomake
sense.
Indonotation, thislawstates thatthefollowing twoprograms areequivalent:
9.2.DEFINITION 123
law1a=do
x<-returna
fx
law1b=do
fa
Law 2
Thesecond monad lawstates thatf>>=return f.That is,fissome computa-
tion, thelawstates thatifweperform thecomputation fandthen pass theresult onto
thetrivialreturn function, then allwehavedone istoperform thecomputation.
That thislawmust hold should beobvious. Toseethis, think offasgetLine
(reads astring from thekeyboard). This lawstates thatreading astring andthen re-
turning thevalue read isexactly thesame asjustreading thestring.
Indonotation, thelawstates thatthefollowing twoprograms areequivalent:
law2a=do
x<-f
returnx
law2b=do
f
Law 3
This states thatf>>=(nx->gx>>=h)(f>>=g)>>=h.AtÔ¨Årst
glance, thislawisnotaseasy tograsp astheother two.Itisessentially anassociati vity associativ e
lawformonads.
NOTE Outside theworld ofmonads, afunction isassociati veif
(fg)h=f(gh).Forinstance,+and*areassociati ve,since
brack eting onthese functions doesn‚Äô tmakeadifference. Ontheother
hand,-and/arenotassociati vesince, forexample, 5 (3 1)6=
(5 3) 1.
Ifwethrowawaythemessiness with thelambdas, weseethatthislawstates:f
>>=(g>>=h)(f>>=g)>>=h.The intuition behind thislawisthat
when westring together actions, itdoesn‚Äô tmatter howwegroup them.
Foraconcrete example, takeftobegetLine .Takegtobeanaction which takes
avalue asinput, prints ittothescreen, reads another string viagetLine ,andthen
returns thatnewlyread string. TakehtobeputStrLn .
Let‚Äôsconsider what(nx->gx>>=h)does. Ittakesavalue calledx,and
runsgonit,feeding theresults intoh.Inthisinstance, thismeans thatit‚Äôsgoing to
124 CHAPTER 9.MONADS
takeavalue, print it,read another value andthen print that. Thus, theentire lefthand
sideofthelawÔ¨Årstreads astring andthen does what we‚Äôvejustdescribed.
Ontheother hand, consider(f>>=g).This action reads astring from the
keyboard, prints it,andthen reads another string, returning thatnewlyread string asa
result. When webind thiswithhasontheright hand sideofthelaw,wegetanaction
thatdoes theaction described by(f>>=g),andthen prints theresults.
Clearly ,these twoactions arethesame.
While thisexplanation isquite complicated, andthetextofthelawisalso quite
complicated, theactual meaning issimple: ifwehavethree actions, andwecompose
them inthesame order ,itdoesn‚Äô tmatter where weputtheparentheses. Therestisjust
notation.
Indonotation, says thatthefollowing twoprograms areequivalent:
law3a=do
x<-f
dog<-x
hy
law3b=do
y<-dox<-f
gx
hy
9.3 ASimple State Monad
One ofthesimplest monads thatwecancraft isastate-passing monad. InHask ell,all
state information usually must bepassed tofunctions explicitly asarguments. Using
monads, wecaneffectivelyhide some state information.
Suppose wehaveafunctionfoftypea!b,andweneed toaddstate tothis
function. Ingeneral, ifstate isoftypestate ,wecanencode itbychanging thetype of
ftoa!state!(state;b).That is,thenewversion offtakestheoriginal parameter
oftypeaandanewstate parameter .And, inaddition toreturning thevalue oftypeb,
italsoreturns anupdated state, encoded inatuple.
Forinstance, suppose wehaveabinary treedeÔ¨Åned as:
dataTreea
=Leafa
|Branch(Treea)(Treea)
Now,wecanwrite asimple map function toapply some function toeach value in
theleaves:
mapTree ::(a->b)->Treea->Treeb
mapTree f(Leafa)=Leaf(fa)
9.3.ASIMPLE STATEMONAD 125
mapTree f(Branch lhsrhs)=
Branch(mapTree flhs)(mapTree frhs)
This works Ô¨Åneuntil weneed towrite afunction thatnumbers theleavesleftto
right. Inasense, weneed toaddstate, which keeps track ofhowmanyleaveswe‚Äôve
numbered sofar,tothemapTree function. Wecanaugment thefunction tosomething
like:
mapTreeState ::(a->state->(state, b))->
Treea->state->(state, Treeb)
mapTreeState f(Leafa)state=
let(state‚Äô, b)=fastate
in(state‚Äô, Leafb)
mapTreeState f(Branch lhsrhs)state=
let(state‚Äô ,lhs‚Äô)=mapTreeState flhsstate
(state‚Äô‚Äô, rhs‚Äô)=mapTreeState frhsstate‚Äô
in(state‚Äô‚Äô, Branchlhs‚Äôrhs‚Äô)
This isbeginning togetabitunweildy ,andthetype signature isgetting harder and
harder tounderstand. What wewanttodoisabstract awaythestate passing part. That
is,thedifferences betweenmapTree andmapTreeState are:(1)theaugmented f
type, (2)wereplaced thetype->Treebwith->state->(state, Tree
b).Notice thatboth types changed inexactly thesame way.Wecanabstract thisaway
with atype synon ymdeclaration:
typeStatesta=st->(st,a)
Togoalong with thistype, wewrite twofunctions:
returnState ::a->Statesta
returnState a=\st->(st,a)
bindState ::Statesta->(a->Statestb)->
Statestb
bindState mk=\st->
let(st‚Äô,a)=mst
m‚Äô =ka
inm‚Äôst‚Äô
Let‚Äôsexamine each ofthese inturn. The Ô¨Årst function,returnState ,takesa
value oftypeaandcreates something oftypeStatesta.Ifwethink ofthest
asthestate, andthevalue oftypeaasthevalue, then thisisafunction thatdoesn‚Äô t
change thestate andreturns thevaluea.
ThebindState function looks distinctly liketheinterior letdeclarations inmapTreeState .
Ittakestwoarguments. TheÔ¨Årstargument isanaction thatreturns something oftype
126 CHAPTER 9.MONADS
awith statest.Thesecond isafunction thattakesthisaandproduces something of
typebalso with thesame state. Theresult ofbindState isessentially theresult of
transforming theaintoab.
ThedeÔ¨Ånition ofbindState takesaninitial state,st.ItÔ¨Årstapplies thistothe
Statestaargument calledm.This givesback anewstatest‚Äô andavaluea.It
then letsthefunctionkactona,producing something oftypeStatestb,called
m‚Äô.WeÔ¨Ånally runm‚Äôwith thenewstatest‚Äô.
Wewrite anewfunction,mapTreeStateM andgiveitthetype:
mapTreeStateM ::(a->Statestb)->Treea->Statest(Treeb)
Using these ‚Äúplumbing‚Äù functions (returnState andbindState )wecan
write thisfunction without everhaving toexplicitly talkabout thestate:
mapTreeStateM f(Leafa)=
fa‚ÄòbindState‚Äò \b->
returnState (Leafb)
mapTreeStateM f(Branch lhsrhs)=
mapTreeStateM flhs‚ÄòbindState‚Äò \lhs‚Äô->
mapTreeStateM frhs‚ÄòbindState‚Äò \rhs‚Äô->
returnState (Branch lhs‚Äôrhs‚Äô)
IntheLeaf case, weapplyftoaandthen bind theresult toafunction thattakes
theresult andreturns aLeaf with thenewvalue.
IntheBranch case, werecurse ontheleft-hand-side, binding theresult toafunc-
tionthatrecurses ontheright-hand-side, binding thattoasimple function thatreturns
thenewlycreatedBranch .
Asyouhaveprobably guessed bythispoint,Statestisamonad,returnState
isanalogous totheoverloadedreturn method, andbindState isanalogous tothe
overloaded>>= method. Infact,wecanverify thatStatestaobeysthemonad
laws:
Law 1states:returna>>=ffa.Let‚Äôscalculate onthelefthand side,
substituting ournames:
returnState a‚ÄòbindState‚Äò f
==>
\st->let(st‚Äô,a)=(returnState a)st
m‚Äô =fa
inm‚Äôst‚Äô
==>
\st->let(st‚Äô,a)=(\st->(st,a))st
in(fa)st‚Äô
==>
\st->let(st‚Äô,a)=(st,a)
in(fa)st‚Äô
9.3.ASIMPLE STATEMONAD 127
==>
\st->(fa)st
==>
fa
IntheÔ¨Årststep, wesimply substitute thedeÔ¨Ånition ofbindState .Inthesecond
step, wesimplify thelasttwolines andsubstitute thedeÔ¨Ånition ofreturnState .In
thethird step, weapplysttothelambda function. Inthefourth step, werenamest‚Äô
tostandremo vethelet.Inthelaststep, weetareduce.
Moving ontoLaw 2,weneed toshowthatf>>=return f.This isshown
asfollows:
f‚ÄòbindState‚Äò returnState
==>
\st->let(st‚Äô,a)=fst
in(returnState a)st‚Äô
==>
\st->let(st‚Äô,a)=fst
in(\st->(st,a))st‚Äô
==>
\st->let(st‚Äô,a)=fst
in(st‚Äô,a)
==>
\st->fst
==>
f
Finally ,weneed toshowthatState obeysthethird law:f>>=(nx->gx
>>=h)(f>>=g)>>=h.This ismuch more involvedtoshow,sowewill
only sketch theproof here. Notice thatwecanwrite theleft-hand-side as:
\st->let(st‚Äô,a)=fst
in(\x->gx‚ÄòbindState‚Äò h)ast‚Äô
==>
\st->let(st‚Äô,a)=fst
in(ga‚ÄòbindState‚Äò h)st‚Äô
==>
\st->let(st‚Äô,a)=fst
in(\st‚Äô->let(st‚Äô‚Äô,b)=ga
inhbst‚Äô‚Äô)st‚Äô
==>
\st->let(st‚Äô,a)=fst
(st‚Äô‚Äô,b)=gast‚Äô
(st‚Äô‚Äô‚Äô,c) =hbst‚Äô‚Äô
in(st‚Äô‚Äô‚Äô,c)
128 CHAPTER 9.MONADS
Theinteresting thing tonote here isthatwehaveboth action applications onthe
same letlevel.Since letisassociati ve,thismeans thatwecanputwhiche verbrack eting
weprefer andtheresults willnotchange. Ofcourse, thisisaninformal, ‚Äúhand waving‚Äù
argument anditwould takeusafewmore derivations toactually prove,butthisgives
thegeneral idea.
NowthatweknowthatStatestisactually amonad, we‚Äôdliketomakeitan
instance oftheMonad class. Unfortunately ,thestraightforw ardwayofdoing this
doesn‚Äô twork. Wecan‚Äôtwrite:
instance Monad(Statest)where{...}
This isbecause youcannot makeinstances outofnon-fully-applied type synon yms.
Instead, what weneed todoinstead isconvertthetype synon ymintoanewtype ,as:
newtype Statesta=State(st->(st,a))
Unfortunately ,thismeans thatweneed todosome packing andunpacking ofthe
State constructor intheMonad instance declaration, butit‚Äôsnotterribly difÔ¨Åcult:
instance Monad(Statestate)where
returna=State(\state ->(state, a))
Staterun>>=action=Staterun‚Äô
whererun‚Äôst=
let(st‚Äô,a)=runst
Staterun‚Äô‚Äô=actiona
inrun‚Äô‚Äôst‚Äô
Now,wecanwrite ourmapTreeM function as: mapT reeM
mapTreeM ::(a->Statestateb)->Treea->
Statestate(Treeb)
mapTreeM f(Leafa)=do
b<-fa
return(Leafb)
mapTreeM f(Branch lhsrhs)=do
lhs‚Äô<-mapTreeM flhs
rhs‚Äô<-mapTreeM frhs
return(Branch lhs‚Äôrhs‚Äô)
which issigniÔ¨Åcantly cleaner than before. Infact,ifweremo vethetype signature, we
getthemore general type:
mapTreeM ::Monadm=>(a->mb)->Treea->
m(Treeb)
9.3.ASIMPLE STATEMONAD 129
That is,mapTreeM canberuninanymonad, notjustourState monad.
Now,thenice thing about encapsulating thestateful aspect ofthecomputation like
thisisthatwecanprovide functions togetandchange thecurrent state. These look
like: getState
putStategetState ::Statestatestate
getState =State(\state ->(state, state))
putState ::state->Statestate()
putState new=State(\_->(new,()))
Here,getState isamonadic operation that takesthecurrent state, passes it
through unchanged, andthen returns itasthevalue. TheputState function takesa
newstate andproduces anaction thatignores thecurrent state andinserts thenewone.
Now,wecanwrite ournumberTree function as:
numberTree ::Treea->StateInt(Tree(a,Int))
numberTree tree=mapTreeM numbertree
wherenumberv=do
cur<-getState
putState (cur+1)
return(v,cur)
Finally ,weneed tobeable toruntheaction byproviding aninitial state:
runStateM ::Statestatea->state->a
runStateM (Statef)st=snd(fst)
Now,wecanprovide anexample Tree:
testTree =
Branch
(Branch
(Leaf‚Äôa‚Äô)
(Branch
(Leaf‚Äôb‚Äô)
(Leaf‚Äôc‚Äô)))
(Branch
(Leaf‚Äôd‚Äô)
(Leaf‚Äôe‚Äô))
andnumber it:
State>runStateM (numberTree testTree) 1
Branch(Branch (Leaf(‚Äôa‚Äô,1)) (Branch (Leaf(‚Äôb‚Äô,2))
(Leaf(‚Äôc‚Äô,3)))) (Branch (Leaf(‚Äôd‚Äô,4))
(Leaf(‚Äôe‚Äô,5)))
130 CHAPTER 9.MONADS
This may seem likealargeamount ofworktodosomething simple. However,
note thenewpowerofmapTreeM .Wecanalso print outtheleavesofthetreeina
left-to-right fashion as:
State>mapTreeM printtestTree
‚Äôa‚Äô
‚Äôb‚Äô
‚Äôc‚Äô
‚Äôd‚Äô
‚Äôe‚Äô
This crucially relies onthefactthatmapTreeM hasthemore general type involving
arbitrary monads ‚Äìnotjustthestate monad. Furthermore, wecanwrite anaction that
willmakeeach leafvalue equal toitsoldvalue aswell asallthevalues preceeding:
fluffLeaves tree=mapTreeM flufftree
wherefluffv=do
cur<-getState
putState (v:cur)
return(v:cur)
andcanseeitinaction:
State>runStateM (fluffLeaves testTree) []
Branch(Branch (Leaf"a")(Branch (Leaf"ba")
(Leaf"cba"))) (Branch (Leaf"dcba")
(Leaf"edcba"))
Infact,youdon‚Äôtevenneed towrite your ownmonad instance anddatatype. All
thisisbuiltintotheControl.Monad.State module. There, ourrunStateM
iscalledevalState ;ourgetState iscalledget;andourputState iscalled
put.
This module also contains astate transformer monad ,which wewill discuss in
Section 9.7.
9.4 Common Monads
Itturns outthatmanyofourfavorite datatypes areactually monads themselv es.Con-
sider ,forinstance, lists. Theyhaveamonad deÔ¨Ånition thatlooks something like: lists
instance Monad[]where
returnx=[x]
l>>=f=concatMap fl
fail_=[]
9.4.COMMON MONADS 131
This enables ustouselistsindonotation. Forinstance, giventhedeÔ¨Ånition:
crossl1l2=do
x<-l1
y<-l2
return(x,y)
wegetacross-product function:
Monads> cross"ab""cde"
[(‚Äôa‚Äô,‚Äôd‚Äô),(‚Äôa‚Äô,‚Äôe‚Äô),(‚Äôa‚Äô,‚Äôf‚Äô),(‚Äôb‚Äô,‚Äôd‚Äô),(‚Äôb‚Äô,‚Äôe‚Äô),
(‚Äôb‚Äô,‚Äôf‚Äô)]
Itisnotacoincidence thatthislooks verymuch likethelistcomprehension form: listcomprehensions
Prelude> [(x,y)|x<-"ab",y<-"def"]
[(‚Äôa‚Äô,‚Äôd‚Äô),(‚Äôa‚Äô,‚Äôe‚Äô),(‚Äôa‚Äô,‚Äôf‚Äô),(‚Äôb‚Äô,‚Äôd‚Äô),(‚Äôb‚Äô,‚Äôe‚Äô),
(‚Äôb‚Äô,‚Äôf‚Äô)]
List comprehension form issimply anabbre viated form ofamonadic statement
using lists. Infact,inolder versions ofHask ell,thelistcomprehension form could be
used foranymonad ‚Äìnotjustlists. However,inthecurrent version ofHask ell,thisis
nolonger allowed.
TheMaybetype isalso amonad, with failure being represented asNothing and Maybe
with success asJust .Wegetthefollowing instance declaration:
instance MonadMaybewhere
returna=Justa
Nothing >>=f=Nothing
Justx>>=f=fx
fail_ =Nothing
Wecanusethesame cross product function thatwedidforlists onMaybes.This
isbecause thedonotation works foranymonad, andthere‚Äô snothing speciÔ¨Åc tolists
about thecross function.
Monads> cross(Just‚Äôa‚Äô)(Just‚Äôb‚Äô)
Just(‚Äôa‚Äô,‚Äôb‚Äô)
Monads> cross(Nothing ::MaybeChar)(Just‚Äôb‚Äô)
Nothing
Monads> cross(Just‚Äôa‚Äô)(Nothing ::MaybeChar)
Nothing
Monads> cross(Nothing ::MaybeChar)
(Nothing ::MaybeChar)
Nothing
132 CHAPTER 9.MONADS
What thismeans isthatifwewrite afunction (likesearchAll from Section 8.4) searchAll
only interms ofmonadic operators, wecanuseitwith anymonad, depending onwhat
wemean. Using realmonadic functions (not donotation), thesearchAll function
looks something like:
searchAll g@(Graph vlel)srcdst
|src==dst=return[src]
|otherwise =search‚Äô el
wheresearch‚Äô []=fail"nopath"
search‚Äô ((u,v,_):es)
|src==u=
searchAll gvdst>>=\path->
return(u:path)
|otherwise =search‚Äô es
Thetype ofthisfunction isMonadm=>Graphve->Int->Int->
m[Int] .This means thatnomatter what monad we‚Äôreusing atthemoment, this
function willperform thecalculation. Suppose wehavethefollowing graph:
gr=Graph[(0,‚Äôa‚Äô),(1,‚Äôb‚Äô),(2,‚Äôc‚Äô),(3,‚Äôd‚Äô)]
[(0,1,‚Äôl‚Äô), (0,2,‚Äôm‚Äô), (1,3,‚Äôn‚Äô), (2,3,‚Äôm‚Äô)]
This represents agraph with four nodes, labelled a,b,c andd.There isanedge
from atoboth bandc.There isalsoanedge from both bandctod.Using theMaybe
monad, wecancompute thepath from atod:
Monads> searchAll gr03::Maybe[Int]
Just[0,1,3]
Weprovide thetype signature, sothattheinterpreter knowswhat monad we‚Äôre
using. Ifwetrytosearch intheopposite direction, there isnopath. Theinability to
Ô¨Åndapath isrepresented asNothing intheMaybemonad:
Monads> searchAll gr30::Maybe[Int]
Nothing
Note thatthestring ‚Äúnopath‚Äù hasdisappeared since there‚Äô snowayfortheMaybe
monad torecord this.
Ifweperform thesame impossible search inthelistmonad, wegettheempty list,
indicating nopath:
Monads> searchAll gr30::[[Int]]
[]
9.4.COMMON MONADS 133
Ifweperform thepossible search, wegetback alistcontaining theÔ¨Årstpath:
Monads> searchAll gr03::[[Int]]
[[0,1,3]]
Youmay haveexpected thisfunction calltoreturn allpaths, but,ascoded, itdoes
not.SeeSection 9.6formore about using liststorepresent nondeterminism. nondeter minism
IfweusetheIOmonad, wecanactually getattheerror message, since IOknows
howtokeeptrack oferror messages:
Monads> searchAll gr03::IO[Int]
Monads> it
[0,1,3]
Monads> searchAll gr30::IO[Int]
***Exception: usererror
Reason: nopath
IntheÔ¨Årstcase, weneeded totypeittogetGHCi toactually evaluate thesearch.
There isoneproblem with thisimplementation ofsearchAll :ifitÔ¨Ånds anedge
thatdoes notlead toasolution, itwon‚Äôtbeable tobacktrack. This hastodowith
therecursi vecalltosearchAll inside ofsearch‚Äô .Consider ,forinstance, what
happens ifsearchAll gvdst doesn‚Äô tÔ¨Åndapath. There‚Äô snowayforthisim-
plementation torecover.Forinstance, ifweremo vetheedge from node btonode d,
weshould stillbeable toÔ¨Åndapath from atod,butthisalgorithm can‚ÄôtÔ¨Åndit.We
deÔ¨Åne:
gr2=Graph[(0,‚Äôa‚Äô),(1,‚Äôb‚Äô),(2,‚Äôc‚Äô),(3,‚Äôd‚Äô)]
[(0,1,‚Äôl‚Äô), (0,2,‚Äôm‚Äô), (2,3,‚Äôm‚Äô)]
andthen trytosearch:
Monads> searchAll gr203
***Exception: usererror
Reason: nopath
ToÔ¨Åxthis, weneed afunction likecombine from ourComputation class. We
willseehowtodothisinSection 9.6.
Exer cises
Exer cise9.1Verify thatMaybeobeysthethreemonad laws.
Exer cise9.2ThetypeEither String isamonad thatcankeeptrackoferrors.Write an
instance forit,andthen trydoing thesearchfromthischapter using thismonad.
Hint: Yourinstance declar ation should begin:instance Monad(Either String)
where .
134 CHAPTER 9.MONADS
9.5 Monadic Combinators
TheMonad /Control.Monad library contains afewveryuseful monadic combina-
tors, which haven‚Äôtyetbeen thoroughly discussed. The ones wewill discuss inthis
section, together with their types, are:
(=<<)::(a->mb)->ma->mb
mapM::(a->mb)->[a]->m[b]
mapM::(a->mb)->[a]->m()
filterM ::(a->mBool)->[a]->m[a]
foldM::(a->b->ma)->a->[b]->ma
sequence ::[ma]->m[a]
sequence ::[ma]->m()
liftM::(a->b)->ma->mb
when::Bool->m()->m()
join::m(ma)->ma
Intheabove,misalwaysassumed tobeaninstance ofMonad .
Ingeneral, functions with anunderscore attheendareequivalent totheones with-
out,except thattheydonotreturn anyvalue.
The=<< function isexactly thesame as>>=,except ittakesitsarguments inthe
opposite order .Forinstance, intheIOmonad, wecanwrite either ofthefollowing:
Monads> writeFile "foo""helloworld!" >>
(readFile "foo">>=putStrLn)
helloworld!
Monads> writeFile "foo""helloworld!" >>
(putStrLn =<<readFile "foo")
helloworld!
ThemapM ,filterM andfoldM areouroldfriendsmap,filter andfoldr mapM
Ô¨ÅlterM
foldMwrapped upinside ofmonads. These functions areincredibly useful (particularly
foldM )when working with monads. WecanusemapM ,forinstance, toprint alistof
things tothescreen:
Monads> mapM_print[1,2,3,4,5]
1
2
3
4
5
9.5.MONADICCOMBIN ATORS 135
WecanusefoldM tosum alistandprint theintermediate sum ateach step:
Monads> foldM(\ab->
putStrLn (showa++"+"++showb++
"="++show(a+b))>>
return(a+b))0[1..5]
0+1=1
1+2=3
3+3=6
6+4=10
10+5=15
Monads> it
15
Thesequence andsequence functions simply ‚Äúexecute‚Äù alistofactions. For sequence
instance:
Monads> sequence [print1,print2,print‚Äôa‚Äô]
1
2
‚Äôa‚Äô
*Monads> it
[(),(),()]
*Monads> sequence_ [print1,print2,print‚Äôa‚Äô]
1
2
‚Äôa‚Äô
*Monads> it
()
Wecanseethattheunderscored version doesn‚Äô treturn each value, while thenon-
underscored version returns thelistofthereturn values.
TheliftM function ‚Äúlifts‚Äù anon-monadic function toamonadic function. (Do liftM
notconfuse thiswith thelift function used formonad transformers inSection 9.7.)
This isuseful forshortening code (among other things). Forinstance, wemight want
towrite afunction thatprepends each lineinaÔ¨Ålewith itslinenumber .Wecandothis
with:
numberFile ::FilePath ->IO()
numberFile fp=do
text<-readFile fp
letl=linestext
letn=zipWith (\nt->shown++‚Äô‚Äô:t)[1..]l
mapM_putStrLn n
However,wecanshorten thisusingliftM :
136 CHAPTER 9.MONADS
numberFile ::FilePath ->IO()
numberFile fp=do
l<-lines‚ÄòliftM‚Äò readFile fp
letn=zipWith (\nt->shown++‚Äô‚Äô:t)[1..]l
mapM_putStrLn n
Infact,youcanapply anysortof(pure) processing toaÔ¨ÅleusingliftM .For
instance, perhaps wealsowanttosplit lines intowords; wecandothiswith:
...
w<-(mapwords.lines)‚ÄòliftM‚Äò readFile fp
...
Note thattheparentheses arerequired, since the(.) function hasthesame Ô¨Åxity
has‚ÄòliftM‚Äò .
Lifting pure functions into monads isalso useful inother monads. Forinstance
liftM canbeused toapply function inside ofJust .Forinstance:
Monads> liftM(+1)(Just5)
Just6
*Monads> liftM(+1)Nothing
Nothing
Thewhen function executes amonadic action only ifacondition ismet. So,ifwe when
only wanttoprint non-empty lines:
Monads> mapM_(\l->when(not$nulll)(putStrLn l))
["","abc","def","","","ghi"]
abc
def
ghi
Ofcourse, thesame could beaccomplished withfilter ,butsometimes when is
more convenient.
Finally ,thejoin function isthemonadic equivalent ofconcat onlists. Infact, join
whenmisthelistmonad,join isexactlyconcat .Inother monads, itaccomplishes
asimilar task:
Monads> join(Just(Just‚Äôa‚Äô))
Just‚Äôa‚Äô
Monads> join(Just(Nothing ::MaybeChar))
Nothing
Monads> join(Nothing ::Maybe(MaybeChar))
Nothing
9.6.MONADPLUS 137
Monads> join(return (putStrLn "hello"))
hello
Monads> return(putStrLn "hello")
Monads> join[[1,2,3],[4,5]]
[1,2,3,4,5]
These functions willturn outtobeevenmore useful aswemoveontomore ad-
vanced topics inChapter 10.
9.6 MonadPlus
Givenonly the>>= andreturn functions, itisimpossible towrite afunction like
combine with typeca!ca!ca.However,such afunction issogenerally useful combine
thatitexists inanother class calledMonadPlus .Inaddition tohaving acombine MonadPlus
function, instances ofMonadPlus also havea‚Äúzero‚Äù element that istheidentity
under the‚Äúplus‚Äù (i.e., combine) action. ThedeÔ¨Ånition is:
classMonadm=>MonadPlus mwhere
mzero::ma
mplus::ma->ma->ma
Inorder togainaccess toMonadPlus ,youneed toimport theMonad module
(orControl.Monad inthehierarchical libraries).
InSection 9.4, weshowed thatMaybeandlistareboth monads. Infact,they Maybe
lists arealso both instances ofMonadPlus .Inthecase ofMaybe,thezero element is
Nothing ;inthecase oflists, itistheempty list.Themplus operation onMaybeis
Nothing ,ifboth elements areNothing ;otherwise, itistheÔ¨ÅrstJust value. For
lists,mplus isthesame as++.
That is,theinstance declarations look like:
instance MonadPlus Maybewhere
mzero=Nothing
mplusNothing y=y
mplusx _=x
instance MonadPlus []where
mzero=[]
mplusxy=x++y
Wecanusethisclass toreimplement thesearch function we‚Äôvebeen exploring,
such thatitwillexplore allpossible paths. Thenewfunction looks like:
searchAll2 g@(Graph vlel)srcdst
|src==dst=return[src]
138 CHAPTER 9.MONADS
|otherwise =search‚Äô el
wheresearch‚Äô []=fail"nopath"
search‚Äô ((u,v,_):es)
|src==u=
(searchAll2 gvdst>>=\path->
return(u:path)) ‚Äòmplus‚Äò
search‚Äô es
|otherwise =search‚Äô es
Now,when we‚Äôregoing through theedge listinsearch‚Äô ,andwecome across a
matching edge, notonly doweexplore thispath, butwealso continue toexplore the
out-edges ofthecurrent node intherecursi vecalltosearch‚Äô .
The IOmonad isnotaninstance ofMonadPlus ;wewe‚Äôrenotable toexecute
thesearch with thismonad. Wecanseethatwhen using listsasthemonad, we(a)get
allpossible paths ingrand(b)getapath ingr2.
MPlus>searchAll2 gr03::[[Int]]
[[0,1,3],[0,2,3]]
MPlus>searchAll2 gr203::[[Int]]
[[0,2,3]]
Youmight betempted toimplement thisas:
searchAll2 g@(Graph vlel)srcdst
|src==dst=return[src]
|otherwise =search‚Äô el
wheresearch‚Äô []=fail"nopath"
search‚Äô ((u,v,_):es)
|src==u=do
path<-searchAll2 gvdst
rest<-search‚Äô es
return((u:path) ‚Äòmplus‚Äò rest)
|otherwise =search‚Äô es
Butnote thatthisdoesn‚Äô tdowhat wewant.Here, iftherecursi vecalltosearchAll2
fails, wedon‚Äôttrytocontinue andexecutesearch‚Äô es.Thecalltomplus must be
atthetoplevelinorder forittowork.
Exer cises
Exer cise9.3Suppose that wechang edtheorderofarguments tomplus .I.e.,the
matc hing case ofsearch‚Äô lookedlike:
search' es`mplus`
(searchAll2 gvdst>>=\path ->
return (u:path))
9.7.MONADTRANSFORMERS 139
How would youexpect thistochang etheresults when using thelistmonad ongr?
Why?
9.7 Monad Transf ormers
Often wewantto‚Äúpiggyback‚Äù monads ontopofeach other .Forinstance, there might
beacase where you need access toboth IOoperations through theIOmonad and
state functions through some state monad. Inorder toaccomplish this, weintroduce
aMonadT rans class, which essentially ‚Äúlifts‚Äù theoperations ofonemonad intoan- MonadT rans
other .Youcanthink ofthisasstacking monads ontopofeachother .This class hasa
simple method:lift .Theclass declaration forMonadT rans is: lift
classMonadTrans twhere
lift::Monadm=>ma->tma
Theidea here isthattistheouter monad andthatmlivesinside ofit.Inorder to
execute acommand oftypeMonadm=>ma,weÔ¨Årstlift itintothetransformer .
Thesimplest example ofatransformer (and arguably themost useful) isthestate
transformer monad, which isastate monad wrapped around anarbitrary monad. Be- state monad
fore, wedeÔ¨Åned astate monad as:
newtype Statestatea=State(state->(state, a))
Now,instead ofusing afunction oftypestate->(state, a)asthemonad,
weassume there‚Äô ssome other monadmandmaketheinternal action intosomething of
typestate->m(state, a).This givesrisetothefollowing deÔ¨Ånition fora
state transformer: state transformer
newtype StateTstatema=
StateT(state->m(state, a))
Forinstance, wecanthink ofmasIO.Inthiscase, ourstate transformer monad is
abletoexecute actions intheIOmonad. First, wemakethisaninstance ofMonadT rans :
instance MonadTrans (StateT state)where
liftm=StateT(\s->doa<-m
return(s,a))
Here, lifting afunction from therealm ofmtotherealm ofStateTstate simply
involveskeeping thestate (thesvalue) constant andexecuting theaction.
Ofcourse, wealso need tomakeStateT amonad, itself. This isrelati vely
straightforw ard,provided thatmisalready amonad:
140 CHAPTER 9.MONADS
instance Monadm=>Monad(StateT statem)where
returna=StateT(\s->return(s,a))
StateTm>>=k=StateT(\s->do
(s‚Äô,a)<-ms
letStateTm‚Äô=ka
m‚Äôs‚Äô)
fails=StateT(\_->fails)
The idea behind thedeÔ¨Ånition ofreturn isthatwekeepthestate constant and
simply return thestate/a pairintheenclosed monad. Note thattheuseofreturn in
thedeÔ¨Ånition ofreturn refers totheenclosed monad, notthestate transformer .
InthedeÔ¨Ånition ofbind, wecreate anewStateT thattakesastatesasanar-
gument. First, itapplies thisstate totheÔ¨Årst action (StateTm)andgets thenew
state andanswer asaresult. Itthen runs thekaction onthisnewstate andgets anew
transformer .ItÔ¨Ånally applies thenewstate tothistransformer .This deÔ¨Ånition isnearly
identical tothedeÔ¨Ånition ofbind forthestandard (non-transformer) State monad
described inSection 9.3.
Thefail function passes onthecalltofail intheenclosed monad, since state
transformers don‚Äôtnativelyknowhowtodeal with failure.
Ofcourse, inorder toactually usethismonad, weneed toprovide functiongetT
,putT andevalStateT .These areanalogous togetState ,putState and getT
putT
evalStateTrunStateM from Section 9.3:
getT::Monadm=>StateTsms
getT=StateT(\s->return(s,s))
putT::Monadm=>s->StateTsm()
putTs=StateT(\_->return(s,()))
evalStateT ::Monadm=>StateTsma->s->ma
evalStateT (StateT m)state=do
(s‚Äô,a)<-mstate
returna
These functions should bestraightforw ard.Note, however,thattheresult ofevalStateT
isactually amonadic action intheenclosed monad. This istypical ofmonad trans-
formers: theydon‚Äôtknowhowtoactually runthings intheir enclosed monad (they
only knowhowtolift actions). Thus, what yougetoutisamonadic action inthe
inside monad (inourcase, IO), which youthen need torunyourself.
Wecanusestate transformers toreimplement aversion ofourmapTreeM function
from Section 9.3.Theonly change here isthatwhen wegettoaleaf, weprint outthe
value oftheleaf; when wegettoabranch, wejustprint out‚ÄúBranch. ‚Äù
mapTreeM action(Leafa)=do
lift(putStrLn ("Leaf"++showa))
9.7.MONADTRANSFORMERS 141
b<-actiona
return(Leafb)
mapTreeM action(Branch lhsrhs)=do
lift(putStrLn "Branch")
lhs‚Äô<-mapTreeM actionlhs
rhs‚Äô<-mapTreeM actionrhs
return(Branch lhs‚Äôrhs‚Äô)
Theonly difference between thisfunction andtheonefrom Section 9.3isthecalls
tolift(putStrLn ...) astheÔ¨Årstline. Thelift tells usthatwe‚Äôregoing to
beexecuting acommand inanenclosed monad. Inthiscase, theenclosed monad is
IO,since thecommand lifted isputStrLn .
Thetype ofthisfunction isrelati velycomple x:
mapTreeM ::(MonadTrans t,Monad(tIO),Showa)=>
(a->tIOa1)->Treea->tIO(Treea1)
Ignoring, forasecond, theclass constraints, thissays thatmapTreeM takesan
action andatreeandreturns atree. This justasbefore. Inthis, werequire thattis
amonad transformer (since weapplylift init);werequire thattIOisamonad,
since weuseputStrLn weknowthattheenclosed monad isIO;Ô¨Ånally ,werequire
thataisaninstance ofshow‚Äìthisissimply because weuseshow toshowthevalue
ofleaves.
Now,wesimply changenumberTree tousethisversion ofmapTreeM ,andthe
newversions ofget andput,andweendupwith:
numberTree tree=mapTreeM numbertree
wherenumberv=do
cur<-getT
putT(cur+1)
return(v,cur)
Using this, wecanrunourmonad:
MTrans> evalStateT (numberTree testTree) 0
Branch
Branch
Leaf‚Äôa‚Äô
Branch
Leaf‚Äôb‚Äô
Leaf‚Äôc‚Äô
Branch
Leaf‚Äôd‚Äô
Leaf‚Äôe‚Äô
*MTrans> it
142 CHAPTER 9.MONADS
Branch(Branch (Leaf(‚Äôa‚Äô,0))
(Branch (Leaf(‚Äôb‚Äô,1)) (Leaf(‚Äôc‚Äô,2))))
(Branch (Leaf(‚Äôd‚Äô,3)) (Leaf(‚Äôe‚Äô,4)))
One problem notspeciÔ¨Åed inourdiscussion ofMonadPlus isthatoursearch
algorithm willfailtoterminate ongraphs with cycles. Consider: cycles
gr3=Graph[(0,‚Äôa‚Äô),(1,‚Äôb‚Äô),(2,‚Äôc‚Äô),(3,‚Äôd‚Äô)]
[(0,1,‚Äôl‚Äô), (1,0,‚Äôm‚Äô), (0,2,‚Äôn‚Äô),
(1,3,‚Äôo‚Äô), (2,3,‚Äôp‚Äô)]
Inthisgraph, there isaback edge from node bback tonode a.Ifweattempt torun
searchAll2 ,regardless ofwhat monad weuse, itwillfailtoterminate. Moreo ver,
ifwemovethiserroneous edge totheendofthelist(and callthisgr4),theresult of
searchAll2 gr403will contain aninÔ¨Ånite number ofpaths: presumably we
only wantpaths thatdon‚Äôtcontain cycles.
Inorder togetaround thisproblem, weneed tointroduce state. Namely ,weneed
tokeeptrack ofwhich nodes wehavevisited, sothatwedon‚Äôtvisit them again.
Wecandothisasfollows:
searchAll5 g@(Graph vlel)srcdst
|src==dst=do
visited <-getT
putT(src:visited)
return[src]
|otherwise =do
visited <-getT
putT(src:visited)
ifsrc‚Äòelem‚Äòvisited
thenmzero
elsesearch‚Äô el
where
search‚Äô []=mzero
search‚Äô ((u,v,_):es)
|src==u=
(dopath<-searchAll5 gvdst
return(u:path)) ‚Äòmplus‚Äò
search‚Äô es
|otherwise =search‚Äô es
Here, weimplicitly useastate transformer (see thecalls togetT andputT )to
keeptrack ofvisited states. Weonly continue torecurse, when weencounter astate we
haven‚Äôtyetvisited. Futhermore, when werecurse, weaddthecurrent state toourset
ofvisited states.
Now,wecanrunthestate transformer andgetoutonly thecorrect paths, evenon
thecyclic graphs:
9.7.MONADTRANSFORMERS 143
MTrans> evalStateT (searchAll5 gr303)[]::[[Int]]
[[0,1,3],[0,2,3]]
MTrans> evalStateT (searchAll5 gr403)[]::[[Int]]
[[0,1,3],[0,2,3]]
Here, theempty listprovided asanargument toevalStateT istheinitial state
(i.e., theinitial visited list). Inourcase, itisempty .
Wecanalso provide anexecStateT method that, instead ofreturning aresult,
returns theÔ¨Ånal state. This function looks like:
execStateT ::Monadm=>StateTsma->s->ms
execStateT (StateT m)state=do
(s‚Äô,a)<-mstate
returns‚Äô
This isnotsouseful inourcase, asitwillreturn exactly thereverseofevalStateT
(tryitandÔ¨Åndout!), butcanbeuseful ingeneral (if,forinstance, weneed toknowhow
manynumbers areused innumberTree ).
Exer cises
Exer cise9.4Write afunctionsearchAll6 ,based onthecode forsearchAll2 ,
that, atevery entry tothemain function (nottherecursion overtheedgelist), prints the
searchbeing conducted. Forinstance ,theoutput generated forsearchAll6 gr0
3should look like:
Exploring 0->3
Exploring 1->3
Exploring 3->3
Exploring 2->3
Exploring 3->3
MTrans> it
[[0,1,3],[0,2,3]]
Inordertodothis, youwillhave todeÔ¨Åne your own listmonad transformer andmake
appropriate instances ofit.
Exer cise9.5Combine thesearchAll5 function (fromthissection) with thesearchAll6
function (fromtheprevious exercise) intoasingle function calledsearchAll7 .This
function should perform IOasinsearchAll6 butshould also keeptrackofstate
using astate transformer .
144 CHAPTER 9.MONADS
9.8 Parsing Monads
Itturns outthatacertain class ofparsers areallmonads. This makestheconstruction
ofparsing libraries inHask ellveryclean. Inthischapter ,webeginbybuilding ourown
(small) parsing library inSection 9.8.1 andthen introduce theParsec parsing library in
Section 9.8.2.
9.8.1 ASimple Parsing Monad
Consider thetask ofparsing. Asimple parsing monad ismuch likeastate monad,
where thestate istheunparsed string. Wecanrepresent thisexactly as:
newtype Parsera=Parser
{runParser ::String->EitherString(String, a)}
WeagainuseLefterr tobeanerror condition. This yields standard instances
ofMonad andMonadPlus :
instance MonadParserwhere
returna=Parser(\xl->Right(xl,a))
fails=Parser(\xl->Lefts)
Parserm>>=k=Parser$\xl->
casemxlof
Lefts->Lefts
Right(xl‚Äô,a)->
letParsern=ka
innxl‚Äô
instance MonadPlus Parserwhere
mzero=Parser(\xl->Left"mzero")
Parserp‚Äòmplus‚Äò Parserq=Parser$\xl->
casepxlof
Righta->Righta
Lefterr->caseqxlof
Righta->Righta
Left_->Lefterr
Now,wewanttobuildupalibrary ofparing ‚Äúprimiti ves.‚ÄùThemost basic primiti ve primitiv es
isaparser thatwillread aspeciÔ¨Åc character .This function looks like:
char::Char->ParserChar
charc=Parserchar‚Äô
wherechar‚Äô[]=Left("expecting "++showc++
"gotEOF")
char‚Äô(x:xs)
|x==c=Right(xs,c)
9.8.PARSING MONADS 145
|otherwise =Left("expecting "++
showc++"got"++
showx)
Here, theparser succeeds only iftheÔ¨Årst character oftheinput istheexpected
character .
Wecanusethisparser tobuildupaparser forthestring ‚ÄúHello‚Äù:
helloParser ::ParserString
helloParser =do
char‚ÄôH‚Äô
char‚Äôe‚Äô
char‚Äôl‚Äô
char‚Äôl‚Äô
char‚Äôo‚Äô
return"Hello"
This showshoweasy itistocombine these parsers. Wedon‚Äôtneed toworry about
theunderlying string ‚Äìthemonad takescare ofthat forus. Allweneed todois
combine these parser primati ves.Wecantestthisparser byusingrunParser andby runParser
supplying input:
Parsing> runParser helloParser "Hello"
Right("","Hello")
Parsing> runParser helloParser "HelloWorld!"
Right("World!","Hello")
Parsing> runParser helloParser "helloWorld!"
Left"expecting ‚ÄôH‚Äôgot‚Äôh‚Äô"
Wecanhaveaslightly more general function, which willmatch anycharacter Ô¨Åtting
adescription:
matchChar ::(Char->Bool)->ParserChar
matchChar c=ParsermatchChar‚Äô
wherematchChar‚Äô []=
Left("expecting char,gotEOF")
matchChar‚Äô (x:xs)
|cx =Right(xs,x)
|otherwise =
Left("expecting char,got"++
showx)
Using this, wecanwrite acase-insensiti ve‚ÄúHello‚Äù parser:
146 CHAPTER 9.MONADS
ciHelloParser =do
c1<-matchChar (‚Äòelem‚Äò "Hh")
c2<-matchChar (‚Äòelem‚Äò "Ee")
c3<-matchChar (‚Äòelem‚Äò "Ll")
c4<-matchChar (‚Äòelem‚Äò "Ll")
c5<-matchChar (‚Äòelem‚Äò "Oo")
return[c1,c2,c3,c4,c5]
Ofcourse, wecould haveused something likematchChar ((==‚Äôh‚Äô) .toLower) ,
buttheaboveimplementation works justaswell. Wecantestthisfunction:
Parsing> runParser ciHelloParser "hELlOworld!"
Right("world!","hELlO")
Finally ,wecanhaveafunction, which willmatch anycharacter:
anyChar ::ParserChar
anyChar =ParseranyChar‚Äô
whereanyChar‚Äô []=
Left("expecting character, gotEOF")
anyChar‚Äô (x:xs)=Right(xs,x)
Ontopofthese primiti ves,weusually buildsome combinators. Themany combi- many
nator ,forinstance, willtakeaparser thatparses entities oftypeaandwillmakeitinto
aparser thatparses entities oftype[a] (this isaKleene-star operator):
many::Parsera->Parser[a]
many(Parser p)=Parsermany‚Äô
wheremany‚Äôxl=
casepxlof
Lefterr->Right(xl,[])
Right(xl‚Äô,a) ->
letRight(xl‚Äô‚Äô,rest)=many‚Äôxl‚Äô
inRight(xl‚Äô‚Äô,a:rest)
Theideahere isthatÔ¨Årstwetrytoapply thegivenparser ,p.Ifthisfails,wesucceed
butreturn theempty list.Ifpsucceeds, werecurse andkeeptrying toapplypuntil it
fails. Wethen return thelistofsuccesses we‚Äôveaccumulated.
Ingeneral, there would bemanymore functions ofthissort, andtheywould behid-
denawayinalibrary ,sothatusers couldn‚Äô tactually look inside theParser type.
However,using them, you could build up,forinstance, aparser that parses (non-
negative)integers:
9.8.PARSING MONADS 147
int::ParserInt
int=do
t1<-matchChar isDigit
tr<-many(matchChar isDigit)
return(read(t1:tr))
Inthisfunction, weÔ¨Årst match adigit (theisDigit function comes from the
moduleChar /Data.Char )andthen match asmanymore digits aswecan. Wethen
read theresult andreturn it.Wecantestthisparser asbefore:
Parsing> runParser int"54"
Right("",54)
*Parsing> runParser int"54abc"
Right("abc",54)
*Parsing> runParser int"a54abc"
Left"expecting char,got‚Äôa‚Äô"
Now,suppose wewanttoparse aHask ell-style listofInts.This becomes some what
difÔ¨Åcult because, atsome point, we‚Äôreeither going toparse acomma oraclose brace,
butwedon‚Äôtknowwhen thiswillhappen. This iswhere thefactthatParser isan
instance ofMonadPlus comes inhandy: Ô¨Årstwetryone, then wetrytheother .
Consider thefollowing code:
intList ::Parser[Int]
intList =do
char‚Äô[‚Äô
intList‚Äô ‚Äòmplus‚Äò (char‚Äô]‚Äô>>return[])
whereintList‚Äô =do
i<-int
r<-(char‚Äô,‚Äô>>intList‚Äô) ‚Äòmplus‚Äò
(char‚Äô]‚Äô>>return[])
return(i:r)
TheÔ¨Årstthing thiscode does isparse andopen brace. Then, usingmplus ,ittries mplus
oneoftwothings: parsing usingintList‚Äô ,orparsing aclose brace andreturning an
empty list.
TheintList‚Äô function assumes thatwe‚Äôrenotyetattheendofthelist,andsoit
Ô¨Årstparses anint.Itthen parses therestofthelist.However,itdoesn‚Äô tknowwhether
we‚Äôreattheendyet,soitagainusesmplus .Ontheonehand, ittries toparse acomma
andthen recurse; ontheother ,itparses aclose brace andreturns theempty list.Either
way,itsimply prepends theintitparsed itself tothebeginning.
One thing thatyoushould becareful ofistheorder inwhich yousupply arguments
tomplus .Consider thefollowing parser:
148 CHAPTER 9.MONADS
tricky=
mplus(string "Hal")(string "Hall")
Youmight expect thisparser toparse both thewords ‚ÄúHal‚Äù and‚ÄúHall;‚Äù however,it
only parses theformer .Youcanseethiswith:
Parsing> runParser tricky"Hal"
Right("","Hal")
Parsing> runParser tricky"Hall"
Right("l","Hal")
This isbecause ittries toparse ‚ÄúHal, ‚Äùwhich succeeds, andthen itdoesn‚Äô tbother
trying toparse ‚ÄúHall. ‚Äù
Youcanattempt toÔ¨Åxthisbyproviding aparser primiti ve,which detects end-of-Ô¨Åle
(really ,end-of-string) as:
eof::Parser()
eof=Parsereof‚Äô
whereeof‚Äô[]=Right([],())
eof‚Äôxl=Left("Expecting EOF,got"++
show(take10xl))
Youmight then rewritetricky usingeof as:
tricky2 =do
s<-mplus(string "Hal")(string "Hall")
eof
returns
Butthisalsodoesn‚Äô twork,aswecaneasily see:
Parsing> runParser tricky2 "Hal"
Right("",())
Parsing> runParser tricky2 "Hall"
Left"Expecting EOF,got\"l\""
This isbecause, again,themplus doesn‚Äô tknowthatitneeds toparse thewhole
input. So,when youprovide itwith ‚ÄúHall, ‚Äùitparses just‚ÄúHal‚Äù andleavesthelast‚Äúl‚Äù
lying around tobeparsed later.This causeseof toproduce anerror message.
Thecorrect waytoimplement thisis:
tricky3 =
mplus(dos<-string"Hal"
9.8.PARSING MONADS 149
eof
returns)
(dos<-string"Hall"
eof
returns)
Wecanseethatthisworks:
Parsing> runParser tricky3 "Hal"
Right("","Hal")
Parsing> runParser tricky3 "Hall"
Right("","Hall")
This works precisely because each side ofthemplus knowsthatitmust read the
end.
Inthiscase, Ô¨Åxing theparser toaccept both ‚ÄúHal‚Äù and‚ÄúHall‚Äù wasfairly simple,
duetothefactthatweassumed wewould bereading anend-of-Ô¨Åle immediately af-
terwards. Unfortunately ,ifwecannot disambiguate immediately ,lifebecomes signiÔ¨Å-
cantly more complicated. This isageneral problem inparsing, andhaslittle todowith
monadic parsing. The solution most parser libraries (e.g., Parsec, seeSection 9.8.2)
haveadopted istoonly recognize ‚ÄúLL(1)‚Äù grammars: thatmeans thatyoumust beable
todisambiguate theinput with aonetokenlook-ahead.
Exer cises
Exer cise9.6Write aparserintListSpace thatwillparseintlists butwillallow
arbitr arywhite space (spaces, tabs ornewlines) between thecommas andbrackets.
Giventhismonadic parser ,itisfairly easy toaddinformation regarding source
position. Forinstance, ifwe‚Äôreparsing alargeÔ¨Åle, itmight behelpful toreport the
linenumber onwhich anerror occurred. Wecould dothissimply byextending the linenumbers
Parser type andbymodifying theinstances andtheprimiti ves:
newtype Parsera=Parser
{runParser ::Int->String->
EitherString(Int,String, a)}
instance MonadParserwhere
returna=Parser(\nxl->Right(n,xl,a))
fails=Parser(\nxl->Left(shown++
":"++s))
Parserm>>=k=Parser$\nxl->
casemnxlof
Lefts->Lefts
Right(n‚Äô,xl‚Äô,a)->
letParserm2=ka
150 CHAPTER 9.MONADS
inm2n‚Äôxl‚Äô
instance MonadPlus Parserwhere
mzero=Parser(\nxl->Left"mzero")
Parserp‚Äòmplus‚Äò Parserq=Parser$\nxl->
casepnxlof
Righta->Righta
Lefterr->caseqnxlof
Righta->Righta
Left_->Lefterr
matchChar ::(Char->Bool)->ParserChar
matchChar c=ParsermatchChar‚Äô
wherematchChar‚Äô n[]=
Left("expecting char,gotEOF")
matchChar‚Äô n(x:xs)
|cx =
Right(n+ifx==‚Äô\n‚Äô then1else0
,xs,x)
|otherwise =
Left("expecting char,got"++
showx)
ThedeÔ¨Ånitions forchar andanyChar arenotgiven,since theycanbewritten in
terms ofmatchChar .Themany function needs tobemodiÔ¨Åed only toinclude the
newstate.
Now,when werunaparser andthere isanerror ,itwilltelluswhich linenumber
contains theerror:
Parsing2> runParser helloParser 1"Hello"
Right(1,"","Hello")
Parsing2> runParser int1"a54"
Left"1:expecting char,got‚Äôa‚Äô"
Parsing2> runParser intList 1"[1,2,3,a]"
Left"1:expecting ‚Äô]‚Äôgot‚Äô1‚Äô"
WecanusetheintListSpace parser from theprior exercise toseethatthisdoes
infactwork:
Parsing2> runParser intListSpace 1
"[1,2,4\n\n,a\n]"
Left"3:expecting char,got‚Äôa‚Äô"
Parsing2> runParser intListSpace 1
"[1,2,4\n\n\n,a\n]"
Left"4:expecting char,got‚Äôa‚Äô"
Parsing2> runParser intListSpace 1
9.8.PARSING MONADS 151
"[1,\n2,4\n\n\n,a\n]"
Left"5:expecting char,got‚Äôa‚Äô"
Wecanseethatthelinenumber ,onwhich theerror occurs, increases asweadd
additional newlines before theerroneous ‚Äúa‚Äù.
9.8.2 Parsec
Asyoucontinue developing your parser ,youmight wanttoaddmore andmore fea-
tures. Luckily ,Graham Hutton andDaan Leijen havealready done thisforusinthe
Parsec library .This section isintended tobeanintroduction totheParsec library; itby
nomeans coversthewhole library ,butitshould beenough togetyoustarted.
Likeourlibarary ,Parsec provides afewbasic functions tobuildparsers from char-
acters. These are:char ,which isthesame asourchar ;anyChar ,which isthesame char
anyChar asouranyChar ;satisfy ,which isthesame asourmatchChar ;oneOf ,which
satisfy
oneOftakesalistofCharsandmatches anyofthem; andnoneOf ,which istheopposite of
noneOfoneOf .
Theprimary function Parsec uses torunaparser isparse .However,inaddition to
parse aparser ,thisfunction takesastring thatrepresents thename oftheÔ¨Åleyou‚Äôreparsing.
This issoitcangivebetter error messages. Wecantryparsing with theabovefunctions:
ParsecI> parse(char‚Äôa‚Äô)"stdin" "a"
Right‚Äôa‚Äô
ParsecI> parse(char‚Äôa‚Äô)"stdin" "ab"
Right‚Äôa‚Äô
ParsecI> parse(char‚Äôa‚Äô)"stdin" "b"
Left"stdin" (line1,column1):
unexpected "b"
expecting "a"
ParsecI> parse(char‚ÄôH‚Äô>>char‚Äôa‚Äô>>char‚Äôl‚Äô)
"stdin" "Hal"
Right‚Äôl‚Äô
ParsecI> parse(char‚ÄôH‚Äô>>char‚Äôa‚Äô>>char‚Äôl‚Äô)
"stdin" "Hap"
Left"stdin" (line1,column3):
unexpected "p"
expecting "l"
Here, wecanseeafewdifferences between ourparser andParsec: Ô¨Årst, therest
ofthestring isn‚Äôtreturned when werunparse .Second, theerror messages produced
aremuch better .
Inaddition tothebasic character parsing functions, Parsec provides primiti vesfor:
spaces ,which isthesame asours;space which parses asingle space;letter , spaces
space
letterwhich parses aletter;digit ,which parses adigit;string ,which isthesame as
digit
stringours; andafewothers.
Wecanwrite ourint andintList functions inParsec as:
152 CHAPTER 9.MONADS
int::CharParser stInt
int=do
i1<-digit
ir<-manydigit
return(read(i1:ir))
intList ::CharParser st[Int]
intList =do
char‚Äô[‚Äô
intList‚Äô ‚Äòmplus‚Äò (char‚Äô]‚Äô>>return[])
whereintList‚Äô =do
i<-int
r<-(char‚Äô,‚Äô>>intList‚Äô) ‚Äòmplus‚Äò
(char‚Äô]‚Äô>>return[])
return(i:r)
First, note thetype signatures. Thesttype variable issimply astate variable that
wearenotusing. Intheint function, weusethemany function (builtintoParsec)
together with thedigit function (also builtintoParsec). TheintList function is
actually identical totheonewewrote before.
Note, however,thatusingmplus explicitly isnotthepreferred method ofcom-
bining parsers: Parsec provides a<|> function thatisasynon ymofmplus ,butthat
looks nicer:
intList ::CharParser st[Int]
intList =do
char‚Äô[‚Äô
intList‚Äô <|>(char‚Äô]‚Äô>>return[])
whereintList‚Äô =do
i<-int
r<-(char‚Äô,‚Äô>>intList‚Äô) <|>
(char‚Äô]‚Äô>>return[])
return(i:r)
Wecantestthis:
ParsecI> parseintList "stdin" "[3,5,2,10]"
Right[3,5,2,10]
ParsecI> parseintList "stdin" "[3,5,a,10]"
Left"stdin" (line1,column6):
unexpected "a"
expecting digit
Inaddition tothese basic combinators, Parsec provides afewother useful ones:
9.8.PARSING MONADS 153
choice takesalistofparsers andperforms anoroperation (<|>)between all
ofthem.
option takesadefaultvalue oftypeaandaparser thatreturns something of
typea.Itthen tries toparse with theparser ,butituses thedefaultvalue asthe
return, iftheparsing fails.
optional takesaparser thatreturns()andoptionally runs it.
between takesthree parsers: anopen parser ,aclose parser andabetween
parser .Itruns them inorder andreturns thevalue ofthebetween parser .This
canbeused, forinstance, totakecare ofthebrack etsonourintList parser .
notFollowedBy takesaparser andreturns onethatsucceeds only ifthegiven
parser would havefailed.
Suppose wewanttoparse asimple calculator language that includes only plus
andtimes. Furthermore, forsimplicity ,assume each embedded expression must be
enclosed inparentheses. Wecangiveadatatype forthislanguage as:
dataExpr=ValueInt
|Expr:+:Expr
|Expr:*:Expr
deriving (Eq,Ord,Show)
And then write aparser forthislanguage as:
parseExpr ::ParserExpr
parseExpr =choice
[doi<-int;return(Valuei)
,between (char‚Äô(‚Äô)(char‚Äô)‚Äô)$do
e1<-parseExpr
op<-oneOf"+*"
e2<-parseExpr
caseopof
‚Äô+‚Äô->return(e1:+:e2)
‚Äô*‚Äô->return(e1:*:e2)
]
Here, theparser alternates between twooptions (wecould haveused<|>,butI
wanted toshowthechoice combinator inaction). TheÔ¨Årstsimply parses anintand
then wraps itupintheValue constructor .Thesecond option usesbetween toparse
textbetween parentheses. What itparses isÔ¨Årst anexpression, then oneofplus or
times, then another expression. Depending onwhat theoperator is,itreturns eithere1
:+:e2ore1:*:e2.
Wecanmodify thisparser ,sothatinstead ofcomputing anExpr ,itsimply com-
putes thevalue:
154 CHAPTER 9.MONADS
parseValue ::ParserInt
parseValue =choice
[int
,between (char‚Äô(‚Äô)(char‚Äô)‚Äô)$do
e1<-parseValue
op<-oneOf"+*"
e2<-parseValue
caseopof
‚Äô+‚Äô->return(e1+e2)
‚Äô*‚Äô->return(e1*e2)
]
Wecanusethisas:
ParsecI> parseparseValue "stdin" "(3*(4+3))"
Right21
Now,suppose wewanttointroduce bindings intoourlanguage. That is,wewant bindings
toalsobeable tosay‚Äúletx=5in‚Äùinside ofourexpressions andthen usethevariables
we‚ÄôvedeÔ¨Åned. Inorder todothis, weneed tousethegetState andsetState (or getState
setState updateState )functions builtintoParsec.
updateState
parseValueLet ::CharParser (FiniteMap CharInt)Int
parseValueLet =choice
[int
,dostring"let"
c<-letter
char‚Äô=‚Äô
e<-parseValueLet
string"in"
updateState (\fm->addToFM fmce)
parseValueLet
,doc<-letter
fm<-getState
caselookupFM fmcof
Nothing ->unexpected ("variable "++showc++
"unbound")
Justi->returni
,between (char‚Äô(‚Äô)(char‚Äô)‚Äô)$do
e1<-parseValueLet
op<-oneOf"+*"
e2<-parseValueLet
caseopof
‚Äô+‚Äô->return(e1+e2)
9.8.PARSING MONADS 155
‚Äô*‚Äô->return(e1*e2)
]
Theint andrecursi vecases remain thesame. Weaddtwomore cases, onetodeal
with let-bindings, theother todeal with usages.
Inthelet-bindings case, weÔ¨Årstparse a‚Äúlet‚Äù string, followedbythecharacter we‚Äôre
binding (theletter function isaParsec primiti vethatparses alphabetic characters),
followed byit‚Äôsvalue (aparseValueLet ).Then, weparse the‚Äúin‚Äùandupdate the
state toinclude thisbinding. Finally ,wecontinue andparse therest.
Intheusage case, wesimply parse thecharacter andthen look itupinthestate.
However,ifitdoesn‚Äô texist, weusetheParsec primiti veunexpected toreport an
error .
Wecanseethisparser inaction using therunParser command, which enables runParser
ustoprovide aninitial state:
ParsecI> runParser parseValueLet emptyFM "stdin"
"letc=5in((5+4)*c)"
Right45
*ParsecI> runParser parseValueLet emptyFM "stdin"
"letc=5in((5+4)*let x=2in(c+x))"
Right63
*ParsecI> runParser parseValueLet emptyFM "stdin"
"((letx=2in3+4)*x)"
Right14
Note thatthebrack eting does notaffectthedeÔ¨Ånitions ofthevariables. Forin-
stance, inthelastexample, theuseof‚Äúx‚Äùis,insome sense, outside thescope ofthe
deÔ¨Ånition. However,ourparser doesn‚Äô tnotice this, since itoperates inastrictly left-
to-right fashion. Inorder toÔ¨Åxthisomission, bindings would havetoberemo ved(see
theexercises).
Exer cises
Exer cise9.7Modify theparseValueLet parser,sothat itobeysbracketing .In
ordertodothis, youwill need tochang ethestate tosomething likeFiniteMap
Char[Int] ,wher ethe[Int] isastackofdeÔ¨Ånitions.
156 CHAPTER 9.MONADS
Chapter10
AdvancedTechniques
10.1 Exceptions
10.2 Mutable Arrays
10.3 Mutable Refer ences
10.4 The STMonad
10.5 Concurr ency
10.6 Regular Expr essions
10.7 Dynamic Types
157
158 CHAPTER 10.ADVANCEDTECHNIQ UES
AppendixA
BriefComplexity Theory
Comple xityTheory isthestudy ofhowlong aprogram willtaketorun,depending on
thesizeofitsinput. There aremanygood introductory books tocomple xitytheory and
thebasics areexplained inanygood algorithms book. I‚Äôllkeepthediscussion here to
aminimum.
Theidea istosayhowwell aprogram scales with more data. Ifyouhaveaprogram
thatruns quickly onverysmall amounts ofdata butchok esonhuge amounts ofdata,
it‚Äôsnotveryuseful (unless youknowyou‚Äôllonly beworking with small amounts of
data, ofcourse). Consider thefollowing Hask ellfunction toreturn thesum ofthe
elements inalist:
sum[]=0
sum(x:xs)=x+sumxs
Howlong does ittakethisfunction tocomplete? That‚Äô saverydifÔ¨Åcult question; it
would depend onallsorts ofthings: your processor speed, your amount ofmemory ,the
exact wayinwhich theaddition iscarried out,thelength ofthelist,howmanyother
programs arerunning onyour computer ,andsoon.This isfartoomuch todealwith, so
weneed toinventasimpler model. Themodel weuseissortofanarbitrary ‚Äúmachine
step.‚ÄùSothequestion is‚Äúhowmanymachine steps will ittakeforthisprogram to
complete?‚Äù Inthiscase, itonly depends onthelength oftheinput list.
Iftheinput listisoflength 0,thefunction willtakeeither 0or1or2orsome very
small number ofmachine steps, depending exactly onhowyoucount them (perhaps 1
steptodothepattern matching and1more toreturn thevalue0).What ifthelistisof
length 1.Well,itwould takehowevermuch time thelistoflength 0would take,plus a
fewmore steps fordoing theÔ¨Årst(and only element).
Iftheinput listisoflength n,itwilltakehowevermanysteps anempty listwould
take(call thisvaluey)andthen, foreach element itwould takeacertain number of
steps todotheaddition andtherecursi vecall(call thisnumber x).Then, thetotal time
thisfunction will takeisnx+ysince itneeds todothose additions nmanytimes.
These xandyvalues arecalled constant values ,since theyareindependent ofn,and
actually dependent only onexactly howwedeÔ¨Åne amachine step, sowereally don‚Äôt
159
160 APPENDIX A.BRIEFCOMPLEXITY THEORY
wanttoconsider them allthatimportant. Therefore, wesaythatthecomple xityofthis
sum function isO(n)(read ‚Äúorder n‚Äù).Basically saying something isO(n)means that
forsome constant factors xandy,thefunction takesnx+ymachine steps tocomplete.
Consider thefollowing sorting algorithm forlists (commonly called ‚Äúinsertion
sort‚Äù):
sort[]=[]
sort[x]=[x]
sort(x:xs)=insert(sortxs)
whereinsert[]=[x]
insert(y:ys)|x<=y=x:y:ys
|otherwise =y:insertys
Thewaythisalgorithm works isasfollow:ifwewanttosortanempty listoralist
ofjustoneelement, wereturn them astheyare,astheyarealready sorted. Otherwise,
wehavealistoftheformx:xs .Inthiscase, wesortxsandthen wanttoinsertx
intheappropriate location. That‚Äô swhat theinsert function does. Ittraverses the
now-sorted tailandinsertsxwhere veritnaturally Ô¨Åts.
Let‚Äôsanalyze howlong thisfunction takestocomplete. Suppose ittakesf(n)stepts
tosortalistoflength n.Then, inorder tosortalistofn-man yelements, weÔ¨Årsthave
tosortthetailofthelistÔ¨Årst, which takesf(n 1)time. Then, wehavetoinsertxinto
thisnewlist.Ifxhastogoattheend, thiswilltakeO(n 1)=O(n)steps. Putting
allofthistogether ,weseethatwehavetodoO(n)amount ofworkO(n)manytimes,
which means thattheentire comple xityofthissorting algorithm isO(n2).Here, the
squared isnotaconstant value, sowecannot throwitout.
What does thismean? Simply thatforreally long lists, thesum function won‚Äôttake
verylong, butthatthesort function willtakequite some time. Ofcourse there are
algorithms thatrunmuch more slowlythatsimply O(n2)andthere areones thatrun
more quickly thanO(n).
Consider therandom access functions forlists andarrays. Intheworstcase, ac-
cessing anarbitrary element inalistoflength nwill takeO(n)time (think about
accessing thelastelement). Howeverwith arrays, youcanaccess anyelement imme-
diately ,which issaidtobeinconstant time, orO(1),which isbasically asfastanany
algorithm cango.
There‚Äô smuch more incomple xity theory than this, butthisshould beenough to
allowyoutounderstand allthediscussions inthistutorial. Justkeepinmind thatO(1)
isfaster thanO(n)isfaster thanO(n2),etc.
AppendixB
Recursion andInduction
Informally ,afunction isrecursi veifitsdeÔ¨Ånition depends onitself. Theprototypical
example isfactorial, whose deÔ¨Ånition is:
fact(n)=
1 n=0
nfact(n 1)n>0
Here, wecanseethatinorder tocalculate fact(5),weneed tocalculate fact(4),
butinorder tocalculate fact(4),weneed tocalculate fact(3),andsoon.
Recursi vefunction deÔ¨Ånitions alwayscontain anumber ofnon-recursi vebase cases
andanumber ofrecursi vecases. Inthecase offactorial, wehaveoneofeach. The
base case iswhenn=0andtherecursi vecase iswhenn>0.
One canactually think ofthenatural numbers themselv esasrecursi ve(infact,if
youasksettheorists about this, they‚Äôllsaythisishowitis).That is,there isazero
element andthen foreveryelement, ithasasuccessor .That is1=succ(0);2=
succ(1);:::;573=succ(573);:::andsoonforever.Wecanactually implement this
system ofnatural numbers inHask ell:
dataNat=Zero|SuccNat
This isarecursi vetype deÔ¨Ånition. Here, werepresent oneasSuccZero and
three asSucc(Succ(SuccZero)) .One thing wemight wanttodoisbeable
toconvertback andforth beweenNatsandInts.Clearly ,wecanwrite abase case as:
natToInt Zero=0
Inorder towrite therecursi vecase, werealize thatwe‚Äôregoing tohavesomething
oftheformSuccn.Wecanmaketheassumption thatwe‚Äôllbeable totakenand
produce anInt.Assuming wecandothis, allweneed todoisaddonetothisresult.
This givesrisetoourrecursi vecase:
natToInt (Succn)=natToInt n+1
161
162 APPENDIX B.RECURSION ANDINDUCTION
There isaclose connection between recursion andmathematical induction. Induc-
tion isaproof technique which typically breaks problems downinto base cases and
‚Äúinducti ve‚Äùcases, veryanalogous toouranalysis ofrecursion.
Let‚Äôssaywewanttoprovethestatement n!nforalln0.First weformulate
abase case: namely ,wewish toprovethestatement whenn=0.When n=0,n!=1
bydeÔ¨Ånition. Sincen!=1>0=n,wegetthat0!0asdesired.
Now,suppose thatn>0.Thenn=k+1forsome valuek.Wenowinvokethe
inductive hypothesis andclaim thatthestatement holds forn=k.That is,weassume
thatk!k.Now,weusektoformate thestatement forourvalue ofn.That is,n!n
ifandonly iff(k+1)!(k+1).Wenowapply thedeÔ¨Ånition offactorial andget
(k+1)!=(k+1)k!.Now,weknowk!k,so(k+1)k!k+1ifandonly if
k+11.Butweknowthatk0,which means k+11.Thus itisproven.
Itmay seem abitcounter -intuiti vethatweareassuming thattheclaim istruefork
inourproof thatitistrueforn.Youcanthink ofitlikethis: we‚Äôveprovedthestatement
forthecase whenn=0.Now,weknowit‚Äôstrueforn=0sousing thisweuseour
inducti veargument toshowthatit‚Äôstrueforn=1.Now,weknowthatitistruefor
n=1sowereuse ourinducti veargument toshowthatit‚Äôstrueforn=2.Wecan
continue thisargument aslong aswewantandthen seethatit‚Äôstrueforalln.
It‚Äôsmuch likepushing downdominoes. Youknowthatwhen youpush downthe
Ô¨Årstdomino, it‚Äôsgoing toknock overthesecond one. This, inturnwillknock overthe
third, andsoon.Thebase case islikepushing downtheÔ¨Årstdomino, andtheinducti ve
case islikeshowing thatpushing downdomino kwillcause thek+1stdomino tofall.
Infact,wecanuseinduction toprovethatournatToInt function does theright
thing. First weprovethebase case: doesnatToInt Zero evaluate to0?Yes,obvi-
ously itdoes. Now,wecanassume thatnatToInt nevaluates tothecorrect value
(this istheinducti vehypothesis) andaskwhethernatToInt (Succn)produces
thecorrect value. Again,itisobvious thatitdoes, bysimply looking atthedeÔ¨Ånition.
Let‚Äôsconsider amore comple xexample: addition ofNats.Wecanwrite thiscon-
cisely as:
addNatZerom=m
addNat(Succn)m=addNatn(Succm)
Now,let‚Äôsprovethatthisdoes thecorrect thing. First, asthebase case, suppose the
Ô¨Årstargument isZero .Weknowthat0+m=mregardless ofwhatmis;thus inthe
base case thealgorithm does thecorrect thing. Now,suppose thataddNatnmdoes
thecorrect thing forallmandwewanttoshowthataddNat(Succn)mdoes the
correct thing. Weknowthat(n+1)+m=n+(m+1)andthus sinceaddNat
n(Succm)does thecorrect thing (bytheinducti vehypothesis), ourprogram is
correct.
AppendixC
Solutions ToExercises
Solution3.1
Itbinds more tightly; actually ,function application binds more tightly than anything
else. Toseethis, wecandosomething like:
Prelude> sqrt3*3
5.19615
Ifmultiplication bound more tightly ,theresult would havebeen 3.
Solution3.2
Solution:snd(fst((1,‚Äôa‚Äô),"foo")) .This isbecause Ô¨Årstwewanttotake
theÔ¨Årsthalfthethetuple:(1,‚Äôa‚Äô) andthen outofthiswewanttotakethesecond
half, yielding just‚Äôa‚Äô.
Ifyoutriedfst(snd((1,‚Äôa‚Äô),"foo")) youwillhavegotten atype error .
This isbecause theapplication ofsnd willleaveyouwithfst"foo" .However,the
string ‚Äúfoo‚Äù isn‚Äôtatuple, soyoucannot applyfst toit.
Solution3.3
Solution: map Char .isLo wer‚ÄùaBCde‚Äù
Solution3.4
Solution: length (Ô¨Ålter Char .isLo wer‚ÄùaBCde‚Äù)
Solution3.5
foldr max 0[5,10,2,8,1]. Youcould also usefoldl. Thefoldr case iseasier toexplain:
wereplace each cons with anapplication ofmax andtheempty listwith 0.Thus, the
inner -most application willtakethemaximum of0andthelastelement ofthelist(if
itexists). Then, thenext-most inner application will return themaximum ofwhat-
everwasthemaximum before andthesecond-to-last element. This willcontinue on,
carrying tocurrent maximum allthewayback tothebeginning ofthelist.
163
164 APPENDIX C.SOLUTIONS TOEXERCISES
Inthefoldl case, wecanthink ofthisaslooking ateach element inthelistinorder .
Westart offour‚Äústate‚Äù with 0.Wepull offtheÔ¨Årst element andcheck toseeifit‚Äôs
bigger than ourcurrent state. Ifitis,wereplace ourcurrent state with thatnumber and
thecontinue. This happens foreach element andthus eventually returns themaximal
element.
Solution3.6
fst(head (tail[(5,‚Äôb‚Äô),(1, ‚Äôc‚Äô),(6, ‚Äôa‚Äô)]))
Solution3.7
WecandeÔ¨Åne aÔ¨Åbonacci function as:
fib1=1
fib2=1
fibn=fib(n-1)+fib(n-2)
Wecould alsowrite itusing explicit ifstatements, like:
fibn=
ifn==1||n==2
then1
elsefib(n-1)+fib(n-2)
Either isacceptable, buttheÔ¨Årstisperhaps more natural inHask ell.
Solution3.8
WecandeÔ¨Åne:
ab=
a b=1
a+a(b 1) otherwise
And then type outcode:
multa1=a
multab=a+multa(b-1)
Note thatitdoesn‚Äô tmatter thatofaandbwedotherecursion on.Wecould justas
well havedeÔ¨Åned itas:
mult1b=b
multab=b+mult(a-1)b
Solution3.9
WecandeÔ¨Ånemymap as:
165
my_mapf[]=[]
my_mapf(x:xs)=fx:my_mapfxs
Recall thatthemymap function issupposed toapply afunctionftoeveryelement
inthelist.Inthecase thatthelistisempty ,there arenoelements toapply thefunction
to,sowejustreturn theempty list.
Inthecase that thelistisnon-empty ,itisanelementxfollowed byalistxs.
Assuming we‚Äôvealready properly appliedmymap toxs,then allwe‚Äôrelefttodois
applyftoxandthen stick theresults together .This isexactly what thesecond line
does.
Solution3.10
Thecode belowappears inNumbers.hs .Theonly trickyparts aretherecursi vecalls
ingetNums andshowFactorials .
moduleMain
where
importIO
main=do
nums<-getNums
putStrLn ("Thesumis"++show(sumnums))
putStrLn ("Theproduct is"++show(product nums))
showFactorials nums
getNums =do
putStrLn "Givemeanumber(or0tostop):"
num<-getLine
ifreadnum==0
thenreturn[]
elsedorest<-getNums
return((readnum::Int):rest)
showFactorials []=return()
showFactorials (x:xs)=do
putStrLn (showx++"factorial is"++
show(factorial x))
showFactorials xs
factorial 1=1
factorial n=n*factorial (n-1)
Theidea forgetNums isjustasspelled outinthehint. ForshowFactorials ,
weconsider Ô¨Årst therecursi vecall. Suppose wehavealistofnumbers, theÔ¨Årst of
166 APPENDIX C.SOLUTIONS TOEXERCISES
which isx.First weprint outthestring showing thefactorial. Then weprint outthe
rest, hence therecursi vecall. Butwhat should wedointhecase oftheempty list?
Clearly wearedone, sowedon‚Äôtneed todoanything atall,sowesimplyreturn
().
Note thatthismust bereturn()instead ofjust()because ifwesimply wrote
showFactorials []=()then thiswouldn‚Äô tbeanIOaction, asitneeds tobe.
Formore clariÔ¨Åcation onthis, youshould probably justkeepreading thetutorial.
Solution4.1 1.
String or[Char]
2.type error: listsarehomogenous
3.Num a)(a;Char)
4.Int
5.type error: cannot addvalues ofdifferent types
Solution4.2
Thetypes:
1.(a;b) >b
2.[a] >a
3.[a] >Bool
4.[a] >a
5.[[a]] >a
Solution4.3
Thetypes:
1.a >[a].This function takesanelement andreturns thelistcontaining only that
element.
2.a >b >b >(a;[b]).Thesecond andthird argument must beofthesame
type, since theygointothesame list.TheÔ¨Årstelement canbeofanytype.
3.Num a=>a >a.Since weapply(+) toa,itmust beaninstance ofNum .
4.a >String .This ignores theÔ¨Årstargument, soitcanbeanytype.
5.(Char >a) >a.Inthisexpression,xmust beafunction which takesaChar
asanargument. Wedon‚Äôtknowanything about what itproduces, though, sowe
callita.
167
6.Typeerror .Here, weassumexhastypea.Butxisapplied toitself, soitmust
havetypeb >c.Butthen itmust havetype(b >c) >c,butthen itmust
havetype((b >c) >c) >candsoon,leading toaninÔ¨Ånite type.
7.Num a=>a >a.Again,since weapply(+),thismust beaninstance of
Num .
Solution4.4
ThedeÔ¨Ånitions willbesomething like:
dataTripleabc=Tripleabc
tripleFst (Triple xyz)=x
tripleSnd (Triple xyz)=y
tripleThr (Triple xyz)=z
Solution4.5
Thecode, with type signatures, is:
dataQuadruple ab=Quadruple aabb
firstTwo ::Quadruple ab->[a]
firstTwo (Quadruple xyzt)=[x,y]
lastTwo ::Quadruple ab->[b]
lastTwo (Quadruple xyzt)=[z,t]
Wenote here that there areonly twotype variables,aandbassociated with
Quadruple .
Solution4.6
Thecode:
dataTupleabcde=Onea
|Twoab
|Threeabc
|Fourabcd
tuple1(Onea)=Justa
tuple1(Twoab)=Justa
tuple1(Threeabc)=Justa
tuple1(Fourabcd)=Justa
tuple2(Onea)=Nothing
tuple2(Twoab)=Justb
tuple2(Threeabc)=Justb
168 APPENDIX C.SOLUTIONS TOEXERCISES
tuple2(Fourabcd)=Justb
tuple3(Onea)=Nothing
tuple3(Twoab)=Nothing
tuple3(Threeabc)=Justc
tuple3(Fourabcd)=Justc
tuple4(Onea)=Nothing
tuple4(Twoab)=Nothing
tuple4(Threeabc)=Nothing
tuple4(Fourabcd)=Justd
Solution4.7
Thecode:
fromTuple (Onea)=Left(Lefta )
fromTuple (Twoab)=Left(Right(a,b) )
fromTuple (Threeabc)=Right(Left(a,b,c) )
fromTuple (Fourabcd)=Right(Right(a,b,c,d))
Here, weuseembeddedEither storepresent thefactthatthere arefour (instead
oftwo)options.
Solution4.8
Thecode:
listHead (Consxxs)=x
listTail (Consxxs)=xs
listFoldl fyNil=y
listFoldl fy(Consxxs)=listFoldl f(fyx)xs
listFoldr fyNil=y
listFoldr fy(Consxxs)=fx(foldrfzxs)
Solution4.9
Thecode:
elements (Leafx)=[x]
elements (Branch lhsxrhs)=
elements lhs++[x]++elements rhs
Solution4.10
Thecode:
169
foldTree ::(a->b->b)->b->BinaryTree a->b
foldTree fz(Leafx)=fxz
foldTree fz(Branch lhsxrhs)=
foldTree f(fx(foldTree fzrhs))lhs
elements2 =foldTree (:)[]
or:
elements2 tree=foldTree (\ab->a:b)[]tree
TheÔ¨Årstelements2 issimply amore compact version ofthesecond.
Solution4.11
Itmimicks neither exactly .It‚Äôsbehavior most closely resemblesfoldr ,butdiffers
slightly initstreatment oftheinitial value. Wecanobserv ethedifference inaninter-
preter:
CPS>foldr(-)0[1,2,3]
2
CPS>foldl(-)0[1,2,3]
-6
CPS>fold(-)0[1,2,3]
-2
Clearly itbehavesdifferently .Bywriting downthederivations offold andfoldr
wecanseeexactly where theydiverge:
foldr(-)0[1,2,3]
==>1-foldr(-)0[2,3]
==>...
==>1-(2-(3-foldr(-)0[]))
==>1-(2-(3-0))
==>2
fold(-)0[1,2,3]
==>fold‚Äô(-)(\y->0-y)[1,2,3]
==>0-fold‚Äô(-)(\y->1-y)[2,3]
==>0-(1-fold‚Äô(-)(\y->2-y)[3])
==>0-(1-(2-3))
==>-2
Essentially ,theprimary difference isthatinthefoldr case, the‚Äúinitial value‚Äù is
used attheend(replacing[]),whereas intheCPS case, theinitial value isused atthe
beginning.
170 APPENDIX C.SOLUTIONS TOEXERCISES
Solution4.12
Solution5.1
Using if,wegetsomething like:
main=do
putStrLn "Please enteryourname:"
name<-getLine
ifname=="Simon" ||name=="John"||name=="Phil"
thenputStrLn "Haskell isgreat!"
elseifname=="Koen"
thenputStrLn "Debugging Haskell isfun!"
elseputStrLn "Idon‚Äôtknowwhoyouare."
Note thatwedon‚Äôtneed torepeat thedosinside theifs,since these areonly one
action commands.
Wecould alsobeabitsmarter andusetheelem command which isbuiltintothe
Prelude:
main=do
putStrLn "Please enteryourname:"
name<-getLine
ifname‚Äòelem‚Äò["Simon", "John", "Phil"]
thenputStrLn "Haskell isgreat!"
elseifname=="Koen"
thenputStrLn "Debugging Haskell isfun!"
elseputStrLn "Idon‚Äôtknowwhoyouare."
Ofcourse, weneedn‚Äô tputalltheputStrLn sinside theifstatements. Wecould
instead write:
main=do
putStrLn "Please enteryourname:"
name<-getLine
putStrLn
(ifname‚Äòelem‚Äò["Simon", "John", "Phil"]
then"Haskell isgreat!"
elseifname=="Koen"
then"Debugging Haskell isfun!"
else"Idon‚Äôtknowwhoyouare.")
Using case,wegetsomething like:
171
main=do
putStrLn "Please enteryourname:"
name<-getLine
casenameof
"Simon" ->putStrLn "Haskell isgreat!"
"John" ->putStrLn "Haskell isgreat!"
"Phil" ->putStrLn "Haskell isgreat!"
"Koen" ->putStrLn "Debugging Haskell isfun!"
_ ->putStrLn "Idon‚Äôtknowwhoyouare."
Which, inthiscase, isactually notmuch cleaner .
Solution5.2
Thecode might look something like:
moduleDoFilewhere
importIO
main=do
putStrLn "Doyouwantto[read]afile,...?"
cmd<-getLine
casecmdof
"quit" ->return()
"read" ->dodoRead; main
"write" ->dodoWrite; main
_ ->doputStrLn
("Idon‚Äôtunderstand thecommand "
++cmd++".")
main
doRead=do
putStrLn "Enterafilenametoread:"
fn<-getLine
bracket (openFile fnReadMode) hClose
(\h->dotxt<-hGetContents h
putStrLn txt)
doWrite =do
putStrLn "Enterafilenametowrite:"
fn<-getLine
bracket (openFile fnWriteMode) hClose
(\h->doputStrLn
"Entertext(...):"
172 APPENDIX C.SOLUTIONS TOEXERCISES
writeLoop h)
writeLoop h=do
l<-getLine
ifl=="."
thenreturn()
elsedohPutStrLn hl
writeLoop h
Theonly interesting things here arethecalls tobracket ,which ensure thethatthe
program liveson,regardless ofwhether there‚Äô safailure ornot;andthewriteLoop
function. Note that weneed topass thehandle returned byopenFile (through
bracket tothisfunction, soitknowswhere towrite theinput to).
Solution7.1
Functionfunc3 cannot beconverted intopoint-free style. Theothers look something
like:
func1x=map(*x)
func2fg=filterf.mapg
func4=map(+2).filter(‚Äòelem‚Äò [1..10]) .(5:)
func5=foldr(uncurry $flipf)0
Youmight havebeen tempted totrytowritefunc2 asfilterf.map,
trying toeta-reduce offtheg.Inthiscase, thisisn‚Äôtpossible. This isbecause the
function composition operator (.)hastype(b!c)!(a!b)!(a!c).Inthis
case, we‚Äôretrying tousemap asthesecond argument. Butmap takestwoarguments,
while(.) expects afunction which takesonly one.
Solution7.2
Wecanstart outwith arecursi vedeÔ¨Ånition:
and[]=True
and(x:xs)=x&&andxs
From here, wecanclearly rewrite thisas:
and=foldr(&&)True
Solution7.3
Wecanwrite thisrecursi velyas:
173
concatMap f[]=[]
concatMap f(x:xs)=fx++concatMap fxs
This hints thatwecanwrite thisas:
concatMap f=foldr(\ab->fa++b)[]
Now,wecandopoint elimination toget:
foldr(\ab->fa++b)[]
==>foldr(\ab->(++)(fa)b)[]
==>foldr(\a->(++)(fa))[]
==>foldr(\a->((++).f)a)[]
==>foldr((++).f)[]
Solution9.1
TheÔ¨Årstlawis:returna>>=ffa.Inthecase ofMaybe,weget:
returna>>=f
==>Justa>>=\x->fx
==>(\x->fx)a
==>fa
Thesecond lawis:f>>=return f.Here, weget:
f>>=return
==>f>>=\x->returnx
==>f>>=\x->Justx
Atthispoint, there aretwocases depending onwhetherfisNothing ornot. In
theÔ¨Årstcase, weget:
==>Nothing >>=\x->Justx
==>Nothing
==>f
Inthesecond case,fisJusta.Then, weget:
==>Justa>>=\x->Justx
==>(\x->Justx)a
==>Justa
==>f
174 APPENDIX C.SOLUTIONS TOEXERCISES
And thesecond lawisshown. Thethird lawstates:f>>=(nx->gx>>=
h)(f>>=g)>>=h.
IffisNothing ,then theleft-hand-side clearly reduces toNothing .Theright-
hand-side reduces toNothing >>=hwhich inturn reduces toNothing ,sothey
arethesame.
SupposefisJusta.Then theLHS reduces toga>>=handtheRHS re-
duces to(Justa>>=nx->gx)>>=hwhich inturnreduces toga>>=
h,sothese twoarethesame.
Solution9.2
Theidea isthatwewish tousetheLeft constructor torepresent errors ontheRight
constructor torepresent successes. This leads toaninstance declaration like:
instance Monad(Either String) where
returnx=Rightx
Lefts>>=_=Lefts
Rightx>>=f=fx
fails =Lefts
Ifwetrytousethismonad todosearch, weget:
Monads> searchAll gr03::EitherString[Int]
Right[0,1,3]
Monads> searchAll gr30::EitherString[Int]
Left"nopath"
which isexactly what wewant.
Solution9.3
Theorder tomplus essentially determins thesearch order .When therecursi vecallto
searchAll2 comes Ô¨Årst, wearedoing depth-Ô¨Årst search. When therecursi vecallto
search‚Äô comes Ô¨Årst, wearedoing breadth-Ô¨Årst search. Thus, using thelistmonad,
weexpect thesolutions tocome intheother order:
MPlus>searchAll3 gr03::[[Int]]
[[0,2,3],[0,1,3]]
Justasweexpected.
Solution9.4
This isaverydifÔ¨Åcult problem; ifyoufound thatyouwere stuck immediately ,please
justread asmuch ofthissolution asyouneed totryityourself.
First, weneed todeÔ¨Åne alisttransformer monad. This looks like:
175
newtype ListTme=ListT{unListT ::m[e]}
TheListT constructor simply wraps amonadic action (inmonadm)which returns
alist.
Wenowneed tomakethisamonad:
instance Monadm=>Monad(ListTm)where
returnx=ListT(return [x])
fails=ListT(return [])
ListTm>>=k=ListT$do
l<-m
l‚Äô<-mapM(unListT .k)l
return(concat l‚Äô)
Here, success isdesignated byamonadic action which returns asingleton list.
Failure (likeinthestandard listmonad) isrepresented byanempty list:ofcourse, it‚Äôs
actually anempty listreturned from theenclosed monad. Binding happens essentially
byrunning theaction which willresult inalistl.This hastype[e].Wenowneed
toapplyktoeach ofthese elements (which willresult insomething oftypeListTm
[e2] .Weneed togetridoftheListT saround this(byusingunListT )andthen
concatenate them tomakeasingle list.
Now,weneed tomakeitaninstance ofMonadPlus
instance Monadm=>MonadPlus (ListTm)where
mzero=ListT(return [])
ListTm1‚Äòmplus‚Äò ListTm2=ListT$do
l1<-m1
l2<-m2
return(l1++l2)
Here, thezero element isamonadic action which returns anempty list.Addition is
done byexecuting both actions andthen concatenating theresults.
Finally ,weneed tomakeitaninstance ofMonadT rans :
instance MonadTrans ListTwhere
liftx=ListT(doa<-x;return[a])
Lifting anaction intoListT simply involvesrunning itandgetting thevalue (in
thiscase,a)outandthen returning thesingleton list.
Once wehaveallthistogether ,writingsearchAll6 isfairly straightforw ard:
searchAll6 g@(Graph vlel)srcdst
|src==dst=do
lift$putStrLn $
176 APPENDIX C.SOLUTIONS TOEXERCISES
"Exploring "++showsrc++"->"++showdst
return[src]
|otherwise =do
lift$putStrLn $
"Exploring "++showsrc++"->"++showdst
search‚Äô el
where
search‚Äô []=mzero
search‚Äô ((u,v,_):es)
|src==u=
(dopath<-searchAll6 gvdst
return(u:path)) ‚Äòmplus‚Äò
search‚Äô es
|otherwise =search‚Äô es
Theonly change (besides changing therecursi vecalltocallsearchAll6 instead
ofsearchAll2 )here isthatwecallputStrLn with appropriate arguments, lifted
intothemonad.
Ifwelook atthetype ofsearchAll6 ,weseethattheresult (i.e., after applying a
graph andtwoints) hastypeMonadTrans t,MonadPlus (tIO)=>tIO
[Int]) .Intheory ,wecould usethiswith anyappropriate monad transformer; inour
case, wewanttouseListT .Thus, wecanrunthisby:
MTrans> unListT (searchAll6 gr03)
Exploring 0->3
Exploring 1->3
Exploring 3->3
Exploring 2->3
Exploring 3->3
MTrans> it
[[0,1,3],[0,2,3]]
This isprecisely what wewere looking for.
Solution9.5
This exercise isactually simpler than theprevious one. Allweneed todoisincorporate
thecalls toputT andgetT intosearchAll6 andaddanextralifttotheIOcalls.
This extraliftisrequired because nowwe‚Äôrestacking twotransformers ontopofIO
instead ofjustone.
searchAll7 g@(Graph vlel)srcdst
|src==dst=do
lift$lift$putStrLn $
"Exploring "++showsrc++"->"++showdst
visited <-getT
177
putT(src:visited)
return[src]
|otherwise =do
lift$lift$putStrLn $
"Exploring "++showsrc++"->"++showdst
visited <-getT
putT(src:visited)
ifsrc‚Äòelem‚Äòvisited
thenmzero
elsesearch‚Äô el
where
search‚Äô []=mzero
search‚Äô ((u,v,_):es)
|src==u=
(dopath<-searchAll7 gvdst
return(u:path)) ‚Äòmplus‚Äò
search‚Äô es
|otherwise =search‚Äô es
Thetype ofthishasgrownsigniÔ¨Åcantly .After applying thegraph andtwoints, this
hastypeMonad(tIO),MonadTrans t,MonadPlus (StateT [Int]
(tIO))=>StateT[Int](tIO)[Int] .
Essentially thismeans thatwe‚Äôvegotsomething that‚Äôsastate transformer wrapped
ontopofsome other arbitrary transformer (t)which itself sitsontopofIO.Inour
case,tisgoing tobeListT .Thus, werunthisbeast bysaying:
MTrans> unListT (evalStateT (searchAll7 gr403)[])
Exploring 0->3
Exploring 1->3
Exploring 3->3
Exploring 0->3
Exploring 2->3
Exploring 3->3
MTrans> it
[[0,1,3],[0,2,3]]
And itworks, evenongr4.
Solution9.6
First wewrite afunctionspaces which willparse outwhitespaces:
spaces::Parser()
spaces=many(matchChar isSpace) >>return()
Now,using this, wesimply sprinkle calls tospaces throughintList toget
intListSpace :
178 APPENDIX C.SOLUTIONS TOEXERCISES
intListSpace ::Parser[Int]
intListSpace =do
char‚Äô[‚Äô
spaces
intList‚Äô ‚Äòmplus‚Äò (char‚Äô]‚Äô>>return[])
whereintList‚Äô =do
i<-int
spaces
r<-(char‚Äô,‚Äô>>spaces>>intList‚Äô)
‚Äòmplus‚Äò
(char‚Äô]‚Äô>>return[])
return(i:r)
Wecantestthatthisworks:
Parsing> runParser intListSpace "[1,2,4\n\n,5\n]"
Right("",[1,2,4,5])
Parsing> runParser intListSpace "[1,2,4\n\n,a\n]"
Left"expecting char,got‚Äôa‚Äô"
Solution9.7
Wedothisbyreplacing thestate functions with push andpopfunctions asfollows:
parseValueLet2 ::CharParser (FiniteMap Char[Int])Int
parseValueLet2 =choice
[int
,dostring"let"
c<-letter
char‚Äô=‚Äô
e<-parseValueLet2
string"in"
pushBinding ce
v<-parseValueLet2
popBinding c
returnv
,doc<-letter
fm<-getState
caselookupFM fmcof
Nothing ->unexpected ("variable "++
showc++
"unbound")
Just(i:_)->returni
,between (char‚Äô(‚Äô)(char‚Äô)‚Äô)$do
e1<-parseValueLet2
179
op<-oneOf"+*"
e2<-parseValueLet2
caseopof
‚Äô+‚Äô->return(e1+e2)
‚Äô*‚Äô->return(e1*e2)
]
where
pushBinding cv=do
fm<-getState
caselookupFM fmcof
Nothing ->setState (addToFM fmc[v])
Justl->setState (addToFM fmc(v:l))
popBinding c=do
fm<-getState
caselookupFM fmcof
Just[_]->setState (delFromFM fmc)
Just(_:l)->setState (addToFM fmcl)
Theprimary difference here isthatinstead ofcallingupdateState ,weusetwo
local functions,pushBinding andpopBinding .ThepushBinding function
takesavariable name andavalue andadds thevalue onto thehead ofthelistpointed to
inthestateFiniteMap .ThepopBinding function looks atthevalue andifthere is
only oneelement onthestack, itcompletely remo vesthestack from theFiniteMap ;
otherwise itjustremo vestheÔ¨Årst element. This means that ifsomething isinthe
FiniteMap ,thestack isneverempty .
This enables ustomodify only slightly theusage case; thistime, wesimply take
thetopelement offthestack when weneed toinspect thevalue ofavariable.
Wecantestthatthisworks:
ParsecI> runParser parseValueLet2 emptyFM "stdin"
"((letx=2in3+4)*x)"
Left"stdin" (line1,column20):
unexpected variable ‚Äôx‚Äôunbound
Index
(),87
,32
+,32
++,38
 ,32
  ,52
.,50
::,140
=,32
==,144
:,36
::,65
==,65
[],36
ÀÜ,32
 E30F,72
,72
f  g ,52
,122
as,111
derive,134
do,57
hiding ,111
import ,110
qualiÔ¨Åed ,110
accumArray ,143
actions, 95‚Äì100
arithmetic, 32‚Äì34
array ,143
arrays, 143‚Äì145
assocs ,144
Bird scripts, 113
boolean, 66
bounds ,144
bracket ,101brack ets,36
buffering, 58
comments, 52‚Äì53
common sub-e xpression, 117
Compilers, seeGHC,NHC,Interpreters
concatenate, 38
cons, 36
constructors, 81
continuation passing style, 87‚Äì90
CPS, seecontinuation passing style
destructi veupdate, 31
donotation, 173‚Äì176
donotation, 57
drop ,140
Editors, 27‚Äì28
Emacs, 27
elems ,144
Enum, 131‚Äì132
enumerated types, 84
enumFromThenTo ,141
enumFromTo ,141
Eq,127‚Äì129
equality ,65
equals, 70
evaluation order ,32
exceptions, 182
exports, 107‚Äì110
expressions, 32
extensions
enabling
inGHC, 25
inHugs, 23
fallthrough, 123
false, seeboolean
180
INDEX 181
Ô¨Åles, 42‚Äì44
filter ,38,138
FiniteMap, 145‚Äì147
foldl ,38,139
foldr ,38,138
fst,35
functional, 3
functions, 44‚Äì52
anon ymous, seelambda
asarguments, 78‚Äì80
associati ve,40
composition, 50
type, 71‚Äì80
getChar ,101
getContents ,101
getLine ,58,101
GHC, 19,23‚Äì26
guards, 125‚Äì127
Hask ell98,8
Hask ellBookshelf, 7
hClose ,101
head ,37,74
hGetChar ,101
hGetContents ,101
hGetLin ,101
hIsEOF ,101
hPutChar ,101
hPutStr ,101
hPutStrLn ,101
Hugs, 19‚Äì23
ICFP ,9
immutable, 31
imports, 110‚Äì111
indices ,144
induction, 54
inÔ¨Åx, 75,115‚Äì116
input, seeIO
instance, 67
interacti veprograms, 56‚Äì63
Interpreters, seeGHC,Hugs
IO,91‚Äì106
library ,100‚Äì103
isLower ,38lambda, 72
lambda calculus, 72
LaTeXscripts, 114
layout, 147
lazy,2,29
length ,37,79
let
anddo,175
list
comprehensions, 143
listArray ,143
lists, 35‚Äì42, 137‚Äì143
comprehensions, 140
cons, 36
empty ,36
literate style, 112‚Äì114
local bindings, 117
loop, 53
map,38,138
maps, 145‚Äì147
Maybe, 85‚Äì87
modules, 107‚Äì114
hierarchical, 111‚Äì112
monads, 94
anddo,173‚Äì176
deÔ¨Ånition of,170‚Äì173
laws,171
plus, 181
state, 176‚Äì181
transformer ,181
mutable, seeimmutable
named Ô¨Åelds, 135‚Äì137
NHC, 19,26‚Äì27
null ,74
Num, 132
numeric types, 70
openFile ,101
operator precedence, 33
Ord, 130‚Äì131
output, seeIO
pairs, seetuples
parentheses, 33
182 INDEX
pattern matching, 82,119‚Äì125
pure, 2
putChar ,101
putStr ,101
putStrLn ,44,101
random numbers, 59
randomRIO ,59
Read, 132‚Äì133
read ,38
readFile ,101
recursion, 53‚Äì56
referential tranparenc y,31
robot, 9
sections, 115‚Äì116
shado wing, 117
Show,129‚Äì130
show ,38,71
snd,35
sqrt ,32
standard, 8
state, 2
strict, 2,152‚Äì155
strings, 37‚Äì38
converting from/to, 38
tail ,37,74
take ,140
toUpper ,38
true, seeboolean
tuples, 34‚Äì35
type, 64,168
checking, 64
classes, 69‚Äì71, 155‚Äì162
instances, 127‚Äì134, 162‚Äì165
datatypes, 80‚Äì87, 134‚Äì137, 152‚Äì
155
strict, 152‚Äì155
default, 168
errors, 66
explicit declarations, 77‚Äì78
hierarch y,168
higher -order ,73‚Äì75
inference, 64
IO,75‚Äì77kinds, 165‚Äì168
newtype, 149‚Äì152
polymorphic, 67‚Äì69
signatures, 77
synon yms, 101, 148‚Äì149
Unit, 87
unzip ,139
user input, seeinteracti veprograms
wildcard, 122
writeFile ,101
zip,139

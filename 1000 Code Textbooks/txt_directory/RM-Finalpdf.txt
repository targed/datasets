Ada Reference Manual , 2012 Edition  
  
     
  
   
    
       
  
 
Ada Reference Manual  
  
2012 Edition  
  
  
Language and Standard Libraries  
  
       
Copyright © 1992, 1993, 1994, 1995  Intermetrics, Inc. Copyright © 2000  The MITRE Corporation, Inc. Copyright © 2004, 2005, 2006  AXE Consultants Copyright © 2004, 2005, 2006  Ada-Europe Copyright © 2008, 2009, 2010, 2011, 2012  AXE Consultants  
  
     
Ada Reference Manual - Language and Standard Libraries  
Copyright © 1992, 1993, 1994, 1995, Intermetrics, Inc. This copyright is assigned to the U. S. Government.  All rights reserved. 
This document may be copied, in whole or in part, in an y form or by any means, as is or with alterations, 
provided that (1) alterations are clearly marked as alterations and (2) this copyright notice is included 
unmodified in any copy. Compiled copies of standard library units and examples need not contain this 
copyright notice so long as the notice is included in all copies of source code and documentation. 
 
  
Technical Corrigendum 1  
Copyright © 2000, The MITRE Corporation.  All Rights Reserved. This document may be copied, in whole or in part, in an y form or by any means, as is, or with alterations, 
provided that (1) alterations are clearly marked as alterations and (2) this copyright notice is included 
unmodified in any copy. Any other use or distributi on of this document is prohibited without the prior 
express permission of MITRE. 
You use this document on the condition that you i ndemnify and hold harmless MITRE, its Board of 
Trustees, officers, agents, and em ployees, from any and all liability or damages to yourself or your 
hardware or software, or third par ties, including attorneys' fees, court costs, and other related costs and 
expenses, arising out of your us e of this document irrespective of the cause of said liability. 
MITRE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO 
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABI LITY, EFFICIENCY 
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT.  IN NO EVENT WILL MITRE BE LIABLE FOR ANY GENERAL, CONSEQUENTIA L, INDIRECT, INCIDENTAL, EXEMPLARY, 
OR SPECIAL DAMAGES, EVEN IF MITRE HAS B EEN ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES. 
  Amendment 1  
Copyright © 2004, 2005, 2006, 2007, AXE C onsultants.  All Rights Reserved. 
This document may be copied, in whole or in part, in an y form or by any means, as is, or with alterations, 
provided that (1) alterations are clearly marked as alterations and (2) this copyright notice is included 
unmodified in any copy. Any other use or distributi on of this document is prohibited without the prior 
express permission of AXE. 
You use this document on the condition that you i ndemnify and hold harmless AXE, its board, officers, 
agents, and employees, from any and all liability or damage s to yourself or your hardware or software, or 
third parties, including attorneys' fees, court costs, a nd other related costs and expenses, arising out of your 
use of this document irrespective of the cause of said liability. 
AXE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO 
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABI LITY, EFFICIENCY 
MERCHANTABILITY, OR FUNCTIONING OF THIS  DOCUMENT. IN NO EVENT WILL AXE BE 
LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL, EXEMPLARY, OR 
SPECIAL DAMAGES, EVEN IF AXE HAS BEEN  ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES. 
Third Edition  
Copyright © 2008, 2009, 2010, 2011, 2012 AXE C onsultants.  All Rights Reserved. 
This document may be copied, in whole or in part, in an y form or by any means, as is, or with alterations, 
provided that (1) alterations are clearly marked as alterations and (2) this copyright notice is included 
unmodified in any copy. Any other use or distributi on of this document is prohibited without the prior 
express permission of AXE. 
You use this document on the condition that you i ndemnify and hold harmless AXE, its board, officers, 
agents, and employees, from any and all liability or damage s to yourself or your hardware or software, or 
third parties, including attorneys' fees, court costs, a nd other related costs and expenses, arising out of your 
use of this document irrespective of the cause of said liability. 
AXE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO 
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABI LITY, EFFICIENCY 
MERCHANTABILITY, OR FUNCTIONING OF THIS  DOCUMENT. IN NO EVENT WILL AXE BE 
LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL, EXEMPLARY, OR 
SPECIAL DAMAGES, EVEN IF AXE HAS BEEN  ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES. 
  Ada 2005 Consolidated Standard  
Copyright © 2004, 2005, 2006, Ada-Europe. This document may be copied, in whole or in part, in an y form or by any means, as is, or with alterations, 
provided that (1) alterations are clearly marked as alterations and (2) this copyright notice is included 
unmodified in any copy. Any other use or distributi on of this document is prohibited without the prior 
express permission of Ada-Europe. 
You use this document on the condition that you inde mnify and hold harmless Ada-Europe and its Board 
from any and all liability or damages to yourself or y our hardware or software, or third parties, including 
attorneys' fees, court costs, and other related costs a nd expenses, arising out of your use of this document 
irrespective of the cause of said liability. 
ADA-EUROPE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO 
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABI LITY, EFFICIENCY 
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL ADA-EUROPE BE LIABLE FOR ANY GENERAL, C ONSEQUENTIAL, INDI RECT, INCIDENTAL, 
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF ADA-EUROPE HAS BEEN ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGES.  

Ada Reference Manual — 2012 Edition 
i      13 December 2012 Table of Contents Table of Contents 
Table of C ontents ............................................................................................................i  
Introduc tion ................................................................................................................... xi 
1   Ge neral.................................................................................................................... ...1 
1.1 Sc ope ...................................................................................................................... .......................1  
1.1.1 Ex tent................................................................................................................... ...................1  
1.1.2 Stru cture................................................................................................................ .................2  
1.1.3 Conformity of an Implem entation with th e Standa rd.........................................................4  
1.1.4 Method of Descripti on and Syntax Notati on.......................................................................5  
1.1.5 Classificati on of E rrors ................................................................................................. ........6  
1.2 Normative Refere nces ....................................................................................................... ...........7  
1.3 Terms and Defini tions ...................................................................................................... ............8  
2   Lexical Elemen ts.......................................................................................................9  
2.1 Charact er Set.............................................................................................................. ...................9  
2.2 Lexical Elements, Sepa rators, and De limiters.........................................................................11  
2.3 Identi fiers ................................................................................................................ .....................12  
2.4 Numeric Literals........................................................................................................... ...............13  
2.4.1 Decima l Literals ......................................................................................................... ..........13  
2.4.2 Based Literals ........................................................................................................... ...........14  
2.5 Character  Literals ......................................................................................................... ..............14  
2.6 String Literals............................................................................................................ ..................15  
2.7 Comme nts................................................................................................................... .................15  
2.8 Prag mas .................................................................................................................... ...................16  
2.9 Reserve d Word s............................................................................................................. .............18  
3   Declarations  and Ty pes..........................................................................................19  
3.1 Declar ations............................................................................................................... ..................19  
3.2 Types a nd Subt ypes ......................................................................................................... ..........20  
3.2.1 Type D eclarat ions........................................................................................................ ........22  
3.2.2 Subtype Declarat ions..................................................................................................... .....23 
3.2.3 Classification of Oper ations............................................................................................. ..24 
3.2.4 Subtype Predi cates ....................................................................................................... ......25  
3.3 Objects and Named Numbers.................................................................................................. ..27 
3.3.1 Object Declarat ions...................................................................................................... .......29  
3.3.2 Number Declarat ions...................................................................................................... .....31 
3.4 Derived Ty pes and Classes .................................................................................................. .....32 
3.4.1 Deriva tion Cl asses ....................................................................................................... ........35  
3.5 Scalar  Types............................................................................................................... .................37  
3.5.1 Enumerat ion Ty pes ........................................................................................................ .....42 
3.5.2 Charact er Types.......................................................................................................... .........43  
3.5.3 Boolean  Types ............................................................................................................ .........44  
3.5.4 Intege r Types ............................................................................................................ ...........44  
3.5.5 Operations of  Discrete Types............................................................................................. 47 
3.5.6 Real  Types............................................................................................................... .............48  
3.5.7 Floating Point Ty pes ..................................................................................................... ......49  
3.5.8 Operations of Fl oating Point Types...................................................................................51  
3.5.9 Fixed Po int Ty pes........................................................................................................ ........51  
3.5.10 Operations of Fixed Point Types .....................................................................................53  
Ada Reference Manual — 2012 Edition 
Table of Contents 13 December 2012      ii 3.6 Array Types ................................................................................................................ ................. 54  
3.6.1 Index Constraints and Discrete Ranges ........................................................................... 57  
3.6.2 Operations of Array Types ................................................................................................ .5 8 
3.6.3 Stri ng Type s............................................................................................................. ............ 59  
3.7 Discrim inants.............................................................................................................. ................ 60  
3.7.1 Discriminan t Constr aints ................................................................................................. .. 62 
3.7.2 Operations of Di scriminated Types .................................................................................. 63  
3.8 Record  Types............................................................................................................... ............... 64  
3.8.1 Variant Parts a nd Discrete Choices .................................................................................. 66  
3.9 Tagged Types and Type Exte nsions ........................................................................................ 68  
3.9.1 Type Extens ions.......................................................................................................... ........ 72  
3.9.2 Dispatching Operati ons of Tagge d Type s........................................................................ 73  
3.9.3 Abstract Typ es and Subpr ograms .................................................................................... 76  
3.9.4 Interf ace Type s.......................................................................................................... .......... 77  
3.10 Access Type s.............................................................................................................. .............. 80  
3.10.1 Incomplete Ty pe Declar ations ......................................................................................... 82  
3.10.2 Operations of Access Ty pes............................................................................................ 85  
3.11 Declarat ive Parts ......................................................................................................... ............. 91  
3.11.1 Completions of  Declarat ions ........................................................................................... 91  
4   Names a nd Expressi ons ........................................................................................93  
4.1 Names...................................................................................................................... .................... 93  
4.1.1 Indexed Compone nts....................................................................................................... ... 94 
4.1.2 S lices ................................................................................................................... ................. 95  
4.1.3 Selected  Compone nts ...................................................................................................... .. 96 
4.1.4 Attr ibutes............................................................................................................... ............... 98  
4.1.5 User-Defin ed Refe rences .................................................................................................. .9 9 
4.1.6 User-Defin ed Ind exing .................................................................................................... .. 100 
4.2 Lite rals ................................................................................................................... .................... 102  
4.3 Aggr egates................................................................................................................. ............... 103  
4.3.1 Record Aggreg ates ........................................................................................................ ... 103  
4.3.2 Extensi on Aggreg ates ..................................................................................................... . 105 
4.3.3 Array Aggreg ates ......................................................................................................... ..... 107  
4.4 Expr essions ................................................................................................................ .............. 110  
4.5 Operators and Ex pression Eval uation ................................................................................... 111  
4.5.1 Logical Operators and S hort-circuit C ontrol Fo rms ..................................................... 112  
4.5.2 Relational Operators and Membership  Tests ................................................................ 113  
4.5.3 Binary Addi ng Operat ors ................................................................................................. 1 17 
4.5.4 Unary Addi ng Operat ors .................................................................................................. 1 18 
4.5.5 Multiplyi ng Operat ors .................................................................................................... ... 118  
4.5.6 Highest Preced ence Operat ors ....................................................................................... 121  
4.5.7 Conditiona l Expr essions.................................................................................................. 122 
4.5.8 Quantifi ed Expr essions ................................................................................................... . 123 
4.6 Type C onversi ons ........................................................................................................... ......... 124  
4.7 Qualifie d Expr essions ...................................................................................................... ........ 129  
4.8 Allo cators ................................................................................................................. ................. 129  
4.9 Static Expressions a nd Static S ubtypes ................................................................................ 132  
4.9.1 Statically Matching C onstraints and Subtyp es.............................................................. 136  
5   Stat ements .............................................................................................................137  
5.1 Simple and Compound Statements  - Sequences of Statemen ts ........................................ 137  
5.2 Assignment Statem ents...................................................................................................... ..... 138  
5.3 If St atemen ts .............................................................................................................. ............... 140  
5.4 Case St atemen ts............................................................................................................ ........... 141  
Ada Reference Manual — 2012 Edition 
iii      13 December 2012 Table of Contents 5.5 Loop Stat ements............................................................................................................ ...........142  
5.5.1 User-Defined Iterator Types .............................................................................................1 44 
5.5.2 Generalized  Loop Iter ation ............................................................................................... 145 
5.6 Block St atemen ts........................................................................................................... ...........147  
5.7 Exit St atemen ts ............................................................................................................ .............147  
5.8 Goto St atemen ts ............................................................................................................ ...........148  
6   Subpr ograms .........................................................................................................151  
6.1 Subprogram Declarat ions.................................................................................................... ....151  
6.1.1 Preconditions a nd Postcondi tions ..................................................................................154  
6.2 Formal Para meter M odes..................................................................................................... ....157  
6.3 Subprogram  Bodi es.......................................................................................................... ........158  
6.3.1 Conforma nce Ru les........................................................................................................ ...159 
6.3.2 Inline Expansi on of Subpr ograms ...................................................................................161  
6.4 Subprogr am Calls ........................................................................................................... ..........161  
6.4.1 Parameter Associat ions................................................................................................... .163 
6.5 Return Statem ents .......................................................................................................... ..........166  
6.5.1 Nonreturni ng Proce dures.................................................................................................1 69 
6.6 Overloading of Operators ................................................................................................... .....170  
6.7 Null Pr ocedur es ............................................................................................................ ............171  
6.8 Expressi on Functi ons ....................................................................................................... .......172  
7   Packages ................................................................................................................173  
7.1 Package Specifications  and Declar ations ..............................................................................173  
7.2 Package Bodi es ............................................................................................................. ...........174  
7.3 Private Types and Private Exte nsions ....................................................................................175  
7.3.1 Private Operat ions....................................................................................................... ......178  
7.3.2 Type Invari ants.......................................................................................................... .........180  
7.4 Deferred Consta nts......................................................................................................... ..........182  
7.5 Limite d Type s.............................................................................................................. ..............183  
7.6 Assignment a nd Finaliz ation ................................................................................................ ...185 
7.6.1 Completion a nd Finalizat ion.............................................................................................1 87 
8   Visibilit y Rule s.......................................................................................................191  
8.1 Declarat ive Re gion......................................................................................................... ...........191  
8.2 Scope of Declarat ions ...................................................................................................... ........192  
8.3 Visibility................................................................................................................. .....................193  
8.3.1 Overridi ng Indicat ors .................................................................................................... ....196  
8.4 Use Clau ses................................................................................................................ ...............197  
8.5 Renaming D eclarat ions...................................................................................................... ......198  
8.5.1 Object Renami ng Declarat ions ........................................................................................198  
8.5.2 Exception Renami ng Declarat ions ..................................................................................200  
8.5.3 Package Renami ng Declarat ions .....................................................................................200  
8.5.4 Subprogram Rena ming Declar ations ..............................................................................201  
8.5.5 Generic Renami ng Declarat ions ......................................................................................203  
8.6 The Context of Ov erload Reso lution ......................................................................................203  
9   Tasks and Sy nchroniza tion .................................................................................207  
9.1 Task Units a nd Task Ob jects................................................................................................ ...207 
9.2 Task Execution - Task Acti vation........................................................................................... .210 
9.3 Task Dependence - Te rmination of  Tasks ..............................................................................211  
9.4 Protected Units and Protected Ob jects..................................................................................213  
9.5 Intertask Co mmunication.................................................................................................... .....216  
9.5.1 Protected Subprograms and Protected  Acti ons ............................................................ 218 
Ada Reference Manual — 2012 Edition 
Table of Contents 13 December 2012      iv 9.5.2 Entries and A ccept Statem ents ....................................................................................... 219  
9.5.3 Entry Calls.............................................................................................................. ............ 222  
9.5.4 Requeue Statem ents....................................................................................................... .. 225 
9.6 Delay Statements, Duration, a nd Time ................................................................................... 226  
9.6.1 Formatting, Time Zones, a nd other operations  for Ti me.............................................. 229  
9.7 Select Statem ents.......................................................................................................... ........... 235  
9.7.1 Select ive A ccept......................................................................................................... ....... 236  
9.7.2 Timed Entry Calls........................................................................................................ ...... 238  
9.7.3 Conditiona l Entry Calls.................................................................................................. ... 239  
9.7.4 Asynchronous Tran sfer of C ontrol ................................................................................. 239  
9.8 Abort of a Task - Abort of  a Sequence of Statemen ts.......................................................... 240  
9.9 Task and Entr y Attributes.................................................................................................. ...... 242  
9.10 Shared Variables .......................................................................................................... .......... 242  
9.11 Example of Tasking and Synchroni zation ........................................................................... 244  
10   Program Structure and Compilati on Issu es ....................................................247  
10.1 Separate Compila tion...................................................................................................... ....... 247  
10.1.1 Compilation Units - Library Units.................................................................................. 247  
10.1.2 Context Clauses - With Cl auses .................................................................................... 250  
10.1.3 Subunits of Co mpilation Un its ...................................................................................... 252  
10.1.4 The Compila tion Pro cess............................................................................................... 25 4 
10.1.5 Pragmas and Program Un its.......................................................................................... 255  
10.1.6 Environment-Level  Visibility Rules ............................................................................... 256  
10.2 Program Executi on......................................................................................................... ........ 257  
10.2.1 Elaborat ion Cont rol..................................................................................................... .... 259  
11   Excep tions ...........................................................................................................263  
11.1 Exception D eclarat ions.................................................................................................... ...... 263  
11.2 Exception Handler s........................................................................................................ ........ 264  
11.3 Raise St atemen ts.......................................................................................................... .......... 265  
11.4 Exception Handlin g........................................................................................................ ........ 265  
11.4.1 The Packag e Excepti ons................................................................................................ 26 6 
11.4.2 Pragmas Assert a nd Assertion_ Policy ......................................................................... 268  
11.4.3 Example of E xception Hand ling .................................................................................... 271  
11.5 Suppressi ng Ch ecks........................................................................................................ ...... 272  
11.6 Exceptions a nd Optimi zation............................................................................................... . 275 
12   Generi c Unit s.......................................................................................................277  
12.1 Generic D eclarat ions...................................................................................................... ........ 277  
12.2 Generi c Bodi es ............................................................................................................ ........... 279  
12.3 Generic In stantiat ion..................................................................................................... ......... 280  
12.4 Formal Objects ............................................................................................................ ........... 282  
12.5 Formal Types .............................................................................................................. ............ 284  
12.5.1 Formal Private a nd Derived Types ................................................................................ 285  
12.5.2 Formal S calar Ty pes ..................................................................................................... .. 288 
12.5.3 Formal A rray Types...................................................................................................... ... 288 
12.5.4 Formal Access Ty pes ..................................................................................................... 289 
12.5.5 Formal In terface Ty pes.................................................................................................. . 290 
12.6 Formal S ubprogram s ........................................................................................................ ..... 290  
12.7 Formal Packag es........................................................................................................... ......... 293  
12.8 Example of a Generic P ackage ............................................................................................. 2 95 
13   Representa tion Issu es .......................................................................................297  
13.1 Operational and Re presentation As pects ............................................................................ 297  
Ada Reference Manual — 2012 Edition 
v      13 December 2012 Table of Contents 13.1.1 Aspect Specificat ions ................................................................................................... ..300 
13.2 Packed Type s .............................................................................................................. ............303  
13.3 Operational and Repr esentation Attr ibutes .........................................................................304  
13.4 Enumeration Repr esentation Cl auses ..................................................................................310  
13.5 Record  Layout............................................................................................................. ............311  
13.5.1 Record Repr esentation Cl auses ....................................................................................312  
13.5.2 Storage Pl ace Attri butes................................................................................................ .314 
13.5.3 Bit Orderi ng............................................................................................................ ..........315  
13.6 Change of Representa tion .................................................................................................. ...316 
13.7 The Packag e Syst em ........................................................................................................ ......317  
13.7.1 The Package System .Storage_Ele ments ......................................................................319  
13.7.2 The Package System.A ddress_To_Access_Conv ersions ..........................................320  
13.8 Machine C ode Inser tions ................................................................................................... ....320  
13.9 Unchecked Type  Conver sions ..............................................................................................32 1 
13.9.1 Data Validity ........................................................................................................... ..........322  
13.9.2 The Valid  Attribute..................................................................................................... ......324  
13.10 Unchecked Access Va lue Creat ion.....................................................................................324  
13.11 Storage Manage ment....................................................................................................... .....325  
13.11.1 Storage Allocat ion Attri butes .......................................................................................328  
13.11.2 Unchecked Storag e Deallocat ion ................................................................................329  
13.11.3 Default St orage P ools .................................................................................................. .330 
13.11.4 Storag e Subpool s....................................................................................................... ...331 
13.11.5 Subpool R eclamation.................................................................................................... 333 
13.11.6 Storage S ubpool Exam ple............................................................................................334  
13.12 Pragma Restrictions  and Pragma  Profile...........................................................................336  
13.12.1 Language-Defined Rest rictions and Profile s .............................................................338  
13.13 Str eams.................................................................................................................. ................340  
13.13.1 The Packag e Streams ...................................................................................................3 40 
13.13.2 Stream-Orien ted Attri butes ..........................................................................................341  
13.14 Freezi ng Rule s ........................................................................................................... ...........346  
The Standard Libraries..............................................................................................349  
Annex A (normative)  Predefined Language  Environment ......................................351  
A.1 The Packag e Sta ndard....................................................................................................... ......354  
A.2 The P ackage Ad a............................................................................................................ ..........358  
A.3 Character  Handling ......................................................................................................... .........358  
A.3.1 The Packages Characters, Wide_Char acters, and Wide_W ide_Charact ers...............359  
A.3.2 The Package Char acters.Hand ling..................................................................................359  
A.3.3 The Package Char acters.Lati n_1.....................................................................................362  
A.3.4 The Package Char acters.Conv ersions ...........................................................................367  
A.3.5 The Package Wide_C haracters.Ha ndling .......................................................................369  
A.3.6 The Package Wide_Wid e_Characters. Handlin g ............................................................371  
A.4 String Handling............................................................................................................ .............372  
A.4.1 The P ackage St rings ...................................................................................................... ...372 
A.4.2 The Package Strings.M aps ..............................................................................................372  
A.4.3 Fixed-Length String Hand ling..........................................................................................375  
A.4.4 Bounded-Length String Hand ling ...................................................................................384  
A.4.5 Unbounded-Length String Hand ling...............................................................................391  
A.4.6 String-Handling Sets and Mappings ...............................................................................396  
A.4.7 Wide_Str ing Hand ling..................................................................................................... ..397 
A.4.8 Wide_Wide_Str ing Hand ling ............................................................................................399  
A.4.9 String Hashing........................................................................................................... ........402  
A.4.10 String Compar ison....................................................................................................... ...403 
Ada Reference Manual — 2012 Edition 
Table of Contents 13 December 2012      vi A.4.11 String Encodi ng......................................................................................................... ..... 404  
A.5 The Nume rics P ackages ...................................................................................................... .... 409  
A.5.1 Elementa ry Func tions ..................................................................................................... . 410 
A.5.2 Random Number  Genera tion........................................................................................... 413  
A.5.3 Attributes of Fl oating Point Types.................................................................................. 418  
A.5.4 Attributes of Fi xed Point Types ...................................................................................... 422  
A.6 Inpu t-Out put ............................................................................................................... .............. 423  
A.7 External Files and File Objects............................................................................................ ... 423 
A.8 Sequential and Direct Files................................................................................................ ..... 424  
A.8.1 The Generic P ackage Sequent ial_IO .............................................................................. 425  
A.8.2 File Manage ment.......................................................................................................... ..... 426  
A.8.3 Sequential Input-O utput Oper ations .............................................................................. 428  
A.8.4 The Generic P ackage Direct _IO ...................................................................................... 428  
A.8.5 Direct Input-O utput Oper ations ....................................................................................... 429  
A.9 The Generic P ackage Storag e_IO .......................................................................................... 430  
A.10 Text I nput-Out put......................................................................................................... .......... 431  
A.10.1 The Packag e Text _IO ..................................................................................................... 432 
A.10.2 Text File  Manage ment .................................................................................................... 437 
A.10.3 Default Input, Out put, and Erro r File s .......................................................................... 438  
A.10.4 Specification of Li ne and Page  Lengt hs ...................................................................... 439 
A.10.5 Operations on Column s, Lines, a nd Page s ................................................................. 440  
A.10.6 Get and Pu t Proce dures................................................................................................. 4 43 
A.10.7 Input-Output of Ch aracters and Strings ....................................................................... 445  
A.10.8 Input-Output fo r Integer Types...................................................................................... 447  
A.10.9 Input-Output fo r Real Ty pes .......................................................................................... 448  
A.10.10 Input-Output for Enumeration Types ......................................................................... 451  
A.10.11 Input-Output fo r Bounded St rings .............................................................................. 452  
A.10.12 Input-Output fo r Unbounded St rings ......................................................................... 454  
A.11 Wide Text Input-Output and Wide Wide Text  Input-O utput ............................................... 455  
A.12 Stream Input-O utput ....................................................................................................... ....... 456  
A.12.1 The Package Str eams.Stream _IO ................................................................................. 456  
A.12.2 The Package Text _IO.Text_Str eams............................................................................. 458  
A.12.3 The Package Wide_T ext_IO.Text_S treams.................................................................. 459  
A.12.4 The Package Wide_Wid e_Text_IO.Text_S treams ....................................................... 459  
A.13 Exceptions in  Input-O utput................................................................................................ ... 459  
A.14 File Sharing.............................................................................................................. ............... 461  
A.15 The Package Command_Li ne............................................................................................... 461  
A.16 The Package Directories ................................................................................................... .... 462  
A.16.1 The Package Directories. Hierarchical_F ile_Nam es.................................................... 470  
A.17 The Package Envir onment_Vari ables.................................................................................. 472  
A.18 Cont ainers ................................................................................................................ .............. 475  
A.18.1 The Package Containe rs................................................................................................ 47 5 
A.18.2 The Generic Package Containers.V ectors ................................................................... 475  
A.18.3 The Generic Package Cont ainers.Doubly_Li nked_Lis ts............................................ 493  
A.18.4 Maps.................................................................................................................... ............. 504  
A.18.5 The Generic Package C ontainers.Hash ed_Map s........................................................ 511  
A.18.6 The Generic Package C ontainers.Orde red_Ma ps....................................................... 515  
A.18.7 Sets .................................................................................................................... .............. 519  
A.18.8 The Generic Package C ontainers.Hash ed_Set s ......................................................... 527  
A.18.9 The Generic Package C ontainers.Orde red_Se ts ........................................................ 532  
A.18.10 The Generic Package C ontainers.Multi way_Tr ees ................................................... 538 
A.18.11 The Generic Package Cont ainers.Indefini te_Vector s............................................... 552  
A.18.12 The Generic Package Containers .Indefinite_Doubly_ Linked_L ists ....................... 553  
Ada Reference Manual — 2012 Edition 
vii      13 December 2012 Table of Contents A.18.13 The Generic Package Contai ners.Indefinite_H ashed_Map s....................................553  
A.18.14 The Generic Package Containe rs.Indefinite_Ord ered_Map s ...................................554  
A.18.15 The Generic Package Contai ners.Indefinite_H ashed_Set s......................................554  
A.18.16 The Generic Package Containe rs.Indefinite_Ord ered_Set s.....................................554  
A.18.17 The Generic Package Containe rs.Indefinite_Mul tiway_Tr ees .................................555  
A.18.18 The Generic Package Cont ainers.Indefini te_Holde rs...............................................555  
A.18.19 The Generic Package C ontainers.Bounded_ Vector s ...............................................559  
A.18.20 The Generic Package Containe rs.Bounded_Doubly_Li nked_Lis ts ........................560  
A.18.21 The Generic Package Cont ainers.Bounded_H ashed_Map s ....................................561  
A.18.22 The Generic Package Cont ainers.Bounded_Or dered_Ma ps ...................................562  
A.18.23 The Generic Package Cont ainers.Bounded_H ashed_Set s......................................563  
A.18.24 The Generic Package Cont ainers.Bounded_Or dered_Se ts.....................................565  
A.18.25 The Generic Package Contai ners.Bounded_Mult iway_Tr ees..................................566  
A.18.26 Array Sorting .......................................................................................................... .......568  
A.18.27 The Generic Package Containers .Synchronized_Qu eue_Inter faces ......................569  
A.18.28 The Generic Package Containe rs.Unbounded_Synchroni zed_Queu es .................570  
A.18.29 The Generic Package Containe rs.Bounded_Synchroni zed_Queu es......................571  
A.18.30 The Generic Package Contai ners.Unbounded_Priori ty_Queue s ............................572  
A.18.31 The Generic Package Contai ners.Bounded_Priori ty_Queue s.................................573  
A.18.32 Example of Container Use ...........................................................................................574  
A.19 The Packag e Local es....................................................................................................... ......576  
Annex B (normative)  Interface to Ot her Langua ges................................................579  
B.1 Interfaci ng Asp ects ........................................................................................................ ..........579  
B.2 The Packag e Inte rfaces ..................................................................................................... ......582  
B.3 Interfacing wi th C and C++................................................................................................. .....583  
B.3.1 The Package In terfaces.C.St rings ...................................................................................591  
B.3.2 The Generic Package Interfaces.C.Po inters ..................................................................594  
B.3.3 Unchecked Un ion Type s ..................................................................................................59 7 
B.4 Interfacing with COBOL..................................................................................................... ......599  
B.5 Interfacing with Fortran ................................................................................................... ........605  
Annex C (normative)  Systems Pr ogramming...........................................................609  
C.1 Access to Mach ine Oper ations............................................................................................... 609 
C.2 Required Represen tation S upport ..........................................................................................61 0 
C.3 Interrupt  Suppor t.......................................................................................................... ............610  
C.3.1 Protected Pro cedure Handl ers ........................................................................................612  
C.3.2 The Packag e Interr upts ................................................................................................... .614 
C.4 Preelaborati on Require ments ................................................................................................ .616 
C.5 Pragma Di scard_Na mes ....................................................................................................... ...617 
C.6 Shared Vari able C ontrol .................................................................................................... ......618  
C.7 Task In formati on ........................................................................................................... ...........620  
C.7.1 The Package Task_I dentificat ion ....................................................................................620  
C.7.2 The Package Task_Attri butes ..........................................................................................622  
C.7.3 The Package T ask_Termina tion ......................................................................................624  
Annex D (normative)  Real-Time Systems .................................................................627  
D.1 Task Pr iorities............................................................................................................ ...............627  
D.2 Priority Schedu ling ........................................................................................................ ..........629  
D.2.1 The Task Disp atching M odel ...........................................................................................629  
D.2.2 Task Dispatch ing Prag mas..............................................................................................631  
D.2.3 Preemptive Dispatching ................................................................................................... 632 
D.2.4 Non-Preemptiv e Dispatch ing...........................................................................................633  
D.2.5 Round Robin Dispatch ing................................................................................................63 5 
Ada Reference Manual — 2012 Edition 
Table of Contents 13 December 2012      viii D.2.6 Earliest Deadline First Dispat ching ................................................................................ 636  
D.3 Priority Ceiling Lo cking................................................................................................... ........ 638  
D.4 Entry Queu ing Polic ies..................................................................................................... ....... 640  
D.5 Dynamic Priorities ......................................................................................................... .......... 642  
D.5.1 Dynamic Prio rities for Tasks ........................................................................................... 64 2 
D.5.2 Dynamic Priorities fo r Protected Object s ...................................................................... 643  
D.6 Preemptiv e Abor t ........................................................................................................... .......... 644  
D.7 Tasking R estrict ions....................................................................................................... ......... 645  
D.8 Monotoni c Time ............................................................................................................. .......... 647  
D.9 Delay Accur acy ............................................................................................................. ........... 651  
D.10 Synchronous Task Cont rol.................................................................................................. . 652 
D.10.1 Synchronous  Barriers.................................................................................................... 653 
D.11 Asynchronous Task Cont rol................................................................................................. 654 
D.12 Other Optimizations a nd Determinism  Rules ..................................................................... 655  
D.13 The Raven scar Pr ofile ..................................................................................................... ...... 656  
D.14 Executi on Ti me ............................................................................................................ .......... 657  
D.14.1 Execution Ti me Timers .................................................................................................. 6 59 
D.14.2 Group Execution Time B udgets .................................................................................... 661  
D.14.3 Execution Time of Interrupt Ha ndlers .......................................................................... 663  
D.15 Timing Events............................................................................................................. ............ 664  
D.16 Multiprocessor Im plementa tion ........................................................................................... 66 6 
D.16.1 Multiprocessor Disp atching Do mains.......................................................................... 667  
Annex E (normative)  Distributed Systems ...............................................................671  
E.1 Part itions................................................................................................................. .................. 671  
E.2 Categorization of  Library Units ............................................................................................ .. 673 
E.2.1 Shared Passive  Library Units.......................................................................................... 674  
E.2.2 Remote Types Library Units............................................................................................ 674  
E.2.3 Remote Call Inte rface Library Units ................................................................................ 676  
E.3 Consistency of a Distributed System .................................................................................... 677  
E.4 Remote S ubprogram Calls.................................................................................................... .. 677 
E.4.1 Asynchronous Remote Calls........................................................................................... 679  
E.4.2 Example of Use of a Remo te Access-to-Class- Wide Ty pe........................................... 680  
E.5 Partition Communi cation Subs ystem.................................................................................... 682  
Annex F (normative)  Information Systems...............................................................685  
F.1 Machine_Radix Attri bute Definiti on Clau se .......................................................................... 685  
F.2 The Packag e Deci mal........................................................................................................ ....... 686  
F.3 Edited Output fo r Decimal Types ........................................................................................... 6 87 
F.3.1 Picture St ring Forma tion................................................................................................. . 688 
F.3.2 Edited Out put Genera tion ................................................................................................ 6 92 
F.3.3 The Package T ext_IO.Edi ting........................................................................................... 696  
F.3.4 The Package Wid e_Text_IO.Edi ting................................................................................ 699  
F.3.5 The Package Wide_W ide_Text_IO.E diting ..................................................................... 699  
Annex G (normative)  Numeri cs .................................................................................701  
G.1 Complex Arithmetic......................................................................................................... ........ 701  
G.1.1 Compl ex Type s............................................................................................................ ..... 701  
G.1.2 Complex Elem entary Func tions ..................................................................................... 706  
G.1.3 Complex Input-O utput ..................................................................................................... 709 
G.1.4 The Package Wid e_Text_IO.Com plex_IO ...................................................................... 712  
G.1.5 The Package Wide_W ide_Text_IO.Com plex_IO ............................................................ 712  
G.2 Numeric Performa nce Require ments .................................................................................... 712  
G.2.1 Model of Floati ng Point Arit hmetic................................................................................. 713  
Ada Reference Manual — 2012 Edition 
ix      13 December 2012 Table of Contents G.2.2 Model-Oriented Attribut es of Floating Po int Type s ......................................................714  
G.2.3 Model of Fixed Point Arit hmetic......................................................................................715  
G.2.4 Accuracy Requirements fo r the Elementa ry Functi ons ............................................... 717 
G.2.5 Performance Requirements fo r Random Number Generati on ....................................719  
G.2.6 Accuracy Requirements for Complex Ar ithmetic..........................................................719  
G.3 Vector and Matr ix Manipul ation............................................................................................. .721 
G.3.1 Real Vector s and Matr ices ...............................................................................................7 21 
G.3.2 Complex Vector s and Matr ices .......................................................................................726  
Annex H (normative)  High Integrit y Systems ...........................................................739  
H.1 Pragma No rmalize_Scal ars ................................................................................................... ..739 
H.2 Documentation of Im plementation Decisi ons....................................................................... 740 
H.3 Reviewable Object Code ..................................................................................................... ....740  
H.3.1 Pragma Reviewable ........................................................................................................ ..740 
H.3.2 Pragma Insp ection_Point.................................................................................................7 41 
H.4 High Integrit y Restrictions ................................................................................................ ......742  
H.5 Pragma De tect_Blo cking ..................................................................................................... ....744  
H.6 Pragma Partition_ Elaboration_ Policy....................................................................................745  
Annex J (normative)  Obsolescent Featur es.............................................................747  
J.1 Renamings of Library Units................................................................................................. ....747  
J.2 Allowed Replacements  of Char acters ....................................................................................747  
J.3 Reduced Accu racy Subtypes .................................................................................................. 748 
J.4 The Constrai ned Attr ibute.................................................................................................. ......749  
J.5 ASCII...................................................................................................................... .....................749  
J.6 Numeri c_Erro r.............................................................................................................. .............750  
J.7 At Clau ses................................................................................................................. .................750  
J.7.1 Interrupt  Entries........................................................................................................ .........750  
J.8 Mod Clau ses................................................................................................................ ..............752  
J.9 The Storage_S ize Attribute................................................................................................. .....752  
J.10 Specific Suppr ession of Checks ...........................................................................................7 52 
J.11 The Class Attribute of Un tagged Incomple te Type s ...........................................................753  
J.12 Pragma Interf ace.......................................................................................................... ...........753  
J.13 Dependence Restrict ion Identi fiers ......................................................................................75 3 
J.14 Character and Wide_Char acter Conversi on Functi ons...................................................... 754 
J.15 Aspect-relat ed Pragmas.................................................................................................... .....754  
J.15.1 Pragma  Inline ........................................................................................................... ........754  
J.15.2 Pragma No_Ret urn ........................................................................................................ ..755 
J.15.3 Prag ma Pack ............................................................................................................. .......755  
J.15.4 Pragma Storage_S ize..................................................................................................... .755 
J.15.5 Interfaci ng Prag mas ..................................................................................................... ...756 
J.15.6 Pragma Un checked_Uni on.............................................................................................757  
J.15.7 Pragmas Interrupt_Handl er and Attach _Handl er.........................................................757  
J.15.8 Shared Vari able Prag mas ...............................................................................................75 8 
J.15.9 Prag ma CPU .............................................................................................................. .......758  
J.15.10 Pragma Disp atching_Do main ......................................................................................759  
J.15.11 Pragmas Priority a nd Interrupt_P riority......................................................................759  
J.15.12 Pragma Rela tive_Dead line............................................................................................760  
J.15.13 Pragma Asynchr onous .................................................................................................760  
Annex K (informative)  Language-Defined Asp ects and Attr ibutes ........................761  
K.1 Language-Defin ed Aspects................................................................................................... ..761 
K.2 Language-Defin ed Attr ibutes................................................................................................ ..764 
Annex L (informative)  Language-Defined  Pragmas.................................................781  
Ada Reference Manual — 2012 Edition 
Table of Contents 13 December 2012      x Annex M (informative)  Summary of Document ation Require ments ......................785  
M.1 Specific Documentat ion Require ments ................................................................................ 785  
M.2 Implementation-Defi ned Character istics .............................................................................. 787  
M.3 Implementa tion Ad vice ...................................................................................................... ..... 794  
Annex N (informative)  Glossar y.................................................................................803  
Annex P (informative)  Syntax Su mmary ...................................................................809  
Annex Q (informative)  Language-Defined  Entities ..................................................843  
Q.1 Language-Def ined P ackages.................................................................................................. 843 
Q.2 Language-Defined Ty pes and S ubtypes ............................................................................... 846  
Q.3 Language-Defined  Subprogr ams........................................................................................... 850  
Q.4 Language-Defin ed Excep tions............................................................................................... 8 61 
Q.5 Language-Defin ed Objects ................................................................................................... .. 862 
Index.......................................................................................................................... ..867  
 
Ada Reference Manual — 2012 Edition 
xi      13 December 2012 Introduction Introduction 
This is the Ada Reference Manual.  
Other available Ada documents include:  
• Ada 2012 Rationale. This gives an introduction to  the changes and new features in Ada 2012, 
and explains the rationale behi nd them. Programmers should read this rationale before reading 
this Standard in depth. Rationales for Ada 83, Ada 95, and Ada 2005 are also available. 
• This paragraph was deleted.  
• The Annotated Ada Reference Manual (AARM). Th e AARM contains all of the text in this 
International Standard, plus va rious annotations. It is intende d primarily for compiler writers, 
validation test writers, and others who wish to study the fine details. The annotations include 
detailed rationale for individual ru les and explanations of some of the more arcane interactions 
among the rules.  
Design Goals  
Ada was originally designed with three overriding concerns: program reliability and maintenance, 
programming as a human activity, and efficiency. The 1995 revision to the language was designed to 
provide greater flexibility and extensibility, a dditional control over storage management and 
synchronization, and standardized packages oriented  toward supporting important application areas, while 
at the same time retaining the original emphasis on reliability, maintainability, and efficiency. This third 
edition provides further flexibility and adds more sta ndardized packages within the framework provided 
by the 1995 revision. 
The need for languages that promote reliability and simplify maintenance is well established. Hence 
emphasis was placed on program readability over ease of writing. For example, the rules of the language 
require that program variables be explicitly declared a nd that their type be specified. Since the type of a 
variable is invariant, compilers can ensure that ope rations on variables are compatible with the properties 
intended for objects of the type. Furthermore, error-prone  notations have been avoided, and the syntax of 
the language avoids the use of encoded forms in fa vor of more English-like constructs. Finally, the 
language offers support for separate compilation of program units in a way that facilitates program 
development and maintenance, and wh ich provides the same degree of ch ecking between units as within a 
unit. 
Concern for the human programmer was also stressed dur ing the design. Above all,  an attempt was made 
to keep to a relatively small number of underlying concep ts integrated in a consistent and systematic way 
while continuing to avoid the pitfalls of excessive involution. The design especially aims to provide 
language constructs that correspond intuitivel y to the normal expectations of users. 
Like many other human activities, the development of  programs is becoming ever more decentralized and 
distributed. Consequently, the ability to assemble  a program from independently produced software 
components continues to be a central idea in the design. The concepts of packages, of private types, and of 
generic units are directly related to this idea, wh ich has ramifications in ma ny other aspects of the 
language. An allied concern is the maintenance of  programs to match changing requirements; type 
extension and the hierarchical library enable a progr am to be modified while minimizing disturbance to 
existing tested and trusted components. 
No language can avoid the problem of efficiency. La nguages that require over-elaborate compilers, or that 
lead to the inefficient use of storage or execution time,  force these inefficiencies on all machines and on all 1 
2 
3/3 
4/1 
5/3 
6/3 
7 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
Introduction 13 December 2012      xii programs. Every construct of the language was ex amined in the light of  present implementation 
techniques. Any proposed construct whose implementation was unclear or  that required excessive machine 
resources was rejected.  
Language Summary  
An Ada program is composed of one or more progr am units. Program units ma y be subprograms (which 
define executable algorithms), packages (which define  collections of entities), task units (which define 
concurrent computations), protected units (which de fine operations for the coordinated sharing of data 
between tasks), or generic units (which define para meterized forms of packages and subprograms). Each 
program unit normally consists of two parts: a speci fication, containing the information that must be 
visible to other units, and a body, containing the implem entation details, which need not be visible to other 
units. Most program units can  be compiled separately. 
This distinction of the specification and body, and the ability to compile units separately, allows a program 
to be designed, written, and tested as a set of largely independent software components. 
An Ada program will normally make use of a library  of program units of general utility. The language 
provides means whereby individual organizations can construct their own libra ries. All libraries are 
structured in a hierarchical manner; this enables th e logical decomposition of a subsystem into individual 
components. The text of a separately compiled progr am unit must name the library units it requires. 
Program Units  
A subprogram is the basic unit for expressing an algorithm. There are two kinds of subprograms: 
procedures and functions. A procedure is the means of invoking a series of actions. For example, it may 
read data, update variables, or produce some output. It may have parameters, to provide a controlled 
means of passing information between the procedure a nd the point of call. A function is the means of 
invoking the computation of a value. It is similar to  a procedure, but in addition will return a result. 
A package is the basic unit for defining a collection of  logically related entities. For example, a package 
can be used to define a set of type declarations a nd associated operations. Portions of a package can be 
hidden from the user, thus allowing access only to the logical properties expressed by the package specification. 
Subprogram and package units may be compiled separately  and arranged in hierarchies of parent and child 
units giving fine control over visibility of the l ogical properties and their detailed implementation. 
A task unit is the basic unit for defining a task whos e sequence of actions may be executed concurrently 
with those of other tasks. Such tasks may be im plemented on multicomputers, multiprocessors, or with 
interleaved execution on a single processor. A task unit may define either a single executing task or a task type permitting the creation of any number of similar tasks. 
A protected unit is the basic unit for defining protected  operations for the coordinated use of data shared 
between tasks. Simple mutual exclusion is provided automatically, and more elaborate sharing protocols 
can be defined. A protected operation can either be a subprogram or an entry. A protected entry specifies a 
Boolean expression (an entry barrier) that must be True before the body of the entry is executed. A 
protected unit may define a single protected object or  a protected type permitting the creation of several 
similar objects. 11 
12 
13 
14 
15 
16 
17 
18 
19/2 
Ada Reference Manual — 2012 Edition 
xiii      13 December 2012 Introduction Declarations and Statements  
The body of a program unit generally contains two pa rts: a declarative part, which defines the logical 
entities to be used in the program unit, and a sequen ce of statements, which defines the execution of the 
program unit. 
The declarative part associates names with declared  entities. For example, a name may denote a type, a 
constant, a variable, or an exception. A declarative pa rt also introduces the name s and parameters of other 
nested subprograms, packages, task un its, protected units, and generic units to be used in the program unit. 
The sequence of statements describes a sequence of ac tions that are to be performed. The statements are 
executed in succession (unless a transfer of contro l causes execution to continue from another place). 
An assignment statement changes the value of a variable. A procedure call invokes execution of a 
procedure after associating any actual parameters provided at the call with the corresponding formal 
parameters. 
Case statements and if statements allow the selection of an enclosed sequence of statements based on the 
value of an expression or on the value of a condition. 
The loop statement provides the basic iterative mechanis m in the language. A loop statement specifies that 
a sequence of statements is to be executed repeatedly  as directed by an iteration scheme, or until an exit 
statement is encountered. 
A block statement comprises a sequence of statements preceded by the declaration of local entities used by 
the statements. 
Certain statements are associated with concurrent execution. A delay statement delays the execution of a 
task for a specified duration or until a specified time. An entry call statement is written as a procedure call 
statement; it requests an operation on a task or on a protected object, blocking the caller until the operation 
can be performed. A called task may accept an entr y call by executing a corresponding accept statement, 
which specifies the actions then to be performed as part of the rendezvous with the calling task. An entry 
call on a protected object is processed when the co rresponding entry barrier evaluates to true, whereupon 
the body of the entry is executed. The requeue statem ent permits the provision of a service as a number of 
related activities with preference control. One form of the select statement allows a selective wait for one 
of several alternative rendezvous. Other forms of th e select statement allow conditional or timed entry 
calls and the asynchronous transfer of cont rol in response to some triggering event. 
Execution of a program unit may encounter error s ituations in which normal program execution cannot 
continue. For example, an arithmetic computation may exceed the maximum allowed value of a number, or an attempt may be made to access an array component  by using an incorrect index value. To deal with 
such error situations, the statements of a program un it can be textually followed by exception handlers that 
specify the actions to be taken when the error situa tion arises. Exceptions can be  raised explicitly by a 
raise statement. 
Data Types  
Every object in the language has a type, which charact erizes a set of values and a set of applicable 
operations. The main classes of types are elementary  types (comprising enumeration, numeric, and access 
types) and composite types (including array and record types). 
An enumeration type defines an ordered set of distinct  enumeration literals, for example a list of states or 
an alphabet of characters. The enumeration types Boolean, Character, Wide_Character, and 
Wide_Wide_Character are predefined. 20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32/2 
Ada Reference Manual — 2012 Edition 
Introduction 13 December 2012      xiv Numeric types provide a means of performing exact  or approximate numerical computations. Exact 
computations use integer types, wh ich denote sets of consecutive intege rs. Approximate computations use 
either fixed point types, with absolute bounds on the error, or floating point types, with relative bounds on 
the error. The numeric types Integer, Float, and Duration are predefined. 
Composite types allow definitions of structured object s with related components. The composite types in 
the language include arrays and records. An array is an object with indexed components of the same type. 
A record is an object with named components of possi bly different types. Task and protected types are 
also forms of composite types. The array type s String, Wide_String, and Wide_Wide_String are 
predefined. 
Record, task, and protected types may have special  components called discrimi nants which parameterize 
the type. Variant record structures that depend on th e values of discriminants can be defined within a 
record type. 
Access types allow the construction of linked data structures. A value of an access type represents a 
reference to an object declared as aliased or to an object created by the evaluation of an allocator. Several 
variables of an access type may designate the same  object, and components of one object may designate 
the same or other objects. Both the elements in such  linked data structures and their relation to other 
elements can be altered during program execution. A ccess types also permit references to subprograms to 
be stored, passed as parameters, and ultimately dereferenced as part of an indirect call. 
Private types permit restricted views of a type. A privat e type can be defined in a package so that only the 
logically necessary properties are made visible to the us ers of the type. The full structural details that are 
externally irrelevant are then only availa ble within the package and any child units. 
From any type a new type may be de fined by derivation. A type, together  with its derivatives (both direct 
and indirect) form a derivation class. Class-wide ope rations may be defined that accept as a parameter an 
operand of any type in a derivation class. For record and private types, the derivatives may be extensions 
of the parent type. Types that support these object-o riented capabilities of class-wide operations and type 
extension must be tagged, so that the specific type of  an operand within a derivation class can be identified 
at run time. When an operation of a tagged type is applied to an operand whose specific type is not known 
until run time, implicit dispatching is performed based on the tag of the operand. 
Interface types provide abstract models from which other interfaces and types may be composed and 
derived. This provides a reliable form of multiple inhe ritance. Interface types may also be implemented by 
task types and protected types thereby enabling conc urrent programming and inheritance to be merged. 
The concept of a type is further refined by the concep t of a subtype, whereby a user can constrain the set 
of allowed values of a type. Subtypes  can be used to define subranges of  scalar types, arrays with a limited 
set of index values, and records and private types with particular discriminant values. 
Other Facilities  
Aspect clauses can be used to specify the mapping be tween types and features of an underlying machine. 
For example, the user can specify that objects of a gi ven type must be represented with a given number of 
bits, or that the components of a record are to be re presented using a given storage layout. Other features 
allow the controlled use of low level, nonportable, or implementation-dependent aspects, including the 
direct insertion of machine code. 
The predefined environment of the language provide s for input-output and other capabilities by means of 
standard library packages. Input-output is supported for values of user-defined as  well as of predefined 
types. Standard means of representing valu es in display form are also provided. 33 
34/2 
35 
36 
37 
38 
38.1/2 
39 
40 
41/2 
42/2 
Ada Reference Manual — 2012 Edition 
xv      13 December 2012 Introduction The predefined standard library packages provide f acilities such as string mani pulation, containers of 
various kinds (vectors, lists, maps, etc.), mathematical functions, ra ndom number generation, and access to 
the execution environment. 
The specialized annexes define further predefined library packages and facilities with emphasis on areas 
such as real-time scheduling, interrupt handling, di stributed systems, numeri cal computation, and high-
integrity systems. 
Finally, the language provides a powerful means of parameterization of program units, called generic 
program units. The generic parameters can be type s and subprograms (as well as objects and packages) 
and so allow general algorithms and data  structures to be defined that are applicable to all types of a given 
class.  
Language Changes  
Paragraphs 44 through 57 have been removed as they describe d differences from the first edition of Ada (Ada 83).   
This International Standard replaces the second ed ition of 1995. It modifies the previous edition by 
making changes and additions that improve the capab ility of the language and the reliability of programs 
written in the language. This edition incorpor ates the changes from Amendment 1 (ISO/IEC 
8652:1995:AMD 1:2007), which were designed to improve  the portability of programs, interfacing to 
other languages, and both the object-oriented and real-time capabilities. 
Significant changes originating in Amendment 1 are incorporated: 
• Support for program text is extended to cover the entire ISO/IEC 10646:2003 repertoire. 
Execution support now includes the 32-bit character se t. See subclauses 2.1,  3.5.2, 3.6.3, A.1, 
A.3, and A.4. 
• The object-oriented model has been improved by the addition of an interface facility which 
provides multiple inheritance and additional flexib ility for type extensions . See subclauses 3.4, 
3.9, and 7.3. An alternative notation for calling operations more akin to that used in other 
languages has also been adde d. See subclause 4.1.3. 
• Access types have been further extended to unify properties such as the ability to access 
constants and to exclude null values. See clause 3.10. Anonymous access types are now 
permitted more freely and anonymous access-to-subprogram types are introduced. See subclauses 3.3, 3.6,  3.10, and 8.5.1. 
• The control of structure and visibility has been enhanced to permit mutually dependent 
references between units and finer control over access from the private part of a package. See 
subclauses 3.10.1 and 10.1.2. In  addition, limited types have b een made more useful by the 
provision of aggregates, constants, and constructo r functions. See subclauses 4.3, 6.5, and 7.5. 
• The predefined environment has been exte nded to include additional time and calendar 
operations, improved string handling, a comprehe nsive container library, file and directory 
management, and access to environment variables. See subclauses 9.6.1, A.4, A.16, A.17, and 
A.18. 
• Two of the Specialized Needs Annexes have been considerably enhanced:  
• The Real-Time Systems Annex now includes the Ravenscar profile for high-integrity 
systems, further dispatching policies such as Round Robin and Earliest Deadline First, 
support for timing events, and support for contro l of CPU time utilization. See subclauses 
D.2, D.13, D.14, and D.15. 42.1/2 
42.2/2 
43 
57.1/3 
57.2/3 
57.3/3 
57.4/3 
57.5/3 
57.6/3 
57.7/3 
57.8/3 
57.9/2 
Ada Reference Manual — 2012 Edition 
Introduction 13 December 2012      xvi • The Numerics Annex now includes support for real and complex vectors and matrices as 
previously defined in ISO/IEC 13813:1997 plus fu rther basic operations for linear algebra. 
See subclause G.3.  
• The overall reliability of the language has been enhanced by a number of improvements. These 
include new syntax which detects accidental overloading, as well as pragmas for making 
assertions and giving better control over the suppr ession of checks. See s ubclauses 6.1, 11.4.2, 
and 11.5. 
In addition, this third edition makes enhancements to address two important issues, namely, the particular 
problems of multiprocessor architectures, and the n eed to further increase the capabilities regarding 
assertions for correctness. It also makes additional changes and additions that improve the capability of the 
language and the reliability of programs written in the language. 
The following significant changes with respect to the 1995 edition as amended by Amendment 1 are 
incorporated: 
• New syntax (the aspect specification) is introduced to enable properties to be specified for 
various entities in a more structured manner than through pragmas. See subclause 13.1.1. 
• The concept of assertions introduced in the 2005 edition is extended with the ability to specify 
preconditions and postconditions for subprograms, a nd invariants for private types. The concept 
of constraints in defining subtyp es is supplemented with  subtype predicates that enable subsets 
to be specified other than as simple ranges. These properties are all indicated using aspect specifications. See subclauses 3.2.4, 6.1.1, and 7.3.2. 
• New forms of expressions are introduced. These are if expressions, case expressions, quantified 
expressions, and expression functions. As well as  being useful for programming in general by 
avoiding the introduction of unnecessary assignments, they are especially valuable in conditions 
and invariants since they avoid the need to in troduce auxiliary functions. See subclauses 4.5.7, 
4.5.8, and 6.8. Membership test s are also made more flexible. See subclauses 4.4 and 4.5.2. 
• A number of changes are made to subprogram pa rameters. Functions may now have parameters 
of all modes. In order to mitigate consequent (a nd indeed existing) problems of inadvertent order 
dependence, rules are introduced to reduce aliasi ng. A parameter may now be explicitly marked 
as aliased and the type of a parameter may be incomplete in certain circumstances. See subclauses 3.10.1, 6.1, and 6.4.1. 
• The use of access types is now more flexible. The rules for accessibility and certain conversions 
are improved. See subclauses 3.10. 2, 4.5.2, 4.6, and 8. 6. Furthermore, better control of storage 
pools is provided. See subclause 13.11.4. 
• The Real-Time Systems Annex now includes fac ilities for defining domains of processors and 
assigning tasks to them. Improvements are ma de to scheduling and budgeting facilities. See 
subclauses D.10.1,  D.14, and D.16. 
• A number of important improvements are made to  the standard library. These include packages 
for conversions between strings and UTF encodi ngs, and classification f unctions for wide and 
wide wide characters. Internationalization is cat ered for by a package giving locale information. 
See subclauses A.3, A.4.11, and A.19. The container library  is extended to include bounded 
forms of the existing containers and new contai ners for indefinite objects, multiway trees, and 
queues. See subclause A.18. 
• Finally, certain features are added primarily to ease the use of containers , such as the ability to 
iterate over all elements in a container without ha ving to encode the iteration. These can also be 
used for iteration over arrays, and within quantif ied expressions. See subc lauses 4.1.5, 4.1.6, 
5.5.1, and 5.5.2.  57.10/3 
57.11/3 
57.12/3 
57.13/3 
57.14/3 
57.15/3 
57.16/3 
57.17/3 
57.18/3 
57.19/3 
57.20/3 
57.21/3 
Ada Reference Manual — 2012 Edition 
xvii      13 December 2012 Introduction Instructions for Comment Submission  
Informal comments on this International Standard may be sent via e-mail to ada-comment@ada-
auth.org . If appropriate, the Project Editor will in itiate the defect correction procedure. 
Comments should use the following format:  
 !topic  Title summarizing comment  
 !reference  Ada 2012 RM ss.ss(pp)  
 !from  Author Name yy-mm-dd  
 !keywords  keywords related to topic  
 !discussion  
  text of discussion  
where ss.ss is the clause or subclause number, pp is the paragraph number where applicable, and yy-mm-dd  
is the date the comment was sent. The date is optional, as is the !keywords  line. 
Please use a descriptive “Subject” in your e-mail message, and limit each message to a single comment. When correcting typographical errors or making mi nor wording suggestions, please put the correction 
directly as the topic of the commen t; use square brackets [ ] to indicate text to be omitted and curly braces 
{ } to indicate text to be added, and provide enough context to make the nature of the suggestion self-
evident or put additional information in the body of the comment, for example:  
 !topic  [c]{C}haracter 
 !topic  it[']s meaning is not defined 
Formal requests for interpretations a nd for reporting defects in this Intern ational Standard may be made in 
accordance with the ISO/IEC JTC 1 Directives and the ISO/IEC JTC 1/SC 22 policy for interpretations. National Bodies may submit a Defect Report to IS O/IEC JTC 1/SC 22 for resolution under the JTC 1 
procedures. A response will be provided and, if appr opriate, a Technical Corrigendum will be issued in 
accordance with the procedures. 58/1 
59 
60/3 
61/3 
62/1 
63 
64 
65 
Ada Reference Manual — 2012 Edition 
Introduction 13 December 2012      xviii Acknowledgements for the Ada 83 edition  
Ada is the result of a collective effort to design a common language for programming large scale and real-
time systems. 
The common high order language program began in  1974. The requirements of the United States 
Department of Defense were formali zed in a series of documents which were extensively reviewed by the 
Services, industrial organizations, universities, and foreign military department s. The Ada language was 
designed in accordance with the final (1978) form of these requirements, embodied in the Steelman 
specification. 
The Ada design team was led by Jean D. Ichbiah and has included Bernd Krie g-Brueckner, Brian A. 
Wichmann, Henry F. Ledgard, Jean-Claude Heliard , Jean-Loup Gailly, Jean-Raymond Abrial, John G.P. 
Barnes, Mike Woodger, Olivier Roubine, Pa ul N. Hilfinger, and Robert Firth. 
At various stages of the project, several people closely associated with the design team made major 
contributions. They include J.B. Goodenough, R.F. Brender,  M.W. Davis, G. Fe rran, K. Lester, L. 
MacLaren, E. Morel, I.R. Nassi, I.C. Pyle, S.A. Schuman, and S.C. Vestal. 
Two parallel efforts that were started in the sec ond phase of this design had a deep influence on the 
language. One was the development of a formal de finition using denotational semantics, with the 
participation of V. Donzeau-Gouge, G.  Kahn, and B. Lang. The other was the design of a test translator 
with the participation of K. Ripken,  P. Boullier, P. Cadiou, J. Holden , J.F. Hueras, R.G. Lange, and D.T. 
Cornhill. The entire effort benefitted from the dedi cated assistance of Lyn Churchill and Marion Myers, 
and the effective technical support of B. Gravem, W.L.  Heimerdinger, and P. Clev e. H.G. Schmitz served 
as program manager. 
Over the five years spent on this project, several intense week-long design revi ews were conducted, with 
the participation of P. Belmont, B. Brosgol, P. Cohen,  R. Dewar, A. Evans, G. Fisher, H. Harte, A.L. 
Hisgen, P. Knueven, M. Kronental, N. Lomuto, E. Ploedereder, G. S eegmueller, V. Stenning, D. Taffs, 
and also F. Belz, R. Converse, K. Correll, A.N. Habermann, J. Sammet, S. S quires, J. Teller, P. Wegner, 
and P.R. Wetherall. 
Several persons had a constructive influence with their comments, criticisms and suggestions. They 
include P. Brinch Hansen, G. Goos, C.A.R. Hoare, Mark Rain, W.A. Wulf, and also E. Boebert, P. 
Bonnard, H. Clausen, M. Cox, G. Di smukes, R. Eachus, T. Froggatt, H. Ganzinger, C. He witt, S. Kamin, 
R. Kotler, O. Lecarme, J.A.N. Lee, J.L. Mansion, F.  Minel, T. Phinney, J. Roehrich, V. Schneider, A. 
Singer, D. Slosberg, I.C. Wand, the reviewers of Ada-Europe, AdaT ech, Afcet, those of the LMSC review 
team, and those of the Ada Tokyo Study Group. 
These reviews and comments, the numerous evaluation re ports received at the end of the first and second 
phase, the nine hundred language issue reports and test and evaluation reports received from fifteen 
different countries during the third phase of the pr oject, the thousands of comments received during the 
ANSI Canvass, and the on-going work of the IFIP  Working Group 2.4 on system implementation 
languages and that of the Purdue Europe LTPL-E comm ittee, all had a substantial influence on the final 
definition of Ada. 
The Military Departments and Agencies have pr ovided a broad base of support including funding, 
extensive reviews, and countless i ndividual contributions by the me mbers of the High Order Language 
Working Group and other interested personnel. In particular, William A.  Whitaker provided leadership for 
the program during the formative stages. David A. Fi sher was responsible for the successful development 
and refinement of the language requirement documents that led to the Steelman specification. 65.1/3 
65.2/3 
65.3/3 
65.4/3 
65.5/3 
65.6/3 
65.7/3 
65.8/3 
65.9/3 
Ada Reference Manual — 2012 Edition 
xix      13 December 2012 Introduction The Ada 83 language definition was developed by Cii Honeywell Bull and later Alsys, and by Honeywell 
Systems and Research Center, under contract to the United States Department of Defense. William E. 
Carlson and later Larry E. Druffel served as the tec hnical representatives of the United States Government 
and effectively coordinated the efforts of  all participants in the Ada program. 
Acknowledgements for the Ada 95 edition  
This International Standard was prepared by the Ada 9X Mapping/Revision Team  based at Intermetrics, 
Inc., which has included: W. Carl son, Program Manager; T. Taft, Technical Director; J. Barnes 
(consultant); B. Brosgol (consultant ); R. Duff (Oak Tree Software); M.  Edwards; C. Garrity; R. Hilliard; 
O. Pazy (consultant); D. Rosenfeld;  L. Shafer; W. White; M. Woodger. 
The following consultants to the Ada 9X Project contri buted to the Specialized Needs Annexes: T. Baker 
(Real-Time/Systems Programming — SEI, FSU); K. Dritz (Numeric s — Argonne National Laboratory); 
A. Gargaro (Distributed Systems — Computer  Sciences); J. Goode nough (Real-Time/Systems 
Programming — SEI); J. McHugh (Secure Systems — c onsultant); B. Wichmann (Safety-Critical Systems 
— NPL: UK). 
This work was regularly reviewed by the Ada 9X Distinguished Reviewers and the members of the Ada 
9X Rapporteur Group (XRG): E. Pl oedereder, Chairman of DRs a nd XRG (University of Stuttgart: 
Germany); B. Bardin (Hughes); J. Barnes (consultant: UK); B. Brett (DEC); B. Brosgol (consultant); R. 
Brukardt (RR Software); N. Cohen (IBM); R. De war (NYU); G. Dismukes (TeleSoft); A. Evans 
(consultant); A. Gargaro (Computer  Sciences); M. Gerhardt (ESL);  J. Goodenough (SEI); S. Heilbrunner 
(University of Salzburg: Austria); P. Hilfinger (UC/ Berkeley); B. Källberg (CelsiusTech: Sweden); M. 
Kamrad II (Unisys); J. van Katwijk (Delft Univer sity of Technology: The Netherlands); V. Kaufman 
(Russia); P. Kruchten (Rational); R. Landwehr (CCI: Germany); C. Lester (Portsmouth Polytechnic: UK); 
L. Månsson (TELIA Research: Sweden); S. Michell (Multiprocessor Toolsmiths: Canada); M. Mills (US 
Air Force); D. Pogge (US Navy); K.  Power (Boeing); O. Roubine (Verdi x: France); A. Strohmeier (Swiss 
Fed Inst of Technology: Switzerland); W. Taylor (c onsultant: UK); J. Tokar (Tartan); E. Vasilescu 
(Grumman); J. Vladik (Prospeks s.r.o.: Czech Re public); S. Van Vlierberghe (OFFIS: Belgium).  
Other valuable feedback influencing the revision pr ocess was provided by the Ada 9X Language Precision 
Team (Odyssey Research Associates), the Ada 9X Us er/Implementer Teams (AETECH, Tartan, TeleSoft), 
the Ada 9X Implementation Analysis Team (New Yo rk University) and the Ada community-at-large. 
Special thanks go to R. Mathis, Convenor of ISO/IEC JTC 1/SC 22 Working Group 9.  
The Ada 9X Project was sponsored by the Ada Joint Program Office. Christine M. Anderson at the Air 
Force Phillips Laboratory (Kirtland AFB, NM) was the project manager. 
Acknowledgements for the Corrigendum version  
The editor [R. Brukardt (USA)] would like to thank th e many people whose hard work and assistance has 
made this update possible. 
Thanks go out to all of the members of the ISO/ IEC JTC 1/SC 22/WG 9 Ada Rapporteur Group, whose 
work on creating and editing the wording corrections was critical to the entire process. Especially valuable 
contributions came from the chairman of the ARG, E. Ploedereder (Germany),  who kept the process 
moving; J. Barnes (UK) and K. Is hihata (Japan), whose extremely de tailed reviews kept the editor on his 
toes; G. Dismukes (USA), M. Kamrad (USA), P. Leroy (France), S. Mich ell (Canada), T. Taft (USA), J. 
Tokar (USA), and other member s too numerous to mention. 65.10/3 
66 
67 
68 
69 
70 
71 
71.1/3 
71.2/1 
Ada Reference Manual — 2012 Edition 
Introduction 13 December 2012      xx Special thanks go to R. Duff (USA) for his explanati ons of the previous system  of formatting of these 
documents during the tedious conversi on to more modern formats. Special  thanks also go to the convenor 
of ISO/IEC JTC 1/SC 22/WG 9, J.  Moore (USA), without whose he lp and support the Corrigendum and 
this consolidated reference manua l would not have been possible. 
Acknowledgements for the Amendment 1 version  
The editor [R. Brukardt (USA)] would like to thank th e many people whose hard work and assistance has 
made this update possible. 
Thanks go out to all of the members of the ISO/ IEC JTC 1/SC 22/WG 9 Ada Rapporteur Group, whose 
work on creating and editing the wording corrections was critical to the entire process. Especially valuable 
contributions came from the chairman of the ARG, P. Leroy (France), who kept the process on schedule; J. 
Barnes (UK) whose careful reviews found many typogra phical errors; T. Taft (U SA), who always seemed 
to have a suggestion when we were st uck, and who also was usually able to provide the valuable service of 
explaining why things were as they are; S. Bair d (USA), who found many obscure problems with the 
proposals; and A. Burns (UK), who pushed many of the real-time proposals to completion. Other ARG 
members who contributed were: R. Dewar (USA), G. Dism ukes (USA), R. Duff (U SA), K. Ishihata 
(Japan), S. Michell (Canada), E. Ploedereder (Germa ny), J.P. Rosen (France) , E. Schonberg (USA), J. 
Tokar (USA), and T. Vardanega (Italy). 
Special thanks go to Ada-Europe and the Ada Resour ce Association, without whose help and support the 
Amendment and this consolidated reference manual would not have b een possible. M. Heaney (USA) 
requires special thanks for his tireless work on the containers packages. Finally, special thanks go to the convenor of ISO/IEC JTC 1/SC 22/WG 9, J. Moore (USA), w ho guided the document through the 
standardization process. 
Acknowledgements for the Ada 2012 edition  
The editor [R. Brukardt (USA)] would like to thank th e many people whose hard work and assistance has 
made this revision possible. 
Thanks go out to all of the members of the ISO/ IEC JTC 1/SC 22/WG 9 Ada Rapporteur Group, whose 
work on creating and editing the wording changes was cr itical to the entire process. Especially valuable 
contributions came from the chairman of the ARG, E. Schonberg (USA), who guided the work; T. Taft 
(USA), whose insights broke many l ogjams, both in design and wording;  J. Barnes (UK) whose careful 
reviews uncovered many editorial erro rs; S. Baird (USA), who repeatedly  found obscure interactions with 
the proposals that the rest of us missed. Other AR G members who substantially  contributed were: A. 
Burns (UK), J. Cousins (UK), R. Dewar (USA), G. Dismukes (USA), R. Duff (U SA), P. Leroy (France), 
B. Moore (Canada), E. Ploedereder (Germany), J.P. Rosen (France), B.  Thomas (USA), and T. Vardanega 
(Italy). 
Special thanks go to Ada-Europe and the Ada Resour ce Association, without w hose help and support this 
third edition of the Ada Standard would not have b een possible. A special mention has to go to A. 
Beneschan (USA) for his efforts in eliminating sloppiness in our wording.  M. Heaney (USA) also deserves 
a mention for his efforts to improve the containers p ackages. Finally, special thanks go to the convenor of 
ISO/IEC JTC 1/SC 22/WG 9, J. Tokar (USA), who guided the docum ent through the standardization 
process.  71.3/1 
71.4/3 
71.5/2 
71.6/2 
71.7/3 
71.8/3 
71.9/3 
Ada Reference Manual — 2012 Edition 
xxi      13 December 2012 Introduction Changes  
The International Standard is the same as th is version of the Reference Manual, except:  
• This list of Changes is not incl uded in the International Standard. 
• The “Acknowledgements” page is not in cluded in the International Standard. 
• The text in the running headers and footers on each page is slightly different in the International 
Standard. 
• The title page(s) are different in the International Standard. 
• This document is formatted for 8.5-by-11-inch paper, whereas the International Standard is 
formatted for A4 paper (210-by-297mm); thus, the page breaks are in different places. 
• This paragraph was deleted.  
• The “Using this version of the Ada Referen ce Manual” subclause is not included in the 
International Standard. 
• Paragraph numbers are not included in the International Standard.  
Using this version of the Ada Reference Manual  
This document has been revised with the correcti ons specified in Technical Corrigendum 1 (ISO/IEC 
8652:1995/COR.1:2001) and Amendment 1 (ISO/ IEC 8652/AMD 1:2007), along with changes 
specifically for this third edition. In addition, a va riety of editorial errors have been corrected.  
Changes to the original 8652:1995 can be identifie d by the version number following the paragraph 
number. Paragraphs with a version number of /1 were changed by Technical  Corrigendum 1 or were 
editorial corrections at that time, while paragra phs with a version number of /2 were changed by 
Amendment 1 or were more recent editorial corrections , and paragraphs with a version number of /3 were 
changed by the third (2012) edition of the Standard  or were still more recent editorial corrections. 
Paragraphs not so marked are unchanged by the thir d edition, Amendment 1, T echnical Corrigendum 1, or 
editorial corrections. Paragraph numbers of unchanged paragraphs are the same as in the 1995 edition of 
the Ada Reference Manual. In additi on, some versions of this documen t include revision bars near the 
paragraph numbers. Where paragraphs are inserted, th e paragraph numbers are of the form pp.nn, where 
pp is the number of the preceding paragraph, and nn is an insertion number. For instance, the first 
paragraph inserted after paragraph 8 is numbered 8.1, the second paragr aph inserted is numbered 8.2, and 
so on. Deleted paragraphs are indicated by the text This paragraph was deleted.  Deleted paragraphs include 
empty paragraphs that were numbered in th e 1995 edition of the Ada Reference Manual.  72 
73 
74 75 
76 
77 
77.1/3 
77.2/3 
77.3/3 
77.4/3 
77.5/3 

Ada Reference Manual — 2012 Edition 
1      13 December 2012 1   General  
1   General 
1.1 Scope 
This International Standard specifies the form and meaning of programs written in Ada. Its purpose is to 
promote the portability of Ada programs to a variety of computing systems. 
Ada is a programming language designed to support the construction of long-lived, highly reliable 
software systems. The language in cludes facilities to define packages  of related types, objects, and 
operations. The packages may be parameterized and th e types may be extended to support the construction 
of libraries of reusable, adaptable software co mponents. The operations may be implemented as 
subprograms using conventional sequentia l control structures, or as entries that include synchronization of 
concurrent threads of control as part of their invocation. Ada supports object-oriented programming by 
providing classes and interfaces, inheritance, polymor phism of variables and methods, and generic units. 
The language treats modularity in the physical sens e as well, with a facility to support separate 
compilation. 
The language provides rich support for real-time, concurrent programming, and includes facilities for 
multicore and multiprocessor programming. Errors can be signaled as exceptions and handled explicitly. 
The language also covers systems programming; this requires precise control over the representation of 
data and access to system-dependent properties. Finally, a predefined environment of standard packages is 
provided, including facilities for, among others, input -output, string manipulation, numeric elementary 
functions, and random number generation, and definition and use of containers. 
1.1.1 Extent 
This International Standard specifies:  
• The form of a program written in Ada; 
• The effect of translating and executing such a program; 
• The manner in which program units may be combined to form Ada programs; 
• The language-defined library units that a c onforming implementation is required to supply; 
• The permissible variations within the standa rd, and the manner in which they are to be 
documented; 
• Those violations of the standard that a confor ming implementation is required to detect, and the 
effect of attempting to translate or execu te a program containing such violations; 
• Those violations of the standard that a conf orming implementation is not required to detect.  
This International Standard does not specify:  
• The means whereby a program written in Ada is transformed into object code executable by a 
processor; 
• The means whereby translation or execution of  programs is invoked and the executing units are 
controlled; 1/3 
2/3 
3/3 
1 
2 
3 4 5 6 
7 8 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
1.1.1    Extent 13 December 2012      2 • The size or speed of the object code, or the relative execution speed of different language 
constructs; 
• The form or contents of any listings produced by implementations ; in particular, the form or 
contents of error or warning messages; 
• The effect of unspecified execution. 
• The size of a program or program unit that w ill exceed the capacity of a particular conforming 
implementation.  
1.1.2 Structure 
This International Standard contains thirteen  clauses, fifteen annexes, and an index. 
The core of the Ada language consists of:  
• Clauses 1 through 13 
• Annex A, “Predefined Language Environment” 
• Annex B, “Interface to Other Languages” 
• Annex J, “Obsolescent Features”  
The following Specialized Needs Annexes  define features that are needed by certain application areas:  
• Annex C, “Systems Programming” 
• Annex D, “Real-Time Systems” 
• Annex E, “Distributed Systems” 
• Annex F, “Information Systems” 
• Annex G, “Numerics” 
• Annex H, “High Integrity Systems”  
The core language and the Specialized Needs Annexes are normative, except that the material in each of 
the items listed below is informative:  
• Text under a NOTES or  Examples heading. 
• Each subclause whose title starts with the word “Example” or “Examples”.  
All implementations shall conform to the core la nguage. In addition, an implementation may conform 
separately to one or more Specialized Needs Annexes. 
The following Annexes are informative:  
• Annex K, “Language-Defined Aspects and Attributes” 
• Annex L, “Language-Defined Pragmas” 
• Annex M, “Summary of Do cumentation Requirements” 
• Annex N, “Glossary” 
• Annex P, “Syntax Summary” 
• Annex Q, “Language-Defined Entities” 12 
13 14 
15 
1/3 
2 
3/3 
4 5 6 
7 
8 
9 
10 11 12 13 
14 
15 
16/3 
17 
18 
19 
20 
21/3 
22 23 
23.1/3 
Ada Reference Manual — 2012 Edition 
3      13 December 2012 Structure   1.1.2 Each section is divided into  subc lauses that have a common structure. Each clause and subclause first 
introduces its subject. After the in troductory text, text is labele d with the following headings:  
Syntax 
Syntax rules (indented).  
Name Resolution Rules 
Compile-time rules that are used in name resolution, including overload resolution.  
Legality Rules 
Rules that are enforced at compile time. A construct is legal  if it obeys all of the Legality Rules.  
Static Semantics 
A definition of the compile-time effect of each construct.  
Post-Compilation Rules 
Rules that are enforced before running a partition. A pa rtition is legal if its compilation units are legal and 
it obeys all of the Post-Compilation Rules.  
Dynamic Semantics 
A definition of the run-time effect of each construct.  
Bounded (Run-Time) Errors 
Situations that result in bounded (run-time) errors (see 1.1.5).  
Erroneous Execution 
Situations that result in e rroneous execution (see 1.1.5).  
Implementation Requirements 
Additional requirements for c onforming implementations.  
Documentation Requirements 
Documentation requirements for conforming implementations.  
Metrics 
Metrics that are specified for the time/space propertie s of the execution of certain language constructs.  
Implementation Permissions 
Additional permissions give n to the implementer.  
Implementation Advice 
Optional advice given to the implementer. The word “should” is used to indicate that the advice is a 
recommendation, not a requirement. It is implementa tion defined whether or not a given recommendation 
is obeyed.  
NOTES 
1  Notes emphasize consequences of the rules described in the (sub)clause or elsewhere. This material is informative.  
Examples 
Examples illustrate the possible forms of the construc ts described. This material is informative.  24/3 
25 
26/3 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
Ada Reference Manual — 2012 Edition 
1.1.3    Conformity of an Implementation with the Standard 13 December 2012      4 1.1.3 Conformity of an Implementation with the Standard 
Implementation Requirements 
A conforming implementation shall:  
• Translate and correctly execute legal programs written in Ada, provided that they are not so 
large as to exceed the capacity of the implementation; 
• Identify all programs or program units that ar e so large as to exceed the capacity of the 
implementation (or raise an appropriate exception at run time);  
• Identify all programs or program units that cont ain errors whose detection is required by this 
International Standard;  
• Supply all language-defined library units re quired by this International Standard;  
• Contain no variations except those explicitly perm itted by this International Standard, or those 
that are impossible or impractical to avoid gi ven the implementation's execution environment;  
• Specify all such variations in the manner pr escribed by this International Standard.  
The external effect  of the execution of an Ada program is defi ned in terms of its interactions with its 
external environment. The following are defined as external interactions :  
• Any interaction with an external file (see A.7); 
• The execution of certain code_statement s (see 13.8); which code_statement s cause external 
interactions is impl ementation defined.  
• Any call on an imported subprogram (see Anne x B), including any parameters passed to it; 
• Any result returned or exception propagated fro m a main subprogram (see 10.2) or an exported 
subprogram (see Annex B) to  an external caller;  
• Any read or update of an atomic or volatile object (see C.6); 
• The values of imported and exported objects (see Annex B) at the time of any other interaction 
with the external environment.  
A conforming implementation of this International Standard shall produce for the execution of a given 
Ada program a set of interactions with the external  environment whose order and timing are consistent 
with the definitions and requirements of this Internati onal Standard for the semantics of the given program.  
An implementation that conforms to this Standa rd shall support each capability required by the core 
language as specified. In addition, an implementation th at conforms to this Standard may conform to one 
or more Specialized Needs Annexes (or to none). C onformance to a Specialized Needs Annex means that 
each capability required by the Annex is provided as specified.  
An implementation conforming to this International St andard may provide additional aspects, attributes, 
library units, and pragmas. However, it shall not provi de any aspect, attribute, library unit, or pragma 
having the same name as an aspect, attribute, library unit, or pragma (respectively) specified in a Specialized Needs Annex unless the provided construct is either as specified in the Specialized Needs 
Annex or is more limited in capability than that require d by the Annex. A program that attempts to use an 
unsupported capability of an Annex shall either be id entified by the implementation before run time or 
shall raise an exception at run time.  1 
2 
3 4 5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17/3 
Ada Reference Manual — 2012 Edition 
5      13 December 2012 Conformity of an Implementation with the Standard   1.1.3 Documentation Requirements 
Certain aspects of the semantics are defined to be either implementation defined  or unspecified . In such 
cases, the set of possible effects is specified, and th e implementation may choose any effect in the set. 
Implementations shall document their behavior in implementation-define d situations, but documentation is 
not required for unspecified situati ons. The implementation-defined characteristics are summarized in M.2.  
The implementation may choose to document implementation-defined be havior either by documenting 
what happens in general, or by providing some mechanism for the user  to determine what happens in a 
particular case.  
Implementation Advice 
If an implementation detects the us e of an unsupported Specialized Need s Annex feature at run time, it 
should raise Program_Error if feasible.  
If an implementation wishes to provide implementa tion-defined extensions to the functionality of a 
language-defined library unit, it should normally do so by adding children to the library unit.  
NOTES 
2  The above requirements imply that an implementation conforming to this Standard may support some of the capabilities required by a Specialized Needs Annex without supporting all required capabilities.  
1.1.4 Method of Description and Syntax Notation 
The form of an Ada program is de scribed by means of a context-free syntax together with context-
dependent requirements expr essed by narrative rules. 
The meaning of Ada programs is described by means of narrative rules defining both the effects of each 
construct and the compositi on rules for constructs. 
The context-free syntax of the language is describe d using a simple variant of Backus-Naur Form. In 
particular:  
• Lower case words in a sans-serif font, some containing embedded underlines, are used to denote 
syntactic categories, for example:  
case_statement  
• Boldface words are used to denote reserved words, for example:  
array  
• Square brackets enclose optional items. Thus  the two following rules are equivalent.  
simple_return_statement  ::= return  [expression ]; 
simple_return_statement  ::= return ; | return  expression ; 
• Curly brackets enclose a repeated item. The ite m may appear zero or more times; the repetitions 
occur from left to right as with an equivalent left-recursive rule. Thus the two following rules are 
equivalent.  
term  ::= factor  {multiplying_operator  factor } 
term  ::= factor  | term  multiplying_operator  factor  
• A vertical line separates alternative items unl ess it occurs immediately after an opening curly 
bracket, in which case it stands for itself:  
constraint  ::= scalar_constraint  | composite_constraint  
discrete_choice_list  ::= discrete_choice  {| discrete_choice } 18 
19 
20 
21 
22 
1 
2 3 
4 
5 
6 
7 
8 
9/2 
10 
11 
12 
13 
Ada Reference Manual — 2012 Edition 
1.1.4    Method of Description and Synt ax Notation 13 December 2012      6 • If the name of any syntactic category starts with an italicized part, it is equivalent to the category 
name without the italicized part. The italicized  part is intended to convey some semantic 
information. For example subtype_ name  and task_ name  are both equivalent to name  alone.  
The delimiters, com pound delimiters, reserved words, and numeric_literal s are exclusively made of the 
characters whose code point is between 16#20# and 16#7E#,  inclusively. The special characters for which 
names are defined in this Interna tional Standard (see 2.1) belong to the same range. For example, the 
character E in the definition of exponent  is the character whose name  is “LATIN CAPITAL LETTER E”, 
not “GREEK CAPITAL LETTER EPSILON”.  
When this International Standard me ntions the conversion of some character or sequence of characters to 
upper case, it means the character or sequence of ch aracters obtained by using simple upper case mapping, 
as defined by documents referenced in the note in Clause 1 of ISO/IEC 10646:2011.  
A syntactic category  is a nonterminal in the grammar defined in BNF under “Syntax.” Names of syntactic 
categories are set in a different font, like_this .  
A construct  is a piece of text (explicit or implicit) that is  an instance of a syntactic category defined under 
“Syntax”.  
A constituent  of a construct is the construct itself,  or any construct appearing within it. 
Whenever the run-time semantics defines certain actions to happen in an arbitrary order , this means that 
the implementation shall arrange for these actions to o ccur in a way that is equivalent to some sequential 
order, following the rules that result from that sequentia l order. When evaluations are defined to happen in 
an arbitrary order, with conversion of the results to  some subtypes, or with some run-time checks, the 
evaluations, conversions, and checks may be arbitrar ily interspersed, so long as each expression is 
evaluated before converting or checking its value. No te that the effect of a program can depend on the 
order chosen by the implementation. This can happen, for example, if tw o actual parameters of a given call 
have side effects.  
NOTES 
3  The syntax rules describing structured constructs are presented in a form that corresponds to the recommended paragraphing. For example, an 
if_statement  is defined as:  
if_statement  ::= 
    if condition then 
      sequence_of_statements  
   {elsif condition then 
      sequence_of_statements } 
   [else 
      sequence_of_statements ] 
    end if; 
4  The line breaks and indentation in the syntax rules indicate the recommended line breaks and indentation in the 
corresponding constructs. The pref erred places for other line br eaks are after semicolons.  
1.1.5 Classification of Errors 
Implementation Requirements 
The language definition classifies errors  into several different categories:  
• Errors that are required to be detected prior to run time by every Ada implementation; 
 These errors correspond to any violation of a rule given in this International Standard, other than 
those listed below. In particular, violation of any rule that uses the terms shall, allowed, 
permitted, legal, or illegal belongs to this categor y. Any program that contains such an error is 14 
14.1/3 
14.2/3 
15 
16 17 
18 
19 
20 
21 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
7      13 December 2012 Classification of Errors   1.1.5 not a legal Ada program; on the other hand, the fact that a program is legal does not mean, per 
se, that the program is free from other forms of error. 
 The rules are further classified as either compile time rules, or post compilation rules, depending 
on whether a violation has to be detected at the time a compilation unit is submitted to the compiler, or may be postponed until the time a co mpilation unit is incorporated into a partition 
of a program.  
• Errors that are required to be detected at run time by the execution of an Ada program; 
 The corresponding error situations are associated  with the names of the predefined exceptions. 
Every Ada compiler is required to generate code  that raises the corresponding exception if such 
an error situation arises during program execution. If such an error situation is certain to arise in 
every execution of a construct, then an impl ementation is allowed (although not required) to 
report this fact at compilation time. 
• Bounded errors; 
 The language rules define certain kinds of errors that need not be detected either prior to or 
during run time, but if not detected, the range of  possible effects shall be bounded. The errors of 
this category are called bounded errors . The possible effects of a given bounded error are 
specified for each such error, but in any case one  possible effect of a bounded error is the raising 
of the exception Program_Error. 
• Erroneous execution. 
 In addition to bounded errors, the language rules de fine certain kinds of errors as leading to 
erroneous execution . Like bounded errors, the implementation n eed not detect such errors either 
prior to or during run time. Unlike bounded erro rs, there is no language-specified bound on the 
possible effect of erroneous execution; the effect is in general not predictable.  
Implementation Permissions 
An implementation may provide nonstandard modes  of operation. Typically these modes would be 
selected by a pragma  or by a command line switch when the compiler is invoked. When operating in a 
nonstandard mode, the impl ementation may reject compilation_unit s that do not conform to additional 
requirements associated with the mode, such as an excessive number of warnings  or violation of coding 
style guidelines. Similarly, in a nons tandard mode, the implementation ma y apply special optimizations or 
alternative algorithms that are only meaningful for pr ograms that satisfy certain criteria specified by the 
implementation. In any case, an  implementation shall support a standard  mode that conforms to the 
requirements of this International Standard; in  particular, in the standard mode, all legal compilation_unit s 
shall be accepted.  
Implementation Advice 
If an implementation detects a bounded error or err oneous execution, it should raise Program_Error.  
1.2 Normative References 
The following documents, in whole or  in part, are normatively referenced in this document and are 
indispensable for its application. For dated refe rences, only the edition cited applies. For undated 
references, the latest edition of the referenced  document (including any amendments) applies. 
ISO 639-3:2007, Codes for the representation of names of languages — Part 3: Alpha-3 code for 
comprehensive coverage of languages . 
ISO/IEC 646:1991, Information technology — ISO 7-bit coded character set for information interchange . 4 
5 
6 
7 
8 
9 
10 
11 
12 
1/3 
1.1/3 
2 
Ada Reference Manual — 2012 Edition 
1.2   Normative References 13 December 2012      8 ISO/IEC 1539-1:2004, Information technology — Programming languages — Fortran — Part 1: Base 
language . 
ISO/IEC 1989:2002, Information technology — Programming languages — COBOL . 
ISO/IEC 3166-1:2006, Codes for the representation of names of  countries and their subdivisions — Part 
1: Country Codes . 
ISO/IEC 6429:1992, Information technology — Control func tions for coded graphic character sets . 
ISO 8601:2004, Data elements and interchange formats — In formation interchange — Representation of 
dates and times . 
ISO/IEC 8859-1:1998, Information technology — 8-bit single-byte coded graphic character sets — Part 1: 
Latin alphabet No. 1 . 
ISO/IEC 9899:2011, Information technology — Programming languages — C .  
ISO/IEC 10646:2011, Information technology — Universal Multip le-Octet Coded Character Set (UCS) . 
ISO/IEC 14882:2011, Information technology — Programming languages — C++ .  
ISO/IEC TR 19769:2004, Information technology — Programmi ng languages, their environments and 
system software interfaces — Extensions for th e programming language C to support new character data 
types . 
1.3 Terms and Definitions 
Terms are defined throughout this Inte rnational Standard, indicated by italic  type. Terms explicitly defined 
in this International Standard are not to be presumed to refer implicitly to similar terms defined elsewhere. 
Mathematical terms not defined in this Internationa l Standard are to be interpreted according to the CRC 
Concise Encyclopedia of Mathematics, Second Edition . Other terms not defined in this International 
Standard are to be interpreted according to the Webster's Third New International Dictionary of the 
English Language . Informal descriptions of some terms ar e also given in Annex N, “Glossary”.  3/2 
4/2 
4.1/3 
5 
5.1/2 
6/3 7/3 
8/3 9/3 
10/2 
1/2 
Ada Reference Manual — 2012 Edition 
9      13 December 2012 Lexical Elements   2 2   Lexical Elements 
The text of a program consists of the texts of one or more compilation s. The text of a compilation  is a 
sequence of lexical elements, each composed of char acters; the rules of composition are given in this 
clause. Pragma s, which provide certain information for the co mpiler, are also described in this clause.  
2.1 Character Set 
The character repertoire for the text of an Ada progr am consists of the entire coding space described by the 
ISO/IEC 10646:2011 Universal Multiple-Octet Coded Char acter Set. This coding space is organized in 
planes , each plane comprising 65536 characters.  
Syntax 
Paragraphs 2 and 3 were deleted.   
A character  is defined by this International Standard for each cell in the coding space described by 
ISO/IEC 10646:2011, regardless of whether or not ISO/IEC 10646:2011 allocates a character to that 
cell.  
Static Semantics 
The coded representation for characters is implementati on defined (it need not be a representation defined 
within ISO/IEC 10646:2011). A character whose rela tive code point in its plane is 16#FFFE# or 
16#FFFF# is not allowed anywhere in the text of a program. The only characters allowed outside of comments are those in categories 
other_format , format_effector , and graphic_character .  
The semantics of an Ada program whose text is not in Normalization Form KC (as defined by Clause 21 
of ISO/IEC 10646:2011) is implementation defined.  
The description of the language definition in this In ternational Standard uses the character properties 
General Category, Simple Upper case Mapping, Uppercase Mapping, a nd Special Case Condition of the 
documents referenced by the note in Clause 1 of  ISO/IEC 10646:2011. The actual set of graphic symbols 
used by an implementation for the visual representati on of the text of an Ada program is not specified.  
Characters are categorized as follows:  
 This paragraph was deleted.  
letter_uppercase  
 Any character whose General Category is  defined to be “Letter, Uppercase”. 
letter_lowercase  
 Any character whose General Category is defined to be “Letter, Lowercase”.  
letter_titlecase  
 Any character whose General Category is defined to be “Letter, Titlecase”. 
letter_modifier  
 Any character whose General Category is  defined to be “Letter, Modifier”. 
letter_other  
 Any character whose General Category is defined to be “Letter, Other”. 
mark_non_spacing  
 Any character whose General Category is  defined to be “Mark, Non-Spacing”. 
mark_spacing_combining  
 Any character whose General Category is defined to be “Mark, Spacing Combining”. 1/3 
1/3 
3.1/3 
4/3 
4.1/3 
5/3 
6/3 
7/2 
8/2 
9/2 
9.1/2 9.2/2 9.3/2 9.4/2 9.5/2 
Ada Reference Manual — 2012 Edition 
2.1   Character Set 13 December 2012      10 number_decimal  
 Any character whose General Category is  defined to be “Number, Decimal”. 
number_letter  
 Any character whose General Category is defined to be “Number, Letter”. 
punctuation_connector  
 Any character whose General Category is defined to be “Punctuation, Connector”. 
other_format  
 Any character whose General Category is defined to be “Other, Format”. 
separator_space  
 Any character whose General Category is defined to be “Separator, Space”. 
separator_line  
 Any character whose General Category is defined to be “Separator, Line”.  
separator_paragraph  
 Any character whose General Category is defined to be “Separator, Paragraph”. 
format_effector  
 The characters whose code points are 16#09# (CHARACTER TABULATION), 16#0A# 
(LINE FEED), 16#0B# (LINE TABULA TION), 16#0C# (FORM FEED), 16#0D# 
(CARRIAGE RETURN), 16#85# (NEXT LINE),  and the characters in categories 
separator_line  and separator_paragraph .  
other_control  
 Any character whose General Category is define d to be “Other, Control”, and which is not 
defined to be a format_effector . 
other_private_use  
 Any character whose General Category is defined to be “Other, Private Use”. 
other_surrogate  
 Any character whose General Category is  defined to be “Other, Surrogate”. 
graphic_character  
 Any character that is not in the categories other_control , other_private_use , 
other_surrogate , format_effector , and whose relative code point  in its plane is neither 
16#FFFE# nor 16#FFFF#.  
The following names are used when referring to certain ch aracters (the first name is that given in ISO/IEC 
10646:2011):  
  graphic symbol 
         " 
         #          &          '          (          )          *          +          ,          –          .  name 
quotation mark 
number sign ampersand apostrophe, tick left parenthesis right parenthesis asterisk, multiply plus sign comma hyphen-minus, minus full stop, dot, point   graphic symbol 
         : 
         ;          <          =          >          _          |          /          !          %  name 
colon 
semicolon less-than sign equals sign greater-than sign low line, underline vertical line solidus, divide exclamation point percent sign  10/2 
10.1/2 10.2/2 10.3/2 
11/2 12/2 
12.1/2 
13/3 
13.1/2 
13.2/2 
13.3/2 
14/3 
15/3 
Ada Reference Manual — 2012 Edition 
11      13 December 2012 Character Set   2.1 Implementation Requirements 
An Ada implementation shall accept Ada source code in UTF-8 encoding, with or without a BOM (see 
A.4.11), where every character is represented by  its code point. The character pair CARRIAGE 
RETURN/LINE FEED (code points 16#0D# 16#0A#) signifi es a single end of line (see 2.2); every other 
occurrence of a format_effector  other than the character whose code point position is 16#09# 
(CHARACTER TABULATION) also signifies a single end of line. 
Implementation Permissions 
The categories defined above, as well as case mapping and folding, may be based on an implementation-
defined version of ISO/IEC 10646 (2003 edition or later).  
NOTES 
1  The characters in categories other_control , other_private_use , and other_surrogate  are only allowed in comments. 
2.2 Lexical Elements, Separators, and Delimiters 
Static Semantics 
The text of a program consists of the texts of one or more compilation s. The text of each compilation  is a 
sequence of separate lexical elements . Each lexical element is formed from a sequence of characters, and 
is either a delimiter, an identifier , a reserved word, a numeric_literal , a character_literal , a string_literal , or 
a comment. The meaning of a program depends only on th e particular sequences of lexical elements that 
form its compilation s, excluding comment s. 
The text of a compilation  is divided into lines . In general, the representation for an end of line is 
implementation defined. However,  a sequence of one or more format_effector s other than the character 
whose code point is 16#09# (CHARACTER TABULATION)  signifies at least one end of line.  
In some cases an explicit separator  is required to separate adjacent lexical elements. A separator is any of 
a separator_space , a format_effector , or the end of a line, as follows:  
• A separator_space  is a separator except within a comment , a string_literal , or a 
character_literal . 
• The character whose code point is 16#09# (CHARACTER TABULATION) is a separator 
except within a comment . 
• The end of a line is always a separator.  
One or more separators are allowed between any two adjacent lexical elements, before the first of each 
compilation , or after the last. At least one separator is required between an identifier , a reserved word, or a 
numeric_literal  and an adjacent identifier , reserved word, or numeric_literal . 
One or more other_format  characters are allowed anywhere that a separator is; any such characters have 
no effect on the meaning of an Ada program. 
A delimiter  is either one of the following characters:  
&    '    (    )    *    +    ,    –    .    /    :    ;    <    =    >    | 
or one of the following compound delimiters  each composed of two adjacent special characters  
=>    ..    **    :=    /=    >=    <=    <<    >>    <> 16/3 
17/3 
18/2 
1 
2/3 
3/2 
4/2 
5/3 
6 
7 
7.1/3 
8/2 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
2.2   Lexical Elements, Separators, and Delimiters 13 December 2012      12 Each of the special characters listed for single char acter delimiters is a single delimiter except if this 
character is used as a ch aracter of a compound delimiter,  or as a character of a comment , string_literal , 
character_literal , or numeric_literal . 
The following names are used when  referring to compound delimiters: 
  
 delimiter  name 
 => arrow 
 .. double dot 
 ** double star, exponentiate 
 := assignment (pronounced: “becomes”) 
 /= inequality (pronounced: “not equal”) 
 >= greater than or equal 
 <= less than or equal 
 << left label bracket 
 >> right label bracket 
 <> box 
  
Implementation Requirements 
An implementation shall suppor t lines of at least 200 characters in le ngth, not counting any characters used 
to signify the end of a line. An implementation shall support lexical elements of at least 200 characters in 
length. The maximum supported line length and lexical  element length are impl ementation defined.  
2.3 Identifiers 
Identifier s are used as names.  
Syntax 
identifier ::=  
   identifier_start  {identifier_start  | identifier_extend } 
identifier_start ::=  
     letter_uppercase  
   | letter_lowercase  
   | letter_titlecase  
   | letter_modifier  
   | letter_other  
   | number_letter  
identifier_extend ::=  
     mark_non_spacing  
   | mark_spacing_combining  
   | number_decimal  
   | punctuation_connector  
An identifier  shall not contain two consecutive characters in category punctuation_connector , or end 
with a character in that category.  12 
13 
14 
1 
2/2 
3/2 
3.1/3 
4/3 
Ada Reference Manual — 2012 Edition 
13      13 December 2012 Identifiers   2.3 Static Semantics 
Two identifier s are considered the same if they consist of the same sequence of characters after applying 
locale-independent simple case foldi ng, as defined by documents referenced in the note in Clause 1 of 
ISO/IEC 10646:2011.  
After applying simple case folding, an identifier  shall not be identical to a reserved word.  
Implementation Permissions 
In a nonstandard mode, an implem entation may support other upper/lo wer case equivalence rules for 
identifier s, to accommodate local conventions.  
NOTES 
2  Identifier s differing only in the use of corresponding upper and lower case letters are considered the same.  
Examples 
Examples of identifiers:   
Count      X    Get_Symbol   Ethelyn   Marion 
Snobol_4   X1   Page_Count   Store_Next_Item Πλάτων      --  Plato 
Чайковский   --  Tchaikovsky  
θ  φ        --  Angles 
2.4 Numeric Literals 
There are two kinds of numeric_literal s, real literals  and integer literals . A real literal is a numeric_literal  
that includes a point; an integer literal is a numeric_literal  without a point.  
Syntax 
numeric_literal ::= decimal_literal  | based_literal  
NOTES 
3  The type of an integer literal is universal_integer . The type of a real literal is universal_real .  
2.4.1 Decimal Literals 
A decimal_literal  is a numeric_literal  in the conventional decimal notation (that is, the base is ten).  
Syntax 
decimal_literal ::= numeral  [.numeral ] [exponent ] 
numeral ::= digit  {[underline ] digit} 
exponent ::= E [+] numeral  | E – numeral  
digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
An exponent  for an integer literal shall not have a minus sign.  
Static Semantics 
An underline character in a numeric_literal  does not affect its meaning. The letter E of an exponent  can be 
written either in lower case or in uppe r case, with the same meaning.  
An exponent  indicates the power of ten by which the value of the decimal_literal  without the exponent  is 
to be multiplied to obtain the value of the decimal_literal  with the exponent .  5/3 
5.1/3 
6 
6.1/2 
7 
8/2 
1 
2 
3 
1 
2 
3 4 
4.1/2 
5 
6 
7 
Ada Reference Manual — 2012 Edition 
2.4.1    Decimal Literals 13 December 2012      14 Examples 
Examples of decimal literals:   
12        0      1E6    123_456    --   integer literals  
 12.0      0.0    0.456  3.14159_26 --   real literals  
2.4.2 Based Literals 
A based_literal  is a numeric_literal  expressed in a form that specifies the base explicitly.  
Syntax 
based_literal ::=  
   base  # based_numeral  [.based_numeral ] # [exponent ] 
base ::= numeral  
based_numeral ::=  
   extended_digit  {[underline ] extended_digit } 
extended_digit ::= digit  | A | B | C | D | E | F 
Legality Rules 
The base (the numeric value of the decimal numeral  preceding the first #) shall be at least two and at most 
sixteen. The extended_digit s A through F represent the digits ten through fifteen, respectively. The value 
of each extended_digit  of a based_literal  shall be less than the base.  
Static Semantics 
The conventional meaning of ba sed notation is assumed. An exponent  indicates the power of the base by 
which the value of the based_literal  without the exponent  is to be multiplied to obtain the value of the 
based_literal  with the exponent . The base  and the exponent , if any, are in decimal notation. 
The extended_digit s A through F can be written either in lower case or in upper case, with the same 
meaning.  
Examples 
Examples of based literals:   
2#1111_1111#  16#FF#       016#0ff#   --   integer literals of value 255  
16#E#E1       2#1110_0000#            --   integer literals of value 224  
16#F.FF#E+2   2#1.1111_1111_1110#E11  --   real literals of value 4095.0  
2.5 Character Literals 
A character_literal  is formed by enclosing a graphic char acter between two apostrophe characters.  
Syntax 
character_literal ::= 'graphic_character ' 
NOTES 
4  A character_literal  is an enumeration literal of a character type. See 3.5.2.  8 
9 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
15      13 December 2012 Character Literals   2.5 Examples 
Examples of character literals:   
'A'     '*'     '''     ' ' 
'L'     ' Л'     ' Λ'    --  Various els.  
'∞'     ' א--            '  Big numbers - infinity and aleph.  
2.6 String Literals 
A string_literal  is formed by a sequence of graphic char acters (possibly none) enclosed between two 
quotation marks used as string bracket s. They are used to represent operator_symbol s (see 6.1), values of 
a string type (see 4.2), and array subaggregates (see 4.3.3).  
Syntax 
string_literal ::= "{string_element }" 
string_element ::= "" | non_quotation_mark_ graphic_character  
A string_element  is either a pair of quotation marks (""), or a single graphic_character  other than a 
quotation mark.  
Static Semantics 
The sequence of characters  of a string_literal  is formed from the sequence of string_element s between the 
bracketing quotation marks, in the given order, with a string_element  that is "" becoming a single 
quotation mark in the sequence of characters, and any other string_element  being reproduced in the 
sequence. 
A null string literal  is a string_literal  with no string_element s between the quotation marks. 
NOTES 
5  An end of line cannot appear in a string_literal . 
6  No transformation is performed on the sequence of characters of a string_literal .  
Examples 
Examples of string literals:   
"Message of the day:" 
 ""                    --   a null string literal  
" "   "A"   """"      --   three string literals of length 1  
 "Characters such as $, %, and } are allowed in string literals" "Archimedes said "" Εύρηκα""" 
"Volume of cylinder ( πr²h) = " 
2.7 Comments 
A comment  starts with two adjacent hyphens and extends up to the end of the line.  
Syntax 
comment ::= --{non_end_of_line_ character } 
A comment  may appear on any line of a program.  4 
5/2 
1 
2 
3 4 
5 
6 
7 
7.1/2 
8 
9/2 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
2.7   Comments 13 December 2012      16 Static Semantics 
The presence or absence of comment s has no influence on whether a program is legal or illegal. 
Furthermore, comment s do not influence the meaning of a program; their sole purpose is the 
enlightenment of the human reader.  
Examples 
Examples of comments:   
--  the last sentence above echoes the Algol 68 report  
 end;  --   processing of Line is complete  
 --  a long comment may be split onto  
--  two or more consecutive lines    
 ----------------   the first two hyphens start the comment   
2.8 Pragmas 
A pragma is a compiler directive. There are langua ge-defined pragmas that give instructions for 
optimization, listing control, etc. An implementa tion may support additional (implementation-defined) 
pragmas.  
Syntax 
pragma ::=  
   pragma  identifier  [(pragma_argument_association  {, pragma_argument_association })]; 
pragma_argument_association ::=  
     [pragma_argument_ identifier  =>] name  
   | [pragma_argument_ identifier  =>] expression  
   | pragma_argument_ aspect_mark  =>  name  
   | pragma_argument_ aspect_mark  =>  expression  
In a pragma , any pragma_argument_association s without a pragma_argument_ identifier  or 
pragma_argument_ aspect_mark  shall precede any associations with a pragma_argument_ identifier  
or pragma_argument_ aspect_mark . 
Pragma s are only allowed at the following places in a program:  
• After a semicolon delimiter, but not within a formal_part  or discriminant_part . 
• At any place where the syntax rules allow a construct defined by a syntactic category 
whose name ends with “ declaration ”, “item”, “statement ”, “clause ”, or “ alternative ”, or 
one of the syntactic categories variant  or exception_handler ; but not in place of such a 
construct if the construct is required, or is part  of a list that is required to have at least one 
such construct. 
• In place of a statement  in a sequence_of_statements . 
• At any place where a compilation_unit  is allowed.  
Additional syntax rules and placement restrictions exist for specific pragmas.  
The name  of a pragma  is the identifier following the reserved word pragma . The name  or expression  of 
a pragma_argument_association  is a pragma argument . 
An identifier specific to a pragma  is an identifier or reserved word th at is used in a pragma argument with 
special meaning for that pragma.  4 
5 
6 
1 
2 
3/3 
4/3 
5 
6 
7/3 
7.1/3 
7.2/3 
8 9 
10/3 
Ada Reference Manual — 2012 Edition 
17      13 December 2012 Pragmas   2.8 Static Semantics 
If an implementation does not recognize the name of a pragma , then it has no effect on the semantics of 
the program. Inside such a pragma , the only rules that apply are the Syntax Rules.  
Dynamic Semantics 
Any pragma  that appears at the place of an executable c onstruct is executed. Unless otherwise specified 
for a particular pragma, this execution consists of th e evaluation of each evaluable pragma argument in an 
arbitrary order.  
Implementation Requirements 
The implementation shall give a warning me ssage for an unrecognized pragma name.  
Implementation Permissions 
An implementation may provide impl ementation-defined pragmas; the na me of an implementation-defined 
pragma shall differ from those of the language-defined pragmas.  
An implementation may ignore an unrecognized pragma even  if it violates some of the Syntax Rules, if 
detecting the syntax error is too complex.  
Implementation Advice 
Normally, implementation-defined pr agmas should have no semantic eff ect for error-free programs; that 
is, if the implementation-defined pragmas in a work ing program are replaced with unrecognized pragmas, 
the program should still be legal, and s hould still have the same semantics.  
Normally, an implementation should not define pragmas that can make an illegal program legal, except as 
follows:  
• A pragma  used to complete a declaration; 
• A pragma  used to configure the environmen t by adding, removing, or replacing library_item s.  
Syntax 
The forms of List, Page, and Optimize pragma s are as follows: 
  pragma  List( identifier ); 
  pragma  Page; 
  pragma  Optimize( identifier ); 
Other pragmas are defined throughout this Internati onal Standard, and are summarized in Annex L.  
Static Semantics 
A pragma  List takes one of the identifier s On or Off as the single argument. This pragma is allowed 
anywhere a pragma  is allowed. It specifies that listing of th e compilation is to be continued or suspended 
until a List pragma  with the opposite argument is given within the same compilation. The pragma  itself is 
always listed if the compiler is producing a listing. 
A pragma  Page is allowed anywhere a pragma  is allowed. It specifies that the program text which follows 
the pragma  should start on a new page (if the compiler is currently producing a listing). 
A pragma  Optimize takes one of the identifier s Time, Space, or Off as the single argument. This pragma  
is allowed anywhere a pragma  is allowed, and it applies until the end of the immediately enclosing 
declarative region, or for a pragma  at the place of a compilation_unit , to the end of the compilation . It 11 
12 
13 
14 
15 
16/3 
17 
18/3 
19 
20 
21 
22 23 24 
25 
26 
27 
Ada Reference Manual — 2012 Edition 
2.8   Pragmas 13 December 2012      18 gives advice to the implementation as to whether time or space is the primary optimization criterion, or 
that optional optimizations should be turned off. It is implementation de fined how this advice is followed.  
Examples 
Examples of pragmas:   
pragma List(Off); -- turn off listing generation  
pragma Optimize(Off); -- turn off optional optimizations  
pragma Pure(Rational_Numbers); -- set categorization for package  
pragma Assert(Exists(File_Name), 
              Message => "Nonexistent file"); -- assert file exists  
2.9 Reserved Words 
Syntax 
This paragraph was deleted.  
The following are the reserved words . Within a program, some or all of  the letters of a reserved word 
may be in upper case.  
abort  
abs 
abstract  
accept  
access  
aliased  
all 
and 
array  
at 
begin  
body  
case 
constant  
declare  
delay  
delta  
digits  
do else 
elsif 
end 
entry  
exception  
exit 
for 
function  
generic  
goto 
if 
in 
interface  
is 
limited  
loop 
mod  new 
not 
null 
of 
or 
others  
out 
overriding  
package  
pragma  
private  
procedure  
protected  
raise  
range  
record  
rem 
renames  
requeue  return  
reverse  
select  
separate  
some  
subtype  
synchronized  
tagged  
task 
terminate  
then  
type 
until  
use 
when  
while  
with  
xor 
NOTES 
7  The reserved words appear in lower case boldface  in this International Standard, except when used in the designator  of 
an attribute (see 4.1.4). Lower case boldface is also used for a reserved word in a string_literal  used as an 
operator_symbol . This is merely a convention — pr ograms may be written in whatever ty peface is desired and available.  28 
29/3 
1/1 
2/3 
3 
Ada Reference Manual — 2012 Edition 
19      13 December 2012 Declarations and Types   3 3   Declarations and Types 
This clause describes the types in the language and th e rules for declaring consta nts, variables, and named 
numbers.  
3.1 Declarations 
The language defines se veral kinds of named entities  that are declared by declarations. The entity's name  
is defined by the declaration, usually by a defining_identifier , but sometimes by a defining_character_-
literal  or defining_operator_symbol . 
There are several forms of declaration. A basic_declaration  is a form of declara tion defined as follows.  
Syntax 
basic_declaration ::=  
     type_declaration  | subtype_declaration  
   | object_declaration  | number_declaration  
   | subprogram_declaration  | abstract_subprogram_declaration  
   | null_procedure_declaration  | expression_function_declaration  
   | package_declaration  | renaming_declaration  
   | exception_declaration  | generic_declaration  
   | generic_instantiation  
defining_identifier ::= identifier  
Static Semantics 
A declaration  is a language construct that associates a name  with (a view of) an entity. A declaration may 
appear explicitly in the program text (an explicit  declaration), or may be supposed to occur at a given place 
in the text as a consequence of th e semantics of another construct (an implicit  declaration).  
Each of the following is defined to be a declaration: any basic_declaration ; an enumeration_literal_-
specification ; a discriminant_specification ; a component_declaration ; a loop_parameter_specification ; 
an iterator_specification ; a parameter_specification ; a subprogram_body ; an extended_return_object_-
declaration ; an entry_declaration ; an entry_index_specification ; a choice_parameter_specification ; a 
generic_formal_parameter_declaration .  
All declarations contain a definition  for a view of an entity. A view consists  of an identification of the 
entity (the entity of the view), plus view-speci fic characteristics that affect  the use of the entity through 
that view (such as mode of access to an object, form al parameter names and defaults for a subprogram, or 
visibility to components of a type). In most cases, a declaration also contains the definition for the entity 
itself (a renaming_declaration  is an example of a declaration that does not define a new entity, but instead 
defines a view of an existing entity (see 8.5)). 
When it is clear from context, the term object  is used in place of view of an object . Similarly, the terms 
type and subtype  are used in place of view of a type  and view of a subtype , respectively. 
For each declaration, the language rules de fine a certain region of text called the scope  of the declaration 
(see 8.2). Most declarations associate an identifier  with a declared entity. With in its scope, and only there, 
there are places where it is possible to use the identifier  to refer to the declaration, the view it defines, and 
the associated entity; these places are defined by the visibility rules (see 8.3). At such places the identifier  
is said to be a name  of the entity (the direct_name  or selector_name ); the name is said to denote  the 1/3 
1 
2 
3/3 
4 
5 
6/3 
7 
7.1/3 
8 
Ada Reference Manual — 2012 Edition 
3.1   Declarations 13 December 2012      20 declaration, the view, and the associated en tity (see 8.6). The declaration is said to declare  the name, the 
view, and in most cas es, the entity itself. 
As an alternative to an identifier , an enumeration literal can be declared with a character_literal  as its 
name (see 3.5.1), and a function can be declared with an operator_symbol  as its name (see 6.1). 
The syntax rules use the terms defining_identifier , defining_character_literal , and defining_operator_-
symbol  for the defining occurrence of a name; these are collectively called defining names . The terms 
direct_name  and selector_name  are used for usage occurrences of identifier s, character_literal s, and 
operator_symbol s. These are collectively called usage names .  
Dynamic Semantics 
The process by which a construct achieves its run-time effect is called execution . This process is also 
called elaboration  for declarations and evaluation  for expressions. One of the terms execution, 
elaboration, or evaluation is defined by this Intern ational Standard for each construct that has a run-time 
effect.  
NOTES 
1  At compile time, the declaration of an entity declares  the entity. At run time, the elaboration of the declaration creates  
the entity.  
3.2 Types and Subtypes 
Static Semantics 
A type is characterized by a set of values, and a set of primitive operations  which implement the 
fundamental aspects of its semantics. An object  of a given type is a run-time entity that contains (has) a 
value of the type.  
Types are grouped into categories  of types. There exist several language-defined categories  of types (see 
NOTES below), reflecting the similarity of their valu es and primitive operations. Most categories of types 
form classes  of types. Elementary  types are those whose values are logically indivisible; composite  types 
are those whose values are composed of component  values.  
The elementary types are the scalar  types ( discrete  and real) and the access  types (whose values provide 
access to objects or subprograms). Discrete types are either integer  types or are defined by enumeration of 
their values ( enumeration  types). Real types are either floating point  types or fixed point  types. 
The composite types are the record  types, record extensions , array  types, interface  types, task types, and 
protected  types.  
There can be multiple views of a type with varying sets of operations. An incomplete  type represents an 
incomplete view (see 3.10.1) of a type with a very restricted usage, providing support for recursive data 
structures. A private  type or private extension  represents a partial view (see 7.3) of a type, providing 
support for data abstraction. The full view (see 3.2.1) of a type represents its complete definition. An 
incomplete or partial view is considered a composite type, even if the full view is not.  
Certain composite types (and views th ereof) have special components called discriminants  whose values 
affect the presence, constraints, or initialization of other components. Discrimina nts can be thought of as 
parameters of the type. 
The term subcomponent  is used in this International Standard in place of the term component to indicate 
either a component, or a component of another s ubcomponent. Where other s ubcomponents are excluded, 9 
10 
11 
12 
1 
2/2 
3 
4/2 
4.1/2 
5/2 
6/2 
Ada Reference Manual — 2012 Edition 
21      13 December 2012 Types and Subtypes   3.2 the term component is us ed instead. Similarly, a part of an object or value is used to mean the whole 
object or value, or any set of its subcomponents. The terms component, subcom ponent, and part are also 
applied to a type meaning the co mponent, subcomponent, or part of objects and values of the type.  
The set of possible values for an object of a given ty pe can be subjected to a condition that is called a 
constraint  (the case of a null constraint  that specifies no restriction is also included); the rules for which 
values satisfy a given kind of constraint are given in 3.5 for range_constraint s, 3.6.1 for 
index_constraint s, and 3.7.1 for discriminant_constraint s. The set of possible values for an object of an 
access type can also be subjected to a cond ition that excludes the null value (see 3.10). 
A subtype  of a given type is a combination of the type, a constraint on values of the type, and certain 
attributes specific to the subtype. The given type is called the type of the subtype . Similarly, the associated 
constraint is called the constraint of the subtype .  The set of values of a subtyp e consists of th e values of its 
type that satisfy its constraint and any exclusion of the null value. Such values belong  to the subtype.  
A subtype is called an unconstrained  subtype if its type has unknown discri minants, or if its type allows 
range, index, or discriminant constr aints, but the subtype does not impose such a constraint; otherwise, the 
subtype is called a constrained  subtype (since it has no unconstrained characteristics).  
NOTES 
2  Any set of types can be called a “category” of types, and any set of types that is closed under derivation (see 3.4) can be called a “class” of types. However, only certain categories and classes are used in the description of the rules of the language — generally those that have their own particular set of primitive operations (see 3.2.3), or that correspond to a set of types that are matched by a given kind of generic formal type (see 12.5). The following are examples of “interesting” language-defined classes : elementary, scalar, discrete, enumeration, character, boolean, integer, signed 
integer, modular, real, floating point, fixed point, ordinary fixe d point, decimal fixed point , numeric, access, access-to-
object, access-to-subprogram, compos ite, array, string, ( untagged) record, ta gged, task, protected , nonlimited. Special 
syntax is provided to de fine types in each of th ese classes. In addition to these classes, the fo llowing are examples of 
“interesting” language-defined categories : abstract, incomplete, interface, limited, private, record.  
These language-defined categories are organized like this:  
all types 
 elementary   scalar    d i s c r e t e      enumeration      character      boolean      other enumeration     i n t e g e r       signed integer      modular integer    r e a l      floating point     fixed point      ordinary fixed point      decimal fixed point   access    access-to-object    access-to-subprogram  composite   untagged    a r r a y      s t r i n g      other array    r e c o r d     t a s k     protected 7/2 
8/2 
9 
10/2 
11/2 
12/2 
Ada Reference Manual — 2012 Edition 
3.2   Types and Subtypes 13 December 2012      22   tagged (including interfaces) 
   nonlimited tagged record    limited tagged     limited tagged record     synchronized tagged      t a g g e d  t a s k       tagged protected 
There are other categories, such as “numeric” and “discriminated”, which represent other categorization dimensions, but 
do not fit into the above strictly hierarchical picture.  
3.2.1 Type Declarations 
A type_declaration  declares a type and its first subtype.  
Syntax 
type_declaration ::=  full_type_declaration  
   | incomplete_type_declaration  
   | private_type_declaration  
   | private_extension_declaration  
full_type_declaration ::=  
     type defining_identifier  [known_discriminant_part ] is type_definition  
        [ aspect_specification ]; 
   | task_type_declaration  
   | protected_type_declaration  
type_definition ::=  
     enumeration_type_definition  | integer_type_definition  
   | real_type_definition  | array_type_definition  
   | record_type_definition  | access_type_definition  
   | derived_type_definition  | interface_type_definition  
Legality Rules 
A given type shall not have a subcomponent whose type is the given type itself.  
Static Semantics 
The defining_identifier  of a type_declaration  denotes the first subtype  of the type. The known_-
discriminant_part , if any, defines the discriminants of the ty pe (see 3.7, “Discriminants”). The remainder 
of the type_declaration  defines the remaining characteristics of (the view of) the type. 
A type defined by a type_declaration  is a named  type; such a type has one or more nameable subtypes. 
Certain other forms of declaration also include type de finitions as part of the declaration for an object. The 
type defined by such a declaration is anonymous  — it has no nameable subtypes. For explanatory 
purposes, this International Standard sometimes refers  to an anonymous type by a pseudo-name, written in 
italics, and uses such pseudo-names at pl aces where the syntax normally requires an identifier . For a 
named type whose first subtype is T,  this International Standard sometim es refers to the type of T as 
simply “the type T”.  
A named type that is declared by a full_type_declaration , or an anonymous type that is defined by an 
access_definition  or as part of declaring an object of the type, is called a full type . The declaration of a 
full type also declares the full view  of the type. The type_definition , task_definition , protected_definition , 
or access_definition  that defines a full type is called a full type definition . Types declared by other forms 
of type_declaration  are not separate types; they are partial or incomplete views of some full type.  13/2 
1 
2 
3/3 
4/2 
5 
6 
7/2 
8/2 
Ada Reference Manual — 2012 Edition 
23      13 December 2012 Type Declarations   3.2.1 The definition of a type implicitly declares certain predefined operators  that operate on the type, 
according to what classes the type belongs, as specifi ed in 4.5, “Operators and Expression Evaluation”.  
The predefined types  (for example the types Boolean, Wide_Character, Integer, root_integer , and 
universal_integer ) are the types that are defined in a predef ined library package called Standard; this 
package also includes the (implicit) declarations of their predefined operators. The package Standard is 
described in A.1.  
Dynamic Semantics 
The elaboration of a full_type_declaration  consists of the elaboration of the full type definition. Each 
elaboration of a full type definition creates a distinct type and its first subtype.  
Examples 
Examples of type definitions:   
(White, Red, Yellow, Green, Blue, Brown, Black) 
range 1 .. 72 
array(1 .. 10) of Integer 
Examples of type declarations:   
type Color  is (White, Red, Yellow, Green, Blue, Brown, Black); 
type Column is range 1 .. 72; 
type Table  is array(1 .. 10) of Integer; 
NOTES 
3  Each of the above examples declares a named type. The identifier given denotes the first subtype of the type. Other named subtypes of the type can be declared with 
subtype_declaration s (see 3.2.2). Although names do not directly denote 
types, a phrase like “the type Column” is sometimes used in this International Standard to refer to the type of Column, where Column denotes the first subtype of the type. For an example of the definition of an anonymous type, see the declaration of the array Color_Table in 3.3.1; its type is anonymous — it has no nameable subtypes.  
3.2.2 Subtype Declarations 
A subtype_declaration  declares a subtype of some previously declared type, as defined by a 
subtype_indication .  
Syntax 
subtype_declaration ::=  
   subtype  defining_identifier  is subtype_indication  
        [ aspect_specification ]; 
subtype_indication ::=  [null_exclusion ] subtype_mark  [constraint ] 
subtype_mark ::= subtype_ name  
constraint ::= scalar_constraint  | composite_constraint  
scalar_constraint ::=  
     range_constraint  | digits_constraint  | delta_constraint  
composite_constraint ::=  
     index_constraint  | discriminant_constraint  
Name Resolution Rules 
A subtype_mark  shall resolve to denote a subtype. The type determined by  a subtype_mark  is the type of 
the subtype denoted by the subtype_mark .  9 
10 
11 
12 
13 
14 
15 
16 
1 
2/3 
3/2 
4 5 6 
7 
8 
Ada Reference Manual — 2012 Edition 
3.2.2    Subtype Declarations 13 December 2012      24 Dynamic Semantics 
The elaboration of a subtype_declaration  consists of the elaboration of the subtype_indication . The 
elaboration of a subtype_indication  creates a new subtype. If the subtype_indication  does not include a 
constraint , the new subtype has the same (possibly nu ll) constraint as that denoted by the subtype_mark . 
The elaboration of a subtype_indication  that includes a constraint  proceeds as follows:  
• The constraint  is first elaborated. 
• A check is then made that the constraint  is compatible  with the subtype denoted by the 
subtype_mark .  
The condition imposed by a constraint  is the condition obtained after elaboration of the constraint . The 
rules defining compatibility are given for each form of constraint  in the appropriate subclause. These rules 
are such that if a constraint  is compatible  with a subtype, then th e condition imposed by the constraint  
cannot contradict any condition already imposed  by the subtype on its values. The exception 
Constraint_Error is raised if an y check of compatibility fails.  
NOTES 
4  A scalar_constraint  may be applied to a subtype of an appropriate scalar type (see 3.5, 3.5.9, and J.3), even if the 
subtype is already constrained. On the other hand, a composite_constraint  may be applied to a composite subtype (or an 
access-to-composite subtype) only if the composite subtype is unconstrained (see 3.6.1 and 3.7.1).  
Examples 
Examples of subtype declarations:   
subtype Rainbow   is Color range Red .. Blue;        --   see 3.2.1 
subtype Red_Blue  is Rainbow; 
subtype Int       is Integer; 
subtype Small_Int is Integer range -10 .. 10; 
subtype Up_To_K   is Column range 1 .. K;            --   see 3.2.1 
subtype Square    is Matrix(1 .. 10, 1 .. 10);       --   see 3.6 
subtype Male      is Person(Sex => M);               --   see 3.10.1  
subtype Binop_Ref is not null  Binop_Ptr;             --   see 3.10 
3.2.3 Classification of Operations 
Static Semantics 
An operation operates on a type  T if it yields a value of type T, if it has an operand whose expected type 
(see 8.6) is T, or if it has an access parameter or access result type (see 6.1) designating T. A predefined 
operator, or other language-defined operation such as assignment or a membership test, that operates on a 
type, is called a predefined operation  of the type. The primitive operations  of a type are the predefined 
operations of the type, plus any us er-defined primitive subprograms.  
The primitive subprograms  of a specific type are defined as follows:  
• The predefined operators of the type (see 4.5); 
• For a derived type, the inherited (see 3.4) user-defined subprograms; 
• For an enumeration type, the enumeration literals  (which are considered parameterless functions 
— see 3.5.1); 
• For a specific type declared immediately within a package_specification , any subprograms (in 
addition to the enumeration literals) that are e xplicitly declared immediately within the same 
package_specification  and that operate on the type; 
• For a specific type with an explicitly declar ed primitive "=" operator whose result type is 
Boolean, the corresponding "/=" operator (see 6.6); 9 
10 
11 
12 
13 
14 
15/2 
1/2 
2 
3 
4 5 
6 
6.1/3 
Ada Reference Manual — 2012 Edition 
25      13 December 2012 Classi fication of Operations   3.2.3 • For a nonformal type, any subprograms not covered above that are explicitly declared 
immediately within the same declarative region as the type and that override (see 8.3) other 
implicitly declared primitive subprograms of the type.  
A primitive subprogram whose designator is an operator_symbol  is called a primitive operator . 
3.2.4 Subtype Predicates 
The language-defined predicate aspects  Static_Predicate and Dynamic_Predicate may be used to define 
properties of subtypes. A predicate specification  is an aspect_specification  for one of the two predicate 
aspects. General rules for aspects and aspect_specification s are found in Clause 13 (13.1 and 13.1.1 
respectively).  
Name Resolution Rules 
The expected type for a predicate aspect expression  is any boolean type. 
Static Semantics 
A predicate specification may be given on a type_declaration  or a subtype_declaration , and applies to the 
declared subtype. In addition, predicate specifications apply to certain other subtypes:  
• For a (first) subtype defined by a derived type d eclaration, the predicates of the parent subtype 
and the progenitor subtypes apply. 
• For a subtype created by a subtype_indication , the predicate of the subtype denoted by the 
subtype_mark  applies.  
The predicate  of a subtype consists of all predicate speci fications that apply, and-ed together; if no 
predicate specifications apply, the predicate is True (in particular, the predicate of a base subtype is True). 
Predicate checks are defined to be enabled  or disabled  for a given subtype as follows: 
• If a subtype is declared by a type_declaration  or subtype_declaration  that includes a predicate 
specification, then:  
• if performing checks is required by the Sta tic_Predicate assertion policy (see 11.4.2) and 
the declaration includes a Static_Predicate speci fication, then predicate checks are enabled 
for the subtype; 
• if performing checks is required by the Dy namic_Predicate assertion policy (see 11.4.2) 
and the declaration includes a Dynamic_Predicate specification, then predicate checks are enabled for the subtype; 
• otherwise, predicate checks are disabled for the subtype, regardless of whether predicate 
checking is enabled for any other subtyp es mentioned in the declaration;  
• If a subtype is defined by a derived type declaration that does not include a predicate 
specification, then predicate checks are enabled for the subtype if and only if predicate checks 
are enabled for at least one of the pare nt subtype and the progenitor subtypes; 
• If a subtype is created by a 
subtype_indication  other than in one of the previous cases, then 
predicate checks are enabled for the subtype if and only if predicate checks are enabled for the 
subtype denoted by the subtype_mark ; 
• Otherwise, predicate checks are disabled for the given subtype. 
Legality Rules 
The expression  of a Static_Predicate specification shall be predicate-static ; that is, one of the following:  7/2 
8 
1/3 
2/3 
3/3 
4/3 
5/3 6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
Ada Reference Manual — 2012 Edition 
3.2.4    Subtype Predicates 13 December 2012      26 • a static expression; 
• a membership test whose simple_expression  is the current instance, and whose 
membership_choice_list  meets the requirements for a static membership test (see 4.9); 
• a case_expression  whose selecting_ expression  is the current instance, and whose 
dependent_ expression s are static expressions; 
• a call to a predefined equality or ordering opera tor, where one operand is the current instance, 
and the other is a static expression; 
• a call to a predefined boolean logical opera tor, where each operand is predicate-static; 
• a short-circuit control form where both operands are predicate-static; or 
• a parenthesized predicate-static expression .  
A predicate shall not be specified for an incomplete subtype. 
If a predicate applies to a subtype, then that predi cate shall not mention any other subtype to which the 
same predicate applies. 
An index subtype, discrete_range  of an index_constraint  or slice , or a discrete_subtype_definition  of a 
constrained_array_definition , entry_declaration , or entry_index_specification  shall not denote a subtype 
to which predicate specifications apply. 
The prefix  of an attribute_reference  whose attribute_designator  is First, Last, or Range shall not denote a 
scalar subtype to which predicate specifications apply. 
The discrete_subtype_definition  of a loop_parameter_specification  shall not denote a nonstatic subtype 
to which predicate specifications apply or any subtype to which Dynamic_Predicate specifications apply. 
The discrete_choice  of a named_array_aggregate  shall not denote a nonstatic subtype to which 
predicate specifications apply. 
In addition to the places where Legality Rules normally  apply (see 12.3), these rules apply also in the 
private part of an instance of a generic unit.  
Dynamic Semantics 
If predicate checks are enabled for a given subtype, then:  
On every subtype conversion, the predicate of th e target subtype is evaluated, and a check is 
performed that the predicate is True. This in cludes all parameter passing, except for certain 
parameters passed by referen ce, which are covered by the following rule:  After normal 
completion and leaving of a subprogram, for each in out  or out parameter that is passed by 
reference, the predicate of the subtype of the act ual is evaluated, and a check is performed that 
the predicate is True. For an object created by an object_declaration  with no explicit 
initialization expression , or by an uninitialized allocator , if any subcomponents have 
default_expression s, the predicate of the nominal subtype of the created object is evaluated, and 
a check is performed that the pr edicate is True. Assertions.Asser tion_Error is raised if any of 
these checks fail. 
A value satisfies  a predicate if the predicate is True for that value. 
If any of the above Legality Rules is violated in an instance of a generic unit, Program_Error is raised at 
the point of the violation. 16/3 
17/3 
18/3 19/3 20/3 
21/3 22/3 23/3 
24/3 
25/3 
26/3 
27/3 28/3 29/3 
30/3 
31/3 
32/3 
33/3 
Ada Reference Manual — 2012 Edition 
27      13 December 2012 Subtype Predicates   3.2.4 NOTES 
5  A predicate specification does not cause a subtype to be considered constrained. 
6  A Static_Predicate, like a constraint, always remains True for all objects of the subtype, except in the case of 
uninitialized variables and other invalid values. A Dynamic_Predicate, on the other hand, is checked as specified above, but can become False at other times. For example, the predicate of a record subtype is not checked when a subcomponent is modified.  
3.3 Objects and Named Numbers 
Objects are created at run time and contain a value of a given type. An object can be created and initialized 
as part of elaborating a declaration, evaluating an allocator , aggregate , or function_call , or passing a 
parameter by copy. Prior to reclaiming the storage for an object, it is finalized if necessary (see 7.6.1).  
Static Semantics 
All of the following are objects:  
• the entity declared by an object_declaration ; 
• a formal parameter of a subprogr am, entry, or generic subprogram; 
• a generic formal object; 
• a loop parameter; 
• a choice parameter of an exception_handler ; 
• an entry index of an entry_body ; 
• the result of dereferencing an access-to-object value (see 4.1); 
• the return object of a function; 
• the result of evaluating an aggregate ; 
• a qualified_expression  whose operand denotes an object; 
• a component, slice, or view conversion of another object.  
An object is either a constant  object or a variable  object. Similarly, a view of an object is either a constant  
or a variable . All views of a constant elementary object ar e constant. All views of  a constant composite 
object are constant, except for parts that are of cont rolled or immutably limited ty pes; variable views of 
those parts and their subcomponents ma y exist. In this sense, objects of controlled and immutably limited 
types are inherently mutable . A constant view of an object cannot be  used to modify its value. The terms 
constant and variable by themselves refer to constant and variable views of objects. 
The value of an object is read when the value of any part of the object is evaluated, or when the value of 
an enclosing object is evaluated. The value of a variable is updated  when an assignment is performed to 
any part of the variable, or when an assi gnment is performed to an enclosing object.  
Whether a view of an object is constant or variable  is determined by the de finition of the view. The 
following (and no others) represent constants:  
• an object declared by an object_declaration  with the reserved word constant ; 
• a formal parameter or gene ric formal object of mode in; 
• a discriminant; 
• a loop parameter unless specified to be a variable for a generalized loop (see 5.5.2); 
• a choice parameter or entry index; 34/3 
35/3 
1 
2 
3 
4 5 6 7 8 9 
10/3 
11 
11.1/3 
12 
13/3 
14 
15 
16 
17 18 
18.1/3 
19/3 
Ada Reference Manual — 2012 Edition 
3.3   Objects and Named Numbers 13 December 2012      28 • the dereference of an access-to-constant value; 
• the return object declared by an extended_return_statement  with the reserved word constant ; 
• the object denoted by a function_call  or an aggregate ; 
• the result of evaluating a qualified_expression ; 
• within the body of a protected function (o r a function declared immediately within a 
protected_body ), the current instance of the enclosing protected unit; 
• a selected_component , indexed_component , slice , or view conversion of a constant.  
At the place where a view of an object is defined, a nominal subtype  is associated with the view. The 
object's actual subtype  (that is, its subtype) can be more restric tive than the nominal subtype of the view; it 
always is if the nominal subtype is an indefinite subtype . A subtype is an indefinite subtype if it is an 
unconstrained array subtype, or if it has unknown disc riminants or unconstraine d discriminants without 
defaults (see 3.7); otherw ise, the subtype is a definite  subtype (all elementary subtypes are definite 
subtypes). A class-wide subtype is defined to have unknown di scriminants, and is therefore an indefinite 
subtype. An indefinite subtype does not by itsel f provide enough information to create an object; an 
additional constraint  or explicit initialization expression  is necessary (see 3.3.1). A component cannot 
have an indefinite nominal subtype. 
A view of a composite object is known to be constrained  if: 
• its nominal subtype is c onstrained, and is not an untagged partial view; or 
• its nominal subtype is indefinite; or 
• its type is immutably limited (see 7.5); or 
• it is part of a stand-alone constant (i ncluding a generic formal object of mode in); or 
• it is part of a formal parameter of mode in; or 
• it is part of the object denoted by a function_call  or aggregate ; or 
• it is part of a constant return object of an extended_return_statement ; or 
• it is a dereference of a pool-specific access type, and there is no ancestor of its type that has a 
constrained partial view. 
For the purposes of determining with in a generic body whether an object is known to be constrained:  
• if a subtype is a descendant of an untagged generic formal private or derived type, and the 
subtype is not an unconstrained array subtype, it is not considered indefinite and is considered to 
have a constrained partial view; 
• if a subtype is a descendant of a formal access type, it is not considered pool-specific. 
A named number  provides a name for a numeric value known at compile time. It is declared by a 
number_declaration .  
NOTES 
7  A constant cannot be the target of an assignment operation, nor be passed as an in out or out parameter, between its 
initialization and finalization, if any. 
8  The value of a constant object cannot be changed after its initialization, except in some cases where the object has a 
controlled or immutably limited part (see 7.5, 7.6, and 13.9.1). 
9  The nominal and actual subtypes of an elementary object are always the same. For a discriminated or array object, if the 
nominal subtype is constrained, then so is the actual subtype.  20 
20.1/3 
21/3 
21.1/3 21.2/3 
22 
23/3 
23.1/3 
23.2/3 
23.3/3 23.4/3 23.5/3 23.6/3 23.7/3 23.8/3 23.9/3 
23.10/3 
23.11/3 
23.12/3 
24 
25 
25.1/3 
26/3 
Ada Reference Manual — 2012 Edition 
29      13 December 2012 Object Declarations   3.3.1 3.3.1 Object Declarations 
An object_declaration  declares a stand-alone  object with a given nominal subtype and, optionally, an 
explicit initial value given by an initialization expressi on. For an array, access, task, or protected object, 
the object_declaration  may include the definition of the (anonymous) type of the object.  
Syntax 
object_declaration ::=  
    defining_identifier_list  : [aliased ] [constant ] subtype_indication  [:= expression ] 
        [ aspect_specification ]; 
  | defining_identifier_list  : [aliased ] [constant ] access_definition  [:= expression ] 
        [ aspect_specification ]; 
  | defining_identifier_list  : [aliased ] [constant ] array_type_definition  [:= expression ] 
        [ aspect_specification ]; 
  | single_task_declaration  
  | single_protected_declaration  
defining_identifier_list ::=  
  defining_identifier  {, defining_identifier } 
Name Resolution Rules 
For an object_declaration  with an expression  following the compound delimiter :=, the type expected for 
the expression  is that of the object. This expression  is called the initialization expression .  
Legality Rules 
An object_declaration  without the reserved word constant  declares a variable object. If it has a 
subtype_indication  or an array_type_definition  that defines an indefinite subtype, then there shall be an 
initialization expression.  
Static Semantics 
An object_declaration  with the reserved word constant  declares a constant object. If it has an 
initialization expression, then it is called a full constant declaration . Otherwise, it is called a deferred 
constant declaration . The rules for deferred constant declarations  are given in subclause 7.4. The rules for 
full constant declarations ar e given in this subclause. 
Any declaration that includes a defining_identifier_list  with more than one defining_identifier  is equivalent 
to a series of declarations each containing one defining_identifier  from the list, with the rest of the text of 
the declaration copied for each declaration in the series, in the same order as the list. The remainder of this 
International Standard relies on this  equivalence; explanations are gi ven for declarations with a single 
defining_identifier . 
The subtype_indication , access_definition , or full type definition of an object_declaration  defines the 
nominal subtype of the object. The object_declaration  declares an object of the type of the nominal 
subtype.  
A component of an object is said to require late initialization  if it has an access discriminant value 
constrained by a per-object expression, or if it ha s an initialization expression that includes a name 
denoting the current instance of the type or denoting an access discriminant.  1/3 
2/3 
3 
4 
5/2 
6/3 
7 
8/2 
8.1/2 
Ada Reference Manual — 2012 Edition 
3.3.1    Object Declarations  13 December 2012      30 Dynamic Semantics 
If a composite object declared by an object_declaration  has an unconstrained nominal subtype, then if this 
subtype is indefinite or the object is constant th e actual subtype of this object is constrained. The 
constraint is determined by the bounds or discriminants (i f any) of its initial value; the object is said to be 
constrained by its initial value . When not constrained by its initial va lue, the actual and nominal subtypes 
of the object are the same. If its actual subtype is constrained, the object is called a constrained object . 
For an object_declaration  without an initialization expression, an y initial values for the object or its 
subcomponents are determined by the implicit initial values  defined for its nominal subtype, as follows:  
• The implicit initial value for an access subt ype is the null value of the access type. 
• The implicit initial value for a scalar subtype that  has the Default_Value aspect specified is the 
value of that aspect converted to the nominal  subtype (which might raise Constraint_Error — 
see 4.6, “Type Conversions”); 
• The implicit initial (and only) value for each discri minant of a constrained discriminated subtype 
is defined by the subtype. 
• For a (definite) composite subtype, the im plicit initial value of each component with a 
default_expression  is obtained by evaluation of this  expression and conversion to the 
component's nominal subtype (which might rais e Constraint_Error), unless the component is a 
discriminant of a constrained subtype (the  previous case), or is in an excluded variant  (see 
3.8.1). For each component that does not have a default_expression , if the composite subtype 
has the Default_Component_Value aspect specified, the implicit initial value is the value of that 
aspect converted to the component's nominal subt ype; otherwise, any implicit initial values are 
those determined by the co mponent's nominal subtype. 
• For a protected or task subtype, there is an  implicit component (an entry queue) corresponding to 
each entry, with its implicit initia l value being an empty queue.  
The elaboration of an object_declaration  proceeds in the following sequence of steps:  
1. The subtype_indication , access_definition , array_type_definition , single_task_declaration , or 
single_protected_declaration  is first elaborated. This creates the nominal subtype (and the 
anonymous type in th e last four cases). 
2. If the object_declaration  includes an initialization expression, the (explicit) initial value is 
obtained by evaluating the expression and conver ting it to the nominal subtype (which might 
raise Constraint_Error — see 4.6).  
3. The object is created, and, if there is not an initialization expression, the object is initialized by 
default . When an object is initialized by default,  any per-object constraints (see 3.8) are 
elaborated and any implicit initial values for th e object or for its subcomponents are obtained as 
determined by the nominal subtype. Any initial va lues (whether explicit or implicit) are assigned 
to the object or to the corresponding subcomponents.  As described in 5.2 and 7.6, Initialize and 
Adjust procedures can be called.  
 This paragraph was deleted.  
For the third step above, evaluations and assignments are performed in an arbitr ary order subject to the 
following restrictions:  
• Assignment to any part of the object is preceded by the evaluation of the value that is to be 
assigned.  
• The evaluation of a default_expression  that includes the name of a discriminant is preceded by 
the assignment to that discriminant.  9/2 
10 
11 
11.1/3 
12 
13/3 
14 
15 
16/2 
17 
18/2 
19/2 
20/2 
20.1/2 
20.2/2 
Ada Reference Manual — 2012 Edition 
31      13 December 2012 Object Declarations   3.3.1 • The evaluation of the default_expression  for any component that depends on a discriminant is 
preceded by the assignment to that discriminant.  
• The assignments to any components, incl uding implicit components, not requiring late 
initialization precede the initial value evaluations for any components requiring late initialization; if two components both require late initialization, then assignments to parts of the 
component occurring earlier in the order of the component declarations precede the initial value 
evaluations of the component occurring later.  
There is no implicit initial value defined for a scalar  subtype unless the Default_Value aspect has been 
specified for the type. In the absence of an explicit initialization or the specification of the Default_Value 
aspect, a newly created scalar object might have a va lue that does not belong to its subtype (see 13.9.1 and 
H.1).  
NOTES 
10  Implicit initial values are not defined for an indefinite subtype, because if an object's nominal subtype is indefinite, an  
explicit initial value is required. 
11  As indicated above, a stand-alone object is an object declared by an object_declaration . Similar definitions apply to 
“stand-alone constant” and “stand-alone variable.” A subcomponent of an object is not a stand-alone object, nor is an object that is created by an 
allocator . An object declared by a loop_parameter_s pecification , iterator_spec ification , 
parameter_spec ification , entry_index_spec ification , choice_parameter _specification , extended_return_statement , or a 
formal_object_declaration  of mode in out  is not considered a stand-alone object. 
12  The type of a stand-alone object cannot be abstract (see 3.9.3).  
Examples 
Example of a multiple object declaration:   
--  the multiple object declaration  
John, Paul : not null  Person_Name := new Person(Sex => M);  --   see 3.10.1  
--  is equivalent to the two single object declarations in the order given  
John : not null  Person_Name := new Person(Sex => M); 
Paul : not null  Person_Name := new Person(Sex => M); 
Examples of variable declarations:   
Count, Sum  : Integer; 
Size        : Integer range 0 .. 10_000 := 0; 
Sorted      : Boolean := False; Color_Table : array(1 .. Max) of Color; 
Option      : Bit_Vector(1 .. 10) := ( others => True); 
Hello       : aliased String := "Hi, world."; 
θ, φ        : Float range -π .. + π; 
Examples of constant declarations:   
Limit     : constant  Integer := 10_000; 
Low_Limit : constant  Integer := Limit/10; 
Tolerance : constant  Real := Dispersion(1.15); 
Hello_Msg : constant access  String := Hello'Access; --  see 3.10.2 
3.3.2 Number Declarations 
A number_declaration  declares a named number.  
Syntax 
number_declaration ::=  
     defining_identifier_list  : constant  := static_ expression ; 20.3/2 
20.4/3 
21/3 
22 
23/3 
24 
25 
26 
27/2 
28 
29/2 
30 
31/2 
32 
33/2 
1 
2 
Ada Reference Manual — 2012 Edition 
3.3.2    Number Declarations 13 December 2012      32 Name Resolution Rules 
The static_ expression  given for a number_declaration  is expected to be of any numeric type.  
Legality Rules 
The static_ expression  given for a number declaration shall be a st atic expression, as defined by subclause 
4.9.  
Static Semantics 
The named number denotes a value of type universal_integer  if the type of the static_ expression  is an 
integer type. The named number denotes a value of type universal_real  if the type of the static_ -
expression  is a real type. 
The value denoted by the named number is the value of the static_ expression , converted to the 
corresponding universal type.  
Dynamic Semantics 
The elaboration of a number_declaration  has no effect.  
Examples 
Examples of number declarations:   
Two_Pi        : constant  := 2.0*Ada.Numerics.Pi;   --  a real number (see A.5)  
Max           : constant  := 500;                   --  an integer number  
Max_Line_Size : constant  := Max/6;                 --  the integer 83  
Power_16      : constant  := 2**16;                 --  the integer 65_536  
One, Un, Eins : constant  := 1;                     --  three different names for 1  
3.4 Derived Types and Classes 
A derived_type_definition  defines a derived type  (and its first subtype) whose characteristics are derived  
from those of a parent type, and possibly from progenitor types.  
A class of types  is a set of types that is closed under derivation;  that is, if the parent or a progenitor type of 
a derived type belongs to a class, then so does the de rived type. By saying that a particular group of types 
forms a class, we are saying that all derivatives of a type in the set inherit the characteristics that define 
that set. The more general term category of types  is used for a set of types whose defining characteristics 
are not necessarily inherited by derivatives; for example, limited, abstract, and interface are all categories of types, but not classes of types. 
Syntax 
derived_type_definition ::=  
    [abstract ] [limited ] new parent_ subtype_indication  [[and interface_list ] record_extension_part ] 
Legality Rules 
The parent_ subtype_indication  defines the parent subtype ; its type is the parent type . The interface_list  
defines the progenitor types (see 3.9.4). A derived type  has one parent type and zero or more progenitor 
types. 
A type shall be completely defined (see 3.11.1) pr ior to being specified as the parent type in a 
derived_type_definition  — the full_type_declaration s for the parent type and any of its subcomponents 
have to precede the derived_type_definition .  3 
4/3 
5 
6 
7 
8 
9 
10/2 
1/2 
1.1/2 
2/2 
3/2 
4 
Ada Reference Manual — 2012 Edition 
33      13 December 2012 Derived Types and Classes   3.4 If there is a record_extension_part , the derived type is called a record extension  of the parent type. A 
record_extension_part  shall be provided if and only if the parent type is a tagged type. An interface_list  
shall be provided only if the parent type is a tagged type.  
If the reserved word limited  appears in a derived_type_definition , the parent type shall be a limited type. 
If the parent type is a tagged formal type, then in  addition to the places where Legality Rules normally 
apply (see 12.3), this rule applies also in the pr ivate part of an instance of a generic unit.  
Static Semantics 
The first subtype of the derived type is unconstrained if a known_discriminant_part  is provided in the 
declaration of the derived type, or if the parent subt ype is unconstrained. Otherwis e, the constraint of the 
first subtype corresponds  to that of the parent subtype in the follo wing sense: it is the same as that of the 
parent subtype except that for a range constraint (i mplicit or explicit), the value of each bound of its range 
is replaced by the corresponding value of the derived type.  
The first subtype of the derived type excludes null (s ee 3.10) if and only if the parent subtype excludes 
null. 
The characteristics  and implicitly declared primitive subprograms of the derived type are defined as 
follows:  
• If the parent type or a progenitor type belongs to  a class of types, then the derived type also 
belongs to that class. The following sets of ty pes, as well as any highe r-level sets composed 
from them, are classes in this sense, and hen ce the characteristics defining these classes are 
inherited by derived types from th eir parent or progenitor types: signed integer, modular integer, 
ordinary fixed, decimal fixed, floating poi nt, enumeration, boolean, character, access-to-
constant, general access-to-variable, pool-sp ecific access-to-variable, access-to-subprogram, 
array, string, non-array composite, nonlimited, untagged record, tagged, task, protected, and 
synchronized tagged.  
• If the parent type is an elementary type or an array type, then the set of possible values of the 
derived type is a copy of the set of possible values  of the parent type. For a scalar type, the base 
range of the derived type is the same as that of the parent type.  
• If the parent type is a composite type other th an an array type, then the components, protected 
subprograms, and entries that are declared  for the derived type are as follows:  
• The discriminants specified by a new known_discriminant_part , if there is one; otherwise, 
each discriminant of the parent type (implicitly declared in the same order with the same specifications) — in the latter case, the discriminants are said to be inherited , or if unknown 
in the parent, are also unknown in the derived type; 
• Each nondiscriminant component, entry, and protected subprogram of the parent type, 
implicitly declared in the same order with the same declarations; these components, entries, 
and protected subprograms are said to be inherited ;  
• Each component declared in a record_extension_part , if any.  
 Declarations of components, protected subprogram s, and entries, whether implicit or explicit, 
occur immediately within the declarative regi on of the type, in the order indicated above, 
following the parent subtype_indication .  
• This paragraph was deleted.  
• For each predefined operator of the parent type , there is a corresponding predefined operator of 
the derived type.  5/2 
5.1/3 
6 
6.1/2 
7/3 
8/2 
9 
10 
11 
12 
13 
14 
15/2 
16 
Ada Reference Manual — 2012 Edition 
3.4   Derived Types and Classes 13 December 2012      34 • For each user-defined primitive subprogram (other  than a user-defined equality operator — see 
below) of the parent type or of a progenitor type that already exists at the place of the 
derived_type_definition , there exists a corresponding inherited  primitive subprogram of the 
derived type with the same defining name. Pr imitive user-defined equality operators of the 
parent type and any progenitor types are also inherited by the derived type, except when the 
derived type is a nonlimited record extension, and the inherited operator would have a profile 
that is type conformant with the profile of th e corresponding predefined equality operator; in this 
case, the user-defined equality operator is not i nherited, but is rather incorporated into the 
implementation of the predefined equality opera tor of the record extension (see 4.5.2).  
 The profile of an inherited subprogram (includi ng an inherited enumeration literal) is obtained 
from the profile of the corresponding (user-defin ed) primitive subprogram of the parent or 
progenitor type, after systematic replacement of each subtype of its profile (see 6.1) that is of the parent or progenitor type, other than those s ubtypes found in the designated profile of an 
access_definition , with a corresponding subtype  of the derived type. For a given subtype of the 
parent or progenitor type, the corresponding subtype of the derived type is defined as follows:  
• If the declaration of the derived type has neither a known_discriminant_part  nor a 
record_extension_part , then the corresponding subtype ha s a constraint that corresponds 
(as defined above for the first subtype of the derived type) to that of the given subtype. 
• If the derived type is a record extension, th en the corresponding subtyp e is the first subtype 
of the derived type. 
• If the derived type has a new known_discriminant_part  but is not a record extension, then 
the corresponding subtype is constrained to those values that when converted to the parent 
type belong to the given subtype (see 4.6).  
 The same formal parameters have default_expression s in the profile of the inherited 
subprogram. Any type mismatch due to the systematic replacement of the parent or progenitor type by the derived type is handled as part of the normal type conversion associated with 
parameter passing — see 6.4.1.  
If a primitive subprogram of the parent or proge nitor type is visible at the place of the 
derived_type_definition , then the corresponding inherited subprogram  is implicitly declared immediately 
after the derived_type_definition . Otherwise, the inherited subprogram is  implicitly declared later or not at 
all, as explained in 7.3.1. 
A derived type can also be defined by a private_extension_declaration  (see 7.3) or a formal_derived_-
type_definition  (see 12.5.1). Such a derived type is a partia l view of the corresponding full or actual type. 
All numeric types are derived types, in that they are implicitly derived from a corresponding root numeric 
type (see 3.5.4 and 3.5.6). 
Dynamic Semantics 
The elaboration of a derived_type_definition  creates the derived type and its first subtype, and consists of 
the elaboration of the subtype_indication  and the record_extension_part , if any. If the subtype_-
indication  depends on a discriminant, then only those expr essions that do not depend on a discriminant are 
evaluated.  
For the execution of a call on an inherited subpr ogram, a call on the corresponding primitive subprogram 
of the parent or progenitor type is performed; th e normal conversion of each actual parameter to the 
subtype of the corresponding formal parameter (see 6. 4.1) performs any necessary type conversion as 
well. If the result type of the inherited subprogram is  the derived type, the result of calling the subprogram 
of the parent or progenitor is converted to the derive d type, or in the case of a null extension, extended to 17/2 
18/3 
19 
20 
21 
22/2 
23/2 
24 
25 
26 
27/2 
Ada Reference Manual — 2012 Edition 
35      13 December 2012 Derived Types and Classes   3.4 the derived type using the equivalent of an extension_aggregate  with the original result as the 
ancestor_part  and null record  as the record_component_association_list .  
NOTES 
13  Classes are closed under derivation — any class that contains a type also contains its derivatives. Operations available for a given class of types are available for the derived types in that class. 
14  Evaluating an inherited enumeration literal is equivalent to evaluating the corresponding enumeration literal of the 
parent type, and then converting the result to the derived type. This follows from their equivalence to parameterless functions.  
15  A generic subprogram is not a subprogram, and hence cannot be a primitive subprogram and cannot be inherited by a 
derived type. On the other hand, an instance of a generic subprogram can be a primitive subprogram, and hence can be inherited. 
16  If the parent type is an access type, then the parent a nd the derived type share the same storage pool; there is a null 
access value for the derive d type and it is the implicit initial value fo r the type. See 3.10. 
17  If the parent type is a boolean type, the predefined relational operators of the derived type deliver a result of the 
predefined type Boolean (see 4.5.2). If the parent type is an integer type, the right operand of the predefined exponentiation operator is of the predefined type Integer (see 4.5.6). 
18  Any discriminants of the parent type are either all inherited, or completely replaced with a new set of discriminants. 19  For an inherited subprogram, the subtype of a formal parameter of the derived type need not have any value in 
common with the first subtype of the derived type.  
20  If the reserved word abstract  is given in the declaration of a type, the type is abstract (see 3.9.3). 
21  An interface type that has a progenitor type “is derived from” that type. A 
derived_type_definition , however, never 
defines an interface type. 
22  It is illegal for the parent type of a derived_type_definition  to be a synchronized tagged type.  
Examples 
Examples of derived type declarations:   
type Local_Coordinate is new Coordinate;   --   two different types  
type Midweek is new Day range Tue .. Thu;  --   see 3.5.1 
type Counter is new Positive;              --   same range as Positive  
type Special_Key is new Key_Manager.Key;   --   see 7.3.1 
  --  the inherited subprograms have the following specifications:  
  --          procedure Get_Key(K : out Special_Key);  
  --          function "<"(X, Y : Special_Key) return Boolean;  
3.4.1 Derivation Classes 
In addition to the various language-defined cl asses of types, types can be grouped into derivation classes .  
Static Semantics 
A derived type is derived from  its parent type directly ; it is derived indirectly  from any type from which its 
parent type is derived. A derived type, interface type, type extension, task type, protected type, or formal 
derived type is also derived from every ancestor of each of its progenitor types, if any. The derivation class of types for a type T (also called the class rooted  at T) is the set consisting of T (the root type  of the 
class) and all types derived from T (directly or indirectly) plus any asso ciated universal or class-wide types 
(defined below).  
Every type is either a specific  type, a class-wide  type, or a universal  type. A specific type is one defined 
by a 
type_declaration , a formal_type_declaration , or a full type definition embedded in another construct. 
Class-wide and universal types are imp licitly defined, to act as representa tives for an entire class of types, 
as follows:  28 
29 
30 
31 
32 
33 
34 
35 
35.1/2 
35.2/2 
36 
37 
38 
1 
2/2 
3/2 
Ada Reference Manual — 2012 Edition 
3.4.1    Derivation Classes 13 December 2012      36 Class-wide types  
 Class-wide types are define d for (and belong to) each deriva tion class rooted at a tagged 
type (see 3.9). Given a subtype S of a tagged type T, S'Class is the subtype_mark  for a 
corresponding subtype of the tagged class-wide type T'Class. Such types are called “class-
wide” because when a formal parameter is defined to be of a class-wide type T'Class, an 
actual parameter of any type in the derivation class rooted at T is acceptable (see 8.6). 
 The set of values for a class-wide type T'Class is the discriminated union of the set of 
values of each specific type in the derivation class rooted at T (the tag acts as the implicit 
discriminant — see 3.9). Class-wide types have no primitive subprograms of their own. 
However, as explained in 3.9.2,  operands of a class-wide type T'Class can be used as part of 
a dispatching call on a primitive subprogram of the type T. The only components (including 
discriminants) of T'Class that are visible are those of T. If S is a first subtype, then S'Class 
is a first subtype.  
Universal types  
 Universal types are defined for (and belong to) the integer, real, fixed point, and access 
classes, and are referred to in this standard as respectively, universal_integer , 
universal_real , universal_fixed , and universal_access . These are analogous to class-wide 
types for these language-defined elementary classe s. As with class-wide types, if a formal 
parameter is of a universal type, then an act ual parameter of any type in the corresponding 
class is acceptable. In addition, a value of a universal type (including an integer or real 
numeric_literal , or the literal null) is “universal” in that it is acceptable where some 
particular type in the class is expected (see 8.6). 
 The set of values of a universal type is the undiscriminated union of the set of values 
possible for any definable type in the associat ed class. Like class- wide types, universal 
types have no primitive subprograms of their ow n. However, their “universality” allows 
them to be used as operands with the primitive subprograms of any type in the 
corresponding class.  
The integer and real numeric classes each have a speci fic root type in addition to their universal type, 
named respectively root_integer  and root_real . 
A class-wide or universal type is said to cover  all of the types in its class. A specific type covers only 
itself. 
A specific type T2 is defined to be a descendant  of a type T1 if T2 is the same as T1, or if T2 is derived 
(directly or indirectly) from T1. A class-wide type T2'Class is defined to be a descendant of type T1 if T2 
is a descendant of T1. Similarly, the numeric universal types ar e defined to be descendants of the root 
types of their classes. If a type T2 is a descendant of a type T1, then T1 is called an ancestor  of T2. An 
ultimate ancestor  of a type is an ancestor of that type that  is not itself a descendant of any other type. 
Every untagged type has a unique ultimate ancestor.  
An inherited component (including an inherited discriminant) of a derived type is inherited from  a given 
ancestor of the type if the corresponding component wa s inherited by each derived type in the chain of 
derivations going back to the given ancestor. 
NOTES 
23  Because operands of a universal type are acceptable to the predefined operators of any type in their class, ambiguity can result. For universal_integer  and universal_real , this potential ambiguity is resolved by giving a preference (see 8.6) 
to the predefined operators of the corresponding root types ( root_integer  and root_real , respectively). Hence, in an 
apparently ambiguous expression like  
1 + 4 < 7 
where each of the lite rals is of type universal_integer , the predefined operators of root_integer  will be preferred over 
those of other specific integer types, thereby resolving the ambiguity.  4 
5 
6/2 
7 
8 
9 
10/2 
11 
12 
13 
14 
Ada Reference Manual — 2012 Edition 
37      13 December 2012 Scalar Types   3.5 3.5 Scalar Types 
Scalar  types comprise enumeration type s, integer types, and real type s. Enumeration types and integer 
types are called discrete  types; each value of a discrete type has a position number  which is an integer 
value. Integer types and real types are called numeric  types. All scalar types are ordered, that is, all 
relational operators are predefined for their values. 
Syntax 
range_constraint ::=  range  range  
range ::=  range_attribute_reference  
   | simple_expression  .. simple_expression  
A range  has a lower bound  and an upper bound  and specifies a subset of the values of some scalar type 
(the type of the range ). A range with lower bound L and upper bound R is described by “L .. R”. If R is 
less than L, then the range is a null range , and specifies an empty set of values. Otherwise, the range 
specifies the values of the type from the lower bound to the upper bound, inclusive. A value belongs  to a 
range if it is of the type of the range, and is in the subset of values specified by the range. A value satisfies  
a range constraint if it belongs to the associated range. One range is included  in another if all values that 
belong to the first range also belong to the second.  
Name Resolution Rules 
For a subtype_indication  containing a range_constraint , either directly or as part of some other 
scalar_constraint , the type of the range  shall resolve to that of the type determined by the subtype_mark  
of the subtype_indication . For a range  of a given type, the simple_expression s of the range  (likewise, 
the simple_expression s of the equivalent range  for a range_attribute_reference ) are expected to be of 
the type of the range .  
Static Semantics 
The base range  of a scalar type is the range of finite values  of the type that can be represented in every 
unconstrained object of the type; it is also the range  supported at a minimum for intermediate values 
during the evaluation of expressions involving predefined operators of the type.  
A constrained scalar subtype is one to which a range constraint applies. The range  of a constrained scalar 
subtype is the range associated with the range constraint of the subtype. The range  of an unconstrained 
scalar subtype is the base range of its type.  
Dynamic Semantics 
A range is compatible  with a scalar subtype if and only if it is either a null range or each bound of the 
range belongs to the range of the subtype. A range_constraint  is compatible  with a scalar subtype if and 
only if its range is compa tible with the subtype.  
The elaboration of a range_constraint  consists of the evaluation of the range . The evaluation of a range  
determines a lower bound and an upper bound. If simple_expression s are given to specify bounds, the 
evaluation of the range  evaluates these simple_expression s in an arbitrary order, and converts them to the 
type of the range . If a range_attribute_reference  is given, the evaluation of the range  consists of the 
evaluation of the range_attribute_reference . 1 
2 
3 
4 
5 
6 
7 
8 
9 
Ada Reference Manual — 2012 Edition 
3.5   Scalar Types 13 December 2012      38 Attributes  
For every scalar subtype S, the following attributes are defined:  
S'First S'First denotes the lower bound of the range of S. The value of this attribute is of the type 
of S.  
S'Last S'Last denotes the upper bound of the range of S.  The value of this attribute is of the type of 
S.  
S'Range S'Range is equivalent to the range  S'First .. S'Last. 
S'Base S'Base denotes an unconstr ained subtype of the type of S.  This unconstrained subtype is 
called the base subtype  of the type.  
S'Min S'Min denotes a function with the following specification:  
function  S'Min( Left, Right : S'Base) 
  return S'Base 
 The function returns the lesser of th e values of the two parameters.  
S'Max S'Max denotes a function with the following specification:  
function  S'Max( Left, Right : S'Base) 
  return S'Base 
 The function returns the greater of the values of the two parameters. 
S'Succ S'Succ denotes a function with the following specification:  
function  S'Succ( Arg : S'Base) 
  return S'Base 
 For an enumeration type, the function return s the value whose position number is one more 
than that of the value of Arg; Constraint_Error is raised if th ere is no such value of the type. 
For an integer type, the function returns the result of adding one to the value of Arg. For a 
fixed point type, the function returns the result of adding small  to the value of Arg. For a 
floating point type, the function returns th e machine number (as defined in 3.5.7) 
immediately above the value of Arg; Constraint_Error is raised if there is no such machine 
number.  
S'Pred S'Pred denotes a function with the following specification:  
function  S'Pred( Arg : S'Base) 
  return S'Base 
 For an enumeration type, the function retu rns the value whose position number is one less 
than that of the value of Arg; Constraint_Error is raised if th ere is no such value of the type. 
For an integer type, the function returns the result of subtracting one from the value of Arg. 
For a fixed point type, the function returns the result of subtracting small  from the value of 
Arg. For a floating point type, the function return s the machine number (as defined in 3.5.7) 
immediately below the value of Arg; Constraint_Error is raised if there is no such machine 
number.  
S'Wide_Wide_Image 
 S'Wide_Wide_Image denotes a functi on with the following specification:  
function  S'Wide_Wide_Image( Arg : S'Base) 
  return Wide_Wide_String 
 The function returns an image  of the value of Arg, that is, a sequence of characters 
representing the value in display form . The lower bound of the result is one. 
 The image of an integer value is the co rresponding decimal literal, without underlines, 
leading zeros, exponent, or trailing spaces, but with  a single leading character that is either 
a minus sign or a space.  10 
11 
12 
13 14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
27.1/2 
27.2/2 
27.3/2 
27.4/2 
Ada Reference Manual — 2012 Edition 
39      13 December 2012 Scalar Types   3.5  The image of an enumerati on value is either the corres ponding identifier in upper case or 
the corresponding character literal (including the two apostrophes); neither leading nor 
trailing spaces are included. For a nongraphic character  (a value of a character type that 
has no enumeration literal associated with  it), the result is a corresponding language-
defined name in upper case (for example, the image of the nongraphic character identified 
as nul is “NUL” — the quotes are not part of the image).  
 The image of a floating point value is a decimal real literal best approximating the value 
(rounded away from zero if halfway between) with a single leading character that is either a 
minus sign or a space, a single digit (that is  nonzero unless the value is zero), a decimal 
point, S'Digits–1 (see 3.5.8) digits after the deci mal point (but one if S'Digits is one), an 
upper case E, the sign of the exponent (either + or  –), and two or more digits (with leading 
zeros if necessary) representing the exponent. If S'Signed_Zeros is True, then the leading 
character is a minus sign for a negatively signed zero.  
 The image of a fixed point value is a decimal real literal best approximating the value 
(rounded away from zero if halfway between) with a single leading character that is either a 
minus sign or a space, one or more digits before the decimal point (with no redundant 
leading zeros), a decimal point, and S'Aft (s ee 3.5.10) digits after the decimal point.  
S'Wide_Image S'Wide _Image denotes a function with the following specification:  
function  S'Wide_Image( Arg : S'Base) 
  return Wide_String 
 The function returns an image of the value of Arg as a Wide_String. The lower bound of the 
result is one. The image has the same sequence of graphic characters as defined for S'Wide_Wide_Image if all the graphic characters are defined in Wide_Character; otherwise, the sequence of characters is implem entation defined (but no shorter than that of 
S'Wide_Wide_Image for the same value of Arg).  
 
Paragraphs 31 through 34 were moved to Wide_Wide_Image.   
S'Image S'Image denotes a function with the following specification:  
function  S'Image( Arg : S'Base) 
  return String 
 The function returns an image of the value of Arg as a String. The lower bound of the result 
is one. The image has the same sequence of graphic characters as that defined for S'Wide_Wide_Image if all the graphic character s are defined in Character; otherwise, the 
sequence of characters is implementation defined (but no shorter than that of 
S'Wide_Wide_Image for the same value of Arg).  
S'Wide_Wide_Width 
 S'Wide_Wide_Width denotes the maximum le ngth of a Wide_Wide_String returned by 
S'Wide_Wide_Image over all values of the subtyp e S. It denotes zero for a subtype that has 
a null range. Its type is universal_integer . 
S'Wide_Width 
 S'Wide_Width denotes the maximum length of  a Wide_String returned by S'Wide_Image 
over all values of the subtype S. It denotes zer o for a subtype that has a null range. Its type 
is universal_integer . 
S'Width S'Width denotes th e maximum length of a String returned by S'Image over all values of the 
subtype S. It denotes zero for a subtype that has a null range. Its type is universal_integer . 
S'Wide_Wide_Value 
 S'Wide_Wide_Value denotes a functi on with the following specification:  
function  S'Wide_Wide_Value( Arg : Wide_Wide_String) 
  return S'Base 27.5/2 
27.6/2 
27.7/2 
28 
29 
30/3 
35 
36 
37/3 
37.1/2 
38 
39 
39.1/2 
39.2/2 
Ada Reference Manual — 2012 Edition 
3.5   Scalar Types 13 December 2012      40  This function returns a value given an image of the value as a Wide_Wide_String, ignoring 
any leading or trailing spaces. 
 For the evaluation of a call on S'Wide_Wide_Value for an enumeration subtype S, if the 
sequence of characters of the parameter (i gnoring leading and trailing spaces) has the 
syntax of an enumeration literal and if it corresponds to a literal of the type of S (or corresponds to the result of S'Wide_Wide_Imag e for a nongraphic character of the type), 
the result is the corresponding enumeration value;  otherwise, Constrai nt_Error is raised.  
 For the evaluation of a call on S'Wide_Wide_Value for an integer subtype S, if the 
sequence of characters of the parameter (i gnoring leading and trailing spaces) has the 
syntax of an integer literal, with an optiona l leading sign character (plus or minus for a 
signed type; only plus for a modular type), and the corresponding numeric value belongs to 
the base range of the type of S, then that va lue is the result; otherwis e, Constraint_Error is 
raised. 
 For the evaluation of a call on S'Wide_Wide_Value for a real subtype S, if the sequence of 
characters of the parameter (ignoring leading a nd trailing spaces) has the syntax of one of 
the following:  
• 
numeric_literal  
• numeral .[exponent ] 
• .numeral [exponent ] 
• base #based_numeral .#[exponent ] 
• base #.based_numeral #[exponent ]  
 with an optional leading sign character (plu s or minus), and if the corresponding numeric 
value belongs to the base range of the type of  S, then that value is the result; otherwise, 
Constraint_Error is raised. The sign of a zero value is preserved (positive if none has been 
specified) if S'Signed_Zeros is True. 
S'Wide_Value 
 S'Wide_Value denotes a function with the following specification:  
function  S'Wide_Value( Arg : Wide_String) 
  return S'Base 
 This function returns a value given an image of the value as a Wide_String, ignoring any 
leading or trailing spaces. 
 For the evaluation of a call on S'Wide_Value fo r an enumeration subtype S, if the sequence 
of characters of the parameter (ignoring leadi ng and trailing spaces) has the syntax of an 
enumeration literal and if it corresponds to a lite ral of the type of S (or corresponds to the 
result of S'Wide_Image for a value of the ty pe), the result is the corresponding enumeration 
value; otherwise, Constraint_E rror is raised. For a numeric subtype S, the evaluation of a 
call on S'Wide_Value with Arg of type Wide_String is equivalent to a call on 
S'Wide_Wide_Value for a corresponding Arg of type Wide_Wide_String.  
 Paragraphs 44 through 51 were moved to Wide_Wide_Value.   
S'Value S'Value denotes a function with the following specification:  
function  S'Value( Arg : String) 
  return S'Base 
 This function returns a value given an image of the value as a String, ignoring any leading 
or trailing spaces. 
 For the evaluation of a call on S'Value for an enumeration subtype S, if the sequence of 
characters of the parameter (ignoring leading and trailing spaces) has the syntax of an 39.3/2 
39.4/3 
39.5/3 
39.6/2 
39.7/2 
39.8/2 39.9/2 
39.10/2 39.11/2 39.12/3 
40 
41 
42 
43/3 
52 
53 
54 
55/3 
Ada Reference Manual — 2012 Edition 
41      13 December 2012 Scalar Types   3.5 enumeration literal and if it corresponds to a lite ral of the type of S (or corresponds to the 
result of S'Image for a value of the type), th e result is the corresponding enumeration value; 
otherwise, Constraint_Error is raised. For a numeric subtype S, the evaluation of a call on 
S'Value with Arg of type String is equivalent to a call on S'Wide_Wide_Value for a 
corresponding Arg of type Wide_Wide_String.  
Implementation Permissions 
An implementation may extend the Wide_Wide_Va lue, Wide_Value, Value, Wide_Wide_Image, 
Wide_Image, and Image attributes of a floating point ty pe to support special values such as infinities and 
NaNs. 
An implementation may extend the Wide_Wide_Value, Wide_Value, and Value attributes of a character 
type to accept strings of the form “Hex_ hhhhhhhh ” (ignoring case) for any character (not just the ones for 
which Wide_Wide_Image would produce th at form — see 3.5.2), as well as three-character strings of the 
form “' X'”, where X is any character, including nongraphic characters.  
Static Semantics 
For a scalar type, the following language-defined re presentation aspect may be specified with an 
aspect_specification  (see 13.1.1):  
Default_Value 
 This aspect shall be specified by a static e xpression, and that expre ssion shall be explicit, 
even if the aspect has a boolean type. Default_Value shall be specified only on a 
full_type_declaration .  
If a derived type with no primitive subprograms inher its a boolean Default_Value aspect, the aspect may 
be specified to have any value for the derived type.  
Name Resolution Rules 
The expected type for the expression  specified for the Default_Value aspect is the type defined by the 
full_type_declaration  on which it appears.  
NOTES 
24  The evaluation of S'First or S'Last never raises an exception. If a scalar subtype S has a nonnull range, S'First and S'Last belong to this range. These values can, for example, always be assigned to a variable of subtype S.  
25  For a subtype of a scalar type, the result delivered by the attributes Succ, Pred, and Value might not belong to the 
subtype; similarly, the actual parameters of the attributes Succ, Pred, and Image need not belong to the subtype. 
26  For any value V (including any nongraphic character) of an enumeration subtype S, S'Value(S'Image(V)) equals V, as 
do S'Wide_Value(S'Wide_Image(V)) and S'Wide_Wide_Value(S'Wide_Wide_Image(V)). None of these expressions ever raise Constraint_Error.  
Examples 
Examples of ranges:   
-10 .. 10 
X .. X + 1 0.0 .. 2.0*Pi Red .. Green     --  see 3.5.1 
1 .. 0           --  a null range  
Table'Range      --  a range attribute reference (see 3.6)  
Examples of range constraints:   
range -999.0 .. +999.0 
range S'First+1 .. S'Last-1 56/2 
56.1/3 
56.2/3 
56.3/3 
56.4/3 
56.5/3 
57 
58 59 
60 
61 
62 
63 
Ada Reference Manual — 2012 Edition 
3.5.1    Enumeration Types 13 December 2012      42 3.5.1 Enumeration Types 
An enumeration_type_definition  defines an enumeration type.  
Syntax 
enumeration_type_definition ::=  
   (enumeration_literal _specification  {, enumeration_literal _specification }) 
enumeration_literal_specification ::=  defining_identifier  | defining_character_literal  
defining_character_literal ::= character_literal  
Legality Rules 
The defining_identifier s in upper case and the defining_character_literal s listed in an 
enumeration_type_definition  shall be distinct.  
Static Semantics 
Each enumeration_literal _specification  is the explicit declaration of the corresponding enumeration 
literal : it declares a parameterless func tion, whose defining name is the defining_identifier  or defining_-
character_literal , and whose result subtype is the base  subtype of the enumeration type.  
Each enumeration literal corresponds to a distinct valu e of the enumeration type, and to a distinct position 
number. The position number of the value of the fi rst listed enumeration literal is zero; the position 
number of the value of each subsequent enumeration litera l is one more than that of its predecessor in the 
list. 
The predefined order relations betw een values of the enumeration type follow the order of corresponding 
position numbers. 
If the same defining_identifier  or defining_character_literal  is specified in more than one enumeration_-
type_definition , the corresponding enumeration literals are said to be overloaded . At any place where an 
overloaded enumeration literal occurs in the text of a program, the type of the enumeration literal has to be 
determinable from the context (see 8.6).  
Dynamic Semantics 
The elaboration of an enumeration_type_definition  creates the enumeration type and its first subtype, 
which is constrained to the base range of the type.  
When called, the parameterless f unction associated with an enumer ation literal returns the corresponding 
value of the enumeration type.  
NOTES 
27  If an enumeration literal occurs in a context that does not otherwise suffice to determine the type of the literal, then qualification by the name of the enumeration type is one way to resolve the ambiguity (see 4.7).  
Examples 
Examples of enumeration types and subtypes:  
type Day    is (Mon, Tue, Wed, Thu, Fri, Sat, Sun); 
type Suit   is (Clubs, Diamonds, Hearts, Spades); 
type Gender is (M, F); 
type Level  is (Low, Medium, Urgent); 
type Color  is (White, Red, Yellow, Green, Blue, Brown, Black); 
type Light  is (Red, Amber, Green); --  Red and Green are overloaded  1 
2 
3 
4 
5/3 
6/3 
7 
8 
9 
10 
11 
12 
13 
14 
Ada Reference Manual — 2012 Edition 
43      13 December 2012 Enumeration Types   3.5.1 type Hexa   is ('A', 'B', 'C', 'D', 'E', 'F'); 
type Mixed  is ('A', 'B', '*', B, None, '?', '%'); 
subtype Weekday is Day   range Mon .. Fri; 
subtype Major   is Suit  range Hearts .. Spades; 
subtype Rainbow is Color range Red .. Blue;  --   the Color Red, not the Light  
3.5.2 Character Types 
Static Semantics 
An enumeration type is said to be a character type  if at least one of its enumeration literals is a 
character_literal . 
The predefined type Character is a character type whose values correspond to the 256 code points of Row 
00 (also known as Latin-1) of the ISO/IEC 10646:2011 Basic Multilingual Plane (BMP). Each of the 
graphic characters of Row 00 of the BMP has a corresponding character_literal  in Character. Each of the 
nongraphic characters of Row 00 has a corresponding langua ge-defined name, which is not usable as an 
enumeration literal, but which is usable with the attributes Image, Wide_Image, Wide_Wide_Image, 
Value, Wide_Value, and Wide_Wide_Va lue; these names are given in the definition of type Character in 
A.1, “The Package Standard”, but are set in italics .  
The predefined type Wide_Character is a character  type whose values correspond to the 65536 code points 
of the ISO/IEC 10646:2011 Basic Multilingual Plane (BMP).  Each of the graphic characters of the BMP 
has a corresponding character_literal  in Wide_Character. The first 256 values of Wide_Character have the 
same character_literal  or language-defined name as defined for Character. Each of the graphic_character s 
has a corresponding character_literal . 
The predefined type Wide_Wide_ Character is a character type whose values correspond to the 
2147483648 code points of the ISO/IEC 10646:2011 character set. Each of the graphic_character s has a 
corresponding character_literal  in Wide_Wide_Character. The first 65536 values of 
Wide_Wide_Character have the same character_literal  or language-defined name as defined for 
Wide_Character. 
The characters whose code point is larger than 16#FF# and which are not graphic_character s have 
language-defined names which are formed by appending to the string "Hex_" the representation of their 
code point in hexadecimal as eight extended digits. As with other language-def ined names, these names 
are usable only with the attributes (Wide_)Wide_Imag e and (Wide_)Wide_Value; they are not usable as 
enumeration literals. 
Paragraphs 6 and 7 were deleted.   
NOTES 
28  The language-defined library package Characters.Latin_1 (see A.3.3) includes the declaration of constants denoting control characters, lower case characters, and special characters of the predefined type Character.  
29  A conventional character set such as EBCDIC  can be declared as a character type; the internal codes of the characters 
can be specified by an 
enumeration_repres entation_clause  as explained in subclause 13.4.  
Examples 
Example of a character type:  
type Roman_Digit is ('I', 'V', 'X', 'L', 'C', 'D', 'M'); 15 
16 
1 
2/3 
3/3 
4/3 
5/3 
8 
9/3 
10 
11 
Ada Reference Manual — 2012 Edition 
3.5.3    Boolean Types 13 December 2012      44 3.5.3 Boolean Types 
Static Semantics 
There is a predefined enumeration type named Boolean, d eclared in the visible part of package Standard. It 
has the two enumeration literals False and True ordere d with the relation False < True. Any descendant of 
the predefined type Boolean is called a boolean  type.  
3.5.4 Integer Types 
An integer_type_definition  defines an integer type; it defines either a signed  integer type, or a modular  
integer type. The base range of a signed integer type includes at least the values of the specified range. A 
modular type is an integer type with  all arithmetic modulo a specified positive modulus ; such a type 
corresponds to an unsigned type with wrap-around semantics.  
Syntax 
integer_type_definition ::= signed_integer_type_definition  | modular_type_definition  
signed_integer_type_definition ::= range  static_ simple_expression  .. static_ simple_expression  
modular_type_definition ::= mod  static_ expression  
Name Resolution Rules 
Each simple_expression  in a signed_integer_type_definition  is expected to be of any integer type; they 
need not be of the same type. The expression  in a modular_type_definition  is likewise expected to be of 
any integer type.  
Legality Rules 
The simple_expression s of a signed_integer_type_definition  shall be static, and their values shall be in 
the range System.Min_Int .. System.Max_Int. 
The expression  of a modular_type_definition  shall be static, and its value (the modulus ) shall be positive, 
and shall be no greater than System.Max_Binary_ Modulus if a power of 2, or no greater than 
System.Max_Nonbinary_Modulus if not.  
Static Semantics 
The set of values for a signed integer type is the (i nfinite) set of mathematical integers, though only values 
of the base range of the type are fully supported fo r run-time operations. The set of values for a modular 
integer type are the values from 0 to one less than the modulus, inclusive. 
A signed_integer_type_definition  defines an integer type whose base range includes at least the values of 
the simple_expression s and is symmetric about zero, excepti ng possibly an extra negative value. A 
signed_integer_type_definition  also defines a constrained first subt ype of the type, with a range whose 
bounds are given by the values of the simple_expression s, converted to the type being defined.  
A modular_type_definition  defines a modular type whose base ra nge is from zero to one less than the 
given modulus. A modular_type_definition  also defines a constrained first subtype of the type with a 
range that is the same as the base range of the type. 
There is a predefined signed integer subtype named In teger, declared in the visible part of package 
Standard. It is constrained to the base range of its type.  1 
1 
2 
3 4 
5 
6 
7 
8 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
45      13 December 2012 Integer Types   3.5.4 Integer has two predefined subtypes, declared in the visible part of package Standard:  
subtype Natural  is Integer range 0 .. Integer'Last; 
subtype Positive is Integer range 1 .. Integer'Last; 
A type defined by an integer_type_definition  is implicitly derived from root_integer , an anonymous 
predefined (specific) integer type, whose base range  is System.Min_Int .. Syst em.Max_Int. However, the 
base range of the new type is not inherited from root_integer , but is instead determined by the range or 
modulus specified by the integer_type_definition . Integer literals are all of the type universal_integer , the 
universal type (see 3.4.1) for the class rooted at root_integer , allowing their use with the operations of any 
integer type.  
The position number  of an integer value is equal to the value. 
For every modular subtype S, the fo llowing attributes are defined:  
S'Mod S'Mod denotes a function with the following specification: 
function  S'Mod ( Arg : universal_integer ) 
  return S'Base 
 This function returns Arg mod  S'Modulus, as a value of the type of S. 
S'Modulus S'Modulus yields th e modulus of the type of S,  as a value of the type universal_integer .  
Dynamic Semantics 
The elaboration of an integer_type_definition  creates the integer type and its first subtype. 
For a modular type, if the result of the execution of a predefined operator (see 4.5) is outside the base 
range of the type, the result is redu ced modulo the modulus of the type to  a value that is within the base 
range of the type. 
For a signed integer type, the exception Constraint_Erro r is raised by the execution of an operation that 
cannot deliver the correct result because it is outside the base range of the type. For any integer type, 
Constraint_Error is raised by the operators "/", " rem", and " mod " if the right operand is zero. 
Implementation Requirements 
In an implementation, the range of Inte ger shall include the range –2**15+1 .. +2**15–1. 
If Long_Integer is predefined for an implementation, then its range  shall include the range –2**31+1 .. 
+2**31–1. 
System.Max_Binary_Modulus shall be at least 2**16.  
Implementation Permissions 
For the execution of a predefined operation of a signe d integer type, the implementation need not raise 
Constraint_Error if the result is outside the base range of the type, so long as the correct result is produced.  
An implementation may provide additional predefined signe d integer types, declared in the visible part of 
Standard, whose first subtypes have names of the fo rm Short_Integer, Long_Integ er, Short_Short_Integer, 
Long_Long_Integer, etc. Different predefined integer types are allowed to have the same base range. 
However, the range of Integer shoul d be no wider than that of Long_Integer. Similarly, the range of 
Short_Integer (if provided) should be no wider than  Integer. Corresponding reco mmendations apply to any 
other predefined integer types. There need not be a named integer type corresponding to each distinct base 
range supported by an implementation. The range of each first subtype should be the base range of its 
type.  12 
13 
14 
15 
16/2 
16.1/2 
16.2/2 
16.3/2 
17 
18 
19 
20 
21 
22 
23 
24 
25 
Ada Reference Manual — 2012 Edition 
3.5.4    Integer Types 13 December 2012      46 An implementation may provide nonstandard integer types , descendants of root_integer  that are declared 
outside of the specification of package Standard, which need not have all the standard characteristics of a 
type defined by an integer_type_definition . For example, a nonstandard integer type might have an 
asymmetric base range or it might not  be allowed as an array or loop i ndex (a very long integer). Any type 
descended from a nonstandard integer type is also  nonstandard. An implementation may place arbitrary 
restrictions on the use of such types; it is implementa tion defined whether operators that are predefined for 
“any integer type” are defined for a particular nonsta ndard integer type. In any case, such types are not 
permitted as explicit_generic_actual_parameter s for formal scalar types — see 12.5.2.  
For a one's complement machine, the high bound of the base range of a modular type whose modulus is 
one less than a power of 2 may be equal to the modul us, rather than one less than the modulus. It is 
implementation defined for which powers of 2,  if any, this permission is exercised. 
For a one's complement machine, implementations may support nonbinary  modulus values greater than 
System.Max_Nonbinary_Modulus. It is  implementation defined which specific values greater than 
System.Max_Nonbinary_Modulus, if any, are supported.  
Implementation Advice 
An implementation should support Long_Integer in add ition to Integer if the target machine supports 32-
bit (or longer) arithmetic. No other named integer subtypes are recommended for package Standard. 
Instead, appropriate named integer subtypes should be provided in the library pack age Interfaces (see B.2).  
An implementation for a two's comp lement machine should support modular  types with a binary modulus 
up to System.Max_Int*2+2. An im plementation should support a nonbinary  modulus up to Integer'Last.  
NOTES 
30  Integer literals are of the anonymous predefined integer type universal_integer . Other integer types have no literals. 
However, the overload resolution rules (see 8.6, “The Context of Overload Resolution”) allow expressions of the type universal_integer  whenever an integer type is expected. 
31  The same arithmetic operators are predefined for all signed integer types defined by a 
signed_integer_type_definition  
(see 4.5, “Operators and Expression Evaluation”). For modular types, these same operators are predefined, plus bit-wise logical operators ( and, or, xor, and not). In addition, for the unsigned types declared in the language-defined package 
Interfaces (see B.2), functions are defined that provide bit-wise shifting and rotating. 
32  Modular types match a 
generic_formal_parameter_declaration  of the form " type T is mod  <>;"; signed integer types 
match " type T is range  <>;" (see 12.5.2).  
Examples 
Examples of integer types and subtypes:  
type Page_Num  is range 1 .. 2_000; 
type Line_Size is range 1 .. Max_Line_Size; 
subtype Small_Int   is Integer   range -10 .. 10; 
subtype Column_Ptr  is Line_Size range 1 .. 10; 
subtype Buffer_Size is Integer   range 0 .. Max; 
type Byte        is mod 256; --  an unsigned byte  
type Hash_Index  is mod 97;  --  modulus is prime  26 
27 
27.1/1 
28 
29 
30 
31 
32 
33 
34 
35 
36 
Ada Reference Manual — 2012 Edition 
47      13 December 2012 Operations of Discrete Types   3.5.5 3.5.5 Operations of Discrete Types 
Static Semantics 
For every discrete subtype S, the following attributes are defined:  
S'Pos S'Pos denotes a function with the following specification:  
function  S'Pos( Arg : S'Base) 
  return universal_integer  
 This function returns the position number of the value of Arg, as a value of type 
universal_integer . 
S'Val S'Val denotes a function with the following specification:  
function  S'Val( Arg : universal_integer ) 
  return S'Base 
 This function returns a value of the type of S whose position number equals the value of 
Arg. For the evaluation of a call on S'Val, if ther e is no value in the base range of its type 
with the given position number, Constraint_Error is raised.  
For every static discrete subtype S for which there exis ts at least one value belonging to S that satisfies any 
predicate of S, the following attributes are defined: 
S'First_Valid 
 S'First_Valid denotes the smallest value that belongs to S and satisfies the predicate of S. 
The value of this attribute is of the type of S. 
S'Last_Valid 
 S'Last_Valid denotes the largest value that bel ongs to S and satisfies the predicate of S. The 
value of this attribute is of the type of S.  
First_Valid and Last_Valid attribute_reference s are always static expressions. Any explicit predicate of S 
can only have been specified by a Static_Predicate aspect. 
Implementation Advice 
For the evaluation of a call on S'Pos for an enumera tion subtype, if the value of the operand does not 
correspond to the internal code for any enumeration lite ral of its type (perhaps due to an uninitialized 
variable), then the implementati on should raise Program_Error. This is particularly important for 
enumeration types with noncontiguous internal codes specified by an enumeration_representation_-
clause .  
NOTES 
33  Indexing and loop iteration use values of discrete types. 
34  The predefined operations of a discrete type include the assignment operation, qualification, the membership tests, and 
the relational operators; for a boolean type they include the short-circuit control forms and the logical operators; for an integer type they include type conversion to and from other numeric types, as well as the binary and unary adding operators – and +, the multiplying operators, the unary operator abs, and the exponentiation operator. The assignment 
operation is described in 5.2. The other predefined operations are described in Clause 4. 
35  As for all types, objects of a discrete type have Size and Address attributes (see 13.3). 36  For a subtype of a discrete type, the result delivered by the attribute Val might not belong to the subtype; similarly, the  
actual parameter of the attribute Pos need not belong to the subtype. The following relations are satisfied (in the absence of an exception) by these attributes:  
   S'Val(S'Pos(X)) = X 
   S'Pos(S'Val(N)) = N 1 
2 
3 
4 
5 
6 
7 
7.1/3 
7.2/3 
7.3/3 
7.4/3 
8 
9 
10/3 
11 
12 
13 
Ada Reference Manual — 2012 Edition 
3.5.5    Operations of Discrete Types 13 December 2012      48 Examples 
Examples of attributes of discrete subtypes:  
--  For the types and subtypes declared in subclause 3.5.1 the following hold:  
--  Color'First   = White,   Color'Last   = Black 
--  Rainbow'First = Red,     Rainbow'Last = Blue 
--  Color'Succ(Blue) = Rainbow'Succ(Blue) = Brown 
--  Color'Pos(Blue)  = Rainbow'Pos(Blue)  = 4 --  Color'Val(0)     = Rainbow'Val(0)     = White 
3.5.6 Real Types 
Real types provide approximations to the real numbe rs, with relative bounds on errors for floating point 
types, and with absolute bounds for fixed point types.  
Syntax 
real_type_definition ::=  
   floating_point_definition  | fixed_point_definition  
Static Semantics 
A type defined by a real_type_definition  is implicitly derived from root_real , an anonymous predefined 
(specific) real type. Hence, all real types, whether floating point or fixed point, are in the derivation class 
rooted at root_real .  
Real literals are all of the type universal_real , the universal type (see 3.4.1) for the class rooted at 
root_real , allowing their use with the operations of any real type. Certain multiplying operators have a 
result type of universal_fixed  (see 4.5.5), the universal type for the class of fixed point types, allowing the 
result of the multiplication or division to be used where any specific fixed point type is expected.  
Dynamic Semantics 
The elaboration of a real_type_definition  consists of the elaboration of the floating_point_definition  or the 
fixed_point_definition .  
Implementation Requirements 
An implementation shall perform the run-time eval uation of a use of a predefined operator of root_real  
with an accuracy at least as great as that of any floating point type definable by a floating_point_definition .  
Implementation Permissions 
For the execution of a predefined operation of a real type, the implementation need not raise 
Constraint_Error if the result is outside the base range of the type, so long as the correct result is produced, 
or the Machine_Overflows attribute of the type is False (see G.2). 
An implementation may provide nonstandard real types , descendants of root_real  that are declared 
outside of the specification of package Standard, which need not have all the standard characteristics of a 
type defined by a real_type_definition . For example, a nonstandard real ty pe might have an asymmetric or 
unsigned base range, or its predefined operations mi ght wrap around or “saturate” rather than overflow 
(modular or saturating arithmetic), or it might not conform to the accuracy model (see G.2). Any type descended from a nonstandard real type is also nonstandard. An implementation may place arbitrary 
restrictions on the use of such types; it is implementa tion defined whether operators that are predefined for 
“any real type” are defined for a particular nonstandard  real type. In any case, such types are not permitted 
as 
explicit_generic_actual_parameter s for formal scalar types — see 12.5.2.  14 
15 
16 
17 
1 
2 
3 
4 
5 
6 
7/2 
8 
Ada Reference Manual — 2012 Edition 
49      13 December 2012 Real Types   3.5.6 NOTES 
37  As stated, real literals are of the anonymous predefined real type universal_real . Other real types have no literals. 
However, the overload resolution rules (see 8.6) allow expressions of the type universal_real  whenever a real type is 
expected. 
3.5.7 Floating Point Types 
For floating point types, the error bound is specifi ed as a relative precision by giving the required 
minimum number of significant decimal digits.  
Syntax 
floating_point_definition ::=  
  digits  static_ expression  [real_range_specification ] 
real_range_specification ::=  
  range  static_ simple_expression  .. static_ simple_expression  
Name Resolution Rules 
The requested decimal precision , which is the minimum number of si gnificant decimal digits required for 
the floating point type, is specified by the value of the expression  given after the reserved word digits . 
This expression  is expected to be of any integer type. 
Each simple_expression  of a real_range_specification  is expected to be of any real type; the types need 
not be the same.  
Legality Rules 
The requested decimal precision shall be specified by a static expression  whose value is positive and no 
greater than System.Max_Base_Digits. Each simple_expression  of a real_range_specification  shall also 
be static. If the real_range_specification  is omitted, the requested decimal precision shall be no greater 
than System.Max_Digits.  
A floating_point_definition  is illegal if the implementation does not support a floating point type that 
satisfies the requested decimal precision and range.  
Static Semantics 
The set of values for a floating point type is the (infinite) set of rational numbers. The machine numbers  of 
a floating point type are the values of the type th at can be represented exactly in every unconstrained 
variable of the type. The base range (see 3.5) of a floating point type is symmetric around zero, except that 
it can include some extra negative values in some implementations. 
The base decimal precision  of a floating point type is the number of decimal digits of precision 
representable in objects of the type. The safe range  of a floating point type is that part of its base range for 
which the accuracy corresponding to the base decimal pr ecision is preserved by all predefined operations.  
A floating_point_definition  defines a floating point type whose ba se decimal precision is no less than the 
requested decimal precision. If a real_range_specification  is given, the safe range of the floating point 
type (and hence, also its base range) includes at leas t the values of the simple expressions given in the 
real_range_specification . If a real_range_specification  is not given, the safe (and base) range of the type 
includes at least the values of the range –10.0**(4*D ) .. +10.0**(4*D) where D is the requested decimal 
precision. The safe range might include  other values as well. The attribut es Safe_First and Safe_Last give 
the actual bounds of the safe range. 9 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
3.5.7    Floating Point Types 13 December 2012      50 A floating_point_definition  also defines a first subtype of the type. If a real_range_specification  is given, 
then the subtype is constrained to  a range whose bounds are given by a conversion of the values of the 
simple_expression s of the real_range_specification  to the type being defined. Otherwise, the subtype is 
unconstrained. 
There is a predefined, unconstrained, floating point subt ype named Float, declared in the visible part of 
package Standard.  
Dynamic Semantics 
The elaboration of a floating_point_definition  creates the floating point type and its first subtype.  
Implementation Requirements 
In an implementation that supports floating point types with 6 or more digits of precision, the requested 
decimal precision for Float shall be at least 6. 
If Long_Float is predefined for an implementation, then its requested decimal precision shall be at least 
11.  
Implementation Permissions 
An implementation is allowed to provide additional pred efined floating point types, declared in the visible 
part of Standard, whose (unconstrained) first subtyp es have names of the form Short_Float, Long_Float, 
Short_Short_Float, Long_Long_Float, et c. Different predefined floating point types are allowed to have 
the same base decimal precision. However, the preci sion of Float should be no greater than that of 
Long_Float. Similarly, the precision of Short_Float (if provided) should be no greater than Float. 
Corresponding recommendations apply to any other predef ined floating point types. There need not be a 
named floating point type corresponding to each di stinct base decimal precision supported by an 
implementation.  
Implementation Advice 
An implementation should support Long_Float in additi on to Float if the target machine supports 11 or 
more digits of precision. No othe r named floating point subtypes ar e recommended for package Standard. 
Instead, appropriate named floating point subtypes s hould be provided in the library package Interfaces 
(see B.2).  
NOTES 
38  If a floating point subtype is unconstrained, then assignments to variables of the subtype involve only Overflow_Checks, never Range_Checks.  
Examples 
Examples of floating point types and subtypes:   
type Coefficient is digits 10 range -1.0 .. 1.0; 
type Real is digits 8; 
type Mass is digits 7 range 0.0 .. 1.0E35; 
subtype Probability is Real range 0.0 .. 1.0;   --    a subtype with a smaller range  11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
Ada Reference Manual — 2012 Edition 
51      13 December 2012 Operations of Floating Point Types   3.5.8 3.5.8 Operations of Floating Point Types 
Static Semantics 
The following attribute is defined for every floating point subtype S: 
S'Digits S'Digits denotes the requested decimal precision for the subtype S. The value of this 
attribute is of the type universal_integer . The requested decimal precision of the base 
subtype of a floating point type T is defined to be the largest value of d for which  
 ceiling( d * log(10) / log(T'Machine_Radix)) + g <= T'Model_Mantissa 
 where g is 0 if Machine_Radix is a positive power of 10 and 1 otherwise.  
NOTES 
39  The predefined operations of a floating point type include the assignment operation, qualification, the membership tests, and explicit conversion to and from other numeric types. They also include the relational operators and the following predefined arithmetic operators: the binary and unary adding operators – and +, certain multiplying operators, the unary operator abs, and the exponentiation operator. 
40  As for all types, objects of a floating point type have Size and Address attributes (see 13.3). Other attributes of floatin g 
point types are defined in A.5.3.  
3.5.9 Fixed Point Types 
A fixed point type is either an ordinary fixed point  type, or a decimal fixed point type. The error bound of 
a fixed point type is specified as an absolute value, called the delta  of the fixed point type.  
Syntax 
fixed_point_definition ::= or dinary_fixed_point_definition  | decimal_fixed_point_definition  
ordinary_fixed_point_definition ::=  
   delta  static_ expression   real_range_specification  
decimal_fixed_point_definition ::=  
   delta  static_ expression  digits  static_ expression  [real_range_specification ] 
digits_constraint ::=  
   digits  static_ expression  [range_constraint ] 
Name Resolution Rules 
For a type defined by a fixed_point_definition , the delta  of the type is specified by the value of the 
expression  given after the reserved word delta ; this expression  is expected to be of any real type. For a 
type defined by a decimal_fixed_point_definition  (a decimal  fixed point type), the number of significant 
decimal digits for its first subtype (the digits  of the first subtype) is specified by the expression  given after 
the reserved word digits ; this expression  is expected to be of any integer type.  
Legality Rules 
In a fixed_point_definition  or digits_constraint , the expression s given after the reserved words delta  and 
digits  shall be static; their values shall be positive. 
The set of values of a fixed point type compri se the integral multiples of a number called the small  of the 
type. The machine numbers  of a fixed point type are the values of the type that can be represented exactly 
in every unconstrained variable of the type. For a type defined by an ordinary_fixed_point_definition  (an 
ordinary  fixed point type), the small  may be specified by an attribute_definition_clause  (see 13.3); if so 
specified, it shall be no greater than the delta  of the type. If not specified, the small  of an ordinary fixed 
point type is an implementation-defined power of two less than or equal to the delta .  1 
2/1 
3 
4 
1 
2 
3 
4 5 
6 
7 
8/2 
Ada Reference Manual — 2012 Edition 
3.5.9    Fixed Point Types 13 December 2012      52 For a decimal fixed point type, the small  equals the delta ; the delta  shall be a power of 10. If a 
real_range_specification  is given, both bounds of the range shall be in the range –(10** digits –1)*delta  .. 
+(10** digits –1)*delta . 
A fixed_point_definition  is illegal if the implementation does not support a fixed point type with the given 
small  and specified range or digits .  
For a subtype_indication  with a digits_constraint , the subtype_mark  shall denote a decimal fixed point 
subtype.  
Static Semantics 
The base range (see 3.5) of a fixed point type is  symmetric around zero, except possibly for an extra 
negative value in some implementations. 
An ordinary_fixed_point_definition  defines an ordinary fixed point type  whose base range includes at least 
all multiples of small  that are between the bounds specified in the real_range_specification . The base 
range of the type does not necessarily in clude the specified bounds themselves. An ordinary_fixed_point_-
definition  also defines a constrained first subtype of th e type, with each bound of its range given by the 
closer to zero of:  
• the value of the conversion to the fixed point type of the corresponding expression  of the 
real_range_specification ;  
• the corresponding bound of the base range.  
A decimal_fixed_point_definition  defines a decimal fixed point type whose base range includes at least 
the range –(10** digits –1)*delta  .. +(10** digits –1)*delta . A decimal_fixed_point_definition  also defines a 
constrained first subtype of the type. If a real_range_specification  is given, the bounds of the first subtype 
are given by a conversion of the values of the expression s of the real_range_specification . Otherwise, the 
range of the first subtype is –(10** digits –1)*delta  .. +(10** digits –1)*delta . 
Dynamic Semantics 
The elaboration of a fixed_point_definition  creates the fixed point type and its first subtype. 
For a digits_constraint  on a decimal fixed point subtype with a given delta , if it does not have a 
range_constraint , then it specifies an implicit range –(10** D–1)*delta  .. +(10** D–1)*delta , where D is 
the value of the expression . A digits_constraint  is compatible  with a decimal fixed point subtype if the 
value of the expression  is no greater than the digits  of the subtype, and if it specifies (explicitly or 
implicitly) a range that is comp atible with the subtype.  
The elaboration of a digits_constraint  consists of the elaboration of the range_constraint , if any. If a 
range_constraint  is given, a check is made that the bounds  of the range are both in the range –(10** D–
1)*delta  .. +(10** D–1)*delta , where D is the value of the (static) expression  given after the reserved 
word digits . If this check fails, Cons traint_Error is raised.  
Implementation Requirements 
The implementation shall support at leas t 24 bits of precision (including the sign bit) for fixed point types.  
Implementation Permissions 
Implementations are permitted to support only small s that are a power of two. In particular, all decimal 
fixed point type declarations can be disallowed. No te however that conformance with the Information 
Systems Annex requires support for decimal small s, and decimal fixed point type declarations with digits  
up to at least 18.  9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
Ada Reference Manual — 2012 Edition 
53      13 December 2012 Fixed Point Types   3.5.9 NOTES 
41  The base range of an ordinary fixed point type need not include the specified bounds themselves so that the range specification can be given in a natural way, such as:  
   type Fraction is delta  2.0**(-15) range -1.0 .. 1.0; 
   
With 2's complement hardware, such a type could have a signed 16-bit representation, using 1 bit for the sign and 15 bits 
for fraction, resulting in a base range of –1.0 .. 1.0–2.0**(–15).  
Examples 
Examples of fixed point types and subtypes:   
type Volt is delta 0.125 range 0.0 .. 255.0; 
  -- A pure fraction which requires all the available  
  -- space in a word can be declared as the type Fraction:  
type Fraction is delta System.Fine_Delta range -1.0 .. 1.0; 
  -- Fraction'Last = 1.0 – System.Fine_Delta  
type Money is delta 0.01 digits 15;  -- decimal fixed point  
subtype Salary is Money digits 10; 
  -- Money'Last = 10.0**13 – 0.01, Salary'Last = 10.0**8 – 0.01  
3.5.10 Operations of Fixed Point Types 
Static Semantics 
The following attributes are defined for every fixed point subtype S:  
S'Small S'Small denotes the small  of the type of S. The value of this attribute is of the type 
universal_real . Small may be specified for nonderived ordinary fixed point types via an 
attribute_definition_clause  (see 13.3); the expression of such a clause shall be static. 
S'Delta S'Delta denotes the delta  of the fixed point subtype S. The value of this attribute is of the 
type universal_real .  
S'Fore S'Fore yields the minimum number of characters needed before the decimal point for the 
decimal representation of any value of the s ubtype S, assuming that the representation does 
not include an exponent, but includes a one-charact er prefix that is either a minus sign or a 
space. (This minimum number does not include superfluous zeros or underlines, and is at 
least 2.) The value of this attribute is of the type universal_integer . 
S'Aft S'Aft yields the number of decimal digits needed after the decimal point to accommodate 
the delta  of the subtype S, unless the delta  of the subtype S is greater than 0.1, in which 
case the attribute yields the va lue one. (S'Aft is the smallest positive integer N for which 
(10**N)*S'Delta is greater than or equal to one.)  The value of this attribute is of the type 
universal_integer .  
The following additional attributes are defined for every decimal fixed point subtype S:  
S'Digits S'Digits denotes the digits  of the decimal fixed point subtype S, which corresponds to the 
number of decimal digits that are representable in objects of the subtype. The value of this 
attribute is of the type universal_integer . Its value is determined as follows:  
• For a first subtype or a subtype defined by a subtype_indication  with a 
digits_constraint , the digits is the value of the expression given after the reserved 
word digits ; 
• For a subtype defined by a subtype_indication  without a digits_constraint , the 
digits of the subtype is the same as  that of the subtype denoted by the 
subtype_mark  in the subtype_indication .  22 
23 
24 
25 
26 
27 
28 
1 
2/1 
3 
4 
5 
6 
7 
8 
9 
Ada Reference Manual — 2012 Edition 
3.5.10    Operations of Fixed Point Types 13 December 2012      54 • The digits of a base subt ype is the largest integer D such that the range –(10** D–
1)*delta  .. +(10** D–1)*delta  is included in the base range of the type. 
S'Scale S'Scale denotes the scale  of the subtype S, defined as the value N such that S'Delta = 
10.0**(–N). The scale indicates the position of th e point relative to the rightmost significant 
digits of values of subtype S. The va lue of this attribute is of the type universal_integer .  
S'Round S'Round denotes a function with the following specification:  
function  S'Round( X : universal_real ) 
  return S'Base 
 The function returns the value obtained by  rounding X (away from 0, if X is midway 
between two values of the type of S).  
NOTES 
42  All subtypes of a fixed point type will have the same value for the Delta attribute, in the absence of delta_constraint s 
(see J.3). 
43  S'Scale is not always the same as S'Aft for a decimal subtype; for example, if S'Delta = 1.0 then S'Aft is 1 while 
S'Scale is 0. 
44  The predefined operations of a fixed point type include the assignment operation, qualification, the membership tests, 
and explicit conversion to and from other numeric types. They also include the relational operators and the following predefined arithmetic operators: the binary and unary adding operators – and +, multiplying operators, and the unary operator abs. 
45  As for all types, objects of a fixed point type have Size and Address attributes (see 13.3). Other attributes of fixed 
point types are defined in A.5.4.  
3.6 Array Types 
An array  object is a composite object c onsisting of components which all have the same subtype. The 
name for a component of an array uses one or more i ndex values belonging to specified discrete types. The 
value of an array object is a composite value consisting of th e values of the components.  
Syntax 
array_type_definition ::=  
   unconstrained_array_definition  | constrained_array_definition  
unconstrained_array_definition ::=  
   array (index_subtype_definition  {, index_subtype_definition }) of component_definition  
index_subtype_definition ::= subtype_mark  range  <> 
constrained_array_definition ::=  
   array  (discrete_subtype_definition  {, discrete_subtype_definition }) of component_definition  
discrete_subtype_definition ::= discrete_ subtype_indication  | range  
component_definition ::=  
   [aliased ] subtype_indication  
 | [aliased ] access_definition  
Name Resolution Rules 
For a discrete_subtype_definition  that is a range , the range  shall resolve to be of some specific discrete 
type; which discrete type shall be determined w ithout using any context other than the bounds of the range  
itself (plus the preference for root_integer  — see 8.6).  10 
11 
12 
13 
14 
15 
16 17 
18 
1 
2 
3 4 
5 
6 
7/2 
8 
Ada Reference Manual — 2012 Edition 
55      13 December 2012 Array Types   3.6 Legality Rules 
Each index_subtype_definition  or discrete_subtype_definition  in an array_type_definition  defines an 
index subtype ; its type (the index type ) shall be discrete.  
The subtype defined by the subtype_indication  of a component_definition  (the component subtype ) shall 
be a definite subtype.  
This paragraph was deleted.  
Static Semantics 
An array is characterized by the number of indices (the dimensionality  of the array), the type and position 
of each index, the lower and upper bounds for each inde x, and the subtype of the components. The order 
of the indices is significant. 
A one-dimensional array has a distinct component fo r each possible index value. A multidimensional array 
has a distinct component for each possible sequence of index values that can be formed by selecting one 
value for each index position (in the given order). The po ssible values for a given index are all the values 
between the lower and upper bounds, inclusive;  this range of values is called the index range . The bounds  
of an array are the bounds of its index ranges. The length  of a dimension of an array is the number of 
values of the index range of the dimension (zero for a null range). The length  of a one-dimensional array is 
the length of its only dimension. 
An array_type_definition  defines an array type and its first subtype. For each object of this array type, the 
number of indices, the type and position of each index,  and the subtype of the components are as in the 
type definition; the values of the lower and uppe r bounds for each index belong to the corresponding index 
subtype of its type, except for null arrays (see 3.6.1). 
An unconstrained_array_definition  defines an array type with an unconstrained first subtype. Each 
index_subtype_definition  defines the corresponding index subtype to be the subtype denoted by the 
subtype_mark . The compound delimiter <> (called a box) of an index_subtype_definition  stands for an 
undefined range (different objects of the type need not have the same bounds). 
A constrained_array_definition  defines an array type with a constrained first subtype. Each discrete_-
subtype_definition  defines the corresponding index subtype, as  well as the corresponding index range for 
the constrained first subtype. The constraint  of the first subtype consists of  the bounds of the index ranges.  
The discrete subtype defined by a discrete_subtype_definition  is either that defined by the subtype_-
indication , or a subtype determined by the range  as follows:  
• If the type of the range  resolves to root_integer , then the discrete_subtype_definition  defines a 
subtype of the predefined type Integer with bounds given by a conversion to Integer of the 
bounds of the range ;  
• Otherwise, the discrete_subtype_definition  defines a subtype of the type of the range , with the 
bounds given by the range .  
The component_definition  of an array_type_definition  defines the nominal subtype of the components. If 
the reserved word aliased  appears in the component_definition , then each component of the array is 
aliased (see 3.10).  
Dynamic Semantics 
The elaboration of an array_type_definition  creates the array type and its first subtype, and consists of the 
elaboration of any discrete_subtype_definition s and the component_definition . 9 
10 
11/2 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
Ada Reference Manual — 2012 Edition 
3.6   Array Types 13 December 2012      56 The elaboration of a discrete_subtype_definition  that does not contain any per-object expressions creates 
the discrete subtype, and consis ts of the elaboration of the subtype_indication  or the evaluation of the 
range . The elaboration of a discrete_subtype_definition  that contains one or mo re per-object expressions 
is defined in 3.8. The elaboration of a component_definition  in an array_type_definition  consists of the 
elaboration of the subtype_indication  or access_definition . The elaboration of any discrete_subtype_-
definition s and the elaboration of the component_definition  are performed in an arbitrary order.  
Static Semantics 
For an array type with a scalar component type, th e following language-defined representation aspect may 
be specified with an aspect_specification  (see 13.1.1):  
Default_Component_Value 
 This aspect shall be specified by a static e xpression, and that expre ssion shall be explicit, 
even if the aspect has a boolean type. Defau lt_Component_Value shall be specified only on 
a full_type_declaration .  
If a derived type with no primitive subprograms inher its a boolean Default_Component_Value aspect, the 
aspect may be specified to have any value for the derived type.  
Name Resolution Rules 
The expected type for the expression  specified for the Default_Co mponent_Value aspect is the 
component type of the array type defined by the full_type_declaration  on which it appears.  
NOTES 
46  All components of an array have the same subtype. In particular, for an array of components that are one-dimensional arrays, this means that all components have the same bounds and hence the same length. 
47  Each elaboration of an 
array_type_definition  creates a distinct array type. A consequence of this is that each object 
whose object_declaration  contains an array_type_definition  is of its own unique type.  
Examples 
Examples of type declarations with unconstrained array definitions:  
type Vector     is array(Integer  range <>) of Real; 
type Matrix     is array(Integer  range <>, Integer range <>) of Real; 
type Bit_Vector is array(Integer  range <>) of Boolean; 
type Roman      is array(Positive range <>) of Roman_Digit; --  see 3.5.2 
Examples of type declarations with constrained array definitions:  
type Table    is array(1 .. 10) of Integer; 
type Schedule is array(Day) of Boolean; 
type Line     is array(1 .. Max_Line_Size) of Character; 
Examples of object declarations  with array type definitions:  
Grid      : array(1 .. 80, 1 .. 100) of Boolean; 
Mix       : array(Color range Red .. Green) of Boolean; 
Msg_Table : constant array (Error_Code) of access constant  String := 
      (Too_Big => new String'("Result too big"), Too_Small => ...); 
Page      : array(Positive range <>) of Line :=  --   an array of arrays  
  (1 | 50  => Line'(1 | Line'Last => '+', others => '-'),  --  see 4.3.3 
   2 .. 49 => Line'(1 | Line'Last => '|', others => ' ')); 
    --  Page is constrained by its initial value to (1..50)  22/2 
22.1/3 
22.2/3 
22.3/3 
22.4/3 
23 
24 
25 
26 
27 
28 
29 
30/2 
Ada Reference Manual — 2012 Edition 
57      13 December 2012 Index Constraints and Discrete Ranges   3.6.1 3.6.1 Index Constraints and Discrete Ranges 
An index_constraint  determines the range of possible values for every index of an array subtype, and 
thereby the corresponding array bounds.  
Syntax 
index_constraint ::=  (discrete_range  {, discrete_range }) 
discrete_range ::= discrete_ subtype_indication  | range  
Name Resolution Rules 
The type of a discrete_range  is the type of the subtype defined by the subtype_indication , or the type of 
the range . For an index_constraint , each discrete_range  shall resolve to be of the type of the 
corresponding index.  
Legality Rules 
An index_constraint  shall appear only in a subtype_indication  whose subtype_mark  denotes either an 
unconstrained array subtype, or an unconstraine d access subtype whose designated subtype is an 
unconstrained array subtype; in either case, the index_constraint  shall provide a discrete_range  for each 
index of the array type.  
Static Semantics 
A discrete_range  defines a range whose bounds are given by the range , or by the range of the subtype 
defined by the subtype_indication .  
Dynamic Semantics 
An index_constraint  is compatible  with an unconstrained array subtype if and only if the index range 
defined by each discrete_range  is compatible (see 3.5) with the corresponding index subtype. If any of 
the discrete_range s defines a null range, any array thus constrained is a null array , having no 
components. An array value satisfies  an index_constraint  if at each index position the array value and the 
index_constraint  have the same index bounds.  
The elaboration of an index_constraint  consists of the evaluation of the discrete_range (s), in an arbitrary 
order. The evaluation of a discrete_range  consists of the elaboration of the subtype_indication  or the 
evaluation of the range .  
NOTES 
48  The elaboration of a subtype_indication  consisting of a subtype_mark  followed by an index_constraint  checks the 
compatibility of the index_constraint  with the subtype_mark  (see 3.2.2). 
49  Even if an array value does not satisfy the index constraint of an array subtype, Constraint_Error is not raised on 
conversion to the array subtype,  so long as the length of each dimension of the array va lue and the array subtype match. 
See 4.6.  
Examples 
Examples of array declarations  including an index constraint:  
Board     : Matrix(1 .. 8,  1 .. 8);  --   see 3.6 
Rectangle : Matrix(1 .. 20, 1 .. 30); Inverse   : Matrix(1 .. N,  1 .. N);  --   N need not be static  
Filter    : Bit_Vector(0 .. 31); 1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
Ada Reference Manual — 2012 Edition 
3.6.1    Index Constraints and Discre te Ranges 13 December 2012      58 Example of array declaration with  a constrained array subtype:  
My_Schedule : Schedule;  --   all arrays of type Schedule have the same bounds  
Example of record type with a component that is an array:  
type Var_Line(Length : Natural) is 
   record 
      Image : String(1 .. Length);    end record; 
Null_Line : Var_Line(0);  --   Null_Line.Image is a null array  
3.6.2 Operations of Array Types 
Legality Rules 
The argument N used in the attribute_designator s for the N-th dimension of an array shall be a static 
expression  of some integer type. The value of N sha ll be positive (nonzero) and no greater than the 
dimensionality of the array.  
Static Semantics 
The following attributes are defined for a prefix  A that is of an array type (after any implicit dereference), 
or denotes a constrained array subtype:  
A'First A'First denotes the lower bound of the firs t index range; its type is the corresponding index 
type. 
A'First(N) A'First(N) denotes the lower bound of th e N-th index range; its type is the corresponding 
index type. 
A'Last A'Last denotes the upper bound of the first index range; its type is the corresponding index 
type. 
A'Last(N) A'Last(N) denotes the upper bound of the N-th index range; its type is the corresponding 
index type. 
A'Range A'Range is equivalent to the range A'First .. A'Last, except that the prefix  A is only 
evaluated once. 
A'Range(N) A'Range(N) is equivalent to the ra nge A'First(N) .. A'Last(N), except that the prefix  A is 
only evaluated once. 
A'Length A'Length denotes the number of values of the first index range (zero for a null range); its 
type is universal_integer . 
A'Length(N) A'Length(N) denotes the number of values  of the N-th index range (zero for a null range); 
its type is universal_integer .  
Implementation Advice 
An implementation should normally represent multidimensi onal arrays in row-major order, consistent with 
the notation used for multidimensional array aggregates  (see 4.3.3). However, if convention Fortran is 
specified for a multidimensional array type, then colu mn-major order should be used instead (see B.5, 
“Interfacing with Fortran”).  
NOTES 
50  The attribute_reference s A'First and A'First(1) denote the same value. A similar relation exists for the 
attribute_reference s A'Last, A'Range, and A'Length. The following relation is satisfied (except for a null array) by the 
above attributes if the index type is an integer type:  
   A'Length(N) = A'Last(N) - A'First(N) + 1 14 
15 
16 
17 
18 
1 
2/1 
3 
4 5 6 7 8 9 
10 
11/3 
12 
13 
Ada Reference Manual — 2012 Edition 
59      13 December 2012 Operations of Array Types   3.6.2 51  An array type is limited if its component type is limited (see 7.5). 
52  The predefined operations of an array type include the membership tests, qualification, and explicit conversion. If the 
array type is not limited, they also include assignment and the predefined equality operators. For a one-dimensional array type, they include the predefined concatenation operators (if nonlimited) and, if the component type is discrete, the predefined relational operators; if the component type is boolean, the predefined logical operators are also included. 
53  A component of an array can be named with an 
indexed_component . A value of an array type can be specified with an 
array_aggregate . For a one-dimensional array type, a slice of the array can be named; also, string literals are defined if the 
component type is a character type.  
Examples 
Examples (using arrays declared in  the examples of subclause 3.6.1):   
--  Filter'First      =   0   Filter'Last       =  31   Filter'Length =  32 
--  Rectangle'Last(1) =  20   Rectangle'Last(2) =  30 
3.6.3 String Types 
Static Semantics 
A one-dimensional array type whose component  type is a character type is called a string  type. 
There are three predefined string types, String, Wi de_String, and Wide_Wide_String, each indexed by 
values of the predefined subtype Po sitive; these are declared  in the visible part of package Standard:  
subtype Positive is Integer range 1 .. Integer'Last; 
type String is array(Positive range <>) of Character; 
type Wide_String is array(Positive range <>) of Wide_Character; 
type Wide_Wide_String is array(Positive range <>) of Wide_Wide_Character; 
 
NOTES 
54  String literals (see 2.6 and 4.2) are defined for all string types. The concatenation operator & is predefined for string 
types, as for all nonlimited one-dimensional array types. The ordering operators <, <=, >, and >= are predefined for string types, as for all one-dimensional discrete array types; these ordering operators correspond to lexicographic order (see 4.5.2). 
Examples 
Examples of string objects:   
Stars      : String(1 .. 120) := (1 .. 120 => '*' ); 
Question   : constant  String  := "How many characters?"; 
 --  Question'First = 1, Question'Last = 20  
 --  Question'Length = 20 (the number of 
characters)  
Ask_Twice  : String  := Question & Question; --  constrained to (1..40)  
Ninety_Six : constant  Roman   := "XCVI"; --  see 3.5.2 and 3.6  14 
15 
16/2 
17 
18 
1 
2/2 
3 
4/2 
5 
6 
7 
8 
Ada Reference Manual — 2012 Edition 
3.7   Discriminants 13 December 2012      60 3.7 Discriminants 
A composite type (other than an array or interface type) can have discriminants, which parameterize the 
type. A known_discriminant_part  specifies the discriminants of a co mposite type. A discriminant of an 
object is a component of the object, and is either of a discrete type or an access type. An 
unknown_discriminant_part  in the declaration of a view of a type specifies that the discriminants of the 
type are unknown for the given view; all subtypes of such a view are indefinite subtypes.  
Syntax 
discriminant_part ::= unknown_discriminant_part  | known_discriminant_part  
unknown_discriminant_part ::= (<>) 
known_discriminant_part ::=  
   (discriminant_specification  {; discriminant_specification }) 
discriminant_specification ::=  
   defining_identifier_list  : [null_exclusion ] subtype_mark  [:= default_expression ] 
 | defining_identifier_list  : access_definition  [:= default_expression ] 
default_expression ::= expression  
Name Resolution Rules 
The expected type for the default_expression  of a discriminant_specification  is that of the corresponding 
discriminant.  
Legality Rules 
A discriminant_part  is only permitted in a declaration for a compos ite type that is not an array or interface 
type (this includes generic formal types). A type declared with a known_discriminant_part  is called a 
discriminated  type, as is a type that inherits (known) discriminants.  
The subtype of a discriminant may be defined by an optional null_exclusion  and a subtype_mark , in 
which case the subtype_mark  shall denote a discrete or access subtype, or it may be defined by an 
access_definition . A discriminant that is defined by an access_definition  is called an access discriminant  
and is of an anonymous access type.  
Default_expression s shall be provided either for all or  for none of the discriminants of a known_-
discriminant_part . No default_expression s are permitted in a known_discriminant_part  in a declaration 
of a nonlimited tagged type or a generic formal type. 
A discriminant_specification  for an access discriminant may have a default_expression  only in the 
declaration for an immutably limited type (see 7.5) . In addition to the places where Legality Rules 
normally apply (see 12.3), this rule applies also in th e private part of an instance of a generic unit.  
This paragraph was deleted.  
For a type defined by a derived_type_definition , if a known_discriminant_part  is provided in its 
declaration, then:  
• The parent subtype shall be constrained; 
• If the parent type is not a tagged type, then each discriminant of the derived type shall be used in 
the constraint defining the parent subtype; 1/2 
2/2 
3 4 
5/2 
6 
7 
8/2 
9/2 
9.1/3 
10/3 
11/2 
12 
13 
14 
Ada Reference Manual — 2012 Edition 
61      13 December 2012 Discriminants   3.7 • If a discriminant is used in the constraint defining the parent subtype, the subtype of the 
discriminant shall be statically compatible (see 4.9.1) with the subtype of the corresponding 
parent discriminant.  
This paragraph was deleted.  
Static Semantics 
A discriminant_specification  declares a discriminant; the subtype_mark  denotes its subtype unless it is an 
access discriminant, in which case the discriminant's subtype is the anonymous access-to-variable subtype 
defined by the access_definition . 
For a type defined by a derived_type_definition , each discriminant of the parent type is either inherited, 
constrained to equal some new disc riminant of the derived type, or constrained to the value of an 
expression. When inherited or constr ained to equal some new discriminant, the parent  discriminant and the 
discriminant of the derived type are said to correspond . Two discriminants also correspond if there is some 
common discriminant to which they  both correspond. A discriminant co rresponds to itself as well. If a 
discriminant of a parent type is constrained to a specific value by a derived_type_definition , then that 
discriminant is said to be specified  by that derived_type_definition .  
A constraint  that appears within the definition of a discriminated type depends on a discriminant  of the 
type if it names the discriminant as a bound or discriminant value. A component_definition  depends on a 
discriminant if its constraint  depends on the discriminant, or on a di scriminant that corresponds to it.  
A component depends on a discriminant  if:  
• Its component_definition  depends on the discriminant; or  
• It is declared in a variant_part  that is governed by the discriminant; or 
• It is a component inherited as part of a derived_type_definition , and the constraint  of the 
parent_ subtype_indication  depends on the discriminant; or  
• It is a subcomponent of a component  that depends on the discriminant.  
Each value of a discriminated type includes a value for each component of the type that does not depend 
on a discriminant; this includes the discriminants themselves. The values  of discriminants determine which 
other component values are present in the value of the discriminated type.  
A type declared with a known_discriminant_part  is said to have known discriminants ; its first subtype is 
unconstrained. A type declared with an unknown_discriminant_part  is said to have unknown 
discriminants . A type declared without a discriminant_part  has no discriminants, unless it is a derived 
type; if derived, such a type has the same sort of discriminants (known, unknown, or none) as its parent (or 
ancestor) type. A tagged class-wide type also has unknown discriminants. Any subtype of a type with 
unknown discriminants is an unconstrained and indefinite subtype (see 3.2 and 3.3).  
Dynamic Semantics 
For an access discriminant, its access_definition  is elaborated when the value of the access discriminant is 
defined: by evaluation of its default_expression , by elaboration of a discriminant_constraint , or by an 
assignment that initializes the enclosing object.  
NOTES 
55  If a discriminated type has default_expression s for its discriminants, then unconstrained variables of the type are 
permitted, and the values of the discriminants can be changed by an assignment to such a variable. If defaults are not provided for the discriminants, then all variables of the type are constrained, either by explicit constraint or by their initi al 
value; the values of the discriminants of such a variable cannot be changed after initialization.  15 
16/3 
17 
18 
19 
20 
21 
22 23 
24 
25 
26 
27/2 
28 
Ada Reference Manual — 2012 Edition 
3.7   Discriminants 13 December 2012      62 56  The default_expression  for a discriminant of a type is evaluated when an object of an unconstrained subtype of the 
type is created. 
57  Assignment to a discriminant of an object (after its initialization) is not allowed, since the name of a discriminant is a 
constant; neither assignment_statement s nor assignments inherent in passing as an in out  or out parameter are allowed. 
Note however that the value of a discriminant can be changed by assigning to the enclosing object, presuming it is an unconstrained variable.  
58  A discriminant that is of a named access type is not called an access discriminant; that term is used only for 
discriminants defined by an 
access_definition .  
Examples 
Examples of discriminated types:   
type Buffer(Size : Buffer_Size := 100)  is        --  see 3.5.4 
   record 
      Pos   : Buffer_Size := 0;       Value : String(1 .. Size);    end record; 
type Matrix_Rec(Rows, Columns : Integer) is 
   record 
      Mat : Matrix(1 .. Rows, 1 .. Columns);       --  see 3.6 
   end record; 
type Square(Side : Integer) is new 
   Matrix_Rec(Rows => Side, Columns => Side); 
type Double_Square(Number : Integer) is 
   record 
      Left  : Square(Number);       Right : Square(Number);    end record; 
task type  Worker(Prio : System.Priority; Buf : access Buffer) 
   with Priority => Prio is -- see D.1 
   --  discriminants used to parameterize the task type (see 9.1)  
   entry Fill; 
   entry Drain; 
end Worker; 
3.7.1 Discriminant Constraints 
A discriminant_constraint  specifies the values of the discrimi nants for a given discriminated type.  
Syntax 
discriminant_constraint ::=  
   (discriminant_association  {, discriminant_association }) 
discriminant_association ::=  
   [discriminant_ selector_name  {| discriminant_ selector_name } =>] expression  
A discriminant_association  is said to be named  if it has one or more discriminant_ selector_name s; 
it is otherwise said to be positional . In a discriminant_constraint , any positional associations shall 
precede any named associations.  
Name Resolution Rules 
Each selector_name  of a named discriminant_association  shall resolve to denote a discriminant of the 
subtype being constrained; the discriminants so named are the associated discriminants  of the named 
association. For a positional association, the associated discriminant  is the one whose discriminant_-
specification  occurred in the corresponding position in the known_discriminant_part  that defined the 
discriminants of the subt ype being constrained. 29 
30 
31 
32 
33 
34 
35 
36 
37/3 
1 
2 
3 4 
5 
Ada Reference Manual — 2012 Edition 
63      13 December 2012 Discriminant Constraints   3.7.1 The expected type for the expression  in a discriminant_association  is that of the associated 
discriminant(s).  
Legality Rules 
A discriminant_constraint  is only allowed in a subtype_indication  whose subtype_mark  denotes either an 
unconstrained discriminated subtype, or an unconstr ained access subtype whose designated subtype is an 
unconstrained discriminated subtype. However, in the case of an access subtype, a discriminant_constraint  
is legal only if any dereference of a value of the access type is known to be constrained (see 3.3). In 
addition to the places where Legality Rules normally appl y (see 12.3), these rules apply also in the private 
part of an instance of a generic unit. 
A named discriminant_association  with more than one selector_name  is allowed only if the named 
discriminants are all of the same type. A discriminant_constraint  shall provide exactly one value for each 
discriminant of the subtype being constrained. 
This paragraph was deleted.  
Dynamic Semantics 
A discriminant_constraint  is compatible  with an unconstrained discriminated subtype if each discriminant 
value belongs to the subtype of the corresponding discriminant.  
A composite value satisfies  a discriminant constraint if and only if each discriminant of the composite 
value has the value imposed by the discriminant constraint. 
For the elaboration of a discriminant_constraint , the expression s in the discriminant_association s are 
evaluated in an arbitrary order and converted to the ty pe of the associated discri minant (which might raise 
Constraint_Error — see 4.6); the expression  of a named association is ev aluated (and converted) once for 
each associated discriminant. The result of each eval uation and conversion is the value imposed by the 
constraint for the associated discriminant.  
NOTES 
59  The rules of the language ensure that a discriminant of an object always has a value, either from explicit or implicit initialization.  
Examples 
Examples (using types declar ed above in subclause 3.7):   
Large   : Buffer(200);  --   constrained, always 200 characters  
                        --    (explicit discriminant value)  
Message : Buffer;       --   unconstrained, initially 100 characters  
                        --    (default discriminant value)  
Basis   : Square(5);    --   constrained, always 5 by 5  
Illegal : Square;       --   illegal, a Square has to be constrained  
3.7.2 Operations of Discriminated Types 
If a discriminated type has default_expression s for its discriminants, then unconstrained variables of the 
type are permitted, and the discriminants of such a va riable can be changed by assignment to the variable. 
For a formal parameter of such a type, an attri bute is provided to determine whether the corresponding 
actual parameter is constrained or unconstrained.  6 
7/3 
8 
9/3 
10 
11 12 
13 
14/3 
15 
1 
Ada Reference Manual — 2012 Edition 
3.7.2    Operations of Discriminated Types 13 December 2012      64 Static Semantics 
For a prefix  A that is of a discriminated type (after an y implicit dereference), the following attribute is 
defined:  
A'Constrained 
 Yields the value True if A denotes a consta nt, a value, a tagged object, or a constrained 
variable, and False otherwise.  
Erroneous Execution 
The execution of a construct is erroneous if  the construct has a constituent that is a name  denoting a 
subcomponent that depends on discriminants, and the value of any of  these discriminants is changed by 
this execution between evaluating the name  and the last use (within this  execution) of the subcomponent 
denoted by the name .  
3.8 Record Types 
A record object is a composite object  consisting of named components. Th e value of a record object is a 
composite value consisting of th e values of the components.  
Syntax 
record_type_definition ::= [[abstract ] tagged ] [limited ] record_definition  
record_definition ::=  
    record  
       component_list  
    end record  
  | null record  
component_list ::=  
      component_item  {component_item } 
   | {component_item } variant_part  
   |  null; 
component_item ::= component_declaration  | aspect_clause  
component_declaration ::=  
   defining_identifier_list  : component_definition  [:= default_expression ] 
        [ aspect_specification ]; 
Name Resolution Rules 
The expected type for the default_expression , if any, in a component_declaration  is the type of the 
component.  
Legality Rules 
This paragraph was deleted.  
Each component_declaration  declares a component of the record type. Besides components declared by 
component_declaration s, the components of a record type include any components declared by 
discriminant_specification s of the record type declaration. The id entifiers of all components of a record 
type shall be distinct.  
Within a type_declaration , a name  that denotes a component, protected  subprogram, or entry of the type 
is allowed only in the following cases: 2 
3/3 
4 
1 
2 
3 
4 
5/1 
6/3 
7 
8/2 
9/2 
10 
Ada Reference Manual — 2012 Edition 
65      13 December 2012 Record Types   3.8 • A name  that denotes any component, protected s ubprogram, or entry is allowed within an 
aspect_specification , an operational item, or a represen tation item that occurs within the 
declaration of the composite type. 
• A name  that denotes a noninherited discriminant is allowed within the declaration of the type, 
but not within the discriminant_part . If the discriminant is used to define the constraint of a 
component, the bounds of an entr y family, or the constraint of the parent subtype in a 
derived_type_definition , then its name shall appear alone as a direct_name  (not as part of a 
larger expression or expanded name).  A discriminant shall not be used  to define the constraint of 
a scalar component.  
If the name of the current instance of a type (see 8.6) is  used to define the constr aint of a component, then 
it shall appear as a direct_name  that is the prefix  of an attribute_reference  whose result is of an access 
type, and the attribute_reference  shall appear alone.  
Static Semantics 
If a record_type_definition  includes the reserved word limited , the type is called an explicitly limited 
record  type. 
The component_definition  of a component_declaration  defines the (nominal) subtype of the component. 
If the reserved word aliased  appears in the component_definition , then the component is aliased (see 
3.10).  
If the component_list  of a record type is defined by the reserved word null and there are no discriminants, 
then the record type has no components and all records of the type are null records . A record_definition  of 
null record  is equivalent to record null; end record .  
Dynamic Semantics 
The elaboration of a record_type_definition  creates the record type and its first subtype, and consists of 
the elaboration of the record_definition . The elaboration of a record_definition  consists of the elaboration 
of its component_list , if any. 
The elaboration of a component_list  consists of the elaboration of the component_item s and variant_part , 
if any, in the order in which they appear. The elaboration of a component_declaration  consists of the 
elaboration of the component_definition .  
Within the definition of a composite type, if a component_definition  or discrete_subtype_definition  (see 
9.5.2) includes a name  that denotes a discriminant of the type, or that is an attribute_reference  whose 
prefix  denotes the current instance of the type, the expression containing the name  is called a per-object 
expression , and the constraint  or range  being defined is called a per-object constraint . For the elaboration 
of a component_definition  of a component_declaration  or the discrete_subtype_definition  of an entry_-
declaration  for an entry family (see 9.5.2), if th e component subtype is defined by an access_definition  or 
if the constraint  or range  of the subtype_indication  or discrete_subtype_definition  is not a per-object 
constraint, then the access_definition , subtype_indication , or discrete_subtype_definition  is elaborated. 
On the other hand, if the constraint  or range  is a per-object constraint, then the elaboration consists of the 
evaluation of any included expression that is not part of a per-object expression. Each such expression is 
evaluated once unless it is part of a named associati on in a discriminant constraint, in which case it is 
evaluated once for each associated discriminant. 
When a per-object constraint is elaborated (as part of creating an object), each per-object expression of the 
constraint is evaluated. For othe r expressions, the values determin ed during the elaboration of the 
component_definition  or entry_declaration  are used. Any checks associated with the enclosing 11/3 
12/3 
13 
13.1/3 
14 
15 
16 
17 
18/2 
18.1/1 
Ada Reference Manual — 2012 Edition 
3.8   Record Types 13 December 2012      66 subtype_indication  or discrete_subtype_definition  are performed, including the subtype compatibility 
check (see 3.2.2), and the associated subtype is created.  
NOTES 
60  A component_declaration  with several identifiers is equivalent to a sequence of single component_declaration s, as 
explained in 3.3.1. 
61  The default_expression  of a record component is only evaluated upon the creation of a default-initialized object of the 
record type (presuming the object has the component, if it is in a variant_part  — see 3.3.1). 
62  The subtype defined by a component_definition  (see 3.6) has to be a definite subtype. 
63  If a record type does not have a variant_part , then the same components are present in all values of the type. 
64  A record type is limited if it has the reserved word limited  in its definition, or if any of its components are limited (see 
7.5). 
65  The predefined operations of a record type include membership tests, qualification, and explicit conversion. If the 
record type is nonlimited, they also include assignment and the predefined equality operators. 
66  A component of a record can be named with a selected_component . A value of a record can be specified with a 
record_aggregate . 
Examples 
Examples of record type declarations:  
type Date is 
   record 
      Day   : Integer range 1 .. 31; 
      Month : Month_Name;       Year  : Integer range 0 .. 4000; 
   end record; 
type Complex is 
   record 
      Re : Real := 0.0;       Im : Real := 0.0;    end record; 
Examples of record variables:  
Tomorrow, Yesterday : Date; 
A, B, C : Complex; 
-- both components of A, B, and C are implicitly initialized to zero  
3.8.1 Variant Parts and Discrete Choices 
A record type with a variant_part  specifies alternative lis ts of components. Each variant  defines the 
components for the value or values of  the discriminant covered by its discrete_choice_list .  
Syntax 
variant_part ::=  
   case discriminant_ direct_name  is 
       variant  
      { variant } 
   end case; 
variant ::=  
   when  discrete_choice_list  => 
      component_list  
discrete_choice_list ::= discrete_choice  {| discrete_choice } 19 
20 21 
22 23 
24 
25/2 
26 
27 
28 
29 
30 
31 
1 
2 
3 
4 
Ada Reference Manual — 2012 Edition 
67      13 December 2012 Variant Parts and Discrete Choices   3.8.1 discrete_choice ::= choice_expression  | discrete_ subtype_indication  | range  | others  
Name Resolution Rules 
The discriminant_ direct_name  shall resolve to denote a discriminant (called the discriminant of the 
variant_part ) specified in the known_discriminant_part  of the full_type_declaration  that contains the 
variant_part . The expected type for each discrete_choice  in a variant  is the type of the discriminant of the 
variant_part .  
Legality Rules 
The discriminant of the variant_part  shall be of a discrete type.  
The choice_expression s, subtype_indication s, and range s given as discrete_choice s in a variant_part  
shall be static. The discrete_choice  others  shall appear alone in a discrete_choice_list , and such a 
discrete_choice_list , if it appears, shall be the last  one in the enclosing construct. 
A discrete_choice  is defined to cover a value  in the following cases:  
• A discrete_choice  that is a choice_expression  covers a value if the value equals the value of 
the choice_expression  converted to the expected type. 
• A discrete_choice  that is a subtype_indication  covers all values (possibly none) that belong to 
the subtype and that satisfy the static predicate of the subtype (see 3.2.4). 
• A discrete_choice  that is a range  covers all values (possibly none) that belong to the range. 
• The discrete_choice  others  covers all values of its expected type that are not covered by 
previous discrete_choice_list s of the same construct.  
A discrete_choice_list  covers a value if one of its discrete_choice s covers the value. 
The possible values of the discriminant of a variant_part  shall be covered as follows:  
• If the discriminant is of a static constrained s calar subtype then, except within an instance of a 
generic unit, each non- others  discrete_choice  shall cover only values in that subtype that satisfy 
its predicate, and each value of that subtype that satisfies its predicate shall be covered by some 
discrete_choice  (either explicitly or by others ); 
• If the type of the discriminant is a descenda nt of a generic formal scalar type, then the 
variant_part  shall have an others  discrete_choice ;  
• Otherwise, each value of the base range of the ty pe of the discriminant shall be covered (either 
explicitly or by others ).  
Two distinct discrete_choice s of a variant_part  shall not cover the same value. 
Static Semantics 
If the component_list  of a variant  is specified by null, the variant has no components. 
The discriminant of a variant_part  is said to govern  the variant_part  and its variant s. In addition, the 
discriminant of a derived type governs a variant_part  and its variant s if it corresponds (see 3.7) to the 
discriminant of the variant_part . 
Dynamic Semantics 
A record value contains the values of the components of a particular variant  only if the value of the 
discriminant governing the variant  is covered by the discrete_choice_list  of the variant . This rule applies 
in turn to any further variant  that is, itself, included in the component_list  of the given variant . 5/3 
6 
7 
8/3 
9 
10/3 
10.1/3 
11/3 
12 
13 
14 
15/3 
16/3 
17 18 
19 
20 
21 
Ada Reference Manual — 2012 Edition 
3.8.1    Variant Parts and Discrete Choices 13 December 2012      68 When an object of a discriminated type T is initialized by default, C onstraint_Error is raised if no 
discrete_choice_list  of any variant  of a variant_part  of T covers the value of the discriminant that governs 
the variant_part . When a variant_part  appears in the component_list  of another variant  V, this test is only 
applied if the value of the discriminant governing V is covered by the discrete_choice_list  of V.  
The elaboration of a variant_part  consists of the elaboration of the component_list  of each variant  in the 
order in which they appear.  
Examples 
Example of record type with a variant part:  
type Device is (Printer, Disk, Drum); 
type State  is (Open, Closed); 
type Peripheral(Unit : Device := Disk) is 
   record 
      Status : State;       case Unit is 
         when Printer => 
            Line_Count : Integer range 1 .. Page_Size; 
         when others => 
            Cylinder   : Cylinder_Index;             Track      : Track_Number;          end case; 
      end record; 
Examples of record subtypes:   
subtype Drum_Unit is Peripheral(Drum); 
subtype Disk_Unit is Peripheral(Disk); 
Examples of constrai ned record variables:   
Writer   : Peripheral(Unit  => Printer); 
Archive  : Disk_Unit; 
3.9 Tagged Types and Type Extensions 
Tagged types and type extensions support object-o riented programming, based on inheritance with 
extension and run-time polymorphism via dispatching operations .  
Static Semantics 
A record type or private type that has the reserved word tagged  in its declaration is called a tagged  type. 
In addition, an interface type is a tagged type, as is a task or protected type derived from an interface (see 3.9.4). When deriving from a tagged type, as for an y derived type, additional primitive subprograms may 
be defined, and inherited primitive subprograms ma y be overridden. The derived type is called an 
extension  of its ancestor types, or simply a type extension . 
Every type extension is also a tagged type, and is a record extension  or a private extension  of some other 
tagged type, or a noninterface synchronized tagged type (see 3.9.4). A record extension is defined by a 
derived_type_definition  with a record_extension_part  (see 3.9.1), which may include the definition of 
additional components. A private extension, which is  a partial view of a record extension or of a 
synchronized tagged type, can be declared in the visible part of a package (see 7.3) or in a generic formal 
part (see 12.5.1).  
An object of a tagged type has an associated (run-time) tag that identifies the specific tagged type used to 
create the object originally. The tag of an operand of a class-wide tagged type T'Class controls which 21.1/3 
22 
23 
24 
25 
26 
27 
28 
29 
1 
2/2 
2.1/2 
3 
Ada Reference Manual — 2012 Edition 
69      13 December 2012 Tagged Types and Type Extensions   3.9 subprogram body is to be executed when a primitive subprogram of type T is applied to the operand (see 
3.9.2); using a tag to control which body to execute is called dispatching .  
The tag of a specific tagged type identifies the full_type_declaration  of the type, and for a type extension, 
is sufficient to uniquely identify the type among all des cendants of the same ancestor. If a declaration for a 
tagged type occurs within a generic_package_declaration , then the corresponding type declarations in 
distinct instances of the generic package are associated with distinct tags. For a ta gged type that is local to 
a generic package body and with all of its ancestors (if any) also lo cal to the generic body, the language 
does not specify whether repeated instantiations of the generic body result in distinct tags.  
The following language-defined library package exists:  
package Ada.Tags is 
    pragma Preelaborate(Tags); 
    type Tag is private; 
    pragma Preelaborable_Initialization(Tag); 
    No_Tag : constant  Tag; 
    function  Expanded_Name(T : Tag) return String; 
    function  Wide_Expanded_Name(T : Tag) return Wide_String; 
    function  Wide_Wide_Expanded_Name(T : Tag) return Wide_Wide_String; 
    function  External_Tag(T : Tag) return String; 
    function  Internal_Tag(External : String) return Tag; 
    function  Descendant_Tag(External : String; Ancestor : Tag) return Tag; 
    function  Is_Descendant_At_Same_Level(Descendant, Ancestor : Tag) 
        return Boolean; 
    function  Parent_Tag (T : Tag) return Tag; 
    type Tag_Array is array  (Positive range <>) of Tag; 
    function  Interface_Ancestor_Tags (T : Tag) return Tag_Array; 
    function  Is_Abstract (T : Tag) return Boolean; 
    Tag_Error : exception ; 
private 
   ... -- not specified by the language  
end Ada.Tags; 
No_Tag is the default initial value of type Tag.  
The function Wide_Wide_Expanded_Name returns the fu ll expanded name of the first subtype of the 
specific type identified by the tag, in upper case, starting with a root library unit. The result is 
implementation defined if the type  is declared within an unnamed block_statement .  
The function Expanded_Name (respectively, Wide_E xpanded_Name) returns the same sequence of 
graphic characters as that defined for Wide_Wide_ Expanded_Name, if all the graphic characters are 
defined in Character (respectively, Wide_Charact er); otherwise, the sequence of characters is 
implementation defined, but no shorter than that returned by Wide_Wide_Expanded_Name for the same 
value of the argument.  
The function External_Tag returns a string to be used in an external representation for the given tag. The 
call External_Tag(S'Tag) is equivalent to the attribute_reference  S'External_Tag (see 13.3).  
The string returned by the functions Expande d_Name, Wide_Expanded_Nam e, Wide_Wide_Expanded_-
Name, and External_Tag has lower bound 1. 
The function Internal_Tag returns a tag that corresponds to the given external tag, or raises Tag_Error if 
the given string is not the external tag for any specific type of the partition. Tag_Error is also raised if the 
specific type identified is a library-level type whose tag has not yet been created (see 13.14). 4/2 
5 
6/2 
6.1/2 
7/2 
7.1/2 
7.2/2 
7.3/2 7.4/2 7.5/3 
8 9 
9.1/2 
10/2 
10.1/2 
11 
11.1/2 
12/2 
Ada Reference Manual — 2012 Edition 
3.9   Tagged Types and Type Extensions 13 December 2012      70 The function Descendant_Tag returns the (internal) tag for the type that corresponds to the given external 
tag and is both a descendant of the type identified by the Ancestor tag and has the same accessibility level 
as the identified ancestor. Tag_Error is  raised if External is not the ex ternal tag for such a type. Tag_Error 
is also raised if the specific type identified is a library-level type whose tag has not yet been created, or if 
the given external tag identifies more than one ty pe that has the appropriate Ancestor and accessibility 
level. 
The function Is_Descendant_At_Same_Lev el returns True if the Descendant tag identifies a type that is 
both a descendant of the type identified by Ancestor and at the same accessibility level. If not, it returns 
False. 
For the purposes of the dynamic seman tics of functions Descendant_Tag and 
Is_Descendant_At_Same_Level, a tagged type T2 is a descendant  of a type T1 if it is the same as T1, or if 
its parent type or one of its progenitor types is a descenda nt of type T1 by this rule, even if at the point of 
the declaration of T2, one of the deri vations in the chain is not visible. 
The function Parent_Tag returns the tag of the parent ty pe of the type whose tag is T. If the type does not 
have a parent type (that is, it was not declared by a derived_type_declaration), then No_Tag is returned. 
The function Interface_Ancestor_Tags returns an arra y containing the tag of each interface ancestor type 
of the type whose tag is T, other th an T itself. The lower bound of the returned array is 1, and the order of 
the returned tags is unspecified. Each tag appears in the result exactly once. If the type whose tag is T has 
no interface ancestors, a null array is returned. 
The function Is_Abstract returns True if the type whose tag is T is abstr act, and False otherwise. 
For every subtype S of a tagged type T (specific or class-wide), the following attributes are defined:  
S'Class S'Class denotes a subtype of the class-wide type (called T'Class in this International 
Standard) for the class rooted at T (or if S already denotes a class-wide subtype, then 
S'Class is the same as S). 
 S'Class is unconstrained. Howeve r, if S is constrained, then the values of S'Class are only 
those that when converted to the type T belong to S.  
S'Tag S'Tag denotes the tag of the type T (or if T is class-wide, the tag of the root type of the 
corresponding class). The value of this  attribute is of type Tag.  
Given a prefix  X that is of a class-wide tagged type (after  any implicit dereference), the following attribute 
is defined:  
X'Tag X'Tag denotes the tag of X. The valu e of this attribute is of type Tag.  
The following language-defined generic function exists: 
generic 
    type T (<>) is abstract tagged limited private ; 
    type Parameters (<>) is limited private ; 
    with function  Constructor (Params : not null access  Parameters) 
        return T is abstract ; 
function  Ada.Tags.Generic_Dispatching_Constructor 
   (The_Tag : Tag;     Params  : not null access  Parameters) return T'Class 
   with Convention => Intrinsic; 
pragma Preelaborate(Generic_Dispatching_Constructor); 
Tags.Generic_Dispatching_Constructor provides a mechanism to create an object of an appropriate type 
from just a tag value. The function Constructor is e xpected to create the object given a reference to an 
object of type Parameters. 12.1/3 
12.2/2 
12.3/3 
12.4/3 
12.5/3 
12.6/3 
13 14 
15 
16 17 
18 
18.1/2 
18.2/3 
18.3/2 
Ada Reference Manual — 2012 Edition 
71      13 December 2012 Tagged Types and Type Extensions   3.9 Dynamic Semantics 
The tag associated with an object of a tagged type is determined as follows:  
• The tag of a stand-alone object, a component, or an aggregate  of a specific tagged type T 
identifies T.  
• The tag of an object created by an allocator for an access type with a specific designated tagged 
type T, identifies T.  
• The tag of an object of a class-wide tagged ty pe is that of its initialization expression.  
• The tag of the result returned by a functi on whose result type is a specific tagged type T 
identifies T.  
• The tag of the result returned by a function with a class-wide result type is that of the return 
object.  
The tag is preserved by type conversion and by para meter passing. The tag of a value is the tag of the 
associated object (see 6.2). 
Tag_Error is raised by a call of Descendant_Tag , Expanded_Name, External_Tag, Interface_Ancestor_-
Tags, Is_Abstract, Is _Descendant_At_Same_Level, Pare nt_Tag, Wide_Expanded_Name, or 
Wide_Wide_Expanded_Name if any tag passed is No_Tag. 
An instance of Tags.Generic_Dispa tching_Constructor raises Tag_Error if The_Tag does not represent a 
concrete descendant of T or if the innermost master (see 7.6.1) of this descendant is not also a master of 
the instance. Otherwise, it dispatch es to the primitive function denoted by the formal Constructor for the 
type identified by The_Tag, passing Params, and return s the result. Any exception raised by the function is 
propagated. 
Erroneous Execution 
If an internal tag provided to an instance of Tags .Generic_Dispatching_Construc tor or to any subprogram 
declared in package Tags identifies either a type th at is not library-level and whose tag has not been 
created (see 13.14), or a type that does not exist in th e partition at the time of the call, then execution is 
erroneous. 
Implementation Permissions 
The implementation of Internal_Tag and Descenda nt_Tag may raise Tag_Error if no specific type 
corresponding to the string External passed as a paramete r exists in the partition at the time the function is 
called, or if there is no such type whose innermost master is a master of the point of the function call.  
Implementation Advice 
Internal_Tag should return the tag of a type, if one ex ists, whose innermost master is a master of the point 
of the function call.  
NOTES 
67  A type declared with the reserved word tagged  should normally be declared in a package_specification , so that new 
primitive subprograms can be declared for it. 
68  Once an object has been created, its tag never changes. 69  Class-wide types are defined to have unknown discriminants (see 3.7). This means that objects of a class-wide type 
have to be explicitly initialized (whether created by an 
object_declaration  or an allocator ), and that aggregate s have to be 
explicitly qualified with a specific type when their expected type is class-wide. 
70  The capability provided by Tags.Generic_Dispatching_Constructor is sometimes known as a factory .  19 
20 
21 22 
23 
24/2 
25 
25.1/3 
25.2/2 
25.3/2 
26/2 
26.1/3 
27 
28 
29 
30/2 
Ada Reference Manual — 2012 Edition 
3.9   Tagged Types and Type Extensions 13 December 2012      72 Examples 
Examples of tagged record types:   
type Point is tagged  
  record 
    X, Y : Real := 0.0;   end record ; 
type Expression is tagged null record ; 
  --  Components will be added by each extension  
3.9.1 Type Extensions 
Every type extension is a tagged type, and is a record extension  or a private extension  of some other 
tagged type, or a noninterface synchronized tagged type.  
Syntax 
record_extension_part ::= with  record_definition  
Legality Rules 
The parent type of a record extension shall not be a class-wide type nor shall it be a synchronized tagged 
type (see 3.9.4). If the parent type or any progenito r is nonlimited, then each of the components of the 
record_extension_part  shall be nonlimited. In addition to the places where Legality Rules normally apply 
(see 12.3), these rules apply also in the privat e part of an instance of a generic unit.  
Within the body of a generic unit, or the body of any of  its descendant library units, a tagged type shall not 
be declared as a descendant of a formal type decl ared within the formal part of the generic unit. 
Static Semantics 
A record extension is a null extension  if its declaration has no known_discriminant_part  and its 
record_extension_part  includes no component_declaration s.  
Dynamic Semantics 
The elaboration of a record_extension_part  consists of the elaboration of the record_definition .  
NOTES 
71  The term “type extension” refers to a type as a whole. The term “extension part” refers to the piece of text that defines the additional components (if any) the type extension has relative to its specified ancestor type.  
72  When an extension is declared immediately within a body, primitive subprograms are inherited and are overridable, 
but new primitive subprograms cannot be added. 
73  A 
name  that denotes a component (including a discriminant) of the parent type is not allowed within the 
record_extension_part . Similarly, a name  that denotes a component defined within the record_extension_part  is not 
allowed within the record_extension_part . It is permissible to use a name  that denotes a discriminant of the record 
extension, providing there is a new known_discriminant_part  in the enclosing type declaration. (The full rule is given in 
3.8.)  
74  Each visible component of a record extension has to have a unique name, whether the component is (visibly) inherited 
from the parent type or declared in the record_extension_part  (see 8.3).  
Examples 
Examples of record extensions (of types defined above in 3.9):   
type Painted_Point is new Point with 
  record 
    Paint : Color := White;   end record ; 
    --  Components X and Y are inherited  31 
32 
33 
1/2 
2 
3/2 
4/2 
4.1/2 
5 
6 
7/2 
8 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
73      13 December 2012 Type Extensions   3.9.1 Origin : constant  Painted_Point := (X | Y => 0.0, Paint => Black); 
type Literal is new Expression with 
  record                 --  a leaf in an Expression tree  
    Value : Real;   end record ; 
type Expr_Ptr is access all  Expression'Class; 
                               --  see 3.10 
type Binary_Operation is new Expression with 
  record                 --  an internal node in an Expression tree  
    Left, Right : Expr_Ptr;   end record ; 
type Addition is new Binary_Operation with null record ; 
type Subtraction is new Binary_Operation with null record ; 
  --  No additional components needed for these extensions  
Tree : Expr_Ptr :=         --  A tree representation of “5.0 + (13.0–7.0)”  
   new Addition'( 
      Left  => new Literal'(Value => 5.0), 
      Right => new Subtraction'( 
         Left  => new Literal'(Value => 13.0), 
         Right => new Literal'(Value => 7.0))); 
3.9.2 Dispatching Operations of Tagged Types 
The primitive subprograms of a tagged type, the subprograms declared by formal_abstract_subprogram_-
declaration s, and the stream attributes of a specific tagged type that are available (see 13.13.2) at the end 
of the declaration list where the type is declared are called dispatching operations . A dispatching operation 
can be called using a statically determined controlling  tag, in which case the body to be executed is 
determined at compile time. Alternatively, the cont rolling tag can be dynamically determined, in which 
case the call dispatches  to a body that is determined at run time; such a call is termed a dispatching call . 
As explained below, the properties of the operands a nd the context of a particular call on a dispatching 
operation determine how the controlling tag is dete rmined, and hence whether or not the call is a 
dispatching call. Run-time polymorphism is achieve d when a dispatching operation is called by a 
dispatching call.  
Static Semantics 
A call on a dispatching operation  is a call whose name  or prefix  denotes the declaration of a dispatching 
operation. A controlling operand  in a call on a dispatching operation of a tagged type T is one whose 
corresponding formal parameter is of type T or is of an anonymous access type with designated type T; the 
corresponding formal parameter is called a controlling formal parameter . If the controlling formal 
parameter is an access parameter, the controlling opera nd is the object designated by the actual parameter, 
rather than the actual parameter itself. If the ca ll is to a (primitive) function with result type T (a function 
with a controlling result ), then the call has a controlling result  — the context of the call can control the 
dispatching. Similarly, if the call is to a function with an access result type designating T (a function with a 
controlling access result ), then the call has a controlling access result , and the context can similarly 
control dispatching.  
A name  or expression of a tagged type is either statically  tagged, dynamically  tagged, or tag 
indeterminate , according to whether, when used as a contro lling operand, the tag that controls dispatching 
is determined statically by the operand's (specific)  type, dynamically by its tag at run time, or from 
context. A qualified_expression  or parenthesized expression is stati cally, dynamically, or indeterminately 
tagged according to its operand. For other kinds of name s and expressions, this is determined as follows:  12 
13 
14 
15 
16 
17 
1/2 
2/3 
3 
Ada Reference Manual — 2012 Edition 
3.9.2    Dispatching Operations of Ta gged Types 13 December 2012      74 • The name  or expression is statically tagged  if it is of a specific tagged type and, if it is a call 
with a controlling result or controlling access result, it has at least one statically tagged controlling operand;  
• The 
name  or expression is dynamically tagged  if it is of a class-wide type, or it is a call with a 
controlling result or controlling access result and at least one dynamically tagged controlling 
operand; 
• The name  or expression is tag indeterminate  if it is a call with a controlling result or controlling 
access result, all of whose controlling opera nds (if any) are tag indeterminate.  
A type_conversion  is statically or dynamically tagged according to whether the type determined by the 
subtype_mark  is specific or class-wide, respectively. For an object that is designated by an expression 
whose expected type is an anonym ous access-to-specific tagged type, the object is dynamically tagged if 
the expression, ignoring enclosing pare ntheses, is of the form X'Access, where X is of a class-wide type, 
or is of the form new T'(...), where T denotes a class-wide subtype. Otherwise, the object is statically or 
dynamically tagged according to whether the designated ty pe of the type of the expression is specific or 
class-wide, respectively.  
Legality Rules 
A call on a dispatching operation shall not have both dynamically tagged and sta tically tagged controlling 
operands.  
If the expected type for an expression or name  is some specific tagged type, then the expression or name  
shall not be dynamically tagged unless it is a cont rolling operand in a call on a dispatching operation. 
Similarly, if the expected type for an expression is  an anonymous access-to-specific tagged type, then the 
object designated by the expression shall not be dyna mically tagged unless it is a controlling operand in a 
call on a dispatching operation.  
In the declaration of a dispatching operation of a ta gged type, everywhere a subtype of the tagged type 
appears as a subtype of the profile (see 6.1), it shall st atically match the first subtype of the tagged type. If 
the dispatching operation overrides an  inherited subprogram, it shall be  subtype conformant with the 
inherited subprogram. The convention of an inherite d dispatching operation is the convention of the 
corresponding primitive operation of the parent or progen itor type. The default convention of a dispatching 
operation that overrides an inherited primitive operation is  the convention of the inherited operation; if the 
operation overrides multiple inherited operations, then they shall all have the same convention. An 
explicitly declared dispatching operation sh all not be of convention Intrinsic.  
The default_expression  for a controlling formal parameter of a dispatching operation shall be tag indeter-
minate.  
If a dispatching operation is defined by a subprogram_renaming_declaration  or the instantiation of a 
generic subprogram, any access parameter of the rena med subprogram or the generic subprogram that 
corresponds to a controlling access parameter of the di spatching operation, shall have a subtype that 
excludes null. 
A given subprogram shall not be a dispatching opera tion of two or more distinct tagged types.  
The explicit declaration of a primitive subprogram of a tagged type shall occur before the type is frozen 
(see 13.14). For example, new dispatching operations ca nnot be added after objects or values of the type 
exist, nor after deriving a record extension from it, nor after a body. 4/2 
5/2 
6/2 
7/1 
8 
9/1 
10/2 
11/2 
11.1/2 
12 
13 
Ada Reference Manual — 2012 Edition 
75      13 December 2012 Dispatchi ng Operations of Tagged Types   3.9.2 Dynamic Semantics 
For the execution of a call on a dispatching operation of a type T, the controlling tag value  determines 
which subprogram body is executed. The cont rolling tag value is defined as follows:  
• If one or more controlling operands are statica lly tagged, then the controlling tag value is 
statically determined  to be the tag of T. 
• If one or more controlling operands are dynamically  tagged, then the controlling tag value is not 
statically determined, but is rather determined by the tags of the controlling operands. If there is 
more than one dynamically tagged controlling opera nd, a check is made that they all have the 
same tag. If this check fails, Constrai nt_Error is raised unless the call is a function_call  whose 
name  denotes the declaration of an equality operato r (predefined or user defined) that returns 
Boolean, in which case the result of the ca ll is defined to indicate inequality, and no 
subprogram_body  is executed. This check is performed prior to evaluating any tag-
indeterminate controlling operands.  
• If all of the controlling operands (if any) are tag-indeterminate, then:  
• If the call has a controlling result or controlling access result and is itself, or designates, a 
(possibly parenthesized or qualified) c ontrolling operand of an enclosing call on a 
dispatching operation of a descendant of type T, then its controlling tag value is determined 
by the controlling tag value of this enclosing call; 
• If the call has a controlling result or contro lling access result and (possibly parenthesized, 
qualified, or dereferenced) is the expression of an assignment_statement  whose target is 
of a class-wide type, then its controlling tag value is determined by the target; 
• Otherwise, the controlling tag value is sta tically determined to be the tag of type T.  
For the execution of a call on a dispatching operation, th e action performed is dete rmined by the properties 
of the corresponding dispatching operation of the speci fic type identified by the controlling tag value: 
• if the corresponding operation is explicitly declared for this type, even if the declaration occurs 
in a private part, then the action comprises an invocation of the explicit body for the operation; 
• if the corresponding operation is implicitly declared for this type and is implemented by an entry 
or protected subprogram (see 9.1 and 9.4), then  the action comprises a call on this entry or 
protected subprogram, with the target object being given by the first actual parameter of the call, 
and the actual parameters of the entry or prot ected subprogram being given by the remaining 
actual parameters of the call, if any; 
• if the corresponding operation is a predefined ope rator then the action comprises an invocation 
of that operator; 
• otherwise, the action is the same as the acti on for the corresponding operation of the parent type 
or progenitor type from which the operation was i nherited except that additional invariant checks 
(see 7.3.2) and class-wide postcondition checks (see 6.1.1) may apply. If there is more than one 
such corresponding operation, the action is that for the operation that is not a null procedure, if 
any; otherwise, the action is that of  an arbitrary one of the operations.  
NOTES 
75  The body to be executed for a call on a dispatching operation is determined by the tag; it does not matter whether that tag is determined statically or dynamically, and it does not matter whether the subprogram's declaration is visible at the place of the call. 
76  This subclause covers calls on dispatching subprograms of a tagged type. Rules for tagged type membership tests are 
described in 4.5.2. Controlling tag determination for an 
assignment_statement  is described in 5.2. 
77  A dispatching call can di spatch to a body whose d eclaration is not visible at the place of the call. 14 
15 
16 
17/2 
18/2 
18.1/2 
19 
20/3 
20.1/3 
20.2/3 
20.3/3 
20.4/3 
21 
22/2 
23 
Ada Reference Manual — 2012 Edition 
3.9.2    Dispatching Operations of Ta gged Types 13 December 2012      76 78  A call through an access-to-subprogram value is never a dispat ching call, even if th e access value designates a 
dispatching operation. Similarly a call whose prefix  denotes a subprogram_renaming_declaration  cannot be a dispatching 
call unless the renaming itself is the declaration of a primitive subprogram.  
3.9.3 Abstract Types and Subprograms 
An abstract type  is a tagged type intended for us e as an ancestor of other types, but which is not allowed to 
have objects of its own. An abstract subprogram  is a subprogram that has no body, but is intended to be 
overridden at some point when inherited. Because objects of an abstract type cannot be created, a 
dispatching call to an abstract subprogram always dispatches to some overriding body.  
Syntax 
abstract_subprogram_declaration ::=  
    [overriding_indicator ] 
    subprogram_specification  is abstract  
        [ aspect_specification ]; 
Static Semantics 
Interface types (see 3.9.4) are abstract types. In a ddition, a tagged type that has the reserved word abstract  
in its declaration is an abstract type. The class-wide ty pe (see 3.4.1) rooted at an abstract type is not itself 
an abstract type.  
Legality Rules 
Only a tagged type shall have the reserved word abstract  in its declaration.  
A subprogram declared by an abstract_subprogram_declaration  or a formal_abstract_subprogram_-
declaration  (see 12.6) is an abstract subprogram . If it is a primitive subprogram of a tagged type, then the 
tagged type shall be abstract.  
If a type has an implicitly declared primitive subprogram that is inherited or is a predefined operator, and 
the corresponding primitive subprogram of the parent or an cestor type is abstract or is a function with a 
controlling access result, or if a type other than a nonabstract null extension inherits a function with a 
controlling result, then:  
• If the type is abstract or untagged,  the implicitly declared subprogram is abstract .  
• Otherwise, the subprogram shall be overridden w ith a nonabstract subprogram  or, in the case of 
a private extension inheriting a function with a c ontrolling result, have a full type that is a null 
extension; for a type declared in the visible part  of a package, the overriding may be either in the 
visible or the private part. Such a subprogram is said to require overriding . However, if the type 
is a generic formal type, the subprogram need not be overridden for the formal type itself; a 
nonabstract version will necessarily be provided by the actual type.  
A call on an abstract subprogram shall be a disp atching call; nondispatching calls to an abstract 
subprogram are not allowed.  
The type of an aggregate , or of an object created by an object_declaration  or an allocator , or a generic 
formal object of mode in, shall not be abstract. The type of the target of an assignment operation (see 5.2) 
shall not be abstract. The type of a component shall not be abstract. If the result type of a function is 
abstract, then the function shall be abstract. If a function has an access result type designating an abstract type, then the function shall be abstract. The type denoted by a 
return_subtype_indication  (see 6.5) shall 
not be abstract. A generic function shall not have an abstract result type or an access result type designating an abstract type.  24 
1/2 
1.1/3 
1.2/2 
2/2 
3/2 
4/3 
5/2 
6/2 
7 
8/3 
Ada Reference Manual — 2012 Edition 
77      13 December 2012 Abstract Types and Subprograms   3.9.3 If a partial view is not abstract, the corresponding full view  shall not be abstract. If a generic formal type is 
abstract, then for each primitive subprogram of the fo rmal that is not abstract, the corresponding primitive 
subprogram of the actual shall not be abstract.  
For an abstract type declared in a visible part, an ab stract primitive subprogram shall not be declared in the 
private part, unless it is overriding an abstract subprogr am implicitly declared in the visible part. For a 
tagged type declared in a visible part, a primitive function with a controlling result or a controlling access 
result shall not be declared in the private part, unle ss it is overriding a function implicitly declared in the 
visible part.  
A generic actual subprogram shall not be an abstract  subprogram unless the gene ric formal subprogram is 
declared by a formal_abstract_subprogram_declaration . The prefix  of an attribute_reference  for the 
Access, Unchecked_Access, or Address attributes  shall not denote an abstract subprogram.  
Dynamic Semantics 
The elaboration of an abstract_subprogram_declaration  has no effect.  
NOTES 
79  Abstractness is not inherited; to declare an abstract type, the reserved word abstract  has to be used in the declaration 
of the type extension.  
80  A class-wide type is never abstract. Even if a class is rooted at an abstract type, the class-wide type for the class is no t 
abstract, and an object of the class-wide type can be created; the tag of such an object will identify some nonabstract type in the class.  
Examples 
Example of an abstract type repr esenting a set of natural numbers:   
package Sets is 
    subtype Element_Type is Natural; 
    type Set is abstract tagged null record ; 
    function  Empty return Set is abstract ; 
    function  Union(Left, Right : Set) return Set is abstract ; 
    function  Intersection(Left, Right : Set) return Set is abstract ; 
    function  Unit_Set(Element : Element_Type) return Set is abstract ; 
    procedure  Take(Element : out Element_Type; 
                   From : in out Set) is abstract ; 
end Sets; 
NOTES 
81  Notes on the example:  Given the above abstract type, one could then derive various (nonabstract) extensions of the 
type, representing alternative implementations of a set. One might use a bit vector, but impose an upper bound on the largest element representa ble, while another might use a hash table, tradi ng off sp ace for flexibility.  
3.9.4 Interface Types 
An interface type is an abstract tagged type that pr ovides a restricted form of multiple inheritance. A 
tagged type, task type, or protected type may have one or more interface types as ancestors.  
Syntax 
interface_type_definition ::=  
    [limited  | task | protected  | synchronized ] interface  [and interface_list ] 
interface_list ::= interface_ subtype_mark  {and interface_ subtype_mark } 
Static Semantics 
An interface type (also called an interface ) is a specific abstract tagged type that is defined by an 
interface_type_definition . 9 
10/3 
11/2 
11.1/2 
12 
13 
14 
15 
16 
1/2 
2/2 
3/2 
4/2 
Ada Reference Manual — 2012 Edition 
3.9.4    Interface Types 13 December 2012      78 An interface with the reserved word limited , task, protected , or synchronized  in its definition is termed, 
respectively, a limited interface , a task interface , a protected interface , or a synchronized interface . In 
addition, all task and protected interfaces are sync hronized interfaces, and all synchronized interfaces are 
limited interfaces.  
A task or protected type derived from an interface is a tagged type. Such a tagged type is called a 
synchronized  tagged type, as are synchronized interfaces and private extensions whose declaration 
includes the reserved word synchronized . 
A task interface is an abstract task type. A prot ected interface is an abstract protected type.  
An interface type has no components.  An interface_
subtype_mark  in an interface_list  names a progenitor subtype ; its type is the progenitor 
type. An interface type inherits user-defined primitiv e subprograms from each progenitor type in the same 
way that a derived type inherits user-defined pr imitive subprograms from its progenitor types (see 3.4).  
Legality Rules 
All user-defined primitive subprograms of an inte rface type shall be abstract subprograms or null 
procedures. 
The type of a subtype named in an interface_list  shall be an interface type. 
A type derived from a nonlimited interface shall be nonlimited. An interface derived from a task interface shall include the reserved word task in its definition; any other 
type derived from a task interface shall be a private extension or a task type declared by a task declaration (see 9.1). 
An interface derived from a protected interface shall include the reserved word protected  in its definition; 
any other type derived from a protected interface shall be  a private extension or a protected type declared 
by a protected declaration (see 9.4). 
An interface derived from a synchronized interface shall include one of the reserved words task, 
protected , or synchronized  in its definition; any other type derived from a synchronized interface shall be 
a private extension, a task type declared by a task d eclaration, or a protected type declared by a protected 
declaration. 
No type shall be derived from both a task interface and a protected interface. In addition to the places where Legality Rules normally  apply (see 12.3), these rules apply also in the 
private part of an instance of a generic unit.  
Dynamic Semantics 
The elaboration of an interface_type_definition  creates the interface type and its first subtype.  
NOTES 
82  Nonlimited interface ty pes have predefined nonabstract equality opera tors. These may be overri dden with user-defined 
abstract equality operators. Such operators will then require an explicit overriding for any nonabstract descendant of the interface.  
Examples 
Example of a limited interface and a synchronized interface extending it:  5/2 
6/2 
7/2 
8/2 9/2 
10/2 
11/2 
12/2 13/2 
14/2 
15/2 
16/2 
17/2 
18/3 
19/2 
20/2 
Ada Reference Manual — 2012 Edition 
79      13 December 2012 Interface Types   3.9.4 type Queue is limited interface ; 
procedure  Append(Q : in out Queue; Person : in Person_Name) is abstract ; 
procedure  Remove_First(Q      : in out Queue; 
                       Person : out Person_Name) is abstract ; 
function  Cur_Count(Q : in Queue) return Natural is abstract ; 
function  Max_Count(Q : in Queue) return Natural is abstract ; 
-- See 3.10.1 for Person_Name.  
Queue_Error : exception ; 
-- Append raises Queue_Error if Cur_Count(Q) = Max_Count(Q)  
-- Remove_First raises Queue_Error if Cur_Count(Q) = 0  
type Synchronized_Queue is synchronized interface and  Queue; --  see 9.11 
procedure  Append_Wait(Q      : in out Synchronized_Queue; 
                      Person : in Person_Name) is abstract ; 
procedure  Remove_First_Wait(Q      : in out Synchronized_Queue; 
                            Person : out Person_Name) is abstract ; 
... procedure  Transfer(From   : in out Queue'Class; 
                   To     : in out Queue'Class; 
                   Number : in     Natural := 1) is 
   Person : Person_Name; begin 
   for I in 1..Number loop 
      Remove_First(From, Person);       Append(To, Person);    end loop ; 
end Transfer; 
This defines a Queue interface defining a queue of peopl e. (A similar design could be created to define 
any kind of queue simply by replacing Person_Name by  an appropriate type.) The Queue interface has 
four dispatching operations, Append, Remove_Fir st, Cur_Count, and Max_Count. The body of a class-
wide operation, Transfer is also shown. Ever y nonabstract extension of Queue must provide 
implementations for at least its four dispatching operations, as they are abstract. Any object of a type derived from Queue may be passed to Transfer as e ither the From or the To operand. The two operands 
need not be of the same type in any given call. 
The Synchronized_Queue interface inherits the four  dispatching operations from Queue and adds two 
additional dispatching operations, which wait if necessa ry rather than raising the Queue_Error exception. 
This synchronized interface may only be implemented by a task or protected type, and as such ensures safe concurrent access. 
Example use of the interface:  
type Fast_Food_Queue is new Queue with record  ...; 
procedure  Append(Q : in out Fast_Food_Queue; Person : in Person_Name); 
procedure  Remove_First(Q : in out Fast_Food_Queue; Person : out 
Person_Name); function  Cur_Count(Q : in Fast_Food_Queue) return Natural; 
function  Max_Count(Q : in Fast_Food_Queue) return Natural; 
... Cashier, Counter : Fast_Food_Queue; ... 
-- Add George (see 3.10.1) to the cashier's queue:  
Append (Cashier, George); -- After payment, move George to the sandwich counter queue:  
Transfer (Cashier, Counter); ... 
An interface such as Queue can be used directly as th e parent of a new type (as shown here), or can be 
used as a progenitor when a type is derived. In e ither case, the primitive opera tions of the interface are 
inherited. For Queue, the implementation of the four i nherited routines must be provided. Inside the call of 21/2 
22/3 
23/2 
24/2 
25/2 
26/2 
27/2 
28/2 
29/3 
30/2 
31/2 32/2 
33/2 
Ada Reference Manual — 2012 Edition 
3.9.4    Interface Types 13 December 2012      80 Transfer, calls will dispatch to the implemen tations of Append and Remove_First for type 
Fast_Food_Queue. 
Example of a task interface:  
type Serial_Device is task interface ;  --  see 9.1 
procedure  Read (Dev : in Serial_Device; C : out Character) is abstract ; 
procedure  Write(Dev : in Serial_Device; C : in  Character) is abstract ; 
The Serial_Device interface has two dispatching operati ons which are intended to be implemented by task 
entries (see 9.1). 
3.10 Access Types 
A value of an access type (an access value ) provides indirect access to the object or subprogram it 
designates . Depending on its type, an access value can desi gnate either subprograms, objects created by 
allocators (see 4.8), or more generally aliased  objects of an appropriate type.  
Syntax 
access_type_definition ::=  
    [null_exclusion ] access_to_object_definition  
  | [null_exclusion ] access_to_subprogram_definition  
access_to_object_definition ::=  
    access  [general_access_modifier ] subtype_indication  
general_access_modifier ::= all | constant  
access_to_subprogram_definition ::=  
    access  [protected ] procedure  parameter_profile  
  | access  [protected ] function   parameter_and_result_profile  
null_exclusion ::= not null 
access_definition ::=  
    [null_exclusion ] access  [constant ] subtype_mark  
  | [null_exclusion ] access  [protected ] procedure  parameter_profile  
  | [null_exclusion ] access  [protected ] function  parameter_and_result_profile  
Static Semantics 
There are two kinds of access types, access-to-object  types, whose values designate objects, and access-to-
subprogram  types, whose values designate subprograms. A ssociated with an access-to-object type is a 
storage pool ; several access types may share the same stor age pool. All descendants of an access type 
share the same storage pool. A storage pool is an ar ea of storage used to hold dynamically allocated 
objects (called pool elements ) created by allocators; storage pools ar e described further in 13.11, “Storage 
Management”. 
Access-to-object types are further subdivided into pool-specific  access types, whose values can designate 
only the elements of their associated storage pool, and general  access types, whose values can designate 
the elements of any storage pool, as well as aliased objects created by declarations rather than allocators, 
and aliased subcomponent s of other objects.  
A view of an object is defined to be aliased  if it is defined by an object_declaration , component_-
definition , parameter_specification , or extended_return_object_declaration  with the reserved word 
aliased , or by a renaming of an aliased view. In add ition, the dereference of an access-to-object value 
denotes an aliased view, as does a vi ew conversion (see 4.6) of an aliase d view. The current instance of an 34/2 
35/2 
36/2 
1 
2/2 
3 
4 
5 
5.1/2 
6/2 
7/1 
8 
9/3 
Ada Reference Manual — 2012 Edition 
81      13 December 2012 Access Types   3.10 immutably limited type (see 7.5) is defined to be alia sed. Finally, a formal para meter or generic formal 
object of a tagged type is defined to be aliased. A liased views are the ones that can be designated by an 
access value.  
An access_to_object_definition  defines an access-to-object type and its first subtype; the subtype_-
indication  defines the designated subtype  of the access type. If a general_access_modifier  appears, then 
the access type is a general access type. If the modifier is the reserved word constant , then the type is an 
access-to-constant type ; a designated object cannot be updated through a value of such a type. If the 
modifier is the reserved word all, then the type is an access-to-variable type ; a designated object can be 
both read and updated through a value of such a type. If no general_access_modifier  appears in the 
access_to_object_definition , the access type is a pool-specific access-to-variable type.  
An access_to_subprogram_definition  defines an access-to-subprogram type and its first subtype; the 
parameter_profile  or parameter_and_result_profile  defines the designated profile  of the access type. 
There is a calling convention  associated with the designated prof ile; only subprograms with this calling 
convention can be designated by values of the access type. By default, the calling convention is 
“protected ” if the reserved word protected  appears, and “Ada” otherwis e. See Annex B for how to 
override this default.  
An access_definition  defines an anonymous general access ty pe or an anonymous access-to-subprogram 
type. For a general access type, the subtype_mark  denotes its designated subtype ; if the general_-
access_modifier  constant  appears, the type is an access-to-constant type; otherwise, it is an access-to-
variable type. For an access-to-subprogram type, the parameter_profile  or parameter_and_result_profile  
denotes its designated profile . 
For each access type, there is a null access value designa ting no entity at all, which can be obtained by 
(implicitly) converting the literal null to the access type. The null value of an access type is the default 
initial value of the type. Nonnull values of an acce ss-to-object type are obtained by evaluating an 
allocator , which returns an access value designating a newly created object (see 3.10.2), or in the case of a 
general access-to-object type, evaluating an attribute_reference  for the Access or Unchecked_Access 
attribute of an aliased view of an object. Nonnull va lues of an access-to-subprogram type are obtained by 
evaluating an attribute_reference  for the Access attribute of a nonintrinsic subprogram. 
A null_exclusion  in a construct specifies that the null valu e does not belong to the access subtype defined 
by the construct, that is, the access subtype excludes null . In addition, the anonymous access subtype 
defined by the access_definition  for a controlling access parameter (see 3.9.2) excludes null. Finally, for a 
subtype_indication  without a null_exclusion , the subtype denoted by the subtype_indication  excludes null 
if and only if the subtype denoted by the subtype_mark  in the subtype_indication  excludes null.  
All subtypes of an access-to-subprogram  type are constrained. The first subtype of a type defined by an 
access_definition  or an access_to_object_definition  is unconstrained if the designated subtype is an 
unconstrained array or discri minated subtype; otherwise, it is constrained.  
Legality Rules 
If a subtype_indication , discriminant_specification , parameter_specification , parameter_and_result_-
profile , object_renaming_declaration , or formal_object_declaration  has a null_exclusion , the subtype_-
mark  in that construct shall denote an access subtype that does not exclude null.  
Dynamic Semantics 
A composite_constraint  is compatible  with an unconstrained access subtype if it is compatible with the 
designated subtype. A null_exclusion  is compatible with any access subtype that does not exclude null. An 10 
11 
12/3 
13/2 
13.1/2 
14/3 
14.1/2 
15/2 
Ada Reference Manual — 2012 Edition 
3.10    Access Types 13 December 2012      82 access value satisfies  a composite_constraint  of an access subtype if it equals the null value of its type or 
if it designates an object whose value satisfies the cons traint. An access value satisfies an exclusion of the 
null value if it does not equal the null value of its type. 
The elaboration of an access_type_definition  creates the access type and its first subtype. For an access-
to-object type, this elaboration includes the elaboration of the subtype_indication , which creates the 
designated subtype. 
The elaboration of an access_definition  creates an anonymous access type.  
NOTES 
83  Access values are called “pointers” or “references” in some other languages. 
84  Each access-to-object type has an associated storage poo l; several access ty pes can share the same  pool. An object can 
be created in the storage pool of an access type by an allocator  (see 4.8) for the access ty pe. A storage pool (roughly) 
corresponds to what some other languages call a “heap.” See 13.11 for a discussion of pools. 
85  Only index_constraint s and discriminant_constraint s can be applied to access types (see 3.6.1 and 3.7.1).  
Examples 
Examples of access-to-object types:   
type Peripheral_Ref is not null access  Peripheral;  --   see 3.8.1 
type Binop_Ptr is access all  Binary_Operation'Class; 
                                           --  general access-to-class-wide, see 3.9.1  
Example of an access subtype:   
subtype Drum_Ref is Peripheral_Ref(Drum);  --   see 3.8.1 
Example of an access-to-subprogram type:   
type Message_Procedure is access procedure  (M : in String := "Error!"); 
procedure  Default_Message_Procedure(M : in String); 
Give_Message : Message_Procedure := Default_Message_Procedure'Access; ... procedure  Other_Procedure(M : in String); 
... Give_Message := Other_Procedure'Access; ... Give_Message("File not found.");  --  call with parameter (. all is optional)  
Give_Message. all;                 --  call with no parameters  
3.10.1 Incomplete Type Declarations 
There are no particular limitations on the designated type of an access type. In particular, the type of a 
component of the designated type can be another acce ss type, or even the same access type. This permits 
mutually dependent and recursive access types. An incomplete_type_declaration  can be used to introduce 
a type to be used as a designated type, while  deferring its full definition to a subsequent 
full_type_declaration .  
Syntax 
incomplete_type_declaration ::= type defining_identifier  [discriminant_part ] [is tagged ]; 
Static Semantics 
An incomplete_type_declaration  declares an incomplete view  of a type and its first subtype; the first 
subtype is unconstrained if a discriminant_part  appears. If the incomplete_type_declaration  includes the 
reserved word tagged , it declares a tagged incomplete view . An incomplete view of a type is a limited 
view of the type (see 7.5). 16 
17/2 
18 
19 
20 
21 
22/2 
23 
24 
25 
26 
1 
2/2 
2.1/2 
Ada Reference Manual — 2012 Edition 
83      13 December 2012 Incomplete Type Declarations   3.10.1 Given an access type A whose designated type T is an incomplete view, a dereference of a value of type A 
also has this incomplete view except when:  
• it occurs within the immediate scope of the completion of T, or 
• it occurs within the scope of a nonlimited_with_clause  that mentions a library package in whose 
visible part the completion of T is declared, or 
• it occurs within the scope of the completion of T and T is an incomplete view declared by an 
incomplete_type_declaration .  
In these cases, the dereference has the view of T visible at the point of the dereference.  
Similarly, if a subtype_mark  denotes a subtype_declaration  defining a subtype of an incomplete view T, 
the subtype_mark  denotes an incomplete view except under th e same three circumstances given above, in 
which case it denotes the view of T visible at the point of the subtype_mark .  
Legality Rules 
An incomplete_type_declaration  requires a completion, which shall be a type_declaration  other than an 
incomplete_type_declaration . If the incomplete_type_declaration  occurs immediately within either the 
visible part of a package_specification  or a declarative_part , then the type_declaration  shall occur later 
and immediately within this visible part or declarative_part . If the incomplete_type_declaration  occurs 
immediately within the private part of a given package_specification , then the type_declaration  shall 
occur later and immediately within eith er the private part itself, or the declarative_part  of the 
corresponding package_body .  
If an incomplete_type_declaration  includes the reserved word tagged , then a type_declaration  that 
completes it shall declare a tagged type. If an incomplete_type_declaration  has a known_discriminant_-
part, then a type_declaration  that completes it shall have a fully conforming (explicit) known_-
discriminant_part  (see 6.3.1). If an incomplete_type_declaration  has no discriminant_part  (or an 
unknown_discriminant_part ), then a corresponding type_declaration  is nevertheless allowed to have 
discriminants, either explicitly , or inherited via derivation. 
A name  that denotes an incomplete view of a type may be used as follows:  
• as the subtype_mark  in the subtype_indication  of an access_to_object_definition ; the only 
form of constraint  allowed in this subtype_indication  is a discriminant_constraint  (a 
null_exclusion  is not allowed);  
• as the subtype_mark  in the subtype_indication  of a subtype_declaration ; the subtype_-
indication  shall not have a null_exclusion  or a constraint ;  
• as the subtype_mark  in an access_definition  for an access-to-object type;  
• as the subtype_mark  defining the subtype of a parameter or result in a profile occurring within a 
basic_declaration ;  
• as a generic actual parameter whose corres ponding generic formal parameter is a formal 
incomplete type (see 12.5.1).  
If such a name  denotes a tagged incomplete view, it may also be used: 
• as the subtype_mark  defining the subtype of a parameter in the profile for a subprogram_body , 
entry_body , or accept_statement ; 
• as the prefix  of an attribute_reference  whose attribute_designator  is Class; such an attribute_-
reference  is restricted to the uses allowed he re; it denotes a tagged incomplete view.  
This paragraph was deleted.  2.2/2 
2.3/2 
2.4/3 
2.5/3 2.6/3 
2.7/3 
3/3 
4/3 
5/2 
6/3 
7/2 
8/3 
8.1/3 
8.2/3 8.3/2 
8.4/3 
9/2 
9.1/3 
Ada Reference Manual — 2012 Edition 
3.10.1    Incomplete Type Declarations 13 December 2012      84 • This paragraph was deleted.  
If any of the above uses occurs as part of the d eclaration of a primitive subprogram of the incomplete 
view, and the declaration occurs immediately within th e private part of a package, then the completion of 
the incomplete view shall also occur immediately with in the private part; it shall not be deferred to the 
package body.  
No other uses of a name  that denotes an incomplete view of a type are allowed. 
A prefix  that denotes an object shall not be of an incomp lete view. An actual parameter in a call shall not 
be of an untagged incomplete view. The result object of  a function call shall not be of an incomplete view. 
A prefix  shall not denote a subprogram having a formal pa rameter of an untagged incomplete view, nor a 
return type that is an incomplete view.  
Paragraph 11 was deleted.   
Dynamic Semantics 
The elaboration of an incomplete_type_declaration  has no effect.  
NOTES 
86  Within a declarative_part , an incomplete_type_declaration  and a corresponding full_type_declaration  cannot be 
separated by an intervening body. This is because a type has to be completely defined before it is frozen, and a body freezes all types declared prior to it in the same 
declarative_part  (see 13.14). 
87  A name  that denotes an object of an incomplete view is defined to be of a limited type. Hence, the target of an 
assignment statement cannot be of an incomplete view. 
Examples 
Example of a recursive type:   
type Cell;  --   incomplete type declaration  
type Link is access Cell; 
type Cell is 
   record 
      Value  : Integer;       Succ   : Link;       Pred   : Link;    end record; 
Head   : Link  := new Cell'(0, null, null); 
Next   : Link  := Head.Succ; 
Examples of mutually dependent access types:   
type Person(<>);    --  incomplete type declaration  
type Car is tagged ; --  incomplete type declaration  
type Person_Name is access Person; 
type Car_Name    is access all Car'Class; 
type Car is tagged 
   record 
      Number  : Integer;       Owner   : Person_Name;    end record; 9.2/3 
9.3/2 
9.4/2 
10/3 
12 
13 
13.1/3 
14 
15 
16 
17 
18 
19/2 
20/2 21/2 
Ada Reference Manual — 2012 Edition 
85      13 December 2012 Incomplete Type Declarations   3.10.1 type Person(Sex : Gender) is 
   record 
      Name     : String(1 .. 20);       Birth    : Date;       Age      : Integer range 0 .. 130; 
      Vehicle  : Car_Name;       case Sex is 
         when M => Wife           : Person_Name(Sex => F); 
         when F => Husband        : Person_Name(Sex => M); 
      end case; 
   end record; 
My_Car, Your_Car, Next_Car : Car_Name := new Car;  --  see 4.8 
George : Person_Name := new Person(M); 
   ... George.Vehicle := Your_Car; 
3.10.2 Operations of Access Types 
The attribute Access is used to create access va lues designating aliased objects and nonintrinsic 
subprograms. The “accessibility” rules prevent dangling references (in the absence of uses of certain 
unchecked features — see Clause 13).  
Name Resolution Rules 
For an attribute_reference  with attribute_designator  Access (or Unchecked_Access — see 13.10), the 
expected type shall be a single access type A such that:  
• A is an access-to-object type with designated type D and the type of the prefix  is D'Class or is 
covered by D, or 
• A is an access-to-subprogram type whose designated pr ofile is type conformant with that of the 
prefix.  
The prefix  of such an attribute_reference  is never interpreted as an implicit_dereference  or a 
parameterless function_call  (see 4.1.4). The designated type or profile of the expected type of the 
attribute_reference  is the expected type or profile for the prefix .  
Static Semantics 
The accessibility rules, which prevent dangling references, are written in terms of accessibility levels , 
which reflect the run-time nesting of masters . As explained in 7.6.1, a master is the execution of a certain 
construct, such as a subprogram_body . An accessibility level is deeper than  another if it is more deeply 
nested at run time. For example, an object declared  local to a called subprogram has a deeper accessibility 
level than an object declared local to the ca lling subprogram. The accessibility rules for access types 
require that the accessibility level of an object designate d by an access value be no deeper than that of the 
access type. This ensures that the object will live at l east as long as the access type, which in turn ensures 
that the access value cannot later designate an object that no longer exists. The Unchecked_Access 
attribute may be used to circumvent the accessibility rules. 
A given accessibility level is said to be statically deeper  than another if the given level is known at 
compile time (as defined below) to be deeper than the other for all possible executions. In most cases, 
accessibility is enforced at compile time by Legality  Rules. Run-time accessibility checks are also used, 
since the Legality Rules do not cover certain cases  involving access parameters and generic packages. 22 
23 
1/3 
2/2 
2.1/2 
2.2/2 2.3/2 
3/2 
4 
Ada Reference Manual — 2012 Edition 
3.10.2    Operations of Access Types 13 December 2012      86 Each master, and each entity and view created by it, has an accessibility level:  
• The accessibility level of a given master is d eeper than that of each dynamically enclosing 
master, and deeper than that of each master upon which the task executing the given master directly depends (see 9.3). 
• An entity or view defined by a declaration and created as part of its elaboration has the same 
accessibility level as the innermost master of the declaration except in the cases of renaming and 
derived access types described belo w. Other than for an explicitly aliased parameter, a formal 
parameter of a callable entity has the same accessibility level as the master representing the invocation of the entity.  
• The accessibility level of a view of an object or subprogram defined by a 
renaming_declaration  
is the same as that of the renamed view. 
• The accessibility level of a view conversion, qualified_expression , or parenthesized expression, 
is the same as that of the operand. 
• The accessibility level of a conditional_expression  is the accessibility level of the evaluated 
dependent_ expression . 
• The accessibility level of an aggregate  that is used (in its entirety)  to directly initialize part of 
an object is that of the object being initialized. In other contexts, the accessibility level of an 
aggregate  is that of the innermost master that evaluates the aggregate . 
• The accessibility level of the result of a function call is that of the master of the function call , 
which is determined by the point of call as follows: 
• If the result is used (in its entirety) to directly  initialize part of an object, the master is that 
of the object being initialized. In the case wher e the initialized object is a coextension (see 
below) that becomes a coextension of another object, the master is that of the eventual 
object to which the coextension will be transferred. 
• If the result is of an anonymous access type and is the operand of an explicit conversion, 
the master is that of the target type of the conversion; 
• If the result is of an anonymous access type and defines an access discriminant, the master 
is the same as that for an object created by an anonymous allocator  that defines an access 
discriminant (even if the access result is of an access-to-subprogram type). 
• If the call itself defines the result of a functi on to which one of the above rules applies, 
these rules are applied recursively; 
• In other cases, the master of the call is that of the innermost master that evaluates the 
function call. 
 In the case of a call to a function whose result type is an anonymous access type, the 
accessibility level of the type of the result of the function call is also determined by the point of 
call as described above. 
• Within a return statement, the accessibility level of the return object is that of the execution of 
the return statement. If the return statement completes normally by returning from the function, then prior to leaving the function, the accessibility level of the return object changes to be a level 
determined by the point of call, as does the leve l of any coextensions (see below) of the return 
object. 
• The accessibility level of a derived access type is  the same as that of  its ultimate ancestor. 
• The accessibility level of the anonymous access type defined by an 
access_definition  of an 
object_renaming_declaration  is the same as that of the renamed view. 5 
6 
7/3 
8 
9/2 
9.1/3 
10/3 
10.1/3 
10.2/3 
10.3/3 
10.4/3 
10.5/3 
10.6/3 10.7/3 
10.8/3 
11 
11.1/2 
Ada Reference Manual — 2012 Edition 
87      13 December 2012 Operations of Access Types   3.10.2 • The accessibility level of the anonymous access type of an access discriminant in the 
subtype_indication  or qualified_expression  of an allocator , or in the expression  or return_-
subtype_indication  of a return statement is  determined as follows: 
• If the value of the access discriminant is determined by a discriminant_association  in a 
subtype_indication , the accessibility level of the object or subprogram designated by the 
associated value (or library level if the value is null);  
• If the value of the access discriminant is determined by a default_expression  in the 
declaration of the discriminant, the level of  the object or subprogram designated by the 
associated value (or library level if null);  
• If the value of the access discriminant is determined by a record_component_association  
in an aggregate , the accessibility level of the object or subprogram designated by the 
associated value (or library level if the value is null); 
• In other cases, where the value of the access discriminant is determined by an object with 
an unconstrained nominal subtype, the accessibility level of the object. 
• The accessibility level of the anonymous access ty pe of an access discriminant in any other 
context is that of the enclosing object. 
• The accessibility level of the anonymous access type of an access parameter specifying an 
access-to-object type is the same as that of the view designated by the actual (or library-level if the actual is null).  
• The accessibility level of the anonymous access type of an access parameter specifying an 
access-to-subprogram type is deeper than that of any master; all such anonymous access types 
have this same level.  
• The accessibility level of the type of a stand-alone object of an anonymous access-to-object type 
is the same as the accessibility level of the type  of the access value most recently assigned to the 
object; accessibility checks ensure that this is neve r deeper than that of the declaration of the 
stand-alone object. 
• The accessibility level of an explicitly aliased (s ee 6.1) formal parameter in a function body is 
determined by the point of call; it is the same level that the return object ultimately will have. 
• The accessibility level of an object created by an 
allocator  is the same as that of the access type, 
except for an allocator  of an anonymous access type (an anonymous allocator ) in certain 
contexts, as follows: For an anony mous allocator that defines the result of a function with an 
access result, the accessibility level is determined as though the allocator  were in place of the 
call of the function; in the special case of a call th at is the operand of a type conversion, the level 
is that of the target access type of the conversi on. For an anonymous allocator defining the value 
of an access parameter, the accessibility level is that  of the innermost master of the call. For an 
anonymous allocator whose type is that of a stand-alone object of an anonymous access-to-
object type, the accessibility level is that of the declaration of the stand-alone object. For one defining an access discriminant, the accessib ility level is determined as follows: 
• for an allocator  used to define the discriminant of an object, the level of the object; 
• for an allocator  used to define the constraint in a subtype_indication  in any other context, 
the level of the master that elaborates the subtype_indication . 
• This paragraph was deleted.  
 In the first case, the allocated object is said to be a coextension  of the object whose discriminant 
designates it, as well as of any object of which th e discriminated object is itself a coextension or 
subcomponent. If the allocated object is a coexte nsion of an anonymous object representing the 
result of an aggregate or function call that is used (in its entirety) to directly initialize a part of an 
object, after the result is assigned, the coextens ion becomes a coextension of the object being 12/2 
12.1/2 
12.2/3 
12.3/3 
12.4/3 
12.5/3 
13/3 
13.1/2 
13.2/3 
13.3/3 
14/3 
14.1/3 
14.2/3 
14.3/3 
14.4/3 
Ada Reference Manual — 2012 Edition 
3.10.2    Operations of Access Types 13 December 2012      88 initialized and is no longer considered a coextens ion of the anonymous object. All coextensions 
of an object (which have not thus been transfer ed by such an initialization) are finalized when 
the object is finalized (see 7.6.1).  
• Within a return statement, the accessibility level of the anonymous access type of an access 
result is that of the master of the call. 
• The accessibility level of a view of an object or  subprogram designated by an access value is the 
same as that of the access type.  
• The accessibility level of a component, protect ed subprogram, or entry of (a view of) a 
composite object is the same as that of (the view of) the composite object.  
In the above rules, the operand of a view  conversion, parenthe sized expression or qualified_expression  is 
considered to be used in a context if the view conversion, parent hesized expression or 
qualified_expression  itself is used in that context. Similarly, a dependent_ expression  of a 
conditional_expression  is considered to be us ed in a context if the conditional_expression  itself is used in 
that context. 
One accessibility level is defined to be statically deeper  than another in the following cases:  
• For a master that is statically nested within  another master, the accessibility level of the inner 
master is statically deeper th an that of the outer master.  
• The accessibility level of the anonymous access type of an access parameter specifying an 
access-to-subprogram type is statically deeper th an that of any master; all such anonymous 
access types have this same level.  
• The statically deeper relationship does not appl y to the accessibility level of the anonymous type 
of an access parameter specifying an access-to-object type nor does it apply to a descendant of a generic formal type; that is, such an accessibility le vel is not considered to be statically deeper, 
nor statically shallower, than any other. 
• The statically deeper relationship does not apply to the accessibility level of the type of a stand-
alone object of an anonymous access-to-object type ; that is, such an accessibility level is not 
considered to be statically deeper, nor statically shallower, than any other. 
• Inside a return statement that applies to a function F, when determining whether the accessibility 
level of an explicitly aliased parameter of F is statically deeper than the level of the return object 
of F, the level of the return object is considered to be the same as that of the level of the 
explicitly aliased parameter; for statically co mparing with the level of other entities, an 
explicitly aliased parameter of F is considered to have the accessibility level of the body of F. 
• For determining whether a level is statically d eeper than the level of the anonymous access type 
of an access result of a function, when within a re turn statement that applies to the function, the 
level of the master of the call is presumed to be the same as that of the level of the master that 
elaborated the function body. 
• For determining whether one level is statically  deeper than another when within a generic 
package body, the generic package is  presumed to be instantiated at the same level as where it 
was declared; run-time checks are needed in the case of more d eeply nested instantiations.  
• For determining whether one level is statically deeper than another when within the declarative 
region of a 
type_declaration , the current instance of the type is presumed to be an object created 
at a deeper level than that of the type.  
The accessibility level of all library units is called the library level ; a library-level declaration or entity is 
one whose accessibility level is the library level.  14.5/3 
15/3 
16 
16.1/3 
17 
18 
18.1/2 
19/3 
19.1/3 
19.2/3 
19.3/3 
20 
21 
22 
Ada Reference Manual — 2012 Edition 
89      13 December 2012 Operations of Access Types   3.10.2 The following attribute is defined for a prefix  X that denotes an aliased view of an object:  
X'Access X'Access yields an access value that desi gnates the object denoted by X. The type of 
X'Access is an access-to-object type, as determ ined by the expected type. The expected 
type shall be a general access type. X shall denote an aliased view of an object, including possibly the current instance (see 8.6) of a limite d type within its definition, or a formal 
parameter or generic formal object of a tagged type. The view denoted by the 
prefix  X shall 
satisfy the following additional requirements, pr esuming the expected type for X'Access is 
the general access type A with designated type D:  
• If A is an access-to-variable type, then the view shall be a variable; on the other 
hand, if A is an access-to-constant type, the view may be either a constant or a 
variable.  
• The view shall not be a subcomponent th at depends on discriminants of an object 
unless the object is known to be constrained. 
• If A is a named access type and D is a tagged type, then the type of the view shall 
be covered by D; if A is anonymous and D is tagged, then the type of the view 
shall be either D'Class or a type covered by D; if D is untagged, then the type of 
the view shall be D, and either:  
• the designated subtype of A shall statically match the nominal subtype of the 
view; or 
• D shall be discriminated in its full view and unconstrained in any partial 
view, and the designated subtype of A shall be unconstrained. For the 
purposes of determining with in a generic body whether D is unconstrained in 
any partial view, a discriminated subtype is considered to have a constrained 
partial view if it is a descendant of an untagged generic formal private or 
derived type.  
• The accessibility level of the view shall not be statically deeper than that of the 
access type A.  
 In addition to the places where Legality  Rules normally apply (see 12.3), these 
requirements apply also in the private part of an instance of a generic unit. 
 A check is made that the accessibility level of X is not deeper than that of the access type A. 
If this check fails, Progr am_Error is raised.  
 If the nominal subtype of X does not sta tically match the designated subtype of A, a view 
conversion of X to the designated subtype is evaluated (which might raise Constraint_Error 
— see 4.6) and the value of X'Access designates that view.  
The following attribute is defined for a prefix  P that denotes a subprogram:  
P'Access P'Access yields an access value that designa tes the subprogram denoted by P. The type of 
P'Access is an access-to-subprogram type ( S), as determined by the expected type. The 
accessibility level of P shall not be statically deeper than that of S. In addition to the places 
where Legality Rules normally apply (see 12.3), this  rule applies also in the private part of 
an instance of a generic unit. The profile of  P shall be subtype conformant with the 
designated profile of S, and shall not be Intrinsic. If the subprogram denoted by P is 
declared within a generic unit, and the expre ssion P'Access occurs within the body of that 
generic unit or within the body of a generic un it declared within the declarative region of 
the generic unit, then the ultimate ancestor of S shall be either a nonformal type declared 
within the generic unit or an anonymous access type of an access parameter. 23 
24/1 
25 
26/3 
27/2 
27.1/2 
27.2/3 
28/3 
28.1/3 
29 30 
31 
32/3 
Ada Reference Manual — 2012 Edition 
3.10.2    Operations of Access Types 13 December 2012      90 Legality Rules 
An expression  is said to have distributed accessibility  if it is 
• a conditional_expression  (see 4.5.7); or 
• a view conversion, qualified_expression , or parenthesized expr ession whose operand has 
distributed accessibility.  
The statically deeper relationship does not apply to the accessibility level of an expression  having 
distributed accessibility; that is, such an accessibility leve l is not considered to be statically deeper, nor 
statically shallower, than any other. 
Any static accessibility requirement that is imposed on an expression  that has distributed accessibility (or 
on its type) is instead imposed on the dependent_ expression s of the underlying conditional_expression . 
This rule is applie d recursively if a dependent_ expression  also has distributed accessibility. 
NOTES 
88  The Unchecked_Access attribute yields the same result as the Access attribute for objects, but has fewer restrictions (see 13.10). There are other predefined operations that yield access values: an 
allocator  can be used to create an object, 
and return an access value that designates it (see 4. 8); evaluating the literal null yields a null access value that designates 
no entity at all (see 4.2). 
89  The predefined operations of an access type also include the assignment operation, qualification, and membership 
tests. Explicit c onversion is allowed between general access types with matc hing designated subtypes ; explicit conversion 
is allowed between access-to-s ubprogram types with subtype conformant profiles (see 4. 6). Named access types have 
predefined equality opera tors; anonymous acce ss types do not, but they can use the predefined equality  operators for 
universal_access  (see 4.5.2).  
90  The object or subprogram designate d by an access value can be named with a dere ference, either an explicit_-
dereference  or an implicit_dereference . See 4.1. 
91  A call through the dere ference of an access-to-s ubprogram value is never a dispatching call.  
92  The Access attribute for subprograms and parameters of an a nonymous access- to-subprogram type may together be 
used to implement “downward closures” — that is, to pass a more-nested subprogram as a parameter to a less-nested subprogram, as might be appropriate for an iterator abstraction or numerical integration. Downward closures can also be implemented using generic formal subpr ograms (see 12.6). Note that  Unchecked_Access is not allowed for subprograms. 
93  Note that using an access-to-class-wide tagged type with a dispatching operation is a potentially more structured 
alternative to using an  access-to-subprogram type. 
94  An implementation may consider two access-to-subprogram values to be unequal, even though they designate the 
same subprogram. This might be because  one points directly to the subprogram , while the other points to a special 
prologue that performs an Elaboration_Check and then jumps to the subprogram. See 4.5.2.  
Examples 
Example of use of the Access attribute:   
Martha : Person_Name := new Person(F);       --  see 3.10.1 
Cars   : array (1..2) of aliased Car; 
   ... Martha.Vehicle := Cars(1)'Access; George.Vehicle := Cars(2)'Access; 32.1/3 
32.2/3 
32.3/3 
32.4/3 
32.5/3 
33 
34/2 
35 
36 
37/2 
38 
39 
40 
41 
Ada Reference Manual — 2012 Edition 
91      13 December 2012 Declarative Parts   3.11 3.11 Declarative Parts 
A declarative_part  contains declarative_item s (possibly none).  
Syntax 
declarative_part ::= {declarative_item } 
declarative_item ::=  
    basic_declarative_item  | body  
basic_declarative_item ::=  
    basic_declaration  | aspect_clause  | use_clause  
body ::= proper_body  | body_stub  
proper_body ::=  
    subprogram_body  | package_body  | task_body  | protected_body  
Static Semantics 
The list of declarative_item s of a declarative_part  is called the declaration list  of the declarative_part .  
Dynamic Semantics 
The elaboration of a declarative_part  consists of the elaboration of the declarative_item s, if any, in the 
order in which they are given in the declarative_part . 
An elaborable construct is in the elaborated  state after the normal completion of its elaboration. Prior to 
that, it is not yet elaborated .  
For a construct that attempts to use a body, a ch eck (Elaboration_Check) is performed, as follows:  
• For a call to a (non-protected) subprogram that has an explicit body, a check is made that the 
body is already elaborated. This check and the ev aluations of any actual parameters of the call 
are done in an arbitrary order.  
• For a call to a protected operation of a protected  type (that has a body — no check is performed 
if  the protected type is imported — see B.1), a check is made that the protected_body  is already 
elaborated. This check and the evaluations of an y actual parameters of the call are done in an 
arbitrary order.  
• For the activation of a task, a check is made by the activator that the task_body  is already 
elaborated. If two or more tasks are being activ ated together (see 9.2), as the result of the 
elaboration of a declarative_part  or the initialization for the object created by an allocator, this 
check is done for all of them be fore activating any of them.  
• For the instantiation of a generic unit that has a body, a check is made that this body is already 
elaborated. This check and the evaluation of any explicit_generic_actual_parameter s of the 
instantiation are done in an arbitrary order.  
The exception Program_Error is raised if any of these checks fails.  
3.11.1 Completions of Declarations 
Declarations sometimes come in two parts. A decl aration that requires a second part is said to require 
completion . The second part is called the completion  of the declaration (and of the entity declared), and is 
either another declaration, a body, or a pragma . A body  is a body , an entry_body , a 1 
2 
3 
4/1 
5 
6 
6.1/2 
7 
8 9 
10/1 
11/3 
12 
13 
14 
1/3 
Ada Reference Manual — 2012 Edition 
3.11.1    Completions of Declara tions 13 December 2012      92 null_procedure_declaration  or an expression_function_declaration  that completes another declaration, or 
a renaming-as-body (see 8.5.4).  
Name Resolution Rules 
A construct that can be a completion is interpreted as the completion of a prior declaration only if:  
• The declaration and the completion occur imme diately within the same declarative region; 
• The defining name or defining_program_unit_name  in the completion is the same as in the 
declaration, or in the case of a pragma , the pragma  applies to the declaration; 
• If the declaration is overloadable, then the comp letion either has a type-conformant profile, or is 
a pragma .  
Legality Rules 
An implicit declaration shall not have a completion. For any explicit declaration that is specified to require 
completion , there shall be a corresponding explicit completi on, unless the declared entity is imported (see 
B.1).  
At most one completion is allowed for a given declar ation. Additional requireme nts on completions appear 
where each kind of completion is defined.  
A type is completely defined  at a place that is after its full type definition (if it has one) and after all of its 
subcomponent types are completely de fined. A type shall be completely  defined before it is frozen (see 
13.14 and 7.3).  
NOTES 
95  Completions are in principle allowed for any kind of explicit declaration. However, for some kinds of declaration, the only allowed completion is an implementation-defined pragma, and implementations are not required to have any such pragmas.  
96  There are rules that prevent premature uses of declarations that have a corresponding completion. The 
Elaboration_Checks of 3.11 prevent such uses at run time for subprograms, protected operations, tasks, and generic units. The rules of 13.14, “Freezi ng Rules” prevent, at compile tim e, premature uses of other en tities such as private types and 
deferred constants.  2 
3 
4 
5 
6/3 
7 
8 
9/3 
10 
Ada Reference Manual — 2012 Edition 
93      13 December 2012 Names and Expressions   4 4   Names and Expressions 
The rules applicable to the different forms of name  and expression, and to thei r evaluation, are given in 
this clause.  
4.1 Names 
Name s can denote declared entities, whether decl ared explicitly or implicitly (see 3.1). Name s can also 
denote objects or subprograms designate d by access values; the results of type_conversion s or 
function_call s; subcomponents and slices of objects and va lues; protected subprograms, single entries, 
entry families, and entries in families of entries. Finally, name s can denote attributes of any of the 
foregoing.  
Syntax 
name ::=  
     direct_name  | explicit_dereference  
   | indexed_component  | slice  
   | selected_component  | attribute_reference  
   | type_conversion  | function_call  
   | character_literal  | qualified_expression  
   | generalized_reference  | generalized_indexing  
direct_name ::= identifier  | operator_symbol  
prefix ::= name  | implicit_dereference  
explicit_dereference ::= name .all 
implicit_dereference ::= name  
Certain forms of name  (indexed_component s, selected_component s, slice s, and attribute_reference s) 
include a prefix  that is either itself a name  that denotes some related entity, or an implicit_dereference  of 
an access value that designates some related entity.  
Name Resolution Rules 
The name  in a dereference  (either an implicit_dereference  or an explicit_dereference ) is expected to be 
of any access type.  
Static Semantics 
If the type of the name  in a dereference is some access-to-object type T, then the dereference denotes a 
view of an object, the nominal subtype  of the view being the designated subtype of T. If the designated 
subtype has unconstrained disc riminants, the (actual) subtype of the view is constrained by the values of 
the discriminants of the designated object, except when th ere is a partial view of the type of the designated 
subtype that does not have discri minants, in which case the derefe rence is not constrained by its 
discriminant values.  
If the type of the name  in a dereference is some access-to-subprogram type S, then the dereference 
denotes a view of a subprogram, the profile  of the view being the designated profile of S.  
Dynamic Semantics 
The evaluation of a name  determines the entity denoted by the name . This evaluation has no other effect 
for a name  that is a direct_name  or a character_literal . 1/3 
1 
2/3 
3 
4 5 6 
7/3 
8 
9/3 
10 
11/2 
Ada Reference Manual — 2012 Edition 
4.1   Names 13 December 2012      94 The evaluation of a name  that has a prefix  includes the evaluation of the prefix . The evaluation of a prefix  
consists of the evaluation of the name  or the implicit_dereference . The prefix  denotes the entity denoted 
by the name  or the implicit_dereference . 
The evaluation of a dereference c onsists of the evaluation of the name  and the determination of the object 
or subprogram that is designated by the value of the name . A check is made that the value of the name  is 
not the null access value. Constraint_Error is raised if  this check fails. The dereference denotes the object 
or subprogram designated by the value of the name .  
Examples 
Examples of direct names:   
Pi  -- the direct name of a number   (see 3.3.2) 
Limit  -- the direct name of a constant   (see 3.3.1) 
Count  -- the direct name of a scalar variable   (see 3.3.1) 
Board  -- the direct name of an array variable   (see 3.6.1) 
Matrix  -- the direct name of a type   (see 3.6) 
Random  -- the direct name of a function   (see 6.1) 
Error  -- the direct name of an exception   (see 11.1) 
Examples of dereferences:   
Next_Car. all --   explicit dereference denoting the object designated by  
                --   the access variable Next_Car (see 3.10.1)  
Next_Car.Owner  --   selected component with implicit dereference;  
                --   same as Next_Car. all.Owner 
4.1.1 Indexed Components 
An indexed_component  denotes either a component of an array or an entry in a family of entries.  
Syntax 
indexed_component ::= prefix (expression  {, expression }) 
Name Resolution Rules 
The prefix  of an indexed_component  with a given number of expression s shall resolve to denote an array 
(after any implicit dereference) with the corres ponding number of index positions, or shall resolve to 
denote an entry family of a task or protected  object (in which case there shall be only one expression ). 
The expected type for each expression  is the corresponding index type. 
Static Semantics 
When the prefix  denotes an array, the indexed_component  denotes the component of the array with the 
specified index value(s). The nominal subtype of the indexed_component  is the component subtype of the 
array type.  
When the prefix  denotes an entry family, the indexed_component  denotes the individual entry of the entry 
family with the specified index value. 
Dynamic Semantics 
For the evaluation of an indexed_component , the prefix  and the expression s are evaluated in an arbitrary 
order. The value of each expression  is converted to the corresponding index type. A check is made that 
each index value belongs to the corresponding index range  of the array or entry family denoted by the 
prefix . Constraint_Error is rais ed if this check fails. 12 
13 
14 
15 
16 
17 
1 
2 
3 
4 
5 
6 
7 
Ada Reference Manual — 2012 Edition 
95      13 December 2012 Indexed Components   4.1.1 Examples 
Examples of indexed components:   
 My_Schedule(Sat)     --   a component of a one-dimensional array  (see 3.6.1)  
 Page(10)             --   a component of a one-dimensional array  (see 3.6)  
 Board(M, J + 1)      --   a component of a two-dimensional array  (see 3.6.1)  
 Page(10)(20)         --   a component of a component  (see 3.6)  
 Request(Medium)      --   an entry in a family of entries  (see 9.1)  
 Next_Frame(L)(M, N)  --   a component of a function call  (see 6.1)  
NOTES 
1  Notes on the examples:  Distinct notations are used for components of multidimensional arrays (such as Board) and 
arrays of arrays (such as Page). The components of an array of arrays are arrays and can therefore be indexed. Thus Page(10)(20) denotes the 20th component of Page(10). In the last example Next_Frame(L) is a function call returning an access value that designates a two-dimensional array. 
4.1.2 Slices 
A slice  denotes a one-dimensional array formed by a sequence of consecutive components of a one-
dimensional array. A slice  of a variable is a variable; a slice  of a constant is a constant; a slice  of a value is 
a value.  
Syntax 
slice ::= prefix (discrete_range ) 
Name Resolution Rules 
The prefix  of a slice  shall resolve to denote a one-dimensional array (after any implicit dereference). 
The expected type for the discrete_range  of a slice  is the index type of the array type.  
Static Semantics 
A slice  denotes a one-dimensional array formed by the sequence of consecutive components of the array 
denoted by the prefix , corresponding to the range of values of the index given by the discrete_range . 
The type of the slice  is that of the prefix . Its bounds are those defined by the discrete_range . 
Dynamic Semantics 
For the evaluation of a slice , the prefix  and the discrete_range  are evaluated in an arbitrary order. If the 
slice  is not a null slice  (a slice  where the discrete_range  is a null range), then a check is made that the 
bounds of the discrete_range  belong to the index range of the array denoted by the prefix . 
Constraint_Error is raised  if this check fails. 
NOTES 
2  A slice  is not permitted as the prefix  of an Access attribute_reference , even if the components or the array as a whole 
are aliased. See 3.10.2.  
3  For a one-dimensional array A, the slice  A(N .. N) denotes an array that has only one component; its type is the type of 
A. On the other hand, A(N) denotes a component of the array A and has the corresponding component type.  8 
9 
10 
1 
2 
3 
4 
5 
6 
7 
8 
9 
Ada Reference Manual — 2012 Edition 
4.1.2    Slices 13 December 2012      96 Examples 
Examples of slices:   
  Stars(1 .. 15)        --   a slice of 15 characters  (see 3.6.3)  
  Page(10 .. 10 + Size) --   a slice of 1 + Size components  (see 3.6)  
  Page(L)(A .. B)       --   a slice of the array Page(L)  (see 3.6)  
  Stars(1 .. 0)         --   a null slice  (see 3.6.3)  
  My_Schedule(Weekday)  --   bounds given by subtype  (see 3.6.1 and 3.5.1)  
  Stars(5 .. 15)(K)     --   same as Stars(K)  (see 3.6.3)  
                        --   provided that K is in 5 .. 15  
4.1.3 Selected Components 
Selected_component s are used to denote components (including discriminants), entries, entry families, 
and protected subprograms; they are also used  as expanded names as  described below.  
Syntax 
selected_component ::= prefix  . selector_name  
selector_name ::= identifier  | character_literal  | operator_symbol  
Name Resolution Rules 
A selected_component  is called an expanded name  if, according to the visibility rules, at least one 
possible interpretation of its prefix  denotes a package or an enclos ing named construct (directly, not 
through a subprogram_renaming_declaration  or generic_renaming_declaration ).  
A selected_component  that is not an expanded name shall resolve to denote one of the following:  
• A component (includi ng a discriminant): 
 The prefix  shall resolve to denote an object or value of some non-array composite type (after any 
implicit dereference). The selector_name  shall resolve to denote a discriminant_specification  of 
the type, or, unless the type is a protected type, a component_declaration  of the type. The 
selected_component  denotes the corresponding component  of the object or value.  
• A single entry, an entry fam ily, or a protected subprogram: 
 The prefix  shall resolve to denote an object or value of  some task or protected type (after any 
implicit dereference). The selector_name  shall resolve to denote an entry_declaration  or 
subprogram_declaration  occurring (implicitly or explicitly) within the visible part of that type. 
The selected_component  denotes the corresponding entry,  entry family, or protected 
subprogram.  
• A view of a subprogram whose first formal pa rameter is of a tagged type or is an access 
parameter whose designated type is tagged: 
 The prefix  (after any implicit dereference) shall resolve to denote an object or value of a specific 
tagged type T or class-wide type T'Class. The selector_name  shall resolve to denote a view of a 
subprogram declared immediately w ithin the declarative region in which an ancestor of the type 
T is declared. The first formal paramete r of the subprogram shall be of type T, or a class-wide 
type that covers T, or an access parameter designating one of these types. The designator of the 
subprogram shall not be the same as that of a co mponent of the tagged type visible at the point 
of the selected_component . The subprogram shall not be an implicitly declared primitive 
operation of type T that overrides an inherited subprogram implemented by an entry or protected 
subprogram visible at the point of the selected_component . The selected_component  denotes 
a view of this subprogram that  omits the first formal parame ter. This view is called a prefixed 
view of the subprogram, and the prefix  of the selected_component  (after any implicit 
dereference) is called the prefix  of the prefixed view.  10 
11 
1 
2 
3 
4 
5 
6 
7 
8 
9 
9.1/2 
9.2/3 
Ada Reference Manual — 2012 Edition 
97      13 December 2012 Selected Components   4.1.3 An expanded name shall resolve to denote a declar ation that occurs immediately within a named 
declarative region, as follows:  
• The prefix  shall resolve to denote either a package (including the current instance of a generic 
package, or a rename of a package), or an enclosing named construct. 
• The selector_name  shall resolve to denote a declaration that occurs immediately within the 
declarative region of the package or enclosing construct (the declaration shall be visible at the place of the expanded name — see 8.3). The expanded name denotes that declaration.  
• If the 
prefix  does not denote a package, then it shall be a direct_name  or an expanded name, and 
it shall resolve to denote a program unit (other th an a package), the current instance of a type, a 
block_statement , a loop_statement , or an accept_statement  (in the case of an accept_-
statement  or entry_body , no family index is allowed); the expanded name shall occur within the 
declarative region of this construct. Further, if  this construct is a callable construct and the prefix  
denotes more than one such enclosing callable construct, then the expanded name is ambiguous, 
independently of the selector_name . 
Legality Rules 
For a subprogram whose first parameter is an access pa rameter, the prefix of any prefixed view shall 
denote an aliased view of an object. 
For a subprogram whose firs t parameter is of mode in out  or out, or of an anonymous access-to-variable 
type, the prefix of any prefixed  view shall denote a variable. 
Dynamic Semantics 
The evaluation of a selected_component  includes the evaluation of the prefix . 
For a selected_component  that denotes a component of a variant , a check is made that the values of the 
discriminants are such that the value or object denoted by the prefix  has this component. The exception 
Constraint_Error is raised  if this check fails. 
Examples 
Examples of selected components:   
  Tomorrow.Month     --   a record component  (see 3.8)  
  Next_Car.Owner     --   a record component  (see 3.10.1)  
  Next_Car.Owner.Age --   a record component  (see 3.10.1)  
                     --   the previous two lines in volve implicit dereferences  
  Writer.Unit        --   a record component (a discriminant)  (see 3.8.1)  
  Min_Cell(H).Value  --   a record component of the result  (see 6.1)  
                     --   of the function call Min_Cell(H)  
  Cashier.Append     --   a prefixed view of a procedure  (see 3.9.4)  
  Control.Seize      --   an entry of a protected object  (see 9.4)  
  Pool(K).Write      --   an entry of the task Pool(K)  (see 9.4)  
Examples of expanded names:   
  Key_Manager."<"      --   an operator of the visible part of a package  (see 7.3.1)  
  Dot_Product.Sum      --   a variable declared in a function body  (see 6.1)  
  Buffer.Pool          --   a variable declared in a protected unit  (see 9.11)  
  Buffer.Read          --   an entry of a protected unit  (see 9.11)  
  Swap.Temp            --   a variable declared in a block statement  (see 5.6)  
  Standard.Boolean     --   the name of a predefined type  (see A.1)  10 
11 
12 
13 
13.1/2 
13.2/2 
14 
15 
16 
17/2 
18 
19 
Ada Reference Manual — 2012 Edition 
4.1.4    Attributes 13 December 2012      98 4.1.4 Attributes 
An attribute  is a characteristic of an entity  that can be queried via an attribute_reference  or a range_-
attribute_reference .  
Syntax 
attribute_reference ::= prefix 'attribute_designator  
attribute_designator ::=  
    identifier [(static_ expression )] 
  | Access | Delta | Digits | Mod 
range_attribute_reference ::= prefix 'range_attribute_designator  
range_attribute_designator ::= Range[( static_ expression )] 
Name Resolution Rules 
In an attribute_reference , if the attribute_designator  is for an attribute defined for (at least some) objects 
of an access type, then the prefix  is never interpreted as an implicit_dereference ; otherwise (and for all 
range_attribute_reference s), if the type of the name  within the prefix  is of an access type, the prefix  is 
interpreted as an implicit_dereference . Similarly, if the attribute_designator  is for an attribute defined for 
(at least some) functions, then the prefix  is never interpreted as a parameterless function_call ; otherwise 
(and for all range_attribute_reference s), if the prefix  consists of a name  that denotes a function, it is 
interpreted as a parameterless function_call .  
The expression , if any, in an attribute_designator  or range_attribute_designator  is expected to be of any 
integer type.  
Legality Rules 
The expression , if any, in an attribute_designator  or range_attribute_designator  shall be static.  
Static Semantics 
An attribute_reference  denotes a value, an object, a subprogram, or some other kind of program entity. 
For an attribute_reference  that denotes a value or an object, if its type is scalar, then its nominal subtype 
is the base subtype of the type; if its type is tagged,  its nominal subtype is the first subtype of the type; 
otherwise, its nominal subtyp e is a subtype of the type without any constraint or null_exclusion . Similarly, 
unless explicitly specified otherwise, for an attribute_reference  that denotes a function, when its result 
type is scalar, its result subtype is the base subtype of the type, when its result type is tagged, the result 
subtype is the first subtype of the ty pe, and when the result type is some other type, the result subtype is a 
subtype of the type without any constraint or null_exclusion .  
A range_attribute_reference  X'Range(N) is equivalent to the range  X'First(N) .. X'Last(N), except that 
the prefix  is only evaluated once. Similarly, X'Range is equivalent to X'First .. X'Last, except that the 
prefix  is only evaluated once. 
Dynamic Semantics 
The evaluation of an attribute_reference  (or range_attribute_reference ) consists of the evaluation of the 
prefix .  1 
2 
3/2 
4 
5 
6 
7 
8 
9/3 
10 
11 
Ada Reference Manual — 2012 Edition 
99      13 December 2012 Attributes   4.1.4 Implementation Permissions 
An implementation may provide impl ementation-defined attributes; the identifier  for an implementation-
defined attribute shall differ from those of the language -defined attributes unless supplied for compatibility 
with a previous edition of th is International Standard.  
NOTES 
4  Attributes are defined throughout this International Standard, and are summarized in K.2. 
5  In general, the name  in a prefix  of an attribute_reference  (or a range_attribute_reference ) has to be resolved without 
using any context. However, in the case of the Access attribute, the expected type for the attribute_reference  has to be a 
single access type, and the resolution of the name  can use the fact that the type of the object or the profile of the callable 
entity denoted by the prefix  has to match the designated type or be type conformant with the designated profile of the 
access type.  
Examples 
Examples of attributes:   
Color'First        --  minimum value of the enumeration type Color  (see 3.5.1)  
Rainbow'Base'First --  same as Color'First  (see 3.5.1)  
Real'Digits        --  precision of the type Real  (see 3.5.7)  
Board'Last(2)      --  upper bound of the second dimension of Board  (see 3.6.1)  
Board'Range(1)     --  index range of the first dimension of Board  (see 3.6.1)  
Pool(K)'Terminated --  True if task Pool(K) is terminated  (see 9.1)  
Date'Size          --  number of bits for records of type Date  (see 3.8)  
Message'Address    --  address of the record variable Message  (see 3.7.1)  
4.1.5 User-Defined References 
Static Semantics 
Given a discriminated type T, the following type-related operational aspect may be specified: 
Implicit_Dereference 
 This aspect is specified by a name  that denotes an access discriminant declared for the type 
T. 
A (view of a) type with a specified Implicit_Dereference aspect is a reference type . A reference object  is 
an object of a reference type. The discriminant named by the Implicit_Dereference aspect is the reference 
discriminant  of the reference type or reference object. A generalized_reference  is a name  that identifies a 
reference object, and denotes the object or subprogram designated by the reference discriminant of the 
reference object. 
Syntax 
generalized_reference ::= reference_object_ name  
Name Resolution Rules 
The expected type for the reference_object_ name  in a generalized_reference  is any reference type.  
Static Semantics 
A generalized_reference  denotes a view equivalent to that of a dereference of the reference discriminant 
of the reference object. 
Given a reference type T, the Implicit_Dereference aspect is inherited by descendants of type T if not 
overridden. If a descendant type constrains th e value of the reference discriminant of T by a new 
discriminant, that new discri minant is the reference discriminant of  the descendant. If the descendant type 
constrains the value of the reference discriminant of T by an expression  other than the name  of a new 12/1 
13 
14/2 
15 
16 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
Ada Reference Manual — 2012 Edition 
4.1.5    User-Defined References 13 December 2012      100 discriminant, a generalized_reference  that identifies an object of the descendant type denotes the object 
or subprogram designated by the valu e of this constraining expression. 
Dynamic Semantics 
The evaluation of a generalized_reference  consists of the evaluation of the reference_object_ name  and a 
determination of the object or subprogram designated by  the reference discriminant of the named reference 
object. A check is made that the value of the reference discriminant is not the null access value. Constraint_Error is raised if this check fails. The 
generalized_reference  denotes the object or subprogram 
designated by the value of the reference di scriminant of the named reference object. 
Examples 
type Barrel is tagged  ...  -- holds objects of type Element  
type Ref_Element(Data : access Element) is limited private  
   with Implicit_Dereference => Data; 
      -- This Ref_Element type is a "reference" type.  
      -- "Data" is its reference discriminant.  
function  Find (B : aliased in out  Barrel; Key : String) return Ref_Element; 
   -- Return a reference to an element of a barrel.  
B: aliased Barrel; 
... Find (B, "grape") := Element'(...);  -- Assign through a reference.  
-- This is equivalent to:  
Find (B, "grape").Data. all := Element'(...); 
4.1.6 User-Defined Indexing 
Static Semantics 
Given a tagged type T, the following type-related, operational aspects may be specified: 
Constant_Indexing 
 This aspect shall be specified by a name  that denotes one or more functions declared 
immediately within the same declaration list in which T is declared. All such functions shall 
have at least two parameters, th e first of which is of type T or T'Class, or is an access-to-
constant parameter with designated type T or T'Class. 
Variable_Indexing 
 This aspect shall be specified by a name  that denotes one or more functions declared 
immediately within the same declaration list in which T is declared. All such functions shall 
have at least two parameters, th e first of which is of type T or T'Class, or is an access 
parameter with designated type T or T'Class. All such functions shall have a return type that 
is a reference type (see 4.1.5), whose reference discriminant is of an access-to-variable type.  
These aspects are inherited by descendants of T (including the class-wide type T'Class). The aspects shall 
not be overridden, but the functions they denote may be. 
An indexable container type  is (a view of) a tagged type with at least one of the aspects Constant_Indexing 
or Variable_Indexing specified. An indexable container object  is an object of an indexable container type. 
A 
generalized_indexing  is a name  that denotes the result of calling a function named by a 
Constant_Indexing or Variable_Indexing aspect. 8/3 
9/3 
10/3 
11/3 
12/3 
13/3 14/3 15/3 
1/3 
2/3 
3/3 
4/3 
5/3 
Ada Reference Manual — 2012 Edition 
101      13 December 2012 User-Defined Indexing   4.1.6 Legality Rules 
The Constant_Indexing or Variable_Indexi ng aspect shall not be specified:  
• on a derived type if the parent type has the corresponding aspect specified or inherited; or 
• on a full_type_declaration  if the type has a tagged partial view.  
In addition to the places where Legality Rules normally  apply (see 12.3), these rules apply also in the 
private part of an instance of a generic unit. 
Syntax 
generalized_indexing ::= indexable_container_object_ prefix  actual_parameter_part  
Name Resolution Rules 
The expected type for the indexable_container_object_ prefix  of a generalized_indexing  is any indexable 
container type. 
If the Constant_Indexing aspect is specified for the type of the indexable_container_object_ prefix  of a 
generalized_indexing , then the generalized_indexing  is interpreted as a constant indexing  under the 
following circumstances: 
• when the Variable_Indexing aspect is not specified for the type of the 
indexable_container_object_ prefix ; 
• when the indexable_container_object_ prefix  denotes a constant; 
• when the generalized_indexing  is used within a primary  where a name  denoting a constant is 
permitted. 
Otherwise, the generalized_indexing  is interpreted as a variable indexing . 
When a generalized_indexing  is interpreted as a constant (or variab le) indexing, it is equivalent to a call 
on a prefixed view of one of the functions named by  the Constant_Indexing (or Variable_Indexing) aspect 
of the type of the indexable_container_object_ prefix  with the given actual_parameter_part , and with the 
indexable_container_object_ prefix  as the prefix  of the prefixed view. 
Examples 
type Indexed_Barrel is tagged  ... 
  with Variable_Indexing => Find; 
  -- Indexed_Barrel is an indexable container type,  
  -- Find is the generalized indexing operation.  
function  Find (B : aliased in out  Indexed_Barrel; Key : String) return 
Ref_Element;    -- Return a reference to an element of a barrel (see 4.1.5).  
IB: aliased Indexed_Barrel; 
-- All of the following calls are then equivalent:  
Find (IB,"pear").Data. all := Element'(...); -- Traditional call  
IB.Find ("pear").Data. all := Element'(...); -- Call of prefixed view  
IB.Find ("pear")          := Element'(...); -- Implicit dereference (see 4.1.5)  
IB      ("pear")          := Element'(...); -- Implicit indexing and dereference  
IB      ("pear").Data. all := Element'(...); -- Implicit indexing only  6/3 
7/3 
8/3 9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
20/3 
21/3 
Ada Reference Manual — 2012 Edition 
4.2   Literals 13 December 2012      102 4.2 Literals 
A literal  represents a value literally, that is, by means of  notation suited to its kind. A literal is either a 
numeric_literal , a character_literal , the literal null, or a string_literal .  
Name Resolution Rules 
This paragraph was deleted.  
For a name  that consists of a character_literal , either its expected type shall be a single character type, in 
which case it is interpreted as a parameterless function_call  that yields the corresponding value of the 
character type, or its expected profile shall corres pond to a parameterless function with a character result 
type, in which case it is interpreted as the name of  the corresponding parameterless function declared as 
part of the character type's definition (see 3.5.1). In either case, the character_literal  denotes the 
enumeration_literal _specification .  
The expected type for a primary  that is a string_literal  shall be a single string type.  
Legality Rules 
A character_literal  that is a name  shall correspond to a defining_character_literal  of the expected type, or 
of the result type of the expected profile. 
For each character of a string_literal  with a given expected string type, there shall be a corresponding 
defining_character_literal  of the component type of the expected string type. 
This paragraph was deleted.  
Static Semantics 
An integer literal is of type universal_integer . A real literal is of type universal_real . The literal null is of 
type universal_access .  
Dynamic Semantics 
The evaluation of a numeric literal, or the literal null, yields the represented value. 
The evaluation of a string_literal  that is a primary  yields an array value containing the value of each 
character of the sequence of characters of the string_literal , as defined in 2.6. The bounds of this array 
value are determined according to the rules for positional_array_aggregate s (see 4.3.3), except that for a 
null string literal, the upper bound is the predecessor of the lower bound. 
For the evaluation of a string_literal  of type T, a check is made that the va lue of each character of the 
string_literal  belongs to the component subtype of T. For the evaluation of a null string literal, a check is 
made that its lower bound is greater than the lowe r bound of the base range of the index type. The 
exception Constraint_Error is raised if either of these checks fails.  
NOTES 
6  Enumeration literals that are identifier s rather than character_literal s follow the normal rules for identifier s when used in 
a name  (see 4.1 and 4.1.3). Character_literal s used as selector_name s follow the normal rules for expanded names (see 
4.1.3).  1 
2/2 
3 
4 
5 
6 
7/2 
8/2 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
103      13 December 2012 Literals   4.2 Examples 
Examples of literals:   
3.14159_26536  --   a real literal  
1_345  --   an integer literal  
'A'  --   a character literal  
"Some Text"  --   a string literal  
4.3 Aggregates 
An aggregate  combines component values into  a composite value of an array type, record type, or record 
extension.  
Syntax 
aggregate ::= record_aggregate  | extension_aggregate  | array_aggregate  
Name Resolution Rules 
The expected type for an aggregate  shall be a single array type, record type, or record extension.  
Legality Rules 
An aggregate  shall not be of a class-wide type.  
Dynamic Semantics 
For the evaluation of an aggregate , an anonymous object is created and values for the components or 
ancestor part are obtained (as described in the subsequent subclause for each kind of the aggregate ) and 
assigned into the corresponding components or ancesto r part of the anonymous object. Obtaining the 
values and the assignments occur in an  arbitrary order. The value of the aggregate  is the value of this 
object.  
If an aggregate  is of a tagged type, a check is made that its value belongs to the first subtype of the type. 
Constraint_Error is raised  if this check fails.  
4.3.1 Record Aggregates 
In a record_aggregate , a value is specified for each component of  the record or record extension value, 
using either a named or a positional association.  
Syntax 
record_aggregate ::= (record_component_association_list ) 
record_component_association_list ::=  
    record_component_association  {, record_component_association } 
  | null record  
record_component_association ::=  
    [component_choice_list  =>] expression  
   | component_choice_list  => <> 
component_choice_list ::=  
     component_ selector_name  {| component_ selector_name } 
   | others  
A record_component_association  is a named component association  if it has a 
component_choice_list ; otherwise, it is a positional component association . Any positional 13 
14 
1 
2 
3/2 
4 
5 
6 
1 
2 
3 
4/2 
5 
6 
Ada Reference Manual — 2012 Edition 
4.3.1    Record Aggregates 13 December 2012      104 component associations shall precede any named component associations. If there is a named 
association with a component_choice_list  of others , it shall come last.  
In the record_component_association_list  for a record_aggregate , if there is only one association, 
it shall be a named association.  
Name Resolution Rules 
The expected type for a record_aggregate  shall be a single record type or record extension.  
For the record_component_association_list  of a record_aggregate , all components of the composite 
value defined by the aggregate are needed ; for the association list of an extension_aggregate , only those 
components not determined by the ancestor expre ssion or subtype are needed (see 4.3.2). Each selector_-
name  in a record_component_association  shall denote a needed component (including possibly a 
discriminant).  
The expected type for the expression  of a record_component_association  is the type of the associated  
component(s); the associated component(s) are as follows:  
• For a positional association, the component (including possibly a discriminant) in the 
corresponding relative position (in the declarative re gion of the type), counting only the needed 
components;  
• For a named association with one or more component_ selector_name s, the named 
component(s); 
• For a named association with the reserved word others , all needed components that are not 
associated with some previous association.  
Legality Rules 
If the type of a record_aggregate  is a record extension, then it shall be a descendant of a record type, 
through one or more record extens ions (and no private extensions). 
The reserved words null record  may appear only if there are no components needed in a given record_-
component_association_list .  
Each record_component_association  other than an others  choice with a <> shall have at least one 
associated component, and each needed compone nt shall be associated with exactly one record_-
component_association . If a record_component_association  with an expression  has two or more 
associated components, all of them shall be of the sa me type, or all of them shall be of anonymous access 
types whose subtypes statically match.  
The value of a discriminant that governs a variant_part  P shall be given by a st atic expression, unless P is 
nested within a variant  V that is not selected by the discriminant value governing the variant_part  
enclosing V.  
A record_component_association  for a discriminant without a default_expression  shall have an 
expression  rather than <>.  
Dynamic Semantics 
The evaluation of a record_aggregate  consists of the evaluation of the record_component_association_-
list. 
For the evaluation of a record_component_association_list , any per-object constraints (see 3.8) for 
components specified in the association list are elaborated and any expression s are evaluated and 
converted to the subtype of the associated component. Any constraint elaborations and expression  7 
8/2 
9 
10 
11 
12 
13 
14 
15/3 16/3 
17/3 
17.1/2 
18 
19 
Ada Reference Manual — 2012 Edition 
105      13 December 2012 Record Aggregates   4.3.1 evaluations (and conversions) occur in an arbitrary order, except that the expression  for a discriminant is 
evaluated (and converted) prior to the elaboration of an y per-object constraint that depends on it, which in 
turn occurs prior to the evaluation and conversion of the expression  for the component with the per-object 
constraint.  
For a record_component_association  with an expression , the expression  defines the value for the 
associated component(s). For a record_component_association  with <>, if the component_declaration  
has a default_expression , that default_expression  defines the value for the associated component(s); 
otherwise, the associated component(s) are initialized  by default as for a stand-alone object of the 
component subtype (see 3.3.1). 
The expression  of a record_component_association  is evaluated (and converted) once for each 
associated component. 
NOTES 
7  For a record_aggregate  with positional associations, expressions specifying discriminant values appear first since the 
known_discriminant_part  is given first in the declaration of the type; they have to be in the same order as in the 
known_discriminant_part .  
Examples 
Example of a record aggregate with positional associations:   
(4, July, 1776)                                       --   see 3.8  
Examples of record aggregates  with named associations:   
(Day => 4, Month => July, Year => 1776) 
(Month => July, Day => 4, Year => 1776) 
(Disk, Closed, Track => 5, Cylinder => 12)            --   see 3.8.1 
(Unit => Disk, Status => Closed, Cylinder => 9, Track => 1) 
Examples of component associ ations with several choices:   
(Value => 0, Succ|Pred => new Cell'(0, null, null))  --   see 3.10.1  
 --  The allocator is eval uated twice: Succ and Pred designate different cells  
(Value => 0, Succ|Pred => <>)  --   see 3.10.1  
 --  Succ and Pred will be set to null 
Examples of record aggregates fo r tagged types (see 3.9 and 3.9.1):   
Expression'( null record ) 
Literal'(Value => 0.0) Painted_Point'(0.0, Pi/2.0, Paint => Red) 
4.3.2 Extension Aggregates 
An extension_aggregate  specifies a value for a type that is a record extension by specifying a value or 
subtype for an ancestor of the type, followed by asso ciations for any components not determined by the 
ancestor_part .  
Syntax 
extension_aggregate ::=  
    (ancestor_part  with  record_component_association_list ) 
ancestor_part ::= expression  | subtype_mark  19.1/2 
20 
21 
22 
23 
24 
25 
26 
27/2 
28 
29 
29.1/2 29.2/2 
30 
31 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
4.3.2    Extension Aggregates 13 December 2012      106 Name Resolution Rules 
The expected type for an extension_aggregate  shall be a single type that is a record extension. If the 
ancestor_part  is an expression , it is expected to be of any tagged type.  
Legality Rules 
If the ancestor_part  is a subtype_mark , it shall denote a specific tagged subtype. If the ancestor_part  is 
an expression , it shall not be dynamically tagged. The type of the extension_aggregate  shall be a 
descendant of the type of the ancestor_part  (the ancestor  type), through one or more record extensions 
(and no private extensions). If the ancestor_part  is a subtype_mark , the view of the ancestor type from 
which the type is descended (see 7.3.1)  shall not have unknown discriminants.  
If the type of the ancestor_part  is limited and at least one component is needed in the 
record_component_association_list , then the ancestor_part  shall not be:  
• a call to a function with an unconstrained result subtype; nor 
• a parenthesized or qualified expression w hose operand would violate this rule; nor 
• a conditional_expression  having at least one dependent_ expression  that would violate this rule.  
Static Semantics 
For the record_component_association_list  of an extension_aggregate , the only components needed  are 
those of the composite value defined by the aggreg ate that are not inherited from the type of the 
ancestor_part , plus any inherited discriminants if the ancestor_part  is a subtype_mark  that denotes an 
unconstrained subtype.  
Dynamic Semantics 
For the evaluation of an extension_aggregate , the record_component_association_list  is evaluated. If 
the ancestor_part  is an expression , it is also evaluated; if the ancestor_part  is a subtype_mark , the 
components of the value of the aggregate not given by the record_component_association_list  are 
initialized by default as for an object of the ancesto r type. Any implicit initializations or evaluations are 
performed in an arbitrary order, except that the expression  for a discriminant is evaluated prior to any 
other evaluation or initialization that depends on it. 
If the type of the ancestor_part  has discriminants and the ancestor_part  is not a subtype_mark  that 
denotes an unconstrained subtype, then a check is made that each discriminant determined by the 
ancestor_part  has the value specified for a corresponding discriminant, if any, either in the record_-
component_association_list , or in the derived_type_definition  for some ancestor of the type of the 
extension_aggregate . Constraint_Error is raised  if this check fails.  
NOTES 
8  If all components of the value of the extension_aggregate  are determined by the ancestor_part , then the record_-
component_association_list  is required to be simply null record . 
9  If the ancestor_part  is a subtype_mark , then its type can be abstract. If its type is controlled, then as the last step of 
evaluating the aggregate, the Initialize procedure of the ancestor type is called, unless the Initialize procedure is abstract (see 7.6).  
Examples 
Examples of extension aggregates (for types defined in 3.9.1):   
Painted_Point'(Point with Red) 
(Point'(P) with Paint => Black) 4/2 
5/3 
5.1/3 
5.2/3 
5.3/3 5.4/3 
6 
7 
8/3 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
107      13 December 2012 Extension Aggregates   4.3.2 (Expression with Left => 1.2, Right => 3.4) 
Addition'(Binop with null record ) 
             --  presuming Binop is of type Binary_Operation  
4.3.3 Array Aggregates 
In an array_aggregate , a value is specified for each component of  an array, either positionally or by its 
index. For a positional_array_aggregate , the components are given in incr easing-index order, with a final 
others , if any, representing any remaining components. For a named_array_aggregate , the components 
are identified by the values covered by the discrete_choice s. 
Syntax 
array_aggregate ::=  
  positional_array_aggregate  | named_array_aggregate  
positional_array_aggregate ::=  
    (expression , expression  {, expression }) 
  | (expression  {, expression }, others  => expression ) 
  | (expression  {, expression }, others  => <>) 
named_array_aggregate ::=  
    (array_component_association  {, array_component_association }) 
array_component_association ::=  
    discrete_choice_list  => expression  
  | discrete_choice_list  => <> 
An n-dimensional  array_aggregate  is one that is written as n levels of nested array_aggregate s (or at the 
bottom level, equivalent string_literal s). For the multidimensional case (n >= 2) the array_aggregate s (or 
equivalent string_literal s) at the n–1 lower levels are called subaggregate s of the enclosing n-dimensional 
array_aggregate . The expression s of the bottom level subaggregates (or of the array_aggregate  itself if 
one-dimensional) are called the array component expressions  of the enclosing n-dimensional 
array_aggregate .  
Name Resolution Rules 
The expected type for an array_aggregate  (that is not a subaggregate) shall be a single array type. The 
component type of this array type is the expect ed type for each array component expression of the 
array_aggregate .  
The expected type for each discrete_choice  in any discrete_choice_list  of a named_array_aggregate  is 
the type of the corresponding index ; the corresponding index for an array_aggregate  that is not a 
subaggregate is the first index of its type; fo r an (n–m)-dimensional s ubaggregate within an 
array_aggregate  of an n-dimensional type, the correspondi ng index is the index in position m+1.  
Legality Rules 
An array_aggregate  of an n-dimensional array type shall be written as an n-dimensional 
array_aggregate .  
An others  choice is allowed for an array_aggregate  only if an applicable index constraint  applies to the 
array_aggregate . An applicable index constraint is a constr aint provided by certain contexts where an 
array_aggregate  is permitted that can be used to determine the bounds of the array value specified by the 
aggregate. Each of the following contexts (and none other) defines an applicable index constraint:  
• For an explicit_actual_parameter , an explicit_generic_actual_parameter , the expression  of a 
return statement, the initialization expression in an object_declaration , or a default_expression  13 
1 
2 
3/2 
4 
5/2 
6 
7/2 
8 
9 
10 
11/2 
Ada Reference Manual — 2012 Edition 
4.3.3    Array Aggregates 13 December 2012      108 (for a parameter or a component), when the nominal subtype of the corresponding formal 
parameter, generic formal pa rameter, function return object, object, or component is a 
constrained array subtype, the applicable index constraint is the constr aint of the subtype; 
• For the expression  of an assignment_statement  where the name  denotes an array variable, the 
applicable index constraint is the constraint of the array variable;  
• For the operand of a qualified_expression  whose subtype_mark  denotes a constrained array 
subtype, the applicable index constraint  is the constraint of the subtype; 
• For a component expression  in an aggregate , if the component's nominal subtype is a 
constrained array subtype, the applicable index c onstraint is the constrai nt of the subtype;  
• For a parenthesized expression , the applicable index constraint is that, if any, defined for the 
expression ;  
• For a conditional_expression , the applicable index constraint for each dependent_ expression  is 
that, if any, defined for the conditional_expression .  
The applicable index constraint applies  to an array_aggregate  that appears in such a context, as well as to 
any subaggregates thereof. In the case of an explicit_actual_parameter  (or default_expression ) for a call 
on a generic formal subprogram, no applicab le index constraint is defined.  
The discrete_choice_list  of an array_component_association  is allowed to have a discrete_choice  that is 
a nonstatic choice_expression  or that is a subtype_indication  or range  that defines a nonstatic or null 
range, only if it is the single discrete_choice  of its discrete_choice_list , and there is only one 
array_component_association  in the array_aggregate .  
In a named_array_aggregate  where all discrete_choice s are static, no two discrete_choice s are allowed 
to cover the same value (see 3.8.1); if there is no others  choice, the discrete_choice s taken together shall 
exactly cover a contiguous sequence of va lues of the corresponding index type.  
A bottom level subaggregate of a multidimensional array_aggregate  of a given array type is allowed to be 
a string_literal  only if the component type of the array type is a character type; each character of such a 
string_literal  shall correspond to a defining_character_literal  of the component type.  
Static Semantics 
A subaggregate that is a string_literal  is equivalent to one that is a positional_array_aggregate  of the 
same length, with each expression  being the character_literal  for the corresponding character of the 
string_literal .  
Dynamic Semantics 
The evaluation of an array_aggregate  of a given array type proceeds in two steps:  
1. Any discrete_choice s of this aggregate and of its subaggregates are evaluated in an arbitrary 
order, and converted to the corresponding index type;  
2. The array component expressions of the aggregat e are evaluated in an arbitrary order and their 
values are converted to the component subtype of  the array type; an array component expression 
is evaluated once for each associated component.  
Each expression  in an array_component_association  defines the value for the associated component(s). 
For an array_component_association  with <>, the associated component (s) are initialized by default as 
for a stand-alone object of the component subtype (see 3.3.1). 
The bounds of the index range of an array_aggregate  (including a subaggregate) are determined as 
follows:  12 
13 14 
15/3 
15.1/3 
16 
17/3 
18/3 
19 
20 
21 
22 
23 
23.1/2 
24 
Ada Reference Manual — 2012 Edition 
109      13 December 2012 Array Aggregates   4.3.3 • For an array_aggregate  with an others  choice, the bounds are those of the corresponding index 
range from the applicable index constraint; 
• For a positional_array_aggregate  (or equivalent string_literal ) without an others  choice, the 
lower bound is that of the corresponding index range  in the applicable index constraint, if 
defined, or that of the corresponding index subt ype, if not; in either case, the upper bound is 
determined from the lower bound and the number of expression s (or the length of the 
string_literal ); 
• For a named_array_aggregate  without an others  choice, the bounds are determined by the 
smallest and largest index values covered by any discrete_choice_list .  
For an array_aggregate , a check is made that the index range de fined by its bounds is compatible with the 
corresponding index subtype.  
For an array_aggregate  with an others  choice, a check is made that no expression  or <> is specified for 
an index value outside the bounds determined  by the applicable index constraint.  
For a multidimensional array_aggregate , a check is made that all suba ggregates that correspond to the 
same index have the same bounds.  
The exception Constraint_Error is raised  if any of the above checks fail.  
NOTES 
10  In an array_aggregate , positional notation may only be used with two or more expression s; a single expression  in 
parentheses is interpreted as a parenthesized expression. A named_array_aggregate , such as (1 => X), may be used to 
specify an array with a single component.  
Examples 
Examples of array aggregates with positional associations:   
(7, 9, 5, 1, 3, 2, 4, 8, 6, 0) 
Table'(5, 8, 4, 1, others => 0)  --   see 3.6  
Examples of array aggregates  with named associations:   
(1 .. 5 => (1 .. 8 => 0.0))      --   two-dimensional  
(1 .. N => new Cell)             --   N new cells, in particular for N = 0  
Table'(2 | 4 | 10 => 1, others => 0) 
Schedule'(Mon .. Fri => True,  others => False)  --   see 3.6 
Schedule'(Wed | Sun  => False, others => True) 
Vector'(1 => 2.5)                                --   single-component vector  
Examples of two-dimensional array aggregates:   
-- Three aggregates for the same value of subtype Matrix(1..2,1..3) (see 3.6):  
((1.1, 1.2, 1.3), (2.1, 2.2, 2.3)) 
(1 => (1.1, 1.2, 1.3), 2 => (2.1, 2.2, 2.3)) (1 => (1 => 1.1, 2 => 1.2, 3 => 1.3), 2 => (1 => 2.1, 2 => 2.2, 3 => 2.3)) 
Examples of aggregates  as initial values:   
A : Table := (7, 9, 5, 1, 3, 2, 4, 8, 6, 0);        --  A(1)=7, A(10)=0  
B : Table := (2 | 4 | 10 => 1, others => 0);        --  B(1)=0, B(10)=1  
C : constant  Matrix := (1 .. 5 => (1 .. 8 => 0.0)); --  C'Last(1)=5, C'Last(2)=8  
D : Bit_Vector(M .. N) := (M .. N => True);         --  see 3.6 
E : Bit_Vector(M .. N) := ( others => True); 
F : String(1 .. 1) := (1 => 'F');  --  a one component aggre gate: same as "F"  25 
26 
27 
28 
29/3 
30 31 
32/3 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
Ada Reference Manual — 2012 Edition 
4.3.3    Array Aggregates 13 December 2012      110 Example of an array aggregate with defaulted ot hers choice and with an applicable index constraint 
provided by an enclosing record aggregate:  
Buffer'(Size => 50, Pos => 1, Value => String'('x', others => <>))  --  see 3.7 
4.4 Expressions 
An expression  is a formula that defines the computation or retrieval of a value. In this International 
Standard, the term “expression” refers to  a construct of the syntactic category expression  or of any of the 
following categories: choice_expression , choice_relation , relation , simple_expression , term , factor , 
primary , conditional_expression , quantified_expression .  
Syntax 
expression ::=  
     relation  {and relation }  | relation  {and then  relation } 
   | relation  {or relation }  | relation  {or else relation } 
   | relation  {xor relation } 
choice_expression ::=  
     choice_relation  {and choice_relation } 
   | choice_relation  {or choice_relation } 
   | choice_relation  {xor choice_relation } 
   | choice_relation  {and then  choice_relation } 
   | choice_relation  {or else  choice_relation } 
choice_relation ::=  
     simple_expression  [relational_operator  simple_expression ] 
relation ::=  
     simple_expression  [relational_operator  simple_expression ] 
   | simple_expression  [not] in membership_choice_list  
membership_choice_list ::= membership_choice  {| membership_choice } 
membership_choice ::= choice_expression  | range  | subtype_mark  
simple_expression ::= [unary_adding_operator ] term  {binary_adding_operator  term } 
term ::= factor  {multiplying_operator  factor } 
factor ::= primary  [** primary ] | abs primary  | not primary  
primary ::=  
   numeric_literal  | null | string_literal  | aggregate  
 | name  | allocator  | (expression ) 
 | (conditional_expression ) | (quantified_expression ) 
Name Resolution Rules 
A name  used as a primary  shall resolve to denote an object or a value.  
Static Semantics 
Each expression has a type; it specifies the comput ation or retrieval of a value of that type.  
Dynamic Semantics 
The value of a primary  that is a name  denoting an object is the value of the object.  44/2 
45/2 
1/3 
2 
2.1/3 
2.2/3 
3/3 
3.1/3 
3.2/3 
4 5 6 
7/3 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
111      13 December 2012 Expressions   4.4 Implementation Permissions 
For the evaluation of a primary  that is a name  denoting an object of an unconstrained numeric subtype, if 
the value of the object is outside the base range of its type, the implementation may either raise 
Constraint_Error or return the value of the object.  
Examples 
Examples of primaries:   
4.0                --   real literal  
Pi                 --   named number  
(1 .. 10 => 0)     --   array aggregate  
Sum                --   variable 
Integer'Last       --   attribute 
Sine(X)            --   function call  
Color'(Blue)       --   qualified expression  
Real(M*N)          --   conversion  
(Line_Count + 10)  --   parenthesized expression  
Examples of expressions:   
Volume                      --  primary 
not Destroyed               --  factor 
2*Line_Count                --  term 
-4.0                        --  simple expression  
-4.0 + A                    --  simple expression  
B**2 - 4.0*A*C              --  simple expression  
R*Sin(θ)*Cos(φ)             --  simple expression  
Password(1 .. 3) = "Bwv"    --  relation 
Count in Small_Int          --  relation 
Count not in Small_Int      --  relation 
Index = 0 or Item_Hit       --  expression  
(Cold and Sunny) or Warm    --  expression (parentheses are required)  
A**(B**C)                   --  expression (parentheses are required)  
4.5 Operators and Expression Evaluation 
The language defines the following six categories of ope rators (given in order of increasing precedence). 
The corresponding operator_symbol s, and only those, can be used as designator s in declarations of 
functions for user-defined operators. S ee 6.6, “Overloading of Operators”.  
Syntax 
logical_operator ::=   and | or  | xor 
relational_operator ::=   =   | /=  | <   | <= | > | >= 
binary_adding_operator ::=   +   | –   | & 
unary_adding_operator ::=   +   | – 
multiplying_operator ::=   *   | /   | mod  | rem 
highest_precedence_operator ::=   **  | abs | not 
Static Semantics 
For a sequence of operators of the same precedence leve l, the operators are associated with their operands 
in textual order from left to ri ght. Parentheses can be used to  impose specific associations.  
For each form of type definition, certain of the above operators are predefined ; that is, they are implicitly 
declared immediately after the type definition. For each  such implicit operator declaration, the parameters 
are called Left and Right for binary  operators; the single parameter is called Right for unary  operators. An 11 
12 
13 
14 
15/2 
1 
2 
3 4 5 6 7 
8 
9 
Ada Reference Manual — 2012 Edition 
4.5   Operators and Expression Ev aluation 13 December 2012      112 expression of the form X op Y, where op is a binary operator, is equivalent to a function_call  of the form 
"op"(X, Y). An expression of the form op Y, wher e op is a unary operator, is equivalent to a function_call  
of the form "op"(Y). The predefined  operators and their effects are de scribed in subclauses 4.5.1 through 
4.5.6.  
Dynamic Semantics 
The predefined operations on integer types either yi eld the mathematically correct result or raise the 
exception Constraint_Error. For im plementations that support the Nu merics Annex, the predefined 
operations on real types yield results whose accuracy is defined in Annex G, or raise the exception Constraint_Error.  
Implementation Requirements 
The implementation of a predefined operator that deliv ers a result of an integer or fixed point type may 
raise Constraint_Error only if the result is outside the base range of the result type. 
The implementation of a predefined operator that de livers a result of a floating point type may raise 
Constraint_Error only if the result is outside the safe range of the result type.  
Implementation Permissions 
For a sequence of predefined operators of the same  precedence level (and in the absence of parentheses 
imposing a specific association), an implementation may impose any association of the operators with operands so long as the result produced is an allowed result for the left-to-right association, but ignoring 
the potential for failure of language-defined checks in  either the left-to-right or chosen order of 
association.  
NOTES 
11  The two operands of an expression of the form X op Y, where op is a binary operator, are evaluated in an arbitrary order, as for any 
function_call  (see 6.4). 
Examples 
Examples of precedence:   
not Sunny or Warm    --   same as (not Sunny) or Warm  
X > 4.0 and Y > 0.0  --   same as (X > 4.0) and (Y > 0.0)  
-4.0*A**2            --   same as –(4.0 * (A**2))  
abs(1 + A) + B       --   same as (abs (1 + A)) + B  
Y**(-3)              --   parentheses are necessary  
A / B * C            --   same as (A/B)*C  
A + (B + C)          --   evaluate B + C before adding it to A  
4.5.1 Logical Operators and Short-circuit Control Forms 
Name Resolution Rules 
An expression  consisting of two relation s connected by and then  or or else  (a short-circuit control form ) 
shall resolve to be of some boolean type; the expected type for both relation s is that same boolean type.  
Static Semantics 
The following logical operators are predefined for every boolean type T, for every modular type T, and for 
every one-dimensional array type T whose component type is a boolean type:  
function  "and"(Left, Right : T) return T 
function  "or" (Left, Right : T) return T 
function  "xor"(Left, Right : T) return T 10 
11 
12 
13 
14 
15 
16 
17 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
113      13 December 2012 Logical Operator s and Short-circuit Control Forms   4.5.1 For boolean types, the predefined logical operators and, or, and xor perform the conventional operations 
of conjunction, inclusive disjunction, a nd exclusive disjunction, respectively. 
For modular types, the predefined logical operators are defined on a bit-by-bit basis, using the binary 
representation of the value of the operands to yiel d a binary representation for the result, where zero 
represents False and one represents  True. If this result is outside the base range of the type, a final 
subtraction by the modulus is pe rformed to bring the result into the base range of the type. 
The logical operators on arrays are performed  on a component-by-component basis on matching 
components (as for equality — see 4.5.2), using the pr edefined logical operator for the component type. 
The bounds of the resulting array are those of the left operand. 
Dynamic Semantics 
The short-circuit control forms and then  and or else  deliver the same result as the corresponding 
predefined and and or operators for boolean types, except that th e left operand is always evaluated first, 
and the right operand is not evaluated if the va lue of the left operand determines the result. 
For the logical operators on arrays, a check is made th at for each component of the left operand there is a 
matching component of the right operand, and vice vers a. Also, a check is made that each component of 
the result belongs to the component subtype. The exception Constraint_Erro r is raised if either of the 
above checks fails.  
NOTES 
12  The conventional meaning of the logical operators is given by the following truth table:  
   A   B (A and B) (A or B) (A xor B) 
  True   True   True   True   False  True   False  False  True   True  False  True   False  True   True  False  False  False  False  False 
Examples 
Examples of logical operators:   
Sunny or Warm 
Filter(1 .. 10) and Filter(15 .. 24)   --    see 3.6.1  
Examples of short-circuit control forms:   
Next_Car.Owner /= null and then Next_Car.Owner.Age > 25   --    see 3.10.1  
N = 0 or else A(N) = Hit_Value 
4.5.2 Relational Operators and Membership Tests 
The equality operators  = (equals) and /= (not equals) are pr edefined for nonlimited types. The other 
relational_operator s are the ordering operators  < (less than), <= (less than or equal), > (greater than), and 
>= (greater than or equal). The ordering operato rs are predefined for scalar types, and for discrete array 
types , that is, one-dimensional array types whos e components are of a discrete type.  
A membership test , using in or not in , determines whether or not a valu e belongs to any given subtype or 
range, is equal to any given value, has a tag that iden tifies a type that is covered by a given type, or is 
convertible to and has an accessibility level appropr iate for a given access type. Membership tests are 
allowed for all types. 4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
1 
2/3 
Ada Reference Manual — 2012 Edition 
4.5.2    Relational Operators and Membership Tests 13 December 2012      114 Name Resolution Rules 
The tested type  of a membership test is determined by the membership_choice s of the 
membership_choice_list . Either all membership_choice s of the membership_choice_list  shall resolve to 
the same type, which is the tested type; or each membership_choice  shall be of an elementary type, and 
the tested type shall be covered by each of these elementary types. 
If the tested type is tagged, then the simple_expression  shall resolve to be of a type that is convertible 
(see 4.6) to the tested type; if untagged, the expected type for the simple_expression  is the tested type. 
The expected type of a choice_expression  in a membership_choice , and of a simple_expression  of a 
range  in a membership_choice , is the tested type of the membership operation. 
Legality Rules 
For a membership test, if the simple_expression  is of a tagged class-wide type, then the tested type shall 
be (visibly) tagged.  
If a membership test includes one or more choice_expression s and the tested type of the membership test 
is limited, then the tested type of the membership test shall have a visible primitive equality operator.  
Static Semantics 
The result type of a membership test  is the predefined type Boolean. 
The equality operators are predefined for every specific type T that is not limited, and not an anonymous 
access type, with the following specifications:  
function  "=" (Left, Right : T) return Boolean 
function  "/="(Left, Right : T) return Boolean 
The following additional equality operators for the universal_access  type are declared in package Standard 
for use with anonymous access types:  
function  "=" (Left, Right : universal_access ) return Boolean 
function  "/="(Left, Right : universal_access ) return Boolean 
The ordering operators are predefined for every specific scalar type T, and for every discrete array type T, 
with the following specifications:  
function  "<" (Left, Right : T) return Boolean 
function  "<="(Left, Right : T) return Boolean 
function  ">" (Left, Right : T) return Boolean 
function  ">="(Left, Right : T) return Boolean 
Name Resolution Rules 
At least one of the operands of an equality operator for universal_access  shall be of a specific anonymous 
access type. Unless the predefined equality operato r is identified using an expanded name with prefix  
denoting the package Standard, neither operand shall be  of an access-to-object type whose designated type 
is D or D'Class, where D has a user-defined primitive equality operator such that:  
• its result type is Boolean; 
• it is declared immediately within the same declaration list as D or any partial or incomplete view 
of D; and 
• at least one of its operands is an access parameter with designated type D.  
Legality Rules 
At least one of the operands of the equality operators for universal_access  shall be of type 
universal_access , or both shall be of access-to-object type s, or both shall be of access-to-subprogram 
types. Further:  3/3 
3.1/3 
4 
4.1/3 
5 
6 
7 
7.1/2 
7.2/2 
8 
9 
9.1/2 
9.2/2 
9.3/3 
9.4/2 
9.5/2 
Ada Reference Manual — 2012 Edition 
115      13 December 2012 Relational Operators and Membership Tests   4.5.2 • When both are of access-to-object types, the designated types shall be the same or one shall 
cover the other, and if the designated types are elementary or array types, then the designated 
subtypes shall statically match; 
• When both are of access-to-subprogram types,  the designated profiles shall be subtype 
conformant.  
If the profile of an explicitly declared primitive equa lity operator of an untagged record type is type 
conformant with that of the corresponding predefined equality operator, the declaration shall occur before 
the type is frozen. In addition, if the untagged r ecord type has a nonlimited partial view, then the 
declaration shall occur in the visible part of the enclosing package. In addition to the places where 
Legality Rules normally apply (see 12.3), this rule app lies also in the private part of an instance of a 
generic unit.  
Dynamic Semantics 
For discrete types, the predefined relational operato rs are defined in terms of corresponding mathematical 
operations on the position numbers of  the values of the operands. 
For real types, the predefined relational operators are defined in terms of the corresponding mathematical 
operations on the values of the operands, subject to the accuracy of the type.  
Two access-to-object values are equal if they designate  the same object, or if both are equal to the null 
value of the access type. 
Two access-to-subprogram values are equal if they ar e the result of the same evaluation of an Access 
attribute_reference , or if both are equal to the null valu e of the access type. Two access-to-subprogram 
values are unequal if they designate different subpr ograms. It is unspecified whether two access values 
that designate the same subprogram but are th e result of distinct evaluations of Access 
attribute_reference s are equal or unequal.  
For a type extension, predefined equality is defined in  terms of the primitive (possibly user-defined) equals 
operator for the parent type and for any components th at have a record type in the extension part, and 
predefined equality for any other components not inherited from the parent type.  
For a derived type whose parent is an untagged record type, predefined equality is defined in terms of the 
primitive (possibly user-defined) equals operator of the parent type.  
For a private type, if its full type is a record type, predefined equality is defined in terms of the primitive 
equals operator of the full type; otherw ise, predefined equality for the priv ate type is that of its full type. 
For other composite types, the predefined equality operators (and certain other predefined operations on 
composite types — see 4.5.1 and 4.6) are de fined in terms of the corresponding operation on matching 
components , defined as follows:  
• For two composite objects or values of the sa me non-array type, matching components are those 
that correspond to the same component_declaration  or discriminant_specification ; 
• For two one-dimensional arrays of the same ty pe, matching components are those (if any) whose 
index values match in the following sense: the lower bounds of the index ranges are defined to 
match, and the successors of matchi ng indices are defined to match; 
• For two multidimensional arrays of the same type, matching components are those whose index 
values match in successive index positions.  
The analogous definitions apply if the types of the two objects or values are convertible, rather than being 
the same.  9.6/2 
9.7/2 
9.8/3 
10 
11 12 13 
14/3 
14.1/3 
15/3 
16 
17 
18 
19 
20 
Ada Reference Manual — 2012 Edition 
4.5.2    Relational Operators and Membership Tests 13 December 2012      116 Given the above definition of matching components, the result of the predefined equals operator for 
composite types (other than for those composite  types covered earlier) is defined as follows:  
• If there are no components, the result is defined to be True; 
• If there are unmatched components, th e result is defined to be False; 
• Otherwise, the result is defined in terms of  the primitive equals operator for any matching 
components that are records, and the predefined  equals for any other matching components.  
If the primitive equals operator for an untagged record ty pe is abstract, then Program_Error is raised at the 
point of any (implicit) call to  that abstract subprogram.  
For any composite type, the order in which "=" is calle d for components is unspecifi ed. Furthermore, if the 
result can be determined before calling "=" on some co mponents, it is unspecified whether "=" is called on 
those components. 
The predefined "/=" operator gives the compleme ntary result to the predefined "=" operator.  
For a discrete array type, the predef ined ordering operators correspond to lexicographic order  using the 
predefined order relation of the component type: A null array is lexicographically less than any array 
having at least one component. In the case of nonnull arra ys, the left operand is lexicographically less than 
the right operand if the first component of the left opera nd is less than that of the right; otherwise, the left 
operand is lexicographically less than  the right operand only if their first components are equal and the tail 
of the left operand is lexicographically  less than that of the right (the tail consists of the remaining 
components beyond the first and can be null). 
An individual membership test  is the membership test of a single membership_choice . 
For the evaluation of a membership test using in whose membership_choice_list  has a single 
membership_choice , the simple_expression  and the membership_choice  are evaluated in an arbitrary 
order; the result is the result of the individual membership test for the membership_choice . 
For the evaluation of a membership test using in whose membership_choice_list  has more than one 
membership_choice , the simple_expression  of the membership test is evaluated first and the result of the 
operation is equivalent to that of a sequence c onsisting of an individual membership test on each 
membership_choice  combined with the short-circuit control form or else . 
An individual membership test yields the result True if:  
• The membership_choice  is a choice_expression , and the simple_expression  is equal to the 
value of the membership_choice . If the tested type is a record type or a limited type, the test 
uses the primitive equality for the type; othe rwise, the test uses  predefined equality. 
• The membership_choice  is a range  and the value of the simple_expression  belongs to the 
given range . 
• The membership_choice  is a subtype_mark , the tested type is scalar, the value of the 
simple_expression  belongs to the range of the named s ubtype, and the predicate of the named 
subtype evaluates to True.  
• The membership_choice  is a subtype_mark , the tested type is not scalar, the value of the 
simple_expression  satisfies any constraints of the named subtype, the predicate of the named 
subtype evaluates to True, and:  
• if the type of the simple_expression  is class-wide, the value has a tag that identifies a type 
covered by the tested type;  21 
22 
23 
24/3 
24.1/3 
24.2/1 
25 
26/3 
26.1/3 
27/3 
27.1/3 
28/3 
28.1/3 
28.2/3 
29/3 
30/3 
30.1/2 
Ada Reference Manual — 2012 Edition 
117      13 December 2012 Relational Operators and Membership Tests   4.5.2 • if the tested type is an access type and the named subtype excludes null, the value of the 
simple_expression  is not null; 
• if the tested type is a general access-to-object type, the type of the simple_expression  is 
convertible to the tested type and its accessibility  level is no deeper than that of the tested 
type; further, if the designated type of the tested type is tagged and the simple_expression  
is nonnull, the tag of the object designated by the value of the simple_expression  is 
covered by the designated type of the tested type.  
Otherwise, the test yields the result False. 
A membership test using not in  gives the complementary result to  the corresponding membership test 
using in. 
Implementation Requirements 
For all nonlimited types declared in language-defined packages, the "=" and "/=" operators of the type 
shall behave as if they were the predefined equality operators for the purposes of the equality of composite 
types and generic formal types.  
NOTES 
This paragraph was deleted.  
13  If a composite type has components that depend on discriminants, two values of this type have matching components 
if and only if their discriminants are equal. Two nonnull arrays have matching components if and only if the length of each dimension is the same for both.  
Examples 
Examples of expressions involving re lational operators and membership tests:   
X /= Y 
"" < "A" and "A" < "Aa"     --   True 
"Aa" < "B" and "A" < "A  "  --   True 
My_Car = null               --  True if My_Car has been set to null (see 3.10.1)  
My_Car = Your_Car           --  True if we both share the same car  
My_Car.all = Your_Car. all   --  True if the two cars are identical  
N not in 1 .. 10            --  range membership test  
Today in Mon .. Fri         --  range membership test  
Today in Weekday            --  subtype membership test (see 3.5.1)  
Card in Clubs | Spades      --  list membership test (see 3.5.1)  
Archive in Disk_Unit        --  subtype membership test (see 3.8.1)  
Tree.all in Addition'Class  --  class membership test (see 3.9.1)  
4.5.3 Binary Adding Operators 
Static Semantics 
The binary adding operators + (addition) and – (subtr action) are predefined for every specific numeric 
type T with their conventional meaning. Th ey have the following specifications:  
function  "+"(Left, Right : T) return T 
function  "-"(Left, Right : T) return T 
The concatenation operators & are predefined for every nonlimited, one-dimensional array type T with 
component type C. They have the following specifications:  
function  "&"(Left : T; Right : T) return T 
function  "&"(Left : T; Right : C) return T 
function  "&"(Left : C; Right : T) return T 
function  "&"(Left : C; Right : C) return T 30.2/3 
30.3/3 
31/3 
32 
32.1/1 
33/2 
34 
35 
36 
37 
38/3 
39/3 
1 
2 
3 
4 
Ada Reference Manual — 2012 Edition 
4.5.3    Binary Adding Operator s 13 December 2012      118 Dynamic Semantics 
For the evaluation of a concatenation with result type T, if both operands are of type T, the result of the 
concatenation is a one-dimensional array whose length is  the sum of the lengths of its operands, and whose 
components comprise the components of the left operand followed by the components of the right 
operand. If the left operand is a null array, the result of  the concatenation is the right operand. Otherwise, 
the lower bound of the result is  determined as follows:  
• If the ultimate ancestor of the array type was defined by a constrained_array_definition , then 
the lower bound of the result is that of the index subtype;  
• If the ultimate ancestor of the array type was defined by an unconstrained_array_definition , 
then the lower bound of the result is that of the left operand.  
The upper bound is determined by the lower bound and the length. A check is made that the upper bound 
of the result of the concatenation belongs to the range of the index subtype, unless the result is a null array. 
Constraint_Error is raised  if this check fails. 
If either operand is of the component type C, the result of the concatenation is given by the above rules, 
using in place of such an operand an array having th is operand as its only component (converted to the 
component subtype) and having the lower bound of the i ndex subtype of the array type as its lower bound.  
The result of a concatenation is defined in terms of  an assignment to an anonymous object, as for any 
function call (see 6.5).  
NOTES 
14  As for all predefined operators on modular types, the binary adding operators + and – on modular types include a final reduction modulo the modulus if the result is outside the base range of the type.  
Examples 
Examples of expressions involving binary adding operators:   
Z + 0.1      --   Z has to be of a real type  
"A" & "BCD"  --   concatenation of two string literals  
'A' & "BCD"  --   concatenation of a char acter literal and a string literal  
'A' & 'A'    --   concatenation of two character literals  
4.5.4 Unary Adding Operators 
Static Semantics 
The unary adding operators + (identity) and – (negati on) are predefined for every specific numeric type T 
with their conventional meaning. They  have the following specifications:  
function  "+"(Right : T) return T 
function  "-"(Right : T) return T 
NOTES 
15  For modular integer types, the unary adding operator –, when given a nonzero operand, returns the result of subtracting the value of the operand from the modulus; for a zero operand, the result is zero.  
4.5.5 Multiplying Operators 
Static Semantics 
The multiplying operators * (multiplication), / (division), mod  (modulus), and rem (remainder) are 
predefined for every specific integer type T:  5 
6 
7 8 
9 
10 
11 
12 
13 
14 
1 
2 
3 
1 
Ada Reference Manual — 2012 Edition 
119      13 December 2012 Multiplying Operators   4.5.5 function  "*"  (Left, Right : T) return T 
function  "/"  (Left, Right : T) return T 
function  "mod"(Left, Right : T) return T 
function  "rem"(Left, Right : T) return T 
Signed integer multiplication has its conventional meaning. 
Signed integer division a nd remainder are defined by the relation:  
A = (A/B)*B + (A rem B) 
where (A rem B) has the sign of A and an absolute value le ss than the absolute value of B. Signed integer 
division satisfies the identity:  
(-A)/B = -(A/B) = A/(-B) 
The signed integer modulus operator is defined such that the result of A mod  B is either zero, or has the 
sign of B and an absolute value less than the absolute  value of B; in addition, for some signed integer 
value N, this result satisfies the relation:  
A = B*N + (A mod B) 
The multiplying operators on modular types are defi ned in terms of the corresponding signed integer 
operators, followed by a reduction modulo the modulus if the result is outside the base range of the type 
(which is only possible for the "*" operator).  
Multiplication and division operators are predef ined for every specific floating point type T:  
function  "*"(Left, Right : T) return T 
function  "/"(Left, Right : T) return T 
The following multiplication and division operators, with an operand of the predefined type Integer, are 
predefined for every specific fixed point type T:  
function  "*"(Left : T; Right : Integer) return T 
function  "*"(Left : Integer; Right : T) return T 
function  "/"(Left : T; Right : Integer) return T 
All of the above multiplying operators are usable w ith an operand of an appropriate universal numeric 
type. The following additional multiplying operators for root_real  are predefined, and are usable when 
both operands are of an appropriate universal or root num eric type, and the result is allowed to be of type 
root_real , as in a number_declaration :  
function  "*"(Left, Right : root_real) return root_real 
function  "/"(Left, Right : root_real) return root_real 
function  "*"(Left : root_real; Right : root_integer ) return root_real 
function  "*"(Left : root_integer ; Right : root_real) return root_real 
function  "/"(Left : root_real; Right : root_integer ) return root_real 
Multiplication and division between any two fixed point types are provided by the following two 
predefined operators:  
function  "*"(Left, Right : universal_fixed ) return universal_fixed  
function  "/"(Left, Right : universal_fixed ) return universal_fixed  
Name Resolution Rules 
The above two fixed-fixed multiplying operators shall not be used in a context where the expected type for 
the result is itself universal_fixed  — the context has to identify some other numeric type to which the 
result is to be converted, either explicitly or im plicitly. Unless the predefined universal operator is 
identified using an expanded name with prefix  denoting the package Standard, an explicit conversion is 
required on the result when using the above fixed-fixe d multiplication operator if either operand is of a 
type having a user-defined primitive multiplication operator such that:  2 
3 
4 
5 
6 
7 
8/3 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
19.1/2 
Ada Reference Manual — 2012 Edition 
4.5.5    Multiplying Operators 13 December 2012      120 • it is declared immediately within the same d eclaration list as the type or any partial or 
incomplete view thereof; and 
• both of its formal parameters are of a fixed-point type.  
A corresponding requirement applies to the universal fixed-fixe d division operator. 
Paragraph 20 was deleted.   
Dynamic Semantics 
The multiplication and division operators for real ty pes have their conventiona l meaning. For floating 
point types, the accuracy of the result is determined by the precision of the result type. For decimal fixed point types, the result is truncated toward zero if th e mathematical result is between two multiples of the 
small  of the specific result type (possibly determined by  context); for ordinary fixed point types, if the 
mathematical result is between two multiples of the small , it is unspecified which of  the two is the result.  
The exception Constraint_Error is raised by integer division, rem, and mod  if the right operand is zero. 
Similarly, for a real type T with T'Machine_Overflows True, division by  zero raises Constraint_Error.  
NOTES 
16  For positive A and B, A/B is the quotient and A rem B is the remainder when A is divided by B. The following 
relations are satisfied by the rem operator:  
     A  rem (-B) =   A rem B 
   (-A) rem   B  = -(A rem B) 
17  For any signed integer K, the following identity holds:  
   A mod B   =   (A + K*B) mod B 
The relations between signed integer division, remainder, and modulus are illustrated by the following table:  
   A      B   A/B   A rem B  A mod B     A     B    A/B   A rem B   A mod B 
   10     5    2       0        0       -10    5    -2       0         0 
   11     5    2       1        1       -11    5    -2      -1         4    12     5    2       2        2       -12    5    -2      -2         3    13     5    2       3        3       -13    5    -2      -3         2    14     5    2       4        4       -14    5    -2      -4         1 
   A      B   A/B   A rem B  A mod B     A     B    A/B   A rem B   A mod B 
    10    -5   -2       0        0       -10   -5     2       0         0    11    -5   -2       1       -4       -11   -5     2      -1        -1    12    -5   -2       2       -3       -12   -5     2      -2        -2    13    -5   -2       3       -2       -13   -5     2      -3        -3    14    -5   -2       4       -1       -14   -5     2      -4        -4 
Examples 
Examples of expressions involving multiplying operators:   
I : Integer := 1; 
J : Integer := 2; K : Integer := 3; 
X : Real := 1.0;                      --      see 3.5.7  
Y : Real := 2.0; 
F : Fraction := 0.25;                 --      see 3.5.9  
G : Fraction := 0.5; 19.2/3 
19.3/2 
19.4/2 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
Ada Reference Manual — 2012 Edition 
121      13 December 2012 Multiplying Operators   4.5.5 Expression   Value   Result Type  
 I*J             2       same as I and J, that is, Integer  
K/J             1       same as K and J, that is, Integer  
K mod  J   1       same as K and J, that is, Integer  
 X/Y             0.5     same as X and Y, that is, Real  
F/2             0.125   same as F, that is, Fraction  
 3*F             0.75    same as F, that is, Fraction  
0.75*G          0.375   universal_fixed, implicitly convertible  
                        to any fixed point type  
Fraction(F*G)    0.125   Fraction, as stated by the conversion  
Real(J)*Y       4.0     Real, the type of both operands after  
                        conversion of J  
4.5.6 Highest Precedence Operators 
Static Semantics 
The highest precedence unary operator abs (absolute value) is predefined for every specific numeric type 
T, with the following specification:  
function  "abs"(Right : T) return T 
The highest precedence unary operator not (logical negation) is predefined for every boolean type T, every 
modular type T, and for every one-dimensional array type T whose components are of a boolean type, with 
the following specification:  
function  "not"(Right : T) return T 
The result of the operator not for a modular type is defined as the difference between the high bound of 
the base range of the type and the value of the ope rand. For a binary modulus, this corresponds to a bit-
wise complement of the binary repres entation of the value of the operand. 
The operator not that applies to a one-dimensional array of  boolean components yields a one-dimensional 
boolean array with the same bounds; each component of the result is obtained by logical negation of the 
corresponding component of the operand (that is, the co mponent that has the same index value). A check 
is made that each component of the result be longs to the component subtype; the exception 
Constraint_Error is raised  if this check fails.  
The highest precedence exponentiation  operator ** is predefined for every specific integer type T with the 
following specification:  
function  "**"(Left : T; Right : Natural) return T 
Exponentiation is also predefined for ever y specific floating point type as well as root_real , with the 
following specification (where T is root_real  or the floating point type):  
function  "**"(Left : T; Right : Integer'Base) return T 
The right operand of an exponentiation is the exponent . The value of X**N with the value of the exponent 
N positive is the same as the value of X*X*...X (with  N–1 multiplications) except that the multiplications 
are associated in an arbitrary order. With N equal to  zero, the result is one. With the value of N negative 
(only defined for a floating point operand), the result is the reciprocal of the result using the absolute value 
of N as the exponent.  
Implementation Permissions 
The implementation of exponentia tion for the case of a negative exponent is allowed to raise 
Constraint_Error if the intermediate result of the rep eated multiplications is outside the safe range of the 35 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11/3 
12 
Ada Reference Manual — 2012 Edition 
4.5.6    Highest Precedence Operat ors 13 December 2012      122 type, even though the final result (after taking th e reciprocal) would not be. (The best machine 
approximation to the final result in th is case would generally be 0.0.)  
NOTES 
18  As implied by the specification given above for exponentiation of an integer type, a check is made that the exponent is not negative. Constraint_Error is raised if this check fails.  
4.5.7 Conditional Expressions 
A conditional_expression  selects for evaluation at most one of the enclosed dependent_ expression s, 
depending on a decision among the alternatives. One kind of conditional_expression  is the if_expression , 
which selects for evaluation a dependent_ expression  depending on the value of one or more 
corresponding conditions. The other kind of conditional_expression  is the case_expression , which 
selects for evaluation one of a number of alternative dependent_ expression s; the chosen alternative is 
determined by the value of a selecting_ expression .  
Syntax 
conditional_expression ::= if_expression  | case_expression  
if_expression ::=  
   if condition  then  dependent_ expression  
   {elsif condition  then  dependent_ expression } 
   [else dependent_ expression ] 
condition ::= boolean_ expression  
case_expression ::=  
    case selecting_ expression  is 
    case_expression_alternative  {, 
    case_expression_alternative } 
case_expression_alternative ::=  
    when  discrete_choice_list  => 
        dependent_ expression  
Wherever the Syntax Rules allow an expression , a conditional_expression  may be used in place of 
the expression , so long as it is immediatel y surrounded by parentheses. 
Name Resolution Rules 
If a conditional_expression  is expected to be of a type T, then each dependent_ expression  of the 
conditional_expression  is expected to be of type T. Similarly, if a conditional_expression  is expected to 
be of some class of types, then each dependent_ expression  of the conditional_expression  is subject to the 
same expectation. If a conditional_expression  shall resolve to be of a type T, then each 
dependent_ expression  shall resolve to be of type T. 
The possible types of a conditional_expression  are further determined as follows: 
• If the conditional_expression  is the operand of a type conversion, the type of the 
conditional_expression  is the target type of the conversion; otherwise, 
• If all of the dependent_ expression s are of the same type, the type of the conditional_expression  
is that type; otherwise, 
• If a dependent_ expression  is of an elementary type, the type of the conditional_expression  
shall be covered by that type; otherwise, 
• If the conditional_expression  is expected to be of type T or shall resolve to type T, then the 
conditional_expression  is of type T. 13 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 12/3 13/3 
Ada Reference Manual — 2012 Edition 
123      13 December 2012 Conditional Expressions   4.5.7 A condition  is expected to be of any boolean type.  
The expected type for the selecting_ expression  and the discrete_choice s are as for case statements (see 
5.4).  
Legality Rules 
All of the dependent_ expression s shall be convertible (see 4.6) to the type of the conditional_expression . 
If the expected type of a conditional_expression  is a specific tagged type, all of the 
dependent_ expression s of the conditional_expression  shall be dynamically tagged, or none shall be 
dynamically tagged. In this case, the conditional_expression  is dynamically tagged if all of the 
dependent_ expression s are dynamically tagged, is tag-indeterminate if all of the dependent_ expression s 
are tag-indeterminate, and is statically tagged otherwise. 
If there is no else dependent_ expression , the if_expression  shall be of a boolean type. 
All Legality Rules that apply to the discrete_choice s of a case_statement  (see 5.4) also apply to the 
discrete_choice s of a case_expression  except within an instance of a generic unit.  
Dynamic Semantics 
For the evaluation of an if_expression , the condition  specified after if, and any condition s specified after 
elsif, are evaluated in succession (treating a final else as elsif True then ), until one evaluates to True or all 
condition s are evaluated and yield False. If a condition  evaluates to True, the associated 
dependent_ expression  is evaluated, converted to the type of the if_expression , and the resulting value is 
the value of the if_expression . Otherwise (when there is no else clause), the value of the if_expression  is 
True. 
For the evaluation of a case_expression , the selecting_ expression  is first evaluated. If the value of the 
selecting_ expression  is covered by the discrete_choice_list  of some case_expression_alternative , then 
the dependent_ expression  of the case_expression_alternative  is evaluated, converted to the type of the 
case_expression , and the resulting value is the value of the case_expression . Otherwise (the value is not 
covered by any discrete_choice_list , perhaps due to being outside the base range), Constraint_Error is 
raised. 
4.5.8 Quantified Expressions 
Syntax 
quantified_expression ::= for quantifier  loop_parameter_specification  => predicate  
  | for quantifier  iterator_specification  => predicate  
quantifier ::= all | some  
predicate ::= boolean_ expression  
Wherever the Syntax Rules allow an expression , a quantified_expression  may be used in place of 
the expression , so long as it is immediatel y surrounded by parentheses. 
Name Resolution Rules 
The expected type of a quantified_expression  is any Boolean type. The predicate  in a 
quantified_expression  is expected to be of the same type.  14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
20/3 
21/3 
1/3 
2/3 
3/3 4/3 
5/3 
Ada Reference Manual — 2012 Edition 
4.5.8    Quantified Expressions 13 December 2012      124 Dynamic Semantics 
For the evaluation of a quantified_expression , the loop_parameter_specification  or iterator_specification  
is first elaborated. The evaluation of a quantified_expression  then evaluates the predicate  for each value 
of the loop parameter. These values are examined in the order specified by the 
loop_parameter_specification  (see 5.5) or iterator_specification  (see 5.5.2). 
The value of the quantified_expression  is determined as follows: 
• If the quantifier  is all, the expression is True if the evaluation of the predicate  yields True for 
each value of the loop parameter. It is  False otherwise. Evaluation of the quantified_expression  
stops when all values of the domain have been examined, or when the predicate  yields False for 
a given value. Any exception raised by evaluation of the predicate  is propagated. 
• If the quantifier  is some , the expression is True if the evaluation of the predicate  yields True for 
some value of the loop parameter. It is False otherwise. Evaluation of the quantified_expression  
stops when all values of the domain have been examined, or when the predicate  yields True for 
a given value. Any exception raised by evaluation of the predicate  is propagated. 
Examples 
The postcondition for a sorting routine on an arra y A with an index subtype T can be written: 
Post => (A'Length < 2 or else 
   (for all I in A'First .. T'Pred(A'Last) => A (I) <= A (T'Succ (I)))) 
The assertion that a positive number is compos ite (as opposed to prime) can be written: 
pragma Assert ( for some  X in 2 .. N / 2 => N mod X = 0); 
4.6 Type Conversions 
Explicit type conversions, both value conversions a nd view conversions, are allowed between closely 
related types as defined below. Th is subclause also defines rules fo r value and view conversions to a 
particular subtype of a type, both explicit one s and those implicit in other constructs.  
Syntax 
type_conversion ::=  
    subtype_mark (expression ) 
  | subtype_mark (name ) 
The target subtype  of a type_conversion  is the subtype denoted by the subtype_mark . The operand  of a 
type_conversion  is the expression  or name  within the parentheses; its type is the operand type . 
One type is convertible  to a second type if a type_conversion  with the first type as operand type and the 
second type as target type is legal according to the ru les of this subclause. Two types are convertible if 
each is convertible to the other.  
A type_conversion  whose operand is the name  of an object is called a view conversion  if both its target 
type and operand type are tagged, or if it app ears in a call as an actual parameter of mode out or in out ; 
other type_conversion s are called value conversions .  
Name Resolution Rules 
The operand of a type_conversion  is expected to be of any type.  
The operand of a view conversion is interpreted only as a name ; the operand of a value conversion is 
interpreted as an expression .  6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
13/3 
1/3 
2 
3 
4/3 
5/2 
6 
7 
Ada Reference Manual — 2012 Edition 
125      13 December 2012 Type Conversions   4.6 Legality Rules 
In a view conversion for an untagged type, the target type shall be convertible (back) to the operand type.  
Paragraphs 9 through 20 were reorganized and moved below.   
If there is a type (other than a root numeric type) that  is an ancestor of both the target type and the operand 
type, or both types are class-wide types, then at  least one of the following rules shall apply:  
• The target type shall be untagged; or 
• The operand type shall be covered by or  descended from the target type; or  
• The operand type shall be a class-wide type that covers the target type; or  
• The operand and target types sha ll both be class-wide types and the specific type associated with 
at least one of them shall be an interface type.  
If there is no type (other than a root numeric type) that is the ancestor of both the target type and the 
operand type, and they are not both class-wide ty pes, one of the following rules shall apply:  
• If the target type is a numeric type, then the operand type shall be a numeric type. 
• If the target type is an array type, then the operand type shall be an array type. Further: 
• The types shall have the same dimensionality; 
• Corresponding index types shall be convertible;  
• The component subtypes shall statically match;  
• If the component types are anonymous access types, then the accessibility level of the 
operand type shall not be statically deeper than that of the target type;  
• Neither the target type nor the operand type shall be limited;  
• If the target type of a view conversion has aliased components, then so shall the operand 
type; and  
• The operand type of a view conversion sha ll not have a tagged, private, or volatile 
subcomponent.  
• If the target type is universal_access , then the operand type shall be an access type. 
• If the target type is a general access-to-object type, then the operand type shall be universal_-
access  or an access-to-object type. Further, if the operand type is not universal_access : 
• If the target type is an access-to-variable type, then the operand type shall be an access-to-
variable type;  
• If the target designated type is tagged, then the operand designated type shall be convertible 
to the target designated type;  
• If the target designated type is not tagged, th en the designated types shall be the same, and 
either: 
• the designated subtypes shall statically match; or 
• the designated type shall be discriminate d in its full view and unconstrained in any 
partial view, and one of the designate d subtypes shall be unconstrained; 
• The accessibility level of the operand type shall not be statically deeper than that of the 
target type, unless the target type is an anonymous access type of a stand-alone object. If 
the target type is that of such a stand-alone object, the accessibility level of the operand type shall not be statically deeper than that of the declaration of the stand-alone object. In 8/2 
21/3 
21.1/2 
22 
23/2 
23.1/2 
24/3 
24.1/2 
24.2/2 
24.3/2 
24.4/2 24.5/2 24.6/2 
24.7/2 
24.8/2 
24.9/2 
24.10/2 
24.11/2 
24.12/2 
24.13/2 24.14/2 
24.15/2 
24.16/2 
24.17/3 
Ada Reference Manual — 2012 Edition 
4.6   Type Conversions 13 December 2012      126 addition to the places where Legality Rules norma lly apply (see 12.3), this rule applies also 
in the private part of an instance of a generic unit.  
• If the target type is a pool-specific access-to -object type, then the operand type shall be 
universal_access .  
• If the target type is an access-to-subprogram type, then the operand type shall be universal_-
access  or an access-to-subprogram type. Further, if the operand type is not universal_access : 
• The designated profiles shall be subtype conformant.  
• The accessibility level of the operand type shall not be statically deeper than that of the 
target type. In addition to the places where Legality Rules normally apply (see 12.3), this 
rule applies also in the private part of an instance of a generic unit. If the operand type is 
declared within a generic body, the target type  shall be declared within the generic body. 
Static Semantics 
A type_conversion  that is a value conversion denotes the value that is the result of converting the value of 
the operand to the target subtype. 
A type_conversion  that is a view conversion denotes a view of the object denoted by the operand. This 
view is a variable of the target type if the operand denotes a variable; otherwise,  it is a constant of the 
target type. 
The nominal subtype of a type_conversion  is its target subtype.  
Dynamic Semantics 
For the evaluation of a type_conversion  that is a value conversion, the operand is evaluated, and then the 
value of the operand is converted  to a corresponding  value of the target type, if any. If there is no value of 
the target type that corresponds to the operand value,  Constraint_Error is raised; this can only happen on 
conversion to a modular type, and only when the opera nd value is outside the base range of the modular 
type. Additional rules follow:  
• Numeric Type Conversion  
• If the target and the operand types are both intege r types, then the result is the value of the 
target type that corresponds to the same  mathematical integer as the operand. 
• If the target type is a decimal fixed point type , then the result is truncated (toward 0) if the 
value of the operand is not a multiple of the small  of the target type. 
• If the target type is some other real type, then  the result is within the accuracy of the target 
type (see G.2, “Numeric Performance Requireme nts”, for implementati ons that support the 
Numerics Annex).  
• If the target type is an integer type and the operand type is real, the result is rounded to the 
nearest integer (away from zero if exac tly halfway between two integers).  
• Enumeration Type Conversion  
• The result is the value of the target type with the same position number as that of the 
operand value.  
• Array Type Conversion  
• If the target subtype is a constrained array subtype, then a check is made that the length of 
each dimension of the value of the operand equals the length of the corresponding dimension of the target subtype. The bounds of the result are those of the target subtype. 24.18/2 
24.19/2 
24.20/3 
24.21/2 
25 
26/3 
27 
28 
29 
30 
31 32 
33 
34 
35 
36 
37 
Ada Reference Manual — 2012 Edition 
127      13 December 2012 Type Conversions   4.6 • If the target subtype is an unconstrained a rray subtype, then the bounds of the result are 
obtained by converting each bound of the valu e of the operand to the corresponding index 
type of the target type. For each nonnull index range, a check is made that the bounds of the 
range belong to the corresponding index subtype.  
• In either array case, the value of each com ponent of the result is that of the matching 
component of the operand value (see 4.5.2).  
• If the component types of the array types are anonymous access types, then a check is made 
that the accessibility level of the operand type is not deeper than that of the target type.  
• Composite (Non-Array) Type Conversion  
• The value of each nondiscriminant component of the result is that of the matching 
component of the operand value.  
• The tag of the result is that of the operand.  If the operand type is class-wide, a check is 
made that the tag of the operand identifies a (sp ecific) type that is covered by or descended 
from the target type.  
• For each discriminant of the target type th at corresponds to a discriminant of the operand 
type, its value is that of the corresponding discriminant of the operand value; if it 
corresponds to more than one discriminant of  the operand type, a check is made that all 
these discriminants are equal in the operand value. 
• For each discriminant of the target type that corresponds to a discriminant that is specified 
by the derived_type_definition  for some ancestor of the operand type (or if class-wide, 
some ancestor of the specific type identified by the tag of the operand), its value in the 
result is that specified by the derived_type_definition .  
• For each discriminant of the operand type th at corresponds to a discriminant that is 
specified by the derived_type_definition  for some ancestor of the target type, a check is 
made that in the operand value it equals the value specified for it. 
• For each discriminant of the result, a check is made that its value bel ongs to its subtype.  
• Access Type Conversion  
• For an access-to-object type, a check is made that the accessibility level of the operand type 
is not deeper than that of the target type, unl ess the target type is an anonymous access type 
of a stand-alone object. If the target type is that of such a stand-alone object, a check is made that the accessibility level of the opera nd type is not deeper than that of the 
declaration of the stand-alone object; then if  the check succeeds, the accessibility level of 
the target type becomes that of the operand type.  
• If the operand value is null, the result of the c onversion is the null value of the target type.  
• If the operand value is not null, then the re sult designates the same object (or subprogram) 
as is designated by the operand value, but view ed as being of the target designated subtype 
(or profile); any checks associated with eval uating a conversion to the target designated 
subtype are performed.  
After conversion of the value to the target type, if th e target subtype is constrai ned, a check is performed 
that the value satisfies this constr aint. If the target subtype excludes null, then a check is made that the 
value is not null. If predicate checks are enabled for the target subtype (see 3.2.4), a check is performed 
that the predicate of the target subtype is satisfied for the value.  
For the evaluation of a view conversion, the operand name  is evaluated, and a new view of the object 
denoted by the operand is created, whos e type is the target type; if the target type is composite, checks are 
performed as above for a value conversion. 38 
39 
39.1/2 
40 
41 
42 
43 
44 
45 
46 
47 
48/3 
49/2 
50 
51/3 
52 
Ada Reference Manual — 2012 Edition 
4.6   Type Conversions 13 December 2012      128 The properties of this new view are as follows:  
• If the target type is composite, the bounds or disc riminants (if any) of the view are as defined 
above for a value conversion; each nondiscriminant  component of the view denotes the matching 
component of the operand object; the subtype of th e view is constrained if either the target 
subtype or the operand object is constrained, or if  the target subtype is indefinite, or if the 
operand type is a descendant of the target type  and has discriminants th at were not inherited 
from the target type; 
• If the target type is tagged, then an assignmen t to the view assigns to the corresponding part of 
the object denoted by the operand; otherwise, an  assignment to the view assigns to the object, 
after converting the assigned value to the subtype of the object (which might raise 
Constraint_Error);  
• Reading the value of the view yields the resu lt of converting the value of the operand object to 
the target subtype (which might raise Constraint _Error), except if the object is of an access type 
and the view conversion is passed as an out parameter; in this latter case, the value of the 
operand object is used to initialize the formal pa rameter without checking against any constraint 
of the target subtype (see 6.4.1).  
If an Accessibility_Check fails, Program_Erro r is raised. If a predicate check fails, 
Assertions.Assertion_Error is raised. Any other check a ssociated with a conversi on raises Constraint_Error 
if it fails. 
Conversion to a type is the same as conversi on to an unconstrained subtype of the type.  
NOTES 
19  In addition to explicit type_conversion s, type conversions are performed implicitly in situations where the expected 
type and the actual type of a construct differ, as is permitted by the type resolution rules (see 8.6). For example, an integer  
literal is of the type universal_integer , and is implicitly converted when assigned to a target of some specific integer type. 
Similarly, an actual parameter of a specific tagged type is implicitly converted when the corresponding formal parameter is of a class-wide type. 
Even when the expected and actual types are the same, implicit subtype conversions are performed to adjust the array 
bounds (if any) of an operand to match the desired target subtype, or to raise Constraint_Error if the (possibly adjusted) value does not satisfy the constraints of the target subtype. 
20  A ramification of the overload resolution rules is that the operand of an (explicit) 
type_conversion  cannot be an 
allocator , an aggregate , a string_literal , a character_literal , or an attribute_reference  for an Access or Unchecked_Access 
attribute. Similarly, such an expression  enclosed by parentheses is not allowed. A qualified_expression  (see 4.7) can be 
used instead of such a type_conversion . 
21  The constraint of the target subtype has no effect for a type_conversion  of an elementary type passed as an out 
parameter. Hence, it is recommended that the first subtype be specified as the target to minimize confusion (a similar recommendation applies to renaming and generic formal in out  objects).  
Examples 
Examples of numeric type conversion:   
Real(2*J)      --  value is converted to floating point  
Integer(1.6)   --  value is 2  
Integer(-0.4)  --  value is 0  
Example of conversion between derived types:   
type A_Form is new B_Form; 
X : A_Form; 
Y : B_Form; 
X := A_Form(Y); 
Y := B_Form(X);  --  the reverse conversion  53 
54/1 
55 
56 
57/3 
58 
59 
60 
61/2 
62 
63 
64 
65 
66 
67 
68 
Ada Reference Manual — 2012 Edition 
129      13 December 2012 Type Conversions   4.6 Examples of conversions between array types:   
type Sequence is array (Integer range <>) of Integer; 
subtype Dozen is Sequence(1 .. 12); 
Ledger : array(1 .. 100) of Integer; 
Sequence(Ledger)            --  bounds are those of Ledger  
Sequence(Ledger(31 .. 42))  --  bounds are 31 and 42  
Dozen(Ledger(31 .. 42))     --  bounds are those of Dozen  
4.7 Qualified Expressions 
A qualified_expression  is used to state explicitly the type, and to  verify the subtype, of an operand that is 
either an expression  or an aggregate .  
Syntax 
qualified_expression ::=  
   subtype_mark '(expression ) | subtype_mark 'aggregate  
Name Resolution Rules 
The operand  (the expression  or aggregate ) shall resolve to be of the type determined by the subtype_-
mark , or a universal type that covers it.  
Static Semantics 
If the operand of a qualified_expression  denotes an object, the qualified_expression  denotes a constant 
view of that object. The nominal subtype of a qualified_expression  is the subtype denoted by the 
subtype_mark .  
Dynamic Semantics 
The evaluation of a qualified_expression  evaluates the operand (and if of a universal type, converts it to 
the type determined by the subtype_mark ) and checks that its value belongs to the subtype denoted by the 
subtype_mark . The exception Constraint_Error is raised if this check fails.  
NOTES 
22  When a given context does not uniquely identify an expected type, a qualified_expression  can be used to do so. In 
particular, if an overloaded name  or aggregate  is passed to an overl oaded subprogram, it might be necessary  to qualify 
the operand to resolve its type.  
Examples 
Examples of disambiguating expressions using qualification:   
type Mask is (Fix, Dec, Exp, Signif); 
type Code is (Fix, Cla, Dec, Tnz, Sub); 
Print (Mask'(Dec));  --  Dec is of type Mask  
Print (Code'(Dec));  --  Dec is of type Code  
for J in Code'(Fix) .. Code'(Dec) loop ... -- qualification needed fo r either Fix or Dec  
for J in Code range Fix .. Dec loop ...    -- qualification unnecessary  
for J in Code'(Fix) .. Dec loop ...        -- qualification unnecessary for Dec  
Dozen'(1 | 3 | 5 | 7 => 2, others => 0) -- see 4.6  
4.8 Allocators 
The evaluation of an allocator  creates an object and yields an access value that designates the object.  69 
70 
71 
1 
2 
3 
3.1/3 
4 
5 
6 
7 
8 9 
10 
1 
Ada Reference Manual — 2012 Edition 
4.8   Allocators 13 December 2012      130 Syntax 
allocator ::=  
   new [subpool_specification ] subtype_indication  
 | new [subpool_specification ] qualified_expression  
subpool_specification ::= (subpool_handle_ name ) 
For an allocator  with a subtype_indication , the subtype_indication  shall not specify a 
null_exclusion . 
Name Resolution Rules 
The expected type for an allocator  shall be a single access-to-object type with designated type D such that 
either D covers the type determined by the subtype_mark  of the subtype_indication  or qualified_-
expression , or the expected type is anonym ous and the determined type is D'Class. A 
subpool_handle_ name  is expected to be of any type desce nded from Subpool_Handle, which is the type 
used to identify a subpool, decl ared in package System.Stora ge_Pools.Subpools (see 13.11.4).  
Legality Rules 
An initialized  allocator is an allocator  with a qualified_expression . An uninitialized  allocator is one with a 
subtype_indication . In the subtype_indication  of an uninitialized allocator, a constraint  is permitted only 
if the subtype_mark  denotes an unconstrained compos ite subtype; if there is no constraint , then the 
subtype_mark  shall denote a definite subtype.  
If the type of the allocator  is an access-to-constant type, the allocator  shall be an initialized allocator.  
If a subpool_specification  is given, the type of the storage pool of  the access type shall be a descendant of 
Root_Storage_Pool_With_Subpools. 
If the designated type of the type of the allocator  is class-wide, the accessibility level of the type 
determined by the subtype_indication  or qualified_expression  shall not be statically deeper than that of 
the type of the allocator .  
If the subtype determined by the subtype_indication  or qualified_expression  of the allocator  has one or 
more access discriminants, then the accessibility level of the anonymous access type of each access 
discriminant shall not be statically deeper than that of the type of the allocator  (see 3.10.2).  
An allocator  shall not be of an access type for which the Storage_Size has been specified by a static 
expression with value zero or is defined by the language to be zero.  
If the designated type of the type of the allocator  is limited, then the allocator  shall not be used to define 
the value of an access discriminant, unless the discriminated type is immutably limited (see 7.5). 
In addition to the places where Legality Rules normally  apply (see 12.3), these rules apply also in the 
private part of an instance of a generic unit.  
Static Semantics 
If the designated type of the type of the allocator  is elementary, then the subtype of the created object is 
the designated subtype. If the designated type is com posite, then the subtype of the created object is the 
designated subtype when the designated subtype is cons trained or there is an ancestor of the designated 
type that has a constrained partial view; otherwise, the created object is constrained by its initial value 
(even if the designated subtype is  unconstrained with defaults).  2/3 
2.1/3 
2.2/3 
3/3 
4 
5/2 
5.1/3 
5.2/3 
5.3/3 
5.4/3 
5.5/3 5.6/3 
6/3 
Ada Reference Manual — 2012 Edition 
131      13 December 2012 Allocators   4.8 Dynamic Semantics 
For the evaluation of an initialized allocator, the evaluation of the qualified_expression  is performed first. 
An object of the designated type is created and the value of the qualified_expression  is converted to the 
designated subtype and assigned to the object.  
For the evaluation of an uninitialized allocator, the elaboration of the subtype_indication  is performed 
first. Then:  
• If the designated type is elementary, an object  of the designated subtype is created and any 
implicit initial value is assigned; 
• If the designated type is composite, an object of th e designated type is created with tag, if any, 
determined by the subtype_mark  of the subtype_indication . This object is then initialized by 
default (see 3.3.1) using the subtype_indication  to determine its nominal subtype. A check is 
made that the value of the object belongs to the designated subtype. Constraint_Error is raised if 
this check fails. This check and the initialization of the obj ect are performed in an arbitrary 
order. 
For any allocator , if the designated type of the type of the allocator  is class-wide, then a check is made 
that the master of the type determined by the subtype_indication , or by the tag of the value of the 
qualified_expression , includes the elaboration of the type of the allocator . If any part of the subtype 
determined by the subtype_indication  or qualified_expression  of the allocator  (or by the tag of the value 
if the type of the qualified_expression  is class-wide) has one or more access discriminants, then a check is 
made that the accessibility level of the anonymous acce ss type of each access discriminant is not deeper 
than that of the type of the allocator . Program_Error is raised if either such check fails.  
If the object to be created by an allocator  has a controlled or protected part, and the finalization of the 
collection of the type of the allocator  (see 7.6.1) has started, Program_Error is raised.  
If the object to be created by an allocator  contains any tasks, and the master of the type of the allocator  is 
completed, and all of the dependent tasks of the ma ster are terminated (see 9.3), then Program_Error is 
raised.  
If the allocator  includes a subpool_handle_ name , Constraint_Error is raised  if the subpool handle is null. 
Program_Error is raised if the subpool does not belong  (see 13.11.4) to the storage pool of the access type 
of the allocator .  
If the created object contains any tasks, they ar e activated (see 9.2). Finally, an access value that 
designates the created object is returned.  
Bounded (Run-Time) Errors 
 It is a bounded error if the finalization of th e collection of the type (see 7.6.1) of the allocator  has started. 
If the error is detected, Program_Error is raised . Otherwise, the allocation proceeds normally.  
NOTES 
23  Allocators cannot create objects of an abstract type. See 3.9.3. 
24  If any part of the created object is controlled, the initialization includes calls on corresponding Initialize or Adjust 
procedures. See 7.6. 
25  As explained in 13.11, “Storage Management”, the storage for an object allocated by an allocator  comes from a 
storage pool (possibly user defined). The exception Storage_Error is raised by an allocator  if there is not enough storage. 
Instances of Unchecked_Deallocation may be used to explicitly reclaim storage. 
26  Implementations are permitted, but not required, to provide garbage collection.  7/2 
8 
9/2 
10/2 
10.1/3 
10.2/2 
10.3/2 
10.4/3 
11 
11.1/2 
12 
13 
14 
15/3 
Ada Reference Manual — 2012 Edition 
4.8   Allocators 13 December 2012      132 Examples 
Examples of allocators:   
new Cell'(0, null, null)                          -- initialized explicitly, see 3.10.1  
new Cell'(Value => 0, Succ => null, Pred => null) -- initialized explicitly  
new Cell                                          -- not initialized  
new Matrix(1 .. 10, 1 .. 20)                      -- the bounds only are given  
new Matrix'(1 .. 10 => (1 .. 20 => 0.0))          -- initialized explicitly  
new Buffer(100)                                   -- the discriminant only is given  
new Buffer'(Size => 80, Pos => 0, Value => (1 .. 80 => 'A')) -- initialized explicitly  
Expr_Ptr'( new Literal)                  -- allocator for a ccess-to-class-wide type, see 3.9.1  
Expr_Ptr'( new Literal'(Expression with 3.5))      -- initialized explicitly  
4.9 Static Expressions and Static Subtypes 
Certain expressions of a scalar or string type are define d to be static. Similarly, certain discrete ranges are 
defined to be static, and certain scalar and stri ng subtypes are defined to be static subtypes. Static  means 
determinable at compile time, using the declared  properties or values of the program entities.  
A static expression is a scalar or string expression that is one of the following: 
• a numeric_literal ;  
• a string_literal  of a static string subtype;  
• a name  that denotes the declaration of a named number or a static constant;  
• a function_call  whose function_ name  or function_ prefix  statically denotes a static function, and 
whose actual parameters, if any (whether give n explicitly or by default), are all static 
expressions;  
• an attribute_reference  that denotes a scalar value, and whose prefix  denotes a static scalar 
subtype; 
• an attribute_reference  whose prefix  statically denotes a statically constrained array object or 
array subtype, and whose attribute_designator  is First, Last, or Length, with an optional 
dimension; 
• a type_conversion  whose subtype_mark  denotes a static scalar s ubtype, and whose operand is a 
static expression; 
• a qualified_expression  whose subtype_mark  denotes a static (scalar or string) subtype, and 
whose operand is a static expression;  
• a membership test whose simple_expression  is a static expression, and whose 
membership_choice_list  consists only of membership_choice s that are either static 
choice_expression s, static range s, or subtype_mark s that denote a static (scalar or string) 
subtype;  
• a short-circuit control form both of whose relation s are static expressions; 
• a conditional_expression  all of whose condition s, selecting_ expression s, and 
dependent_ expression s are static expressions; 
• a static expression enclosed in parentheses.  
A name  statically denotes  an entity if it denotes the entity and:  
• It is a direct_name , expanded name, or character_literal , and it denotes a declaration other than 
a renaming_declaration ; or 16 
17 
18 
19 20 
1 
2 
3 
4 5 6 
7 
8 
9 
10 
11/3 
12 
12.1/3 
13 
14 
15 
Ada Reference Manual — 2012 Edition 
133      13 December 2012 Static Expressions and Static Subtypes   4.9 • It is an attribute_reference  whose prefix  statically denotes some entity; or 
• It denotes a renaming_declaration  with a name  that statically denotes the renamed entity.  
A static function  is one of the following:  
• a predefined operator whose parameter and resu lt types are all scalar types none of which are 
descendants of formal scalar types; 
• a predefined concatenation operator whose result type is a string type; 
• an enumeration literal; 
• a language-defined attribute that is a function, if the prefix  denotes a static scalar subtype, and if 
the parameter and result types are scalar.  
In any case, a generic formal subpr ogram is not a static function. 
A static constant  is a constant view declared by a full constant declaration or an object_renaming_-
declaration  with a static nominal subtype, having a value defined by a static scalar expression or by a 
static string expression whose value has a length not exceeding the maximum length of a string_literal  in 
the implementation.  
A static range  is a range  whose bounds are static expressions, or a range_attribute_reference  that is 
equivalent to such a range . A static discrete_range  is one that is a static range or is a subtype_indication  
that defines a static scalar subtype. The base range of a scalar type is a static range, unless the type is a descendant of a formal scalar type. 
A static subtype  is either a static scalar subtype  or a static string subtype . A static scalar subtype is an 
unconstrained scalar subtype whose ty pe is not a descendant of a form al type, or a constrained scalar 
subtype formed by imposing a compa tible static constraint on a static  scalar subtype. A static string 
subtype is an unconstrained string subtype whose inde x subtype and component subtype are static, or a 
constrained string subtype formed by imposing a compatible static constrai nt on a static string subtype. In 
any case, the subtype of a generic formal object of mode in out , and the result subtype of a generic formal 
function, are not static. Also, a subtype is not static if any Dynamic_Predicate specifications apply to it.  
The different kinds of static constraint  are defined as follows:  
• A null constraint is always static; 
• A scalar constraint is static if it has no 
range_constraint , or one with a static range; 
• An index constraint is static if each discrete_range  is static, and each index subtype of the 
corresponding array type is static; 
• A discriminant constraint is static if each expression  of the constraint is static, and the subtype 
of each discriminant is static.  
In any case, the constraint of the first subtype of a scalar formal type is neither static nor null. 
A subtype is statically constrained  if it is constrained, and its c onstraint is static. An object is statically 
constrained  if its nominal subtype is statically constrai ned, or if it is a static string constant.  
Legality Rules 
An expression is statically unevaluated  if it is part of: 
• the right operand of a static short-circuit contro l form whose value is determined by its left 
operand; or 16 
17 18 
19 
20 
21 22 
23 
24 
25 
26/3 
27 
28 
29 30 
31 
31.1/2 
32 
32.1/3 
32.2/3 
Ada Reference Manual — 2012 Edition 
4.9   Static Expressions and Static  Subtypes 13 December 2012      134 • a dependent_ expression  of an if_expression  whose associated condition  is static and equals 
False; or 
• a condition  or dependent_ expression  of an if_expression  where the condition  corresponding to 
at least one preceding dependent_ expression  of the if_expression  is static and equals True; or 
• a dependent_ expression  of a case_expression  whose selecting_ expression  is static and whose 
value is not covered by the corresponding discrete_choice_list ; or 
• a choice_expression  (or a simple_expression  of a range  that occurs as a membership_choice  
of a membership_choice_list ) of a static membership test that is preceded in the enclosing 
membership_choice_list  by another item whose individua l membership test (see 4.5.2) 
statically yields True.  
A static expression is evaluated at compile time excep t when it is statically unevaluated. The compile-time 
evaluation of a static expression is performed exactly , without performing Overflow_Checks. For a static 
expression that is evaluated:  
• The expression is illegal if its evaluation fails  a language-defined check other than Overflow_-
Check. For the purposes of this  evaluation, the assertion policy is assumed to be Check. 
• If the expression is not part of a larger static e xpression and the expression is expected to be of a 
single specific type, then its value shall be within the base range of its expected type. Otherwise, 
the value may be arbitrarily large or small.  
• If the expression is of type universal_real  and its expected type is a decimal fixed point type, 
then its value shall be a multiple of the small  of the decimal type. This restriction does not apply 
if the expected type is a desce ndant of a formal scalar type (or a corresponding actual type in an 
instance).  
In addition to the places where Legality Rules normally apply (see 12.3), the above restrictions also apply 
in the private part of an instance of a generic unit. 
Implementation Requirements 
For a real static expression that is not part of a larg er static expression, and whose expected type is not a 
descendant of a formal type, the implementation shall round or truncate the value (according to the 
Machine_Rounds attribute of the expect ed type) to the nearest machine num ber of the expected type; if the 
value is exactly half-way betw een two machine numbers, the roundi ng performed is implementation-
defined. If the expected type is a descendant of a fo rmal type, or if the static expression appears in the 
body of an instance of a generic unit and the co rresponding expression is nonstatic in the corresponding 
generic body, then no special rounding or truncati ng is required — normal accuracy rules apply (see 
Annex G).  
Implementation Advice 
For a real static expression that is not part of a larg er static expression, and whose expected type is not a 
descendant of a formal type, the rounding should be the same as the default rounding for the target system.  
NOTES 
27  An expression can be static even if it occurs in a context where staticness is not required.  
28  A static (or run-time) type_conversion  from a real type to an integer type performs rounding. If the operand value is 
exactly half-way between two integers, the rounding is performed away from zero.  
Examples 
Examples of static expressions:   
1 + 1       -- 2 
abs(-10)*3  -- 30 32.3/3 
32.4/3 32.5/3 32.6/3 
33/3 
34/3 
35/2 
36/2 
37/2 
38/2 
38.1/2 
39 
40 
41 
42 
Ada Reference Manual — 2012 Edition 
135      13 December 2012 Static Expressions and Static Subtypes   4.9 Kilo : constant  := 1000; 
Mega : constant  := Kilo*Kilo;   -- 1_000_000  
Long : constant  := Float'Digits*2; 
Half_Pi    : constant  := Pi/2;           -- see 3.3.2 
Deg_To_Rad : constant  := Half_Pi/90; 
Rad_To_Deg : constant  := 1.0/Deg_To_Rad; -- equivalent to 1.0/((3.14159_26536/2)/90)  43 
44 
Ada Reference Manual — 2012 Edition 
4.9.1    Statically Matching Constraints and Subtypes 13 December 2012      136 4.9.1 Statically Matching Constraints and Subtypes 
Static Semantics 
A constraint statically matches  another constraint if:  
• both are null constraints; 
• both are static and have equal corre sponding bounds or discriminant values; 
• both are nonstatic and result from the same elaboration of a constraint  of a subtype_indication  
or the same evaluation of a range  of a discrete_subtype_definition ; or 
• both are nonstatic and come from the same formal_type_declaration .  
A subtype statically matches  another subtype of the same type if th ey have statically matching constraints, 
all predicate specifications that apply to them come from the same declarations, and, for access subtypes, either both or neither exclude null. Two anonymous access-to-object subtypes statically match if their 
designated subtypes statically match,  and either both or neither exclude null, and either both or neither are 
access-to-constant. Two anonymous access-to-subprogram s ubtypes statically match if their designated 
profiles are subtype conformant, and either both or neither exclude null.  
Two ranges of the same type statically match  if both result from the same evaluation of a 
range , or if both 
are static and have equal corresponding bounds.  
A constraint is statically compatible  with a scalar subtype if it stati cally matches the constraint of the 
subtype, or if both are static and the constraint is compatible with the s ubtype. A constraint is statically 
compatible  with an access or composite subtype if it statically matches the constraint of the subtype, or if 
the subtype is unconstrained.  
Two statically matching subtypes are statically co mpatible with each other. In addition, a subtype S1 is 
statically compatible with a subtype S2 if:  
• the constraint of S1 is statically compatible with S2, and 
• if S2 excludes null, so does S1, and 
• either:  
• all predicate specifications that apply to S2 apply also to S1, or 
• both subtypes are static, every value that satisfies the predicate of S1 also satisfies the 
predicate of S2, and it is not the case that both types each have at least one applicable 
predicate specification, predicate checks are enabled (see 11.4.2) for S2, and predicate 
checks are not enabled for S1.  1/2 
1.1/2 
1.2/2 1.3/2 
1.4/2 
2/3 
3 
4/3 
5/3 
6/3 
7/3 8/3 
9/3 
10/3 
Ada Reference Manual — 2012 Edition 
137      13 December 2012 Statements   5 5   Statements 
A statement  defines an action to be performed upon its execution. 
This clause describes the gene ral rules applicable to all statement s. Some statement s are discussed in 
later clauses: Procedure_call_statement s and return statements are described in 6, “Subprograms”. 
Entry_call_statement s, requeue_statement s, delay_statement s, accept_statement s, select_statement s, 
and abort_statement s are described in 9, “T asks and Synchronization”. Raise_statement s are described 
in 11, “Exceptions”, and code_statement s in 13. The remaining forms of statement s are presented in this 
clause.  
5.1 Simple and Compound Statements - Sequences of Statements 
A statement  is either simple or compound. A simple_statement  encloses no other statement . A 
compound_statement  can enclose simple_statement s and other compound_statement s.  
Syntax 
sequence_of_statements ::= statement  {statement } {label } 
statement ::=  
   {label } simple_statement  | {label } compound_statement  
simple_statement ::= null_statement  
   | assignment_statement  | exit_statement  
   | goto_statement  | procedure_call_statement  
   | simple_return_statement  | entry_call_statement  
   | requeue_statement  | delay_statement  
   | abort_statement  | raise_statement  
   | code_statement  
compound_statement ::=  
     if_statement  | case_statement  
   | loop_statement  | block_statement  
   | extended_return_statement  
   | accept_statement  | select_statement  
null_statement ::= null; 
label ::= <<label_ statement_identifier >> 
statement_identifier ::= direct_name  
The direct_name  of a statement_identifier  shall be an identifier  (not an operator_symbol ).  
Name Resolution Rules 
The direct_name  of a statement_identifier  shall resolve to denote its corresponding implicit declaration 
(see below).  
Legality Rules 
Distinct identifier s shall be used for all statement_identifier s that appear in the same body, including inner 
block_statement s but excluding inner program units.  1 
2/3 
1 
2/3 
3 
4/2 
5/2 
6 
7 8 9 
10 
11 
Ada Reference Manual — 2012 Edition 
5.1   Simple and Compound Statements - Sequen ces of Statements 13 December 2012      138 Static Semantics 
For each statement_identifier , there is an implicit decl aration (with the specified identifier ) at the end of 
the declarative_part  of the innermost block_statement  or body that encloses the statement_identifier . The 
implicit declarations occur in the same order as the statement_identifier s occur in the source text. If a 
usage name denotes such an implicit d eclaration, the entity it denotes is the label , loop_statement , or 
block_statement  with the given statement_identifier .  
If one or more label s end a sequence_of_statements , an implicit null_statement  follows the label s 
before any following constructs. 
Dynamic Semantics 
The execution of a null_statement  has no effect. 
A transfer of control  is the run-time action of an exit_statement , return statement, goto_statement , or 
requeue_statement , selection of a terminate_alternative , raising of an exception, or an abort, which 
causes the next action performed to be one other th an what would normally be expected from the other 
rules of the language. As explained in 7.6.1, a transfer  of control can cause the execution of constructs to 
be completed and then left, wh ich may trigger finalization. 
The execution of a sequence_of_statements  consists of the execution of the individual statement s in 
succession until the sequence_  is completed.  
NOTES 
1  A statement_identifier  that appears immediately within the declarative region of a named loop_statement  or an 
accept_statement  is nevertheless implicitly declared immediately within the declarative region of the innermost enclosing 
body or block_statement ; in other words, the expanded name for a named statement is not affected by whether the 
statement occurs inside or outside a named loop or an accept_statement  — only nesting within block_statement s is 
relevant to the form of its expanded name.  
Examples 
Examples of labeled statements:   
<<Here>> <<Ici>> <<Aqui>> <<Hier>> null; 
<<After>> X := 1; 
5.2 Assignment Statements 
An assignment_statement  replaces the current value of a variable with the result of evaluating an 
expression .  
Syntax 
assignment_statement ::=  
   variable_ name  := expression ; 
The execution of an assignment_statement  includes the evaluation of the expression  and the assignment  
of the value of the expression  into the target . An assignment operation (as opposed to an assignment_-
statement ) is performed in other contexts as well, in cluding object initialization and by-copy parameter 
passing. The target  of an assignment operation is the view of th e object to which a value is being assigned; 
the target of an assignment_statement  is the variable denoted by the variable_ name .  
Name Resolution Rules 
The variable_ name  of an assignment_statement  is expected to be of any type. The expected type for the 
expression  is the type of the target.  12 
12.1/3 
13 
14/2 
15 
16 
17 
18 
19 
1 
2 
3 
4/2 
Ada Reference Manual — 2012 Edition 
139      13 December 2012 Assignment Statements   5.2 Legality Rules 
The target denoted by the variable_ name  shall be a variable of a nonlimited type. 
If the target is of a tagged class-wide type T'Class, then the expression  shall either be dynamically tagged, 
or of type T and tag-indeterminate (see 3.9.2).  
Dynamic Semantics 
For the execution of an assignment_statement , the variable_ name  and the expression  are first evaluated 
in an arbitrary order.  
When the type of the target is class-wide:  
• If the expression  is tag-indeterminate (see 3.9.2), th en the controlling tag value for the 
expression  is the tag of the target;  
• Otherwise (the expression  is dynamically tagged), a check is made that the tag of the value of 
the expression  is the same as that of the target; if th is check fails, Constrai nt_Error is raised.  
The value of the expression  is converted to the subtype of the target. The conversion might raise an 
exception (see 4.6).  
In cases involving controlled types, the target is fina lized, and an anonymous object might be used as an 
intermediate in the assignment, as described in 7. 6.1, “Completion and Finalization”. In any case, the 
converted value of the expression  is then assigned  to the target, which consists  of the following two steps:  
• The value of the target becomes the converted value. 
• If any part of the target is controlled, its valu e is adjusted as explai ned in subclause 7.6.  
NOTES 
2  The tag of an object never changes; in particular, an assignment_statement  does not change the tag of the target. 
This paragraph was deleted.  
Examples 
Examples of assignment statements:   
Value := Max_Value - 1; 
Shade := Blue; 
Next_Frame(F)(M, N) := 2.5;        --   see 4.1.1 
U := Dot_Product(V, W);            --   see 6.3 
Writer := (Status => Open, Unit => Printer, Line_Count => 60);  --  see 3.8.1 
Next_Car. all := (72074, null);    --   see 3.10.1  
Examples involving scalar subtype conversions:   
I, J : Integer range 1 .. 10 := 5; 
K    : Integer range 1 .. 20 := 15; 
 ... 
I := J;  --   identical ranges  
K := J;  --   compatible ranges  
J := K;  --   will raise Constraint_Error if K > 10  5/2 
6 
7 
8 
9 
10 11 
12 
13 
14/3 
15 
16/2 
17 
18 
19 20 
21 
22 
23 
Ada Reference Manual — 2012 Edition 
5.2   Assignment Statements  13 December 2012      140 Examples involving array subtype conversions:   
A : String(1 .. 31); 
B : String(3 .. 33);  ... 
A := B;  --   same number of components  
A(1 .. 9)  := "tar sauce"; 
A(4 .. 12) := A(1 .. 9);  --   A(1 .. 12) = "tartar sauce"  
NOTES 
3  Notes on the examples:  Assignment_statement s are allowed even in the case of overlapping slices of the same array, 
because the variable_ name  and expression  are both evaluated before copying the value into the variable. In the above 
example, an implementation yielding A(1 .. 12) = "tartartartar" would be incorrect.  
5.3 If Statements 
An if_statement  selects for execution at most one of the enclosed sequences_of_statements , depending 
on the (truth) value of one or more corresponding condition s.  
Syntax 
if_statement ::=  
    if condition  then  
      sequence_of_statements  
   {elsif condition  then  
      sequence_of_statements } 
   [else 
      sequence_of_statements ] 
    end if; 
Paragraphs 3 and 4 were deleted.   
Dynamic Semantics 
For the execution of an if_statement , the condition  specified after if, and any condition s specified after 
elsif, are evaluated in succession (treating a final else as elsif True then ), until one evaluates to True or all 
condition s are evaluated and yield False. If a condition  evaluates to True, then the corresponding 
sequence_of_statements  is executed; otherwise, none  of them is executed.  
Examples 
Examples of if statements:   
if Month = December and Day = 31 then 
   Month := January;    Day   := 1;    Year  := Year + 1; end if; 
if Line_Too_Short then 
   raise Layout_Error; 
elsif Line_Full then 
   New_Line;    Put(Item); else 
   Put(Item); end if; 
if My_Car.Owner.Vehicle /= My_Car then            --   see 3.10.1  
   Report ("Incorrect data"); end if; 24 
25 
26 
27 
28 
1 
2 
5/3 
6 
7 
8 
9 
Ada Reference Manual — 2012 Edition 
141      13 December 2012 Case Statements   5.4 5.4 Case Statements 
A case_statement  selects for execution one of a number of alternative sequences_of_statements ; the 
chosen alternative is defined by the value of an expression.  
Syntax 
case_statement ::=  
   case selecting_ expression  is 
       case_statement_alternative  
      { case_statement_alternative } 
   end case; 
case_statement_alternative ::=  
   when  discrete_choice_list  => 
      sequence_of_statements  
Name Resolution Rules 
The selecting_ expression  is expected to be of any discrete type. The expected type for each 
discrete_choice  is the type of the selecting_ expression .  
Legality Rules 
The choice_expression s, subtype_indication s, and range s given as discrete_choice s of a 
case_statement  shall be static. A discrete_choice  others , if present, shall appear alone and in the last 
discrete_choice_list . 
The possible values of the selecting_ expression  shall be covered (see 3.8.1) as follows:  
• If the selecting_ expression  is a name  (including a type_conversion , qualified_expression , or 
function_call ) having a static and constrained nominal subtype, then each non- others  
discrete_choice  shall cover only values in that subtype that satisfy its predicate (see 3.2.4), and 
each value of that subtype that satisfies its predicate shall be covered by some discrete_choice  
(either explicitly or by others ).  
• If the type of the selecting_ expression  is root_integer , universal_integer , or a descendant of a 
formal scalar type, then the case_statement  shall have an others  discrete_choice .  
• Otherwise, each value of the base range of the type of the selecting_ expression  shall be covered 
(either explicitly or by others ).  
Two distinct discrete_choice s of a case_statement  shall not cover the same value.  
Dynamic Semantics 
For the execution of a case_statement  the selecting_ expression  is first evaluated. 
If the value of the selecting_ expression  is covered by the discrete_choice_list  of some case_statement_-
alternative , then the sequence_of_statements  of the _alternative  is executed. 
Otherwise (the value is not covered by any discrete_choice_list , perhaps due to being outside the base 
range), Constraint_Error is raised.  
NOTES 
4  The execution of a case_statement  chooses one and only one alternative. Qualification of the expression of a 
case_statement  by a static subtype can often be used to limit the number of choices that need be given explicitly.  1 
2/3 
3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10 
11/3 
12/3 
13 
14 
Ada Reference Manual — 2012 Edition 
5.4   Case Statements 13 December 2012      142 Examples 
Examples of case statements:   
case Sensor is 
   when Elevation => Record_Elevation(Sensor_Value); 
   when Azimuth => Record_Azimuth  (Sensor_Value); 
   when Distance => Record_Distance (Sensor_Value); 
   when others => null; 
end case; 
case Today is 
   when Mon => Compute_Initial_Balance; 
   when Fri => Compute_Closing_Balance; 
   when Tue .. Thu => Generate_Report(Today); 
   when Sat .. Sun => null; 
end case; 
case Bin_Number(Count) is 
   when 1 => Update_Bin(1); 
   when 2 => Update_Bin(2); 
   when 3 | 4 => 
      Empty_Bin(1);       Empty_Bin(2);    when others => raise Error; 
end case; 
5.5 Loop Statements 
A loop_statement  includes a sequence_of_statements  that is to be executed repeatedly, zero or more 
times.  
Syntax 
loop_statement ::=  
   [loop_ statement_identifier :] 
      [iteration_scheme ] loop 
         sequence_of_statements  
       end loop [loop_ identifier ]; 
iteration_scheme ::= while  condition  
   | for loop_parameter_specification  
   | for iterator_specification  
loop_parameter_specification ::=  
   defining_identifier  in [reverse ] discrete_subtype_definition  
If a loop_statement  has a loop_ statement_identifier , then the identifier  shall be repeated after the 
end loop ; otherwise, there shall not be an identifier  after the end loop .  
Static Semantics 
A loop_parameter_specification  declares a loop parameter , which is an object w hose subtype is that 
defined by the discrete_subtype_definition .  
Dynamic Semantics 
For the execution of a loop_statement , the sequence_of_statements  is executed repeatedly, zero or more 
times, until the loop_statement  is complete. The loop_statement  is complete when a transfer of control 
occurs that transfers control out of  the loop, or, in the case of an iteration_scheme , as specified below. 15 
16 
17 
18 
1 
2 
3/3 
4 
5 
6 
7 
Ada Reference Manual — 2012 Edition 
143      13 December 2012 Loop Statements   5.5 For the execution of a loop_statement  with a while  iteration_scheme , the condition is evaluated before 
each execution of the sequence_of_statements ; if the value of the condition  is True, the sequence_of_-
statements  is executed; if False, the execution of the loop_statement  is complete. 
For the execution of a loop_statement  with the iteration_scheme  being for loop_parameter_-
specification , the loop_parameter_specification  is first elaborated. This elaboration creates the loop 
parameter and elaborates the discrete_subtype_definition . If the discrete_subtype_definition  defines a 
subtype with a null range, the execution of the loop_statement  is complete. Otherwise, the 
sequence_of_statements  is executed once for each value of the discrete subtype defined by the 
discrete_subtype_definition  that satisfies the predicate of the subtype (or until the loop is left as a 
consequence of a transfer of control). Prior to each such iteration, the corresponding value of the discrete 
subtype is assigned to the loop parameter. These values are assigned in increasing order unless the 
reserved word reverse  is present, in which case the values are assigned in decreasing order.  
For details about the execution of a loop_statement  with the iteration_scheme  being for 
iterator_specification , see 5.5.2. 
NOTES 
5  A loop parameter is a constant; it cannot be updated within the sequence_of_statements  of the loop (see 3.3). 
6  An object_declaration  should not be given for a loop parameter, since the loop parameter is automatically declared by 
the loop_parameter_s pecification . The scope of a loop parameter extends from the loop_parameter_s pecification  to the 
end of the loop_statement , and the visibility rules are such that a loop parameter is only visible within the 
sequence_of_statements  of the loop.  
7  The discrete_subtype_definition  of a for loop is elaborated just once. Use of the reserved word reverse  does not alter 
the discrete subtype defined, so that the following iteration_scheme s are not equivalent; the first has a null range.  
for J in reverse 1 .. 0 
for J in 0 .. 1 
Examples 
Example of a loop statement without an iteration scheme:   
loop 
   Get(Current_Character);    exit when Current_Character = '*'; 
end loop; 
Example of a loop statement with a while  iteration scheme:   
while Bid(N).Price < Cut_Off.Price loop 
   Record_Bid(Bid(N).Price);    N := N + 1; end loop; 
Example of a loop statement with a for iteration scheme:   
for J in Buffer'Range loop     --   works even with a null range  
   if Buffer(J) /= Space then 
      Put(Buffer(J));    end if; 
end loop; 
Example of a loop statement with a name:   
Summation: 
   while Next /= Head loop       --  see 3.10.1 
      Sum  := Sum + Next.Value;       Next := Next.Succ;    end loop Summation; 8 
9/3 
9.1/3 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
Ada Reference Manual — 2012 Edition 
5.5.1    User-Defined Iterator Types 13 December 2012      144 5.5.1 User-Defined Iterator Types 
Static Semantics 
The following language-defined gene ric library package exists:  
generic 
   type Cursor; 
   with function  Has_Element (Position : Cursor) return Boolean; 
package Ada.Iterator_Interfaces is 
   pragma Pure (Iterator_Interfaces); 
   type Forward_Iterator is limited interface ; 
   function  First (Object : Forward_Iterator) return Cursor is abstract ; 
   function  Next (Object : Forward_Iterator; Position : Cursor) 
      return Cursor is abstract ; 
   type Reversible_Iterator is limited interface and  Forward_Iterator; 
   function  Last (Object : Reversible_Iterator) return Cursor is abstract ; 
   function  Previous (Object : Reversible_Iterator; Position : Cursor) 
      return Cursor is abstract ; 
end Ada.Iterator_Interfaces; 
An iterator type  is a type descended from the Forward_Iterator interface from some instance of 
Ada.Iterator_Interfaces. A reversible iterator type  is a type descended from the Reversible_Iterator 
interface from some instance of Ada.Iterator_Interfaces. An iterator object  is an object of an iterator type. 
A reversible iterator object  is an object of a reversible iterator type. The formal subtype Cursor from the 
associated instance of Ada.Iterator_Interfaces is the iteration cursor subtype  for the iterator type. 
The following type-related operational aspects may be  specified for an indexable container type T (see 
4.1.6): 
Default_Iterator 
 This aspect is specified by a name  that denotes exactly one function declared immediately 
within the same declaration list in which T is declared, whose firs t parameter is of type T or 
T'Class or an access parameter whose designated type is type T or T'Class, whose other 
parameters, if any, have default expressions, a nd whose result type is an iterator type. This 
function is the default iterator function  for T. Its result subtype is the default iterator 
subtype  for T. The iteration cursor subtype for th e default iterator subtype is the default 
cursor subtype  for T. 
Iterator_Element 
 This aspect is specified by a name  that denotes a subtype. This is the default element 
subtype  for T. 
These aspects are inherited by descendants of type T (including T'Class). 
An iterable container type  is an indexable container type w ith specified Default_Iterator and 
Iterator_Element aspects. A reversible iterable container type  is an iterable container type with the default 
iterator type being a reversible iterator type. An iterable container object  is an object of an iterable 
container type. A reversible iterable container object  is an object of a reversible iterable container type. 
Legality Rules 
The Constant_Indexing aspect (if any) of an iterable container type T shall denote exactly one function 
with the following properties: 
• the result type of the function is covered by the default element type of T or is a reference type 
(see 4.1.5) with an access discriminant designating a type covered by the default element type of 
T; 1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
13/3 
Ada Reference Manual — 2012 Edition 
145      13 December 2012 User-Defined Iterator Types   5.5.1 • the type of the second parameter of the f unction covers the default cursor type for T; 
• if there are more than two parameters, the a dditional parameters all ha ve default expressions. 
This function (if any) is the default constant indexing function  for T. 
The Variable_Indexing aspect (if any) of an iterable container type T shall denote exactly one function 
with the following properties: 
• the result type of the function is a reference type (see 4.1.5) with an access discriminant 
designating a type covered by the default element type of T; 
• the type of the second parameter of the f unction covers the default cursor type for T; 
• if there are more than two parameters, the a dditional parameters all ha ve default expressions. 
This function (if any) is the default variable indexing function  for T. 
5.5.2 Generalized Loop Iteration 
Generalized forms of loop iteration are provided by an iterator_specification .  
Syntax 
iterator_specification ::=  
    defining_identifier  in [reverse ] iterator_ name  
  | defining_identifier  [: subtype_indication ] of [reverse ] iterable_ name  
Name Resolution Rules 
For the first form of iterator_specification , called a generalized iterator , the expected type for the 
iterator_ name  is any iterator type. For the second form of iterator_specification , the expected type for the 
iterable_ name  is any array or iterable container type. If the iterable_ name  denotes an array object, the 
iterator_specification  is called an array component iterator ; otherwise it is called a container element 
iterator .  
Legality Rules 
If the reserved word reverse  appears, the iterator_specification  is a reverse iterator ; otherwise it is a 
forward iterator . In a reverse generalized iterator, the iterator_ name  shall be of a reversible iterator type. 
In a reverse container element iterator, the default iterator type for the type of the iterable_ name  shall be a 
reversible iterator type. 
The type of the subtype_indication , if any, of an array component ite rator shall cover the component type 
of the type of the iterable_ name . The type of the subtype_indication , if any, of a container element 
iterator shall cover the default element type for the type of the iterable_ name . 
In a container element iterator whose iterable_ name  has type T, if the iterable_ name  denotes a constant 
or the Variable_Indexing aspect is not specified for T, then the Constant_Indexing aspect shall be specified 
for T. 
Static Semantics 
An iterator_specification  declares a loop parameter . In a generalized iterator, the nominal subtype of the 
loop parameter is the iteration cursor subtype. In an array component iterator or a container element 
iterator, if a subtype_indication  is present, it determines  the nominal subtype of the loop parameter. In an 
array component iterator, if a subtype_indication  is not present, the nominal subtype of the loop parameter 
is the component subtype of the type of the iterable_ name . In a container element iterator, if a 14/3 
15/3 16/3 
17/3 
18/3 
19/3 
20/3 21/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
Ada Reference Manual — 2012 Edition 
5.5.2    Generalized Loop Iteration 13 December 2012      146 subtype_indication  is not present, the nominal subtype of the loop parameter is the default element 
subtype for the type of the iterable_ name . 
In a generalized iterator, the loop parameter is a constant. In an array component iterator, the loop 
parameter is a constant if the iterable_ name  denotes a constant; otherwis e it denotes a variable. In a 
container element iterator, the loop parameter is a constant if the iterable_ name  denotes a constant, or if 
the Variable_Indexing aspect is not specified for the type of the iterable_ name ; otherwise it is a variable. 
Dynamic Semantics 
For the execution of a loop_statement  with an iterator_specification , the iterator_specification  is first 
elaborated. This elaboration elaborates the subtype_indication , if any. 
For a generalized iterator, the loop parameter is created, the iterator_ name  is evaluated, and the denoted 
iterator object becomes the loop iterator . In a forward generalized iterator, the operation First of the 
iterator type is called on the loop iterator, to produce the initial value for the loop parameter. If the result 
of calling Has_Element on the initial value is False, then the execution of the loop_statement  is complete. 
Otherwise, the sequence_of_statements  is executed and then the Next operation of the iterator type is 
called with the loop iterator and the current value of the loop parameter to produce the next value to be 
assigned to the loop parameter. This repeats until th e result of calling Has_Element on the loop parameter 
is False, or the loop is left as a c onsequence of a transfer of control. For a reverse generalized iterator, the 
operations Last and Previous are called rather than First and Next. 
For an array component iterator, the iterable_ name  is evaluated and the denoted array object becomes the 
array for the loop . If the array for the loop is a null array, then the execution of the loop_statement  is 
complete. Otherwise, the sequence_of_statements  is executed with the loop parameter denoting each 
component of the array for the loop, using a canonical  order of components, wh ich is last dimension 
varying fastest (unless the array has convention Fortran, in which case it is  first dimension varying fastest). 
For a forward array component iterator, the iteration starts with the component  whose index values are 
each the first in their index range, and continues in  the canonical order. For a reverse array component 
iterator, the iteration starts with th e component whose index values are each the last in their index range, 
and continues in the reverse of the canonical  order. The loop iteration proceeds until the 
sequence_of_statements  has been executed for each component of the array for the loop, or until the 
loop is left as a consequence of a transfer of control. 
For a container element iterator, the iterable_ name  is evaluated and the denoted iterable container object 
becomes the iterable container object for the loop . The default iterator function for the type of the iterable 
container object for the loop is called on the ite rable container object and the result is the loop iterator . An 
object of the default cursor subtype is created (the loop cursor ). 
For a forward container element iterator, the operati on First of the iterator type is called on the loop 
iterator, to produce the initial value for the loop curs or. If the result of calling Has_Element on the initial 
value is False, then the execution of the loop_statement  is complete. Otherwise, the 
sequence_of_statements  is executed with the loop parameter de noting an indexing (see 4.1.6) into the 
iterable container object for the loop, with the only pa rameter to the indexing being the current value of 
the loop cursor; then the Next operation of the iterato r type is called with the loop iterator and the loop 
cursor to produce the next value to be assigned to the loop cursor. This repeats until the result of calling 
Has_Element on the loop cursor is False, or until the loop is left as a consequence of a transfer of control. 
For a reverse container element iterator, the operations Last and Previous are called rather than First and 
Next. If the loop parameter is a cons tant (see above), then the indexing uses the default constant indexing 
function for the type of the iterable container object for the loop; otherwise it us es the default variable 
indexing function. 8/3 
9/3 
10/3 
11/3 
12/3 
13/3 
Ada Reference Manual — 2012 Edition 
147      13 December 2012 Generalized Loop Iteration   5.5.2 Examples 
-- Array component iterator example:  
for Element of Board loop  -- See 3.6.1. 
   Element := Element * 2.0; -- Double each element of Board, a two-dimensional array.  
end loop ; 
For examples of use of generali zed iterators, see A.18.32 and the co rresponding container packages in 
A.18.2 and A.18.3.  
5.6 Block Statements 
A block_statement  encloses a handled_sequence_of_statements  optionally preceded by a 
declarative_part .  
Syntax 
block_statement ::=  
   [block_ statement_identifier :] 
       [ declare  
            declarative_part ] 
        begin  
            handled_sequence_of_statements  
        end [block_ identifier ]; 
If a block_statement  has a block_ statement_identifier , then the identifier  shall be repeated after the 
end; otherwise, there shall not be an identifier  after the end.  
Static Semantics 
A block_statement  that has no explicit declarative_part  has an implicit empty declarative_part .  
Dynamic Semantics 
The execution of a block_statement  consists of the elaboration of its declarative_part  followed by the 
execution of its handled_sequence_of_statements .  
Examples 
Example of a block statement with a local variable:   
Swap: 
   declare 
      Temp : Integer;    begin 
      Temp := V; V := U; U := Temp;    end Swap; 
5.7 Exit Statements 
An exit_statement  is used to complete the execution of an enclosing loop_statement ; the completion is 
conditional if the exit_statement  includes a condition .  
Syntax 
exit_statement ::=  
   exit [loop_ name ] [when  condition ]; 
Name Resolution Rules 
The loop_ name , if any, in an exit_statement  shall resolve to denote a loop_statement .  14/3 
15/3 
1 
2 
3 
4 
5 
6 
7 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
5.7   Exit Statements 13 December 2012      148 Legality Rules 
Each exit_statement  applies to  a loop_statement ; this is the loop_statement  being exited. An exit_-
statement  with a name  is only allowed within the loop_statement  denoted by the name , and applies to 
that loop_statement . An exit_statement  without a name  is only allowed within a loop_statement , and 
applies to the innermost enclosing one. An exit_statement  that applies to a given loop_statement  shall not 
appear within a body or accept_statement , if this construct is its elf enclosed by the given 
loop_statement .  
Dynamic Semantics 
For the execution of an exit_statement , the condition , if present, is first eval uated. If the value of the 
condition  is True, or if there is no condition , a transfer of control is done to complete the loop_statement . 
If the value of the condition  is False, no transfer of control takes place.  
NOTES 
8  Several nested loops can be exited by an exit_statement  that names the outer loop.  
Examples 
Examples of loops w ith exit statements:   
for N in 1 .. Max_Num_Items loop 
   Get_New_Item(New_Item);    Merge_Item(New_Item, Storage_File);    exit when New_Item = Terminal_Item; 
end loop; 
Main_Cycle: 
   loop 
      --   initial statements  
      exit Main_Cycle when Found; 
      --   final statements  
   end loop Main_Cycle; 
5.8 Goto Statements 
A goto_statement  specifies an explicit transfer of control from this statement  to a target statement with a 
given label.  
Syntax 
goto_statement ::= goto label_ name ; 
Name Resolution Rules 
The label_ name  shall resolve to denote a label ; the statement  with that label  is the target statement .  
Legality Rules 
The innermost sequence_of_statements  that encloses the target statement shall also enclose the 
goto_statement . Furthermore, if a goto_statement  is enclosed by an accept_statement  or a body, then 
the target statement shall not be out side this enclosing construct.  
Dynamic Semantics 
The execution of a goto_statement  transfers control to the target statement, completing the execution of 
any compound_statement  that encloses the goto_statement  but does not enclose the target.  
NOTES 
9  The above rules allow transfer of control to a statement  of an enclosing sequence_of_statements  but not the reverse. 
Similarly, they prohibit transfers of control such as between alternatives of a case_statement , if_statement , or 4 
5 
6 
7 
8 
9 
1 
2 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
149      13 December 2012 Goto Statements   5.8 select_statement ; between exception_handler s; or from an exception_handler  of a handled_sequence_of_statements  
back to its sequence_of_statements .  
Examples 
Example of a loop containing a goto statement:   
<<Sort>> 
for I in 1 .. N-1 loop 
   if A(I) > A(I+1) then 
      Exchange(A(I), A(I+1));       goto Sort; 
   end if; 
end loop; 7 
8 

Ada Reference Manual — 2012 Edition 
151      13 December 2012 Subprograms   6 6   Subprograms 
A subprogram is a program unit or intrinsic operati on whose execution is invoked by a subprogram call. 
There are two forms of subprogram: procedur es and functions. A procedure call is a statement ; a function 
call is an expression and returns a value. The defin ition of a subprogram can be given in two parts: a 
subprogram declaration defining its interface, and a subprogram_body  defining its execution. Operators 
and enumeration literals are functions.  
A callable entity  is a subprogram or entry (see Secti on 9). A callable entity is invoked by a call; that is, a 
subprogram call or entry call. A callable construct  is a construct that defines the action of a call upon a 
callable entity: a subprogram_body , entry_body , or accept_statement .  
6.1 Subprogram Declarations 
A subprogram_declaration  declares a procedure or function.  
Syntax 
subprogram_declaration ::=  
    [overriding_indicator ] 
    subprogram_specification  
        [ aspect_specification ]; 
This paragraph was deleted.  
subprogram_specification ::=  
    procedure_specification  
  | function_specification  
procedure_specification ::= procedure  defining_program_unit_name  parameter_profile  
function_specification ::= function  defining_designator  parameter_and_result_profile  
designator ::= [parent_unit_name  . ]identifier  | operator_symbol  
defining_designator ::= defining_program_unit_name  | defining_operator_symbol  
defining_program_unit_name ::= [parent_unit_name  . ]defining_identifier  
The optional parent_unit_name  is only allowed for library units (see 10.1.1).  
operator_symbol ::= string_literal  
The sequence of characters in an operator_symbol  shall form a reserved word, a delimiter, or 
compound delimiter that corresponds to an operator belonging to one of the six categories of 
operators defined in subclause 4.5. 
defining_operator_symbol ::= operator_symbol  
parameter_profile ::= [formal_part ] 
parameter_and_result_profile ::=  
    [formal_part ] return  [null_exclusion ] subtype_mark  
  | [formal_part ] return  access_definition  
formal_part ::=  
   (parameter_specification  {; parameter_specification }) 
parameter_specification ::=  
    defining_identifier_list  : [aliased ] mode  [null_exclusion ] subtype_mark  [:= default_expression ] 
  | defining_identifier_list  : access_definition  [:= default_expression ] 1 
2/3 
1 
2/3 
3/2 
4/2 
4.1/2 
4.2/2 
5 6 7 8 9 
10/3 
11 
12 
13/2 
14 
15/3 
Ada Reference Manual — 2012 Edition 
6.1   Subprogram Declarations  13 December 2012      152 mode ::= [in] | in out | out 
Name Resolution Rules 
A formal parameter  is an object directly visible within a subprogram_body  that represents the actual 
parameter passed to the subprogram in a call; it is declared by a parameter_specification . For a formal 
parameter, the expected type for its default_expression , if any, is that of the formal parameter.  
Legality Rules 
The parameter mode  of a formal parameter conveys the directi on of information transfer with the actual 
parameter: in, in out , or out. Mode in is the default, and is the mode  of a parameter defined by an 
access_definition .  
A default_expression  is only allowed in a parameter_specification  for a formal parameter of mode in. 
A subprogram_declaration  or a generic_subprogram_declaration  requires a completion unless the 
Import aspect (see B.1) is True  for the declaration; the completion shall be a body or a 
renaming_declaration  (see 8.5). A completion is not allowed for an abstract_subprogram_declaration  
(see 3.9.3), a null_procedure_declaration  (see 6.7), or an expression_function_declaration  (see 6.8).  
A name  that denotes a formal parameter is not allowed within the formal_part  in which it is declared, nor 
within the formal_part  of a corresponding body or accept_statement .  
Static Semantics 
The profile  of (a view of) a callable entity is either a parameter_profile  or parameter_and_result_profile ; 
it embodies information about the interface to that en tity — for example, the profile includes information 
about parameters passed to the callable entity. All ca llable entities have a profile — enumeration literals, 
other subprograms, and entries. An access-to-subprogram type has a designated profile. Associated with a 
profile is a calling convention. A subprogram_declaration  declares a procedure or a function, as indicated 
by the initial reserved word, with name a nd profile as given by its specification. 
The nominal subtype of a formal parameter is the subtype determined by the optional null_exclusion  and 
the subtype_mark , or defined by the access_definition , in the parameter_specification . The nominal 
subtype of a function result is the subtype determined by the optional null_exclusion  and the 
subtype_mark , or defined by the access_definition , in the parameter_and_result_profile .  
An explicitly aliased parameter  is a formal parameter whose parameter_specification  includes the 
reserved word aliased . 
An access parameter  is a formal in parameter specified by an access_definition . An access result type  is a 
function result type specified by an access_definition . An access parameter or result type is of an 
anonymous access type (see 3.10). Access parameters of  an access-to-object type allow dispatching calls 
to be controlled by access values. Access parameters  of an access-to-subprogram type permit calls to 
subprograms passed as parameters irre spective of their accessibility level. 
The subtypes of a profile  are:  
• For any non-access parameters, the nominal subtype of the parameter. 
• For any access parameters of an access-to-object type, the designated subtype of the parameter 
type. 
• For any access parameters of an access-to-subpr ogram type, the subtypes of the designated 
profile of the parameter type. 
• For any non-access result, the nominal subtype of the function result. 16 
17 
18/3 
19 
20/3 
21 
22 
23/2 
23.1/3 
24/2 
25 
26 
27/2 
27.1/3 
28/2 
Ada Reference Manual — 2012 Edition 
153      13 December 2012 S ubprogram Declarations   6.1 • For any access result type of an access-to-object type, the designated subtype of the result type. 
• For any access result type of an access-to-subprogram type, the subtypes of the designated 
profile of the result type. 
The types of a profile  are the types of those subtypes. 
A subprogram declared by an abstract_subprogram_declaration  is abstract; a subprogram declared by a 
subprogram_declaration  is not. See 3.9.3, “Abstract Types a nd Subprograms”. Similarly, a procedure 
declared by a null_procedure_declaration  is a null procedure; a procedure declared by a 
subprogram_declaration  is not. See 6.7, “Null Procedures”.  Finally, a function declared by an 
expression_function_declaration  is an expression function; a function declared by a 
subprogram_declaration  is not. See 6.8, “Expression Functions”. 
An overriding_indicator  is used to indicate whether overridi ng is intended. See 8.3.1, “Overriding 
Indicators”.  
Dynamic Semantics 
The elaboration of a subprogram_declaration  has no effect.  
NOTES 
1  A parameter_spec ification  with several identifiers is equivalent to a sequence of single parameter_spec ification s, as 
explained in 3.3. 
2  Abstract subprograms do not have bodies, and cannot be used in a nondispatching call (see 3.9.3, “Abstract Types and 
Subprograms”). 
3  The evaluation of default_expression s is caused by certain calls, as described in 6.4.1. They are not evaluated during 
the elaboration of the subprogram declaration. 
4  Subprograms can be called recursively and can be called concurrently from multiple tasks.  
Examples 
Examples of subprogr am declarations:   
procedure  Traverse_Tree; 
procedure  Increment(X : in out Integer); 
procedure  Right_Indent(Margin : out Line_Size);          --   see 3.5.4 
procedure  Switch(From, To : in out Link);                --   see 3.10.1  
function  Random return Probability;                      --   see 3.5.7 
function  Min_Cell(X : Link) return Cell;                 --   see 3.10.1  
function  Next_Frame(K : Positive) return Frame;          --   see 3.10 
function  Dot_Product(Left, Right : Vector) return Real;  --   see 3.6 
function  "*"(Left, Right : Matrix) return Matrix;        --   see 3.6 
Examples of in parameters with default expressions:   
procedure  Print_Header(Pages  : in Natural; 
            Header : in Line    :=  (1 .. Line'Last => ' ');  --   see 3.6 
            Center : in Boolean := True); 28.1/2 
28.2/3 
29 
30/3 
30.1/2 
31/2 
32 
33 34 35 
36 
37 
38 
39 
40 
41 
42 
Ada Reference Manual — 2012 Edition 
6.1.1    Preconditions and Postconditions 13 December 2012      154 6.1.1 Preconditions and Postconditions 
For a subprogram or entry, the following language -defined aspects may be specified with an 
aspect_specification  (see 13.1.1): 
Pre This aspect specifies a specific precondition fo r a callable entity; it shall be specified by an 
expression , called a specific precondition expression . If not specified for an entity, the 
specific precondition expression for the entity is the enumeration literal True. 
Pre'Class This aspect specifies a class-wide pr econdition for an operation of a tagged type and its 
descendants; it shall be specified by an expression , called a class-wide precondition 
expression . If not specified for an entity, then if no other class-wide precondition applies to 
the entity, the class-wide precondition expression for the entity is the enumeration literal True. 
Post This aspect specifies a specific postcondition for a callable entity; it shall be specified by an 
expression , called a specific postcondition expression . If not specified for an entity, the 
specific postcondition expression for the entity is the enumeration literal True. 
Post'Class This aspect specifies a class-wide pos tcondition for an operation of a tagged type and its 
descendants; it shall be specified by an expression , called a class-wide postcondition 
expression . If not specified for an entity, the class-wide postcondition expression for the 
entity is the enumeration literal True.  
Name Resolution Rules 
The expected type for a precondition or postcondition expression is any boolean type. 
Within the expression for a Pre'Class or Post'Class aspect for a primitive subprogram of a tagged type T, a 
name that denotes a formal parameter of type T is interpreted as having type T'Class. Similarly, a name 
that denotes a formal access parameter of type access-to- T is interpreted as having type access-to- T'Class. 
This ensures that the expression is well-defined for a primitive subprogram of a type descended from T. 
For an attribute_reference with attri bute_designator Old, if the attribute reference has an expected type or 
shall resolve to a given type, the same applies to the prefix ; otherwise, the prefix  shall be resolved 
independently of context. 
Legality Rules 
The Pre or Post aspect shall not be specified for an  abstract subprogram or a null procedure. Only the 
Pre'Class and Post'Class aspects may be specified for such a subprogram. 
If a type T has an implicitly declared subprogram P inherited from a parent type T1 and a homograph (see 
8.3) of P from a progenitor type T2, and 
• the corresponding primitive subprogram P1 of type T1 is neither null nor abstract; and 
• the class-wide precondition expr ession True does not apply to P1 (implicitly or explicitly); and 
• there is a class-wide precondition expressi on that applies to the corresponding primitive 
subprogram P2 of T2 that does not fully conform to any class-wide precondition expression that 
applies to P1,  
then: 
• If the type T is abstract, the implic itly declared subprogram P is abstract . 
• Otherwise, the subprogram P requires overriding  and shall be overridden with a nonabstract 
subprogram. 1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 13/3 
14/3 
15/3 
16/3 
Ada Reference Manual — 2012 Edition 
155      13 December 2012 Preconditions and Postconditions   6.1.1 If a renaming of a subprogram or entry S1 overrides an inherited subprogram S2, then the overriding is 
illegal unless each class-wide precond ition expression that applies to S1 fully conforms to some class-wide 
precondition expression that applies to S2 and each class-wide preconditi on expression that applies to S2 
fully conforms to some class-wide precondition expression that applies to S1. 
Static Semantics 
If a Pre'Class or Post'Class aspect is specified for a primitive subprogram of a tagged type T, then the 
associated expression also applies to the corre sponding primitive subprogram of each descendant of T. 
If performing checks is required by the Pre, Pre'Class, Post, or Post'Class asserti on policies (see 11.4.2) in 
effect at the point of a corresponding aspect specificati on applicable to a given subprogram or entry, then 
the respective precondition or postcond ition expressions are considered enabled . 
An expression  is potentially unevaluated  if it occurs within: 
• any part of an if_expression  other than the first condition ; 
• a dependent_ expression  of a case_expression ; 
• the right operand of a short-circuit control form; or 
• a membership_choice  other than the first of a membership operation.  
For a prefix  X that denotes an object of a nonlimited ty pe, the following attribute is defined:  
X'Old For each X'Old in a postcondition expression that is enabled, a constant is implicitly 
declared at the beginning of the subprogram or entr y. The constant is of the type of X and is 
initialized to the result of evaluating X (as an  expression) at the point of the constant 
declaration. The value of X'Old in the postcond ition expression is the value of this constant; 
the type of X'Old is the type of X. These imp licit constant declarations occur in an arbitrary 
order. 
 Reference to this attribute is only a llowed within a postcondition expression. The prefix  of 
an Old attribute_reference  shall not contain a Result attribute_reference , nor an Old 
attribute_reference , nor a use of an entity declared within the postcondition expression but 
not within prefix  itself (for example, the loop parameter of an enclosing 
quantified_expression ). The prefix  of an Old attribute_reference  that is potentially 
unevaluated shall statically denote an entity. 
For a prefix  F that denotes a function declaration, the following attribute is defined:  
F'Result Within a postcondition expression for functi on F, denotes the result object of the function. 
The type of this attribute is that of the function result except within a Post'Class 
postcondition expression for a function with a controlling result or with a controlling access 
result. For a controlling result, the type of the attribute is T'Class, where T is the function 
result type. For a controlling access result, the ty pe of the attribute is an anonymous access 
type whose designated type is T'Class, where T is the designated type of the function result 
type. 
 Use of this attribute is allowed only within a postcondition expression for F.  
Dynamic Semantics 
Upon a call of the subprogram or entry, after eval uating any actual parameters, precondition checks are 
performed as follows: 
• The specific precondition check begins with the evaluation of the specific precondition 
expression that applies to the subprogram or entry, if it is enabled; if the expression evaluates to 
False, Assertions.Assertion_Error is  raised; if the expression is not enabled, the check succeeds. 17/3 
18/3 
19/3 
20/3 
21/3 
22/3 23/3 24/3 25/3 
26/3 
27/3 
28/3 
29/3 
30/3 
31/3 
32/3 
Ada Reference Manual — 2012 Edition 
6.1.1    Preconditions and Postconditions 13 December 2012      156 • The class-wide precondition check begins with  the evaluation of any enabled class-wide 
precondition expressions that apply to the subprogram  or entry. If and only if all the class-wide 
precondition expressions evaluate to Fals e, Assertions.Assertion_Error is raised. 
The precondition checks are performed in an arbitrary order, and if any of the class-wide precondition 
expressions evaluate to True, it is not specified wh ether the other class-wide precondition expressions are 
evaluated. The precondition checks and any check for elaboration of the subprogram body are performed 
in an arbitrary order. It is not specified whet her in a call on a protected operation, the checks are 
performed before or after starting the protected action.  For an entry call, the checks are performed prior to 
checking whether the entry is open. 
Upon successful return from a call of the subprogram or entry, prior to copying back any by-copy in out  
or out parameters, the postcondition check is performed. This consists of  the evaluation of any enabled 
specific and class-wide postcondition expressions that apply to the subprogram or entry. If any of the 
postcondition expressions evaluate to False, then Assertions.Assertion_Error is  raised. The postcondition 
expressions are evaluated in an arbitrary order, and if any postcondition expression evaluates to False, it is 
not specified whether any other postcondition expressi ons are evaluated. The postcondition check, and any 
constraint or predicate checks associated with in out  or out parameters are performed in an arbitrary order. 
If a precondition or postcondition check fails, the exception is raised at the point of the call; the exception 
cannot be handled inside the called subprogram or entr y. Similarly, any exception raised by the evaluation 
of a precondition or postcondition expressi on is raised at the point of call. 
For any subprogram or entry call (including dispatchi ng calls), the checks that are performed to verify 
specific precondition expressions and specific and cla ss-wide postcondition expressions are determined by 
those for the subprogram or entry actually invoked. Note that the class-wide  postcondition expressions 
verified by the postcondition check that is pa rt of a call on a primitive subprogram of type T includes all 
class-wide postcondition expressions originating in any progenitor of T, even if the primitive subprogram 
called is inherited from a type T1 and some of the postcondition expressions do not apply to the 
corresponding primitive subprogram of T1. 
The class-wide precondition check for a call to a subpr ogram or entry consists solely of checking the 
class-wide precondition expressions that apply to the denoted callable entity (not necessarily the one that 
is invoked). 
For a call via an access-to-subprogram value, all precondition and postcondition checks performed are 
determined by the subprogram or entry denoted by the prefix of the Access attribute reference that 
produced the value.  
NOTES 
5  A precondition is checked just before the call. If another task can change any value that the precondition expression depends on, the precondition need not hold within the subprogram or entry body.  33/3 
34/3 
35/3 
36/3 
37/3 
38/3 
39/3 
40/3 
Ada Reference Manual — 2012 Edition 
157      13 December 2012 Formal Parameter Modes   6.2 6.2 Formal Parameter Modes 
A parameter_specification  declares a formal parameter of mode in, in out , or out.  
Static Semantics 
A parameter is passed either by copy  or by reference . When a parameter is passed by copy, the formal 
parameter denotes a separate object from the actual parameter, and any information transfer between the 
two occurs only before and after executing the subprogr am. When a parameter is passed by reference, the 
formal parameter denotes (a view of) the object denot ed by the actual parameter; reads and updates of the 
formal parameter directly refe rence the actual parameter object. 
A type is a by-copy type  if it is an elementary type, or if it is a descendant of a private type whose full type 
is a by-copy type. A parameter of a by-copy type is passed by copy, unless the formal parameter is 
explicitly aliased. 
A type is a by-reference type  if it is a descendant of one of the following:  
• a tagged type; 
• a task or protected type; 
• an explicitly limited record type;  
• a composite type with a subc omponent of a by-reference type; 
• a private type whose full type is a by-reference type.  
A parameter of a by-reference type is  passed by reference, as is an explicitly aliased parameter of any 
type. Each value of a by-reference type has an associated object. For a parenthesized expression, 
qualified_expression , or type_conversion , this object is the one associated with the operand. For a 
conditional_expression , this object is the one associated with the evaluated dependent_ expression . 
For other parameters, it is unspecified whether the parameter is passed by copy or by reference.  
Bounded (Run-Time) Errors 
If one name  denotes a part of a form al parameter, and a second name  denotes a part of a distinct formal 
parameter or an object that is not part  of a formal parameter, then the two name s are considered distinct 
access paths . If an object is of a type for which the para meter passing mechanism is not specified and is 
not an explicitly aliased parameter, then it is a bounded error to assign to the object via one access path, 
and then read the value of the object via a distinct access path, unless the first access path denotes a part of 
a formal parameter that no longer exists at the point  of the second access (due to leaving the corresponding 
callable construct). The possible consequences are th at Program_Error is raised, or the newly assigned 
value is read, or some old va lue of the object is read.  
NOTES 
6  A formal parameter of mode in is a constant view (see 3.3); it cannot be updated within the subprogram_body .  1 
2 
3/3 
4 
5 
6 
7/3 
8 9 
10/3 
11/3 
12/3 
13 
Ada Reference Manual — 2012 Edition 
6.3   Subprogram Bodies 13 December 2012      158 6.3 Subprogram Bodies 
A subprogram_body  specifies the execution of a subprogram.  
Syntax 
subprogram_body ::=  
    [overriding_indicator ] 
    subprogram_specification  
       [ aspect_specification ] is 
       declarative_part  
    begin  
        handled_sequence_of_statements  
    end [designator ]; 
If a designator  appears at the end of a subprogram_body , it shall repeat the defining_designator  of 
the subprogram_specification .  
Legality Rules 
In contrast to other bodies, a subprogram_body  need not be the completion of a previous declaration, in 
which case the body declares the s ubprogram. If the body is a completion, it shall be the completion of a 
subprogram_declaration  or generic_subprogram_declaration . The profile of a subprogram_body  that 
completes a declaration shall conform fully to that of the declaration.  
Static Semantics 
A subprogram_body  is considered a declaration. It can either complete a previous declaration, or itself be 
the initial declaration of the subprogram.  
Dynamic Semantics 
The elaboration of a nongeneric subprogram_body  has no other effect than to establish that the 
subprogram can from then on be called w ithout failing the Elaboration_Check.  
The execution of a subprogram_body  is invoked by a subprogram call. For this execution the 
declarative_part  is elaborated, and the handled_sequence_of_statements  is then executed.  
Examples 
Example of procedure body:   
procedure  Push(E : in Element_Type; S : in out Stack) is 
begin 
   if S.Index = S.Size then 
      raise Stack_Overflow; 
   else 
      S.Index := S.Index + 1;       S.Space(S.Index) := E;    end if; 
end Push; 
Example of a function body:   
function  Dot_Product(Left, Right : Vector) return Real is 
   Sum : Real := 0.0; begin 
   Check(Left'First = Right'First and Left'Last = Right'Last); 
   for J in Left'Range loop 
      Sum := Sum + Left(J)*Right(J);    end loop; 
   return Sum; 
end Dot_Product; 1 
2/3 
3 
4 
5 
6 
7 
8 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
159      13 December 2012 Conformance Rules   6.3.1 6.3.1 Conformance Rules 
When subprogram profiles are given in more than one place, they are required to conform in one of four 
ways: type conformance, mode conformance, subtype conformance, or full conformance.  
Static Semantics 
As explained in B.1, “Interfacing Aspects”, a convention  can be specified for an entity. Unless this 
International Standard states otherwise, the default c onvention of an entity is Ada. For a callable entity or 
access-to-subprogram type, the convention is called the calling convention . The following conventions are 
defined by the language:  
• The default calling convention for any subprogram not listed below is Ada. The Convention 
aspect may be specified to override the default calling convention (see B.1).  
• The Intrinsic  calling convention represents subprograms th at are “built in” to the compiler. The 
default calling convention is Intrinsic for the following:  
• an enumeration literal; 
• a "/=" operator declared implicitly due  to the declaration of "=" (see 6.6); 
• any other implicitly declared subprogram unless it is a dispatching operation of a tagged 
type; 
• an inherited subprogram of a generic form al tagged type with unknown discriminants;  
• an attribute that is a subprogram; 
• a subprogram declared immediately within a protected_body ; 
• any prefixed view of a subprogram (see 4.1.3).  
 The Access attribute is not allo wed for Intrinsic subprograms.  
• The default calling convention is protected  for a protected subprogram, and for an access-to-
subprogram type with the reserved word protected  in its definition. 
• The default calling convention is entry  for an entry. 
• The calling convention for an anonymous access-to-subprogram parameter or anonymous 
access-to-subprogram result is protected  if the reserved word protected  appears in its definition; 
otherwise, it is the convention of the s ubprogram that contains the parameter.  
• If not specified above as Intrinsic, the ca lling convention for any inherited or overriding 
dispatching operation of a tagged type is that  of the corresponding subprogram of the parent 
type. The default calling convention for a new di spatching operation of a tagged type is the 
convention of the type.  
Of these four conventions, only Ada and Intrinsic are allowed as a convention_ identifier  in the 
specification of a Convention aspect.  
Two profiles are type conformant  if they have the same number of parameters, and both have a result if 
either does, and corresponding parameter and result ty pes are the same, or, for access parameters or access 
results, corresponding designated types are the same , or corresponding designated profiles are type 
conformant.  
Two profiles are mode conformant  if: 
• they are type conformant; and 
• corresponding parameters have identical mode s and both or neither are explicitly aliased 
parameters; and 1 
2/1 
3/3 
4 
5 
6 7 
8 
9 
10/2 
10.1/2 
11 
12 
13 
13.1/3 
13.2/1 
14/3 
15/2 
16/3 
16.1/3 
16.2/3 
Ada Reference Manual — 2012 Edition 
6.3.1    Conformance Rules 13 December 2012      160 • for corresponding access parameters and any access result type, the designated subtypes 
statically match and either both or neither are access-to-constant, or the designated profiles are subtype conformant.  
Two profiles are subtype conformant  if they are mode conformant, co rresponding subtypes of the profile 
statically match, and the associated calling conventi ons are the same. The profile of a generic formal 
subprogram is not subtype confor mant with any other profile.  
Two profiles are fully conformant  if they are subtype conformant, if they have access-to-subprogram 
results whose designated profiles are fully c onformant, and for corresponding parameters:  
• they have the same names; and 
• both or neither have 
null_exclusion s; and 
• neither have default_expression s, or they both have default_expression s that are fully 
conformant with one another; and 
• for access-to-subprogram parameters, the designated profiles are fully conformant.  
Two expressions are fully conformant  if, after replacing each use of an operator with the equivalent 
function_call :  
• each constituent construct of one corresponds to an instance of the same syntactic category in 
the other, except that an expanded name may correspond to a direct_name  (or character_literal ) 
or to a different expanded name in the other; and 
• each direct_name , character_literal , and selector_name  that is not part of the prefix  of an 
expanded name in one denotes the sa me declaration as the corresponding direct_name , 
character_literal , or selector_name  in the other; and  
• each attribute_designator  in one is the same as the corresponding attribute_designator  in the 
other; and 
• each primary  that is a literal in one has the same valu e as the corresponding literal in the other.  
Two known_discriminant_part s are fully conformant  if they have the same num ber of discriminants, and 
discriminants in the same positi ons have the same names, sta tically matching subtypes, and 
default_expression s that are fully conformant with one another.  
Two discrete_subtype_definition s are fully conformant  if they are both subtype_indication s or are both 
range s, the subtype_mark s (if any) denote the same subtype, and the corresponding simple_expression s 
of the range s (if any) fully conform.  
The prefixed view profile  of a subprogram is the profile obtained by omitting the first parameter of that 
subprogram. There is no prefixed view profile for a parameterless subprogram. For the purposes of 
defining subtype and mode conformance,  the convention of a prefixed view  profile is considered to match 
that of either an entry or a protected operation. 
Implementation Permissions 
An implementation may declare an ope rator declared in a language-defined  library unit to be intrinsic. 16.3/3 
17/3 
18/3 
18.1/3 
18.2/3 18.3/3 
18.4/3 
19 
20 
21 
21.1/3 
22 
23 
24 
24.1/2 
25 
Ada Reference Manual — 2012 Edition 
161      13 December 2012 Inline Expansion of Subprograms   6.3.2 6.3.2 Inline Expansion of Subprograms 
Subprograms may be expanded in line at the call site.  
Paragraphs 2 through 4 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
For a callable entity or a generic subprogram, the fo llowing language-defined representation aspect may 
be specified: 
Inline The type of aspect Inline is Boolean. When aspect Inline is  True for a callable entity, inline 
expansion is desired for all calls to that en tity. When aspect Inline is True for a generic 
subprogram, inline expansion is desired for a ll calls to all instances of that generic 
subprogram. 
 If directly specified, the aspect_definition  shall be a static expression. This aspect is never 
inherited; if not directly specified, the aspect is False. 
Implementation Permissions 
For each call, an implementation is free to follow or to ignore the recommendation determined by the 
Inline aspect.  
6.4 Subprogram Calls 
A subprogram call  is either a procedure_call_statement  or a function_call ; it invokes the execution of the 
subprogram_body . The call specifies the association of the actual parameters, if any, with formal 
parameters of the subprogram.  
Syntax 
procedure_call_statement ::=  
    procedure_ name ; 
  | procedure_ prefix  actual_parameter_part ; 
function_call ::=  
    function_ name  
  | function_ prefix  actual_parameter_part  
actual_parameter_part ::=  
    (parameter_association  {, parameter_association }) 
parameter_association ::=  
   [formal_parameter_ selector_name  =>] explicit_actual_parameter  
explicit_actual_parameter ::= expression  | variable_ name  
A parameter_association  is named  or positional  according to whether or not the formal_parameter_ -
selector_name  is specified. Any positional associations shall precede any named associations. 
Named associations are not allowed if the prefix  in a subprogram call is an attribute_reference .  
Name Resolution Rules 
The name  or prefix  given in a procedure_call_statement  shall resolve to denote a callable entity that is a 
procedure, or an entry renamed as (viewed as) a procedure. The name  or prefix  given in a function_call  
shall resolve to denote a callable entity that is a function. The name  or prefix  shall not resolve to denote an 1 
5/3 
5.1/3 
5.2/3 
6/3 
1 
2 
3 
4 
5 6 
7 
8/2 
Ada Reference Manual — 2012 Edition 
6.4   Subprogram Calls 13 December 2012      162 abstract subprogram unless it is also a di spatching subprogram. When there is an actual_parameter_part , 
the prefix  can be an implicit_dereference  of an access-to-subprogram value.  
A subprogram call shall contain at most one associati on for each formal parameter. Each formal parameter 
without an association shall have a default_expression  (in the profile of the view denoted by the name  or 
prefix ). This rule is an overloading rule (see 8.6).  
Dynamic Semantics 
For the execution of a subprogram call, the name  or prefix  of the call is evaluated, and each parameter_-
association  is evaluated (see 6.4.1). If a default_expression  is used, an implicit parameter_association  is 
assumed for this rule. These evaluations  are done in an arbitrary order. The subprogram_body  is then 
executed, or a call on an entry or protected subprogram  is performed (see 3.9.2). Finally, if the subprogram 
completes normally, then after it is left, any necessa ry assigning back of formal to actual parameters 
occurs (see 6.4.1). 
If the name  or prefix  of a subprogram call denotes a prefixed view (see 4.1.3), th e subprogram call is 
equivalent to a call on the underlying subprogram, with  the first actual parameter being provided by the 
prefix  of the prefixed view (or the Access attribute of this prefix  if the first formal parameter is an access 
parameter), and the remaining act ual parameters given by the actual_parameter_part , if any. 
The exception Program_Error is raised at the point of a function_call  if the function completes normally 
without executing a return statement.  
A function_call  denotes a constant, as defined in 6.5; the nom inal subtype of the constant is given by the 
nominal subtype of the function result.  
Examples 
Examples of procedure calls:   
Traverse_Tree;                                               --   see 6.1 
Print_Header(128, Title, True);                              --   see 6.1 
Switch(From => X, To => Next);                               --   see 6.1 
Print_Header(128, Header => Title, Center => True);          --   see 6.1 
Print_Header(Header => Title, Center => True, Pages => 128); --   see 6.1 
Examples of function calls:   
Dot_Product(U, V)   --   see 6.1 and 6.3  
Clock               --   see 9.6 
F.all               --   presuming F is of an access-to-subprogram type — see 3.10  
Examples of procedures with default expressions:   
procedure  Activate(Process : in Process_Name; 
                   After   : in Process_Name := No_Process; 
                   Wait    : in Duration := 0.0; 
                   Prior   : in Boolean := False); 
procedure  Pair(Left, Right : in Person_Name := new Person(M));   --   see 3.10.1  
Examples of their calls:   
Activate(X); 
Activate(X, After => Y); Activate(X, Wait => 60.0, Prior => True); Activate(X, Y, 10.0, False); 
Pair; 
Pair(Left => new Person(F), Right => new Person(M)); 9 
10/2 
10.1/2 
11/2 
12/2 
13 
14 
15 
16 
17 
18 
19 
20/3 
21 
22 
23/3 
Ada Reference Manual — 2012 Edition 
163      13 December 2012 Subprogram Calls   6.4 NOTES 
7  If a default_expression  is used for two or more parameters in a multiple parameter_spec ification , the default_-
expression  is evaluated once for each omitted parameter. Hence in the above examples, the two calls of Pair are 
equivalent.  
Examples 
Examples of overloaded subprograms:   
procedure  Put(X : in Integer); 
procedure  Put(X : in String); 
procedure  Set(Tint   : in Color); 
procedure  Set(Signal : in Light); 
Examples of their calls:   
Put(28); 
Put("no possible ambiguity here"); 
Set(Tint   => Red); 
Set(Signal => Red); Set(Color'(Red)); 
--  Set(Red) would be ambiguous since Red may  
--  denote a value either of type Color or of type Light  
6.4.1 Parameter Associations 
A parameter association de fines the association between an actual parameter and a formal parameter.  
Name Resolution Rules 
The formal_parameter_ selector_name  of a named parameter_association  shall resolve to denote a 
parameter_specification  of the view being called; this is the formal parameter of the association. The 
formal parameter for a positional parameter_association  is the parameter with the corresponding position 
in the formal part of the view being called. 
The actual parameter  is either the explicit_actual_parameter  given in a parameter_association  for a 
given formal parameter, or the corresponding default_expression  if no parameter_association  is given 
for the formal parameter. The expected type for an actual parameter is the type of the corresponding 
formal parameter.  
If the mode is in, the actual is interpreted as an expression ; otherwise, the actual is interpreted only as a 
name , if possible.  
Legality Rules 
If the mode is in out  or out, the actual shall be a name  that denotes a variable.  
If the formal parameter is an explicitly aliased parame ter, the type of the actual parameter shall be tagged 
or the actual parameter shall be an aliased view of an object. Further, if the formal parameter subtype F is 
untagged: 
• the subtype F shall statically match the nominal subtype of the actual object; or 
• the subtype F shall be unconstrained, discriminated in  its full view, and unconstrained in any 
partial view.  
In a function call, the accessibility level of the actual object for each explicitly aliased parameter shall not 
be statically deeper than the accessibility le vel of the master of the call (see 3.10.2). 
Two name s are known to denote the same object  if: 24 
25 
26 
27 
28 
29 
30 
31 
1 
2/3 
3 
4 
5 
6/3 
6.1/3 
6.2/3 
6.3/3 
6.4/3 
Ada Reference Manual — 2012 Edition 
6.4.1    Parameter Associations 13 December 2012      164 • both name s statically denote the same sta nd-alone object or parameter; or 
• both name s are selected_component s, their prefix es are known to denote the same object, and 
their selector_name s denote the same component; or 
• both name s are dereferences (implicit or explicit) and the dereferenced name s are known to 
denote the same object; or 
• both name s are indexed_component s, their prefix es are known to denote the same object, and 
each of the pairs of corresponding index values are either both static expressions with the same 
static value or both name s that are known to denote the same object; or 
• both name s are slice s, their prefix es are known to denote the same object, and the two slice s 
have statically matching index constraints; or 
• one of the two name s statically denotes a renami ng declaration whose renamed object_ name  is 
known to denote the same object as the other, the prefix  of any dereference within the renamed 
object_ name  is not a variable, and any expression  within the renamed object_ name  contains no 
references to variables nor calls on nonstatic functions.  
Two name s are known to refer to the same object  if  
• The two name s are known to denote the same object; or 
• One of the name s is a selected_component , indexed_component , or slice  and its prefix  is 
known to refer to the same object as the other name ; or 
• One of the two name s statically denotes a renami ng declaration whose renamed object_ name  is 
known to refer to the same object as the other name .  
If a call C has two or more parameters of mode in out  or out that are of an elementary type, then the call is 
legal only if: 
• For each name  N that is passed as a parameter of mode in out  or out to the call C, there is no 
other name  among the other parameters of mode in out  or out to C that is known to denote the 
same object. 
If a construct C has two or more direct constituents that are name s or expression s whose evaluation may 
occur in an arbitrary order, at least one of which contains a function call with an in out  or out parameter, 
then the construct is legal only if: 
• For each name N that is passed as a parameter of mode in out  or out to some inner function call 
C2 (not including the construct C itself), there is no other name  anywhere within a direct 
constituent of the construct C other than the one containing C2, that is known to refer to the 
same object.  
For the purposes of checking this rule: 
• For an array aggregate , an expression  associated with a discrete_choice_list  that has two or 
more discrete choices, or that has a nonstatic ra nge, is considered as two or more separate 
occurrences of the expression ; 
• For a record aggregate : 
• The expression  of a record_component_association  is considered to occur once for each 
associated component; and 
• The default_expression  for each record_component_association  with <> for which the 
associated component has a default_expression  is considered part of the aggregate ;  
• For a call, any default_expression  evaluated as part of the call is considered part of the call.  6.5/3 
6.6/3 
6.7/3 6.8/3 
6.9/3 
6.10/3 
6.11/3 
6.12/3 
6.13/3 
6.14/3 6.15/3 
6.16/3 
6.17/3 
6.18/3 
6.19/3 
6.20/3 
6.21/3 
6.22/3 
6.23/3 6.24/3 
Ada Reference Manual — 2012 Edition 
165      13 December 2012 Parameter Associations   6.4.1 Dynamic Semantics 
For the evaluation of a parameter_association :  
• The actual parameter is first evaluated. 
• For an access parameter, the access_definition  is elaborated, which creates the anonymous 
access type. 
• For a parameter (of any mode) that is passed by  reference (see 6.2), a view conversion of the 
actual parameter to the nominal subtype of the formal parameter is evaluated, and the formal parameter denotes that conversion.  
• For an in or in out  parameter that is passed by copy (s ee 6.2), the formal parameter object is 
created, and the value of the actual parameter is converted to the nominal subtype of the formal 
parameter and assigned to the formal.  
• For an out parameter that is passed by copy, the fo rmal parameter object is created, and:  
• For an access type, the formal parameter is in itialized from the value of the actual, without 
checking that the value satisfies any constraint , any predicate, or any exclusion of the null 
value;  
• For a scalar type that has the Default_Value aspect specified, the formal parameter is 
initialized from the value of the actual, wit hout checking that the value satisfies any 
constraint or any predicate; 
• For a composite type with discriminants or that has implicit initial values for any 
subcomponents (see 3.3.1), the behavior is as for an in out  parameter passed by copy.  
• For any other type, the formal parameter is uninitialized. If composite, a view conversion of 
the actual parameter to the nominal subtype of the formal is evaluated (which might raise Constraint_Error), and the actual subtype of the formal is that of the view conversion. If 
elementary, the actual subtype of the form al is given by its nominal subtype.  
• In a function call, for each explicitly aliased parameter, a check is made that the accessibility 
level of the master of the actual object is not d eeper than that of the  master of the call (see 
3.10.2).  
A formal parameter of mode in out  or out with discriminants is constrained if either its nominal subtype or 
the actual parameter is constrained. 
After normal completion and leaving of a subprogram, for each in out  or out parameter that is passed by 
copy, the value of the formal parameter is converted to the subtype of the variable given as the actual 
parameter and assigned to it. Thes e conversions and assignments o ccur in an arbitrary order.  
Erroneous Execution 
If the nominal subtype of a formal parameter with discriminants is c onstrained or indefinite, and the 
parameter is passed by reference, then the executi on of the call is erroneous if the value of any 
discriminant of the actual is changed while the form al parameter exists (that is, before leaving the 
corresponding callable construct).  7 
8 
9 
10 
11 
12 
13/3 
13.1/3 
14 
15 
15.1/3 
16 
17 
18/3 
Ada Reference Manual — 2012 Edition 
6.5   Return Statements 13 December 2012      166 6.5 Return Statements 
A simple_return_statement  or extended_return_statement  (collectively called a return statement )  is 
used to complete the execution of the innermost enclosing subprogram_body , entry_body , or accept_-
statement .  
Syntax 
simple_return_statement ::= return  [expression ]; 
extended_return_object_declaration ::=  
    defining_identifier  : [aliased ][constant ] return_subtype_indication  [:= expression ] 
extended_return_statement ::=  
    return  extended_return_object_declaration  [do 
        handled_sequence_of_statements  
    end return ]; 
return_subtype_indication ::= subtype_indication  | access_definition  
Name Resolution Rules 
The result subtype  of a function is the subtype denoted by the subtype_mark , or defined by the 
access_definition , after the reserved word return  in the profile of the function. The expected type for the 
expression , if any, of a simple_return_statement  is the result type of the corresponding function. The 
expected type for the expression  of an extended_return_statement  is that of the return_subtype_-
indication .  
Legality Rules 
A return statement shall be within a callable construct, and it applies to  the innermost callable construct or 
extended_return_statement  that contains it. A return statement sh all not be within a body that is within 
the construct to which the return statement applies. 
A function body shall contain at least one return st atement that applies to the function body, unless the 
function contains code_statement s. A simple_return_statement  shall include an expression  if and only 
if it applies to a function body. An extended_return_statement  shall apply to a function body. An 
extended_return_statement  with the reserved word constant  shall include an expression . 
For an extended_return_statement  that applies to a function body: 
• If the result subtype of the function is defined by a subtype_mark , the return_subtype_-
indication  shall be a subtype_indication . The type of the subtype_indication  shall be covered by 
the result type of the function. The subtype defined by the subtype_indication  shall be statically 
compatible with the result subtype of the func tion; if the result type of the function is 
elementary, the two subtypes shall statically match. If the result subtype of the function is 
indefinite, then the subtype defined by the subtype_indication  shall be a definite subtype, or 
there shall be an expression . 
• If the result subtype of the function is defined by an access_definition , the return_subtype_-
indication  shall be an access_definition . The subtype defined by the access_definition  shall 
statically match the result subtype of the func tion. The accessibility level of this anonymous 
access subtype is that of the result subtype. 
• If the result subtype of the function is class- wide, the accessibility level of the type of the 
subtype defined by the return_subtype_indication  shall not be statically deeper than that of the 
master that elaborated the function body.  1/2 
2/2 
2.1/3 
2.2/3 
2.3/2 
3/2 
4/2 
5/3 
5.1/2 
5.2/3 
5.3/2 
5.4/3 
Ada Reference Manual — 2012 Edition 
167      13 December 2012 Return Statements   6.5 For any return statement that applies to a function body: 
• If the result subtype of the function is limited, then the expression  of the return statement (if 
any) shall meet the restrictions described in 7.5.  
• If the result subtype of the function is class- wide, the accessibility level of the type of the 
expression  (if any) of the return statement shall not be  statically deeper than that of the master 
that elaborated the function body. 
• If the subtype determined by the expression  of the simple_return_statement  or by the 
return_subtype_indication  has one or more access discrimina nts, the accessibility level of the 
anonymous access type of each access discriminant sha ll not be statically deeper than that of the 
master that elaborated the function body. 
If the keyword aliased  is present in an extended_return_object_declaration , the type of the extended 
return object shall be immutably limited.  
Static Semantics 
Within an extended_return_statement , the return object  is declared with the given defining_identifier , 
with the nominal subtype defined by the return_subtype_indication . An extended_return_statement  with 
the reserved word constant  is a full constant declaration that declares the return object to be a constant 
object.  
Dynamic Semantics 
For the execution of an extended_return_statement , the subtype_indication  or access_definition  is 
elaborated. This creates the nominal subtype of the return object. If there is an expression , it is evaluated 
and converted to the nominal subtype (which might ra ise Constraint_Error — see 4. 6); the return object is 
created and the converted value is assigned to the retu rn object. Otherwise, the return object is created and 
initialized by default as for a stand-alone object of its nominal subtype (see 3.3.1). If the nominal subtype 
is indefinite, the return object is constrained by its initial value. A ch eck is made that the value of the 
return object belongs to the function result subtype. Constraint_Error is raised  if this check fails.  
For the execution of a simple_return_statement , the expression  (if any) is first evaluated, converted to 
the result subtype, and then is assigned to the anonymous return object .  
If the return object has any parts that are tasks, the activation of those tasks does not occur until after the 
function returns (see 9.2).  
If the result type of a function is a specific tagged type , the tag of the return object is that of the result 
type. If the result type is class-wide, the tag of the return object is that of the type of the 
subtype_indication  if it is specific, or otherw ise that of the value of the expression . A check is made that 
the master of the type identified by the tag of th e result includes the elaboration of the master that 
elaborated the function body. If this ch eck fails, Program_E rror is raised.  
If the result subtype of the function is defined by an access_definition  designating a specific tagged type 
T, a check is made that the result value is null or the tag of the object designated by the result value 
identifies T. Constraint_Error is raised  if this check fails.  
Paragraphs 9 through 20 were deleted.   
If any part of the specific type of the return object of a function (or coextension thereof) has one or more 
access discriminants whose value is not constrained by the result subtype of the function, a check is made that the accessibility level of the anonymous access type  of each access discriminant, as determined by the 5.5/3 
5.6/3 
5.7/3 
5.8/3 
5.9/3 
5.10/3 
5.11/3 
6/2 
7/2 8/3 
8.1/3 
21/3 
Ada Reference Manual — 2012 Edition 
6.5   Return Statements 13 December 2012      168 expression  or the return_subtype_indication  of the return statement, is not deeper than the level of the 
master of the call (see 3.10.2). If this check fails, Program_Error is raised.  
For the execution of an extended_return_statement , the handled_sequence_of_statements  is executed. 
Within this handled_sequence_of_statements , the execution of a simple_return_statement  that applies 
to the extended_return_statement  causes a transfer of control that completes the extended_return_-
statement . Upon completion of a return statement that applies to a callable construct by the normal 
completion of a simple_return_statement  or by reaching the end return  of an extended_return_-
statement , a transfer of control is performed which completes the execution of the callable construct, and 
returns to the caller. 
In the case of a function, the function_call  denotes a constant view of the return object.  
Implementation Permissions 
For a function call used to initialize a composite object  with a constrained nominal subtype or used to 
initialize a return object that is built in place into such an object: 
• If the result subtype of the function is constrained,  and conversion of an object of this subtype to 
the subtype of the object being initialized would raise Constraint_Error, then Constraint_Error 
may be raised before calling the function. 
• If the result subtype of the function is unconstraine d, and a return statement is executed such that 
the return object is known to be constrained, a nd conversion of the return object to the subtype 
of the object being initialized would raise Constrai nt_Error, then Constraint_Error may be raised 
at the point of the call (after abandoning the execution of the function body).  
Examples 
Examples of return statements:   
return;                         --  in a procedure body, entry_body , 
                                -- accept_statement , or extended_return_statement  
return Key_Value(Last_Index);   --  in a function body  
return Node : Cell do           --  in a function body, see 3.10.1 for Cell  
   Node.Value := Result;    Node.Succ := Next_Node; end return; 22/3 
23/2 
24/3 
24.1/3 
24.2/3 
25 
26/2 
27 
28/2 
Ada Reference Manual — 2012 Edition 
169      13 December 2012 N onreturning Procedures   6.5.1 6.5.1 Nonreturning Procedures 
Specifying aspect No_Return to have the value True indicates that a procedure cannot return normally; it 
may propagate an exception or loop forever.  
Paragraphs 2 and 3 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
For a procedure or generic procedure, the followi ng language-defined representation aspect may be 
specified:  
No_Return The type of aspect No_R eturn is Boolean. When aspect No_R eturn is True for an entity, the 
entity is said to be nonreturning . 
 If directly specified, the aspect_definition  shall be a static expression. This aspect is never 
inherited; if not directly specified, the aspect is False. 
If a generic procedure is nonreturning, then so are its  instances. If a procedure d eclared within a generic 
unit is nonreturning, then so are the correspondi ng copies of that procedure in instances. 
Legality Rules 
Aspect No_Return shall not be specified for a nu ll procedure nor an instance of a generic unit. 
A return statement shall not apply to a nonr eturning procedure or generic procedure. 
A procedure shall be nonreturning if it overrides a disp atching nonreturning procedure. In addition to the 
places where Legality Rules normally apply (see 12.3), this  rule applies also in the private part of an 
instance of a generic unit. 
If a renaming-as-body completes a nonreturning procedur e declaration, then the renamed procedure shall 
be nonreturning. 
Paragraph 8 was deleted.   
Dynamic Semantics 
If the body of a nonreturning procedure completes norma lly, Program_Error is raised at the point of the 
call.  
Examples 
procedure  Fail(Msg : String)  --  raises Fatal_Error exception  
   with No_Return; 
   --  Inform compiler and reader that procedure never returns normally  1/3 
3.1/3 
3.2/3 
3.3/3 3.4/3 
4/3 
5/2 6/2 
7/2 
9/2 
10/3 
Ada Reference Manual — 2012 Edition 
6.6   Overloading of Operat ors 13 December 2012      170 6.6 Overloading of Operators 
An operator  is a function whose designator  is an operator_symbol . Operators, like other functions, may 
be overloaded.  
Name Resolution Rules 
Each use of a unary or binary operator is equivalent to a function_call  with function_ prefix  being the 
corresponding operator_symbol , and with (respectively) one or two positional actual parameters being the 
operand(s) of the operator (in order).  
Legality Rules 
The subprogram_specification  of a unary or binary operator sh all have one or two parameters, 
respectively. The parameters shall be of mode in. A generic function instantiation whose designator  is an 
operator_symbol  is only allowed if the specification of th e generic function has the corresponding number 
of parameters, and they are all of mode in. 
Default_expression s are not allowed for the parameters of an operator (whether the operator is declared 
with an explicit subprogram_specification  or by a generic_instantiation ). 
An explicit declaration of "/=" shall not have a result type of the predefined type Boolean.  
Static Semantics 
An explicit declaration of "=" whose result type is B oolean implicitly declares an operator "/=" that gives 
the complementary result.  
NOTES 
8  The operators "+" and "–" are both unary and binary operators, and hence may be overloaded with both one- and two-parameter functions.  
Examples 
Examples of user-defined operators:   
function  "+" (Left, Right : Matrix) return Matrix; 
function  "+" (Left, Right : Vector) return Vector; 
 --  assuming that A, B, and C are of the type Vector  
--  the following two statements are equivalent:  
 A := B + C; A := "+"(B, C); 1 
2 
3/3 
4 
5 
6/3 
7 
8 
9 
Ada Reference Manual — 2012 Edition 
171      13 December 2012 Null Procedures   6.7 6.7 Null Procedures 
A null_procedure_declaration  provides a shorthand to declare a procedure with an empty body.  
Syntax 
null_procedure_declaration ::=  
   [overriding_indicator ] 
   procedure_specification  is null 
       [ aspect_specification ]; 
Legality Rules 
If a null_procedure_declaration  is a completion, it shall be the completion of a subprogram_declaration  
or generic_subprogram_declaration . The profile of a null_procedure_declaration  that completes a 
declaration shall conform fully to that of the declaration.  
Static Semantics 
A null_procedure_declaration  declares a null procedure . A completion is not allowed for a 
null_procedure_declaration ; however, a null_procedure_declaration  can complete a previous declaration.  
Dynamic Semantics 
The execution of a null procedure is invoked by a s ubprogram call. For the execu tion of a subprogram call 
on a null procedure, the execution of the subprogram_body  has no effect.  
The elaboration of a null_procedure_declaration  has no other effect than to establish that the null 
procedure can be called without failing the Elaboration_Check.  
Examples 
procedure  Simplify(Expr : in out Expression) is null; --  see 3.9 
-- By default, Simplify does nothing, but it ma y be overridden in extensions of Expression  1/2 
2/3 
2.1/3 
3/3 
4/2 
5/3 
6/2 
Ada Reference Manual — 2012 Edition 
6.8   Expression Functions 13 December 2012      172 6.8 Expression Functions 
An expression_function_declaration  provides a shorthand to declare a function whose body consists of a 
single return statement.  
Syntax 
expression_function_declaration ::=  
   [overriding_indicator ] 
   function_specification  is 
       ( expression ) 
       [ aspect_specification ]; 
Name Resolution Rules 
The expected type for the expression  of an expression_function_declaration  is the result type (see 6.5) of 
the function.  
Legality Rules 
If an expression_function_declaration  is a completion, it shall be the completion of a 
subprogram_declaration  or generic_subprogram_declaration . The profile of an expression_function_-
declaration  that completes a declaration shall conf orm fully to that of the declaration. 
If the result subtype has one or more unconstrained access discriminants, the accessibility level of the 
anonymous access type of each access discriminant, as determined by the expression  of the expression 
function, shall not be statically deeper than  that of the master that elaborated the expression_function_-
declaration . 
Static Semantics 
An expression_function_declaration  declares an expression function . A completion is not allowed for an 
expression_function_declaration ; however, an expression_function_declaration  can complete a previous 
declaration.  
Dynamic Semantics 
The execution of an expression function is invoke d by a subprogram call. For the execution of a 
subprogram call on an expression function, the execution of the subprogram_body  executes an implicit 
function body containing only a simple_return_statement  whose expression  is that of the expression 
function. 
The elaboration of an expression_function_declaration  has no other effect than to establish that the 
expression function can be called wit hout failing the Elaboration_Check.  
Examples 
function  Is_Origin (P : in Point) return Boolean is -- see 3.9 
   (P.X = 0.0 and P.Y = 0.0); 1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
Ada Reference Manual — 2012 Edition 
173      13 December 2012 Packages   7 7   Packages 
Packages are program units that a llow the specification of groups of logically related entities. Typically, a 
package contains the declaration of a type (often a private type or private extension) along with the 
declarations of primitive subprograms of the type, wh ich can be called from outside the package, while 
their inner workings remain hidden from outside users.  
7.1 Package Specifications  and Declarations 
A package is generally provided in two parts: a package_specification  and a package_body . Every 
package has a package_specification , but not all packages have a package_body .  
Syntax 
package_declaration ::= package_specification ; 
package_specification ::=  
    package  defining_program_unit_name  
        [ aspect_specification ] is 
      { basic_declarative_item } 
   [private  
      { basic_declarative_item }] 
    end [[parent_unit_name .]identifier ] 
If an identifier  or parent_unit_name .identifier  appears at the end of a package_specification , then 
this sequence of lexical elements shall repeat the defining_program_unit_name .  
Legality Rules 
A package_declaration  or generic_package_declaration  requires a completion (a body) if it contains any 
basic_declarative_item  that requires a completion, but whose completion is not in its 
package_specification .  
Static Semantics 
The first list of basic_declarative_item s of a package_specification  of a package other than a generic 
formal package is called the visible part  of the package. The optional list of basic_declarative_item s after 
the reserved word private  (of any package_specification ) is called the private part  of the package. If the 
reserved word private  does not appear, the package has an implicit empty private part. Each list of 
basic_declarative_item s of a package_specification  forms a declaration list  of the package. 
An entity declared in the private part of a package is visible only within the declarative region of the 
package itself (including any child units — see 10. 1.1). In contrast, expa nded names denoting entities 
declared in the visible part can be used even outside  the package; furthermore, direct visibility of such 
entities can be achieved by means of use_clause s (see 4.1.3 and 8.4).  
Dynamic Semantics 
The elaboration of a package_declaration  consists of the elaboration of its basic_declarative_item s in the 
given order.  
NOTES 
1  The visible part of a package contains all the information that another program unit is able to know about the package. 
2  If a declaration occurs immediately within the specification of a package, and the declaration has a corresponding 
completion that is a body, then that body has to occur immediately within the body of the package.  1 
1 
2 
3/3 
4 
5/2 
6/2 
7 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
7.1   Package Specifications and Decl arations 13 December 2012      174 Examples 
Example of a package declaration:   
package Rational_Numbers is 
   type Rational is 
      record 
         Numerator   : Integer;          Denominator : Positive;       end record; 
   function  "="(X,Y : Rational) return Boolean; 
   function  "/"  (X,Y : Integer)  return Rational;  --   to construct a rational number  
   function  "+"  (X,Y : Rational) return Rational; 
   function  "-"  (X,Y : Rational) return Rational; 
   function  "*"  (X,Y : Rational) return Rational; 
   function  "/"  (X,Y : Rational) return Rational; 
end Rational_Numbers; 
There are also many examples of package declarations in the predef ined language environment (see Annex 
A).  
7.2 Package Bodies 
In contrast to the entities declared in the visibl e part of a package, the entities declared in the 
package_body  are visible only within the package_body  itself. As a consequence, a package with a 
package_body  can be used for the construction of a group of related subprograms in which the logical 
operations available to clients are clearly  isolated from the internal entities.  
Syntax 
package_body ::=  
    package  body  defining_program_unit_name  
        [ aspect_specification ] is 
       declarative_part  
   [begin  
        handled_sequence_of_statements ] 
    end [[parent_unit_name .]identifier ]; 
If an identifier  or parent_unit_name .identifier  appears at the end of a package_body , then this 
sequence of lexical elements shall repeat the defining_program_unit_name .  
Legality Rules 
A package_body  shall be the completion of a previous package_declaration  or generic_package_-
declaration . A library package_declaration  or library generic_package_declaration  shall not have a 
body unless it requires a body; pragma  Elaborate_Body can be used to require a library_unit_declaration  
to have a body (see 10.2.1) if it would not otherwise require one.  
Static Semantics 
In any package_body  without statement s there is an implicit null_statement . For any package_-
declaration  without an explicit comple tion, there is an implicit package_body  containing a single 
null_statement . For a noninstance, nonlibrary package, this body occurs at the end of the declarative_part  
of the innermost enclosing program unit or block_statement ; if there are several such packages, the order 
of the implicit package_bodies  is unspecified. (For an instance, the implicit package_body  occurs at the 
place of the instantiation (see 12.3). For a library p ackage, the place is partially determined by the 
elaboration dependences (see Clause 10).)  11 
12 
13 
14 
15 16 
17 
1 
2/3 
3 
4 
5/3 
Ada Reference Manual — 2012 Edition 
175      13 December 2012 Package Bodies   7.2 Dynamic Semantics 
For the elaboration of a nongeneric package_body , its declarative_part  is first elaborated, and its 
handled_sequence_of_statements  is then executed.  
NOTES 
3  A variable declared in the body of a package is only visible within this body and, consequently, its value can only be changed within the 
package_body . In the absence of local tasks, the value of such a variable remains unchanged between 
calls issued from outside the package to subprograms declared in the visible part. The properties of such a variable are similar to those of a “static” variable of C. 
4  The elaboration of the body of a subprogram explicitly declared in the visible part of a package is caused by the 
elaboration of the body of the package. Hence a call of such a subprogram by an outside program unit raises the exception Program_Error if the call takes place before the elaboration of the 
package_body  (see 3.11).  
Examples 
Example of a package body (see 7.1):   
package body Rational_Numbers is 
   procedure  Same_Denominator (X,Y : in out Rational) is 
   begin 
      --   reduces X and Y to the same denominator:  
      ...    end Same_Denominator; 
   function  "="(X,Y : Rational) return Boolean is 
      U : Rational := X;       V : Rational := Y;    begin 
      Same_Denominator (U,V);       return U.Numerator = V.Numerator; 
   end "="; 
   function  "/" (X,Y : Integer) return Rational is 
   begin 
      if Y > 0 then 
         return (Numerator => X,  Denominator => Y); 
      else 
         return (Numerator => -X, Denominator => -Y); 
      end if; 
   end "/"; 
   function  "+" (X,Y : Rational) return Rational is ... end "+"; 
   function  "-" (X,Y : Rational) return Rational is ... end "-"; 
   function  "*" (X,Y : Rational) return Rational is ... end "*"; 
   function  "/" (X,Y : Rational) return Rational is ... end "/"; 
end Rational_Numbers; 
7.3 Private Types and Private Extensions 
The declaration (in the visible part of a package) of a type as a private type or private extension serves to 
separate the characteristics that can be used direc tly by outside program units (that is, the logical 
properties) from other characteristics whose direct use is confined to the package (the details of the 
definition of the type itself). See 3.9.1 for an overview of type extensions.  
Syntax 
private_type_declaration ::=  
   type defining_identifier  [discriminant_part ] is [[abstract ] tagged ] [limited ] private  
      [aspect_specification ]; 6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
1 
2/3 
Ada Reference Manual — 2012 Edition 
7.3   Private Types and Private Extensions 13 December 2012      176 private_extension_declaration ::=  
   type defining_identifier  [discriminant_part ] is 
     [abstract ] [limited  | synchronized ] new ancestor_ subtype_indication  
     [and interface_list ] with private  
       [ aspect_specification ]; 
Legality Rules 
A private_type_declaration  or private_extension_declaration  declares a partial view  of the type; such a 
declaration is allowed only as a declarative_item  of the visible part of a package, and it requires a 
completion, which shall be a full_type_declaration  that occurs as a declarative_item  of the private part of 
the package. The view of the type declared by the full_type_declaration  is called the full view . A generic 
formal private type or a generic formal private extension is also a partial view.  
A type shall be completely defined before it is fro zen (see 3.11.1 and 13.14). Thus, neither the declaration 
of a variable of a partial view of a type, nor the creation by an allocator  of an object of the partial view are 
allowed before the full declaration of the type. Simila rly, before the full declaration, the name of the 
partial view cannot be used in a generic_instantiation  or in a representation item.  
A private type is limited if its declaration includes the reserved word limited ; a private extension is limited 
if its ancestor type is a limited type that is not an interface type, or if the reserved word limited  or 
synchronized  appears in its definition. If the partial view  is nonlimited, then the full view shall be 
nonlimited. If a tagged partial view is limited, then the full view shall be limited. On the other hand, if an 
untagged partial view is limited, the full view may be limited or nonlimited. 
If the partial view is tagged, then the full view shall be tagged. On the other hand, if the partial view is 
untagged, then the full view may be tagged or untagged.  In the case where the partial view is untagged and 
the full view is tagged, no derivatives of the partial view are allowed within the immediate scope of the 
partial view; derivatives of the full view are allowed.  
If a full type has a partial view that is tagged, then:  
• the partial view shall be a synchronized tagged ty pe (see 3.9.4) if and only if the full type is a 
synchronized tagged type; 
• the partial view shall be a descendant of an interface type (see 3.9.4) if and only if the full type 
is a descendant of the interface type. 
The ancestor subtype  of a private_extension_declaration  is the subtype defined by the ancestor_ -
subtype_indication ; the ancestor type shall be a specific tagged type. The full view of a private extension 
shall be derived (directly or indirectly) from the an cestor type. In addition to the places where Legality 
Rules normally apply (see 12.3), the requirement that the ancestor be specific applies also in the private part of an instance of a generic unit.  
If the reserved word limited  appears in a 
private_extension_declaration , the ancestor type shall be a 
limited type. If the reserved word synchronized  appears in a private_extension_declaration , the ancestor 
type shall be a limited interface. 
If the declaration of a partial view includes a known_discriminant_part , then the full_type_declaration  
shall have a fully conforming (explicit) known_discriminant_part  (see 6.3.1, “Conformance Rules”). The 
ancestor subtype may be unconstrained; the parent subt ype of the full view is required to be constrained 
(see 3.7).  
If a private extension inherits known discriminants from the ancestor subtype, then the full view shall also 
inherit its discriminants from the ancestor subtype, and the parent subtype of the full view shall be 
constrained if and only if the an cestor subtype is constrained.  3/3 
4 
5 
6/2 
7 
7.1/2 
7.2/2 
7.3/2 
8 
8.1/2 
9 
10 
Ada Reference Manual — 2012 Edition 
177      13 December 2012 Private Types and Private Extensions   7.3 If the full_type_declaration  for a private extension includes a derived_type_definition , then the reserved 
word limited  shall appear in the full_type_declaration  if and only if it also appears in the 
private_extension_declaration .  
If a partial view has unknown discriminants, then the full_type_declaration  may define a definite or an 
indefinite subtype, with or without discriminants. 
If a partial view has neither known nor unknown discriminants, then the full_type_declaration  shall define 
a definite subtype. 
If the ancestor subtype of a private extension has constr ained discriminants, then the parent subtype of the 
full view shall impose a statically matchi ng constraint on those discriminants.  
Static Semantics 
A private_type_declaration  declares a private type and its first subtype. Similarly, a private_extension_-
declaration  declares a private extension and its first subtype.  
A declaration of a partial view and the corresponding full_type_declaration  define two views of a single 
type. The declaration of a partial view together with th e visible part define the operations that are available 
to outside program units; the declaration of the full view together with the private part define other 
operations whose direct use is possi ble only within the declarative region of the package itself. Moreover, 
within the scope of the declaration of the full view, the characteristics (s ee 3.4) of the type are determined 
by the full view; in particular, with in its scope, the full view determines  the classes that include the type, 
which components, entries, and protected subprograms ar e visible, what attributes and other predefined 
operations are allowed, and whether the first subtype is static. See 7.3.1. 
For a private extension, the characteristics (including components, but excluding discriminants if there is a 
new discriminant_part  specified), predefined operators, and i nherited user-defined primitive subprograms 
are determined by its ancestor type and its progenitor ty pes (if any), in the same way that those of a record 
extension are determined by those of its parent type and its progenitor types (see 3.4 and 7.3.1).  
Dynamic Semantics 
The elaboration of a private_type_declaration  creates a partial view of a type. The elaboration of a 
private_extension_declaration  elaborates the ancestor_ subtype_indication , and creates a partial view of a 
type.  
NOTES 
5  The partial view of a type as declared by a private_type_declaration  is defined to be a composite view (in 3.2). The full 
view of the type might or might not be composite. A private extension is also composite, as is its full view. 
6  Declaring a private type with an unknown_discriminant_part  is a way of preventing clients from creating uninitialized 
objects of the type; they are th en forced to initia lize each object by calling some operation declared in the visible part of 
the package.  
7  The ancestor type specified in a private_extension_declaration  and the parent type specified in the corresponding 
declaration of a record extension given in the private part need not be the same. If the ancestor type is not an interface type, the parent type of the full view can be any descendant of the ancestor type. In this case, for a primitive subprogram that is inherited from the ancestor type and not overridden, the formal parameter names and default expressions (if any) come from the corresponding primitive subprogram of the specified ancestor type, while the body comes from the corresponding primitive subprogram of the parent type of the full view. See 3.9.2. 
8  If the ancestor type specified in a 
private_extension_declaration  is an interface type, the parent type can be any type so 
long as the full view is a descendant of the ancestor type. The progenitor types specified in a 
private_extension_declaration  and the progenitor types specified in the corresponding declaration of a record extension 
given in the private part need not be the same — the only requirement is that the private extension and the record extension be descended from the same set of interfaces.  10.1/3 
11 
12 13 
14 
15/3 
16/3 
17 
18 
19/2 
20/2 
20.1/2 
Ada Reference Manual — 2012 Edition 
7.3   Private Types and Private Extensions 13 December 2012      178 Examples 
Examples of private type declarations:   
type Key is private; 
type File_Name is limited private; 
Example of a private extension declaration:   
type List is new Ada.Finalization.Controlled with private; 
7.3.1 Private Operations 
For a type declared in the visible part of a packag e or generic package, certain operations on the type do 
not become visible until later in the package — either in the private part or the body. Such private 
operations  are available only inside the declarative re gion of the package or generic package.  
Static Semantics 
The predefined operators that exist for a given type  are determined by the classes to which the type 
belongs. For example, an integer type has a predef ined "+" operator. In most cases, the predefined 
operators of a type are declared immediately after th e definition of the type; the exceptions are explained 
below. Inherited subprograms are also implicitly decl ared immediately after the definition of the type, 
except as stated below. 
For a composite type, the characteristics (see 7.3) of th e type are determined in part by the characteristics 
of its component types. At the place where the com posite type is declared, the only characteristics of 
component types used are those characteristics visibl e at that place. If later immediately within the 
declarative region in which the composite type is d eclared additional characteristics become visible for a 
component type, then any corres ponding characteristics become visible for the composite type. Any 
additional predefined operators are implicitly declar ed at that place. If there is no such place, then 
additional predefined operators are not d eclared at all, but they still exist. 
The corresponding rule applies to a type defined by a derived_type_definition , if there is a place 
immediately within the declarative region in which the type is declared where additional characteristics of 
its parent type become visible. 
For example, an array type whose component type is limited private b ecomes nonlimited if the full view of 
the component type is nonlimited and visible at some later place immediately within the declarative region 
in which the array type is declared. In such a case, the predefined "=" ope rator is implicitly declared at that 
place, and assignment is allowed after that place. 
A type is a descendant  of the full view of some ancestor of its pa rent type only if the current view it has of 
its parent is a descendant of the full view of that ancestor. More generally, at any given place, a type is descended from the same view of an ancestor as th at from which the current view of its parent is 
descended. This view determines what characteristic s are inherited from the ancestor, and, for example, 
whether the type is considered to be a descendant of a record type, or a descendant only through record 
extensions of a more distant ancestor. 
It is possible for there to be places where a derived type is visibly a descendant of an ancestor type, but not 
a descendant of even a partial view of the ancestor type, because the parent of the derived type is not 
visibly a descendant of the ancestor.  In this case, the derived type inherits no characteristics from that ancestor, but nevertheless is within the derivation cla ss of the ancestor for the purposes of type conversion, 
the "covers" relationship, and matchi ng against a formal derived type. In  this case the derived type is 
considered to be a descendant  of an incomplete view of the ancestor. 21 
22 
23 
24 
1 
2 
3/3 
4/1 
5/1 
5.1/3 
5.2/3 
Ada Reference Manual — 2012 Edition 
179      13 December 2012 Private Operations   7.3.1 Inherited primitive subprograms follow a different rule. For a derived_type_definition , each inherited 
primitive subprogram is implicitly declar ed at the earliest place, if any, immediately within the declarative 
region in which the type_declaration  occurs, but after the type_declaration , where the corresponding 
declaration from the parent is visible. If there is no such place, then the inherited subprogram is not 
declared at all, but it still exists. For a tagged type, it is possible to dispatch to an inherited subprogram 
that is not declared at all. 
For a private_extension_declaration , each inherited subprogram is declared immediately after the 
private_extension_declaration  if the corresponding declaration from th e ancestor is visible at that place. 
Otherwise, the inherited subprogram is not declared for the private extension, though it might be for the 
full type.  
The Class attribute is defined for tagged subtypes in 3.9. In addition, for every subtype S of an untagged 
private type whose full view is tagged,  the following attribute is defined:  
S'Class Denotes the class-wide subtype corresponding to the full vi ew of S. This attribute is 
allowed only from the beginning of the private pa rt in which the full view is declared, until 
the declaration of the full view. After the full view, the Class attribute of the full view can 
be used.  
NOTES 
9  Because a partial view and a full view are two different views of one and the same type, outside of the defining package the characteristics of the type are those defined by the visible part. Within these outside program units the type is just a private type or private extension, and any language rule that applies only to another class of types does not apply. The fact that the full declaration might implement a private type with a type of a particular class (for example, as an array type) is relevant only within the declarative region of the package itself including any child units. 
The consequences of this actual implementation are, however, valid everywhere. For example: any default initialization of 
components takes place; the attribute Si ze provides the size of the full view; fi nalization is still done for controlled 
components of the full view; task dependence rules still apply to components that are task objects. 
10  Partial views provide initialization, membership tests, selected components for the selection of discriminants and 
inherited components, qualification, and explicit conversion. Nonlimited partial views also allow use of 
assignment_statement s. 
11  For a subtype S of a partial view, S'Size is defined (see 13.3). For an object A of a partial view, the attributes A'Size 
and A'Address are defined (see 13.3). The Position, First_Bit, and Last_Bit attributes are also defined for discriminants and inherited components.  
Examples 
Example of a type with private operations:   
package Key_Manager is 
   type Key is private; 
   Null_Key : constant  Key; --  a deferred constant declaration (see 7.4)  
   procedure  Get_Key(K : out Key); 
   function  "<" (X, Y : Key) return Boolean; 
private 
   type Key is new Natural; 
   Null_Key : constant  Key := Key'First; 
end Key_Manager; 6/3 
7 
8 
9 
10 
11 
12/2 
13 
14 
15 
Ada Reference Manual — 2012 Edition 
7.3.1    Private Operations 13 December 2012      180 package body Key_Manager is 
   Last_Key : Key := Null_Key;    procedure  Get_Key(K : out Key) is 
   begin 
      Last_Key := Last_Key + 1;       K := Last_Key;    end Get_Key; 
   function  "<" (X, Y : Key) return Boolean is 
   begin 
      return Natural(X) < Natural(Y); 
   end "<"; 
end Key_Manager; 
NOTES 
12  Notes on the example:  Outside of the package Key_Manager, the operations available for objects of type Key include 
assignment, the comparison for equality or inequality, the procedure Get_Key and the operator "<"; they do not include other relational operators such as ">=", or arithmetic operators. 
The explicitly declared operator "<" hides the predefined operator "<" implicitly declared by the 
full_type_declaration . 
Within the body of the function,  an explicit c onversion of X and Y to the subtype Na tural is necessary to invoke the "<" 
operator of the parent type. Alternatively, the result of the function could be written as not (X >= Y), since the operator ">=" is not redefined. 
The value of the variable Last_Key, declared in the package body, remains unchanged between calls of the procedure 
Get_Key. (See also the NOTES of 7.2.)  
7.3.2 Type Invariants 
For a private type or private extension, the followi ng language-defined aspects may be specified with an 
aspect_specification  (see 13.1.1): 
Type_Invariant 
 This aspect shall be specified by an expression , called an invariant expression . 
Type_Invariant may be specified on a private_type_declaration , on a private_extension_-
declaration , or on a full_type_declaration  that declares the completion of a private type or 
private extension. 
Type_Invariant'Class 
 This aspect shall be specified by an expression , called an invariant expression . 
Type_Invariant'Class may be specified on a private_type_declaration  or a private_-
extension_declaration . 
Name Resolution Rules 
The expected type for an invariant expression is any boolean type. 
Within an invariant expression, the identifier of the fi rst subtype of the associated type denotes the current 
instance of the type. Within an invariant expression associated with type T, the type of the current instance 
is T for the Type_Invariant aspect and T'Class for the Type_Invariant'Class aspect. 
Legality Rules 
The Type_Invariant'Class aspect shall not be specifi ed for an untagged type. The Type_Invariant aspect 
shall not be specified for an abstract type. 
Static Semantics 
If the Type_Invariant aspect is specified for a type T, then the invariant expression applies to T. 
If the Type_Invariant'Class aspect is specified for a tagged type T, then the invariant expression applies to 
all descendants of T. 16 
17 
18 
19 
20 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
Ada Reference Manual — 2012 Edition 
181      13 December 2012 Type Invariants   7.3.2 Dynamic Semantics 
If one or more invariant expressions apply to a type T, then an invariant check is performed at the 
following places, on the specified object(s): 
• After successful default initialization of an object of type T, the check is performed on the new 
object; 
• After successful conversion to type T, the check is performed on th e result of the conversion; 
• For a view conversion, outsi de the immediate scope of T, that converts from a descendant of T 
(including T itself) to an ancestor of type T (other than T itself), a check is performed on the part 
of the object that is of type T: 
• after assigning to the view conversion; and 
• after successful return from a call th at passes the view conversion as an in out  or out 
parameter.  
• After a successful call on the Read or Input stream attribute of the type T, the check is performed 
on the object initialized by the stream attribute; 
• An invariant is checked upon successful return  from a call on any subprogram or entry that:  
• is declared within the immediate scope of type T (or by an instance of a generic unit, and 
the generic is declared within the immediate scope of type T), and 
• is visible outside the immediate scope of type T or overrides an operation that is visible 
outside the immediate scope of T, and 
• has a result with a part of type T, or one or more parameters with a part of type T, or an 
access to variable parameter whose designated type has a part of type T.  
 The check is performed on each such part of type T.  
If performing checks is required by the Invariant or Inva riant'Class assertion policie s (see 11.4.2) in effect 
at the point of corresponding aspect specification appli cable to a given type, then the respective invariant 
expression is considered enabled . 
The invariant check consists of the evaluation of each enabled invariant expression that applies to T, on 
each of the objects specified above. If any of these eval uate to False, Assertions .Assertion_Error is raised 
at the point of the object initialization, conversion,  or call. If a given call requires more than one 
evaluation of an invariant expression, either for multip le objects of a single type or for multiple types with 
invariants, the evaluations are performed in an arbitrary order, and if one of them evaluates to False, it is 
not specified whether the others are evaluated. Any i nvariant check is performed prior to copying back any 
by-copy in out  or out parameters. Invariant checks, any pos tcondition check, and any constraint or 
predicate checks associated with in out  or out parameters are performed in an arbitrary order. 
The invariant checks performed on a call are determin ed by the subprogram or entry actually invoked, 
whether directly, as part of a dispatching call, or as part of a call through an access-to-subprogram value. 
NOTES 
13  For a call of a primitive subprogram of type NT that is inherited from type T, the specified checks of the specific 
invariants of both the types NT and T are performed. For a call of a primitive subprogram of type NT that is overridden for 
type NT, the specified checks of the specific invariants of only type NT are performed. 9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 16/3 
17/3 
18/3 19/3 20/3 
21/3 
22/3 
23/3 
24/3 
Ada Reference Manual — 2012 Edition 
7.4   Deferred Constants 13 December 2012      182 7.4 Deferred Constants 
Deferred constant declarations may be used to declare constants in the visible part of a package, but with 
the value of the constant given in the private part. They may also be used to declare constants imported 
from other languages (see Annex B).  
Legality Rules 
A deferred constant declaration  is an object_declaration  with the reserved word constant  but no 
initialization expression. The constant declared by a deferred constant declaration is called a deferred 
constant . Unless the Import aspect (see B.1) is True for a deferred constant declaration, the  deferred 
constant declaration requires a co mpletion, which shall be a full constant declaration (called the full 
declaration  of the deferred constant).  
A deferred constant declaration that  is completed by a full constant declaration shall occur immediately 
within the visible part of a package_specification . For this case, the following additional rules apply to 
the corresponding full declaration:  
• The full declaration shall occur immediately w ithin the private part of the same package; 
• The deferred and full constants shall have the same type, or shall have statically matching 
anonymous access subtypes;  
• If the deferred constant declaration includes a subtype_indication  S that defines a constrained 
subtype, then the constraint defined by the subtype_indication  in the full declaration shall match 
the constraint defined by S statically. On the other hand, if the subtype of the deferred constant is 
unconstrained, then the full declaration is still a llowed to impose a constraint. The constant itself 
will be constrained, like all constants; 
• If the deferred constant declara tion includes the reserved word aliased , then the full declaration 
shall also;  
• If the subtype of the deferred constant decl aration excludes null, the subtype of the full 
declaration shall also exclude null.  
A deferred constant declaration for which the Import aspect  is True need not appear in the visible part of a 
package_specification , and has no full constant declaration. 
The completion of a deferred constant declaration sh all occur before the cons tant is frozen (see 13.14). 
Dynamic Semantics 
The elaboration of a deferred constant declaration elaborates the subtype_indication , access_definition , 
or (only allowed in the case of an imported constant) the array_type_definition .  
NOTES 
14  The full constant declaration for a deferred constant that is of a given private type or private extension is not allowed before the corresponding 
full_type_declaration . This is a consequence of the freezing rules for types (see 13.14).  
Examples 
Examples of deferred constant declarations:   
Null_Key : constant  Key;      --  see 7.3.1 
CPU_Identifier : constant  String(1..8) 
   with Import => True, Convention => Assembler, Link_Name => "CPU_ID"; 
                              --  see B.1 1 
2/3 
3 
4 
5/2 
6/3 
7/2 
7.1/2 
8/3 
9/2 
10/3 
11 
12 
13 
14/3 
Ada Reference Manual — 2012 Edition 
183      13 December 2012 Limited Types   7.5 7.5 Limited Types 
A limited type is (a view of) a type  for which copying (such as for an assignment_statement ) is not 
allowed. A nonlimited type is a (view of a)  type for which copying is allowed.  
Legality Rules 
If a tagged record type has any limited components, then the reserved word limited  shall appear in its 
record_type_definition . If the reserved word limited  appears in the definition of a 
derived_type_definition , its parent type and any progenitor interfaces shall be limited.  
In the following contexts, an expression  of a limited type is not permitted unless it is an aggregate , a 
function_call , a parenthesized expression  or qualified_expression  whose operand is permitted by this 
rule, or a conditional_expression  all of whose dependent_ expression s are permitted by this rule:  
• the initialization expression  of an object_declaration  (see 3.3.1) 
• the default_expression  of a component_declaration  (see 3.8) 
• the expression  of a record_component_association  (see 4.3.1) 
• the expression  for an ancestor_part  of an extension_aggregate  (see 4.3.2) 
• an expression  of a positional_array_aggregate  or the expression  of an 
array_component_association  (see 4.3.3) 
• the qualified_expression  of an initialized allocator (see 4.8) 
• the expression  of a return statement (see 6.5) 
• the expression  of an expression_function_declaration  (see 6.8) 
• the default_expression  or actual parameter for a formal object of mode in (see 12.4) 
Static Semantics 
A view of a type is limited  if it is one of the following:  
• a type with the reserved word limited , synchronized , task, or protected  in its definition;  
• a class-wide type whose specific type is limited; 
• a composite type w ith a limited component; 
• an incomplete view; 
• a derived type whose parent is limited and is not an interface. 
Otherwise, the type is nonlimited. 
There are no predefined equality operators for a limited type. A type is immutably limited  if it is one of the following: 
• An explicitly limited record type; 
• A record extension with the reserved word limited ; 
• A nonformal limited private type that is tagged or has at least one access discriminant with a 
default_expression ; 
• A task type, a protected type, or a synchronized interface; 
• A type derived from an immutably limited type. 1/2 
2/2 
2.1/3 
2.2/2 
2.3/2 2.4/2 2.5/2 2.6/2 
2.7/2 
2.8/2 2.9/3 
2.10/3 
3/3 
4/2 
5/3 6/2 
6.1/3 6.2/2 
7 
8 
8.1/3 
8.2/3 
8.3/3 8.4/3 
8.5/3 
8.6/3 
Ada Reference Manual — 2012 Edition 
7.5   Limited Types 13 December 2012      184 A descendant of a generic formal limited private type  is presumed to be immutably limited except within 
the body of a generic unit or a body declared within th e declarative region of a generic unit, if the formal 
type is declared within the fo rmal part of the generic unit. 
NOTES 
15  While it is allowed to write initializations of limited objects, such initializations never copy a limited object. The source of such an assignment operation must be an 
aggregate  or function_call , and such aggregate s and function_call s 
must be built directly in the target object (see 7.6).  
Paragraphs 10 through 15 were deleted.   
16  As illustrated in 7.3.1, an untagged limited type can become nonlimited under certain circumstances.  
Examples 
Example of a package with a limited type:   
package IO_Package is 
   type File_Name is limited private; 
   procedure  Open (F : in out File_Name); 
   procedure  Close(F : in out File_Name); 
   procedure  Read (F : in File_Name; Item : out Integer); 
   procedure  Write(F : in File_Name; Item : in  Integer); 
private 
   type File_Name is 
      limited record 
         Internal_Name : Integer := 0;       end record; 
end IO_Package; 
package body IO_Package is 
   Limit : constant  := 200; 
   type File_Descriptor is record  ...  end record; 
   Directory : array (1 .. Limit) of File_Descriptor; 
   ...    procedure  Open (F : in out File_Name) is  ...  end; 
   procedure  Close(F : in out File_Name) is  ...  end; 
   procedure  Read (F : in File_Name; Item : out Integer) is ... end; 
   procedure  Write(F : in File_Name; Item : in  Integer) is ... end; 
begin 
   ... end IO_Package; 
NOTES 
17  Notes on the example:  In the example above, an outside subprogram making use of IO_Package may obtain a file 
name by calling Open and later use it in calls to Read and Write. Thus, outside the package, a file name obtained from Open acts as a kind of password; its internal properties (such as containing a numeric value) are not known and no other operations (such as addition or comparison of internal names) can be performed on a file name. Most importantly, clients of the package cannot make copies of objects of type File_Name. 
This example is characteristic of any case where complete control over the operations of a type is desired. Such packages 
serve a dual purpose. They prevent a user from making use of the internal structure of the type. They also implement the notion of an encapsulated data type where the only operations on the type are those given in the package specification. 
The fact that the full view of File_Name is explicitly declared limited  means that parameter passing will always be by 
reference and function results will always be built directly in the result object (see 6.2 and 6.5). 8.7/3 
9/3 
16 
17 
18 
19 
20 
21 
22 
23/2 
Ada Reference Manual — 2012 Edition 
185      13 December 2012 Assignment and Finalization   7.6 7.6 Assignment and Finalization 
Three kinds of actions are fundamental to the mani pulation of objects: initialization, finalization, and 
assignment. Every object is initialized, either explicitly or by default, after being created (for example, by 
an object_declaration  or allocator ). Every object is finalized before  being destroyed (for example, by 
leaving a subprogram_body  containing an object_declaration , or by a call to an instance of 
Unchecked_Deallocation). An assignmen t operation is used as part of assignment_statement s, explicit 
initialization, parameter passi ng, and other operations.  
Default definitions for these three fundamental  operations are provided by the language, but a controlled  
type gives the user additional control over parts of thes e operations. In particular, the user can define, for a 
controlled type, an Initialize procedure which is invoked immediately after the normal default initialization of a controlled object, a Finalize procedur e which is invoked immediately before finalization 
of any of the components of a controlled object, and an Adjust procedure which is invoked as the last step 
of an assignment to a (non limited) controlled object.  
Static Semantics 
The following language-defined library package exists:  
package Ada.Finalization is 
    pragma Pure(Finalization); 
    type Controlled is abstract tagged private ; 
    pragma Preelaborable_Initialization(Controlled); 
    procedure  Initialize (Object : in out Controlled) is null; 
    procedure  Adjust     (Object : in out Controlled) is null; 
    procedure  Finalize   (Object : in out Controlled) is null; 
    type Limited_Controlled is abstract tagged limited private ; 
    pragma Preelaborable_Initialization(Limited_Controlled); 
    procedure  Initialize (Object : in out Limited_Controlled) is null; 
    procedure  Finalize   (Object : in out Limited_Controlled) is null; 
private 
    ... -- not specified by the language  
end Ada.Finalization; 
A controlled type is a descendant of Controlled or  Limited_Controlled. The predefined "=" operator of 
type Controlled always returns True, since this opera tor is incorporated into the implementation of the 
predefined equality operator of types derived from Controlled, as explained in 4.5.2. The type 
Limited_Controlled is like Controlled, except that it is limited and it lacks the primitive subprogram 
Adjust.  
A type is said to need finalization  if: 
• it is a controlled type, a task type or a protected type; or 
• it has a component whose type  needs finalization; or 
• it is a class-wide type; or 
• it is a partial view whose fu ll view needs finalization; or 
• it is one of a number of language-defined types th at are explicitly defined to need finalization. 
Dynamic Semantics 
During the elaboration or evaluation of a construct that  causes an object to be initialized by default, for 
every controlled subcomponent of the object that is not assigned an initial value (as defined in 3.3.1), 1 
2 
3 
4/3 
5/2 6/2 
7/2 
8/2 
9/2 
9.1/2 
9.2/2 
9.3/3 9.4/3 9.5/3 9.6/2 
10/2 
Ada Reference Manual — 2012 Edition 
7.6   Assignment and Finalization 13 December 2012      186 Initialize is called on that subcomponent. Similarly, if th e object that is initialized by default as a whole is 
controlled, Initialize is called on the object. 
For an extension_aggregate  whose ancestor_part  is a subtype_mark  denoting a controlled subtype, the 
Initialize procedure of the ancestor type is called, unless that Initialize procedure is abstract.  
Initialize and other initialization operations are done in an arbitrary order, excep t as follows. Initialize is 
applied to an object after initialization of its subc omponents, if any (including both implicit initialization 
and Initialize calls). If an object has a component with  an access discriminant constrained by a per-object 
expression, Initialize is applied to this compone nt after any components that do not have such 
discriminants. For an object with se veral components with such a discriminant, Initialize is applied to them 
in order of their component_declaration s. For an allocator , any task activations follow all calls on 
Initialize.  
When a target object with any controlled parts is assigne d a value, either when created or in a subsequent 
assignment_statement , the assignment operation  proceeds as follows:  
• The value of the target becomes the assigned value. 
• The value of the target is adjusted.   
To adjust the value of a composite object, the values of the components of  the object are first adjusted in 
an arbitrary order, and then, if the object is nonlimited controlled, Adjust is called. Adjusting the value of 
an elementary object has no effect, nor does adjusti ng the value of a composite object with no controlled 
parts.  
For an assignment_statement ,  after the name  and expression  have been evaluated, and any conversion 
(including constraint checking) has been done, an a nonymous object is created, and the value is assigned 
into it; that is, the assignment operation is applied. (Assignment includes value adjustment.) The target of 
the assignment_statement  is then finalized. The value of the a nonymous object is then assigned into the 
target of the assignment_statement . Finally, the anonymous object is fi nalized. As explained below, the 
implementation may eliminat e the intermediate anonymous object, so  this description subsumes the one 
given in 5.2, “Assignment Statements”.  
When a function call or aggregate  is used to initialize an object, the result of the function call or 
aggregate  is an anonymous object, which is assigned into the newly-created object. For such an 
assignment, the anonymous object might be built in place , in which case the assignment does not involve 
any copying. Under certain circumstances, the anony mous object is required to be built in place. In 
particular: 
• If the full type of any part of the object is immutably limited, the anonymous object is built in 
place. 
• In the case of an aggregate , if the full type of any part of the newly-created object is controlled, 
the anonymous object is built in place. 
• In other cases, it is unspecified whethe r the anonymous object is built in place. 
Notwithstanding what this International Standard says elsewhere, if an object is built in place: 
• Upon successful completion of the return statement or aggregate , the anonymous object mutates 
into the newly-created object; that is, the anony mous object ceases to exist, and the newly-
created object appears in its place. 
• Finalization is not perform ed on the anonymous object. 
• Adjustment is not performed on the newly-created object. 11/2 
12 
13 
14 
15 
16/3 
17 
17.1/3 
17.2/3 
17.3/3 17.4/3 
17.5/3 
17.6/3 
17.7/3 
17.8/3 
Ada Reference Manual — 2012 Edition 
187      13 December 2012 Assignment and Finalization   7.6 • All access values that designate parts of th e anonymous object now designate the corresponding 
parts of the newly-created object. 
• All renamings of parts of the anonymous object  now denote views of the corresponding parts of 
the newly-created object. 
• Coextensions of the anonymous object become  coextensions of the newly-created object.  
Implementation Permissions 
An implementation is allowed to relax the above rules for assignment_statement s in the following ways:  
• If an object is assigned the value of that same  object, the implementation need not do anything.  
• For assignment of a noncontrolled type, the implementation may finalize and assign each 
component of the variable separately (rather th an finalizing the entire variable and assigning the 
entire new value) unless a discriminant of th e variable is changed by the assignment.  
• The implementation need not create an anonym ous object if the value being assigned is the 
result of evaluating a name  denoting an object (the source object) whose storage cannot overlap 
with the target. If the source object might overlap with the target object, then the implementation 
can avoid the need for an intermediary anony mous object by exercising one of the above 
permissions and perform the assignment one co mponent at a time (for an overlapping array 
assignment), or not at all (for an assignment where the target and the source of the assignment are the same object).  
Furthermore, an implementation is permitted to om it implicit Initialize, Adjust, and Finalize calls and 
associated assignment operations on an object of a nonlimited controlled type provided that: 
• any omitted Initialize call is not a call on a user-defined Initialize procedure, and  
• any usage of the value of the object after the implicit Initialize or Adjust call and before any 
subsequent Finalize call on the object does not cha nge the external effect of the program, and 
• after the omission of such calls and operations, any execution of the program that executes an 
Initialize or Adjust call on an object or initializes an object by an 
aggregate  will also later 
execute a Finalize call on the object and will always do so prior to assigning a new value to the object, and 
• the assignment operations associated with  omitted Adjust calls are also omitted.  
This permission applies to Adjust and Finalize calls even if the implicit calls have additional external 
effects.  
7.6.1 Completion and Finalization 
This subclause defines completion  and leaving  of the execution of constructs and entities. A master  is the 
execution of a construct that includes finalization of local objects after it is complete (and after waiting for 
any local tasks — see 9.3), but before leaving. Ot her constructs and entities are left immediately upon 
completion.  
Dynamic Semantics 
The execution of a construct or entity is complete  when the end of that execution has been reached, or 
when a transfer of control (see 5.1) causes it to be abandoned. Completion due to reaching the end of 
execution, or due to the transfer of control of an exit_statement , return statement, goto_statement , or 
requeue_statement  or of the selection of a terminate_alternative  is normal completion . Completion is 
abnormal  otherwise — when control is transferred out of a construct due to abort or the raising of an 
exception.  17.9/3 
17.10/3 17.11/3 
18/3 
19/3 
20/3 
21/3 
22/2 
23/2 
24/2 
25/2 
26/2 
27/2 
1 
2/2 
Ada Reference Manual — 2012 Edition 
7.6.1    Completion and Finalization 13 December 2012      188 After execution of a construct or entity is complete, it is left, meaning that execution continues with the 
next action, as defined for the execution that is taking place. Leaving an execution happens immediately 
after its completion, except in the case of a master : the execution of a body other than a package_body ; 
the execution of a statement ; or the evaluation of an expression , function_call , or range  that is not part of 
an enclosing expression , function_call , range , or simple_statement  other than a simple_return_-
statement . A master is finalized after it is complete, and before it is left. 
For the finalization  of a master, dependent tasks are first awaited, as explained in 9.3. Then each object 
whose accessibility level is the same as that of the master is finalized if the object was successfully 
initialized and still exists. Th ese actions are performed whether the ma ster is left by reaching the last 
statement or via a transfer of control. When a tran sfer of control causes completion of an execution, each 
included master is finalized in order, from innermost outward.  
For the finalization  of an object:  
• If the full type of the object is an elementary type, finalization has no effect;  
• If the full type of the object is a tagged type, and the tag of the object identifies a controlled 
type, the Finalize procedure of that controlled type is called; 
• If the full type of the object is a protected type, or if the full type of the object is a tagged type 
and the tag of the object identifies a protected type, the actions defined in 9.4 are performed; 
• If the full type of the object is a composite type , then after performing the above actions, if any, 
every component of the object is finalized in an arbitrary order, except as  follows: if the object 
has a component with an access discriminant c onstrained by a per-object expression, this 
component is finalized before any components that  do not have such discri minants; for an object 
with several components with such  a discriminant, they are finalized in the reverse of the order 
of their component_declaration s;  
• If the object has coextensions (see 3.10.2), each coextension is finalized after the object whose 
access discriminant designates it. 
Immediately before an instance of Unchecked_Deallocati on reclaims the storage of an object, the object is 
finalized. If an instance of Unchecked_Deallocation is never applied to an object created by an allocator , 
the object will still exist when th e corresponding master completes, and it will be finalized then. 
The finalization of a master performs finalization of objects created by declarations in the master in the 
reverse order of their creation. After the finalization of a master is complete, the objects finalized as part of its finalization cease to exist, as do any types and subtypes define d and created within the master.  
Each nonderived access type T has an associated collection , which is the set of objects created by 
allocator s of T, or of types derived from T. Unchecked_Deallocation removes an object from its collection. 
Finalization of a collection consists of finalization of each object in the collection, in an arbitrary order. 
The collection of an access type is an object  implicitly declared at the following place: 
• For a named access type, the first freezing point (see 13.14) of the type. 
• For the type of an access parameter, the call that contains the allocator . 
• For the type of an access result, within  the master of the call (see 3.10.2).  
• For any other anonymous access type, the first freezing point of the innermost enclosing 
declaration.  
The target of an assignment_statement  is finalized before copying in th e new value, as explained in 7.6. 
The master of an object is the master enclosing its  creation whose accessibility level (see 3.10.2) is equal 
to that of the object, except in the case of an  anonymous object representing the result of an aggregate  or 3/2 
4 
5 
6/3 
7/3 
8/3 9/3 
9.1/2 
10 
11/3 
11.1/3 
11.2/3 
11.3/3 11.4/3 11.5/3 
12/2 
13/3 
Ada Reference Manual — 2012 Edition 
189      13 December 2012 Completion and Finalization   7.6.1 function call. If such an anonymous object is part  of the result of evaluating the actual parameter 
expression for an explicitly aliased parameter of a func tion call, the master of the object is the innermost 
master enclosing the evaluation of the aggregate  or function call, excluding the aggregate  or function call 
itself. Otherwise, the master of su ch an anonymous object is the innerm ost master enclosing the evaluation 
of the aggregate  or function call, which may be the aggregate  or function call itself.  
In the case of an expression  that is a master, finalization of  any (anonymous) objects occurs after 
completing evaluation of the expression  and all use of the objects, prior to starting the execution of any 
subsequent construct. 
Bounded (Run-Time) Errors 
It is a bounded error for a call on Finalize or Adjust that  occurs as part of object finalization or assignment 
to propagate an exception. The possible conseque nces depend on what action invoked the Finalize or 
Adjust operation:  
• For a Finalize invoked as part of an assignment_statement , Program_Error is raised at that 
point. 
• For an Adjust invoked as part of assignment ope rations other than those invoked as part of an 
assignment_statement , other adjustments due to be pe rformed might or might not be 
performed, and then Program_Error is raised. During its propagation,  finalization might or might 
not be applied to objects whose Adjust faile d. For an Adjust invoked as part of an 
assignment_statement , any other adjustments due to be performed are performed, and then 
Program_Error is raised.  
• For a Finalize invoked as part of a call on an  instance of Unchecked_Deallocation, any other 
finalizations due to be performed are perfo rmed, and then Program _Error is raised.  
• This paragraph was deleted.  
• For a Finalize invoked due to reaching the end of the execution of a master, any other 
finalizations associated with the master are performed, and Program_Error is raised immediately after leaving the master. 
• For a Finalize invoked by the transfer of control of an 
exit_statement , return statement, 
goto_statement , or requeue_statement , Program_Error is raised no earlier than after the 
finalization of the master being finalized when  the exception occurred, and no later than the 
point where normal execution would have conti nued. Any other finalizations due to be 
performed up to that point are perform ed before raising Program_Error.  
• For a Finalize invoked by a transfer of control that is due to raising an exception, any other 
finalizations due to be performed for the same  master are performed; Program_Error is raised 
immediately after leaving the master.  
• For a Finalize invoked by a transfer of control due to an abort or selection of a terminate 
alternative, the exception is ignored; any other fi nalizations due to be pe rformed are performed.  
Implementation Permissions 
If the execution of an allocator  propagates an exception, any parts of the allocated object that were 
successfully initialized may be finalized as part of th e finalization of the innermost master enclosing the 
allocator . 
The implementation may finalize objects created by allocator s for an access type whose storage pool 
supports subpools (see 13.11.4) as if the objects were creat ed (in an arbitrary order) at the point where the 
storage pool was elaborated instead of at the first freezing point of the access type. 13.1/3 
14/1 
15 
16/2 
17 
17.1/3 
17.2/1 
18/2 
19 
20 
20.1/3 
20.2/3 
Ada Reference Manual — 2012 Edition 
7.6.1    Completion and Finalization 13 December 2012      190 NOTES 
18  The rules of Clause 10 imply that immediately prior to partition termination, Finalize operations are applied to library-level controlled objects (including those created by 
allocator s of library-level access types, except those already finalized). 
This occurs after waiting for library-level tasks to terminate.  
19  A constant is only constant between its initialization and finalization. Both initialization and finalization are allowed t o 
change the value of a constant. 
20  Abort is deferred during certain operations related to controlled types, as explained in 9.8. Those rules prevent an 
abort from causing a controlled object to be left in an ill-defined state. 
21  The Finalize procedure is called upon finalization of a controlled object, even if Finalize was called earlier, either 
explicitly or as part of an assignment; hence, if a controlled type is visibly controlled (implying that its Finalize primitive  
is directly callable), or is nonlimited (implying that assignment is allowed), its Finalize procedure should be designed to have no ill effect if it is applied a second time to the same object.  21/3 
22 
23 24 
Ada Reference Manual — 2012 Edition 
191      13 December 2012 Visibility Rules   8 8   Visibility Rules 
The rules defining the scope of declar ations and the rules defining which identifier s, character_literal s, 
and operator_symbol s are visible at (or from) various places in the text of the program are described in 
this clause. The formulation of these rules uses the notion of a declarative region. 
As explained in Clause 3, a declaration declares a vi ew of an entity and associates a defining name with 
that view. The view comprises an identification of the viewed entity, and possibly additional properties. A 
usage name denotes a declaration. It also denotes the view declared by that declaration, and denotes the 
entity of that view. Thus, two different usage names might denote two different views of the same entity; 
in this case they denote the same entity.  
8.1 Declarative Region 
Static Semantics 
For each of the following constructs, there is a portion of the program text called its declarative region , 
within which nested declarations can occur:  
• any declaration, other than that of an enumera tion type, that is not a completion of a previous 
declaration; 
• a block_statement ; 
• a loop_statement ; 
• a quantified_expression ; 
• an extended_return_statement ; 
• an accept_statement ; 
• an exception_handler .  
The declarative region includes the text of the cons truct together with additional text determined 
(recursively), as follows:  
• If a declaration is included, so  is its completion, if any. 
• If the declaration of a library unit (including St andard — see 10.1.1) is included, so are the 
declarations of any child units (and their completions, by the previous rule). The child declarations occur after the declaration. 
• If a 
body_stub  is included, so is the corresponding subunit . 
• If a type_declaration  is included, then so is a corresponding record_representation_clause , if 
any.  
The declarative region of a declaration is also called the declarative region  of any view or entity declared 
by the declaration.  
A declaration occurs immediately within  a declarative region if this region is the innermost declarative 
region that encloses the declaration (the immediately enclosing  declarative region), not counting the 
declarative region (if any) associated with the declaration itself.  
A declaration is local  to a declarative region if the declaration occurs immediately within the declarative 
region. An entity is local  to a declarative region if the entity is decl ared by a declaration that is local to the 
declarative region.  1/3 
2/3 
1 
2 
3 
4 
4.1/3 4.2/3 
5 6 
7 
8 
9 
10 
11 
12 
13 
14 
Ada Reference Manual — 2012 Edition 
8.1   Declarative Region 13 December 2012      192 A declaration is global  to a declarative region if the declara tion occurs immediately within another 
declarative region that encloses th e declarative region. An entity is global  to a declarative region if the 
entity is declared by a declaration that  is global to the declarative region.  
NOTES 
1  The children of a parent library unit are inside the parent's declarative region, even though they do not occur inside the parent's declaration or body. This implies that one can use (for example) "P.Q" to refer to a child of P whose defining name is Q, and that after " use P;" Q can refer (directly) to that child. 
2  As explained above and in 10.1.1, “Compilation Units - Library Units”, all library units are descendants of Standard, 
and so are contained in the declarative region of Standard. They are not inside the declaration or body of Standard, but 
they are inside its declarative region. 
3  For a declarative region that comes in multiple parts, the text of the declarative region does not contain any text that 
might appear between the parts. Thus, when a portion of a declarative region is said to extend from one place to another in the declarative region, the portion does not contain any text that might appear between the parts of the declarative region.  
8.2 Scope of Declarations 
For each declaration, the language rules define a certain portion of the program text called the scope  of the 
declaration. The scope of a declaration is also calle d the scope of any view or entity declared by the 
declaration. Within the scope of an entity, and only ther e, there are places where it is legal to refer to the 
declared entity. These places are defined by the rules of visibility and overloading.  
Static Semantics 
The immediate scope  of a declaration is a portion of the declarative region immediately enclosing the 
declaration. The immediate scope starts at the begi nning of the declaration, except in the case of an 
overloadable declaration, in which case the immediate sc ope starts just after the place where the profile of 
the callable entity is determined (which is at the end of the _specification  for the callable entity, or at the 
end of the generic_instantiation  if an instance). The immediate scope extends to the end of the declarative 
region, with the following exceptions:  
• The immediate scope of a library_item  includes only its semantic dependents.  
• The immediate scope of a declaration in the pr ivate part of a library unit does not include the 
visible part of any public descendant of that library unit.  
The visible part  of (a view of) an entity is a portion of the text of its declaration containing declarations 
that are visible from outside. The private part  of (a view of) an entity that has a visible part contains all 
declarations within the declaration of  (the view of) the entity, except thos e in the visible part; these are not 
visible from outside. Visible and private parts are defi ned only for these kinds of entities: callable entities, 
other program units, a nd composite types.  
• The visible part of a view of  a callable entity is its profile. 
• The visible part of a composite type other th an a task or protected type consists of the 
declarations of all components declared  (explicitly or implicitly) within the type_declaration . 
• The visible part of a generic unit includes the generic_formal_part . For a generic package, it 
also includes the first list of basic_declarative_item s of the package_specification . For a 
generic subprogram, it also includes the profile.  
• The visible part of a package, task unit, or prot ected unit consists of decl arations in the program 
unit's declaration other than those following the reserved word private , if any; see 7.1 and 12.7 
for packages, 9.1 for task units , and 9.4 for protected units.  15 
16 
17 
18 
1 
2 
3 
4 
5 
6 
7 
8 
9 
Ada Reference Manual — 2012 Edition 
193      13 December 2012 Scope of Declarations   8.2 The scope of a declaration always contains the immediat e scope of the declaration. In addition, for a given 
declaration that occurs immediately within the visible part  of an outer declaration, or is a public child of an 
outer declaration, the scope of the given declara tion extends to the end of the scope of the outer 
declaration, except that the scope of a library_item  includes only its semantic dependents.  
The scope of an attribute_definition_clause  is identical to the scope of a declaration that would occur at 
the point of the attribute_definition_clause . The scope of an aspect_specification  is identical to the scope 
of the associated declaration. 
The immediate scope of a declaration is also the imme diate scope of the entity or view declared by the 
declaration. Similarly, the scope of a declaration is also the scope of the entity or view declared by the 
declaration.  
NOTES 
4  There are notations for denoting visible declarations that are not directly visible. For example, parameter_-
specification s are in the visible part of a subprogram_declaration  so that they can be used in named-notation calls 
appearing outside the called subprogram. For another example, declarations of the visible part of a package can be denoted by expanded names appearing outside the package, and can be made directly visible by a 
use_clause .  
8.3 Visibility 
The visibility rules , given below, determine which declarations are visible and directly visible at each 
place within a program. The visibility rules appl y to both explicit and implicit declarations.  
Static Semantics 
A declaration is defined to be directly visible  at places where a name  consisting of only an identifier  or 
operator_symbol  is sufficient to denote the declaration; that is, no selected_component  notation or 
special context (such as preceding => in a named association) is necessary to denote the declaration. A declaration is defined to be visible  wherever it is directly visible, as well as at other places where some 
name  (such as a selected_component ) can denote the declaration. 
The syntactic category direct_name  is used to indicate contexts wher e direct visibility is required. The 
syntactic category selector_name  is used to indicate contexts where visibility, but not direct visibility, is 
required. 
There are two kinds of direct visibility: immediate visibility  and use-visibility . A declaration is 
immediately visible at a place if it is directly visible because the place is within its immediate scope. A declaration is use-visible if it is directly visible because of a 
use_clause  (see 8.4). Both conditions can 
apply. 
A declaration can be hidden , either from direct visibility, or from a ll visibility, within certain parts of its 
scope. Where hidden from all visibility , it is not visible at all (neither using a direct_name  nor a 
selector_name ). Where hidden from direct visibility , only direct visibility is lost; visibility using a 
selector_name  is still possible. 
Two or more declarations are overloaded  if they all have the same defining name and there is a place 
where they are all directly visible.  
The declarations of callable entities (including enumeration literals) are overloadable , meaning that 
overloading is allowed for them.  
Two declarations are homographs  if they have the same defining name , and, if both are overloadable, their 
profiles are type conformant. An inner declarati on hides any outer homograph from direct visibility. 10 
10.1/3 
11 
12/3 
1 
2 
3 
4 
5 
6 
7 8 
Ada Reference Manual — 2012 Edition 
8.3   Visibility 13 December 2012      194 Two homographs are not generally allowed immediatel y within the same declarative region unless one 
overrides  the other (see Legality Rules below). The only declarations that are overridable  are the implicit 
declarations for predefined operators and inherite d primitive subprograms. A declaration overrides another 
homograph that occurs immediately within the sa me declarative region in the following cases:  
• A declaration that is not overridable overrides one that is overridable,  regardless of which 
declaration occurs first;  
• The implicit declaration of an inherited opera tor overrides that of a predefined operator;  
• An implicit declaration of an inherited subprogr am overrides a previous implicit declaration of 
an inherited subprogram. 
• If two or more homographs are implicitly declared at the same place: 
• If at least one is a subprogram  that is neither a null proce dure nor an abstract subprogram, 
and does not require overriding (see 3.9.3), then they override those that are null 
procedures, abstract subprograms, or require  overriding. If more than one such homograph 
remains that is not thus overridden, then they are all hidden from all visibility. 
• Otherwise (all are null procedures, abstract subprograms, or require overriding), then any 
null procedure overrides all abstract subpr ograms and all subprograms that require 
overriding; if more than one such homograph re mains that is not thus overridden, then if 
they are all fully conformant with one another, one is chosen arbitrarily; if not, they are all 
hidden from all visibility.  
• For an implicit declaration of a primitive subprogram  in a generic unit, there is a copy of this 
declaration in an instance. However, a whol e new set of primitive subprograms is implicitly 
declared for each type declared within the visibl e part of the instance. These new declarations 
occur immediately after the type declaration, a nd override the copied ones. The copied ones can 
be called only from within the instance; the new ones can be called only from outside the 
instance, although for tagged types, the body of a new one can be executed by a call to an old 
one.  
A declaration is visible within its scope, excep t where hidden from all visibility, as follows:  
• An overridden declaration is hidden from all visibility within the scope of the overriding 
declaration.  
• A declaration is hidden from all visibility until the end of the declaration, except:  
• For a record type or record extension, the declaration is hidden from all visibility only until 
the reserved word record ; 
• For a package_declaration , generic_package_declaration , subprogram_body , or 
expression_function_declaration , the declaration is hidden from all visibility only until the 
reserved word is of the declaration;  
• For a task declaration or protected declarati on, the declaration is hidden from all visibility 
only until the reserved word with  of the declaration if there is one, or the reserved word is 
of the declaration if there is no with . 
• If the completion of a declaration is a declarati on, then within the scope of the completion, the 
first declaration is hidden from all visibility. Similarly, a discriminant_specification  or 
parameter_specification  is hidden within the scope of a corresponding discriminant_-
specification  or parameter_specification  of a corresponding completion, or of a corresponding 
accept_statement .  
• The declaration of a library unit (including a library_unit_renaming_declaration ) is hidden from 
all visibility at places outside its declarativ e region that are not within the scope of a 
nonlimited_with_clause  that mentions it. The limited view of a library package is hidden from 9/1 
10/1 
11 
12 
12.1/2 
12.2/2 
12.3/2 
13 
14 
15 
16 
17 
18/3 
18.1/2 
19 
20/2 
Ada Reference Manual — 2012 Edition 
195      13 December 2012 Visibility   8.3 all visibility at places that are not within the scope of a limited_with_clause  that mentions it; in 
addition, the limited view is hidden from all vi sibility within the declarative region of the 
package, as well as within the scope of any nonlimited_with_clause  that mentions the package. 
Where the declaration of the limited view of a p ackage is visible, any name that denotes the 
package denotes the limited view, including those provided by a package renaming. 
• For each declaration or renaming of a generic unit as a child of some parent generic package, 
there is a corresponding declaration nested immedi ately within each instance of the parent. Such 
a nested declaration is hidden from all visibility except at places that are within the scope of a 
with_clause  that mentions the child. 
A declaration with a defining_identifier  or defining_operator_symbol  is immediately visible (and hence 
directly visible) within its immediate scope  ex cept where hidden from direct visibility, as follows:  
• A declaration is hidden from direct visibility within the immediate scope of a homograph of the 
declaration, if the homograph occurs within an inner declarative region; 
• A declaration is also hidden from direct visibility where hidden from all visibility.  
An attribute_definition_clause  or an aspect_specification  is visible  everywhere within its scope. 
Name Resolution Rules 
A direct_name  shall resolve to denote a directly visible d eclaration whose defining name is the same as 
the direct_name . A selector_name  shall resolve to denote a visible declaration whose defining name is 
the same as the selector_name .  
These rules on visibility and direct visibility do not apply in a context_clause , a parent_unit_name , or a 
pragma  that appears at the place of a compilation_unit . For those contexts, see the rules in 10.1.6, 
“Environment-Level Visibility Rules”.  
Legality Rules 
A nonoverridable declaration is illegal if there is a homograph occurring immediately within the same 
declarative region that is visible at the place of the d eclaration, and is not hidden from all visibility by the 
nonoverridable declaration. In addition, a type extens ion is illegal if somewhere within its immediate 
scope it has two visible components w ith the same name. Similarly, the context_clause  for a compilation 
unit is illegal if it mentions (in a with_clause ) some library unit, and there is a homograph of the library 
unit that is visible at the place of the compilation unit, and the homograph and the mentioned library unit are both declared immediately within the same declar ative region. These rules also apply to dispatching 
operations declared in the visible part of an instance of a generic unit. However, they do not apply to other 
overloadable declarations in an instance; such decl arations may have type conformant profiles in the 
instance, so long as the corresponding declarations  in the generic were not type conformant.  
NOTES 
5  Visibility for compilation units follows from the definition of  the environment in 10.1.4, ex cept that it is necessary to 
apply a with_clause  to obtain visibility to a library_unit_declaration  or library_unit_renaming_declaration . 
6  In addition to the visibility rules given above, the meaning of the occurrence of a direct_name  or selector_name  at a 
given place in the text can depend on the overloading rules (see 8.6). 
7  Not all contexts where an identifier , character_literal , or operator_symbol  are allowed require visibility of a 
corresponding declaration. Contexts where visibility is not required are identified by using one of these three syntactic categories directly in a syntax rule, rather than using 
direct_name  or selector_name .  20.1/2 
21 
22 
23 
23.1/3 
24 
25 
26/2 
27 
28 29 
Ada Reference Manual — 2012 Edition 
8.3.1    Overriding Indicators 13 December 2012      196 8.3.1 Overriding Indicators 
An overriding_indicator  is used to declare that an operation is  intended to override (or not override) an 
inherited operation.  
Syntax 
overriding_indicator ::= [not] overriding  
Legality Rules 
If an abstract_subprogram_declaration , null_procedure_declaration , expression_function_declaration , 
subprogram_body , subprogram_body_stub , subprogram_renaming_declaration , generic_instantiation  
of a subprogram, or subprogram_declaration  other than a protected subprogram has an overriding_-
indicator , then: 
• the operation shall be a primitive operation for some type; 
• if the overriding_indicator  is overriding , then the operation shall override a homograph at the 
place of the declaration or body; 
• if the overriding_indicator  is not overriding , then the operation shall not override any 
homograph (at any place).  
In addition to the places where Legality Rules normally a pply, these rules also apply in the private part of 
an instance of a generic unit. 
NOTES 
8  Rules for overriding_indicator s of task and protected entries and of protected subprograms are found in 9.5.2 and 9.4, 
respectively.  
Examples 
The use of overriding_indicator s allows the detection of errors at co mpile-time that otherwise might not be 
detected at all. For instance, we might declare a s ecurity queue derived from the Queue interface of 3.9.4 
as: 
type Security_Queue is new Queue with record  ...; 
overriding  
procedure  Append(Q : in out Security_Queue; Person : in Person_Name); 
overriding  
procedure  Remove_First(Q : in out Security_Queue; Person : in Person_Name); 
overriding  
function  Cur_Count(Q : in Security_Queue) return Natural; 
overriding  
function  Max_Count(Q : in Security_Queue) return Natural; 
not overriding  
procedure  Arrest(Q : in out Security_Queue; Person : in Person_Name); 
The first four subprogram declarations guarant ee that these subprograms will override the four 
subprograms inherited from the Queue interface. A misspelling in one of these subprograms will be 
detected by the implementation. C onversely, the declaration of Arrest  guarantees that this is a new 
operation. 1/2 
2/2 
3/3 
4/2 
5/2 
6/2 7/2 
8/2 
9/2 
10/2 
11/2 
12/2 13/2 14/2 15/2 
16/2 
Ada Reference Manual — 2012 Edition 
197      13 December 2012 Use Clauses   8.4 8.4 Use Clauses 
A use_package_clause  achieves direct visibility of declarations that appear in the visible part of a 
package; a use_type_clause  achieves direct visibility of the primitive operators of a type.  
Syntax 
use_clause ::= use_package_clause  | use_type_clause  
use_package_clause ::= use package_ name  {, package_ name }; 
use_type_clause ::= use [all] type subtype_mark  {, subtype_mark }; 
Legality Rules 
A package_ name  of a use_package_clause  shall denote a nonlimited view of a package.  
Static Semantics 
For each use_clause , there is a certain region of text called the scope  of the use_clause . For a 
use_clause  within a context_clause  of a library_unit_declaration  or library_unit_renaming_declaration , 
the scope is the entire declarative region of the declaration. For a use_clause  within a context_clause  of a 
body, the scope is the entire body and any subunits (i ncluding multiply nested subunits). The scope does 
not include context_clause s themselves. 
For a use_clause  immediately within a declarative region, the scope is the portion of the declarative 
region starting just after the use_clause  and extending to the end of the declarative region. However, the 
scope of a use_clause  in the private part of a library unit does not include the visible part of any public 
descendant of that library unit.  
A package is named  in a use_package_clause  if it is denoted by a package_ name  of that clause. A type 
is named  in a use_type_clause  if it is determined by a subtype_mark  of that clause. 
For each package named in a use_package_clause  whose scope encloses a place, each declaration that 
occurs immediately within the decl arative region of the package is potentially use-visible  at this place if 
the declaration is visible at this place. For each type T or T'Class named in a use_type_clause  whose 
scope encloses a place, the declarati on of each primitive operator of type T is potentially use-visible at this 
place if its declaration is visible at this place. If a use_type_clause  whose scope encloses a place includes 
the reserved word all, then the following entities are also poten tially use-visible at this place if the 
declaration of the entity is visible at this place:  
• Each primitive subprogram of T including each enumeration literal (if any); 
• Each subprogram that is declared immediately w ithin the declarative region in which an ancestor 
type of T is declared and that operates on a class-wide type that covers T.  
Certain implicit declarations may become potentially use- visible in certain contexts as described in 12.6. 
A declaration is use-visible  if it is potentially use-visible, ex cept in these naming-conflict cases:  
• A potentially use-visible declaration is not use- visible if the place considered is within the 
immediate scope of a homograph of the declaration. 
• Potentially use-visible declarations that have the same identifier  are not use-visible unless each 
of them is an overloadable declaration.  
Dynamic Semantics 
The elaboration of a use_clause  has no effect.  1 
2 
3 
4/3 
5/2 
6 
7 
7.1/2 
8/3 
8.1/3 
8.2/3 
8.3/3 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
8.4   Use Clauses 13 December 2012      198 Examples 
Example of a use clause in a context clause:   
with Ada.Calendar; use Ada; 
Example of a use type clause:   
use type  Rational_Numbers.Rational; --  see 7.1 
Two_Thirds: Rational_Numbers.Rational := 2/3; 
8.5 Renaming Declarations 
A renaming_declaration  declares another name for an entity, such as an object, exception, package, 
subprogram, entry, or generi c unit. Alternatively, a subprogram_renaming_declaration  can be the 
completion of a previous subprogram_declaration . 
Syntax 
renaming_declaration ::=  
      object_renaming_declaration  
    | exception_renaming_declaration  
    | package_renaming_declaration  
    | subprogram_renaming_declaration  
    | generic_renaming_declaration  
Dynamic Semantics 
The elaboration of a renaming_declaration  evaluates the name  that follows the reserved word renames  
and thereby determines the view and entity denoted by this name (the renamed view  and renamed entity ). 
A name  that denotes the renaming_declaration  denotes (a new view of) the renamed entity.  
NOTES 
9  Renaming may be used to resolve name conflicts and to act as a shorthand. Renaming with a different identifier  or 
operator_symbol  does not hide the old name ; the new name  and the old name  need not be visible at the same places. 
10  A task or protected object that is declared by an explicit object_declaration  can be renamed as an object. However, a 
single task or protected object cannot be renamed since the corresponding type is anonymous (meaning it has no nameable subtypes). For similar reasons, an  object of an anonymous array or  access type cannot  be renamed. 
11  A subtype defined without any additional constraint can be used to achieve the effect of renaming another subtype 
(including a task or protected subtype) as in  
   subtype Mode is Ada.Text_IO.File_Mode; 
8.5.1 Object Renaming Declarations 
An object_renaming_declaration  is used to rename an object.  
Syntax 
object_renaming_declaration ::=  
    defining_identifier  : [null_exclusion ] subtype_mark  renames  object_ name  
        [ aspect_specification ]; 
  | defining_identifier  : access_definition  renames  object_ name  
        [ aspect_specification ]; 
Name Resolution Rules 
The type of the object_ name  shall resolve to the type determined by the subtype_mark , or in the case 
where the type is defined by an access_definition , to an anonymous access type. If the anonymous access 13 
14 
15 
16 
1 
2 
3 
4 
5 
6 
7 
1 
2/3 
3/2 
Ada Reference Manual — 2012 Edition 
199      13 December 2012 Object  Renaming Declarations   8.5.1 type is an access-to-object type, the type of the object_ name  shall have the same designated type as that of 
the access_definition . If the anonymous access type is an access-to-subprogram type, the type of the 
object_ name  shall have a designated profile that is type conformant with that of the access_definition . 
Legality Rules 
The renamed entity shall be an object. 
In the case where the type is defined by an access_definition , the type of the renamed object and the type 
defined by the access_definition :  
• shall both be access-to-object types with stati cally matching designated subtypes and with both 
or neither being access-to-constant types; or  
• shall both be access-to-subprogram types with subtype conformant designated profiles.  
For an object_renaming_declaration  with a null_exclusion  or an access_definition  that has a 
null_exclusion : 
• if the object_ name  denotes a generic formal object of a generic unit G, and the 
object_renaming_declaration  occurs within the body of G or within the body of a generic unit 
declared within the declarative region of G, then the declaration of the formal object of G shall 
have a null_exclusion ; 
• otherwise, the subtype of the object_ name  shall exclude null. In addition to the places where 
Legality Rules normally apply (see 12.3), this rule a pplies also in the private part of an instance 
of a generic unit. 
The renamed entity shall not be a subcomponent th at depends on discriminants of an object whose 
nominal subtype is unconstrained unless th e object is known to be constrained. A slice  of an array shall 
not be renamed if this restriction disallows renaming of the array. In addition to the places where Legality 
Rules normally apply, these rules apply also in th e private part of an instance of a generic unit. 
Static Semantics 
An object_renaming_declaration  declares a new view of the renamed object whose properties are 
identical to those of the renamed view. Thus, the prope rties of the renamed object are not affected by the 
renaming_declaration . In particular, its value and whether or not  it is a constant are unaffected; similarly, 
the null exclusion or constraints that apply to an object are not affected by renaming (any constraint 
implied by the subtype_mark  or access_definition  of the object_renaming_declaration  is ignored).  
Examples 
Example of renaming an object:   
declare 
   L : Person renames Leftmost_Person; --  see 3.10.1 
begin 
   L.Age := L.Age + 1; end; 4 
4.1/2 
4.2/2 
4.3/2 
4.4/2 
4.5/2 
4.6/2 
5/3 
6/2 
7 
8 
Ada Reference Manual — 2012 Edition 
8.5.2    Exception Renaming Declara tions 13 December 2012      200 8.5.2 Exception Renaming Declarations 
An exception_renaming_declaration  is used to rename an exception.  
Syntax 
exception_renaming_declaration ::= defining_identifier  : exception  renames  exception_ name  
   [aspect_specification ]; 
Legality Rules 
The renamed entity shall be an exception.  
Static Semantics 
An exception_renaming_declaration  declares a new view of the renamed exception.  
Examples 
Example of renaming an exception:   
EOF : exception  renames Ada.IO_Exceptions.End_Error; -- see A.13 
8.5.3 Package Renaming Declarations 
A package_renaming_declaration  is used to rename a package.  
Syntax 
package_renaming_declaration ::= 
package  defining_program_unit_name  renames  package_ name  
   [aspect_specification ]; 
Legality Rules 
The renamed entity shall be a package. 
If the package_ name  of a package_renaming_declaration  denotes a limited view of a package P, then a 
name that denotes the package_renaming_declaration  shall occur only within the immediate scope of the 
renaming or the scope of a with_clause  that mentions the package P or, if P is a nested package, the 
innermost library package enclosing P.  
Static Semantics 
A package_renaming_declaration  declares a new view of the renamed package. 
At places where the declaration of the limited view of the renamed package is visible, a name  that denotes 
the package_renaming_declaration  denotes a limited view of the package (see 10.1.1).  
Examples 
Example of renaming a package:   
package TM renames Table_Manager; 1 
2/3 
3 
4 
5 
6 
1 
2/3 
3 
3.1/2 
4 
4.1/2 
5 
6 
Ada Reference Manual — 2012 Edition 
201      13 December 2012 Subprogr am Renaming Declarations   8.5.4 8.5.4 Subprogram Renaming Declarations 
A subprogram_renaming_declaration  can serve as the completion of a subprogram_declaration ; such a 
renaming_declaration  is called a renaming-as-body . A subprogram_renaming_declaration  that is not a 
completion is called a renaming-as-declaration , and is used to rename a subprogram (possibly an 
enumeration literal) or an entry.  
Syntax 
subprogram_renaming_declaration ::=  
    [overriding_indicator ] 
    subprogram_specification  renames  callable_entity_ name  
        [ aspect_specification ]; 
Name Resolution Rules 
The expected profile for the callable_entity_ name  is the profile given in the subprogram_specification .  
Legality Rules 
The profile of a renaming-as-declaration shall be m ode conformant, with that of the renamed callable 
entity.  
For a parameter or result subtype of the subprogram_specification  that has an explicit null_exclusion : 
• if the callable_entity_ name  denotes a generic formal subprogram of a generic unit G, and the 
subprogram_renaming_declaration  occurs within the body of a generic unit G or within the 
body of a generic unit declared within th e declarative region of the generic unit G, then the 
corresponding parameter or result subt ype of the formal subprogram of G shall have a 
null_exclusion ; 
• otherwise, the subtype of the corresponding para meter or result type of the renamed callable 
entity shall exclude null. In addition to the places where Legality Rules normally apply (see 
12.3), this rule applies also in the privat e part of an instance of a generic unit.  
The profile of a renaming-as-body shall conform fully  to that of the declaration it completes. If the 
renaming-as-body completes that declaration before th e subprogram it declares is  frozen, the profile shall 
be mode conformant with that of the renamed ca llable entity and the subprogram it declares takes its 
convention from the renamed subprogram; otherwise, the pr ofile shall be subtype conformant with that of 
the renamed callable entity and the convention of th e renamed subprogram shall not be Intrinsic. A 
renaming-as-body is illegal if the declaration occurs before the subprogram whose declaration it completes 
is frozen, and the renaming renames the subprogram itself, through one or more subprogram renaming 
declarations, none of whose subprograms has been frozen.  
The callable_entity_ name  of a renaming shall not denote a s ubprogram that requires overriding (see 
3.9.3).  
The callable_entity_ name  of a renaming-as-body shall not denote an abstract subprogram.  
A name  that denotes a formal parameter of the subprogram_specification  is not allowed within the 
callable_entity_ name .  
Static Semantics 
A renaming-as-declaration declares a new view of the renamed entity. The profile of this new view takes 
its subtypes, parameter modes, and calling convention from the original profile of the callable entity, while 1/3 
2/3 
3 
4/3 
4.1/2 
4.2/2 
4.3/2 
5/3 
5.1/2 
5.2/2 
6 
7 
Ada Reference Manual — 2012 Edition 
8.5.4    Subprogram Renaming Declara tions 13 December 2012      202 taking the formal parameter name s and default_expression s from the profile given in the 
subprogram_renaming_declaration . The new view is a function or procedure, never an entry.  
Dynamic Semantics 
For a call to a subprogram whose body  is given as a renaming-as-body, the execution of the renaming-as-
body is equivalent to the execution of a subprogram_body  that simply calls the renamed subprogram with 
its formal parameters as the actual parameters and, if it is a function,  returns the value of the call.  
For a call on a renaming of a dispatching subprogram th at is overridden, if the overriding occurred before 
the renaming, then the body executed is that of the overriding declaration, even if the overriding 
declaration is not visible at the place of the renaming; otherwise, the inherited or  predefined subprogram is 
called. A corresponding rule applies to a call on a re naming of a predefined equality operator for an 
untagged record type.  
Bounded (Run-Time) Errors 
If a subprogram directly or indirectly renames itsel f, then it is a bounded error to call that subprogram. 
Possible consequences are that Program_Error or Storage_E rror is raised, or that th e call results in infinite 
recursion.  
NOTES 
12  A procedure can only be renamed as a procedure. A function whose defining_designator  is either an identifier  or an 
operator_symbol  can be renamed with either an identifier  or an operator_symbol ; for renaming as an operator, the 
subprogram specification given in the renaming_declaration  is subject to the rules given in 6.6 for operator declarations. 
Enumeration literals can be renamed as functions; similarly, attribute_reference s that denote functions (such as references 
to Succ and Pred) can be renamed as functions. An entry can only be renamed as a procedure; the new name  is only 
allowed to appear in contexts that allow a procedure name . An entry of a family can be renamed, but an entry family 
cannot be renamed as a whole. 
13  The operators of the root numeric types cannot be renamed because the ty pes in the profile ar e anonymous, so the 
corresponding specifications cannot be written; the same holds for certain attributes, such as Pos. 
14  Calls with the new name  of a renamed entry are procedure_call_statement s and are not allowed at places where the 
syntax requires an entry_call_statement  in conditional_  and timed_entry_call s, nor in an asynchronous_select ; similarly, 
the Count attribute is not available for the new name . 
15  The primitiveness of a renaming-as-declaration is determined by its profile, and by where it occurs, as for any 
declaration of (a view of) a subprogram; primitiveness is not determined by the renamed view. In order to perform a dispatching call, the subprogram name has to denote a primitive subprogram, not a nonprimitive renaming of a primitive subprogram.  
Examples 
Examples of subprogram renaming declarations:   
procedure  My_Write(C : in Character) renames Pool(K).Write; --   see 4.1.3 
function  Real_Plus(Left, Right : Real   ) return Real    renames "+"; 
function  Int_Plus (Left, Right : Integer) return Integer renames "+"; 
function  Rouge return Color renames Red;  --   see 3.5.1 
function  Rot   return Color renames Red; 
function  Rosso return Color renames Rouge; 
function  Next(X : Color) return Color renames Color'Succ; --  see 3.5.1 
Example of a subprogram renaming decl aration with new parameter names:   
function  "*" (X,Y : Vector) return Real renames Dot_Product; --  see 6.1 
Example of a subprogram renaming decl aration with a new default expression:   
function  Minimum(L : Link := Head) return Cell renames Min_Cell; --  see 6.1 7.1/1 
8/3 
8.1/1 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
Ada Reference Manual — 2012 Edition 
203      13 December 2012 Generi c Renaming Declarations   8.5.5 8.5.5 Generic Renaming Declarations 
A generic_renaming_declaration  is used to rename a generic unit.  
Syntax 
generic_renaming_declaration ::=  
    generic package  defining_program_unit_name  renames  generic_package_ name  
        [ aspect_specification ]; 
  | generic procedure  defining_program_unit_name  renames  generic_procedure_ name  
        [ aspect_specification ]; 
  | generic function  defining_program_unit_name  renames  generic_function_ name  
        [ aspect_specification ]; 
Legality Rules 
The renamed entity shall be a generic unit of the corresponding kind.  
Static Semantics 
A generic_renaming_declaration  declares a new view of the renamed generic unit.  
NOTES 
16  Although the properties of the new view are the same as those of th e renamed view, th e place where the 
generic_renaming_declaration  occurs may affect the legality of subsequent renamings and instantiations that denote the 
generic_renaming_declaration , in particular if the renamed generic unit is a library unit (see 10.1.1).  
Examples 
Example of renaming a generic unit:   
generic package  Enum_IO renames Ada.Text_IO.Enumeration_IO;  -- see A.10.10  
8.6 The Context of Overload Resolution 
Because declarations can be overloaded, it is possible fo r an occurrence of a usage name to have more than 
one possible interpretation; in most cases, ambiguity  is disallowed. This s ubclause describes how the 
possible interpretations resolve to the actual interpretation. 
Certain rules of the language (the  Name Resolution Rules) are cons idered “overloading rules”. If a 
possible interpretation violates an overloading rule, it is assumed not to be the intended interpretation; 
some other possible interpretation is assumed to be the actual interpretati on. On the other hand, violations 
of nonoverloading rules do not affect wh ich interpretation is chosen; instead , they cause the construct to be 
illegal. To be legal, there usually has to be exactly  one acceptable interpretation of a construct that is a 
“complete context”, not counting any nested complete contexts. 
The syntax rules of the language and the visibility rule s given in 8.3 determine the possible interpretations. 
Most type checking rules (rules that require a particular  type, or a particular class of types, for example) 
are overloading rules. Various rule s for the matching of formal and actual parameters are overloading 
rules.  
Name Resolution Rules 
Overload resolution is applied separately to each complete context , not counting inner complete contexts. 
Each of the following constructs is a complete context :  
• A context_item . 1 
2/3 
3 
4 
5 
6 
7 
1/3 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
8.6   The Context of Overload Resolution 13 December 2012      204 • A declarative_item  or declaration.  
• A statement . 
• A pragma_argument_association .  
• The expression  of a case_statement .  
An (overall) interpretation  of a complete context embodies its  meaning, and includes the following 
information about the constituents of the complete c ontext, not including constituents of inner complete 
contexts:  
• for each constituent of the complete context, to which syntactic categories it belongs, and by 
which syntax rules; and  
• for each usage name, which declaration it denotes  (and, therefore, which view and which entity 
it denotes); and  
• for a complete context that is a declarative_item , whether or not it is a completion of a 
declaration, and (if so) which declaration it completes.  
A possible interpretation  is one that obeys the syntax rules and the visibility rules. An acceptable 
interpretation  is a possible interpretation that obeys the overloading rules , that is, those rules that specify 
an expected type or expected prof ile, or specify how a construct shall resolve  or be interpreted .  
The interpretation  of a constituent of a complete context is determined from the overall interpretation of 
the complete context as a whole. Thus, for example, “interpreted as a function_call ,” means that the 
construct's interpretation says that it belongs to the syntactic category function_call . 
Each occurrence of a usage name denotes  the declaration determined by its interpretation. It also denotes 
the view declared by its denoted decl aration, except in the following cases:  
• If a usage name appears within the declarative region of a type_declaration  and denotes that 
same type_declaration , then it denotes the current instance  of the type (rather than the type 
itself); the current instance of a type is the object or  value of the type that is associated with the 
execution that evaluates the usage name.  Sim ilarly, if a usage name appears within the 
declarative region of a subtype_declaration  and denotes that same subtype_declaration , then it 
denotes the current instance of the subtype. These rules do not apply if the usage name appears within the 
subtype_mark  of an access_definition  for an access-to-object type, or within the 
subtype of a parameter or result of an access-to-subprogram type.  
• If a usage name appears within the declarative region of a generic_declaration  (but not within 
its generic_formal_part ) and it denotes that same generic_declaration , then it denotes the 
current instance  of the generic unit (rather than the generic unit itself). See also 12.3.  
A usage name that denotes a view also  denotes the entity of that view.  
The expected type  for a given expression , name , or other construct determines, according to the type 
resolution rules  given below, the types considered for the construct during overload resolution. The type 
resolution rules provide support for class-wide progr amming, universal literals, dispatching operations, 
and anonymous access types:  
• If a construct is expected to be of any type in a class of types, or of th e universal or class-wide 
type for a class, then the type of the construct shall resolve to a type in that class or to a 
universal type that covers the class.  
• If the expected type for a construct is a specific type T, then the type of the construct shall 
resolve either to T, or:  
• to T'Class; or  6 
7 8 9 
10 
11 
12 13 14 
15 
16 
17/3 
18 
19 
20/2 
21 
22 
23 
Ada Reference Manual — 2012 Edition 
205      13 December 2012 The Context of Overload Resolution   8.6 • to a universal type that covers T; or 
• when T is a specific anonymous access-to-object type (see 3.10) with designated type D, to 
an access-to-object type whose designated type is D'Class or is covered by D; or 
• when T is a named general access-to-object type (see 3.10) with designated type D, to an 
anonymous access-to-object type whose desi gnated type covers or is covered by D; or 
• when T is an anonymous access-to-subprogram ty pe (see 3.10), to an access-to-subprogram 
type whose designated profile is type conformant with that of T. 
In certain contexts, such as in a subprogram_renaming_declaration , the Name Resolution Rules define an 
expected profile  for a given name ; in such cases, the name  shall resolve to the name of a callable entity 
whose profile is type conformant  with the expected profile.  
Legality Rules 
When a construct is one that requires that its expected type be a single  type in a given class, the type of the 
construct shall be determinable solely from the c ontext in which the construct appears, excluding the 
construct itself, but using the requirement that it be in  the given class. Furthermore, the context shall not 
be one that expects any type in some class that c ontains types of the given class; in particular, the 
construct shall not be the operand of a type_conversion . 
Other than for the simple_expression  of a membership test, if the expected type for a name  or expression  
is not the same as the actual type of the name  or expression , the actual type shall be convertible to the 
expected type (see 4.6); further, if the expected type  is a named access-to-object type with designated type 
D1 and the actual type is an anonymous access-to-object type with designated type D2, then D1 shall 
cover D2, and the name  or expression  shall denote a view with an accessibility level for which the 
statically deeper relationship applies; in particular  it shall not denote an access parameter nor a stand-alone 
access object. 
A complete context shall have at least one acceptable interpretation; if there is exactly one, then that one is 
chosen.  
There is a preference  for the primitive operators (and range s) of the root numeric types root_integer  and 
root_real . In particular, if two acceptable interpretations of a constituent of a complete context differ only 
in that one is for a primitive operator (or range ) of the type root_integer  or root_real , and the other is not, 
the interpretation using the primitive operator (or range ) of the root numeric type is preferred . 
Similarly, there is a preference for the equality operators of the universal_access  type (see 4.5.2). If two 
acceptable interpretations of a constituent of a complete  context differ only in that one is for an equality 
operator of the universal_access  type, and the other is not, the interpretation using the equality operator of 
the universal_access  type is preferred. 
For a complete context, if there is exactly one overall acceptable interpretation where each constituent's 
interpretation is the same as or preferred (in the above sense) over those in all other overall acceptable 
interpretations, then that one overall acceptable interpre tation is chosen. Otherwise, the complete context 
is ambiguous . 
A complete context other than a pragma_argument_association  shall not be ambiguous. 
A complete context that is a pragma_argument_association  is allowed to be ambiguous (unless otherwise 
specified for the particular pragma), but only if ev ery acceptable interpretation of the pragma argument is 
as a name  that statically denotes a callable entity. Such a name  denotes all of the declarations determined 
by its interpretations, and all of the views declared by these declarations.  24 
25/2 
25.1/3 25.2/3 
26 
27/2 
27.1/3 
28 
29 
29.1/3 
30 
31 
32 
Ada Reference Manual — 2012 Edition 
8.6   The Context of Overload Resolution 13 December 2012      206 NOTES 
17  If a usage name has only one acceptable interpreta tion, then it denotes the corres ponding entity. Howeve r, this does 
not mean that the usage name is necessarily legal since other requirements exist which are not considered for overload resolution; for example, the fact that an expression is static, whether an object is constant, mode and subtype conformance rules, freezing rules, order of elaboration, and so on. 
Similarly, subtypes are not considered for overload resolution (the violation of a constraint does not make a program 
illegal but raises an exception during program execution).  33 
34 
Ada Reference Manual — 2012 Edition 
207      13 December 2012 Tasks and Synchronization   9 9   Tasks and Synchronization 
The execution of an Ada program consis ts of the execution of one or more tasks . Each task represents a 
separate thread of control that proceeds independe ntly and concurrently between the points where it 
interacts  with other tasks. The various forms of task inte raction are described in this clause, and include:  
• the activation and termination of a task; 
• a call on a protected subprogram of a protected object , providing exclusive read-write access, or 
concurrent read-only access to shared data; 
• a call on an entry, either of another task, allowing for synchronous communication with that 
task, or of a protected object, allowing for asyn chronous communication with one or more other 
tasks using that same protected object; 
• a timed operation, including a simple delay statement, a timed entry call or accept, or a timed 
asynchronous select stat ement (see next item); 
• an asynchronous transfer of control as part of  an asynchronous select statement, where a task 
stops what it is doing and begins execution at a di fferent point in response to the completion of 
an entry call or the expiration of a delay; 
• an abort statement, allowing one task to cause the termination of another task.  
In addition, tasks can communicate indirectly by reading and updating (unprotected) shared variables, 
presuming the access is properly synchronized th rough some other kind of task interaction. 
Static Semantics 
The properties of a task are defined by a corresponding task declaration and task_body , which together 
define a program unit called a task unit .  
Dynamic Semantics 
Over time, tasks proceed through various states . A task is initially inactive ; upon activation, and prior to 
its termination  it is either blocked  (as part of some task interaction) or ready  to run. While ready, a task 
competes for the available execution resources  that it requires to run.  
NOTES 
1  Concurrent task execution may be implemented on multicomputers, multiprocessors, or with interleaved execution on a single physical processor. On the other hand, whenever an implementation can determine that the required semantic effects can be achieved when parts of the execution of a given task are performed by different physical processors acting in parallel, it may choose to perform them in this way. 
9.1 Task Units and Task Objects 
A task unit is declared by a task declaration , which has a corresponding task_body . A task declaration 
may be a task_type_declaration , in which case it declares a named task type; alternatively, it may be a 
single_task_declaration , in which case it defines an anonymous ta sk type, as well as declaring a named 
task object of that type.  1/3 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
1 
Ada Reference Manual — 2012 Edition 
9.1   Task Units and Task Objects 13 December 2012      208 Syntax 
task_type_declaration ::=  
   task type defining_identifier  [known_discriminant_part ] 
        [ aspect_specification ] [is 
     [new interface_list  with ] 
     task_definition ]; 
single_task_declaration ::=  
   task defining_identifier   
        [ aspect_specification ][is 
     [new interface_list  with ] 
     task_definition ]; 
task_definition ::=  
     {task_item } 
  [ private  
     {task_item }] 
  end [task_ identifier ] 
task_item ::= entry_declaration  | aspect_clause  
task_body ::=  
   task body  defining_identifier  
        [ aspect_specification ] is 
     declarative_part  
   begin  
     handled_sequence_of_statements  
   end [task_ identifier ]; 
If a task_ identifier  appears at the end of a task_definition  or task_body , it shall repeat the 
defining_identifier .  
Paragraph 8 was deleted.   
Static Semantics 
A task_definition  defines a task type and its fi rst subtype. The first list of task_item s of a task_definition , 
together with the known_discriminant_part , if any, is called the visible part of the task unit. The optional 
list of task_item s after the reserved word private  is called the private part of the task unit.  
For a task declaration without a task_definition , a task_definition  without task_item s is assumed. 
For a task declaration with an interface_list , the task type inherits user-defined primitive subprograms 
from each progenitor type (see 3.9.4), in the same way that a derived type inherits user-defined primitive 
subprograms from its progenitor types (see 3.4). If the first parameter of a primitive inherited subprogram 
is of the task type or an access parameter designating the task type, and there is an entry_declaration  for a 
single entry with the same identifier within the task d eclaration, whose profile is type conformant with the 
prefixed view profile of the inherited subprogr am, the inherited subprogr am is said to be implemented  by 
the conforming task entry using an implicitly declar ed nonabstract subprogram which has the same profile 
as the inherited subprogram and which overrides it.  
Legality Rules 
A task declaration requires a completion, which shall be a task_body , and every task_body  shall be the 
completion of some task declaration.  
Each interface_ subtype_mark  of an interface_list  appearing within a task declaration shall denote a 
limited interface type that is not a protected interface.  2/3 
3/3 
4 
5/1 
6/3 
7 
9 
9.1/1 
9.2/3 
9.3/2 
9.4/2 
Ada Reference Manual — 2012 Edition 
209      13 December 2012 Task Units and Task Objects   9.1 The prefixed view profile of an explicitly declared primitive subprogram of a tagged task type shall not be 
type conformant with any entry of the task type, if the subprogram has the same defining name as the 
entry and the first parameter of the subprogram is of the task type or is an access parameter designating the 
task type.  
For each primitive subprogram inherited by the type decl ared by a task declaration, at most one of the 
following shall apply: 
• the inherited subprogram is overridden with a pr imitive subprogram of the task type, in which 
case the overriding subprogram shall be subtype c onformant with the inherited subprogram and 
not abstract; or 
• the inherited subprogram is impl emented by a single entry of th e task type; in which case its 
prefixed view profile shall be subtype conf ormant with that of the task entry.  
If neither applies, the inherited subprogram shall be  a null procedure. In addition to the places where 
Legality Rules normally apply (see 12.3), these rules also  apply in the private part of an instance of a 
generic unit.  
Dynamic Semantics 
The elaboration of a task declaration elaborates the task_definition . The elaboration of a single_task_-
declaration  also creates an object of an (anonymous) task type.  
The elaboration of a task_definition  creates the task type and its fi rst subtype; it also includes the 
elaboration of the entry_declaration s in the given order. 
As part of the initialization of a task object, any aspect_clause s and any per-object constraints associated 
with entry_declaration s of the corresponding task_definition  are elaborated in the given order.  
The elaboration of a task_body  has no effect other than to establish that tasks of the type can from then on 
be activated without failing the Elaboration_Check. 
The execution of a task_body  is invoked by the activation of a ta sk of the corresponding type (see 9.2). 
The content of a task object of a given task type includes:  
• The values of the discriminants of the task object, if any; 
• An entry queue for each entry of the task object;  
• A representation of the state of the associated task.  
NOTES 
2  Other than in an access_definition , the name of a task unit within the declaration or body of the task unit denotes the 
current instance of the unit (see 8.6), rather than the first subtype of the corresponding task type (and thus the name cannot be used as a 
subtype_mark ).  
3  The notation of a selected_component  can be used to denote a discriminant of a task (see 4.1.3). Within a task unit, the 
name of a discriminant of the task type denotes the corresponding discriminant of the current instance of the unit. 
4  A task type is a limited type (see 7.5), and hence precludes use of assignment_statement s and predefined equality 
operators. If an application need s to store and exchange task  identities, it can do so by de fining an access ty pe designating 
the corresponding task objects and by using access values for iden tification purposes. Assignment is available for such an 
access type as for any access ty pe. Alternatively, if the implementation supports the Sy stems Programming Annex, the 
Identity attribute can be used for task identification (see C.7.1).  9.5/3 
9.6/2 
9.7/2 
9.8/2 
9.9/2 
10 
11 
12/1 
13 14 
15 
16 
17 18 
19/2 
20 
21/2 
Ada Reference Manual — 2012 Edition 
9.1   Task Units and Task Objects 13 December 2012      210 Examples 
Examples of declarations of task types:   
task type Server is 
   entry Next_Work_Item(WI : in Work_Item); 
   entry Shut_Down; 
end Server; 
task type Keyboard_Driver(ID : Keyboard_ID := New_ID) is 
      new Serial_Device with  --  see 3.9.4 
   entry Read (C : out Character); 
   entry Write(C : in  Character); 
end Keyboard_Driver; 
Examples of declarations of single tasks:   
task Controller is 
   entry Request(Level)(D : Item);  --   a family of entries  
end Controller; 
task Parser is 
   entry Next_Lexeme(L : in  Lexical_Element); 
   entry Next_Action(A : out Parser_Action); 
end; 
task User;  --   has no entries  
Examples of task objects:   
Agent    : Server; 
Teletype : Keyboard_Driver(TTY_ID); Pool     : array(1 .. 10) of Keyboard_Driver; 
Example of access type designating task objects:   
type Keyboard is access Keyboard_Driver; 
Terminal : Keyboard := new Keyboard_Driver(Term_ID); 
9.2 Task Execution - Task Activation 
Dynamic Semantics 
The execution of a task of a given task type  consists of the execution of the corresponding task_body . The 
initial part of this execution is called the activation  of the task; it consists of the elaboration of the 
declarative_part  of the task_body . Should an exception be propagated by the elaboration of its 
declarative_part , the activation of the task is defined to have failed , and it becomes a completed task. 
A task object (which represents one task) can be a part of a stand-alone object, of an object created by an 
allocator , or of an anonymous object of a limited type, or a coextension of one of these. All tasks that are 
part or coextensions of any of the stand- alone objects created by the elaboration of object_declaration s (or 
generic_association s of formal objects of mode in) of a single declarative region are activated together. 
All tasks that are part or coextensions of a single object that is not a stand-alone object are activated together.  
For the tasks of a given declarative region, the ac tivations are initiated within the context of the 
handled_-
sequence_of_statements  (and its associated exception_handler s if any — see 11.2), just prior to 
executing the statements of the handled_sequence_of_statements . For a package without an explicit 
body or an explicit handled_sequence_of_statements , an implicit body or an implicit null_statement  is 
assumed, as defined in 7.2.  22 
23 
24/2 
25 
26 
27 
28 
29 
30 
31 
32 
1 
2/2 
3/2 
Ada Reference Manual — 2012 Edition 
211      13 December 2012 Task Execution - Task Activation   9.2 For tasks that are part or coextensions of a single object that is not a stand-alone object, activations are 
initiated after completing any initialization of the out ermost object enclosing these tasks, prior to 
performing any other operation on the outermost object . In particular, for tasks that are part or 
coextensions of the object created by the evaluation of an allocator , the activations are initiated as the last 
step of evaluating the allocator , prior to returning the new access value. For tasks that are part or 
coextensions of an object that is the result of a func tion call, the activations are not initiated until after the 
function returns. 
The task that created the new tasks and initiated their activations (the activator ) is blocked until all of 
these activations complete (successfully or not). Once all of these activations are complete, if the 
activation of any of the tasks has failed (due to th e propagation of an exception), Tasking_Error is raised 
in the activator, at the place at which it initiated the ac tivations. Otherwise, the ac tivator proceeds with its 
execution normally. Any tasks that are aborted prior to completing their activation are ignored when determining whether to raise Tasking_Error.  
If the master that directly encloses the point where the activation of a task T would be initiated, completes 
before the activation of T is initiated, T becomes terminated and is never activated. Furthermore, if a return 
statement is left such that the return object is not retu rned to the caller, any task that was created as a part 
of the return object or one of its coextensions imme diately becomes terminated and is never activated.  
NOTES 
5  An entry of a task can be called before the task has been activated. 
6  If several tasks are activated together, the execution of any of these tasks need not await the end of the activation of the  
other tasks. 
7  A task can become completed during its activation either because of an exception or because it is aborted (see 9.8). 
Examples 
Example of task activation:   
procedure  P is 
   A, B : Server;    --   elaborate the task objects A, B  
   C    : Server;    --   elaborate the task object C  
begin 
   --   the tasks A, B, C are activated together before the first statement  
   ... end; 
9.3 Task Dependence - Termination of Tasks 
Dynamic Semantics 
Each task (other than an environment task — see 10.2) depends  on one or more masters (see 7.6.1), as 
follows:  
• If the task is created by the evaluation of an allocator  for a given access type, it depends on each 
master that includes the elaboration of the d eclaration of the ultimate ancestor of the given 
access type. 
• If the task is created by the elaboration of an object_declaration , it depends on each master that 
includes this elaboration. 
• Otherwise, the task depends on the master of the outermost object of which it is a part (as 
determined by the accessibility level of that obj ect — see 3.10.2 and 7.6.1), as well as on any 
master whose execution includes that of the master of the outermost object.  4/2 
5 
6/3 
7 
8 
9 
10 
11 
1 
2 
3 
3.1/2 
Ada Reference Manual — 2012 Edition 
9.3   Task Dependence - Termination of Tasks 13 December 2012      212 Furthermore, if a task depends on a given master, it is defined to depend on the task that executes the 
master, and (recursively) on any master of that task.  
A task is said to be completed  when the execution of its corresponding task_body  is completed. A task is 
said to be terminated  when any finalization of the task_body  has been performed (see 7.6.1). The first step 
of finalizing a master (including a task_body ) is to wait for the termination of any tasks dependent on the 
master. The task executing the master is blocked un til all the dependents have terminated. Any remaining 
finalization is then performed and the master is left. 
Completion of a task (and the corresponding task_body ) can occur when the task is blocked at a select_-
statement  with an open terminate_alternative  (see 9.7.1); the open terminate_alternative  is selected if 
and only if the following conditions are satisfied:  
• The task depends on some completed master; and 
• Each task that depends on the master considered is either already terminated or similarly blocked 
at a select_statement  with an open terminate_alternative .  
When both conditions are satisfied, the task considered  becomes completed, together with all tasks that 
depend on the master considered that are not yet completed.  
NOTES 
8  The full view of a limited private type can be a task type, or can have subcomponents of a task type. Creation of an object of such a type creates dependences according to the full type. 
9  An 
object_renaming_declaration  defines a new view of an existing entity and hence creates no further dependence. 
10  The rules given for the collective completion of a group of tasks all blocked on select_statement s with open 
terminate_alternative s ensure that the collective completion can occur only when there are no remaining active tasks that 
could call one of the tasks being collectively completed. 
11  If two or more tasks are blocked on select_statement s with open terminate_alternative s, and become completed 
collectively, their finalization actions proceed concurrently. 
12  The completion of a task can occur due to any of the following:  
• the raising of an exception during the elaboration of the declarative_part  of the corresponding task_body ; 
• the completion of the handled_sequence_of_statements  of the corresponding task_body ; 
• the selection of an open terminate_alternative  of a select_statement  in the corresponding task_body ; 
• the abort of the task.  
Examples 
Example of task dependence:   
declare 
   type Global is access Server;        --   see 9.1 
   A, B : Server;    G    : Global; begin 
   --   activation of A and B  
   declare 
      type Local is access Server; 
      X : Global := new Server;  --   activation of X. all 
      L : Local  := new Server;  --   activation of L. all 
      C : Server;    begin 
      --   activation of C  
      G := X;  --   both G and X designate the same task object  
      ...    end;  --   await termination of C and L. all (but not X. all) 
   ... end;  --   await termination of A, B, and G. all 4 
5 
6/1 
7/2 
8 
9 
10 
11 
12 
13 
14 
15 
16 17 18 
19 
20 
Ada Reference Manual — 2012 Edition 
213      13 December 2012 Protected Units and Protected Objects   9.4 9.4 Protected Units and Protected Objects 
A protected object  provides coordinated access to shared  data, through calls on its visible protected 
operations , which can be protected subprograms  or protected entries . A protected unit  is declared by a 
protected declaration , which has a corresponding protected_body . A protected declaration may be a 
protected_type_declaration , in which case it declares a named protected type; alternatively, it may be a 
single_protected_declaration , in which case it defines an anonymous protected type, as well as declaring 
a named protected object of that type.  
Syntax 
protected_type_declaration ::=  
  protected  type defining_identifier  [known_discriminant_part ] 
        [ aspect_specification ] is 
     [new interface_list  with ] 
     protected_definition ; 
single_protected_declaration ::=  
  protected  defining_identifier  
        [ aspect_specification ] is 
     [new interface_list  with ] 
     protected_definition ; 
protected_definition ::=  
    { protected_operation_declaration  } 
[ private  
    { protected_element_declaration  } ] 
  end [protected_ identifier ] 
protected_operation_declaration ::= subprogram_declaration  
     | entry_declaration  
     | aspect_clause  
protected_element_declaration ::=  protected_operation_declaration  
     | component_declaration  
protected_body ::=  
  protected  body  defining_identifier  
        [ aspect_specification ] is 
   { protected_operation_item  } 
  end [protected_ identifier ]; 
protected_operation_item ::= subprogram_declaration  
     | subprogram_body  
     | entry_body  
     | aspect_clause  
If a protected_ identifier  appears at the end of a protected_definition  or protected_body , it shall 
repeat the defining_identifier .  
Paragraph 10 was deleted.   
Static Semantics 
A protected_definition  defines a protected type and its first subtype. The list of protected_operation_-
declaration s of a protected_definition , together with the known_discriminant_part , if any, is called the 1 
2/3 
3/3 
4 
5/1 
6 
7/3 
8/1 
9 
11/2 
Ada Reference Manual — 2012 Edition 
9.4   Protected Units and Protected  Objects 13 December 2012      214 visible part of the protected unit. The optional list of protected_element_declaration s after the reserved 
word private  is called the private part of the protected unit.  
For a protected declaration with an interface_list , the protected type inher its user-defined primitive 
subprograms from each progenitor type (see 3.9.4), in th e same way that a derived type inherits user-
defined primitive subprograms from its progenitor type s (see 3.4). If the first parameter of a primitive 
inherited subprogram is of the protected type or an access parameter designating the protected type, and 
there is a protected_operation_declaration  for a protected subprogram or single entry with the same 
identifier within the protected declara tion, whose profile is type conforma nt with the prefixed view profile 
of the inherited subprogram, the inhe rited subprogram is said to be implemented  by the conforming 
protected subprogram or entry using an implicitly declared nonabstract subprogram which has the same 
profile as the inherited subprogram and which overrides it.  
Legality Rules 
A protected declaration requires a completion, which shall be a protected_body , and every protected_-
body  shall be the completion of some protected declaration.  
Each interface_ subtype_mark  of an interface_list  appearing within a protected declaration shall denote a 
limited interface type that is not a task interface.  
The prefixed view profile of an explicitly declared  primitive subprogram of a tagged protected type shall 
not be type conformant with any protected operation of  the protected type, if the subprogram has the same 
defining name as the protected operation and the first pa rameter of the subprogram is of the protected type 
or is an access parameter designating the protected type.  
For each primitive subprogram inherited by the type decl ared by a protected declaration, at most one of 
the following shall apply: 
• the inherited subprogram is overridden with a primitive subprogram of the protected type, in 
which case the overriding subprogram shall be subtype conformant with the inherited 
subprogram and not abstract; or 
• the inherited subprogram is im plemented by a protected subpr ogram or single entry of the 
protected type, in which case its prefixed view pr ofile shall be subtype conformant with that of 
the protected subprogram or entry.  
If neither applies, the inherited subprogram shall be  a null procedure. In addition to the places where 
Legality Rules normally apply (see 12.3), these rules also  apply in the private part of an instance of a 
generic unit.  
If an inherited subprogram is implemented by a protected procedure or an entry, then the first parameter of 
the inherited subprogram shall be of mode out or in out , or an access-to-variable parameter. If an inherited 
subprogram is implemented by  a protected function, then the first parameter of the inherited subprogram 
shall be of mode in, but not an access-to-variable parameter.  
If a protected subprogram declaration has an overriding_indicator , then at the point of the declaration: 
• if the overriding_indicator  is overriding , then the subprogram sha ll implement an inherited 
subprogram; 
• if the overriding_indicator  is not overriding , then the subprogram sh all not implement any 
inherited subprogram. 
In addition to the places where Legality Rules normally  apply (see 12.3), these rules also apply in the 
private part of an instance of a generic unit. 11.1/3 
11.2/2 
11.3/2 11.4/3 
11.5/2 
11.6/2 
11.7/2 
11.8/2 
11.9/3 
11.10/2 
11.11/2 
11.12/2 11.13/2 
Ada Reference Manual — 2012 Edition 
215      13 December 2012 Protected Units and Protected Objects   9.4 Dynamic Semantics 
The elaboration of a protected declaration elaborates the protected_definition . The elaboration of a 
single_protected_declaration  also creates an object of an  (anonymous) protected type.  
The elaboration of a protected_definition  creates the protected type and its first subtype; it also includes 
the elaboration of the component_declaration s and protected_operation_declaration s in the given order. 
As part of the initialization of a protected object, an y per-object constraints (see 3.8) are elaborated.  
The elaboration of a protected_body  has no other effect than to establish that protected operations of the 
type can from then on be called without failing the Elaboration_Check. 
The content of an object of a given protected type includes:  
• The values of the components of the protected object, including (implicitly) an entry queue for 
each entry declared for the protected object;  
• A representation of the state of the execution resource associated  with the protected object (one 
such resource is associated with each protected object).  
The execution resource associated with a protected object has to be acquired to read or update any 
components of the protected object; it can be acquired (as part of a protected action — see 9.5.1) either for 
concurrent read-only access, or for exclusive read-write access. 
As the first step of the finalization  of a protected object, each call remaining on any entry queue of the 
object is removed from its queue and Program_Erro r is raised at the place of the corresponding entry_-
call_statement .  
Bounded (Run-Time) Errors 
It is a bounded error to call an entry or subprogram of a protected object after that object is finalized. If the 
error is detected, Program_Error is raised. Otherwis e, the call proceeds normally, which may leave a task 
queued forever.  
NOTES 
13  Within the declaration or body of a protected unit other than in an access_definition , the name of the protected unit 
denotes the current instance of the unit (see 8.6), rather than the first subtype of the corresponding protected type (and thus the name cannot be used as a 
subtype_mark ).  
14  A selected_component  can be used to denote a discriminant of a protected object (see 4.1.3). Within a protected unit, 
the name of a discriminant of the protected type denotes the corresponding discriminant of the current instance of the unit. 
15  A protected type is a limited type (see 7.5), and hence precludes use of assignment_statement s and predefined 
equality operators. 
16  The bodies of the protected operations given in the protected_body  define the actions that take place upon calls to the 
protected operations. 
17  The declarations in the private part are only visible within the private part and the body of the protected unit.  
Examples 
Example of declaration of protected type and corresponding body:   
protected  type Resource is 
   entry Seize; 
   procedure  Release; 
private 
   Busy : Boolean := False; end Resource; 12 
13 14 
15 
16 
17 
18 19 
20 
20.1/2 
21/2 
22 
23/2 
24 25 
26 
27 
Ada Reference Manual — 2012 Edition 
9.4   Protected Units and Protected  Objects 13 December 2012      216 protected  body Resource is 
   entry Seize when not  Busy is 
   begin 
      Busy := True;    end Seize; 
   procedure  Release is 
   begin 
      Busy := False;    end Release; 
end Resource; 
Example of a single protected declaration and corresponding body:   
protected  Shared_Array is 
   --   Index, Item, and Item_Array are global types  
   function   Component    (N : in Index) return Item; 
   procedure  Set_Component(N : in Index; E : in  Item); 
private 
   Table : Item_Array(Index) := (others => Null_Item); end Shared_Array; 
protected  body Shared_Array is 
   function  Component(N : in Index) return Item is 
   begin 
      return Table(N); 
   end Component; 
   procedure  Set_Component(N : in Index; E : in Item) is 
   begin 
      Table(N) := E;    end Set_Component; 
end Shared_Array; 
Examples of protected objects:   
Control  : Resource; 
Flags    : array(1 .. 100) of Resource; 
9.5 Intertask Communication 
The primary means for intertask communication is  provided by calls on entries and protected 
subprograms. Calls on protected subprograms allow coor dinated access to shared data objects. Entry calls 
allow for blocking the caller until a given condition is satisfied (namely, that the corresponding entry is 
open — see 9.5.3), and then communicating data or c ontrol information directly with another task or 
indirectly via a shared protected object. 
Static Semantics 
When a name  or prefix  denotes an entry, protected subprogram , or a prefixed view of a primitive 
subprogram of a limited interface whose first parameter is a controlling parameter, the name  or prefix  
determines a target object , as follows:  
• If it is a direct_name  or expanded name that denotes the declaration (or body) of the operation, 
then the target object is implicitly specified to be the current instance of the task or protected 
unit immediately enclosing the operation; a call using such a name is defined to be an internal 
call; 
• If it is a selected_component  that is not an expanded name, then the target object is explicitly 
specified to be the  object denoted by the prefix  of the name ; a call using such a name is defined 
to be an external call ;  28 
29 
30 
31 
32 
33 
34 
35 
1 
2/3 
3/3 
4/3 
Ada Reference Manual — 2012 Edition 
217      13 December 2012 Intertask Communication   9.5 • If the name  or prefix  is a dereference (implicit or explic it) of an access-to-protected-subprogram 
value, then the target object is determined by the prefix  of the Access attribute_reference  that 
produced the access value originally; a call using such a name is defined to be an external call ; 
• If the name  or prefix  denotes a subprogram_renaming_declaration , then the target object is as 
determined by the name  of the renamed entity. 
A call on an entry or a protect ed subprogram either uses a name  or prefix  that determines a target object 
implicitly, as above, or is a call on (a non-prefixed view of) a primitive subprogram of a limited interface 
whose first parameter is a controlling parameter, in wh ich case the target object is identified explicitly by 
the first parameter. Th is latter case is an external call . 
A corresponding definition of target object applies to a requeue_statement  (see 9.5.4), with a 
corresponding distinction between an internal requeue  and an external requeue . 
Legality Rules 
If a name  or prefix  determines a target object, and the name denotes a protected entry or procedure, then 
the target object shall be a variable, unless the prefix  is for an attribute_reference  to the Count attribute 
(see 9.9).  
Dynamic Semantics 
Within the body of a protected operation, the current  instance (see 8.6) of the immediately enclosing 
protected unit is determined by the target object speci fied (implicitly or explicitly) in the call (or requeue) 
on the protected operation.  
Any call on a protected procedure or entry of a target protected object is defined to be an update to the 
object, as is a requeue on such an entry.  
Syntax 
synchronization_kind ::= By_Entry | By_Protected_Procedure | Optional 
Static Semantics 
For the declaration of a primitive procedure of a sy nchronized tagged type the following language-defined 
representation aspect may be specified with an aspect_specification  (see 13.1.1): 
Synchronization 
 If specified, the aspect definition shall be a synchronization_kind . 
Inherited subprograms inherit the Synchronization as pect, if any, from the corresponding subprogram of 
the parent or progenitor type. If an overriding operati on does not have a directly specified Synchronization 
aspect then the Synchronization aspect of the inher ited operation is inherited by the overriding operation.  
Legality Rules 
The synchronization_kind  By_Protected_Procedure shall not be app lied to a primitive procedure of a task 
interface. 
A procedure for which the specified synchronization_kind  is By_Entry shall be implemented by an entry. 
A procedure for which the specified synchronization_kind  is By_Protected_Procedure shall be 
implemented by a protected procedure. A procedure for which the specified synchronization_kind  is 
Optional may be implemented by an entry or by  a procedure (including a protected procedure). 
If a primitive procedure overrides an inherited operati on for which the Synchronization aspect has been 
specified to be By_Entry or By_Protected_Procedure,  then any specification of the aspect Synchronization 
applied to the overriding operation shall have the same synchronization_kind . 5/3 
6 
6.1/3 
7 
7.1/3 
8 
9 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
16/3 
Ada Reference Manual — 2012 Edition 
9.5   Intertask Communication 13 December 2012      218 In addition to the places where Legality Rules normally  apply (see 12.3), these rules also apply in the 
private part of an instance of a generic unit.  
NOTES 
18  The synchronization_kind  By_Protected_Procedure implies that the operation will not block.  
9.5.1 Protected Subprograms and Protected Actions 
A protected subprogram  is a subprogram declared immediately within a protected_definition . Protected 
procedures provide exclusive read-write access to th e data of a protected object; protected functions 
provide concurrent read-only access to the data.  
Static Semantics 
Within the body of a protected function (or a function declared immediately within a protected_body ), the 
current instance of the enclosing protected unit is defi ned to be a constant (tha t is, its subcomponents may 
be read but not updated). Within the body of a protect ed procedure (or a procedure declared immediately 
within a protected_body ), and within an entry_body , the current instance is defined to be a variable 
(updating is permitted).  
Dynamic Semantics 
For the execution of a call on a protect ed subprogram, the evaluation of the name  or prefix  and of the 
parameter associations, a nd any assigning back of in out  or out parameters, proceeds as for a normal 
subprogram call (see 6.4). If the call is  an internal call (see 9.5), the body  of the subprogram is executed as 
for a normal subprogram call. If the call is an external call, then the body  of the subprogram is executed as 
part of a new protected action  on the target protected object; the protected action completes after the body 
of the subprogram is executed. A protected action can also be started by an entry call (see 9.5.3). 
A new protected action is not started on a protected  object while another protected action on the same 
protected object is underway, unless both actions are the result of a call on a protected function. This rule 
is expressible in terms of the execution res ource associated with the protected object:  
• Starting  a protected action on a protected object corresponds to acquiring  the execution resource 
associated with the protected object, either fo r concurrent read-only access if the protected 
action is for a call on a protected function, or  for exclusive read-write access otherwise; 
• Completing  the protected action corresponds to releasing  the associated execution resource.  
After performing an operation on a protected object othe r than a call on a protected function, but prior to 
completing the associated protected action, the entry queues (if any) of the protected object are serviced 
(see 9.5.3).  
Bounded (Run-Time) Errors 
During a protected action, it is a bounded error to invoke an operation that is potentially blocking . The 
following are defined to be potentially blocking operations:  
• a select_statement ; 
• an accept_statement ; 
• an entry_call_statement ; 
• a delay_statement ; 
• an abort_statement ; 
• task creation or activation; 17/3 
18/3 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 11 12 13 14 
Ada Reference Manual — 2012 Edition 
219      13 December 2012 Protected S ubprograms and Protected Actions   9.5.1 • an external call on a protected subprogram (or an  external requeue) with the same target object 
as that of the protected action;  
• a call on a subprogram whose body contai ns a potentially blocking operation.  
If the bounded error is detected, Program_Error is rais ed. If not detected, the bounded error might result in 
deadlock or a (nested) protected action on the same target object. 
Certain language-defined subprograms are potentially blocking. In particular, the subprograms of the 
language-defined input-output packages that manipul ate files (implicitly or explicitly) are potentially 
blocking. Other potentially blocking subprograms are identified where they are defined. When not 
specified as potentially blocking, a langua ge-defined subprogram is nonblocking.  
NOTES 
19  If two tasks both try to start a protected action on a protected object, and at most one is calling a protected function, then only one of the tasks can  proceed. Alt hough the other task cannot pr oceed, it is not considered  blocked, and it might 
be consuming processing resources while it awaits its turn. There is no language-defined ordering or queuing presumed for tasks competing to start a protected action — on a multiprocessor such tasks might use busy-waiting; for monoprocessor considerations, see D.3, “Priority Ceiling Locking”.  
20  The body of a protected unit may contain declarations and bodies for local subprograms. These are not visible outside 
the protected unit. 
21  The body of a protected function can contain internal calls on other protected functions, but not protected procedures, 
because the current in stance is a constant. On the other hand, the body of a protected procedure can contai n internal calls 
on both protected functions and procedures. 
22  From within a protected action, an internal call on a protected subprogram, or an external call on a protected 
subprogram with a different target object is not considered a potentially blocking operation.  
23  The 
pragma  Detect_Blocking may be used to ensure that all executions of potentially blocking operations during a 
protected action raise Program_Error. See H.5.  
Examples 
Examples of protected s ubprogram calls (see 9.4):   
Shared_Array.Set_Component(N, E); 
E := Shared_Array.Component(M); Control.Release; 
9.5.2 Entries and Accept Statements 
Entry_declaration s, with the corresponding entry_bodies  or accept_statement s, are used to define 
potentially queued operations on ta sks and protected objects.  
Syntax 
entry_declaration ::=  
   [overriding_indicator ] 
   entry  defining_identifier  [(discrete_subtype_definition )] parameter_profile  
      [aspect_specification ]; 
accept_statement ::=  
   accept  entry_ direct_name  [(entry_index )] parameter_profile  [do 
     handled_sequence_of_statements  
   end [entry_ identifier ]]; 
entry_index ::= expression  15 
16 
17 
18 
19 
20 
21 
22 
22.1/2 
23 
24 
1 
2/3 
3 
4 
Ada Reference Manual — 2012 Edition 
9.5.2    Entries and Accept Statements 13 December 2012      220 entry_body ::=  
  entry  defining_identifier   entry_body_formal_part   entry_barrier  is 
    declarative_part  
  begin  
    handled_sequence_of_statements  
  end [entry_ identifier ]; 
entry_body_formal_part ::= [(entry_index_specification )] parameter_profile  
entry_barrier ::= when  condition  
entry_index_specification ::= for defining_identifier  in discrete_subtype_definition  
If an entry_ identifier  appears at the end of an accept_statement , it shall repeat the entry_ direct_-
name . If an entry_ identifier  appears at the end of an entry_body , it shall repeat the defining_-
identifier . 
An entry_declaration  is allowed only in a protected or task declaration.  
An overriding_indicator  is not allowed in an entry_declaration  that includes a 
discrete_subtype_definition .  
Name Resolution Rules 
In an accept_statement , the expected profile for the entry_ direct_name  is that of the entry_declaration ; 
the expected type for an entry_index  is that of the subtype defined by the discrete_subtype_definition  of 
the corresponding entry_declaration . 
Within the handled_sequence_of_statements  of an accept_statement , if a selected_component  has a 
prefix  that denotes the corresponding entry_declaration , then the entity denoted by the prefix  is the 
accept_statement , and the selected_component  is interpreted as an expanded name (see 4.1.3); the 
selector_name  of the selected_component  has to be the identifier  for some formal parameter of the 
accept_statement .  
Legality Rules 
An entry_declaration  in a task declaration shall not contain a specification for an access parameter (see 
3.10).  
If an entry_declaration  has an overriding_indicator , then at the point of the declaration:  
• if the overriding_indicator  is overriding , then the entry shall implement an inherited 
subprogram; 
• if the overriding_indicator  is not overriding , then the entry shall not implement any inherited 
subprogram. 
In addition to the places where Legality Rules normally  apply (see 12.3), these rules also apply in the 
private part of an instance of a generic unit. 
For an accept_statement , the innermost enclosing body shall be a task_body , and the entry_ direct_name  
shall denote an entry_declaration  in the corresponding task declaration; the profile of the accept_-
statement  shall conform fully to that of the corresponding entry_declaration . An accept_statement  shall 
have a parenthesized entry_index  if and only if the corresponding entry_declaration  has a discrete_-
subtype_definition . 
An accept_statement  shall not be within another accept_statement  that corresponds to the same entry_-
declaration , nor within an asynchronous_select  inner to the enclosing task_body .  5 
6 
7 8 9 
10 
10.1/2 
11 
12 
13 
13.1/2 
13.2/2 
13.3/2 13.4/2 
14 
15 
Ada Reference Manual — 2012 Edition 
221      13 December 2012 Entries and Accept Statements   9.5.2 An entry_declaration  of a protected unit requires a completion, which shall be an entry_body , and every 
entry_body  shall be the completion of an entry_declaration  of a protected unit. The profile of the entry_-
body  shall conform fully to that of the corresponding declaration.  
An entry_body_formal_part  shall have an entry_index_specification  if and only if the corresponding 
entry_declaration  has a discrete_subtype_definition . In this case, the discrete_subtype_definition s of the 
entry_declaration  and the entry_index_specification  shall fully conform to one another (see 6.3.1).  
A name that denotes a formal parameter of an entry_body  is not allowed within the entry_barrier  of the 
entry_body . 
Static Semantics 
The parameter modes define d for parameters in the parameter_profile  of an entry_declaration  are the 
same as for a subprogram_declaration  and have the same meaning (see 6.2).  
An entry_declaration  with a discrete_subtype_definition  (see 3.6) declares a family  of distinct entries 
having the same profile, with one such entry for each value of the entry index subtype  defined by the 
discrete_subtype_definition . A name for an entry of a family takes the form of an indexed_component , 
where the prefix  denotes the entry_declaration  for the family, and the index value identifies the entry 
within the family. The term single entry  is used to refer to any entry othe r than an entry of an entry family. 
In the entry_body  for an entry family, the entry_index_specification  declares a named constant whose 
subtype is the entry index subtype defined by the corresponding entry_declaration ; the value of the named 
entry index  identifies which entry of the family was called.  
Dynamic Semantics 
The elaboration of an entry_declaration  for an entry family consists of the elaboration of the discrete_-
subtype_definition , as described in 3.8. The elaboration of an entry_declaration  for a single entry has no 
effect.  
The actions to be performed when an entr y is called are specified by the corresponding accept_-
statement s (if any) for an entry of a task unit, and by the corresponding entry_body  for an entry of a 
protected unit. 
For the execution of an accept_statement , the entry_index , if any, is first evaluated and converted to the 
entry index subtype; this index value identifies which entry of the family is to be accepted. Further execution of the 
accept_statement  is then blocked until a caller of th e corresponding entry is selected (see 
9.5.3), whereupon the handled_sequence_of_statements , if any, of the accept_statement  is executed, 
with the formal parameters associat ed with the corresponding actual parame ters of the selected entry call. 
Upon completion of the handled_sequence_of_statements , the accept_statement  completes and is left. 
When an exception is propagated from the handled_sequence_of_statements  of an accept_statement , 
the same exception is also raised by the execution of the corresponding entry_call_statement .  
The above interaction between a calling task and an accepting task is called a rendezvous . After a 
rendezvous, the two tasks continue their execution independently. 
An entry_body  is executed when the condition  of the entry_barrier  evaluates to True and a caller of the 
corresponding single entry, or entry of the corresponding entry family, has been selected (see 9.5.3). For 
the execution of the entry_body , the declarative_part  of the entry_body  is elaborated, and the handled_-
sequence_of_statements  of the body is executed, as for the execution of a subprogram_body . The value 
of the named entry index, if any, is determined by the value of the entry index specified in the entry_ name  
of the selected entry call (or intermediate requeue_statement  — see 9.5.4).  16 
17 
18 
19 
20 
21 
22/1 
23 
24 
25 
26 
Ada Reference Manual — 2012 Edition 
9.5.2    Entries and Accept Statements 13 December 2012      222 NOTES 
24  A task entry has corresponding accept_ statements (zero or mo re), whereas a protected entry has a corresponding 
entry_body (exactly one). 
25  A consequence of the rule regarding the allowed placements of accept_statement s is that a task can execute 
accept_statement s only for its own entries. 
26  A return statement (see 6.5) or a requeue_statement  (see 9.5.4) may be used to complete the execution of an 
accept_statement  or an entry_body .  
27  The condition  in the entry_barrier  may reference anything visible except the formal parameters of the entry. This 
includes the entry index (if any), the components (including discriminants) of the protected object, the Count attribute of an entry of that protected object, and data global to the protected unit. 
The restriction against referencing the formal parameters within an 
entry_barrier  ensures that all calls of the same entry 
see the same barrier value. If it is necessary to look at the parameters of an entry call before deciding whether to handle it,  
the entry_barrier  can be “ when  True” and the caller can be requeued (on some private entry) when its parameters indicate 
that it cannot be handled immediately.  
Examples 
Examples of entr y declarations:   
entry Read(V : out Item); 
entry Seize; 
entry Request(Level)(D : Item);  --   a family of entries  
Examples of accept statements:   
accept Shut_Down; 
accept Read(V : out Item) do 
   V := Local_Item; end Read; 
accept Request(Low)(D : Item) do 
   ... end Request; 
9.5.3 Entry Calls 
An entry_call_statement  (an entry call ) can appear in various contexts. A simple  entry call is a stand-
alone statement that represents an unconditional call on an entry of a target task or a protected object. 
Entry calls can also appear as part of select_statement s (see 9.7).  
Syntax 
entry_call_statement ::= entry_ name  [actual_parameter_part ]; 
Name Resolution Rules 
The entry_ name  given in an entry_call_statement  shall resolve to denote an entry. The rules for 
parameter associations are the same as for subprogram calls (see 6.4 and 6.4.1).  
Static Semantics 
The entry_ name  of an entry_call_statement  specifies (explicitly or implicitly) the target object of the call, 
the entry or entry family, and the entry index, if any (see 9.5).  
Dynamic Semantics 
Under certain circumstances (detailed below), an entr y of a task or protected object is checked to see 
whether it is open  or closed :  27 
28 
29/2 
30 
31 
32 
33 
34 
35 
36 
37 
1 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
223      13 December 2012 Entry Calls   9.5.3 • An entry of a task is open if the task is blocked on an accept_statement  that corresponds to the 
entry (see 9.5.2), or on a selective_accept  (see 9.7.1) with an open accept_alternative  that 
corresponds to the entry; otherwise, it is closed. 
• An entry of a protected object is open if the condition  of the entry_barrier  of the corresponding 
entry_body  evaluates to True; otherwise, it is closed. If the evaluation of the condition  
propagates an exception, the exception Program_Error is propagated to all current callers of all 
entries of the protected object.  
For the execution of an entry_call_statement , evaluation of the name  and of the parameter associations is 
as for a subprogram call (see 6. 4). The entry call is then issued : For a call on an entry of a protected object, 
a new protected action is started on the object (see 9.5.1). The named entry is checked to see if it is open; if open, the entry call is said to be selected immediately , and the execution of the call proceeds as follows:  
• For a call on an open entry of a task, the accepting task becomes ready and continues the 
execution of the corresponding 
accept_statement  (see 9.5.2). 
• For a call on an open entry of a protected object, the corresponding entry_body  is executed (see 
9.5.2) as part of the protected action.  
If the accept_statement  or entry_body  completes other than by a requeue  (see 9.5.4), return is made to 
the caller (after servicing the entry queues — see below); any necessary assigning back of formal to actual parameters occurs, as for a subpr ogram call (see 6.4.1); such assignments take place outside of any 
protected action.  
If the named entry is closed, th e entry call is added to an entry queue  (as part of the protected action, for a 
call on a protected entry), and the call remains queued un til it is selected or cancelled; there is a separate 
(logical) entry queue for each entry of a given task or protected object (including each entry of an entry family). 
When a queued call is selected , it is removed from its entry queue. Selecting a queued call from a 
particular entry queue is called servicing  the entry queue. An entry with queued calls can be serviced 
under the following circumstances:  
• When the associated task reaches a corresponding 
accept_statement , or a selective_accept  
with a corresponding open accept_alternative ; 
• If after performing, as part of a protected ac tion on the associated protected object, an operation 
on the object other than a call on a protected functi on, the entry is checked and found to be open.  
If there is at least one call on a queue corresponding to  an open entry, then one such call is selected 
according to the entry queuing policy  in effect (see below), and the corresponding accept_statement  or 
entry_body  is executed as above for an entry call that is selected immediately. 
The entry queuing policy controls selection among queue d calls both for task and protected entry queues. 
The default entry queuing policy is to select calls on a given entry queue in order of arrival. If calls from 
two or more queues are simultaneously eligible for selection, the default entry queuing policy does not 
specify which queue is serviced first. Othe r entry queuing policies can be specified by pragma s (see D.4). 
For a protected object, the above servicing of entry queues continues until there are no open entries with 
queued calls, at which point the protected action completes.  
For an entry call that is added to a queue, and that is not the triggering_statement  of an asynchronous_-
select  (see 9.7.4), the calling task is blocked until the call is cancelled, or the call is selected and a 
corresponding accept_statement  or entry_body  completes without requeuing. In addition, the calling task 
is blocked during a rendezvous. 6/3 
7/3 
8 
9 
10 11 
12 
13 
14 
15 16 
17 
18 
19 
Ada Reference Manual — 2012 Edition 
9.5.3    Entry Calls 13 December 2012      224 An attempt can be made to cancel an entry call upon an  abort (see 9.8) and as part of certain forms of 
select_statement  (see 9.7.2, 9.7.3, and 9.7.4). The cancella tion does not take place until a point (if any) 
when the call is on some entry queue, and not protected  from cancellation as part of a requeue (see 9.5.4); 
at such a point, the call is removed from the entry queue and the call completes due to the cancellation. 
The cancellation of a call on an entry of a protected obj ect is a protected action, and as such cannot take 
place while any other protected action is occurring on the protected object. Like any protected action, it includes servicing of the entry queues (in case some  entry barrier depends on a Count attribute).  
A call on an entry of a task that has already comple ted its execution raises the exception Tasking_Error at 
the point of the call; similarly, this exception is raised  at the point of the call if the called task completes 
its execution or becomes abnormal before accepting the call or completing the rendezvous (see 9.8). This 
applies equally to a simple entry call and to an entry call as part of a 
select_statement . 
Implementation Permissions 
An implementation may perform the sequence of steps of  a protected action using any thread of control; it 
need not be that of the task that started the protected action. If an entry_body  completes without 
requeuing, then the corresponding calling task may be made ready without waiting for the entire protected 
action to complete.  
When the entry of a protected object is checked to see whether it is open, th e implementation need not 
reevaluate the condition  of the corresponding entry_barrier  if no variable or attribute referenced by the 
condition  (directly or indirectly) has been altered by the execution (or cancellation) of a protected 
procedure or entry call on the object since the condition  was last evaluated.  
An implementation may evaluate the condition s of all entry_barrier s of a given protected object any time 
any entry of the object is checked to see if it is open.  
When an attempt is made to cancel an entry call, th e implementation need not ma ke the attempt using the 
thread of control of the task (or interrupt) that initia ted the cancellation; in particular, it may use the thread 
of control of the caller itself to attempt the cancellati on, even if this might allow the entry call to be 
selected in the interim.  
NOTES 
28  If an exception is raised during the execution of an entry_body , it is propagated to the corresponding caller (see 11.4). 
29  For a call on a protected entry, the entry is checked to see if it is open prior to queuing the call, and again thereafter if 
its Count attribute (see 9.9) is referenced in some entry barrier.  
30  In addition to simple entry calls, the language permits timed, conditional, and asynchronous entry calls (see 9.7.2, 
9.7.3, and see 9.7.4).  
31  The condition  of an entry_barrier  is allowed to be evaluated by an implementation more often than strictly necessary, 
even if the evaluation might have side effects. On the other hand, an implementation need not reevaluate the condition  if 
nothing it references was updated by an intervening protected action on the protected object, even if the condition  
references some global variable that might have been updated by an action performed from outside of a protected action.  
Examples 
Examples of entry calls:   
Agent.Shut_Down;                      --   see 9.1 
Parser.Next_Lexeme(E);                --   see 9.1 
Pool(5).Read(Next_Char);              --   see 9.1 
Controller.Request(Low)(Some_Item);   --   see 9.1 
Flags(3).Seize;                       --   see 9.4 20 
21 
22 
23 
24 
25 
26 
27 
28 29 
30 
31 
Ada Reference Manual — 2012 Edition 
225      13 December 2012 Requeue Statements   9.5.4 9.5.4 Requeue Statements 
A requeue_statement  can be used to complete an accept_statement  or entry_body , while redirecting the 
corresponding entry call to a new (or the same) entry queue. Such a requeue  can be performed with or 
without allowing an intermediate cancellation of the call,  due to an abort or the expiration of a delay.  
Syntax 
requeue_statement ::= requeue  procedure_or_entry_ name  [with  abort ]; 
Name Resolution Rules 
The procedure_or_entry_ name  of a requeue_statement  shall resolve to denote a procedure or an entry 
(the requeue target ). The profile of the entry, or the profile or prefixed profile of the procedure, shall 
either have no parameters, or be ty pe conformant (see 6.3.1) with the profile of the innermost enclosing 
entry_body  or accept_statement .  
Legality Rules 
A requeue_statement  shall be within a callable c onstruct that is either an entry_body  or an 
accept_statement , and this construct shall be the innerm ost enclosing body or callable construct. 
If the requeue target has parameters, then its (prefixed)  profile shall be subtype conformant with the profile 
of the innermost enclosi ng callable construct.  
If the target is a procedure, the name shall denote a renaming of an entry, or shall denote a view or a 
prefixed view of a primitive subprogram of a synchr onized interface, where the first parameter of the 
unprefixed view of the primitive subprogram shall be  a controlling parameter, and the Synchronization 
aspect shall be specified with synchronization_kind  By_Entry for the primitive subprogram. 
In a requeue_statement  of an accept_statement  of some task unit, either the target object shall be a part 
of a formal parameter of the accept_statement , or the accessibility level of the target object shall not be 
equal to or statically deeper than any enclosing accept_statement  of the task unit. In a requeue_-
statement  of an entry_body  of some protected unit, either the target object shall be a part of a formal 
parameter of the entry_body , or the accessibility level of the target object shall not be statically deeper 
than that of the entry_declaration  for the entry_body . 
Dynamic Semantics 
The execution of a requeue_statement  proceeds by first evaluating the procedure_or_entry_ name , 
including the prefix  identifying the target task or protected object and the expression  identifying the entry 
within an entry family, if any. The entry_body  or accept_statement  enclosing the requeue_statement  is 
then completed, finalized, and left (see 7.6.1). 
For the execution of a requeue on an entry of a target task, after leaving the enclosing callable construct, 
the named entry is checked to see if it is open and the requeued call is either selected immediately or queued, as for a normal entry call (see 9.5.3). 
For the execution of a requeue on an entry of a target  protected object, after leaving the enclosing callable 
construct:  
• if the requeue is an internal requeue (that is , the requeue is back on an entry of the same 
protected object — see 9.5), the call is added to the queue of the named entry and the ongoing protected action continues (see 9.5.1);  1 
2/3 
3/3 
4 
5/3 
5.1/3 
6/3 
7/3 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
9.5.4    Requeue Statements 13 December 2012      226 • if the requeue is an external requeue (that is, th e target protected object is not implicitly the same 
as the current object — see 9.5), a protected action is started on the target object and proceeds as for a normal entry call (see 9.5.3).  
If the requeue target named in the 
requeue_statement  has formal parameters, then during the execution of 
the accept_statement  or entry_body  corresponding to the new entry, the formal parameters denote the 
same objects as did the corresponding formal parameters of the callable construct completed by the 
requeue. In any case, no parameters are specified in a requeue_statement ; any parameter passing is 
implicit. 
If the requeue_statement  includes the reserved words with abort  (it is a requeue-with-abort ), then:  
• if the original entry call has been aborted (see 9.8), then the requeue acts as an abort completion 
point for the call, and the call is cancelled and no requeue is performed; 
• if the original entry call was timed (or conditi onal), then the original expiration time is the 
expiration time for the requeued call.  
If the reserved words with abort  do not appear, then the call remains protected against cancellation while 
queued as the result of the requeue_statement .  
NOTES 
32  A requeue is permitted from a single entry to an entry of an entry family, or vice-versa. The entry index, if any, plays no part in the subtype conformance check between the profiles of the two entries; an entry index is part of the entry_
name  
for an entry of a family.  
Examples 
Examples of requeue statements:   
requeue Request(Medium) with abort ; 
                    --  requeue on a member of an entry family of the current task, see 9.1  
requeue Flags(I).Seize; 
                    --  requeue on an entry of an array component, see 9.4  
9.6 Delay Statements, Duration, and Time 
A delay_statement  is used to block further execution until a specified expiration time  is reached. The 
expiration time can be specified either as a particular point in time (in a delay_until_statement ), or in 
seconds from the current time (in a delay_relative_statement ). The language-defined package Calendar 
provides definitions for a type Time  and associated operations, including a function Clock that returns the 
current time.  
Syntax 
delay_statement ::= delay_until_statement  | delay_relative_statement  
delay_until_statement ::= delay until  delay_ expression ; 
delay_relative_statement ::= delay  delay_ expression ; 
Name Resolution Rules 
The expected type for the delay_ expression  in a delay_relative_statement  is the predefined type 
Duration. The delay_ expression  in a delay_until_statement  is expected to be of any nonlimited type. 
Legality Rules 
There can be multiple time bases, each w ith a corresponding clock, and a corresponding time type . The 
type of the delay_ expression  in a delay_until_statement  shall be a time type — either the type Time 11 
12/3 
13 
14 
15 16 
17 
18 
19 
20 
1 
2 
3 4 
5 
6/3 
Ada Reference Manual — 2012 Edition 
227      13 December 2012 Delay Stat ements, Duration, and Time   9.6 defined in the language-defined package Calendar (see below), the type Time in the package Real_Time 
(see D.8), or some other impl ementation-defined time type.  
Static Semantics 
There is a predefined fixed point type named Duration, declared in the visible part of package Standard; a 
value of type Duration is used to represent the length of  an interval of time, expr essed in seconds. The type 
Duration is not specific to a particular time base, but can be used with any time base. 
A value of the type Time in package Calendar, or of some other time type, repres ents a time as reported by 
a corresponding clock. 
The following language-defined library package exists:  
 
package Ada.Calendar is 
  type Time is private; 
  subtype Year_Number  is Integer range 1901 .. 2399; 
  subtype Month_Number is Integer range 1 .. 12; 
  subtype Day_Number   is Integer range 1 .. 31; 
  subtype Day_Duration is Duration range 0.0 .. 86_400.0; 
  function  Clock return Time; 
  function  Year   (Date : Time) return Year_Number; 
  function  Month  (Date : Time) return Month_Number; 
  function  Day    (Date : Time) return Day_Number; 
  function  Seconds(Date : Time) return Day_Duration; 
  procedure  Split (Date  : in Time; 
                   Year    : out Year_Number; 
                   Month   : out Month_Number; 
                   Day     : out Day_Number; 
                   Seconds : out Day_Duration); 
  function  Time_Of(Year  : Year_Number; 
                   Month   : Month_Number;                    Day     : Day_Number;                    Seconds : Day_Duration := 0.0)    return Time; 
  function  "+" (Left : Time;   Right : Duration) return Time; 
  function  "+" (Left : Duration; Right : Time) return Time; 
  function  "-" (Left : Time;   Right : Duration) return Time; 
  function  "-" (Left : Time;   Right : Time) return Duration; 
  function  "<" (Left, Right : Time) return Boolean; 
  function  "<="(Left, Right : Time) return Boolean; 
  function  ">" (Left, Right : Time) return Boolean; 
  function  ">="(Left, Right : Time) return Boolean; 
  Time_Error : exception;  
private 
   ... -- not specified by the language  
end Ada.Calendar; 
Dynamic Semantics 
For the execution of a delay_statement , the delay_ expression  is first evaluated. For a 
delay_until_statement , the expiration time for the delay is the value of the delay_ expression , in the time 
base associated with the type of the expression . For a delay_relative_statement , the expiration time is 
defined as the current time, in the time base associ ated with relative delays, plus the value of the 
delay_ expression  converted to the type Duration, and then  rounded up to the next clock tick. The time 
base associated with relative delays is as defined in D.9, “Delay Accuracy” or is implementation defined.  7 
8/3 
9 
10 
11/2 
12 
13 
14 
15 
16 
17 
18 
19 
20 
Ada Reference Manual — 2012 Edition 
9.6   Delay Statements, Duration, and Time 13 December 2012      228 The task executing a delay_statement  is blocked until the expiration time is reached, at which point it 
becomes ready again. If the expiration time has already passed, the task is not blocked.  
If an attempt is made to cancel  the delay_statement  (as part of an asynchronous_select  or abort — see 
9.7.4 and 9.8), the statement is cancelled if the expi ration time has not yet passed, thereby completing the 
delay_statement .  
The time base associated with the type Time of p ackage Calendar is implementation defined. The function 
Clock of package Calendar returns a value repres enting the current time for this time base. The 
implementation-defined value of th e named number System.Tick (see 13. 7) is an approximation of the 
length of the real-time interval during which th e value of Calendar.Clock remains constant.  
The functions Year, Month, Day, and Seconds return  the corresponding values for a given value of the 
type Time, as appropriate to an implementation-de fined time zone; the procedure Split returns all four 
corresponding values. Conversely, the function Time_Of combines a year number,  a month number, a day 
number, and a duration, into a value of type Time. The operators "+" and "–" fo r addition and subtraction 
of times and durations, and the relational operato rs for times, have the conventional meaning.  
If Time_Of is called with a seconds value of 86_400.0, th e value returned is equal to the value of Time_Of 
for the next day with a seconds value of 0.0. The value returned by the function Seconds or through the 
Seconds parameter of the procedure Split is always less than 86_400.0. 
The exception Time_Error is raised by the function Ti me_Of if the actual parameters do not form a proper 
date. This exception is also raised by  the operators "+" and "–" if the result is not representable in the type 
Time or Duration, as appropriate. This exception is al so raised by the functions Year, Month, Day, and 
Seconds and the procedure Split if the year number of th e given date is outside of the range of the subtype 
Year_Number.  
Implementation Requirements 
The implementation of the type Duration shall allo w representation of time intervals (both positive and 
negative) up to at least 86400 seconds (one day); Du ration'Small shall not be greater than twenty 
milliseconds. The implementation of the type Time sh all allow representation of all dates with year 
numbers in the range of Year_Numbe r; it may allow representation of ot her dates as well (both earlier and 
later).  
Implementation Permissions 
An implementation may define additional time types. 
An implementation may raise Time_Error if the value of a delay_ expression  in a delay_until_statement  
of a select_statement  represents a time more than 90 days past th e current time. The actual limit, if any, is 
implementation-defined.  
Implementation Advice 
Whenever possible in an implementation, the valu e of Duration'Small should be no greater than 100 
microseconds.  
The time base for delay_relative_statement s should be monotonic; it need not  be the same time base as 
used for Calendar.Clock.  
NOTES 
33  A delay_relative_statement  with a negative value of the delay_ expression  is equivalent to one with a zero value. 21 
22/3 
23 
24/2 
25 
26/1 
27 
28/3 
29 
30 
31 
32 
Ada Reference Manual — 2012 Edition 
229      13 December 2012 Delay Stat ements, Duration, and Time   9.6 34  A delay_statement  may be executed by the environment task; consequently delay_statement s may be executed as 
part of the elaboration of a library_item  or the execution of the main subprogram. Such statements delay the environment 
task (see 10.2). 
35  A delay_statement  is an abort completion point and a potentially blocking operation, even if the task is not actually 
blocked. 
36  There is no necessary relationship between System.Tick (the resolution of the clock of package Calendar) and 
Duration'Small (the small  of type Duration).  
37  Additional requirements associated with delay_statement s are given in D.9, “Delay Accuracy”. 
Examples 
Example of a relative delay statement:   
delay 3.0;  --  delay 3.0 seconds  
Example of a periodic task:   
declare 
   use Ada.Calendar; 
   Next_Time : Time := Clock + Period;                       --  Period is a global constant of type Duration  
begin 
   loop               --  repeated every Period seconds  
      delay until Next_Time; 
      ... --  perform some actions  
      Next_Time := Next_Time + Period;    end loop; 
end; 
9.6.1 Formatting, Time Zones, and other operations for Time 
Static Semantics 
The following language-defined  library packages exist: 
package Ada.Calendar.Time_Zones is 
   -- Time zone manipulation:  
   type Time_Offset is range  -28*60 .. 28*60; 
   Unknown_Zone_Error : exception ; 
   function  UTC_Time_Offset (Date : Time := Clock) return Time_Offset; 
end Ada.Calendar.Time_Zones; 
 
package Ada.Calendar.Arithmetic is 
   -- Arithmetic on days:  
   type Day_Count is range  
     -366*(1+Year_Number'Last - Year_Number'First)      ..      366*(1+Year_Number'Last - Year_Number'First); 
   subtype Leap_Seconds_Count is Integer range -2047 .. 2047; 
   procedure  Difference (Left, Right : in Time; 
                         Days : out Day_Count; 
                         Seconds : out Duration; 
                         Leap_Seconds : out Leap_Seconds_Count); 
   function  "+" (Left : Time; Right : Day_Count) return Time; 
   function  "+" (Left : Day_Count; Right : Time) return Time; 
   function  "-" (Left : Time; Right : Day_Count) return Time; 
   function  "-" (Left, Right : Time) return Day_Count; 33 
34 
35 36 
37 
38 
39 
40 
1/2 
2/2 
3/2 4/2 5/2 6/2 7/2 8/2 
9/2 
10/2 
11/2 
12/2 
13/2 
Ada Reference Manual — 2012 Edition 
9.6.1    Formatting, Time Zones, and other operations for Time 13 December 2012      230 end Ada.Calendar.Arithmetic; 
 
with Ada.Calendar.Time_Zones; 
package Ada.Calendar.Formatting is 
   -- Day of the week:  
   type Day_Name is (Monday, Tuesday, Wednesday, Thursday, 
       Friday, Saturday, Sunday); 
   function  Day_of_Week (Date : Time) return Day_Name; 
   -- Hours:Minutes:Seconds access:  
   subtype Hour_Number         is Natural range 0 .. 23; 
   subtype Minute_Number       is Natural range 0 .. 59; 
   subtype Second_Number       is Natural range 0 .. 59; 
   subtype Second_Duration     is Day_Duration range 0.0 .. 1.0; 
   function  Year       (Date : Time; 
                        Time_Zone  : Time_Zones.Time_Offset := 0)                            return Year_Number; 
   function  Month      (Date : Time; 
                        Time_Zone  : Time_Zones.Time_Offset := 0)                            return Month_Number; 
   function  Day        (Date : Time; 
                        Time_Zone  : Time_Zones.Time_Offset := 0)                            return Day_Number; 
   function  Hour       (Date : Time; 
                        Time_Zone  : Time_Zones.Time_Offset := 0)                            return Hour_Number; 
   function  Minute     (Date : Time; 
                        Time_Zone  : Time_Zones.Time_Offset := 0)                            return Minute_Number; 
   function  Second     (Date : Time) 
                           return Second_Number; 
   function  Sub_Second (Date : Time) 
                           return Second_Duration; 
   function  Seconds_Of (Hour   :  Hour_Number; 
                        Minute : Minute_Number;                         Second : Second_Number := 0;                         Sub_Second : Second_Duration := 0.0)        return Day_Duration; 
   procedure  Split (Seconds    : in Day_Duration; 
                    Hour       : out Hour_Number; 
                    Minute     : out Minute_Number; 
                    Second     : out Second_Number; 
                    Sub_Second : out Second_Duration); 
   function  Time_Of (Year       : Year_Number; 
                     Month      : Month_Number;                      Day        : Day_Number;                      Hour       : Hour_Number;                      Minute     : Minute_Number;                      Second     : Second_Number;                      Sub_Second : Second_Duration := 0.0;                      Leap_Second: Boolean := False;                      Time_Zone  : Time_Zones.Time_Offset := 0)                              return Time; 
   function  Time_Of (Year       : Year_Number; 
                     Month      : Month_Number;                      Day        : Day_Number;                      Seconds    : Day_Duration := 0.0;                      Leap_Second: Boolean := False;                      Time_Zone  : Time_Zones.Time_Offset := 0)                              return Time; 14/2 
15/2 
16/2 
17/2 
18/2 
19/2 20/2 
21/2 
22/2 23/2 24/2 25/2 26/2 
27/2 28/2 
29/2 
30/2 
31/2 
Ada Reference Manual — 2012 Edition 
231      13 December 2012 Formatting, Time Zones, and other operations for Time   9.6.1    procedure  Split (Date       : in Time; 
                    Year       : out Year_Number; 
                    Month      : out Month_Number; 
                    Day        : out Day_Number; 
                    Hour       : out Hour_Number; 
                    Minute     : out Minute_Number; 
                    Second     : out Second_Number; 
                    Sub_Second : out Second_Duration; 
                    Time_Zone  : in Time_Zones.Time_Offset := 0); 
   procedure  Split (Date       : in Time; 
                    Year       : out Year_Number; 
                    Month      : out Month_Number; 
                    Day        : out Day_Number; 
                    Hour       : out Hour_Number; 
                    Minute     : out Minute_Number; 
                    Second     : out Second_Number; 
                    Sub_Second : out Second_Duration; 
                    Leap_Second: out Boolean; 
                    Time_Zone  : in Time_Zones.Time_Offset := 0); 
   procedure  Split (Date       : in Time; 
                    Year       : out Year_Number; 
                    Month      : out Month_Number; 
                    Day        : out Day_Number; 
                    Seconds    : out Day_Duration; 
                    Leap_Second: out Boolean; 
                    Time_Zone  : in Time_Zones.Time_Offset := 0); 
   -- Simple image and value:  
   function  Image (Date : Time; 
                   Include_Time_Fraction : Boolean := False;                    Time_Zone  : Time_Zones.Time_Offset := 0) return String; 
   function  Value (Date : String; 
                   Time_Zone  : Time_Zones.Time_Offset := 0) return Time; 
   function  Image (Elapsed_Time : Duration; 
                   Include_Time_Fraction : Boolean := False) return String; 
   function  Value (Elapsed_Time : String) return Duration; 
end Ada.Calendar.Formatting; 
Type Time_Offset represents the number of minutes  difference between the im plementation-defined time 
zone used by Calendar and another time zone. 
function  UTC_Time_Offset (Date : Time := Clock) return Time_Offset; 
Returns, as a number of minutes, the result of subtracting the implemen tation-defined time zone 
of Calendar from UTC time, at the time Date. If the time zone of the Calendar implementation is unknown, then Unknown_Zone_Error is raised.  
procedure  Difference (Left, Right : in Time; 
                      Days : out Day_Count; 
                      Seconds : out Duration; 
                      Leap_Seconds : out Leap_Seconds_Count); 
Returns the difference between Left and Right. Days is the number of days of difference, 
Seconds is the remainder seconds of difference excluding leap seconds, a nd Leap_Seconds is the 
number of leap seconds. If Left < Right, then Seconds <= 0.0, Days <= 0, and Leap_Seconds <= 
0. Otherwise, all values are nonnegative. The ab solute value of Seconds is always less than 
86_400.0. For the returned values, if Days = 0, then Seconds + Duration(Leap_Seconds) = 
Calendar."–" (Left, Right).  32/2 
33/2 
34/2 
35/2 
36/2 
37/2 38/2 
39/2 
40/2 
41/2 
42/3 
43/2 
44/2 
Ada Reference Manual — 2012 Edition 
9.6.1    Formatting, Time Zones, and other operations for Time 13 December 2012      232 function  "+" (Left : Time; Right : Day_Count) return Time; 
function  "+" (Left : Day_Count; Right : Time) return Time; 
Adds a number of days to a time va lue. Time_Error is raised if the result is not representable as a 
value of type Time. 
function  "-" (Left : Time; Right : Day_Count) return Time; 
Subtracts a number of days from a time value. Time_Error is raised if the result is not 
representable as a value of type Time. 
function  "-" (Left, Right : Time) return Day_Count; 
Subtracts two time values, and retu rns the number of days between them. This is the same value 
that Difference would return in Days. 
function  Day_of_Week (Date : Time) return Day_Name; 
Returns the day of the week for Time. This is  based on the Year, Month, and Day values of 
Time. 
function  Year       (Date : Time; 
                     Time_Zone  : Time_Zones.Time_Offset := 0)                         return Year_Number; 
Returns the year for Date, as appropriate for the specified time zone offset. 
function  Month      (Date : Time; 
                     Time_Zone  : Time_Zones.Time_Offset := 0)                         return Month_Number; 
Returns the month for Date, as appropriate for the specified time zone offset. 
function  Day        (Date : Time; 
                     Time_Zone  : Time_Zones.Time_Offset := 0)                         return Day_Number; 
Returns the day number for Date, as appropr iate for the specified time zone offset. 
function  Hour       (Date : Time; 
                     Time_Zone  : Time_Zones.Time_Offset := 0)                         return Hour_Number; 
Returns the hour for Date, as appropriate  for the specified time zone offset. 
function  Minute     (Date : Time; 
                     Time_Zone  : Time_Zones.Time_Offset := 0)                         return Minute_Number; 
Returns the minute within the hour for Date, as appropriate for the specified time zone offset. 
function  Second     (Date : Time) 
                        return Second_Number; 
Returns the second within the hour and minute for Date. 
function  Sub_Second (Date : Time) 
                        return Second_Duration; 
Returns the fraction of second for Date (this ha s the same accuracy as Day_Duration). The value 
returned is always less than 1.0. 45/2 
46/2 
47/2 
48/2 
49/2 
50/2 
51/2 
52/2 
53/2 
54/2 
55/2 
56/2 
57/2 
58/2 
59/2 
60/2 
61/2 
62/2 
63/2 
64/2 
65/2 
66/2 
Ada Reference Manual — 2012 Edition 
233      13 December 2012 Formatting, Time Zones, and other operations for Time   9.6.1 function  Seconds_Of (Hour   : Hour_Number; 
                     Minute : Minute_Number;                      Second : Second_Number := 0;                      Sub_Second : Second_Duration := 0.0)     return Day_Duration; 
Returns a Day_Duration value for the combina tion of the given Hour, Minute, Second, and 
Sub_Second. This value can be used in Ca lendar.Time_Of as well as the argument to 
Calendar."+" and Calenda r."–". If Seconds_Of is called with  a Sub_Second value of 1.0, the 
value returned is equal to the value of Sec onds_Of for the next sec ond with a Sub_Second value 
of 0.0. 
procedure  Split (Seconds    : in Day_Duration; 
                 Hour       : out Hour_Number; 
                 Minute     : out Minute_Number; 
                 Second     : out Second_Number; 
                 Sub_Second : out Second_Duration); 
Splits Seconds into Hour, Minute, Second and Sub_Second in such a way that the resulting 
values all belong to their respective subtypes. The value returned in the Sub_Second parameter 
is always less than 1.0. If Seconds  = 86400.0, Split propagates Time_Error. 
function  Time_Of (Year       : Year_Number; 
                  Month      : Month_Number;                   Day        : Day_Number;                   Hour       : Hour_Number;                   Minute     : Minute_Number;                   Second     : Second_Number;                   Sub_Second : Second_Duration := 0.0;                   Leap_Second: Boolean := False;                   Time_Zone  : Time_Zones.Time_Offset := 0)                           return Time; 
If Leap_Second is False, returns a Time built fro m the date and time values, relative to the 
specified time zone offset. If Leap_Second is True , returns the Time that  represents the time 
within the leap second that is one second later than the time specified by the other parameters. 
Time_Error is raised if the parameters do not fo rm a proper date or time. If Time_Of is called 
with a Sub_Second value of 1.0, the value returned is equal to the value of Time_Of for the next 
second with a Sub_Second value of 0.0.  
function  Time_Of (Year       : Year_Number; 
                  Month      : Month_Number;                   Day        : Day_Number;                   Seconds    : Day_Duration := 0.0;                   Leap_Second: Boolean := False;                   Time_Zone  : Time_Zones.Time_Offset := 0)                           return Time; 
If Leap_Second is False, returns a Time built fro m the date and time values, relative to the 
specified time zone offset. If Leap_Second is True , returns the Time that  represents the time 
within the leap second that is one second later than the time specified by the other parameters. 
Time_Error is raised if the parameters do not fo rm a proper date or time. If Time_Of is called 
with a Seconds value of 86_400.0, the value return ed is equal to the value of Time_Of for the 
next day with a Seconds value of 0.0. 67/2 
68/2 
69/2 
70/3 
71/2 
72/2 
73/2 
74/2 
Ada Reference Manual — 2012 Edition 
9.6.1    Formatting, Time Zones, and other operations for Time 13 December 2012      234 procedure  Split (Date       : in Time; 
                 Year       : out Year_Number; 
                 Month      : out Month_Number; 
                 Day        : out Day_Number; 
                 Hour       : out Hour_Number; 
                 Minute     : out Minute_Number; 
                 Second     : out Second_Number; 
                 Sub_Second : out Second_Duration; 
                 Leap_Second: out Boolean; 
                 Time_Zone  : in Time_Zones.Time_Offset := 0); 
If Date does not represent a time within a leap s econd, splits Date into its  constituent parts (Year, 
Month, Day, Hour, Minute, Second, Sub_Second), re lative to the specified time zone offset, and 
sets Leap_Second to False. If Date represents a time within a leap s econd, set the constituent 
parts to values corresponding to a time one second ear lier than that given by Date, relative to the 
specified time zone offset, and sets Leap_S econds to True. The value returned in the 
Sub_Second parameter is al ways less than 1.0. 
procedure  Split (Date       : in Time; 
                 Year       : out Year_Number; 
                 Month      : out Month_Number; 
                 Day        : out Day_Number; 
                 Hour       : out Hour_Number; 
                 Minute     : out Minute_Number; 
                 Second     : out Second_Number; 
                 Sub_Second : out Second_Duration; 
                 Time_Zone  : in Time_Zones.Time_Offset := 0); 
Splits Date into its constituent parts (Year, M onth, Day, Hour, Minute, Second, Sub_Second), 
relative to the specified time z one offset. The value returned in the Sub_Second parameter is 
always less than 1.0. 
procedure  Split (Date       : in Time; 
                 Year       : out Year_Number; 
                 Month      : out Month_Number; 
                 Day        : out Day_Number; 
                 Seconds    : out Day_Duration; 
                 Leap_Second: out Boolean; 
                 Time_Zone  : in Time_Zones.Time_Offset := 0); 
If Date does not represent a time within a leap s econd, splits Date into its  constituent parts (Year, 
Month, Day, Seconds), relative to the specified time zone offset, and sets  Leap_Second to False. 
If Date represents a time within  a leap second, set the constitu ent parts to values corresponding 
to a time one second earlier than that given by Da te, relative to the specified time zone offset, 
and sets Leap_Seconds to True. The value returned  in the Seconds parameter is always less than 
86_400.0. 
function  Image (Date : Time; 
                Include_Time_Fraction : Boolean := False;                 Time_Zone  : Time_Zones.Time_Offset := 0) return String; 
Returns a string form of the Date relative to the given Time_Zone. The format is "Year-Month-
Day Hour:Minute:Second", where the Year is a 4-digit value, and a ll others are 2-digit values, of 
the functions defined in Calenda r and Calendar.Formatting, including a leading zero, if needed. 
The separators between the values are a minus, another minus, a colon, and a single space between the Day and Hour. If Include_Time_ Fraction is True, the integer part of 
Sub_Seconds*100 is suffixed to the string as a point followed by a 2-digit value.  75/2 
76/2 
77/2 
78/2 
79/2 
80/2 
81/2 
82/2 
Ada Reference Manual — 2012 Edition 
235      13 December 2012 Formatting, Time Zones, and other operations for Time   9.6.1 function  Value (Date : String; 
                Time_Zone  : Time_Zones.Time_Offset := 0) return Time; 
Returns a Time value for the image given as Date, relative to the given time zone. 
Constraint_Error is raised if the string is not fo rmatted as described for Image, or the function 
cannot interpret the given string as a Time value. 
function  Image (Elapsed_Time : Duration; 
                Include_Time_Fraction : Boolean := False) return String; 
Returns a string form of the Elapsed_Time. Th e format is "Hour:Mi nute:Second", where all 
values are 2-digit values, including a leading zero,  if needed. The separators between the values 
are colons. If Include_Time_Fraction is True, th e integer part of Sub_Seconds*100 is suffixed to 
the string as a point followed by a 2-digit valu e. If Elapsed_Time < 0.0, the result is Image ( abs 
Elapsed_Time, Include_Time_Fraction)  prefixed with a minus sign. If abs Elapsed_Time 
represents 100 hours or more, the re sult is implementation-defined.  
function  Value (Elapsed_Time : String) return Duration; 
Returns a Duration value for the image given as El apsed_Time. Constraint_Error is raised if the 
string is not formatted as descri bed for Image, or the function cannot interpret the given string as 
a Duration value.  
Implementation Advice 
An implementation should support leap seconds if the target system suppor ts them. If leap seconds are not 
supported, Difference should return zero for Leap_S econds, Split should return False for Leap_Second, 
and Time_Of should raise Time_E rror if Leap_Second is True.  
NOTES 
38  The implementation-defined time zone of package Calendar may, but need not, be the local time zone. UTC_Time_Offset always returns the difference relative to the implementation-defined time zone of package Calendar. If UTC_Time_Offset does not rais e Unknown_Zone_Error, UTC time can  be safely calcu lated (within the accuracy of the 
underlying time-base). 
39  Calling Split on the results of subtracting Duration(UTC_Time_Offset*60) from Clock provides the components 
(hours, minutes, and so on) of the UTC time. In the United States, for example, UTC_Time_Offset will generally be negative.  
9.7 Select Statements 
There are four forms of the select_statement . One form provides a selective wait for one or more 
select_alternative s. Two provide timed and conditional entr y calls. The fourth provides asynchronous 
transfer of control.  
Syntax 
select_statement ::=  
   selective_accept  
  | timed_entry_call  
  | conditional_entry_call  
  | asynchronous_select  83/2 
84/2 
85/2 
86/2 
87/2 
88/2 
89/2 
90/2 
91/2 
1 
2 
Ada Reference Manual — 2012 Edition 
9.7   Select Statements 13 December 2012      236 Examples 
Example of a select statement:   
select 
   accept Driver_Awake_Signal; 
or 
   delay 30.0*Seconds; 
   Stop_The_Train; end select; 
9.7.1 Selective Accept 
This form of the select_statement  allows a combination of waiting for,  and selecting from, one or more 
alternatives. The selection may depend on conditions associated with each alternative of the 
selective_accept .  
Syntax 
selective_accept ::=  
  select  
   [guard ] 
     select_alternative  
{ or 
   [guard ] 
     select_alternative  } 
[ else 
   sequence_of_statements  ] 
  end select ; 
guard ::= when  condition  => 
select_alternative ::=  
   accept_alternative  
  | delay_alternative  
  | terminate_alternative  
accept_alternative ::=  
  accept_statement  [sequence_of_statements ] 
delay_alternative ::=  
  delay_statement  [sequence_of_statements ] 
terminate_alternative ::= terminate ; 
A selective_accept  shall contain at least one accept_alternative . In addition, it can contain:  
• a terminate_alternative  (only one); or 
• one or more delay_alternative s; or 
• an else part  (the reserved word else followed by a sequence_of_statements ).  
These three possibilities are mutually exclusive.  
Legality Rules 
If a selective_accept  contains more than one delay_alternative , then all shall be delay_relative_-
statement s, or all shall be delay_until_statement s for the same time type.  
Dynamic Semantics 
A select_alternative  is said to be open  if it is not immediately preceded by a guard , or if the condition  of 
its guard  evaluates to True. It is said to be closed  otherwise. 3 
4 
1 
2 
3 
4 
5 
6 7 
8 
9 
10 11 12 
13 
14 
Ada Reference Manual — 2012 Edition 
237      13 December 2012 Selective Accept   9.7.1 For the execution of a selective_accept , any guard  condition s are evaluated; open alternatives are thus 
determined. For an open delay_alternative , the delay_ expression  is also evaluated. Similarly, for an open 
accept_alternative  for an entry of a family, the entry_index  is also evaluated. These evaluations are 
performed in an arbitrary order, except that a delay_ expression  or entry_index  is not evaluated until after 
evaluating the corresponding condition , if any. Selection and execution of one open alternative, or of the 
else part, then completes the execution of the selective_accept ; the rules for this selection are described 
below. 
Open accept_alternative s are first considered. Selection of one such alternative takes place immediately if 
the corresponding entry already has queued calls. If several alternatives can thus be selected, one of them 
is selected according to the entry queuing policy in eff ect (see 9.5.3 and D.4). When such an alternative is 
selected, the selected call is removed from its entry queue and the handled_sequence_of_statements  (if 
any) of the corresponding accept_statement  is executed; after the rendez vous completes any subsequent 
sequence_of_statements  of the alternative is executed. If no selection is immediately possible (in the 
above sense) and there is no else part, the task blocks until an open alternative can be selected. 
Selection of the other forms of alternative or of an else part is performed as follows:  
• An open delay_alternative  is selected when its expiration time is reached if no accept_-
alternative  or other delay_alternative  can be selected prior to the expiration time. If several 
delay_alternative s have this same expiration time, one of them is selected according to the 
queuing policy in effect (see D.4); the defau lt queuing policy chooses arbitrarily among the 
delay_alternative s whose expiration time has passed. 
• The else part is selected and its sequence_of_statements  is executed if no accept_alternative  
can immediately be selected; in particular, if all alternatives are closed. 
• An open terminate_alternative  is selected if the conditions stated at the end of subclause 9.3 are 
satisfied.  
The exception Program_Error is raised if all altern atives are closed and there is no else part. 
NOTES 
40  A selective_accept  is allowed to have several open delay_alternative s. A selective_accept  is allowed to have several 
open accept_alternative s for the same entry. 
Examples 
Example of a task body with a selective accept:   
task body Server is 
   Current_Work_Item : Work_Item; begin 
   loop 
      select 
         accept Next_Work_Item(WI : in Work_Item) do 
            Current_Work_Item := WI;          end; 
         Process_Work_Item(Current_Work_Item);       or 
         accept Shut_Down; 
         exit;       --  Premature shut down requested  
      or 
         terminate ;  --  Normal shutdown at end of scope  
      end select; 
   end loop; 
end Server; 15 
16 
17 
18 
19 
20/3 
21 
22 
23 
24 
Ada Reference Manual — 2012 Edition 
9.7.2    Timed Entry Calls 13 December 2012      238 9.7.2 Timed Entry Calls 
A timed_entry_call  issues an entry call that is cancelled if th e call (or a requeue-with-abort of the call) is 
not selected before the expiration time is reached. A procedure call may appear rather than an entry call 
for cases where the procedure might be implemented by an entry.  
Syntax 
timed_entry_call ::=  
  select  
   entry_call_alternative  
  or 
   delay_alternative  
  end select ; 
entry_call_alternative ::=  
  procedure_or_entry_call  [sequence_of_statements ] 
procedure_or_entry_call ::=  
  procedure_call_statement  | entry_call_statement  
Legality Rules 
If a procedure_call_statement  is used for a procedure_or_entry_call , the procedure_ name  or 
procedure_ prefix  of the procedure_call_statement  shall statically denote an entry renamed as a procedure 
or (a view of) a primitive subprogram of a limite d interface whose first parameter is a controlling 
parameter (see 3.9.2).  
Dynamic Semantics 
For the execution of a timed_entry_call , the entry_ name , procedure_ name , or procedure_ prefix , and any 
actual parameters are evaluated, as for a simple entry call (see 9.5.3) or procedure call (see 6.4). The expiration time (see 9.6) for the call is determined by evaluating the delay_
expression  of the 
delay_alternative . If the call is an entry call or a call on a pr ocedure implemented by an entry, the entry 
call is then issued. Otherwise, the call proceeds as de scribed in 6.4 for a procedure call, followed by the 
sequence_of_statements  of the entry_call_alternative ; the sequence_of_statements  of the delay_-
alternative  is ignored. 
If the call is queued (including due to a requeue-with-abor t), and not selected before the expiration time is 
reached, an attempt to cancel the call is made. If th e call completes due to the cancellation, the optional 
sequence_of_statements  of the delay_alternative  is executed; if the entry call completes normally, the 
optional sequence_of_statements  of the entry_call_alternative  is executed.  
Examples 
Example of a timed entry call:   
select 
   Controller.Request(Medium)(Some_Item); or 
   delay 45.0; 
   --   controller too busy, try something else  
end select; 1/2 
2 
3/2 
3.1/2 
3.2/2 
4/2 
5 
6 
7 
Ada Reference Manual — 2012 Edition 
239      13 December 2012 Conditional Entry Calls   9.7.3 9.7.3 Conditional Entry Calls 
A conditional_entry_call  issues an entry call that is then cancelled if it is not selected immediately (or if a 
requeue-with-abort of the call is not selected immediat ely). A procedure call may appear rather than an 
entry call for cases where the procedure might be implemented by an entry.  
Syntax 
conditional_entry_call ::=  
  select  
   entry_call_alternative  
  else 
   sequence_of_statements  
  end select ; 
Dynamic Semantics 
The execution of a conditional_entry_call  is defined to be equivalent to the execution of a timed_entry_-
call with a delay_alternative  specifying an immediate expiration time and the same sequence_of_-
statements  as given after the reserved word else.  
NOTES 
41  A conditional_entry_call  may briefly increase the Count attribute of the entry, even if the conditional call is not 
selected. 
Examples 
Example of a conditional entry call:   
procedure  Spin(R : in Resource) is 
begin 
   loop 
      select 
         R.Seize;          return; 
      else 
         null;  --   busy waiting  
      end select; 
   end loop; 
end; 
9.7.4 Asynchronous Transfer of Control 
An asynchronous select_statement  provides asynchronous transfer of control upon completion of an entry 
call or the expiration of a delay.  
Syntax 
asynchronous_select ::=  
  select  
   triggering_alternative  
  then abort  
   abortable_part  
  end select ; 
triggering_alternative ::=  triggering_statement  [sequence_of_statements ] 
triggering_statement ::= procedure_or_entry_call  | delay_statement  
abortable_part ::= sequence_of_statements  1/2 
2 
3 
4 
5 
6 
1 
2 
3 
4/2 
5 
Ada Reference Manual — 2012 Edition 
9.7.4    Asynchronous Transfer of C ontrol 13 December 2012      240 Dynamic Semantics 
For the execution of an asynchronous_select  whose triggering_statement  is a procedure_or_entry_call , 
the entry_ name , procedure_ name , or procedure_ prefix , and actual parameters are evaluated as for a 
simple entry call (see 9.5.3) or procedure call (see 6.4) . If the call is an entry call or a call on a procedure 
implemented by an entry, the entry call is issued. If the entry call is queued (or requeued-with-abort), then 
the abortable_part  is executed. If the entry call is selected immediately, and neve r requeued-with-abort, 
then the abortable_part  is never started. If the call is on a proce dure that is not implemented by an entry, 
the call proceeds as described in 6.4, followed by the sequence_of_statements  of the triggering_-
alternative ; the abortable_part  is never started. 
For the execution of an asynchronous_select  whose triggering_statement  is a delay_statement , the 
delay_ expression  is evaluated and the expiration time is determined, as for a normal delay_statement . If 
the expiration time has not already passed, the abortable_part  is executed. 
If the abortable_part  completes and is left prior to completion of the triggering_statement , an attempt to 
cancel the triggering_statement  is made. If the attempt to cancel succeeds (see 9.5.3 and 9.6), the 
asynchronous_select  is complete. 
If the triggering_statement  completes other than due to cancellation, the abortable_part  is aborted (if 
started but not yet completed — see 9.8). If the triggering_statement  completes normally, the optional 
sequence_of_statements  of the triggering_alternative  is executed after the abortable_part  is left.  
Examples 
Example of a main command loop for a command interpreter:   
loop 
   select 
      Terminal.Wait_For_Interrupt;       Put_Line("Interrupted");    then abort  
      -- This will be abandoned upon terminal interrupt  
      Put_Line("-> ");       Get_Line(Command, Last);       Process_Command(Command(1..Last));    end select; 
end loop; 
Example of a time-limited calculation:   
select 
   delay 5.0; 
   Put_Line("Calculation does not converge"); then abort  
   -- This calculation should finish in 5.0 seconds;  
   --  if not, it is assumed to diverge.  
   Horribly_Complicated_Recursive_Function(X, Y); end select; 
9.8 Abort of a Task - Abort of a Sequence of Statements 
An abort_statement  causes one or more tasks to become abnorma l, thus preventing any further interaction 
with such tasks. The completion of the triggering_statement  of an asynchronous_select  causes a 
sequence_of_statements  to be aborted.  
Syntax 
abort_statement ::= abort  task_ name  {, task_ name }; 6/2 
7 
8 
9 
10 
11 
12 
13 
1 
2 
Ada Reference Manual — 2012 Edition 
241      13 December 2012 Abort of a Task - Abort of a Sequence of Statements   9.8 Name Resolution Rules 
Each task_ name  is expected to be of any task type; they  need not all be of the same task type. 
Dynamic Semantics 
For the execution of an abort_statement , the given task_ name s are evaluated in an arbitrary order. Each 
named task is then aborted , which consists of making the task abnormal  and aborting the execution of the 
corresponding task_body , unless it is already completed.  
When the execution of a construct is aborted  (including that of a task_body  or of a sequence_of_-
statements ), the execution of every construct included within  the aborted execution is also aborted, except 
for executions included within the execution of an abort-deferred  operation; the execution of an abort-
deferred operation continues to comp letion without being affected by the abort; the following are the 
abort-deferred operations:  
• a protected action; 
• waiting for an entry call to complete (after having initiated the attempt to cancel it — see 
below); 
• waiting for the termination of dependent tasks; 
• the execution of an Initialize procedure as the last  step of the default initialization of a controlled 
object; 
• the execution of a Finalize procedure as part of the finalization of a controlled object; 
• an assignment operation to an object with a controlled part.  
The last three of these are discussed further in 7.6.  
When a master is aborted, all tasks th at depend on that master are aborted. 
The order in which tasks become abnormal as the result of an abort_statement  or the abort of a 
sequence_of_statements  is not specified by the language. 
If the execution of an entry call is aborted, an imme diate attempt is made to cancel the entry call (see 
9.5.3). If the execution of a construct is aborted at a time when the execution is blocked, other than for an 
entry call, at a point that is outside the execution of  an abort-deferred operation, then the execution of the 
construct completes immediately. For an abort due to an abort_statement , these immediate effects occur 
before the execution of the abort_statement  completes. Other than for these immediate cases, the 
execution of a construct that is aborted does not necessarily complete before the abort_statement  
completes. However, the execution of the aborte d construct completes no later than its next abort 
completion point  (if any) that occurs outside of an a bort-deferred operation; the following are abort 
completion points for an execution:  
• the point where the execution initiates the activation of another task; 
• the end of the activation of a task; 
• the start or end of the execution of an entry call, accept_statement , delay_statement , or 
abort_statement ;  
• the start of the execution of a select_statement , or of the sequence_of_statements  of an 
exception_handler .  
Bounded (Run-Time) Errors 
An attempt to execute an asynchronous_select  as part of the execution of an abort-deferred operation is a 
bounded error. Similarly, an attempt to create a task that depends on a master that is included entirely 3 
4 
5 
6 
7 
8 
9 
10 
11 12 
13 14 
15 
16 
17 18 
19 
20/3 
Ada Reference Manual — 2012 Edition 
9.8   Abort of a Task - Abort of a Sequen ce of Statements 13 December 2012      242 within the execution of an abort-deferred operation is a bounded error. In both cases, Program_Error is 
raised if the error is detected by the implementati on; otherwise, the operations proceed as they would 
outside an abort-deferred operation, except that an abort of the abortable_part  or the created task might or 
might not have an effect.  
Erroneous Execution 
If an assignment operation completes prematurely due to an abort, the assignment is said to be disrupted ; 
the target of the assignment or its parts can become abnormal, and certain subsequent uses of the object 
can be erroneous, as explained in 13.9.1.  
NOTES 
42  An abort_statement  should be used only in situations requiring unconditional termination. 
43  A task is allowed to abort any task it can name, including itself. 44  Additional requirements associated with abort are given in D.6, “Preemptive Abort”.  
9.9 Task and Entry Attributes 
Dynamic Semantics 
For a prefix  T that is of a task type (after any implicit de reference), the following attributes are defined:  
T'Callable Yields the value True when the task denoted by T is callable , and False otherwise; a task is 
callable unless it is completed or abnormal. The va lue of this attribute is of the predefined 
type Boolean. 
T'Terminated Yields the value True if the task denoted  by T is terminated, and False otherwise. The value 
of this attribute is of th e predefined type Boolean.  
For a prefix  E that denotes an entry of a task or protected  unit, the following attribute is defined. This 
attribute is only allowed within the body of the task or  protected unit, but excluding,  in the case of an entry 
of a task unit, within any progr am unit that is, itself, inner to  the body of the task unit.  
E'Count Yields the number of calls presently queue d on the entry E of the current instance of the 
unit. The value of this a ttribute is of the type universal_integer . 
NOTES 
45  For the Count attribute, the entry can be either a single entry or an entry of a family. The name of the entry or entry family can be either a 
direct_name  or an expanded name. 
46  Within task units, algorithms interrogating the attribute E'Count should take precautions to allow for the increase of 
the value of this attribute for incoming entry calls, and its decrease, for example with timed_entry_call s. Also, a 
conditional_entry_call  may briefly increase this value, even if the conditional call is not accepted. 
47  Within protected units, algorithms interrogating the attribute E'Count in the entry_barrier  for the entry E should take 
precautions to allow for the evaluation of the condition  of the barrier both before and after queuing a given caller.  
9.10 Shared Variables 
Static Semantics 
If two different objects, including nonoverl apping parts of the same object, are independently addressable , 
they can be manipulated concurrently by two different tasks without synchronization. Any two 
nonoverlapping objects are independently  addressable if either object is specified as independently 
addressable (see C.6). Otherwise,  two nonoverlapping objects are indepe ndently addressable except when 
they are both parts of a composite object for whic h a nonconfirming value is specified for any of the 21 
22 
23 24 
1 
2 
3 
4 
5 
6 
7 
8 
1/3 
Ada Reference Manual — 2012 Edition 
243      13 December 2012 Shared Variables   9.10 following representation aspects: (record) Layout, Com ponent_Size, Pack, Atomic, or Convention; in this 
case it is unspecified whether the parts are independently addressable.  
Dynamic Semantics 
Separate tasks normally proceed independently and concurrently with one a nother. However, task 
interactions can be used to synchronize the actions of two or more tasks to allow, for example, meaningful 
communication by the direct updating and reading of va riables shared between the tasks. The actions of 
two different tasks are synchronized in th is sense when an action of one task signals  an action of the other 
task; an action A1 is defined to signal an  action A2 under the following circumstances:  
• If A1 and A2 are part of the execution of the sa me task, and the language rules require A1 to be 
performed before A2; 
• If A1 is the action of an activator that initiates the activation of a task, and A2 is part of the 
execution of the task that is activated; 
• If A1 is part of the activation of a task, and A2 is the action of waiting for completion of the 
activation; 
• If A1 is part of the execution of a task, and A2 is the action of waiting for the termination of the 
task; 
• If A1 is the termination of a task T, and A2 is either an evaluation of the expression 
T'Terminated that results in True, or a call to  Ada.Task_Identification.Is_Terminated with an 
actual parameter that identifies T and a result of True (see C.7.1); 
• If A1 is the action of issuing an entry call, a nd A2 is part of the corresponding execution of the 
appropriate entry_body  or accept_statement ;  
• If A1 is part of the execution of an accept_statement  or entry_body , and A2 is the action of 
returning from the corresponding entry call; 
• If A1 is part of the execution of a protected procedure body or entry_body  for a given protected 
object, and A2 is part of a later execution of an entry_body  for the same protected object;  
• If A1 signals some action that in turn signals A2.  
Erroneous Execution 
Given an action of assigning to an object, and an action of reading or updating a part of the same object (or 
of a neighboring object if the two are not independently  addressable), then the execution of the actions is 
erroneous unless the actions are sequential . Two actions are sequential if one of the following is true:  
• One action signals the other; 
• Both actions occur as part of the execution of the same task;  
• Both actions occur as part of protected actions  on the same protected object, and at most one of 
the actions is part of a call on a prot ected function of the protected object.  
Aspect Atomic or aspect Atomic_C omponents may also be specified to  ensure that certain reads and 
updates are sequential — see C.6.  2 
3 
4 5 6 
6.1/3 
7/3 
8 9 
10 
11 
12 
13 14 
15/3 
Ada Reference Manual — 2012 Edition 
9.11    Example of Tasking and Sync hronization 13 December 2012      244 9.11 Example of Tasking and Synchronization 
Examples 
The following example defines a buffer protected object to smooth variations between the speed of output 
of a producing task and the speed of input of some consuming task. For instance, the producing task might 
have the following structure: 
task Producer; 
task body  Producer is 
   Person : Person_Name; --  see 3.10.1 
begin 
   loop 
      ... --   simulate arrival of the next customer  
      Buffer.Append_Wait(Person);       exit when Person = null; 
   end loop; 
end Producer; 
and the consuming task might have the following structure: 
task Consumer; 
task body  Consumer is 
   Person : Person_Name; begin 
   loop 
      Buffer.Remove_First_Wait(Person);       exit when Person = null; 
      ... --   simulate serving a customer  
   end loop; 
end Consumer; 
The buffer object contains an internal array of pers on names managed in a round -robin fashion. The array 
has two indices, an In_Index denoting the index for th e next input person name and an Out_Index denoting 
the index for the next output person name. 
The Buffer is defined as an extension of the Sy nchronized_Queue interface (see 3.9.4), and as such 
promises to implement the abstraction defined by that interface. By doing so, the Buffer can be passed to the Transfer class-wide operation defined for objects of a type covered by Queue'Class. 
protected  Buffer is new Synchronized_Queue with  --  see 3.9.4 
   entry Append_Wait(Person : in Person_Name); 
   entry Remove_First_Wait(Person : out Person_Name); 
   function  Cur_Count return Natural; 
   function  Max_Count return Natural; 
   procedure  Append(Person : in Person_Name); 
   procedure  Remove_First(Person : out Person_Name); 
private 
   Pool      : Person_Name_Array(1 .. 100);    Count     : Natural := 0;    In_Index, Out_Index : Positive := 1; end Buffer; 
protected body  Buffer is 
   entry Append_Wait(Person : in Person_Name) 
      when Count < Pool'Length is 
   begin 
      Append(Person);    end Append_Wait; 1 
2 
3/2 
4 
5 
6/2 
7/2 
7.1/2 
8/2 
9/2 
Ada Reference Manual — 2012 Edition 
245      13 December 2012 Example of  Tasking and Synchronization   9.11    procedure  Append(Person : in Person_Name) is 
   begin 
      if Count = Pool'Length then 
         raise Queue_Error with "Buffer Full";  --  see 11.3 
      end if; 
      Pool(In_Index) := Person;       In_Index       := (In_Index mod Pool'Length) + 1; 
      Count          := Count + 1;    end Append; 
   entry Remove_First_Wait(Person : out Person_Name) 
      when Count > 0 is 
   begin 
      Remove_First(Person);    end Remove_First_Wait; 
   procedure  Remove_First(Person : out Person_Name) is 
   begin 
      if Count = 0 then 
         raise Queue_Error with "Buffer Empty"; --  see 11.3 
      end if; 
      Person    := Pool(Out_Index);       Out_Index := (Out_Index mod Pool'Length) + 1; 
      Count     := Count - 1;    end Remove_First; 
   function  Cur_Count return Natural is 
   begin 
       return Buffer.Count; 
   end Cur_Count; 
   function  Max_Count return Natural is 
   begin 
       return Pool'Length; 
   end Max_Count; 
end Buffer; 9.1/2 
10/2 
11/2 
12/2 
13/2 

Ada Reference Manual — 2012 Edition 
247      13 December 2012 Program St ructure and Compilation Issues   10 10   Program Structure and Compilation Issues 
The overall structure of programs and the facilities for se parate compilation are described in this clause. A 
program  is a set of partitions , each of which may execute in a separate address space, possibly on a 
separate computer.  
As explained below, a partition is constructed from library units . Syntactically, the declaration of a library 
unit is a library_item , as is the body of a library unit. An implementation may support a concept of a 
program library  (or simply, a “library”), which contains library_item s and their subunits. Library units 
may be organized into a hierarchy of children, grandchildren, and so on. 
This clause has two subclauses: 10. 1, “Separate Compilation” discusse s compile-time issues related to 
separate compilation. 10.2, “Program  Execution” discusses issues relate d to what is traditionally known as 
“link time” and “run time” — building and executing partitions. 
10.1 Separate Compilation 
A program unit  is either a package, a task unit, a protected unit, a protected entry, a generic unit, or an 
explicitly declared subprogram other than an enumera tion literal. Certain kinds of program units can be 
separately compiled. Alternatively, they can app ear physically nested within other program units. 
The text of a program can be submitted to the compiler in one or more compilation s. Each compilation  is a 
succession of compilation_unit s. A compilation_unit  contains either the declaration, the body, or a 
renaming of a program unit. The representation for a compilation  is implementation-defined.  
A library unit is a separately compiled program unit, a nd is always a package, s ubprogram, or generic unit. 
Library units may have other (logically nested) library units as children, and may have other program units 
physically nested within them. A root library unit, t ogether with its children and grandchildren and so on, 
form a subsystem . 
Implementation Permissions 
An implementation may impose implem entation-defined restrictions on compilation s that contain multiple 
compilation_unit s.  
10.1.1 Compilation Units - Library Units 
A library_item  is a compilation unit that is the declarati on, body, or renaming of a library unit. Each 
library unit (except Standard) has a parent unit , which is a library package or generic library package. A 
library unit is a child  of its parent unit. The root library units are the children of the predefined library 
package Standard.  
Syntax 
compilation ::= {compilation_unit } 
compilation_unit ::=  
    context_clause  library_item  
  | context_clause  subunit  
library_item ::= [private ] library_unit_declaration  
  | library_unit_body  
  | [private ] library_unit_renaming_declaration  1/3 
2 
3/3 
1 
2 
3 
4 
1 
2 
3 
4 
Ada Reference Manual — 2012 Edition 
10.1.1    Compilation Units - Library Units 13 December 2012      248 library_unit_declaration ::=  
     subprogram_declaration  | package_declaration  
   | generic_declaration  | generic_instantiation  
library_unit_renaming_declaration ::=  
   package_renaming_declaration  
 | generic_renaming_declaration  
 | subprogram_renaming_declaration  
library_unit_body ::= subprogram_body  | package_body  
parent_unit_name ::= name  
An overriding_indicator  is not allowed in a subprogram_declaration , generic_instantiation , or 
subprogram_renaming_declaration  that declares a library unit. 
A library unit  is a program unit that is declared by a library_item . When a program unit is a library unit, 
the prefix “library” is used to refer to it (or “generic  library” if generic), as well as to its declaration and 
body, as in “library procedure”, “library package_body ”, or “generic library package”. The term 
compilation unit  is used to refer to a compilation_unit . When the meaning is clear from context, the term is 
also used to refer to the library_item  of a compilation_unit  or to the proper_body  of a subunit  (that is, the 
compilation_unit  without the context_clause  and the separate  (parent_unit_name )).  
The parent declaration  of a library_item  (and of the library unit) is the declaration denoted by the parent_-
unit_name , if any, of the defining_program_unit_name  of the library_item . If there is no parent_-
unit_name , the parent declaration is the declaration of Standard, the library_item  is a root library_item , 
and the library unit (renaming) is a root library unit (renaming). The declaration and body of Standard 
itself have no parent declaration. The parent unit  of a library_item  or library unit is the library unit 
declared by its parent declaration.  
The children of a library unit occur immediately within  the declarative region of the declaration of the 
library unit. The ancestors  of a library unit are itself, its parent, its  parent's parent, and so on. (Standard is 
an ancestor of every library unit.) The descendant  relation is the inverse of the ancestor relation.  
A library_unit_declaration  or a library_unit_renaming_declaration  is private  if the declaration is 
immediately preceded by the reserved word private ; it is otherwise public . A library unit is private or 
public according to its declaration. The public descendants  of a library unit are the library unit itself, and 
the public descendants of its public children. Its other descendants are private descendants .  
For each library package_declaration  in the environment, there is an implicit declaration of a limited view  
of that library package. The lim ited view of a package contains: 
• For each package_declaration  occurring immediately within the visible part, a declaration of 
the limited view of that package, with the same defining_program_unit_name . 
• For each type_declaration  occurring immediately within the visible part that is not an 
incomplete_type_declaration , an incomplete view of the type with no discriminant_part ; if the 
type_declaration  is tagged, then the view is  a tagged incomplete view.  
The limited view of a library package_declaration  is private if that library package_declaration  is 
immediately preceded by the reserved word private . 
There is no syntax for declaring limited views of pack ages, because they are always implicit. The implicit 
declaration of a limited view of a library package is  not the declaration of a library unit (the library 
package_declaration  is); nonetheless, it is a library_item . The implicit declaration of the limited view of a 
library package forms an (implicit) compilation unit whose context_clause  is empty. 
A library package_declaration  is the completion of the d eclaration of its limited view. 5 
6 
7 
8 
8.1/2 
9 
10 
11 
12 
12.1/2 
12.2/3 
12.3/3 
12.4/2 
12.5/2 
12.6/2 
Ada Reference Manual — 2012 Edition 
249      13 December 2012 Compilation Units - Library Units   10.1.1 Legality Rules 
The parent unit of a library_item  shall be a library package or generic library package. 
If a defining_program_unit_name  of a given declaration or body has a parent_unit_name , then the given 
declaration or body shall be a library_item . The body of a program unit shall be a library_item  if and only 
if the declaration of the program unit is a library_item . In a library_unit_renaming_declaration , the (old) 
name  shall denote a library_item .  
A parent_unit_name  (which can be used within a defining_program_unit_name  of a library_item  and in 
the separate  clause of a subunit ), and each of its prefix es, shall not denote a renaming_declaration . On 
the other hand, a name that denotes a library_unit_renaming_declaration  is allowed in a 
nonlimited_with_clause  and other places where the name of a library unit is allowed. 
If a library package is an instance of a generic package,  then every child of the lib rary package shall either 
be itself an instance or be a renaming of a library unit.  
A child of a generic library package shall either be itself a generic unit or be a renaming of some other 
child of the same generic unit. 
A child of a parent generic package shall be instantia ted or renamed only within the declarative region of 
the parent generic. 
For each child C of some parent generic package P, there is a corresponding declaration C nested 
immediately within each instance of P. For the purposes of this rule, if a child C itself has a child D, each 
corresponding declaration for C has a corresponding child D. The corresponding declaration for a child 
within an instance is visible only within the scope of a with_clause  that mentions the (original) child 
generic unit. 
A library subprogram shall not override a primitive subprogram.  The defining name of a function that is a compilation unit shall not be an 
operator_symbol .  
Static Semantics 
A subprogram_renaming_declaration  that is a library_unit_renaming_declaration  is a renaming-as-
declaration, not a renaming-as-body. 
There are two kinds of depende nces among compilation units:  
• The semantic dependences  (see below) are the ones needed to check the compile-time rules 
across compilation unit boundaries; a compilation unit depends semantically on the other 
compilation units needed to determine its legality . The visibility rules are based on the semantic 
dependences. 
• The elaboration dependences  (see 10.2) determine the order of elaboration of library_item s.  
A library_item  depends semantically upon its parent declar ation. A subunit depends semantically upon its 
parent body. A library_unit_body  depends semantically upon the corresponding library_unit_declaration , 
if any. The declaration of the limited view of a lib rary package depends semantically upon the declaration 
of the limited view of its parent. The declaration of a library package depends semantically upon the 
declaration of its limited view. A compilation unit depends semantically upon each library_item  mentioned 
in a with_clause  of the compilation unit. In addition, if a given compilation unit contains an 
attribute_reference  of a type defined in another compilation unit, then the given compilation unit depends 
semantically upon the other compilation unit. The se mantic dependence relationship is transitive. 13 
14 
15/2 
16 
17/3 
18 
19/2 
20 
21 
22 
23 
24 
25 
26/2 
Ada Reference Manual — 2012 Edition 
10.1.1    Compilation Units - Library Units 13 December 2012      250 Dynamic Semantics 
The elaboration of the declaration of the limited view of a package has no effect.  
NOTES 
1  A simple program may consist of a single compilation unit. A compilation  need not have any compilation units; for 
example, its text can consist of pragma s.  
2  The designator  of a library function cannot be an operator_symbol , but a nonlibrary renaming_declaration  is allowed 
to rename a library function as an operator. Within a partition, two library subprograms are required to have distinct names and hence ca nnot overload each other. However, 
renaming_declaration s are allowed to define overloaded names 
for such subprograms, and a locally declared subprogram is allowed to overload a library subprogram. The expanded name Standard.L can be used to denote a root library unit L (unless the declaration of Standard is hidden) since root library unit declarations occur immediately within the declarative region of package Standard.  
Examples 
Examples of library units:   
package Rational_Numbers.IO is  --  public child of Rational_Numbers, see 7.1  
   procedure  Put(R : in  Rational); 
   procedure  Get(R : out Rational); 
end Rational_Numbers.IO; 
private procedure  Rational_Numbers.Reduce(R : in out Rational); 
                                --  private child of Rational_Numbers  
with Rational_Numbers.Reduce;   --  refer to a private child  
package body  Rational_Numbers is 
   ... end Rational_Numbers; 
with Rational_Numbers.IO; use Rational_Numbers; 
with Ada.Text_io;               --  see A.10 
procedure  Main is               --  a root library procedure  
   R : Rational; begin 
   R := 5/3;                    --  construct a rational number, see 7.1  
   Ada.Text_IO.Put("The answer is: ");    IO.Put(R);    Ada.Text_IO.New_Line; end Main; 
with Rational_Numbers.IO; 
package Rational_IO renames Rational_Numbers.IO; 
                                --  a library unit renaming declaration  
Each of the above library_item s can be submitted to the compiler separately.  
10.1.2 Context Clauses - With Clauses 
A context_clause  is used to specify the library_item s whose names are needed within a compilation unit.  
Syntax 
context_clause ::= {context_item } 
context_item ::= with_clause  | use_clause  
with_clause ::= limited_with_clause  | nonlimited_with_clause  
limited_with_clause ::= limited  [private ] with  library_unit_ name  {, library_unit_ name }; 
nonlimited_with_clause ::= [private ] with  library_unit_ name  {, library_unit_ name }; 26.1/2 
27 
28 
29 
30 
31 
32 
33 
34 
35 
1 
2 
3 
4/2 
4.1/2 4.2/2 
Ada Reference Manual — 2012 Edition 
251      13 December 2012 Context Clauses - With Clauses   10.1.2 Name Resolution Rules 
The scope  of a with_clause  that appears on a library_unit_declaration  or library_unit_renaming_-
declaration  consists of the entire declarative region of the declaration, which includes all children and 
subunits. The scope of a with_clause  that appears on a body consists of the body, which includes all 
subunits.  
A library_item  (and the corresponding library unit) is named  in a with_clause  if it is denoted by a 
library_unit_ name  in the with_clause . A library_item  (and the corresponding library unit) is mentioned  in 
a with_clause  if it is named in the with_clause  or if it is denoted by a prefix  in the with_clause . 
Outside its own declarative region, the declaration or renaming of a library unit can be visible only within 
the scope of a with_clause  that mentions it. The visibility of the declaration or renaming of a library unit 
otherwise follows from its placement in the environment.  
Legality Rules 
If a with_clause  of a given compilation_unit  mentions a private child of some library unit, then the given 
compilation_unit  shall be one of:  
• the declaration, body, or subunit of a pr ivate descendant of that library unit; 
• the body or subunit of a public descendant of th at library unit, but not a subprogram body acting 
as a subprogram declar ation (see 10.1.4); or 
• the declaration of a public descendant of that library unit, in which case the with_clause  shall 
include the reserved word private .  
A name  denoting a library_item  (or the corresponding declaration for a child of a generic within an 
instance — see 10.1.1), if it is visible only due to being mentioned in one or more with_clause s that 
include the reserved word private , shall appear only within:  
• a private part; 
• a body, but not within the subprogram_specification  of a library subprogram body; 
• a private descendant of the unit on which one of these with_clause s appear; or 
• a pragma within a context clause.  
A library_item  mentioned in a limited_with_clause  shall be the implicit declaration of the limited view of 
a library package, not the declaration of a subprogr am, generic unit, generic instance, or a renaming. 
A limited_with_clause  shall not appear on a library_unit_body , subunit , or library_unit_renaming_-
declaration . 
A limited_with_clause  that names a library package shall not appear: 
• in the context_clause  for the explicit declaration of the named library package or any of its 
descendants; 
• within a context_clause  for a library_item  that is within the scope of a nonlimited_with_clause  
that mentions the same library package; or 
• within a context_clause  for a library_item  that is within the scope of a use_clause  that names 
an entity declared within  the declarative region of the library package. 
NOTES 
3  A library_item  mentioned in a nonlimited_with_clause  of a compilation unit is visible within the compilation unit and 
hence acts just like an ordinary declaration. Thus, within a compilation unit that mentions its declaration, the name of a library package can be given in 
use_clause s and can be used to form expanded names, a library subprogram can be 
called, and instances of a generic library unit can be declared. If a child of a parent generic package is mentioned in a 5 
6/2 
7 
8/2 
9/2 
10/2 
11/2 12/3 
13/2 
14/2 15/2 16/2 17/2 
18/2 19/2 
20/3 
21/3 22/3 
23/2 
Ada Reference Manual — 2012 Edition 
10.1.2    Context Clauses - With Clauses 13 December 2012      252 nonlimited_with_clause , then the corresponding declaration nested within each visible instance is visible within the 
compilation unit. Similarly, a library_item  mentioned in a limited_with_clause  of a compilation unit is visible within the 
compilation unit and thus can be used to form expanded names. 
Examples 
package Office is 
end Office; 
with Ada.Strings.Unbounded; 
package Office.Locations is 
   type Location is new Ada.Strings.Unbounded.Unbounded_String; 
end Office.Locations; 
limited with  Office.Departments;  --  types are incomplete  
private with  Office.Locations;    --  only visible in private part  
package Office.Employees is 
   type Employee is private ; 
   function  Dept_Of(Emp : Employee) return access  Departments.Department; 
   procedure  Assign_Dept(Emp  : in out Employee; 
                         Dept : access Departments.Department); 
   ... 
private    type Employee is 
      record  
         Dept : access Departments.Department; 
         Loc : Locations.Location;          ...       end record ; 
end Office.Employees; 
limited with  Office.Employees; 
package Office.Departments is 
   type Department is private ; 
   function  Manager_Of(Dept : Department) return access  Employees.Employee; 
   procedure  Assign_Manager(Dept : in out Department; 
                            Mgr  : access Employees.Employee); 
   ... end Office.Departments; 
The limited_with_clause  may be used to support mutually dependent abstractions that are split across 
multiple packages. In this case, an employee is assigned to a depa rtment, and a department has a manager 
who is an employee. If a with_clause  with the reserved word private  appears on one library unit and 
mentions a second library unit, it provides visibility to th e second library unit, but restricts that visibility to 
the private part and body of the first unit. The comp iler checks that no use is made of the second unit in 
the visible part of the first unit. 
10.1.3 Subunits of Compilation Units 
Subunits are like child units , with these (important) differences: subunits support the separate compilation 
of bodies only (not declarations); the parent contains a body_stub  to indicate the existence and place of 
each of its subunits; declar ations appearing in the parent's body can be visible within the subunits.  
Syntax 
body_stub ::= 
subprogram_body_stub  | package_body_stub  | task_body_stub  | protected_body_stub  
subprogram_body_stub ::=  
   [overriding_indicator ] 
   subprogram_specification  is separate  
      [aspect_specification ]; 24/2 
25/2 
26/2 
27/2 
28/2 
29/2 
30/2 
31/2 
1 
2 
3/3 
Ada Reference Manual — 2012 Edition 
253      13 December 2012 Subunits of Compilation Units   10.1.3 package_body_stub ::=  
   package  body  defining_identifier  is separate  
      [aspect_specification ]; 
task_body_stub ::=  
   task body  defining_identifier  is separate  
      [aspect_specification ]; 
protected_body_stub ::=  
   protected  body  defining_identifier  is separate  
      [aspect_specification ]; 
subunit ::= separate  (parent_unit_name ) proper_body  
Legality Rules 
The parent body  of a subunit is the body of th e program unit denoted by its parent_unit_name .  The term 
subunit  is used to refer to a subunit  and also to the proper_body  of a subunit . The subunits of a program 
unit include any subunit that names that program unit as its parent, as well as any subunit that names such 
a subunit as its pare nt (recursively).  
The parent body of a subunit shall be present in the current environment, and shall contain a corresponding 
body_stub  with the same defining_identifier  as the subunit.  
A package_body_stub  shall be the completion of a package_declaration  or generic_package_-
declaration ; a task_body_stub  shall be the completion of a task declaration; a protected_body_stub  shall 
be the completion of a protected declaration. 
In contrast, a subprogram_body_stub  need not be the completion of a previous declaration, in which case 
the _stub  declares the subprogram. If the _stub  is a completion, it shall be the completion of a 
subprogram_declaration  or generic_subprogram_declaration . The profile of a subprogram_body_stub  
that completes a declaration shall confor m fully to that of the declaration.  
A subunit that corresponds to a body_stub  shall be of the same kind ( package_ , subprogram_ , task_ , or 
protected_ ) as the body_stub . The profile of a subprogram_body  subunit shall be fully conformant to that 
of the corresponding body_stub .  
A body_stub  shall appear immediately within the declarative_part  of a compilation unit body. This rule 
does not apply within an instance of a generic unit.  
The defining_identifier s of all body_stub s that appear immediately within a particular declarative_part  
shall be distinct.  
Post-Compilation Rules 
For each body_stub , there shall be a subunit containing the corresponding proper_body .  
NOTES 
4  The rules in 10.1.4, “The Compilation Process” say that a body_stub  is equivalent to the corresponding proper_body . 
This implies:  
• Visibility within a subunit is th e visibility that would be obtaine d at the place of the corresponding body_stub  
(within the parent body) if the context_clause  of the subunit were appended to that of the parent body.  
• The effect of the elaboration of a body_stub  is to elaborate the subunit.  4 
5 
6 
7 
8/2 
9 
10/3 
11 
12 
13 
14 
15 
16 
17 
18 
Ada Reference Manual — 2012 Edition 
10.1.3    Subunits of Compilation Units 13 December 2012      254 Examples 
The package Parent is firs t written without subunits:  
package Parent is 
    procedure  Inner; 
end Parent; 
with Ada.Text_IO; 
package body Parent is 
    Variable : String := "Hello, there.";     procedure  Inner is 
    begin 
        Ada.Text_IO.Put_Line(Variable);     end Inner; 
end Parent; 
The body of procedure Inner may be turned into a subunit by rewriting the package body as follows (with 
the declaration of Parent remaining the same):  
package body Parent is 
    Variable : String := "Hello, there.";     procedure  Inner is separate ; 
end Parent; 
with Ada.Text_IO; 
separate (Parent) 
procedure  Inner is 
begin 
    Ada.Text_IO.Put_Line(Variable); end Inner; 
10.1.4 The Compilation Process 
Each compilation unit submitted to the comp iler is compiled in the context of an environment  
declarative_part  (or simply, an environment ), which is a conceptual declarative_part  that forms the 
outermost declarative region of the context of any compilation . At run time, an environment forms the 
declarative_part  of the body of the environment task of a partition (see 10.2, “Program Execution”).  
The declarative_item s of the environment are library_item s appearing in an order such that there are no 
forward semantic dependences. Each included subun it occurs in place of the corresponding stub. The 
visibility rules apply as if the environment were  the outermost declarative region, except that with_clause s 
are needed to make declarations of  library units visible (see 10.1.2). 
The mechanisms for creating an environment and fo r adding and replacing compilation units within an 
environment are implementation defined. The mechan isms for adding a compilation unit mentioned in a 
limited_with_clause  to an environment are implementation defined.  
Name Resolution Rules 
If a library_unit_body  that is a subprogram_body  is submitted to the compiler,  it is interpreted only as a 
completion if a library_unit_declaration  with the same defining_program_unit_name  already exists in the 
environment for a subprogram other th an an instance of a generic subpr ogram or for a generic subprogram 
(even if the profile of the body is not type conforma nt with that of the decl aration); otherwise, the 
subprogram_body  is interpreted as both the declara tion and body of a library subprogram.  
Legality Rules 
When a compilation unit is compiled, all compilati on units upon which it depends semantically shall 
already exist in the environment; the se t of these compilation units shall be consistent  in the sense that the 19 
20 
21 
22 
23 
24 
1 
2 
3/2 
4/3 
5 
Ada Reference Manual — 2012 Edition 
255      13 December 2012 The Compilation Process   10.1.4 new compilation unit shall not semantically depend (direc tly or indirectly) on two different versions of the 
same compilation unit, nor on an earlier version of itself.  
Implementation Permissions 
The implementation may require that a compilation unit be legal before it can be mentioned in a 
limited_with_clause  or it can be inserted into the environment. 
When a compilation unit that declares or renames a library unit is added to the environment, the 
implementation may remove from the environment any preexisting library_item  or subunit  with the same 
full expanded name. When a compilation unit that is a s ubunit or the body of a library unit is added to the 
environment, the implementation ma y remove from the environment any preexisting version of the same 
compilation unit. When a compilation unit that contains a body_stub  is added to the environment, the 
implementation may re move any preexisting library_item  or subunit  with the same full expanded name as 
the body_stub . When a given compilation unit is removed fro m the environment, the implementation may 
also remove any compilation unit that depends sema ntically upon the given one. If the given compilation 
unit contains the body of a subprogram for which as pect Inline is True, the implementation may also 
remove any compilation unit contai ning a call to that subprogram.  
NOTES 
5  The rules of the language are enforced across compilation  and compilation unit boundaries, just as they are enforced 
within a single compilation unit.  
6  An implementation may support a concept of a library , which contains library_item s. If multiple libraries are supported, 
the implementation has to define how a single environment is constructed when a compilation unit is submitted to the compiler. Naming conflicts between different libraries might be resolved by treating each library as the root of a hierarchy of child library units.  
7  A compilation unit containing an instantiation of a separately compiled generic unit does not semantically depend on 
the body of the generic unit. Therefore, replacing the generic body in the environment does not result in the removal of the compilation unit containing the instantiation.  
10.1.5 Pragmas and Program Units 
This subclause discusses pragmas relate d to program units, library units, and compilation s.  
Name Resolution Rules 
Certain pragma s are defined to be program unit pragmas . A name  given as the argument of a program 
unit pragma shall resolve to denote the declarations or  renamings of one or more program units that occur 
immediately within the declarative region or compilation  in which the pragma  immediately occurs, or it 
shall resolve to denote the declaration of the immediately enclosing program unit (if any); the pragma  
applies to the denoted program unit(s). If there are no name s given as arguments, the pragma  applies to 
the immediately enclosing program unit.  
Legality Rules 
A program unit pragma shall appear in one of these places:  
• At the place of a compilation_unit , in which case the pragma  shall immediately follow in the 
same compilation  (except for other pragma s) a library_unit_declaration  that is a subprogram_-
declaration , generic_subprogram_declaration , or generic_instantiation , and the pragma  shall 
have an argument that is a name  denoting that declaration.  
• Immediately within the visible part of a program  unit and before any nested declaration (but not 
within a generic formal part), in which case the argument, if any, shall be a direct_name  that 
denotes the immediately enclosing program unit declaration.  6/2 
7/3 
8 
9 
10 
1 
2 
3 
4 
5/1 
Ada Reference Manual — 2012 Edition 
10.1.5    Pragmas and Program Units 13 December 2012      256 • At the place of a declaration other than the first, of a declarative_part  or program unit 
declaration, in which case the pragma  shall have an argument, which shall be a direct_name  
that denotes one or more of the following (and nothing else): a subprogram_declaration , a 
generic_subprogram_declaration , or a generic_instantiation , of the same declarative_part  or 
program unit declaration.  
Certain program unit pragmas are defined to be library unit pragmas . If a library unit pragma applies to a 
program unit, the program unit shall be a library unit.  
Static Semantics 
A library unit pragma that applies to a generic unit doe s not apply to its instances, unless a specific rule for 
the pragma specifies the contrary.  
Post-Compilation Rules 
Certain pragma s are defined to be configuration pragmas ; they shall appear before the first 
compilation_unit  of a compilation . They are generally used to select a partition-wide or system-wide 
option. The pragma  applies to all compilation_unit s appearing in the compilation , unless there are none, in 
which case it applies to all future compilation_unit s compiled into the same environment.  
Implementation Permissions 
An implementation may require that configuration pr agmas that select partition-wide or system-wide 
options be compiled when the environment contains no library_item s other than those of the predefined 
environment. In this case, the implementation sh all still accept configuration pragmas in individual 
compilations that confirm the initially select ed partition-wide or system-wide options. 
Implementation Advice 
When applied to a generic unit, a program unit pragma  that is not a library unit pragma should apply to 
each instance of the generic unit for which there is not an overriding pragma applied directly to the 
instance.  
10.1.6 Environment-Level Visibility Rules 
The normal visibility rules do not apply within a parent_unit_name  or a context_clause , nor within a 
pragma  that appears at the place of a compilation unit. Th e special visibility rules for those contexts are 
given here.  
Static Semantics 
Within the parent_unit_name  at the beginning of an explicit library_item , and within a 
nonlimited_with_clause , the only declarations that are visible are those that are explicit library_item s of 
the environment, and the only declarations that are directly visible are those that are explicit root 
library_item s of the environment. Within a limited_with_clause , the only declarations that are visible are 
those that are the implicit declaration of the limited vi ew of a library package of the environment, and the 
only declarations that are directly visible are those th at are the implicit declaration of the limited view of a 
root library package. 
Within a use_clause  or pragma  that is within a context_clause , each library_item  mentioned in a 
previous with_clause  of the same context_clause  is visible, and each root library_item  so mentioned is 
directly visible. In addition, within such a use_clause , if a given declaration is visible or directly visible, 
each declaration that occurs immediately within the gi ven declaration's visible part is also visible. No 
other declarations are visible or directly visible.  6 
7/3 
7.1/1 
8 
9/2 
10/1 
1 
2/2 
3 
Ada Reference Manual — 2012 Edition 
257      13 December 2012 Environment-Level Visibility Rules   10.1.6 Within the parent_unit_name  of a subunit, library_item s are visible as they are in the parent_unit_name  
of a library_item ; in addition, the declaration corresponding to each body_stub  in the environment is also 
visible.  
Within a pragma  that appears at the place of a compilation unit, the immediately preceding library_item  
and each of its ancestors is visible. The ancestor root library_item  is directly visible. 
Notwithstanding the rules of 4. 1.3, an expanded name in a with_clause , a pragma  in a context_clause , or 
a pragma  that appears at the place of a compilation unit may consist of a prefix  that denotes a generic 
package and a selector_name  that denotes a child of that generic package. (The child is necessarily a 
generic unit; see 10.1.1.)  
10.2 Program Execution 
An Ada program  consists of a set of partitions , which can execute in parallel with one another, possibly in 
a separate address space, and possibly on a separate computer.  
Post-Compilation Rules 
A partition is a program or part of a program that  can be invoked from outside the Ada implementation. 
For example, on many systems, a partition might be an executable file generated by the system linker. The 
user can explicitly assign  library units to a partition. The assignment is done in an implementation-defined 
manner. The compilation units included in a partition ar e those of the explicitly assigned library units, as 
well as other compilation units needed by  those library units. The compila tion units needed by a given 
compilation unit are determined as follows (unless specified otherwise via an  implementation-defined 
pragma , or by some other implementation-defined means):  
• A compilation unit needs itself; 
• If a compilation unit is needed, then so are any compilation units upon which it depends 
semantically; 
• If a library_unit_declaration  is needed, then so is any corresponding library_unit_body ; 
• If a compilation unit with stubs is need ed, then so are any corresponding subunits; 
• If the (implicit) declaration of the limited view of  a library package is needed, then so is the 
explicit declaration of the library package. 
The user can optionally designate (in an impl ementation-defined manner) one subprogram as the main 
subprogram  for the partition. A main subprogram, if specified, shall be a subprogram.  
Each partition has an anonymous environment task , which is an implicit outermost task whose execution 
elaborates the library_item s of the environment declarative_part , and then calls the main subprogram, if 
there is one. A partition's execution is that of its tasks.  
The order of elaboration of library un its is determined primarily by the elaboration dependences . There is 
an elaboration dependence of a given library_item  upon another if the given library_item  or any of its 
subunits depends semantically on the other library_item . In addition, if a given library_item  or any of its 
subunits has a pragma  Elaborate or Elaborate_All that names another library unit, then there is an 
elaboration dependence of the given library_item  upon the body of the other library unit, and, for 
Elaborate_All only, upon each library_item  needed by the declaration of the other library unit.  
The environment task for a partition has the following structure:  
task Environment_Task ; 4 
5 
6/2 
1 
2 
3 
4 
5 
6/2 
6.1/2 
7 
8 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
10.2    Program Execution 13 December 2012      258 task body Environment_Task  is 
    ... (1) --  The environment declarative_part  
            --  (that is, the sequence of library_item s) goes here.  
begin 
    ... (2) --  Call the main subprogram, if there is one.  
end Environment_Task ; 
The environment declarative_part  at (1) is a sequence of declarative_item s consisting of copies of the 
library_item s included in the partition. The order of elaboration of library_item s is the order in which they 
appear in the environment declarative_part :  
• The order of all included library_item s is such that there are no forward elaboration 
dependences.  
• Any included library_unit_declaration  for which aspect Elaborate_Body is True (including when 
a pragma  Elaborate_Body applies) is immediately followed by its library_unit_body , if 
included.  
• All library_item s declared pure occur before an y that are not declared pure. 
• All preelaborated library_item s occur before any that are not preelaborated.  
There shall be a total order of the library_item s that obeys the above rules. The order is otherwise 
implementation defined.  
The full expanded names of the library units and subun its included in a given partition shall be distinct. 
The sequence_of_statements  of the environment task (see (2 ) above) consists of either:  
• A call to the main subprogram, if the partition has one. If the main subprogram has parameters, 
they are passed; where the actuals come from is implementation defined. What happens to the result of a main function is al so implementation defined.  
or:  
• A 
null_statement , if there is no main subprogram.  
The mechanisms for building and running partitions  are implementation defined. These might be 
combined into one operation, as, for example, in  dynamic linking, or “load-and-go” systems.  
Dynamic Semantics 
The execution of a program consis ts of the execution of a set of  partitions. Further details are 
implementation defined. The execution of a partition st arts with the execution of its environment task, 
ends when the environment task terminates, and incl udes the executions of all tasks of the partition. The 
execution of the (implicit) task_body  of the environment task acts as a master for all other tasks created as 
part of the execution of the partition. When the environment task completes (normally or abnormally), it waits for the termination of all such tasks, and th en finalizes any remaining objects of the partition.  
Bounded (Run-Time) Errors 
Once the environment task has awaited the terminati on of all other tasks of the partition, any further 
attempt to create a task (during finalization) is  a bounded error, and may result in the raising of 
Program_Error either upon creation or activation of the ta sk. If such a task is activated, it is not specified 
whether the task is awaited prior to termination of the environment task.  
Implementation Requirements 
The implementation shall ensure that all compilation un its included in a partition are consistent with one 
another, and are legal according to the rules of the language.  12 
13 
14 
15/3 
16 
17 18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
Ada Reference Manual — 2012 Edition 
259      13 December 2012 Program Execution   10.2 Implementation Permissions 
The kind of partition described in this subclause is known as an active  partition. An implementation is 
allowed to support other kinds of partitions, with implementation-defined semantics.  
An implementation may restrict the kinds of subprogr ams it supports as main subprograms. However, an 
implementation is required to support all main s ubprograms that are public parameterless library 
procedures.  
If the environment task completes abnormally, the implementation may abort any dependent tasks.  
NOTES 
8  An implementation may provide inter-partition communication mechanism(s) via special packages and pragmas. Standard pragmas for distribution and methods for specifying inter-partition communication are defined in Annex E, “Distributed Systems”. If no such  mechanisms are provided, then  each partiti on is isolated from all others, and behaves as 
a program in and of itself.  
9  Partitions are not required to run in  separate a ddress spaces. For example, an im plementation might support dynamic 
linking via the partition concept. 
10  An order of elaboration of 
library_item s that is consistent with the partial ordering defined above does not always 
ensure that each library_unit_body  is elaborated before any other compilation unit whose elaboration necessitates that the 
library_unit_body  be already elaborated. (In particular, there is no requirement that the body of a library unit be elaborated 
as soon as possible after the library_unit_declaration  is elaborated, unless the pragmas in subclause 10.2.1 are used.) 
11  A partition (active or otherwise) need not have a main subprogram. In such a case, all the work done by the partition 
would be done by elaboration of various library_item s, and by tasks created by that elaboration. Passive partitions, which 
cannot have main subprograms, are defined in Annex E, “Distributed Systems”.  
10.2.1 Elaboration Control 
This subclause defines pragmas that he lp control the elaboration order of library_item s.  
Syntax 
The form of a pragma  Preelaborate is as follows:  
  pragma  Preelaborate[( library_unit_ name )]; 
A pragma  Preelaborate is a library unit pragma.  
The form of a pragma  Preelaborable_Initialization is as follows:  
  pragma  Preelaborable_Initialization( direct_name );  
Legality Rules 
An elaborable construct is preelaborable unless its  elaboration performs any of the following actions:  
• The execution of a statement  other than a null_statement .  
• A call to a subprogram other than a static function. 
• The evaluation of a primary  that is a name  of an object, unless the name  is a static expression, 
or statically denotes a discriminant of an enclosing type.  
• The creation of an object (including a component) th at is initialized by default, if its type does 
not have preelaborable initialization. Similarly, the evaluation of an extension_aggregate  with 
an ancestor subtype_mark  denoting a subtype of such a type. 
A generic body is preelaborable only if elaborati on of a corresponding instance body would not perform 
any such actions, presuming that:  
• the actual for each discriminated formal derived type, formal private type, or formal private 
extension declared within the formal part of the generic unit is a type that does not have 28/3 
29 
30 
31 
32 
33 
34 
1 
2 
3 
4 
4.1/2 
4.2/2 
5 
6 
7 8 
9/3 
10/2 
10.1/3 
Ada Reference Manual — 2012 Edition 
10.2.1    Elaboration Control 13 December 2012      260 preelaborable initialization, unless pragma  Preelaborable_Initialization has been applied to the 
formal type; 
• the actual for each formal type is nonstatic; 
• the actual for each formal object is nonstatic; and 
• the actual for each formal subprogram  is a user-defined subprogram.  
A pragma  Preelaborate (or pragma  Pure — see below) is used to  specify that a library unit is 
preelaborated , namely that the Preelaborate aspect of the lib rary unit is True; all compilation units of the 
library unit are preelaborated. The declaration and body  of a preelaborated library unit, and all subunits 
that are elaborated as part of elaborating the library  unit, shall be preelaborable. All compilation units of a 
preelaborated library unit shall depend semanti cally only on declared pure or preelaborated library_item s. 
In addition to the places where Legality Rules normally  apply (see 12.3), these rules also apply in the 
private part of an instance of a generic unit. If a library  unit is preelaborated, then its declaration, if any, 
and body, if any, are elaborated prior to all nonpreelaborated library_item s of the partition.  
The following rules specify which entities have preelaborable initialization : 
• The partial view of a private type or pr ivate extension, a protected type without 
entry_declaration s, a generic formal private type, or  a generic formal derived type, has 
preelaborable initialization if and only if the pragma  Preelaborable_Initialization has been 
applied to them. A protected type with entry_declaration s or a task type never has preelaborable 
initialization. 
• A component (including a discri minant) of a record or protected type has preelaborable 
initialization if its declaration includes a default_expression  whose execution does not perform 
any actions prohibited in preelaborable constructs  as described above, or if its declaration does 
not include a default expression and its type has preelaborable initialization. 
• A derived type has preelaborable initialization if  its parent type has preelaborable initialization 
and if the noninherited components all have preel aborable initialization. However, a controlled 
type with an Initialize procedure that is not  a null procedure does not have preelaborable 
initialization. 
• A view of a type has preelaborable initialization if  it is an elementary type, an array type whose 
component type has preelaborable initialization,  a record type whose components all have 
preelaborable initialization, or an interface type.  
A pragma  Preelaborable_Initialization specifies that a type  has preelaborable initialization. This pragma 
shall appear in the visible part of a package or generic package. 
If the pragma appears in the first list of basic_declarative_item s of a package_specification , then the 
direct_name  shall denote the first subtype of a composite type, and the type shall be declared immediately 
within the same package as the pragma . If the pragma  is applied to a private type or a private extension, 
the full view of the type shall have preelaborable initialization. If the pragma  is applied to a protected 
type, the protected type shall not have entries, a nd each component of the protected type shall have 
preelaborable initialization. For any other composite ty pe, the type shall have preelaborable initialization. 
In addition to the places where Legality Rules normally  apply (see 12.3), these rules apply also in the 
private part of an instance of a generic unit. 
If the pragma  appears in a generic_formal_part , then the direct_name  shall denote a generic formal 
private type or a generic formal derived type declared in the same generic_formal_part  as the pragma . In 
a generic_instantiation  the corresponding actual type shall have preelaborable initialization. 10.2/2 
10.3/2 10.4/2 
11/3 
11.1/2 
11.2/3 
11.3/2 
11.4/3 
11.5/2 
11.6/2 
11.7/3 
11.8/2 
Ada Reference Manual — 2012 Edition 
261      13 December 2012 Elaboration Control   10.2.1 Implementation Advice 
In an implementation, a type declar ed in a preelaborated package shoul d have the same representation in 
every elaboration of a given version of the package, whether the elaborations occur in distinct executions 
of the same program, or in executions of distinct pr ograms or partitions that include the given version.  
Syntax 
The form of a pragma  Pure is as follows:  
  pragma  Pure[( library_unit_ name )]; 
A pragma  Pure is a library unit pragma.  
Static Semantics 
A pure compilation unit is a preelaborable compilation un it whose elaboration does not perform any of the 
following actions: 
• the elaboration of a variable declaration; 
• the evaluation of an allocator  of an access-to-variable type; for the purposes of this rule, the 
partial view of a type is presumed to have  nonvisible components whose default initialization 
evaluates such an allocator ; 
• the elaboration of the declaration of a nonde rived named access-to-variable type unless the 
Storage_Size of the type has been specified by a static expression with value zero or is defined 
by the language to be zero; 
• the elaboration of the declaration of a nonderi ved named access-to-constant type for which the 
Storage_Size has been specified by an expression other than a static expression with value zero. 
A generic body is pure only if elaboration of a co rresponding instance body would not perform any such 
actions presuming any composite formal types ha ve nonvisible components whose default initialization 
evaluates an allocator  of an access-to-variable type. 
The Storage_Size for an anonymous access-to-variable type  declared at library level in a library unit that 
is declared pure is defined to be zero. 
Legality Rules 
This paragraph was deleted.  
A pragma  Pure is used to specify that a library unit is declared pure , namely that the Pure aspect of the 
library unit is True; all compilation units of the library  unit are declared pure. In addition, the limited view 
of any library package is declared pure. The declaration and body of a declared pure library unit, and all 
subunits that are elaborated as part of elaborating th e library unit, shall be pure. All compilation units of a 
declared pure library unit shall depend semantically only on declared pure library_item s. In addition to the 
places where Legality Rules normally apply (see 12.3), th ese rules also apply in the private part of an 
instance of a generic unit. Furthermore, the full view of  any partial view declared in the visible part of a 
declared pure library unit that has any available str eam attributes shall suppor t external streaming (see 
13.13.2).  
Implementation Permissions 
If a library unit is declared pure, then the implem entation is permitted to omit a call on a library-level 
subprogram of the library unit if the results are not n eeded after the call. In addition, the implementation 
may omit a call on such a subprogram and simply reuse the results produced by an earlier call on the same 
subprogram, provided that none of the parameters nor any object accessible via access values from the 
parameters have any part that is of a type whose fu ll type is an immutably limited type, and the addresses 12 
13 
14 
15 
15.1/3 
15.2/2 
15.3/2 
15.4/3 
15.5/3 
15.6/3 
15.7/2 
16/2 
17/3 
18/3 
Ada Reference Manual — 2012 Edition 
10.2.1    Elaboration Control 13 December 2012      262 and values of all by-reference actual parameters, the values of all by-copy-in actual parameters, and the 
values of all objects accessible via access values from the parameters, are the same as they were at the earlier call. This permission applies even if the s ubprogram produces other side effects when called.  
Syntax 
The form of a pragma  Elaborate, Elaborate_All, or Elaborate_Body is as follows:  
  pragma  Elaborate( library_unit_ name {, library_unit_ name }); 
  pragma  Elaborate_All( library_unit_ name {, library_unit_ name }); 
  pragma  Elaborate_Body[( library_unit_ name )]; 
A pragma  Elaborate or Elaborate_All is only allowed within a context_clause .  
A pragma  Elaborate_Body is a library unit pragma.  
Legality Rules 
If the aspect Elaborate_Body is True for a declaration (including when pragma  Elaborate_Body applies), 
then the declaration requires a completion (a body). 
The library_unit_ name  of a pragma  Elaborate or Elaborate_All sh all denote a nonlimited view of a 
library unit.  
Static Semantics 
A pragma  Elaborate specifies that the body of the named library unit is elaborated before the current 
library_item . A pragma  Elaborate_All specifies that each library_item  that is needed by the named library 
unit declaration is elaborated before the current library_item . 
A pragma  Elaborate_Body sets the Elaborate_Body repres entation aspect of the library unit to which it 
applies to the value True. If the Elaborate_Body aspect  of a library unit is True, the body of the library 
unit is elaborated immediately after its declaration. 
NOTES 
12  A preelaborated library unit is allowed to have nonpreelaborable children.  
13  A library unit that is declared pure is allowed to have impure children.  19 
20 
21 22 23 24 
25/3 
25.1/2 
26/3 
26.1/3 
27 
28 
Ada Reference Manual — 2012 Edition 
263      13 December 2012 Exceptions   11 11   Exceptions 
This clause defines the facilities for dealing with erro rs or other exceptional situ ations that arise during 
program execution. An exception  represents a kind of exceptional situation; an occurrence of such a 
situation (at run time) is called an exception occurrence . To raise  an exception is to abandon normal 
program execution so as to draw attention to th e fact that the corresponding situation has arisen. 
Performing some actions in response to the arising of an exception is called handling  the exception.  
An exception_declaration  declares a name for an exception. An  exception can be raised explicitly (for 
example, by a raise_statement ) or implicitly (for example, by the failure of a language-defined check). 
When an exception arises, control can be transferred to a user-provided exception_handler  at the end of a 
handled_sequence_of_statements , or it can be propagated to a dynamically enclosing execution.  
11.1 Exception Declarations 
An exception_declaration  declares a name for an exception.  
Syntax 
exception_declaration ::= defining_identifier_list  : exception  
   [aspect_specification ]; 
Static Semantics 
Each single exception_declaration  declares a name for a different exception. If a generic unit includes an 
exception_declaration , the exception_declaration s implicitly generated by different instantiations of the 
generic unit refer to distinct exceptions (but all have the same defining_identifier ). The particular 
exception denoted by an exception name is determined  at compilation time and is the same regardless of 
how many times the exception_declaration  is elaborated.  
The predefined  exceptions are the ones declared in the declar ation of package Standard: Constraint_Error, 
Program_Error, Storage_Error, and Ta sking_Error; one of them is rais ed when a language-defined check 
fails.  
Dynamic Semantics 
The elaboration of an exception_declaration  has no effect. 
The execution of any construct raises Storage_Error if there is insufficient storage for that execution. The 
amount of storage needed for the execu tion of constructs is unspecified.  
Examples 
Examples of user-defined exception declarations:   
Singular : exception ; 
Error    : exception ; 
Overflow, Underflow : exception ; 1/3 
2/3 
1 
2/3 
3 
4 
5 
6 
7 
8 
Ada Reference Manual — 2012 Edition 
11.2    Exception Handlers 13 December 2012      264 11.2 Exception Handlers 
The response to one or more ex ceptions is specified by an exception_handler .  
Syntax 
handled_sequence_of_statements ::=  
     sequence_of_statements  
  [exception  
     exception_handler  
    {exception_handler }] 
exception_handler ::=  
  when  [choice_parameter_specification :] exception_choice  {| exception_choice } => 
     sequence_of_statements  
choice_parameter_specificat ion ::= defining_identifier  
exception_choice ::= exception_ name  | others  
Legality Rules 
A choice with an exception_ name  covers  the named exception. A choice with others  covers all exceptions 
not named by previous choices of the same handled_sequence_of_statements . Two choices in different 
exception_handler s of the same handled_sequence_of_statements  shall not cover the same exception.  
A choice with others  is allowed only for the last handler of a handled_sequence_of_statements  and as 
the only choice of that handler. 
An exception_ name  of a choice shall not denote an exception d eclared in a generic formal package.  
Static Semantics 
A choice_parameter_specification  declares a choice parameter , which is a constant object of type 
Exception_Occurrence (see 11.4.1). During the handling of  an exception occurrence, the choice parameter, 
if any, of the handler represents the exception occurrence that is being handled. 
Dynamic Semantics 
The execution of a handled_sequence_of_statements  consists of the execution of the sequence_of_-
statements . The optional handlers are used to handle any exceptions that are propagated by the 
sequence_of_statements .  
Examples 
Example of an exception handler:   
begin 
   Open(File, In_File, "input.txt");   --  see A.8.2 
exception  
   when E : Name_Error => 
      Put("Cannot open input file : ");       Put_Line(Exception_Message(E));  --  see 11.4.1 
      raise; 
end; 1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
265      13 December 2012 Raise Statements   11.3 11.3 Raise Statements 
A raise_statement  raises an exception.  
Syntax 
raise_statement ::= raise ; 
      | raise  exception_ name  [with  string_ expression ]; 
Legality Rules 
The name , if any, in a raise_statement  shall denote an exception. A raise_statement  with no 
exception_ name  (that is, a re-raise statement ) shall be within a handler, but not within a body enclosed by 
that handler.  
Name Resolution Rules 
The expression , if any, in a raise_statement , is expected to be of type String.  
Dynamic Semantics 
To raise an exception  is to raise a new occurrence of that exception, as explained in 11.4. For the 
execution of a raise_statement  with an exception_ name , the named exception is raised. If a 
string_ expression  is present, the expression  is evaluated and its value is associated with the exception 
occurrence. For the execution of a re-raise statement,  the exception occurrence that caused transfer of 
control to the innermost enclosi ng handler is raised again.  
Examples 
Examples of raise statements:   
raise Ada.IO_Exceptions.Name_Error;   --  see A.13 
raise Queue_Error with "Buffer Full"; --  see 9.11 
raise;                                --  re-raise the current exception  
11.4 Exception Handling 
When an exception occurrence is raised, normal program  execution is abandoned and control is transferred 
to an applicable exception_handler , if any. To handle  an exception occurrence is to respond to the 
exceptional event. To propagate  an exception occurrence is to raise it again in another context; that is, to 
fail to respond to the exceptional ev ent in the present context.  
Dynamic Semantics 
Within a given task, if the execution of construct a is defined by this Interna tional Standard to consist (in 
part) of the execution of construct b, then while b is executing, the execution of a is said to dynamically 
enclose  the execution of b. The innermost dynamically enclosing  execution of a given execution is the 
dynamically enclosing execution that started most recently.  
When an exception occurrence is raised by the execution of a given construct, the rest of the execution of 
that construct is abandoned ; that is, any portions of the execution that have not yet taken place are not 
performed. The construct is first completed, a nd then left, as explained in 7.6.1. Then:  
• If the construct is a task_body , the exception does not propagate further;  
• If the construct is the sequence_of_statements  of a handled_sequence_of_statements  that 
has a handler with a choice covering the exception,  the occurrence is handled by that handler; 1 
2/2 
3 
3.1/2 
4/2 
5 
6/2 
7 
1 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
11.4    Exception Handling 13 December 2012      266 • Otherwise, the occurrence is propagated  to the innermost dynamically enclosing execution, 
which means that the occurrence is raised again in that context.  
When an occurrence is handled  by a given handler, the choice_parameter_specification , if any, is first 
elaborated, which creates the choice parameter and initializes it to the occurrence. Then, the 
sequence_of_statements  of the handler is executed; this ex ecution replaces the abandoned portion of the 
execution of the sequence_of_statements .  
NOTES 
1  Note that exceptions raised in a declarative_part  of a body are not handled by the handlers of the handled_-
sequence_of_statements  of that body.  
11.4.1 The Package Exceptions 
Static Semantics 
The following language-defined library package exists:  
with Ada.Streams; 
package Ada.Exceptions is 
    pragma Preelaborate(Exceptions); 
    type Exception_Id is private; 
    pragma Preelaborable_Initialization(Exception_Id); 
    Null_Id : constant  Exception_Id; 
    function  Exception_Name(Id : Exception_Id) return String; 
    function  Wide_Exception_Name(Id : Exception_Id) return Wide_String; 
    function  Wide_Wide_Exception_Name(Id : Exception_Id) 
        return Wide_Wide_String; 
    type Exception_Occurrence is limited private; 
    pragma Preelaborable_Initialization(Exception_Occurrence); 
    type Exception_Occurrence_Access is access all Exception_Occurrence; 
    Null_Occurrence : constant  Exception_Occurrence; 
    procedure  Raise_Exception(E : in Exception_Id; 
                              Message : in String := "") 
        with No_Return; 
    function  Exception_Message(X : Exception_Occurrence) return String; 
    procedure  Reraise_Occurrence(X : in Exception_Occurrence); 
    function  Exception_Identity(X : Exception_Occurrence) 
                                return Exception_Id; 
    function  Exception_Name(X : Exception_Occurrence) return String; 
        --  Same as Exception_Name(Exception_Identity(X)).  
    function  Wide_Exception_Name(X : Exception_Occurrence) 
        return Wide_String; 
        --  Same as Wide_Exception_Name(Exception_Identity(X)).  
    function  Wide_Wide_Exception_Name(X : Exception_Occurrence) 
        return Wide_Wide_String; 
        --  Same as Wide_Wide_Exception_Name(Exception_Identity(X)).  
    function  Exception_Information(X : Exception_Occurrence) return String; 
    procedure  Save_Occurrence(Target : out Exception_Occurrence; 
                              Source : in Exception_Occurrence); 
    function  Save_Occurrence(Source : Exception_Occurrence) 
                             return Exception_Occurrence_Access; 
    procedure  Read_Exception_Occurrence 
       (Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
        Item   : out Exception_Occurrence); 
    procedure  Write_Exception_Occurrence 
       (Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
        Item   : in Exception_Occurrence); 
    for Exception_Occurrence'Read use Read_Exception_Occurrence; 
    for Exception_Occurrence'Write use Write_Exception_Occurrence; 6 
7 
8 
1 
2/2 
3/2 
4/3 
5/2 
6/2 
6.1/2 
6.2/2 
Ada Reference Manual — 2012 Edition 
267      13 December 2012 The Package Exceptions   11.4.1 private 
   ... --  not specified by the language  
end Ada.Exceptions; 
Each distinct exception is represente d by a distinct value of type Exception_Id. Null_Id does not represent 
any exception, and is the default initial value of ty pe Exception_Id. Each occurrence of an exception is 
represented by a value of type Exception_Occurren ce. Null_Occurrence does not represent any exception 
occurrence, and is the default initia l value of type Exception_Occurrence. 
For a prefix  E that denotes an exception, the following attribute is defined:  
E'Identity E'Identity returns the unique identity of the exception. The type of this attribute is 
Exception_Id.  
Raise_Exception raises a new occurrence of the identified exception. 
Exception_Message returns the me ssage associated with the given Exception_Occurrence. For an 
occurrence raised by a call to Raise_Exception, the message is the Message parameter passed to Raise_Exception. For the occurrence raised by a 
raise_statement  with an exception_ name  and a 
string_ expression , the message is the string_ expression . For the occurrence raised by a raise_statement  
with an exception_ name  but without a string_ expression , the message is a string giving implementation-
defined information about the exception occurrence. Fo r an occurrence originally raised in some other 
manner (including by the failure of a language-defined ch eck), the message is an unspecified string. In all 
cases, Exception_Message returns a string with lower bound 1.  
Reraise_Occurrence reraises the specified exception occurrence. 
Exception_Identity returns the identity of the exception of the occurrence. 
The Wide_Wide_Exception_Name functi ons return the full expanded name of the exception, in upper 
case, starting with a root library unit. For an excepti on declared immediately within package Standard, the 
defining_identifier  is returned. The result is implementation defi ned if the exception is declared within an 
unnamed block_statement .  
The Exception_Name functions (respectively, Wide_E xception_Name) return the same sequence of 
graphic characters as that defined for Wide_Wide_ Exception_Name, if all th e graphic characters are 
defined in Character (respectively, Wide_Charact er); otherwise, the sequence of characters is 
implementation defined, but no shorter than that returned by Wide_Wide_Exception_Name for the same 
value of the argument.  
The string returned by the Exception_Name, Wi de_Exception_Name, and Wide_Wide_Exception_Name 
functions has lower bound 1. 
Exception_Information returns implementation-defined information about the exception occurrence. The 
returned string has lower bound 1.  
Reraise_Occurrence has no effect in the case of Null_Occurrence. Raise_Ex ception and Exception_Name 
raise Constraint_Error for a Null_Id. Exception_M essage, Exception_Name, and Exception_Information 
raise Constraint_Error for a Null_ Occurrence. Exception_Identity app lied to Null_Occurrence returns 
Null_Id. 
The Save_Occurrence procedure copies the Source to the Target. The Save_Occurrence function uses an 
allocator  of type Exception_Occurrence_Access to create a new object, copies the Source to this new 
object, and returns an access value designating this new object; the result may be deallocated using an instance of Unchecked_Deallocation.  6.3/2 
7 
8/1 
9 
10/2 
10.1/3 
10.2/2 
11 
12/2 
12.1/2 
12.2/2 
13/2 14/2 
15 
Ada Reference Manual — 2012 Edition 
11.4.1    The Package Exceptions 13 December 2012      268 Write_Exception_Occurrence writes a representati on of an exception occurrence to a stream; 
Read_Exception_Occurrence reconstruc ts an exception occurrence from a stream (including one written in 
a different partition).  
Paragraph 16 was deleted.   
Implementation Permissions 
An implementation of Exception_Name in a sp ace-constrained environment may return the defining_-
identifier  instead of the full expanded name. 
The string returned by Exception_Message may be truncated (to no less than 200 characters) by the 
Save_Occurrence procedure (not the function), the Reraise_Occurrence procedure, and the re-raise 
statement.  
Implementation Advice 
Exception_Message (by default) and Exception_Inf ormation should produce information useful for 
debugging. Exception_Message should be short (about one line), whereas Exception_Information can be 
long. Exception_Message should not include the Ex ception_Name. Exception_Information should include 
both the Exception_Name and the Exception_Message. 
11.4.2 Pragmas Assert and Assertion_Policy 
Pragma Assert is used to assert the truth of a boolean expression at a point within a sequence of 
declarations or statements. 
Assert pragmas, subtype predicates (see 3.2.4), preconditions and postconditions (see 6.1.1), and type 
invariants (see 7.3.2) are collectively referred to as assertions ; their boolean expressions are referred to as 
assertion expressions . 
Pragma Assertion_Policy is used to control whether a ssertions are to be ignored by the implementation, 
checked at run time, or handled in some implementation-defined manner.  
Syntax 
The form of a pragma  Assert is as follows:  
  pragma  Assert([Check =>] boolean_ expression [, [Message =>] string_ expression ]); 
A pragma  Assert is allowed at the place where a declarative_item  or a statement  is allowed. 
The form of a pragma  Assertion_Policy is as follows:  
  pragma  Assertion_Policy( policy_ identifier ); 
  pragma  Assertion_Policy( 
         assertion_ aspect_mark  => policy_ identifier  
     {, assertion_ aspect_mark  => policy_ identifier }); 
A pragma  Assertion_Policy is allowed only immediately within a declarative_part , immediately 
within a package_specification , or as a configuration pragma. 
Name Resolution Rules 
The expected type for the boolean_ expression  of a pragma  Assert is any boolean type. The expected type 
for the string_ expression  of a pragma  Assert is type String.  15.1/2 
17 
18 
19 
1/3 
1.1/3 
1.2/3 
2/2 
3/2 
4/2 5/2 
6/2 
6.1/3 
7/3 
8/2 
Ada Reference Manual — 2012 Edition 
269      13 December 2012 Pragmas Assert and Assertion_Policy   11.4.2 Legality Rules 
The assertion_ aspect_mark  of a pragma  Assertion_Policy shall be one of Assert, Static_Predicate, 
Dynamic_Predicate, Pre, Pre'Class, Post, Post'Cla ss, Type_Invariant, Type_I nvariant'Class, or some 
implementation defined aspect_mark . The policy_ identifier  shall be either Check, Ignore, or some 
implementation-defined identifier .  
Static Semantics 
A pragma  Assertion_Policy determines for each  assertion aspect named in the 
pragma_argument_association s whether assertions of the given aspect are to be enforced by a run-time 
check. The policy_ identifier  Check requires that assertion expressions of the given aspect be checked that 
they evaluate to True at the points specified for the given aspect; the policy_ identifier  Ignore requires that 
the assertion expression not be evaluated at these poi nts, and the run-time checks not be performed. Note 
that for subtype predicate aspects (see 3.2.4), even when the applicab le Assertion_Policy is Ignore, the 
predicate will still be evaluated as part of membership tests and Valid attribute_reference s, and if static, 
will still have an effect on loop iteration over the subtype, and the selection of 
case_statement_alternative s and variant s. 
If no assertion_ aspect_mark s are specified in the pragma, the specified policy applies to all assertion 
aspects. 
A pragma  Assertion_Policy applies to the named assertion aspects in a speci fic region, and applies to all 
assertion expressions speci fied in that region. A pragma  Assertion_Policy given in a declarative_part  or 
immediately within a package_specification  applies from the place of the pragma to the end of the 
innermost enclosing declarative region. The region for a pragma  Assertion_Policy given as a 
configuration pragma is the declarative region for th e entire compilation unit (or units) to which it applies. 
If a pragma  Assertion_Policy applies to a generic_instantiation , then the pragma  Assertion_Policy 
applies to the entire instance. 
If multiple Assertion_Policy pragmas apply to a given c onstruct for a given assertion aspect, the assertion 
policy is determined by the one in the innermost enclosing region of a pragma  Assertion_Policy 
specifying a policy for the assertion aspect. If no su ch Assertion_Policy pragma  exists, the policy is 
implementation defined. 
The following language-defined  library package exists: 
package Ada.Assertions is 
   pragma Pure(Assertions); 
   Assertion_Error : exception ; 
   procedure  Assert(Check : in Boolean); 
   procedure  Assert(Check : in Boolean; Message : in String); 
end Ada.Assertions; 
A compilation unit containing a check for an assertion (including a pragma  Assert) has a semantic 
dependence on the Assertions library unit. 
This paragraph was deleted.  
Dynamic Semantics 
If performing checks is required by the Assert assertion policy in effect at the place of a pragma  Assert, 
the elaboration of the pragma consists of evaluati ng the boolean expression, and if the result is False, 
evaluating the Message argument, if any, and rais ing the exception Assertions.Assertion_Error, with a 
message if the Message argument is provided. 9/3 
10/3 
10.1/3 
10.2/3 
10.3/3 
10.4/3 
11/2 
12/2 
13/2 
14/2 
15/2 
16/3 
17/3 
18/3 
Ada Reference Manual — 2012 Edition 
11.4.2    Pragmas Assert and Assertion_Policy 13 December 2012      270 Calling the procedure Assertions.Assert without  a Message parameter is equivalent to: 
if Check = False then 
   raise Ada.Assertions.Assertion_Error; 
end if; 
Calling the procedure Assertions.Assert with  a Message parameter is equivalent to: 
if Check = False then 
   raise Ada.Assertions.Assertion_Error with Message; 
end if; 
The procedures Assertions.Assert have these effect s independently of the assertion policy in effect. 
Bounded (Run-Time) Errors 
It is a bounded error to invoke a potentially blocking operation (see 9.5.1) during the evaluation of an 
assertion expression associated with a call on, or re turn from, a protected operation. If the bounded error is 
detected, Program_Error is raised. If not detected, ex ecution proceeds normally, but if it is invoked within 
a protected action, it might result in dead lock or a (nested) protected action.  
Implementation Permissions 
Assertion_Error may be declared by renaming an  implementation-defined exception from another 
package.  
Implementations may define th eir own assertion policies. 
If the result of a function call in an assertion is not  needed to determine the value of the assertion 
expression, an implementation is permitted to omit the function call. This permission applies even if the 
function has side effects. 
An implementation need not allow the specification of  an assertion expression if the evaluation of the 
expression has a side effect such that an imme diate reevaluation of the expression could produce a 
different value. Similarly, an im plementation need not allow the speci fication of an assertion expression 
that is checked as part of a ca ll on or return from a callable entity C, if the evaluation of the expression has 
a side effect such that the evaluation of some other assertion expression associated with the same call of (or return from) C could produce a different value than it w ould if the first expression had not been 
evaluated. 
NOTES 
2  Normally, the boolean expression in a pragma  Assert should not call functions that have significant side effects when 
the result of the expression is True, so that the particular assertion policy in effect will not affect normal operation of the  
program.  19/2 
20/2 
21/2 
22/2 
23/2 
23.1/3 
24/2 
25/2 
26/3 
27/3 
28/2 
Ada Reference Manual — 2012 Edition 
271      13 December 2012 Example of Exception Handling   11.4.3 11.4.3 Example of Exception Handling 
Examples 
Exception handling may be used to separate the detec tion of an error from the response to that error:  
package File_System is 
    type File_Handle is limited private; 
    File_Not_Found : exception ; 
    procedure  Open(F : in out File_Handle; Name : String); 
        --  raises File_Not_Found if named file does not exist  
    End_Of_File : exception ; 
    procedure  Read(F : in out File_Handle; Data : out Data_Type); 
        --  raises End_Of_File if the file is not open  
    ... 
end File_System; 
package body File_System is 
    procedure  Open(F : in out File_Handle; Name : String) is 
    begin 
        if File_Exists(Name) then 
            ...         else 
            raise File_Not_Found with "File not found: " & Name & "."; 
        end if; 
    end Open; 
    procedure  Read(F : in out File_Handle; Data : out Data_Type) is 
    begin 
        if F.Current_Position <= F.Last_Position then 
            ...         else 
            raise End_Of_File; 
        end if; 
    end Read; 
    ... end File_System; 
with Ada.Text_IO; 
with Ada.Exceptions; 
with File_System; use File_System; 
use Ada; 
procedure  Main is 
begin 
    ... --  call operations in File_System  
exception  
    when End_Of_File => 
        Close(Some_File);     when Not_Found_Error : File_Not_Found => 
        Text_IO.Put_Line(Exceptions.Exception_Message(Not_Found_Error));     when The_Error : others => 
        Text_IO.Put_Line("Unknown error:");         if Verbosity_Desired then 
            Text_IO.Put_Line(Exceptions.Exception_Information(The_Error));         else 
            Text_IO.Put_Line(Exceptions.Exception_Name(The_Error));             Text_IO.Put_Line(Exceptions.Exception_Message(The_Error));         end if; 
        raise; 
end Main; 
In the above example, the File_Sys tem package contains information about detecting certain exceptional 
situations, but it does not specify how to handle those situations. Procedure Main specifies how to handle 1 
2/2 
3 
4 5 
6/2 
7 
8 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
11.4.3    Example of Exception Hand ling 13 December 2012      272 them; other clients of File_System might have different handlers, ev en though the exceptional situations 
arise from the same basic causes.  
11.5 Suppressing Checks 
Checking pragmas  give instructions to an implementa tion on handling language-defined checks. A 
pragma  Suppress gives permission to an  implementation to om it certain language-defined checks, while a 
pragma  Unsuppress revokes the permission to omit checks.. 
A language-defined check  (or simply, a “check”) is one of the s ituations defined by this International 
Standard that requires a check to be made at run time to determine whether some condition is true. A 
check fails when the condition being checked is Fals e, causing an exception to be raised.  
Syntax 
The forms of checking pragmas are as follows:  
  pragma  Suppress( identifier ); 
  pragma  Unsuppress( identifier ); 
A checking pragma is allowed only immediately within a declarative_part , immediately within a 
package_specification , or as a configuration pragma.  
Legality Rules 
The identifier  shall be the name of a check.  
This paragraph was deleted.  
Static Semantics 
A checking pragma applies to the named check in a specific region, and applies to all entities in that 
region. A checking pragma given in a declarative_part  or immediately within a package_specification  
applies from the place of the pragma  to the end of the innermost encl osing declarative region. The region 
for a checking pragma given as a configuration pragma  is the declarative region for the entire compilation 
unit (or units) to which it applies. 
If a checking pragma applies to a generic_instantiation , then the checking pragma also applies to the 
entire instance.  
A pragma  Suppress gives permission to an  implementation to omit the name d check (or every check in the 
case of All_Checks) for any entities to which it applie s. If permission has been given to suppress a given 
check, the check is said to be suppressed .  
A pragma  Unsuppress revokes the permission to omit the named check (or every check in the case of 
All_Checks) given by any pragma  Suppress that applies at the point of the pragma  Unsuppress. The 
permission is revoked for the region to which the pragma  Unsuppress applies. If there is no such 
permission at the point of a pragma  Unsuppress, then the pragma  has no effect. A later pragma  Suppress 
can renew the permission. 
The following are the language-defined checks:  
• The following checks correspond to situations in which the exception Constraint_Error is raised 
upon failure. 1/2 
2/3 
3/2 
4/2 
4.1/2 
5/2 
6/2 
7/2 
7.1/2 
7.2/3 
8/2 
8.1/2 
9 
10 
Ada Reference Manual — 2012 Edition 
273      13 December 2012 Suppressing Checks   11.5 Access_Check  
 When evaluating a dereference (explicit or  implicit), check that the value of the name  
is not null. When converting to a subtype that excludes null, check that the converted 
value is not null. 
Discriminant_Check  
 Check that the discriminants of a compos ite value have the values imposed by a 
discriminant constraint. Also, when accessing a record component, check that it exists 
for the current discriminant values. 
Division_Check  
 Check that the second operand is not zero for the operations /, rem and mod . 
Index_Check  
 Check that the bounds of an array value are equal to the corresponding bounds of an 
index constraint. Also, when accessing a component of an array object, check for each dimension that the given index value belongs  to the range defined by the bounds of the 
array object. Also, when accessing a slice of an array object, check that the given discrete range is compatible with the ra nge defined by the bounds of the array object. 
Length_Check  
 Check that two arrays have matching co mponents, in the case of array subtype 
conversions, and logical operators for arrays of boolean components. 
Overflow_Check  
 Check that a scalar value is within the base range of its type, in cases where the 
implementation chooses to raise an exception instead of returning the correct 
mathematical result. 
Range_Check  
 Check that a scalar value satisfies a range constraint. Also, for the elaboration of a 
subtype_indication , check that the constraint  (if present) is compatible with the 
subtype denoted by the subtype_mark . Also, for an aggregate , check that an index or 
discriminant value belongs to the corres ponding subtype. Also, check that when the 
result of an operation yields an array, the value of each component belongs to the component subtype. 
Tag_Check  
 Check that operand tags in a dispatching call are all equal. Check for the correct tag on 
tagged type conversions, for an 
assignment_statement , and when returning a tagged 
limited object from a function.  
• The following checks correspond to situations in  which the exception Program_Error is raised 
upon failure.  
Accessibility_Check  
 Check the accessibility level of an entity or view. 
Allocation_Check  
 For an allocator , check that the master of any tasks to be created by the allocator  is not 
yet completed or some depende nts have not yet terminated, and that the finalization of 
the collection has not started. 
Elaboration_Check  
 When a subprogram or protected entry is ca lled, a task activation is accomplished, or a 
generic instantiation is elaborated, check that the body of the corresponding unit has already been elaborated. 
 
This paragraph was deleted.  11/2 
12 
13/2 
14 
15 
16 
17 
18 
19 
19.1/2 19.2/2 
20 
21/2 
Ada Reference Manual — 2012 Edition 
11.5    Suppressing Checks 13 December 2012      274 • The following check corresponds to situations in  which the exception Storage_Error is raised 
upon failure.  
Storage_Check  
 Check that evaluation of an allocator  does not require more space than is available for 
a storage pool. Check that the space availabl e for a task or subprogram has not been 
exceeded.  
• The following check corresponds to all situations in which any pr edefined exception is raised.  
All_Checks  
 Represents the union of all checks; suppressing All_Checks suppresses all checks 
other than those associated with assertions . In addition, an implementation is allowed 
(but not required) to behave as if a prag ma Assertion_Policy(Ignore) applies to any 
region to which pragma Suppress(All_Checks) applies. 
Erroneous Execution 
If a given check has been suppressed, and the corre sponding error situation occurs, the execution of the 
program is erroneous.  
Implementation Permissions 
An implementation is allowed to place restrictions on checking pragmas, subject only to the requirement 
that pragma  Unsuppress shall allow any check names supported by pragma  Suppress. An implementation 
is allowed to add additional check names, with impl ementation-defined semantic s. When Overflow_Check 
has been suppressed, an implementation may also suppr ess an unspecified subset of the Range_Checks.  
An implementation may support an additional parameter on pragma  Unsuppress similar to the one 
allowed for pragma  Suppress (see J.10). The meaning of such a parameter is implementation-defined.  
Implementation Advice 
The implementation should minimize the code execu ted for checks that have been suppressed.  
NOTES 
3  There is no guarantee that a suppressed check is actually removed; hence a pragma  Suppress should be used only for 
efficiency reasons. 
4  It is possible to give both a pragma  Suppress and Unsuppress for the same check immediately within the same 
declarative_part . In that case, the last pragma  given determines whether or not the check is suppressed. Similarly, it is 
possible to resuppress a check which has been unsuppressed by giving a pragma  Suppress in an inner declarative region.  
Examples 
Examples of suppressing and unsuppressing checks:   
pragma Suppress(Index_Check); 
pragma Unsuppress(Overflow_Check); 22 
23 
24 
25/3 
26 
27/2 
27.1/2 
28 
29 
29.1/2 
30/2 
31/2 
Ada Reference Manual — 2012 Edition 
275      13 December 2012 Exceptions and Optimization   11.6 11.6 Exceptions and Optimization 
This subclause gives permission to  the implementation to perform certain “optimizations” that do not 
necessarily preserve the canonical semantics.  
Dynamic Semantics 
The rest of this International Standard  (outside this subclause) defines the canonical semantics  of the 
language. The canonical semantics of a given (legal) progr am determines a set of possible external effects 
that can result from the execution of the program with given inputs.  
As explained in 1.1.3, “Conformity of an Implementation with the Standard”, the external effect of a 
program is defined in terms of its interactions with  its external environment. Hence, the implementation 
can perform any internal actions whatso ever, in any order or in parallel, so long as the external effect of 
the execution of the program is one that is allowed by  the canonical semantics, or by the rules of this 
subclause.  
Implementation Permissions 
The following additional permissions ar e granted to the implementation:  
• An implementation need not always raise an  exception when a language-defined check fails. 
Instead, the operation that failed the check can simply yield an undefined result . The exception 
need be raised by the implementation only if, in  the absence of raising it, the value of this 
undefined result would have some effect on the external interactions of the program. In 
determining this, the im plementation shall not presume that an undefined result has a value that 
belongs to its subtype, nor even to the base range  of its type, if scalar . Having removed the raise 
of the exception, the canonical semantics will in  general allow the implementation to omit the 
code for the check, and some or all of the operation itself.  
• If an exception is raised due to the failure of a language-defined check, then upon reaching the 
corresponding exception_handler  (or the termination of the task, if none), the external 
interactions that have occurred need reflect onl y that the exception was raised somewhere within 
the execution of the sequence_of_statements  with the handler (or the task_body ), possibly 
earlier (or later if the interactions are independe nt of the result of the checked operation) than 
that defined by the canonical semantics, but not  within the execution of some abort-deferred 
operation or independent  subprogram that does not dynamically enclose the execution of the 
construct whose check failed. An independent s ubprogram is one that is defined outside the 
library unit containing the construct whose check fa iled, and for which the Inline aspect is False. 
Any assignment that occurred outside of such  abort-deferred operati ons or independent 
subprograms can be disrupted by the raising of the exception, causing the object or its parts to 
become abnormal, and certain subsequent uses of  the object to be erroneous, as explained in 
13.9.1.  
NOTES 
5  The permissions granted by this subclause can have an effect on the semantics of a program only if the program fails a language-defined check.  1/3 
2/3 
3/3 
4 
5 
6/3 
7/3 

Ada Reference Manual — 2012 Edition 
277      13 December 2012 Generic Units   12 12   Generic Units 
A generic unit  is a program unit that is either a generic s ubprogram or a generic package. A generic unit is 
a template , which can be parameterized, and from wh ich corresponding (nongeneric) subprograms or 
packages can be obtained. The resu lting program units are said to be instances  of the original generic unit.  
A generic unit is declared by a generic_declaration . This form of declaration has a generic_formal_part  
declaring any generic formal parameters. An instance of a generic unit is obtained as the result of a 
generic_instantiation  with appropriate generic actual parameters  for the generic formal parameters. An 
instance of a generic subprogram is  a subprogram. An instance of a generic package is a package. 
Generic units are templates. As templates they do not have the properties that are specific to their 
nongeneric counterparts. For example, a generic subprogram can be instantiated but it cannot be called. In 
contrast, an instance of a generic subprogram is a (nongeneric) subprogram; hen ce, this instance can be 
called but it cannot be used to produce further instances.  
12.1 Generic Declarations 
A generic_declaration  declares a generic unit, which is either a generic subprogram or a generic package. 
A generic_declaration  includes a generic_formal_part  declaring any generic formal parameters. A 
generic formal parameter can be an object; alternativ ely (unlike a parameter of a subprogram), it can be a 
type, a subprogram, or a package.  
Syntax 
generic_declaration ::= generic_subprogram_declaration  | generic_package_declaration  
generic_subprogram_declaration ::=  
     generic_formal_part   subprogram_specification  
        [ aspect_specification ]; 
generic_package_declaration ::=  
     generic_formal_part   package_specification ; 
generic_formal_part ::= generic  {generic_formal_parameter_declaration  | use_clause } 
generic_formal_parameter_declaration ::=  
      formal_object_declaration  
    | formal_type_declaration  
    | formal_subprogram_declaration  
    | formal_package_declaration  
The only form of subtype_indication  allowed within a generic_formal_part  is a subtype_mark  (that 
is, the subtype_indication  shall not include an explicit constraint ). The defining name of a generic 
subprogram shall be an identifier  (not an operator_symbol ).  
Static Semantics 
A generic_declaration  declares a generic unit — a generic package, generic procedure, or generic 
function, as appropriate. 
An entity is a generic formal  entity if it is declared by a generic_formal_parameter_declaration . “Generic 
formal,” or simply “formal,” is used as a prefix in referring to objects, subtypes (and types), functions, 
procedures and packages, that are generic formal en tities, as well as to their respective declarations. 
Examples: “generic formal procedure” or a “formal integer type declaration.”  1 
2 
3 
1 
2 
3/3 
4 
5 
6 
7 
8/2 
9 
Ada Reference Manual — 2012 Edition 
12.1    Generic Declarations 13 December 2012      278 Dynamic Semantics 
The elaboration of a generic_declaration  has no effect.  
NOTES 
1  Outside a generic unit a name  that denotes the generic_declaration  denotes the generic unit. In contrast, within the 
declarative region of the generic unit, a name  that denotes the generic_declaration  denotes the current instance.  
2  Within a generic subprogram_body , the name of this program unit acts as the name of a subprogram. Hence this name 
can be overloaded, and it can appear in a recursive call of the current instance. For the same reason, this name cannot appear after the reserved word new in a (recursive) 
generic_instantiation . 
3  A default_expression  or default_name  appearing in a generic_formal_part  is not evaluated during elaboration of the 
generic_formal_part ; instead, it is evaluated when used. (The usual visibility rules apply to any name  used in a default: 
the denoted declaration therefore has to be visible at the place of the expression.)  
Examples 
Examples of generic formal parts:   
generic     --   parameterless  
generic 
   Size : Natural;  --   formal object  
generic 
   Length : Integer := 200;          --  formal object with a default expression  
   Area   : Integer := Length*Length; --  formal object with a default expression  
generic 
   type Item  is private;                       --  formal type  
   type Index is (<>);                          --  formal type  
   type Row   is array(Index range <>) of Item; --  formal type  
   with function  "<"(X, Y : Item) return Boolean;    --  formal subprogram  
Examples of generic declarations decl aring generic subprograms Exchange and Squaring:   
generic 
   type Elem is private; 
procedure  Exchange(U, V : in out Elem); 
generic 
   type Item is private; 
   with function  "*"(U, V : Item) return Item is <>; 
function  Squaring(X : Item) return Item; 
Example of a generic declarati on declaring a generic package:   
generic 
   type Item   is private; 
   type Vector is array (Positive range <>) of Item; 
   with function  Sum(X, Y : Item) return Item; 
package On_Vectors is 
   function  Sum  (A, B : Vector) return Vector; 
   function  Sigma(A    : Vector) return Item; 
   Length_Error : exception ; 
end On_Vectors; 10 
11 
12 
13 
14 
15 
16 
17 18 
19 
20 
21 
22 
23 
24 
Ada Reference Manual — 2012 Edition 
279      13 December 2012 Generic Bodies   12.2 12.2 Generic Bodies 
The body of a generic unit (a generic body ) is a template for the instance bodies. The syntax of a generic 
body is identical to that of a nongeneric body.  
Dynamic Semantics 
The elaboration of a generic body has no other effect th an to establish that the generic unit can from then 
on be instantiated without failing the Elaboration_Ch eck. If the generic body is a child of a generic 
package, then its elaboration esta blishes that each corresponding declara tion nested in an instance of the 
parent (see 10.1.1) can from then on be instan tiated without failing the Elaboration_Check.  
NOTES 
4  The syntax of generic subprograms implies that a generic subprogram body is always the completion of a declaration.  
Examples 
Example of a generic procedure body:   
procedure  Exchange(U, V : in out Elem) is  --  see 12.1 
   T : Elem;  --   the generic formal type  
begin 
   T := U;    U := V;    V := T; end Exchange; 
Example of a generic function body:   
function  Squaring(X : Item) return Item is  --   see 12.1 
begin 
   return X*X;  --   the formal operator "*"  
end Squaring; 
Example of a generic package body:   
package body On_Vectors is  --   see 12.1 
   function  Sum(A, B : Vector) return Vector is 
      Result : Vector(A'Range); --   the formal type Vector  
      Bias   : constant  Integer := B'First - A'First; 
   begin 
      if A'Length /= B'Length then 
         raise Length_Error; 
      end if; 
      for N in A'Range loop 
         Result(N) := Sum(A(N), B(N + Bias)); --  the formal function Sum  
      end loop; 
      return Result; 
   end Sum; 
   function  Sigma(A : Vector) return Item is 
      Total : Item := A(A'First); --   the formal type Item  
   begin 
      for N in A'First + 1 .. A'Last loop 
         Total := Sum(Total, A(N)); --   the formal function Sum  
      end loop; 
      return Total; 
   end Sigma; 
end On_Vectors; 1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
12.3    Generic Instantiation 13 December 2012      280 12.3 Generic Instantiation 
An instance of a generic unit is declared by a generic_instantiation .  
Syntax 
generic_instantiation ::=  
     package  defining_program_unit_name  is 
         new generic_package_ name  [generic_actual_part ] 
            [ aspect_specification ]; 
   | [overriding_indicator ] 
     procedure  defining_program_unit_name  is 
         new generic_procedure_ name  [generic_actual_part ] 
            [ aspect_specification ]; 
   | [overriding_indicator ] 
     function  defining_designator  is 
         new generic_function_ name  [generic_actual_part ] 
            [ aspect_specification ]; 
generic_actual_part ::=  
   (generic_association  {, generic_association }) 
generic_association ::=  
   [generic_formal_parameter_ selector_name  =>] explicit_generic_actual_parameter  
explicit_generic_actual_parameter ::= expression  | variable_ name  
   | subprogram_ name  | entry_ name  | subtype_mark  
   | package_instance_ name  
A generic_association  is named  or positional  according to whether or not the generic_formal_-
parameter_ selector_name  is specified. Any positional associations shall precede any named 
associations.  
The generic actual parameter  is either the explicit_generic_actual_parameter  given in a generic_-
association  for each formal, or the corresponding default_expression  or default_name  if no generic_-
association  is given for the formal. When the meaning is clear from context, the term “generic actual,” or 
simply “actual,” is used as a synonym for “generic act ual parameter” and also for the view denoted by one, 
or the value of one.  
Legality Rules 
In a generic_instantiation  for a particular kind of program unit (package, procedure, or function), the 
name  shall denote a generic unit of the corresponding ki nd (generic package, generic procedure, or 
generic function, respectively). 
The generic_formal_parameter_ selector_name  of a named generic_association  shall denote a 
generic_formal_parameter_declaration  of the generic unit being instantiated. If two or more formal 
subprograms have the same defining name, then named associations ar e not allowed for the corresponding 
actuals. 
The generic_formal_parameter_declaration  for a positional generic_association  is the parameter with 
the corresponding position in the generic_formal_part  of the generic unit being instantiated. 
A generic_instantiation  shall contain at most one generic_association  for each formal. Each formal 
without an association shall have a default_expression  or subprogram_default . 1 
2/3 
3 
4 5 
6 
7/3 
8 
9/3 
9.1/3 
10 
Ada Reference Manual — 2012 Edition 
281      13 December 2012 Generic Instantiation   12.3 In a generic unit Legality Rules are enforced at compile time of the generic_declaration  and generic body, 
given the properties of the formals. In the visible part  and formal part of an instance, Legality Rules are 
enforced at compile time of the generic_instantiation , given the properties of the actuals. In other parts of 
an instance, Legality Rules are not enforced; this rule  does not apply when a given rule explicitly specifies 
otherwise.  
Static Semantics 
A generic_instantiation  declares an instance; it is equivalent to the instance declaration (a package_-
declaration  or subprogram_declaration ) immediately followed by the instance body, both at the place of 
the instantiation.  
The instance is a copy of the text of the template. Each use of a formal parameter becomes (in the copy) a 
use of the actual, as explained below. An instance of  a generic package is a package, that of a generic 
procedure is a procedure, and that of a generic function is a function.  
The interpretation of each construct within a gene ric declaration or body is determined using the 
overloading rules when that generic declaration or body is compiled. In an instance, the interpretation of 
each (copied) construct is the same, except in the case of a name that denotes the generic_declaration  or 
some declaration within the generic unit; the co rresponding name in the instance then denotes the 
corresponding copy of the denoted declaration. The overloading rules do not apply in the instance.  
In an instance, a generic_formal_parameter_declaration  declares a view whose properties are identical to 
those of the actual, except as specified in 12.4,  “Formal Objects” and 12. 6, “Formal Subprograms”. 
Similarly, for a declaration within a generic_formal_parameter_declaration , the corresponding 
declaration in an instance declares  a view whose properties are identi cal to the corresponding declaration 
within the declaration of the actual.  
Implicit declarations are also copied, and a name that denotes an implicit declaration in the generic 
denotes the corresponding copy in the instance. However, for a type declared within the visible part of the 
generic, a whole new set of primitive subprograms is im plicitly declared for use outside the instance, and 
may differ from the copied set if the properties of th e type in some way depend on the properties of some 
actual type specified in the instantiation. For example, if the type in the generic is derived from a formal private type, then in the instance the type will inherit subprograms from the corresponding actual type. 
These new implicit declarations occur immediately afte r the type declaration in the instance, and override 
the copied ones. The copied ones can be called only from within the instance; the new ones can be called 
only from outside the instance, alt hough for tagged types, the body of a new one can be executed by a call 
to an old one.  
In the visible part of an instance, an explicit decl aration overrides an implicit declaration if they are 
homographs, as described in 8.3. On  the other hand, an explicit declaration in the private part of an 
instance overrides an implicit declaration in the inst ance, only if the corresponding explicit declaration in 
the generic overrides a corresponding implicit declarati on in the generic. Corresponding rules apply to the 
other kinds of overriding described in 8.3.  
Post-Compilation Rules 
Recursive generic instantiation is not allowed in the following sense: if a given generic unit includes an 
instantiation of a second generic unit, then the instance generated by this instantiation shall not include an 
instance of the first generic unit (wheth er this instance is generated directly, or indirectly by intermediate 
instantiations).  11 
12 
13 
14 
15 
16 
17 
18 
19 
Ada Reference Manual — 2012 Edition 
12.3    Generic Instantiation 13 December 2012      282 Dynamic Semantics 
For the elaboration of a generic_instantiation , each generic_association  is first evaluated. If a default is 
used, an implicit generic_association  is assumed for this rule. These ev aluations are done in an arbitrary 
order, except that the evaluation for a default actual takes place after the evaluation for another actual if 
the default includes a name  that denotes the other one. Finally, the instance declaration and body are 
elaborated.  
For the evaluation of a generic_association  the generic actual parameter is  evaluated. Additional actions 
are performed in the case of a formal object of mode in (see 12.4).  
NOTES 
5  If a formal type is not tagged, then the type is treated as an untagged type within the generic body. Deriving from such a type in a generic body is permitted; the new type does not get a new tag value, even if the actual is tagged. Overriding operations for such a derived type cannot be dispatched to from outside the instance.  
Examples 
Examples of generic instantiations (see 12.1):   
procedure  Swap is new Exchange(Elem => Integer); 
procedure  Swap is new Exchange(Character);   --   Swap is overloaded  
function  Square is new Squaring(Integer);  --   "*" of Integer used by default  
function  Square is new Squaring(Item => Matrix, "*" => Matrix_Product); 
function  Square is new Squaring(Matrix, Matrix_Product); --  same as previous     
package Int_Vectors is new On_Vectors(Integer, Table, "+"); 
Examples of uses of  instantiated units:   
Swap(A, B); 
A := Square(A); 
T : Table(1 .. 5) := (10, 20, 30, 40, 50); 
N : Integer := Int_Vectors.Sigma(T);  --   150 (see 12.2, “Generic Bodies” for the body of 
Sigma) 
use Int_Vectors; 
M : Integer := Sigma(T);  --   150 
12.4 Formal Objects 
A generic formal object can be used to pass a value or variable to a generic unit.  
Syntax 
formal_object_declaration ::=  
    defining_identifier_list  : mode  [null_exclusion ] subtype_mark  [:= default_expression ] 
        [ aspect_specification ]; 
  |  defining_identifier_list  : mode  access_definition  [:= default_expression ] 
        [ aspect_specification ]; 
Name Resolution Rules 
The expected type for the default_expression , if any, of a formal object is the type of the formal object. 
For a generic formal object of mode in, the expected type for the actual is the type of the formal. 
For a generic formal object of mode in out , the type of the actual shall resolve to the type determined by 
the subtype_mark , or for a formal_object_declaration  with an access_definition , to a specific anonymous 
access type. If the anonymous access type is an access-to- object type, the type of the actual shall have the 
same designated type as that of the access_definition . If the anonymous access type is an access-to-20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
1 
2/3 
3 
4 
5/2 
Ada Reference Manual — 2012 Edition 
283      13 December 2012 Formal Objects   12.4 subprogram type, the type of the actual shall have a de signated profile which is type conformant with that 
of the access_definition .  
Legality Rules 
If a generic formal object has a default_expression , then the mode shall be in (either explicitly or by 
default); otherwise, its mode shall be either in or in out .  
For a generic formal object of mode in, the actual shall be an expression . For a generic formal object of 
mode in out , the actual shall be a name  that denotes a variable for whic h renaming is allowed (see 8.5.1).  
In the case where the type of the formal is defined by an access_definition , the type of the actual and the 
type of the formal: 
• shall both be access-to-object types with stati cally matching designated subtypes and with both 
or neither being access-to-constant types; or  
• shall both be access-to-subprogram types with subtype conformant designated profiles.  
For a formal_object_declaration  with a null_exclusion  or an access_definition  that has a null_exclusion : 
• if the actual matching the formal_object_declaration  denotes the generic formal object of 
another generic unit G, and the instantiation containing the actual occurs within the body of G or 
within the body of a generic unit declar ed within the declarative region of G, then the 
declaration of the formal object of G shall have a null_exclusion ; 
• otherwise, the subtype of the actual matching the formal_object_declaration  shall exclude null. 
In addition to the places where Legality Rules norma lly apply (see 12.3), this rule applies also in 
the private part of an instance of a generic unit. 
Static Semantics 
A formal_object_declaration  declares a generic formal object. The default mode is in. For a formal object 
of mode in, the nominal subtype is the one denoted by the subtype_mark  or access_definition  in the 
declaration of the formal. For a formal object of mode in out , its type is determined by the subtype_mark  
or access_definition  in the declaration; its nominal subtype is nonstatic, even if the subtype_mark  
denotes a static subtype; for a com posite type, its nominal subtype is unc onstrained if the first subtype of 
the type is unconstrained, even if the subtype_mark  denotes a constrained subtype.  
In an instance, a formal_object_declaration  of mode in is a full constant declaration  and declares a new 
stand-alone constant object whose initializa tion expression is the actual, whereas a 
formal_object_declaration  of mode in out  declares a view whose propertie s are identical to those of the 
actual.  
Dynamic Semantics 
For the evaluation of a generic_association  for a formal object of mode in, a constant object is created, 
the value of the actual parameter is converted to the nominal subtype of the formal object, and assigned to 
the object, including any value adjustment — see 7.6.  
NOTES 
6  The constraints that apply to a generic formal object of mode in out  are those of the corresponding generic actual 
parameter (not those implied by the subtype_mark  that appears in the formal_object_declaration ). Therefore, to avoid 
confusion, it is recommended that the name of a first subtype be used for the declaration of such a formal object.  6 
7 
8/2 
8.1/2 
8.2/2 
8.3/2 
8.4/2 
8.5/2 
9/2 
10/2 
11 
12 
Ada Reference Manual — 2012 Edition 
12.5    Formal Types 13 December 2012      284 12.5 Formal Types 
A generic formal subtype can be used to pass to a generic unit a subtype whos e type is in a certain 
category of types.  
Syntax 
formal_type_declaration ::=  
      formal_complete_type_declaration  
    | formal_incomplete_type_declaration  
formal_complete_type_declaration ::=  
    type defining_identifier [discriminant_part ] is formal_type_definition  
        [ aspect_specification ]; 
formal_incomplete_type_declaration ::=  
    type defining_identifier [discriminant_part ] [is tagged ]; 
formal_type_definition ::=  
      formal_private_type_definition  
    | formal_derived_type_definition  
    | formal_discrete_type_definition  
    | formal_signed_integer_type_definition  
    | formal_modular_type_definition  
    | formal_floating_point_definition  
    | formal_ordinary_fixed_point_definition  
    | formal_decimal_fixed_point_definition  
    | formal_array_type_definition  
    | formal_access_type_definition  
    | formal_interface_type_definition  
Legality Rules 
For a generic formal subtype, the actual shall be a subtype_mark ; it denotes the (generic) actual subtype .  
Static Semantics 
A formal_type_declaration  declares a (generic) formal type , and its first subtype, the (generic) formal 
subtype .  
The form of a formal_type_definition  determines a category (of types)  to which the formal type belongs. 
For a formal_private_type_definition  the reserved words tagged  and limited  indicate the category of types 
(see 12.5.1). The reserved word tagged  also plays this role in the case of a 
formal_incomplete_type_declaration . For a formal_derived_type_definition  the category of types is the 
derivation class rooted at the ancestor type. For othe r formal types, the name of the syntactic category 
indicates the category of types; a formal_discrete_type_definition  defines a discrete type, and so on.  
Legality Rules 
The actual type shall be in the category determined for the formal.  
Static Semantics 
The formal type also belongs to each category that  contains the determined category. The primitive 
subprograms of the type are as for any type in the de termined category. For a formal type other than a 
formal derived type, these are the predefined operators  of the type. For an elementary formal type, the 
predefined operators are implicitly declared immediat ely after the declaration of the formal type. For a 1/2 
2/3 
2.1/3 
2.2/3 
3/2 
4 
5 
6/3 
7/2 
8/3 
Ada Reference Manual — 2012 Edition 
285      13 December 2012 Formal Types   12.5 composite formal type, the predefined operators ar e implicitly declared either immediately after the 
declaration of the formal type, or later immediately within the declarative region in which the type is 
declared according to the rules of 7.3.1. In an instance,  the copy of such an implicit declaration declares a 
view of the predefined operator of the actual type, ev en if this operator has been overridden for the actual 
type and even if it is never declared for the actual type. The rules specific to formal derived types are given in 12.5.1.  
NOTES 
7  Generic formal types, like all types, are not named. Instead, a name  can denote a generic formal subtype. Within a 
generic unit, a generic formal type is considered as being distinct from all other (formal or nonformal) types.  
8  A discriminant_part  is allowed only for certain kinds of types, and therefore only for certain kinds of generic formal 
types. See 3.7.  
Examples 
Examples of generic formal types:   
type Item is private; 
type Buffer(Length : Natural) is limited private; 
type Enum  is (<>); 
type Int   is range <>; 
type Angle is delta <>; 
type Mass  is digits <>; 
type Table is array (Enum) of Item; 
Example of a generic formal part declaring a formal integer type:   
generic 
   type Rank is range <>; 
   First  : Rank := Rank'First;    Second : Rank := First + 1;  --   the operator "+" of the type Rank   
12.5.1 Formal Private and Derived Types 
In its most general form, the categor y determined for a formal private type is all types, but the category 
can be restricted to only nonlimited types or to only tagged types. Similarly, the category for a formal 
incomplete type is all types but the category can be restricted to only tagged types; unlike other formal 
types, the actual type does not need to be able to  be frozen (see 13.14). The category determined for a 
formal derived type is the derivation class rooted at the ancestor type.  
Syntax 
formal_private_type_definition ::= [[abstract ] tagged ] [limited ] private  
formal_derived_type_definition ::=  
     [abstract ] [limited  | synchronized ] new subtype_mark  [[and interface_list ]with  private ] 
Legality Rules 
If a generic formal type declaration has a known_discriminant_part , then it shall not include a 
default_expression  for a discriminant.  
The ancestor subtype  of a formal derived type is the subtype denoted by the subtype_mark  of the 
formal_derived_type_definition . For a formal derived type declaration, the reserved words with private  
shall appear if and only if the ancestor type is a ta gged type; in this case the formal derived type is a 
private extension of the ancestor type and the ancestor shall not be a class-wide type. Similarly, an 
interface_list  or the optional reserved words abstract  or synchronized  shall appear only if the ancestor 
type is a tagged type. The reserved word limited  or synchronized  shall appear only if the ancestor type 9 
10 
11 
12 
13 
14 
15 
16 
1/3 
2 
3/2 
4 
5/3 
Ada Reference Manual — 2012 Edition 
12.5.1    Formal Private and Derive d Types 13 December 2012      286 and any progenitor types are limited types. The reserved word synchronized  shall appear (rather than 
limited ) if the ancestor type or any of the progenitor types are synchronized interfaces. The ancestor type 
shall be a limited interface if the reserved word synchronized  appears. 
The actual type for a formal derived type shall be a descendant of the ancestor type and every progenitor 
of the formal type. If the formal type is nonlimited,  the actual type shall be nonlimited. If the reserved 
word synchronized  appears in the declaration of the formal derived type, the actual type shall be a 
synchronized tagged type.  
If a formal private or derived subtype is definite, then the actual subtype shall also be definite.  
A formal_incomplete_type_declaration  declares a formal incomplete type. The only view of a formal 
incomplete type is an incomplete view. Thus, a formal incomplete type is subject to the same usage 
restrictions as any other incomplete type — see 3.10.1. 
For a generic formal derived type with no discriminant_part :  
• If the ancestor subtype is constrained, the actua l subtype shall be constrained, and shall be 
statically compatible with the ancestor;  
• If the ancestor subtype is an unconstrained access or composite subtype, the actual subtype shall 
be unconstrained.  
• If the ancestor subtype is an unconstrained discri minated subtype, then the actual shall have the 
same number of discriminants, and each disc riminant of the actual shall correspond to a 
discriminant of the ancestor, in the sense of 3.7. 
• If the ancestor subtype is an access subtype, the actual subtype shall exclude null if and only if 
the ancestor subtype excludes null.  
The declaration of a formal derived type shall not have a known_discriminant_part . For a generic formal 
private or incomplete type with a known_discriminant_part :  
• The actual type shall be a type with  the same number of discriminants. 
• The actual subtype shall be unconstrained. 
• The subtype of each discriminant of the actual type shall statically match the subtype of the 
corresponding discriminant of the formal type.  
For a generic formal type with an unknown_discriminant_part , the actual may, but need not, have 
discriminants, and may be definite or indefinite. 
Static Semantics 
The category determined for a formal private type is as follows:  
Type Definition   Determined Category  
 limited private   the category of all types 
private   the category of all nonlimited types 
tagged limited private   the category of all tagged types 
tagged private   the category of all nonlimited tagged types 
The presence of the reserved word abstract  determines whether the actual type may be abstract. 
The category determined for a formal incomplete type is the category of all types, unless the 
formal_type_declaration  includes the reserved word tagged ; in this case, it is the category of all tagged 
types. 5.1/3 
6/3 
6.1/3 
7 
8 
9 
10 
10.1/2 
11/3 
12 
13 14 
15 
16/2 
17/2 
18 
18.1/3 
Ada Reference Manual — 2012 Edition 
287      13 December 2012 Formal Private and Derived Types   12.5.1 A formal private or derived type is a private or deri ved type, respectively. A formal derived tagged type is 
a private extension. A formal private or derived type is abstract if the reserved word abstract  appears in its 
declaration. 
For a formal derived type, the characteristics (incl uding components, but excludi ng discriminants if there 
is a new discriminant_part ), predefined operators, and inherite d user-defined primitive subprograms are 
determined by its ancestor type and its progenitor type s (if any), in the same way that those of a derived 
type are determined by those of its parent ty pe and its progenitor types (see 3.4 and 7.3.1). 
In an instance, the copy of an implicit declarati on of a primitive subprogram of a formal derived type 
declares a view of the corresponding primitive subprogr am of the ancestor or progenitor of the formal 
derived type, even if this primitive has been overridden for the actual type and even if it is never declared 
for the actual type. When the ancestor or progenitor of the formal derived type is itself a formal type, the 
copy of the implicit declaration d eclares a view of the corresponding c opied operation of the ancestor or 
progenitor. In the case of a formal private extension, however, the tag of the formal type is that of the 
actual type, so if the tag in a call is statically determ ined to be that of the formal type, the body executed 
will be that corresponding to the actual type.  
For a prefix  S that denotes a formal indefinite subt ype, the following attribute is defined:  
S'Definite S'Definite yields True if the actual subtype corresponding to S is definite; otherwise, it 
yields False. The value of this attribut e is of the predefined type Boolean.  
Dynamic Semantics 
In the case where a formal type has unknown discrimina nts, and the actual type is a class-wide type 
T'Class: 
• For the purposes of defining the primitive operati ons of the formal type, each of the primitive 
operations of the actual type is considered to be a subprogram (with an intrinsic calling 
convention — see 6.3.1) whose body consists  of a dispatching call upon the corresponding 
operation of T, with its formal parameters as the actua l parameters. If it is a function, the result 
of the dispatching call is returned. 
• If the corresponding operation of T has no controlling formal parame ters, then the controlling tag 
value is determined by the context of the call, according to the rules for tag-indeterminate calls 
(see 3.9.2 and 5.2). In the case where the tag would be statically determined to be that of the 
formal type, the call raises Program_Error. If such a function is renamed, any call on the 
renaming raises Program_Error.  
NOTES 
9  In accordance with the general rule that the actual type shall be long to the category determined  for the formal (see 12.5, 
“Formal Types”):  
• If the formal type is nonlimited, then so shall be the actual; 
• For a formal derived type, the actual shall be in the class rooted at the ancestor subtype.  
10  The actual type can be abstract only if the formal type is abstract (see 3.9.3).  
11  If the formal has a discriminant_part , the actual can be either definite or indefinite. Otherwise, the actual has to be 
definite.  19 
20/3 
21/3 
22/1 
23/3 
23.1/3 
23.2/2 
23.3/2 
24/2 
25 
26 27 
28 
Ada Reference Manual — 2012 Edition 
12.5.2    Formal Scalar Types 13 December 2012      288 12.5.2 Formal Scalar Types 
A formal scalar type  is one defined by any of the formal_type_definition s in this subclause. The category 
determined for a formal scalar type  is the category of all discrete, si gned integer, modular, floating point, 
ordinary fixed point, or decimal types.  
Syntax 
formal_discrete_type_definition ::= (<>) 
formal_signed_integer_type_definition ::= range  <> 
formal_modular_type_definition ::= mod  <> 
formal_floating_point_definition ::= digits  <> 
formal_ordinary_fixed_point_definition ::= delta  <> 
formal_decimal_fixed_point_definition ::= delta  <> digits  <> 
Legality Rules 
The actual type for a formal scalar type shall not be a nonstandard numeric type.  
NOTES 
12  The actual type shall be in the class of types implied by the syntactic category of the formal type definition (see 12.5, “Formal Types”). For example, the actual for a 
formal_modular_type_definition  shall be a modular type.  
12.5.3 Formal Array Types 
The category determined for a formal array type is the category of all array types.  
Syntax 
formal_array_type_definition ::= array_type_definition  
Legality Rules 
The only form of discrete_subtype_definition  that is allowed within the declaration of a generic formal 
(constrained) array subtype is a subtype_mark .  
For a formal array subtype, the actual subt ype shall satisfy the following conditions:  
• The formal array type and the actual array type  shall have the same dimensionality; the formal 
subtype and the actual subtype shall be eith er both constrained or both unconstrained. 
• For each index position, the index types sha ll be the same, and the index subtypes (if 
unconstrained), or the index ranges (if constrai ned), shall statically match (see 4.9.1).  
• The component subtypes of th e formal and actual array types shall statically match.  
• If the formal type has aliased com ponents, then so shall the actual.  
Examples 
Example of formal array types:   
--  given the generic package  1/2 
2 
3 4 5 6 7 
8 
9 
1/2 
2 
3 
4 
5 
6 7 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
289      13 December 2012 Formal Array Types   12.5.3 generic 
   type Item   is private; 
   type Index  is (<>); 
   type Vector is array (Index range <>) of Item; 
   type Table  is array (Index) of Item; 
package P is 
   ... end P; 
--  and the types  
type Mix    is array (Color range <>) of Boolean; 
type Option is array (Color) of Boolean; 
--  then Mix can match Vector and Option can match Table  
package R is new P(Item   => Boolean, Index => Color, 
                   Vector => Mix,     Table => Option); 
--  Note that Mix cannot match Table and Option cannot match Vector  
12.5.4 Formal Access Types 
The category determined for a formal access type is the category of all access types.  
Syntax 
formal_access_type_definition ::= access_type_definition  
Legality Rules 
For a formal access-to-object type, the designated subtypes of the formal and actual types shall statically 
match.  
If and only if the general_access_modifier  constant  applies to the formal, the actual shall be an access-
to-constant type. If the general_access_modifier  all applies to the formal, then the actual shall be a 
general access-to-variable type (see 3.10). If and only if the formal subtype excludes null, the actual subtype shall exclude null.  
For a formal access-to-subprogram subtype, the designate d profiles of the formal and the actual shall be 
subtype conformant.  
Examples 
Example of formal access types:   
--  the formal types of the generic package  
generic 
   type Node is private; 
   type Link is access Node; 
package P is 
   ... end P; 
--  can be matched by the actual types  
type Car; 
type Car_Name is access Car; 
type Car is 
   record 
      Pred, Succ : Car_Name;       Number     : License_Number;       Owner      : Person;    end record; 
--  in the following generic instantiation  11 
12 
13 
14 
15 
16 
1/2 
2 
3 
4/2 
5/3 
6 
7 
8 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
12.5.4    Formal Access Types 13 December 2012      290 package R is new P(Node => Car, Link => Car_Name); 
12.5.5 Formal Interface Types 
The category determined for a formal interface ty pe is the category of all interface types.  
Syntax 
formal_interface_type_definition ::= interface_type_definition  
Legality Rules 
The actual type shall be a descendant of  every progenitor of the formal type. 
The actual type shall be a limited, task, protected, or synchronized interface if and only if the formal type 
is also, respectively, a limited, task, protected, or synchronized interface.  
Examples 
type Root_Work_Item is tagged private ; 
generic 
   type Managed_Task is task interface ; 
   type Work_Item(<>) is new Root_Work_Item with private ; 
package Server_Manager is 
   task type  Server is new Managed_Task with 
      entry Start(Data : in out Work_Item); 
   end Server; 
end Server_Manager; 
This generic allows an application to establish a standa rd interface that all tasks need to implement so they 
can be managed appropriately by an application-specific scheduler. 
12.6 Formal Subprograms 
Formal subprograms can be used to pass callable entities to a generic unit.  
Syntax 
formal_subprogram_declaration ::= formal_concrete_subprogram_declaration  
    | formal_abstract_subprogram_declaration  
formal_concrete_subprogram_declaration ::=  
     with  subprogram_specification  [is subprogram_default ] 
        [ aspect_specification ]; 
formal_abstract_subprogram_declaration ::=  
     with  subprogram_specification  is abstract  [subprogram_default ] 
        [ aspect_specification ]; 
subprogram_default ::= default_name  | <> | null 
default_name ::= name  
A subprogram_default  of null shall not be specified for a formal function or for a 
formal_abstract_subprogram_declaration .  
Name Resolution Rules 
The expected profile for the default_name , if any, is that of the formal subprogram.  
For a generic formal subprogram, the expected profile for the actual is that of the formal subprogram.  13 
1/2 
2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
1 
2/2 
2.1/3 
2.2/3 
3/2 
4 
4.1/2 
5 
6 
Ada Reference Manual — 2012 Edition 
291      13 December 2012 Formal Subprograms   12.6 Legality Rules 
The profiles of the formal and any name d default shall be mode conformant.  
The profiles of the formal and actual shall be mode conformant.  For a parameter or result subtype of a 
formal_subprogram_declaration  that has an explicit null_exclusion : 
• if the actual matching the formal_subprogram_declaration  denotes a generic formal object of 
another generic unit G, and the instantiation containing the act ual that occurs within the body of 
a generic unit G or within the body of a generic unit decl ared within the declarative region of the 
generic unit G, then the corresponding parameter or resu lt type of the formal subprogram of G 
shall have a null_exclusion ; 
• otherwise, the subtype of the corresponding para meter or result type of the actual matching the 
formal_subprogram_declaration  shall exclude null. In addition to the places where Legality 
Rules normally apply (see 12.3), this rule applies also in the private part of an instance of a 
generic unit.  
If a formal parameter of a formal_abstract_subprogram_declaration  is of a specific tagged type T or of 
an anonymous access type designating a specific tagged type T, T is called a controlling type  of the 
formal_abstract_subprogram_declaration . Similarly, if the result of a formal_abstract_subprogram_-
declaration  for a function is of a specific tagged type T or of an anonymous access type designating a 
specific tagged type T, T is called a controlling type of the formal_abstract_subprogram_declaration . A 
formal_abstract_subprogram_declaration  shall have exactly one controlling type, and that type shall not 
be incomplete.  
The actual subprogram for a formal_abstract_subprogram_declaration  shall be a dispatching operation of 
the controlling type or of the actual type corresponding to the controlling type. 
Static Semantics 
A formal_subprogram_declaration  declares a generic formal subpr ogram. The types of the formal 
parameters and result, if any, of the form al subprogram are thos e determined by the subtype_mark s given 
in the formal_subprogram_declaration ; however, independent of the partic ular subtypes that are denoted 
by the subtype_mark s, the nominal subtypes of the formal parame ters and result, if any, are defined to be 
nonstatic, and unconstrained if of an array type (no a pplicable index constraint is provided in a call on a 
formal subprogram). In an instance, a formal_subprogram_declaration  declares a view of the actual. The 
profile of this view takes its subtypes and calling c onvention from the original profile of the actual entity, 
while taking the formal parameter name s and default_expression s from the profile given in the formal_-
subprogram_declaration . The view is a function or procedure, never an entry.  
If a subtype_mark  in the profile of the formal_subprogram_declaration  denotes a formal private or 
formal derived type and the actual type for this formal type is a class-wide type T'Class, then for the 
purposes of resolving the corresponding actual subprogram at the point of the instantiation, certain implicit 
declarations may be available as possible resolutions as follows: 
For each primitive subprogram of T that is directly visible at the point of the instantiation, and 
that has at least one controlling formal pa rameter, a corresponding implicitly declared 
subprogram with the same defining name, and having the same profile as the primitive subprogram except that T is systematically replaced by T'Class in the types of its profile, is 
potentially use-visible. The body of such a s ubprogram is as defined in 12.5.1 for primitive 
subprograms of a formal type when the actual type is class-wide.  7/3 
8/3 
8.1/2 
8.2/2 
8.3/2 
8.4/3 
8.5/2 
9 
9.1/3 
9.2/3 
Ada Reference Manual — 2012 Edition 
12.6    Formal Subprograms 13 December 2012      292 If a generic unit has a subprogram_default  specified by a box, and the corresponding actual parameter is 
omitted, then it is equivalent to an explicit actual para meter that is a usage name identical to the defining 
name of the formal. 
If a generic unit has a subprogram_default  specified by the reserved word null, and the corresponding 
actual parameter is omitted, then it is equivalent to an explicit actual parameter that is a null procedure 
having the profile given in the formal_subprogram_declaration . 
The subprogram declared by a formal_abstract_subprogram_declaration  with a controlling type T is a 
dispatching operation of type T.  
NOTES 
13  The matching rules for formal subprograms state requirements that are similar to those applying to 
subprogram_renaming_declaration s (see 8.5.4). In particular, the name of a parameter of the formal subprogram need not 
be the same as that of the corresponding parameter of the actual subprogram; similarly, for these parameters, 
default_expression s need not correspond. 
14  The constraints that apply to a parameter of a formal subprogram are those of the corresponding formal parameter of 
the matching actual subprogram (not those implied by the corresponding subtype_mark  in the _specification  of the formal 
subprogram). A similar remark applies to the result of a function. Therefore, to avoid confusion, it is recommended that the 
name  of a first subtype be used in any declaration of a formal subprogram. 
15  The subtype specified for a formal parameter of a generic formal subprogram can be any visible subtype, including a 
generic formal subtype of the same generic_formal_part . 
16  A formal subprogram is matched by an attribute of a type if the attribute is a function with a matching specification. 
An enumeration literal of a given type matches a parameterless formal function whose result type is the given type. 
17  A default_name  denotes an entity that is visible or directly visible at the place of the generic_declaration ; a box used 
as a default is equiva lent to a name that denotes  an entity that is directly  visible at th e place of the _instantiation .  
18  The actual subprogram cannot be abstract unless the formal subprogram is a formal_abstract_subprogram_-
declaration  (see 3.9.3). 
19  The subprogram declared by a formal_abstract_subprogram_declaration  is an abstract subprogram. All calls on a 
subprogram declared by a formal_abstract_subprogram_declaration  must be dispatching calls. See 3.9.3. 
20  A null procedure as a subprogram default has convention Intrinsic (see 6.3.1).  
Examples 
Examples of generic formal subprograms:   
with function  "+"(X, Y : Item) return Item is <>; 
with function  Image(X : Enum) return String is Enum'Image; 
with procedure  Update is Default_Update; 
with procedure  Pre_Action(X : in Item) is null;  --  defaults to no action  
with procedure  Write(S    : not null access  Root_Stream_Type'Class; 
                     Desc : Descriptor)                      is abstract  Descriptor'Write;  --  see 13.13.2  
-- Dispatching operation on De scriptor with default  
--  given the generic procedure declaration  
generic 
   with procedure  Action (X : in Item); 
procedure  Iterate(Seq : in Item_Sequence); 
--  and the procedure  
procedure  Put_Item(X : in Item); 
--  the following instantiation is possible  
procedure  Put_List is new Iterate(Action => Put_Item); 10 
10.1/2 
10.2/2 
11 
12 
13 
14 15 
16/2 
16.1/2 16.2/2 
17 
18/2 
19 
20 
21 
22 23 24 
Ada Reference Manual — 2012 Edition 
293      13 December 2012 Formal Packages   12.7 12.7 Formal Packages 
Formal packages can be used to pass packages to a generic unit. The formal_package_declaration  
declares that the formal package is an instance of a given generi c package. Upon instantiation, the actual 
package has to be an instance of that generic package.  
Syntax 
formal_package_declaration ::=  
    with  package  defining_identifier  is new generic_package_ name   formal_package_actual_part  
        [ aspect_specification ]; 
formal_package_actual_part ::=  
    ([others  =>] <>) 
  | [generic_actual_part ] 
  | (formal_package_association  {, formal_package_association } [, others  => <>]) 
formal_package_association ::=  
    generic_association  
  | generic_formal_parameter_ selector_name  => <> 
Any positional formal_package_association s shall precede any named 
formal_package_association s.  
Legality Rules 
The generic_package_ name  shall denote a generic package (the template  for the formal package); the 
formal package is an instance of the template. 
The generic_formal_parameter_ selector_name  of a formal_package_association  shall denote a 
generic_formal_parameter_declaration  of the template. If two or more formal subprograms of the 
template have the same defining name, then named associations ar e not allowed for the corresponding 
actuals. 
A formal_package_actual_part  shall contain at most one formal_package_association  for each formal 
parameter. If the formal_package_actual_part  does not include “ others  => <>”, each formal parameter 
without an association shall have a default_expression  or subprogram_default . 
The rules for matching between formal_package_association s and the generic formals of the template are 
as follows:  
• If all of the formal_package_association s are given by generic associations, the 
explicit_generic_actual_parameter s of the formal_package_association s shall be legal for an 
instantiation of the template. 
• If a formal_package_association  for a formal type T of the template is given by <>, then the 
formal_package_association  for any other generic_formal_parameter_declaration  of the 
template that mentions T directly or indirectly must be given by <> as well. 
The actual shall be an instance of the template. If the formal_package_actual_part  is (<>) or ( others  => 
<>), then the actual may be any instance of the template ; otherwise, certain of the actual parameters of the 
actual instance shall match the corresponding actual para meters of the formal p ackage, determined as 
follows: 
• If the formal_package_actual_part  includes generic_association s as well as associations with 
<>, then only the actual parameters specified explicitly with generic_association s are required 
to match; 1 
2/3 
3/2 
3.1/2 
3.2/2 
4 
4.1/3 
4.2/3 
4.3/3 
4.4/3 
4.5/3 
5/2 
5.1/2 
Ada Reference Manual — 2012 Edition 
12.7    Formal Packages 13 December 2012      294 • Otherwise, all actual parameters shall match, wh ether any actual parameter is given explicitly or 
by default.  
The rules for matching of actual parameters between the actual instance and the formal package are as 
follows: 
• For a formal object of mode in, the actuals match if they are static expressions with the same 
value, or if they statically denote the sa me constant, or if they are both the literal null.  
• For a formal subtype, the actuals match if  they denote statically matching subtypes.  
• For other kinds of formals, the actuals match if they statically denote the same entity.  
For the purposes of matching, any actual parameter that is the name of a formal object of mode in is 
replaced by the formal object's actual expression (recursively).  
Static Semantics 
A formal_package_declaration  declares a generic formal package. 
The visible part of a formal package includes the first list of basic_declarative_item s of the package_-
specification . In addition, for each actual parameter that is not  required to match, a copy of the declaration 
of the corresponding formal parameter of the template is included in the visible part of the formal package. 
If the copied declaration is for a formal type, c opies of the implicit declarations of the primitive 
subprograms of the formal type ar e also included in the visible part of the formal package. 
For the purposes of matching, if the actual instance A is itself a formal package, then the actual parameters 
of A are those specified explicitly or implicitly in the formal_package_actual_part  for A, plus, for those 
not specified, the copies of the formal parameters of the template included in the visible part of A. 
Examples 
Example of a generic package w ith formal package parameters:  
with Ada.Containers.Ordered_Maps;  --  see A.18.6 
generic 
   with package  Mapping_1 is new Ada.Containers.Ordered_Maps(<>); 
   with package  Mapping_2 is new Ada.Containers.Ordered_Maps 
                                    (Key_Type => Mapping_1.Element_Type,                                      others => <>); 
package Ordered_Join is 
   --  Provide a "join" between two mappings  
   subtype Key_Type is Mapping_1.Key_Type; 
   subtype Element_Type is Mapping_2.Element_Type; 
   function  Lookup(Key : Key_Type) return Element_Type; 
   ... 
end Ordered_Join; 
Example of an instantiation of a package with formal packages:  
with Ada.Containers.Ordered_Maps; 
package Symbol_Package is 
   type String_Id is ... 
   type Symbol_Info is ... 
   package String_Table is new Ada.Containers.Ordered_Maps 
           (Key_Type => String,             Element_Type => String_Id); 
   package Symbol_Table is new Ada.Containers.Ordered_Maps 
           (Key_Type => String_Id,             Element_Type => Symbol_Info); 5.2/2 
5.3/2 
6/2 
7 
8 
8.1/1 
9 
10/2 
11/2 
12/2 
13/2 
14/2 
15/2 
16/2 
17/2 
18/2 
19/2 
20/2 21/2 
22/2 
Ada Reference Manual — 2012 Edition 
295      13 December 2012 Formal Packages   12.7    package String_Info is new Ordered_Join(Mapping_1 => String_Table, 
                                           Mapping_2 => Symbol_Table); 
   Apple_Info : constant  Symbol_Info := String_Info.Lookup("Apple"); 
end Symbol_Package; 
12.8 Example of a Generic Package 
The following example provides a possible formulation of  stacks by means of a generic package. The size 
of each stack and the type of the stack elements are provided as generic formal parameters.  
Examples 
This paragraph was deleted.  
generic 
   Size : Positive;    type Item is private; 
package Stack is 
   procedure  Push(E : in  Item); 
   procedure  Pop (E : out Item); 
   Overflow, Underflow : exception ; 
end Stack; 
package body Stack is 
   type Table is array (Positive range <>) of Item; 
   Space : Table(1 .. Size);    Index : Natural := 0; 
   procedure  Push(E : in Item) is 
   begin 
      if Index >= Size then 
         raise Overflow; 
      end if; 
      Index := Index + 1;       Space(Index) := E;    end Push; 
   procedure  Pop(E : out Item) is 
   begin 
      if Index = 0 then 
         raise Underflow; 
      end if; 
      E := Space(Index);       Index := Index - 1;    end Pop; 
end Stack; 
Instances of this generic package can be obtained as follows:  
package Stack_Int  is new Stack(Size => 200, Item => Integer); 
package Stack_Bool is new Stack(100, Boolean); 
Thereafter, the procedures of the instantia ted packages can be called as follows:  
Stack_Int.Push(N); 
Stack_Bool.Push(True); 23/2 
24/2 
25/2 
1 
2/1 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
12.8    Example of a Generic Package 13 December 2012      296 Alternatively, a generic formulation of the type St ack can be given as follows (package body omitted):  
generic 
   type Item is private; 
package On_Stacks is 
   type Stack(Size : Positive) is limited private; 
   procedure  Push(S : in out Stack; E : in  Item); 
   procedure  Pop (S : in out Stack; E : out Item); 
   Overflow, Underflow : exception ; 
private 
   type Table is array (Positive range <>) of Item; 
   type Stack(Size : Positive) is 
      record 
         Space : Table(1 .. Size);          Index : Natural := 0;       end record; 
end On_Stacks; 
In order to use such a package, an instance has to  be created and thereafter stacks of the corresponding 
type can be declared:  
declare 
   package Stack_Real is new On_Stacks(Real); use Stack_Real; 
   S : Stack(100); begin 
   ...    Push(S, 2.54);    ... end; 13 
14 
15 
16 
Ada Reference Manual — 2012 Edition 
297      13 December 2012 Representation Issues   13 13   Representation Issues 
This clause describes features fo r querying and controlling certain aspects of entities and for interfacing to 
hardware.  
13.1 Operational and Representation Aspects 
Two kinds of aspects of entities can be specified : representation aspects and operational aspects. 
Representation aspects affect how the types and othe r entities of the language are to be mapped onto the 
underlying machine. Operational aspects determine other properties of entities. 
Either kind of aspect of an entity may be specified by means of an aspect_specification  (see 13.1.1), 
which is an optional element of most kinds of decl arations and applies to the entity or entities being 
declared. Aspects may also be specified by certain ot her constructs occurring subsequent to the declaration 
of the affected entity: a representa tion aspect value may be specified by means of a representation item 
and an operational aspect value may be sp ecified by means of an operational item. 
There are six kinds of representation items : attribute_definition_clause s for representation attributes, 
enumeration_representation_clause s, record_representation_clause s, at_clause s, component_clause s, 
and representation pragmas . They can be provided to give more efficient representation or to interface 
with features that are outside the domain of the language (for ex ample, peripheral hardware).  
An operational item  is an attribute_definition_clause  for an operational attribute. 
An operational item or a representation item applies to an entity identified by a local_name , which 
denotes an entity declared local to the current declar ative region, or a library unit declared immediately 
preceding a representation pragma in a compilation .  
Syntax 
aspect_clause ::= attribute_definition_clause  
      | enumeration_representation_clause  
      | record_representation_clause  
      | at_clause  
local_name ::= direct_name  
      | direct_name 'attribute_designator  
      | library_unit_ name  
A representation pragma is allowed only at places where an aspect_clause  or compilation_unit  is 
allowed.  
Name Resolution Rules 
In an operational item or representation item, if the local_name  is a direct_name , then it shall resolve to 
denote a declaration (or, in the case of a pragma , one or more declarations) that occurs immediately within 
the same declarative region as the item. If the local_name  has an attribute_designator , then it shall 
resolve to denote an implementation-defined compone nt (see 13.5.1) or a class-wide type implicitly 
declared immediately within the same declarative region as the item. A local_name  that is a 
library_unit_ name  (only permitted in a representation pragma) shall resolve to denote the library_item  
that immediately precedes (except for other pragmas) the representation pragma.  1/3 
0.1/3 
0.2/3 
1/1 
1.1/1 
1.2/1 
2/1 
3 
4/1 
5/1 
Ada Reference Manual — 2012 Edition 
13.1    Operational and Representati on Aspects 13 December 2012      298 Legality Rules 
The local_name  of an aspect_clause  or representation pragma shall statically denote an entity (or, in the 
case of a pragma , one or more entities) declared immediately preceding it in a compilation , or within the 
same declarative_part , package_specification , task_definition , protected_definition , or record_definition  
as the representation or operational item. If a local_name  denotes a local callable entity, it may do so 
through a local subprogram_renaming_declaration  (as a way to resolve ambiguity in the presence of 
overloading); otherwise, the local_name  shall not denote a renaming_declaration .  
The representation  of an object consists of a certain number of bits (the size of the object). For an object of 
an elementary type, these are the b its that are normally read or updated by the machine code when loading, 
storing, or operating-on the value of the object. For an object of a composite type, these are the bits 
reserved for this object, and include bits occupied by subcomponents of the object. If the size of an object 
is greater than that of its subtyp e, the additional bits are padding bits. For an elementary object, these 
padding bits are normally read and updated along with  the others. For a composite object, padding bits 
might not be read or updated in any given com posite operation, depending on the implementation. 
A representation item directly specifies  a representation aspect  of the entity denoted by the local_name , 
except in the case of a type-related representation item, whose local_name  shall denote a first subtype, 
and which directly specifies an aspect of the subtype's type. A representation item that names a subtype is either subtype-specific  (Size and Alignment clauses) or type-related  (all others). Subtype-specific aspects 
may differ for different subtypes of the same type. 
An operational item directly specifies  an operational aspect  of the entity denoted by the 
local_name , 
except in the case of a type-related operational item, whose local_name  shall denote a first subtype, and 
which directly specifies an aspect of the type of the subtype.  
A representation item that directly specifies an aspect of a subtype or type shall appear after the type is 
completely defined (see 3.11.1), and before the subt ype or type is frozen (see 13.14). If a representation 
item or aspect_specification  is given that directly specifies an asp ect of an entity, then it is illegal to give 
another representation item or aspect_specification  that directly specifies the same aspect of the entity.  
An operational item that directly specifies an aspect of an entity shall appear before the entity is frozen 
(see 13.14). If an operational item or aspect_specification  is given that directly specifies an aspect of an 
entity, then it is illegal to give another operational item or aspect_specification  that directly specifies the 
same aspect of the entity.  
Unless otherwise specified, it is illegal to specify an  operational or representation aspect of a generic 
formal parameter.  
For an untagged derived type, it is illegal to specify a type-related representation aspect if the parent type 
is a by-reference type, or has any user-defined primitive subprograms.  
Operational and representation aspects of a generic formal parameter are the same as those of the actual. 
Operational and representation aspects are the same for all views of a type. Specification of a type-related representation aspect is not allowed for a des cendant of a generic formal untagged type.  
The specification of the Size aspect for a given subtype, or the size or storage place for an object 
(including a component) of a given subtype, sha ll allow for enough storage space to accommodate any 
value of the subtype. 
If a specification of a representation or operational as pect is not supported by the implementation, it is 
illegal or raises an exception at run time. 6/1 
7/2 
8/3 
8.1/3 
9/3 
9.1/3 
9.2/3 
10/3 11/3 
12/3 
13/3 
Ada Reference Manual — 2012 Edition 
299      13 December 2012 Operational and Representation Aspects   13.1 A type_declaration  is illegal if it has one or more progen itors, and a nonconfirming value was specified 
for a representation aspect of an ancestor, and this c onflicts with the representati on of some other ancestor. 
The cases that cause conflicts are implementation defined.  
Static Semantics 
If two subtypes statically match, then their subtype- specific aspects (Size and Alignment) are the same.  
A derived type inherits each type-related representation as pect of its parent type that was directly specified 
before the declaration of the derived type, or (in the cas e where the parent is derived) that was inherited by 
the parent type from the grandparent type. A derived subtype inherits each subt ype-specific representation 
aspect of its parent subtype that was directly specified  before the declaration of the derived type, or (in the 
case where the parent is derived) that was inherited by the parent subtype from the grandparent subtype, 
but only if the parent subtype statically matches th e first subtype of the parent type. An inherited 
representation aspect is overridden by a subsequent aspect_specification  or representation item that 
specifies a different value for the same aspect of the type or subtype.  
In contrast, whether operational aspects are inherite d by a derived type depends on each specific aspect; 
unless specified, an operational aspect is not inherited.  When operational aspects are inherited by a derived 
type, aspects that were directly specified by aspect_specification s or operational items that are visible at 
the point of the derived type declaration, or (in the cas e where the parent is derived) that were inherited by 
the parent type from the grandparent type are inherite d. An inherited operational aspect is overridden by a 
subsequent aspect_specification  or operational item that specifies the same aspect of the type.  
When an aspect that is a subprogram is inherited, the derived type inher its the aspect in the same way that 
a derived type inherits a user-defined pr imitive subprogram from its parent (see 3.4).  
Each aspect of representation of an entity is as follows:  
• If the aspect is specified  for the entity, meaning that it is eith er directly specified or inherited, 
then that aspect of the entity is  as specified, except in the case of  Storage_Size, which specifies a 
minimum.  
• If an aspect of representation of an entity is  not specified, it is chosen by default in an 
unspecified manner.  
If an operational aspect is specified  for an entity (meaning that it is eith er directly specified or inherited), 
then that aspect of the entity is as  specified. Otherwise, the aspect of  the entity has the default value for 
that aspect. 
An aspect_specification  or representation item that specifies a representation aspect that would have been 
chosen in the absence of the aspect_specification  or representation item is said to be confirming . The 
aspect value specified in this case is said to be a confirming  representation aspect value. Other values of 
the aspect are said to be nonconfirming , as are the aspect_specification s and representation items that 
specified them.  
Dynamic Semantics 
For the elaboration of an aspect_clause , any evaluable constructs within it are evaluated.  
Implementation Permissions 
An implementation may interpret representation as pects in an implementation-defined manner. An 
implementation may place implementation-defined rest rictions on the specification of representation 
aspects. A recommended level of support  is defined for the specification of representation aspects and 
related features in each subclause. These recommendations are changed to requirements for 13.1/3 
14 
15/3 
15.1/3 
15.2/2 
16 
17 
18 
18.1/1 
18.2/3 
19/1 
20/3 
Ada Reference Manual — 2012 Edition 
13.1    Operational and Representati on Aspects 13 December 2012      300 implementations that support th e Systems Programming Annex (see C.2, “Required Representation 
Support”). 
Implementation Advice 
The recommended level of support for the specificati on of all representation aspects is qualified as 
follows:  
• A confirming specification for a repres entation aspect should be supported.  
• An implementation need not s upport the specification for a repres entation aspect that contains 
nonstatic expressions, unless each  nonstatic expression is a name  that statically denotes a 
constant declared before the entity.  
• An implementation need not support a specificati on for the Size for a given composite subtype, 
nor the size or storage place for an object (including a component) of a given composite subtype, unless the constraints on the subtype and its co mposite subcomponents (if any) are all static 
constraints. 
• An implementation need not support specifying a nonconfirming representation aspect value if it 
could cause an aliased object or an object of a by-reference type to be allocated at a nonaddressable location or, when the alignment attr ibute of the subtype of such an object is 
nonzero, at an address that is not an integral multiple of that alignment.  
• An implementation need not support specifying a nonconfirming representation aspect value if it 
could cause an aliased object of an elementary ty pe to have a size other than that which would 
have been chosen by default.  
• An implementation need not support specifying a nonconfirming representation aspect value if it 
could cause an aliased object of a composite type , or an object whose type is by-reference, to 
have a size smaller than that which w ould have been chosen by default.  
• An implementation need not support specifyi ng a nonconfirming subtype-specific representation 
aspect value for an indefinite or abstract subtype.  
For purposes of these rules, the determination of whether specifying a representation aspect value for a 
type could cause  an object to have some property is based sole ly on the properties of the type itself, not on 
any available information about how the type is used. In particular, it presumes that minimally aligned 
objects of this type might be declared at some point.  
NOTES 
1  Aspects that can be specified are defined throughout this International Standard, and are summarized in K.1.  
13.1.1 Aspect Specifications 
Certain representation or operational aspects of an entity  may be specified as part of its declaration using 
an aspect_specification , rather than using a separate represen tation or operational item. The declaration 
with the aspect_specification  is termed the associated declaration .  
Syntax 
aspect_specification ::=  
   with  aspect_mark  [=> aspect_definition ] {, 
           aspect_mark  [=> aspect_definition ] } 
aspect_mark ::= aspect_ identifier ['Class] 
aspect_definition ::= name  | expression  | identifier  21/3 
21.1/3 
22/3 
23 
24/3 
25/3 
26/3 
27/3 
28/3 
29/3 
1/3 
2/3 
3/3 
4/3 
Ada Reference Manual — 2012 Edition 
301      13 December 2012 As pect Specifications   13.1.1 Name Resolution Rules 
An aspect_mark  identifies an aspect of the entity defined by the associated declaration (the associated 
entity ); the aspect denotes an object, a value, an expr ession, a subprogram, or some other kind of entity. If 
the aspect_mark  identifies:  
• an aspect that denotes an object, the aspect_definition  shall be a name . The expected type for 
the name  is the type of the identified aspect of the associated entity; 
• an aspect that is a value or an expression, the aspect_definition  shall be an expression . The 
expected type for the expression  is the type of the identified aspect of the associated entity; 
• an aspect that de notes a subprogram, the aspect_definition  shall be a name ; the expected profile 
for the name  is the profile required for the aspect of the associated entity; 
• an aspect that denotes some other kind of entity, the aspect_definition  shall be a name , and the 
name shall resolve to denote an entity of the appropriate kind; 
• an aspect that is given by an identifier specific to the aspect, the aspect_definition  shall be an 
identifier , and the identifier  shall be one of the identifiers specific to the identified aspect.  
The usage names in an aspect_definition   are not resolved at the point of the associated declaration, but 
rather are resolved at the end of the immediately enclosing declaration list. 
If the associated declaration is for a subprogram or entr y, the names of the formal parameters are directly 
visible within the aspect_definition , as are certain attributes, as specified elsewhere in this International 
Standard for the identified aspect. If the associated declaration is a type_declaration , within the 
aspect_definition  the names of any components are directly vi sible, and the name of the first subtype 
denotes the current instance of the type (see 8.6). If the associated declaration is a subtype_declaration , 
within the aspect_definition  the name of the new subtype denotes the current instance of the subtype.  
Legality Rules 
If the first freezing point of the associated entity co mes before the end of the immediately enclosing 
declaration list, then each usage name in the aspect_definition  shall resolve to the same entity at the first 
freezing point as it does at the end of the immediately enclosing declaration list. 
At most one occurrence of each aspect_mark  is allowed within a single aspect_specification . The aspect 
identified by the aspect_mark  shall be an aspect that can be specifi ed for the associated entity (or view of 
the entity defined by the associated declaration). 
The aspect_definition  associated with a given aspect_mark  may be omitted only when the aspect_mark  
identifies an aspect of a boolean type, in which case it is equivalent to the aspect_definition  being 
specified as True. 
If the aspect_mark  includes 'Class, then the associated entity shall be a tagged type or a primitive 
subprogram of a tagged type. 
There are no language-defined aspects that may be specified on a renaming_declaration , a 
generic_formal_parameter_declaration , a subunit , a package_body , a task_body , a protected_body , or 
a body_stub  other than a subprogram_body_stub .  
A language-defined aspect shall not be specified in an aspect_specification  given on a subprogram_body  
or subprogram_body_stub  that is a completion of another declaration. 
Static Semantics 
Depending on which aspect is identified by the aspect_mark , an aspect_definition  specifies:  5/3 
6/3 
7/3 8/3 9/3 
10/3 11/3 
12/3 
13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
Ada Reference Manual — 2012 Edition 
13.1.1    Aspect Specifications  13 December 2012      302 • a name  that denotes a subprogram, object, or other kind of entity; 
• an expression , which is either evaluated to produce a single value, or which (as in a 
precondition) is to be evaluated at par ticular points during later execution; or 
• an identifier  specific to the aspect.  
The identified aspect of the associated entity, or in  some cases, the view of the entity defined by the 
declaration, is as specified by the aspect_definition  (or by the default of True when boolean). Whether an 
aspect_specification  applies  to an entity or only to the particular view of the entity defined by the 
declaration is determined by the aspect_mark  and the kind of entity. The following aspects are view 
specific: 
• An aspect specified on an object_declaration ; 
• An aspect specified on a subprogram_declaration ; 
• An aspect specified on a renaming_declaration . 
All other aspect_specification s are associated with the entity, and apply  to all views of the entity, unless 
otherwise specified in this International Standard. 
If the aspect_mark  includes 'Class, then:  
• if the associated entity is a tagged type, the specification applies  to all descendants of the type; 
• if the associated entity is a primitive subprogram of a tagged type T, the specification applies  to 
the corresponding primitive subprogram of all descendants of T.  
All specifiable operational and representati on attributes may be specified with an aspect_specification  
instead of an attribute_definition_clause  (see 13.3). 
Any aspect specified by a representation pragma or library unit pragma that has a local_name  as its single 
argument may be specified by an aspect_specification , with the entity being the local_name . The 
aspect_definition  is expected to be of type Boolean. The expression shall be static. 
In addition, other operational and representation aspect s not associated with specifiable attributes or 
representation pragmas may be specified, as specifi ed elsewhere in this International Standard. 
If an aspect of a derived type is inherited from an ancestor type and has the boolean value True, the 
inherited value shall not be overridden to have the value False for the derived type, unless otherwise 
specified in this International Standard. 
If a Legality Rule or Static Semantics rule only applie s when a particular aspect has been specified, the 
aspect is considered to have been specified only when the aspect_specification  or 
attribute_definition_clause  is visible (see 8.3) at the point  of the application of the rule. 
Alternative legality and semantics rules may apply for pa rticular aspects, as specified elsewhere in this 
International Standard. 
Dynamic Semantics 
At the freezing point of the associated entity, the aspect_specification  is elaborated. The elaboration of 
the aspect_specification  includes the evaluation of the name  or expression , if any, unless the aspect itself 
is an expression. If the corresponding aspect repr esents an expression (as in a precondition), the 
elaboration has no effect; the expression is evaluate d later at points within the execution as specified 
elsewhere in this International Sta ndard for the particular aspect.  20/3 
21/3 
22/3 
23/3 
24/3 
25/3 26/3 27/3 
28/3 
29/3 
30/3 
31/3 
32/3 
33/3 
34/3 
35/3 
36/3 
37/3 
Ada Reference Manual — 2012 Edition 
303      13 December 2012 As pect Specifications   13.1.1 Implementation Permissions 
Implementations may s upport implementation-defined aspects. The aspect_specification  for an 
implementation-defined aspect may use an  implementation-defined syntax for the aspect_definition , and 
may follow implementation-defined legality and semantics rules.  
13.2 Packed Types 
The Pack aspect having the value Tr ue specifies that storage minimi zation should be the main criterion 
when selecting the representa tion of a composite type.  
Paragraphs 2 through 4 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
For a full type declaration of a composite type, th e following language-defined representation aspect may 
be specified: 
Pack The type of aspect Pack is Boolean. When as pect Pack is True for a type, the type (or the 
extension part) is said to be packed . For a type extension, the parent part is packed as for 
the parent type, and specifying Pack causes packing only of the extension part.  
 If directly specified, the aspect_definition  shall be a static expression. If not specified 
(including by inheritance), the aspect is False.  
Implementation Advice 
If a type is packed, then the implem entation should try to minimize storage allocated to objects of the type, 
possibly at the expense of speed of accessing component s, subject to reasonable complexity in addressing 
calculations.  
If a packed type has a component that is not of a by -reference type and has no aliased part, then such a 
component need not be aligned according to the Alignm ent of its subtype; in particular it need not be 
allocated on a storage element boundary.  
The recommended level of support for the Pack aspect is:  
• For a packed record type, the components should be  packed as tightly as possible subject to the 
Sizes of the component subt ypes, and subject to any record_representation_clause  that applies 
to the type; the implementation may, but need not, reorder components or cross aligned word 
boundaries to improve the packing. A component whose Size is greater than the word size may 
be allocated an integral number of words.  
• For a packed array type, if the Size of the com ponent subtype is less than or equal to the word 
size, Component_Size should be less than or e qual to the Size of the component subtype, 
rounded up to the nearest factor of the word size.  38/3 
1/3 
5/3 
5.1/3 
5.2/3 
6 
6.1/2 
7/3 
8 
9/3 
Ada Reference Manual — 2012 Edition 
13.3    Operational and Representation Attributes 13 December 2012      304 13.3 Operational and Representation Attributes 
The values of certain implemen tation-dependent characteristics can  be obtained by interrogating 
appropriate operational or representation attributes. Some of these attributes are specifiable via an 
attribute_definition_clause .  
Syntax 
attribute_definition_clause ::=  
      for local_name 'attribute_designator  use expression ; 
    | for local_name 'attribute_designator  use name ; 
Name Resolution Rules 
For an attribute_definition_clause  that specifies an attribute that denotes a value, the form with an 
expression  shall be used. Otherw ise, the form with a name  shall be used. 
For an attribute_definition_clause  that specifies an attribute that denotes a value or an object, the expected 
type for the expression or name  is that of the attribute. For an attribute_definition_clause  that specifies an 
attribute that denotes a subprogram , the expected profile for the name  is the profile required for the 
attribute. For an attribute_definition_clause  that specifies an attribute that denotes some other kind of 
entity, the name  shall resolve to denote an entity of the appropriate kind.  
Legality Rules 
An attribute_designator  is allowed in an attribute_definition_clause  only if this International Standard 
explicitly allows it, or for an implementation-define d attribute if the implementation allows it. Each 
specifiable attribute constitutes an operational aspect or aspect of representation; th e name of the aspect is 
that of the attribute.  
For an attribute_definition_clause  that specifies an attribute that de notes a subprogram, the profile shall be 
mode conformant with the one required for the attr ibute, and the convention shall be Ada. Additional 
requirements are defined for particular attributes.  
Static Semantics 
A Size clause  is an attribute_definition_clause  whose attribute_designator  is Size. Similar definitions 
apply to the other specifiable attributes.  
A storage element  is an addressable element of storage in the machine. A word  is the largest amount of 
storage that can be conveniently and efficiently mani pulated by the hardware, given the implementation's 
run-time model. A word cons ists of an integral number of storage elements.  
A machine scalar  is an amount of storage that can be conve niently and efficiently loaded, stored, or 
operated upon by the hardware. Machine scalars consist of  an integral number of storage elements. The set 
of machine scalars is implementation defined, but includes at least the storage element and the word. Machine scalars are used to interpret 
component_clause s when the nondefault bit ordering applies.  
The following representation attributes are define d: Address, Alignment, Size, Storage_Size, 
Component_Size, Has_Same_Sto rage, and Overlaps_Storage. 
For a prefix  X that denotes an object, program unit, or label:  
X'Address Denotes the address of the first of the stor age elements allocated to X. For a program unit or 
label, this value refers to  the machine code associated with the corresponding body or 
statement . The value of this attribute is of type System.Address. 1/1 
2 
3 
4 
5/3 
6 
7/2 
8 
8.1/3 
9/3 
10/1 
11 
Ada Reference Manual — 2012 Edition 
305      13 December 2012 Operational and Representation Attributes   13.3  The prefix of X'Address shall not stati cally denote a subprogram that has convention 
Intrinsic. X'Address raises Program_Error if  X denotes a subprogram that has convention 
Intrinsic. 
 Address may be specified for stand-al one objects and for program units via an 
attribute_definition_clause .  
Erroneous Execution 
If an Address is specified, it is the programmer's res ponsibility to ensure that the address is valid and 
appropriate for the entity and its use; ot herwise, program execution is erroneous. 
Implementation Advice 
For an array X, X'Address should point at the first component of the array, and not at the array bounds.  
The recommended level of support for the Address attribute is:  
• X'Address should produce a useful result if X is an object that is aliased or of a by-reference 
type, or is an entity whose Address has been specified.  
• An implementation should support Addr ess clauses for imported subprograms. 
• This paragraph was deleted.  
• If the Address of an object is specified, or it is imported or exported, then the implementation 
should not perform optimizations base d on assumptions of no aliases.  
NOTES 
2  The specification of a link name with the Link_Name aspect (see B.1) for a subprogram or object is an alternative to explicit specification of its link-time a ddress, allowing a link-time directive to  place the subprogram or object within 
memory. 
3  The rules for the Size attribute imply, for an aliased object X, that if X'Size = Storage_Unit, then X'Address points at a 
storage element containing all of the bits of X, and only the bits of X.  
Static Semantics 
For a prefix  X that denotes an object:  
X'Alignment The value of this attribute is of type universal_integer , and nonnegative; zero means that 
the object is not necessarily aligned on a st orage element boundary. If X'Alignment is not 
zero, then X is aligned on a storage unit boundary  and X'Address is an integral multiple of 
X'Alignment (that is, the Addre ss modulo the Alignment is zero). 
 This paragraph was deleted.  
 Alignment may be specified for stand-alone objects via an attribute_definition_clause ; the 
expression of such a clause shall be static, and its value nonnegative. 
 This paragraph was deleted.  
For every subtype S:  
S'Alignment The value of th is attribute is of type universal_integer , and nonnegative. 
 For an object X of subtype S, if S'Alignmen t is not zero, then X'Alignment is a nonzero 
integral multiple of S'Alignment unless speci fied otherwise by a representation item. 
 Alignment may be specified for first subtypes via an attribute_definition_clause ; the 
expression of such a clause shall be static, and its value nonnegative. 
Erroneous Execution 
Program execution is erroneous if an Address clause  is given that conflicts  with the Alignment.  11.1/3 
12 
13/3 
14 
15 16 
17 
18/2 
19 
20 
21 
22/2 
23/2 
24/2 
25/2 
26/2 
26.1/2 
26.2/2 
26.3/2 
26.4/2 
27 
Ada Reference Manual — 2012 Edition 
13.3    Operational and Representation Attributes 13 December 2012      306 For an object that is not allocated under control of th e implementation, execution is  erroneous if the object 
is not aligned according to its Alignment. 
Implementation Advice 
For any tagged specific subtype S, S'Class'Alignment should equal S'Alignment. 
The recommended level of support for the A lignment attribute for subtypes is:  
• An implementation should support an Alignment clause for a discrete type, fixed point type, 
record type, or array type, specifying an Alignmen t value that is zero or a power of two, subject 
to the following: 
• An implementation need not suppor t an Alignment clause for a signed integer type specifying an 
Alignment greater than the largest Alignment va lue that is ever chosen by default by the 
implementation for any signed integer type. A corresponding limitation may be imposed for 
modular integer types, fixed point types, enumer ation types, record types, and array types. 
• An implementation need not support a nonconfirmi ng Alignment clause which could enable the 
creation of an object of an elementary type which cannot be easily loaded and stored by 
available machine instructions. 
• An implementation need not s upport an Alignment specified for a derived tagged type which is 
not a multiple of the Alignment of the parent  type. An implementation need not support a 
nonconfirming Alignment specified for a derived untagged by-reference type.  
The recommended level of support for the Alignment attribute for objects is:  
• This paragraph was deleted.  
• For stand-alone library-level objects of stati cally constrained subtyp es, the implementation 
should support all Alignments suppor ted by the target linker. For example, page alignment is 
likely to be supported for such objects, but not for subtypes. 
• For other objects, an implementation should at least support the alignmen ts supported for their 
subtype, subject to the following: 
• An implementation need not s upport Alignments specified for objects of a by-reference type or 
for objects of types containing aliased subcomponents if the sp ecified Alignment is not a 
multiple of the Alignment of the subtype of the object.  
NOTES 
4  Alignment is a subtype-specific attribute. 
This paragraph was deleted.  
5  A component_clause , Component_Size clause, or specifying the Pack aspect as True can override a specified 
Alignment.  
Static Semantics 
For a prefix  X that denotes an object:  
X'Size Denotes the size in bits of the representation of the object. The value of this attribute is of 
the type universal_integer .  
 Size may be specified for stand-alone objects via an attribute_definition_clause ; the 
expression of such a clause shall be static and its value nonnegative. 
Implementation Advice 
The size of an array object should not include its bounds.  28/2 
28.1/3 
29 
30/2 
31/2 
32/2 
32.1/2 
33 
34/2 
35 
35.1/2 
35.2/2 
36 
37/2 38/3 
39/1 
40 
41 
41.1/2 
Ada Reference Manual — 2012 Edition 
307      13 December 2012 Operational and Representation Attributes   13.3 The recommended level of support for the Size attribute of  objects is the same as for subtypes (see below), 
except that only a confirming Size clause need be  supported for an aliased elementary object.  
• This paragraph was deleted.  
Static Semantics 
For every subtype S:  
S'Size If S is definite, denotes the size (in bits ) that the implementati on would choose for the 
following objects of subtype S:  
• A record component of subtype S when the record type is packed. 
• The formal parameter of an instan ce of Unchecked_Conversion that converts 
from subtype S to some other subtype.  
 If S is indefinite, the meaning is implementati on defined. The value of this attribute is of 
the type universal_integer . The Size of an object is at least as large as that of its subtype, 
unless the object's Size is determined by a Size clause, a component_clause, or a 
Component_Size clause. Size may be sp ecified for first subtypes via an attribute_-
definition_clause ; the expression of such a clause sha ll be static and its value nonnegative.  
Implementation Requirements 
In an implementation, Boolean'Size shall be 1.  
Implementation Advice 
If the Size of a subtype allows for efficient independent  addressability (see 9.10) on the target architecture, 
then the Size of the following objects of the s ubtype should equal the Size of the subtype:  
• Aliased objects (including components). 
• Unaliased components, unless the Size of  the component is determined by a component_clause  
or Component_Size clause.  
A Size clause on a composite subtype should not a ffect the internal layout of components.  
The recommended level of support for th e Size attribute of subtypes is:  
• The Size (if not specified) of a static discrete or  fixed point subtype should be the number of bits 
needed to represent each value belonging to th e subtype using an unbiased representation, 
leaving space for a sign bit only if the subtype contains negative values. If such a subtype is a first subtype, then an implem entation should support a specified Size for it that reflects this 
representation. 
• For a subtype implemented with levels of indirection, the Size should include the size of the 
pointers, but not the size of what they point at.  
• An implementation should support a Size clause fo r a discrete type, fixed point type, record 
type, or array type, subject to the following:  
• An implementation need not support a Size cl ause for a signed integer type specifying a 
Size greater than that of the largest signed in teger type supported by the implementation in 
the absence of a size clause (that is, when the size is chosen by default). A corresponding 
limitation may be imposed for modul ar integer types, fixed point  types, enumeration types, 
record types, and array types. 
• A nonconfirming size clause for the first subt ype of a derived untagged by-reference type 
need not be supported.  42/2 
43/2 
44 
45 
46 
47 
48 
49 
50/2 
51 
52 
53 
54 
55 
56 
56.1/2 
56.2/2 
56.3/2 
Ada Reference Manual — 2012 Edition 
13.3    Operational and Representation Attributes 13 December 2012      308 NOTES 
6  Size is a subtype-specific attribute. 
7  A component_clause  or Component_Size clause can override a specified Size. Aspect Pack cannot.  
Static Semantics 
For a prefix  T that denotes a task object (after any implicit dereference):  
T'Storage_Size 
 Denotes the number of storage elements reserved for the task. The value of this attribute is 
of the type universal_integer . The Storage_Size includes the size of the task's stack, if any. 
The language does not specify whether or not it includes other storage associated with the 
task (such as the “task control block” used  by some implementations.) If the aspect 
Storage_Size is specified for the type of the object, the value of the Storage_Size attribute 
is at least the value determined by the aspect.  
Aspect Storage_Size specifies the amount of storag e to be reserved for the execution of a task.  
Paragraphs 62 through 65 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
For a task type (including the anonymous type of a single_task_declaration ), the following language-
defined representation aspect may be specified: 
Storage_Size The Storage_Size aspect is an expression , which shall be of any integer type. 
Legality Rules 
The Storage_Size aspect shall not be specified for a task interface type.  
Dynamic Semantics 
When a task object is created, the expression  (if any) associated with the Storage_Size aspect of its type is 
evaluated; the Storage_Size attribute of the newly created task object is at least the value of the 
expression . 
At the point of task object creation, or upon task activa tion, Storage_Error is raised  if there is insufficient 
free storage to accommodate the requested Storage_Size.  
Static Semantics 
For a prefix  X that denotes an array subtype or array object (after any implicit dereference):  
X'Component_Size 
 Denotes the size in bits of components of the type  of X. The value of this attribute is of type 
universal_integer .  
 Component_Size may be specified for array types via an attribute_definition_clause ; the 
expression of such a clause shall be static, and its value nonnegative. 
Implementation Advice 
The recommended level of support for the Component_Size attribute is:  
• An implementation need not support specified Co mponent_Sizes that are less than the Size of 
the component subtype. 
• An implementation should support specified Com ponent_Sizes that are factors and multiples of 
the word size. For such Component_Sizes, the array should contain no gaps between 
components. For other Component_Sizes (if supported), the array should contain no gaps 57 
58/3 
59/1 
60/3 
61/3 
65.1/3 
65.2/3 
65.3/3 
66/3 
67 
68/1 
69 
70 
71 
72 
73/3 
Ada Reference Manual — 2012 Edition 
309      13 December 2012 Operational and Representation Attributes   13.3 between components when Pack is also speci fied; the implementati on should forbid this 
combination in cases where it cannot support a no-gaps representation.  
Static Semantics 
For a prefix  X that denotes an object:  
X'Has_Same_Storage 
 X'Has_Same_Storage denotes a func tion with the following specification: 
function  X'Has_Same_Storage ( Arg : any_type) 
  return Boolean 
 The actual parameter shall be a name that denotes an object. The object denoted by the 
actual parameter can be of any type. This function evaluates the names of the objects 
involved and returns True if the representation of the object denoted by the actual parameter occupies exactly the same bits as the representation of the object denoted by X; otherwise, it returns False. 
For a 
prefix  X that denotes an object:  
X'Overlaps_Storage 
 X'Overlaps_Storage denotes a func tion with the following specification: 
function  X'Overlaps_Storage ( Arg : any_type) 
  return Boolean 
 The actual parameter shall be a name that denotes an object. The object denoted by the 
actual parameter can be of any type. This function evaluates the names of the objects 
involved and returns True if the representation of the object denoted by the actual parameter shares at least one bit with the representation of the object denoted by X; 
otherwise, it returns False.  
NOTES 
8  X'Has_Same_Storage(Y) implies X'Overlaps_Storage(Y). 
9  X'Has_Same_Storage(Y) and X'Overlaps_Storage(Y) are not considered to be reads of X and Y.  
Static Semantics 
The following type-related operational a ttribute is defined: External_Tag. 
For every subtype S of a tagged type T (specific or class-wide): 
S'External_Tag 
 S'External_Tag denotes an external string repr esentation for S'Tag; it is of the predefined 
type String. External_Tag may be specified for a specific tagged type via an 
attribute_definition_clause ; the expression of such a clause shall be static. The default 
external tag representation is implementa tion defined. See 13.13.2. The value of 
External_Tag is never inherited; the default value is always used unless a new value is 
directly specified for a type.  
Dynamic Semantics 
If a user-specified external tag S'External_Tag is th e same as T'External_Tag for some other tagged type 
declared by a different declaration in the partition,  Program_Error is raised by the elaboration of the 
attribute_definition_clause . 
Implementation Requirements 
In an implementation, the default external tag for each  specific tagged type declared in a partition shall be 
distinct, so long as the type is declared outside an instance of a generic body. If the compilation unit in 
which a given tagged type is declared, and all comp ilation units on which it semantically depends, are the 73.1/3 
73.2/3 
73.3/3 
73.4/3 
73.5/3 
73.6/3 
73.7/3 
73.8/3 
73.9/3 
73.10/3 
73.11/3 
74/1 
75/3 
75.1/3 
76 
Ada Reference Manual — 2012 Edition 
13.3    Operational and Representation Attributes 13 December 2012      310 same in two different partitions, then the external tag for the type shall be the same in the two partitions. 
What it means for a compilation unit to be the same in  two different partitions is implementation defined. 
At a minimum, if the compilation unit is not recompile d between building the two different partitions that 
include it, the compilation unit is consid ered the same in the two partitions.  
Implementation Permissions 
If a user-specified external tag S'External_Tag is th e same as T'External_Tag for some other tagged type 
declared by a different declaration in the partition, the partition may be rejected. 
NOTES 
10  The following language-defined attributes are specifiable, at least for some of the kinds of entities to which they apply: Address, Alignment, Bit_Order, Component_Size, External_Tag, Input, Machine_Radix, Output, Read, Size, Small, Storage_Pool, Storage_Size, Stream_Size, and Write. 
11  It follows from the general rules in 13.1 that if one writes “ for X'Size use Y;” then the X'Size 
attribute_reference  will 
return Y (assuming the implementation allows the Size clause). The same is true for all of the specifiable attributes except Storage_Size.  
Examples 
Examples of attribute definition clauses:   
Byte : constant  := 8; 
Page : constant  := 2**12; 
type Medium is range 0 .. 65_000; 
for Medium'Size use 2*Byte; 
for Medium'Alignment use 2; 
Device_Register : Medium; for Device_Register'Size use Medium'Size; 
for Device_Register'Address use 
System.Storage_Elements.To_Address(16#FFFF_0020#); 
type Short is delta 0.01 range -100.0 .. 100.0; 
for Short'Size use 15; 
for Car_Name'Storage_Size use -- specify access type's storage pool size  
        2000*((Car'Size/System.Storage_Unit) +1); --  approximately 2000 cars  
function  My_Input(Stream : not null access  
Ada.Streams.Root_Stream_Type'Class)   return T; 
for T'Input use My_Input; --  see 13.13.2  
NOTES 
12  Notes on the examples:  In the Size clause for Short, fifteen bits is the minimum necessary, since the type definition 
requires Short'Small <= 2**(–7).  
13.4 Enumeration Representation Clauses 
An enumeration_representation_clause  specifies the internal codes for enumeration literals.  
Syntax 
enumeration_representation_clause ::=  
    for first_subtype_ local_name  use enumeration_aggregate ; 
enumeration_aggregate ::= array_aggregate  
Name Resolution Rules 
The enumeration_aggregate  shall be written as a one-dimensional array_aggregate , for which the index 
subtype is the unconstrained subtype of the enumera tion type, and each component expression is expected 
to be of any integer type.  76.1/3 
77/2 
78 
79 
80 
81 
82 
83 
84/2 
85 
1 
2 
3 
4 
Ada Reference Manual — 2012 Edition 
311      13 December 2012 Enumera tion Representation Clauses   13.4 Legality Rules 
The first_subtype_ local_name  of an enumeration_representation_clause  shall denote an enumeration 
subtype.  
Each component of the array_aggregate  shall be given by an expression  rather than a <>. The 
expression s given in the array_aggregate  shall be static, and shall specify distinct integer codes for each 
value of the enumeration type; the associated integer codes shall satisfy the predefined ordering relation of 
the type.  
Static Semantics 
An enumeration_representation_clause  specifies the coding  aspect of representation. The coding 
consists of the internal code  for each enumeration literal, that is, th e integral value used internally to 
represent each literal. 
Implementation Requirements 
For nonboolean enumeration types, if the coding is not specified for the type, then for each value of the 
type, the internal code shall be  equal to its position number.  
Implementation Advice 
The recommended level of support for enumeration_representation_clause s is:  
• An implementation should support at l east the internal codes in the range 
System.Min_Int..System.Max_Int. An  implementation need not support enumeration_-
representation_clause s for boolean types.  
NOTES 
13  Unchecked_Conversion may be used to query the internal codes used for an enumeration type. The attributes of the type, such as Succ, Pred, and Pos, are unaffected by the 
enumeration_repres entation_clause . For example, Pos always 
returns the position number, not the internal integer code that might have been specified in an 
enumeration_repres entation_clause .  
Examples 
Example of an enumerati on representation clause:   
type Mix_Code is (ADD, SUB, MUL, LDA, STA, STZ); 
for Mix_Code use 
   (ADD => 1, SUB => 2, MUL => 3, LDA => 8, STA => 24, STZ =>33); 
13.5 Record Layout 
The (record) layout  aspect of representa tion consists of the storage places  for some or all components, that 
is, storage place attributes of the component s. The layout can be specified with a record_representation_-
clause .  5 
6/2 
7 
8 
9 
10 
11/3 
12 
13 
14 
1 
Ada Reference Manual — 2012 Edition 
13.5.1    Record Representation Clauses 13 December 2012      312 13.5.1 Record Representation Clauses 
A record_representation_clause  specifies the storage representation of records and record extensions, 
that is, the order, position, and size of com ponents (including discri minants, if any).  
Syntax 
record_representation_clause ::=  
    for first_subtype_ local_name  use 
      record  [mod_clause ] 
        { component_clause } 
      end record ; 
component_clause ::=  
    component_ local_name  at position  range  first_bit  .. last_bit ; 
position ::= static_ expression  
first_bit ::= static_ simple_expression  
last_bit ::= static_ simple_expression  
Name Resolution Rules 
Each position , first_bit , and last_bit  is expected to be of any integer type.  
Legality Rules 
The first_subtype_ local_name  of a record_representation_clause  shall denote a specific record or record 
extension subtype.  
If the component_ local_name  is a direct_name , the local_name  shall denote a component of the type. For 
a record extension, the component shall not be inher ited, and shall not be a di scriminant that corresponds 
to a discriminant of the parent type. If the component_ local_name  has an attribute_designator , the 
direct_name  of the local_name  shall denote either the declaration of the type or a component of the type, 
and the attribute_designator  shall denote an implementation-defi ned implicit component of the type. 
The position , first_bit , and last_bit  shall be static expressions. The value of position  and first_bit  shall be 
nonnegative. The value of last_bit  shall be no less than first_bit  – 1.  
If the nondefault bit ordering applies to the type, then either:  
• the value of last_bit  shall be less than the size of the largest machine scalar; or 
• the value of first_bit  shall be zero and the value of last_bit  + 1 shall be a multiple of 
System.Storage_Unit.  
At most one component_clause  is allowed for each component of the type, including for each 
discriminant ( component_clause s may be given for some, all, or none of the components). Storage places 
within a component_list  shall not overlap, unless they are for components in distinct variant s of the same 
variant_part . 
A name that denotes a component of  a type is not allowed within a record_representation_clause  for the 
type, except as the component_ local_name  of a component_clause .  
Static Semantics 
A record_representation_clause  (without the mod_clause ) specifies the layout. 1 
2 
3 
4 
5 6 
7 
8/2 
9 
10 
10.1/2 
10.2/2 
10.3/2 
11 
12 
13/2 
Ada Reference Manual — 2012 Edition 
313      13 December 2012 Record Representation Clauses   13.5.1 If the default bit ordering applies to the type, the position , first_bit , and last_bit  of each 
component_clause  directly specify the position and size of the corresponding component. 
If the nondefault bit ordering applies to the type, then the layout is de termined as follows:  
• the component_clause s for which the value of last_bit  is greater than or equal to the size of the 
largest machine scalar  directly specify the position and size of the corresponding component; 
• for other component_clause s, all of the components having the same value of position  are 
considered to be part of a single machine scalar, located at that position ; this machine scalar has 
a size which is the smallest machine scalar size larger than the largest last_bit  for all 
component_clause s at that position ; the first_bit  and last_bit  of each component_clause  are 
then interpreted as bit offset s in this machine scalar.  
A record_representation_clause  for a record extension does not override the layout of the parent part; if 
the layout was specified for the parent type, it is inherited by the record extension.  
Implementation Permissions 
An implementation may generate implementation-defined components (for example, one containing the 
offset of another component). An  implementation may generate name s that denote such implementation-
defined components; such names shall be implementation-defined attribute_reference s. An implemen-
tation may allow such implementati on-defined names to be used in record_representation_clause s. An 
implementation can restrict such component_clause s in any manner it sees fit.  
If a record_representation_clause  is given for an untagged derived type, the storage place attributes for 
all of the components of the derived type may di ffer from those of the corresponding components of the 
parent type, even for components whose stor age place is not specified explicitly in the record_-
representation_clause .  
Implementation Advice 
The recommended level of support for record_representation_clause s is:  
• An implementation should support machine scalars that correspond to  all of the integer, floating 
point, and address formats supported by the machine. 
• An implementation should support storage places th at can be extracted with a load, mask, shift 
sequence of machine code, and set with a load, sh ift, mask, store sequence, given the available 
machine instructions and run-time model. 
• A storage place should be supported if its size is equal to the Size of the component subtype, and 
it starts and ends on a boundary that obeys the Alignment of the component subtype. 
• For a component with a subtype whose Size is less than the word size, any storage place that 
does not cross an aligned word  boundary should be supported. 
• An implementation may reserve a storage place for the tag field of a tagged type, and disallow 
other components from overlapping that place.  
• An implementation need not support a component_clause  for a component of an extension part 
if the storage place is not after the storage places  of all components of the parent type, whether 
or not those storage places had been specified.  
NOTES 
14  If no component_clause  is given for a component, then the choice of the stor age place for the compone nt is left to the 
implementation. If component_clause s are given for all components, the record_representation_clause  completely 
specifies the representation of the type and will be obeyed exactly by the implementation.  13.1/2 
13.2/3 
13.3/2 
13.4/2 
14 
15 
16 
17 
17.1/2 
18 
19 
20/2 
21 22 
23 
Ada Reference Manual — 2012 Edition 
13.5.1    Record Representation Clauses 13 December 2012      314 Examples 
Example of specifying the layout of a record type:   
Word : constant  := 4;  --   storage element is byte, 4 bytes per word  
type State         is (A,M,W,P); 
type Mode          is (Fix, Dec, Exp, Signif); 
type Byte_Mask     is array (0..7)  of Boolean; 
type State_Mask    is array (State) of Boolean; 
type Mode_Mask     is array (Mode)  of Boolean; 
type Program_Status_Word is 
  record 
      System_Mask        : Byte_Mask;       Protection_Key     : Integer range 0 .. 3; 
      Machine_State      : State_Mask;       Interrupt_Cause    : Interruption_Code;       Ilc                : Integer range 0 .. 3; 
      Cc                 : Integer range 0 .. 3; 
      Program_Mask       : Mode_Mask;       Inst_Address       : Address; end record; 
for Program_Status_Word use 
  record 
      System_Mask      at 0*Word range 0  .. 7; 
      Protection_Key   at 0*Word range 10 .. 11; --  bits 8,9 unused  
      Machine_State    at 0*Word range 12 .. 15; 
      Interrupt_Cause  at 0*Word range 16 .. 31; 
      Ilc              at 1*Word range 0  .. 1;  --  second word  
      Cc               at 1*Word range 2  .. 3; 
      Program_Mask     at 1*Word range 4  .. 7; 
      Inst_Address     at 1*Word range 8  .. 31; 
  end record; 
for Program_Status_Word'Size use 8*System.Storage_Unit; 
for Program_Status_Word'Alignment use 8; 
NOTES 
15  Note on the example:  The record_representation_clause  defines the record layout. The Size clause guarantees that (at 
least) eight storage elements are used for objects of the type. The Alignment clause guarantees that aliased, imported, or exported objects of the type will have addresses divisible by eight.  
13.5.2 Storage Place Attributes 
Static Semantics 
For a component C of a com posite, non-array object R, the storage place attributes  are defined:  
R.C'Position If the nondefault bit ordering a pplies to the composite type, and if a component_clause  
specifies the placement of C, denotes the value given for the position  of the 
component_clause ; otherwise, denotes the same valu e as R.C'Address – R'Address. The 
value of this attribute is of the type universal_integer .  
R.C'First_Bit 
 If the nondefault bit ordering applies to the composite type, and if a component_clause  
specifies the placement of C, denotes the value given for the first_bit  of the 
component_clause ; otherwise, denotes the offset, from the start of the first of the storage 
elements occupied by C, of the first bit occupied  by C. This offset is  measured in bits. The 
first bit of a storage element is numbered zero. The value of this attribute is of the type 
universal_integer . 24 
25 
26 
27 
28 
29 
30 
31 
1 
2/2 
3/2 
Ada Reference Manual — 2012 Edition 
315      13 December 2012 St orage Place Attributes   13.5.2 R.C'Last_Bit 
 If the nondefault bit ordering applies to the composite type, and if a component_clause  
specifies the placement of C, denotes the value given for the last_bit  of the 
component_clause ; otherwise, denotes the offset, from the start of the first of the storage 
elements occupied by C, of the last bit occupied  by C. This offset is  measured in bits. The 
value of this attribute is of the type universal_integer .  
Implementation Advice 
If a component is represented using some form of point er (such as an offset) to the actual data of the 
component, and this data is contiguous with the rest of the object, then the storage place attributes should 
reflect the place of the actual data, not the pointer. If a component is allocated discontiguously from the 
rest of the object, then a warning should be generated upon reference to one of its storage place attributes.  
13.5.3 Bit Ordering 
The Bit_Order attribute specifies the interp retation of the storage place attributes.  
Static Semantics 
A bit ordering is a method of interpreting the meani ng of the storage place attributes. High_Order_First 
(known in the vernacular as “big endian”) means that th e first bit of a storage el ement (bit 0) is the most 
significant bit (interpreting the sequence of bits that represent a component as an  unsigned integer value). 
Low_Order_First (known in the vernacu lar as “little endian”) means the opposite: the first bit is the least 
significant. 
For every specific record subtype S, the following attribute is defined:  
S'Bit_Order Denotes the bit ordering for the type of  S. The value of this attribute is of type 
System.Bit_Order. Bit_Order may be specified for specific record types via an 
attribute_definition_clause ; the expression of such a clause shall be static. 
If Word_Size = Storage_Unit, the default bit orde ring is implementation defined. If Word_Size > 
Storage_Unit, the default bit ordering is the same as  the ordering of storage elements in a word, when 
interpreted as an integer.  
The storage place attributes of a component of a type  are interpreted according to the bit ordering of the 
type.  
Implementation Advice 
The recommended level of support for the nondefault bit ordering is:  
• The implementation should support the nondefault bit ordering in addition to the default bit 
ordering.  
NOTES 
16  Bit_Order clauses make it possible to write record_representation_clause s that can be ported between machines 
having different bit ordering. They do not guarantee transparent exchange of data between such machines.  4/2 
5 
1 
2 
3 
4 
5 
6 
7 
8/2 
9/2 
Ada Reference Manual — 2012 Edition 
13.6    Change of Representation 13 December 2012      316 13.6 Change of Representation 
A type_conversion  (see 4.6) can be used to convert between two different representations of the same 
array or record. To convert an array from one repres entation to another, two array types need to be 
declared with matching component subtypes, and conver tible index types. If one type has Pack specified 
and the other does not, then explicit conversion can be used to pack or unpack an array. 
To convert a record from one representation to anot her, two record types with a common ancestor type 
need to be declared, with no inherited subprograms. Di stinct representations can then be specified for the 
record types, and explicit conversion between the types can  be used to effect a change in representation.  
Examples 
Example of change of representation:   
-- Packed_Descriptor and Descriptor are two different types  
-- with identical characteristics, apart from their  
-- representation  
type Descriptor is 
    record 
      --  components of a descriptor  
    end record; 
type Packed_Descriptor is new Descriptor; 
for Packed_Descriptor use 
    record 
      --  component clauses for some or for all components  
    end record; 
-- Change of representation can now be a ccomplished by explicit type conversions:  
D : Descriptor; 
P : Packed_Descriptor; 
P := Packed_Descriptor(D);  --  pack D 
D := Descriptor(P);         --  unpack P 1/3 
2 
3 
4 
5 
6 
7 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
317      13 December 2012 The Package System   13.7 13.7 The Package System 
For each implementation there is a library package calle d System which includes the definitions of certain 
configuration-dependent characteristics.  
Static Semantics 
The following language-defined library package exists:  
package System is 
   pragma Pure(System); 
   type Name is implementation-defined-enumeration-type ; 
   System_Name : constant  Name := implementation-defined ; 
   --  System-Dependent Named Numbers:  
   Min_Int               : constant  := root_integer 'First; 
   Max_Int               : constant  := root_integer 'Last; 
   Max_Binary_Modulus    : constant  := implementation-defined ; 
   Max_Nonbinary_Modulus : constant  := implementation-defined ; 
   Max_Base_Digits       : constant  := root_real'Digits; 
   Max_Digits            : constant  := implementation-defined ; 
   Max_Mantissa          : constant  := implementation-defined ; 
   Fine_Delta            : constant  := implementation-defined ; 
   Tick                  : constant  := implementation-defined ; 
   --  Storage-related Declarations:  
   type Address is implementation-defined ; 
   Null_Address : constant  Address; 
   Storage_Unit : constant  := implementation-defined ; 
   Word_Size    : constant  := implementation-defined  * Storage_Unit; 
   Memory_Size  : constant  := implementation-defined ; 
   --  Address Comparison:  
   function  "<" (Left, Right : Address) return Boolean 
      with Convention => Intrinsic; 
   function  "<="(Left, Right : Address) return Boolean 
      with Convention => Intrinsic; 
   function  ">" (Left, Right : Address) return Boolean 
      with Convention => Intrinsic; 
   function  ">="(Left, Right : Address) return Boolean 
      with Convention => Intrinsic; 
   function  "=" (Left, Right : Address) return Boolean 
      with Convention => Intrinsic; 
-- function  "/=" (Left, Right : Address) return Boolean; 
   --  "/=" is implicitly defined  
   --  Other System-Dependent Declarations:  
   type Bit_Order is (High_Order_First, Low_Order_First); 
   Default_Bit_Order : constant  Bit_Order := implementation-defined ; 
   --  Priority-related declarations (see D.1):  
   subtype Any_Priority is Integer range implementation-defined ; 
   subtype Priority is Any_Priority range Any_Priority'First .. 
             implementation-defined ; 
   subtype Interrupt_Priority is Any_Priority range Priority'Last+1 .. 
             Any_Priority'Last; 
   Default_Priority : constant  Priority := 
             (Priority'First + Priority'Last)/2; 
private 
   ... -- not specified by the language  
end System; 1 
2 
3/2 
4 5 
6 
7 8 9 
10 
11 12 
13 
14/3 
15/2 
16 
17 
18 
Ada Reference Manual — 2012 Edition 
13.7    The Package System 13 December 2012      318 Name is an enumeration subtype. Values of type Name are the names of alternative machine configura-
tions handled by the implementati on. System_Name represents the current machine configuration. 
The named numbers Fine_Delta and Tick are of the type universal_real ; the others are of the type 
universal_integer . 
The meanings of the named numbers are:  
Min_Int  The smallest (most negative) value allowed for the expressions of a signed_integer_type_-
definition . 
Max_Int  The largest (most positive) va lue allowed for the expressions of a signed_integer_type_-
definition . 
Max_Binary_Modulus  
 A power of two such that it, and all lesse r positive powers of two, are allowed as the 
modulus of a modular_type_definition . 
Max_Nonbinary_Modulus  
 A value such that it, and all lesser positive integers, are allowed as the modulus of a 
modular_type_definition .  
Max_Base_Digits  
 The largest value allowed for the requested decimal precision in a floating_point_definition . 
Max_Digits  The largest value allowed fo r the requested decimal precision in a floating_point_definition  
that has no real_range_specification . Max_Digits is less than or equal to 
Max_Base_Digits. 
Max_Mantissa  
 The largest possible number of binary digits in  the mantissa of machine numbers of a user-
defined ordinary fixed point type. (The  mantissa is defined in Annex G.) 
Fine_Delta  The smallest delta allowed in an ordinary_fixed_point_definition  that has the real_range_-
specification  range  –1.0 .. 1.0.  
Tick  A period in seconds approximating the r eal time interval during which the value of 
Calendar.Clock rema ins constant.  
Storage_Unit  
 The number of bits per storage element. 
Word_Size  The number of bits per word. Memory_Size  An implementation-defined value that  is intended to reflect the memory size of the 
configuration in storage elements.  
Address is a definite, nonlimited type with preelabor able initialization (see 10.2.1). Address represents 
machine addresses capable of addre ssing individual storage elements. Null_ Address is an address that is 
distinct from the address of any object or program unit.  
Default_Bit_Order shall be a static constant. See 13.5.3 for an explanation of Bit_Order and 
Default_Bit_Order.  
Implementation Permissions 
An implementation may add additiona l implementation-defined declarations to package System and its 
children. However, it is usually better for the im plementation to provide additional functionality via 
implementation-defined children of System.  19 
20 21 
22 
23 24 
25 
26 
27 
28 
29 
30 31 32 
33 
34/2 
35/2 
36/2 
Ada Reference Manual — 2012 Edition 
319      13 December 2012 The Package System   13.7 Implementation Advice 
Address should be a private type.  
NOTES 
17  There are also some language-defined child packages of System defined elsewhere.  
13.7.1 The Package System.Storage_Elements 
Static Semantics 
The following language-defined library package exists:  
package System.Storage_Elements is 
   pragma Pure(Storage_Elements); 
   type Storage_Offset is range implementation-defined ; 
   subtype Storage_Count is Storage_Offset range 0..Storage_Offset'Last; 
   type Storage_Element is mod implementation-defined ; 
   for Storage_Element'Size use Storage_Unit; 
   type Storage_Array is array 
     (Storage_Offset range <>) of aliased Storage_Element; 
   for Storage_Array'Component_Size use Storage_Unit; 
   --  Address Arithmetic:  
   function  "+"(Left : Address; Right : Storage_Offset) return Address 
      with Convention => Intrinsic; 
   function  "+"(Left : Storage_Offset; Right : Address) return Address 
      with Convention => Intrinsic; 
   function  "-"(Left : Address; Right : Storage_Offset) return Address 
      with Convention => Intrinsic; 
   function  "-"(Left, Right : Address) return Storage_Offset 
      with Convention => Intrinsic; 
   function  "mod"(Left : Address; Right : Storage_Offset) 
      return Storage_Offset 
         with Convention => Intrinsic; 
   --  Conversion to/from integers:  
   type Integer_Address is implementation-defined ; 
   function  To_Address(Value : Integer_Address) return Address 
      with Convention => Intrinsic; 
   function  To_Integer(Value : Address) return Integer_Address 
      with Convention => Intrinsic; 
end System.Storage_Elements; 
Storage_Element represents a storage element. Storage_ Offset represents an offset in storage elements. 
Storage_Count represents a number of storage elements. Storage_Arra y represents a contiguous sequence 
of storage elements.  
Integer_Address is a (signed or m odular) integer subtype. To_Address and To_Integer convert back and 
forth between this type and Address.  
Implementation Requirements 
Storage_Offset'Last shall be greater than or equal to  Integer'Last or the largest possible storage offset, 
whichever is smaller. Storage_Offset'Fir st shall be <= (–Storage_Offset'Last).  
Paragraph 15 was deleted.   37 
38 
1 
2/2 
3 
4 5 
6 
7/3 
8/3 
9 
10/3 
11/3 
12 
13 
14 
Ada Reference Manual — 2012 Edition 
13.7.1    The Package System.Storage_Elements 13 December 2012      320 Implementation Advice 
Operations in System and its children should reflect the target environment sema ntics as closely as is 
reasonable. For example, on most machines, it ma kes sense for address arithmetic to “wrap around.” 
Operations that do not make se nse should raise Program_Error.  
13.7.2 The Package System.Address_To_Access_Conversions 
Static Semantics 
The following language-defined gene ric library package exists:  
generic 
    type Object(<>) is limited private; 
package System.Address_To_Access_Conversions is 
   pragma Preelaborate(Address_To_Access_Conversions); 
   type Object_Pointer is access all Object; 
   function  To_Pointer(Value : Address) return Object_Pointer 
      with Convention => Intrinsic; 
   function  To_Address(Value : Object_Pointer) return Address 
      with Convention => Intrinsic; 
end System.Address_To_Access_Conversions; 
The To_Pointer and To_Address subprograms convert  back and forth between values of types 
Object_Pointer and Address. To_P ointer(X'Address) is equal to X'Unchecked_Access for any X that 
allows Unchecked_Access. To_Poi nter(Null_Address) returns null. For other addresses, the behavior is 
unspecified. To_Address( null) returns Null_Address. To_Address(Y), where Y /= null, returns 
Y.all'Address.  
Implementation Permissions 
An implementation may place restrictions on inst antiations of Address_To_Access_Conversions.  
13.8 Machine Code Insertions 
A machine code insertion can be achie ved by a call to a subprogram whose sequence_of_statements  
contains code_statement s.  
Syntax 
code_statement ::= qualified_expression ; 
A code_statement  is only allowed in the handled_sequence_of_statements  of a subprogram_-
body . If a subprogram_body  contains any code_statement s, then within this subprogram_body  the 
only allowed form of statement  is a code_statement  (labeled or not), the only allowed declarative_-
items are use_clause s, and no exception_handler  is allowed ( comment s and pragma s are allowed 
as usual).  
Name Resolution Rules 
The qualified_expression  is expected to be of any type.  
Legality Rules 
The qualified_expression  shall be of a type declared in package System.Machine_Code.  
A code_statement  shall appear only within the scope of a with_clause  that mentions package 
System.Machine_Code.  16 
1 
2 
3/3 
4/3 
5/2 
6 
1 
2 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
321      13 December 2012 Machine Code Insertions   13.8 Static Semantics 
The contents of the library package System.Machine_ Code (if provided) are implementation defined. The 
meaning of code_statement s is implementation defined. Typically, each qualified_expression  represents 
a machine instruction or assembly directive.  
Implementation Permissions 
An implementation may place restrictions on code_statement s. An implementation is not required to 
provide package System.Machine_Code.  
NOTES 
18  An implementation may provide implementation-defined pragmas specifying register conventions and calling conventions. 
19  Machine code functions are exempt from the rule that a return statement is required. In fact, return statements are 
forbidden, since only 
code_statement s are allowed.  
20  Intrinsic subprograms (see 6.3.1, “Confor mance Rules”) can also be used to achieve machine code inse rtions. Interface 
to assembly langua ge can be achieved using the features in Annex B, “Int erface to Othe r Languages”.  
Examples 
Example of a code statement:   
M : Mask; 
procedure  Set_Mask 
  with Inline; 
procedure  Set_Mask is 
  use System.Machine_Code; --  assume “ with System.Machine_Code;”  appears somewhere above  
begin 
  SI_Format'(Code => SSM, B => M'Base_Reg, D => M'Disp);   --   Base_Reg and Disp are implementation-defined attributes  
end Set_Mask; 
13.9 Unchecked Type Conversions 
An unchecked type conversion can be achieved by  a call to an instance of the generic function 
Unchecked_Conversion.  
Static Semantics 
The following language-defined generic library function exists:  
generic 
   type Source(<>) is limited private; 
   type Target(<>) is limited private; 
function  Ada.Unchecked_Conversion(S : Source) return Target 
   with Convention => Intrinsic; 
pragma Pure(Ada.Unchecked_Conversion); 
Dynamic Semantics 
The size of the formal parameter S in an instance of Unchecked_Conversion is that of its subtype. This is 
the actual subtype passed to Source, except when the actual is an unconstrained composite subtype, in 
which case the subtype is constrained by the bounds or discriminants of the value of the actual expression 
passed to S. 
If all of the following are true, the effect of an uncheck ed conversion is to return the value of an object of 
the target subtype whose representation is the same as that of the source object S:  
• S'Size = Target'Size.  7 
8 
9 
10/2 
11 
12 
13/3 
14 
1 
2 
3/3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
13.9    Unchecked Type Conversions 13 December 2012      322 • S'Alignment is a multiple of Target'A lignment or Target'Alignment is zero. 
• The target subtype is not an unconstrained composite subtype. 
• S and the target subtype both have a contiguous representation. 
• The representation of S is a representation of an object of the target subtype.  
Otherwise, if the result type is scal ar, the result of the function is impl ementation defined, and can have an 
invalid representation (see 13.9.1). If the result type is  nonscalar, the effect is im plementation defined; in 
particular, the result can be abnormal (see 13.9.1). 
Implementation Permissions 
An implementation may return the result of an uncheck ed conversion by reference, if the Source type is 
not a by-copy type. In this case, the result of the unc hecked conversion represents simply a different (read-
only) view of the operand of the conversion.  
An implementation may place restrictions on Unchecked_Conversion.  
Implementation Advice 
Since the Size of an array object generally does not  include its bounds, the bounds should not be part of 
the converted data.  
The implementation should not generate unnecessary run- time checks to ensure that the representation of 
S is a representation of the target type. It should take  advantage of the permission to return by reference 
when possible. Restrictions on unc hecked conversions should be avoi ded unless required by the target 
environment.  
The recommended level of support fo r unchecked conversions is:  
• Unchecked conversions should be supported and s hould be reversible in the cases where this 
subclause defines the result. To enable meani ngful use of unchecked conversion, a contiguous 
representation should be used for elementary subtypes, for statica lly constrained array subtypes 
whose component subtype is one of  the subtypes described in this paragraph, and for record 
subtypes without discriminants whose component subtypes are de scribed in this paragraph.  
13.9.1 Data Validity 
Certain actions that can potentially lead to erroneous execution are not directly erroneous, but instead can 
cause objects to become abnormal . Subsequent uses of abnor mal objects can be erroneous. 
A scalar object can have an invalid representation , which means that the object's representation does not 
represent any value of the object's subtype. The primary cause of inva lid representations is uninitialized 
variables. 
Abnormal objects and invalid representations  are explained in this subclause.  
Dynamic Semantics 
When an object is first created, and any explicit or default initializations have been performed, the object 
and all of its parts are in the normal  state. Subsequent operations gene rally leave them normal. However, 
an object or part of an object can become abnormal  in the following ways:  
• An assignment to the object is disrupted due to an abort (see 9.8) or due to the failure of a 
language-defined check (see 11.6). 7/3 
8 9 
10 
11/2 
12 
13 
14/2 
15 
16 
17/3 
1 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
323      13 December 2012 Data Validity   13.9.1 • The object is not scalar, and is passed to an in out  or out parameter of an imported procedure, 
the Read procedure of an instance of Sequential_ IO, Direct_IO, or Storage_IO, or the stream 
attribute T'Read, if after return from the proce dure the representation of the parameter does not 
represent a value of the parameter's subtype. 
• The object is the return object of a function call of a nonscalar type, and the function is an 
imported function, an instance of Unchecked_Conversi on, or the stream attribute T'Input, if after 
return from the function the representation of the return object does not represent a value of the 
function's subtype. 
For an imported object, it is the programmer's responsib ility to ensure that the object remains in a normal 
state.  
Whether or not an object actually becomes abnormal in  these cases is not specified. An abnormal object 
becomes normal again upon successful completion of an assignment to the object as a whole.  
Erroneous Execution 
It is erroneous to evaluate a primary  that is a name  denoting an abnormal object, or to evaluate a prefix  
that denotes an abnormal object.  
Bounded (Run-Time) Errors 
If the representation of a scalar object does not repres ent a value of the object's subtype (perhaps because 
the object was not initialized), the object is said to have an invalid representation . It is a bounded error to 
evaluate the value of such an object. If the error is detected, either Constraint_Error or Program_Error is 
raised. Otherwise, execution continues using the invalid  representation. The rules of the language outside 
this subclause assume that all objects have valid re presentations. The semantics of operations on invalid 
representations are as follows: 
• If the representation of the object represents a valu e of the object's type, the value of the type is 
used. 
• If the representation of the object does not represen t a value of the object's type, the semantics of 
operations on such representations  is implementation-defined, but  does not by itself lead to 
erroneous or unpredictable execution, or  to other objects becoming abnormal.  
Erroneous Execution 
A call to an imported function or an instance of Unch ecked_Conversion is erroneous if the result is scalar, 
the result object has an invalid representation,  and the result is used other than as the expression  of an 
assignment_statement  or an object_declaration , as the object_ name  of an 
object_renaming_declaration , or as the prefix  of a Valid attribute. If such a result object is used as the 
source of an assignment, and the assigned value is an invalid representation for the target of the 
assignment, then any use of the target object prior to a further assignment to the target object, other than as 
the prefix  of a Valid attribute reference, is erroneous.  
The dereference of an access value is erroneous if it doe s not designate an object of an appropriate type or 
a subprogram with an appropriate profile, if it desi gnates a nonexistent object, or if it is an access-to-
variable value that designates a constant object and it did not originate from an attribute_reference applied 
to an aliased variable view of a controlled or immutably limited object. An access value whose dereference is erroneous can exist, for example, because of Unchecked_Deallocation, Unchecked_Access, 
or Unchecked_Conversion. 
NOTES 
21  Objects can become abnormal due to other kinds of actions that directly update the object's representation; such actions are generally considered directly erroneous, however.  6/2 
6.1/2 
6.2/2 
7 
8 
9 
10 
11 
12/3 
13/3 
14 
Ada Reference Manual — 2012 Edition 
13.9.2    The Valid Attribute 13 December 2012      324 13.9.2 The Valid Attribute 
The Valid attribute can be used to check the validity  of data produced by unchecked conversion, input, 
interface to foreign languages, and the like.  
Static Semantics 
For a prefix  X that denotes a scalar object (after any implicit dereference), the following attribute is 
defined:  
X'Valid Yields True if and only if the object denoted  by X is normal, has a valid representation, and 
the predicate of the nominal subtype of X evaluate s to True. The value of this attribute is of 
the predefined type Boolean.  
NOTES 
22  Invalid data can be created in the following cases (not counting erroneous or unpredictable execution):  
• an uninitialized scalar object, 
• the result of an unchecked conversion, 
• input, 
• interface to anothe r language (i ncluding machine code), 
• aborting an assignment, 
• disrupting an assignment due to the failure of a language-defined check (see 11.6), and 
• use of an object whose Address has been specified.  
23  X'Valid is not considered to be a read of X; hence, it is not an error to check the validity of invalid data. 
24  The Valid attribute may be used to check the result of calling an instance of Unchecked_Conversion (or any other 
operation that can return invalid values). Howeve r, an exception handler should also be provided because implementations 
are permitted to raise Constraint_Error or Program_Error if they detect the use of an invalid representation (see 13.9.1). 
13.10 Unchecked Access Value Creation 
The attribute Unchecked_Access is used to create acce ss values in an unsafe manner — the programmer is 
responsible for preventing “dangling references.”  
Static Semantics 
The following attribute is defined for a prefix  X that denotes an aliased view of an object:  
X'Unchecked_Access 
 All rules and semantics that apply to  X'Access (see 3.10.2) apply also to 
X'Unchecked_Access, except that, for the purposes  of accessibility rules and checks, it is as 
if X were declared immediately within a library package.  
NOTES 
25  This attribute is provided to support the situation where a local object is to be inserted into a global linked data structure, when the programmer knows that it will always be removed from the data structure prior to exiting the object's scope. The Access attribute would be illegal in this case (see 3.10. 2, “Operations of Access Types”).  
26  There is no Unchecked_Access attribute for subprograms.  1 
2 
3/3 
4 
5 
6 7 8 9 
10 11 12 
13/2 
1 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
325      13 December 2012 Storage Management   13.11 13.11 Storage Management 
Each access-to-object type has an associated storage pool. The storage allocated by an allocator  comes 
from the pool; instances of Unchecked_Deallocation re turn storage to the pool. Several access types can 
share the same pool. 
A storage pool is a variable of a type in the class r ooted at Root_Storage_Pool, wh ich is an abstract limited 
controlled type. By default, the implementation chooses a standard storage pool  for each access-to-object 
type. The user may define new pool types, and ma y override the choice of pool for an access-to-object 
type by specifying Storage_Pool for the type.  
Legality Rules 
If Storage_Pool is specified for a given access type, Storage_Size shall not be specified for it.  
Static Semantics 
The following language-defined library package exists:  
with Ada.Finalization; 
with System.Storage_Elements; 
package System.Storage_Pools is 
    pragma Preelaborate(System.Storage_Pools); 
    type Root_Storage_Pool is 
        abstract  new Ada.Finalization.Limited_Controlled with private; 
    pragma Preelaborable_Initialization(Root_Storage_Pool); 
    procedure  Allocate( 
      Pool : in out Root_Storage_Pool; 
      Storage_Address : out Address; 
      Size_In_Storage_Elements : in Storage_Elements.Storage_Count; 
      Alignment : in Storage_Elements.Storage_Count) is abstract ; 
    procedure  Deallocate( 
      Pool : in out Root_Storage_Pool; 
      Storage_Address : in Address; 
      Size_In_Storage_Elements : in Storage_Elements.Storage_Count; 
      Alignment : in Storage_Elements.Storage_Count) is abstract ; 
    function  Storage_Size(Pool : Root_Storage_Pool) 
        return Storage_Elements.Storage_Count is abstract ; 
private 
   ... -- not specified by the language  
end System.Storage_Pools; 
A storage pool type  (or pool type ) is a descendant of Root_Storage_Pool. The elements  of a storage pool 
are the objects allocated in the pool by allocator s.  
For every access-to-object subtype S, the following representation attributes are defined:  
S'Storage_Pool 
 Denotes the storage pool of the type of S. The type of this attribute is Root_Storage_-
Pool'Class. 
S'Storage_Size 
 Yields the result of calling Storage_Size(S' Storage_Pool), which is intended to be a 
measure of the number of storag e elements reserved for the pool . The type of this attribute 
is universal_integer .  
Storage_Size or Storage_Pool may be specified  for a nonderived access-to-object type via an attribute_-
definition_clause ; the name  in a Storage_Pool clause shall denote a variable. 1 
2/2 
3 
4 
5 
6/2 
7 
8 
9 
10 
11 
12/2 
13 
14 
15 
Ada Reference Manual — 2012 Edition 
13.11    Storage Management 13 December 2012      326 An allocator  of a type T that does not support subpools allocates storage from T's storage pool. If the 
storage pool is a user-defined object, then the storage is allocated by calling Allocate as described below. 
Allocator s for types that support subpools are described in 13.11.4.  
If Storage_Pool is not specified for a type defined by an access_to_object_definition , then the 
implementation chooses a standard st orage pool for it in an implementati on-defined manner. In this case, 
the exception Storage_Error is raised by an allocator  if there is not enough stor age. It is implementation 
defined whether or not the implementation provides us er-accessible names for the standard pool type(s).  
If Storage_Size is specified for an access type, then the Storage_Size of this pool is at least that requested, 
and the storage for the pool is reclaimed when the ma ster containing the declaration of the access type is 
left. If the implementation cannot satisfy the request , Storage_Error is raised at the point of the attribute_-
definition_clause . If neither Storage_Pool nor Storage_Si ze are specified, then the meaning of 
Storage_Size is implementation defined.  
If Storage_Pool is specified for an access type, then the specified pool is used. 
The effect of calling Allocate and Deallocate for a standa rd storage pool directly (rather than implicitly via 
an allocator  or an instance of Unchecked_D eallocation) is unspecified.  
Erroneous Execution 
If Storage_Pool is specified for an access type, then if Allocate can satisfy the request, it should allocate a 
contiguous block of memory, and return the address of  the first storage element in Storage_Address. The 
block should contain Size_In_Stora ge_Elements storage elements, and should be aligned according to 
Alignment. The allocated storage s hould not be used for any other purpose while the pool element remains 
in existence. If the request cannot be satisfied, th en Allocate should propagate an exception (such as 
Storage_Error). If Allocate behaves in any other ma nner, then the program execution is erroneous.  
Implementation Requirements 
The Allocate procedure of a user-defined storage pool object P may be called by the implementation only 
to allocate storage for a type T whose pool is P, only at the following points: 
• During the execution of an allocator  of type T; 
• During the execution of a return statement for a function whose result is built-in-place in the 
result of an allocator  of type T; 
• During the execution of an assignment operation w ith a target of an allocated object of type T 
with a part that has an unconstrained discriminated subtype with defaults. 
For each of the calls of Allocate described above, P (equivalent to T'Storage_Pool) is passed as the Pool 
parameter. The Size_In_Storage_Ele ments parameter indicates the numbe r of storage elements to be 
allocated, and is no more than D'Max_Size_In_Storage_Elements, where D is the designated subtype of T. 
The Alignment parameter is a nonzero integral multiple of D'Alignment if D is a specific type, and 
otherwise is a nonzero integral multiple of the alignmen t of the specific type identified by the tag of the 
object being created; it is unspecified if there is no su ch value. The Alignment parameter is no more than 
D'Max_Alignment_For_Allocation. The result returned in the Storage_A ddress parameter is used as the 
address of the allocated storage, which is a con tiguous block of memory of  Size_In_Storage_Elements 
storage elements. Any exception propagated by Allocate is propagated by the construct that contained the 
call. 
The number of calls to Allocate needed to implement an allocator  for any particular type is unspecified. 
The number of calls to Deallocate needed to im plement an instance of Unchecked_Deallocation (see 
13.11.2) for any particular object is the same as the number of Allocate calls for that object. 16/3 
17 
18 
19 
20 
21 
21.1/3 
21.2/3 
21.3/3 
21.4/3 21.5/3 
21.6/3 
Ada Reference Manual — 2012 Edition 
327      13 December 2012 Storage Management   13.11 The Deallocate procedure of a us er-defined storage pool object P may be called by the implementation to 
deallocate storage for a type T whose pool is P only at the places when an Allocate call is allowed for P, 
during the execution of an instance of Unchecked_Deallocation for T, or as part of the finalization of the 
collection of T. For such a call of Deallocate, P (equivalent to T'Storage_Pool) is passed as the Pool 
parameter. The value of the Storage_ Address parameter for a call to Deallo cate is the value returned in the 
Storage_Address parameter of the corresponding su ccessful call to Allocate. The values of the 
Size_In_Storage_Elements and Ali gnment parameters are the same values passed to the corresponding 
Allocate call. Any exception propagated by Deallocate is  propagated by the construct that contained the 
call. 
Documentation Requirements 
An implementation shall document the set of values th at a user-defined Allocat e procedure needs to accept 
for the Alignment parameter. An im plementation shall document how the standard storage pool is chosen, 
and how storage is allocated by standard storage pools.  
Implementation Advice 
An implementation should document any cases in which it dynamically  allocates heap storage for a 
purpose other than the evaluation of an allocator .  
A default (implementation-provided) storage pool for an access-to-constant type should not have overhead 
to support deallocation of individual objects.  
The storage pool used for an allocator  of an anonymous access type should be determined as follows: 
• If the allocator  is defining a coextension (see 3.10.2) of an object being created by an outer 
allocator , then the storage pool used for the outer allocator  should also be used for the 
coextension; 
• For other access discriminants a nd access parameters, the storage pool should be created at the 
point of the allocator , and be reclaimed when the allocated object becomes inaccessible; 
• If the allocator  defines the result of a function with an access result, the storage pool is 
determined as though the allocator  were in place of the call of the function. If the call is the 
operand of a type conversion, the storage pool is th at of the target access type of the conversion. 
If the call is itself defining the result of a function with an access result, this rule is applied recursively; 
• Otherwise, a default storage pool should be created at the point where the anonymous access 
type is elaborated; such a storage pool need not support deallocation of individual objects.  
NOTES 
27  A user-defined storage pool type can be obtained by extending the Root_Storage_Pool type, and overriding the primitive subprograms Allocate, Deallocate, and Storage_Size. A user-defined storage pool can then be obtained by declaring an object of the type extension. The user can override Initialize and Finalize if there is any need for nontrivial initialization and finalization for a user-defined pool type. For example, Finalize might reclaim blocks of storage that are allocated separately from the pool object itself. 
28  The writer of the user-defined allocation and deallocation procedures, and users of 
allocator s for the associated access 
type, are responsible for dealing with any interactions with tasking. In particular:  
• If the allocator s are used in different tasks, they require mutual exclusion. 
• If they are used inside protected objects, they cannot block. 
• If they are used by interrupt handlers (see C.3, “Interrupt Support”), the mutual exclusion mechanism has to 
work properly in that context.  
29  The primitives Allocate, Deallocate, and Storage_Size are declared as abstract (see 3.9.3), and therefore they have to 
be overridden when a new (nonabstract) storage pool type is declared.  21.7/3 
22 
23 
24 
25/2 
25.1/2 
25.2/2 
25.3/3 
25.4/2 
26 
27 
28 
29 30 
31 
Ada Reference Manual — 2012 Edition 
13.11    Storage Management 13 December 2012      328 Examples 
To associate an access type with a storage pool object, the user first declares a pool object of some type 
derived from Root_Storage_Pool. Then, the user de fines its Storage_Pool attribute, as follows: 
Pool_Object : Some_Storage_Pool_Type; 
type T is access Designated; 
for T'Storage_Pool use Pool_Object; 
Another access type may be added to an existing storage pool, via:  
for T2'Storage_Pool use T'Storage_Pool; 
The semantics of this is implementation defined for a standard storage pool.  
As usual, a derivative of Root_Sto rage_Pool may define additional opera tions. For example, consider the 
Mark_Release_Pool_Type defined in 13.11.6, that ha s two additional operations, Mark and Release, the 
following is a possible use:  
type Mark_Release_Pool_Type 
   (Pool_Size : Storage_Elements.Storage_Count)         is new Subpools.Root_Storage_Pool_With_Subpools with private ; 
           -- As defined in package MR_Pool, see 13.11.6  
... Our_Pool : Mark_Release_Pool_Type (Pool_Size => 2000); 
My_Mark : MR_Pool.Subpool_Handle; -- See 13.11.6  
type Acc is access ...; 
for Acc'Storage_Pool use Our_Pool; 
... 
My_Mark := Mark(Our_Pool); 
... --  Allocate objects using “ new (My_Mark) Designated(...)”.  
Release(My_Mark); --  Finalize objects and reclaim storage.  
13.11.1 Storage Allocation Attributes 
The Max_Size_In_Storage_Elements and Max_Alignment_For_Allocation a ttributes may be useful in 
writing user-defined pool types.  
Static Semantics 
For every subtype S, the following attributes are defined:  
S'Max_Size_In_Storage_Elements 
 Denotes the maximum value for Size_In_Storage _Elements that could be requested by the 
implementation via Allocate for an access type whose designated subtype is S. The value of this attribute is of type universal_integer .  
S'Max_Alignment_For_Allocation 
 Denotes the maximum value for Alignment that  could be requested by the implementation 
via Allocate for an access type whose designated subtype is S. The value of this attribute is of type universal_integer .  
For a type with access discriminants, if the implementation allocates space for a coextension in the same 
pool as that of the object having the access discrimina nt, then these attributes account for any calls on 
Allocate that could be performed to provide space for such coextensions.  32 
33 
34 
35 
36 
37 
38/3 
39/3 
40 
41/3 
42/3 
43/3 
1/3 
2/3 
3/3 
4/3 
5/3 
Ada Reference Manual — 2012 Edition 
329      13 December 2012 Unchecked Storage Deallocation   13.11.2 13.11.2 Unchecked Storage Deallocation 
Unchecked storage deallocation of an object designated by a value of an access type is achieved by a call 
to an instance of the generic pr ocedure Unchecked_Deallocation.  
Static Semantics 
The following language-defined gene ric library procedure exists:  
generic 
   type Object(<>) is limited private; 
   type Name   is access  Object; 
procedure  Ada.Unchecked_Deallocation(X : in out Name) 
   with Convention => Intrinsic; 
pragma Preelaborate(Ada.Unchecked_Deallocation); 
Legality Rules 
A call on an instance of Unchecked_Deallocation is ille gal if the actual access type of the instance is a 
type for which the Storage_Size has been specified by a static expression with value zero or is defined by 
the language to be zero. In addition to the places wh ere Legality Rules normally apply (see 12.3), this rule 
applies also in the private part of an instance of a generic unit. 
Dynamic Semantics 
Given an instance of Unchecked_Deallocation declared as follows:  
procedure  Free is 
    new Ada.Unchecked_Deallocation( 
        object_subtype_name , access_to_variable_subtype_name ); 
Procedure Free has the following effect:  
1. After executing Free(X), the value of X is null. 
2. Free(X), when X is already equal to null, has no effect. 
3. Free(X), when X is not equal to null first performs finalization of  the object designated by X 
(and any coextensions of the object — see 3.10.2), as  described in 7.6.1. It then deallocates the 
storage occupied by the object designated by X (and any coextensions). If the storage pool is a 
user-defined object, then the storage is deallocat ed by calling Deallocate as described in 13.11. 
There is one exception: if the object being fr eed contains tasks, the object might not be 
deallocated.  
After Free(X), the object designated by X, and any subcomponents (and coextensions) thereof, no longer 
exist; their storage can be reused for other purposes.  
Bounded (Run-Time) Errors 
It is a bounded error to free a discriminated, untermi nated task object. The possible consequences are:  
• No exception is raised. 
• Program_Error or Tasking_Error is raised  at the point of the deallocation. 
• Program_Error or Tasking_Error is raised in th e task the next time it references any of the 
discriminants.  
In the first two cases, the storage for the discriminant s (and for any enclosing object if it is designated by 
an access discriminant of the task) is not reclaimed prior to task termination.  1 
2 
3/3 
3.1/3 
4 
5 
6 
7 
8 
9/3 
10/2 
11 
12 
13 14 
15 
Ada Reference Manual — 2012 Edition 
13.11.2    Unchecked Storage Deallocation 13 December 2012      330 Erroneous Execution 
Evaluating a name that denotes a nonexistent object, or a protected subprogram or subprogram renaming 
whose associated object (if any) is nonexistent, is erroneous. The execution of a call to an instance of 
Unchecked_Deallocation is erroneous if the object was created other than by an allocator  for an access 
type whose pool is Name'Storage_Pool. 
Implementation Advice 
For a standard storage pool, Free should actually reclaim the storage.  
A call on an instance of Unchecked_Deallocation w ith a nonnull access value should raise Program_Error 
if the actual access type of the instance is a type for which the Storage_Size has been specified to be zero 
or is defined by the language to be zero.  
NOTES 
30  The rules here that refer to Free apply to any instance of Unchecked_Deallocation. 
31  Unchecked_Deallocation ca nnot be instantiated for an access- to-constant type. This is imp lied by the rule s of 12.5.4.  
13.11.3 Default Storage Pools 
This paragraph was deleted.  
Syntax 
The form of a pragma  Default_Storage_Pool is as follows:  
  pragma  Default_Storage_Pool ( storage_pool_indicator );  
storage_pool_indicator ::= storage_pool_ name  | null 
A pragma  Default_Storage_Pool is allowed imme diately within the visible part of a 
package_specification , immediately within a declarative_part , or as a configuration pragma.  
Name Resolution Rules 
The storage_pool_ name  is expected to be of type Root_Storage_Pool'Class.  
Legality Rules 
The storage_pool_ name  shall denote a variable. 
If the pragma  is used as a configuration pragma, the storage_pool_indicator  shall be null, and it defines 
the default pool  to be null within all applicable compilation units (see 10.1.5), except within the 
immediate scope of another pragma  Default_Storage_Pool. Otherwise, the pragma occurs immediately 
within a sequence of declarations, and it defines the de fault pool within the immediate scope of the pragma 
to be either null or the pool denoted by the storage_pool_ name , except within the immediate scope of a 
later pragma Default_Storage_Pool. Thus, an inner pragma overrides an outer one. 
A pragma  Default_Storage_Pool shall not be used as a c onfiguration pragma that applies to a compilation 
unit that is within the immediate scope of another pragma  Default_Storage_Pool. 
Static Semantics 
The language-defined aspect Default_Storage_Pool may be specified for a generic instance; it defines the 
default pool for access types within an instance. The exp ected type for the Default_Storage_Pool aspect is 
Root_Storage_Pool'Class. The aspect_definition  must be a name that denotes a variable. This aspect 
overrides any Default_Storage_Pool pragma that might  apply to the generic unit; if the aspect is not 
specified, the default pool of the instance is that defined for the generic unit. 16/3 
17 
17.1/3 
18 
19 
1/3 
2/3 
3/3 
3.1/3 3.2/3 
3.3/3 
4/3 
4.1/3 
4.2/3 
5/3 
Ada Reference Manual — 2012 Edition 
331      13 December 2012 Default Storage Pools   13.11.3 For nonderived access types declared in places where the default pool is defined by the pragma or aspect, 
their Storage_Pool or Storage_Size attribute is determined as follows, unless Storage_Pool or Storage_Size is specified for the type: 
• If the default pool is null, the Storage_Size attribute is defined by the language to be zero. 
Therefore, an 
allocator  for such a type is illegal. 
• If the default pool is nonnull, the St orage_Pool attribute is that pool. 
Otherwise, there is no default pool; the standard storag e pool is used for the type as described in 13.11. 
This paragraph was deleted.  
Implementation Permissions 
An object created by an allocator  that is passed as the actual parameter to an access parameter may be 
allocated on the stack, and automatically r eclaimed, regardless of the default pool..  
NOTES 
32  Default_Storage_Pool may be used with restrictions No_Coextensions and No_Access_Parameter_Allocators (see H.4) to ensure that all 
allocator s use the default pool.  
13.11.4 Storage Subpools 
This subclause defines a package to support the pa rtitioning of a storage pool into subpools. A subpool 
may be specified as the default to be used for allo cation from the associated storage pool, or a particular 
subpool may be specified as part of an allocator  (see 4.8).  
Static Semantics 
The following language-defined  library package exists: 
package System.Storage_Pools.Subpools is 
   pragma Preelaborate (Subpools); 
   type Root_Storage_Pool_With_Subpools is 
      abstract new  Root_Storage_Pool with private ; 
   type Root_Subpool is abstract tagged limited private ; 
   type Subpool_Handle is access all  Root_Subpool'Class; 
   for Subpool_Handle'Storage_Size use 0; 
   function  Create_Subpool (Pool : in out Root_Storage_Pool_With_Subpools) 
      return not null  Subpool_Handle is abstract ; 
   -- The following operations are intended for pool implementers:  
   function  Pool_of_Subpool (Subpool : not null  Subpool_Handle) 
      return access  Root_Storage_Pool_With_Subpools'Class; 
   procedure  Set_Pool_of_Subpool ( 
      Subpool : in not null  Subpool_Handle; 
      To : in out Root_Storage_Pool_With_Subpools'Class); 
   procedure  Allocate_From_Subpool ( 
      Pool : in out Root_Storage_Pool_With_Subpools; 
      Storage_Address : out Address; 
      Size_In_Storage_Elements : in Storage_Elements.Storage_Count; 
      Alignment : in Storage_Elements.Storage_Count; 
      Subpool : in not null  Subpool_Handle) is abstract  
         with Pre'Class => Pool_of_Subpool(Subpool) = Pool'Access; 
   procedure  Deallocate_Subpool ( 
      Pool : in out Root_Storage_Pool_With_Subpools; 
      Subpool : in out Subpool_Handle) is abstract  
         with Pre'Class => Pool_of_Subpool(Subpool) = Pool'Access; 6/3 
6.1/3 
6.2/3 
6.3/3 
7/3 
8/3 
9/3 
1/3 
2/3 
3/3 
4/3 5/3 
6/3 
7/3 8/3 
9/3 
10/3 
11/3 
12/3 
Ada Reference Manual — 2012 Edition 
13.11.4    Storage Subpools 13 December 2012      332    function  Default_Subpool_for_Pool ( 
      Pool : in out Root_Storage_Pool_With_Subpools) 
         return not null  Subpool_Handle; 
   overriding  
   procedure  Allocate ( 
      Pool : in out Root_Storage_Pool_With_Subpools; 
      Storage_Address : out Address; 
      Size_In_Storage_Elements : in Storage_Elements.Storage_Count; 
      Alignment : in Storage_Elements.Storage_Count); 
   overriding  
   procedure  Deallocate ( 
      Pool : in out Root_Storage_Pool_With_Subpools; 
      Storage_Address : in Address; 
      Size_In_Storage_Elements : in Storage_Elements.Storage_Count; 
      Alignment : in Storage_Elements.Storage_Count) is null; 
   overriding  
   function  Storage_Size (Pool : Root_Storage_Pool_With_Subpools) 
      return Storage_Elements.Storage_Count 
          is (Storage_Elements.Storage_Count'Last); 
private 
   ... -- not specified by the language  
end System.Storage_Pools.Subpools; 
A subpool  is a separately reclaimable portion of a storage pool, identified by an object of type 
Subpool_Handle (a subpool handle ). A subpool handle also identifies the enclosing storage pool, a storage 
pool that supports subpools , which is a storage pool whose type is descended from 
Root_Storage_Pool_With_Subpools. A subpool is cr eated by calling Create_Subpool or a similar 
constructor; the constructor returns the subpool handle. 
A subpool object  is an object of a type descended from Root_Subpool. Typically, subpool objects are 
managed by the containing storage pool; only the handles  need be exposed to clients of the storage pool. 
Subpool objects are designated by subpool handles, a nd are the run-time representation of a subpool. 
Each subpool belongs  to a single storage pool (which will alwa ys be a pool that supports subpools). An 
access to the pool that a subpool belongs to can be  obtained by calling Pool_of_Subpool with the subpool 
handle. Set_Pool_of_Subpool causes the subpool of the s ubpool handle to belong to the given pool; this is 
intended to be called from subpool constructors  like Create_Subpool. Set_Pool_of_Subpool propagates 
Program_Error if the subpool already belongs to a pool. 
When an allocator  for a type whose storage pool supports subpools is evaluated, a call is made on 
Allocate_From_Subpool passing in a Subpool_Handle, in a ddition to the parameters as defined for calls on 
Allocate (see 13.11). The subpool designated by the subpool_handle_ name  is used, if specified in an 
allocator . Otherwise, Default_Subpool_for_Pool of the P ool is used to provide a subpool handle. All 
requirements on the Allocate procedure also apply to Allocate_from_Subpool. 
Legality Rules 
If a storage pool that supports subpools is specified as  the Storage_Pool for an access type, the access type 
is called a subpool access type . A subpool access type shall be a pool-specific access type. 
The accessibility level of a subpool access type shall not be  statically deeper than that of the storage pool 
object. If the specified storage pool object is a storage pool that supports subpools, then the name  that 
denotes the object shall not denote part of a formal para meter, nor shall it denote part of a dereference of a 
value of a non-library-level general access type. In addition to the places where Legality Rules normally 
apply (see 12.3), these rules also apply in the pr ivate part of an instance of a generic unit.  13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
20/3 
21/3 
22/3 
23/3 
Ada Reference Manual — 2012 Edition 
333      13 December 2012 Storage Subpools   13.11.4 Dynamic Semantics 
When an access type with a specified storage pool is  frozen (see 13.14), if the tag of the storage pool 
object identifies a storage pool that suppor ts subpools, the following checks are made: 
• the name  used to specify the storage pool object does not denote part of a formal parameter nor 
part of a dereference of a value of a non-library-level general access type; and 
• the accessibility level of the access type is not deeper than that of the storage pool object.  
Program_Error is raised if either of these checks fail. 
A call to Subpools.Allocate(P, Addr, Size, Align) does the following: 
Allocate_From_Subpool 
  (Root_Storage_Pool_With_Subpools'Class(P),    Addr, Size, Align,    Subpool => Default_Subpool_for_Pool                 (Root_Storage_Pool_With_Subpools'Class(P))); 
An allocator  that allocates in a subpool ra ises Program_Error if the allocated object has task parts. 
Unless overridden, Default_Subpool_for _Pool propagates Program_Error. 
Implementation Permissions 
When an allocator for a type whose storage pool is of type Root_Storage_Pool 'Class is evaluated, but 
supports subpools, the implementation may call Allo cate rather than Allocat e_From_Subpool. This will 
have the same effect, so long as Allocate has not been overridden. 
NOTES 
33  A user-defined storage pool type that supports subpools can be implemented by extending the Root_Storage_Pool_With_Subpools type, and overriding the primitive subprograms Create_Subpool, Allocate_From_Subpool, and Deallocate_Subpool. Create_Subpool should call Set_Pool_Of_Subpool before returning the subpool handle. To make use of such a pool, a user would declare an object of the type extension, use it to define the Storage_Pool attribute of one or more access types, and then call Create_Subpool to obtain subpool handles associated with the pool. 
34  A user-defined storage pool type that supports subpools may define additional subpool constructors similar to 
Create_Subpool (these typically will have additional parameters). 
35  The pool implementor should override Default_Subpool_For_Pool if the pool is to support a default subpool for the 
pool. The implementor can override Deallocate if individual object reclamation is to be supported, and can override Storage_Size if there is some limit on the total size of the storage pool. The implementor can override Initialize and Finalize if there is any need for nontrivial initialization and finalization for the pool as a whole. For example, Finalize might reclaim blocks of storage that are allocated over a nd above the space occupied by the pool object itself. The pool 
implementor may extend the Root_Subpool ty pe as necessary to carry  additional information with each s ubpool provided 
by Create_Subpool. 
13.11.5 Subpool Reclamation 
A subpool may be explicitly deallocated  using Unchecked_Deallocate_Subpool.  
Static Semantics 
The following language-defined library procedure exists: 
with System.Storage_Pools.Subpools; 
procedure  Ada.Unchecked_Deallocate_Subpool 
   (Subpool : in out System.Storage_Pools.Subpools.Subpool_Handle); 
If Subpool is null, a call on Unchecked_Deallocate_Subpool has no effect. Otherwise, the subpool is 
finalized, and Subpool is set to null. 24/3 
25/3 
26/3 
27/3 
28/3 
29/3 
30/3 
31/3 
32/3 
33/3 
34/3 
35/3 
1/3 
2/3 
3/3 
4/3 
Ada Reference Manual — 2012 Edition 
13.11.5    Subpool Reclamation 13 December 2012      334 Finalization of a subpool has the following effects: 
• The subpool no longer belongs to any pool; 
• Any of the objects allocated from the subpool that still exist are finalized in  an arbitrary order; 
• The following dispatching call is then made:  
   Deallocate_Subpool(Pool_of_Subpool(Subpool). all, Subpool); 
Finalization of a Root_Storage_P ool_With_Subpools object finalizes all subpools that belong to that pool 
that have not yet been finalized. 
13.11.6 Storage Subpool Example 
Examples 
The following example is a simple but complete im plementation of the classic Mark/Release pool using 
subpools: 
with System.Storage_Pools.Subpools; 
with System.Storage_Elements; 
with Ada.Unchecked_Deallocate_Subpool; 
package MR_Pool is 
   use System.Storage_Pools; 
      -- For uses of Subpools.  
   use System.Storage_Elements; 
      -- For uses of Storage_Count and Storage_Array.  
   -- Mark and Release work in a stack fashion, and allocations are not allowed  
   -- from a subpool other than the one at the top of the stack. This is also  
   -- the default pool.  
   subtype Subpool_Handle is Subpools.Subpool_Handle; 
   type Mark_Release_Pool_Type (Pool_Size : Storage_Count) is new 
      Subpools.Root_Storage_Pool_With_Subpools with private ; 
   function  Mark (Pool : in out Mark_Release_Pool_Type) 
      return not null  Subpool_Handle; 
   procedure  Release (Subpool : in out Subpool_Handle) renames 
      Ada.Unchecked_Deallocate_Subpool; 
private 
   type MR_Subpool is new Subpools.Root_Subpool with record  
      Start : Storage_Count;    end record ; 
   subtype Subpool_Indexes is Positive range 1 .. 10; 
   type Subpool_Array is array  (Subpool_Indexes) of aliased  MR_Subpool; 
   type Mark_Release_Pool_Type (Pool_Size : Storage_Count) is new 
      Subpools.Root_Storage_Pool_With_Subpools with record  
      Storage         : Storage_Array (0 .. Pool_Size-1);       Next_Allocation : Storage_Count := 0;       Markers         : Subpool_Array;       Current_Pool    : Subpool_Indexes := 1;    end record ; 
   overriding  
   function  Create_Subpool (Pool : in out Mark_Release_Pool_Type) 
      return not null  Subpool_Handle; 
   function  Mark (Pool : in out Mark_Release_Pool_Type) 
      return not null  Subpool_Handle renames Create_Subpool; 5/3 
6/3 
7/3 8/3 
9/3 
10/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 8/3 9/3 
10/3 
11/3 
12/3 
13/3 
Ada Reference Manual — 2012 Edition 
335      13 December 2012 Storage Subpool Example   13.11.6    overriding  
   procedure  Allocate_From_Subpool ( 
      Pool : in out Mark_Release_Pool_Type; 
      Storage_Address : out System.Address; 
      Size_In_Storage_Elements : in Storage_Count; 
      Alignment : in Storage_Count; 
      Subpool : not null  Subpool_Handle); 
   overriding  
   procedure  Deallocate_Subpool ( 
      Pool : in out Mark_Release_Pool_Type; 
      Subpool : in out Subpool_Handle); 
   overriding  
   function  Default_Subpool_for_Pool (Pool : in out Mark_Release_Pool_Type) 
      return not null  Subpool_Handle; 
   overriding  
   procedure  Initialize (Pool : in out Mark_Release_Pool_Type); 
   -- We don't need Finalize.  
end MR_Pool; 
package body  MR_Pool is 
   use type  Subpool_Handle; 
   procedure  Initialize (Pool : in out Mark_Release_Pool_Type) is 
      -- Initialize the first default subpool.  
   begin 
      Pool.Markers(1).Start := 1;       Subpools.Set_Pool_of_Subpool          (Pool.Markers(1)'Unchecked_Access, Pool);    end Initialize; 
   function  Create_Subpool (Pool : in out Mark_Release_Pool_Type) 
      return not null  Subpool_Handle is 
      -- Mark the current allocation location.  
   begin 
      if Pool.Current_Pool = Subpool_Indexes'Last then 
         raise Storage_Error; -- No more subpools.  
      end if; 
      Pool.Current_Pool := Pool.Current_Pool + 1; -- Move to the next subpool  
      return Result : constant not null  Subpool_Handle := 
         Pool.Markers(Pool.Current_Pool)'Unchecked_Access       do 
         Pool.Markers(Pool.Current_Pool).Start := Pool.Next_Allocation;          Subpools.Set_Pool_of_Subpool (Result, Pool);       end return ; 
   end Create_Subpool; 
   procedure  Deallocate_Subpool ( 
      Pool : in out Mark_Release_Pool_Type; 
      Subpool : in out Subpool_Handle) is 
   begin 
      if Subpool /= Pool.Markers(Pool.Current_Pool)'Unchecked_Access then 
         raise Program_Error; -- Only the last marked subpool can be released.  
      end if; 
      if Pool.Current_Pool /= 1 then 
         Pool.Next_Allocation := Pool.Markers(Pool.Current_Pool).Start;          Pool.Current_Pool := Pool.Current_Pool - 1; -- Move to the previous subpool  
      else -- Reinitialize the default subpool:  
         Pool.Next_Allocation := 1;          Subpools.Set_Pool_of_Subpool             (Pool.Markers(1)'Unchecked_Access, Pool);       end if; 
   end Deallocate_Subpool; 14/3 
15/3 
16/3 
17/3 
18/3 
19/3 20/3 21/3 22/3 
23/3 
24/3 
25/3 
Ada Reference Manual — 2012 Edition 
13.11.6    Storage Subpool Example 13 December 2012      336    function  Default_Subpool_for_Pool (Pool : in out Mark_Release_Pool_Type) 
      return not null  Subpool_Handle is 
   begin 
      return Pool.Markers(Pool.Current_Pool)'Unchecked_Access; 
   end Default_Subpool_for_Pool; 
   procedure  Allocate_From_Subpool ( 
      Pool : in out Mark_Release_Pool_Type; 
      Storage_Address : out System.Address; 
      Size_In_Storage_Elements : in Storage_Count; 
      Alignment : in Storage_Count; 
      Subpool : not null  Subpool_Handle) is 
   begin 
      if Subpool /= Pool.Markers(Pool.Current_Pool)'Unchecked_Access then 
         raise Program_Error; -- Only the last marked subpool can be used for allocations.  
      end if; 
      -- Correct the alignment if necessary:  
      Pool.Next_Allocation := Pool.Next_Allocation +          ((-Pool.Next_Allocation) mod Alignment); 
      if Pool.Next_Allocation + Size_In_Storage_Elements > 
         Pool.Pool_Size then 
         raise Storage_Error; -- Out of space.  
      end if; 
      Storage_Address := Pool.Storage (Pool.Next_Allocation)'Address;       Pool.Next_Allocation :=          Pool.Next_Allocation + Size_In_Storage_Elements;    end Allocate_From_Subpool; 
end MR_Pool; 
13.12 Pragma Restrictions and Pragma Profile 
A pragma  Restrictions expresses the user's inte nt to abide by certain restrictions. A pragma  Profile 
expresses the user's intent to abide by a set of Rest rictions or other specified run-time policies. These may 
facilitate the construction of simpler run-time environments.  
Syntax 
The form of a pragma  Restrictions is as follows:  
  pragma  Restrictions( restriction {, restriction }); 
restriction ::= restriction_ identifier  
    | restriction_parameter_ identifier  => restriction_parameter_argument  
restriction_parameter_argument ::= name  | expression  
Name Resolution Rules 
Unless otherwise specified for a particular restriction, the expression  is expected to be of any integer type.  
Legality Rules 
Unless otherwise specified for a particular restriction, the expression  shall be static, and its value shall be 
nonnegative.  
Paragraph 7 was deleted.   
Post-Compilation Rules 
A pragma  Restrictions is a configuration pragma. If a pragma  Restrictions applies to any compilation unit 
included in the partition, this may impose either (or both)  of two kinds of requirements, as specified for the 
particular restriction: 26/3 
27/3 
28/3 
29/3 
1/3 
2 
3 
4/2 
4.1/2 
5 
6 
8/3 
Ada Reference Manual — 2012 Edition 
337      13 December 2012 Pragma Rest rictions and Pragma Profile   13.12 • A restriction may impose requirements on some or all of the units comprising the partition. 
Unless otherwise specified for a particular restric tion, such a requirement applies to all of the 
units comprising the partition and is enforced via a post-compilation check. 
• A restriction may impose require ments on the run-time behavior of the program, as indicated by 
the specification of run-time behavior associ ated with a violation of the requirement. 
For the purpose of checking whether a partition contains  constructs that violate any restriction (unless 
specified otherwise for a particular restriction): 
• Generic instances are logically expanded at the point of instantiation; 
• If an object of a type is declared or allocated  and not explicitly initialized, then all expressions 
appearing in the definition for the type and an y of its ancestors are presumed to be used; 
• A default_expression  for a formal parameter or a generic formal object is considered to be used 
if and only if the corresponding actual parameter is not provided in a given call or instantiation.  
Implementation Permissions 
An implementation may provide impl ementation-defined restrictions; the identifier for an implementation-
defined restriction shall di ffer from those of the language-defined restrictions.  
An implementation may place limitations on the values of the expression  that are supported, and 
limitations on the supported combinations of restricti ons. The consequences of violating such limitations 
are implementation defined.  
An implementation is permitted to omit restriction checks for code that is recognized at compile time to be 
unreachable and for which no code is generated. 
Whenever enforcement of a restriction is not required prior to execution, an implementation may 
nevertheless enforce the restriction prior to executi on of a partition to which the restriction applies, 
provided that every execution of the partition would violate the restriction.  
Syntax 
The form of a pragma  Profile is as follows:  
  pragma  Profile ( profile_ identifier  {, profile_ pragma_argument_association }); 
Legality Rules 
The profile_ identifier  shall be the name of a usage profile. The semantics of any profile_ pragma_-
argument_association s are defined by the usage profile specified by the profile_ identifier .  
Static Semantics 
A profile is equivalent to the set of configuration pragmas that is defined for each usage profile.  
Post-Compilation Rules 
A pragma  Profile is a configuration pragma. There may be more than one pragma  Profile for a partition.  
Implementation Permissions 
An implementation may provide implementation-defined usage profiles; the identifier for an 
implementation-defined usage profile shall differ fro m those of the language-defined usage profiles. 
NOTES 
36  Restrictions intended to facilitate the construction of efficient tasking run-time systems are defined in D.7. Restrictions  
intended for use when constructing high integrity systems are defined in H.4. 8.1/3 
8.2/3 
8.3/1 
8.4/1 
8.5/1 
8.6/1 
8.7/3 
9 
9.1/1 
9.2/1 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
16/2 
Ada Reference Manual — 2012 Edition 
13.12    Pragma Restrictions and Prag ma Profile 13 December 2012      338 37  An implementation has to enforce the restrictions in cases where enforcement is required, even if it chooses not to take 
advantage of the restrictions in terms of efficiency.  
13.12.1 Language-Defined Restrictions and Profiles 
Static Semantics 
The following restriction_ identifier s are language defined (additional re strictions are defined in the 
Specialized Needs Annexes): 
No_Implementation_Aspect_Specifications  
 There are no implementation-defined aspects specified by an aspect_specification . This 
restriction applies only to the current compilati on or environment, not the entire partition.  
No_Implementation_Attributes  
 There are no implementation-defi ned attributes. This restriction applies only to the current 
compilation or environment, not the entire partition.  
No_Implementation_Identifiers  
 There are no usage names that denote declara tions with implementation-defined identifiers 
that occur within language-defined packages  or instances of language-defined generic 
packages. Such identifiers can arise as follows:  
• The following language-defined pack ages and generic packages allow 
implementation-defined identifiers: 
• package System (see 13.7); 
• package Standard (see A.1); 
• package Ada.Command_Line (see A.15); 
• package Interfaces.C (see B.3); 
• package Interfaces.C.Strings (see B.3.1); 
• package Interfaces.C.Pointers (see B.3.2); 
• package Interfaces.COBOL (see B.4); 
• package Interfaces.Fortran (see B.5);  
• The following language-defined packages  contain only implementation-defined 
identifiers: 
• package System.Machine_Code (see 13.8); 
• package Ada.Directories.Information (see A.16); 
• nested Implementation packages of the Queue containers (see A.18.28-31); 
• package Interfaces (see B.2); 
• package Ada.Interrupts.Names (see C.3.2). 
 For package Standard, Standard.Long_Integer  and Standard.Long_Float are considered 
language-defined identifiers, but identifiers such as Standard.Short_Short_Integer are 
considered implementation-defined. 
 This restriction applies only to the current  compilation or environment, not the entire 
partition. 17 
1/2 
1.1/3 
2/2 
2.1/3 
2.2/3 
2.3/3 
2.4/3 2.5/3 2.6/3 2.7/3 2.8/3 2.9/3 
2.10/3 2.11/3 
2.12/3 
2.13/3 2.14/3 2.15/3 2.16/3 2.17/3 
2.18/3 
Ada Reference Manual — 2012 Edition 
339      13 December 2012 Language-Defined Restrictions and Profiles   13.12.1 No_Implementation_Pragmas  
 There are no implementation-defined pragma s or pragma arguments. This restriction 
applies only to the current compilation or environment, not the entire partition. 
No_Implementation_Units  
 There is no mention in the context_clause  of any implementation-defined descendants of 
packages Ada, Interfaces, or System. This rest riction applies only to the current compilation 
or environment, not the entire partition. 
No_Obsolescent_Features  
 There is no use of language features define d in Annex J. It is implementation defined 
whether uses of the renamings of J.1 and of the pragma s of J.15 are detected by this 
restriction. This restriction applies only to the current compilation or environment, not the 
entire partition.  
The following restriction_parameter_ identifier s are language defined: 
No_Dependence  
 Specifies a library unit on which there are no semantic dependences. 
No_Specification_of_Aspect  
 Identifies an aspect for which no aspect_specification , attribute_definition_clause , or 
pragma  is given. 
No_Use_Of_Attribute  
 Identifies an attribute for which no attribute_reference  or attribute_definition_clause  is 
given. 
No_Use_Of_Pragma  
 Identifies a pragma  which is not to be used. 
Legality Rules 
The restriction_parameter_argument  of a No_Dependence restriction shall be a name ; the name  shall 
have the form of a full expanded name of a library  unit, but need not denote a unit present in the 
environment. 
The restriction_parameter_argument  of a No_Specification_of_Aspect restriction shall be an identifier ; 
this is an identifier specific to a pragma (see 2.8) and does not denote any declaration. 
The restriction_parameter_argument  of a No_Use_Of_Attribute restriction shall be an identifier  or one of 
the reserved words Access, Delta, Digits, Mod, or Range; this is an identif ier specific to a pragma. 
The restriction_parameter_argument  of a No_Use_Of_Pragma restriction shall be an identifier  or the 
reserved word Interface; this is an identifier specific to a pragma. 
Post-Compilation Rules 
No compilation unit included in the partition shall depe nd semantically on the library unit identified by the 
name  of a No_Dependence restriction. 
Static Semantics 
The following profile_ identifier  is language defined: 
No_Implementation_Extensions  
  
For usage profile No_Implementation_Extensions, there shall be no 
profile_ pragma_argument_association s. 3/2 
3.1/3 
4/3 
5/3 
6/2 
6.1/3 
6.2/3 
6.3/3 
7/2 
7.1/3 
7.2/3 7.3/3 
8/3 
9/3 
10/3 
11/3 
Ada Reference Manual — 2012 Edition 
13.12.1    Language-Defined Restrictions and Profiles 13 December 2012      340 The No_Implementation_Extensions usage profile is  equivalent to the following restrictions:  
No_Implementation_Aspect_Specifications, 
No_Implementation_Attributes, No_Implementation_Identifiers, No_Implementation_Pragmas, No_Implementation_Units. 
13.13 Streams 
A stream  is a sequence of elements comprising valu es from possibly differe nt types and allowing 
sequential access to these values. A stream type  is a type in the class whose root type is 
Streams.Root_Stream_Type. A stream type may be implemented in various ways, such as an external sequential file, an internal buffer, or a network channel.  
13.13.1 The Package Streams 
Static Semantics 
The abstract type Root_Stream_Type is the root type of the class of stream types. The types in this class 
represent different kinds of streams.  A new stream type is defined by  extending the root type (or some 
other stream type), overriding the Read and Write operations, and optionally defining additional primitive 
subprograms, according to the requirements of the pa rticular kind of stream. The predefined stream-
oriented attributes like T'Read and T'Write make di spatching calls on the Read and Write procedures of 
the Root_Stream_Type. (User-defined T'Read and T'Write  attributes can also make such calls, or can call 
the Read and Write attributes of other types.)  
package Ada.Streams is 
    pragma Pure(Streams); 
    type Root_Stream_Type is abstract tagged limited private ; 
    pragma Preelaborable_Initialization(Root_Stream_Type); 
    type Stream_Element is mod implementation-defined ; 
    type Stream_Element_Offset is range implementation-defined ; 
    subtype Stream_Element_Count is 
        Stream_Element_Offset range 0..Stream_Element_Offset'Last; 
    type Stream_Element_Array is 
        array(Stream_Element_Offset range <>) of aliased  Stream_Element; 
    procedure  Read( 
      Stream : in out Root_Stream_Type; 
      Item   : out Stream_Element_Array; 
      Last   : out Stream_Element_Offset) is abstract ; 
    procedure  Write( 
      Stream : in out Root_Stream_Type; 
      Item   : in Stream_Element_Array) is abstract ; 
private 
   ... -- not specified by the language  
end Ada.Streams; 
The Read operation transfers stream elements from the sp ecified stream to fill the array Item. Elements are 
transferred until Item'Length elements have been transf erred, or until the end of the stream is reached. If 
any elements are transferred, the index of the last  stream element transferred is returned in Last. 
Otherwise, Item'First - 1 is returned in Last. Last is  less than Item'Last only if the end of the stream is 
reached. 
The Write operation appends Item to the specified stream. 12/3 
13/3 
1 
1 
2 
3/2 4/1 
5 
6 
7 
8/2 
9 
Ada Reference Manual — 2012 Edition 
341      13 December 2012 The Package Streams   13.13.1 Implementation Permissions 
If Stream_Element'Size is not a multiple of System .Storage_Unit, then the components of Stream_-
Element_Array need not be aliased.  
NOTES 
38  See A.12.1, “The Package Streams.Stream_IO” for an example of extending type Root_Stream_Type. 
39  If the end of stream has b een reached, and Item'First is St ream_Element_Offset'First, Read will raise Constraint_Error.  
13.13.2 Stream-Oriented Attributes 
The type-related operational attributes Write, Read, Ou tput, and Input convert values to a stream of 
elements and reconstruct values from a stream.  
Static Semantics 
For every subtype S of an elementary type T, the following representation attribute is defined:  
S'Stream_Size 
 Denotes the number of bits read from or writte n to a stream by the default implementations 
of S'Read and S'Write. Hence, the number of stream elements required per item of 
elementary type T is: 
T'Stream_Size / Ada.Streams.Stream_Element'Size 
 The value of this attribute is of type universal_integer  and is a multiple of 
Stream_Element'Size. 
 Stream_Size may be specified for first subtypes via an attribute_definition_clause ; the 
expression  of such a clause shall be static, nonnegative, and a multiple of 
Stream_Element'Size. 
Implementation Advice 
If not specified, the value of Stream_Size for an el ementary type should be the number of bits that 
corresponds to the minimum number of stream elements required by the first subtype of the type, rounded 
up to the nearest factor or multiple of the word size that is also a mu ltiple of the stream element size.  
The recommended level of support for the Stream_Size attribute is:  
• A Stream_Size clause should be supporte d for a discrete or fixed point type T if the specified 
Stream_Size is a multiple of Stream_Element'Size and is no less than the size of the first subtype 
of T, and no greater than the size of the largest type of the same elementary class (signed integer, 
modular integer, enumeration, ordinary fixed point, or decimal fixed point).  
Static Semantics 
For every subtype S of a specific type T, the following attributes are defined.  
S'Write S'Write denotes a procedure with the following specification:  
procedure  S'Write( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item : in T) 
 S'Write writes the value of Item to Stream . 
S'Read S'Read denotes a procedure with the following specification:  
procedure  S'Read( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item : out T) 
 S'Read reads the value of Item from Stream .  9.1/1 
10 
11/2 
1/3 
1.1/2 
1.2/3 
1.3/2 
1.4/2 
1.5/2 
1.6/2 
1.7/2 
1.8/2 
2 
3 
4/2 
5 
6 
7/2 
8 
Ada Reference Manual — 2012 Edition 
13.13.2    Stream-Oriented Attribut es 13 December 2012      342 For an untagged derived type, the Write (resp. Read) a ttribute is inherited according to the rules given in 
13.1 if the attribute is specified and available for the parent type at the point where T is declared. For a 
tagged derived type, these attributes are not inherite d, but rather the default implementations are used. 
The default implementations of the Write and Read attributes, where available, execute as follows: 
For elementary types, Read reads (and Write writes) the number of stream elements implied by the 
Stream_Size for the type T; the representation of those stream elements is implementation defined. For 
composite types, the Write or Read attribute for each component is called in canonical order, which is last 
dimension varying fastest for an arra y (unless the convention of the array is Fortran, in which case it is 
first dimension varying fastest), a nd positional aggregate order for a reco rd. Bounds are not included in the 
stream if T is an array type. If T is a discriminated type, discrimina nts are included only if they have 
defaults. If T is a tagged type, the tag is not included. For ty pe extensions, the Write or Read attribute for 
the parent type is called, followed by the Write or R ead attribute of each component of the extension part, 
in canonical order. For a limited type extension, if the a ttribute of the parent type or any progenitor type of 
T is available anywhere within the immediate scope of T, and the attribute of the parent type or the type of 
any of the extension components is not available at the freezing point of T, then the attribute of T shall be 
directly specified. 
If T is a discriminated type and its di scriminants have defaults, then S' Read first reads the discriminants 
from the stream without modifying Item. S'Read then creates an object of type T constrained by these 
discriminants. The value of this object is then converted to the subtype of Item and is assigned to Item. 
Finally, the Read attribute for each nondiscriminant component of Item is called in canonical order as 
described above. Normal default initialization a nd finalization take place for the created object. 
Constraint_Error is raised by the pr edefined Write attribute if the valu e of the elementary item is outside 
the range of values representable using Stream_Size bits. For a signed integer type, an enumeration type, 
or a fixed point type, the range is unsigned only if th e integer code for the lower bound of the first subtype 
is nonnegative, and a (symmetric) signe d range that covers all values of  the first subtype would require 
more than Stream_Size bits; ot herwise, the range is signed. 
For every subtype S'Class of a class-wide type T'Class:  
S'Class'Write 
 S'Class'Write denotes a procedure with the following specification:  
procedure  S'Class'Write( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item   : in T'Class) 
 Dispatches to the subprogram denoted by the Write attribute of the specific type identified 
by the tag of Item. 
S'Class'Read S'Class'Read denotes a pro cedure with the following specification:  
procedure  S'Class'Read( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item : out T'Class) 
 Dispatches to the subprogram denoted by the Read attribute of the specific type identified 
by the tag of Item.  
Paragraph 17 was deleted.   
Static Semantics 
For every subtype S of a specific type T, the following attributes are defined.  
S'Output S'Output denotes a procedure with the following specification:  8.1/3 
8.2/2 
9/3 
9.1/3 
9.2/3 
10 
11 
12/2 
13 
14 
15/2 
16 
18 
19 
Ada Reference Manual — 2012 Edition 
343      13 December 2012 Str eam-Oriented Attributes   13.13.2 procedure  S'Output( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item : in T) 
 S'Output writes the value of Item to Stream , including any bounds or discriminants.  
S'Input S'Input denotes a function with the following specification:  
function  S'Input( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class) 
   return T 
 S'Input reads and returns one value from Stream , using any bounds or discriminants written 
by a corresponding S'Output to determine how much to read.  
For an untagged derived type, the Output (resp. Input) a ttribute is inherited according to the rules given in 
13.1 if the attribute is specified and available for the parent type at the point where T is declared. For a 
tagged derived type, these attributes are not inherite d, but rather the default implementations are used. 
The default implementations of the Output and Input attributes, wh ere available, execute as follows:  
• If T is an array type, S'Output first writes the bounds, and S'Input first reads the bounds. If T has 
discriminants without defaults, S' Output first writes the discrimi nants (using the Write attribute 
of the discriminant type for each), and S'Input  first reads the discriminants (using the Read 
attribute of the discriminant type for each). 
• S'Output then calls S'Write to write the value of Item to the stream. S'Input then creates an object 
of type T, with the bounds or (when without defaults) the discriminants, if any, taken from the 
stream, passes it to S'Read, and returns the value of the object. If T has discriminants, then this 
object is unconstrained if and only the discrimina nts have defaults. Normal default initialization 
and finalization take place for this obj ect (see 3.3.1, 7.6, and 7.6.1).  
If T is an abstract type, then S' Input is an abstract function. 
For every subtype S'Class of a class-wide type T'Class:  
S'Class'Output 
 S'Class'Output denotes a procedure with the following specification:  
procedure  S'Class'Output( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item   : in T'Class) 
 First writes the external tag of Item to Stream  (by calling String'Output( Stream , Tags.-
External_Tag( Item'Tag)) — see 3.9) and then dispatches  to the subprogram denoted by the 
Output attribute of the specific type identified by the tag. Tag_Error is raised if the tag of 
Item identifies a type declared at an acce ssibility level deeper than that of S.  
S'Class'Input 
 S'Class'Input denotes a function with the following specification:  
function  S'Class'Input( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class) 
   return T'Class 
 First reads the external tag from Stream  and determines the corresponding internal tag (by 
calling Tags.Descendant_Tag(String'Input( Stream ), S'Tag) which might raise Tag_Error — 
see 3.9) and then dispatches to  the subprogram denoted by the Input attribute of the specific 
type identified by the internal tag; returns th at result. If the specific type identified by the 
internal tag is abstract, Constraint_Error is raised. 
In the default implementation of Read and Input for a composite type, for each scalar component that is a 
discriminant or that has an implicit initial value, a ch eck is made that the value returned by Read for the 
component belongs to its subtype. Constraint_Error is raised if th is check fails. For other scalar 20/2 
21 
22 
23/2 
24 
25/3 
25.1/2 
26/3 
27/3 
27.1/2 
28 
29 
30/2 
31/2 
32 
33/2 
34/3 
35/3 
Ada Reference Manual — 2012 Edition 
13.13.2    Stream-Oriented Attribut es 13 December 2012      344 components, no check is made. For each component that  is of an access type, if the implementation can 
detect that the value returned by Read for the compone nt is not a value of its s ubtype, Constraint_Error is 
raised. If the value is not a value of its subtype and this error is not detected, the component has an 
abnormal value, and erroneous execution can result (see 13.9.1). In the default im plementation of Read for 
a composite type with defaulted discriminants, if the actual parameter of Read is constrained, a check is 
made that the discriminants read from the stream are equal to those of the actual parameter. Constraint_Error is raised  if this check fails. 
It is unspecified at which point and in which or der these checks are performed. In particular, if 
Constraint_Error is raised due to the failure of one of these checks, it is unspecified how many stream 
elements have been read from the stream. 
In the default implementation of Read and Input for a ty pe, End_Error is raised if the end of the stream is 
reached before the reading of a value of the type is completed. 
The stream-oriented attributes may be specified for any type via an 
attribute_definition_clause . The 
subprogram name given in such a clause shall stati cally denote a subprogram that is not an abstract 
subprogram. Furthermore, if a stream-oriented attr ibute is specified for an interface type by an 
attribute_definition_clause , the subprogram name given in the clause shall statically denote a null 
procedure.  
A stream-oriented attribute for a subtype of a specific type T is available  at places where one of the 
following conditions is true:  
• T is nonlimited. 
• The attribute_designator  is Read (resp. Write) and T is a limited record extension, and the 
attribute Read (resp. Write) is available for the parent type of T and for the types of all of the 
extension components.  
• T is a limited untagged derived type, and th e attribute was inherited for the type.  
• The attribute_designator  is Input (resp. Output), and T is a limited type, and the attribute Read 
(resp. Write) is available for T.  
• The attribute has been specified via an attribute_definition_clause , and the 
attribute_definition_clause  is visible.  
A stream-oriented attribute for a subtype of a class-wide type T'Class is available at places where one of 
the following conditions is true: 
• T is nonlimited; 
• the attribute has been specified via an attribute_definition_clause , and the 
attribute_definition_clause  is visible; or 
• the corresponding attribute of T is available, provided that if T has a partial view, the 
corresponding attribute is available at the end of the visible part where T is declared. 
An attribute_reference  for one of the stream-oriented attributes is  illegal unless the attribute is available at 
the place of the attribute_reference . Furthermore, an attribute_reference  for T'Input is illegal if T is an 
abstract type. 
In the parameter_and_result_profile s for the default implementations of the stream-oriented attributes, 
the subtype of the Item parame ter is the base subtype of T if T is a scalar type, and the first subtype 
otherwise. The same rule applies to the result of the Input attribute. 36/2 
37/1 
38/3 
39/2 
40/2 
41/2 
42/2 
43/2 
44/2 45/2 
46/2 
47/2 
48/2 49/2 
50/3 
Ada Reference Manual — 2012 Edition 
345      13 December 2012 Str eam-Oriented Attributes   13.13.2 For an attribute_definition_clause  specifying one of these attributes, the subtype of the Item parameter 
shall be the first subtype or the base subtype if scalar, and the first subtype if not scalar. The same rule applies to the result of the Input function. 
A type is said to support external streaming  if Read and Write attributes are provided for sending values 
of such a type between active partitions, with Write marshalling the representation, and Read 
unmarshalling the representation. A lim ited type supports external streaming only if it has available Read 
and Write attributes. A type with a part that is of  a nonremote access type supports external streaming only 
if that access type or the type of some part that  includes the access type component, has Read and Write 
attributes that have been specified via an 
attribute_definition_clause , and that attribute_definition_clause  
is visible. An anonymous access type does not suppor t external streaming. All other types (including 
remote access types, see E.2.2) support external streaming. 
Erroneous Execution 
If the internal tag returned by Descendant_Tag to T'Cl ass'Input identifies a type that is not library-level 
and whose tag has not been created, or does not exist in the partition at the time of the call, execution is 
erroneous.  
Implementation Requirements 
For every subtype S of a language-defined nonlimited specific type T, the output generated by S'Output or 
S'Write shall be readable by S'Input or S'Read, resp ectively. This rule applies across partitions if the 
implementation conforms to th e Distributed Systems Annex. 
If Constraint_Error is raised during a call to Read because of failure of one the above checks, the 
implementation shall ensure that the discriminants of  the actual parameter of Read are not modified.  
Implementation Permissions 
The number of calls performed by th e predefined implementation of the stream-oriented attributes on the 
Read and Write operations of the stream type is uns pecified. An implementation may take advantage of 
this permission to perform internal  buffering. However, all the calls on the Read and Write operations of 
the stream type needed to implement an explicit invo cation of a stream-oriented attribute shall take place 
before this invocation returns. An explicit invocati on is one appearing explicitly in the program text, 
possibly through a generic instantiation (see 12.3). 
If T is a discriminated type and its discriminants have defaults, then in two cases an execution of the 
default implementation of S'Read is not requi red to create an anonymous object of type T: If the 
discriminant values that are read in are e qual to the corresponding discriminant values of Item, then no 
object of type T need be created and Item may be used instead. If they are not equal and Item is a 
constrained variable, then Constraint_Error may be raised  at that point, before any further values are read 
from the stream and before the object of type T is created. 
A default implementation of S'Input that calls th e default implementation of S'Read may create a 
constrained anonymous object with discrimi nants that match those in the stream.  
NOTES 
40  For a definite subtype S of a type T, only T'Write and T'Read are needed to pass an arbitrary value of the subtype 
through a stream. For an indefinite subtype S of a type T, T'Output and T'Input will normally be needed, since T'Write and 
T'Read do not pass bounds, discriminants, or tags. 
41  User-specified attributes of S'Class are not inherited by other class-wide types descended from S.  51/3 
52/3 
53/2 
54/1 
55/3 
56/3 
56.1/3 
56.2/3 
57 
58 
Ada Reference Manual — 2012 Edition 
13.13.2    Stream-Oriented Attribut es 13 December 2012      346 Examples 
Example of user-defin ed Write attribute:   
procedure  My_Write( 
  Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
  Item   : My_Integer'Base); for My_Integer'Write use My_Write; 
13.14 Freezing Rules 
This subclause defines a place in the program text wh ere each declared entity becomes “frozen.” A use of 
an entity, such as a reference to it by name, or (for a type) an expression of the type, causes freezing of the 
entity in some contexts, as described below. The Legality  Rules forbid certain kinds of uses of an entity in 
the region of text where it is frozen.  
The freezing  of an entity occurs at one or more places ( freezing points ) in the program text where the 
representation for the entity has to be fully determined . Each entity is frozen from its first freezing point to 
the end of the program text (given the orde ring of compilation units defined in 10.1.4).  
This subclause also defines a place in the program te xt where the profile of each declared callable entity 
becomes frozen . A use of a callable entity causes freezing of its  profile in some contexts, as described 
below. At the place where the profile of a callable entity becomes frozen, the entity itself becomes frozen. 
The end of a declarative_part , protected_body , or a declaration of a library package or generic library 
package, causes freezing  of each entity and profile declared with in it, except for incomplete types. A 
noninstance body other than a renames-as-body causes freezing of each entity and profile declared before 
it within the same declarative_part  that is not an incomplete type; it only causes freezing of an incomplete 
type if the body is within the immedi ate scope of the incomplete type.  
A construct that (explicitly or implicitly ) references an entity can cause the freezing  of the entity, as 
defined by subsequent paragraphs. At the place where a construct causes freezing, each name , 
expression , implicit_dereference , or range  within the construct causes freezing:  
• The occurrence of a generic_instantiation  causes freezing, except that a name  which is a 
generic actual parameter whose co rresponding generic formal parame ter is a formal incomplete 
type (see 12.5.1) does not cause freezing. In add ition, if a parameter of the instantiation is 
defaulted, the default_expression  or default_name  for that parameter causes freezing. 
• The occurrence of an object_declaration  that has no corresponding completion causes freezing.  
• The declaration of a record extension causes freezing of the parent subtype.  
• The declaration of a record extension, interf ace type, task unit, or protected unit causes freezing 
of any progenitor types specified in the declaration.  
• At the freezing point of the entity associated with an aspect_specification , any expression s or 
name s within the aspect_specification  cause freezing. Any static expressions within an 
aspect_specification  also cause freezing at the end of the immediately enclosing declaration list.  
A static expression (other than within an aspect_specification ) causes freezing where it occurs. An object 
name or nonstatic expression causes freezing where it occu rs, unless the name or expression is part of a 
default_expression , a default_name , the expression  of an expression function, an aspect_specification , 
or a per-object expression of a component's constraint , in which case, the freezing occurs later as part of 
another construct or at the freezing point of an associated entity. 
An implicit call freezes the same entities and profiles that would be frozen by an explicit call. This is true 
even if the implicit call is removed via implementation permissions. 59 
60/2 
1/3 
2 
2.1/3 
3/3 
4/1 
5/3 
6 
7 
7.1/2 
7.2/3 
8/3 
8.1/3 
Ada Reference Manual — 2012 Edition 
347      13 December 2012 Freezing Rules   13.14 If an expression is implicitly converted to a type or subtype T, then at the place where the expression 
causes freezing, T is frozen. 
The following rules define which entities are frozen at the place where a construct causes freezing:  
• At the place where an expression causes freezing, the type of the expression is frozen, unless the 
expression is an enumeration literal used as a discrete_choice  of the array_aggregate  of an 
enumeration_representation_clause .  
• At the place where a function call causes freezing, the profile of the function is frozen. 
Furthermore, if a parameter of the call is defaulted, the default_expression  for that parameter 
causes freezing. If the function call is to an expression function, the expression  of the 
expression function causes freezing. 
• At the place where a generic_instantiation  causes freezing of a callable entity, the profile of that 
entity is frozen unless the formal subprogram  corresponding to the callable entity has a 
parameter or result of a formal untagged incomple te type; if the callable entity is an expression 
function, the expression  of the expression function causes freezing. 
• At the place where a use of the Acce ss or Unchecked_Access attribute whose prefix  denotes an 
expression function causes freezing, the expression  of the expression function causes freezing. 
• At the place where a name  causes freezing, the entity denoted by the name  is frozen, unless the 
name  is a prefix  of an expanded name; at the place where an object name  causes freezing, the 
nominal subtype associated with the name  is frozen.  
• At the place where an implicit_dereference  causes freezing, the nominal subtype associated with 
the implicit_dereference  is frozen. 
• At the place where a range  causes freezing, the type of the range  is frozen.  
• At the place where an allocator  causes freezing, the designated subtype of its type is frozen. If 
the type of the allocator  is a derived type, then all ancestor types are also frozen.  
• At the place where a profile is frozen, each subt ype of the profile is frozen. If the corresponding 
callable entity is a member of an entry family , the index subtype of the family is frozen.  
• At the place where a subtype is frozen, its type is frozen. At the place where a type is frozen, any 
expressions or name s within the full type definition cause freezing; the first subtype, and any 
component subtypes, index subtypes, and parent subtype of the type are frozen as well. For a 
specific tagged type, the corresponding class-wide ty pe is frozen as well. For a class-wide type, 
the corresponding specific type is frozen as well.  
• At the place where a specific tagged type is frozen, the primitive subprograms of the type are 
frozen. At the place where a type is frozen, any subprogram named in an 
attribute_definition_clause  for the type is frozen.  
Legality Rules 
The explicit declaration of a primitive subprogram of a tagged type shall occur before the type is frozen 
(see 3.9.2).  
A type shall be completely defined be fore it is frozen (see 3.11.1 and 7.3). 
The completion of a deferred constant declaration sh all occur before the constant is frozen (see 7.4). 
An operational or representation item that directly specifi es an aspect of an entity shall appear before the 
entity is frozen (see 13.1).  
Dynamic Semantics 
The tag (see 3.9) of a tagged type T is created at the point where T is frozen.  8.2/1 
9 
10 
10.1/3 
10.2/3 
10.3/3 
11 
11.1/1 
12 
13 
14/3 
15 
15.1/3 
16 
17 
18 
19/1 
20/2 

Ada Reference Manual — 2012 Edition 
349      13 December 2012 The Standard Libraries The Standard Libraries 

Ada Reference Manual — 2012 Edition 
351      13 December 2012 Predefined Language Environment   A Annex A 
(normative)  
Predefined Language Environment 
This Annex contains the specifications of library un its that shall be provided by every implementation. 
There are three root library units: Ada, Interfaces, a nd System; other library units are children of these: 
  
  
Standard — A.1 
 Ada — A.2   Assertions — 11.4.2   Asynchronous_Task_Control — D.11   Calendar — 9.6    Arithmetic — 9.6.1    Formatting — 9.6.1    Time_Zones — 9.6.1   Characters — A.3.1    Conversions — A.3.4    Handling — A.3.2    Latin_1 — A.3.3   Command_Line — A.15   Complex_Text_IO — G.1.3   Containers — A.18.1    Bounded_Doubly_Linked_Lists       —  A . 1 8 . 2 0     Bounded_Hashed_Maps — A.18.21    Bounded_Hashed_Sets — A.18.23    Bounded_Multiway_Trees — A.18.25    Bounded_Ordered_Maps — A.18.22    Bounded_Ordered_Sets — A.18.24    Bounded_Priority_Queues — A.18.31    Bounded_Synchronized_Queues        —  A . 1 8 . 2 9     Bounded_Vectors — A.18.19    Doubly_Linked_Lists — A.18.3    Generic_Array_Sort — A.18.26    Generic_Constrained_Array_Sort       —  A . 1 8 . 2 6     Generic_Sort — A.18.26    Hashed_Maps — A.18.5    Hashed_Sets — A.18.8    Indefinite_Doubly_Linked_Lists       —  A . 1 8 . 1 2     Indefinite_Hashed_Maps — A.18.13    Indefinite_Hashed_Sets — A.18.15    Indefinite_Holders — A.18.18    Indefinite_Mu ltiway_Trees — A.18.17 
   Indefinite_Ordered_Maps — A.18.14    Indefinite_Ordered_Sets — A.18.16    Indefinite_Vectors — A.18.11
 Standard ( ...continued ) 
 Ada ( ...continued ) 
  Containers ( ...continued ) 
   Multiway_Trees — A.18.10    Ordered_Maps — A.18.6    Ordered_Sets — A.18.9    Synchronized_Q ueue_Interfaces 
      —  A . 1 8 . 2 7     Unbounded_Priority_Queues       —  A . 1 8 . 3 0     Unbounded_Synchronized_Queues       —  A . 1 8 . 2 8     Vectors — A.18.2   Decimal — F.2   Direct_IO — A.8.4   Directories — A.16    Hierarchical_File_Names — A.16.1    Information — A.16   Dispatching — D.2.1    EDF — D.2.6    Non_Preemptive — D.2.4    Round_Robin — D.2.5   Dynamic_Priorities — D.5.1   Environment_Variables — A.17   Exceptions — 11.4.1   Execution_Time — D.14    Group_Budgets — D.14.2    Interrupts — D.14.3    Timers — D.14.1   Finalization — 7.6   Float_Text_IO — A.10.9   Float_Wide_Text_IO — A.11   Float_Wide_Wide_Text_IO — A.11   Integer_Text_IO — A.10.8   Integer_Wide_Text_IO — A.11   Integer_Wide_Wide_Text_IO — A.11   Interrupts — C.3.2    Names — C.3.2   IO_Exceptions — A.13   Iterator_Interfaces — 5.5.1   Locales — A.19 
 1 
2/3 
Ada Reference Manual — 2012 Edition 
A   Predefined Language Environment 13 December 2012      352 Standard ( ...continued ) 
 Ada ( ...continued ) 
  Numerics — A.5    Complex_Arrays — G.3.2    Complex_Elementary_Functions — G.1.2    Complex_Types — G.1.1    Discrete_Random — A.5.2    Elementary_Functions — A.5.1    Float_Random — A.5.2    Generic_Complex_Arrays — G.3.2    Generic_Complex_Elementary_Functions       —  G . 1 . 2     Generic_Complex_Types — G.1.1    Generic_Elementary_Functions — A.5.1    Generic_Real_Arrays — G.3.1    Real_Arrays — G.3.1   Real_Time — D.8    Timing_Events — D.15   Sequential_IO — A.8.1   Storage_IO — A.9   Streams — 13.13.1    Stream_IO — A.12.1   Strings — A.4.1    Bounded — A.4.4     Equal_Case_Insensitive — A.4.10     H a s h  —  A . 4 . 9      Hash_Case_Insensitive — A.4.9     Less_Case_Insensitive — A.4.10    Fixed — A.4.3     Equal_Case_Insensitive — A.4.10     H a s h  —  A . 4 . 9      Hash_Case_Insensitive — A.4.9     Less_Case_Insensitive — A.4.10    Equal_Case_Insensitive — A.4.10    Hash — A.4.9    Hash_Case_Insensitive — A.4.9    Less_Case_Insensitive — A.4.10    Maps — A.4.2     Constants — A.4.6    Unbounded — A.4.5     Equal_Case_Insensitive — A.4.10     H a s h  —  A . 4 . 9      Hash_Case_Insensitive — A.4.9     Less_Case_Insensitive — A.4.10    UTF_Encoding — A.4.11     Conversions — A.4.11     Strings — A.4.11     Wide_Strings — A.4.11     Wide_Wide_Strings — A.4.11 
 Standard ( ...continued ) 
 Ada ( ...continued ) 
  Strings ( ...continued ) 
   Wide_Bounded — A.4.7     Wide_Equal_Case_Insensitive        —  A . 4 . 7      Wide_Hash — A.4.7     Wide_Hash_Case_Insensitive — A.4.7    Wide_Equal_Case_Insensitive — A.4.7    Wide_Fixed — A.4.7     Wide_Equal_Case_Insensitive        —  A . 4 . 7      Wide_Hash — A.4.7     Wide_Hash_Case_Insensitive — A.4.7    Wide_Hash — A.4.7    Wide_Hash_Case_Insensitive — A.4.7    Wide_Maps — A.4.7     Wide_Constants — A.4.7    Wide_Unbounded — A.4.7     Wide_Equal_Case_Insensitive        —  A . 4 . 7      Wide_Hash — A.4.7     Wide_Hash_Case_Insensitive — A.4.7    Wide_Wide_Bounded — A.4.8     Wide_Wide_Equal_Case_Insensitive        —  A . 4 . 8      Wide_Wide_Hash — A.4.8     Wide_Wide_Hash_Case_Insensitive        —  A . 4 . 8     Wide_Wide_Equal_Case_Insensitive       —  A . 4 . 8     Wide_Wide_Fixed — A.4.8     Wide_Wide_Equal_Case_Insensitive        —  A . 4 . 8      Wide_Wide_Hash — A.4.8     Wide_Wide_Hash_Case_Insensitive        —  A . 4 . 8     Wide_Wide_Hash — A.4.8    Wide_Wide_Hash_Case_Insensitive        —  A . 4 . 8     Wide_Wide_Maps — A.4.8     Wide_Wide_Constants — A.4.8    Wide_Wide_Unbounded — A.4.8     Wide_Wide_Equal_Case_Insensitive        —  A . 4 . 8      Wide_Wide_Hash — A.4.8     Wide_Wide_Hash_Case_Insensitive        —  A . 4 . 8    Synchronous_Barriers — D.10.1   Synchronous_Task_Control — D.10    E D F  —  D . 1 0  
 
Ada Reference Manual — 2012 Edition 
353      13 December 2012 Predefined Language Environment   A Standard ( ...continued ) 
 Ada ( ...continued ) 
  Tags — 3.9    Generic_Dispatching_Constructor — 3.9   Task_Attributes — C.7.2   Task_Identification — C.7.1   Task_Termination — C.7.3
 
  Text_IO — A.10.1    Bounded_IO — A.10.11    Complex_IO — G.1.3    Editing — F.3.3    Text_Streams — A.12.2    Unbounded_IO — A.10.12   Unchecked_Conversion — 13.9   Unchecked_Deallocate_Subpool — 13.11.5   Unchecked_Deallocation — 13.11.2   Wide_Characters — A.3.1    Handling — A.3.5   Wide_Text_IO — A.11    Complex_IO — G.1.4    Editing — F.3.4    Text_Streams — A.12.3    Wide_Bounded_IO — A.11    Wide_Unbounded_IO — A.11   Wide_Wide_Characters — A.3.1    Handling — A.3.6   Wide_Wide_Text_IO — A.11    Complex_IO — G.1.5    Editing — F.3.5    Text_Streams — A.12.4    Wide_Wide_Bounded_IO — A.11    Wide_Wide_Unbounded_IO — A.11
  Interfaces — B.2   C — B.3    Pointers — B.3.2    Strings — B.3.1   COBOL — B.4   Fortran — B.5
 
 System — 13.7   Address_To_Access_Conversions — 13.7.2   Machine_Code — 13.8   Multiprocessors — D.16    Dispatching_Domains — D.16.1   RPC — E.5   Storage_Elements — 13.7.1   Storage_Pools — 13.11    Subpools — 13.11.4
 
Implementation Requirements 
The implementation shall ensure that each language-def ined subprogram is reentr ant in the sense that 
concurrent calls on the same subprogram perform as sp ecified, so long as all parameters that could be 
passed by reference denot e nonoverlapping objects.  
If a descendant of a language-defined tagged type is declared, the implementation shall ensure that each 
inherited language-defined subprogram behaves as described in this Inte rnational Standard. In particular, 
overriding a language-defined subprogram shall not alte r the effect of any inherited language-defined 
subprogram.  
Implementation Permissions 
The implementation may restrict the replacemen t of language-defined compilation units. The 
implementation may restrict children of language-def ined library units (other than Standard).  3/2 
3.1/3 
4 
Ada Reference Manual — 2012 Edition 
A.1   The Package Standard 13 December 2012      354 A.1 The Package Standard 
This subclause outlines the specifica tion of the package Standard contai ning all predefined identifiers in 
the language. The corresponding package body  is not specified by the language. 
The operators that are predefined for the types decl ared in the package Standard are given in comments 
since they are implicitly declared. Italics are us ed for pseudo-names of anonymous types (such as 
root_real ) and for undefined information (such as implementation-defined ).  
Static Semantics 
The library package Standard has the following declaration:  
package Standard is 
   pragma Pure(Standard); 
   type Boolean is (False, True); 
   --  The predefined relational operato rs for this type are as follows:  
   -- function  "="   (Left, Right : Boolean'Base) return Boolean; 
   -- function  "/="  (Left, Right : Boolean'Base) return Boolean; 
   -- function  "<"   (Left, Right : Boolean'Base) return Boolean; 
   -- function  "<="  (Left, Right : Boolean'Base) return Boolean; 
   -- function  ">"   (Left, Right : Boolean'Base) return Boolean; 
   -- function  ">="  (Left, Right : Boolean'Base) return Boolean; 
   --  The predefined logical opera tors and the predefined logical  
   --  negation operator are as follows:  
   -- function  "and" (Left, Right : Boolean'Base) return Boolean'Base; 
   -- function  "or"  (Left, Right : Boolean'Base) return Boolean'Base; 
   -- function  "xor" (Left, Right : Boolean'Base) return Boolean'Base; 
   -- function  "not" (Right : Boolean'Base) return Boolean'Base; 
   --  The integer type root_integer and the  
   --  corresponding universal type unive rsal_integer are predefined.  
   type Integer is range implementation-defined ; 
   subtype Natural  is Integer range 0 .. Integer'Last; 
   subtype Positive is Integer range 1 .. Integer'Last; 
   --  The predefined operators for type Integer are as follows:  
   -- function  "="  (Left, Right : Integer'Base) return Boolean; 
   -- function  "/=" (Left, Right : Integer'Base) return Boolean; 
   -- function  "<"  (Left, Right : Integer'Base) return Boolean; 
   -- function  "<=" (Left, Right : Integer'Base) return Boolean; 
   -- function  ">"  (Left, Right : Integer'Base) return Boolean; 
   -- function  ">=" (Left, Right : Integer'Base) return Boolean; 
   -- function  "+"   (Right : Integer'Base) return Integer'Base; 
   -- function  "-"   (Right : Integer'Base) return Integer'Base; 
   -- function  "abs" (Right : Integer'Base) return Integer'Base; 
   -- function  "+"   (Left, Right : Integer'Base) return Integer'Base; 
   -- function  "-"   (Left, Right : Integer'Base) return Integer'Base; 
   -- function  "*"   (Left, Right : Integer'Base) return Integer'Base; 
   -- function  "/"   (Left, Right : Integer'Base) return Integer'Base; 
   -- function  "rem" (Left, Right : Integer'Base) return Integer'Base; 
   -- function  "mod" (Left, Right : Integer'Base) return Integer'Base; 
   -- function  "**"  (Left : Integer'Base; Right : Natural) 
   --                  return Integer'Base; 1/3 
2 
3 
4 
5 
6 
7/1 
8 
9/1 
10/1 
11/2 
12 
13 
14 
15 
16 
17 
18 
Ada Reference Manual — 2012 Edition 
355      13 December 2012 The Package Standard   A.1    --  The specification of ea ch operator for the type  
   --  root_integer, or for any additional predefined integer  
   --  type, is obtained by replacing Integer by the name of the type  
   --  in the specification of the corresponding operator of the type  
   --  Integer. The right operand of the exponentiation operator  
   --  remains as subtype Natural.  
   --  The floating point type root_real and the  
   --  corresponding universal type universal_real are predefined.  
   type Float is digits implementation-defined ; 
   --  The predefined operators for this type are as follows:  
   -- function  "="   (Left, Right : Float) return Boolean; 
   -- function  "/="  (Left, Right : Float) return Boolean; 
   -- function  "<"   (Left, Right : Float) return Boolean; 
   -- function  "<="  (Left, Right : Float) return Boolean; 
   -- function  ">"   (Left, Right : Float) return Boolean; 
   -- function  ">="  (Left, Right : Float) return Boolean; 
   -- function  "+"   (Right : Float) return Float; 
   -- function  "-"   (Right : Float) return Float; 
   -- function  "abs" (Right : Float) return Float; 
   -- function  "+"   (Left, Right : Float) return Float; 
   -- function  "-"   (Left, Right : Float) return Float; 
   -- function  "*"   (Left, Right : Float) return Float; 
   -- function  "/"   (Left, Right : Float) return Float; 
   -- function  "**"  (Left : Float; Right : Integer'Base) return Float; 
   --  The specification of each operator for the type root_real, or for  
   --  any additional predefined floa ting point type, is obtained by  
   --  replacing Float by the name of the type in the specification of the  
   --  corresponding operator of the type Float.  
   --  In addition, the following operato rs are predefined for the root  
   --  numeric types:  
   function  "*" (Left : root_integer ; Right : root_real) 
     return root_real; 
   function  "*" (Left : root_real;    Right : root_integer ) 
     return root_real; 
   function  "/" (Left : root_real;    Right : root_integer ) 
     return root_real; 
   --  The type universal_fi xed is predefined.  
   --  The only multiplying operators defined between  
   --  fixed point types are  
   function  "*" (Left : universal_fixed ; Right : universal_fixed ) 
     return universal_fixed ; 
   function  "/" (Left : universal_fixed ; Right : universal_fixed ) 
     return universal_fixed ; 
   --  The type universal_access is predefined.  
   --  The following equality operators are predefined:  
   function  "="  (Left, Right: universal_access ) return Boolean; 
   function  "/=" (Left, Right: universal_access ) return Boolean; 19 
20/2 
21 
22 23 
24 
25 
26 
27 
28 
29 30 31 32 
33 
34 
34.1/2 34.2/2 
Ada Reference Manual — 2012 Edition 
A.1   The Package Standard 13 December 2012      356       --  The declaration of type Character is based on the standard ISO 8859-1 character set.  
       --  There are no character literals correspondi ng to the positions for control characters.  
      --  They are indicated in italics in this definition. See 3.5.2.  
    type Character is 
     ( nul, soh, stx, etx, eot, enq, ack, bel, -- 0 (16#00#) .. 7 (16#07#)  
      bs, ht, lf, vt, ff, cr, so, si, -- 8 (16#08#) .. 15 (16#0F#)  
       dle, dc1, dc2, dc3, dc4, nak, syn, etb, -- 16 (16#10#) .. 23 (16#17#)  
      can, em, sub, esc, fs, gs, rs, us, -- 24 (16#18#) .. 31 (16#1F#)  
       ' ', '!', '"', '#', '$', '%', '&', ''', -- 32 (16#20#) .. 39 (16#27#)  
      '(', ')', '*', '+', ',', '-', '.', '/', -- 40 (16#28#) .. 47 (16#2F#)  
       '0', '1', '2', '3', '4', '5', '6', '7', -- 48 (16#30#) .. 55 (16#37#)  
      '8', '9', ':', ';', '<', '=', '>', '?', -- 56 (16#38#) .. 63 (16#3F#)  
       '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', -- 64 (16#40#) .. 71 (16#47#)  
      'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', -- 72 (16#48#) .. 79 (16#4F#)  
       'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', -- 80 (16#50#) .. 87 (16#57#)  
      'X', 'Y', 'Z', '[', '\', ']', '^', '_', -- 88 (16#58#) .. 95 (16#5F#)  
       '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', -- 96 (16#60#) .. 103 (16#67#)  
      'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', -- 104 (16#68#) .. 111 (16#6F#)  
       'p', 'q', 'r', 's', 't', 'u', 'v', 'w', -- 112 (16#70#) .. 119 (16#77#)  
      'x', 'y', 'z', '{', '|', '}', '~', del, -- 120 (16#78#) .. 127 (16#7F#)  
       reserved_128 , reserved_129 , bph, nbh,   -- 128 (16#80#) .. 131 (16#83#)  
      reserved_132 , nel, ssa, esa,    -- 132 (16#84#) .. 135 (16#87#)  
      hts, htj, vts, pld, plu, ri, ss2, ss3, -- 136 (16#88#) .. 143 (16#8F#)  
       dcs, pu1, pu2, sts, cch, mw, spa, epa, -- 144 (16#90#) .. 151 (16#97#)  
      sos, reserved_153 , sci, csi,    -- 152 (16#98#) .. 155 (16#9B#)  
      st, osc, pm, apc,     -- 156 (16#9C#) .. 159 (16#9F#)  
       ' ', '¡', '¢', '£', '¤', '¥', '¦', '§', -- 160 (16#A0#) .. 167 (16#A7#)  
      '¨', '©', 'ª', '«',     -- 168 (16#A8#) .. 171 (16#AB#)  
      ¬', soft_hyphen , '®', '¯',    -- 172 (16#AC#) .. 175 (16#AF#)  
       '°', '±', '²', '³', '´', 'µ', '¶', '·', -- 176 (16#B0#) .. 183 (16#B7#)  
      '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', -- 184 (16#B8#) .. 191 (16#BF#)  
       'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç', -- 192 (16#C0#) .. 199 (16#C7#)  
      'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', -- 200 (16#C8#) .. 207 (16#CF#)  
       'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', -- 208 (16#D0#) .. 215 (16#D7#)  
      'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', -- 216 (16#D8#) .. 223 (16#DF#)  
       'à', 'á', 'â', 'ã', 'ä', 'å', 'æ', 'ç', -- 224 (16#E0#) .. 231 (16#E7#)  
      'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', -- 232 (16#E8#) .. 239 (16#EF#)  
       'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', -- 240 (16#F0#) .. 247 (16#F7#)  
      'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ');-- 248 (16#F8#) .. 255 (16#FF#)  
   --  The predefined operators for the ty pe Character are the same as for  
   --  any enumeration type.  
 
   --  The declaration of type Wide_Character is based on the standard ISO/IEC 10646:2011 BMP character  
   --  set. The first 256 positions have the same contents as type Character. See 3.5.2.  
    type Wide_Character is (nul, soh ... Hex_0000FFFE , Hex_0000FFFF ); 35/3 
36 
36.1/3 
Ada Reference Manual — 2012 Edition 
357      13 December 2012 The Package Standard   A.1    --  The declaration of type Wide_Wide_Character is based on the full  
   --  ISO/IEC 10646:2011 character set. The first 65536 positions have the  
   --  same contents as type Wide_Character. See 3.5.2.  
    type Wide_Wide_Character is (nul, soh ... Hex_7FFFFFFE , Hex_7FFFFFFF ); 
   for Wide_Wide_Character'Size use 32; 
   package ASCII is ... end ASCII;  -- Obsolescent; see J.5  
  
   --  Predefined string types:  
    type String is array(Positive range <>) of Character 
      with Pack; 
   --  The predefined operators for this type are as follows:  
   --     function  "="  (Left, Right: String) return Boolean; 
   --     function  "/=" (Left, Right: String) return Boolean; 
   --     function  "<"  (Left, Right: String) return Boolean; 
   --     function  "<=" (Left, Right: String) return Boolean; 
   --     function  ">"  (Left, Right: String) return Boolean; 
   --     function  ">=" (Left, Right: String) return Boolean; 
   --     function  "&" (Left: String;    Right: String)    return String; 
   --     function  "&" (Left: Character; Right: String)    return String; 
   --     function  "&" (Left: String;    Right: Character) return String; 
   --     function  "&" (Left: Character; Right: Character) return String; 
   type Wide_String is array(Positive range <>) of Wide_Character 
      with Pack; 
   --  The predefined operators for this type correspond to those for String.  
   type Wide_Wide_String is array  (Positive range <>) 
      of Wide_Wide_Character 
         with Pack; 
   --  The predefined operators for this type correspond to those for String.  
   type Duration is delta implementation-defined  range implementation-defined ; 
      --  The predefined operators for the ty pe Duration are the same as for  
      --  any fixed point type.  
   --  The predefined exceptions:  
   Constraint_Error: exception ; 
   Program_Error   : exception ; 
   Storage_Error   : exception ; 
   Tasking_Error   : exception ; 
end Standard; 
Standard has no private part.  
In each of the types Character, Wide_Character, and Wide_Wide_Character, the character literals for the 
space character (position 32) and the non-breaking sp ace character (position 160) correspond to different 
values. Unless indicated otherwise, each  occurrence of the character literal ' ' in this International Standard 
refers to the space character. Similarly, the charact er literals for hyphen (position 45) and soft hyphen 
(position 173) correspond to different values. Unless indi cated otherwise, each occu rrence of the character 
literal '–' in this International Standa rd refers to the hyphen character.  
Dynamic Semantics 
Elaboration of the body of Standard has no effect.  
Implementation Permissions 
An implementation may provide additional predefined  integer types and additional predefined floating 
point types. Not all of these types need have names.  36.2/3 
36.3/2 
37/3 
38 
39 
40 
41/3 
42 
42.1/3 
42.2/2 
43 44 
45 
46 
47 
48 
49/2 
50 
51 
Ada Reference Manual — 2012 Edition 
A.1   The Package Standard 13 December 2012      358 Implementation Advice 
If an implementation provides additional named predefin ed integer types, then the names should end with 
“Integer” as in “Long_Integer”. If an implementation provides additional named predefined floating point 
types, then the names should end w ith “Float” as in “Long_Float”.  
NOTES 
1  Certain aspects of the predefined entities cannot be completely described in the language itself. For example, although the enumeration type Boolean can be written showing the two enumeration literals False and True, the short-circuit control forms cannot be expressed in the language. 
2  As explained in 8.1, “Declarative Region” and 10.1.4, “The Compilation Process”, the declarative region of the package 
Standard encloses every library unit and consequently the main subprogram; the declaration of every library unit is assumed to occur within this declarative region. 
Library_item s are assumed to be ordered in such a way that there are no 
forward semantic dependences. However, as explained in 8.3, “Visibility”, the only library units that are visible within a 
given compilation unit are the library units named by all with_clause s that apply to the given unit, and moreover, within 
the declarative region of a given library unit, that library unit itself. 
3  If all block_statement s of a program are named, then  the name of each program unit can always be written as an 
expanded name starting with Standard (unless Standard is itself hidden). The name of a library unit cannot be a homograph of a name (such as Integer) that is already declared in Standard. 
4  The exception Standard.Numeric_Error is defined in J.6.  
A.2 The Package Ada 
Static Semantics 
The following language-defined library package exists:  
package Ada is 
    pragma Pure(Ada); 
end Ada; 
Ada serves as the parent of most of the other la nguage-defined library units; its declaration is empty 
(except for the pragma  Pure).  
Legality Rules 
In the standard mode, it is illegal to  compile a child of package Ada.  
A.3 Character Handling 
This subclause presents the packages related to ch aracter processing: an empty declared pure package 
Characters and child packages Characters.Ha ndling and Characters.Latin_1. The package 
Characters.Handling provides classifi cation and conversion functions for Character data, and some simple 
functions for dealing with Wide_Character a nd Wide_Wide_Character data. The child package 
Characters.Latin_1 declares a set of constants initialized to values of type Character.  52 
53 
54 
55 
56 
1 
2 
3 
4 
1/3 
Ada Reference Manual — 2012 Edition 
359      13 December 2012 The Packages Characters,  Wide_Characters, and Wide_Wide_Characters   A.3.1 A.3.1 The Packages Characters, Wide_Characters, and 
Wide_Wide_Characters 
Static Semantics 
The library package Characters has the following declaration:  
package Ada.Characters is 
  pragma Pure(Characters); 
end Ada.Characters; 
The library package Wide_Characters has the following declaration:  
package Ada.Wide_Characters is 
  pragma Pure(Wide_Characters); 
end Ada.Wide_Characters; 
The library package Wide_Wide_Charact ers has the following declaration:  
package Ada.Wide_Wide_Characters is 
  pragma Pure(Wide_Wide_Characters); 
end Ada.Wide_Wide_Characters; 
Implementation Advice 
If an implementation chooses to provide implementation-defined ope rations on Wide_Character or 
Wide_String (such as collating and sorting, et c.) it should do so by providing child units of 
Wide_Characters. Similarly if it chooses to  provide implementati on-defined operations on 
Wide_Wide_Character or Wide_Wide_String it should do so by providing child units of 
Wide_Wide_Characters.  
A.3.2 The Package Characters.Handling 
Static Semantics 
The library package Characters.Handling has the following declaration:  
with Ada.Characters.Conversions; 
package Ada.Characters.Handling is 
  pragma Pure(Handling); 
--Character classification functions  
  function  Is_Control           (Item : in Character) return Boolean; 
  function  Is_Graphic           (Item : in Character) return Boolean; 
  function  Is_Letter            (Item : in Character) return Boolean; 
  function  Is_Lower             (Item : in Character) return Boolean; 
  function  Is_Upper             (Item : in Character) return Boolean; 
  function  Is_Basic             (Item : in Character) return Boolean; 
  function  Is_Digit             (Item : in Character) return Boolean; 
  function  Is_Decimal_Digit     (Item : in Character) return Boolean 
                     renames Is_Digit; 
  function  Is_Hexadecimal_Digit (Item : in Character) return Boolean; 
  function  Is_Alphanumeric      (Item : in Character) return Boolean; 
  function  Is_Special           (Item : in Character) return Boolean; 
  function  Is_Line_Terminator   (Item : in Character) return Boolean; 
  function  Is_Mark              (Item : in Character) return Boolean; 
  function  Is_Other_Format      (Item : in Character) return Boolean; 
  function  Is_Punctuation_Connector (Item : in Character) return Boolean; 
  function  Is_Space             (Item : in Character) return Boolean; 1 
2 
3/2 
4/2 
5/2 
6/2 
7/3 
1 
2/2 
3 
4/3 
Ada Reference Manual — 2012 Edition 
A.3.2    The Package Characters.Handling 13 December 2012      360 --Conversion functions for Character and String  
  function  To_Lower (Item : in Character) return Character; 
  function  To_Upper (Item : in Character) return Character; 
  function  To_Basic (Item : in Character) return Character; 
  function  To_Lower (Item : in String) return String; 
  function  To_Upper (Item : in String) return String; 
  function  To_Basic (Item : in String) return String; 
--Classifications of and conversions between Character and ISO 646  
  subtype ISO_646 is 
    Character range Character'Val(0) .. Character'Val(127); 
  function  Is_ISO_646 (Item : in Character) return Boolean; 
  function  Is_ISO_646 (Item : in String)    return Boolean; 
  function  To_ISO_646 (Item       : in Character; 
                       Substitute : in ISO_646 := ' ') 
    return ISO_646; 
  function  To_ISO_646 (Item       : in String; 
                       Substitute : in ISO_646 := ' ') 
    return String; 
-- The functions Is_Character, Is_String, T o_Character, To_String, To_Wide_Character,  
-- and To_Wide_String are obsolescent; see J.14.  
Paragraphs 14 through 18 were deleted.  
end Ada.Characters.Handling; 
In the description below for each function that returns a Boolean result, the effect is described in terms of 
the conditions under which the value True is returned . If these conditions are not met, then the function 
returns False. 
Each of the following classification functions has a formal Character parameter, Item, and returns a 
Boolean result.  
Is_Control  True if Item is a control character. A control character  is a character whose position is in 
one of the ranges 0..31 or 127..159. 
Is_Graphic  True if Item is a graphic character. A graphic character  is a character whose position is in 
one of the ranges 32..126 or 160..255. 
Is_Letter  True if Item is a letter. A letter  is a character that is in one of the ranges 'A'..'Z' or 'a'..'z', or 
whose position is in one of the ra nges 192..214, 216..246, or 248..255. 
Is_Lower  True if Item is a lower-case letter. A lower-case letter  is a character that is in the range 
'a'..'z', or whose position is in one  of the ranges 223..246 or 248..255. 
Is_Upper True if Item is  an upper-case letter. An upper-case letter  is a character that is in the range 
'A'..'Z' or whose position is in one  of the ranges 192..214 or 216.. 222. 
Is_Basic  True if Item is a basic letter. A basic letter  is a character that is in one of the ranges 'A'..'Z' 
and 'a'..'z', or that is one of the following: 'Æ', 'æ', 'Ð', 'ð', 'Þ', 'þ', or 'ß'. 
Is_Digit  True if Item is a decimal digit. A decimal digit  is a character in the range '0'..'9'. 
Is_Decimal_Digit  
 A renaming of Is_Digit. 
Is_Hexadecimal_Digit  
 True if Item is a hexadecimal digit. A hexadecimal digit  is a character that is either a 
decimal digit or that is in one of the ranges 'A' .. 'F' or 'a' .. 'f'. 5 
6 
7 8 
9 
10 11 
12 
13/2 
19 
20 
21 
22 
23 24 25 26 27 28 
29 
30 
Ada Reference Manual — 2012 Edition 
361      13 December 2012 The Package Characters.Handling   A.3.2 Is_Alphanumeric  
 True if Item is an alphanumeric character. An alphanumeric character  is a character that is 
either a letter or a decimal digit. 
Is_Special  True if Item is a special graphic character. A special graphic character  is a graphic 
character that is not alphanumeric. 
Is_Line_Terminator 
 True if Item is a character with position 10 .. 13 (Line_Feed, Line_Tabulation, Form_Feed, 
Carriage_Return) or 133 (Next_Line). 
Is_Mark Never True (no value of type Charact er has categories Mark, Non-Spacing or Mark, 
Spacing Combining). 
Is_Other_Format 
 True if Item is a character  with position 173 (Soft_Hyphen). 
Is_Punctuation_Connector 
 True if Item is a charact er with position 95 ('_', known as  Low_Line or Underscore). 
Is_Space True if Item is a character with position 32 (' ') or 160 (No_Break_Space).  
Each of the names To_Lower, To_Upper, and To_Basic  refers to two functions: one that converts from 
Character to Character, and the other that converts from String to String. The result of each Character-to-
Character function is described below, in terms of the conversion applied to It em, its formal Character 
parameter. The result of each  String-to-String convers ion is obtained by applying to each element of the 
function's String parameter the corresponding Characte r-to-Character conversion; the result is the null 
String if the value of the formal parameter is the null String. The lower bound of the result String is 1.  
To_Lower Returns the corresponding lower-case value for Item if Is_Upper(Item ), and returns Item 
otherwise. 
To_Upper Returns the corresponding upper-case value fo r Item if Is_Lower(Item) and Item has an 
upper-case form, and returns Item  otherwise. The lower case letters 'ß' and 'ÿ' do not have 
upper case forms. 
To_Basic Returns the letter corresponding to Item but with no diacritical mark, if Item is a letter but 
not a basic letter; returns Item otherwise.  
The following set of functions test for membership in  the ISO 646 character range, or convert between ISO 
646 and Character.  
Is_ISO_646 The function whose formal pa rameter, Item, is of type Charact er returns True if Item is in 
the subtype ISO_646. 
Is_ISO_646 The function whose formal parameter, Item, is of type String returns True if 
Is_ISO_646(Item(I)) is True for each I in Item'Range. 
To_ISO_646 
 The function whose first formal parameter, It em, is of type Character returns Item if 
Is_ISO_646(Item), and returns the Subs titute ISO_646 character otherwise. 
To_ISO_646 
 The function whose first formal parameter, It em, is of type String returns the String whose 
Range is 1..Item'Length and each of whose elements is given by To_ISO_646 of the 
corresponding element in Item.  
Paragraphs 42 through 49 were deleted.   
NOTES 
5  A basic letter is a letter without a diacritical mark. 31 
32 
32.1/3 
32.2/3 
32.3/3 32.4/3 32.5/3 
33 
34 
35 
36 
37 
38 
39 40 
41 
50 
Ada Reference Manual — 2012 Edition 
A.3.2    The Package Characters.Handling 13 December 2012      362 6  Except for the hexadecimal digits, basic letters, and ISO_646 characters, the categories identified in the classification 
functions form a strict hierarchy:  
— Control characters — Graphic characters  — Alphanumeric characters   — Letters    — Upper-case letters    — Lower-case letters   — Decimal digits  — Special graphic characters 
7  There are certain characters which are defined to be lower case letters by ISO 10646 and are therefore allowed in 
identifiers, but are not considered lower case letters by Ada.Characters.Handling. 
A.3.3 The Package Characters.Latin_1 
The package Characters.Latin_1 declares c onstants for characters in ISO 8859-1.  
Static Semantics 
The library package Characters.Latin_1 has the following declaration:  
package Ada.Characters.Latin_1 is 
    pragma Pure(Latin_1); 
-- Control characters:  
    NUL                  : constant  Character := Character'Val(0); 
    SOH                  : constant  Character := Character'Val(1); 
    STX                  : constant  Character := Character'Val(2); 
    ETX                  : constant  Character := Character'Val(3); 
    EOT                  : constant  Character := Character'Val(4); 
    ENQ                  : constant  Character := Character'Val(5); 
    ACK                  : constant  Character := Character'Val(6); 
    BEL                  : constant  Character := Character'Val(7); 
    BS                   : constant  Character := Character'Val(8); 
    HT                   : constant  Character := Character'Val(9); 
    LF                   : constant  Character := Character'Val(10); 
    VT                   : constant  Character := Character'Val(11); 
    FF                   : constant  Character := Character'Val(12); 
    CR                   : constant  Character := Character'Val(13); 
    SO                   : constant  Character := Character'Val(14); 
    SI                   : constant  Character := Character'Val(15); 
    DLE                  : constant  Character := Character'Val(16); 
    DC1                  : constant  Character := Character'Val(17); 
    DC2                  : constant  Character := Character'Val(18); 
    DC3                  : constant  Character := Character'Val(19); 
    DC4                  : constant  Character := Character'Val(20); 
    NAK                  : constant  Character := Character'Val(21); 
    SYN                  : constant  Character := Character'Val(22); 
    ETB                  : constant  Character := Character'Val(23); 
    CAN                  : constant  Character := Character'Val(24); 
    EM                   : constant  Character := Character'Val(25); 
    SUB                  : constant  Character := Character'Val(26); 
    ESC                  : constant  Character := Character'Val(27); 
    FS                   : constant  Character := Character'Val(28); 
    GS                   : constant  Character := Character'Val(29); 
    RS                   : constant  Character := Character'Val(30); 
    US                   : constant  Character := Character'Val(31); 51 
52 
53 54 55 56 57 58 59 
60/3 
1 
2 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
363      13 December 2012 The Package Characters.Latin_1   A.3.3 -- ISO 646 graphic characters:  
    Space                : constant  Character := ' ';  --  Character'Val(32)  
    Exclamation          : constant  Character := '!';  --  Character'Val(33)  
    Quotation            : constant  Character := '"';  --  Character'Val(34)  
    Number_Sign          : constant  Character := '#';  --  Character'Val(35)  
    Dollar_Sign          : constant  Character := '$';  --  Character'Val(36)  
    Percent_Sign         : constant  Character := '%';  --  Character'Val(37)  
    Ampersand            : constant  Character := '&';  --  Character'Val(38)  
    Apostrophe           : constant  Character := ''';  --  Character'Val(39)  
    Left_Parenthesis     : constant  Character := '(';  --  Character'Val(40)  
    Right_Parenthesis    : constant  Character := ')';  --  Character'Val(41)  
    Asterisk             : constant  Character := '*';  --  Character'Val(42)  
    Plus_Sign            : constant  Character := '+';  --  Character'Val(43)  
    Comma                : constant  Character := ',';  --  Character'Val(44)  
    Hyphen               : constant  Character := '-';  --  Character'Val(45)  
    Minus_Sign           : Character renames Hyphen; 
    Full_Stop            : constant  Character := '.';  --  Character'Val(46)  
    Solidus              : constant  Character := '/';  --  Character'Val(47)  
    --  Decimal digits '0' though '9' are at positions 48 through 57  
    Colon                : constant  Character := ':';  --  Character'Val(58)  
    Semicolon            : constant  Character := ';';  --  Character'Val(59)  
    Less_Than_Sign       : constant  Character := '<';  --  Character'Val(60)  
    Equals_Sign          : constant  Character := '=';  --  Character'Val(61)  
    Greater_Than_Sign    : constant  Character := '>';  --  Character'Val(62)  
    Question             : constant  Character := '?';  --  Character'Val(63)  
    Commercial_At        : constant  Character := '@';  --  Character'Val(64)  
    --  Letters 'A' through 'Z' are at positions 65 through 90  
    Left_Square_Bracket  : constant  Character := '[';  --  Character'Val(91)  
    Reverse_Solidus      : constant  Character := '\';  --  Character'Val(92)  
    Right_Square_Bracket : constant  Character := ']';  --  Character'Val(93)  
    Circumflex           : constant  Character := '^';  --  Character'Val(94)  
    Low_Line             : constant  Character := '_';  --  Character'Val(95)  
    Grave                : constant  Character := '`';  --  Character'Val(96)  
    LC_A                 : constant  Character := 'a';  --  Character'Val(97)  
    LC_B                 : constant  Character := 'b';  --  Character'Val(98)  
    LC_C                 : constant  Character := 'c';  --  Character'Val(99)  
    LC_D                 : constant  Character := 'd';  --  Character'Val(100)  
    LC_E                 : constant  Character := 'e';  --  Character'Val(101)  
    LC_F                 : constant  Character := 'f';  --  Character'Val(102)  
    LC_G                 : constant  Character := 'g';  --  Character'Val(103)  
    LC_H                 : constant  Character := 'h';  --  Character'Val(104)  
    LC_I                 : constant  Character := 'i';  --  Character'Val(105)  
    LC_J                 : constant  Character := 'j';  --  Character'Val(106)  
    LC_K                 : constant  Character := 'k';  --  Character'Val(107)  
    LC_L                 : constant  Character := 'l';  --  Character'Val(108)  
    LC_M                 : constant  Character := 'm';  --  Character'Val(109)  
    LC_N                 : constant  Character := 'n';  --  Character'Val(110)  
    LC_O                 : constant  Character := 'o';  --  Character'Val(111)  
    LC_P                 : constant  Character := 'p';  --  Character'Val(112)  
    LC_Q                 : constant  Character := 'q';  --  Character'Val(113)  
    LC_R                 : constant  Character := 'r';  --  Character'Val(114)  
    LC_S                 : constant  Character := 's';  --  Character'Val(115)  
    LC_T                 : constant  Character := 't';  --  Character'Val(116)  
    LC_U                 : constant  Character := 'u';  --  Character'Val(117)  
    LC_V                 : constant  Character := 'v';  --  Character'Val(118)  
    LC_W                 : constant  Character := 'w';  --  Character'Val(119)  
    LC_X                 : constant  Character := 'x';  --  Character'Val(120)  
    LC_Y                 : constant  Character := 'y';  --  Character'Val(121)  
    LC_Z                 : constant  Character := 'z';  --  Character'Val(122)  
    Left_Curly_Bracket   : constant  Character := '{';  --  Character'Val(123)  
    Vertical_Line        : constant  Character := '|';  --  Character'Val(124)  
    Right_Curly_Bracket  : constant  Character := '}';  --  Character'Val(125)  
    Tilde                : constant  Character := '~';  --  Character'Val(126)  
    DEL                  : constant  Character := Character'Val(127); 7 
8 
9 
10 
11 
12 
13 
14 
Ada Reference Manual — 2012 Edition 
A.3.3    The Package Characters.Latin_1 13 December 2012      364 -- ISO 6429 control characters:  
    IS4                  : Character renames FS; 
    IS3                  : Character renames GS; 
    IS2                  : Character renames RS; 
    IS1                  : Character renames US; 
    Reserved_128         : constant  Character := Character'Val(128); 
    Reserved_129         : constant  Character := Character'Val(129); 
    BPH                  : constant  Character := Character'Val(130); 
    NBH                  : constant  Character := Character'Val(131); 
    Reserved_132         : constant  Character := Character'Val(132); 
    NEL                  : constant  Character := Character'Val(133); 
    SSA                  : constant  Character := Character'Val(134); 
    ESA                  : constant  Character := Character'Val(135); 
    HTS                  : constant  Character := Character'Val(136); 
    HTJ                  : constant  Character := Character'Val(137); 
    VTS                  : constant  Character := Character'Val(138); 
    PLD                  : constant  Character := Character'Val(139); 
    PLU                  : constant  Character := Character'Val(140); 
    RI                   : constant  Character := Character'Val(141); 
    SS2                  : constant  Character := Character'Val(142); 
    SS3                  : constant  Character := Character'Val(143); 
    DCS                  : constant  Character := Character'Val(144); 
    PU1                  : constant  Character := Character'Val(145); 
    PU2                  : constant  Character := Character'Val(146); 
    STS                  : constant  Character := Character'Val(147); 
    CCH                  : constant  Character := Character'Val(148); 
    MW                   : constant  Character := Character'Val(149); 
    SPA                  : constant  Character := Character'Val(150); 
    EPA                  : constant  Character := Character'Val(151); 
    SOS                  : constant  Character := Character'Val(152); 
    Reserved_153         : constant  Character := Character'Val(153); 
    SCI                  : constant  Character := Character'Val(154); 
    CSI                  : constant  Character := Character'Val(155); 
    ST                   : constant  Character := Character'Val(156); 
    OSC                  : constant  Character := Character'Val(157); 
    PM                   : constant  Character := Character'Val(158); 
    APC                  : constant  Character := Character'Val(159); 
-- Other graphic characters:  
-- Character positions 160 (16#A0#) .. 175 (16#AF#):  
    No_Break_Space             : constant  Character := ' '; -- Character'Val(160)  
    NBSP                       : Character renames No_Break_Space; 
    Inverted_Exclamation       : constant  Character := '¡'; -- Character'Val(161)  
    Cent_Sign                  : constant  Character := '¢'; -- Character'Val(162)  
    Pound_Sign                 : constant  Character := '£'; -- Character'Val(163)  
    Currency_Sign              : constant  Character := '¤'; -- Character'Val(164)  
    Yen_Sign                   : constant  Character := '¥'; -- Character'Val(165)  
    Broken_Bar                 : constant  Character := '¦'; -- Character'Val(166)  
    Section_Sign               : constant  Character := '§'; -- Character'Val(167)  
    Diaeresis                  : constant  Character := '¨'; -- Character'Val(168)  
    Copyright_Sign             : constant  Character := '©'; -- Character'Val(169)  
    Feminine_Ordinal_Indicator : constant  Character := 'ª'; -- Character'Val(170)  
    Left_Angle_Quotation       : constant  Character := '«'; -- Character'Val(171)  
    Not_Sign                   : constant  Character := '¬'; -- Character'Val(172)  
    Soft_Hyphen                : constant  Character := Character'Val(173); 
    Registered_Trade_Mark_Sign : constant  Character := '®'; -- Character'Val(174)  
    Macron                     : constant  Character := '¯'; -- Character'Val(175)  15 
16 
17 
18 
19 
20 
21/3 
Ada Reference Manual — 2012 Edition 
365      13 December 2012 The Package Characters.Latin_1   A.3.3 -- Character positions 176 (16#B0#) .. 191 (16#BF#):  
    Degree_Sign                : constant  Character := '°'; -- Character'Val(176)  
    Ring_Above                 : Character renames Degree_Sign; 
    Plus_Minus_Sign            : constant  Character := '±'; -- Character'Val(177)  
    Superscript_Two            : constant  Character := '²'; -- Character'Val(178)  
    Superscript_Three          : constant  Character := '³'; -- Character'Val(179)  
    Acute                      : constant  Character := '´'; -- Character'Val(180)  
    Micro_Sign                 : constant  Character := 'µ'; -- Character'Val(181)  
    Pilcrow_Sign               : constant  Character := '¶'; -- Character'Val(182)  
    Paragraph_Sign             : Character renames Pilcrow_Sign; 
    Middle_Dot                 : constant  Character := '·'; -- Character'Val(183)  
    Cedilla                    : constant  Character := '¸'; -- Character'Val(184)  
    Superscript_One            : constant  Character := '¹'; -- Character'Val(185)  
    Masculine_Ordinal_Indicator: constant  Character := 'º'; -- Character'Val(186)  
    Right_Angle_Quotation      : constant  Character := '»'; -- Character'Val(187)  
    Fraction_One_Quarter       : constant  Character := '¼'; -- Character'Val(188)  
    Fraction_One_Half          : constant  Character := '½'; -- Character'Val(189)  
    Fraction_Three_Quarters    : constant  Character := '¾'; -- Character'Val(190)  
    Inverted_Question          : constant  Character := '¿'; -- Character'Val(191)  
-- Character positions 192 (16#C0#) .. 207 (16#CF#):  
    UC_A_Grave                 : constant  Character := 'À'; -- Character'Val(192)  
    UC_A_Acute                 : constant  Character := 'Á'; -- Character'Val(193)  
    UC_A_Circumflex            : constant  Character := 'Â'; -- Character'Val(194)  
    UC_A_Tilde                 : constant  Character := 'Ã'; -- Character'Val(195)  
    UC_A_Diaeresis             : constant  Character := 'Ä'; -- Character'Val(196)  
    UC_A_Ring                  : constant  Character := 'Å'; -- Character'Val(197)  
    UC_AE_Diphthong            : constant  Character := 'Æ'; -- Character'Val(198)  
    UC_C_Cedilla               : constant  Character := 'Ç'; -- Character'Val(199)  
    UC_E_Grave                 : constant  Character := 'È'; -- Character'Val(200)  
    UC_E_Acute                 : constant  Character := 'É'; -- Character'Val(201)  
    UC_E_Circumflex            : constant  Character := 'Ê'; -- Character'Val(202)  
    UC_E_Diaeresis             : constant  Character := 'Ë'; -- Character'Val(203)  
    UC_I_Grave                 : constant  Character := 'Ì'; -- Character'Val(204)  
    UC_I_Acute                 : constant  Character := 'Í'; -- Character'Val(205)  
    UC_I_Circumflex            : constant  Character := 'Î'; -- Character'Val(206)  
    UC_I_Diaeresis             : constant  Character := 'Ï'; -- Character'Val(207)  
-- Character positions 208 (16#D0#) .. 223 (16#DF#):  
    UC_Icelandic_Eth           : constant  Character := 'Ð'; -- Character'Val(208)  
    UC_N_Tilde                 : constant  Character := 'Ñ'; -- Character'Val(209)  
    UC_O_Grave                 : constant  Character := 'Ò'; -- Character'Val(210)  
    UC_O_Acute                 : constant  Character := 'Ó'; -- Character'Val(211)  
    UC_O_Circumflex            : constant  Character := 'Ô'; -- Character'Val(212)  
    UC_O_Tilde                 : constant  Character := 'Õ'; -- Character'Val(213)  
    UC_O_Diaeresis             : constant  Character := 'Ö'; -- Character'Val(214)  
    Multiplication_Sign        : constant  Character := '×'; -- Character'Val(215)  
    UC_O_Oblique_Stroke        : constant  Character := 'Ø'; -- Character'Val(216)  
    UC_U_Grave                 : constant  Character := 'Ù'; -- Character'Val(217)  
    UC_U_Acute                 : constant  Character := 'Ú'; -- Character'Val(218)  
    UC_U_Circumflex            : constant  Character := 'Û'; -- Character'Val(219)  
    UC_U_Diaeresis             : constant  Character := 'Ü'; -- Character'Val(220)  
    UC_Y_Acute                 : constant  Character := 'Ý'; -- Character'Val(221)  
    UC_Icelandic_Thorn         : constant  Character := 'Þ'; -- Character'Val(222)  
    LC_German_Sharp_S          : constant  Character := 'ß'; -- Character'Val(223)  22 
23 
24 
Ada Reference Manual — 2012 Edition 
A.3.3    The Package Characters.Latin_1 13 December 2012      366 -- Character positions 224 (16#E0#) .. 239 (16#EF#):  
    LC_A_Grave                 : constant  Character := 'à'; -- Character'Val(224)  
    LC_A_Acute                 : constant  Character := 'á'; -- Character'Val(225)  
    LC_A_Circumflex            : constant  Character := 'â'; -- Character'Val(226)  
    LC_A_Tilde                 : constant  Character := 'ã'; -- Character'Val(227)  
    LC_A_Diaeresis             : constant  Character := 'ä'; -- Character'Val(228)  
    LC_A_Ring                  : constant  Character := 'å'; -- Character'Val(229)  
    LC_AE_Diphthong            : constant  Character := 'æ'; -- Character'Val(230)  
    LC_C_Cedilla               : constant  Character := 'ç'; -- Character'Val(231)  
    LC_E_Grave                 : constant  Character := 'è'; -- Character'Val(232)  
    LC_E_Acute                 : constant  Character := 'é'; -- Character'Val(233)  
    LC_E_Circumflex            : constant  Character := 'ê'; -- Character'Val(234)  
    LC_E_Diaeresis             : constant  Character := 'ë'; -- Character'Val(235)  
    LC_I_Grave                 : constant  Character := 'ì'; -- Character'Val(236)  
    LC_I_Acute                 : constant  Character := 'í'; -- Character'Val(237)  
    LC_I_Circumflex            : constant  Character := 'î'; -- Character'Val(238)  
    LC_I_Diaeresis             : constant  Character := 'ï'; -- Character'Val(239)  
-- Character positions 240 (16#F0#) .. 255 (16#FF#):  
    LC_Icelandic_Eth           : constant  Character := 'ð'; -- Character'Val(240)  
    LC_N_Tilde                 : constant  Character := 'ñ'; -- Character'Val(241)  
    LC_O_Grave                 : constant  Character := 'ò'; -- Character'Val(242)  
    LC_O_Acute                 : constant  Character := 'ó'; -- Character'Val(243)  
    LC_O_Circumflex            : constant  Character := 'ô'; -- Character'Val(244)  
    LC_O_Tilde                 : constant  Character := 'õ'; -- Character'Val(245)  
    LC_O_Diaeresis             : constant  Character := 'ö'; -- Character'Val(246)  
    Division_Sign              : constant  Character := '÷'; -- Character'Val(247)  
    LC_O_Oblique_Stroke        : constant  Character := 'ø'; -- Character'Val(248)  
    LC_U_Grave                 : constant  Character := 'ù'; -- Character'Val(249)  
    LC_U_Acute                 : constant  Character := 'ú'; -- Character'Val(250)  
    LC_U_Circumflex            : constant  Character := 'û'; -- Character'Val(251)  
    LC_U_Diaeresis             : constant  Character := 'ü'; -- Character'Val(252)  
    LC_Y_Acute                 : constant  Character := 'ý'; -- Character'Val(253)  
    LC_Icelandic_Thorn         : constant  Character := 'þ'; -- Character'Val(254)  
    LC_Y_Diaeresis             : constant  Character := 'ÿ'; -- Character'Val(255)  
end Ada.Characters.Latin_1; 
Implementation Permissions 
An implementation may provide additi onal packages as children of Ada.Characters, to declare names for 
the symbols of the local character set or other character sets.  25 
26 
27 
Ada Reference Manual — 2012 Edition 
367      13 December 2012 The Package Characters.Conversions   A.3.4 A.3.4 The Package Characters.Conversions 
Static Semantics 
The library package Characters.Conversi ons has the following declaration:  
package Ada.Characters.Conversions is 
   pragma Pure(Conversions); 
   function  Is_Character (Item : in Wide_Character)      return Boolean; 
   function  Is_String    (Item : in Wide_String)         return Boolean; 
   function  Is_Character (Item : in Wide_Wide_Character) return Boolean; 
   function  Is_String    (Item : in Wide_Wide_String)    return Boolean; 
   function  Is_Wide_Character (Item : in Wide_Wide_Character) 
      return Boolean; 
   function  Is_Wide_String    (Item : in Wide_Wide_String) 
      return Boolean; 
   function  To_Wide_Character (Item : in Character) return Wide_Character; 
   function  To_Wide_String    (Item : in String)    return Wide_String; 
   function  To_Wide_Wide_Character (Item : in Character) 
      return Wide_Wide_Character; 
   function  To_Wide_Wide_String    (Item : in String) 
      return Wide_Wide_String; 
   function  To_Wide_Wide_Character (Item : in Wide_Character) 
      return Wide_Wide_Character; 
   function  To_Wide_Wide_String    (Item : in Wide_String) 
      return Wide_Wide_String; 
   function  To_Character (Item       : in Wide_Character; 
                         Substitute : in Character := ' ') 
      return Character; 
   function  To_String    (Item       : in Wide_String; 
                          Substitute : in Character := ' ') 
      return String; 
   function  To_Character (Item :       in Wide_Wide_Character; 
                          Substitute : in Character := ' ') 
      return Character; 
   function  To_String    (Item :       in Wide_Wide_String; 
                          Substitute : in Character := ' ') 
      return String; 
   function  To_Wide_Character (Item :       in Wide_Wide_Character; 
                               Substitute : in Wide_Character := ' ') 
      return Wide_Character; 
   function  To_Wide_String    (Item :       in Wide_Wide_String; 
                               Substitute : in Wide_Character := ' ') 
      return Wide_String; 
end Ada.Characters.Conversions; 
The functions in package Characters.Conversions test  Wide_Wide_Character or Wide_Character values 
for membership in Wide_Character or Character , or convert between corresponding characters of 
Wide_Wide_Character, Wide_Character, and Character. 
function  Is_Character (Item : in Wide_Character) return Boolean; 
Returns True if Wide_Character'Pos(It em) <= Character'Pos(Character'Last). 
function  Is_Character (Item : in Wide_Wide_Character) return Boolean; 
Returns True if Wide_Wide_Character'Pos (Item) <= Character'Pos(Character'Last). 
function  Is_Wide_Character (Item : in Wide_Wide_Character) return Boolean; 
Returns True if Wide_Wide_Character'Pos(Item ) <= Wide_Character'Pos(Wide_Character'Last). 1/2 
2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
8/2 
9/2 
10/2 
11/2 
12/2 
13/2 
Ada Reference Manual — 2012 Edition 
A.3.4    The Package Characters.Conve rsions 13 December 2012      368 function  Is_String (Item : in Wide_String)      return Boolean; 
function  Is_String (Item : in Wide_Wide_String) return Boolean; 
Returns True if Is_Character(Item(I)) is True for each I in Item'Range. 
function  Is_Wide_String (Item : in Wide_Wide_String) return Boolean; 
Returns True if Is_Wide_Character(Item (I)) is True for each I in Item'Range. 
function  To_Character (Item :       in Wide_Character; 
                       Substitute : in Character := ' ') return Character; 
function  To_Character (Item :       in Wide_Wide_Character; 
                       Substitute : in Character := ' ') return Character; 
Returns the Character corresponding to Item if Is_Character(Item), and returns the Substitute 
Character otherwise. 
function  To_Wide_Character (Item : in Character) return Wide_Character; 
Returns the Wide_Character X such that Ch aracter'Pos(Item) = Wide_Character'Pos (X). 
function  To_Wide_Character (Item :       in Wide_Wide_Character; 
                            Substitute : in Wide_Character := ' ') 
   return Wide_Character; 
Returns the Wide_Character corresponding to Item  if Is_Wide_Character(Item), and returns the 
Substitute Wide_Character otherwise. 
function  To_Wide_Wide_Character (Item : in Character) 
   return Wide_Wide_Character; 
Returns the Wide_Wide_Character X such that Character'Pos(Item) = 
Wide_Wide_Character'Pos (X). 
function  To_Wide_Wide_Character (Item : in Wide_Character) 
   return Wide_Wide_Character; 
Returns the Wide_Wide_Character X such that Wide_Character'Pos(Item) = 
Wide_Wide_Character'Pos (X). 
function  To_String (Item :       in Wide_String; 
                    Substitute : in Character := ' ') return String; 
function  To_String (Item :       in Wide_Wide_String; 
                    Substitute : in Character := ' ') return String; 
Returns the String whose range is 1..Item'Length and each of whose elements is given by 
To_Character of the corre sponding element in Item. 
function  To_Wide_String (Item : in String) return Wide_String; 
Returns the Wide_String whose range is 1..Item'Length and each of whose elements is given by 
To_Wide_Character of the co rresponding element in Item. 
function  To_Wide_String (Item :       in Wide_Wide_String; 
                         Substitute : in Wide_Character := ' ') 
   return Wide_String; 
Returns the Wide_String whose range is 1..Item'Length and each of whose elements is given by 
To_Wide_Character of the corresponding elem ent in Item with the given Substitute 
Wide_Character. 14/2 
15/2 
16/2 
17/2 
18/2 
19/2 
20/2 
21/2 
22/2 
23/2 
24/2 
25/2 
26/2 
27/2 
28/2 
29/2 
30/2 
31/2 
32/2 
33/2 
Ada Reference Manual — 2012 Edition 
369      13 December 2012 The Package Characters.Conversions   A.3.4 function  To_Wide_Wide_String (Item : in String) return Wide_Wide_String; 
function  To_Wide_Wide_String (Item : in Wide_String) 
   return Wide_Wide_String; 
Returns the Wide_Wide_String whose range is 1..Item'Length and each of whose elements is 
given by To_Wide_Wide_Character of  the corresponding element in Item. 
A.3.5 The Package Wide_Characters.Handling 
The package Wide_Characters.Handling provides opera tions for classifying Wide_Characters and case 
folding for Wide_Characters.  
Static Semantics 
The library package Wide_Characters.Handling has the following declaration: 
package Ada.Wide_Characters.Handling is 
   pragma Pure(Handling); 
   function  Character_Set_Version return String; 
   function  Is_Control (Item : Wide_Character) return Boolean; 
   function  Is_Letter (Item : Wide_Character) return Boolean; 
   function  Is_Lower (Item : Wide_Character) return Boolean; 
   function  Is_Upper (Item : Wide_Character) return Boolean; 
   function  Is_Digit (Item : Wide_Character) return Boolean; 
   function  Is_Decimal_Digit (Item : Wide_Character) return Boolean 
      renames Is_Digit; 
   function  Is_Hexadecimal_Digit (Item : Wide_Character) return Boolean; 
   function  Is_Alphanumeric (Item : Wide_Character) return Boolean; 
   function  Is_Special (Item : Wide_Character) return Boolean; 
   function  Is_Line_Terminator (Item : Wide_Character) return Boolean; 
   function  Is_Mark (Item : Wide_Character) return Boolean; 
   function  Is_Other_Format (Item : Wide_Character) return Boolean; 
   function  Is_Punctuation_Connector (Item : Wide_Character) return Boolean; 
   function  Is_Space (Item : Wide_Character) return Boolean; 
   function  Is_Graphic (Item : Wide_Character) return Boolean; 
   function  To_Lower (Item : Wide_Character) return Wide_Character; 
   function  To_Upper (Item : Wide_Character) return Wide_Character; 
   function  To_Lower (Item : Wide_String) return Wide_String; 
   function  To_Upper (Item : Wide_String) return Wide_String; 
end Ada.Wide_Characters.Handling; 
The subprograms defined in Wide_Char acters.Handling are locale independent. 
function  Character_Set_Version return String; 
Returns an implementation-defined identifier that  identifies the version of the character set 
standard that is used for categorizing characters by the implementation. 
function  Is_Control (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as other_control ; 
otherwise returns False. 34/2 
35/2 
1/3 
2/3 
3/3 
4/3 
5/3 6/3 7/3 8/3 9/3 
10/3 
11/3 
12/3 13/3 14/3 15/3 16/3 17/3 18/3 19/3 20/3 
21/3 22/3 
23/3 
24/3 
25/3 
26/3 
27/3 
Ada Reference Manual — 2012 Edition 
A.3.5    The Package Wide_Characters. Handling 13 December 2012      370 function  Is_Letter (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as letter_uppercase , 
letter_lowercase , letter_titlecase , letter_modifier , letter_other , or number_letter ; otherwise 
returns False. 
function  Is_Lower (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as letter_lowercase ; 
otherwise returns False. 
function  Is_Upper (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as letter_uppercase ; 
otherwise returns False. 
function  Is_Digit (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as number_decimal ; 
otherwise returns False. 
function  Is_Hexadecimal_Digit (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as number_decimal , or is 
in the range 'A' .. 'F' or 'a' .. 'f'; otherwise returns False. 
function  Is_Alphanumeric (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as letter_uppercase , 
letter_lowercase , letter_titlecase , letter_modifier , letter_other , number_letter , or 
number_decimal ; otherwise returns False. 
function  Is_Special (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as graphic_character , but 
not categorized as letter_uppercase , letter_lowercase , letter_titlecase , letter_modifier , 
letter_other , number_letter , or number_decimal ; otherwise returns False. 
function  Is_Line_Terminator (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as separator_line  or 
separator_paragraph , or if Item is a conventional lin e terminator char acter (Line_Feed, 
Line_Tabulation, Form_Feed, Carriage_Return , Next_Line); otherwise returns False. 
function  Is_Mark (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as mark_non_spacing  or 
mark_spacing_combining ; otherwise returns False. 
function  Is_Other_Format (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as other_format ; 
otherwise returns False. 
function  Is_Punctuation_Connector (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as 
punctuation_connector ; otherwise returns False. 28/3 
29/3 
30/3 
31/3 
32/3 
33/3 
34/3 
35/3 
36/3 
37/3 
38/3 
39/3 
40/3 
41/3 
42/3 
43/3 
44/3 
45/3 
46/3 
47/3 
48/3 
49/3 
Ada Reference Manual — 2012 Edition 
371      13 December 2012 The Package Wide_Characters.Handling   A.3.5 function  Is_Space (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as separator_space ; 
otherwise returns False. 
function  Is_Graphic (Item : Wide_Character) return Boolean; 
Returns True if the Wide_Character de signated by Item is categorized as graphic_character ; 
otherwise returns False. 
function  To_Lower (Item : Wide_Character) return Wide_Character; 
Returns the Simple Lowercase Mapping as define d by documents referenced in the note in 
Clause 1 of ISO/IEC 10646:2011 of the Wide_Cha racter designated by Item. If the Simple 
Lowercase Mapping does not exist for the Wide_Char acter designated by Item, then the value of 
Item is returned. 
function  To_Lower (Item : Wide_String) return Wide_String; 
Returns the result of applying the To_Lower conve rsion to each Wide_Character element of the 
Wide_String designated by Item. The result is th e null Wide_String if the value of the formal 
parameter is the null Wide_String. The lo wer bound of the result Wide_String is 1. 
function  To_Upper (Item : Wide_Character) return Wide_Character; 
Returns the Simple Uppercase Mapping as define d by documents referenced in the note in 
Clause 1 of ISO/IEC 10646:2011 of the Wide_Cha racter designated by Item. If the Simple 
Uppercase Mapping does not exist for the Wide_Char acter designated by Item, then the value of 
Item is returned. 
function  To_Upper (Item : Wide_String) return Wide_String; 
Returns the result of applying the To_Upper conve rsion to each Wide_Character element of the 
Wide_String designated by Item. The result is th e null Wide_String if the value of the formal 
parameter is the null Wide_String. The lo wer bound of the result Wide_String is 1. 
Implementation Advice 
The string returned by Character_Set_Version should include either “10646:” or “Unicode”. 
NOTES 
8  The results returned by these functions may depend on which particular version of the 10646 standard is supported by the implementation (see 2.1). 
9  The case insensitive equality comparison routines provided in A.4.10, “String Comparison” are also available for wide 
strings (see A.4.7).  
A.3.6 The Package Wide_Wide_Characters.Handling 
The package Wide_Wide_Characters.Handling has the same contents as Wide_Characters.Handling 
except that each occurrence of Wide_Character is replaced by Wide_Wide_Character, and each 
occurrence of Wide_String is replaced by Wide_Wide_String. 50/3 
51/3 
52/3 
53/3 
54/3 
55/3 
56/3 
57/3 
58/3 
59/3 
60/3 
61/3 
62/3 
63/3 
64/3 
1/3 
Ada Reference Manual — 2012 Edition 
A.4   String Handling 13 December 2012      372 A.4 String Handling 
This subclause presents the specifications of the package Strings and several child packages, which 
provide facilities for dealing with string data. Fi xed-length, bounded-length, and unbounded-length strings 
are supported, for String, Wide_Str ing, and Wide_Wide_String. The string-handling subprograms include 
searches for pattern strings and for characters in pr ogram-specified sets, translation (via a character-to-
character mapping), and transformation (replacing, inser ting, overwriting, and deleting of substrings).  
A.4.1 The Package Strings 
The package Strings provides declarations common to the string handling packages.  
Static Semantics 
The library package Strings has the following declaration:  
package Ada.Strings is 
   pragma Pure(Strings); 
   Space      : constant  Character      := ' '; 
   Wide_Space : constant  Wide_Character := ' '; 
   Wide_Wide_Space : constant  Wide_Wide_Character := ' '; 
   Length_Error, Pattern_Error, Index_Error, Translation_Error : exception ; 
   type Alignment  is (Left, Right, Center); 
   type Truncation is (Left, Right, Error); 
   type Membership is (Inside, Outside); 
   type Direction  is (Forward, Backward); 
   type Trim_End   is (Left, Right, Both); 
end Ada.Strings; 
A.4.2 The Package Strings.Maps 
The package Strings.Maps defines the types, operations , and other entities needed for character sets and 
character-to-character mappings.  
Static Semantics 
The library package Strings.Maps has the following declaration:  
package Ada.Strings.Maps is 
   pragma Pure(Maps); 
   --  Representation for a set of character values:  
   type Character_Set is private; 
   pragma Preelaborable_Initialization(Character_Set); 
   Null_Set : constant  Character_Set; 
   type Character_Range is 
     record 
        Low  : Character;         High : Character;      end record; 
   -- Represents Character range Low..High  
   type Character_Ranges is array (Positive range <>) of Character_Range; 
   function  To_Set    (Ranges : in Character_Ranges) return Character_Set; 
   function  To_Set    (Span   : in Character_Range) return Character_Set; 
   function  To_Ranges (Set    : in Character_Set)  return Character_Ranges; 
   function  "="   (Left, Right : in Character_Set) return Boolean; 1/3 
1 
2 
3 
4/2 
5 
6 
1 
2 
3/2 
4/2 
5 
6 
7 
8 9 
10 11 
Ada Reference Manual — 2012 Edition 
373      13 December 2012 The Package Strings.Maps   A.4.2    function  "not" (Right : in Character_Set)       return Character_Set; 
   function  "and" (Left, Right : in Character_Set) return Character_Set; 
   function  "or"  (Left, Right : in Character_Set) return Character_Set; 
   function  "xor" (Left, Right : in Character_Set) return Character_Set; 
   function  "-"   (Left, Right : in Character_Set) return Character_Set; 
   function  Is_In (Element : in Character; 
                   Set     : in Character_Set) 
      return Boolean; 
   function  Is_Subset (Elements : in Character_Set; 
                       Set      : in Character_Set) 
      return Boolean; 
   function  "<=" (Left  : in Character_Set; 
                  Right : in Character_Set) 
      return Boolean renames Is_Subset; 
   --  Alternative representation for a set of character values:  
   subtype Character_Sequence is String; 
   function  To_Set (Sequence  : in Character_Sequence) return Character_Set; 
   function  To_Set (Singleton : in Character)     return Character_Set; 
   function  To_Sequence (Set  : in Character_Set) return Character_Sequence; 
   --  Representation for a char acter to character mapping:  
   type Character_Mapping is private; 
   pragma Preelaborable_Initialization(Character_Mapping); 
   function  Value (Map     : in Character_Mapping; 
                   Element : in Character) 
      return Character; 
   Identity : constant  Character_Mapping; 
   function  To_Mapping (From, To : in Character_Sequence) 
      return Character_Mapping; 
   function  To_Domain (Map : in Character_Mapping) 
      return Character_Sequence; 
   function  To_Range  (Map : in Character_Mapping) 
      return Character_Sequence; 
   type Character_Mapping_Function is 
      access function  (From : in Character) return Character; 
private 
   ... -- not specified by the language  
end Ada.Strings.Maps; 
An object of type Character_Set represents a set of characters. 
Null_Set represents the set containing no characters. An object Obj of type Character_Range represents th e set of characters in the range Obj.Low .. Obj.High. 
An object Obj of type Character_Ranges represents the union of the sets corresponding to Obj(I) for I in 
Obj'Range.  
function  To_Set (Ranges : in Character_Ranges) return Character_Set; 
If Ranges'Length=0 then Null_Set is returned; othe rwise, the returned value represents the set 
corresponding to Ranges. 
function  To_Set (Span : in Character_Range) return Character_Set; 
The returned value represents the se t containing each character in Span.  12 
13 
14 15 16 
17 
18 19 
20/2 
21 22 
23 
24 
25 
26 
27 
28 29 30 
31 
32/3 
33 
34 
Ada Reference Manual — 2012 Edition 
A.4.2    The Package Strings.Maps 13 December 2012      374 function  To_Ranges (Set : in Character_Set) return Character_Ranges; 
If Set = Null_Set, then an empty Character_Range s array is returned; otherwise, the shortest 
array of contiguous ranges of Character values in Set, in increasing order of Low, is returned. 
function  "=" (Left, Right : in Character_Set) return Boolean; 
The function "=" returns True if Left and Right represent identical sets, and False otherwise.  
Each of the logical operators " not", "and", "or", and " xor" returns a Character_Set value that represents 
the set obtained by applying the corresponding operation to  the set(s) represented by the parameter(s) of 
the operator. "–"(Left, Right) is equiva lent to "and"(Left, "not"(Right)).  
function  Is_In (Element : in Character; 
                Set     : in Character_Set); 
   return Boolean; 
Is_In returns True if Element is  in Set, and False otherwise. 
function  Is_Subset (Elements : in Character_Set; 
                    Set      : in Character_Set) 
   return Boolean; 
Is_Subset returns True if Elements is a subset of Set, and False otherwise. 
subtype Character_Sequence is String; 
The Character_Sequence subtype is used to portray a set of character values and also to identify 
the domain and range of a character mapping.  
function  To_Set (Sequence  : in Character_Sequence) return Character_Set; 
 function  To_Set (Singleton : in Character)          return Character_Set; 
Sequence portrays the set of character values th at it explicitly contains (ignoring duplicates). 
Singleton portrays the set comprising a single Character. Each of the To_Set functions returns a Character_Set value that represents the set portrayed by Sequence or Singleton. 
function  To_Sequence (Set : in Character_Set) return Character_Sequence; 
The function To_Sequence returns a Character_Se quence value containing each of the characters 
in the set represented by Set, in  ascending order with no duplicates. 
type Character_Mapping is private; 
An object of type Character_Mapping represents a Character-to-Character mapping. 
function  Value (Map     : in Character_Mapping; 
                Element : in Character) 
   return Character; 
The function Value returns the Character value to which Element maps with respect to the 
mapping represented by Map.  
A character C matches  a pattern character P with respect to a given Character_Mapping value Map if 
Value(Map, C) = P. A string S matches  a pattern string P with respect to a given Character_Mapping if 
their lengths are the same and if each character in  S matches its corresponding character in the pattern 
string P.  
String handling subprograms that deal with charact er mappings have parameters whose type is 
Character_Mapping.  35 
36/3 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
Ada Reference Manual — 2012 Edition 
375      13 December 2012 The Package Strings.Maps   A.4.2 Identity : constant  Character_Mapping; 
Identity maps each Character to itself. 
function  To_Mapping (From, To : in Character_Sequence) 
    return Character_Mapping; 
To_Mapping produces a Character_Mapping such that each element of From maps to the 
corresponding element of To, and each other char acter maps to itself. If From'Length /= 
To'Length, or if some character is repeated in From, then Translation_Error is propagated. 
function  To_Domain (Map : in Character_Mapping) return Character_Sequence; 
To_Domain returns the shortest Character_Sequen ce value D such that each character not in D 
maps to itself, and such that the characters in  D are in ascending order. The lower bound of D is 
1. 
function  To_Range  (Map : in Character_Mapping) return Character_Sequence; 
To_Range returns the Character_Sequence value R,  such that if D = To_Domain(Map), then R 
has the same bounds as D, and D(I) maps to R(I) for each I in D'Range.  
An object F of type Character_Mapping_Function maps  a Character value C to the Character value 
F.all(C), which is said to match  C with respect to mapping function F.  
NOTES 
10  Character_Mapping and Character_Mapping_Function are used both for character equivalence mappings in the search subprograms (such as for case insensitivity) and as transformational mappings in the Translate subprograms. 
11  To_Domain(Identity) and To_Range(Iden tity) each returns the null string.  
Examples 
To_Mapping("ABCD", "ZZAB") returns a Character_Mapping that maps 'A' and 'B' to 'Z', 'C' to 'A', 'D' to 
'B', and each other Character to itself.  
A.4.3 Fixed-Length String Handling 
The language-defined package Strings.Fixed provi des string-handling subprograms for fixed-length 
strings; that is, for values of type Standard.Stri ng. Several of these subprograms are procedures that 
modify the contents of a String that is passed as an out or an in out parameter; each has additional 
parameters to control the effect when the logical le ngth of the result differs fro m the parameter's length. 
For each function that returns a String, the lower bound of the returned value is 1.  The basic model embodied in the pack age is that a fixed-length string comprises significant characters and 
possibly padding (with space characters) on either or both ends. When a shorter string is copied to a longer 
string, padding is inserted, and when a longer string is  copied to a shorter one, padding is stripped. The 
Move procedure in Strings.Fixed, which takes a String as an out parameter, allows the programmer to 
control these effects. Similar control is provi ded by the string transformation procedures.  
Static Semantics 
The library package Strings.Fixed has the following declaration:  
with Ada.Strings.Maps; 
package Ada.Strings.Fixed is 
   pragma Preelaborate(Fixed); 
-- "Copy" procedure for strings of possibly different lengths  56 
57 
58 
59 
60 
61 
62 
63/1 
64 
65 
66 
67 
1 
2 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
A.4.3    Fixed-Length String Hand ling 13 December 2012      376    procedure  Move (Source  : in  String; 
                   Target  : out String; 
                   Drop    : in  Truncation := Error; 
                   Justify : in  Alignment  := Left; 
                   Pad     : in  Character  := Space); 
-- Search subprograms  
   function  Index (Source  : in String; 
                   Pattern : in String; 
                   From    : in Positive; 
                   Going   : in Direction := Forward; 
                   Mapping : in Maps.Character_Mapping := Maps.Identity) 
      return Natural; 
   function  Index (Source  : in String; 
                   Pattern : in String; 
                   From    : in Positive; 
                   Going   : in Direction := Forward; 
                   Mapping : in Maps.Character_Mapping_Function) 
      return Natural; 
   function  Index (Source   : in String; 
                   Pattern  : in String; 
                   Going    : in Direction := Forward; 
                   Mapping  : in Maps.Character_Mapping 
                                := Maps.Identity)       return Natural; 
   function  Index (Source   : in String; 
                   Pattern  : in String; 
                   Going    : in Direction := Forward; 
                   Mapping  : in Maps.Character_Mapping_Function) 
      return Natural; 
   function  Index (Source  : in String; 
                   Set     : in Maps.Character_Set; 
                   From    : in Positive; 
                   Test    : in Membership := Inside; 
                   Going   : in Direction := Forward) 
      return Natural; 
   function  Index (Source : in String; 
                   Set    : in Maps.Character_Set; 
                   Test   : in Membership := Inside; 
                   Going  : in Direction  := Forward) 
      return Natural; 
   function  Index_Non_Blank (Source : in String; 
                             From   : in Positive; 
                             Going  : in Direction := Forward) 
      return Natural; 
   function  Index_Non_Blank (Source : in String; 
                             Going  : in Direction := Forward) 
      return Natural; 
   function  Count (Source   : in String; 
                   Pattern  : in String; 
                   Mapping  : in Maps.Character_Mapping 
                                 := Maps.Identity)       return Natural; 
   function  Count (Source   : in String; 
                   Pattern  : in String; 
                   Mapping  : in Maps.Character_Mapping_Function) 
      return Natural; 
   function  Count (Source   : in String; 
                   Set      : in Maps.Character_Set) 
      return Natural; 7 
8 
8.1/2 
8.2/2 
9 
10 
10.1/2 
11 
11.1/2 
12 
13 
14 
15 
Ada Reference Manual — 2012 Edition 
377      13 December 2012 Fixe d-Length String Handling   A.4.3    procedure  Find_Token (Source : in String; 
                         Set    : in Maps.Character_Set; 
                         From   : in Positive; 
                         Test   : in Membership; 
                         First  : out Positive; 
                         Last   : out Natural); 
   procedure  Find_Token (Source : in String; 
                         Set    : in Maps.Character_Set; 
                         Test   : in Membership; 
                         First  : out Positive; 
                         Last   : out Natural); 
-- String translation subprograms  
   function  Translate (Source  : in String; 
                       Mapping : in Maps.Character_Mapping) 
      return String; 
   procedure  Translate (Source  : in out String; 
                        Mapping : in Maps.Character_Mapping); 
   function  Translate (Source  : in String; 
                       Mapping : in Maps.Character_Mapping_Function) 
      return String; 
   procedure  Translate (Source  : in out String; 
                        Mapping : in Maps.Character_Mapping_Function); 
-- String transformation subprograms  
   function  Replace_Slice (Source   : in String; 
                           Low      : in Positive; 
                           High     : in Natural; 
                           By       : in String) 
      return String; 
   procedure  Replace_Slice (Source   : in out String; 
                            Low      : in Positive; 
                            High     : in Natural; 
                            By       : in String; 
                            Drop     : in Truncation := Error; 
                            Justify  : in Alignment  := Left; 
                            Pad      : in Character  := Space); 
   function  Insert (Source   : in String; 
                    Before   : in Positive; 
                    New_Item : in String) 
      return String; 
   procedure  Insert (Source   : in out String; 
                     Before   : in Positive; 
                     New_Item : in String; 
                     Drop     : in Truncation := Error); 
   function  Overwrite (Source   : in String; 
                       Position : in Positive; 
                       New_Item : in String) 
      return String; 
   procedure  Overwrite (Source   : in out String; 
                        Position : in Positive; 
                        New_Item : in String; 
                        Drop     : in Truncation := Right); 
   function  Delete (Source  : in String; 
                    From    : in Positive; 
                    Through : in Natural) 
      return String; 
   procedure  Delete (Source  : in out String; 
                     From    : in Positive; 
                     Through : in Natural; 
                     Justify : in Alignment := Left; 
                     Pad     : in Character := Space); 15.1/3 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
Ada Reference Manual — 2012 Edition 
A.4.3    Fixed-Length String Hand ling 13 December 2012      378  --String selector subprograms  
   function  Trim (Source : in String; 
                  Side   : in Trim_End) 
      return String; 
   procedure  Trim (Source  : in out String; 
                   Side    : in Trim_End; 
                   Justify : in Alignment := Left; 
                   Pad     : in Character := Space); 
   function  Trim (Source : in String; 
                  Left   : in Maps.Character_Set; 
                  Right  : in Maps.Character_Set) 
      return String; 
   procedure  Trim (Source  : in out String; 
                   Left    : in Maps.Character_Set; 
                   Right   : in Maps.Character_Set; 
                   Justify : in Alignment := Strings.Left; 
                   Pad     : in Character := Space); 
   function  Head (Source : in String; 
                  Count  : in Natural; 
                  Pad    : in Character := Space) 
      return String; 
   procedure  Head (Source  : in out String; 
                   Count   : in Natural; 
                   Justify : in Alignment := Left; 
                   Pad     : in Character := Space); 
   function  Tail (Source : in String; 
                  Count  : in Natural; 
                  Pad    : in Character := Space) 
      return String; 
   procedure  Tail (Source  : in out String; 
                   Count   : in Natural; 
                   Justify : in Alignment := Left; 
                   Pad     : in Character := Space); 
--String constructor functions  
   function  "*" (Left  : in Natural; 
                 Right : in Character) return String; 
   function  "*" (Left  : in Natural; 
                 Right : in String) return String; 
end Ada.Strings.Fixed; 
The effects of the above s ubprograms are as follows.  
procedure  Move (Source  : in  String; 
                Target  : out String; 
                Drop    : in  Truncation := Error; 
                Justify : in  Alignment  := Left; 
                Pad     : in  Character  := Space); 
The Move procedure copies characters from Source to Target. If Source has the same length as 
Target, then the effect is to assign Source to Target. If Source is shorter than Target, then:  
• If Justify=Left, then Source is copied into  the first Source'Length characters of Target. 
• If Justify=Right, then Source is copied into the last Source'Length characters of 
Target. 
• If Justify=Center, then Source is copied into the middle Source'Length characters of 
Target. In this case, if the difference in length between Target and Source is odd, then 
the extra Pad character is on the right. 
• Pad is copied to each Target character not otherwise assigned.  31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 42 
43 
44 
45/3 
46 
47 
48 
49 
Ada Reference Manual — 2012 Edition 
379      13 December 2012 Fixe d-Length String Handling   A.4.3 If Source is longer than Target, then  the effect is based on Drop.  
• If Drop=Left, then the rightmost Target'Length characters of Source are copied into 
Target. 
• If Drop=Right, then the leftmost Target'Length characters of Source are copied into 
Target. 
• If Drop=Error, then the effect depends on th e value of the Justify parameter and also 
on whether any characters in Source other than Pad would fail to be copied:  
• If Justify=Left, and if each of the rightmost Source'Length-Target'Length 
characters in Source is Pad, then the le ftmost Target'Length characters of Source 
are copied to Target. 
• If Justify=Right, and if each of the leftmost Source'Length-Target'Length 
characters in Source is Pad, then the ri ghtmost Target'Length characters of Source 
are copied to Target. 
• Otherwise, Length_Error is propagated.  
function  Index (Source  : in String; 
                Pattern : in String; 
                From    : in Positive; 
                Going   : in Direction := Forward; 
                Mapping : in Maps.Character_Mapping := Maps.Identity) 
   return Natural; 
 function  Index (Source  : in String; 
                Pattern : in String; 
                From    : in Positive; 
                Going   : in Direction := Forward; 
                Mapping : in Maps.Character_Mapping_Function) 
   return Natural; 
Each Index function searches, starting from From, for a slice of Source, with length 
Pattern'Length, that matches Pattern with respect  to Mapping; the parameter Going indicates the 
direction of the lookup. If Source is the null string, Index returns 0; otherwise, if From is not in 
Source'Range, then Index_Error is propagated. If Going = Forward, then Index returns the 
smallest index I which is greater than or equal to From such that the slice of Source starting at I matches Pattern. If Going = Backward, then Index re turns the largest index I such that the slice 
of Source starting at I matches Pattern and ha s an upper bound less than or equal to From. If 
there is no such slice, then 0 is returned. If Pattern is the null string, then Pattern_Error is 
propagated. 
function  Index (Source   : in String; 
                Pattern  : in String; 
                Going    : in Direction := Forward; 
                Mapping  : in Maps.Character_Mapping 
                              := Maps.Identity)    return Natural; 
 function  Index (Source   : in String; 
                Pattern  : in String; 
                Going    : in Direction := Forward; 
                Mapping  : in Maps.Character_Mapping_Function) 
   return Natural; 
If Going = Forward, returns  
      Index (Source, Pattern, Source'First, Forward, Mapping); 
otherwise, returns  50 
51 
52 53 
54 
55 
56 
56.1/2 
56.2/3 
57 
58/2 
58.1/2 
58.2/3 
Ada Reference Manual — 2012 Edition 
A.4.3    Fixed-Length String Hand ling 13 December 2012      380       Index (Source, Pattern, Source'Last, Backward, Mapping); 
function  Index (Source  : in String; 
                Set     : in Maps.Character_Set; 
                From    : in Positive; 
                Test    : in Membership := Inside; 
                Going   : in Direction := Forward) 
   return Natural; 
Index searches for the first or last occurrence of any of a set of characters (when Test=Inside), or 
any of the complement of a set of characters (w hen Test=Outside). If Source is the null string, 
Index returns 0; otherwise, if From is not in Source'Range, then Index_Error is propagated. 
Otherwise, it returns the smallest index I >= From  (if Going=Forward) or the largest index I <= 
From (if Going=Backward) such that Source(I) satis fies the Test condition with respect to Set; it 
returns 0 if there is no such Character in Source. 
function  Index (Source : in String; 
                Set    : in Maps.Character_Set; 
                Test   : in Membership := Inside; 
                Going  : in Direction  := Forward) 
   return Natural; 
If Going = Forward, returns  
      Index (Source, Set, Source'First, Test, Forward); 
otherwise, returns  
      Index (Source, Set, Source'Last, Test, Backward); 
function  Index_Non_Blank (Source : in String; 
                          From   : in Positive; 
                          Going  : in Direction := Forward) 
   return Natural; 
Returns Index (Source, Maps.To_Set(Space), From, Outside, Going); 
function  Index_Non_Blank (Source : in String; 
                          Going  : in Direction := Forward) 
   return Natural; 
Returns Index(Source, Maps.To_Set(Space), Outside, Going) 
function  Count (Source   : in String; 
                Pattern  : in String; 
                Mapping  : in Maps.Character_Mapping 
                             := Maps.Identity)    return Natural; 
 function  Count (Source   : in String; 
                Pattern  : in String; 
                Mapping  : in Maps.Character_Mapping_Function) 
   return Natural; 
Returns the maximum number of  nonoverlapping slices of Source that match Pattern with 
respect to Mapping. If Pattern is the null string then Pattern_Error is propagated.  
function  Count (Source   : in String; 
                Set      : in Maps.Character_Set) 
   return Natural; 
Returns the number of occurrences in S ource of characters that are in Set. 58.3/2 
58.4/2 
58.5/3 
59 
60/2 
60.1/2 
60.2/3 
60.3/2 
60.4/2 
60.5/2 
61 
62 
63 
64 
65 
66 
Ada Reference Manual — 2012 Edition 
381      13 December 2012 Fixe d-Length String Handling   A.4.3 procedure  Find_Token (Source : in String; 
                      Set    : in Maps.Character_Set; 
                      From   : in Positive; 
                      Test   : in Membership; 
                      First  : out Positive; 
                      Last   : out Natural); 
If Source is not the null string and From is not  in Source'Range, then Index_Error is raised. 
Otherwise, First is set to the index of the first character in Source(From .. Source'Last) that satisfies the Test condition. Last is set to the la rgest index such that all characters in Source(First 
.. Last) satisfy the Test condition. If no characters in Source(From .. Source'Last) satisfy the Test condition, First is set to From, and Last is set to 0. 
procedure  Find_Token (Source : in String; 
                      Set    : in Maps.Character_Set; 
                      Test   : in Membership; 
                      First  : out Positive; 
                      Last   : out Natural); 
Equivalent to Find_Token (Source, Set, Source'First, Test, First, Last). 
function  Translate (Source  : in String; 
                    Mapping : in Maps.Character_Mapping) 
   return String; 
 function  Translate (Source  : in String; 
                    Mapping : in Maps.Character_Mapping_Function) 
   return String; 
Returns the string S whose length is Source'Length and such that S(I) is the character to which 
Mapping maps the corresponding element of  Source, for I in 1..Source'Length. 
procedure  Translate (Source  : in out String; 
                     Mapping : in Maps.Character_Mapping); 
 procedure  Translate (Source  : in out String; 
                     Mapping : in Maps.Character_Mapping_Function); 
Equivalent to Source := Translate(Source, Mapping). 
function  Replace_Slice (Source   : in String; 
                        Low      : in Positive; 
                        High     : in Natural; 
                        By       : in String) 
   return String; 
If Low > Source'Last+1, or High < Source'First–1,  then Index_Error is propagated. Otherwise: 
• If High >= Low, then the returned string comprises Source(Source'First..Low–1) & By 
& Source(High+1..Source'Last), but with lower bound 1. 
• If High < Low, then the returned string is Insert(Source, Before=>Low, 
New_Item=>By).  
procedure  Replace_Slice (Source   : in out String; 
                         Low      : in Positive; 
                         High     : in Natural; 
                         By       : in String; 
                         Drop     : in Truncation := Error; 
                         Justify  : in Alignment  := Left; 
                         Pad      : in Character  := Space); 
Equivalent to Move(Replace_Slice(Source, Low, High, By), Source, Drop, Justify, Pad). 66.1/3 
66.2/3 
67 
68/3 
69 
70 
71 
72 
73 
74/1 
74.1/1 
74.2/1 
75 
76 
Ada Reference Manual — 2012 Edition 
A.4.3    Fixed-Length String Hand ling 13 December 2012      382 function  Insert (Source   : in String; 
                 Before   : in Positive; 
                 New_Item : in String) 
   return String; 
Propagates Index_Error if Before is not in S ource'First .. Source'Last+1; otherwise, returns 
Source(Source'First..Before–1) & New_Item & Source(Before..Source'Last), but with lower 
bound 1. 
procedure  Insert (Source   : in out String; 
                  Before   : in Positive; 
                  New_Item : in String; 
                  Drop     : in Truncation := Error); 
Equivalent to Move(Insert(Source, Before, New_Item), Source, Drop). 
function  Overwrite (Source   : in String; 
                    Position : in Positive; 
                    New_Item : in String) 
   return String; 
Propagates Index_Error if Position is not in Sour ce'First .. Source'Last+1; otherwise, returns the 
string obtained from Source by consecutively re placing characters starting at Position with 
corresponding characters from New_Item. If the end of Source is reached before the characters 
in New_Item are exhausted, the remaining char acters from New_Item are appended to the string. 
procedure  Overwrite (Source   : in out String; 
                     Position : in Positive; 
                     New_Item : in String; 
                     Drop     : in Truncation := Right); 
Equivalent to Move(Overwrite(Source, Position, New_Item), Source, Drop). 
function  Delete (Source  : in String; 
                 From    : in Positive; 
                 Through : in Natural) 
   return String; 
If From <= Through, the returned string is  Replace_Slice(Source, From, Through, ""); 
otherwise, it is Source with lower bound 1. 
procedure  Delete (Source  : in out String; 
                  From    : in Positive; 
                  Through : in Natural; 
                  Justify : in Alignment := Left; 
                  Pad     : in Character := Space); 
Equivalent to Move(Delete(S ource, From, Through), Source, Ju stify => Justify, Pad => Pad). 
function  Trim (Source : in String; 
               Side   : in Trim_End) 
  return String; 
Returns the string obtained by removing from Source all leading Space characters (if Side = 
Left), all trailing Space characters (if Side = Right), or all leading and trailing Space characters (if Side = Both). 
procedure  Trim (Source  : in out String; 
                Side    : in Trim_End; 
                Justify : in Alignment := Left; 
                Pad     : in Character := Space); 
Equivalent to Move(Trim(Source, Side),  Source, Justify=>J ustify, Pad=>Pad). 77 
78/3 
79 
80 
81 
82/3 
83 
84 
85 
86/3 
87 
88 
89 
90 
91 
92 
Ada Reference Manual — 2012 Edition 
383      13 December 2012 Fixe d-Length String Handling   A.4.3 function  Trim (Source : in String; 
               Left   : in Maps.Character_Set; 
               Right  : in Maps.Character_Set) 
   return String; 
Returns the string obtained by removing from S ource all leading characters in Left and all 
trailing characters in Right. 
procedure  Trim (Source  : in out String; 
                Left    : in Maps.Character_Set; 
                Right   : in Maps.Character_Set; 
                Justify : in Alignment := Strings.Left; 
                Pad     : in Character := Space); 
Equivalent to Move(Trim(Source, Left, Right ), Source, Justify => Justify, Pad=>Pad). 
function  Head (Source : in String; 
               Count  : in Natural; 
               Pad    : in Character := Space) 
   return String; 
Returns a string of length Count. If Count <= Sour ce'Length, the string comprises the first Count 
characters of Source. Otherwise,  its contents are Source concat enated with Count–Source'Length 
Pad characters. 
procedure  Head (Source  : in out String; 
                Count   : in Natural; 
                Justify : in Alignment := Left; 
                Pad     : in Character := Space); 
Equivalent to Move(Head(Source, Count, Pad) , Source, Drop=>Error, Justify=>Justify, 
Pad=>Pad). 
function  Tail (Source : in String; 
               Count  : in Natural; 
               Pad    : in Character := Space) 
   return String; 
Returns a string of length Count. If Count <= Sour ce'Length, the string comprises the last Count 
characters of Source. Otherwise, its cont ents are Count-Source'Length Pad characters 
concatenated with Source. 
procedure  Tail (Source  : in out String; 
                Count   : in Natural; 
                Justify : in Alignment := Left; 
                Pad     : in Character := Space); 
Equivalent to Move(Tail(Source, Count, Pa d), Source, Drop=>Error, Justify=>Justify, 
Pad=>Pad). 
function  "*" (Left  : in Natural; 
              Right : in Character) return String; 
 function  "*" (Left  : in Natural; 
              Right : in String) return String; 
These functions replicate a character or string a specified number of times. The first function 
returns a string whose length is Left and each of  whose elements is Right. The second function 
returns a string whose length is Left*Right'Length and whose value is the null string if Left = 0 
and otherwise is (Left–1)*Right & Right with lower bound 1.  93 
94 
95 
96 
97 
98/3 
99 
100 
101 
102/3 
103 
104 
105 
106/1 
Ada Reference Manual — 2012 Edition 
A.4.3    Fixed-Length String Hand ling 13 December 2012      384 NOTES 
12  In the Index and Count functions taking Pattern and Mapping parameters, the actual String parameter passed to Pattern should comprise characters occurring as target characters of the mapping. Otherwise, the pattern will not match. 
13  In the Insert subprograms, inserting at the end of a string is obtained by passing Source'Last+1 as the Before 
parameter. 
14  If a null Character_Mapping_Function is passed to any of the string handling subprograms, Constraint_Error is 
propagated.  
A.4.4 Bounded-Length String Handling 
The language-defined package Strings.Bounded provides a generic package each of whose instances yields 
a private type Bounded_String and a set of operations . An object of a particular Bounded_String type 
represents a String whose low bound is 1 and whose length can vary conceptually between 0 and a 
maximum size established at the generic instantiati on. The subprograms for fixed-length string handling 
are either overloaded directly for Bounded_String, or ar e modified as needed to reflect the variability in 
length. Additionally, since the Bounded_String type is  private, appropriate constructor and selector 
operations are provided.  
Static Semantics 
The library package Strings.Bounded has the following declaration:  
with Ada.Strings.Maps; 
package Ada.Strings.Bounded is 
   pragma Preelaborate(Bounded); 
   generic 
      Max   : Positive;    --  Maximum length of a Bounded_String  
   package Generic_Bounded_Length is 
      Max_Length : constant  Positive := Max; 
      type Bounded_String is private; 
      Null_Bounded_String : constant  Bounded_String; 
      subtype Length_Range is Natural range 0 .. Max_Length; 
      function  Length (Source : in Bounded_String) return Length_Range; 
   --  Conversion, Concatenati on, and Selection functions  
      function  To_Bounded_String (Source : in String; 
                                  Drop   : in Truncation := Error) 
         return Bounded_String; 
      function  To_String (Source : in Bounded_String) return String; 
      procedure  Set_Bounded_String 
         (Target :    out Bounded_String; 
          Source : in     String; 
          Drop   : in     Truncation := Error); 
      function  Append (Left, Right : in Bounded_String; 
                       Drop        : in Truncation  := Error) 
         return Bounded_String; 
      function  Append (Left  : in Bounded_String; 
                       Right : in String; 
                       Drop  : in Truncation := Error) 
         return Bounded_String; 
      function  Append (Left  : in String; 
                       Right : in Bounded_String; 
                       Drop  : in Truncation := Error) 
         return Bounded_String; 107/3 
108 109 
1 
2 
3 
4 5 
6 7 8 9 
10 11 
12 
12.1/2 
13 
14 
15 
Ada Reference Manual — 2012 Edition 
385      13 December 2012 Bounded-Length String Handling   A.4.4       function  Append (Left  : in Bounded_String; 
                       Right : in Character; 
                       Drop  : in Truncation := Error) 
         return Bounded_String; 
      function  Append (Left  : in Character; 
                       Right : in Bounded_String; 
                       Drop  : in Truncation := Error) 
         return Bounded_String; 
      procedure  Append (Source   : in out Bounded_String; 
                        New_Item : in Bounded_String; 
                        Drop     : in Truncation  := Error); 
      procedure  Append (Source   : in out Bounded_String; 
                        New_Item : in String; 
                        Drop     : in Truncation  := Error); 
      procedure  Append (Source   : in out Bounded_String; 
                        New_Item : in Character; 
                        Drop     : in Truncation  := Error); 
      function  "&" (Left, Right : in Bounded_String) 
         return Bounded_String; 
      function  "&" (Left : in Bounded_String; Right : in String) 
         return Bounded_String; 
      function  "&" (Left : in String; Right : in Bounded_String) 
         return Bounded_String; 
      function  "&" (Left : in Bounded_String; Right : in Character) 
         return Bounded_String; 
      function  "&" (Left : in Character; Right : in Bounded_String) 
         return Bounded_String; 
      function  Element (Source : in Bounded_String; 
                        Index  : in Positive) 
         return Character; 
      procedure  Replace_Element (Source : in out Bounded_String; 
                                 Index  : in Positive; 
                                 By     : in Character); 
      function  Slice (Source : in Bounded_String; 
                      Low    : in Positive; 
                      High   : in Natural) 
         return String; 
      function  Bounded_Slice 
         (Source : in Bounded_String; 
          Low    : in Positive; 
          High   : in Natural) 
             return Bounded_String; 
      procedure  Bounded_Slice 
         (Source : in     Bounded_String; 
          Target :    out Bounded_String; 
          Low    : in     Positive; 
          High   : in     Natural); 
      function  "="  (Left, Right : in Bounded_String) return Boolean; 
      function  "="  (Left : in Bounded_String; Right : in String) 
        return Boolean; 
      function  "="  (Left : in String; Right : in Bounded_String) 
        return Boolean; 
      function  "<"  (Left, Right : in Bounded_String) return Boolean; 
      function  "<"  (Left : in Bounded_String; Right : in String) 
        return Boolean; 
      function  "<"  (Left : in String; Right : in Bounded_String) 
        return Boolean; 16 
17 
18 
19 20 21 
22 23 24 25 26 
27 28 
28.1/2 
28.2/2 
29 
30 
31 
32 
33 
Ada Reference Manual — 2012 Edition 
A.4.4    Bounded-Length String Hand ling 13 December 2012      386       function  "<=" (Left, Right : in Bounded_String) return Boolean; 
      function  "<="  (Left : in Bounded_String; Right : in String) 
        return Boolean; 
      function  "<="  (Left : in String; Right : in Bounded_String) 
        return Boolean; 
      function  ">"  (Left, Right : in Bounded_String) return Boolean; 
      function  ">"  (Left : in Bounded_String; Right : in String) 
        return Boolean; 
      function  ">"  (Left : in String; Right : in Bounded_String) 
        return Boolean; 
      function  ">=" (Left, Right : in Bounded_String) return Boolean; 
      function  ">="  (Left : in Bounded_String; Right : in String) 
        return Boolean; 
      function  ">="  (Left : in String; Right : in Bounded_String) 
        return Boolean; 
   --  Search subprograms  
      function  Index (Source  : in Bounded_String; 
                      Pattern : in String; 
                      From    : in Positive; 
                      Going   : in Direction := Forward; 
                      Mapping : in Maps.Character_Mapping := Maps.Identity) 
         return Natural; 
      function  Index (Source  : in Bounded_String; 
                      Pattern : in String; 
                      From    : in Positive; 
                      Going   : in Direction := Forward; 
                      Mapping : in Maps.Character_Mapping_Function) 
         return Natural; 
      function  Index (Source   : in Bounded_String; 
                      Pattern  : in String; 
                      Going    : in Direction := Forward; 
                      Mapping  : in Maps.Character_Mapping 
                                 := Maps.Identity)          return Natural; 
      function  Index (Source   : in Bounded_String; 
                      Pattern  : in String; 
                      Going    : in Direction := Forward; 
                      Mapping  : in Maps.Character_Mapping_Function) 
         return Natural; 
      function  Index (Source  : in Bounded_String; 
                      Set     : in Maps.Character_Set; 
                      From    : in Positive; 
                      Test    : in Membership := Inside; 
                      Going   : in Direction := Forward) 
         return Natural; 
      function  Index (Source : in Bounded_String; 
                      Set    : in Maps.Character_Set; 
                      Test   : in Membership := Inside; 
                      Going  : in Direction  := Forward) 
         return Natural; 
      function  Index_Non_Blank (Source : in Bounded_String; 
                                From   : in Positive; 
                                Going  : in Direction := Forward) 
         return Natural; 
      function  Index_Non_Blank (Source : in Bounded_String; 
                                Going  : in Direction := Forward) 
         return Natural; 34 
35 
36 37 
38 
39 40 
41 
42 
43/2 
43.1/2 
43.2/2 
44 
45 
45.1/2 
46 
46.1/2 
47 
Ada Reference Manual — 2012 Edition 
387      13 December 2012 Bounded-Length String Handling   A.4.4       function  Count (Source   : in Bounded_String; 
                      Pattern  : in String; 
                      Mapping  : in Maps.Character_Mapping 
                                   := Maps.Identity)          return Natural; 
      function  Count (Source   : in Bounded_String; 
                      Pattern  : in String; 
                      Mapping  : in Maps.Character_Mapping_Function) 
         return Natural; 
      function  Count (Source   : in Bounded_String; 
                      Set      : in Maps.Character_Set) 
         return Natural; 
      procedure  Find_Token (Source : in Bounded_String; 
                            Set    : in Maps.Character_Set; 
                            From   : in Positive; 
                            Test   : in Membership; 
                            First  : out Positive; 
                            Last   : out Natural); 
      procedure  Find_Token (Source : in Bounded_String; 
                            Set    : in Maps.Character_Set; 
                            Test   : in Membership; 
                            First  : out Positive; 
                            Last   : out Natural); 
   --  String translation subprograms  
      function  Translate (Source  : in Bounded_String; 
                          Mapping : in Maps.Character_Mapping) 
         return Bounded_String; 
      procedure  Translate (Source  : in out Bounded_String; 
                           Mapping : in Maps.Character_Mapping); 
      function  Translate (Source  : in Bounded_String; 
                          Mapping : in Maps.Character_Mapping_Function) 
         return Bounded_String; 
      procedure  Translate (Source  : in out Bounded_String; 
                           Mapping : in Maps.Character_Mapping_Function); 
   --  String transformation subprograms  
      function  Replace_Slice (Source   : in Bounded_String; 
                              Low      : in Positive; 
                              High     : in Natural; 
                              By       : in String; 
                              Drop     : in Truncation := Error) 
         return Bounded_String; 
      procedure  Replace_Slice (Source   : in out Bounded_String; 
                               Low      : in Positive; 
                               High     : in Natural; 
                               By       : in String; 
                               Drop     : in Truncation := Error); 
      function  Insert (Source   : in Bounded_String; 
                       Before   : in Positive; 
                       New_Item : in String; 
                       Drop     : in Truncation := Error) 
         return Bounded_String; 
      procedure  Insert (Source   : in out Bounded_String; 
                        Before   : in Positive; 
                        New_Item : in String; 
                        Drop     : in Truncation := Error); 
      function  Overwrite (Source    : in Bounded_String; 
                          Position  : in Positive; 
                          New_Item  : in String; 
                          Drop      : in Truncation := Error) 
         return Bounded_String; 48 
49 
50 
50.1/3 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
Ada Reference Manual — 2012 Edition 
A.4.4    Bounded-Length String Hand ling 13 December 2012      388       procedure  Overwrite (Source    : in out Bounded_String; 
                           Position  : in Positive; 
                           New_Item  : in String; 
                           Drop      : in Truncation := Error); 
      function  Delete (Source  : in Bounded_String; 
                       From    : in Positive; 
                       Through : in Natural) 
         return Bounded_String; 
      procedure  Delete (Source  : in out Bounded_String; 
                        From    : in Positive; 
                        Through : in Natural); 
   -- String selector subprograms  
      function  Trim (Source : in Bounded_String; 
                     Side   : in Trim_End) 
         return Bounded_String; 
      procedure  Trim (Source : in out Bounded_String; 
                      Side   : in Trim_End); 
      function  Trim (Source : in Bounded_String; 
                     Left   : in Maps.Character_Set; 
                     Right  : in Maps.Character_Set) 
         return Bounded_String; 
      procedure  Trim (Source : in out Bounded_String; 
                      Left   : in Maps.Character_Set; 
                      Right  : in Maps.Character_Set); 
      function  Head (Source : in Bounded_String; 
                     Count  : in Natural; 
                     Pad    : in Character  := Space; 
                     Drop   : in Truncation := Error) 
         return Bounded_String; 
      procedure  Head (Source : in out Bounded_String; 
                      Count  : in Natural; 
                      Pad    : in Character  := Space; 
                      Drop   : in Truncation := Error); 
      function  Tail (Source : in Bounded_String; 
                     Count  : in Natural; 
                     Pad    : in Character  := Space; 
                     Drop   : in Truncation := Error) 
         return Bounded_String; 
      procedure  Tail (Source : in out Bounded_String; 
                      Count  : in Natural; 
                      Pad    : in Character  := Space; 
                      Drop   : in Truncation := Error); 
   -- String constructor subprograms  
      function  "*" (Left  : in Natural; 
                    Right : in Character) 
         return Bounded_String; 
      function  "*" (Left  : in Natural; 
                    Right : in String) 
         return Bounded_String; 
      function  "*" (Left  : in Natural; 
                    Right : in Bounded_String) 
         return Bounded_String; 
      function  Replicate (Count : in Natural; 
                          Item  : in Character; 
                          Drop  : in Truncation := Error) 
         return Bounded_String; 63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 77 78 
Ada Reference Manual — 2012 Edition 
389      13 December 2012 Bounded-Length String Handling   A.4.4       function  Replicate (Count : in Natural; 
                          Item  : in String; 
                          Drop  : in Truncation := Error) 
         return Bounded_String; 
      function  Replicate (Count : in Natural; 
                          Item  : in Bounded_String; 
                          Drop  : in Truncation := Error) 
         return Bounded_String; 
   private 
       ... -- not specified by the language  
   end Generic_Bounded_Length; 
end Ada.Strings.Bounded; 
Null_Bounded_String represents the null string. If an  object of type Bounded_String is not otherwise 
initialized, it will be initialized to the same value as Null_Bounded_String.  
function  Length (Source : in Bounded_String) return Length_Range; 
The Length function returns the length of the string represented by Source. 
function  To_Bounded_String (Source : in String; 
                            Drop   : in Truncation := Error) 
   return Bounded_String; 
If Source'Length <= Max_Length, then this func tion returns a Bounded_String that represents 
Source. Otherwise, the effect depends on the value of Drop:  
• If Drop=Left, then the result is a Bounded_Str ing that represents the string comprising 
the rightmost Max_Length characters of Source. 
• If Drop=Right, then the result is a B ounded_String that represents the string 
comprising the leftmost Max_Length characters of Source. 
• If Drop=Error, then Strings.L ength_Error is propagated.  
function  To_String (Source : in Bounded_String) return String; 
To_String returns the String value with lo wer bound 1 represented by Source. If B is a 
Bounded_String, then B = To_Bounded_String(To_String(B)). 
procedure  Set_Bounded_String 
   (Target :    out Bounded_String; 
    Source : in     String; 
    Drop   : in     Truncation := Error); 
Equivalent to Target := To_Bounded_String (Source, Drop); 
Each of the Append functions returns a Bounded_String obtained by concatenating the string or character 
given or represented by one of the parameters, with the string or character given or represented by the 
other parameter, and applying T o_Bounded_String to the concatenation result string, with Drop as 
provided to the Append function. 
Each of the procedures Append(Source, New_Item , Drop) has the same effect as the corresponding 
assignment Source := Append( Source, New_Item, Drop). 
Each of the "&" functions has the same effect as  the corresponding Append function, with Error as the 
Drop parameter.  79 
80 
81 
82 
83 
84 
85 
86 
87/3 
88 
89 90 
91 
92 
92.1/2 
92.2/2 
93 
94 
95 
Ada Reference Manual — 2012 Edition 
A.4.4    Bounded-Length String Hand ling 13 December 2012      390 function  Element (Source : in Bounded_String; 
                  Index  : in Positive) 
   return Character; 
Returns the character at position Index in th e string represented by Source; propagates 
Index_Error if Index > Length(Source). 
procedure  Replace_Element (Source : in out Bounded_String; 
                           Index  : in Positive; 
                           By     : in Character); 
Updates Source such that the character at positi on Index in the string represented by Source is 
By; propagates Index_Error if Index > Length(Source). 
function  Slice (Source : in Bounded_String; 
                Low    : in Positive; 
                High   : in Natural) 
   return String; 
Returns the slice at positions Low through High in  the string represented by Source; propagates 
Index_Error if Low > Length(Source)+1 or High > Length(Source). The bounds of the returned 
string are Low and High.. 
function  Bounded_Slice 
   (Source : in Bounded_String; 
    Low    : in Positive; 
    High   : in Natural) 
       return Bounded_String; 
Returns the slice at positions Low through High in  the string represented by Source as a bounded 
string; propagates Index_Error if Low > Le ngth(Source)+1 or High > Length(Source). 
procedure  Bounded_Slice 
   (Source : in     Bounded_String; 
    Target :    out Bounded_String; 
    Low    : in     Positive; 
    High   : in     Natural); 
Equivalent to Target := Bounded_Slice (Source, Low, High); 
Each of the functions "=", "<", ">", "<=", and " >=" returns the same result as the corresponding String 
operation applied to the String values give n or represented by the two parameters. 
Each of the search subprograms (Index, Index_Non_Bla nk, Count, Find_Token) has the same effect as the 
corresponding subprogram in Strings.Fixed applied to the string represented by the Bounded_String 
parameter. 
Each of the Translate subprograms, when applied to  a Bounded_String, has an analogous effect to the 
corresponding subprogram in Strings.Fixed. For the Transl ate function, the translation is applied to the 
string represented by the Bounded_Str ing parameter, and the result is converted (via To_Bounded_String) 
to a Bounded_String. For the Translate procedure, th e string represented by the Bounded_String parameter 
after the translation is given by the Translate f unction for fixed-length strings applied to the string 
represented by the original value of the parameter. 
Each of the transformation subprograms (Replace_Slice,  Insert, Overwrite, Delete), selector subprograms 
(Trim, Head, Tail), and constructor functions ("*") has an effect based on its corresponding subprogram in 
Strings.Fixed, and Replicate is based on Fixed."*".  In the case of a function, the corresponding fixed-
length string subprogram is applied to the stri ng represented by the Bounded_String parameter. 
To_Bounded_String is applied the result stri ng, with Drop (or Error in the case of 
Generic_Bounded_Length."*") determin ing the effect when the string length exceeds Max_Length. In the 96 
97 
98 
99 
100 
101/1 
101.1/2 
101.2/2 
101.3/2 
101.4/2 
102 
103 
104 
105/1 
Ada Reference Manual — 2012 Edition 
391      13 December 2012 Bounded-Length String Handling   A.4.4 case of a procedure, the corresponding function in Strings.Bounded.Generic_Bounde d_Length is applied, 
with the result assigned into the Source parameter.  
Implementation Advice 
Bounded string objects should not be implemented by  implicit pointers and dynamic allocation.  
A.4.5 Unbounded-Length String Handling 
The language-defined package Strings.Unbounded provide s a private type Unbounded_String and a set of 
operations. An object of type Unbounded_String repr esents a String whose low bound is 1 and whose 
length can vary conceptually between 0 and Natu ral'Last. The subprograms for fixed-length string 
handling are either overloaded directly for Unbounded_Str ing, or are modified as needed to reflect the 
flexibility in length. Since the Unbounded_String type is private, relevant constructor and selector 
operations are provided.  
Static Semantics 
The library package Strings.Unbounded has the following declaration:  
with Ada.Strings.Maps; 
package Ada.Strings.Unbounded is 
   pragma Preelaborate(Unbounded); 
   type Unbounded_String is private; 
   pragma Preelaborable_Initialization(Unbounded_String); 
   Null_Unbounded_String : constant  Unbounded_String; 
   function  Length (Source : in Unbounded_String) return Natural; 
   type String_Access is access all String; 
   procedure  Free (X : in out String_Access); 
-- Conversion, Concatenati on, and Selection functions  
   function  To_Unbounded_String (Source : in String) 
      return Unbounded_String; 
   function  To_Unbounded_String (Length : in Natural) 
      return Unbounded_String; 
   function  To_String (Source : in Unbounded_String) return String; 
   procedure  Set_Unbounded_String 
     (Target :    out Unbounded_String; 
      Source : in     String); 
   procedure  Append (Source   : in out Unbounded_String; 
                     New_Item : in Unbounded_String); 
   procedure  Append (Source   : in out Unbounded_String; 
                     New_Item : in String); 
   procedure  Append (Source   : in out Unbounded_String; 
                     New_Item : in Character); 
   function  "&" (Left, Right : in Unbounded_String) 
      return Unbounded_String; 
   function  "&" (Left : in Unbounded_String; Right : in String) 
      return Unbounded_String; 
   function  "&" (Left : in String; Right : in Unbounded_String) 
      return Unbounded_String; 
   function  "&" (Left : in Unbounded_String; Right : in Character) 
      return Unbounded_String; 
   function  "&" (Left : in Character; Right : in Unbounded_String) 
      return Unbounded_String; 106 
1 
2 
3 
4/2 
5 
6 7 
8 
9 
10 11 
11.1/2 
12 
13 14 15 16 17 18 19 
Ada Reference Manual — 2012 Edition 
A.4.5    Unbounded-Length String Hand ling 13 December 2012      392    function  Element (Source : in Unbounded_String; 
                     Index  : in Positive) 
      return Character; 
   procedure  Replace_Element (Source : in out Unbounded_String; 
                              Index  : in Positive; 
                              By     : in Character); 
   function  Slice (Source : in Unbounded_String; 
                   Low    : in Positive; 
                   High   : in Natural) 
      return String; 
   function  Unbounded_Slice 
      (Source : in Unbounded_String; 
       Low    : in Positive; 
       High   : in Natural) 
          return Unbounded_String; 
   procedure  Unbounded_Slice 
      (Source : in     Unbounded_String; 
       Target :    out Unbounded_String; 
       Low    : in     Positive; 
       High   : in     Natural); 
   function  "="  (Left, Right : in Unbounded_String) return Boolean; 
   function  "="  (Left : in Unbounded_String; Right : in String) 
     return Boolean; 
   function  "="  (Left : in String; Right : in Unbounded_String) 
     return Boolean; 
   function  "<"  (Left, Right : in Unbounded_String) return Boolean; 
   function  "<"  (Left : in Unbounded_String; Right : in String) 
     return Boolean; 
   function  "<"  (Left : in String; Right : in Unbounded_String) 
     return Boolean; 
   function  "<=" (Left, Right : in Unbounded_String) return Boolean; 
   function  "<="  (Left : in Unbounded_String; Right : in String) 
     return Boolean; 
   function  "<="  (Left : in String; Right : in Unbounded_String) 
     return Boolean; 
   function  ">"  (Left, Right : in Unbounded_String) return Boolean; 
   function  ">"  (Left : in Unbounded_String; Right : in String) 
     return Boolean; 
   function  ">"  (Left : in String; Right : in Unbounded_String) 
     return Boolean; 
   function  ">=" (Left, Right : in Unbounded_String) return Boolean; 
   function  ">="  (Left : in Unbounded_String; Right : in String) 
     return Boolean; 
   function  ">="  (Left : in String; Right : in Unbounded_String) 
     return Boolean; 
-- Search subprograms  
   function  Index (Source  : in Unbounded_String; 
                   Pattern : in String; 
                   From    : in Positive; 
                   Going   : in Direction := Forward; 
                   Mapping : in Maps.Character_Mapping := Maps.Identity) 
      return Natural; 20 
21 22 
22.1/2 
22.2/2 
23 
24 
25 26 
27 
28 29 
30 
31 32 
33 
34 35 
36 
37 38 
38.1/2 
Ada Reference Manual — 2012 Edition 
393      13 December 2012 Unbounded-Length String Handling   A.4.5    function  Index (Source  : in Unbounded_String; 
                   Pattern : in String; 
                   From    : in Positive; 
                   Going   : in Direction := Forward; 
                   Mapping : in Maps.Character_Mapping_Function) 
      return Natural; 
   function  Index (Source   : in Unbounded_String; 
                   Pattern  : in String; 
                   Going    : in Direction := Forward; 
                   Mapping  : in Maps.Character_Mapping 
                                := Maps.Identity)       return Natural; 
   function  Index (Source   : in Unbounded_String; 
                   Pattern  : in String; 
                   Going    : in Direction := Forward; 
                   Mapping  : in Maps.Character_Mapping_Function) 
      return Natural; 
   function  Index (Source  : in Unbounded_String; 
                   Set     : in Maps.Character_Set; 
                   From    : in Positive; 
                   Test    : in Membership := Inside; 
                   Going    : in Direction := Forward) 
      return Natural; 
   function  Index (Source : in Unbounded_String; 
                   Set    : in Maps.Character_Set; 
                   Test   : in Membership := Inside; 
                   Going  : in Direction  := Forward) return Natural; 
   function  Index_Non_Blank (Source : in Unbounded_String; 
                             From   : in Positive; 
                             Going  : in Direction := Forward) 
      return Natural; 
   function  Index_Non_Blank (Source : in Unbounded_String; 
                             Going  : in Direction := Forward) 
      return Natural; 
   function  Count (Source   : in Unbounded_String; 
                   Pattern  : in String; 
                   Mapping  : in Maps.Character_Mapping 
                                := Maps.Identity)       return Natural; 
   function  Count (Source   : in Unbounded_String; 
                   Pattern  : in String; 
                   Mapping  : in Maps.Character_Mapping_Function) 
      return Natural; 
   function  Count (Source   : in Unbounded_String; 
                   Set      : in Maps.Character_Set) 
      return Natural; 
   procedure  Find_Token (Source : in Unbounded_String; 
                         Set    : in Maps.Character_Set; 
                         From   : in Positive; 
                         Test   : in Membership; 
                         First  : out Positive; 
                         Last   : out Natural); 
   procedure  Find_Token (Source : in Unbounded_String; 
                         Set    : in Maps.Character_Set; 
                         Test   : in Membership; 
                         First  : out Positive; 
                         Last   : out Natural); 
-- String translation subprograms  
   function  Translate (Source  : in Unbounded_String; 
                       Mapping : in Maps.Character_Mapping) 
      return Unbounded_String; 38.2/2 
39 
40 
40.1/2 
41 
41.1/2 
42 
43 
44 
45 
45.1/3 
46 
47 
48 
Ada Reference Manual — 2012 Edition 
A.4.5    Unbounded-Length String Hand ling 13 December 2012      394    procedure  Translate (Source  : in out Unbounded_String; 
                        Mapping : in Maps.Character_Mapping); 
   function  Translate (Source  : in Unbounded_String; 
                       Mapping : in Maps.Character_Mapping_Function) 
      return Unbounded_String; 
   procedure  Translate (Source  : in out Unbounded_String; 
                        Mapping : in Maps.Character_Mapping_Function); 
-- String transformation subprograms  
   function  Replace_Slice (Source   : in Unbounded_String; 
                           Low      : in Positive; 
                           High     : in Natural; 
                           By       : in String) 
      return Unbounded_String; 
   procedure  Replace_Slice (Source   : in out Unbounded_String; 
                            Low      : in Positive; 
                            High     : in Natural; 
                            By       : in String); 
   function  Insert (Source   : in Unbounded_String; 
                    Before   : in Positive; 
                    New_Item : in String) 
      return Unbounded_String; 
   procedure  Insert (Source   : in out Unbounded_String; 
                     Before   : in Positive; 
                     New_Item : in String); 
   function  Overwrite (Source    : in Unbounded_String; 
                       Position  : in Positive; 
                       New_Item  : in String) 
      return Unbounded_String; 
   procedure  Overwrite (Source    : in out Unbounded_String; 
                        Position  : in Positive; 
                        New_Item  : in String); 
   function  Delete (Source  : in Unbounded_String; 
                    From    : in Positive; 
                    Through : in Natural) 
      return Unbounded_String; 
   procedure  Delete (Source  : in out Unbounded_String; 
                     From    : in Positive; 
                     Through : in Natural); 
   function  Trim (Source : in Unbounded_String; 
                  Side   : in Trim_End) 
      return Unbounded_String; 
   procedure  Trim (Source : in out Unbounded_String; 
                   Side   : in Trim_End); 
   function  Trim (Source : in Unbounded_String; 
                  Left   : in Maps.Character_Set; 
                  Right  : in Maps.Character_Set) 
      return Unbounded_String; 
   procedure  Trim (Source : in out Unbounded_String; 
                   Left   : in Maps.Character_Set; 
                   Right  : in Maps.Character_Set); 
   function  Head (Source : in Unbounded_String; 
                  Count  : in Natural; 
                  Pad    : in Character := Space) 
      return Unbounded_String; 
   procedure  Head (Source : in out Unbounded_String; 
                   Count  : in Natural; 
                   Pad    : in Character := Space); 49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 62 
63 
64 
65 
66 
Ada Reference Manual — 2012 Edition 
395      13 December 2012 Unbounded-Length String Handling   A.4.5    function  Tail (Source : in Unbounded_String; 
                  Count  : in Natural; 
                  Pad    : in Character := Space) 
      return Unbounded_String; 
   procedure  Tail (Source : in out Unbounded_String; 
                   Count  : in Natural; 
                   Pad    : in Character := Space); 
   function  "*" (Left  : in Natural; 
                 Right : in Character) 
      return Unbounded_String; 
   function  "*" (Left  : in Natural; 
                 Right : in String) 
      return Unbounded_String; 
   function  "*" (Left  : in Natural; 
                 Right : in Unbounded_String) 
      return Unbounded_String; 
private 
   ... -- not specified by the language  
end Ada.Strings.Unbounded; 
The type Unbounded_String needs finalization (see 7.6). 
Null_Unbounded_String represents the null String. If an  object of type Unbounded_String is not otherwise 
initialized, it will be initialized to th e same value as Null_Unbounded_String. 
The function Length returns the length of the String represented by Source. The type String_Access provides a (nonprivate) acce ss type for explicit processing of unbounded-length 
strings. The procedure Free performs an unchecked deallocation of an object of type String_Access. 
The function To_Unbounded_String(Source : in String)  returns an Unbounded_String that represents 
Source. The function To_Unbounded_String(Length : in  Natural) returns an Unbounded_String that 
represents an uninitialized St ring whose length is Length. 
The function To_String returns the String with lo wer bound 1 represented by Source. To_String and 
To_Unbounded_String are related as follows:  
• If S is a String, then To_String(To_Unbounded_String(S)) = S. 
• If U is an Unbounded_String, then T o_Unbounded_String(To_String(U)) = U.  
The procedure Set_Unbounded_String sets Target to  an Unbounded_String that  represents Source. 
For each of the Append procedures, the resulting string represented by the Source parameter is given by 
the concatenation of the original valu e of Source and the value of New_Item. 
Each of the "&" functions returns an Unbounded_String obtained by concatenating the string or character 
given or represented by one of the parameters, with the string or character given or represented by the 
other parameter, and applyi ng To_Unbounded_String to the concatenation result string. 
The Element, Replace_Element, and Slice subprogr ams have the same effect as the corresponding 
bounded-length string subprograms. 
The function Unbounded_Slice returns the slice at positi ons Low through High in the string represented by 
Source as an Unbounded_String. The procedure U nbounded_Slice sets Target to the Unbounded_String 
representing the slice at positions Low through Hi gh in the string represented by Source. Both 
subprograms propagate Index_Error if Low > Length(Source)+1 or High > Length(Source). 67 
68 
69 70 71 72 
72.1/2 
73 
74 
75 
76 
77 
78 
79 
79.1/2 
80 
81 
82 
82.1/3 
Ada Reference Manual — 2012 Edition 
A.4.5    Unbounded-Length String Hand ling 13 December 2012      396 Each of the functions "=", "<", ">", "<=", and " >=" returns the same result as the corresponding String 
operation applied to the String values gi ven or represented by Left and Right. 
Each of the search subprograms (Index, Index_Non_Bla nk, Count, Find_Token) has the same effect as the 
corresponding subprogram in Strings.Fixed applied to the string represented by the Unbounded_String 
parameter. 
The Translate function has an analogous effect to  the corresponding subprogram  in Strings.Fixed. The 
translation is applied to the string represented by the Unbounded_String parameter, and the result is 
converted (via To_Unbounded_String) to an Unbounded_String. 
Each of the transformation functions (Replace_Slice, In sert, Overwrite, Delete), selector functions (Trim, 
Head, Tail), and constructor func tions ("*") is likewise analogous to its corresponding subprogram in 
Strings.Fixed. For each of the subprograms, the corre sponding fixed-length string subprogram is applied to 
the string represented by the Unbounded_String pa rameter, and To_Unbounded_String is applied the 
result string. 
For each of the procedures Translate, Replace_Slice, Insert, Overwrite, Delete, Trim, Head, and Tail, the 
resulting string represented by the Source paramete r is given by the corresponding function for fixed-
length strings applied to the string repr esented by Source's original value.  
Implementation Requirements 
No storage associated with an Unbounded_String object  shall be lost upon assignment or scope exit.  
A.4.6 String-Handling Sets and Mappings 
The language-defined package Stri ngs.Maps.Constants declares Char acter_Set and Character_Mapping 
constants corresponding to classifi cation and conversion functions in  package Characters.Handling.  
Static Semantics 
The library package Strings.Maps.Constants has the following declaration: 
package Ada.Strings.Maps.Constants is 
   pragma Pure(Constants); 
   Control_Set           : constant  Character_Set; 
   Graphic_Set           : constant  Character_Set; 
   Letter_Set            : constant  Character_Set; 
   Lower_Set             : constant  Character_Set; 
   Upper_Set             : constant  Character_Set; 
   Basic_Set             : constant  Character_Set; 
   Decimal_Digit_Set     : constant  Character_Set; 
   Hexadecimal_Digit_Set : constant  Character_Set; 
   Alphanumeric_Set      : constant  Character_Set; 
   Special_Set           : constant  Character_Set; 
   ISO_646_Set           : constant  Character_Set; 
   Lower_Case_Map        : constant  Character_Mapping; 
     -- Maps to lower case for letters, else identity  
   Upper_Case_Map        : constant  Character_Mapping; 
     -- Maps to upper case for letters, else identity  
   Basic_Map             : constant  Character_Mapping; 
     -- Maps to basic letter for letters, else identity  
private 
   ... -- not specified by the language  
end Ada.Strings.Maps.Constants; 83 
84 
85 
86 
87 
88 
1 
2 
3/2 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
397      13 December 2012 String- Handling Sets and Mappings   A.4.6 Each of these constants represen ts a correspondingly named set of characters or character mapping in 
Characters.Handling (see A.3.2).  
NOTES 
15  There are certain characters which are defined to be lower case letters by ISO 10646 and are therefore allowed in identifiers, but are not considered lower case letters by Ada.Strings.Maps.Constants. 
A.4.7 Wide_String Handling 
Facilities for handling strings of Wide_Character elem ents are found in the pack ages Strings.Wide_Maps, 
Strings.Wide_Fixed, Strings.Wid e_Bounded, Strings.Wide_Unbounded, and Strings.Wide_Maps.Wide_-
Constants, and in the library functions Strings.W ide_Hash, Strings.Wide_Fi xed.Wide_Hash, Strings.-
Wide_Bounded.Wide_Hash, Stri ngs.Wide_Unbounded.Wide_Hash, Strings.Wide_Hash_Case_-
Insensitive, Strings.Wide_Fixed.Wide_Hash_Cas e_Insensitive, Strings.Wide_Bounded.Wide_Hash_-
Case_Insensitive, Strings.Wide_ Unbounded.Wide_Hash_Case_Insensitiv e, Strings.Wide_Equal_Case_-
Insensitive, Strings.Wide_Fixed. Wide_Equal_Case_Insensitive, St rings.Wide_Bounded.Wide_Equal_-
Case_Insensitive, and Strings.Wid e_Unbounded.Wide_Equal_Case_Insens itive. They provide the same 
string-handling operations as the corresponding packages and functions for strings of Character elements.  
Static Semantics 
The package Strings.Wide_Maps has the following declaration.  
package Ada.Strings.Wide_Maps is 
   pragma Preelaborate(Wide_Maps); 
   --  Representation for a set of Wide_Character values:  
   type Wide_Character_Set is private; 
   pragma Preelaborable_Initialization(Wide_Character_Set); 
   Null_Set : constant  Wide_Character_Set; 
   type Wide_Character_Range is 
     record 
         Low  : Wide_Character;          High : Wide_Character;      end record; 
   -- Represents Wide_Character range Low..High  
   type Wide_Character_Ranges is array (Positive range <>) 
      of Wide_Character_Range; 
   function  To_Set    (Ranges : in Wide_Character_Ranges) 
      return Wide_Character_Set; 
   function  To_Set    (Span   : in Wide_Character_Range) 
      return Wide_Character_Set; 
   function  To_Ranges (Set    : in Wide_Character_Set) 
      return Wide_Character_Ranges; 
   function  "="   (Left, Right : in Wide_Character_Set) return Boolean; 
   function  "not" (Right : in Wide_Character_Set) 
      return Wide_Character_Set; 
   function  "and" (Left, Right : in Wide_Character_Set) 
      return Wide_Character_Set; 
   function  "or"  (Left, Right : in Wide_Character_Set) 
      return Wide_Character_Set; 
   function  "xor" (Left, Right : in Wide_Character_Set) 
      return Wide_Character_Set; 
   function  "-"   (Left, Right : in Wide_Character_Set) 
      return Wide_Character_Set; 
   function  Is_In (Element : in Wide_Character; 
                   Set     : in Wide_Character_Set) 
      return Boolean; 7 
8/3 
1/3 
2 
3 
4/2 
5 
6 
7 
8 9 
10 11 
12 
13 
Ada Reference Manual — 2012 Edition 
A.4.7    Wide_String Handling 13 December 2012      398    function  Is_Subset (Elements : in Wide_Character_Set; 
                       Set      : in Wide_Character_Set) 
      return Boolean; 
   function  "<=" (Left  : in Wide_Character_Set; 
                  Right : in Wide_Character_Set) 
      return Boolean renames Is_Subset; 
   --  Alternative representation for a set of Wide_Character values:  
   subtype Wide_Character_Sequence is Wide_String; 
   function  To_Set (Sequence  : in Wide_Character_Sequence) 
      return Wide_Character_Set; 
   function  To_Set (Singleton : in Wide_Character) 
      return Wide_Character_Set; 
   function  To_Sequence (Set  : in Wide_Character_Set) 
      return Wide_Character_Sequence; 
   --  Representation for a Wide_Char acter to Wide_Character mapping:  
   type Wide_Character_Mapping is private; 
   pragma Preelaborable_Initialization(Wide_Character_Mapping); 
   function  Value (Map     : in Wide_Character_Mapping; 
                   Element : in Wide_Character) 
      return Wide_Character; 
   Identity : constant  Wide_Character_Mapping; 
   function  To_Mapping (From, To : in Wide_Character_Sequence) 
      return Wide_Character_Mapping; 
   function  To_Domain (Map : in Wide_Character_Mapping) 
      return Wide_Character_Sequence; 
   function  To_Range  (Map : in Wide_Character_Mapping) 
      return Wide_Character_Sequence; 
   type Wide_Character_Mapping_Function is 
      access function  (From : in Wide_Character) return Wide_Character; 
private 
   ... -- not specified by the language  
end Ada.Strings.Wide_Maps; 
The context clause for each of the packages Strings.Wide_Fixed, Strings.Wide_Bounded, and 
Strings.Wide_Unbounded identifies Strings.W ide_Maps instead of Strings.Maps. 
Types Wide_Character_Set and Wide_C haracter_Mapping need finalization. 
For each of the packages Strings.Fix ed, Strings.Bounded, Strings.Unbounded, and 
Strings.Maps.Constants, and for library f unctions Strings.Hash, Strings.Fixed.Hash, 
Strings.Bounded.Hash, Strings.Unbounde d.Hash, Strings.Hash_Case_Inse nsitive, Strings.Fixed.Hash_-
Case_Insensitive, Strings.Bounded.Hash_Case_Inse nsitive, Strings.Unbounded.Ha sh_Case_Insensitive, 
Strings.Equal_Case_Insensitive, Strings.Fixed.Equal_Case_Insens itive, Strings.Bounded.Equal_Case_-
Insensitive, and Strings.Unbounded.E qual_Case_Insensitive, the corresponding wide string package or 
function has the same contents except that  
• Wide_Space replaces Space 
• Wide_Character replaces Character 
• Wide_String replaces String 
• Wide_Character_Set replaces Character_Set 
• Wide_Character_Mapping replaces Character_Mapping 
• Wide_Character_Mapping_Function replaces Character_Mapping_Function 
• Wide_Maps replaces Maps 14 
15 16 
17 18 19 
20/2 
21 22 
23 
24 25 26 27 
28 
28.1/3 
29/3 
30 
31 32 33 34 35 36 
Ada Reference Manual — 2012 Edition 
399      13 December 2012 Wide_String Handling   A.4.7 • Bounded_Wide_String replaces Bounded_String 
• Null_Bounded_Wide_String replaces Null_Bounded_String 
• To_Bounded_Wide_String replaces To_Bounded_String 
• To_Wide_String replaces To_String 
• Set_Bounded_Wide_String replaces Set_Bounded_String 
• Unbounded_Wide_String replaces Unbounded_String 
• Null_Unbounded_Wide_String replaces Null_Unbounded_String 
• Wide_String_Access replaces String_Access 
• To_Unbounded_Wide_String replaces To_Unbounded_String 
• Set_Unbounded_Wide_String replaces Set_Unbounded_String 
The following additional declaration is presen t in Strings.Wide_Maps .Wide_Constants:  
Character_Set : constant  Wide_Maps.Wide_Character_Set; 
--Contains each Wide_Character value WC such that  
--Characters.Conversions.Is_Character(WC) is True  
Each Wide_Character_Set constant in the pack age Strings.Wide_Maps.Wid e_Constants contains no 
values outside the Character portion of Wide_Character. Similarly, each Wide_Character_Mapping constant in this package is the identity mapping when applied to any element outside the Character portion 
of Wide_Character. 
Pragma  Pure is replaced by pragma  Preelaborate in Strings.W ide_Maps.Wide_Constants. 
NOTES 
16  If a null Wide_Character_Mapping_Function is passed to any of the Wide_String handling subprograms, Constraint_Error is propagated. 
A.4.8 Wide_Wide_String Handling 
Facilities for handling strings of Wide_Wide_Charact er elements are found in  the packages Strings.-
Wide_Wide_Maps, Strings.Wide_Wide_Fixed, St rings.Wide_Wide_Bounded, Strings.Wide_Wide_-
Unbounded, and Strings.Wide_Wide_Map s.Wide_Wide_Constants, and in the library functions Strings.-
Wide_Wide_Hash, Strings.Wide_ Wide_Fixed.Wide_Wide_Hash, Strings.Wide_Wide_Bounded.Wide_-
Wide_Hash, Strings.Wide_Wi de_Unbounded.Wide_Wide_Hash, St rings.Wide_Wide_Hash_Case_-
Insensitive, Strings.Wide_Wide_Fixed.Wide_Wi de_Hash_Case_Insensitive,  Strings.Wide_Wide_-
Bounded.Wide_Wide_Hash_Case_Insensitive, Strings.Wide_Wide_Unbounde d.Wide_Wide_Hash_-
Case_Insensitive, Strings.Wide_Wide_Equal_Case_I nsensitive, Strings.Wide_ Wide_Fixed.Wide_Wide_-
Equal_Case_Insensitive, Strings.Wide_Wide_B ounded.Wide_Wide_Equal_Ca se_Insensitive, and 
Strings.Wide_Wide_Unbounded.Wide_Wid e_Equal_Case_Insensitive. They provide the same string-
handling operations as the corresponding packages and functions for strings of  Character elements.  
Static Semantics 
The library package Strings.Wide_Wide_Maps has the following declaration. 
package Ada.Strings.Wide_Wide_Maps is 
   pragma Preelaborate(Wide_Wide_Maps); 
   -- Representation for a set of Wide_Wide_Character values:  
   type Wide_Wide_Character_Set is private ; 
   pragma Preelaborable_Initialization(Wide_Wide_Character_Set); 
   Null_Set : constant  Wide_Wide_Character_Set; 37 
38 39 40 
40.1/2 
41 42 43 44 
44.1/2 
45 
46/2 
46.1/2 
46.2/2 
47 
1/3 
2/2 
3/2 
4/2 
5/2 
Ada Reference Manual — 2012 Edition 
A.4.8    Wide_Wide_String Handling 13 December 2012      400    type Wide_Wide_Character_Range is 
      record 
         Low  : Wide_Wide_Character;          High : Wide_Wide_Character;       end record ; 
   -- Represents Wide_Wide_Character range Low..High  
   type Wide_Wide_Character_Ranges is array  (Positive range <>) 
         of Wide_Wide_Character_Range; 
   function  To_Set (Ranges : in Wide_Wide_Character_Ranges) 
         return Wide_Wide_Character_Set; 
   function  To_Set (Span : in Wide_Wide_Character_Range) 
         return Wide_Wide_Character_Set; 
   function  To_Ranges (Set : in Wide_Wide_Character_Set) 
         return Wide_Wide_Character_Ranges; 
   function  "=" (Left, Right : in Wide_Wide_Character_Set) return Boolean; 
   function  "not" (Right : in Wide_Wide_Character_Set) 
         return Wide_Wide_Character_Set; 
   function  "and" (Left, Right : in Wide_Wide_Character_Set) 
         return Wide_Wide_Character_Set; 
   function  "or" (Left, Right : in Wide_Wide_Character_Set) 
         return Wide_Wide_Character_Set; 
   function  "xor" (Left, Right : in Wide_Wide_Character_Set) 
         return Wide_Wide_Character_Set; 
   function  "-" (Left, Right : in Wide_Wide_Character_Set) 
         return Wide_Wide_Character_Set; 
   function  Is_In (Element : in Wide_Wide_Character; 
                   Set     : in Wide_Wide_Character_Set) 
         return Boolean; 
   function  Is_Subset (Elements : in Wide_Wide_Character_Set; 
                       Set      : in Wide_Wide_Character_Set) 
         return Boolean; 
   function  "<=" (Left  : in Wide_Wide_Character_Set; 
                  Right : in Wide_Wide_Character_Set) 
         return Boolean renames Is_Subset; 
   -- Alternative representation for a set of Wide_Wide_Character values:  
   subtype Wide_Wide_Character_Sequence is Wide_Wide_String; 
   function  To_Set (Sequence : in Wide_Wide_Character_Sequence) 
         return Wide_Wide_Character_Set; 
   function  To_Set (Singleton : in Wide_Wide_Character) 
         return Wide_Wide_Character_Set; 
   function  To_Sequence (Set : in Wide_Wide_Character_Set) 
         return Wide_Wide_Character_Sequence; 
   -- Representation for a Wide_Wide_Character to Wide_Wide_Character  
   -- mapping: 
   type Wide_Wide_Character_Mapping is private ; 
   pragma Preelaborable_Initialization(Wide_Wide_Character_Mapping); 
   function  Value (Map     : in Wide_Wide_Character_Mapping; 
                   Element : in Wide_Wide_Character) 
         return Wide_Wide_Character; 
   Identity : constant  Wide_Wide_Character_Mapping; 
   function  To_Mapping (From, To : in Wide_Wide_Character_Sequence) 
         return Wide_Wide_Character_Mapping; 
   function  To_Domain (Map : in Wide_Wide_Character_Mapping) 
         return Wide_Wide_Character_Sequence; 
   function  To_Range (Map : in Wide_Wide_Character_Mapping) 
         return Wide_Wide_Character_Sequence; 6/2 
7/2 
8/2 9/2 
10/2 11/2 
12/2 
13/2 
14/2 15/2 16/2 
17/2 18/2 19/2 20/2 
21/2 
22/2 
23/2 
24/2 25/2 
Ada Reference Manual — 2012 Edition 
401      13 December 2012 Wide_Wide_String Handling   A.4.8    type Wide_Wide_Character_Mapping_Function is 
         access function  (From : in Wide_Wide_Character) 
         return Wide_Wide_Character; 
private 
   ... -- not specified by the language  
end Ada.Strings.Wide_Wide_Maps; 
The context clause for each of the packages Stri ngs.Wide_Wide_Fixed, Strings.Wide_Wide_Bounded, and 
Strings.Wide_Wide_Unbounded identifies Strings.W ide_Wide_Maps instead of Strings.Maps. 
Types Wide_Wide_Character_Set and Wide_W ide_Character_Mapping need finalization. 
For each of the packages Strings.Fixed, Strings.Bounded, Strings .Unbounded, and Strings.-
Maps.Constants, and for library functions Strings.Hash, Strings.F ixed.Hash, Strings.Bounded.Hash, 
Strings.Unbounded.Hash, Strings.Hash_C ase_Insensitive, Strings.Fixed.H ash_Case_Insensitive, Strings.-
Bounded.Hash_Case_Insensitive, Strings.Unbounded. Hash_Case_Insensitive, Strings.Equal_Case_-
Insensitive, Strings.Fixed.Equal_Ca se_Insensitive, Strings.Bounded.Equa l_Case_Insensitive, and Strings.-
Unbounded.Equal_Case_Insensitive, th e corresponding wide wide string p ackage or function has the same 
contents except that 
• Wide_Wide_Space replaces Space 
• Wide_Wide_Character replaces Character 
• Wide_Wide_String replaces String 
• Wide_Wide_Character_Set replaces Character_Set 
• Wide_Wide_Character_Mapping replaces Character_Mapping 
• Wide_Wide_Character_Mapping_Functi on replaces Character_Mapping_Function 
• Wide_Wide_Maps replaces Maps 
• Bounded_Wide_Wide_String replaces Bounded_String 
• Null_Bounded_Wide_Wide_String replaces Null_Bounded_String 
• To_Bounded_Wide_Wide_String replaces To_Bounded_String 
• To_Wide_Wide_String replaces To_String 
• Set_Bounded_Wide_Wide_String replaces Set_Bounded_String 
• Unbounded_Wide_Wide_String replaces Unbounded_String 
• Null_Unbounded_Wide_Wide_String replaces Null_Unbounded_String 
• Wide_Wide_String_Access replaces String_Access 
• To_Unbounded_Wide_Wide_String replaces To_Unbounded_String 
• Set_Unbounded_Wide_Wide_String replaces Set_Unbounded_String 
The following additional declarations are present in Strings.Wide_Wide_Map s.Wide_Wide_Constants: 
Character_Set : constant  Wide_Wide_Maps.Wide_Wide_Character_Set; 
-- Contains each Wide_Wide_Character value WWC such that  
-- Characters.Conversions.Is_Character(WWC) is True  
Wide_Character_Set : constant  Wide_Wide_Maps.Wide_Wide_Character_Set; 
-- Contains each Wide_Wide_Character value WWC such that  
-- Characters.Conversions.Is_Wide_Character(WWC) is True  
Each Wide_Wide_Character_Set constant in th e package Strings.Wide_Wide_Maps.Wide_Wide_-
Constants contains no values outside the Character portion of Wide_Wide_Character. Similarly, each 26/2 
27/2 
28/2 
28.1/3 
29/3 
30/2 
31/2 32/2 33/2 34/2 35/2 36/2 37/2 38/2 39/2 40/2 41/2 42/2 43/2 44/2 45/2 46/2 47/2 
48/2 
49/2 
Ada Reference Manual — 2012 Edition 
A.4.8    Wide_Wide_String Handling 13 December 2012      402 Wide_Wide_Character_Mapping constant in this pack age is the identity mapping when applied to any 
element outside the Character portion of Wide_Wide_Character. 
Pragma  Pure is replaced by pragma  Preelaborate in Strings.Wide_Wi de_Maps.Wide_Wide_Constants. 
NOTES 
17  If a null Wide_Wide_Character_Mapping_Function is passed to any of the Wide_Wide_String handling subprograms, Constraint_Error is propagated.  
A.4.9 String Hashing 
Static Semantics 
The library function Strings.Hash has the following declaration:  
with Ada.Containers; 
function  Ada.Strings.Hash (Key : String) return Containers.Hash_Type; 
pragma Pure(Ada.Strings.Hash); 
Returns an implementation-defined value whic h is a function of the value of Key. If A and B are 
strings such that A equals B, Hash( A) equals Hash( B).  
The library function Strings.Fixed.Has h has the following declaration:  
with Ada.Containers, Ada.Strings.Hash; 
function  Ada.Strings.Fixed.Hash (Key : String) return Containers.Hash_Type 
   renames Ada.Strings.Hash; 
The generic library function Strings.Bounded. Hash has the following declaration:  
with Ada.Containers; 
generic 
   with package  Bounded is 
      new Ada.Strings.Bounded.Generic_Bounded_Length (<>); 
function  Ada.Strings.Bounded.Hash (Key : Bounded.Bounded_String) 
   return Containers.Hash_Type; 
pragma Preelaborate(Ada.Strings.Bounded.Hash); 
Equivalent to Strings.Has h (Bounded.To_String (Key)); 
The library function Strings.Unbounded.Hash  has the following declaration:  
with Ada.Containers; 
function  Ada.Strings.Unbounded.Hash (Key : Unbounded_String) 
   return Containers.Hash_Type; 
pragma Preelaborate(Ada.Strings.Unbounded.Hash); 
Equivalent to Strings.Hash (To_String (Key)); 
The library function Strings.Hash_Case_In sensitive has the following declaration: 
with Ada.Containers; 
function  Ada.Strings.Hash_Case_Insensitive (Key : String) 
   return Containers.Hash_Type; 
pragma Pure(Ada.Strings.Hash_Case_Insensitive); 
Returns an implementation-defined value which is a function of the value of Key, converted to 
lower case. If A and B are strings such that St rings.Equal_Case_Insensitiv e (A, B) (see A.4.10) 
is True, then Hash_Case_Insensitive(A)  equals Hash_Case_Insensitive(B).  
The library function Strings.F ixed.Hash_Case_Insensitive has the following declaration: 
with Ada.Containers, Ada.Strings.Hash_Case_Insensitive; 
function  Ada.Strings.Fixed.Hash_Case_Insensitive (Key : String) 
   return Containers.Hash_Type renames Ada.Strings.Hash_Case_Insensitive; 50/2 
51/2 
1/2 
2/3 
3/2 
4/2 
5/3 
6/2 
7/3 
8/3 
9/2 
10/3 
11/3 
11.1/3 
11.2/3 
11.3/3 
11.4/3 
11.5/3 
Ada Reference Manual — 2012 Edition 
403      13 December 2012 String Hashing   A.4.9 The generic library function Strings.Bounded.Hash_C ase_Insensitive has the following declaration: 
with Ada.Containers; 
generic 
   with package  Bounded is 
      new Ada.Strings.Bounded.Generic_Bounded_Length (<>); 
function  Ada.Strings.Bounded.Hash_Case_Insensitive 
   (Key : Bounded.Bounded_String) return Containers.Hash_Type; 
pragma Preelaborate(Ada.Strings.Bounded.Hash_Case_Insensitive); 
Equivalent to Strings.Hash_Case_In sensitive (Bounded.To_String (Key));  
The library function Strings.Unbounded.Hash_Case_ Insensitive has the following declaration: 
with Ada.Containers; 
function  Ada.Strings.Unbounded.Hash_Case_Insensitive 
   (Key : Unbounded_String) return Containers.Hash_Type; 
pragma Preelaborate(Ada.Strings.Unbounded.Hash_Case_Insensitive); 
Equivalent to Strings.Hash_Case_ Insensitive (To_String (Key));  
Implementation Advice 
The Hash functions should be good hash functions, return ing a wide spread of values for different string 
values. It should be unlikely for similar strings to return the same value.  
A.4.10 String Comparison 
Static Semantics 
The library function Strings.Equal_Case_Ins ensitive has the following declaration: 
function  Ada.Strings.Equal_Case_Insensitive (Left, Right : String) 
   return Boolean; 
pragma Pure(Ada.Strings.Equal_Case_Insensitive); 
Returns True if the strings consist of the same sequence of characters after applying locale-
independent simple case folding, as defined by documents referenced in the note in Clause 1 of 
ISO/IEC 10646:2011. Otherwise, return s False. This function uses th e same method as is used to 
determine whether two identifiers are the same. 
The library function Strings.Fixed.Equal_Case _Insensitive has the following declaration: 
with Ada.Strings.Equal_Case_Insensitive; 
function  Ada.Strings.Fixed.Equal_Case_Insensitive 
   (Left, Right : String) return Boolean 
      renames Ada.Strings.Equal_Case_Insensitive; 
The generic library function Strings.Bounded.Equal_ Case_Insensitive has the following declaration: 
generic 
   with package  Bounded is 
      new Ada.Strings.Bounded.Generic_Bounded_Length (<>); 
function  Ada.Strings.Bounded.Equal_Case_Insensitive 
   (Left, Right : Bounded.Bounded_String) return Boolean; 
pragma Preelaborate(Ada.Strings.Bounded.Equal_Case_Insensitive); 
Equivalent to Strings.Equal_Case_Insensitiv e (Bounded.To_String (Left), Bounded.To_String 
(Right));  
The library function Strings.Unbounded.Equal_Case _Insensitive has the following declaration: 
function  Ada.Strings.Unbounded.Equal_Case_Insensitive 
   (Left, Right : Unbounded_String) return Boolean; 
pragma Preelaborate(Ada.Strings.Unbounded.Equal_Case_Insensitive); 11.6/3 
11.7/3 
11.8/3 
11.9/3 
11.10/3 
11.11/3 
12/2 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
Ada Reference Manual — 2012 Edition 
A.4.10    String Comparison 13 December 2012      404 Equivalent to Strings.Equal_Case_Insensitiv e (To_String (Left), To_String (Right));  
The library function Strings.Less_Case_Ins ensitive has the following declaration: 
function  Ada.Strings.Less_Case_Insensitive (Left, Right : String) 
   return Boolean; 
pragma Pure(Ada.Strings.Less_Case_Insensitive); 
Performs a lexicographic comparison of strings Left and Right, converted to lower case.  
The library function Strings.Fixed.Less_Case _Insensitive has the following declaration: 
with Ada.Strings.Less_Case_Insensitive; 
function  Ada.Strings.Fixed.Less_Case_Insensitive 
   (Left, Right : String) return Boolean 
      renames Ada.Strings.Less_Case_Insensitive; 
The generic library function Strings.Bounded.Less_Ca se_Insensitive has the following declaration: 
generic 
   with package  Bounded is 
      new Ada.Strings.Bounded.Generic_Bounded_Length (<>); 
function  Ada.Strings.Bounded.Less_Case_Insensitive 
  (Left, Right : Bounded.Bounded_String) return Boolean; 
pragma Preelaborate(Ada.Strings.Bounded.Less_Case_Insensitive); 
Equivalent to Strings.Less_ Case_Insensitive (Bounded.To_Str ing (Left), Bounded.To_String 
(Right));  
The library function Strings.Unbounded.Less_Case_I nsensitive has the following declaration: 
function  Ada.Strings.Unbounded.Less_Case_Insensitive 
  (Left, Right : Unbounded_String) return Boolean; 
pragma Preelaborate(Ada.Strings.Unbounded.Less_Case_Insensitive); 
Equivalent to Strings.Less_Case_Insensitiv e (To_String (Left), To_String (Right));  
A.4.11 String Encoding 
Facilities for encoding, decoding, and converting strings in various  character encoding schemes are 
provided by packages Strings.UTF_Encoding,  Strings.UTF_Encoding.Conversions, Strings.-
UTF_Encoding.Strings, Strings .UTF_Encoding.Wide_Strings, and Strings.UTF_Encoding.-
Wide_Wide_Strings. 
Static Semantics 
The encoding library packages have the following declarations: 
package Ada.Strings.UTF_Encoding is 
   pragma Pure (UTF_Encoding); 
   -- Declarations common to the string encoding packages  
   type Encoding_Scheme is (UTF_8, UTF_16BE, UTF_16LE); 
   subtype UTF_String is String; 
   subtype UTF_8_String is String; 
   subtype UTF_16_Wide_String is Wide_String; 
   Encoding_Error : exception ; 
   BOM_8    : constant  UTF_8_String := 
                Character'Val(16#EF#) &                 Character'Val(16#BB#) &                 Character'Val(16#BF#); 11/3 
12/3 
13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
20/3 
21/3 
22/3 
1/3 
2/3 
3/3 
4/3 5/3 
6/3 7/3 8/3 9/3 
Ada Reference Manual — 2012 Edition 
405      13 December 2012 String Encoding   A.4.11    BOM_16BE : constant  UTF_String := 
                Character'Val(16#FE#) &                 Character'Val(16#FF#); 
   BOM_16LE : constant  UTF_String := 
                Character'Val(16#FF#) &                 Character'Val(16#FE#); 
   BOM_16   : constant  UTF_16_Wide_String := 
               (1 => Wide_Character'Val(16#FEFF#)); 
   function  Encoding (Item    : UTF_String; 
                      Default : Encoding_Scheme := UTF_8)       return Encoding_Scheme; 
end Ada.Strings.UTF_Encoding; 
package Ada.Strings.UTF_Encoding.Conversions is 
   pragma Pure (Conversions); 
   -- Conversions between various encoding schemes  
   function  Convert (Item          : UTF_String; 
                     Input_Scheme  : Encoding_Scheme;                      Output_Scheme : Encoding_Scheme;                      Output_BOM    : Boolean := False) return UTF_String; 
   function  Convert (Item          : UTF_String; 
                     Input_Scheme  : Encoding_Scheme;                      Output_BOM    : Boolean := False)       return UTF_16_Wide_String; 
   function  Convert (Item          : UTF_8_String; 
                     Output_BOM    : Boolean := False)       return UTF_16_Wide_String; 
   function  Convert (Item          : UTF_16_Wide_String; 
                     Output_Scheme : Encoding_Scheme;                      Output_BOM    : Boolean := False) return UTF_String; 
   function  Convert (Item          : UTF_16_Wide_String; 
                     Output_BOM    : Boolean := False) return UTF_8_String; 
end Ada.Strings.UTF_Encoding.Conversions; 
package Ada.Strings.UTF_Encoding.Strings is 
   pragma Pure (Strings); 
   -- Encoding / decoding between Stri ng and various encoding schemes  
   function  Encode (Item          : String; 
                    Output_Scheme : Encoding_Scheme;                     Output_BOM    : Boolean  := False) return UTF_String; 
   function  Encode (Item       : String; 
                    Output_BOM : Boolean  := False) return UTF_8_String; 
   function  Encode (Item       : String; 
                    Output_BOM : Boolean  := False)       return UTF_16_Wide_String; 
   function  Decode (Item         : UTF_String; 
                    Input_Scheme : Encoding_Scheme) return String; 
   function  Decode (Item : UTF_8_String) return String; 
   function  Decode (Item : UTF_16_Wide_String) return String; 
end Ada.Strings.UTF_Encoding.Strings; 
package Ada.Strings.UTF_Encoding.Wide_Strings is 
   pragma Pure (Wide_Strings); 
   -- Encoding / decoding between Wide_St ring and various encoding schemes  
   function  Encode (Item          : Wide_String; 
                    Output_Scheme : Encoding_Scheme;                     Output_BOM    : Boolean  := False) return UTF_String; 
   function  Encode (Item       : Wide_String; 
                    Output_BOM : Boolean  := False) return UTF_8_String; 10/3 
11/3 12/3 
13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 20/3 
21/3 
22/3 
23/3 
24/3 
25/3 
26/3 
27/3 
28/3 29/3 30/3 
31/3 
32/3 
Ada Reference Manual — 2012 Edition 
A.4.11    String Encoding 13 December 2012      406    function  Encode (Item       : Wide_String; 
                    Output_BOM : Boolean  := False)       return UTF_16_Wide_String; 
   function  Decode (Item         : UTF_String; 
                    Input_Scheme : Encoding_Scheme) return Wide_String; 
   function  Decode (Item : UTF_8_String) return Wide_String; 
   function  Decode (Item : UTF_16_Wide_String) return Wide_String; 
end Ada.Strings.UTF_Encoding.Wide_Strings; 
package Ada.Strings.UTF_Encoding.Wide_Wide_Strings is 
   pragma Pure (Wide_Wide_Strings); 
   -- Encoding / decoding between Wide_Wid e_String and various encoding schemes  
   function  Encode (Item          : Wide_Wide_String; 
                    Output_Scheme : Encoding_Scheme;                     Output_BOM    : Boolean  := False) return UTF_String; 
   function  Encode (Item       : Wide_Wide_String; 
                    Output_BOM : Boolean  := False) return UTF_8_String; 
   function  Encode (Item       : Wide_Wide_String; 
                    Output_BOM : Boolean  := False)       return UTF_16_Wide_String; 
   function  Decode (Item         : UTF_String; 
                    Input_Scheme : Encoding_Scheme) return Wide_Wide_String; 
   function  Decode (Item : UTF_8_String) return Wide_Wide_String; 
   function  Decode (Item : UTF_16_Wide_String) return Wide_Wide_String; 
end Ada.Strings.UTF_Encoding.Wide_Wide_Strings; 
The type Encoding_Scheme defines encoding sche mes. UTF_8 corresponds to the UTF-8 encoding 
scheme defined by Annex D of ISO/IEC 10646. UTF_16BE corresponds to the UTF-16 encoding scheme 
defined by Annex C of ISO/IEC 10646 in 8 bit, big- endian order; and UTF_16LE corresponds to the UTF-
16 encoding scheme in 8 bit, little-endian order. 
The subtype UTF_String is used to represent a Stri ng of 8-bit values containing a sequence of values 
encoded in one of three ways (UTF-8, UTF-16BE, or  UTF-16LE). The subtype UTF_8_String is used to 
represent a String of 8-bit values containing a se quence of values encoded in UTF-8. The subtype 
UTF_16_Wide_String is used to repres ent a Wide_String of 16-bit values containing a sequence of values 
encoded in UTF-16. 
The BOM_8, BOM_16BE, BOM_16LE, a nd BOM_16 constants correspond to va lues used at the start of a 
string to indicate the encoding. 
Each of the Encode functions takes a String, Wide_S tring, or Wide_Wide_String Item parameter that is 
assumed to be an array of unencoded characters. E ach of the Convert functions takes a UTF_String, 
UTF_8_String, or UTF_16_String Item parameter that  is assumed to contain characters whose position 
values correspond to a valid encoding sequence accordi ng to the encoding scheme required by the function 
or specified by its Input_Scheme parameter. 
Each of the Convert and Encode functions returns a UTF_String, UTF_8_String,  or UTF_16_String value 
whose characters have position values  that correspond to the encoding of the Item parameter according to 
the encoding scheme required by the function or speci fied by its Output_Schem e parameter. For UTF_8, 
no overlong encoding is returned. A BOM is included at th e start of the returned string if the Output_BOM 
parameter is set to True. The lower bound of the returned string is 1. 
Each of the Decode functions takes a UTF_String,  UTF_8_String, or UTF _16_String Item parameter 
which is assumed to contain characters whose pos ition values correspond to a valid encoding sequence 
according to the encoding scheme required by the func tion or specified by its Input_Scheme parameter, 33/3 
34/3 
35/3 
36/3 37/3 38/3 
39/3 
40/3 
41/3 
42/3 
43/3 
44/3 45/3 
46/3 
47/3 
48/3 
49/3 
50/3 
51/3 
Ada Reference Manual — 2012 Edition 
407      13 December 2012 String Encoding   A.4.11 and returns the corresponding String,  Wide_String, or Wide_Wide_St ring value. The lower bound of the 
returned string is 1. 
For each of the Convert and Decode functions, an in itial BOM in the input that matches the expected 
encoding scheme is ignored, and a different in itial BOM causes Encoding_Error to be propagated. 
The exception Encoding_Error is also propa gated in the following situations:  
• By a Decode function when a UTF encoded st ring contains an invalid encoding sequence. 
• By a Decode function when the expected en coding is UTF-16BE or UTF-16LE and the input 
string has an odd length. 
• By a Decode function yielding a String when the decoding of a sequence results in a code point 
whose value exceeds 16#FF#. 
• By a Decode function yielding a Wide_String when  the decoding of a sequence results in a code 
point whose value exceeds 16#FFFF#. 
• By an Encode function taking a Wide_String as input when an invalid character appears in the 
input. In particular, the characters whose position is in the range 16#D800# .. 16#DFFF# are 
invalid because they conflict with UTF-16 su rrogate encodings, and the characters whose 
position is 16#FFFE# or 16#FFFF# are also invalid because they conflict with BOM codes.  
function  Encoding (Item    : UTF_String; 
                   Default : Encoding_Scheme := UTF_8)    return Encoding_Scheme; 
Inspects a UTF_String value to determine whethe r it starts with a BOM for UTF-8, UTF-16BE, 
or UTF_16LE. If so, returns the scheme correspondi ng to the BOM; otherwise, returns the value 
of Default. 
function  Convert (Item          : UTF_String; 
                  Input_Scheme  : Encoding_Scheme;                   Output_Scheme : Encoding_Scheme;                   Output_BOM    : Boolean := False) return UTF_String; 
Returns the value of Item (originally encoded in UTF-8, UTF-16LE, or UTF-16BE as specified 
by Input_Scheme) encoded in one of these th ree schemes as specified by Output_Scheme. 
function  Convert (Item          : UTF_String; 
                  Input_Scheme  : Encoding_Scheme;                   Output_BOM    : Boolean := False)    return UTF_16_Wide_String; 
Returns the value of Item (originally encoded in UTF-8, UTF-16LE, or UTF-16BE as specified 
by Input_Scheme) encoded in UTF-16. 
function  Convert (Item          : UTF_8_String; 
                  Output_BOM    : Boolean := False)    return UTF_16_Wide_String; 
Returns the value of Item (originally encoded in UTF-8) encoded in UTF-16. 
function  Convert (Item          : UTF_16_Wide_String; 
                  Output_Scheme : Encoding_Scheme;                   Output_BOM    : Boolean := False) return UTF_String; 
Returns the value of Item (originally encoded in UTF-16) encoded in UTF-8, UTF-16LE, or 
UTF-16BE as specified by Output_Scheme. 52/3 
53/3 
54/3 
55/3 
56/3 57/3 58/3 
59/3 
60/3 
61/3 
62/3 
63/3 
64/3 
65/3 
66/3 
67/3 
68/3 
Ada Reference Manual — 2012 Edition 
A.4.11    String Encoding 13 December 2012      408 function  Convert (Item          : UTF_16_Wide_String; 
                  Output_BOM    : Boolean := False) return UTF_8_String; 
Returns the value of Item (originally encoded in UTF-16) encoded in UTF-8. 
function  Encode (Item          : String; 
                 Output_Scheme : Encoding_Scheme;                  Output_BOM    : Boolean  := False) return UTF_String; 
Returns the value of Item encoded in UTF- 8, UTF-16LE, or UTF-16BE as specified by 
Output_Scheme. 
function  Encode (Item       : String; 
                 Output_BOM : Boolean  := False) return UTF_8_String; 
Returns the value of Item encoded in UTF-8. 
function  Encode (Item       : String; 
                 Output_BOM : Boolean  := False) return UTF_16_Wide_String; 
Returns the value of Item encoded in UTF_16. 
function  Decode (Item         : UTF_String; 
                 Input_Scheme : Encoding_Scheme) return String; 
Returns the result of decoding Item, which is encoded in UTF-8, UTF-16LE, or UTF-16BE as 
specified by Input_Scheme. 
function  Decode (Item : UTF_8_String) return String; 
Returns the result of decoding Item, which is encoded in UTF-8. 
function  Decode (Item : UTF_16_Wide_String) return String; 
Returns the result of decoding Item, which is encoded in UTF-16. 
function  Encode (Item          : Wide_String; 
                 Output_Scheme : Encoding_Scheme;                  Output_BOM    : Boolean  := False) return UTF_String; 
Returns the value of Item encoded in UTF- 8, UTF-16LE, or UTF-16BE as specified by 
Output_Scheme. 
function  Encode (Item       : Wide_String; 
                 Output_BOM : Boolean  := False) return UTF_8_String; 
Returns the value of Item encoded in UTF-8. 
function  Encode (Item       : Wide_String; 
                 Output_BOM : Boolean  := False) return UTF_16_Wide_String; 
Returns the value of Item encoded in UTF_16. 
function  Decode (Item         : UTF_String; 
                 Input_Scheme : Encoding_Scheme) return Wide_String; 
Returns the result of decoding Item, which is encoded in UTF-8, UTF-16LE, or UTF-16BE as 
specified by Input_Scheme. 
function  Decode (Item : UTF_8_String) return Wide_String; 
Returns the result of decoding Item, which is encoded in UTF-8. 
function  Decode (Item : UTF_16_Wide_String) return Wide_String; 
Returns the result of decoding Item, which is encoded in UTF-16. 69/3 
70/3 
71/3 
72/3 
73/3 
74/3 
75/3 
76/3 
77/3 
78/3 
79/3 
80/3 
81/3 
82/3 
83/3 
84/3 
85/3 
86/3 
87/3 
88/3 
89/3 
90/3 
91/3 
92/3 
93/3 
94/3 
Ada Reference Manual — 2012 Edition 
409      13 December 2012 String Encoding   A.4.11 function  Encode (Item          : Wide_Wide_String; 
                 Output_Scheme : Encoding_Scheme;                  Output_BOM    : Boolean  := False) return UTF_String; 
Returns the value of Item encoded in UTF- 8, UTF-16LE, or UTF-16BE as specified by 
Output_Scheme. 
function  Encode (Item       : Wide_Wide_String; 
                 Output_BOM : Boolean  := False) return UTF_8_String; 
Returns the value of Item encoded in UTF-8. 
function  Encode (Item       : Wide_Wide_String; 
                 Output_BOM : Boolean  := False) return UTF_16_Wide_String; 
Returns the value of Item encoded in UTF_16. 
function  Decode (Item         : UTF_String; 
                 Input_Scheme : Encoding_Scheme) return Wide_Wide_String; 
Returns the result of decoding Item, which is encoded in UTF-8, UTF-16LE, or UTF-16BE as 
specified by Input_Scheme. 
function  Decode (Item : UTF_8_String) return Wide_Wide_String; 
Returns the result of decoding Item, which is encoded in UTF-8. 
function  Decode (Item : UTF_16_Wide_String) return Wide_Wide_String; 
Returns the result of decoding Item, which is encoded in UTF-16. 
Implementation Advice 
If an implementation supports other encoding schemes, anot her similar child of Ada.Strings should be 
defined.  
NOTES 
18  A BOM (Byte-Order Mark, code position 16#FEFF#) can be included in a file or other entity to indicate the encoding; it is skipped when decoding. Typically, only the first line of a file or other entity contains a BOM. When decoding, the Encoding function can be called on the first line to determine the encoding; this encoding will then be used in subsequent calls to Decode to convert all of the lines to an internal format.  
A.5 The Numerics Packages 
The library package Numerics is the parent of severa l child units that provide facilities for mathematical 
computation. One child, the generic package Generic_El ementary_Functions, is defi ned in A.5.1, together 
with nongeneric equivalents; two others, the package Float_Random and the generic package 
Discrete_Random, are defined in A.5.2. Additional (optional) ch ildren are defined in Annex G, 
“Numerics”.  
Static Semantics 
This paragraph was deleted.  95/3 
96/3 
97/3 
98/3 
99/3 
100/3 
101/3 
102/3 
103/3 
104/3 
105/3 
106/3 
107/3 
108/3 
1 
2/1 
Ada Reference Manual — 2012 Edition 
A.5   The Numerics Packages 13 December 2012      410 package Ada.Numerics is 
   pragma Pure(Numerics); 
   Argument_Error : exception ; 
   Pi : constant  := 
          3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37511;    π  : constant  := Pi; 
   e  : constant  := 
          2.71828_18284_59045_23536_02874_71352_66249_77572_47093_69996; end Ada.Numerics; 
The Argument_Error exception is raised  by a subprogram in a child unit of Numerics to signal that one or 
more of the actual subprogram parameters are out side the domain of the corresponding mathematical 
function. 
Implementation Permissions 
The implementation may specify the values of Pi and e to a larger number of significant digits.  
A.5.1 Elementary Functions 
Implementation-defined approximations to the ma thematical functions known as the “elementary 
functions” are provided by the subprograms in Nu merics.Generic_Elementary_Functions. Nongeneric 
equivalents of this generic package for each of the predefined floating point types are also provided as 
children of Numerics.  
Static Semantics 
The generic library package Numerics.Generic_Eleme ntary_Functions has the following declaration:  
generic 
   type Float_Type is digits <>; 
 package Ada.Numerics.Generic_Elementary_Functions is 
   pragma Pure(Generic_Elementary_Functions); 
   function  Sqrt    (X           : Float_Type'Base) return Float_Type'Base; 
   function  Log     (X           : Float_Type'Base) return Float_Type'Base; 
   function  Log     (X, Base     : Float_Type'Base) return Float_Type'Base; 
   function  Exp     (X           : Float_Type'Base) return Float_Type'Base; 
   function  "**"    (Left, Right : Float_Type'Base) return Float_Type'Base; 
   function  Sin     (X           : Float_Type'Base) return Float_Type'Base; 
   function  Sin     (X, Cycle    : Float_Type'Base) return Float_Type'Base; 
   function  Cos     (X           : Float_Type'Base) return Float_Type'Base; 
   function  Cos     (X, Cycle    : Float_Type'Base) return Float_Type'Base; 
   function  Tan     (X           : Float_Type'Base) return Float_Type'Base; 
   function  Tan     (X, Cycle    : Float_Type'Base) return Float_Type'Base; 
   function  Cot     (X           : Float_Type'Base) return Float_Type'Base; 
   function  Cot     (X, Cycle    : Float_Type'Base) return Float_Type'Base; 3/2 
4 
5 
1 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
411      13 December 2012 Elementary Functions   A.5.1    function  Arcsin  (X           : Float_Type'Base) return Float_Type'Base; 
   function  Arcsin  (X, Cycle    : Float_Type'Base) return Float_Type'Base; 
   function  Arccos  (X           : Float_Type'Base) return Float_Type'Base; 
   function  Arccos  (X, Cycle    : Float_Type'Base) return Float_Type'Base; 
   function  Arctan  (Y           : Float_Type'Base; 
                     X           : Float_Type'Base := 1.0)                                                     return Float_Type'Base; 
   function  Arctan  (Y           : Float_Type'Base; 
                     X           : Float_Type'Base := 1.0;                      Cycle       : Float_Type'Base) return Float_Type'Base; 
   function  Arccot  (X           : Float_Type'Base; 
                     Y           : Float_Type'Base := 1.0)                                                     return Float_Type'Base; 
   function  Arccot  (X           : Float_Type'Base; 
                     Y           : Float_Type'Base := 1.0;                      Cycle       : Float_Type'Base) return Float_Type'Base; 
   function  Sinh    (X           : Float_Type'Base) return Float_Type'Base; 
   function  Cosh    (X           : Float_Type'Base) return Float_Type'Base; 
   function  Tanh    (X           : Float_Type'Base) return Float_Type'Base; 
   function  Coth    (X           : Float_Type'Base) return Float_Type'Base; 
   function  Arcsinh (X           : Float_Type'Base) return Float_Type'Base; 
   function  Arccosh (X           : Float_Type'Base) return Float_Type'Base; 
   function  Arctanh (X           : Float_Type'Base) return Float_Type'Base; 
   function  Arccoth (X           : Float_Type'Base) return Float_Type'Base; 
end Ada.Numerics.Generic_Elementary_Functions; 
The library package Numerics.Elementary_Functions is declared pure and defines the same subprograms 
as Numerics.Generic_Elementary_Functions, except that  the predefined type Float is systematically 
substituted for Float_Type'Base throughout. Nongeneric equivalents of Numerics.Generic_Elementary_-
Functions for each of the other predefined floating point types are defined similarly, with the names 
Numerics.Short_Elementary_Functions, Nume rics.Long_Elementary_Functions, etc.  
The functions have their usual mathematical meanings. When the Base parameter is specified, the Log 
function computes the logarithm to the given base; othe rwise, it computes the natural logarithm. When the 
Cycle parameter is specified, the parameter X of the forward trigonometric functions (Sin, Cos, Tan, and 
Cot) and the results of the inverse trigonometric f unctions (Arcsin, Arccos, Arctan, and Arccot) are 
measured in units such that a full cycle of revolution has the given value; otherwise, they are measured in 
radians. 
The computed results of the mathematically multiv alued functions are rendered single-valued by the 
following conventions, which are meant to imply the principal branch:  
• The results of the Sqrt and Arccosh functi ons and that of the exponentiation operator are 
nonnegative. 
• The result of the Arcsin function is in  the quadrant containing the point (1.0, x), where x is the 
value of the parameter X. This quadrant is I or  IV; thus, the range of the Arcsin function is 
approximately – π/2.0 to π/2.0 (–Cycle/4.0 to Cycle/4.0, if the parameter Cycle is specified). 
• The result of the Arccos function is in the quadrant containing the point ( x, 1.0), where x is the 
value of the parameter X. This quadrant is I or  II; thus, the Arccos function ranges from 0.0 to 
approximately π (Cycle/2.0, if the parameter Cycle is specified). 
• The results of the Arctan and Arccot functi ons are in the quadrant containing the point ( x, y), 
where x and y are the values of the parameters X and Y, respectively. This may be any quadrant 
(I through IV) when the parameter X (resp., Y) of Arctan (resp., Arccot) is specified, but it is 
restricted to quadrants I and IV (resp., I and II) when that parameter is omitted. Thus, the range 
when that parameter is specified is approximately – π to π (–Cycle/2.0 to Cycle/2.0, if the 
parameter Cycle is specified); when omitted, the ra nge of Arctan (resp., Arccot) is that of Arcsin 6 
7 
8 
9/1 
10 
11 
12 
13 
14 
15 
Ada Reference Manual — 2012 Edition 
A.5.1    Elementary Functions 13 December 2012      412 (resp., Arccos), as given above. When the point ( x, y) lies on the negative x-axis, the result 
approximates  
• π (resp., – π) when the sign of the parameter Y is positive (resp., negative), if 
Float_Type'Signed_Zeros is True; 
• π, if Float_Type'Signed_Zeros is False.  
(In the case of the inverse trigonomet ric functions, in which a result lying on or near one of the axes may 
not be exactly representable, the approximation inherent in computing the result may place it in an adjacent quadrant, close to but on the wrong side of the axis.)  
Dynamic Semantics 
The exception Numerics.Argument_Error is raised, si gnaling a parameter value outside the domain of the 
corresponding mathematical functi on, in the following cases:  
• by any forward or inverse trigonometric function with specified cycle, when the value of the 
parameter Cycle is zero or negative; 
• by the Log function with specified base, when th e value of the parameter Base is zero, one, or 
negative; 
• by the Sqrt and Log functions, when the value of the parameter X is negative; 
• by the exponentiation operator, when the value of the left operand is negative or when both 
operands have the value zero; 
• by the Arcsin, Arccos, and Arctanh functions, when the absolute value of the parameter X 
exceeds one; 
• by the Arctan and Arccot functions, when the parameters X and Y both have the value zero; 
• by the Arccosh function, when the value of the parameter X is less than one; and 
• by the Arccoth function, when the absolute value of the parameter X is less than one.  
The exception Constraint_Error is raised, signaling a pole of the mathematical function (analogous to 
dividing by zero), in the following cases, provided that Float_Type'Machine_Overflows is True:  
• by the Log, Cot, and Coth functions, wh en the value of the parameter X is zero; 
• by the exponentiation operator, when the value of  the left operand is zero and the value of the 
exponent is negative; 
• by the Tan function with specified cycle, when  the value of the parameter X is an odd multiple 
of the quarter cycle; 
• by the Cot function with specified cycle, when the value of the parameter X is zero or a multiple 
of the half cycle; and 
• by the Arctanh and Arccoth functions, when th e absolute value of the parameter X is one.  
Constraint_Error can also be raised when a fin ite result overflows (see G.2.4); this may occur for 
parameter values sufficiently near poles, and, in the case of some of  the functions, for parameter values 
with sufficiently large magnitudes. When Float_Type'M achine_Overflows is False, the result at poles is 
unspecified.  
When one parameter of a function with multiple parame ters represents a pole and another is outside the 
function's domain, the latter takes precedence (i .e., Numerics.Argument_Error is raised).  16 
17 
18 
19 
20 
21 22 
23 
24 25 
26 27 28 
29 
30 
31 32 33 
34 
35 
Ada Reference Manual — 2012 Edition 
413      13 December 2012 Elementary Functions   A.5.1 Implementation Requirements 
In the implementation of Numerics.Generic_Element ary_Functions, the range of intermediate values 
allowed during the calculation of a final result shall not be affected by any range constraint of the subtype 
Float_Type.  
In the following cases, evaluation of an elementary function shall yield the prescribed result , provided that 
the preceding rules do not call for an exception to be raised:  
• When the parameter X has the value zero, the Sq rt, Sin, Arcsin, Tan, Si nh, Arcsinh, Tanh, and 
Arctanh functions yield a result of zero, and the Exp, Cos, and Cosh functions yield a result of 
one. 
• When the parameter X has the value one, the Sqrt  function yields a result of one, and the Log, 
Arccos, and Arccosh functions yield a result of zero. 
• When the parameter Y has the value zero and th e parameter X has a positive value, the Arctan 
and Arccot functions yield a result of zero. 
• The results of the Sin, Cos, Tan, and Cot f unctions with specified cycle are exact when the 
mathematical result is zero; those of the first two are also exact when the mathematical result is ± 1.0. 
• Exponentiation by a zero exponent yields th e value one. Exponentiation by a unit exponent 
yields the value of the left operand. Exponen tiation of the value one yields the value one. 
Exponentiation of the value zero yields the value zero.  
Other accuracy requirements for the elementary functions, which apply only in implementations 
conforming to the Numerics Annex, and then only in the “strict” mode defined there (see G.2), are given 
in G.2.4. 
When Float_Type'Signed_Zeros is True, the sign of a zero result shall be as follows:  
• A prescribed zero result delivered at the origin  by one of the odd functions (Sin, Arcsin, Sinh, 
Arcsinh, Tan, Arctan or Arccot as a function of Y when X is fixed and positive, Tanh, and 
Arctanh) has the sign of the parameter X (Y, in the case of Arctan or Arccot). 
• A prescribed zero result delivered by one of the odd functions away from the origin , or by some 
other elementary function, has an  implementation-defined sign.  
• A zero result that is not a prescribed result (i .e., one that results from rounding or underflow) has 
the correct mathematical sign.  
Implementation Permissions 
The nongeneric equivalent packages may, but need not, be actual instantiations of the generic package for 
the appropriate predefined type.  
A.5.2 Random Number Generation 
Facilities for the generation of pseudo-random floa ting point numbers are provided in the package 
Numerics.Float_Random; the generic package Numeri cs.Discrete_Random provides similar facilities for 
the generation of pseudo-random inte gers and pseudo-random values of enumeration types. For brevity, 
pseudo-random values of any of these types are called random numbers . 
Some of the facilities provided are basic to all app lications of random numbers. These include a limited 
private type each of whose objects serves as the ge nerator of a (possibly distinct) sequence of random 
numbers; a function to obtain the “next” random num ber from a given sequence of random numbers (that 36 
37 
38 
39 
40 41 
42 
43 
44 
45 
46 
47 
48 
1 
2 
Ada Reference Manual — 2012 Edition 
A.5.2    Random Number Generation 13 December 2012      414 is, from its generator); and subprograms to initialize or  reinitialize a given generator to a time-dependent 
state or a state denoted by a single integer. 
Other facilities are provided specifically for advanced  applications. These include subprograms to save 
and restore the state of a given generator; a private type whose objects can be used to hold the saved state 
of a generator; and subprograms to obtain a string repres entation of a given generator state, or, given such 
a string representation, the corresponding state.  
Static Semantics 
The library package Numerics.Float_Ra ndom has the following declaration:  
package Ada.Numerics.Float_Random is 
   -- Basic facilities  
   type Generator is limited private; 
   subtype Uniformly_Distributed is Float range 0.0 .. 1.0; 
   function  Random (Gen : Generator) return Uniformly_Distributed; 
   procedure  Reset (Gen       : in Generator; 
                    Initiator : in Integer); 
   procedure  Reset (Gen       : in Generator); 
   -- Advanced facilities  
   type State is private; 
   procedure  Save  (Gen        : in  Generator; 
                    To_State   : out State); 
   procedure  Reset (Gen        : in  Generator; 
                    From_State : in  State); 
   Max_Image_Width : constant  := implementation-defined integer value ; 
   function  Image (Of_State    : State)  return String; 
   function  Value (Coded_State : String) return State; 
private 
   ... -- not specified by the language  
end Ada.Numerics.Float_Random; 
The type Generator needs finalization (see 7.6). 
The generic library package Numerics.Discr ete_Random has the following declaration:  
 
generic 
   type Result_Subtype is (<>); 
package Ada.Numerics.Discrete_Random is 
   -- Basic facilities  
   type Generator is limited private; 
   function  Random (Gen : Generator) return Result_Subtype; 
   procedure  Reset (Gen       : in Generator; 
                    Initiator : in Integer); 
   procedure  Reset (Gen       : in Generator); 
   -- Advanced facilities  
   type State is private; 
   procedure  Save  (Gen        : in  Generator; 
                    To_State   : out State); 
   procedure  Reset (Gen        : in  Generator; 
                    From_State : in  State); 
   Max_Image_Width : constant  := implementation-defined integer value ; 
   function  Image (Of_State    : State)  return String; 
   function  Value (Coded_State : String) return State; 3 
4 
5 
6 7 8 
9 
10 
11 12 
13 
14 
15 
15.1/2 
16 
17 
18 
19 20 21 
22 
23 24 
25 
26 
Ada Reference Manual — 2012 Edition 
415      13 December 2012 Random Number Generation   A.5.2 private 
   ... -- not specified by the language  
end Ada.Numerics.Discrete_Random; 
The type Generator needs finalization (see 7.6) in  every instantiation of Numerics.Discrete_Random. 
An object of the limited private type Generator is associated with a sequen ce of random numbers. Each 
generator has a hidden (internal) st ate, which the operations on generato rs use to determine the position in 
the associated sequence. All generators are implicitly initialized to an unspecified state that does not vary 
from one program execution to another; they may also  be explicitly initialized, or reinitialized, to a time-
dependent state, to a previously saved state, or to a state uniquely denoted by an integer value.  
An object of the private type State can be used to hol d the internal state of a generator. Such objects are 
only needed if the application is designed to save  and restore generator states or to examine or 
manufacture them. The implicit initial value of type St ate corresponds to the implicit initial value of all 
generators. 
The operations on generators affect the state and theref ore the future values of the associated sequence. 
The semantics of the operations on genera tors and states are defined below.  
function  Random (Gen : Generator) return Uniformly_Distributed; 
function  Random (Gen : Generator) return Result_Subtype; 
Obtains the “next” random number from the given generator, relative to its current state, 
according to an implementation-defined algorithm. The result of the function in Numerics.Float_Random is deliver ed as a value of the subtype Uniformly_Distributed, which is 
a subtype of the predefined type Float having a ra nge of 0.0 .. 1.0. The result of the function in 
an instantiation of Numerics.Dis crete_Random is delivered as a value of the generic formal 
subtype Result_Subtype.  
procedure  Reset (Gen       : in Generator; 
                 Initiator : in Integer); 
procedure  Reset (Gen       : in Generator); 
Sets the state of the specified generator to one th at is an unspecified function of the value of the 
parameter Initiator (or to a time-dependent state, if only a generator parameter is specified). The 
latter form of the pro cedure is known as the time-dependent Reset procedure .  
procedure  Save  (Gen        : in  Generator; 
                 To_State   : out State); 
procedure  Reset (Gen        : in  Generator; 
                 From_State : in  State); 
Save obtains the current state of a generator. Reset gives a generator the specified state. A 
generator that is reset to a state previously obt ained by invoking Save is restored to the state it 
had when Save was invoked. 
function  Image (Of_State    : State)  return String; 
function  Value (Coded_State : String) return State; 
Image provides a representation of a state coded (in an implementation-defined way) as a string 
whose length is bounded by the value of Max_Ima ge_Width. Value is th e inverse of Image: 
Value(Image(S)) = S for each state S that can be obtained from a generator by invoking Save.  
Dynamic Semantics 
Instantiation of Numerics.Discrete_ Random with a subtype having a null range raises Constraint_Error. 
This paragraph was deleted.  27 
27.1/2 
28 
29/3 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40/1 
Ada Reference Manual — 2012 Edition 
A.5.2    Random Number Generation 13 December 2012      416 Bounded (Run-Time) Errors 
It is a bounded error to invoke Value with a string that is not the image of any generator state. If the error 
is detected, Constraint_Error or Progr am_Error is raised. Otherwise, a ca ll to Reset with the resulting state 
will produce a generator such that calls to Random w ith this generator will produce a sequence of values 
of the appropriate subtype, but which might not be random in character. That is , the sequence of values 
might not fulfill the implementation requirements of this subclause.  
Implementation Requirements 
A sufficiently long sequence of random numbers obtaine d by successive calls to Random is approximately 
uniformly distributed over the range of the result subtype. 
The Random function in an instantiation of Numerics .Discrete_Random is guaranteed to yield each value 
in its result subtype in a finite number of calls, provided that the number of such values does not exceed 2 
15. 
Other performance requirements for the random number generator, whic h apply only in implementations 
conforming to the Numerics Annex, and then only in the “strict” mode defined there (see G.2), are given 
in G.2.5.  
Documentation Requirements 
No one algorithm for random number ge neration is best for all applica tions. To enable the user to 
determine the suitability of the random number generato rs for the intended application, the implementation 
shall describe the algorithm used and shall give its period, if known exactly, or a lower bound on the 
period, if the exact period is unknown. Periods that are so long that the periodicity is unobservable in 
practice can be described in such te rms, without giving a numerical bound.  
The implementation also shall document the minimum time interval between calls to the time-dependent 
Reset procedure that are guaranteed to initiate differe nt sequences, and it shall document the nature of the 
strings that Value will accept wit hout raising Constraint_Error.  
Implementation Advice 
Any storage associated with an object of type Gene rator should be reclaimed on exit from the scope of the 
object.  
If the generator period is sufficiently long in relation to the number of distinct initiator values, then each 
possible value of Initiator passed to Reset should initia te a sequence of random numbers that does not, in a 
practical sense, overlap the sequence initiated by any ot her value. If this is not possible, then the mapping 
between initiator values and generator states should be  a rapidly varying function of the initiator value.  
NOTES 
19  If two or more tasks are to share the same generator, then the tasks have to synchronize their access to the generator as for any shared variable (see 9.10). 
20  Within a given implementation, a repeatable random number sequence can be obtained by relying on the implicit 
initialization of generators or by explicitly initializing a generator with a repeatable initiator value. Different sequences o f 
random numbers can be obtained from a given generator in different program executions by explicitly initializing the generator to a time-dependent state. 
21  A given implementation of the Random function in Numerics.Float_Random may or may not be capable of delivering 
the values 0.0 or 1.0. Portable applications should assume that these values, or values sufficiently close to them to behave indistinguishably from them, can occur. If a sequence of random integers from some fixed range is needed, the application should use the Random function in an appropriate instantiation of Numerics.Discrete_Random, rather than transforming the result of the Random function in Numerics.Float_Random. However, some applications with unusual requirements, such as for a sequence of random intege rs each drawn from a different  range, will find it more c onvenient to transform the 
result of the floating point Random function. For M ≥ 1, the expression  40.1/1 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
Ada Reference Manual — 2012 Edition 
417      13 December 2012 Random Number Generation   A.5.2    Integer(Float(M) * Random(G)) mod M 
transforms the result of Random(G) to an integer uniformly distributed over the range 0 .. M–1; it is valid even if Random 
delivers 0.0 or 1.0. Each value of the result range is possible, provided that M is not too large. Exponentially distributed (floating point) random numbers with mean and standard deviation 1.0 can be obtained by the transformation  
   -Log(Random(G) + Float'Model_Small) 
where Log comes from Numerics.Elementary_Functions (see A.5.1); in this expression, the addition of Float'Model_Small avoids the exception that would be raised were Log to be given the value zero, without affecting the result (in most implementations) when Random returns a nonzero value.  
Examples 
Example of a program that plays a simulated dice game:   
with Ada.Numerics.Discrete_Random; 
procedure  Dice_Game is 
   subtype Die is Integer range 1 .. 6; 
   subtype Dice is Integer range 2*Die'First .. 2*Die'Last; 
   package Random_Die is new Ada.Numerics.Discrete_Random (Die); 
   use Random_Die; 
   G : Generator;    D : Dice; begin 
   Reset (G);  -- Start the generator in a unique state in each run  
   loop 
      -- Roll a pair of dice; sum and process the results  
      D := Random(G) + Random(G);       ...    end loop; 
end Dice_Game; 
Example of a program that simulates coin tosses:   
with Ada.Numerics.Discrete_Random; 
procedure  Flip_A_Coin is 
   type Coin is (Heads, Tails); 
   package Random_Coin is new Ada.Numerics.Discrete_Random (Coin); 
   use Random_Coin; 
   G : Generator; begin 
   Reset (G);  -- Start the generator in a unique state in each run  
   loop 
      -- Toss a coin and process the result  
      case Random(G) is 
          when Heads => 
             ...           when Tails => 
             ...       end case; 
   ...    end loop; 
end Flip_A_Coin; 51 
52 
53/2 
54 
55 
56 
57 
58 
Ada Reference Manual — 2012 Edition 
A.5.2    Random Number Generation 13 December 2012      418 Example of a parallel simulation of a physical syst em, with a separate generator of event probabilities in 
each task:   
with Ada.Numerics.Float_Random; 
procedure  Parallel_Simulation is 
   use Ada.Numerics.Float_Random; 
   task type Worker is 
      entry Initialize_Generator (Initiator : in Integer); 
      ...    end Worker; 
   W : array (1 .. 10) of Worker; 
   task body Worker is 
      G : Generator;       Probability_Of_Event : Uniformly_Distributed;    begin 
      accept Initialize_Generator (Initiator : in Integer) do 
         Reset (G, Initiator);       end Initialize_Generator; 
      loop 
         ...          Probability_Of_Event := Random(G);          ...       end loop; 
   end Worker; 
begin 
   -- Initialize the generators in the Wo rker tasks to different states  
   for I in W'Range loop 
      W(I).Initialize_Generator (I);    end loop; 
   ... -- Wait for the Worker tasks to terminate  
end Parallel_Simulation; 
NOTES 
22  Notes on the last example:  Although each Worker task initializes its generator to a different state, those states will be 
the same in every execution of the program. Th e generator states can be  initialized uniquely in each program execution by 
instantiating Ada.Numerics.Discrete_Random for the type Integer in the main procedure, resetting the generator obtained from that instance to a time-dependent state, and then using random integers obtained from that generator to initialize the generators in each Worker task.  
A.5.3 Attributes of Floating Point Types 
Static Semantics 
The following representation-oriented attributes  are defined for every subtype S of a floating point type T.  
S'Machine_Radix 
 Yields the radix of the hardware representation of the type T. The value of this attribute is 
of the type universal_integer .  
The values of other representation-oriented attributes  of a floating point subtype, and of the “primitive 
function” attributes of a floating point subtype desc ribed later, are defined in terms of a particular 
representation of nonzero values called the canonical form . The canonical form (for the type T) is the form 
    ± mantissa  · T'Machine_Radixexponent 
where  
• mantissa  is a fraction in the number base T'Machine_Radix, the first digit of which is nonzero, 
and 
• exponent  is an integer.  
S'Machine_Mantissa 
 Yields the largest value of p such that every value expressible in the canonical form (for the 
type T), having a p-digit mantissa  and an exponent  between T'Machine_Emin and 59 
60 
61 
1 
2 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
419      13 December 2012 Attribut es of Floating Point Types   A.5.3 T'Machine_Emax, is a machine number (see 3.5.7) of the type T. This attribute yields a 
value of the type universal_integer .  
S'Machine_Emin 
 Yields the smallest (m ost negative) value of exponent  such that every value expressible in 
the canonical form (for the type T), having a mantissa  of T'Machine_Mantissa digits, is a 
machine number (see 3.5.7) of the type T. This attribute yields a value of the type 
universal_integer . 
S'Machine_Emax 
 Yields the largest (most positive) value of exponent  such that every value expressible in the 
canonical form (for the type T), having a mantissa  of T'Machine_Mantissa digits, is a 
machine number (see 3.5.7) of the type T. This attribute yields a value of the type 
universal_integer .  
S'Denorm Yields the value True if every value expressible in the form 
     ± mantissa  · T'Machine_RadixT'Machine_Emin 
 where mantissa  is a nonzero T'Machine_Mantissa-digit fraction in the number base 
T'Machine_Radix, the first digit of which is zero, is a machine numbe r (see 3.5.7) of the 
type T; yields the value False otherwise. The value of  this attribute is of the predefined type 
Boolean.  
The values described by the formula in  the definition of S'Denorm are called denormalized numbers . A 
nonzero machine number that is not a denormalized number is a normalized number . A normalized 
number x of a given type T is said to be represented in canonical form  when it is expressed in the 
canonical form (for the type T) with a mantissa  having T'Machine_Mantissa digits; the resulting form is 
the canonical-form representation  of x.  
S'Machine_Rounds 
 Yields the value True if rounding is perform ed on inexact results of every predefined 
operation that yields a result of the type T; yields the value False otherwise. The value of 
this attribute is of the predefined type Boolean.  
S'Machine_Overflows 
 Yields the value True if overflow and divide -by-zero are detected and reported by raising 
Constraint_Error for every predefined opera tion that yields a result of the type T; yields the 
value False otherwise. The valu e of this attribute is of the predefined type Boolean. 
S'Signed_Zeros 
 Yields the value True if the hardware representation for the type T has the capability of 
representing both positively and negatively signed zeros, these being generated and used by 
the predefined operations of the type T as specified in IEC 559:1989; yields the value False 
otherwise. The value of this attribute is of the predefined type Boolean.  
For every value x of a floating point type T, the normalized exponent  of x is defined as follows:  
• the normalized exponent of zero is (by convention) zero; 
• for nonzero x, the normalized exponent of x is the unique integer k such that T'Machine_Radixk–1 
≤ |x| < T'Machine_Radixk.  
The following primitive function attributes  are defined for any subtype S of a floating point type T.  
S'Exponent S'Exponent denotes a functi on with the following specification:  
function  S'Exponent ( X : T) 
  return universal_integer  
 The function yields the normalized exponent of X. 7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
Ada Reference Manual — 2012 Edition 
A.5.3    Attributes of Floating Poin t Types 13 December 2012      420 S'Fraction S'Fraction denotes a functi on with the following specification:  
function  S'Fraction ( X : T) 
  return T 
 The function yields the value X · T'Machine_Radix–k, where k is the normalized exponent of 
X. A zero result, which can only occur when X is zero, has the sign of X.  
S'Compose S'Compose denotes a functi on with the following specification:  
function  S'Compose ( Fraction : T; 
                    Exponent : universal_integer ) 
  return T 
 Let v be the value Fraction  · T'Machine_RadixExponent –k, where k is the normalized exponent 
of Fraction . If v is a machine number of the type T, or if | v| ≥ T'Model_Small, the function 
yields v; otherwise, it yields either one of  the machine numbers of the type T adjacent to v. 
Constraint_Error is optionally raised if v is outside the base range of S. A zero result has the 
sign of Fraction  when S'Signed_Zeros is True.  
S'Scaling S'Scaling denotes a functi on with the following specification:  
function  S'Scaling ( X : T; 
                    Adjustment  : universal_integer ) 
  return T 
 Let v be the value X · T'Machine_RadixAdjustment. If v is a machine number of the type T, or if 
|v| ≥ T'Model_Small, the function yields v; otherwise, it yields either one of the machine 
numbers of the type T adjacent to v. Constraint_Error is optionally raised if v is outside the 
base range of S. A zero result has the sign of X when S'Signed_Zeros is True.  
S'Floor S'Floor denotes a function with the following specification:  
function  S'Floor ( X : T) 
  return T 
 The function yields the value X, i.e., the largest (most positive)  integral value less than or 
equal to X. When X is zero, the result has the sign of X; a zero result otherwise has a 
positive sign. 
S'Ceiling S'Ceiling denotes a function with the following specification:  
function  S'Ceiling ( X : T) 
  return T 
 The function yields the value X, i.e., the smallest (most negative) integral value greater 
than or equal to X. When X is zero, the result has the sign of X; a zero result otherwise has a 
negative sign when S'Signed_Zeros is True. 
S'Rounding S'Rounding denotes a function with the following specification:  
function  S'Rounding ( X : T) 
  return T 
 The function yields the integral value nearest to X, rounding away from zero if X lies 
exactly halfway between two integers. A zero result has the sign of X when S'Signed_Zeros 
is True. 
S'Unbiased_Rounding 
 S'Unbiased_Rounding denotes a function with the following specification:  
function  S'Unbiased_Rounding ( X : T) 
  return T 
 The function yields the integral value nearest to X, rounding toward the even integer if X 
lies exactly halfway between two integers. A zero result has the sign of X when 
S'Signed_Zeros is True. 21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
Ada Reference Manual — 2012 Edition 
421      13 December 2012 Attribut es of Floating Point Types   A.5.3 S'Machine_Rounding 
 S'Machine_Rounding denotes a function with the following specification:  
function  S'Machine_Rounding ( X : T) 
  return T 
 The function yields the integral value nearest to X. If X lies exactly halfway between two 
integers, one of those integers is returned, but  which of them is returned is unspecified. A 
zero result has the sign of X when S'Signed_Zeros is True. This function provides access to 
the rounding behavior which is most efficient on the target processor. 
S'Truncation S'Truncation denotes a function with the following specification:  
function  S'Truncation ( X : T) 
  return T 
 The function yields the value X when X is negative, and X otherwise. A zero result has 
the sign of X when S'Signed_Zeros is True. 
S'Remainder S'Remai nder denotes a function with the following specification:  
function  S'Remainder ( X, Y : T) 
  return T 
 For nonzero Y, let v be the value X – n · Y, where n is the integer nearest to the exact value 
of X/Y; if |n – X/Y| = 1/2, then n is chosen to be even. If v is a machine number of the type 
T, the function yields v; otherwise, it yields zero. C onstraint_Error is raised if Y is zero. A 
zero result has the sign of X when S'Signed_Zeros is True.  
S'Adjacent S'Adjacent denotes a function with the following specification:  
function  S'Adjacent ( X, Towards : T) 
  return T 
 If Towards  = X, the function yields X; otherwise, it yields the machine number of the type T 
adjacent to X in the direction of Towards , if that machine number exists. If the result would 
be outside the base range of S, Constraint_Error is raised. When T'Signed_Zeros is True, a 
zero result has the sign of X. When Towards  is zero, its sign has no bearing on the result.  
S'Copy_Sign S'Copy_Sign denotes a func tion with the following specification:  
function  S'Copy_Sign ( Value, Sign : T) 
  return T 
 If the value of Value  is nonzero, the function yields a result whose magnitude is that of 
Value  and whose sign is that of Sign; otherwise, it yields the va lue zero. Constraint_Error is 
optionally raised if the result is outside the base range of S. A zero result has the sign of 
Sign when S'Signed_Zeros is True.  
S'Leading_Part 
 S'Leading_Part denotes a function with the following specification:  
function  S'Leading_Part ( X : T; 
                         Radix_Digits  : universal_integer ) 
  return T 
 Let v be the value T'Machine_Radixk–Radix_Digits, where k is the normalized exponent of X. The 
function yields the value  
• X/v · v, when X is nonnegative and Radix_Digits  is positive; 
• X/v · v, when X is negative and Radix_Digits  is positive.  
 Constraint_Error is raised when Radix_Digits  is zero or negative. A zero result, which can 
only occur when X is zero, has the sign of X.  
S'Machine S'Machine denotes a function with the following specification:  41.1/2 
41.2/2 
41.3/2 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 59 
60 
Ada Reference Manual — 2012 Edition 
A.5.3    Attributes of Floating Poin t Types 13 December 2012      422 function  S'Machine ( X : T) 
  return T 
 If X is a machine number of the type T, the function yields X; otherwise, it yields the value 
obtained by rounding or truncating X to either one of the adjacent machine numbers of the 
type T. Constraint_Error is raised if rounding or truncating X to the precision of the 
machine numbers results in a va lue outside the base range of S. A zero result has the sign of 
X when S'Signed_Zeros is True.  
The following model-oriented attributes  are defined for any subtype S of a floating point type T.  
S'Model_Mantissa 
 If the Numerics Annex is not supported, this  attribute yields an implementation defined 
value that is greater than or equal to d · log(10) / log( T'Machine_Radix)  + 1, where d is 
the requested decimal precision of T, and less than or equal to the value of 
T'Machine_Mantissa. See G.2.2 for further re quirements that apply to implementations 
supporting the Numerics Annex. The value of this attribute is of the type universal_integer . 
S'Model_Emin 
 If the Numerics Annex is not supported, this  attribute yields an implementation defined 
value that is greater than or equal to the value of T'Machine_Emin. See G.2.2 for further 
requirements that apply to implementations supporting the Numerics Annex. The value of 
this attribute is of the type universal_integer . 
S'Model_Epsilon 
 Yields the value T'Machine_Radix1 – T'Model_Mantissa. The value of this attribute is of the type 
universal_real .  
S'Model_Small 
 Yields the value T'Machine_RadixT'Model_Emin – 1. The value of this attribute is of the type 
universal_real .  
S'Model S'Model denotes a function with the following specification:  
function  S'Model ( X : T) 
  return T 
 If the Numerics Annex is not supported, the meaning of this attri bute is implementation 
defined; see G.2.2 for the definition that  applies to implementations supporting the 
Numerics Annex. 
S'Safe_First 
 Yields the lower bound of the safe range (see 3.5.7) of the type T. If the Numerics Annex is 
not supported, the value of this attribute is  implementation defined; see G.2.2 for the 
definition that applies to implementations supporting the Numerics Annex. The value of 
this attribute is of the type universal_real . 
S'Safe_Last Yields the upper bound of the safe range (see 3.5.7) of the type T. If the Numerics Annex is 
not supported, the value of this attribute is  implementation defined; see G.2.2 for the 
definition that applies to implementations supporting the Numerics Annex. The value of 
this attribute is of the type universal_real .  
A.5.4 Attributes of Fixed Point Types 
Static Semantics 
The following representation-oriented  attributes are defined for every subtype S of a fixed point type T.  61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
1 
Ada Reference Manual — 2012 Edition 
423      13 December 2012 Attributes of Fixed Point Types   A.5.4 S'Machine_Radix 
 Yields the radix of the hardware representation of the type T. The value of this attribute is 
of the type universal_integer . 
S'Machine_Rounds 
 Yields the value True if rounding is perform ed on inexact results of every predefined 
operation that yields a result of the type T; yields the value False otherwise. The value of 
this attribute is of the predefined type Boolean. 
S'Machine_Overflows 
 Yields the value True if overflow and divide -by-zero are detected and reported by raising 
Constraint_Error for every predefined opera tion that yields a result of the type T; yields the 
value False otherwise. The valu e of this attribute is of th e predefined type Boolean.  
A.6 Input-Output 
Input-output is provided through language-defined packag es, each of which is a ch ild of the root package 
Ada. The generic packages Sequential_IO and Direct_I O define input-output operati ons applicable to files 
containing elements of a given type. The generic p ackage Storage_IO supports reading from and writing to 
an in-memory buffer. Additional opera tions for text input-output are supplied in the packages Text_IO, 
Wide_Text_IO, and Wide_Wide_Text _IO. Heterogeneous input-output  is provided through the child 
packages Streams.Stream_IO and Text_IO.Text_Str eams (see also 13.13). The package IO_Exceptions 
defines the exceptions needed by the predefined input-output packages.  
A.7 External Files and File Objects 
Static Semantics 
Values input from the external environment of the pr ogram, or output to the external environment, are 
considered to occupy external files . An external file can be anything external to the program that can 
produce a value to be read or receive a value to be wr itten. An external file is identified by a string (the 
name ). A second string (the form ) gives further system-dependent characteristics that may be associated 
with the file, such as the physical organizati on or access rights. The conventions governing the 
interpretation of such strings shall be documented. 
Input and output operations are expre ssed as operations on objects of some file type , rather than directly in 
terms of the external files. In the remainder of this clause, the term file is always used to refer to a file 
object; the term external file  is used otherwise. 
Input-output for sequential files of values of a singl e element type is defined by means of the generic 
package Sequential_IO. In order to define seque ntial input-output for a given element type, an 
instantiation of this generic unit, with the given type as actual parameter, has to be declared. The resulting 
package contains the declaration of a file type (called File_Type) for files of such elements, as well as the 
operations applicable to these files, such  as the Open, Read, and Write procedures. 
Input-output for direct access files is likewise defined by a generic package called Direct_IO. Input-output 
in human-readable form is defined by the (nongeneri c) packages Text_IO for Character and String data, 
Wide_Text_IO for Wide_Character and Wide _String data, and Wide_Wide_Text_IO for 
Wide_Wide_Character and Wide_Wide_String data. Input -output for files containing streams of elements 
representing values of possibly different types is  defined by means of the (nongeneric) package 
Streams.Stream_IO. 2 
3 
4 
1/2 
1 
2/3 
3 
4/2 
Ada Reference Manual — 2012 Edition 
A.7   External Files and File Objects 13 December 2012      424 Before input or output operations can be performed on a file, the file first has to be associated with an 
external file. While such an association is in effect, the file is said to be open , and otherwise the file is said 
to be closed . 
The language does not define what happens to external  files after the completion of the main program and 
all the library tasks (in particular, if corresponding file s have not been closed). The effect of input-output 
for access types is unspecified. 
An open file has a current mode , which is a value of one of the following enumeration types:  
type File_Mode is (In_File, Inout_File, Out_File);  --   for Direct_IO  
These values correspond respectivel y to the cases where only reading, both reading and writing, 
or only writing are to be performed.  
type File_Mode is (In_File, Out_File, Append_File); 
--  for Sequential_IO, Text_IO, Wide_Text _IO, Wide_Wide_Text_IO, and Stream_IO  
These values correspond respectively to the cas es where only reading, only writing, or only 
appending are to be performed. 
The mode of a file can be changed.  
Several file management operations are common to Sequential_IO, Direct_IO, Text_IO, Wide_Text_IO, 
and Wide_Wide_Text_IO. These operations are descri bed in subclause A.8.2 for sequential and direct 
files. Any additional effects concerning text i nput-output are described in subclause A.10.2. 
The exceptions that can be propagated by the executi on of an input-output subprogram are defined in the 
package IO_Exceptions; the situati ons in which they can be propagated are described following the 
description of the subprogram (and in subclause A. 13). The exceptions Storage_Error and Program_Error 
may be propagated. (Program_Error can only be propa gated due to errors made by the caller of the 
subprogram.) Finally, exceptions can be propagated in certain implementati on-defined situations.  
NOTES 
23  Each instantiation of the generic packages Sequential_IO and Direct_IO declares a different type File_Type. In the case of Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, and Streams.Stream_IO, the corresponding type File_Type is unique. 
24  A bidirectional device can often be modeled as two sequential files associated with the device, one of mode In_File, 
and one of mode Out_File. An implementation may restrict the number of files that may be associated with a given external file.  
A.8 Sequential and Direct Files 
Static Semantics 
Two kinds of access to external files are defined in this subclause: sequential access  and direct access . 
The corresponding file types and the associated ope rations are provided by the generic packages 
Sequential_IO and Direct_IO. A file object to be used for sequential access is called a sequential file , and 
one to be used for direct access is called a direct file . Access to stream file s is described in A.12.1. 
For sequential access, the file is viewed as a sequence of  values that are transferred in the order of their 
appearance (as produced by the program or by the exte rnal environment). When the file is opened with 
mode In_File or Out_File, transfer starts respectively from or to the beginning of the file. When the file is 
opened with mode Append_File, transf er to the file starts after th e last element of the file.  5 
6 
7 
8 
9 
10/2 
11 
12 
13/2 
14/3 
15/2 
16 
1/2 
2 
Ada Reference Manual — 2012 Edition 
425      13 December 2012 Sequential and Direct Files   A.8 For direct access, the file is viewed as a set of el ements occupying consecutive positions in linear order; a 
value can be transferred to or from an element of the file at any selected position. The position of an 
element is specified by its index , which is a number, greater than zero, of the implementation-defined 
integer type Count. The first element, if any, has index one; the index of the last element, if any, is called 
the current size ; the current size is zero if there are no elem ents. The current size is a property of the 
external file. 
An open direct file has a current index , which is the index that will be used by the next read or write 
operation. When a direct file is opened, the current inde x is set to one. The current index of a direct file is 
a property of a file object, not of an external file.  
A.8.1 The Generic Package Sequential_IO 
Static Semantics 
The generic library package Sequential_ IO has the following declaration:  
with Ada.IO_Exceptions; 
generic 
   type Element_Type(<>) is private; 
package Ada.Sequential_IO is 
   type File_Type is limited private; 
   type File_Mode is (In_File, Out_File, Append_File); 
   -- File management  
   procedure  Create(File : in out File_Type; 
                    Mode : in File_Mode := Out_File; 
                    Name : in String := ""; 
                    Form : in String := ""); 
   procedure  Open  (File : in out File_Type; 
                    Mode : in File_Mode; 
                    Name : in String; 
                    Form : in String := ""); 
   procedure  Close (File : in out File_Type); 
   procedure  Delete(File : in out File_Type); 
   procedure  Reset (File : in out File_Type; Mode : in File_Mode); 
   procedure  Reset (File : in out File_Type); 
   function  Mode   (File : in File_Type) return File_Mode; 
   function  Name   (File : in File_Type) return String; 
   function  Form   (File : in File_Type) return String; 
   function  Is_Open(File : in File_Type) return Boolean; 
   --  Input and output operations  
   procedure  Read  (File : in File_Type; Item : out Element_Type); 
   procedure  Write (File : in File_Type; Item : in Element_Type); 
   function  End_Of_File(File : in File_Type) return Boolean; 
   --  Exceptions  
   Status_Error : exception  renames IO_Exceptions.Status_Error; 
   Mode_Error   : exception  renames IO_Exceptions.Mode_Error; 
   Name_Error   : exception  renames IO_Exceptions.Name_Error; 
   Use_Error    : exception  renames IO_Exceptions.Use_Error; 
   Device_Error : exception  renames IO_Exceptions.Device_Error; 
   End_Error    : exception  renames IO_Exceptions.End_Error; 
   Data_Error   : exception  renames IO_Exceptions.Data_Error; 
private 
   ... -- not specified by the language  
end Ada.Sequential_IO; 3 
4 
1 
2 
3 
4 5 6 
7 
8 
9 
10 
11 12 
13 
14 15 
16 
Ada Reference Manual — 2012 Edition 
A.8.1    The Generic Package Sequential_IO 13 December 2012      426 The type File_Type needs finalization (see 7. 6) in every instantiation of Sequential_IO. 
A.8.2 File Management 
Static Semantics 
The procedures and functions described in this subcla use provide for the control of external files; their 
declarations are repeated in each of  the packages for sequential, direct, text, and stream input-output. For 
text input-output, the procedures Create, Open, and Re set have additional effect s described in subclause 
A.10.2.  
procedure  Create(File : in out File_Type; 
                 Mode : in File_Mode := default_mode ; 
                 Name : in String := ""; 
                 Form : in String := ""); 
Establishes a new external file, with the given na me and form, and associates this external file 
with the given file. The given file is left open. The current mode of the given file is set to the 
given access mode. The default access mode is the mode Out_File for sequential, stream, and text input-output; it is the mode Inout_File for di rect input-output. For direct access, the size of 
the created file is implementation defined. 
A null string for Name specifies an external file that is not accessible after the completion of the 
main program (a temporary file). A null string fo r Form specifies the use of the default options 
of the implementation for the external file. 
The exception Status_Error is propagated if th e given file is already open. The exception 
Name_Error is propagated if the string given as Name does not allow the identification of an 
external file. The exception Use_Error is propaga ted if, for the specified mode, the external 
environment does not support creation of an external  file with the given name (in the absence of 
Name_Error) and form. 
procedure  Open(File : in out File_Type; 
               Mode : in File_Mode; 
               Name : in String; 
               Form : in String := ""); 
Associates the given file with an existing extern al file having the given name and form, and sets 
the current mode of the given file to the given mode. The given file is left open. 
The exception Status_Error is propagated if th e given file is already open. The exception 
Name_Error is propagated if the string given as Name does not allow the identification of an 
external file; in particular, this exception is pr opagated if no external file with the given name 
exists. The exception Use_Error is propagated if, for the specified mode, the external 
environment does not support opening for an external file with the given name (in the absence of 
Name_Error) and form. 
procedure  Close(File : in out File_Type); 
Severs the association between the given file and its associated external file. The given file is 
left closed. In addition, for sequential files, if  the file being closed has mode Out_File or 
Append_File, then the last element written since the most recent open or reset is the last element 
that can be read from the file. If no elements ha ve been written and the file mode is Out_File, 
then the closed file is empty. If no elements ha ve been written and the file mode is Append_File, 
then the closed file is unchanged. 17/2 
1 
2 
3/2 
4 
5 
6 
7 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
427      13 December 2012 File Management   A.8.2 The exception Status_Error is propagated if the given file is not open. 
procedure  Delete(File : in out File_Type); 
Deletes the external file associated with the give n file. The given file is closed, and the external 
file ceases to exist. 
The exception Status_Error is propagated if the gi ven file is not open. The exception Use_Error 
is propagated if deletion of the external file is not supported by the external environment. 
procedure  Reset(File : in out File_Type; Mode : in File_Mode); 
procedure  Reset(File : in out File_Type); 
Resets the given file so that reading from its el ements can be restarted from the beginning of the 
external file (for modes In_File and Inout_File),  and so that writing to its elements can be 
restarted at the beginning of the external file (for modes Out_File and Inout_File) or after the 
last element of the external file (for mode A ppend_File). In particular, for direct access this 
means that the current index is set to one. If a M ode parameter is supplied, the current mode of 
the given file is set to the given mode. In addition,  for sequential files, if the given file has mode 
Out_File or Append_File when Reset is called, the last element written since the most recent 
open or reset is the last element that can be read  from the external file. If no elements have been 
written and the file mode is Out_File, the reset file is empty. If no elements have been written 
and the file mode is Append_File, th en the reset file is unchanged. 
The exception Status_Error is propagated if the file is not open. The exception Use_Error is 
propagated if the external environment does not s upport resetting for the external file and, also, 
if the external environment does not support resetti ng to the specified mode for the external file. 
function  Mode(File : in File_Type) return File_Mode; 
Returns the current mode of the given file. 
The exception Status_Error is propagated if the file is not open. 
function  Name(File : in File_Type) return String; 
Returns a string which uniquely identifies the extern al file currently associated with the given 
file (and may thus be used in an Open operation). 
The exception Status_Error is propagated if the gi ven file is not open. The exception Use_Error 
is propagated if the associated external file is  a temporary file that cannot be opened by any 
name. 
function  Form(File : in File_Type) return String; 
Returns the form string for the external file cu rrently associated with the given file. If an 
external environment allows alternative specifica tions of the form (for example, abbreviations 
using default options), the string returned  by the function should correspond to a full 
specification (that is, it should indicate explicitly all options selected, including default options). 
The exception Status_Error is propagated if the given file is not open. 
function  Is_Open(File : in File_Type) return Boolean; 
Returns True if the file is open (that is, if it is a ssociated with an external file); otherwise, returns 
False.  11 
12 
13 
14 
15 
16/2 
17 
18 
19 
20 
21 
22/2 
23 
24 
25 
26 
27 
28/3 
Ada Reference Manual — 2012 Edition 
A.8.2    File Management 13 December 2012      428 Implementation Permissions 
An implementation may propagate Name _Error or Use_Error if an attempt is made to use an I/O feature 
that cannot be supported by the implementation due to limitations in the external  environment. Any such 
restriction should be documented.  
A.8.3 Sequential Input-Output Operations 
Static Semantics 
The operations available for sequential input and output  are described in this subclause. The exception 
Status_Error is propagated if any of these operations  is attempted for a file that is not open.  
procedure  Read(File : in File_Type; Item : out Element_Type); 
Operates on a file of mode In_File. Reads an el ement from the given file, and returns the value 
of this element in the Item parameter.  
The exception Mode_Error is propagated if the m ode is not In_File. The exception End_Error is 
propagated if no more elements can be read from the given file. The exception Data_Error can 
be propagated if the element read cannot be inte rpreted as a value of th e subtype Element_Type 
(see A.13, “Exceptions in Input-Output”).  
procedure  Write(File : in File_Type; Item : in Element_Type); 
Operates on a file of mode Out_ File or Append_File. Writes the valu e of Item to the given file. 
The exception Mode_Error is propagated if the mode is not Out_File  or Append_File. The 
exception Use_Error is propagated if the cap acity of the external file is exceeded. 
function  End_Of_File(File : in File_Type) return Boolean; 
Operates on a file of mode In_File. Returns True if no more elements can be read from the given 
file; otherwise, returns False. 
The exception Mode_Error is propagate d if the mode is not In_File.  
A.8.4 The Generic Package Direct_IO 
Static Semantics 
The generic library package Direct_IO has the following declaration:  
with Ada.IO_Exceptions; 
generic 
   type Element_Type is private; 
package Ada.Direct_IO is 
   type File_Type is limited private; 
   type File_Mode is (In_File, Inout_File, Out_File); 
   type Count     is range 0 .. implementation-defined ; 
   subtype Positive_Count is Count range 1 .. Count'Last; 
   --  File management  
   procedure  Create(File : in out File_Type; 
                    Mode : in File_Mode := Inout_File; 
                    Name : in String := ""; 
                    Form : in String := ""); 29 
1 
2 
3 
4 
5 
6 
7 
8 
9/3 
10 
1 
2 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
429      13 December 2012 The Generic Package Direct_IO   A.8.4    procedure  Open  (File : in out File_Type; 
                    Mode : in File_Mode; 
                    Name : in String; 
                    Form : in String := ""); 
   procedure  Close (File : in out File_Type); 
   procedure  Delete(File : in out File_Type); 
   procedure  Reset (File : in out File_Type; Mode : in File_Mode); 
   procedure  Reset (File : in out File_Type); 
   function  Mode   (File : in File_Type) return File_Mode; 
   function  Name   (File : in File_Type) return String; 
   function  Form   (File : in File_Type) return String; 
   function  Is_Open(File : in File_Type) return Boolean; 
   --  Input and output operations  
   procedure  Read (File : in File_Type; Item : out Element_Type; 
                                        From : in Positive_Count); 
   procedure  Read (File : in File_Type; Item : out Element_Type); 
   procedure  Write(File : in File_Type; Item : in  Element_Type; 
                                        To   : in Positive_Count); 
   procedure  Write(File : in File_Type; Item : in Element_Type); 
   procedure  Set_Index(File : in File_Type; To : in Positive_Count); 
   function  Index(File : in File_Type) return Positive_Count; 
   function  Size (File : in File_Type) return Count; 
   function  End_Of_File(File : in File_Type) return Boolean; 
   --  Exceptions  
   Status_Error : exception  renames IO_Exceptions.Status_Error; 
   Mode_Error   : exception  renames IO_Exceptions.Mode_Error; 
   Name_Error   : exception  renames IO_Exceptions.Name_Error; 
   Use_Error    : exception  renames IO_Exceptions.Use_Error; 
   Device_Error : exception  renames IO_Exceptions.Device_Error; 
   End_Error    : exception  renames IO_Exceptions.End_Error; 
   Data_Error   : exception  renames IO_Exceptions.Data_Error; 
private 
   ... -- not specified by the language  
end Ada.Direct_IO; 
The type File_Type needs finalization (see 7. 6) in every instantiation of Direct_IO. 
A.8.5 Direct Input-Output Operations 
Static Semantics 
The operations available for direct input and output  are described in this subclause. The exception 
Status_Error is propagated if any of these operations  is attempted for a file that is not open.  
procedure  Read(File : in File_Type; Item : out Element_Type; 
                                    From : in  Positive_Count); 
procedure  Read(File : in File_Type; Item : out Element_Type); 
Operates on a file of mode In_File or Inout_File. In the case of the first form, sets the current 
index of the given file to the index value give n by the parameter From. Then (for both forms) 
returns, in the parameter Item, the value of the element whose position in the given file is 
specified by the current index of the file; finally, increases the current index by one. 
The exception Mode_Error is propagated if the mode  of the given file is Out_File. The exception 
End_Error is propagated if the index to be us ed exceeds the size of the external file. The 
exception Data_Error can be propagated if the elem ent read cannot be interpreted as a value of 
the subtype Element_Type (see A.13). 7 
8 
9 
10 
11 12 
13 14 
15 
16 
17 18 
19 
20/2 
1 
2 
3 
4 
Ada Reference Manual — 2012 Edition 
A.8.5    Direct Input-Out put Operations 13 December 2012      430 procedure  Write(File : in File_Type; Item : in Element_Type; 
                                     To   : in Positive_Count); 
procedure  Write(File : in File_Type; Item : in Element_Type); 
Operates on a file of mode Inout_F ile or Out_File. In the case of th e first form, sets the index of 
the given file to the index value given by th e parameter To. Then (for both forms) gives the 
value of the parameter Item to the element whos e position in the given file is specified by the 
current index of the file; finally, increases the current index by one. 
The exception Mode_Error is propagated if the mode  of the given file is In_File. The exception 
Use_Error is propagated if the capacity  of the external file is exceeded. 
procedure  Set_Index(File : in File_Type; To : in Positive_Count); 
Operates on a file of any mode. Sets the current index of the given file to the given index value 
(which may exceed the current size of the file). 
function  Index(File : in File_Type) return Positive_Count; 
Operates on a file of any mode. Return s the current index of the given file. 
function  Size(File : in File_Type) return Count; 
Operates on a file of any mode. Returns the current  size of the external file that is associated 
with the given file. 
function  End_Of_File(File : in File_Type) return Boolean; 
Operates on a file of mode In_File or Inout_File . Returns True if the current index exceeds the 
size of the external file; otherwise, returns False. 
The exception Mode_Error is propagated if th e mode of the given file is Out_File. 
NOTES 
25  Append_File mode is not supported for the generic package Direct_IO.  
A.9 The Generic Package Storage_IO 
The generic package Storage_IO provides for readi ng from and writing to an in-memory buffer. This 
generic package supports the construction of  user-defined input-output packages.  
Static Semantics 
The generic library package Storage_ IO has the following declaration:  
with Ada.IO_Exceptions; 
with System.Storage_Elements; 
generic 
   type Element_Type is private; 
package Ada.Storage_IO is 
   pragma Preelaborate(Storage_IO); 
   Buffer_Size : constant  System.Storage_Elements.Storage_Count := 
      implementation-defined ; 
   subtype Buffer_Type is 
      System.Storage_Elements.Storage_Array(1..Buffer_Size); 
   --  Input and output operations  
   procedure  Read (Buffer : in  Buffer_Type; Item : out Element_Type); 
   procedure  Write(Buffer : out Buffer_Type; Item : in  Element_Type); 5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15/3 
16 
17 
1 
2 
3 
4 
5 
6 7 
Ada Reference Manual — 2012 Edition 
431      13 December 2012 The Generic Package Storage_IO   A.9    --  Exceptions  
   Data_Error   : exception  renames IO_Exceptions.Data_Error; 
end Ada.Storage_IO; 
In each instance, the constant Buffer_Size has a value that is the size (in storage elements) of the buffer 
required to represent the content of an object of s ubtype Element_Type, includi ng any implicit levels of 
indirection used by the implementa tion. The Read and Write procedures of Storage_IO correspond to the 
Read and Write procedures of Direct_IO (see A.8.4), but  with the content of the Item parameter being read 
from or written into the specified Buffe r, rather than an external file. 
NOTES 
26  A buffer used for Storage_IO holds only one element at a time; an external file used for Direct_IO holds a sequence of elements.  
A.10 Text Input-Output 
Static Semantics 
This subclause describes the package Text_IO, wh ich provides facilities for input and output in human-
readable form. Each file is read or written sequentia lly, as a sequence of characters grouped into lines, and 
as a sequence of lines grouped into pages. The specifi cation of the package is given below in subclause 
A.10.1. 
The facilities for file management given above, in subcla uses A.8.2 and A.8.3, are available for text input-
output. In place of Read and Write, however, there are pr ocedures Get and Put that input values of suitable 
types from text files, and output values to them. Th ese values are provided to the Put procedures, and 
returned by the Get procedures, in a parameter Item. Several overloaded procedures  of these names exist, 
for different types of Item. These Get procedures analyze the input sequences of characters based on 
lexical elements (see Clause 2) and return the co rresponding values; the Put procedures output the given 
values as appropriate lexical elem ents. Procedures Get and Put are also available that input and output 
individual characters treated as charact er values rather than as lexical elements. Related to character input 
are procedures to look ahead at the next charact er without reading it, and to read a character 
“immediately” without waiting for an end-of-line to signal availability. 
In addition to the procedures Get and Put for numeric and enumeration types of It em that operate on text 
files, analogous procedures are provided that read fro m and write to a parameter of type String. These 
procedures perform the same analys is and composition of character seque nces as their counterparts which 
have a file parameter. 
For all Get and Put procedures that operate on text f iles, and for many other subprograms, there are forms 
with and without a file parameter. Each such Get procedure operates on an input file, and each such Put 
procedure operates on an output file. If no file is specifi ed, a default input file or a default output file is 
used. 
At the beginning of program execution the default input  and output files are the so-called standard input 
file and standard output file. These files are open,  have respectively the current modes In_File and 
Out_File, and are associated with two implementation- defined external files. Procedures are provided to 
change the current default input file and the current default output file.  
At the beginning of program execution a default file fo r program-dependent error-related text output is the 
so-called standard error file. This file is open, has the current mode Out_File, and is associated with an 
implementation-defined external file . A procedure is provided to change the current default error file. 8 
9 
10 
11 
1/3 
2/3 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
A.10    Text Input-Output 13 December 2012      432 From a logical point of view, a text file is a sequence of pages, a page is a sequence of lines, and a line is a 
sequence of characters; the end of a line is marked by a line terminator ; the end of a page is marked by the 
combination of a line terminator immediately followed by a page terminator ; and the end of a file is 
marked by the combination of a line terminator immediately followed by a page terminator and then a file 
terminator . Terminators are generated during output; either by calls of procedures provided expressly for 
that purpose; or implicitly as part of other opera tions, for example, when a bounded line length, a bounded 
page length, or both, have been specified for a file. 
The actual nature of terminators is not defined by the language and hence depends on the implementation. 
Although terminators are recognized or generated by certa in of the procedures that follow, they are not 
necessarily implemented as characters or as sequences  of characters. Whether they are characters (and if 
so which ones) in any particular implementation need  not concern a user who neither explicitly outputs nor 
explicitly inputs control characters. The effect of input  (Get) or output (Put) of control characters (other 
than horizontal tabulation) is not specified by the language.  
The characters of a line are numbered, starting from one; the number of a character is called its column 
number . For a line terminator, a column number is also  defined: it is one more than the number of 
characters in the line. The lines of a page, and the pages of a file, are similarly numbered. The current 
column number is the column number of the next char acter or line terminator to be transferred. The 
current line number is the number of  the current line. The current pa ge number is the number of the 
current page. These numbers are valu es of the subtype Positive_Count of  the type Count (by convention, 
the value zero of the type Count is us ed to indicate special conditions).  
type Count is range 0 .. implementation-defined ; 
subtype Positive_Count is Count range 1 .. Count'Last; 
For an output file or an append file, a maximum line length  can be specified and a maximum page length  
can be specified. If a value to be output cannot fit on the current line, for a specified maximum line length, 
then a new line is automatically started before the valu e is output; if, further, this new line cannot fit on the 
current page, for a specified maximu m page length, then a new page is  automatically started before the 
value is output. Functions are provided to determ ine the maximum line length and the maximum page 
length. When a file is opened with mode Out_File or Append_File, both values are zero: by convention, 
this means that the line lengths a nd page lengths are unbounded. (Conseque ntly, output consists of a single 
line if the subprograms for explicit control of line and page structure are not used.) The constant 
Unbounded is provided for this purpose.  
A.10.1 The Package Text_IO 
Static Semantics 
The library package Text_IO has the following declaration:  
with Ada.IO_Exceptions; 
package Ada.Text_IO is 
   type File_Type is limited private; 
   type File_Mode is (In_File, Out_File, Append_File); 
   type Count is range 0 .. implementation-defined ; 
   subtype Positive_Count is Count range 1 .. Count'Last; 
   Unbounded : constant  Count := 0; --  line and page length  
   subtype Field       is Integer range 0 .. implementation-defined ; 
   subtype Number_Base is Integer range 2 .. 16; 
   type Type_Set is (Lower_Case, Upper_Case); 
   --  File Management  7 
8 
9 
10 
11 
1 
2 
3 
4 5 
6 
7 
8 
Ada Reference Manual — 2012 Edition 
433      13 December 2012 The Package Text_IO   A.10.1    procedure  Create (File : in out File_Type; 
                     Mode : in File_Mode := Out_File; 
                     Name : in String    := ""; 
                     Form : in String    := ""); 
   procedure  Open   (File : in out File_Type; 
                     Mode : in File_Mode; 
                     Name : in String; 
                     Form : in String := ""); 
   procedure  Close  (File : in out File_Type); 
   procedure  Delete (File : in out File_Type); 
   procedure  Reset  (File : in out File_Type; Mode : in File_Mode); 
   procedure  Reset  (File : in out File_Type); 
   function   Mode   (File : in File_Type) return File_Mode; 
   function   Name   (File : in File_Type) return String; 
   function   Form   (File : in File_Type) return String; 
   function   Is_Open(File : in File_Type) return Boolean; 
   --  Control of default input and output files  
   procedure  Set_Input (File : in File_Type); 
   procedure  Set_Output(File : in File_Type); 
   procedure  Set_Error (File : in File_Type); 
   function  Standard_Input  return File_Type; 
   function  Standard_Output return File_Type; 
   function  Standard_Error  return File_Type; 
   function  Current_Input   return File_Type; 
   function  Current_Output  return File_Type; 
   function  Current_Error   return File_Type; 
   type File_Access is access constant  File_Type; 
   function  Standard_Input  return File_Access; 
   function  Standard_Output return File_Access; 
   function  Standard_Error  return File_Access; 
   function  Current_Input   return File_Access; 
   function  Current_Output  return File_Access; 
   function  Current_Error   return File_Access; 
--Buffer control  
   procedure  Flush (File : in File_Type); 
   procedure  Flush; 
   --  Specification of line and page lengths  
   procedure  Set_Line_Length(File : in File_Type; To : in Count); 
   procedure  Set_Line_Length(To   : in Count); 
   procedure  Set_Page_Length(File : in File_Type; To : in Count); 
   procedure  Set_Page_Length(To   : in Count); 
   function   Line_Length(File : in File_Type) return Count; 
   function   Line_Length return Count; 
   function   Page_Length(File : in File_Type) return Count; 
   function   Page_Length return Count; 
   --  Column, Line, and Page Control  
   procedure  New_Line   (File    : in File_Type; 
                         Spacing : in Positive_Count := 1); 
   procedure  New_Line   (Spacing : in Positive_Count := 1); 
   procedure  Skip_Line  (File    : in File_Type; 
                         Spacing : in Positive_Count := 1); 
   procedure  Skip_Line  (Spacing : in Positive_Count := 1); 
   function   End_Of_Line(File : in File_Type) return Boolean; 
   function   End_Of_Line return Boolean; 
   procedure  New_Page   (File : in File_Type); 
   procedure  New_Page; 9 
10 
11 
12 
13 
14 15 
16 17 18 
19 
20 
21/1 
22 
23 
24 25 26 27 
28 
29 30 
31 
Ada Reference Manual — 2012 Edition 
A.10.1    The Package Text_IO 13 December 2012      434    procedure  Skip_Page  (File : in File_Type); 
   procedure  Skip_Page; 
   function   End_Of_Page(File : in File_Type) return Boolean; 
   function   End_Of_Page return Boolean; 
   function   End_Of_File(File : in File_Type) return Boolean; 
   function   End_Of_File return Boolean; 
   procedure  Set_Col (File : in File_Type; To : in Positive_Count); 
   procedure  Set_Col (To   : in Positive_Count); 
   procedure  Set_Line(File : in File_Type; To : in Positive_Count); 
   procedure  Set_Line(To   : in Positive_Count); 
   function  Col (File : in File_Type) return Positive_Count; 
   function  Col  return Positive_Count; 
   function  Line(File : in File_Type) return Positive_Count; 
   function  Line return Positive_Count; 
   function  Page(File : in File_Type) return Positive_Count; 
   function  Page return Positive_Count; 
   --  Character Input-Output  
   procedure  Get(File : in  File_Type; Item : out Character); 
   procedure  Get(Item : out Character); 
   procedure  Put(File : in  File_Type; Item : in Character); 
   procedure  Put(Item : in  Character); 
   procedure  Look_Ahead (File        : in  File_Type; 
                         Item        : out Character; 
                         End_Of_Line : out Boolean); 
   procedure  Look_Ahead (Item        : out Character; 
                         End_Of_Line : out Boolean); 
   procedure  Get_Immediate(File      : in  File_Type; 
                           Item      : out Character); 
   procedure  Get_Immediate(Item      : out Character); 
   procedure  Get_Immediate(File      : in  File_Type; 
                           Item      : out Character; 
                           Available : out Boolean); 
   procedure  Get_Immediate(Item      : out Character; 
                           Available : out Boolean); 
   --  String Input-Output  
   procedure  Get(File : in  File_Type; Item : out String); 
   procedure  Get(Item : out String); 
   procedure  Put(File : in  File_Type; Item : in String); 
   procedure  Put(Item : in  String); 
   procedure  Get_Line(File : in  File_Type; 
                      Item : out String; 
                      Last : out Natural); 
   procedure  Get_Line(Item : out String; Last : out Natural); 
   function  Get_Line(File : in  File_Type) return String; 
   function  Get_Line return String; 
   procedure  Put_Line(File : in  File_Type; Item : in String); 
   procedure  Put_Line(Item : in  String); 
-- Generic packages for Input -Output of Integer Types  
   generic 
      type Num is range <>; 
   package Integer_IO is 
      Default_Width : Field := Num'Width; 
      Default_Base  : Number_Base := 10; 32 
33 34 35 36 37 38 39 40 
41 
42 43 
44 
45 
46 
47 
48 49 
49.1/2 
50 51 
52 
53 
Ada Reference Manual — 2012 Edition 
435      13 December 2012 The Package Text_IO   A.10.1       procedure  Get(File  : in  File_Type; 
                    Item  : out Num; 
                    Width : in Field := 0); 
      procedure  Get(Item  : out Num; 
                    Width : in  Field := 0); 
      procedure  Put(File  : in File_Type; 
                    Item  : in Num; 
                    Width : in Field := Default_Width; 
                    Base  : in Number_Base := Default_Base); 
      procedure  Put(Item  : in Num; 
                    Width : in Field := Default_Width; 
                    Base  : in Number_Base := Default_Base); 
      procedure  Get(From : in  String; 
                    Item : out Num; 
                    Last : out Positive); 
      procedure  Put(To   : out String; 
                    Item : in Num; 
                    Base : in Number_Base := Default_Base); 
   end Integer_IO; 
   generic 
      type Num is mod <>; 
   package Modular_IO is 
      Default_Width : Field := Num'Width; 
      Default_Base  : Number_Base := 10; 
      procedure  Get(File  : in  File_Type; 
                    Item  : out Num; 
                    Width : in Field := 0); 
      procedure  Get(Item  : out Num; 
                    Width : in  Field := 0); 
      procedure  Put(File  : in File_Type; 
                    Item  : in Num; 
                    Width : in Field := Default_Width; 
                    Base  : in Number_Base := Default_Base); 
      procedure  Put(Item  : in Num; 
                    Width : in Field := Default_Width; 
                    Base  : in Number_Base := Default_Base); 
      procedure  Get(From : in  String; 
                    Item : out Num; 
                    Last : out Positive); 
      procedure  Put(To   : out String; 
                    Item : in Num; 
                    Base : in Number_Base := Default_Base); 
   end Modular_IO; 
   --  Generic packages for Input -Output of Real Types  
   generic 
      type Num is digits <>; 
   package Float_IO is 
      Default_Fore : Field := 2; 
      Default_Aft  : Field := Num'Digits-1;       Default_Exp  : Field := 3; 
      procedure  Get(File  : in  File_Type; 
                    Item  : out Num; 
                    Width : in  Field := 0); 
      procedure  Get(Item  : out Num; 
                    Width : in  Field := 0); 54 
55 
56 
57 
58 
59 
60 
61 
62 63 
64 65 
Ada Reference Manual — 2012 Edition 
A.10.1    The Package Text_IO 13 December 2012      436       procedure  Put(File : in File_Type; 
                    Item : in Num; 
                    Fore : in Field := Default_Fore; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
      procedure  Put(Item : in Num; 
                    Fore : in Field := Default_Fore; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
      procedure  Get(From : in String; 
                    Item : out Num; 
                    Last : out Positive); 
      procedure  Put(To   : out String; 
                    Item : in Num; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
   end Float_IO; 
   generic 
      type Num is delta <>; 
   package Fixed_IO is 
      Default_Fore : Field := Num'Fore; 
      Default_Aft  : Field := Num'Aft;       Default_Exp  : Field := 0; 
      procedure  Get(File  : in  File_Type; 
                    Item  : out Num; 
                    Width : in  Field := 0); 
      procedure  Get(Item  : out Num; 
                    Width : in  Field := 0); 
      procedure  Put(File : in File_Type; 
                    Item : in Num; 
                    Fore : in Field := Default_Fore; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
      procedure  Put(Item : in Num; 
                    Fore : in Field := Default_Fore; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
      procedure  Get(From : in  String; 
                    Item : out Num; 
                    Last : out Positive); 
      procedure  Put(To   : out String; 
                    Item : in Num; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
   end Fixed_IO; 
   generic 
      type Num is delta <> digits <>; 
   package Decimal_IO is 
      Default_Fore : Field := Num'Fore; 
      Default_Aft  : Field := Num'Aft;       Default_Exp  : Field := 0; 
      procedure  Get(File  : in  File_Type; 
                    Item  : out Num; 
                    Width : in  Field := 0); 
      procedure  Get(Item  : out Num; 
                    Width : in  Field := 0); 66 
67 
68 
69 70 
71 
72 
73 
74 75 
Ada Reference Manual — 2012 Edition 
437      13 December 2012 The Package Text_IO   A.10.1       procedure  Put(File : in File_Type; 
                    Item : in Num; 
                    Fore : in Field := Default_Fore; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
      procedure  Put(Item : in Num; 
                    Fore : in Field := Default_Fore; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
      procedure  Get(From : in  String; 
                    Item : out Num; 
                    Last : out Positive); 
      procedure  Put(To   : out String; 
                    Item : in Num; 
                    Aft  : in Field := Default_Aft; 
                    Exp  : in Field := Default_Exp); 
   end Decimal_IO; 
   --  Generic package for Input-O utput of Enumeration Types  
   generic 
      type Enum is (<>); 
   package Enumeration_IO is 
      Default_Width   : Field := 0; 
      Default_Setting : Type_Set := Upper_Case; 
      procedure  Get(File : in  File_Type; 
                    Item : out Enum); 
      procedure  Get(Item : out Enum); 
      procedure  Put(File  : in File_Type; 
                    Item  : in Enum; 
                    Width : in Field    := Default_Width; 
                    Set   : in Type_Set := Default_Setting); 
      procedure  Put(Item  : in Enum; 
                    Width : in Field    := Default_Width; 
                    Set   : in Type_Set := Default_Setting); 
      procedure  Get(From : in  String; 
                    Item : out Enum; 
                    Last : out Positive); 
      procedure  Put(To   : out String; 
                    Item : in  Enum; 
                    Set  : in  Type_Set := Default_Setting); 
   end Enumeration_IO; 
-- Exceptions  
   Status_Error : exception  renames IO_Exceptions.Status_Error; 
   Mode_Error   : exception  renames IO_Exceptions.Mode_Error; 
   Name_Error   : exception  renames IO_Exceptions.Name_Error; 
   Use_Error    : exception  renames IO_Exceptions.Use_Error; 
   Device_Error : exception  renames IO_Exceptions.Device_Error; 
   End_Error    : exception  renames IO_Exceptions.End_Error; 
   Data_Error   : exception  renames IO_Exceptions.Data_Error; 
   Layout_Error : exception  renames IO_Exceptions.Layout_Error; 
private 
   ... -- not specified by the language  
end Ada.Text_IO; 
The type File_Type needs finalization (see 7.6). 
A.10.2 Text File Management 
Static Semantics 
The only allowed file modes for text files are the modes In_File, Out_F ile, and Append_File. The 
subprograms given in subclause A.8.2 for the control of  external files, and the function End_Of_File given 76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86/2 
1 
Ada Reference Manual — 2012 Edition 
A.10.2    Text File Management 13 December 2012      438 in subclause A.8.3 for sequential input-output, are also av ailable for text files. There is also a version of 
End_Of_File that refers to the current default input f ile. For text files, the procedures have the following 
additional effects:  
• For the procedures Create and Open: After a file  with mode Out_File or  Append_File is opened, 
the page length and line length are unbounded (both have the conventional value zero). After a 
file (of any mode) is opened, the current column , current line, and current page numbers are set 
to one. If the mode is Append_File, it is implemen tation defined whether a page terminator will 
separate preexisting text in the file from the new text to be written.  
• For the procedure Close: If the file has the curre nt mode Out_File or Append_File, has the effect 
of calling New_Page, unless the current page is already terminated; then outputs a file 
terminator. 
• For the procedure Reset: If the file has the curre nt mode Out_File or Append_File, has the effect 
of calling New_Page, unless the current page is already terminated; then outputs a file 
terminator. The current column, line, and page numbers are set to one, and the line and page 
lengths to Unbounded. If the new mode is Appe nd_File, it is implementa tion defined whether a 
page terminator will separate preexisting text in  the file from the new text to be written.  
The exception Mode_Error is propagated by the procedur e Reset upon an attempt to change the mode of a 
file that is the current default input file, the current default output file, or the current default error file.  
NOTES 
27  An implementation can define the Form parameter of Create and Open to control effects including the following:  
• the interpretation of line and column numbers for an interactive file, and 
• the interpretation of text formats in a file created by a foreign program.  
A.10.3 Default Input, Output, and Error Files 
Static Semantics 
The following subprograms provide for the control of the pa rticular default files that are used when a file 
parameter is omitted from a Get, Put, or other operati on of text input-output de scribed below, or when 
application-dependent error-related text is to be output.  
procedure  Set_Input(File : in File_Type); 
Operates on a file of mode In_File. Sets the current de fault input file to File. 
The exception Status_Error is propagated if the given file is not open. The exception 
Mode_Error is propagated if the mode of the given file is not In_File. 
procedure  Set_Output(File : in File_Type); 
procedure  Set_Error (File : in File_Type); 
Each operates on a file of mode Out_File or Append_File. Set_Output sets the current default 
output file to File. Set_Error sets the current de fault error file to File. The exception Status_Error 
is propagated if the given file is not open. Th e exception Mode_Error is propagated if the mode 
of the given file is not  Out_File or Append_File. 
function  Standard_Input return File_Type; 
function  Standard_Input return File_Access; 
Returns the standard input file (see A.10), or an  access value designating the standard input file, 
respectively. 2 
3 
4 
5 
6 
7 
8 
1 
2 
3 
4 
5 
6 
7 
8 
Ada Reference Manual — 2012 Edition 
439      13 December 2012 Default Input, Output, and Error Files   A.10.3 function  Standard_Output return File_Type; 
function  Standard_Output return File_Access; 
Returns the standard output file (see A.10) or  an access value designating the standard output 
file, respectively. 
function  Standard_Error return File_Type; 
function  Standard_Error return File_Access; 
Returns the standard error file (see A.10), or an  access value designating the standard error file, 
respectively. 
The Form strings implicitly associated with th e opening of Standard_Input, Standard_Output, and 
Standard_Error at the start of program execution are implementation defined.  
function  Current_Input return File_Type; 
function  Current_Input return File_Access; 
Returns the current default input file, or an access value designating the current default input 
file, respectively. 
function  Current_Output return File_Type; 
function  Current_Output return File_Access; 
Returns the current default output file, or an access value designating the current default output 
file, respectively. 
function  Current_Error return File_Type; 
function  Current_Error return File_Access; 
Returns the current default error file, or an acce ss value designating the current default error file, 
respectively. 
procedure  Flush (File : in File_Type); 
procedure  Flush; 
The effect of Flush is the same as the co rresponding subprogram in Streams.Stream_IO (see 
A.12.1). If File is not explicitly sp ecified, Current_Output is used.  
Erroneous Execution 
The execution of a program is erroneous if it invoke s an operation on a current default input, default 
output, or default error file, and if the correspondi ng file object is closed or no longer exists.  
This paragraph was deleted.  
NOTES 
28  The standard input, st andard output, and st andard error f iles cannot be ope ned, closed, reset, or  deleted, because the 
parameter File of the corresponding procedures has the mode in out. 
29  The standard input, st andard output, and st andard error f iles are different file  objects, but not n ecessarily different 
external files.  
A.10.4 Specification of Line and Page Lengths 
Static Semantics 
The subprograms described in this s ubclause are concerned with the line and page structure of a file of 
mode Out_File or Append_File. They operate either on the file given as the first parameter, or, in the 
absence of such a file parameter, on the current defau lt output file. They provide for output of text with a 
specified maximum line length or pa ge length. In these cases, line and page terminators are output 9 
10 
11 
12/1 
13 
14 
15 
16 
17 
18 
19 
20/1 
21 
22/1 
23/1 
24 
25 
1 
Ada Reference Manual — 2012 Edition 
A.10.4    Specification of Line and Page  Lengths 13 December 2012      440 implicitly and automatically when needed. When lin e and page lengths are unbounded (that is, when they 
have the conventional value zero), as in the case of a newly opened file, new lines and new pages are only 
started when explicitly called for. 
In all cases, the exception Status_Erro r is propagated if the file to be used is not open; the exception 
Mode_Error is propagated if the mode of th e file is not Out_File or Append_File.  
procedure  Set_Line_Length(File : in File_Type; To : in Count); 
procedure  Set_Line_Length(To   : in Count); 
Sets the maximum line length of the specified out put or append file to the number of characters 
specified by To. The value zero for To specifies an unbounded line length.  
The exception Use_Error is propagated if the sp ecified line length is inappropriate for the 
associated external file. 
procedure  Set_Page_Length(File : in File_Type; To : in Count); 
procedure  Set_Page_Length(To   : in Count); 
Sets the maximum page length of the specified output or append file to the number of lines 
specified by To. The value zero for To specifies an unbounded page length. 
The exception Use_Error is propagated if the sp ecified page length is inappropriate for the 
associated external file. 
function  Line_Length(File : in File_Type) return Count; 
function  Line_Length return Count; 
Returns the maximum line length currently set for the specified output or append file, or zero if 
the line length is unbounded. 
function  Page_Length(File : in File_Type) return Count; 
function  Page_Length return Count; 
Returns the maximum page length currently set for the specified output or append file, or zero if 
the page length is unbounded.  
A.10.5 Operations on Columns, Lines, and Pages 
Static Semantics 
The subprograms described in this subclause provide fo r explicit control of line and page structure; they 
operate either on the file given as the first parameter,  or, in the absence of such a file parameter, on the 
appropriate (input or output) current default file. The exception Status_Error is propagated by any of these 
subprograms if the file to be used is not open.  
procedure  New_Line(File : in File_Type; Spacing : in Positive_Count := 1); 
procedure  New_Line(Spacing : in Positive_Count := 1); 
Operates on a file of mode  Out_File or Append_File. 
For a Spacing of one: Outputs a line terminator a nd sets the current column number to one. Then 
increments the current line number by one, excep t in the case that the current line number is 
already greater than or equal to the maximum page length, for a bounded page length; in that 
case a page terminator is output, the current page  number is incremented by one, and the current 
line number is set to one. 
For a Spacing greater than one, the above  actions are perfo rmed Spacing times. 2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
1 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
441      13 December 2012 Operations on Columns, Lines, and Pages   A.10.5 The exception Mode_Error is propagated if th e mode is not Out_ File or Append_File. 
procedure  Skip_Line(File  : in File_Type; Spacing : in Positive_Count := 1); 
procedure  Skip_Line(Spacing : in Positive_Count := 1); 
Operates on a file of mode In_File. 
For a Spacing of one: Reads and discards all char acters until a line terminator has been read, and 
then sets the current column number to one. If th e line terminator is not immediately followed by 
a page terminator, the current  line number is incremented by one. Otherwise, if the line 
terminator is immediately followed by a page term inator, then the page terminator is skipped, 
the current page number is incremented by one , and the current line number is set to one. 
For a Spacing greater than one, the above  actions are perfo rmed Spacing times. 
The exception Mode_Error is propagated if the m ode is not In_File. The exception End_Error is 
propagated if an attempt is made to read a file terminator. 
function  End_Of_Line(File : in File_Type) return Boolean; 
function  End_Of_Line return Boolean; 
Operates on a file of mode In_File. Returns True if  a line terminator or a file terminator is next; 
otherwise, returns False. 
The exception Mode_Error is propagate d if the mode is not In_File. 
procedure  New_Page(File : in File_Type); 
procedure  New_Page; 
Operates on a file of mode Out_File or Append_F ile. Outputs a line terminator if the current line 
is not terminated, or if the curre nt page is empty (that is, if th e current column and line numbers 
are both equal to one). Then outputs a page termin ator, which terminates the current page. Adds 
one to the current page number and sets th e current column and line numbers to one. 
The exception Mode_Error is propagated if th e mode is not Out_ File or Append_File. 
procedure  Skip_Page(File : in File_Type); 
procedure  Skip_Page; 
Operates on a file of mode In_File. Reads and di scards all characters and line terminators until a 
page terminator has been read. Then adds one to  the current page number, and sets the current 
column and line numbers to one. 
The exception Mode_Error is propagated if the m ode is not In_File. The exception End_Error is 
propagated if an attempt is made to read a file terminator. 
function  End_Of_Page(File : in File_Type) return Boolean; 
function  End_Of_Page return Boolean; 
Operates on a file of mode In_File. Returns True  if the combination of a line terminator and a 
page terminator is next, or if a file term inator is next; otherwise, returns False. 
The exception Mode_Error is propagate d if the mode is not In_File. 
function  End_Of_File(File : in File_Type) return Boolean; 
function  End_Of_File return Boolean; 
Operates on a file of mode In_File. Returns True  if a file terminator is next, or if the 
combination of a line, a page, and a file term inator is next; otherwise, returns False. 6 
7 
8 
9 
10 
11 
12 
13/3 
14 
15 
16 
17 
18 
19 
20 
21 
22/3 
23 
24 
25/3 
Ada Reference Manual — 2012 Edition 
A.10.5    Operations on Columns, Lines, and Pages 13 December 2012      442 The exception Mode_Error is propagate d if the mode is not In_File. 
The following subprograms provide for the control of the current position of reading or writing in a file. In 
all cases, the default file is  the current output file.  
procedure  Set_Col(File : in File_Type; To : in Positive_Count); 
procedure  Set_Col(To   : in Positive_Count); 
If the file mode is Ou t_File or Append_File:  
• If the value specified by To is greater than the current column number, outputs spaces, 
adding one to the current column number after each space, until the current column number equals the specified value. If the value specified by To is equal to the current column number, there is no effect. If the value specified by To is less than the current column number, has the effect of calling New_Line (with a spacing of one), then 
outputs (To – 1) spaces, and sets the current column number to the specified value. 
• The exception Layout_Error is propagated if the value specified by To exceeds 
Line_Length when the line length is bounde d (that is, when it does not have the 
conventional value zero).  
If the file mode is In_File:  
• Reads (and discards) individual characters, line terminators, and page terminators, 
until the next character to be read has a co lumn number that equals the value specified 
by To; there is no effect if the current column number already equals this value. Each transfer of a character or terminator ma intains the current column, line, and page 
numbers in the same way as a Get procedur e (see A.10.6). (Short lines will be skipped 
until a line is reached that has a charact er at the specified column position.) 
• The exception End_Error is propagated if an atte mpt is made to read a file terminator.  
procedure  Set_Line(File : in File_Type; To : in Positive_Count); 
procedure  Set_Line(To   : in Positive_Count); 
If the file mode is Ou t_File or Append_File:  
• If the value specified by To is greater than the current line number, has the effect of 
repeatedly calling New_Line (with a spacing of one), until the current line number equals the specified value. If the value specified by To is equal to the current line number, there is no effect. If the value specified by To is less than the current line number, has the effect of calling New_Page follo wed, if To is greater than 1, by a call 
of New_Line with a spacing equal to (To – 1). 
• The exception Layout_Error is propagated if the value specified by To exceeds 
Page_Length when the page length is bounde d (that is, when it does not have the 
conventional value zero).  
If the mode is In_File:  
• Has the effect of repeatedly calling Skip_Line (with a spacing of one), until the current 
line number equals the value specified by To; there is no effect if the current line number already equals this value. (Short pa ges will be skipped until a page is reached 
that has a line at the specified line position.) 
• The exception End_Error is propagated if an atte mpt is made to read a file terminator.  
function  Col(File : in File_Type) return Positive_Count; 
function  Col return Positive_Count; 
Returns the current column number. 26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37/3 
38 
39 
40 
41 
42 
43 
Ada Reference Manual — 2012 Edition 
443      13 December 2012 Operations on Columns, Lines, and Pages   A.10.5 The exception Layout_Error is propagate d if this number exceeds Count'Last. 
function  Line(File : in File_Type) return Positive_Count; 
function  Line return Positive_Count; 
Returns the current line number. 
The exception Layout_Error is propagate d if this number exceeds Count'Last. 
function  Page(File : in File_Type) return Positive_Count; 
function  Page return Positive_Count; 
Returns the current page number. 
The exception Layout_Error is propagate d if this number exceeds Count'Last. 
The column number, line number, or page number are allowed to exceed Count'Last (as a consequence of 
the input or output of sufficiently many characters,  lines, or pages). These events do not cause any 
exception to be propagated. However, a call of Col,  Line, or Page propagates the exception Layout_Error 
if the corresponding number exceeds Count'Last.  
NOTES 
30  A page terminator is always skipped whenever the preceding line terminator is skipped. An implementation may represent the combination of these terminators by a single character, provided that it is properly recognized on input.  
A.10.6 Get and Put Procedures 
Static Semantics 
The procedures Get and Put for items of the type Ch aracter, String, numeric type s, and enumeration types 
are described in subsequent subclaus es. Features of these procedures that are common to most of these 
types are described in this subclause. The Get and Pu t procedures for items of type Character and String 
deal with individual character values; the Get and Pu t procedures for numeric and enumeration types treat 
the items as lexical elements. 
All procedures Get and Put have forms with a file parameter, written first. Where this parameter is 
omitted, the appropriate (input or output) current defau lt file is understood to be specified. Each procedure 
Get operates on a file of mode In_File. Each proce dure Put operates on a file of mode Out_File or 
Append_File. 
All procedures Get and Put maintain the current column , line, and page numbers of the specified file: the 
effect of each of these procedures upon these numbers is the result of the effects of individual transfers of 
characters and of individual output or skipping of terminat ors. Each transfer of a character adds one to the 
current column number. Each output of a line terminat or sets the current column number to one and adds 
one to the current line number. Each output of a page terminator sets the current column and line numbers 
to one and adds one to the current page number. Fo r input, each skipping of a line terminator sets the 
current column number to one and adds one to the cu rrent line number; each skipping of a page terminator 
sets the current column and line numbers to one a nd adds one to the current page number. Similar 
considerations apply to the procedur es Get_Line, Put_Line, and Set_Col. 
Several Get and Put procedures, for num eric and enumeration types, have format  parameters which 
specify field lengths; these parameters are of th e nonnegative subtype Field of the type Integer. 
Input-output of enumeration values uses the synt ax of the corresponding lexical elements. Any Get 
procedure for an enumeration type begins by skipping any leading blanks, or line or page terminators. A 
blank  is defined as a space or a horizontal tabulation ch aracter. Next, characters are input only so long as 44 
45 
46 
47 
48 
49 
50 
51 
52 
1 
2 
3 
4 
5/2 
Ada Reference Manual — 2012 Edition 
A.10.6    Get and Put Procedures 13 December 2012      444 the sequence input is an initial sequence of an identifie r or of a character literal (in particular, input ceases 
when a line terminator is encountered ). The character or line terminator that causes input to cease remains 
available for subsequent input. 
For a numeric type, the Get procedur es have a format parameter called Width. If the value given for this 
parameter is zero, the Get procedure proceeds in the same manner as for enumeration types, but using the syntax of numeric literals instead of that of enumer ation literals. If a nonzero value is given, then exactly 
Width characters are input, or the characters up to a line terminator, whichever comes first; any skipped 
leading blanks are included in the count. The syntax us ed for numeric literals is an extended syntax that 
allows a leading sign (but no intervening blanks, or line or page terminators) and that also allows (for real 
types) an integer literal as well as forms that have digits only before the point or only after the point. 
Any Put procedure, for an item of a numeric or an enumeration type, outputs the value of the item as a 
numeric literal, identifier, or character literal, as appr opriate. This is preceded by  leading spaces if required 
by the format parameters Width or Fore (as described in later subcla uses), and then a minus sign for a 
negative value; for an enumeration type, the spaces fo llow instead of leading. The format given for a Put 
procedure is overridden if it is insufficiently wide, by using the minimum needed width. 
Two further cases arise for Put procedures for numeric  and enumeration types, if the line length of the 
specified output file is bounded (that is, if it does not  have the conventional value zero). If the number of 
characters to be output does not exceed the maximum line length, but is such that they cannot fit on the current line, starting from the current column, then (i n effect) New_Line is called (with a spacing of one) 
before output of the item. Otherwise, if the numbe r of characters exceeds the maximum line length, then 
the exception Layout_Error is propagated and nothing is output. 
The exception Status_Error is propagated by any of the pr ocedures Get, Get_Line, Put, and Put_Line if the 
file to be used is not open. The exception Mode_Erro r is propagated by the procedures Get and Get_Line 
if the mode of the file to be used is not In_File; and by the procedures Put and Put_Line, if the mode is not 
Out_File or Append_File. 
The exception End_Error is propagated by a Get procedure if  an attempt is made to skip a file terminator. 
The exception Data_Error is propagated by a Get proce dure if the sequence finally input is not a lexical 
element corresponding to the type, in particular if no ch aracters were input; for this test, leading blanks are 
ignored; for an item of a numeric type, when a sign is  input, this rule applies to the succeeding numeric 
literal. The exception Layout_Error is propagated by a Put procedure that outputs to a parameter of type 
String, if the length of the actual string is insufficient for the output of the item.  
Examples 
In the examples, here and in subc lauses A.10.8 and A.10.9, the string quotes and the lower case letter b are 
not transferred: they are shown only to reveal the layout and spaces. 
N : Integer; 
   ... Get(N); 
--   Characters at input  Sequence input  Value of N  
 --   bb–12535b  –12535  –12535  
--   bb12_535e1b  12_535e1  125350  
--   bb12_535e;  12_535e  (none) Data_Error raised  
Example of overridden width parameter:  
Put(Item => -23, Width => 2);  --   "–23" 6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
Ada Reference Manual — 2012 Edition 
445      13 December 2012 Input-Output  of Characters and Strings   A.10.7 A.10.7 Input-Output of Characters and Strings 
Static Semantics 
For an item of type Character the following procedures are provided:  
procedure  Get(File : in File_Type; Item : out Character); 
procedure  Get(Item : out Character); 
After skipping any line terminators and any page terminators, reads the next character from the 
specified input file and returns the value of  this character in the out parameter Item. 
The exception End_Error is propagated if an atte mpt is made to skip a file terminator. 
procedure  Put(File : in File_Type; Item : in Character); 
procedure  Put(Item : in Character); 
If the line length of the specified output file is  bounded (that is, does not have the conventional 
value zero), and the current column number exceeds it, has the effect of calling New_Line with a 
spacing of one. Then, or otherwise, out puts the given character to the file. 
procedure  Look_Ahead (File        : in  File_Type; 
                      Item        : out Character; 
                      End_Of_Line : out Boolean); 
procedure  Look_Ahead (Item        : out Character; 
                      End_Of_Line : out Boolean); 
Status_Error is propagated if the file is not ope n. Mode_Error is propagated if the mode of the 
file is not In_File. Sets End_Of_Line to True if at  end of line, including if at end of page or at 
end of file; in each of these cases  the value of Item is not speci fied. Otherwise, End_Of_Line is 
set to False and Item is set to the next character (without consuming it) from the file. 
procedure  Get_Immediate(File : in  File_Type; 
                        Item : out Character); 
procedure  Get_Immediate(Item : out Character); 
Reads the next character, either control or graphi c, from the specified File or the default input 
file. Status_Error is propagated if the file is not  open. Mode_Error is propagated if the mode of 
the file is not In_File. End_Error is propagated if at the end of the file. The current column, line 
and page numbers for the file are not affected. 
procedure  Get_Immediate(File      : in  File_Type; 
                        Item      : out Character; 
                        Available : out Boolean); 
procedure  Get_Immediate(Item      : out Character; 
                        Available : out Boolean); 
If a character, either control or graphic, is ava ilable from the specified File or the default input 
file, then the character is read; Available is True  and Item contains the value of this character. If 
a character is not available, then Available is False and the value of Item is not specified. Status_Error is propagated if the file is not ope n. Mode_Error is propagated if the mode of the 
file is not In_File. End_Error is propagated if at the end of the file. The current column, line and 
page numbers for the file are not affected. 
For an item of type String the following subprograms are provided:  1 
2 
3 
4 
5 
6 
7 
8/3 
9 
10/3 
11 
12/3 
13/2 
Ada Reference Manual — 2012 Edition 
A.10.7    Input-Output of Characters a nd Strings 13 December 2012      446 procedure  Get(File : in File_Type; Item : out String); 
procedure  Get(Item : out String); 
Determines the length of the given string and attempts that number of Get operations for 
successive characters of the string (in particular, no operation is performed if the string is null). 
procedure  Put(File : in File_Type; Item : in String); 
procedure  Put(Item : in String); 
Determines the length of the given string and attempts that number of Put operations for 
successive characters of the string (in particular, no operation is performed if the string is null). 
function  Get_Line(File : in File_Type) return String; 
function  Get_Line return String; 
Returns a result string constructed by reading su ccessive characters from the specified input file, 
and assigning them to successive characters of the result string. The result string has a lower bound of 1 and an upper bound of the number of characters read. Reading stops when the end of the line is met; Skip_Line is then (i n effect) called with a spacing of 1. 
Constraint_Error is raised if the length of the line exceeds Positive'Last; in this case, the line 
number and page number are unchanged, and the co lumn number is unspecified but no less than 
it was before the call. The exception End_Error is propa gated if an attempt is made to skip a file 
terminator. 
procedure  Get_Line(File : in File_Type; 
                   Item : out String; 
                   Last : out Natural); 
procedure  Get_Line(Item : out String; 
                   Last : out Natural); 
Reads successive characters from the specified input file and assigns them to successive 
characters of the specified string. Reading stops if the end of the string is met. Reading also stops if the end of the line is met before meeting the end of the string; in this case Skip_Line is 
(in effect) called with a spacing of 1. The values of characters not assigned are not specified. 
If characters are read, returns in Last the index va lue such that Item(Last) is the last character 
assigned (the index of the first character assigned is Item'First). If no characters are read, returns in Last an index value that is one less than Item'First. The exception End_Error is propagated if 
an attempt is made to skip a file terminator. 
procedure  Put_Line(File : in File_Type; Item : in String); 
procedure  Put_Line(Item : in String); 
Calls the procedure Put for the given string, and then the procedure New_Line with a spacing of 
one.  
Implementation Advice 
The Get_Immediate procedures s hould be implemented with unbuffere d input. For a device such as a 
keyboard, input should be “available” if a key has alread y been typed, whereas for a disk file, input should 
always be available except at end of file. For a file associated with a keyboard-like device, any line-editing 
features of the underlying operating system should be disabled during the execution of Get_Immediate.  
NOTES 
31  Get_Immediate can be used to read a single key from the keyboard “immediately”; that is, without waiting for an end of line. In a call of Get_Immediate without the parameter Available, the caller will wait until a character is available. 14 
15 
16 
17 
17.1/2 
17.2/2 
17.3/2 
18 
19 
20 
21 
22 
23 
24 
Ada Reference Manual — 2012 Edition 
447      13 December 2012 Input-Output  of Characters and Strings   A.10.7 32  In a literal string parameter of Put, the enclosing string bracket characters are not output. Each doubled string bracket 
character in the enclosed string is output as a single string bracket character, as a consequence of the rule for string litera ls 
(see 2.6). 
33  A string read by Get or written by Put can extend over several lines. An implementation is allowed to assume that 
certain external files do not contain page terminators, in which case Get_Line and Skip_Line can return as soon as a line terminator is read.  
A.10.8 Input-Output for Integer Types 
Static Semantics 
The following procedures are defined in the generic p ackages Integer_IO and Modular_IO, which have to 
be instantiated for the appropriate signed integer or modular type respectively (indicated by Num in the 
specifications). 
Values are output as decimal or based literals, without low line characters or exponent, and, for 
Integer_IO, preceded by a minus sign if negative. The format (which includes any leading spaces and 
minus sign) can be specified by an optional field widt h parameter. Values of wi dths of fields in output 
formats are of the nonnegative integer subtype Field.  Values of bases are of the integer subtype 
Number_Base.  
subtype Number_Base is Integer range 2 .. 16; 
The default field width and base to be used by out put procedures are defined by the following variables 
that are declared in the generic p ackages Integer_IO and Modular_IO: 
Default_Width : Field := Num'Width; 
Default_Base  : Number_Base := 10; 
The following procedures are provided:  
procedure  Get(File : in File_Type; Item : out Num; Width : in Field := 0); 
procedure  Get(Item : out Num; Width : in Field := 0); 
If the value of the parameter Width is zero, skip s any leading blanks, line terminators, or page 
terminators, then reads a plus sign if present or  (for a signed type only) a minus sign if present, 
then reads the longest possible sequence of characters matching the syntax of a numeric literal without a point. If a nonzero value of Width is s upplied, then exactly Width characters are input, 
or the characters (possibly none) up to a line te rminator, whichever comes first; any skipped 
leading blanks are included in the count. 
Returns, in the parameter Item, the value of type Num that corresponds to the sequence input. 
The exception Data_Error is propagated if the seque nce of characters read does not form a legal 
integer literal or if the value obtained is not of the subtype Num. 
procedure  Put(File  : in File_Type; 
              Item  : in Num; 
              Width : in Field := Default_Width; 
              Base  : in Number_Base := Default_Base); 
 procedure  Put(Item  : in Num; 
              Width : in Field := Default_Width; 
              Base  : in Number_Base := Default_Base); 
Outputs the value of the parameter Item as an integer literal, with no low lines, no exponent, and 
no leading zeros (but a single zero for the value zero), and a preceding minus sign for a negative value. 25 
26 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10/3 
11 
12 
Ada Reference Manual — 2012 Edition 
A.10.8    Input-Output for Integer Types 13 December 2012      448 If the resulting sequence of characters to be output has fewer than Width characters, then leading 
spaces are first output to make up the difference. 
Uses the syntax for decimal literal if the parame ter Base has the value ten (either explicitly or 
through Default_Base); otherwise, uses the synt ax for based literal, with any letters in upper 
case. 
procedure  Get(From : in String; Item : out Num; Last : out Positive); 
Reads an integer value from the beginning of the given string, following the same rules as the 
Get procedure that reads an integer value from a f ile, but treating the end of the string as a file 
terminator. Returns, in the parameter Item, th e value of type Num that corresponds to the 
sequence input. Returns in Last the index value such  that From(Last) is th e last character read. 
The exception Data_Error is propagated if the se quence input does not have the required syntax 
or if the value obtained is not of the subtype Num. 
procedure  Put(To   : out String; 
              Item : in Num; 
              Base : in Number_Base := Default_Base); 
Outputs the value of the parameter Item to the gi ven string, following the same rule as for output 
to a file, using the length of the given string as the value for Width.  
Integer_Text_IO is a library package that is a nonge neric equivalent to Text_IO.Integer_IO for the 
predefined type Integer:  
with Ada.Text_IO; 
package Ada.Integer_Text_IO is new Ada.Text_IO.Integer_IO(Integer); 
For each predefined signed integer type, a nongeneric equi valent to Text_IO.Intege r_IO is provided, with 
names such as Ada.Long_Integer_Text_IO. 
Implementation Permissions 
The nongeneric equivalent packages may, but need not, be actual instantiations of the generic package for 
the appropriate predefined type. 
Paragraphs 24 and 25 were deleted.   
Examples 
subtype Byte_Int is Integer range -127 .. 127; 
package Int_IO is new Integer_IO(Byte_Int); use Int_IO; 
-- default format used at instantiation,  
-- Default_Width = 4, Default_Base = 10  
Put(126);                            --  "b126" 
Put(-126, 7);                        --  "bbb–126"  
Put(126, Width => 13, Base => 2);    --  "bbb2#1111110#"  
A.10.9 Input-Output for Real Types 
Static Semantics 
The following procedures are defined in the generi c packages Float_IO, Fixed_IO, and Decimal_IO, 
which have to be instantiated for the appropriate fl oating point, ordinary fixed point, or decimal fixed 
point type respectively (indicated by Num in the specifications). 13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
26/3 
27 
1 
Ada Reference Manual — 2012 Edition 
449      13 December 2012 Input-Output for Real Types   A.10.9 Values are output as decimal literals without low line characters. The format of each value output consists 
of a Fore field, a decimal point, an Aft field, and (if a nonzero Exp parameter is supplied) the letter E and 
an Exp field. The two possible formats thus correspond to: 
Fore  .  Aft 
and to: 
Fore  .  Aft  E  Exp 
without any spaces between these fi elds. The Fore field may include leading spaces, and a minus sign for 
negative values. The Aft field includes only decimal di gits (possibly with trailing zeros). The Exp field 
includes the sign (plus or minus) and the exponent (possibly with leading zeros). 
For floating point types, the default lengths of these fields are defined by the following variables that are 
declared in the generic package Float_IO: 
Default_Fore : Field := 2; 
Default_Aft  : Field := Num'Digits-1; Default_Exp  : Field := 3; 
For ordinary or decimal fixed point types, the defau lt lengths of these fields are defined by the following 
variables that are declared in the generic p ackages Fixed_IO and Decimal_IO, respectively: 
Default_Fore : Field := Num'Fore; 
Default_Aft  : Field := Num'Aft; Default_Exp  : Field := 0; 
The following procedures are provided:  
procedure  Get(File : in File_Type; Item : out Num; Width : in Field := 0); 
procedure  Get(Item : out Num; Width : in Field := 0); 
If the value of the parameter Width is zero, skip s any leading blanks, line terminators, or page 
terminators, then reads the longest possible seque nce of characters matching the syntax of any of 
the following (see 2.4):  
• [+|–] numeric_literal  
• [+|–] numeral .[exponent ] 
• [+|–]. numeral [exponent ] 
• [+|–] base #based_numeral .#[exponent ] 
• [+|–] base #.based_numeral #[exponent ]  
If a nonzero value of Width is supplied, then  exactly Width characters are input, or the 
characters (possibly none) up to a line terminator , whichever comes first; any skipped leading 
blanks are included in the count. 
Returns in the parameter Item the value of ty pe Num that corresponds to the sequence input, 
preserving the sign (positive if none has been sp ecified) of a zero value if Num is a floating 
point type and Num'Signed_Zeros is True. 
The exception Data_Error is propagated if the se quence input does not have the required syntax 
or if the value obtained is not of the subtype Num. 2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 16 17 18 19 
20 
21 
Ada Reference Manual — 2012 Edition 
A.10.9    Input-Output for Real T ypes 13 December 2012      450 procedure  Put(File : in File_Type; 
              Item : in Num; 
              Fore : in Field := Default_Fore; 
              Aft  : in Field := Default_Aft; 
              Exp  : in Field := Default_Exp); 
 procedure  Put(Item : in Num; 
              Fore : in Field := Default_Fore; 
              Aft  : in Field := Default_Aft; 
              Exp  : in Field := Default_Exp); 
Outputs the value of the parameter Item as a deci mal literal with the format defined by Fore, Aft 
and Exp. If the value is negative, or if Num is  a floating point type where Num'Signed_Zeros is 
True and the value is a negatively signed zero, th en a minus sign is included in the integer part. 
If Exp has the value zero, then the integer part to be output has as many digits as are needed to 
represent the integer part of the value of Item, overriding Fore if necessary, or consists of the 
digit zero if the value of Item has no integer part. 
If Exp has a value greater than zero, then the intege r part to be output has a single digit, which is 
nonzero except for the value 0.0 of Item. 
In both cases, however, if the integer part to be  output has fewer than Fore characters, including 
any minus sign, then leading spaces are first output to make up the difference. The number of digits of the fractional part is given by Aft, or is one if Aft equals zero. The value is rounded; a 
value of exactly one half in the last place is rounded away from zero. 
If Exp has the value zero, there is no exponent part . If Exp has a value greater than zero, then the 
exponent part to be output has as many digits as are needed to re present the exponent part of the 
value of Item (for which a single digit integer part  is used), and includes an initial sign (plus or 
minus). If the exponent part to be  output has fewer than Exp characters, including the sign, then 
leading zeros precede the digits, to make up the difference. For the value 0.0 of Item, the exponent has the value zero. 
procedure  Get(From : in String; Item : out Num; Last : out Positive); 
Reads a real value from the beginning of the give n string, following the same rule as the Get 
procedure that reads a real value from a file, but tr eating the end of the string as a file terminator. 
Returns, in the parameter Item, the value of type Num that corresponds to the sequence input. 
Returns in Last the index value such that  From(Last) is the last character read. 
The exception Data_Error is propagated if the se quence input does not have the required syntax, 
or if the value obtained is not of the subtype Num. 
procedure  Put(To   : out String; 
              Item : in Num; 
              Aft  : in Field := Default_Aft; 
              Exp  : in Field := Default_Exp); 
Outputs the value of the parameter Item to the gi ven string, following the same rule as for output 
to a file, using a value for Fore such that th e sequence of characters output exactly fills the 
string, including any leading spaces.  
Float_Text_IO is a library package that is a nongeneric equivalent to Text_IO.Float_IO for the predefined 
type Float:  
with Ada.Text_IO; 
package Ada.Float_Text_IO is new Ada.Text_IO.Float_IO(Float); 22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
Ada Reference Manual — 2012 Edition 
451      13 December 2012 Input-Output for Real Types   A.10.9 For each predefined floating point type, a nongeneric e quivalent to Text_IO.Floa t_IO is provided, with 
names such as Ada.Long_Float_Text_IO. 
Implementation Permissions 
An implementation may extend Get and Put for floati ng point types to support special values such as 
infinities and NaNs. 
The implementation of Put need not produce an output value with greater accuracy  than is supported for 
the base subtype. The additional accuracy, if any, of the value produced by Put when the number of 
requested digits in the integer and fractional parts exceeds the required accuracy is implementation defined.  
The nongeneric equivalent packages may, but need not, be actual instantiations of the generic package for 
the appropriate predefined type. 
NOTES 
34  For an item with a positive value, if output to a string exactly fills the string without leading spaces , then output of th e 
corresponding negative value will propagate Layout_Error. 
35  The rules for the Value attribute (see 3.5) and the rules for Get are based on the same set of formats.  
Examples 
This paragraph was deleted.  
package Real_IO is new Float_IO(Real); use Real_IO; 
-- default format used at instantiation, Default_Exp = 3  
X : Real := -123.4567;  --   digits 8      (see 3.5.7)  
Put(X);  -- default format   "–1.2345670E+02"  
Put(X, Fore => 5, Aft => 3, Exp => 2);  -- "bbb–1.235E+2"  
Put(X, 5, 3, 0);              -- "b–123.457"  
A.10.10 Input-Output for Enumeration Types 
Static Semantics 
The following procedures are defined in the generic p ackage Enumeration_IO, which has to be instantiated 
for the appropriate enumeration type (i ndicated by Enum in the specification). 
Values are output using either upper or lower case letters  for identifiers. This is specified by the parameter 
Set, which is of the enumeration type Type_Set. 
type Type_Set is (Lower_Case, Upper_Case); 
The format (which includes any trailing spaces) can be specified by an optional field width parameter. The 
default field width and letter case are defined by the following variables that are declared in the generic 
package Enumeration_IO: 
Default_Width   : Field := 0; 
Default_Setting : Type_Set := Upper_Case; 
The following procedures are provided:  
procedure  Get(File : in File_Type; Item : out Enum); 
procedure  Get(Item : out Enum); 
After skipping any leading blanks, line terminator s, or page terminators, reads an identifier 
according to the syntax of this lexical el ement (lower and upper case being considered 
equivalent), or a character literal according to th e syntax of this lexical element (including the 34 
35 
36 
37 
38 
39 
40/1 
41 
42 
43 
1 
2 
3 
4 
5 
6 
7 
8 
Ada Reference Manual — 2012 Edition 
A.10.10    Input-Output for Enumerati on Types 13 December 2012      452 apostrophes). Returns, in the parameter Item, th e value of type Enum that corresponds to the 
sequence input. 
The exception Data_Error is propagated if the se quence input does not have the required syntax, 
or if the identifier or character literal does not correspond to a value of the subtype Enum. 
procedure  Put(File  : in File_Type; 
              Item  : in Enum; 
              Width : in Field := Default_Width; 
              Set   : in Type_Set := Default_Setting); 
 procedure  Put(Item  : in Enum; 
              Width : in Field := Default_Width; 
              Set   : in Type_Set := Default_Setting); 
Outputs the value of the parameter Item as an  enumeration literal (either an identifier or a 
character literal). The optional parameter Set indi cates whether lower case or upper case is used 
for identifiers; it has no effect for character lite rals. If the sequence of characters produced has 
fewer than Width characters, then trailing spaces are finally output to make up the difference. If Enum is a character type, the sequence of char acters produced is as for Enum'Image(Item), as 
modified by the Width and Set parameters.  
procedure  Get(From : in String; Item : out Enum; Last : out Positive); 
Reads an enumeration value from the beginning of the given string, following the same rule as 
the Get procedure that reads an enumeration valu e from a file, but treating the end of the string 
as a file terminator. Returns, in the parameter Item, the value of type Enum that corresponds to 
the sequence input. Returns in Last the index valu e such that From(Last) is the last character 
read. 
The exception Data_Error is propagated if the se quence input does not have the required syntax, 
or if the identifier or character literal does not  correspond to a value of the subtype Enum.  
procedure  Put(To   : out String; 
              Item : in Enum; 
              Set  : in Type_Set := Default_Setting); 
Outputs the value of the parameter Item to the gi ven string, following the same rule as for output 
to a file, using the length of the given string as the value for Width.  
Although the specification of the generic package Enumeration_IO would allow instantiation for an 
integer type, this is not the intended purpose of this generic package, and the effect of such instantiations is 
not defined by the language.  
NOTES 
36  There is a difference between Put defined for characters, and for enumeration values. Thus  
   Ada.Text_IO.Put('A');  --   outputs the character A  
   package Char_IO is new Ada.Text_IO.Enumeration_IO(Character); 
   Char_IO.Put('A');  --   outputs the character 'A', between apostrophes  
37  The type Boolean is an enumeration type, hence Enumeration_IO can be instantiated for this type.  
A.10.11 Input-Output for Bounded Strings 
The package Text_IO.Bounded_IO provides input-output  in human-readable form  for Bounded_Strings.  9 
10 
11 
12 
13 
14 
15 
16 
17/1 
18 
19 
20 
21 
1/2 
Ada Reference Manual — 2012 Edition 
453      13 December 2012 Input-O utput for Bounded Strings   A.10.11 Static Semantics 
The generic library package Text_IO.B ounded_IO has the following declaration: 
with Ada.Strings.Bounded; 
generic 
   with package  Bounded is 
                     new Ada.Strings.Bounded.Generic_Bounded_Length (<>); 
package Ada.Text_IO.Bounded_IO is 
   procedure  Put 
      (File : in File_Type; 
       Item : in Bounded.Bounded_String); 
   procedure  Put 
      (Item : in Bounded.Bounded_String); 
   procedure  Put_Line 
      (File : in File_Type; 
       Item : in Bounded.Bounded_String); 
   procedure  Put_Line 
      (Item : in Bounded.Bounded_String); 
   function  Get_Line 
      (File : in File_Type) 
      return Bounded.Bounded_String; 
   function  Get_Line 
      return Bounded.Bounded_String; 
   procedure  Get_Line 
      (File : in File_Type; Item : out Bounded.Bounded_String); 
   procedure  Get_Line 
      (Item : out Bounded.Bounded_String); 
end Ada.Text_IO.Bounded_IO; 
For an item of type Bounded_String, the following subprograms are provided: 
procedure  Put 
   (File : in File_Type; 
    Item : in Bounded.Bounded_String); 
Equivalent to Text_IO.Put (F ile, Bounded.To_String(Item)); 
procedure  Put 
   (Item : in Bounded.Bounded_String); 
Equivalent to Text_IO.Pu t (Bounded.To_String(Item)); 
procedure  Put_Line 
   (File : in File_Type; 
    Item : in Bounded.Bounded_String); 
Equivalent to Text_IO.Put_Line  (File, Bounded.To_String(Item)); 
procedure  Put_Line 
   (Item : in Bounded.Bounded_String); 
Equivalent to Text_IO.Put_Li ne (Bounded.To_String(Item)); 
function  Get_Line 
   (File : in File_Type) 
   return Bounded.Bounded_String; 
Returns Bounded.To_Bounded_Stri ng(Text_IO.Get_Line(File)); 
function  Get_Line 
   return Bounded.Bounded_String; 
Returns Bounded.To_Bounded_Str ing(Text_IO.Get_Line); 2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
8/2 
9/2 
10/2 11/2 12/2 
13/2 
14/2 
15/2 
16/2 
17/2 
18/2 
19/2 
20/2 
21/2 
22/2 
23/2 
24/2 
25/2 
Ada Reference Manual — 2012 Edition 
A.10.11    Input-Output for Bounded St rings 13 December 2012      454 procedure  Get_Line 
   (File : in File_Type; Item : out Bounded.Bounded_String); 
Equivalent to Item := Get_Line (File); 
procedure  Get_Line 
   (Item : out Bounded.Bounded_String); 
Equivalent to Item := Get_Line;  
A.10.12 Input-Output for Unbounded Strings 
The package Text_IO.Unbounded_IO provides i nput-output in human-readable form for 
Unbounded_Strings.  
Static Semantics 
The library package Text_IO.Unbounded_IO has the following declaration: 
with Ada.Strings.Unbounded; 
package Ada.Text_IO.Unbounded_IO is 
   procedure  Put 
      (File : in File_Type; 
       Item : in Strings.Unbounded.Unbounded_String); 
   procedure  Put 
      (Item : in Strings.Unbounded.Unbounded_String); 
   procedure  Put_Line 
      (File : in File_Type; 
       Item : in Strings.Unbounded.Unbounded_String); 
   procedure  Put_Line 
      (Item : in Strings.Unbounded.Unbounded_String); 
   function  Get_Line 
      (File : in File_Type) 
      return Strings.Unbounded.Unbounded_String; 
   function  Get_Line 
      return Strings.Unbounded.Unbounded_String; 
   procedure  Get_Line 
      (File : in File_Type; Item : out Strings.Unbounded.Unbounded_String); 
   procedure  Get_Line 
      (Item : out Strings.Unbounded.Unbounded_String); 
end Ada.Text_IO.Unbounded_IO; 
For an item of type Unbounded_String, the following subprograms are provided: 
procedure  Put 
   (File : in File_Type; 
    Item : in Strings.Unbounded.Unbounded_String); 
Equivalent to Text_IO.Put (File , Strings.Unbounded.To_String(Item)); 
procedure  Put 
   (Item : in Strings.Unbounded.Unbounded_String); 
Equivalent to Text_IO.Put (S trings.Unbounded.To_String(Item)); 
procedure  Put_Line 
   (File : in File_Type; 
    Item : in Strings.Unbounded.Unbounded_String); 
Equivalent to Text_IO.Put_Line (F ile, Strings.Unbounded.To_String(Item)); 26/2 
27/2 
28/2 
29/2 
1/2 
2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
8/2 
9/2 
10/2 11/2 12/2 
13/2 
14/2 
15/2 
16/2 
17/2 
18/2 
19/2 
Ada Reference Manual — 2012 Edition 
455      13 December 2012 Input-O utput for Unbounded Strings   A.10.12 procedure  Put_Line 
   (Item : in Strings.Unbounded.Unbounded_String); 
Equivalent to Text_IO.Put_Line (Strings.Unbounded.To_String(Item)); 
function  Get_Line 
   (File : in File_Type) 
   return Strings.Unbounded.Unbounded_String; 
Returns Strings.Unbounded.To_Unbounded_Str ing(Text_IO.Get_Line(File)); 
function  Get_Line 
   return Strings.Unbounded.Unbounded_String; 
Returns Strings.Unbounded.To_Unbounded_S tring(Text_IO.Get_Line); 
procedure  Get_Line 
   (File : in File_Type; Item : out Strings.Unbounded.Unbounded_String); 
Equivalent to Item := Get_Line (File); 
procedure  Get_Line 
   (Item : out Strings.Unbounded.Unbounded_String); 
Equivalent to Item := Get_Line;  
A.11 Wide Text Input-Output and Wide Wide Text Input-Output 
The packages Wide_Text_IO and Wide_Wide_Text_I O provide facilities for input and output in human-
readable form. Each file is read or written sequentia lly, as a sequence of wide characters (or wide wide 
characters) grouped into lines, and as a sequence of lines grouped into pages.  
Static Semantics 
The specification of package Wide_Text_IO is the same  as that for Text_IO, except that in each Get, 
Look_Ahead, Get_Immediate, Get_Line, Put, and Put_ Line subprogram, any occu rrence of Character is 
replaced by Wide_Character, and any occurrence of  String is replaced by Wide_String. Nongeneric 
equivalents of Wide_Text_IO.Integ er_IO and Wide_Text_IO.Float_IO ar e provided (as for Text_IO) for 
each predefined numeric type, with names such as Ada.Integer_Wide_Text_IO, Ada.Long_Integer_-
Wide_Text_IO, Ada.Float_Wide_Text_ IO, Ada.Long_Float_Wide_Text_IO. 
The specification of package Wide_Wide_Text_IO is th e same as that for Text_IO, except that in each 
Get, Look_Ahead, Get_Immediate, Get_Line, Put, a nd Put_Line subprogram, any occurrence of Character 
is replaced by Wide_Wide_Character, and any occurrence of String is replaced by Wide_Wide_String. Nongeneric equivalents of Wide_W ide_Text_IO.Integer_IO and Wi de_Wide_Text_IO.Float_IO are 
provided (as for Text_IO) for each predefined num eric type, with names such as Ada.Integer_-
Wide_Wide_Text_IO, Ada.Long_Integer_Wide_Wi de_Text_IO, Ada.Float_Wide_Wide_Text_IO, 
Ada.Long_Float_Wide_Wide_Text_IO. 
The specification of package Wide_Text_IO.W ide_Bounded_IO is the same as that for 
Text_IO.Bounded_IO, except that any occurrence of Bounded_String is replaced by Bounded_Wide_-
String, and any occurrence of package Bounded is  replaced by Wide_Bounded. The specification of 
package Wide_Wide_Text_IO.Wide_Wide_Bounded_IO is  the same as that for Text_IO.Bounded_IO, 
except that any occurrence of Bounded_String is replaced by Bounded_Wide_Wide_String, and any 
occurrence of package Bounded is replaced by Wide_Wide_Bounded. 
The specification of package Wide_Text_IO.Wide_ Unbounded_IO is the same as that for Text_IO.-
Unbounded_IO, except that any occurrence of Unbounded_String is replaced by Unbounded_Wide_-
String, and any occurrence of package Unbounded is  replaced by Wide_Unbounded. The specification of 20/2 
21/2 
22/2 
23/2 
24/2 
25/2 
26/2 
27/2 
28/2 
29/2 
1/2 
2/2 
3/2 
4/3 
5/3 
Ada Reference Manual — 2012 Edition 
A.11    Wide Text Input-Output and Wide Wide Text Input-Out put 13 December 2012      456 package Wide_Wide_Text_IO.Wide_Wide_ Unbounded_IO is the same as that for 
Text_IO.Unbounded_IO, except that any occurren ce of Unbounded_String is replaced by Unbounded_-
Wide_Wide_String, and any occurrence of packag e Unbounded is replaced by Wide_Wide_Unbounded.  
A.12 Stream Input-Output 
The packages Streams.Stream_IO, Text_IO.Te xt_Streams, Wide_Text_IO.Text_Streams, and 
Wide_Wide_Text_IO.Text_Streams provide stream-oriented operations on files.  
A.12.1 The Package Streams.Stream_IO 
The subprograms in the child package Streams.Stream_I O provide control over stream files. Access to a 
stream file is either sequential, via a call on Read or  Write to transfer an array of stream elements, or 
positional (if supported by the implem entation for the given file), by specifying a relative index for an 
element. Since a stream file can be converted to a Stream_Access value, calling stream-oriented attribute 
subprograms of different element types with the sa me Stream_Access value provi des heterogeneous input-
output. See 13.13 for a general discussion of streams.  
Static Semantics 
The elements of a stream file are stream elements . If positioning is supported for the specified external 
file, a current index and current size are maintained fo r the file as described in A.8. If positioning is not 
supported, a current index is not maintained, a nd the current size is implementation defined.  
The library package Streams.Stream_IO has the following declaration:  
with Ada.IO_Exceptions; 
package Ada.Streams.Stream_IO is 
    pragma Preelaborate(Stream_IO); 
    type Stream_Access is access all Root_Stream_Type'Class; 
    type File_Type is limited private;  
    type File_Mode is (In_File, Out_File, Append_File); 
    type    Count          is range 0 .. implementation-defined ; 
    subtype Positive_Count is Count range 1 .. Count'Last; 
      -- Index into file, in stream elements.  
    procedure  Create (File : in out File_Type; 
                      Mode : in File_Mode := Out_File; 
                      Name : in String    := ""; 
                      Form : in String    := ""); 
    procedure  Open (File : in out File_Type; 
                    Mode : in File_Mode; 
                    Name : in String; 
                    Form : in String := ""); 
    procedure  Close  (File : in out File_Type); 
    procedure  Delete (File : in out File_Type); 
    procedure  Reset  (File : in out File_Type; Mode : in File_Mode); 
    procedure  Reset  (File : in out File_Type); 
    function  Mode (File : in File_Type) return File_Mode; 
    function  Name (File : in File_Type) return String; 
    function  Form (File : in File_Type) return String; 
    function  Is_Open     (File : in File_Type) return Boolean; 
    function  End_Of_File (File : in File_Type) return Boolean; 
    function  Stream (File : in File_Type) return Stream_Access; 
        -- Return stream access for use with T'Input and T'Output  1/2 
1 
1.1/1 
2 
3/3 
4 
5 6 7 
8 
9 
10 
11 
12 
13 
Ada Reference Manual — 2012 Edition 
457      13 December 2012 The P ackage Streams.Stream_IO   A.12.1 This paragraph was deleted.  
    -- Read array of stream elements from file  
    procedure  Read (File : in  File_Type; 
                    Item : out Stream_Element_Array; 
                    Last : out Stream_Element_Offset; 
                    From : in  Positive_Count); 
    procedure  Read (File : in  File_Type; 
                    Item : out Stream_Element_Array; 
                    Last : out Stream_Element_Offset); 
This paragraph was deleted.  
    -- Write array of stream elements into file  
    procedure  Write (File : in File_Type; 
                     Item : in Stream_Element_Array; 
                     To   : in Positive_Count); 
    procedure  Write (File : in File_Type; 
                           Item : in Stream_Element_Array); 
This paragraph was deleted.  
    -- Operations on position within file  
    procedure  Set_Index(File : in File_Type; To : in Positive_Count); 
    function  Index(File : in File_Type) return Positive_Count; 
    function  Size (File : in File_Type) return Count; 
    procedure  Set_Mode(File : in out File_Type; Mode : in File_Mode); 
    procedure  Flush(File : in File_Type); 
    -- exceptions 
    Status_Error : exception  renames IO_Exceptions.Status_Error; 
    Mode_Error   : exception  renames IO_Exceptions.Mode_Error; 
    Name_Error   : exception  renames IO_Exceptions.Name_Error; 
    Use_Error    : exception  renames IO_Exceptions.Use_Error; 
    Device_Error : exception  renames IO_Exceptions.Device_Error; 
    End_Error    : exception  renames IO_Exceptions.End_Error; 
    Data_Error   : exception  renames IO_Exceptions.Data_Error; 
private 
   ... -- not specified by the language  
end Ada.Streams.Stream_IO; 
The type File_Type needs finalization (see 7.6). 
The subprograms given in subclause A.8.2 for the contro l of external files (Create, Open, Close, Delete, 
Reset, Mode, Name, Form, and Is_Open)  are available for stream files. 
The End_Of_File function:  
• Propagates Mode_Error if the mode  of the file is not In_File; 
• If positioning is supported for the given external file, the function returns True if the current 
index exceeds the size of the external file; otherwise, it returns False; 
• If positioning is not supported for the given extern al file, the function returns True if no more 
elements can be read from the given file; otherwise, it returns False.  
The Set_Mode procedure sets the mode of the file. If the new mode is Append_File, the file is positioned 
to its end; otherwise, the pos ition in the file is unchanged. 
The Flush procedure synchronizes the external file with  the internal file (by flushing any internal buffers) 
without closing the file or changing the position. Mode _Error is propagated if the mode of the file is 
In_File. 14/1 
15 
16 
17/1 
18 
19 
20/1 
21 22 23 
24 
25/1 
26 
27 
27.1/2 
28/2 
28.1/2 
28.2/2 
28.3/3 
28.4/3 28.5/2 
28.6/1 
Ada Reference Manual — 2012 Edition 
A.12.1    The Package Streams.Str eam_IO 13 December 2012      458 The Stream function returns a Stream_Access result from a File_Type object, thus allowing the stream-
oriented attributes Read, Write, Input, and Output to be used on the same file for multiple types. Stream 
propagates Status_Error if File is not open. 
The procedures Read and Write are equivalent to the corresponding operations in the package Streams. 
Read propagates Mode_Error if the mode of File is not In_File. Write propagates Mode_Error if the mode 
of File is not Out_File or A ppend_File. The Read procedure with a Positive_Count parameter starts 
reading at the specified index. The Write procedure with a Positive_Count parameter starts writing at the 
specified index. For a file that supports positioning,  Read without a Positive_Count parameter starts 
reading at the current index, and Write without a Po sitive_Count parameter starts writing at the current 
index. 
The Size function returns the current size of the file. The Index function returns the current index.  The Set_Index procedure sets the current index to the specified value. If positioning is supported for the external file, the current index is maintained as follows: 
• For Open and Create, if the Mode parameter is Append_File, the current index is set to the 
current size of the file plus one; otherw ise, the current index is set to one. 
• For Reset, if the Mode parameter is Append_File , or no Mode parameter is given and the current 
mode is Append_File, the current i ndex is set to the current size of  the file plus one; otherwise, 
the current index is set to one. 
• For Set_Mode, if the new mode is Append_File, the current index is  set to current size plus one; 
otherwise, the current index is unchanged. 
• For Read and Write without a Positive_Count para meter, the current index is incremented by the 
number of stream elements read or written. 
• For Read and Write with a Positive_Count paramete r, the value of the current index is set to the 
value of the Positive_Count parameter plus the number of stream elements read or written.  
If positioning is not supported for the given file, then a call of Index or Set_Index propagates Use_Error. 
Similarly, a call of Read or Write with a Positive_Count parameter propagates Use_Error. 
Paragraphs 34 through 36 were deleted.   
Erroneous Execution 
If the File_Type object passed to the Stream function is later closed or finalized, and the stream-oriented 
attributes are subsequently called (explicitly or implicitly) on the Stream_Access value returned by 
Stream, execution is erroneous. This rule applies even if the File_Type object was opened again after it had been closed.  
A.12.2 The Package Text_IO.Text_Streams 
The package Text_IO.Text_Streams provides a func tion for treating a text file as a stream.  
Static Semantics 
The library package Text_IO.Text_Streams has the following declaration:  
with Ada.Streams; 
package Ada.Text_IO.Text_Streams is 
   type Stream_Access is access all Streams.Root_Stream_Type'Class; 29/1 
30/2 
30.1/1 
31/1 
32 
32.1/1 
32.2/1 
32.3/1 
32.4/1 
32.5/1 32.6/1 
33 
36.1/1 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
459      13 December 2012 The Package Text_IO.Text_Streams   A.12.2    function  Stream (File : in File_Type) return Stream_Access; 
end Ada.Text_IO.Text_Streams; 
The Stream function has the same effect as th e corresponding function in Streams.Stream_IO.  
NOTES 
38  The ability to obtain a stream for a text file allows Current_Input, Current_Output, and Current_Error to be processed with the functionality of streams, including the mixing of text and binary input-output, and the mixing of binary input-output for different types. 
39  Performing operations on the stream associated with a text file does not affect the column, line, or page counts.  
A.12.3 The Package Wide_Text_IO.Text_Streams 
The package Wide_Text_IO.Text_Streams provides a func tion for treating a wide text file as a stream.  
Static Semantics 
The library package Wide_Text_IO.Text_St reams has the following declaration:  
with Ada.Streams; 
package Ada.Wide_Text_IO.Text_Streams is 
   type Stream_Access is access all Streams.Root_Stream_Type'Class; 
   function  Stream (File : in File_Type) return Stream_Access; 
end Ada.Wide_Text_IO.Text_Streams; 
The Stream function has the same effect as th e corresponding function in Streams.Stream_IO.  
A.12.4 The Package Wide_Wide_Text_IO.Text_Streams 
The package Wide_Wide_Text_IO.Text_Streams provides a function for treating a wide wide text file as a 
stream.  
Static Semantics 
The library package Wide_Wide_Text_IO.Text _Streams has the following declaration:  
with Ada.Streams; 
package Ada.Wide_Wide_Text_IO.Text_Streams is 
   type Stream_Access is access all Streams.Root_Stream_Type'Class; 
   function  Stream (File : in File_Type) return Stream_Access; 
end Ada.Wide_Wide_Text_IO.Text_Streams; 
The Stream function has the same effect as th e corresponding function in Streams.Stream_IO.  
A.13 Exceptions in Input-Output 
The package IO_Exceptions defines the exceptions needed by the pred efined input-output packages.  
Static Semantics 
The library package IO_Exceptions has the following declaration:  
package Ada.IO_Exceptions is 
   pragma Pure(IO_Exceptions); 4 
5 
6 
7 
1 
2 
3 
4 
5 
1/2 
2/2 
3/2 
4/2 
5/2 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
A.13    Exceptions in Input-Out put 13 December 2012      460    Status_Error : exception ; 
   Mode_Error   : exception ; 
   Name_Error   : exception ; 
   Use_Error    : exception ; 
   Device_Error : exception ; 
   End_Error    : exception ; 
   Data_Error   : exception ; 
   Layout_Error : exception ; 
end Ada.IO_Exceptions; 
If more than one error condition exists, the corres ponding exception that appears earliest in the following 
list is the one that is propagated. 
The exception Status_Error is propagated by an attempt to operate upon a file that is not open, and by an 
attempt to open a file that is already open. 
The exception Mode_Error is propagated by an attempt to  read from, or test for the end of, a file whose 
current mode is Out_File or Append_F ile, and also by an attempt to write  to a file whose current mode is 
In_File. In the case of Text_IO, th e exception Mode_Error is also propagated by specifying a file whose 
current mode is Out_File or Appe nd_File in a call of Set_Input, Skip_Line, End_Of_Line, Skip_Page, or 
End_Of_Page; and by specifying a file whose curre nt mode is In_File in a call of Set_Output, 
Set_Line_Length, Set_Page_Le ngth, Line_Length, Page_Lengt h, New_Line, or New_Page. 
The exception Name_Error is propagated by a call of Cr eate or Open if the string given for the parameter 
Name does not allow the identification of an external file. For example, this exception is propagated if the 
string is improper, or, alternatively, if either none or more than one external file corresponds to the string. 
The exception Use_Error is propagated if an operation is  attempted that is not possible for reasons that 
depend on characteristics of the external file. For exam ple, this exception is propagated by the procedure 
Create, among other circumstances, if the given mode is Out_File but the form specifies an input only 
device, if the parameter Form specifies invalid access ri ghts, or if an external file with the given name 
already exists and overwriting is not allowed. 
The exception Device_Error is propagated if an input -output operation cannot be completed because of a 
malfunction of the underlying system. 
The exception End_Error is propagated by an atte mpt to skip (read past) the end of a file. 
The exception Data_Error can be propagated by the pro cedure Read (or by the Read attribute) if the 
element read cannot be interpreted as  a value of the required subtype. This exception is also propagated by 
a procedure Get (defined in the package Text_IO) if  the input character sequence fails to satisfy the 
required syntax, or if the value input does not belong to the range of the required subtype. 
The exception Layout_Error is propagated (in text input-out put) by Col, Line, or Page if the value returned 
exceeds Count'Last. The exception Layout_Error is also propagated on output by an attempt to set column 
or line numbers in excess of specified maximum line or page lengths, respectively (excluding the 
unbounded cases). It is also propagated by an atte mpt to Put too many characters to a string. 
These exceptions are also propagated by various othe r language-defined packages  and operations, see the 
definition of those entities for other reasons  that these exceptions are propagated. 
Documentation Requirements 
The implementation shall document the conditions under which Name_Erro r, Use_Error and Device_Error 
are propagated.  4 
5 
6 
7 8 
9 
10 
11 
12 
13 
14 
14.1/3 
15 
Ada Reference Manual — 2012 Edition 
461      13 December 2012 Excep tions in Input-Output   A.13 Implementation Permissions 
If the associated check is too complex, an implemen tation need not propagate Data_Error as part of a 
procedure Read (or the Read attribute) if the value read cannot be interpreted as a value of the required 
subtype.  
Erroneous Execution 
If the element read by the procedure Read (or by the R ead attribute) cannot be interpreted as a value of the 
required subtype, but this is not de tected and Data_Error is not propagate d, then the resulting value can be 
abnormal, and subsequent references to the value can l ead to erroneous execution, as explained in 13.9.1.  
A.14 File Sharing 
Dynamic Semantics 
It is not specified by the language whether the same exte rnal file can be associated with more than one file 
object. If such sharing is supported by the implem entation, the following effects are defined:  
• Operations on one text file object do not affect the column, line, and page numbers of any other 
file object. 
• This paragraph was deleted.  
• For direct and stream files, the current index is a property of each file object; an operation on 
one file object does not affect the current index of any other file object. 
• For direct and stream files, the current size of  the file is a property of the external file.  
All other effects are identical.  
A.15 The Package Command_Line 
The package Command_Line allows a program to obtain the values of its argumen ts and to set the exit 
status code to be returned on normal termination.  
Static Semantics 
The library package Ada.Command_Line has the following declaration:  
package Ada.Command_Line is 
  pragma Preelaborate(Command_Line); 
  function  Argument_Count return Natural; 
  function  Argument (Number : in Positive) return String; 
  function  Command_Name return String; 
  type Exit_Status is implementation-defined integer type ; 
  Success : constant  Exit_Status; 
  Failure : constant  Exit_Status; 
  procedure  Set_Exit_Status (Code : in Exit_Status); 
private 
  ... -- not specified by the language  
end Ada.Command_Line; 
 16 
17 
1 
2 
3/1 
4 
5 
6 
1 
2 
3 
4 
5 6 7 8 
9 
10 
Ada Reference Manual — 2012 Edition 
A.15    The Package Command_Line 13 December 2012      462 function  Argument_Count return Natural; 
If the external execution environment suppor ts passing arguments to a program, then 
Argument_Count returns the number of arguments  passed to the program invoking the function. 
Otherwise, it returns 0. The meaning of “num ber of arguments” is im plementation defined. 
function  Argument (Number : in Positive) return String; 
If the external execution environment supports passing arguments to a program, then Argument 
returns an implementation-defined value co rresponding to the argument at relative position 
Number. If Number is outside the range 1 ..Argument_Count, then Constraint_Error is 
propagated.  
function  Command_Name return String; 
If the external execution environment suppor ts passing arguments to a program, then 
Command_Name returns an implementation-define d value corresponding to the name of the 
command invoking the program; otherwise, Command_Name returns the null string. 
type Exit_Status is implementation-defined integer type ; 
The type Exit_Status represents the range of exit status values supported by the external 
execution environment. The constants Success and Failure correspond to success and failure, 
respectively. 
procedure  Set_Exit_Status (Code : in Exit_Status); 
If the external execution environment supports re turning an exit status from a program, then 
Set_Exit_Status sets Code as the status. Normal  termination of a program returns as the exit 
status the value most recently set by Set_Exit_Stat us, or, if no such value has been set, then the 
value Success. If a program terminates abnormally, the status set by Set_Exit_Status is ignored, 
and an implementation-defined exit status value is set. 
If the external execution environment does not support returning an exit value from a program, 
then Set_Exit_Status does nothing.  
Implementation Permissions 
An alternative declaration is allowed for package Command_Line if different functionality is appropriate 
for the external execution environment.  
NOTES 
40  Argument_Count, Argument, and Command_Name correspond to the C language's argc, argv[n] (for n>0) and argv[0], respectively.  
A.16 The Package Directories 
The package Directories provides operations for manipul ating files and directorie s, and their names.  
Static Semantics 
The library package Directories has the following declaration:  
with Ada.IO_Exceptions; 
with Ada.Calendar; 
package Ada.Directories is 
   -- Directory and file operations:  
   function  Current_Directory return String; 11 
12/3 
13 
14 
15 
16/3 
16.1/1 
17 
18 
19 
20 
21 
22 
1/2 
2/2 
3/2 
4/2 
5/2 
Ada Reference Manual — 2012 Edition 
463      13 December 2012 The Package Directories   A.16    procedure  Set_Directory (Directory : in String); 
   procedure  Create_Directory (New_Directory : in String; 
                               Form          : in String := ""); 
   procedure  Delete_Directory (Directory : in String); 
   procedure  Create_Path (New_Directory : in String; 
                          Form          : in String := ""); 
   procedure  Delete_Tree (Directory : in String); 
   procedure  Delete_File (Name : in String); 
   procedure  Rename (Old_Name, New_Name : in String); 
   procedure  Copy_File (Source_Name, 
                        Target_Name : in String; 
                        Form        : in String := ""); 
   -- File and directory name operations:  
   function  Full_Name (Name : in String) return String; 
   function  Simple_Name (Name : in String) return String; 
   function  Containing_Directory (Name : in String) return String; 
   function  Extension (Name : in String) return String; 
   function  Base_Name (Name : in String) return String; 
   function  Compose (Containing_Directory : in String := ""; 
                     Name                 : in String; 
                     Extension            : in String := "") return String; 
   type Name_Case_Kind is 
      (Unknown, Case_Sensitive, Case_Insensitive, Case_Preserving); 
   function  Name_Case_Equivalence (Name : in String) return Name_Case_Kind; 
   -- File and directory queries:  
   type File_Kind is (Directory, Ordinary_File, Special_File); 
   type File_Size is range  0 .. implementation-defined ; 
   function  Exists (Name : in String) return Boolean; 
   function  Kind (Name : in String) return File_Kind; 
   function  Size (Name : in String) return File_Size; 
   function  Modification_Time (Name : in String) return Ada.Calendar.Time; 
   -- Directory searching:  
   type Directory_Entry_Type is limited private ; 
   type Filter_Type is array  (File_Kind) of Boolean; 
   type Search_Type is limited private ; 
   procedure  Start_Search (Search    : in out Search_Type; 
                           Directory : in String; 
                           Pattern   : in String; 
                           Filter    : in Filter_Type := ( others => True)); 
   procedure  End_Search (Search : in out Search_Type); 
   function  More_Entries (Search : in Search_Type) return Boolean; 
   procedure  Get_Next_Entry (Search : in out Search_Type; 
                             Directory_Entry : out Directory_Entry_Type); 
   procedure  Search ( 
      Directory : in String; 
      Pattern   : in String; 
      Filter    : in Filter_Type := ( others => True); 
      Process   : not null access procedure  ( 
          Directory_Entry : in Directory_Entry_Type)); 
   -- Operations on Directory Entries:  6/2 
7/2 
8/2 
9/2 
10/2 
11/2 12/2 13/2 
14/2 
15/2 16/2 17/2 18/2 19/2 20/2 
20.1/3 
20.2/3 
21/2 22/2 23/2 24/2 25/2 26/2 27/2 28/2 29/2 30/2 31/2 32/2 
33/2 
34/2 35/2 
36/2 
37/2 
Ada Reference Manual — 2012 Edition 
A.16    The Package Directories 13 December 2012      464    function  Simple_Name (Directory_Entry : in Directory_Entry_Type) 
       return String; 
   function  Full_Name (Directory_Entry : in Directory_Entry_Type) 
       return String; 
   function  Kind (Directory_Entry : in Directory_Entry_Type) 
       return File_Kind; 
   function  Size (Directory_Entry : in Directory_Entry_Type) 
       return File_Size; 
   function  Modification_Time (Directory_Entry : in Directory_Entry_Type) 
       return Ada.Calendar.Time; 
   Status_Error : exception renames  Ada.IO_Exceptions.Status_Error; 
   Name_Error   : exception renames  Ada.IO_Exceptions.Name_Error; 
   Use_Error    : exception renames  Ada.IO_Exceptions.Use_Error; 
   Device_Error : exception renames  Ada.IO_Exceptions.Device_Error; 
private 
    ... -- not specified by the language  
end Ada.Directories; 
External files may be classified as directories, special files, or ordinary files. A directory  is an external file 
that is a container for files on the target system. A special file  is an external file that cannot be created or 
read by a predefined Ada input-output package. External  files that are not special files or directories are 
called ordinary files .  
A file name  is a string identifying an external file. Similarly, a directory name  is a string identifying a 
directory. The interpretation of file names a nd directory names is implementation-defined.  
The full name  of an external file is a full specification of the name of the file. If the external environment 
allows alternative specifications of the name (for ex ample, abbreviations), the full name should not use 
such alternatives. A full name typically will include th e names of all of the directories that contain the 
item. The simple name  of an external file is the name of th e item, not including any containing directory 
names. Unless otherwise specified, a f ile name or directory name parameter in a call to a predefined Ada 
input-output subprogram can be a full name, a simple name, or any other form of name supported by the 
implementation.  
The default directory  is the directory that is used if a director y or file name is not a full name (that is, 
when the name does not fully identify all of the containing directories).  
A directory entry  is a single item in a directory, identifying a single external file (including directories and 
special files).  
For each function that returns a string, the lower bound of the returned value is 1. The following file and directory operations are provided: 
function  Current_Directory return String; 
Returns the full directory name for the current de fault directory. The name returned shall be 
suitable for a future call to Set_Directory. Th e exception Use_Error is propagated if a default 
directory is not supported by the external environment. 
procedure  Set_Directory (Directory : in String); 
Sets the current default directory. The exception Name_Error is propagated if the string given as 
Directory does not identify an existing directory.  The exception Use_Error is propagated if the 
external environment does not support making Directory (in the absence of Name_Error) a 
default directory. 38/2 
39/2 40/2 41/2 42/2 43/2 
44/3 
45/2 
46/2 
47/2 
48/2 
49/2 50/2 
51/2 
52/2 
53/2 
54/2 
55/2 
Ada Reference Manual — 2012 Edition 
465      13 December 2012 The Package Directories   A.16 procedure  Create_Directory (New_Directory : in String; 
                            Form          : in String := ""); 
Creates a directory with name New_Directory. The Form parameter can be used to give system-
dependent characteristics of the directory; th e interpretation of the Form parameter is 
implementation-defined. A null string for Form sp ecifies the use of the default options of the 
implementation of the new directory. The ex ception Name_Error is propagated if the string 
given as New_Directory does not allow the identification of a directory. The exception Use_Error is propagated if the external envir onment does not support the creation of a directory 
with the given name (in the absence of Name_Error) and form. 
procedure  Delete_Directory (Directory : in String); 
Deletes an existing empty directory with name Directory. The exception Name_Error is 
propagated if the string given as Directory does not identify an existing directory. The exception 
Use_Error is propagated if the directory is not  empty or the external environment does not 
support the deletion of the directory with the given name (in the absence of Name_Error). 
procedure  Create_Path (New_Directory : in String; 
                       Form          : in String := ""); 
Creates zero or more directories with name Ne w_Directory. Each nonexistent directory named 
by New_Directory is created. For example, on a typical Unix system, Create_Path ("/usr/me/my"); would create directory "me" in di rectory "usr", then create directory "my" in 
directory "me". The Form parameter can be used to give system-dependent characteristics of the directory; the interpretation of the Form parame ter is implementation-defined. A null string for 
Form specifies the use of the de fault options of the implementa tion of the new directory. The 
exception Name_Error is propagated if the stri ng given as New_Directory does not allow the 
identification of any directory. The exception Use_Error is propagated if the external environment does not support the creation of any di rectories with the given name (in the absence 
of Name_Error) and form. If Use_Error is propagate d, it is unspecified whether a portion of the 
directory path is created. 
procedure  Delete_Tree (Directory : in String); 
Deletes an existing directory with name Directory.  The directory and all of its contents (possibly 
including other directories) are deleted. The exception Name_Error is propagated if the string 
given as Directory does not identify an exis ting directory. The exception Use_Error is 
propagated if the external environment does not support the deletion of the directory or some 
portion of its contents with the given name (i n the absence of Name_Error). If Use_Error is 
propagated, it is unspecified whether a portion of  the contents of the directory is deleted. 
procedure  Delete_File (Name : in String); 
Deletes an existing ordinary or special file  with name Name. The exception Name_Error is 
propagated if the string given as Name does not identify an existing ordinary or special external 
file. The exception Use_Error is propagated if the external environment does not support the 
deletion of the file with the given name (in the absence of Name_Error). 
procedure  Rename (Old_Name, New_Name : in String); 
Renames an existing external file (including di rectories) with name Old_Name to New_Name. 
The exception Name_Error is propagated if the string given as Old_Name does not identify an 
existing external file or if the string given as New_Name does not allow the identification of an 
external file. The exception Use_Error is propa gated if the external environment does not 56/2 
57/2 
58/2 
59/3 
60/2 
61/3 
62/2 
63/2 
64/2 
65/2 
66/2 
67/3 
Ada Reference Manual — 2012 Edition 
A.16    The Package Directories 13 December 2012      466 support the renaming of the file with the give n name (in the absence of Name_Error). In 
particular, Use_Error is propagated if a file or  directory already exists with name New_Name. 
procedure  Copy_File (Source_Name, 
                     Target_Name : in String; 
                     Form        : in String := ""); 
Copies the contents of the existing external file with name Source_Name to an external file with 
name Target_Name. The resulting external file is a duplicate of the source external file. The 
Form parameter can be used to give system-dependent characteristics of the resulting external file; the interpretation of the Form parameter is implementation-defined. Exception Name_Error 
is propagated if the string given as Source_Name does not identify an existing external ordinary 
or special file, or if the string given as Targ et_Name does not allow the identification of an 
external file. The exception Use_Error is propa gated if the external environment does not 
support creating the file with the name given by Target_Name and form given by Form, or 
copying of the file with the name given by Source_Name (in the absence of Name_Error). If 
Use_Error is propagated, it is unspecified whether a portion of the file is copied.  
The following file and directory name operations are provided: 
function  Full_Name (Name : in String) return String; 
Returns the full name corresponding to the f ile name specified by Name. The exception 
Name_Error is propagated if the string given as Name does not allow the identification of an 
external file (including directories and special files).  
function  Simple_Name (Name : in String) return String; 
Returns the simple name portion of the file na me specified by Name. The exception Name_Error 
is propagated if the string given as Name does not allow the identification of an external file 
(including directories and special files). 
function  Containing_Directory (Name : in String) return String; 
Returns the name of the containing directory of th e external file (including directories) identified 
by Name. (If more than one directory can cont ain Name, the directory name returned is 
implementation-defined.) The exception Name_Error is propagated if the string given as Name 
does not allow the identification of an external file. The exception Use_Error is propagated if the 
external file does not have a containing directory.  
function  Extension (Name : in String) return String; 
Returns the extension name corresponding to Name. The extension name is a portion of a simple 
name (not including any separator characters), typi cally used to identify the file class. If the 
external environment does not have extension names, then the null string is returned. The 
exception Name_Error is propagated if the string given as Name does not allow the 
identification of an external file.  
function  Base_Name (Name : in String) return String; 
Returns the base name corresponding to Name. Th e base name is the remainder of a simple 
name after removing any extension and extens ion separators. The exception Name_Error is 
propagated if the string given as  Name does not allow the identification of an external file 
(including directories and special files).  68/3 
69/3 
70/2 
71/2 
72/2 
73/2 
74/2 
75/2 
76/2 
77/2 
78/2 
79/2 
80/2 
Ada Reference Manual — 2012 Edition 
467      13 December 2012 The Package Directories   A.16 function  Compose (Containing_Directory : in String := ""; 
                  Name                 : in String; 
                  Extension            : in String := "") return String; 
Returns the name of the external file with  the specified Containing_Directory, Name, and 
Extension. If Extension is the null string, then Na me is interpreted as a simple name; otherwise, 
Name is interpreted as a base name. The excep tion Name_Error is propaga ted if the string given 
as Containing_Directory is not null and does not allo w the identification of a directory, or if the 
string given as Extension is not null and is not a possible extension, or if the string given as 
Name is not a possible simple na me (if Extension is null) or base name (if Extension is nonnull). 
function  Name_Case_Equivalence (Name : in String) return Name_Case_Kind; 
Returns the file name equivalence rule for the directory containing Name . Raises Name_Error if 
Name is not a full name. Returns Case_Sensitive if file names that differ only in the case of 
letters are considered different names. If file names that differ only in the case of letters are considered the same name, then Case_Preserving is returned if names have the case of the file name used when a file is created; and Case_Ins ensitive is returned ot herwise. Returns Unknown 
if the file name equivalence is not known.  
The following file and directory queries and types are provided: 
type File_Kind is (Directory, Ordinary_File, Special_File); 
The type File_Kind represents th e kind of file represented by an external file or directory. 
type File_Size is range  0 .. implementation-defined ; 
The type File_Size represents the size of an external file.  
function  Exists (Name : in String) return Boolean; 
Returns True if an external file represented by  Name exists, and False otherwise. The exception 
Name_Error is propagated if the string given as Name does not allow the identification of an 
external file (including directories and special files). 
function  Kind (Name : in String) return File_Kind; 
Returns the kind of external file represented by Name. The exception Name_Error is propagated 
if the string given as Name does not allow the identification of an existing external file. 
function  Size (Name : in String) return File_Size; 
Returns the size of the external file represented by Name. The size of an external file is the 
number of stream elements contained in the file. If the external file is not an ordinary file, the result is implementation-defined. The exception Na me_Error is propagated if the string given as 
Name does not allow the identification of an existing external file. The exception Constraint_Error is propagated if the file size is not a value of type File_Size.  
function  Modification_Time (Name : in String) return Ada.Calendar.Time; 
Returns the time that the external file represen ted by Name was most recently modified. If the 
external file is not an ordinary file, the result is implementation- defined. The exception 
Name_Error is propagated if the string given as Name does not allow the identification of an 
existing external file. The exception Use_Error is propagated if the external environment does not support reading the modification time of the file with the name given by Name (in the 
absence of Name_Error).  
The following directory searching operations and types are provided: 81/2 
82/3 
82.1/3 
82.2/3 
83/2 
84/2 
85/2 
86/2 
87/2 
88/2 
89/2 
90/2 
91/2 
92/2 
93/2 
94/2 
95/2 
96/2 
Ada Reference Manual — 2012 Edition 
A.16    The Package Directories 13 December 2012      468 type Directory_Entry_Type is limited private ; 
The type Directory_Entry_Type represents a single item in a directory. These items can only be 
created by the Get_Next_Entry procedure in th is package. Information about the item can be 
obtained from the functions declared in this packag e. A default-initialized object of this type is 
invalid; objects returned from Get_Next_Entry are valid. 
type Filter_Type is array  (File_Kind) of Boolean; 
The type Filter_Type specifies which directory entries are provided from a search operation. If 
the Directory component is True, directory entr ies representing directories are provided. If the 
Ordinary_File component is True, directory entr ies representing ordinary files are provided. If 
the Special_File component is Tr ue, directory entries representing special files are provided. 
type Search_Type is limited private ; 
The type Search_Type contains the state of a di rectory search. A default-initialized Search_Type 
object has no entries available (function More_Ent ries returns False). Type Search_Type needs 
finalization (see 7.6). 
procedure  Start_Search (Search    : in out Search_Type; 
                        Directory : in String; 
                        Pattern   : in String; 
                        Filter    : in Filter_Type := ( others => True)); 
Starts a search in the directory named by Di rectory for entries matching Pattern and Filter. 
Pattern represents a pattern for matching file name s. If Pattern is the null string, all items in the 
directory are matched; otherwise, the interpreta tion of Pattern is implementation-defined. Only 
items that match Filter will be returned. After a successful call on Start_Search, the object Search may have entries available, but it may have  no entries available if no files or directories 
match Pattern and Filter. The exception Name_E rror is propagated if the string given by 
Directory does not identify an existing directory, or  if Pattern does not allow the identification of 
any possible external file or directory. The ex ception Use_Error is propagated if the external 
environment does not support the searching of the directory with the given name (in the absence 
of Name_Error). When Start_Search propagates Name_Error or Use_Error, the object Search will have no entries available.  
procedure  End_Search (Search : in out Search_Type); 
Ends the search represented by  Search. After a successful call on End_Search, the object Search 
will have no entries available. 
function  More_Entries (Search : in Search_Type) return Boolean; 
Returns True if more entries are available to be  returned by a call to Get_Next_Entry for the 
specified search object, and False otherwise. 
procedure  Get_Next_Entry (Search : in out Search_Type; 
                          Directory_Entry : out Directory_Entry_Type); 
Returns the next Directory_Entry for the search de scribed by Search that matches the pattern and 
filter. If no further matches are available, Status_E rror is raised. It is implementation-defined as 
to whether the results returned by this subprogram are altered if the contents of the directory are 
altered while the Search object is valid (for example, by another program). The exception Use_Error is propagated if the external envir onment does not support continued searching of the 
directory represented by Search.  97/2 
98/2 
99/2 
100/2 
101/2 
102/2 
103/2 
104/3 
105/2 
106/2 
107/2 
108/2 
109/2 
110/3 
Ada Reference Manual — 2012 Edition 
469      13 December 2012 The Package Directories   A.16 procedure  Search ( 
    Directory : in String; 
    Pattern   : in String; 
    Filter    : in Filter_Type := ( others => True); 
    Process   : not null access procedure  ( 
        Directory_Entry : in Directory_Entry_Type)); 
Searches in the directory named by Director y for entries matching Pattern and Filter. The 
subprogram designated by Process is called with each matching entry in turn. Pattern represents 
a pattern for matching file names. If Pattern is the null string, all items in the directory are 
matched; otherwise, the interpretation of Pattern  is implementation-defined. Only items that 
match Filter will be returned. The exception Name _Error is propagated if the string given by 
Directory does not identify an existing directory, or  if Pattern does not allow the identification of 
any possible external file or directory. The ex ception Use_Error is propagated if the external 
environment does not support the searching of the directory with the given name (in the absence 
of Name_Error).  
function  Simple_Name (Directory_Entry : in Directory_Entry_Type) 
     return String; 
Returns the simple external name of the extern al file (including directories) represented by 
Directory_Entry. The format of the name retu rned is implementation- defined. The exception 
Status_Error is propagated if Directory_Entry is invalid. 
function  Full_Name (Directory_Entry : in Directory_Entry_Type) 
     return String; 
Returns the full external name of the external  file (including directories) represented by 
Directory_Entry. The format of the name retu rned is implementation- defined. The exception 
Status_Error is propagated if Directory_Entry is invalid. 
function  Kind (Directory_Entry : in Directory_Entry_Type) 
     return File_Kind; 
Returns the kind of external file represented by  Directory_Entry. The exception Status_Error is 
propagated if Directory_Entry is invalid. 
function  Size (Directory_Entry : in Directory_Entry_Type) 
     return File_Size; 
Returns the size of the external file represented by  Directory_Entry. The size of an external file 
is the number of stream elements contained in the file. If the external file represented by Directory_Entry is not an ordinary file, the result is implementation- defined. The exception 
Status_Error is propagated if Directory_Entry is invalid. The exception Constraint_Error is 
propagated if the file size is not  a value of type File_Size. 
function  Modification_Time (Directory_Entry : in Directory_Entry_Type) 
     return Ada.Calendar.Time; 
Returns the time that the external file repr esented by Directory_Entry was most recently 
modified. If the external file represented by Direct ory_Entry is not an ordinary file, the result is 
implementation-defined. The excep tion Status_Error is propagated if Directory_Entry is invalid. 
The exception Use_Error is propagated if the ex ternal environment does not support reading the 
modification time of the file re presented by Directory_Entry. 111/2 
112/3 
113/2 
114/2 
115/2 
116/2 
117/2 
118/2 
119/2 
120/2 
121/2 
122/2 
Ada Reference Manual — 2012 Edition 
A.16    The Package Directories 13 December 2012      470 Implementation Requirements 
For Copy_File, if Source_Name identifies an existing ex ternal ordinary file created by a predefined Ada 
input-output package, and Target_Name and Form can be  used in the Create operation of that input-output 
package with mode Out_File  without raising an exception, then C opy_File shall not propagate Use_Error. 
Implementation Advice 
If other information about a file (such as the owner or creation date) is available in a directory entry, the 
implementation should provide functi ons in a child package Directorie s.Information to retrieve it.  
Start_Search and Search should raise Name_Error if Pa ttern is malformed, but not if it could represent a 
file in the directory but does not actually do so. 
Rename should be supported at least when both New_Name and Old_Name are simple names and 
New_Name does not identify an existing external file.  
NOTES 
41  The operations Containing_Directory, Full_Name, Simple_Name, Base_Name, Extension, and Compose operate on file names, not external files. The files identified by these ope rations do not need to exist. Name_Error is raised only if the  
file name is malformed and cannot possibly identify a file. Of these operations, only the result of Full_Name depends on the current default directory; the result of the others depends only on their parameters. 
42  Using access types, values of Search_Type and Directory_Entry_Type can be saved and queried later. However, 
another task or application can modify or delete the file represented by a Directory_Entry_Type value or the directory represented by a Search_Type value; such a value can only give the information valid at the time it is created. Therefore, long-term storage of these values is not recommended. 
43  If the target system does not support directories inside of directories, then Kind will never return Directory and 
Containing_Directory will always raise Use_Error. 
44  If the target system does not support creation or deletion of directories, then Create_Directory, Create_Path, 
Delete_Directory, and Delete_Tree will always propagate Use_Error. 
45  To move a file or directory to a different location, use Rename. Most target systems will allow renaming of files from 
one directory to another. If the target file or directory might already exist, it should be deleted first.  
A.16.1 The Package Directori es.Hierarchical_File_Names 
The library package Directories.Hierarchical_File_Nam es is an optional package providing operations for 
file name construction and decomposition for targets with hierarchical file naming.  
Static Semantics 
If provided, the library package Directories.Hierar chical_File_Names has the following declaration: 
package Ada.Directories.Hierarchical_File_Names is 
   function  Is_Simple_Name (Name : in String) return Boolean; 
   function  Is_Root_Directory_Name (Name : in String) return Boolean; 
   function  Is_Parent_Directory_Name (Name : in String) return Boolean; 
   function  Is_Current_Directory_Name (Name : in String) return Boolean; 
   function  Is_Full_Name (Name : in String) return Boolean; 
   function  Is_Relative_Name (Name : in String) return Boolean; 
   function  Simple_Name (Name : in String) return String 
      renames Ada.Directories.Simple_Name; 
   function  Containing_Directory (Name : in String) return String 
      renames Ada.Directories.Containing_Directory; 
   function  Initial_Directory (Name : in String) return String; 123/2 
124/2 
125/3 126/2 
127/2 
128/2 
129/2 
130/2 131/2 
1/3 
2/3 
3/3 
4/3 5/3 6/3 7/3 8/3 9/3 
10/3 
11/3 12/3 
Ada Reference Manual — 2012 Edition 
471      13 December 2012 The Package Di rectories.Hierarchical_File_Names   A.16.1    function  Relative_Name (Name : in String) return String; 
   function  Compose (Directory      : in String := ""; 
                     Relative_Name  : in String; 
                     Extension      : in String := "") return String; 
end Ada.Directories.Hierarchical_File_Names; 
In addition to the operations provided in package Di rectories.Hierarchical_File_Names, the operations in 
package Directories can be used with hierarchical  file names. In particular, functions Full_Name, 
Base_Name, and Extension provide additiona l capabilities for hierarchical file names. 
function  Is_Simple_Name (Name : in String) return Boolean; 
Returns True if Name is a simple name, and returns False otherwise. 
function  Is_Root_Directory_Name (Name : in String) return Boolean; 
Returns True if Name is syntactically a root (a directory that cannot be decomposed further), and 
returns False otherwise. 
function  Is_Parent_Directory_Name (Name : in String) return Boolean; 
Returns True if Name can be used to indicate sym bolically the parent directory of any directory, 
and returns False otherwise. 
function  Is_Current_Directory_Name (Name : in String) return Boolean; 
Returns True if Name can be used to indicate symbolically the directory itself for any directory, 
and returns False otherwise. 
function  Is_Full_Name (Name : in String) return Boolean; 
Returns True if the leftmost directory part of  Name is a root, and returns False otherwise. 
function  Is_Relative_Name (Name : in String) return Boolean; 
Returns True if Name allows the identification of an external file (including directories and 
special files) but is not a full na me, and returns False otherwise. 
function  Initial_Directory (Name : in String) return String; 
Returns the leftmost directory part in Name. That  is, it returns a root directory name (for a full 
name), or one of a parent directory name, a cu rrent directory name, or a simple name (for a 
relative name). The exception Name_Error is propa gated if the string given as Name does not 
allow the identification of an external file  (including directories and special files). 
function  Relative_Name (Name : in String) return String; 
Returns the entire file name except the Initial_ Directory portion. The exception Name_Error is 
propagated if the string given as  Name does not allow the identification of an external file 
(including directories and special files), or if Name has a single part (t his includes if any of 
Is_Simple_Name, Is_Root_Directory_Na me, Is_Parent_Directory_Name, or 
Is_Current_Directory_Name are True). 
function  Compose (Directory      : in String := ""; 
                  Relative_Name  : in String; 
                  Extension      : in String := "") return String; 
Returns the name of the external file with  the specified Directory, Relative_Name, and 
Extension. The exception Name_Error is propagated if the string given as Directory is not the 
null string and does not allow the identification of a directory, or if Is_Relative_Name 
(Relative_Name) is False, or if the string given as Extension is not the null string and is not a 
possible extension, or if Extension is not th e null string and Simple_Name (Relative_Name) is 
not a base name. 13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
20/3 
21/3 
22/3 
23/3 
24/3 
25/3 
26/3 
27/3 
28/3 
29/3 
30/3 
31/3 
32/3 
33/3 
34/3 
Ada Reference Manual — 2012 Edition 
A.16.1    The Package Directories.Hierarchi cal_File_Names 13 December 2012      472 The result of Compose is a full name if Is_Full_ Name (Directory) is True; result is a relative 
name otherwise. 
Implementation Advice 
Directories.Hierarchical_File_Names should be provided for systems with  hierarchical file naming, and 
should not be provided on other systems.  
NOTES 
46  These operations operate on file names, not external files. The files identified by these operations do not need to exist. Name_Error is raised only as specified or if the file name is malformed and cannot possibly identify a file. The result of these operations depends only on their parameters. 
47  Containing_Directory raises Use_Error if Name does not have a containing directory, including when any of 
Is_Simple_Name, Is_Root_Directory_Name, Is_Parent_Directory_Name, or Is_Current_Directory_Name are True. 
A.17 The Package Environment_Variables 
The package Environment_Variables allows a program to read or modify environment variables. 
Environment variables are name-value pairs, where bot h the name and value are strings. The definition of 
what constitutes an environment variable , and the meaning of the name and value, are implementation 
defined.  
Static Semantics 
The library package Environment_Variables has the following declaration:  
package Ada.Environment_Variables is 
   pragma Preelaborate(Environment_Variables); 
   function  Value (Name : in String) return String; 
   function  Value (Name : in String; Default : in String) return String; 
   function  Exists (Name : in String) return Boolean; 
   procedure  Set (Name : in String; Value : in String); 
   procedure  Clear (Name : in String); 
   procedure  Clear; 
   procedure  Iterate 
      (Process : not null access procedure  (Name, Value : in String)); 
end Ada.Environment_Variables; 
function  Value (Name : in String) return String; 
If the external execution environment supports e nvironment variables, then Value returns the 
value of the environment variable with the gi ven name. If no environment variable with the 
given name exists, then Constraint_Error is propagated. If the execution environment does not 
support environment variables, th en Program_Error is propagated. 
function  Value (Name : in String; Default : in String) return String; 
If the external execution environment supports environment variables and an environment 
variable with the given name currently exists, th en Value returns its value; otherwise, it returns 
Default. 
function  Exists (Name : in String) return Boolean; 
If the external execution environment supports environment variables and an environment 
variable with the given name currently exists, then Exists returns True; otherwise, it returns 
False. 35/3 
36/3 
37/3 
38/3 
1/2 
2/2 
3/2 
4/2 
4.1/3 
5/2 6/2 7/2 
8/3 9/2 
10/2 
11/2 
11.1/3 
11.2/3 
12/2 
13/3 
Ada Reference Manual — 2012 Edition 
473      13 December 2012 The Package Environment_Variables   A.17 procedure  Set (Name : in String; Value : in String); 
If the external execution environment supports envi ronment variables, then Set first clears any 
existing environment variable with the given na me, and then defines a single new environment 
variable with the given name and value.  Otherwise, Program_Error is propagated. 
If implementation-defined circumst ances prohibit the definition of an environment variable with 
the given name and value, then Constraint_Error is propagated.  
It is implementation defined whether there exist values for which the call Set(Name, Value) has 
the same effect as Clear (Name).  
procedure  Clear (Name : in String); 
If the external execution environment supports e nvironment variables, then Clear deletes all 
existing environment variables with the given name. Otherwise, Program _Error is propagated. 
procedure  Clear; 
If the external execution environment supports e nvironment variables, then Clear deletes all 
existing environment variables. Othe rwise, Program_Error is propagated. 
procedure  Iterate 
   (Process : not null access procedure  (Name, Value : in String)); 
If the external execution environment supports e nvironment variables, then Iterate calls the 
subprogram designated by Process for each existi ng environment variable, passing the name and 
value of that environment variable. Ot herwise, Program_Error is propagated. 
If several environment variables exist that have the same name, Process is called once for each 
such variable. 
Bounded (Run-Time) Errors 
It is a bounded error to call Value if more than one e nvironment variable exists with the given name; the 
possible outcomes are that:  
• one of the values is returned, and that same valu e is returned in subsequent calls in the absence 
of changes to the environment; or 
• Program_Error is propagated.  
Erroneous Execution 
Making calls to the procedures Set or Clear concu rrently with calls to an y subprogram of package 
Environment_Variables, or to any instantiation of Iterate, results in erroneous execution. 
Making calls to the procedures Set or Clear in  the actual subprogram corresponding to the Process 
parameter of Iterate results in erroneous execution.  
Documentation Requirements 
An implementation shall document how the operations of this package beha ve if environment variables are 
changed by external mechanisms (for instance, calling operating system services).  
Implementation Permissions 
An implementation running on a system that does not s upport environment variables is permitted to define 
the operations of package Environment_Variables w ith the semantics corresponding to the case where the 14/2 
15/3 
16/2 
17/2 
18/2 
19/3 
20/2 
21/3 
22/3 
23/3 
24/2 
25/2 
26/2 
27/2 
28/2 
29/2 
30/2 
31/2 
Ada Reference Manual — 2012 Edition 
A.17    The Package Environment_Variables 13 December 2012      474 external execution environment does support environmen t variables. In this case, it shall provide a 
mechanism to initialize a nonempty set of environment variables prior to the execution of a partition.  
Implementation Advice 
If the execution environment supports subprocesses, the currently define d environment variables should be 
used to initialize the environment variables of a subprocess.  
Changes to the environment variab les made outside the control of this package should be reflected 
immediately in the effect of the operations of this package. Changes to the environment variables made 
using this package should be reflected immediately in  the external execution e nvironment. This package 
should not perform any buffering of  the environment variables.  32/2 
33/2 
Ada Reference Manual — 2012 Edition 
475      13 December 2012 Containers   A.18 A.18 Containers 
This clause presents the specifications of the p ackage Containers and several child packages, which 
provide facilities for storing collections of elements. 
A variety of sequence and associative containe rs are provided. Each container includes a cursor  type. A 
cursor is a reference to an element within a contai ner. Many operations on cursors are common to all of 
the containers. A cursor referencing an element in a container is considered to be overlapping with the 
container object itself.  
Within this clause we provide Implementation Advice for the desired average or worst case time 
complexity of certain operations on a container. This advice is expressed using the Landau symbol O(X). 
Presuming f is some function of a length parameter N and t(N) is the time the operation takes (on average 
or worst case, as specified) for the length N, a complexity of O(f(N)) means that there exists a finite A 
such that for any N, t(N)/f(N) < A.  
If the advice suggests that the complexity should be less than O(f(N)), then for any arbitrarily small 
positive real D, there should exis t a positive integer M such that for all N > M, t(N)/f(N) < D. 
When a formal function is used to provide an ordering for a container, it is generally required to define a 
strict weak ordering. A function "<" defines a strict weak ordering  if it is irreflexive, asymmetric, 
transitive, and in addition, if x < y for any values x and y, then for all other values z, (x < z) or ( z < y). 
A.18.1 The Package Containers 
The package Containers is the root  of the containers subsystem.  
Static Semantics 
The library package Containers has the following declaration:  
package Ada.Containers is 
   pragma Pure(Containers); 
   type Hash_Type is mod implementation-defined ; 
   type Count_Type is range  0 .. implementation-defined ; 
   Capacity_Error : exception ; 
end Ada.Containers; 
Hash_Type represents the range of the result of a ha sh function. Count_Type represents the (potential or 
actual) number of elements of a container.  
Capacity_Error is raised when the capacity of a container is exceeded. 
Implementation Advice 
Hash_Type'Modulus should be at least 2**32. Count_Type'Last should be at least 2**31–1.  
A.18.2 The Generic Package Containers.Vectors 
The language-defined generic package Containers.Vector s provides private types Vector and Cursor, and a 
set of operations for each type. A vector container a llows insertion and deletion at any position, but it is 
specifically optimized for insertion and deletion at th e high end (the end with the higher index) of the 
container. A vector container also provides random access to its elements.  1/2 
2/2 
3/2 
4/2 
5/3 
1/2 
2/2 
3/2 
4/2 
5/2 
5.1/3 
6/2 
7/2 
7.1/3 
8/2 
1/2 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      476 A vector container behaves conceptually as an array that expands as necessary as items are inserted. The 
length  of a vector is the number of elements that the vector contains. The capacity  of a vector is the 
maximum number of elements that can be inserted into  the vector prior to it being automatically expanded. 
Elements in a vector container can be referred to by  an index value of a generic formal type. The first 
element of a vector always has its index valu e equal to the lower bound of the formal type. 
A vector container may contain empty elements . Empty elements do not have a specified value. 
Static Semantics 
The generic library package Containers.V ectors has the following declaration:  
with Ada.Iterator_Interfaces; 
generic 
   type Index_Type is range  <>; 
   type Element_Type is private ; 
   with function  "=" (Left, Right : Element_Type) 
      return Boolean is <>; 
package Ada.Containers.Vectors is 
   pragma Preelaborate(Vectors); 
   pragma Remote_Types(Vectors); 
   subtype Extended_Index is 
      Index_Type'Base range 
         Index_Type'First-1 ..          Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;    No_Index : constant  Extended_Index := Extended_Index'First; 
   type Vector is tagged private  
      with Constant_Indexing => Constant_Reference, 
           Variable_Indexing => Reference,            Default_Iterator  => Iterate,            Iterator_Element  => Element_Type;    pragma Preelaborable_Initialization(Vector); 
   type Cursor is private ; 
   pragma Preelaborable_Initialization(Cursor); 
   Empty_Vector : constant  Vector; 
   No_Element : constant  Cursor; 
   function  Has_Element (Position : Cursor) return Boolean; 
   package Vector_Iterator_Interfaces is new 
       Ada.Iterator_Interfaces (Cursor, Has_Element); 
   function  "=" (Left, Right : Vector) return Boolean; 
   function  To_Vector (Length : Count_Type) return Vector; 
   function  To_Vector 
     (New_Item : Element_Type;       Length   : Count_Type) return Vector; 
   function  "&" (Left, Right : Vector) return Vector; 
   function  "&" (Left  : Vector; 
                 Right : Element_Type) return Vector; 
   function  "&" (Left  : Element_Type; 
                 Right : Vector) return Vector; 
   function  "&" (Left, Right  : Element_Type) return Vector; 
   function  Capacity (Container : Vector) return Count_Type; 
   procedure  Reserve_Capacity (Container : in out Vector; 
                               Capacity  : in     Count_Type); 
   function  Length (Container : Vector) return Count_Type; 
   procedure  Set_Length (Container : in out Vector; 
                         Length    : in     Count_Type); 2/2 
3/2 
4/2 
5/2 
6/3 
7/2 
8/3 
9/2 
10/2 
11/2 
11.1/3 11.2/3 
12/2 
13/2 14/2 
15/2 
16/2 
17/2 18/2 
19/2 20/2 
21/2 
22/2 
Ada Reference Manual — 2012 Edition 
477      13 December 2012 The Generi c Package Containers.Vectors   A.18.2    function  Is_Empty (Container : Vector) return Boolean; 
   procedure  Clear (Container : in out Vector); 
   function  To_Cursor (Container : Vector; 
                       Index     : Extended_Index) return Cursor; 
   function  To_Index (Position  : Cursor) return Extended_Index; 
   function  Element (Container : Vector; 
                     Index     : Index_Type)       return Element_Type; 
   function  Element (Position : Cursor) return Element_Type; 
   procedure  Replace_Element (Container : in out Vector; 
                              Index     : in     Index_Type; 
                              New_Item  : in     Element_Type); 
   procedure  Replace_Element (Container : in out Vector; 
                              Position  : in     Cursor; 
                              New_item  : in     Element_Type); 
   procedure  Query_Element 
     (Container : in Vector; 
      Index     : in Index_Type; 
      Process   : not null access procedure  (Element : in Element_Type)); 
   procedure  Query_Element 
     (Position : in Cursor; 
      Process  : not null access procedure  (Element : in Element_Type)); 
   procedure  Update_Element 
     (Container : in out Vector; 
      Index     : in     Index_Type; 
      Process   : not null access procedure  
                      (Element : in out Element_Type)); 
   procedure  Update_Element 
     (Container : in out Vector; 
      Position  : in     Cursor; 
      Process   : not null access procedure  
                      (Element : in out Element_Type)); 
   type Constant_Reference_Type 
         (Element : not null access constant  Element_Type) is private  
      with Implicit_Dereference => Element; 
   type Reference_Type (Element : not null access  Element_Type) is private  
      with Implicit_Dereference => Element; 
   function  Constant_Reference (Container : aliased in  Vector; 
                                Index     : in Index_Type) 
      return Constant_Reference_Type; 
   function  Reference (Container : aliased in out  Vector; 
                       Index     : in Index_Type) 
      return Reference_Type; 
   function  Constant_Reference (Container : aliased in  Vector; 
                                Position  : in Cursor) 
      return Constant_Reference_Type; 
   function  Reference (Container : aliased in out  Vector; 
                       Position  : in Cursor) 
      return Reference_Type; 
   procedure  Assign (Target : in out Vector; Source : in Vector); 
   function  Copy (Source : Vector; Capacity : Count_Type := 0) 
      return Vector; 
   procedure  Move (Target : in out Vector; 
                   Source : in out Vector); 
   procedure  Insert (Container : in out Vector; 
                     Before    : in     Extended_Index; 
                     New_Item  : in     Vector); 23/2 
24/2 25/2 
26/2 
27/2 
28/2 
29/2 
30/2 31/2 
32/2 
33/2 
34/2 
34.1/3 
34.2/3 
34.3/3 
34.4/3 34.5/3 34.6/3 34.7/3 
34.8/3 
35/2 36/2 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      478    procedure  Insert (Container : in out Vector; 
                     Before    : in     Cursor; 
                     New_Item  : in     Vector); 
   procedure  Insert (Container : in out Vector; 
                     Before    : in     Cursor; 
                     New_Item  : in     Vector; 
                     Position  :    out Cursor); 
   procedure  Insert (Container : in out Vector; 
                     Before    : in     Extended_Index; 
                     New_Item  : in     Element_Type; 
                     Count     : in     Count_Type := 1); 
   procedure  Insert (Container : in out Vector; 
                     Before    : in     Cursor; 
                     New_Item  : in     Element_Type; 
                     Count     : in     Count_Type := 1); 
   procedure  Insert (Container : in out Vector; 
                     Before    : in     Cursor; 
                     New_Item  : in     Element_Type; 
                     Position  :    out Cursor; 
                     Count     : in     Count_Type := 1); 
   procedure  Insert (Container : in out Vector; 
                     Before    : in     Extended_Index; 
                     Count     : in     Count_Type := 1); 
   procedure  Insert (Container : in out Vector; 
                     Before    : in     Cursor; 
                     Position  :    out Cursor; 
                     Count     : in     Count_Type := 1); 
   procedure  Prepend (Container : in out Vector; 
                      New_Item  : in     Vector); 
   procedure  Prepend (Container : in out Vector; 
                      New_Item  : in     Element_Type; 
                      Count     : in     Count_Type := 1); 
   procedure  Append (Container : in out Vector; 
                     New_Item  : in     Vector); 
   procedure  Append (Container : in out Vector; 
                     New_Item  : in     Element_Type; 
                     Count     : in     Count_Type := 1); 
   procedure  Insert_Space (Container : in out Vector; 
                           Before    : in     Extended_Index; 
                           Count     : in     Count_Type := 1); 
   procedure  Insert_Space (Container : in out Vector; 
                           Before    : in     Cursor; 
                           Position  :    out Cursor; 
                           Count     : in     Count_Type := 1); 
   procedure  Delete (Container : in out Vector; 
                     Index     : in     Extended_Index; 
                     Count     : in     Count_Type := 1); 
   procedure  Delete (Container : in out Vector; 
                     Position  : in out Cursor; 
                     Count     : in     Count_Type := 1); 
   procedure  Delete_First (Container : in out Vector; 
                           Count     : in     Count_Type := 1); 
   procedure  Delete_Last (Container : in out Vector; 
                          Count     : in     Count_Type := 1); 
   procedure  Reverse_Elements (Container : in out Vector); 
   procedure  Swap (Container : in out Vector; 
                   I, J      : in     Index_Type); 37/2 
38/2 
39/2 
40/2 
41/2 
42/2 
43/2 
44/2 
45/2 
46/2 
47/2 
48/2 49/2 
50/2 
51/2 52/2 
53/2 54/2 
55/2 
Ada Reference Manual — 2012 Edition 
479      13 December 2012 The Generi c Package Containers.Vectors   A.18.2    procedure  Swap (Container : in out Vector; 
                   I, J      : in     Cursor); 
   function  First_Index (Container : Vector) return Index_Type; 
   function  First (Container : Vector) return Cursor; 
   function  First_Element (Container : Vector) 
      return Element_Type; 
   function  Last_Index (Container : Vector) return Extended_Index; 
   function  Last (Container : Vector) return Cursor; 
   function  Last_Element (Container : Vector) 
      return Element_Type; 
   function  Next (Position : Cursor) return Cursor; 
   procedure  Next (Position : in out Cursor); 
   function  Previous (Position : Cursor) return Cursor; 
   procedure  Previous (Position : in out Cursor); 
   function  Find_Index (Container : Vector; 
                        Item      : Element_Type;                         Index     : Index_Type := Index_Type'First)       return Extended_Index; 
   function  Find (Container : Vector; 
                  Item      : Element_Type;                   Position  : Cursor := No_Element)       return Cursor; 
   function  Reverse_Find_Index (Container : Vector; 
                                Item      : Element_Type;                                 Index     : Index_Type := Index_Type'Last)       return Extended_Index; 
   function  Reverse_Find (Container : Vector; 
                          Item      : Element_Type;                           Position  : Cursor := No_Element)       return Cursor; 
   function  Contains (Container : Vector; 
                      Item      : Element_Type) return Boolean; 
This paragraph was deleted.  
   procedure   Iterate 
     (Container : in Vector; 
      Process   : not null access procedure  (Position : in Cursor)); 
   procedure  Reverse_Iterate 
     (Container : in Vector; 
      Process   : not null access procedure  (Position : in Cursor)); 
   function  Iterate (Container : in Vector) 
      return Vector_Iterator_Interfaces.Reversible_Iterator'Class; 
   function  Iterate (Container : in Vector; Start : in Cursor) 
      return Vector_Iterator_Interfaces.Reversible_Iterator'Class; 
   generic 
      with function  "<" (Left, Right : Element_Type) 
         return Boolean is <>; 
   package Generic_Sorting is 
      function  Is_Sorted (Container : Vector) return Boolean; 
      procedure  Sort (Container : in out Vector); 
      procedure  Merge (Target  : in out Vector; 
                       Source  : in out Vector); 
   end Generic_Sorting; 
private 56/2 
57/2 
58/2 59/2 
60/2 
61/2 62/2 
63/2 
64/2 65/2 66/2 67/2 
68/2 
69/2 
70/2 
71/2 
72/3 
73/2 
74/2 
74.1/3 
74.2/3 
75/2 
76/2 
77/2 78/2 
79/2 
80/2 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      480    ... -- not specified by the language  
end Ada.Containers.Vectors; 
The actual function for the generic formal function "=" on Element_Type values is expected to define a 
reflexive and symmetric relationship and return the same result value each time it is called with a particular pair of values. If it behaves in some othe r manner, the functions defined to use it return an 
unspecified value. The exact arguments and number of  calls of this generic formal function by the 
functions defined to use it are unspecified. 
The type Vector is used to represent vectors.  The type Vector needs finalization (see 7.6). 
Empty_Vector represents the empty vector object. It ha s a length of 0. If an object of type Vector is not 
otherwise initialized, it is initialized to  the same value as Empty_Vector. 
No_Element represents a cursor that designates no elem ent. If an object of type Cursor is not otherwise 
initialized, it is initialized to th e same value as No_Element. 
The predefined "=" operator for type Cursor returns Tr ue if both cursors are No_Element, or designate the 
same element in the same container. 
Execution of the default implementati on of the Input, Output, Read, or Write attribute of type Cursor 
raises Program_Error. 
Vector'Write for a Vector object V writes Length( V) elements of the vector to the stream. It also may write 
additional information about the vector. 
Vector'Read reads the representation of a vector from the stream, and assigns to Item a vector with the 
same length and elements as was written by Vector'Write. 
No_Index represents a position that does not corre spond to any element. The subtype Extended_Index 
includes the indices covered by Index_Type plus the va lue No_Index and, if it exists, the successor to the 
Index_Type'Last. 
If an operation attempts to modify the vector such th at the position of the last element would be greater 
than Index_Type'Last, then the ope ration propagates Constraint_Error. 
Some operations of this generic package have access-to-subprogram parameters. To ensure such 
operations are well-defined, they guard against certain  actions by the designated subprogram. In particular, 
some operations check for “tampering with cursors” of a container because they depend on the set of elements of the container remaining constant, and others check for “tampering with elements” of a container because they depend on elements of the container not being replaced. 
A subprogram is said to tamper with cursors  of a vector object V if: 
• it inserts or deletes elements of V, that is, it calls the Insert, Insert_Space, Clear, Delete, or 
Set_Length procedures with V as a parameter; or 
• it finalizes V; or 
• it calls the Assign procedure with V as the Target parameter; or 
• it calls the Move procedure with V as a parameter. 
A subprogram is said to tamper with elements  of a vector object V if: 
• it tampers with cursors of V; or 81/2 
82/2 
83/2 
84/2 
85/2 
86/2 87/2 88/2 
88.1/3 88.2/3 
89/2 
89.1/3 
90/2 
91/2 
92/2 
93/2 
93.1/3 
94/2 95/2 
96/2 
Ada Reference Manual — 2012 Edition 
481      13 December 2012 The Generi c Package Containers.Vectors   A.18.2 • it replaces one or more elements of V, that is, it calls the Replace_Element, Reverse_Elements, 
or Swap procedures or the Sort or Merge pro cedures of an instance of Generic_Sorting with V as 
a parameter. 
When tampering with cursors is prohibited  for a particular vector object V, Program_Error is propagated 
by a call of any language-defined subprogram that  is defined to tamper with the cursors of V, leaving V 
unmodified. Similarly, when tampering with elements is prohibited  for a particular vector object V, 
Program_Error is propagated by a call of any language-def ined subprogram that is defined to tamper with 
the elements of V (or tamper with the cursors of V), leaving V unmodified.  
function  Has_Element (Position : Cursor) return Boolean; 
Returns True if Position designates an element, and returns False otherwise. 
function  "=" (Left, Right : Vector) return Boolean; 
If Left and Right denote the same vector object, th en the function returns True. If Left and Right 
have different lengths, then the function returns False. Otherwise, it compares each element in Left to the corresponding element in Right usi ng the generic formal equality operator. If any 
such comparison returns False, the function re turns False; otherwise, it returns True. Any 
exception raised during evaluation of element equality is propagated. 
function  To_Vector (Length : Count_Type) return Vector; 
Returns a vector with a length of Length, filled with empty elements. 
function  To_Vector 
  (New_Item : Element_Type;    Length   : Count_Type) return Vector; 
Returns a vector with a length of Length, filled with elements initialized to the value New_Item. 
function  "&" (Left, Right : Vector) return Vector; 
Returns a vector comprising the elements of Left followed by the elements of Right. 
function  "&" (Left  : Vector; 
              Right : Element_Type) return Vector; 
Returns a vector comprising the elements of Left followed by the element Right. 
function  "&" (Left  : Element_Type; 
              Right : Vector) return Vector; 
Returns a vector comprising the element Left followed by the elements of Right. 
function  "&" (Left, Right  : Element_Type) return Vector; 
Returns a vector comprising the element Left followed by the element Right. 
function  Capacity (Container : Vector) return Count_Type; 
Returns the capacity of Container. 
procedure  Reserve_Capacity (Container : in out Vector; 
                            Capacity  : in     Count_Type); 
If the capacity of Container is already greater than  or equal to Capacity, then Reserve_Capacity 
has no effect. Otherwise, Reserve_Capacity allocat es additional storage as necessary to ensure 
that the length of the resulting vector can become  at least the value Capacity without requiring 
an additional call to Reserve_Capacity, and is large enough to hold the current length of 
Container. Reserve_Capacity then, as necessary, moves elements into the new storage and 97/2 
97.1/3 
97.2/3 
97.3/3 
98/2 
99/3 
100/2 
101/2 
102/2 
103/2 
104/2 
105/2 
106/2 
107/2 
108/2 
109/2 
110/2 
111/2 
112/2 
113/2 
114/2 
115/3 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      482 deallocates any storage no longer needed. Any ex ception raised during allocation is propagated 
and Container is not modified. 
function  Length (Container : Vector) return Count_Type; 
Returns the number of el ements in Container. 
procedure  Set_Length (Container : in out Vector; 
                      Length    : in     Count_Type); 
If Length is larger than the capacity of Container, Set_Length calls Reserve_Capacity 
(Container, Length), then sets the length of the C ontainer to Length. If Length is greater than the 
original length of Container, empty elements are added to Container; otherwise, elements are removed from Container. 
function  Is_Empty (Container : Vector) return Boolean; 
Equivalent to Length (Container) = 0. 
procedure  Clear (Container : in out Vector); 
Removes all the elements from Container. The capacity of Container does not change. 
function  To_Cursor (Container : Vector; 
                    Index     : Extended_Index) return Cursor; 
If Index is not in the range First_Index (Contai ner) .. Last_Index (Container), then No_Element 
is returned. Otherwise, a cursor designating the element at position Index in Container is 
returned. 
function  To_Index (Position  : Cursor) return Extended_Index; 
If Position is No_Element, No_Index is returned . Otherwise, the index (within its containing 
vector) of the element designa ted by Position is returned. 
function  Element (Container : Vector; 
                  Index     : Index_Type)    return Element_Type; 
If Index is not in the range First_Index (Container) .. Last_Index (Container), then 
Constraint_Error is propagated. Otherwise, El ement returns the element at position Index. 
function  Element (Position  : Cursor) return Element_Type; 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Element returns 
the element designated by Position. 
procedure  Replace_Element (Container : in out Vector; 
                           Index     : in     Index_Type; 
                           New_Item  : in     Element_Type); 
If Index is not in the range First_Index (Container) .. Last_Index (Container), then 
Constraint_Error is propagated. Otherwise, Repl ace_Element assigns the value New_Item to the 
element at position Index. Any exception raised  during the assignment is propagated. The 
element at position Index is not an empty element after successful call to Replace_Element. 
procedure  Replace_Element (Container : in out Vector; 
                           Position  : in     Cursor; 
                           New_Item  : in     Element_Type); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 116/2 
117/2 
118/2 
119/3 
120/2 
121/2 
122/2 
123/2 
124/2 
125/2 
126/2 
127/2 
128/2 
129/2 
130/2 
131/2 
132/2 
133/3 
134/2 
135/3 
Ada Reference Manual — 2012 Edition 
483      13 December 2012 The Generi c Package Containers.Vectors   A.18.2 Replace_Element assigns New_Item to the element designated by Position. Any exception 
raised during the assignment is propagated. The element at Position is not an empty element after successful call to Replace_Element. 
procedure  Query_Element 
  (Container : in Vector; 
   Index     : in Index_Type; 
   Process   : not null access  procedure  (Element : in Element_Type)); 
If Index is not in the range First_Index (Container) .. Last_Index (Container), then 
Constraint_Error is propagated. Othe rwise, Query_Element calls Process. all with the element at 
position Index as the argument. Tampering with th e elements of Container is prohibited during 
the execution of the call on Process. all. Any exception raised by Process. all is propagated. 
procedure  Query_Element 
  (Position : in Cursor; 
   Process  : not null access  procedure  (Element : in Element_Type)); 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Query_Element 
calls Process. all with the element designated by Positi on as the argument. Tampering with the 
elements of the vector that contains the elem ent designated by Position is prohibited during the 
execution of the call on Process. all. Any exception raised by Process. all is propagated. 
procedure  Update_Element 
  (Container : in out Vector; 
   Index     : in     Index_Type; 
   Process   : not null access  procedure  (Element : in out Element_Type)); 
If Index is not in the range First_Index (Container) .. Last_Index (Container), then 
Constraint_Error is propagated. Otherw ise, Update_Element calls Process. all with the element at 
position Index as the argument. Tampering with th e elements of Container is prohibited during 
the execution of the call on Process. all. Any exception raised by Process. all is propagated. 
If Element_Type is unconstrained and definite, then the actual Element parameter of Process. all 
shall be unconstrained. 
The element at position Index is not an empty element after successful completion of this 
operation. 
procedure  Update_Element 
  (Container : in out Vector; 
   Position  : in     Cursor; 
   Process   : not null access  procedure  (Element : in out Element_Type)); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Update_Element calls Process. all with the element designated by Position as the argument. 
Tampering with the elements of Container is  prohibited during the execution of the call on 
Process. all. Any exception raised by Process. all is propagated. 
If Element_Type is unconstrained and definite, then the actual Element parameter of Process. all 
shall be unconstrained. 
The element designated by Position is not an empty element after successful completion of this 
operation. 
type Constant_Reference_Type 
      (Element : not null access constant  Element_Type) is private  
   with Implicit_Dereference => Element; 136/2 
137/3 
138/2 
139/3 
140/2 
141/3 
142/2 
143/2 
144/2 
145/3 
146/2 
147/2 
147.1/3 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      484 type Reference_Type (Element : not null access  Element_Type) is private  
   with Implicit_Dereference => Element; 
The types Constant_Reference_Type and Reference_Type need finalization. 
The default initialization of an object of type  Constant_Reference_Type or Reference_Type 
propagates Program_Error. 
function  Constant_Reference (Container : aliased in  Vector; 
                             Index     : in Index_Type) 
   return Constant_Reference_Type; 
This function (combined with the Constant_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read access to an individual element of a vector given an index value. 
If Index is not in the range First_Index (Container) .. Last_Index (Container), then 
Constraint_Error is propagated. Otherwise, Constant_Reference returns an object whose 
discriminant is an access value that designates th e element at position Index. Tampering with the 
elements of Container is prohibited while the obj ect returned by Constant_Reference exists and 
has not been finalized. 
function  Reference (Container : aliased in out  Vector; 
                    Index     : in Index_Type) 
   return Reference_Type; 
This function (combined with the Variable_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read and write access to an individual element of a vector given an index value. 
If Index is not in the range First_Index (Container) .. Last_Index (Container), then 
Constraint_Error is propagated. Ot herwise, Reference returns an obj ect whose discriminant is an 
access value that designates the element at positi on Index. Tampering with the elements of 
Container is prohibited while the object returned by Reference exists and has not been finalized. 
The element at position Index is not an empty element after successful completion of this 
operation. 
function  Constant_Reference (Container : aliased in  Vector; 
                             Position  : in Cursor) 
   return Constant_Reference_Type; 
This function (combined with the Constant_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read access to an i ndividual element of a vector given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Constant_Reference returns an object whose discri minant is an access value that designates the 
element designated by Position. Tampering with the elements of Container is prohibited while 
the object returned by Constant_Referen ce exists and has not been finalized. 
function  Reference (Container : aliased in out  Vector; 
                    Position  : in Cursor) 
   return Reference_Type; 
This function (combined with the Variable_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read and write access to an individual element of a vector given a cursor. 147.2/3 
147.3/3 
147.4/3 
147.5/3 
147.6/3 
147.7/3 
147.8/3 
147.9/3 
147.10/3 
147.11/3 
147.12/3 
147.13/3 
147.14/3 
147.15/3 
147.16/3 
Ada Reference Manual — 2012 Edition 
485      13 December 2012 The Generi c Package Containers.Vectors   A.18.2 If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then Progr am_Error is propagated. Otherwise, Reference 
returns an object whose discriminant is an access value that designates the element designated by Position. Tampering with the elements of Cont ainer is prohibited while the object returned by 
Reference exists and has not been finalized. 
The element designated by Position is not an empty element after successful completion of this 
operation. 
procedure  Assign (Target : in out Vector; Source : in Vector); 
If Target denotes the same object as Source, th e operation has no effect. If the length of Source 
is greater than the capacity of Target, Reserve_ Capacity (Target, Length (Source)) is called. The 
elements of Source are then copied to Target as for an assignment_statement  assigning Source 
to Target (this includes setting the length of Target to be that of Source).  
function  Copy (Source : Vector; Capacity : Count_Type := 0) 
   return Vector; 
Returns a vector whose elemen ts are initialized from the corre sponding elements of Source. If 
Capacity is 0, then the vector capacity is the lengt h of Source; if Capacity is equal to or greater 
than the length of Source, the vector capacity is  at least the specified value. Otherwise, the 
operation propagates Capacity_Error. 
procedure  Move (Target : in out Vector; 
                Source : in out Vector); 
If Target denotes the same object as Source, th en the operation has no effect. Otherwise, Move 
first calls Reserve_Capacity (Target, Length (Source)) and then Clear (Target); then, each element from Source is removed from Source and insert ed into Target in the original order. The 
length of Source is 0 after a successful call to Move. 
procedure  Insert (Container : in out Vector; 
                  Before    : in     Extended_Index; 
                  New_Item  : in     Vector); 
If Before is not in the range First_Index (Container) .. Last_Index (Container) + 1, then 
Constraint_Error is propagated. If Length(New_Item ) is 0, then Insert does nothing. Otherwise, 
it computes the new length NL as the sum of the current length and Length (New_Item); if the 
value of Last appropriate for length NL would be greater than Index_Type'Last, then 
Constraint_Error is propagated. 
If the current vector capacity is less than NL, Reserve_Capacity (Container, NL) is called to 
increase the vector capacity. Then Insert slides the elements in the range Before .. Last_Index 
(Container) up by Length(New_Item) positions, and th en copies the elements of New_Item to 
the positions starting at Before. Any exception raised during the copying is propagated. 
procedure  Insert (Container : in out Vector; 
                  Before    : in     Cursor; 
                  New_Item  : in     Vector); 
If Before is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. Otherwise, if Lengt h(New_Item) is 0, then  Insert does nothing. If 
Before is No_Element, then the call is equivale nt to Insert (Container, Last_Index (Container) + 
1, New_Item); otherwise, the call is equivale nt to Insert (Container, To_Index (Before), 
New_Item); 147.17/3 
147.18/3 
147.19/3 
147.20/3 
147.21/3 
147.22/3 
148/2 
149/3 
150/2 
151/3 
152/2 
153/2 
154/3 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      486 procedure  Insert (Container : in out Vector; 
                  Before    : in     Cursor; 
                  New_Item  : in     Vector; 
                  Position  :    out Cursor); 
If Before is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. If Befo re equals No_Element, then let T be Last_Index 
(Container) + 1; otherwise, let T be To_Index (Before). Insert (Container, T, New_Item) is 
called, and then Position is set to To_Cursor (Container, T). 
procedure  Insert (Container : in out Vector; 
                  Before    : in     Extended_Index; 
                  New_Item  : in     Element_Type; 
                  Count     : in     Count_Type := 1); 
Equivalent to Insert (Container, Be fore, To_Vector (New_Item, Count)); 
procedure  Insert (Container : in out Vector; 
                  Before    : in     Cursor; 
                  New_Item  : in     Element_Type; 
                  Count     : in     Count_Type := 1); 
Equivalent to Insert (Container, Be fore, To_Vector (New_Item, Count)); 
procedure  Insert (Container : in out Vector; 
                  Before    : in     Cursor; 
                  New_Item  : in     Element_Type; 
                  Position  :    out Cursor; 
                  Count     : in     Count_Type := 1); 
Equivalent to Insert (Container, Before , To_Vector (New_Item, Count), Position); 
procedure  Insert (Container : in out Vector; 
                  Before    : in     Extended_Index; 
                  Count     : in     Count_Type := 1); 
If Before is not in the range First_Index (Container) .. Last_Index (Container) + 1, then 
Constraint_Error is propagated. If Count is 0, th en Insert does nothing. Otherwise, it computes 
the new length NL as the sum of the current length and Count; if the value of Last appropriate 
for length NL would be greater than Index_Type'Last , then Constraint_Error is propagated. 
If the current vector capacity is less than NL, Reserve_Capacity (Container, NL) is called to 
increase the vector capacity. Then Insert slides the elements in the range Before .. Last_Index 
(Container) up by Count positions, and then inserts elements that are initialized by default (see 
3.3.1) in the positions starting at Before. 
procedure  Insert (Container : in out Vector; 
                  Before    : in     Cursor; 
                  Position  :    out Cursor; 
                  Count     : in     Count_Type := 1); 
If Before is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. If Befo re equals No_Element, then let T be Last_Index 
(Container) + 1; otherwise, let T be To_Index (Before). Insert (Container, T, Count) is called, 
and then Position is set to To_Cursor (Container, T). 
procedure  Prepend (Container : in out Vector; 
                   New_Item  : in     Vector; 
                   Count     : in     Count_Type := 1); 
Equivalent to Insert (Container, First_Index (Container), New_Item). 155/2 
156/2 
157/2 
158/2 
159/2 
160/2 
161/2 
162/2 
163/2 
164/3 
165/2 
166/2 
167/2 
168/2 
169/2 
Ada Reference Manual — 2012 Edition 
487      13 December 2012 The Generi c Package Containers.Vectors   A.18.2 procedure  Prepend (Container : in out Vector; 
                   New_Item  : in     Element_Type; 
                   Count     : in     Count_Type := 1); 
Equivalent to Insert (Container, Firs t_Index (Container), New_Item, Count). 
procedure  Append (Container : in out Vector; 
                  New_Item  : in     Vector); 
Equivalent to Insert (Container, La st_Index (Container) + 1, New_Item). 
procedure  Append (Container : in out Vector; 
                  New_Item  : in     Element_Type; 
                  Count     : in     Count_Type := 1); 
Equivalent to Insert (Container, Last _Index (Container) + 1, New_Item, Count). 
procedure  Insert_Space (Container : in out Vector; 
                        Before    : in     Extended_Index; 
                        Count     : in     Count_Type := 1); 
If Before is not in the range First_Index (Container) .. Last_Index (Container) + 1, then 
Constraint_Error is propagated. If Count is 0,  then Insert_Space does nothing. Otherwise, it 
computes the new length NL as the sum of the current length and Count; if the value of Last 
appropriate for length NL would be greater than Index_Type'Last, then Constraint_Error is 
propagated. 
If the current vector capacity is less than NL, Reserve_Capacity (Container, NL) is called to 
increase the vector capacity. Then Insert_Space slides the elements in the range Before .. 
Last_Index (Container) up by Count positions, and th en inserts empty elements in the positions 
starting at Before. 
procedure  Insert_Space (Container : in out Vector; 
                        Before    : in     Cursor; 
                        Position  :    out Cursor; 
                        Count     : in     Count_Type := 1); 
If Before is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. If Befo re equals No_Element, then let T be Last_Index 
(Container) + 1; otherwise, let T be To_Index (Before). Insert_Space (Container, T, Count) is 
called, and then Position is set to To_Cursor (Container, T). 
procedure  Delete (Container : in out Vector; 
                  Index     : in     Extended_Index; 
                  Count     : in     Count_Type := 1); 
If Index is not in the range First_Index (C ontainer) .. Last_Index (Container) + 1, then 
Constraint_Error is propagated. If Count is 0, Dele te has no effect. Otherwise, Delete slides the 
elements (if any) starting at position Index + C ount down to Index. Any exception raised during 
element assignment is propagated. 
procedure  Delete (Container : in out Vector; 
                  Position  : in out Cursor; 
                  Count     : in     Count_Type := 1); 
If Position equals No_Element, then Constrai nt_Error is propagated. If Position does not 
designate an element in Container, then Pr ogram_Error is propagated.  Otherwise, Delete 
(Container, To_Index (Position), Count) is called,  and then Position is set to No_Element. 170/2 
171/2 
172/2 
173/2 
174/2 
175/2 
176/2 
177/3 
178/2 
179/2 
180/2 
181/2 
182/3 
183/2 
184/2 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      488 procedure  Delete_First (Container : in out Vector; 
                        Count     : in     Count_Type := 1); 
Equivalent to Delete (Container,  First_Index (Container), Count). 
procedure  Delete_Last (Container : in out Vector; 
                       Count     : in     Count_Type := 1); 
If Length (Container) <= Count, then Delete_Last is equivalent to Clear (Container). Otherwise, 
it is equivalent to Delete (Container, Inde x_Type'Val(Index_Type'Pos(Last_Index (Container)) – 
Count + 1), Count). 
procedure  Reverse_Elements (Container : in out Vector); 
Reorders the elements of C ontainer in reverse order. 
procedure  Swap (Container : in out Vector; 
                I, J      : in     Index_Type); 
If either I or J is not in the range First_ Index (Container) .. Last_Index (Container), then 
Constraint_Error is propagated. Otherwise, Swap  exchanges the values of the elements at 
positions I and J. 
procedure  Swap (Container : in out Vector; 
                I, J      : in     Cursor); 
If either I or J is No_Element, then Constrai nt_Error is propagated. If either I or J do not 
designate an element in Container, then Pr ogram_Error is propagated. Otherwise, Swap 
exchanges the values of the elements designated by I and J. 
function  First_Index (Container : Vector) return Index_Type; 
Returns the value Index_Type'First. 
function  First (Container : Vector) return Cursor; 
If Container is empty, First returns No_Element. Otherwise, it returns a cursor that designates 
the first element in Container. 
function  First_Element (Container : Vector) return Element_Type; 
Equivalent to Element (Contai ner, First_Index (Container)). 
function  Last_Index (Container : Vector) return Extended_Index; 
If Container is empty, Last_Index returns No_Index.  Otherwise, it returns the position of the last 
element in Container. 
function  Last (Container : Vector) return Cursor; 
If Container is empty, Last returns No_Element. Ot herwise, it returns a cursor that designates the 
last element in Container. 
function  Last_Element (Container : Vector) return Element_Type; 
Equivalent to Element (Contai ner, Last_Index (Container)). 
function  Next (Position : Cursor) return Cursor; 
If Position equals No_Element or designates the last element of the container, then Next returns 
the value No_Element. Otherwise, it returns a cu rsor that designates the element with index 
To_Index (Position) + 1 in the same vector as Position. 185/2 
186/2 
187/2 
188/3 
189/2 
190/2 
191/2 
192/2 
193/2 
194/2 
195/2 
196/2 
197/2 
198/2 
199/2 
200/2 
201/2 
202/2 
203/2 
204/2 
205/2 
206/2 
207/2 
208/2 
Ada Reference Manual — 2012 Edition 
489      13 December 2012 The Generi c Package Containers.Vectors   A.18.2 procedure  Next (Position : in out Cursor); 
Equivalent to Position := Next (Position). 
function  Previous (Position : Cursor) return Cursor; 
If Position equals No_Element or designates the first element of the container, then Previous 
returns the value No_Element. Otherwise, it retu rns a cursor that designates the element with 
index To_Index (Position) – 1 in the same vector as Position. 
procedure  Previous (Position : in out Cursor); 
Equivalent to Position := Previous (Position). 
function  Find_Index (Container : Vector; 
                     Item      : Element_Type;                      Index     : Index_Type := Index_Type'First)    return Extended_Index; 
Searches the elements of Container for an element equal to Item (using the generic formal 
equality operator). The search starts at position Index and proceeds towards Last_Index 
(Container). If no equal element is found, then  Find_Index returns No_Index. Otherwise, it 
returns the index of the first equal element encountered. 
function  Find (Container : Vector; 
               Item      : Element_Type;                Position  : Cursor := No_Element)    return Cursor; 
If Position is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. Otherwise, Find searches the elements of Container for an element equal to Item (using the generic formal equality opera tor). The search starts at the first element if 
Position equals No_Element, and at the element designated by Position otherwise. It proceeds towards the last element of Container. If no equal element is found, then Find returns 
No_Element. Otherwise, it returns a cursor de signating the first equal element encountered. 
function  Reverse_Find_Index (Container : Vector; 
                             Item      : Element_Type;                              Index     : Index_Type := Index_Type'Last)    return Extended_Index; 
Searches the elements of Container for an element equal to Item (using the generic formal 
equality operator). The search starts at position Index or, if Index is greater than Last_Index 
(Container), at position Last_Index (Container). It  proceeds towards First_Index (Container). If 
no equal element is found, then Reverse_Find_Inde x returns No_Index. Otherwise, it returns the 
index of the first equal element encountered. 
function  Reverse_Find (Container : Vector; 
                       Item      : Element_Type;                        Position  : Cursor := No_Element)    return Cursor; 
If Position is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. Othe rwise, Reverse_Find searches the elements of Container for 
an element equal to Item (using the generic form al equality operator). The search starts at the 
last element if Position equals No_Element, and at the element designated by Position otherwise. 
It proceeds towards the first element of C ontainer. If no equal element is found, then 
Reverse_Find returns No_Element . Otherwise, it returns a cursor designating the first equal 
element encountered. 209/2 
210/2 
211/2 
212/2 
213/2 
214/2 
215/2 
216/2 
217/2 
218/3 
219/2 
220/2 
221/2 
222/3 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      490 function  Contains (Container : Vector; 
                   Item      : Element_Type) return Boolean; 
Equivalent to Has_Element (Find (Container, Item)). 
Paragraphs 225 and 226 were moved above.   
procedure  Iterate 
  (Container : in Vector; 
   Process   : not null access  procedure  (Position : in Cursor)); 
Invokes Process. all with a cursor that designates each element in Container, in index order. 
Tampering with the cursors of Container is  prohibited during the execution of a call on 
Process. all. Any exception raised by Process. all is propagated. 
procedure  Reverse_Iterate 
  (Container : in Vector; 
   Process   : not null access  procedure  (Position : in Cursor)); 
Iterates over the elements in Container as pe r procedure Iterate, except that elements are 
traversed in reverse index order. 
function  Iterate (Container : in Vector) 
   return Vector_Iterator_Interfaces.Reversible_Iterator'Class; 
Iterate returns a reversible iterator object (see 5.5.1) that will generate a value for a loop 
parameter (see 5.5.2) designating each node in Cont ainer, starting with the first node and moving 
the cursor as per the Next function when used as  a forward iterator, and starting with the last 
node and moving the cursor as per the Previous  function when used as a reverse iterator. 
Tampering with the cursors of Container is prohibited while the iterator object exists (in 
particular, in the sequence_of_statements  of the loop_statement  whose iterator_specification  
denotes this object). The iterator object needs finalization. 
function  Iterate (Container : in Vector; Start : in Cursor) 
   return Vector_Iterator_Interfaces.Reversible_Iterator'Class; 
If Start is not No_Element and does not designate an item in C ontainer, then Program_Error is 
propagated. If Start is No_Element, then Constr aint_Error is propagated. Otherwise, Iterate 
returns a reversible iterator object (see 5.5.1) th at will generate a value for a loop parameter (see 
5.5.2) designating each node in Container, starti ng with the node designated by Start and moving 
the cursor as per the Next function when used as  a forward iterator, or moving the cursor as per 
the Previous function when used as a reverse itera tor. Tampering with the cursors of Container is 
prohibited while the iterator object exists (in particular, in the sequence_of_statements  of the 
loop_statement  whose iterator_specification  denotes this object). The iterator object needs 
finalization. 
The actual function for the generic formal function "<" of  Generic_Sorting is expected to return the same 
value each time it is called with a particular pair of el ement values. It should define a strict weak ordering 
relationship (see A.18); it should not modify Containe r. If the actual for "<" behaves in some other 
manner, the behavior of the subprograms of Generi c_Sorting are unspecified. The number of times the 
subprograms of Generic_Sorting call "<" is unspecified. 
function  Is_Sorted (Container : Vector) return Boolean; 
Returns True if the elements are sorted smallest first as determined by the generic formal "<" 
operator; otherwise, Is_Sorted returns False. Any exception raised during evaluation of "<" is 
propagated. 223/2 
224/2 
227/2 
228/3 
229/2 
230/3 
230.1/3 
230.2/3 
230.3/3 
230.4/3 
231/3 
232/2 
233/2 
Ada Reference Manual — 2012 Edition 
491      13 December 2012 The Generi c Package Containers.Vectors   A.18.2 procedure  Sort (Container : in out Vector); 
Reorders the elements of Container such that the elements are sorted smallest first as determined 
by the generic formal "<" operator provided. An y exception raised during evaluation of "<" is 
propagated. 
procedure  Merge (Target  : in out Vector; 
                 Source  : in out Vector); 
If Source is empty, then Merge does nothing. If Source and Target are the same nonempty 
container object, then Program_Error is propagate d. Otherwise, Merge removes elements from 
Source and inserts them into Target; afterwards, Target contains the union of the elements that 
were initially in Source and Target; Source is left  empty. If Target and Source are initially sorted 
smallest first, then Target is ordered smallest first as determ ined by the generic formal "<" 
operator; otherwise, the order of  elements in Target is unspecified. Any exception raised during 
evaluation of "<" is propagated. 
Bounded (Run-Time) Errors 
Reading the value of an empty element by ca lling Element, Query_Element, Update_Element, 
Constant_Reference, Reference, Sw ap, Is_Sorted, Sort, Merge, "=",  Find, or Reverse_Find is a bounded 
error. The implementation may treat the element as having any normal value (see 13.9.1) of the element type, or raise Constraint_Error or Progr am_Error before modifying the vector. 
Calling Merge in an instance of Generic_Sorting with either Source or Target not ordered smallest first 
using the provided generic formal "<" operator is a bounded error. Either Program_Error is raised after 
Target is updated as described for Merg e, or the operation works as defined. 
It is a bounded error for the actual function associated  with a generic formal subprogram, when called as 
part of an operation of this package, to tamper with  elements of any Vector parameter of the operation. 
Either Program_Error is raised, or the operation works as  defined on the value of the Vector either prior to, 
or subsequent to, some or all of  the modifications to the Vector. 
It is a bounded error to call any subprogram declared in  the visible part of Containers.Vectors when the 
associated container has been finalized. If the operation takes Container as an in out  parameter, then it 
raises Constraint_Error or Program_Error. Otherwise,  the operation either proceeds as it would for an 
empty container, or it raises C onstraint_Error or Program_Error. 
A Cursor value is ambiguous  if any of the following have occurred since it was created: 
• Insert, Insert_Space, or Delete has been called on the vector that contains the element the cursor 
designates with an index value (or a cursor desi gnating an element at such an index value) less 
than or equal to the index value of th e element designated by the cursor; or 
• The vector that contains the element it designates has been passed to the Sort or Merge 
procedures of an instance of Generic_Sorti ng, or to the Reverse_ Elements procedure. 
It is a bounded error to call any subprogram other than "=" or Has_Element declared in Containers.Vectors 
with an ambiguous (but not i nvalid, see below) cursor parameter. Possible results are: 
• The cursor may be treated as if it were No_Element; 
• The cursor may designate some element in the vector (but not necessarily the element that it 
originally designated); 
• Constraint_Error may be raised; or 
• Program_Error may be raised. 234/2 
235/2 
236/2 
237/3 
238/3 
239/2 
239.1/3 
239.2/3 
240/2 
241/2 
242/2 
243/2 
244/2 
245/2 
246/2 
247/2 
Ada Reference Manual — 2012 Edition 
A.18.2    The Generic Package Containe rs.Vectors 13 December 2012      492 Erroneous Execution 
A Cursor value is invalid  if any of the following have occurred since it was created:  
• The vector that contains the element it designates has been finalized; 
• The vector that contains the element it designates has been used as the Target of a call to Assign, 
or as the target of an assignment_statement ; 
• The vector that contains the element it designates has been used as the Source or Target of a call 
to Move; or  
• The element it designates has been deleted or re moved from the vector that previously contained 
the element.  
The result of "=" or Has_Element is unspecified if it is called with an invalid cursor parameter. Execution 
is erroneous if any other subprogram declared in C ontainers.Vectors is called with an invalid cursor 
parameter. 
Execution is erroneous if the vector associated with the result of a call to Reference or Constant_Reference 
is finalized before the result object returned by the call to Reference or Constant_Reference is finalized. 
Implementation Requirements 
No storage associated with a vector object shall be lost upon assignment or scope exit. 
The execution of an assignment_statement  for a vector shall have the effect of copying the elements 
from the source vector object to the target vector object  and changing the length of the target object to that 
of the source object. 
Implementation Advice 
Containers.Vectors should be im plemented similarly to an array. In pa rticular, if the length of a vector is 
N, then 
• the worst-case time complex ity of Element should be O(log N);  
• the worst-case time complexity of Append with Count=1 when N is less than the capacity of the 
vector should be O(log N); and  
• the worst-case time complexity of Prepend with Count=1 and Delete_First with Count=1 should 
be O(N log N).  
The worst-case time complexity of a call on procedure Sort of an instance of 
Containers.Vectors.Generic_Sorting should be O(N**2), and the average time complexity should be better 
than O(N**2).  
Containers.Vectors.Generic_Sorting. Sort and Containers.Vectors.Gene ric_Sorting.Merge should minimize 
copying of elements.  
Move should not copy elements, and should mini mize copying of internal data structures.  
If an exception is propagated from a vector operation, no storage should be lost, nor any elements removed 
from a vector unless specified by the operation.  
NOTES 
48  All elements of a vector occupy locations in the internal array. If a sparse container is required, a Hashed_Map should be used rather than a vector. 
49  If Index_Type'Base'First = Index_Type'First an instance of Ada.Containers.Vectors will raise Constraint_Error. A 
value below Index_Type'First is required so that an empty vector has a meaningful value of Last_Index. 248/2 
249/2 
249.1/3 
250/2 251/3 252/2 
252.1/3 
253/2 
254/3 
255/2 
256/2 
257/2 
258/2 259/2 
260/2 
261/2 
262/2 
263/2 
264/2 
Ada Reference Manual — 2012 Edition 
493      13 December 2012 The Generic P ackage Containers.Doubly_Linked_Lists   A.18.3 A.18.3 The Generic Package Containers.Doubly_Linked_Lists 
The language-defined generic package Containers.D oubly_Linked_Lists provides private types List and 
Cursor, and a set of operations for each type. A list cont ainer is optimized for insertion and deletion at any 
position.  
A doubly-linked list container object ma nages a linked list of internal nodes , each of which contains an 
element and pointers to the next (successor) and previ ous (predecessor) internal nodes. A cursor designates 
a particular node within a list (and by extension th e element contained in that node). A cursor keeps 
designating the same node (and element) as long as the node  is part of the container, even if the node is 
moved in the container. 
The length  of a list is the number of elements it contains. 
Static Semantics 
The generic library package Containers.Doubly_ Linked_Lists has the following declaration:  
with Ada.Iterator_Interfaces; 
generic 
   type Element_Type is private ; 
   with function  "=" (Left, Right : Element_Type) 
      return Boolean is <>; 
package Ada.Containers.Doubly_Linked_Lists is 
   pragma Preelaborate(Doubly_Linked_Lists); 
   pragma Remote_Types(Doubly_Linked_Lists); 
   type List is tagged private  
      with Constant_Indexing => Constant_Reference, 
           Variable_Indexing => Reference,            Default_Iterator  => Iterate,            Iterator_Element  => Element_Type;    pragma Preelaborable_Initialization(List); 
   type Cursor is private ; 
   pragma Preelaborable_Initialization(Cursor); 
   Empty_List : constant  List; 
   No_Element : constant  Cursor; 
   function  Has_Element (Position : Cursor) return Boolean; 
   package List_Iterator_Interfaces is new 
       Ada.Iterator_Interfaces (Cursor, Has_Element); 
   function  "=" (Left, Right : List) return Boolean; 
   function  Length (Container : List) return Count_Type; 
   function  Is_Empty (Container : List) return Boolean; 
   procedure  Clear (Container : in out List); 
   function  Element (Position : Cursor) 
      return Element_Type; 
   procedure  Replace_Element (Container : in out List; 
                              Position  : in     Cursor; 
                              New_Item  : in     Element_Type); 
   procedure  Query_Element 
     (Position : in Cursor; 
      Process  : not null access procedure  (Element : in Element_Type)); 
   procedure  Update_Element 
     (Container : in out List; 
      Position  : in     Cursor; 
      Process   : not null access procedure  
                      (Element : in out Element_Type)); 1/2 
2/2 
3/2 
4/2 
5/3 
6/3 
7/2 
8/2 
9/2 
9.1/3 9.2/3 
10/2 
11/2 12/2 13/2 14/2 
15/2 
16/2 17/2 
Ada Reference Manual — 2012 Edition 
A.18.3    The Generic Package Containers.Doubl y_Linked_Lists 13 December 2012      494    type Constant_Reference_Type 
         (Element : not null access constant  Element_Type) is private  
      with Implicit_Dereference => Element; 
   type Reference_Type (Element : not null access  Element_Type) is private  
      with Implicit_Dereference => Element; 
   function  Constant_Reference (Container : aliased in  List; 
                                Position  : in Cursor) 
      return Constant_Reference_Type; 
   function  Reference (Container : aliased in out  List; 
                       Position  : in Cursor) 
      return Reference_Type; 
   procedure  Assign (Target : in out List; Source : in List); 
   function  Copy (Source : List) return List; 
   procedure  Move (Target : in out List; 
                   Source : in out List); 
   procedure  Insert (Container : in out List; 
                     Before    : in     Cursor; 
                     New_Item  : in     Element_Type; 
                     Count     : in     Count_Type := 1); 
   procedure  Insert (Container : in out List; 
                     Before    : in     Cursor; 
                     New_Item  : in     Element_Type; 
                     Position  :    out Cursor; 
                     Count     : in     Count_Type := 1); 
   procedure  Insert (Container : in out List; 
                     Before    : in     Cursor; 
                     Position  :    out Cursor; 
                     Count     : in     Count_Type := 1); 
   procedure  Prepend (Container : in out List; 
                      New_Item  : in     Element_Type; 
                      Count     : in     Count_Type := 1); 
   procedure  Append (Container : in out List; 
                     New_Item  : in     Element_Type; 
                     Count     : in     Count_Type := 1); 
   procedure  Delete (Container : in out List; 
                     Position  : in out Cursor; 
                     Count     : in     Count_Type := 1); 
   procedure  Delete_First (Container : in out List; 
                           Count     : in     Count_Type := 1); 
   procedure  Delete_Last (Container : in out List; 
                          Count     : in     Count_Type := 1); 
   procedure  Reverse_Elements (Container : in out List); 
   procedure  Swap (Container : in out List; 
                   I, J      : in     Cursor); 
   procedure  Swap_Links (Container : in out List; 
                         I, J      : in     Cursor); 
   procedure  Splice (Target   : in out List; 
                     Before   : in     Cursor; 
                     Source   : in out List); 
   procedure  Splice (Target   : in out List; 
                     Before   : in     Cursor; 
                     Source   : in out List; 
                     Position : in out Cursor); 
   procedure  Splice (Container: in out List; 
                     Before   : in     Cursor; 
                     Position : in     Cursor); 17.1/3 
17.2/3 
17.3/3 
17.4/3 17.5/3 
17.6/3 
18/2 
19/2 
20/2 
21/2 
22/2 
23/2 24/2 25/2 
26/2 27/2 
28/2 
29/2 30/2 
31/2 
32/2 
Ada Reference Manual — 2012 Edition 
495      13 December 2012 The Generic P ackage Containers.Doubly_Linked_Lists   A.18.3    function  First (Container : List) return Cursor; 
   function  First_Element (Container : List) 
      return Element_Type; 
   function  Last (Container : List) return Cursor; 
   function  Last_Element (Container : List) 
      return Element_Type; 
   function  Next (Position : Cursor) return Cursor; 
   function  Previous (Position : Cursor) return Cursor; 
   procedure  Next (Position : in out Cursor); 
   procedure  Previous (Position : in out Cursor); 
   function  Find (Container : List; 
                  Item      : Element_Type;                   Position  : Cursor := No_Element)       return Cursor; 
   function  Reverse_Find (Container : List; 
                          Item      : Element_Type;                           Position  : Cursor := No_Element)       return Cursor; 
   function  Contains (Container : List; 
                      Item      : Element_Type) return Boolean; 
This paragraph was deleted.  
   procedure  Iterate 
     (Container : in List; 
      Process   : not null access procedure  (Position : in Cursor)); 
   procedure  Reverse_Iterate 
     (Container : in List; 
      Process   : not null access procedure  (Position : in Cursor)); 
   function  Iterate (Container : in List) 
      return List_Iterator_Interfaces.Reversible_Iterator'Class; 
   function  Iterate (Container : in List; Start : in Cursor) 
      return List_Iterator_Interfaces.Reversible_Iterator'Class; 
   generic 
      with function  "<" (Left, Right : Element_Type) 
         return Boolean is <>; 
   package Generic_Sorting is 
      function  Is_Sorted (Container : List) return Boolean; 
      procedure  Sort (Container : in out List); 
      procedure  Merge (Target  : in out List; 
                       Source  : in out List); 
   end Generic_Sorting; 
private 
   ... -- not specified by the language  
end Ada.Containers.Doubly_Linked_Lists; 
The actual function for the generic formal function "=" on Element_Type values is expected to define a 
reflexive and symmetric relationship and return the same result value each time it is called with a particular pair of values. If it behaves in some othe r manner, the functions Find,  Reverse_Find, and "=" on 
list values return an unspecified value. The exact ar guments and number of calls of this generic formal 
function by the functions Find, Reverse_Fi nd, and "=" on list values are unspecified. 
The type List is used to represent lists. The type List needs finalization (see 7.6). 
Empty_List represents the empty List object. It has a le ngth of 0. If an object of type List is not otherwise 
initialized, it is initialized to th e same value as Empty_List. 33/2 
34/2 
35/2 
36/2 
37/2 
38/2 39/2 40/2 41/2 
42/2 
43/2 
44/3 
45/2 
46/2 
46.1/3 
46.2/3 
47/2 
48/2 
49/2 50/2 
51/2 
52/2 53/2 54/2 
55/2 
56/2 
57/2 
Ada Reference Manual — 2012 Edition 
A.18.3    The Generic Package Containers.Doubl y_Linked_Lists 13 December 2012      496 No_Element represents a cursor that designates no elem ent. If an object of type Cursor is not otherwise 
initialized, it is initialized to th e same value as No_Element. 
The predefined "=" operator for type Cursor returns Tr ue if both cursors are No_Element, or designate the 
same element in the same container. 
Execution of the default implementati on of the Input, Output, Read, or Write attribute of type Cursor 
raises Program_Error. 
List'Write for a List object L writes Length( L) elements of the list to the stream. It also may write 
additional information about the list. 
List'Read reads the representation of a list from the stream, and assigns to Item a list with the same length 
and elements as was written by List'Write. 
Some operations of this generic package have access-to-subprogram parameters. To ensure such 
operations are well-defined, they guard against certain  actions by the designated subprogram. In particular, 
some operations check for “tampering with cursors” of a container because they depend on the set of elements of the container remaining constant, and others check for “tampering with elements” of a container because they depend on elements of the container not being replaced. 
A subprogram is said to tamper with cursors  of a list object L if: 
• it inserts or deletes elements of L, that is, it calls the Insert, Clear, Delete, or Delete_Last 
procedures with L as a parameter; or 
• it reorders the elements of L, that is, it calls the Splice, Sw ap_Links, or Reverse_Elements 
procedures or the Sort or Merge procedures  of an instance of Generic_Sorting with L as a 
parameter; or 
• it finalizes L; or 
• it calls the Assign procedure with L as the Target parameter; or 
• it calls the Move procedure with L as a parameter.  
A subprogram is said to tamper with elements  of a list object L if: 
• it tampers with cursors of L; or 
• it replaces one or more elements of L, that is, it calls the Replace_Element or Swap procedures 
with L as a parameter. 
When tampering with cursors is prohibited  for a particular list object L, Program_Error is propagated by a 
call of any language-defined subprogram that is  defined to tamper with the cursors of L, leaving L 
unmodified. Similarly, when tampering with elements is prohibited  for a particular list object L, 
Program_Error is propagated by a call of any language-def ined subprogram that is defined to tamper with 
the elements of L (or tamper with the cursors of L), leaving L unmodified.  
function  Has_Element (Position : Cursor) return Boolean; 
Returns True if Position designates an element, and returns False otherwise. 
function  "=" (Left, Right : List) return Boolean; 
If Left and Right denote the same list object, then  the function returns True. If Left and Right 
have different lengths, then the function returns False. Otherwise, it compares each element in Left to the corresponding element in Right usi ng the generic formal equality operator. If any 
such comparison returns False, the function re turns False; otherwise, it returns True. Any 
exception raised during evaluation of element equality is propagated.  58/2 
59/2 60/2 
60.1/3 60.2/3 
61/2 
62/2 
63/2 
64/2 
65/2 
65.1/3 
66/2 67/2 
68/2 
69/2 
69.1/3 
69.2/3 
69.3/3 
70/2 
71/3 
Ada Reference Manual — 2012 Edition 
497      13 December 2012 The Generic P ackage Containers.Doubly_Linked_Lists   A.18.3 function  Length (Container : List) return Count_Type; 
Returns the number of el ements in Container. 
function  Is_Empty (Container : List) return Boolean; 
Equivalent to Length (Container) = 0. 
procedure  Clear (Container : in out List); 
Removes all the elements from Container. 
function  Element (Position : Cursor) return Element_Type; 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Element returns 
the element designated by Position. 
procedure  Replace_Element (Container : in out List; 
                           Position  : in     Cursor; 
                           New_Item  : in     Element_Type); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Replace_Element assigns the value New_Item to the element designated by Position. 
procedure  Query_Element 
  (Position : in Cursor; 
   Process  : not null access procedure  (Element : in Element_Type)); 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Query_Element 
calls Process. all with the element designated by Positi on as the argument. Tampering with the 
elements of the list that contains the elemen t designated by Position is prohibited during the 
execution of the call on Process. all. Any exception raised by Process. all is propagated. 
procedure  Update_Element 
  (Container : in out List; 
   Position  : in     Cursor; 
   Process   : not null access procedure  (Element : in out Element_Type)); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Update_Element calls Process. all with the element designated by Position as the argument. 
Tampering with the elements of Container is  prohibited during the execution of the call on 
Process. all. Any exception raised by Process. all is propagated. 
If Element_Type is unconstrained and definite, then the actual Element parameter of Process. all 
shall be unconstrained. 
type Constant_Reference_Type 
      (Element : not null access constant  Element_Type) is private  
   with Implicit_Dereference => Element; 
type Reference_Type (Element : not null access  Element_Type) is private  
   with Implicit_Dereference => Element; 
The types Constant_Reference_Type and Reference_Type need finalization. 
The default initialization of an object of type  Constant_Reference_Type or Reference_Type 
propagates Program_Error. 72/2 
73/2 
74/2 
75/2 
76/2 
77/2 
78/2 
79/2 
80/2 
81/3 
82/2 
83/3 
84/2 
85/3 
86/2 
86.1/3 
86.2/3 
86.3/3 
86.4/3 
Ada Reference Manual — 2012 Edition 
A.18.3    The Generic Package Containers.Doubl y_Linked_Lists 13 December 2012      498 function  Constant_Reference (Container : aliased in  List; 
                             Position  : in Cursor) 
   return Constant_Reference_Type; 
This function (combined with the Constant_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read access to an individual element of a list given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Constant_Reference returns an object whose discri minant is an access value that designates the 
element designated by Position. Tampering with the elements of Container is prohibited while 
the object returned by Constant_Referen ce exists and has not been finalized. 
function  Reference (Container : aliased in out  List; 
                    Position  : in Cursor) 
   return Reference_Type; 
This function (combined with the Variable_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read and write access to an individual element of a list given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then Progr am_Error is propagated. Otherwise, Reference 
returns an object whose discriminant is an access value that designates the element designated by Position. Tampering with the elements of Cont ainer is prohibited while the object returned by 
Reference exists and has not been finalized. 
procedure  Assign (Target : in out List; Source : in List); 
If Target denotes the same object as Source, the operation has no effect. Otherwise, the elements 
of Source are copied to Target as for an assignment_statement  assigning Source to Target.  
function  Copy (Source : List) return List; 
Returns a list whose elements match the elements of Source. 
procedure  Move (Target : in out List; 
                Source : in out List); 
If Target denotes the same object as Source, then the operation has no effect. Otherwise, the 
operation is equivalent to Assign (Targe t, Source) followed by Clear (Source). 
procedure  Insert (Container : in out List; 
                  Before    : in     Cursor; 
                  New_Item  : in     Element_Type; 
                  Count     : in     Count_Type := 1); 
If Before is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. Otherw ise, Insert inserts Count copies of New_Item prior to the 
element designated by Before. If Before equals N o_Element, the new elements are inserted after 
the last node (if any). Any exception raised during allocation of internal storage is propagated, 
and Container is not modified. 
procedure  Insert (Container : in out List; 
                  Before    : in     Cursor; 
                  New_Item  : in     Element_Type; 
                  Position  :    out Cursor; 
                  Count     : in     Count_Type := 1); 
If Before is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. Otherw ise, Insert allocates Count c opies of New_Item, and inserts 86.5/3 
86.6/3 
86.7/3 
86.8/3 
86.9/3 
86.10/3 
86.11/3 
86.12/3 
86.13/3 
86.14/3 
87/2 
88/3 
89/2 
90/2 
91/2 
92/3 
Ada Reference Manual — 2012 Edition 
499      13 December 2012 The Generic P ackage Containers.Doubly_Linked_Lists   A.18.3 them prior to the element designated by Before. If Before equals No_Element, the new elements 
are inserted after the last element (if any). Position designates the first newly-inserted element, or if Count equals 0, then Position is assigne d the value of Before. Any exception raised during 
allocation of internal storage is propa gated, and Container is not modified. 
procedure  Insert (Container : in out List; 
                  Before    : in     Cursor; 
                  Position  :    out Cursor; 
                  Count     : in     Count_Type := 1); 
If Before is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. Otherw ise, Insert inserts Count new elements prior to the element 
designated by Before. If Before e quals No_Element, the new elements are inserted after the last 
node (if any). The new elements are initialized by default (see 3.3.1). Position designates the 
first newly-inserted element, or if Count equals 0, then Position is assigned the value of Before. 
Any exception raised during allocation of internal  storage is propagated, and Container is not 
modified. 
procedure  Prepend (Container : in out List; 
                   New_Item  : in     Element_Type; 
                   Count     : in     Count_Type := 1); 
Equivalent to Insert (Container, First (Container), New_Item, Count). 
procedure  Append (Container : in out List; 
                  New_Item  : in     Element_Type; 
                  Count     : in     Count_Type := 1); 
Equivalent to Insert (Container,  No_Element, New_Item, Count). 
procedure  Delete (Container : in out List; 
                  Position  : in out Cursor; 
                  Count     : in     Count_Type := 1); 
If Position equals No_Element, then Constrai nt_Error is propagated. If Position does not 
designate an element in Container, then Pr ogram_Error is propagated.  Otherwise, Delete 
removes (from Container) Count elements starting at the element designated by Position (or all 
of the elements starting at Position if there are fewer than Count elements starting at Position). 
Finally, Position is set to No_Element. 
procedure  Delete_First (Container : in out List; 
                        Count     : in     Count_Type := 1); 
If Length (Container) <= Count, then Delete_First is  equivalent to Clear (Container). Otherwise, 
it removes the first Count nodes from Container. 
procedure  Delete_Last (Container : in out List; 
                       Count     : in     Count_Type := 1); 
If Length (Container) <= Count, then Delete_Last is equivalent to Clear (Container). Otherwise, 
it removes the last Count  nodes from Container. 
procedure  Reverse_Elements (Container : in out List); 
Reorders the elements of C ontainer in reverse order. 93/2 
94/3 
95/2 
96/2 
97/2 
98/2 
99/2 
100/3 
101/2 
102/3 
103/2 
104/3 
105/2 
106/2 
Ada Reference Manual — 2012 Edition 
A.18.3    The Generic Package Containers.Doubl y_Linked_Lists 13 December 2012      500 procedure  Swap (Container : in out List; 
                I, J      : in     Cursor); 
If either I or J is No_Element, then Constrai nt_Error is propagated. If either I or J do not 
designate an element in Container, then Pr ogram_Error is propagated. Otherwise, Swap 
exchanges the values of the elements designated by I and J. 
procedure  Swap_Links (Container : in out List; 
                      I, J      : in     Cursor); 
If either I or J is No_Element, then Constrai nt_Error is propagated. If either I or J do not 
designate an element in Container, then Progr am_Error is propagated. Otherwise, Swap_Links 
exchanges the nodes designated by I and J. 
procedure  Splice (Target   : in out List; 
                  Before   : in     Cursor; 
                  Source   : in out List); 
If Before is not No_Element, a nd does not designate an element in Target, then Program_Error 
is propagated. Otherwise, if Source denotes the same object as Target, the operation has no 
effect. Otherwise, Splice reorders elements such that they are removed from Source and moved to Target, immediately prior to Before. If Befo re equals No_Element, the nodes of Source are 
spliced after the last node of Target. The length of Target is incremented by the number of nodes 
in Source, and the length of Source is set to 0. 
procedure  Splice (Target   : in out List; 
                  Before   : in     Cursor; 
                  Source   : in out List; 
                  Position : in out Cursor); 
If Position is No_Element, then Constraint_E rror is propagated. If Before does not equal 
No_Element, and does not designate an element in  Target, then Program_Error is propagated. If 
Position does not equal No_Element, and doe s not designate a node in Source, then 
Program_Error is propagated. If Source denotes the sa me object as Target, then there is no effect 
if Position equals Before, else the element desi gnated by Position is moved immediately prior to 
Before, or, if Before equals No_Element, after the last element. In both cases, Position and the 
length of Target are unchanged. Otherwise, the element designated by Position is removed from 
Source and moved to Target, immediately prior to  Before, or, if Before equals No_Element, 
after the last element of Target. The length of Target is incremented, the length of Source is 
decremented, and Position is updated to  represent an element in Target.  
procedure  Splice (Container: in out List; 
                  Before   : in     Cursor; 
                  Position : in     Cursor); 
If Position is No_Element, then Constraint_E rror is propagated. If Before does not equal 
No_Element, and does not designate an element in  Container, then Program_Error is propagated. 
If Position does not equal No_Ele ment, and does not designate a node in Container, then 
Program_Error is propagated. If Pos ition equals Before there is no effect. Otherwise, the element 
designated by Position is moved i mmediately prior to Before, or, if Before equals No_Element, 
after the last element. The length of Container is unchanged. 
function  First (Container : List) return Cursor; 
If Container is empty, First returns the value N o_Element. Otherwise, it returns a cursor that 
designates the first node in Container. 107/2 
108/2 
109/2 
110/2 
111/2 
112/2 
113/2 
114/3 
115/2 
116/3 
117/2 
118/3 
Ada Reference Manual — 2012 Edition 
501      13 December 2012 The Generic P ackage Containers.Doubly_Linked_Lists   A.18.3 function  First_Element (Container : List) return Element_Type; 
Equivalent to Element (First (Container)). 
function  Last (Container : List) return Cursor; 
If Container is empty, Last returns the value N o_Element. Otherwise, it returns a cursor that 
designates the last node in Container. 
function  Last_Element (Container : List) return Element_Type; 
Equivalent to Element (Last (Container)). 
function  Next (Position : Cursor) return Cursor; 
If Position equals No_Element or designates the last element of the container, then Next returns 
the value No_Element. Otherwise, it returns a curs or that designates the successor of the element 
designated by Position. 
function  Previous (Position : Cursor) return Cursor; 
If Position equals No_Element or designates the first element of the container, then Previous 
returns the value No_Element. Otherwise, it retu rns a cursor that designates the predecessor of 
the element designated by Position. 
procedure  Next (Position : in out Cursor); 
Equivalent to Position := Next (Position). 
procedure  Previous (Position : in out Cursor); 
Equivalent to Position := Previous (Position). 
function  Find (Container : List; 
               Item      : Element_Type;                Position  : Cursor := No_Element)   return Cursor; 
If Position is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. Find searches the elements of Container for an element equal to Item (using the generic formal equality operator). The search starts at the element designated by 
Position, or at the first element if Position equals No_Element. It proceeds towards Last (Container). If no equal element is found, then Fi nd returns No_Element. Otherwise, it returns a 
cursor designating the first equal element encountered. 
function  Reverse_Find (Container : List; 
                       Item      : Element_Type;                        Position  : Cursor := No_Element)    return Cursor; 
If Position is not No_Element, and does not de signate an element in Container, then 
Program_Error is propagated. Find searches the elements of Container for an element equal to Item (using the generic formal equality operator). The search starts at the element designated by 
Position, or at the last element if Position equals No_Element. It proceeds towards First (Container). If no equal element is found, then Reverse_Find returns No_E lement. Otherwise, it 
returns a cursor designating the first equal element encountered. 
function  Contains (Container : List; 
                   Item      : Element_Type) return Boolean; 
Equivalent to Find (Containe r, Item) /= No_Element. 119/2 
120/2 
121/2 
122/3 
123/2 
124/2 
125/2 
126/2 
127/2 
128/2 
129/2 
130/2 
131/2 
132/2 
133/2 
134/2 
135/2 
136/2 
137/2 
138/2 
Ada Reference Manual — 2012 Edition 
A.18.3    The Generic Package Containers.Doubl y_Linked_Lists 13 December 2012      502 Paragraphs 139 and 140 were moved above.   
procedure  Iterate 
  (Container : in List; 
   Process   : not null access procedure  (Position : in Cursor)); 
Iterate calls Process. all with a cursor that designates each node in Container, starting with the 
first node and moving the cursor as per the Ne xt function. Tampering with the cursors of 
Container is prohibited during the execution of a call on Process. all. Any exception raised by 
Process. all is propagated. 
procedure  Reverse_Iterate 
  (Container : in List; 
   Process   : not null access procedure  (Position : in Cursor)); 
Iterates over the nodes in Container as per proce dure Iterate, except that elements are traversed 
in reverse order, starting with the last node and moving the cursor as per the Previous function. 
function  Iterate (Container : in List) 
   return List_Iterator_Interfaces.Reversible_Iterator'Class; 
Iterate returns a reversible iterator object (see 5.5.1) that will generate a value for a loop 
parameter (see 5.5.2) designating each node in Cont ainer, starting with the first node and moving 
the cursor as per the Next function when used as  a forward iterator, and starting with the last 
node and moving the cursor as per the Previous  function when used as a reverse iterator. 
Tampering with the cursors of Container is prohibited while the iterator object exists (in 
particular, in the sequence_of_statements  of the loop_statement  whose iterator_specification  
denotes this object). The iterator object needs finalization. 
function  Iterate (Container : in List; Start : in Cursor) 
   return List_Iterator_Interfaces.Reversible_Iterator'Class; 
If Start is not No_Element and does not designate an item in C ontainer, then Program_Error is 
propagated. If Start is No_Element, then Constr aint_Error is propagated. Otherwise, Iterate 
returns a reversible iterator object (see 5.5.1) th at will generate a value for a loop parameter (see 
5.5.2) designating each node in Container, starti ng with the node designated by Start and moving 
the cursor as per the Next function when used as  a forward iterator, or moving the cursor as per 
the Previous function when used as a reverse itera tor. Tampering with the cursors of Container is 
prohibited while the iterator object exists (in particular, in the sequence_of_statements  of the 
loop_statement  whose iterator_specification  denotes this object). The iterator object needs 
finalization. 
The actual function for the generic formal function "<" of  Generic_Sorting is expected to return the same 
value each time it is called with a particular pair of el ement values. It should define a strict weak ordering 
relationship (see A.18); it should not modify Containe r. If the actual for "<" behaves in some other 
manner, the behavior of the subprograms of Generi c_Sorting are unspecified. The number of times the 
subprograms of Generic_Sorting call "<" is unspecified. 
function  Is_Sorted (Container : List) return Boolean; 
Returns True if the elements are sorted smallest first as determined by the generic formal "<" 
operator; otherwise, Is_Sorted returns False. Any exception raised during evaluation of "<" is 
propagated. 141/2 
142/3 
143/2 
144/3 
144.1/3 
144.2/3 
144.3/3 
144.4/3 
145/3 
146/2 
147/2 
Ada Reference Manual — 2012 Edition 
503      13 December 2012 The Generic P ackage Containers.Doubly_Linked_Lists   A.18.3 procedure  Sort (Container : in out List); 
Reorders the nodes of Container such that the elemen ts are sorted smallest first as determined by 
the generic formal "<" operator provided. The sort is stable. Any exception raised during 
evaluation of "<" is propagated. 
procedure  Merge (Target  : in out List; 
                 Source  : in out List); 
If Source is empty, then Merge does nothing. If Source and Target are the same nonempty 
container object, then Program_Error is propagate d. Otherwise, Merge removes elements from 
Source and inserts them into Target; afterwards, Target contains the union of the elements that 
were initially in Source and Target; Source is left  empty. If Target and Source are initially sorted 
smallest first, then Target is ordered smallest first as determ ined by the generic formal "<" 
operator; otherwise, the order of  elements in Target is unspecified. Any exception raised during 
evaluation of "<" is propagated. 
Bounded (Run-Time) Errors 
Calling Merge in an instance of Generic_Sorting with either Source or Target not ordered smallest first 
using the provided generic formal "<" operator is a bounded error. Either Program_Error is raised after 
Target is updated as described for Merg e, or the operation works as defined. 
It is a bounded error for the actual function associated  with a generic formal subprogram, when called as 
part of an operation of this package, to tamper with elements of any List parameter of the operation. Either 
Program_Error is raised, or the operation works as defi ned on the value of the List either prior to, or 
subsequent to, some or all of the modifications to the List. 
It is a bounded error to call any subprogram  declared in the visible part of 
Containers.Doubly_Linked_Lists when the associated container has been finalized. If the operation takes 
Container as an in out  parameter, then it raises Constraint _Error or Program_Error. Otherwise, the 
operation either proceeds as it would for an empty container, or it raises Constraint_Error or Program_Error.  
Erroneous Execution 
A Cursor value is invalid  if any of the following have occurred since it was created:  
• The list that contains the element it designates has been finalized; 
• The list that contains the element it designates has been used as the Target of a call to Assign, or 
as the target of an assignment_statement ; 
• The list that contains the element it designates has been used as the Source or Target of a call to 
Move; or  
• The element it designates has been removed from the list that previously contained the element.  
The result of "=" or Has_Element is unspecified if it is called with an invalid cursor parameter. Execution 
is erroneous if any other subprogram  declared in Containers.Doubly_Linke d_Lists is called with an invalid 
cursor parameter.  
Execution is erroneous if the list asso ciated with the result of a call to Reference or Constant_Reference is 
finalized before the result object returned by the ca ll to Reference or Constant_Reference is finalized.  
Implementation Requirements 
No storage associated with a doubly-linked List obj ect shall be lost upon assignment or scope exit. 148/2 
149/2 
150/2 
151/3 
152/2 
152.1/3 
152.2/3 
153/2 
154/2 
154.1/3 
155/2 156/3 
157/2 
157.1/3 
158/2 
Ada Reference Manual — 2012 Edition 
A.18.3    The Generic Package Containers.Doubl y_Linked_Lists 13 December 2012      504 The execution of an assignment_statement  for a list shall have the effect of copying the elements from 
the source list object to the target list object and cha nging the length of the target object to that of the 
source object. 
Implementation Advice 
Containers.Doubly_Linked_Lists should be implemented similarly to a linked list. In particular, if N is the 
length of a list, then the worst-cas e time complexity of Element, Inse rt with Count=1, and Delete with 
Count=1 should be O(log N).  
The worst-case time complexity of a call on procedure Sort of an instance of 
Containers.Doubly_Linked_Lists .Generic_Sorting should be O(N**2), and the average time complexity 
should be better than O(N**2).  
Move should not copy elements, and should mini mize copying of internal data structures.  
If an exception is propagated from a list operation, no storage should be lost, nor  any elements removed 
from a list unless specified by the operation.  
NOTES 
50  Sorting a list never copies elements, and is a stable sort (equal elements remain in the original order). This is different  
than sorting an array or vector, which may need to copy elements, and is probably not a stable sort.  
A.18.4 Maps 
The language-defined generic packages Containers .Hashed_Maps and Containers.Ordered_Maps provide 
private types Map and Cursor, and a set of operations for each type. A map container allows an arbitrary type to be used as a key to find the element associated with that key. A hashed map uses a hash function to organize the keys, while an ordered map orde rs the keys per a specified relation.  
This subclause describes the declarations that are common to both kinds of maps. See A.18.5 for a 
description of the semantics specific to Containe rs.Hashed_Maps and A.18.6 for a description of the 
semantics specific to Containers.Ordered_Maps.  
Static Semantics 
The actual function for the generic formal function "=" on Element_Type values is expected to define a 
reflexive and symmetric relationship and return the same result value each time it is called with a particular pair of values. If it behaves in some ot her manner, the function "=" on map values returns an 
unspecified value. The exact arguments and number of ca lls of this generic formal function by the function 
"=" on map values are unspecified. 
The type Map is used to represent maps. The type Map needs finalization (see 7.6). 
A map contains pairs of keys and elements, called nodes . Map cursors designate nodes, but also can be 
thought of as designating an element (the element c ontained in the node) for consistency with the other 
containers. There exists an equivalence relation on keys , whose definition is different for hashed maps and 
ordered maps. A map never c ontains two or more nodes with equivalent keys. The length  of a map is the 
number of nodes it contains. 
Each nonempty map has two particular nodes called the first node  and the last node  (which may be the 
same). Each node except for the last node has a successor node . If there are no other intervening 
operations, starting with the first node and repeated ly going to the successor node will visit each node in 
the map exactly once until the last node is reached. Th e exact definition of these terms is different for 
hashed maps and ordered maps. 159/3 
160/2 
161/2 
162/2 
163/2 
164/2 
1/2 
2/3 
3/2 
4/2 
5/2 
6/2 
Ada Reference Manual — 2012 Edition 
505      13 December 2012 Maps   A.18.4 Some operations of these generic packages have  access-to-subprogram parameters. To ensure such 
operations are well-defined, they guard against certain  actions by the designated subprogram. In particular, 
some operations check for “tampering with cursors” of a container because they depend on the set of elements of the container remaining constant, and others check for “tampering with elements” of a container because they depend on elements of the container not being replaced. 
A subprogram is said to tamper with cursors  of a map object M if: 
• it inserts or deletes elements of M, that is, it calls the Insert, Include, Clear, Delete, or Exclude 
procedures with M as a parameter; or 
• it finalizes M; or 
• it calls the Assign procedure with M as the Target parameter; or 
• it calls the Move procedure with M as a parameter; or 
• it calls one of the operations define d to tamper with the cursors of M. 
A subprogram is said to tamper with elements  of a map object M if: 
• it tampers with cursors of M; or 
• it replaces one or more elements of M, that is, it calls the Replace or Replace_Element 
procedures with M as a parameter. 
When tampering with cursors is prohibited  for a particular map object M, Program_Error is propagated by 
a call of any language-defined subprogram that is defined to tamper with the cursors of M, leaving M 
unmodified. Similarly, when tampering with elements is prohibited  for a particular map object M, 
Program_Error is propagated by a call of any language-def ined subprogram that is defined to tamper with 
the elements of M (or tamper with the cursors of M), leaving M unmodified.  
Empty_Map represents the empty Map object. It has a length of 0. If an object of type Map is not 
otherwise initialized, it is initialized to the same value as Empty_Map. 
No_Element represents a cursor that designates no node. If an object of type Cursor is not otherwise 
initialized, it is initialized to th e same value as No_Element. 
The predefined "=" operator for type Cursor returns Tr ue if both cursors are No_Element, or designate the 
same element in the same container. 
Execution of the default implementati on of the Input, Output, Read, or Write attribute of type Cursor 
raises Program_Error. 
Map'Write for a Map object M writes Length( M) elements of the map to the stream. It also may write 
additional information about the map. 
Map'Read reads the representation of a map from the stream, and assigns to Item a map with the same 
length and elements as was written by Map'Write. 
function  Has_Element (Position : Cursor) return Boolean; 
Returns True if Position designates an element, and returns False otherwise. 
function  "=" (Left, Right : Map) return Boolean; 
If Left and Right denote the same map object, then  the function returns True. If Left and Right 
have different lengths, then the function returns False. Otherwise, for each key K in Left, the 
function returns False if: 
• a key equivalent to K is not present in Right; or 7/2 
8/2 
9/2 
10/2 
10.1/3 
11/2 12/2 13/2 
14/2 
15/2 
15.1/3 
16/2 
17/2 18/2 19/2 
19.1/3 19.2/3 
19.3/3 
19.4/3 
20/2 
21/2 
22/2 
Ada Reference Manual — 2012 Edition 
A.18.4    Maps 13 December 2012      506 • the element associated with K in Left is not equal to the element associated with K in 
Right (using the generic formal equality operator for elements).  
If the function has not returned a result after checking all of the keys, it returns True. Any 
exception raised during evaluation of key equiva lence or element equality is propagated.  
function  Length (Container : Map) return Count_Type; 
Returns the number of nodes in Container. 
function  Is_Empty (Container : Map) return Boolean; 
Equivalent to Length (Container) = 0. 
procedure  Clear (Container : in out Map); 
Removes all the nodes from Container. 
function  Key (Position : Cursor) return Key_Type; 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Key returns the 
key component of the node designated by Position. 
function  Element (Position : Cursor) return Element_Type; 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Element returns 
the element component of the node designated by Position. 
procedure  Replace_Element (Container : in out Map; 
                           Position  : in     Cursor; 
                           New_Item  : in     Element_Type); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Replace_Element assigns New_Item to the element of the node designated by Position. 
procedure  Query_Element 
  (Position : in Cursor; 
   Process  : not null access procedure  (Key     : in Key_Type; 
                                         Element : in Element_Type)); 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Query_Element 
calls Process. all with the key and element from the node designated by Position as the 
arguments. Tampering with the elements of the map that contains the element designated by Position is prohibited during the execution of the call on Process. all. Any exception raised by 
Process. all is propagated. 
procedure  Update_Element 
  (Container : in out Map; 
   Position  : in     Cursor; 
   Process   : not null access procedure  (Key     : in     Key_Type; 
                                          Element : in out Element_Type)); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Update_Element calls Process. all with the key and element from the node designated by 
Position as the arguments. Tampering with the el ements of Container is prohibited during the 
execution of the call on Process. all. Any exception raised by Process. all is propagated. 
If Element_Type is unconstrained and definite, then the actual Element parameter of Process. all 
shall be unconstrained. 23/2 
24/2 
25/2 
26/2 
27/2 
28/2 
29/2 
30/2 
31/2 
32/2 
33/2 
34/2 
35/2 
36/3 
37/2 
38/3 
39/2 
40/3 
41/2 
Ada Reference Manual — 2012 Edition 
507      13 December 2012 Maps   A.18.4 type Constant_Reference_Type 
      (Element : not null access constant  Element_Type) is private  
   with Implicit_Dereference => Element; 
type Reference_Type (Element : not null access  Element_Type) is private  
   with Implicit_Dereference => Element; 
The types Constant_Reference_Type and Reference_Type need finalization. 
The default initialization of an object of type  Constant_Reference_Type or Reference_Type 
propagates Program_Error. 
function  Constant_Reference (Container : aliased in  Map; 
                             Position  : in Cursor) 
   return Constant_Reference_Type; 
This function (combined with the Constant_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read access to an individual element of a map given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Constant_Reference returns an object whose discri minant is an access value that designates the 
element designated by Position. Tampering with the elements of Container is prohibited while 
the object returned by Constant_Referen ce exists and has not been finalized. 
function  Reference (Container : aliased in out  Map; 
                    Position  : in Cursor) 
   return Reference_Type; 
This function (combined with the Variable_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read and write access to an individual element of a map given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then Progr am_Error is propagated. Otherwise, Reference 
returns an object whose discriminant is an access value that designates the element designated by Position. Tampering with the elements of Cont ainer is prohibited while the object returned by 
Reference exists and has not been finalized. 
function  Constant_Reference (Container : aliased in  Map; 
                             Key       : in Key_Type) 
   return Constant_Reference_Type; 
This function (combined with the Constant_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read access to an individual element of a map given a key value. 
Equivalent to Constant_Reference (C ontainer, Find (Container, Key)). 
function  Reference (Container : aliased in out  Map; 
                    Key       : in Key_Type) 
   return Reference_Type; 
This function (combined with the Variable_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read and write access to  an individual element of a map given a key 
value. 
Equivalent to Reference (Contai ner, Find (Container, Key)). 41.1/3 
41.2/3 
41.3/3 
41.4/3 
41.5/3 
41.6/3 
41.7/3 
41.8/3 
41.9/3 
41.10/3 
41.11/3 
41.12/3 
41.13/3 
41.14/3 
41.15/3 
41.16/3 
Ada Reference Manual — 2012 Edition 
A.18.4    Maps 13 December 2012      508 procedure  Assign (Target : in out Map; Source : in Map); 
If Target denotes the same object as Source,  the operation has no effect. Otherwise, the 
key/element pairs of Source are copied to Target as for an assignment_statement  assigning 
Source to Target.  
procedure  Move (Target : in out Map; 
                Source : in out Map); 
If Target denotes the same object as Source, then the operation has no effect. Otherwise, the 
operation is equivalent to Assign (Targe t, Source) followed by Clear (Source). 
procedure  Insert (Container : in out Map; 
                  Key       : in     Key_Type; 
                  New_Item  : in     Element_Type; 
                  Position  :    out Cursor; 
                  Inserted  :    out Boolean); 
Insert checks if a node with a key equivalent to Ke y is already present in Container. If a match is 
found, Inserted is set to False and Position designates the element with the matching key. 
Otherwise, Insert allocates a new node, initiali zes it to Key and New_Item, and adds it to 
Container; Inserted is set to True and Po sition designates the newly-inserted node. Any 
exception raised during allocation is propa gated and Container is not modified. 
procedure  Insert (Container : in out Map; 
                  Key       : in     Key_Type; 
                  Position  :    out Cursor; 
                  Inserted  :    out Boolean); 
Insert inserts Key into Container as per the five -parameter Insert, with the difference that an 
element initialized by default (see 3.3.1) is inserted. 
procedure  Insert (Container : in out Map; 
                  Key       : in     Key_Type; 
                  New_Item  : in     Element_Type); 
Insert inserts Key and New_Item  into Container as per the five-parameter Insert, with the 
difference that if a node with a key equivale nt to Key is already in the map, then 
Constraint_Error is propagated. 
procedure  Include (Container : in out Map; 
                   Key       : in     Key_Type; 
                   New_Item  : in     Element_Type); 
Include inserts Key and New_Item into Container as per the five-parameter Insert, with the 
difference that if a node with a key equivalent to  Key is already in the map, then this operation 
assigns Key and New_Item to the matching node . Any exception raised during assignment is 
propagated. 
procedure  Replace (Container : in out Map; 
                   Key       : in     Key_Type; 
                   New_Item  : in     Element_Type); 
Replace checks if a node with a key equivalent to  Key is present in Container. If a match is 
found, Replace assigns Key and New_Item to the matching node; otherwise, Constraint_Error is 
propagated. 41.17/3 
41.18/3 
42/2 
43/3 
44/2 
45/2 
46/2 
47/2 
48/2 
49/2 
50/2 
51/2 
52/2 
53/2 
Ada Reference Manual — 2012 Edition 
509      13 December 2012 Maps   A.18.4 procedure  Exclude (Container : in out Map; 
                   Key       : in     Key_Type); 
Exclude checks if a node with a key equivalent to  Key is present in Container. If a match is 
found, Exclude removes the node from the map. 
procedure  Delete (Container : in out Map; 
                  Key       : in     Key_Type); 
Delete checks if a node with a key equivalent to Key is present in Container. If a match is found, 
Delete removes the node from the map; othe rwise, Constraint_Error is propagated. 
procedure  Delete (Container : in out Map; 
                  Position  : in out Cursor); 
If Position equals No_Element, then Constrai nt_Error is propagated. If Position does not 
designate an element in Container, then Pr ogram_Error is propagated.  Otherwise, Delete 
removes the node designated by Position from the ma p. Position is set to No_Element on return. 
function  First (Container : Map) return Cursor; 
If Length (Container) = 0, then First returns No_Ele ment. Otherwise, First returns a cursor that 
designates the first node in Container. 
function  Next (Position  : Cursor) return Cursor; 
Returns a cursor that designates the successor of the node designated by Position. If Position 
designates the last node, then No_Element is returned. If Position equals No_Element, then 
No_Element is returned. 
procedure  Next (Position  : in out Cursor); 
Equivalent to Position := Next (Position). 
function  Find (Container : Map; 
               Key       : Key_Type) return Cursor; 
If Length (Container) equals 0, then Find return s No_Element. Otherwise, Find checks if a node 
with a key equivalent to Key is present in C ontainer. If a match is found, a cursor designating 
the matching node is returned; othe rwise, No_Element is returned. 
function  Element (Container : Map; 
                  Key       : Key_Type) return Element_Type; 
Equivalent to Element (Find (Container, Key)). 
function  Contains (Container : Map; 
                   Key       : Key_Type) return Boolean; 
Equivalent to Find (Containe r, Key) /= No_Element. 
Paragraphs 72 and 73 were moved above.   
procedure  Iterate 
  (Container : in Map; 
   Process   : not null access procedure  (Position : in Cursor)); 
Iterate calls Process. all with a cursor that designates each node in Container, starting with the 
first node and moving the cursor according to the successor relation. Tampering with the cursors 
of Container is prohibited during the execution of a call on Process. all. Any exception raised by 
Process. all is propagated. 54/2 
55/2 
56/2 
57/2 
58/2 
59/2 
60/2 
61/2 
62/2 
63/2 
64/2 
65/2 
66/2 
67/2 
68/2 
69/2 
70/2 
71/2 
74/2 
75/3 
Ada Reference Manual — 2012 Edition 
A.18.4    Maps 13 December 2012      510 Bounded (Run-Time) Errors 
It is a bounded error for the actual function associated  with a generic formal subprogram, when called as 
part of an operation of a map package, to tamper w ith elements of any map parameter of the operation. 
Either Program_Error is raised, or the operation works as defined on the value of the map either prior to, 
or subsequent to, some or all of  the modifications to the map. 
It is a bounded error to call any subprogram declared in the visible part of a map package when the 
associated container has been finalized. If the operation takes Container as an in out  parameter, then it 
raises Constraint_Error or Program_Error. Otherwise,  the operation either proceeds as it would for an 
empty container, or it raises C onstraint_Error or Program_Error.  
Erroneous Execution 
A Cursor value is invalid  if any of the following have occurred since it was created:  
• The map that contains the node it designates has been finalized; 
• The map that contains the node it designates has b een used as the Target of a call to Assign, or 
as the target of an assignment_statement ; 
• The map that contains the node it designates has b een used as the Source or  Target of a call to 
Move; or 
• The node it designates has been removed from th e map that previously contained the node.  
The result of "=" or Has_Element is unspecified if these functions are called with an invalid cursor 
parameter. Execution is erroneous if any other s ubprogram declared in C ontainers.Hashed_Maps or 
Containers.Ordered_Maps is called w ith an invalid cursor parameter. 
Execution is erroneous if the map associated with th e result of a call to Reference or Constant_Reference 
is finalized before the result object returned by the call to Reference or Constant_Reference is finalized.  
Implementation Requirements 
No storage associated with a Map object sh all be lost upon assignment or scope exit. 
The execution of an assignment_statement  for a map shall have the effect of copying the elements from 
the source map object to the target map object and cha nging the length of the target object to that of the 
source object. 
Implementation Advice 
Move should not copy elements, and should mini mize copying of internal data structures.  
If an exception is propagated from a map operation, no storage should be lost, nor  any elements removed 
from a map unless specified by the operation.  75.1/3 
75.2/3 
76/2 
77/2 
77.1/3 
78/2 79/3 
80/2 
80.1/3 
81/2 
82/3 
83/2 
84/2 
Ada Reference Manual — 2012 Edition 
511      13 December 2012 The Generic Package Containers.Hashed_Maps   A.18.5 A.18.5 The Generic Package Containers.Hashed_Maps 
Static Semantics 
The generic library package Containers.Has hed_Maps has the following declaration:  
with Ada.Iterator_Interfaces; 
generic 
   type Key_Type is private ; 
   type Element_Type is private ; 
   with function  Hash (Key : Key_Type) return Hash_Type; 
   with function  Equivalent_Keys (Left, Right : Key_Type) 
      return Boolean; 
   with function  "=" (Left, Right : Element_Type) 
      return Boolean is <>; 
package Ada.Containers.Hashed_Maps is 
   pragma Preelaborate(Hashed_Maps); 
   pragma Remote_Types(Hashed_Maps); 
   type Map is tagged private  
      with Constant_Indexing => Constant_Reference, 
           Variable_Indexing => Reference,            Default_Iterator  => Iterate,            Iterator_Element  => Element_Type;    pragma Preelaborable_Initialization(Map); 
   type Cursor is private ; 
   pragma Preelaborable_Initialization(Cursor); 
   Empty_Map : constant  Map; 
   No_Element : constant  Cursor; 
   function  Has_Element (Position : Cursor) return Boolean; 
   package Map_Iterator_Interfaces is new 
       Ada.Iterator_Interfaces (Cursor, Has_Element); 
   function  "=" (Left, Right : Map) return Boolean; 
   function  Capacity (Container : Map) return Count_Type; 
   procedure  Reserve_Capacity (Container : in out Map; 
                               Capacity  : in     Count_Type); 
   function  Length (Container : Map) return Count_Type; 
   function  Is_Empty (Container : Map) return Boolean; 
   procedure  Clear (Container : in out Map); 
   function  Key (Position : Cursor) return Key_Type; 
   function  Element (Position : Cursor) return Element_Type; 
   procedure  Replace_Element (Container : in out Map; 
                              Position  : in     Cursor; 
                              New_Item  : in     Element_Type); 
   procedure  Query_Element 
     (Position : in Cursor; 
      Process  : not null access procedure  (Key     : in Key_Type; 
                                            Element : in Element_Type)); 
   procedure  Update_Element 
     (Container : in out Map; 
      Position  : in     Cursor; 
      Process   : not null access procedure  
                      (Key     : in     Key_Type; 
                       Element : in out Element_Type)); 
   type Constant_Reference_Type 
         (Element : not null access constant  Element_Type) is private  
      with Implicit_Dereference => Element; 1/2 
2/3 
3/3 
4/2 
5/2 
6/2 
6.1/3 6.2/3 
7/2 
8/2 9/2 
10/2 
11/2 12/2 13/2 14/2 15/2 
16/2 
17/2 
17.1/3 
Ada Reference Manual — 2012 Edition 
A.18.5    The Generic Package Containers .Hashed_Maps 13 December 2012      512    type Reference_Type (Element : not null access  Element_Type) is private  
      with Implicit_Dereference => Element; 
   function  Constant_Reference (Container : aliased in  Map; 
                                Position  : in Cursor) 
      return Constant_Reference_Type; 
   function  Reference (Container : aliased in out  Map; 
                       Position  : in Cursor) 
      return Reference_Type; 
   function  Constant_Reference (Container : aliased in  Map; 
                                Key       : in Key_Type) 
      return Constant_Reference_Type; 
   function  Reference (Container : aliased in out  Map; 
                       Key       : in Key_Type) 
      return Reference_Type; 
   procedure  Assign (Target : in out Map; Source : in Map); 
   function  Copy (Source : Map; Capacity : Count_Type := 0) return Map; 
   procedure  Move (Target : in out Map; 
                   Source : in out Map); 
   procedure  Insert (Container : in out Map; 
                     Key       : in     Key_Type; 
                     New_Item  : in     Element_Type; 
                     Position  :    out Cursor; 
                     Inserted  :    out Boolean); 
   procedure  Insert (Container : in out Map; 
                     Key       : in     Key_Type; 
                     Position  :    out Cursor; 
                     Inserted  :    out Boolean); 
   procedure  Insert (Container : in out Map; 
                     Key       : in     Key_Type; 
                     New_Item  : in     Element_Type); 
   procedure  Include (Container : in out Map; 
                      Key       : in     Key_Type; 
                      New_Item  : in     Element_Type); 
   procedure  Replace (Container : in out Map; 
                      Key       : in     Key_Type; 
                      New_Item  : in     Element_Type); 
   procedure  Exclude (Container : in out Map; 
                      Key       : in     Key_Type); 
   procedure  Delete (Container : in out Map; 
                     Key       : in     Key_Type); 
   procedure  Delete (Container : in out Map; 
                     Position  : in out Cursor); 
   function  First (Container : Map) 
      return Cursor; 
   function  Next (Position  : Cursor) return Cursor; 
   procedure  Next (Position  : in out Cursor); 
   function  Find (Container : Map; 
                  Key       : Key_Type)       return Cursor; 
   function  Element (Container : Map; 
                     Key       : Key_Type)       return Element_Type; 
   function  Contains (Container : Map; 
                      Key       : Key_Type) return Boolean; 
This paragraph was deleted.  17.2/3 
17.3/3 
17.4/3 17.5/3 17.6/3 17.7/3 
17.8/3 
18/2 
19/2 
20/2 
21/2 
22/2 23/2 24/2 
25/2 26/2 27/2 28/2 
29/2 30/2 
31/2 32/2 
33/3 
Ada Reference Manual — 2012 Edition 
513      13 December 2012 The Generic Package Containers.Hashed_Maps   A.18.5    function  Equivalent_Keys (Left, Right : Cursor) 
      return Boolean; 
   function  Equivalent_Keys (Left  : Cursor; 
                             Right : Key_Type)       return Boolean; 
   function  Equivalent_Keys (Left  : Key_Type; 
                             Right : Cursor)       return Boolean; 
   procedure  Iterate 
     (Container : in Map; 
      Process   : not null access procedure  (Position : in Cursor)); 
   function  Iterate (Container : in Map) 
      return Map_Iterator_Interfaces.Forward_Iterator'Class; 
private 
   ... -- not specified by the language  
end Ada.Containers.Hashed_Maps; 
An object of type Map contains an expandable hash ta ble, which is used to provide direct access to nodes. 
The capacity  of an object of type Map is the maximum numbe r of nodes that can be inserted into the hash 
table prior to it being automatically expanded. 
Two keys K1 and K2 are defined to be equivalent  if Equivalent_Keys ( K1, K2) returns True. 
The actual function for the generic formal function Hash  is expected to return the same value each time it 
is called with a particular key value. For any two equi valent key values, the actual for Hash is expected to 
return the same value. If the actual for Hash behaves in  some other manner, the behavior of this package is 
unspecified. Which subprograms of this package call Hash, and how many times they call it, is 
unspecified. 
The actual function for the generic formal function E quivalent_Keys on Key_Type values is expected to 
return the same value each time it is called with a pa rticular pair of key values. It should define an 
equivalence relationship, that is, be reflexive, symme tric, and transitive. If the actual for Equivalent_Keys 
behaves in some other manner, the behavior of this package is unsp ecified. Which subprograms of this 
package call Equivalent_Keys, and how many times they call it, is unspecified. 
If the value of a key stored in a node of a map is cha nged other than by an operation in this package such 
that at least one of Hash or Equivalent_Keys give different results, the behavior of this package is 
unspecified. 
Which nodes are the first node and the last node of a map, and which node is the successor of a given 
node, are unspecified, other than the ge neral semantics desc ribed in A.18.4. 
function  Capacity (Container : Map) return Count_Type; 
Returns the capacity of Container. 
procedure  Reserve_Capacity (Container : in out Map; 
                            Capacity  : in     Count_Type); 
Reserve_Capacity allocates a new hash table such that the length of the resulting map can 
become at least the value Capacity without requi ring an additional call to Reserve_Capacity, and 
is large enough to hold the current length of Cont ainer. Reserve_Capacity then rehashes the 
nodes in Container onto the new hash table. It replaces the old hash table with the new hash 
table, and then deallocates the old hash ta ble. Any exception raised during allocation is 
propagated and Container is not modified. 
Reserve_Capacity tampers with the cursors of Container. 34/2 
35/2 
36/2 37/2 
37.1/3 
38/2 
39/2 40/2 
41/2 
42/2 
43/2 
44/2 
45/2 
46/2 
47/2 
48/2 
49/2 
50/2 
51/2 
Ada Reference Manual — 2012 Edition 
A.18.5    The Generic Package Containers .Hashed_Maps 13 December 2012      514 procedure  Clear (Container : in out Map); 
In addition to the semantics desc ribed in A.18.4, Clear does not affect the capacity of Container. 
procedure  Assign (Target : in out Map; Source : in Map); 
In addition to the semantics desc ribed in A.18.4, if the length of Source is greater than the 
capacity of Target, Reserve_Capacity (Target,  Length (Source)) is called before assigning any 
elements. 
function  Copy (Source : Map; Capacity : Count_Type := 0) return Map; 
Returns a map whose keys and elements are initia lized from the keys and elements of Source. If 
Capacity is 0, then the map capacity is the length of Source; if Capacity is equal to or greater 
than the length of Source, the map capacity is at least the specified value. Otherwise, the 
operation propagates Capacity_Error. 
procedure  Insert (Container : in out Map; 
                  Key       : in     Key_Type; 
                  New_Item  : in     Element_Type; 
                  Position  :    out Cursor; 
                  Inserted  :    out Boolean); 
In addition to the semantics described in A. 18.4, if Length (Container) equals Capacity 
(Container), then Insert first calls Reserve_Cap acity to increase the capacity of Container to 
some larger value. 
function  Equivalent_Keys (Left, Right : Cursor) 
      return Boolean; 
Equivalent to Equivalent_Keys (Key (Left), Key (Right)). 
function  Equivalent_Keys (Left  : Cursor; 
                          Right : Key_Type) return Boolean; 
Equivalent to Equivalent_Keys (Key (Left), Right). 
function  Equivalent_Keys (Left  : Key_Type; 
                          Right : Cursor) return Boolean; 
Equivalent to Equivalent_K eys (Left, Key (Right)). 
function  Iterate (Container : in Map) 
   return Map_Iterator_Interfaces.Forward_Iterator'Class; 
Iterate returns an iterator object (see 5.5.1) that  will generate a value for a loop parameter (see 
5.5.2) designating each node in Container, star ting with the first node and moving the cursor 
according to the successor relation. Tampering with the cursors of Container is prohibited while the iterator object exists (in particular, in the 
sequence_of_statements  of the loop_statement  
whose iterator_specification  denotes this object). The iterator object needs finalization. 
Implementation Advice 
If N is the length of a map, the average time comple xity of the subprograms El ement, Insert, Include, 
Replace, Delete, Exclude and Find that  take a key parameter should be O(log N). The average time 
complexity of the subprograms that take a cursor parameter should be O(1). The average time complexity 
of Reserve_Capacity should be O(N).  52/2 
53/2 
53.1/3 
53.2/3 
53.3/3 
53.4/3 
54/2 
55/2 
56/2 
57/2 
58/2 
59/2 
60/2 
61/2 
61.1/3 
61.2/3 
62/2 
Ada Reference Manual — 2012 Edition 
515      13 December 2012 The Generic Package Containers.Ordered_Maps   A.18.6 A.18.6 The Generic Package Containers.Ordered_Maps 
Static Semantics 
The generic library package Containers.Ord ered_Maps has the following declaration:  
with Ada.Iterator_Interfaces; 
generic 
   type Key_Type is private ; 
   type Element_Type is private ; 
   with function  "<" (Left, Right : Key_Type) return Boolean is <>; 
   with function  "=" (Left, Right : Element_Type) return Boolean is <>; 
package Ada.Containers.Ordered_Maps is 
   pragma Preelaborate(Ordered_Maps); 
   pragma Remote_Types(Ordered_Maps); 
   function  Equivalent_Keys (Left, Right : Key_Type) return Boolean; 
   type Map is tagged private  
      with Constant_Indexing => Constant_Reference, 
           Variable_Indexing => Reference,            Default_Iterator  => Iterate,            Iterator_Element  => Element_Type;    pragma Preelaborable_Initialization(Map); 
   type Cursor is private ; 
   pragma Preelaborable_Initialization(Cursor); 
   Empty_Map : constant  Map; 
   No_Element : constant  Cursor; 
   function  Has_Element (Position : Cursor) return Boolean; 
   package Map_Iterator_Interfaces is new 
       Ada.Iterator_Interfaces (Cursor, Has_Element); 
   function  "=" (Left, Right : Map) return Boolean; 
   function  Length (Container : Map) return Count_Type; 
   function  Is_Empty (Container : Map) return Boolean; 
   procedure  Clear (Container : in out Map); 
   function  Key (Position : Cursor) return Key_Type; 
   function  Element (Position : Cursor) return Element_Type; 
   procedure  Replace_Element (Container : in out Map; 
                              Position  : in     Cursor; 
                              New_Item  : in     Element_Type); 
   procedure  Query_Element 
     (Position : in Cursor; 
      Process  : not null access procedure  (Key     : in Key_Type; 
                                            Element : in Element_Type)); 
   procedure  Update_Element 
     (Container : in out Map; 
      Position  : in     Cursor; 
      Process   : not null access procedure  
                      (Key     : in     Key_Type; 
                       Element : in out Element_Type)); 
   type Constant_Reference_Type 
         (Element : not null access constant  Element_Type) is private  
      with Implicit_Dereference => Element; 
   type Reference_Type (Element : not null access  Element_Type) is private  
      with Implicit_Dereference => Element; 
   function  Constant_Reference (Container : aliased in  Map; 
                                Position  : in Cursor) 
      return Constant_Reference_Type; 1/2 
2/3 
3/2 
4/3 
5/2 
6/2 
7/2 
7.1/3 7.2/3 
8/2 
9/2 
10/2 11/2 12/2 13/2 14/2 
15/2 
16/2 
16.1/3 
16.2/3 
16.3/3 
Ada Reference Manual — 2012 Edition 
A.18.6    The Generic Package Containers.O rdered_Maps 13 December 2012      516    function  Reference (Container : aliased in out  Map; 
                       Position  : in Cursor) 
      return Reference_Type; 
   function  Constant_Reference (Container : aliased in  Map; 
                                Key       : in Key_Type) 
      return Constant_Reference_Type; 
   function  Reference (Container : aliased in out  Map; 
                       Key       : in Key_Type) 
      return Reference_Type; 
   procedure  Assign (Target : in out Map; Source : in Map); 
   function  Copy (Source : Map) return Map; 
   procedure  Move (Target : in out Map; 
                   Source : in out Map); 
   procedure  Insert (Container : in out Map; 
                     Key       : in     Key_Type; 
                     New_Item  : in     Element_Type; 
                     Position  :    out Cursor; 
                     Inserted  :    out Boolean); 
   procedure  Insert (Container : in out Map; 
                     Key       : in     Key_Type; 
                     Position  :    out Cursor; 
                     Inserted  :    out Boolean); 
   procedure  Insert (Container : in out Map; 
                     Key       : in     Key_Type; 
                     New_Item  : in     Element_Type); 
   procedure  Include (Container : in out Map; 
                      Key       : in     Key_Type; 
                      New_Item  : in     Element_Type); 
   procedure  Replace (Container : in out Map; 
                      Key       : in     Key_Type; 
                      New_Item  : in     Element_Type); 
   procedure  Exclude (Container : in out Map; 
                      Key       : in     Key_Type); 
   procedure  Delete (Container : in out Map; 
                     Key       : in     Key_Type); 
   procedure  Delete (Container : in out Map; 
                     Position  : in out Cursor); 
   procedure  Delete_First (Container : in out Map); 
   procedure  Delete_Last (Container : in out Map); 
   function  First (Container : Map) return Cursor; 
   function  First_Element (Container : Map) return Element_Type; 
   function  First_Key (Container : Map) return Key_Type; 
   function  Last (Container : Map) return Cursor; 
   function  Last_Element (Container : Map) return Element_Type; 
   function  Last_Key (Container : Map) return Key_Type; 
   function  Next (Position : Cursor) return Cursor; 
   procedure  Next (Position : in out Cursor); 
   function  Previous (Position : Cursor) return Cursor; 
   procedure  Previous (Position : in out Cursor); 
   function  Find (Container : Map; 
                  Key       : Key_Type) return Cursor; 
   function  Element (Container : Map; 
                     Key       : Key_Type) return Element_Type; 16.4/3 
16.5/3 16.6/3 16.7/3 
16.8/3 
17/2 
18/2 
19/2 
20/2 
21/2 22/2 23/2 
24/2 25/2 26/2 
27/2 28/2 29/2 30/2 31/2 32/2 33/2 34/2 35/2 36/2 37/2 38/2 
39/2 
Ada Reference Manual — 2012 Edition 
517      13 December 2012 The Generic Package Containers.Ordered_Maps   A.18.6    function  Floor (Container : Map; 
                   Key       : Key_Type) return Cursor; 
   function  Ceiling (Container : Map; 
                     Key       : Key_Type) return Cursor; 
   function  Contains (Container : Map; 
                      Key       : Key_Type) return Boolean; 
This paragraph was deleted.  
   function  "<" (Left, Right : Cursor) return Boolean; 
   function  ">" (Left, Right : Cursor) return Boolean; 
   function  "<" (Left : Cursor; Right : Key_Type) return Boolean; 
   function  ">" (Left : Cursor; Right : Key_Type) return Boolean; 
   function  "<" (Left : Key_Type; Right : Cursor) return Boolean; 
   function  ">" (Left : Key_Type; Right : Cursor) return Boolean; 
   procedure  Iterate 
     (Container : in Map; 
      Process   : not null access procedure  (Position : in Cursor)); 
   procedure  Reverse_Iterate 
     (Container : in Map; 
      Process   : not null access procedure  (Position : in Cursor)); 
   function  Iterate (Container : in Map) 
      return Map_Iterator_Interfaces.Reversible_Iterator'Class; 
   function  Iterate (Container : in Map; Start : in Cursor) 
      return Map_Iterator_Interfaces.Reversible_Iterator'Class; 
private 
   ... -- not specified by the language  
end Ada.Containers.Ordered_Maps; 
Two keys K1 and K2 are equivalent  if both K1 < K2 and K2 < K1 return False, using the generic formal 
"<" operator for keys. Function Equiva lent_Keys returns True if Left a nd Right are equivalent, and False 
otherwise. 
The actual function for the generic formal function "<" on Key_Type values is expected to return the same 
value each time it is called with a particular pair of key values. It should define a strict weak ordering 
relationship (see A.18). If the actual for "<" behaves in some ot her manner, the behavior of this package is 
unspecified. Which subprograms of this  package call "<" and how many tim es they call it, is unspecified. 
If the value of a key stored in a map is changed other th an by an operation in this package such that at least 
one of "<" or "=" give different results, th e behavior of this p ackage is unspecified. 
The first node  of a nonempty map is the one whose key is le ss than the key of all the other nodes in the 
map. The last node  of a nonempty map is the one whose key is  greater than the key of all the other 
elements in the map. The successor  of a node is the node with the smalle st key that is larger than the key 
of the given node. The predecessor  of a node is the node with the larges t key that is smaller than the key 
of the given node. All comparisons are done usi ng the generic formal "<" operator for keys. 
function  Copy (Source : Map) return Map; 
Returns a map whose keys and elements ar e initialized from the corresponding keys and 
elements of Source. 
procedure  Delete_First (Container : in out Map); 
If Container is empty, Delete_First has no e ffect. Otherwise, the node designated by First 
(Container) is removed from Contai ner. Delete_First tampers with  the cursors of Container. 40/2 
41/2 42/2 43/3 
44/2 45/2 46/2 47/2 48/2 49/2 50/2 
51/2 
51.1/3 
51.2/3 
52/2 
53/2 54/2 
55/2 
56/3 
57/2 
58/3 
58.1/3 
58.2/3 
59/2 
60/3 
Ada Reference Manual — 2012 Edition 
A.18.6    The Generic Package Containers.O rdered_Maps 13 December 2012      518 procedure  Delete_Last (Container : in out Map); 
If Container is empty, Delete_Last has no eff ect. Otherwise, the node designated by Last 
(Container) is removed from Contai ner. Delete_Last tampers with  the cursors of Container. 
function  First_Element (Container : Map) return Element_Type; 
Equivalent to Element (First (Container)). 
function  First_Key (Container : Map) return Key_Type; 
Equivalent to Key (First (Container)). 
function  Last (Container : Map) return Cursor; 
Returns a cursor that designates the last node in Container. If Container is empty, returns 
No_Element. 
function  Last_Element (Container : Map) return Element_Type; 
Equivalent to Element (Last (Container)). 
function  Last_Key (Container : Map) return Key_Type; 
Equivalent to Key (Last (Container)). 
function  Previous (Position : Cursor) return Cursor; 
If Position equals No_Element, then Previous re turns No_Element. Otherwise, Previous returns 
a cursor designating the predecessor node of the one designated by Position. If Position 
designates the first element, then Previous returns No_Element. 
procedure  Previous (Position : in out Cursor); 
Equivalent to Position := Previous (Position). 
function  Floor (Container : Map; 
                Key       : Key_Type) return Cursor; 
Floor searches for the last node whose key is not greater than Key, using the generic formal "<" 
operator for keys. If such a node is found, a curs or that designates it is returned. Otherwise, 
No_Element is returned. 
function  Ceiling (Container : Map; 
                  Key       : Key_Type) return Cursor; 
Ceiling searches for the first node whose key is not less than Key, using the generic formal "<" 
operator for keys. If such a node is found, a curs or that designates it is returned. Otherwise, 
No_Element is returned. 
function  "<" (Left, Right : Cursor) return Boolean; 
Equivalent to Key (Left) < Key (Right). 
function  ">" (Left, Right : Cursor) return Boolean; 
Equivalent to Key (Right) < Key (Left). 
function  "<" (Left : Cursor; Right : Key_Type) return Boolean; 
Equivalent to Key (Left) < Right. 61/2 
62/3 
63/2 
64/2 
65/2 
66/2 
67/2 
68/2 
69/2 
70/2 
71/2 
72/2 
73/2 
74/3 
75/2 
76/2 
77/2 
78/3 
79/2 
80/3 
81/2 
82/2 
83/2 
84/2 
85/2 
86/2 
Ada Reference Manual — 2012 Edition 
519      13 December 2012 The Generic Package Containers.Ordered_Maps   A.18.6 function  ">" (Left : Cursor; Right : Key_Type) return Boolean; 
Equivalent to Right < Key (Left). 
function  "<" (Left : Key_Type; Right : Cursor) return Boolean; 
Equivalent to Left < Key (Right). 
function  ">" (Left : Key_Type; Right : Cursor) return Boolean; 
Equivalent to Key (Right) < Left. 
procedure  Reverse_Iterate 
  (Container : in Map; 
   Process   : not null access procedure  (Position : in Cursor)); 
Iterates over the nodes in Container as per proce dure Iterate, with the difference that the nodes 
are traversed in predecessor order, starting with the last node. 
function  Iterate (Container : in Map) 
   return Map_Iterator_Interfaces.Reversible_Iterator'Class; 
Iterate returns a reversible iterator object (see 5.5.1) that will generate a value for a loop 
parameter (see 5.5.2) designating each node in Cont ainer, starting with the first node and moving 
the cursor according to the successor relation when used as a forward iterator, and starting with 
the last node and moving the cursor according to the predecessor relation when used as a reverse 
iterator. Tampering with the cursors of Container is prohibited while the iterator object exists (in 
particular, in the sequence_of_statements  of the loop_statement  whose iterator_specification  
denotes this object). The iterator object needs finalization. 
function  Iterate (Container : in Map; Start : in Cursor) 
   return Map_Iterator_Interfaces.Reversible_Iterator'Class; 
If Start is not No_Element and does not designate an item in C ontainer, then Program_Error is 
propagated. If Start is No_Element, then Constr aint_Error is propagated. Otherwise, Iterate 
returns a reversible iterator object (see 5.5.1) th at will generate a value for a loop parameter (see 
5.5.2) designating each node in Container, starti ng with the node designated by Start and moving 
the cursor according to the successor relation when  used as a forward iterator, or moving the 
cursor according to the predecessor relation when us ed as a reverse iterator. Tampering with the 
cursors of Container is prohibited while the iterator object exists (in particular, in the 
sequence_of_statements  of the loop_statement  whose iterator_specification  denotes this 
object). The iterator object needs finalization. 
Implementation Advice 
If N is the length of a map, then the worst-case time co mplexity of the Element, Insert, Include, Replace, 
Delete, Exclude and Find operations th at take a key parameter should be O((log N)**2) or better. The 
worst-case time complexity of the subprograms that take a cursor parameter should be O(1).  
A.18.7 Sets 
The language-defined generic packages Containers .Hashed_Sets and Containe rs.Ordered_Sets provide 
private types Set and Cursor, and a set of operations for each type. A set container allows elements of an arbitrary type to be stored without duplication. A ha shed set uses a hash func tion to organize elements, 
while an ordered set orders its el ement per a specified relation.  87/2 
88/2 
89/2 
90/2 
91/2 
92/2 
93/2 
94/3 
94.1/3 
94.2/3 
94.3/3 
94.4/3 
95/2 
1/2 
Ada Reference Manual — 2012 Edition 
A.18.7    Sets 13 December 2012      520 This subclause describes the declarations that are common to both kinds of sets. See A.18.8 for a 
description of the semantics specific to Containe rs.Hashed_Sets and A.18.9 for a description of the 
semantics specific to Containers.Ordered_Sets.  
Static Semantics 
The actual function for the generic formal function "=" on Element_Type values is expected to define a 
reflexive and symmetric relationship and return the same result value each time it is called with a particular pair of values. If it behaves in some ot her manner, the function "=" on set values returns an 
unspecified value. The exact arguments and number of ca lls of this generic formal function by the function 
"=" on set values are unspecified. 
The type Set is used to re present sets. The type Set needs finalization (see 7.6). 
A set contains elements. Set cursors designate elements. There exists an equivalence relation on elements, 
whose definition is different for hash ed sets and ordered sets. A set neve r contains two or more equivalent 
elements. The length  of a set is the number of elements it contains. 
Each nonempty set has two particular elements called the first element  and the last element  (which may be 
the same). Each element except for the last element has a successor element . If there are no other 
intervening operations, starting with the first elemen t and repeatedly going to the successor element will 
visit each element in the set exactly once until the last  element is reached. The exact definition of these 
terms is different for hash ed sets and ordered sets. 
Some operations of these generic packages have  access-to-subprogram parameters. To ensure such 
operations are well-defined, they guard against certain  actions by the designated subprogram. In particular, 
some operations check for “tampering with cursors” of a container because they depend on the set of elements of the container remaining constant, and others check for “tampering with elements” of a container because they depend on elements of the container not being replaced. 
A subprogram is said to tamper with cursors  of a set object S if: 
• it inserts or deletes elements of S, that is, it calls the Insert, In clude, Clear, Delete, Exclude, or 
Replace_Element procedures with S as a parameter; or 
• it finalizes S; or 
• it calls the Assign procedure with S as the Target parameter; or 
• it calls the Move procedure with S as a parameter; or 
• it calls one of the operations defi ned to tamper with cursors of S. 
A subprogram is said to tamper with elements  of a set object S if: 
• it tampers with cursors of S. 
When tampering with cursors is prohibited  for a particular set object S, Program_Error is propagated by a 
call of any language-defined subprogram that is  defined to tamper with the cursors of S, leaving S 
unmodified. Similarly, when tampering with elements is prohibited  for a particular set object S, 
Program_Error is propagated by a call of any language-def ined subprogram that is defined to tamper with 
the elements of S (or tamper with the cursors of S), leaving S unmodified.  
Empty_Set represents the empty Set obj ect. It has a length of 0. If an object of type Set is not otherwise 
initialized, it is initialized to th e same value as Empty_Set. 
No_Element represents a cursor that designates no elem ent. If an object of type Cursor is not otherwise 
initialized, it is initialized to th e same value as No_Element. 2/3 
3/2 
4/2 
5/2 
6/2 
7/2 
8/2 
9/2 
10/2 
10.1/3 
11/2 12/2 13/2 
14/2 
14.1/3 
15/2 
16/2 
Ada Reference Manual — 2012 Edition 
521      13 December 2012 Sets   A.18.7 The predefined "=" operator for type Cursor returns Tr ue if both cursors are No_Element, or designate the 
same element in the same container. 
Execution of the default implementati on of the Input, Output, Read, or Write attribute of type Cursor 
raises Program_Error. 
Set'Write for a Set object S writes Length( S) elements of the set to the stream. It also may write additional 
information about the set. 
Set'Read reads the representation of a set from the stream, and assigns to Item a set with the same length 
and elements as was written by Set'Write. 
function  Has_Element (Position : Cursor) return Boolean; 
Returns True if Position designates an element, and returns False otherwise. 
function  "=" (Left, Right : Set) return Boolean; 
If Left and Right denote the same set object, then  the function returns True. If Left and Right 
have different lengths, then the function returns False. Otherwise, for each element E in Left, the 
function returns False if an element equal to E (using the generic formal equality operator) is not 
present in Right. If the function has not returned a result after checking all of the elements, it returns True. Any exception raised during eval uation of element equality is propagated.  
function  Equivalent_Sets (Left, Right : Set) return Boolean; 
If Left and Right denote the same set object, then  the function returns True. If Left and Right 
have different lengths, then the function returns False. Otherwise, for each element E in Left, the 
function returns False if an element equivalent to E is not present in Right. If the function has 
not returned a result after checking all of the elements, it returns True. Any exception raised 
during evaluation of element equivalence is propagated. 
function  To_Set (New_Item : Element_Type) return Set; 
Returns a set containing the single element New_Item. 
function  Length (Container : Set) return Count_Type; 
Returns the number of el ements in Container. 
function  Is_Empty (Container : Set) return Boolean; 
Equivalent to Length (Container) = 0. 
procedure  Clear (Container : in out Set); 
Removes all the elements from Container. 
function  Element (Position : Cursor) return Element_Type; 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Element returns 
the element designated by Position. 
procedure  Replace_Element (Container : in out Set; 
                           Position  : in     Cursor; 
                           New_Item  : in     Element_Type); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then Program _Error is propagated. If an element equivalent 
to New_Item is already present in Container at  a position other than Position, Program_Error is 17/2 
18/2 
18.1/3 18.2/3 
18.3/3 
18.4/3 
19/2 
20/2 
21/2 
22/2 
23/2 
24/2 
25/2 
26/2 
27/2 
28/2 
29/2 
30/2 
31/2 
32/2 
33/2 
34/2 
Ada Reference Manual — 2012 Edition 
A.18.7    Sets 13 December 2012      522 propagated. Otherwise, Replace_Element assigns  New_Item to the element designated by 
Position. Any exception raised by  the assignment is propagated. 
procedure  Query_Element 
  (Position : in Cursor; 
   Process  : not null access procedure  (Element : in Element_Type)); 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Query_Element 
calls Process. all with the element designated by Positi on as the argument. Tampering with the 
elements of the set that contains the elemen t designated by Position is prohibited during the 
execution of the call on Process. all. Any exception raised by Process. all is propagated. 
type Constant_Reference_Type 
      (Element : not null access constant  Element_Type) is private  
   with Implicit_Dereference => Element; 
The type Constant_Reference_Type needs finalization. 
The default initialization of an object of type Constant_Reference_Type propagates 
Program_Error. 
function  Constant_Reference (Container : aliased in  Set; 
                             Position  : in Cursor) 
   return Constant_Reference_Type; 
This function (combined with the Constant_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read access to an individual element of a set given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Constant_Reference returns an object whose discri minant is an access value that designates the 
element designated by Position. Tampering with the elements of Container is prohibited while 
the object returned by Constant_Referen ce exists and has not been finalized. 
procedure  Assign (Target : in out Set; Source : in Set); 
If Target denotes the same object as Source, the operation has no effect. Otherwise, the elements 
of Source are copied to Target as for an assignment_statement  assigning Source to Target.  
procedure  Move (Target : in out Set; 
                Source : in out Set); 
If Target denotes the same object as Source, then the operation has no effect. Otherwise, the 
operation is equivalent to Assign (Targe t, Source) followed by Clear (Source). 
procedure  Insert (Container : in out Set; 
                  New_Item  : in     Element_Type; 
                  Position  :    out Cursor; 
                  Inserted  :    out Boolean); 
Insert checks if an element equivalent to New_Item  is already present in Container. If a match is 
found, Inserted is set to False and Position desi gnates the matching element. Otherwise, Insert 
adds New_Item to Container; Inserted is set to  True and Position designates the newly-inserted 
element. Any exception raised during allocation is propagated and Container is not modified. 
procedure  Insert (Container : in out Set; 
                  New_Item  : in     Element_Type); 
Insert inserts New_Item into Container as per th e four-parameter Insert, with the difference that 
if an element equivalent to New_Item is already in the set, then Constraint_Error is propagated. 35/2 
36/3 
36.1/3 
36.2/3 
36.3/3 
36.4/3 
36.5/3 
36.6/3 
36.7/3 
36.8/3 
37/2 
38/3 
39/2 
40/2 
41/2 
42/2 
Ada Reference Manual — 2012 Edition 
523      13 December 2012 Sets   A.18.7 procedure  Include (Container : in out Set; 
                   New_Item  : in     Element_Type); 
Include inserts New_Item into Container as per the four-parameter Insert, with the difference 
that if an element equivalent to New_Item is al ready in the set, then it is replaced. Any exception 
raised during assignment is propagated. 
procedure  Replace (Container : in out Set; 
                   New_Item  : in     Element_Type); 
Replace checks if an element equivalent to New_It em is already in the set. If a match is found, 
that element is replaced with New_Item; ot herwise, Constraint_Error is propagated. 
procedure  Exclude (Container : in out Set; 
                   Item      : in     Element_Type); 
Exclude checks if an element equivalent to Item  is present in Container. If a match is found, 
Exclude removes the element from the set. 
procedure  Delete (Container : in out Set; 
                  Item      : in     Element_Type); 
Delete checks if an element equivalent to Item  is present in Container. If a match is found, 
Delete removes the element from the set; ot herwise, Constraint_Error is propagated. 
procedure  Delete (Container : in out Set; 
                  Position  : in out Cursor); 
If Position equals No_Element, then Constrai nt_Error is propagated. If Position does not 
designate an element in Container, then Pr ogram_Error is propagated.  Otherwise, Delete 
removes the element designated by Position from the set. Position is set to No_Element on 
return. 
procedure  Union (Target : in out Set; 
                 Source : in     Set); 
Union inserts into Target the elements of Source that are not equivalent to some element already 
in Target. 
function  Union (Left, Right : Set) return Set; 
Returns a set comprising all of the elements of Left, and the elements of Right that are not 
equivalent to some element of Left. 
procedure  Intersection (Target : in out Set; 
                        Source : in     Set); 
Intersection deletes from Target the elements of Target that are not equivalent to some element 
of Source. 
function  Intersection (Left, Right : Set) return Set; 
Returns a set comprising all the elements of Left that are equivalent to the some element of 
Right. 
procedure  Difference (Target : in out Set; 
                      Source : in     Set); 
If Target denotes the same object as Source, then Difference clears Target. Otherwise, it deletes 
from Target the elements that are equivalent to some element of Source. 43/2 
44/2 
45/2 
46/2 
47/2 
48/2 
49/2 
50/2 
51/2 
52/2 
53/2 
54/2 
55/2 
56/2 
57/2 
58/3 
59/2 
60/2 
61/2 
62/2 
Ada Reference Manual — 2012 Edition 
A.18.7    Sets 13 December 2012      524 function  Difference (Left, Right : Set) return Set; 
Returns a set comprising the elements of Left that are not equivalent to some element of Right. 
procedure  Symmetric_Difference (Target : in out Set; 
                                Source : in     Set); 
If Target denotes the same object as Source, then Symmetric_Difference clears Target. 
Otherwise, it deletes from Target the elements that are equivalent to some element of Source, and inserts into Target the elements of Source that  are not equivalent to some element of Target. 
function  Symmetric_Difference (Left, Right : Set) return Set; 
Returns a set comprising the elements of Left that are not equivalent to some element of Right, 
and the elements of Right that are not equivalent to some element of Left. 
function  Overlap (Left, Right : Set) return Boolean; 
If an element of Left is equivalent to some element of Right, then Overlap returns True. 
Otherwise, it returns False. 
function  Is_Subset (Subset : Set; 
                    Of_Set : Set) return Boolean; 
If an element of Subset is not equivalent to some element of Of_Set, then Is_Subset returns 
False. Otherwise, it returns True. 
function  First (Container : Set) return Cursor; 
If Length (Container) = 0, then First returns No_Ele ment. Otherwise, First returns a cursor that 
designates the first element in Container. 
function  Next (Position  : Cursor) return Cursor; 
Returns a cursor that designates the successor of  the element designated by Position. If Position 
designates the last element, then No_Element is  returned. If Position equals No_Element, then 
No_Element is returned. 
procedure  Next (Position  : in out Cursor); 
Equivalent to Position := Next (Position). 
This paragraph was deleted.  
function  Find (Container : Set; 
               Item      : Element_Type) return Cursor; 
If Length (Container) equals 0, then Find return s No_Element. Otherwise, Find checks if an 
element equivalent to Item is present in Container. If a match is found, a cursor designating the 
matching element is returned; othe rwise, No_Element is returned. 
function  Contains (Container : Set; 
                   Item      : Element_Type) return Boolean; 
Equivalent to Find (Containe r, Item) /= No_Element. 
Paragraphs 83 and 84 were moved above.   63/2 
64/2 
65/2 
66/2 
67/2 
68/2 
69/2 
70/3 
71/2 
72/3 
73/2 
74/2 
75/2 
76/2 
77/2 
78/2 
79/3 
80/2 
81/2 
82/2 
82.1/3 
Ada Reference Manual — 2012 Edition 
525      13 December 2012 Sets   A.18.7 procedure  Iterate 
  (Container : in Set; 
   Process   : not null access procedure  (Position : in Cursor)); 
Iterate calls Process. all with a cursor that designates each el ement in Container, starting with the 
first element and moving the cursor according to the successor relation. Tampering with the cursors of Container is prohibited during the execution of a call on Process. all. Any exception 
raised by Process. all is propagated. 
Both Containers.Hashed_Set and Cont ainers.Ordered_Set declare a nested generic package Generic_Keys, 
which provides operations that allow se t manipulation in terms of a key (typically, a portion of an element) 
instead of a complete element. The formal function Key of Generic_Keys extracts a key value from an element. It is expected to return the same value each time it is called with a particular element. The 
behavior of Generic_Keys is unspecified  if Key behaves in some other manner. 
A key is expected to unambiguously determine a singl e equivalence class for elements. The behavior of 
Generic_Keys is unspecified if the formal paramete rs of this package behave in some other manner. 
function  Key (Position : Cursor) return Key_Type; 
Equivalent to Key (Element (Position)).  
The subprograms in package Generic_Keys named C ontains, Find, Element, Delete, and Exclude, are 
equivalent to the corresponding subprograms in the pa rent package, with the difference that the Key 
parameter is used to locate an element in the set. 
procedure  Replace (Container : in out Set; 
                   Key       : in     Key_Type; 
                   New_Item  : in     Element_Type); 
Equivalent to Replace_Element (Containe r, Find (Container, Key), New_Item). 
procedure  Update_Element_Preserving_Key 
  (Container : in out Set; 
   Position  : in     Cursor; 
   Process   : not null access procedure  
                                 (Element : in out Element_Type)); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then Pr ogram_Error is propagated.  Otherwise, Update_-
Element_Preserving_Key uses Key to save the key value K of the element designated by 
Position. Update_Element_Prese rving_Key then calls Process. all with that element as the 
argument. Tampering with the elements of Cont ainer is prohibited during the execution of the 
call on Process. all. Any exception raised by Process. all is propagated. After Process. all returns, 
Update_Element_Preserving_Key checks if K determines the same equivalence class as that for 
the new element; if not, the element is remove d from the set and Program_Error is propagated. 
If Element_Type is unconstrained and definite, then the actual Element parameter of Process. all 
shall be unconstrained. 
type Reference_Type (Element : not null access  Element_Type) is private  
   with Implicit_Dereference => Element; 
The type Reference_Type needs finalization. 
The default initialization of an object of ty pe Reference_Type propagates Program_Error. 85/2 
86/3 
87/2 
88/2 
89/2 
90/2 
91/2 
92/2 
93/2 
94/2 
95/3 
96/2 
96.1/3 
96.2/3 
96.3/3 
Ada Reference Manual — 2012 Edition 
A.18.7    Sets 13 December 2012      526 function  Reference_Preserving_Key (Container : aliased in out  Set; 
                                   Position  : in Cursor) 
   return Reference_Type; 
This function (combined with the Implicit_Dereference aspect) provides a convenient way to 
gain read and write access to an individual element of a set given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Reference_Preserving_Key uses Key to save the key value K; then returns an object whose 
discriminant is an access value that designates the element designated by Position. Tampering 
with the elements of Container is pr ohibited while the object returned by 
Reference_Preserving_Key exists and has not b een finalized. When the object returned by 
Reference_Preserving_Key is fi nalized, a check is made if K determines the same equivalence 
class as that for the new element; if not, the element is removed from the set and Program_Error is propagated. 
function  Constant_Reference (Container : aliased in  Set; 
                             Key       : in Key_Type) 
   return Constant_Reference_Type; 
This function (combined with the Implicit_Dereference aspect) provides a convenient way to 
gain read access to an individual element of a set given a key value. 
Equivalent to Constant_Reference (C ontainer, Find (Container, Key)). 
function  Reference_Preserving_Key (Container : aliased in out  Set; 
                                   Key       : in Key_Type) 
   return Reference_Type; 
This function (combined with the Implicit_Dereference aspect) provides a convenient way to 
gain read and write access to an individual element of a set given a key value. 
Equivalent to Reference_Preserving_Key (Container, Find (Container, Key)).  
Bounded (Run-Time) Errors 
It is a bounded error for the actual function associated  with a generic formal subprogram, when called as 
part of an operation of a set package, to tamper with elements of any set parameter of the operation. Either 
Program_Error is raised, or the operation works as de fined on the value of the set either prior to, or 
subsequent to, some or all of the modifications to the set. 
It is a bounded error to call any subprogram declared in the visible part of a set package when the 
associated container has been finalized. If the operation takes Container as an in out  parameter, then it 
raises Constraint_Error or Program_Error. Otherwise,  the operation either proceeds as it would for an 
empty container, or it raises C onstraint_Error or Program_Error.  
Erroneous Execution 
A Cursor value is invalid  if any of the following have occurred since it was created:  
• The set that contains the element it designates has been finalized; 
• The set that contains the element it designates has been used as the Target of a call to Assign, or 
as the target of an assignment_statement ; 
• The set that contains the element it designates has been used as the Source or Target of a call to 
Move; or 
• The element it designates has been removed from the set that previously contained the element.  96.4/3 
96.5/3 
96.6/3 
96.7/3 
96.8/3 
96.9/3 
96.10/3 
96.11/3 
96.12/3 
96.13/3 
96.14/3 
97/2 
98/2 
98.1/3 
99/2 
100/3 
Ada Reference Manual — 2012 Edition 
527      13 December 2012 Sets   A.18.7 The result of "=" or Has_Element is unspecified if these functions are called with an invalid cursor 
parameter. Execution is erroneous if any other s ubprogram declared in C ontainers.Hashed_Sets or 
Containers.Ordered_Sets is called w ith an invalid cursor parameter. 
Execution is erroneous if the set associated with the result of a call to Reference or Constant_Reference is 
finalized before the result object returned by the ca ll to Reference or Constant_Reference is finalized.  
Implementation Requirements 
No storage associated with a Set object sh all be lost upon assignment or scope exit. 
The execution of an assignment_statement  for a set shall have the effect of copying the elements from 
the source set object to the target set object and cha nging the length of the target object to that of the 
source object. 
Implementation Advice 
Move should not copy elements, and should mini mize copying of internal data structures.  
If an exception is propagated from a set operation, no storage should be lost, nor  any elements removed 
from a set unless specified by the operation.  
A.18.8 The Generic Package Containers.Hashed_Sets 
Static Semantics 
The generic library package Containers.Hashed_Sets has the following declaration:  
with Ada.Iterator_Interfaces; 
generic 
   type Element_Type is private ; 
   with function  Hash (Element : Element_Type) return Hash_Type; 
   with function  Equivalent_Elements (Left, Right : Element_Type) 
                 return Boolean; 
   with function  "=" (Left, Right : Element_Type) return Boolean is <>; 
package Ada.Containers.Hashed_Sets is 
   pragma Preelaborate(Hashed_Sets); 
   pragma Remote_Types(Hashed_Sets); 
   type Set is tagged private  
      with Constant_Indexing => Constant_Reference, 
           Default_Iterator  => Iterate,            Iterator_Element  => Element_Type;    pragma Preelaborable_Initialization(Set); 
   type Cursor is private ; 
   pragma Preelaborable_Initialization(Cursor); 
   Empty_Set : constant  Set; 
   No_Element : constant  Cursor; 
   function  Has_Element (Position : Cursor) return Boolean; 
   package Set_Iterator_Interfaces is new 
       Ada.Iterator_Interfaces (Cursor, Has_Element); 
   function  "=" (Left, Right : Set) return Boolean; 
   function  Equivalent_Sets (Left, Right : Set) return Boolean; 
   function  To_Set (New_Item : Element_Type) return Set; 
   function  Capacity (Container : Set) return Count_Type; 
   procedure  Reserve_Capacity (Container : in out Set; 
                               Capacity  : in     Count_Type); 101/2 
101.1/3 
102/2 
103/3 
104/2 
105/2 
1/2 
2/3 
3/3 
4/2 
5/2 
6/2 
6.1/3 6.2/3 
7/2 
8/2 9/2 
10/2 11/2 
Ada Reference Manual — 2012 Edition 
A.18.8    The Generic Package Containers .Hashed_Sets 13 December 2012      528    function  Length (Container : Set) return Count_Type; 
   function  Is_Empty (Container : Set) return Boolean; 
   procedure  Clear (Container : in out Set); 
   function  Element (Position : Cursor) return Element_Type; 
   procedure  Replace_Element (Container : in out Set; 
                              Position  : in     Cursor; 
                              New_Item  : in     Element_Type); 
   procedure  Query_Element 
     (Position : in Cursor; 
      Process  : not null access procedure  (Element : in Element_Type)); 
   type Constant_Reference_Type 
         (Element : not null access constant  Element_Type) is private  
      with Implicit_Dereference => Element; 
   function  Constant_Reference (Container : aliased in  Set; 
                                Position  : in Cursor) 
      return Constant_Reference_Type; 
   procedure  Assign (Target : in out Set; Source : in Set); 
   function  Copy (Source : Set; Capacity : Count_Type := 0) return Set; 
   procedure  Move (Target : in out Set; 
                   Source : in out Set); 
   procedure  Insert (Container : in out Set; 
                     New_Item  : in     Element_Type; 
                     Position  :    out Cursor; 
                     Inserted  :    out Boolean); 
   procedure  Insert (Container : in out Set; 
                     New_Item  : in     Element_Type); 
   procedure  Include (Container : in out Set; 
                      New_Item  : in     Element_Type); 
   procedure  Replace (Container : in out Set; 
                      New_Item  : in     Element_Type); 
   procedure  Exclude (Container : in out Set; 
                      Item      : in     Element_Type); 
   procedure  Delete (Container : in out Set; 
                     Item      : in     Element_Type); 
   procedure  Delete (Container : in out Set; 
                     Position  : in out Cursor); 
   procedure  Union (Target : in out Set; 
                    Source : in     Set); 
   function  Union (Left, Right : Set) return Set; 
   function  "or" (Left, Right : Set) return Set renames Union; 
   procedure  Intersection (Target : in out Set; 
                           Source : in     Set); 
   function  Intersection (Left, Right : Set) return Set; 
   function  "and" (Left, Right : Set) return Set renames Intersection; 
   procedure  Difference (Target : in out Set; 
                         Source : in     Set); 
   function  Difference (Left, Right : Set) return Set; 
   function  "-" (Left, Right : Set) return Set renames Difference; 
   procedure  Symmetric_Difference (Target : in out Set; 
                                   Source : in     Set); 
   function  Symmetric_Difference (Left, Right : Set) return Set; 
   function  "xor" (Left, Right : Set) return Set 
     renames Symmetric_Difference; 12/2 
13/2 14/2 15/2 16/2 
17/2 
17.1/3 17.2/3 17.3/3 
17.4/3 
18/2 
19/2 
20/2 
21/2 22/2 23/2 24/2 25/2 26/2 27/2 
28/2 29/2 
30/2 
31/2 32/2 
33/2 
34/2 35/2 
36/2 
37/2 
Ada Reference Manual — 2012 Edition 
529      13 December 2012 The Generic Package Containers.Hashed_Sets   A.18.8    function  Overlap (Left, Right : Set) return Boolean; 
   function  Is_Subset (Subset : Set; 
                       Of_Set : Set) return Boolean; 
   function  First (Container : Set) return Cursor; 
   function  Next (Position : Cursor) return Cursor; 
   procedure  Next (Position : in out Cursor); 
   function  Find (Container : Set; 
                  Item      : Element_Type) return Cursor; 
   function  Contains (Container : Set; 
                      Item      : Element_Type) return Boolean; 
This paragraph was deleted.  
   function  Equivalent_Elements (Left, Right : Cursor) 
     return Boolean; 
   function  Equivalent_Elements (Left  : Cursor; 
                                 Right : Element_Type)      return Boolean; 
   function  Equivalent_Elements (Left  : Element_Type; 
                                 Right : Cursor)      return Boolean; 
   procedure  Iterate 
     (Container : in Set; 
      Process   : not null access procedure  (Position : in Cursor)); 
   function  Iterate (Container : in Set) 
      return Set_Iterator_Interfaces.Forward_Iterator'Class; 
   generic 
      type Key_Type (<>) is private ; 
      with function  Key (Element : Element_Type) return Key_Type; 
      with function  Hash (Key : Key_Type) return Hash_Type; 
      with function  Equivalent_Keys (Left, Right : Key_Type) 
                                     return Boolean; 
   package Generic_Keys is 
      function  Key (Position : Cursor) return Key_Type; 
      function  Element (Container : Set; 
                        Key       : Key_Type)         return Element_Type; 
      procedure  Replace (Container : in out Set; 
                         Key       : in     Key_Type; 
                         New_Item  : in     Element_Type); 
      procedure  Exclude (Container : in out Set; 
                         Key       : in     Key_Type); 
      procedure  Delete (Container : in out Set; 
                        Key       : in     Key_Type); 
      function  Find (Container : Set; 
                     Key       : Key_Type)          return Cursor; 
      function  Contains (Container : Set; 
                         Key       : Key_Type)          return Boolean; 
      procedure  Update_Element_Preserving_Key 
        (Container : in out Set; 
         Position  : in     Cursor; 
         Process   : not null access procedure  
                         (Element : in out Element_Type)); 
      type Reference_Type 
            (Element : not null access  Element_Type) is private  
         with Implicit_Dereference => Element; 38/2 
39/2 
40/2 
41/2 42/2 43/2 
44/2 45/3 
46/2 
47/2 
48/2 49/2 
49.1/3 
50/2 
51/2 
52/2 
53/2 54/2 
55/2 56/2 
57/2 58/2 
58.1/3 
Ada Reference Manual — 2012 Edition 
A.18.8    The Generic Package Containers .Hashed_Sets 13 December 2012      530       function  Reference_Preserving_Key (Container : aliased in out  Set; 
                                         Position  : in Cursor) 
         return Reference_Type; 
      function  Constant_Reference (Container : aliased in  Set; 
                                   Key       : in Key_Type) 
         return Constant_Reference_Type; 
      function  Reference_Preserving_Key (Container : aliased in out  Set; 
                                         Key       : in Key_Type) 
         return Reference_Type; 
   end Generic_Keys; 
private 
   ... -- not specified by the language  
end Ada.Containers.Hashed_Sets; 
An object of type Set contains an expandable hash table, which is used to provide direct access to 
elements. The capacity  of an object of type Set is the maximum number of elements that can be inserted 
into the hash table prior to it being automatically expanded. 
Two elements E1 and E2 are defined to be equivalent  if Equivalent_Elements ( E1, E2) returns True. 
The actual function for the generic formal function Hash  is expected to return the same value each time it 
is called with a particular element value. For any two equivalent elements, the actual for Hash is expected 
to return the same value. If the actual for Hash behave s in some other manner, the behavior of this package 
is unspecified. Which subprograms of  this package call Hash, and how  many times they call it, is 
unspecified. 
The actual function for the generic formal function Equi valent_Elements is expected to return the same 
value each time it is called with a particular pair of  Element values. It should define an equivalence 
relationship, that is, be reflexive, symmetric, and tr ansitive. If the actual for E quivalent_Elements behaves 
in some other manner, the behavior of this package is unspecified. Which subprogr ams of this package call 
Equivalent_Elements, and how many times they call it, is unspecified. 
If the actual function for the generic formal functi on "=" returns True for any pair of nonequivalent 
elements, then the behavior of the container function "=" is unspecified. 
If the value of an element stored in a set is changed ot her than by an operation in this package such that at 
least one of Hash or Equivalent_E lements give different results, th e behavior of this package is 
unspecified. 
Which elements are the first element and the last element of a set, and which element is the successor of a 
given element, are unspecified, other than the general semantics described in A.18.7. 
function  Capacity (Container : Set) return Count_Type; 
Returns the capacity of Container. 
procedure  Reserve_Capacity (Container : in out Set; 
                            Capacity  : in     Count_Type); 
Reserve_Capacity allocates a new hash table such that the length of the resulting set can become 
at least the value Capacity without requiring an additional call to Reserve_Capacity, and is large 
enough to hold the current length of Container. Rese rve_Capacity then reha shes the elements in 
Container onto the new hash table. It replaces th e old hash table with the new hash table, and 
then deallocates the old hash table. Any excep tion raised during allocation is propagated and 
Container is not modified. 
Reserve_Capacity tampers with the cursors of Container. 58.2/3 
58.3/3 58.4/3 
59/2 
60/2 61/2 62/2 
63/2 
64/2 
65/2 
66/2 
66.1/3 
67/2 
68/2 
69/2 
70/2 
71/2 
72/2 
73/2 
Ada Reference Manual — 2012 Edition 
531      13 December 2012 The Generic Package Containers.Hashed_Sets   A.18.8 procedure  Clear (Container : in out Set); 
In addition to the semantics desc ribed in A.18.7, Clear does not affect the capacity of Container. 
procedure  Assign (Target : in out Set; Source : in Set); 
In addition to the semantics desc ribed in A.18.7, if the length of Source is greater than the 
capacity of Target, Reserve_Capacity (Target,  Length (Source)) is called before assigning any 
elements. 
function  Copy (Source : Set; Capacity : Count_Type := 0) return Set; 
Returns a set whose elements are initialized from th e elements of Source. If Capacity is 0, then 
the set capacity is the length of Source; if Capac ity is equal to or greater than the length of 
Source, the set capacity is at least the specified value. Otherwise, the operation propagates Capacity_Error. 
procedure  Insert (Container : in out Set; 
                  New_Item  : in     Element_Type; 
                  Position  :    out Cursor; 
                  Inserted  :    out Boolean); 
In addition to the semantics described in A. 18.7, if Length (Container) equals Capacity 
(Container), then Insert first calls Reserve_Cap acity to increase the capacity of Container to 
some larger value. 
function  First (Container : Set) return Cursor; 
If Length (Container) = 0, then First returns No_Ele ment. Otherwise, First returns a cursor that 
designates the first hashed element in Container. 
function  Equivalent_Elements (Left, Right : Cursor) 
      return Boolean; 
Equivalent to Equivalent_Elements (Element (Left), Element (Right)). 
function  Equivalent_Elements (Left  : Cursor; 
                              Right : Element_Type) return Boolean; 
Equivalent to Equivalent_Eleme nts (Element (Left), Right). 
function  Equivalent_Elements (Left  : Element_Type; 
                              Right : Cursor) return Boolean; 
Equivalent to Equivalent_Eleme nts (Left, Element (Right)). 
function  Iterate (Container : in Set) 
   return Set_Iterator_Interfaces.Forward_Iterator'Class; 
Iterate returns an iterator object (see 5.5.1) that  will generate a value for a loop parameter (see 
5.5.2) designating each element in Container, starting with the first element and moving the cursor according to the successor relation. Tamperi ng with the cursors of Container is prohibited 
while the iterator object exists (in particular, in the 
sequence_of_statements  of the 
loop_statement  whose iterator_specification  denotes this object). The iterator object needs 
finalization. 
For any element E, the actual function for the generic formal function Generic_Keys.Hash is expected to 
be such that Hash ( E) = Generic_Keys.Hash (Key ( E)). If the actuals for Key or Generic_Keys.Hash 
behave in some other manner, th e behavior of Generic_Keys is unspecified. Which subprograms of 
Generic_Keys call Generic_Keys.Hash, and how many times they call it, is unspecified. 74/2 
75/2 
75.1/3 
75.2/3 
75.3/3 
75.4/3 
76/2 
77/2 
78/2 
79/2 
80/2 
81/2 
82/2 
83/2 
84/2 
85/2 
85.1/3 
85.2/3 
86/2 
Ada Reference Manual — 2012 Edition 
A.18.8    The Generic Package Containers .Hashed_Sets 13 December 2012      532 For any two elements E1 and E2, the boolean values Equivalent_Elements ( E1, E2) and Equivalent_Keys 
(Key ( E1), Key ( E2)) are expected to be equal. If the actuals for Key or Equivalent_K eys behave in some 
other manner, the behavior of Ge neric_Keys is unspecified. Which subprograms of Generic_Keys call 
Equivalent_Keys, and how many tim es they call it, is unspecified. 
Implementation Advice 
If N is the length of a set, the average time complexity  of the subprograms Insert, Include, Replace, Delete, 
Exclude and Find that take an  element parameter should be O(log N). The average time complexity of the 
subprograms that take a cursor parameter should be O(1). The average time complexity of 
Reserve_Capacity should be O(N).  
A.18.9 The Generic Package Containers.Ordered_Sets 
Static Semantics 
The generic library package Containers.Ord ered_Sets has the following declaration:  
with Ada.Iterator_Interfaces; 
generic 
   type Element_Type is private ; 
   with function  "<" (Left, Right : Element_Type) return Boolean is <>; 
   with function  "=" (Left, Right : Element_Type) return Boolean is <>; 
package Ada.Containers.Ordered_Sets is 
   pragma Preelaborate(Ordered_Sets); 
   pragma Remote_Types(Ordered_Sets); 
   function  Equivalent_Elements (Left, Right : Element_Type) return Boolean; 
   type Set is tagged private  
      with Constant_Indexing => Constant_Reference, 
           Default_Iterator  => Iterate,            Iterator_Element  => Element_Type;    pragma Preelaborable_Initialization(Set); 
   type Cursor is private ; 
   pragma Preelaborable_Initialization(Cursor); 
   Empty_Set : constant  Set; 
   No_Element : constant  Cursor; 
   function  Has_Element (Position : Cursor) return Boolean; 
   package Set_Iterator_Interfaces is new 
       Ada.Iterator_Interfaces (Cursor, Has_Element); 
   function  "=" (Left, Right : Set) return Boolean; 
   function  Equivalent_Sets (Left, Right : Set) return Boolean; 
   function  To_Set (New_Item : Element_Type) return Set; 
   function  Length (Container : Set) return Count_Type; 
   function  Is_Empty (Container : Set) return Boolean; 
   procedure  Clear (Container : in out Set); 
   function  Element (Position : Cursor) return Element_Type; 
   procedure  Replace_Element (Container : in out Set; 
                              Position  : in     Cursor; 
                              New_Item  : in     Element_Type); 
   procedure  Query_Element 
     (Position : in Cursor; 
      Process  : not null access procedure  (Element : in Element_Type)); 
   type Constant_Reference_Type 
         (Element : not null access constant  Element_Type) is private  
      with Implicit_Dereference => Element; 87/2 
88/2 
1/2 
2/3 
3/2 
4/3 
5/2 
6/2 
7/2 
7.1/3 7.2/3 
8/2 
9/2 
10/2 11/2 12/2 13/2 14/2 15/2 
16/2 
16.1/3 
Ada Reference Manual — 2012 Edition 
533      13 December 2012 The Generic Package Containers.Ordered_Sets   A.18.9    function  Constant_Reference (Container : aliased in  Set; 
                                Position  : in Cursor) 
      return Constant_Reference_Type; 
   procedure  Assign (Target : in out Set; Source : in Set); 
   function  Copy (Source : Set) return Set; 
   procedure  Move (Target : in out Set; 
                   Source : in out Set); 
   procedure  Insert (Container : in out Set; 
                     New_Item  : in     Element_Type; 
                     Position  :    out Cursor; 
                     Inserted  :    out Boolean); 
   procedure  Insert (Container : in out Set; 
                     New_Item  : in     Element_Type); 
   procedure  Include (Container : in out Set; 
                      New_Item  : in     Element_Type); 
   procedure  Replace (Container : in out Set; 
                      New_Item  : in     Element_Type); 
   procedure  Exclude (Container : in out Set; 
                      Item      : in     Element_Type); 
   procedure  Delete (Container : in out Set; 
                     Item      : in     Element_Type); 
   procedure  Delete (Container : in out Set; 
                     Position  : in out Cursor); 
   procedure  Delete_First (Container : in out Set); 
   procedure  Delete_Last (Container : in out Set); 
   procedure  Union (Target : in out Set; 
                    Source : in     Set); 
   function  Union (Left, Right : Set) return Set; 
   function  "or" (Left, Right : Set) return Set renames Union; 
   procedure  Intersection (Target : in out Set; 
                           Source : in     Set); 
   function  Intersection (Left, Right : Set) return Set; 
   function  "and" (Left, Right : Set) return Set renames Intersection; 
   procedure  Difference (Target : in out Set; 
                         Source : in     Set); 
   function  Difference (Left, Right : Set) return Set; 
   function  "-" (Left, Right : Set) return Set renames Difference; 
   procedure  Symmetric_Difference (Target : in out Set; 
                                   Source : in     Set); 
   function  Symmetric_Difference (Left, Right : Set) return Set; 
   function  "xor" (Left, Right : Set) return Set renames 
      Symmetric_Difference; 
   function  Overlap (Left, Right : Set) return Boolean; 
   function  Is_Subset (Subset : Set; 
                       Of_Set : Set) return Boolean; 
   function  First (Container : Set) return Cursor; 
   function  First_Element (Container : Set) return Element_Type; 
   function  Last (Container : Set) return Cursor; 
   function  Last_Element (Container : Set) return Element_Type; 
   function  Next (Position : Cursor) return Cursor; 
   procedure  Next (Position : in out Cursor); 16.2/3 
16.3/3 
16.4/3 
17/2 
18/2 
19/2 
20/2 21/2 22/2 23/2 24/2 25/2 
26/2 27/2 
28/2 
29/2 30/2 
31/2 
32/2 33/2 
34/2 
35/2 36/2 
37/2 
38/2 
39/2 
40/2 
41/2 
42/2 43/2 44/2 45/2 46/2 
Ada Reference Manual — 2012 Edition 
A.18.9    The Generic Package Containers.O rdered_Sets 13 December 2012      534    function  Previous (Position : Cursor) return Cursor; 
   procedure  Previous (Position : in out Cursor); 
   function  Find (Container : Set; 
                  Item      : Element_Type)       return Cursor; 
   function  Floor (Container : Set; 
                   Item      : Element_Type)       return Cursor; 
   function  Ceiling (Container : Set; 
                     Item      : Element_Type)       return Cursor; 
   function  Contains (Container : Set; 
                      Item      : Element_Type) return Boolean; 
This paragraph was deleted.  
   function  "<" (Left, Right : Cursor) return Boolean; 
   function  ">" (Left, Right : Cursor) return Boolean; 
   function  "<" (Left : Cursor; Right : Element_Type) 
      return Boolean; 
   function  ">" (Left : Cursor; Right : Element_Type) 
      return Boolean; 
   function  "<" (Left : Element_Type; Right : Cursor) 
      return Boolean; 
   function  ">" (Left : Element_Type; Right : Cursor) 
      return Boolean; 
   procedure  Iterate 
     (Container : in Set; 
      Process   : not null access procedure  (Position : in Cursor)); 
   procedure  Reverse_Iterate 
     (Container : in Set; 
      Process   : not null access procedure  (Position : in Cursor)); 
   function  Iterate (Container : in Set) 
      return Set_Iterator_Interfaces.Reversible_Iterator'Class; 
   function  Iterate (Container : in Set; Start : in Cursor) 
      return Set_Iterator_Interfaces.Reversible_Iterator'Class; 
   generic 
      type Key_Type (<>) is private ; 
      with function  Key (Element : Element_Type) return Key_Type; 
      with function  "<" (Left, Right : Key_Type) 
         return Boolean is <>; 
   package Generic_Keys is 
       function  Equivalent_Keys (Left, Right : Key_Type) 
          return Boolean; 
       function  Key (Position : Cursor) return Key_Type; 
       function  Element (Container : Set; 
                         Key       : Key_Type)           return Element_Type; 
       procedure  Replace (Container : in out Set; 
                          Key       : in     Key_Type; 
                          New_Item  : in     Element_Type); 
       procedure  Exclude (Container : in out Set; 
                          Key       : in     Key_Type); 
       procedure  Delete (Container : in out Set; 
                         Key       : in     Key_Type); 47/2 
48/2 49/2 
50/2 51/2 52/2 
53/3 
54/2 55/2 56/2 
57/2 58/2 59/2 60/2 
61/2 
61.1/3 
61.2/3 
62/2 
63/2 
64/2 
65/2 
66/2 67/2 
68/2 
Ada Reference Manual — 2012 Edition 
535      13 December 2012 The Generic Package Containers.Ordered_Sets   A.18.9        function  Find (Container : Set; 
                      Key       : Key_Type)           return Cursor; 
       function  Floor (Container : Set; 
                       Key       : Key_Type)           return Cursor; 
       function  Ceiling (Container : Set; 
                         Key       : Key_Type)           return Cursor; 
       function  Contains (Container : Set; 
                          Key       : Key_Type) return Boolean; 
       procedure  Update_Element_Preserving_Key 
         (Container : in out Set; 
          Position  : in     Cursor; 
          Process   : not null access procedure  
                          (Element : in out Element_Type)); 
      type Reference_Type 
            (Element : not null access  Element_Type) is private  
         with Implicit_Dereference => Element; 
      function  Reference_Preserving_Key (Container : aliased in out  Set; 
                                         Position  : in Cursor) 
         return Reference_Type; 
      function  Constant_Reference (Container : aliased in  Set; 
                                   Key       : in Key_Type) 
         return Constant_Reference_Type; 
      function  Reference_Preserving_Key (Container : aliased in out  Set; 
                                         Key       : in Key_Type) 
         return Reference_Type; 
   end Generic_Keys; 
private 
   ... -- not specified by the language  
end Ada.Containers.Ordered_Sets; 
Two elements E1 and E2 are equivalent  if both E1 < E2 and E2 < E1 return False, using the generic formal 
"<" operator for elements. Function E quivalent_Elements returns True if  Left and Right are equivalent, 
and False otherwise. 
The actual function for the generic formal function "<" on Element_Type values is expected to return the 
same value each time it is called with a particular pa ir of key values. It should define a strict weak 
ordering relationship (see A.18). If the actual for "<" beha ves in some other manner,  the behavior of this 
package is unspecified. Which subprogr ams of this package call "<" and how many times they call it, is 
unspecified. 
If the actual function for the generic formal functi on "=" returns True for any pair of nonequivalent 
elements, then the behavior of the container function "=" is unspecified. 
If the value of an element stored in a set is changed ot her than by an operation in this package such that at 
least one of "<" or "=" give different results, the behavior of this package is unspecified. 
The first element  of a nonempty set is the one which is less th an all the other elements in the set. The last 
element  of a nonempty set is the one which is greater than all the other elements in the set. The successor  
of an element is the smallest element that  is larger than the given element. The predecessor  of an element 
is the largest element that  is smaller than the given element. A ll comparisons are done using the generic 
formal "<" operator for elements. 69/2 
70/2 71/2 72/2 
73/2 
73.1/3 
73.2/3 73.3/3 73.4/3 
74/2 
75/2 76/2 77/2 
78/2 
79/3 
79.1/3 
80/2 81/3 
Ada Reference Manual — 2012 Edition 
A.18.9    The Generic Package Containers.O rdered_Sets 13 December 2012      536 function  Copy (Source : Set) return Set; 
Returns a set whose elements are initialized  from the corresponding elements of Source. 
procedure  Delete_First (Container : in out Set); 
If Container is empty, Delete_First has no eff ect. Otherwise, the element designated by First 
(Container) is removed from Contai ner. Delete_First tampers with  the cursors of Container. 
procedure  Delete_Last (Container : in out Set); 
If Container is empty, Delete_Last has no effect . Otherwise, the element designated by Last 
(Container) is removed from Contai ner. Delete_Last tampers with  the cursors of Container. 
function  First_Element (Container : Set) return Element_Type; 
Equivalent to Element (First (Container)). 
function  Last (Container : Set) return Cursor; 
Returns a cursor that designates the last element in Container. If Container is empty, returns 
No_Element. 
function  Last_Element (Container : Set) return Element_Type; 
Equivalent to Element (Last (Container)). 
function  Previous (Position : Cursor) return Cursor; 
If Position equals No_Element, then Previous re turns No_Element. Otherwise, Previous returns 
a cursor designating the predecessor element of  the one designated by Position. If Position 
designates the first element, then Previous returns No_Element. 
procedure  Previous (Position : in out Cursor); 
Equivalent to Position := Previous (Position). 
function  Floor (Container : Set; 
                Item      : Element_Type) return Cursor; 
Floor searches for the last elemen t which is not greater than Item . If such an element is found, a 
cursor that designates it is returned. Otherwise, No_Element is returned. 
function  Ceiling (Container : Set; 
                  Item      : Element_Type) return Cursor; 
Ceiling searches for the first elem ent which is not less than Item. If such an element is found, a 
cursor that designates it is returned. Otherwise, No_Element is returned. 
function  "<" (Left, Right : Cursor) return Boolean; 
Equivalent to Element (Left) < Element (Right). 
function  ">" (Left, Right : Cursor) return Boolean; 
Equivalent to Element (Right) < Element (Left). 
function  "<" (Left : Cursor; Right : Element_Type) return Boolean; 
Equivalent to Element (Left) < Right. 
function  ">" (Left : Cursor; Right : Element_Type) return Boolean; 
Equivalent to Right < Element (Left). 81.1/3 
81.2/3 
82/2 
83/3 
84/2 
85/3 
86/2 
87/2 
88/2 
89/2 
90/2 
91/2 
92/2 
93/3 
94/2 
95/2 
96/2 
97/3 
98/2 
99/3 
100/2 
101/2 
102/2 
103/2 
104/2 
105/2 
106/2 
107/2 
Ada Reference Manual — 2012 Edition 
537      13 December 2012 The Generic Package Containers.Ordered_Sets   A.18.9 function  "<" (Left : Element_Type; Right : Cursor) return Boolean; 
Equivalent to Left < Element (Right). 
function  ">" (Left : Element_Type; Right : Cursor) return Boolean; 
Equivalent to Element (Right) < Left. 
procedure  Reverse_Iterate 
   (Container : in Set; 
    Process   : not null access procedure  (Position : in Cursor)); 
Iterates over the elements in Container as per procedure Iterate, with the difference that the 
elements are traversed in predecessor or der, starting with the last element. 
function  Iterate (Container : in Set) 
   return Set_Iterator_Interfaces.Reversible_Iterator'Class; 
Iterate returns a reversible iterator object (see 5.5.1) that will generate a value for a loop 
parameter (see 5.5.2) designating each element in Container, starting with the first element and moving the cursor according to the successor relation when used as a forward iterator, and starting with the last element and moving the cu rsor according to the predecessor relation when 
used as a reverse iterator. Tampering with th e cursors of Container is prohibited while the 
iterator object exists (in particular, in the 
sequence_of_statements  of the loop_statement  
whose iterator_specification  denotes this object). The iterator object needs finalization. 
function  Iterate (Container : in Set; Start : in Cursor) 
   return Set_Iterator_Interfaces.Reversible_Iterator'Class; 
If Start is not No_Element and does not designate an item in C ontainer, then Program_Error is 
propagated. If Start is No_Element, then Constr aint_Error is propagated. Otherwise, Iterate 
returns a reversible iterator object (see 5.5.1) th at will generate a value for a loop parameter (see 
5.5.2) designating each element in Container, st arting with the element designated by Start and 
moving the cursor according to the successor relation when used as a forward iterator, or moving the cursor according to the predecessor relation when  used as a reverse iterator. Tampering with 
the cursors of Container is prohibited while th e iterator object exists (in particular, in the 
sequence_of_statements  of the loop_statement  whose iterator_specification  denotes this 
object). The iterator object needs finalization. 
For any two elements E1 and E2, the boolean values ( E1 < E2) and (Key( E1) < Key( E2)) are expected to 
be equal. If the actuals for Key or Generic_Keys."<" behave in some other manne r, the behavior of this 
package is unspecified. Which subprograms of this  package call Key and Generic_Keys."<", and how 
many times the functions are called, is unspecified. 
In addition to the semantics descri bed in A.18.7, the subprograms in package Generic_Keys named Floor 
and Ceiling, are equivalent to the corresponding subprogr ams in the parent package, with the difference 
that the Key subprogram parameter is compared to elements in the container using the Key and "<" 
generic formal functions. The function named Equivale nt_Keys in package Generic_Keys returns True if 
both Left < Right and Right < Left return False usi ng the generic formal "<" ope rator, and returns True 
otherwise. 
Implementation Advice 
If N is the length of a set, then the worst-case time complexity of the Insert, Include, Replace, Delete, 
Exclude and Find operations that take  an element parameter should be O((log N)**2) or better. The worst-
case time complexity of the subprograms that take a cursor parameter should be O(1).  108/2 
109/2 
110/2 
111/2 
112/2 
113/3 
113.1/3 
113.2/3 
113.3/3 
113.4/3 
114/2 
115/2 
116/2 
Ada Reference Manual — 2012 Edition 
A.18.10    The Generic Package Containers.Multiway_Trees 13 December 2012      538 A.18.10 The Generic Package Containers.Multiway_Trees 
The language-defined generic package Containers .Multiway_Trees provides private types Tree and 
Cursor, and a set of operations for each type. A multiway  tree container is well-suited to represent nested 
structures. 
A multiway tree container object manages a tree of internal nodes , each of which contains an element and 
pointers to the parent, first child, last child, next (successor) sibling, and prev ious (predecessor) sibling 
internal nodes. A cursor designates a particular node within a tree (and by extension the element contained 
in that node, if any). A cursor keeps designating the sa me node (and element) as long as the node is part of 
the container, even if the node is moved within the container. 
A subtree  is a particular node (which roots the subtree ) and all of its child nodes (including all of the 
children of the child nodes, recursiv ely).  There is a special node, the root, which is always present and has 
neither an associated element value nor any parent node. The root node provides a place to add nodes to an 
otherwise empty tree and represents the base of the tree. 
A node that has no children is called a leaf node . The ancestors  of a node are the node itself, its parent 
node, the parent of the parent node, and so on until a node with no parent is reached. Similarly, the 
descendants  of a node are the node itself, its child nodes,  the children of each child node, and so on. 
The nodes of a subtree can be visited in several different orders. For a depth-first order , after visiting a 
node, the nodes of its child list are each visited in depth -first order, with each child node visited in natural 
order (first child to last child). 
Static Semantics 
The generic library package Containers.Multiw ay_Trees has the following declaration:  
with Ada.Iterator_Interfaces; 
generic 
   type Element_Type is private ; 
   with function  "=" (Left, Right : Element_Type) return Boolean is <>; 
package Ada.Containers.Multiway_Trees is 
   pragma Preelaborate(Multiway_Trees); 
   pragma Remote_Types(Multiway_Trees); 
   type Tree is tagged private  
      with Constant_Indexing => Constant_Reference, 
           Variable_Indexing => Reference,            Default_Iterator  => Iterate,            Iterator_Element  => Element_Type;    pragma Preelaborable_Initialization(Tree); 
   type Cursor is private ; 
   pragma Preelaborable_Initialization(Cursor); 
   Empty_Tree : constant  Tree; 
   No_Element : constant  Cursor; 
   function  Has_Element (Position : Cursor) return Boolean; 
   package Tree_Iterator_Interfaces is new 
      Ada.Iterator_Interfaces (Cursor, Has_Element); 
   function  Equal_Subtree (Left_Position : Cursor; 
                           Right_Position: Cursor) return Boolean; 
   function  "=" (Left, Right : Tree) return Boolean; 
   function  Is_Empty (Container : Tree) return Boolean; 
   function  Node_Count (Container : Tree) return Count_Type; 1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 12/3 13/3 
14/3 15/3 
16/3 17/3 
Ada Reference Manual — 2012 Edition 
539      13 December 2012 The Generic Package Containers.Multiway_Trees   A.18.10    function  Subtree_Node_Count (Position : Cursor) return Count_Type; 
   function  Depth (Position : Cursor) return Count_Type; 
   function  Is_Root (Position : Cursor) return Boolean; 
   function  Is_Leaf (Position : Cursor) return Boolean; 
   function  Root (Container : Tree) return Cursor; 
   procedure  Clear (Container : in out Tree); 
   function  Element (Position : Cursor) return Element_Type; 
   procedure  Replace_Element (Container : in out Tree; 
                              Position  : in     Cursor; 
                              New_Item  : in     Element_Type); 
   procedure  Query_Element 
     (Position : in Cursor; 
      Process  : not null access procedure  (Element : in Element_Type)); 
   procedure  Update_Element 
     (Container : in out Tree; 
      Position  : in     Cursor; 
      Process   : not null access procedure  
                      (Element : in out Element_Type)); 
   type Constant_Reference_Type 
         (Element : not null access constant  Element_Type) is private  
      with Implicit_Dereference => Element; 
   type Reference_Type (Element : not null access  Element_Type) is private  
      with Implicit_Dereference => Element; 
   function  Constant_Reference (Container : aliased in  Tree; 
                                Position  : in Cursor) 
      return Constant_Reference_Type; 
   function  Reference (Container : aliased in out  Tree; 
                       Position  : in Cursor) 
      return Reference_Type; 
   procedure  Assign (Target : in out Tree; Source : in Tree); 
   function  Copy (Source : Tree) return Tree; 
   procedure  Move (Target : in out Tree; 
                   Source : in out Tree); 
   procedure  Delete_Leaf (Container : in out Tree; 
                          Position  : in out Cursor); 
   procedure  Delete_Subtree (Container : in out Tree; 
                             Position  : in out Cursor); 
   procedure  Swap (Container : in out Tree; 
                   I, J      : in     Cursor); 
   function  Find (Container : Tree; 
                  Item      : Element_Type)       return Cursor; 
   function  Find_In_Subtree (Position : Cursor; 
                             Item     : Element_Type)       return Cursor; 
   function  Ancestor_Find (Position : Cursor; 
                           Item     : Element_Type)       return Cursor; 
   function  Contains (Container : Tree; 
                      Item      : Element_Type) return Boolean; 
   procedure  Iterate 
     (Container : in Tree; 
      Process   : not null access procedure  (Position : in Cursor)); 18/3 
19/3 20/3 21/3 22/3 23/3 24/3 25/3 
26/3 27/3 
28/3 
29/3 
30/3 
31/3 32/3 
33/3 34/3 
35/3 36/3 37/3 38/3 
39/3 40/3 41/3 
42/3 
Ada Reference Manual — 2012 Edition 
A.18.10    The Generic Package Containers.Multiway_Trees 13 December 2012      540    procedure  Iterate_Subtree 
     (Position  : in Cursor; 
      Process   : not null access procedure  (Position : in Cursor)); 
   function  Iterate (Container : in Tree) 
      return Tree_Iterator_Interfaces.Forward_Iterator'Class; 
   function  Iterate_Subtree (Position : in Cursor) 
      return Tree_Iterator_Interfaces.Forward_Iterator'Class; 
   function  Child_Count (Parent : Cursor) return Count_Type; 
   function  Child_Depth (Parent, Child : Cursor) return Count_Type; 
   procedure  Insert_Child (Container : in out Tree; 
                           Parent    : in     Cursor; 
                           Before    : in     Cursor; 
                           New_Item  : in     Element_Type; 
                           Count     : in     Count_Type := 1); 
   procedure  Insert_Child (Container : in out Tree; 
                           Parent    : in     Cursor; 
                           Before    : in     Cursor; 
                           New_Item  : in     Element_Type; 
                           Position  :    out Cursor; 
                           Count     : in     Count_Type := 1); 
   procedure  Insert_Child (Container : in out Tree; 
                           Parent    : in     Cursor; 
                           Before    : in     Cursor; 
                           Position  :    out Cursor; 
                           Count     : in     Count_Type := 1); 
   procedure  Prepend_Child (Container : in out Tree; 
                            Parent    : in     Cursor; 
                            New_Item  : in     Element_Type; 
                            Count     : in     Count_Type := 1); 
   procedure  Append_Child (Container : in out Tree; 
                           Parent    : in     Cursor; 
                           New_Item  : in     Element_Type; 
                           Count     : in     Count_Type := 1); 
   procedure  Delete_Children (Container : in out Tree; 
                              Parent    : in     Cursor); 
   procedure  Copy_Subtree (Target   : in out Tree; 
                           Parent   : in     Cursor; 
                           Before   : in     Cursor; 
                           Source   : in     Cursor); 
   procedure  Splice_Subtree (Target   : in out Tree; 
                             Parent   : in     Cursor; 
                             Before   : in     Cursor; 
                             Source   : in out Tree; 
                             Position : in out Cursor); 
   procedure  Splice_Subtree (Container: in out Tree; 
                             Parent   : in     Cursor; 
                             Before   : in     Cursor; 
                             Position : in     Cursor); 
   procedure  Splice_Children (Target          : in out Tree; 
                              Target_Parent   : in     Cursor; 
                              Before          : in     Cursor; 
                              Source          : in out Tree; 
                              Source_Parent   : in     Cursor); 
   procedure  Splice_Children (Container       : in out Tree; 
                              Target_Parent   : in     Cursor; 
                              Before          : in     Cursor; 
                              Source_Parent   : in     Cursor); 
   function  Parent (Position : Cursor) return Cursor; 43/3 
44/3 
45/3 46/3 
47/3 48/3 
49/3 
50/3 
51/3 
52/3 
53/3 
54/3 
55/3 
56/3 
57/3 
58/3 
59/3 
Ada Reference Manual — 2012 Edition 
541      13 December 2012 The Generic Package Containers.Multiway_Trees   A.18.10    function  First_Child (Parent : Cursor) return Cursor; 
   function  First_Child_Element (Parent : Cursor) return Element_Type; 
   function  Last_Child (Parent : Cursor) return Cursor; 
   function  Last_Child_Element (Parent : Cursor) return Element_Type; 
   function  Next_Sibling (Position : Cursor) return Cursor; 
   function  Previous_Sibling (Position : Cursor) return Cursor; 
   procedure  Next_Sibling (Position : in out Cursor); 
   procedure  Previous_Sibling (Position : in out Cursor); 
   procedure  Iterate_Children 
     (Parent  : in Cursor; 
      Process : not null access procedure  (Position : in Cursor)); 
   procedure  Reverse_Iterate_Children 
     (Parent  : in Cursor; 
      Process : not null access procedure  (Position : in Cursor)); 
   function  Iterate_Children (Container : in Tree; Parent : in Cursor) 
      return Tree_Iterator_Interfaces.Reversible_Iterator'Class; 
private 
   ... -- not specified by the language  
end Ada.Containers.Multiway_Trees; 
The actual function for the generic formal function "=" on Element_Type values is expected to define a 
reflexive and symmetric relationship and return the same result value each time it is called with a particular pair of values. If it behaves in some  other manner, the functi ons Find, Reverse_Find, 
Equal_Subtree, and "=" on tree values return an uns pecified value. The exact arguments and number of 
calls of this generic formal function by the functi ons Find, Reverse_Find, Equa l_Subtree, and "=" on tree 
values are unspecified. 
The type Tree is used to represent trees. The type Tree needs finalization (see 7.6). 
Empty_Tree represents the empty Tree object. It contains only the root node (Node_Count (Empty_Tree) 
returns 1). If an object of type Tree is not otherwis e initialized, it is initialized  to the same value as 
Empty_Tree. 
No_Element represents a cursor that designates no elem ent. If an object of type Cursor is not otherwise 
initialized, it is initialized to th e same value as No_Element. 
The predefined "=" operator for type Cursor returns Tr ue if both cursors are No_Element, or designate the 
same element in the same container. 
Execution of the default implementati on of the Input, Output, Read, or Write attribute of type Cursor 
raises Program_Error. 
Tree'Write for a Tree object T writes Node_Count( T) - 1 elements of the tree to the stream. It also may 
write additional information about the tree. 
Tree'Read reads the representation of a tree from the stream, and assigns to Item a tree with the same 
elements and structure as was written by Tree'Write. 
Some operations of this generic package have access-to-subprogram parameters. To ensure such 
operations are well-defined, they guard against certain  actions by the designated subprogram. In particular, 
some operations check for "tampering with cursors" of a container because they depend on the set of elements of the container remaining constant, and others check for "tampering with elements" of a 
container because they depend on elements of the container not being replaced. 
A subprogram is said to tamper with cursors  of a tree object T if: 60/3 
61/3 62/3 63/3 64/3 65/3 66/3 67/3 68/3 
69/3 70/3 
71/3 
72/3 
73/3 
74/3 
75/3 
76/3 77/3 78/3 79/3 80/3 
81/3 
Ada Reference Manual — 2012 Edition 
A.18.10    The Generic Package Containers.Multiway_Trees 13 December 2012      542 • it inserts or deletes elements of T, that is, it calls the Clear , Delete_Leaf, Insert_Child, 
Delete_Children, Delete_Subtree, or Copy_Subtree procedures with T as a parameter; or 
• it reorders the elements of T, that is, it calls the Splice_Subt ree or Splice_Children procedures 
with T as a parameter; or 
• it finalizes T; or 
• it calls Assign with T as the Target parameter; or 
• it calls the Move procedure with T as a parameter. 
A subprogram is said to tamper with elements  of a tree object T if: 
• it tampers with cursors of T; or 
• it replaces one or more elements of T, that is, it calls the Replace_Element or Swap procedures 
with T as a parameter. 
When tampering with cursors is prohibited  for a particular tree object T, Program_Error is propagated by a 
call of any language-defined subprogram that is  defined to tamper with the cursors of T, leaving T 
unmodified. Similarly, when tampering with elements is prohibited  for a particular tree object T, 
Program_Error is propagated by a call of any language-def ined subprogram that is defined to tamper with 
the elements of T (or tamper with the cursors of T), leaving T unmodified.  
function  Has_Element (Position : Cursor) return Boolean; 
Returns True if Position designates an element,  and returns False otherwise. In particular, 
Has_Element returns False if the cursor de signates a root node or equals No_Element. 
function  Equal_Subtree (Left_Position : Cursor; 
                        Right_Position: Cursor) return Boolean; 
If Left_Position or Right_Position equals No_E lement, propagates Constraint_Error. If the 
number of child nodes of the element designated by Left_Position is different from the number 
of child nodes of the element designated by Right_Position, the function returns False. If 
Left_Position designates a root node and Right_Position does not, th e function returns False. If 
Right_Position designates a root node and Left_Position does not, the function returns False. 
Unless both cursors designate a root node, the elem ents are compared using the generic formal 
equality operator. If the result of the element co mparison is False, the function returns False. 
Otherwise, it calls Equal_Subtree on a cursor designating each child element of the element designated by Left_Position and a cursor desi gnating the corresponding child element of the 
element designated by Right_Position. If any such call returns False, the function returns False; 
otherwise, it returns True. Any exception raised  during the evaluation of element equality is 
propagated. 
function  "=" (Left, Right : Tree) return Boolean; 
If Left and Right denote the same tree object, then  the function returns True. Otherwise, it calls 
Equal_Subtree with cursors designating the root nodes of Left and Right; the result is returned. 
Any exception raised during the evaluati on of Equal_Subtree is propagated. 
function  Node_Count (Container : Tree) return Count_Type; 
Node_Count returns the number of nodes in Container. 
function  Subtree_Node_Count (Position : Cursor) return Count_Type; 
If Position is No_Element, Subtree_Node_Count returns 0; otherwise, Subtree_Node_Count 
returns the number of nodes in the subtree that is rooted by Position. 82/3 
83/3 84/3 
85/3 86/3 87/3 
88/3 
89/3 
90/3 
91/3 
92/3 
93/3 
94/3 
95/3 
96/3 
97/3 
98/3 
99/3 
100/3 
Ada Reference Manual — 2012 Edition 
543      13 December 2012 The Generic Package Containers.Multiway_Trees   A.18.10 function  Is_Empty (Container : Tree) return Boolean; 
Equivalent to Node_Count (Container) = 1. 
function  Depth (Position : Cursor) return Count_Type; 
If Position equals No_Element, De pth returns 0; otherwise, Dept h returns the number of ancestor 
nodes of the node designated by Po sition (including the node itself). 
function  Is_Root (Position : Cursor) return Boolean; 
Is_Root returns True if the Position designates the root node of some tree; and returns False 
otherwise. 
function  Is_Leaf (Position : Cursor) return Boolean; 
Is_Leaf returns True if Position designates a node that does not have any child nodes; and 
returns False otherwise. 
function  Root (Container : Tree) return Cursor; 
Root returns a cursor that designa tes the root node of Container. 
procedure  Clear (Container : in out Tree); 
Removes all the elements from Container. 
function  Element (Position : Cursor) return Element_Type; 
If Position equals No_Element, then Constraint_E rror is propagated; if Position designates the 
root node of a tree, then Program_Error is propa gated. Otherwise, Elem ent returns the element 
designated by Position. 
procedure  Replace_Element (Container : in out Tree; 
                           Position  : in     Cursor; 
                           New_Item  : in     Element_Type); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container (including if  it designates the root node), then Program_Error 
is propagated. Otherwise, Replace_Element assigns the value New_Item to the element designated by Position. 
procedure  Query_Element 
  (Position : in Cursor; 
   Process  : not null access procedure  (Element : in Element_Type)); 
If Position equals No_Element, then Constraint_E rror is propagated; if Position designates the 
root node of a tree, then Program_Error is propagated. Otherwise, Query_Element calls 
Process. all with the element designated by Positi on as the argument. Tampering with the 
elements of the tree that contains the elemen t designated by Position is prohibited during the 
execution of the call on Process. all. Any exception raised by Process. all is propagated. 
procedure  Update_Element 
  (Container : in out Tree; 
   Position  : in     Cursor; 
   Process   : not null access procedure  
                   (Element : in out Element_Type)); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container (including if  it designates the root node), then Program_Error 
is propagated. Otherwise, U pdate_Element calls Process. all with the element designated by 101/3 
102/3 
103/3 
104/3 
105/3 
106/3 
107/3 
108/3 
109/3 
110/3 
111/3 
112/3 
113/3 
114/3 
115/3 
116/3 
117/3 
118/3 
119/3 
120/3 
Ada Reference Manual — 2012 Edition 
A.18.10    The Generic Package Containers.Multiway_Trees 13 December 2012      544 Position as the argument. Tampering with the el ements of Container is prohibited during the 
execution of the call on Process. all. Any exception raised by Process. all is propagated. 
If Element_Type is unconstrained and definite, then the actual Element parameter of Process. all 
shall be unconstrained. 
type Constant_Reference_Type 
      (Element : not null access constant  Element_Type) is private  
   with Implicit_Dereference => Element; 
type Reference_Type (Element : not null access  Element_Type) is private  
   with Implicit_Dereference => Element; 
The types Constant_Reference_Type and Reference_Type need finalization. 
The default initialization of an object of type  Constant_Reference_Type or Reference_Type 
propagates Program_Error. 
function  Constant_Reference (Container : aliased in  Tree; 
                             Position  : in Cursor) 
   return Constant_Reference_Type; 
This function (combined with the Constant_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read access to an individual element of a tree given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then  Program_Error is propagated. Otherwise, 
Constant_Reference returns an object whose discri minant is an access value that designates the 
element designated by Position. Tampering with the elements of Container is prohibited while 
the object returned by Constant_Referen ce exists and has not been finalized. 
function  Reference (Container : aliased in out  Tree; 
                    Position  : in Cursor) 
   return Reference_Type; 
This function (combined with the Variable_Inde xing and Implicit_Dereference aspects) provides 
a convenient way to gain read and write access to an individual element of a tree given a cursor. 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container, then Progr am_Error is propagated. Otherwise, Reference 
returns an object whose discriminant is an access value that designates the element designated by Position. Tampering with the elements of Cont ainer is prohibited while the object returned by 
Reference exists and has not been finalized. 
procedure  Assign (Target : in out Tree; Source : in Tree); 
If Target denotes the same object as Source, the operation has no effect. Otherwise, the elements 
of Source are copied to Target as for an assignment_statement  assigning Source to Target. 
function  Copy (Source : Tree) return Tree; 
Returns a tree with the same structure as S ource and whose elements are initialized from the 
corresponding elements of Source. 
procedure  Move (Target : in out Tree; 
                Source : in out Tree); 
If Target denotes the same object as Source, th en the operation has no effect. Otherwise, Move 
first calls Clear (Target). Then, the nodes other th an the root node in Source are moved to Target 121/3 
122/3 
123/3 
124/3 
125/3 
126/3 
127/3 
128/3 
129/3 
130/3 
131/3 
132/3 
133/3 
134/3 
135/3 
136/3 
137/3 
Ada Reference Manual — 2012 Edition 
545      13 December 2012 The Generic Package Containers.Multiway_Trees   A.18.10 (in the same positions). After Move completes,  Node_Count (Target) is the number of nodes 
originally in Source, and Node_Count (Source) is 1. 
procedure  Delete_Leaf (Container : in out Tree; 
                       Position  : in out Cursor); 
If Position equals No_Element, then Constrai nt_Error is propagated; if Position does not 
designate an element in Container (including if  it designates the root node), then Program_Error 
is propagated. If the element designated by position has any child elements, then 
Constraint_Error is propagated.  Otherwise, Delete_Leaf rem oves (from Container) the element 
designated by Position. Finally, Position is set to No_Element. 
procedure  Delete_Subtree (Container : in out Tree; 
                          Position  : in out Cursor); 
If Position equals No_Element, then Constrai nt_Error is propagated. If Position does not 
designate an element in Container (including if  it designates the root node), then Program_Error 
is propagated. Otherwise, De lete_Subtree removes (from Contai ner) the subtree designated by 
Position (that is, all descendants of the node designated by Position including the node itself), 
and Position is set to No_Element. 
procedure  Swap (Container : in out Tree; 
                I, J      : in     Cursor); 
If either I or J equals No_Element, then Constr aint_Error is propagated. If either I or J do not 
designate an element in Container (including if either designates the root node), then 
Program_Error is propagated. Otherwise, Swap ex changes the values of the elements designated 
by I and J. 
function  Find (Container : Tree; 
               Item      : Element_Type)    return Cursor; 
Find searches the elements of Container for an element equal to Item (using the generic formal 
equality operator). The search starts at the root  node. The search traverses the tree in a depth-
first order. If no equal element is found, then Find returns No_Element. Otherwise, it returns a 
cursor designating the first equal element encountered. 
function  Find_In_Subtree (Position : Cursor; 
                          Item     : Element_Type)    return Cursor; 
If Position equals No_Element, then Constraint _Error is propagated. Find_In_Subtree searches 
the subtree rooted by Position for an element e qual to Item (using the generic formal equality 
operator). The search starts at the element de signated by Position. The search traverses the 
subtree in a depth-first order. If no equal el ement is found, then Find returns No_Element. 
Otherwise, it returns a cursor designati ng the first equal element encountered. 
function  Ancestor_Find (Position : Cursor; 
                        Item     : Element_Type)    return Cursor; 
If Position equals No_Element, then Constraint _Error is propagated. Otherwise, Ancestor_Find 
searches for an element equal to Item (using th e generic formal equality operator). The search 
starts at the node designated by Position, and ch ecks each ancestor proceeding toward the root of 
the subtree. If no equal element is found, then Ancestor_Find returns No_Element. Otherwise, it 
returns a cursor designating the fi rst equal element encountered.  138/3 
139/3 
140/3 
141/3 
142/3 
143/3 
144/3 
145/3 
146/3 
147/3 
148/3 
149/3 
Ada Reference Manual — 2012 Edition 
A.18.10    The Generic Package Containers.Multiway_Trees 13 December 2012      546 function  Contains (Container : Tree; 
                   Item      : Element_Type) return Boolean; 
Equivalent to Find (Containe r, Item) /= No_Element. 
procedure  Iterate 
  (Container : in Tree; 
   Process   : not null access procedure  (Position : in Cursor)); 
Iterate calls Process. all with a cursor that designates each el ement in Container, starting with the 
root node and proceeding in a depth-first order.  Tampering with the cursors of Container is 
prohibited during the execution of a call on Process. all. Any exception raised by Process. all is 
propagated. 
procedure  Iterate_Subtree 
  (Position  : in Cursor; 
   Process   : not null access procedure  (Position : in Cursor)); 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Iterate_Subtree 
calls Process. all with a cursor that designates each elem ent in the subtree rooted by the node 
designated by Position, starting with the node de signated by Position and proceeding in a depth-
first order. Tampering with the cursors of th e tree that contains the element designated by 
Position is prohibited during the execution of a call on Process. all. Any exception raised by 
Process. all is propagated. 
function  Iterate (Container : in Tree) 
   return Tree_Iterator_Interfaces.Forward_Iterator'Class; 
Iterate returns an iterator object (see 5.5.1) that  will generate a value for a loop parameter (see 
5.5.2) designating each node in Container, starti ng with the root node and proceeding in a depth-
first order. Tampering with the cursors of Contai ner is prohibited while the iterator object exists 
(in particular, in the sequence_of_statements  of the loop_statement  whose 
iterator_specification  denotes this object). The iterator object needs finalization. 
function  Iterate_Subtree (Position : in Cursor) 
   return Tree_Iterator_Interfaces.Forward_Iterator'Class; 
If Position equals No_Element, then Constraint_E rror is propagated. Otherwise, Iterate_Subtree 
returns an iterator object (see 5.5.1) that will ge nerate a value for a loop parameter (see 5.5.2) 
designating each element in the subtree rooted by  the node designated by Position, starting with 
the node designated by Position and proceeding in a depth-first order. If Position equals 
No_Element, then Constraint_Error is propagated.  Tampering with the cursors of the container 
that contains the node designated by Position is  prohibited while the iterator object exists (in 
particular, in the sequence_of_statements  of the loop_statement  whose iterator_specification  
denotes this object). The iterator object needs finalization. 
function  Child_Count (Parent : Cursor) return Count_Type; 
Child_Count returns the number of child nodes of the node designated by Parent. 
function  Child_Depth (Parent, Child : Cursor) return Count_Type; 
If Child or Parent is equal to No_Element, th en Constraint_Error is propagated. Otherwise, 
Child_Depth returns the number of ancestor nodes of  Child (including Child itself), up to but not 
including Parent; Program_Error is propagated if Parent is not an ancestor of Child. 150/3 
151/3 
152/3 
153/3 
154/3 
155/3 
156/3 
157/3 
158/3 
159/3 
160/3 
161/3 
162/3 
163/3 
Ada Reference Manual — 2012 Edition 
547      13 December 2012 The Generic Package Containers.Multiway_Trees   A.18.10 procedure  Insert_Child (Container : in out Tree; 
                        Parent    : in     Cursor; 
                        Before    : in     Cursor; 
                        New_Item  : in     Element_Type; 
                        Count     : in     Count_Type := 1); 
If Parent equals No_Element, then Constraint_Erro r is propagated. If Pare nt does not designate a 
node in Container, then Program_Error is propagate d. If Before is not equal to No_Element, and 
does not designate a node in Contai ner, then Program_Error is propa gated. If Before is not equal 
to No_Element, and Parent does not designate the parent node of  the node designated by Before, 
then Constraint_Error is propagated. Otherwise,  Insert_Child allocates Count nodes containing 
copies of New_Item and inserts them as childre n of Parent. If Parent already has child nodes, 
then the new nodes are inserted prior to the node  designated by Before, or, if Before equals 
No_Element, the new nodes are inserted after the last existing child node of Parent. Any 
exception raised during allocation of internal storage is propagated, and Container is not 
modified. 
procedure  Insert_Child (Container : in out Tree; 
                        Parent    : in     Cursor; 
                        Before    : in     Cursor; 
                        New_Item  : in     Element_Type; 
                        Position  :    out Cursor; 
                        Count     : in     Count_Type := 1); 
If Parent equals No_Element, then Constraint_Erro r is propagated. If Pare nt does not designate a 
node in Container, then Program_Error is propagate d. If Before is not equal to No_Element, and 
does not designate a node in Contai ner, then Program_Error is propa gated. If Before is not equal 
to No_Element, and Parent does not designate the parent node of  the node designated by Before, 
then Constraint_Error is propagated. Otherwise,  Insert_Child allocates Count nodes containing 
copies of New_Item and inserts them as childre n of Parent. If Parent already has child nodes, 
then the new nodes are inserted prior to the node  designated by Before, or, if Before equals 
No_Element, the new nodes are inserted after th e last existing child node of Parent. Position 
designates the first newly-inserted node, or if Count  equals 0, then Position is assigned the value 
of Before. Any exception raised during allocati on of internal storage is propagated, and 
Container is not modified. 
procedure  Insert_Child (Container : in out Tree; 
                        Parent    : in     Cursor; 
                        Before    : in     Cursor; 
                        Position  :    out Cursor; 
                        Count     : in     Count_Type := 1); 
If Parent equals No_Element, then Constraint_Erro r is propagated. If Pare nt does not designate a 
node in Container, then Program_Error is propagate d. If Before is not equal to No_Element, and 
does not designate a node in Contai ner, then Program_Error is propa gated. If Before is not equal 
to No_Element, and Parent does not designate the parent node of  the node designated by Before, 
then Constraint_Error is propagated. Otherwis e, Insert_Child allocates Count nodes, the 
elements contained in the new nodes are initialized  by default (see 3.3.1), and the new nodes are 
inserted as children of Parent. If Parent alread y has child nodes, then the new nodes are inserted 
prior to the node designated by Before, or, if  Before equals No_Element, the new nodes are 
inserted after the last existing child node of Pa rent. Position designates the first newly-inserted 
node, or if Count equals 0, then Position is a ssigned the value of Before. Any exception raised 
during allocation of internal storage is pr opagated, and Container is not modified. 164/3 
165/3 
166/3 
167/3 
168/3 
169/3 
Ada Reference Manual — 2012 Edition 
A.18.10    The Generic Package Containers.Multiway_Trees 13 December 2012      548 procedure  Prepend_Child (Container : in out Tree; 
                         Parent    : in     Cursor; 
                         New_Item  : in     Element_Type; 
                         Count     : in     Count_Type := 1); 
Equivalent to Insert_Child (C ontainer, Parent, First_Child (C ontainer, Parent), New_Item, 
Count). 
procedure  Append_Child (Container : in out Tree; 
                        Parent    : in     Cursor; 
                        New_Item  : in     Element_Type; 
                        Count     : in     Count_Type := 1); 
Equivalent to Insert_Child (Container,  Parent, No_Element, New_Item, Count). 
procedure  Delete_Children (Container : in out Tree; 
                           Parent    : in     Cursor); 
If Parent equals No_Element, then Constraint_Erro r is propagated. If Pare nt does not designate a 
node in Container, Program_Error is propagate d. Otherwise, Delete _Children removes (from 
Container) all of the descendants of Parent other than Parent itself. 
procedure  Copy_Subtree (Target   : in out Tree; 
                        Parent   : in     Cursor; 
                        Before   : in     Cursor; 
                        Source   : in     Cursor); 
If Parent equals No_Element, then Constraint_Erro r is propagated. If Pare nt does not designate a 
node in Target, then Program_Error is propagated.  If Before is not equal to No_Element, and 
does not designate a node in Target, then Program_E rror is propagated. If Before is not equal to 
No_Element, and Parent does not designate the parent node of the node designated by Before, 
then Constraint_Error is propagated. If Source de signates a root node, then Constraint_Error is 
propagated. If Source is equal to No_Element, th en the operation has no effect. Otherwise, the 
subtree rooted by Source (which can be from any tr ee; it does not have to be a subtree of Target) 
is copied (new nodes are allocated to create a ne w subtree with the same structure as the Source 
subtree, with each element initia lized from the corresponding elemen t of the Source subtree) and 
inserted into Target as a child of Parent. If Parent already has child nodes, then the new nodes 
are inserted prior to the node designated by Befo re, or, if Before equals No_Element, the new 
nodes are inserted after the last existing child node  of Parent. The parent of the newly created 
subtree is set to Parent, and the overall count of  Target is incremented by Subtree_Node_Count 
(Source). Any exception raised during allocation of internal storage is propagated, and Container 
is not modified. 
procedure  Splice_Subtree (Target   : in out Tree; 
                          Parent   : in     Cursor; 
                          Before   : in     Cursor; 
                          Source   : in out Tree; 
                          Position : in out Cursor); 
If Parent equals No_Element, then Constraint_Erro r is propagated. If Pare nt does not designate a 
node in Target, then Program_Error is propagated.  If Before is not equal to No_Element, and 
does not designate a node in Target, then Program_E rror is propagated. If Before is not equal to 
No_Element, and Parent does not designate the parent node of the node designated by Before, 
then Constraint_Error is propagated. If Pos ition equals No_Element, Constraint_Error is 
propagated. If Position does not designate a node in Source or designates a root node, then 
Program_Error is propagated. If Source denotes th e same object as Target, then: if Position 
equals Before there is no effect; if Position de signates an ancestor of Pa rent (including Parent 
itself), Constraint_Error is propagated; otherwise,  the subtree rooted by the element designated 170/3 
171/3 
172/3 
173/3 
174/3 
175/3 
176/3 
177/3 
178/3 
179/3 
Ada Reference Manual — 2012 Edition 
549      13 December 2012 The Generic Package Containers.Multiway_Trees   A.18.10 by Position is moved to be a child of Parent. If Parent already has child nodes, then the moved 
nodes are inserted prior to the node designated by Before, or, if Before equals No_Element, the 
moved nodes are inserted after the last existing child node of Parent. In each of these cases, 
Position and the count of Target are unchanged, and the parent of the element designated by 
Position is set to Parent. 
Otherwise (if Source does not denote the same obj ect as Target), the subtree designated by 
Position is removed from Source and moved to Targ et. The subtree is inserted as a child of 
Parent. If Parent already has child nodes, then the moved nodes are inserted prior to the node 
designated by Before, or, if Before equals N o_Element, the moved nodes are inserted after the 
last existing child node of Parent. In each of thes e cases, the count of Target is incremented by 
Subtree_Node_Count (Position), and the count of Source is decremented by 
Subtree_Node_Count (Position), Position is updated to repres ent an element in Target. 
procedure  Splice_Subtree (Container: in out Tree; 
                          Parent   : in     Cursor; 
                          Before   : in     Cursor; 
                          Position : in     Cursor); 
If Parent equals No_Element, then Constraint_Erro r is propagated. If Pare nt does not designate a 
node in Container, then Program_Error is propagate d. If Before is not equal to No_Element, and 
does not designate a node in Contai ner, then Program_Error is propa gated. If Before is not equal 
to No_Element, and Parent does not designate the parent node of  the node designated by Before, 
then Constraint_Error is propagated. If Pos ition equals No_Element, Constraint_Error is 
propagated. If Position does not de signate a node in Container or  designates a root node, then 
Program_Error is propagated. If Position equals Be fore, there is no effect. If Position designates 
an ancestor of Parent (including Parent itself), Constraint_Error is propagated. Otherwise, the 
subtree rooted by the element designated by Positi on is moved to be a child of Parent. If Parent 
already has child nodes, then the moved nodes ar e inserted prior to the node designated by 
Before, or, if Before equals No_Element, the moved nodes are inserted after the last existing 
child node of Parent. The parent of the elem ent designated by Position is set to Parent. 
procedure  Splice_Children (Target          : in out Tree; 
                           Target_Parent   : in     Cursor; 
                           Before          : in     Cursor; 
                           Source          : in out Tree; 
                           Source_Parent   : in     Cursor); 
If Target_Parent equals No_Element, then Constr aint_Error is propagated. If Target_Parent does 
not designate a node in Target, then Program_Erro r is propagated. If Before is not equal to 
No_Element, and does not designate an element in  Target, then Program_Error is propagated. If 
Source_Parent equals No_Element, then Constr aint_Error is propagated.  If Source_Parent does 
not designate a node in Source, then Program_Erro r is propagated. If Before is not equal to 
No_Element, and Target_Parent does not designate the parent node of the node designated by 
Before, then Constraint_Error is propagated. 
If Source denotes the same object as Target, then: 
• if Target_Parent equals Source_Parent there is no effect; else 
• if Source_Parent is an ancestor of Target_P arent other than Target_Parent itself, then 
Constraint_Error is propagated; else 
• the child elements (and the further desce ndants) of Source_Parent are moved to be 
child elements of Target_Parent. If Target_P arent already has child elements, then the 
moved elements are inserted prior to the node designated by Before, or, if Before 180/3 
181/3 
182/3 
183/3 
184/3 
185/3 
186/3 
187/3 
188/3 
Ada Reference Manual — 2012 Edition 
A.18.10    The Generic Package Containers.Multiway_Trees 13 December 2012      550 equals No_Element, the moved elements are inserted after the last existing child node 
of Target_Parent. The parent of each moved child element is set to Target_Parent.  
Otherwise (if Source does not denote the same object as Target), the child elements (and the 
further descendants) of Source_Parent are rem oved from Source and moved to Target. The child 
elements are inserted as children of Target_Par ent. If Target_Parent already has child elements, 
then the moved elements are insert ed prior to the node designated by Before, or, if Before equals 
No_Element, the moved elements ar e inserted after the last existing child node of Target_Parent. 
In each of these cases, the overall count of Ta rget is incremented by Subtree_Node_Count 
(Source_Parent)-1, and the overall count of S ource is decremented by Subtree_Node_Count 
(Source_Parent)-1. 
procedure  Splice_Children (Container       : in out Tree; 
                           Target_Parent   : in     Cursor; 
                           Before          : in     Cursor; 
                           Source_Parent   : in     Cursor); 
If Target_Parent equals No_Element, then Constr aint_Error is propagated. If Target_Parent does 
not designate a node in Container, then Program_E rror is propagated. If Before is not equal to 
No_Element, and does not designate an element in  Container, then Program_Error is propagated. 
If Source_Parent equals No_Element, then Cons traint_Error is propagated. If Source_Parent 
does not designate a node in Contai ner, then Program_Error is propa gated. If Before is not equal 
to No_Element, and Target_Parent does not designa te the parent node of the node designated by 
Before, then Constraint_Error is propagated. If Target_Parent equals Source_Parent there is no 
effect. If Source_Parent is an ancestor of Target _Parent other than Target_Parent itself, then 
Constraint_Error is propagated. Otherwise, the ch ild elements (and the further descendants) of 
Source_Parent are moved to be child elements of Target_Parent. If Target_Parent already has 
child elements, then the moved elements are inserted prior to  the node designated by Before, or, 
if Before equals No_Element, th e moved elements are inserted af ter the last existing child node 
of Target_Parent. The parent of each move d child element is set to Target_Parent. 
function  Parent (Position : Cursor) return Cursor; 
If Position is equal to No_Element or desi gnates a root node, No_Element is returned. 
Otherwise, a cursor designating the parent node of the node designated by Position is returned. 
function  First_Child (Parent : Cursor) return Cursor; 
If Parent is equal to No_Element, then Constrai nt_Error is propagated. Otherwise, First_Child 
returns a cursor designating the first child node of  the node designated by Parent; if there is no 
such node, No_Element is returned. 
function  First_Child_Element (Parent : Cursor) return Element_Type; 
Equivalent to Element (First_Child (Parent)). 
function  Last_Child (Parent : Cursor) return Cursor; 
If Parent is equal to No_Element, then Constrai nt_Error is propagated. Otherwise, Last_Child 
returns a cursor designating the last child node of  the node designated by Parent; if there is no 
such node, No_Element is returned. 
function  Last_Child_Element (Parent : Cursor) return Element_Type; 
Equivalent to Element (Last_Child (Parent)). 189/3 
190/3 
191/3 
192/3 
193/3 
194/3 
195/3 
196/3 
197/3 
198/3 
199/3 
200/3 
201/3 
Ada Reference Manual — 2012 Edition 
551      13 December 2012 The Generic Package Containers.Multiway_Trees   A.18.10 function  Next_Sibling (Position : Cursor) return Cursor; 
If Position equals No_Element or designates the last child node of  its parent, then Next_Sibling 
returns the value No_Element. Otherwise, it retu rns a cursor that designates the successor (with 
the same parent) of the node designated by Position. 
function  Previous_Sibling (Position : Cursor) return Cursor; 
If Position equals No_Element or designates the first child node of its parent, then 
Previous_Sibling returns the value No_Element. Othe rwise, it returns a cursor that designates the 
predecessor (with the same parent) of  the node designated by Position. 
procedure  Next_Sibling (Position : in out Cursor); 
Equivalent to Position := Next_Sibling (Position); 
procedure  Previous_Sibling (Position : in out Cursor); 
Equivalent to Position := Previous_Sibling (Position); 
procedure  Iterate_Children 
  (Parent  : in Cursor; 
   Process : not null access procedure  (Position : in Cursor)); 
If Parent equals No_Element, then  Constraint_Error is propagated. 
Iterate_Children calls Process. all with a cursor that designates each child node of Parent, starting 
with the first child node and moving the cu rsor as per the Next_Sibling function. 
Tampering with the cursors of the tree containi ng Parent is prohibited during the execution of a 
call on Process. all. Any exception raised by Process. all is propagated. 
procedure  Reverse_Iterate_Children 
  (Parent  : in Cursor; 
   Process : not null access procedure  (Position : in Cursor)); 
If Parent equals No_Element, then  Constraint_Error is propagated. 
Reverse_Iterate_Children calls Process. all with a cursor that designates each child node of 
Parent, starting with the last child node and moving the cursor as pe r the Previous_Sibling 
function. 
Tampering with the cursors of the tree containi ng Parent is prohibited during the execution of a 
call on Process. all. Any exception raised by Process. all is propagated. 
function  Iterate_Children (Container : in Tree; Parent : in Cursor) 
   return Tree_Iterator_Interfaces.Reversible_Iterator'Class; 
Iterate_Children returns a reversible iterator object  (see 5.5.1) that will generate a value for a 
loop parameter (see 5.5.2) designating each child node of Parent. If Parent equals No_Element, 
then Constraint_Error is propagated. If Parent does not designate a node in Container, then 
Program_Error is propagated. Otherwise, when  used as a forward iterator, the nodes are 
designated starting with the first child node and moving the cursor as per the function 
Next_Sibling; when used as a reverse iterator,  the nodes are designated starting with the last 
child node and moving the cursor as per the f unction Previous_Sibling. Tampering with the 
cursors of Container is prohibited while the iterator object exists (in particular, in the 
sequence_of_statements  of the loop_statement  whose iterator_specification  denotes this 
object). The iterator object needs finalization. 202/3 
203/3 
204/3 
205/3 
206/3 
207/3 
208/3 
209/3 
210/3 
211/3 
212/3 
213/3 
214/3 
215/3 
216/3 
217/3 
218/3 
219/3 
Ada Reference Manual — 2012 Edition 
A.18.10    The Generic Package Containers.Multiway_Trees 13 December 2012      552 Bounded (Run-Time) Errors 
It is a bounded error for the actual function associated  with a generic formal subprogram, when called as 
part of an operation of this package, to tamper w ith elements of any Tree parameter of the operation. 
Either Program_Error is raised, or the operation works as defined on the value of the Tree either prior to, 
or subsequent to, some or all of  the modifications to the Tree. 
It is a bounded error to call any subprogram declared in the visible part of Containers.Multiway_Trees 
when the associated container has been finalized. If the operation takes Container as an in out  parameter, 
then it raises Constraint_Error or Program_Error. Othe rwise, the operation either proceeds as it would for 
an empty container, or it raises Constraint_Error or Program_Error.  
Erroneous Execution 
A Cursor value is invalid  if any of the following have occurred since it was created:  
• The tree that contains the element it designates has been finalized; 
• The tree that contains the element it designates has been used as the Source or Target of a call to 
Move; 
• The tree that contains the element it designates has been used as the Target of a call to Assign or 
the target of an assignment_statement ; 
• The element it designates has been removed from the tree that previously contained the element.  
The result of "=" or Has_Element is unspecified if it is called with an invalid cursor parameter. Execution 
is erroneous if any other subprogram declared in C ontainers.Multiway_Trees is  called with an invalid 
cursor parameter. 
Execution is erroneous if the tree associated with the result of a call to Reference or Constant_Reference is 
finalized before the result object returned by the ca ll to Reference or Constant_Reference is finalized.  
Implementation Requirements 
No storage associated with a multiway tree object  shall be lost upon assignment or scope exit. 
The execution of an assignment_statement  for a tree shall have the effect of copying the elements from 
the source tree object to the target tree object and cha nging the node count of the target object to that of 
the source object. 
Implementation Advice 
Containers.Multiway_Trees should be  implemented similarly to a multiway tree. In particular, if N is the 
overall number of nodes for a particular tree, then th e worst-case time complexity  of Element, Parent, 
First_Child, Last_Child, Next_Sibli ng, Previous_Sibling, Insert_Child  with Count=1, and Delete should 
be O(log N).  
Move should not copy elements, and should mini mize copying of internal data structures.  
If an exception is propagated from a tree operation, no storage should be lost, nor  any elements removed 
from a tree unless specified by the operation.  
A.18.11 The Generic Package Containers.Indefinite_Vectors 
The language-defined generic package Containers.Indefi nite_Vectors provides a private type Vector and a 
set of operations. It provides the sa me operations as the package Containers.Vectors (see A.18.2), with the 
difference that the generic formal Element_Type is indefinite.  220/3 
221/3 
222/3 
223/3 
224/3 
225/3 226/3 
227/3 
228/3 
229/3 
230/3 
231/3 
232/3 
233/3 
1/2 
Ada Reference Manual — 2012 Edition 
553      13 December 2012 The Generic P ackage Containers.Indefinite_Vectors   A.18.11 Static Semantics 
The declaration of the generic library package Cont ainers.Indefinite_Vectors ha s the same contents and 
semantics as Containers.Vectors except: 
• The generic formal Element_Type is indefinite. 
• The procedures with the profiles:  
procedure  Insert (Container : in out Vector; 
                  Before    : in     Extended_Index; 
                  Count     : in     Count_Type := 1); 
procedure  Insert (Container : in out Vector; 
                  Before    : in     Cursor; 
                  Position  :    out Cursor; 
                  Count     : in     Count_Type := 1); 
 are omitted. 
• The actual Element parameter of access subpr ogram Process of Update_Element may be 
constrained even if Elemen t_Type is unconstrained.  
A.18.12 The Generic Package 
Containers.Indefinite_Doubly_Linked_Lists 
The language-defined generic package Containers.I ndefinite_Doubly_Linked_Lists provides private types 
List and Cursor, and a set of operations for each type. It provides the same operations as the package Containers.Doubly_Linked_Lists (see A. 18.3), with the difference that th e generic formal Element_Type 
is indefinite.  
Static Semantics 
The declaration of the generic library package C ontainers.Indefinite_Doubly_Li nked_Lists has the same 
contents and semantics as Cont ainers.Doubly_Linked_Lists except: 
• The generic formal Element_Type is indefinite. 
• The procedure with the profile:  
procedure  Insert (Container : in out List; 
                  Before    : in     Cursor; 
                  Position  :    out Cursor; 
                  Count     : in     Count_Type := 1); 
 is omitted. 
• The actual Element parameter of access subpr ogram Process of Update_Element may be 
constrained even if Elemen t_Type is unconstrained.  
A.18.13 The Generic Package Cont ainers.Indefinite_Hashed_Maps 
The language-defined generic package Containers.Inde finite_Hashed_Maps provides a map with the same 
operations as the package Containe rs.Hashed_Maps (see A.18.5), with the difference that the generic 
formal types Key_Type and Element_Type are indefinite.  
Static Semantics 
The declaration of the generic library package Cont ainers.Indefinite_Hashed_Map s has the same contents 
and semantics as Containers.Hashed_Maps except: 
• The generic formal Key_Type is indefinite. 
• The generic formal Element_Type is indefinite. 2/3 
3/2 
4/2 
5/2 
6/2 
7/2 
8/2 
1/2 
2/3 
3/2 
4/2 
5/2 
6/2 
7/2 
1/2 
2/3 
3/2 
4/2 
Ada Reference Manual — 2012 Edition 
A.18.13    The Generic Package Containers.Indefi nite_Hashed_Maps 13 December 2012      554 • The procedure with the profile:  
procedure  Insert (Container : in out Map; 
                  Key       : in     Key_Type; 
                  Position  :    out Cursor; 
                  Inserted  :    out Boolean); 
 is omitted. 
• The actual Element parameter of access subpr ogram Process of Update_Element may be 
constrained even if Elemen t_Type is unconstrained.  
A.18.14 The Generic Package Contai ners.Indefinite_Ordered_Maps 
The language-defined generic package Containers.Inde finite_Ordered_Maps provides a map with the same 
operations as the package Containers.Ordered_Maps (see A.18.6), with the difference that the generic 
formal types Key_Type and Element_Type are indefinite.  
Static Semantics 
The declaration of the generic library package Contai ners.Indefinite_Ordered_Map s has the same contents 
and semantics as Containers.Ordered_Maps except: 
• The generic formal Key_Type is indefinite. 
• The generic formal Element_Type is indefinite. 
• The procedure with the profile:  
procedure  Insert (Container : in out Map; 
                  Key       : in     Key_Type; 
                  Position  :    out Cursor; 
                  Inserted  :    out Boolean); 
 is omitted. 
• The actual Element parameter of access subpr ogram Process of Update_Element may be 
constrained even if Elemen t_Type is unconstrained. 
A.18.15 The Generic Package Containers.Indefinite_Hashed_Sets 
The language-defined generic package Containers.Inde finite_Hashed_Sets provides a set with the same 
operations as the package Containers.Hashed_Sets (see A. 18.8), with the difference that the generic formal 
type Element_Type is indefinite.  
Static Semantics 
The declaration of the generic library package Cont ainers.Indefinite_Hashed_Set s has the same contents 
and semantics as Containers.Hashed_Sets except: 
• The generic formal Element_Type is indefinite. 
• The actual Element parameter of access subprogram Process of Update_Element_-
Preserving_Key may be constrained even if Element_Type is unconstrained.  
A.18.16 The Generic Package Contai ners.Indefinite_Ordered_Sets 
The language-defined generic package Containers.Inde finite_Ordered_Sets provides a set with the same 
operations as the package Containers.Ordered_Sets (see A.18.9), with the difference that the generic 
formal type Element_Type is indefinite.  5/2 
6/2 
7/2 
8/2 
1/2 
2/3 
3/2 
4/2 5/2 
6/2 
7/2 
8/2 
1/2 
2/3 
3/2 
4/2 
1/2 
Ada Reference Manual — 2012 Edition 
555      13 December 2012 The Generic Packag e Containers.Indefinite_Ordered_Sets   A.18.16 Static Semantics 
The declaration of the generic library package Contai ners.Indefinite_Ordered_Set s has the same contents 
and semantics as Containers.Ordered_Sets except: 
• The generic formal Element_Type is indefinite. 
• The actual Element parameter of access subprogram Process of Update_Element_-
Preserving_Key may be constrained even if Element_Type is unconstrained.  
A.18.17 The Generic Package Containers.Indefinite_Multiway_Trees 
The language-defined generic package Containers.I ndefinite_Multiway_Trees provides a multiway tree 
with the same operations as the package Containe rs.Multiway_Trees (see A.18. 10), with the difference 
that the generic formal Element_Type is indefinite.  
Static Semantics 
The declaration of the generic library package C ontainers.Indefinite_Multiway_Trees has the same 
contents and semantics as C ontainers.Multiway_Trees except: 
• The generic formal Element_Type is indefinite. 
• The procedure with the profile:  
procedure  Insert_Child (Container : in out Tree; 
                        Parent    : in     Cursor; 
                        Before    : in     Cursor; 
                        Position  :    out Cursor; 
                        Count     : in     Count_Type := 1); 
 is omitted. 
• The actual Element parameter of access subpr ogram Process of Update_Element may be 
constrained even if Elemen t_Type is unconstrained.  
A.18.18 The Generic Package Containers.Indefinite_Holders 
The language-defined generic package Containers.Indefi nite_Holders provides a private type Holder and a 
set of operations for that type. A holder containe r holds a single element of an indefinite type. 
A holder container allows the declaration of an object that can be used like an uninitialized variable or 
component of an indefinite type. 
A holder container may be empty . An empty holder does not contain an element.  
Static Semantics 
The generic library package Containers.Indefin ite_Holders has the following declaration:  
generic 
   type Element_Type (<>) is private ; 
   with function  "=" (Left, Right : Element_Type) return Boolean is <>; 
package Ada.Containers.Indefinite_Holders is 
   pragma Preelaborate(Indefinite_Holders); 
   pragma Remote_Types(Indefinite_Holders); 
   type Holder is tagged private ; 
   pragma Preelaborable_Initialization (Holder); 
   Empty_Holder : constant  Holder; 
   function  "=" (Left, Right : Holder) return Boolean; 
   function  To_Holder (New_Item : Element_Type) return Holder; 2/3 
3/2 
4/2 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
1/3 
2/3 3/3 
4/3 
5/3 
6/3 
7/3 
8/3 9/3 
Ada Reference Manual — 2012 Edition 
A.18.18    The Generic Package Containers.Inde finite_Holders 13 December 2012      556    function  Is_Empty (Container : Holder) return Boolean; 
   procedure  Clear (Container : in out Holder); 
   function  Element (Container : Holder) return Element_Type; 
   procedure  Replace_Element (Container : in out Holder; 
                              New_Item  : in     Element_Type); 
   procedure  Query_Element 
  (Container : in Holder; 
   Process   : not null access procedure  (Element : in Element_Type)); 
   procedure  Update_Element 
  (Container : in out Holder; 
   Process   : not null access procedure  (Element : in out Element_Type)); 
   type Constant_Reference_Type 
      (Element : not null access constant  Element_Type) is private  
   with Implicit_Dereference => Element; 
   type Reference_Type (Element : not null access  Element_Type) is private  
   with Implicit_Dereference => Element; 
   function  Constant_Reference (Container : aliased in  Holder) 
   return Constant_Reference_Type; 
   function  Reference (Container : aliased in out  Holder) 
   return Reference_Type; 
   procedure  Assign (Target : in out Holder; Source : in Holder); 
   function  Copy (Source : Holder) return Holder; 
   procedure  Move (Target : in out Holder; Source : in out Holder); 
private 
   ... -- not specified by the language  
end Ada.Containers.Indefinite_Holders; 
The actual function for the generic formal function "=" on Element_Type values is expected to define a 
reflexive and symmetric relationship and return the same result value each time it is called with a particular pair of values. If it behaves in some othe r manner, the function "=" on holder values returns an 
unspecified value. The exact arguments and number of ca lls of this generic formal function by the function 
"=" on holder values are unspecified. 
The type Holder is used to repr esent holder containers. The type Ho lder needs finalization (see 7.6). 
Empty_Holder represents an empty holder object. If an object of type Holder is not otherwise initialized, it 
is initialized to the same  value as Empty_Holder. 
Some operations of this generic package have access-to-subprogram parameters. To ensure such 
operations are well-defined, they guard against certain  actions by the designated subprogram. In particular, 
some operations check for “tampering with the element” of a container because they depend on the element of the container not being replaced. 
A subprogram is said to tamper with the element  of a holder object H if: 
• It clears the element contained by H, that is, it calls the Clear procedure with H as a parameter; 
• It replaces the element contained by H, that is, it calls the Replace_Element procedure with H as 
a parameter; 
• It calls the Move procedure with H as a parameter; 
• It finalizes H. 10/3 
11/3 12/3 13/3 
14/3 
15/3 16/3 17/3 
18/3 19/3 20/3 
21/3 22/3 23/3 24/3 25/3 
26/3 
27/3 
28/3 
29/3 
30/3 
31/3 
32/3 
33/3 
34/3 
Ada Reference Manual — 2012 Edition 
557      13 December 2012 The Generic Pack age Containers.Indefinite_Holders   A.18.18 When tampering with the element is prohibited  for a particular holder object H, Program_Error is 
propagated by a call of any language-defined subprogram that is defined to tamper with the element of H, 
leaving H unmodified. 
function  "=" (Left, Right : Holder) return Boolean; 
If Left and Right denote the same holder object, then the function returns True. Otherwise, it 
compares the element contained in Left to the element contained in Right using the generic formal equality operator, returning the result of  that operation. Any exception raised during the 
evaluation of element equality is propagated. 
function  To_Holder (New_Item : Element_Type) return Holder; 
Returns a nonempty holder containing an element initialized to New_Item. 
function  Is_Empty (Container : Holder) return Boolean; 
Returns True if Container is empty, and False if it contains an element. 
procedure  Clear (Container : in out Holder); 
Removes the element from Container. Container is empty after a successful Clear operation. 
function  Element (Container : Holder) return Element_Type; 
If Container is empty, Constraint_Error is propaga ted. Otherwise, returns the element stored in 
Container. 
procedure  Replace_Element (Container : in out Holder; 
                           New_Item  : in     Element_Type); 
Replace_Element assigns the value New_Item into Container, replacing any preexisting content 
of Container. Container is not empty after a successful call to Replace_Element. 
procedure  Query_Element 
  (Container : in Holder; 
   Process   : not null access procedure  (Element : in Element_Type)); 
If Container is empty, Constraint_Error is propagated. Otherwise, Query_Element calls 
Process. all with the contained element as the ar gument. Tampering with the element of 
Container is prohibited during the execution of the call on Process. all. Any exception raised by 
Process. all is propagated. 
procedure  Update_Element 
  (Container : in out Holder; 
   Process   : not null access procedure  (Element : in out Element_Type)); 
If Container is empty, Constraint_Error is pr opagated. Otherwise, Update_Element calls 
Process. all with the contained element as the ar gument. Tampering with the element of 
Container is prohibited during the execution of the call on Process. all. Any exception raised by 
Process. all is propagated. 
type Constant_Reference_Type 
      (Element : not null access constant  Element_Type) is private  
   with Implicit_Dereference => Element; 
type Reference_Type (Element : not null access  Element_Type) is private  
   with Implicit_Dereference => Element; 
The types Constant_Reference_Type and Reference_Type need finalization. 35/3 
36/3 
37/3 
38/3 
39/3 
40/3 
41/3 
42/3 
43/3 
44/3 
45/3 
46/3 
47/3 
48/3 
49/3 
50/3 
51/3 
52/3 
53/3 
54/3 
Ada Reference Manual — 2012 Edition 
A.18.18    The Generic Package Containers.Inde finite_Holders 13 December 2012      558 The default initialization of an object of type  Constant_Reference_Type or Reference_Type 
propagates Program_Error. 
function  Constant_Reference (Container : aliased in  Holder) 
   return Constant_Reference_Type; 
This function (combined with the Implicit_Dereference aspect) provides a convenient way to 
gain read access to the contained element of a holder container. 
If Container is empty, Constraint_Error is propaga ted. Otherwise, Constant_Reference returns an 
object whose discriminant is an access value that designates the contained element. Tampering with the elements of Containe r is prohibited while the object returned by Constant_Reference 
exists and has not been finalized. 
function  Reference (Container : aliased in out  Holder) 
   return Reference_Type; 
This function (combined with th e Implicit_Dereference aspects) provides a convenient way to 
gain read and write access to the contained element of a holder container. 
If Container is empty, Constraint_Error is propa gated. Otherwise, Reference returns an object 
whose discriminant is an access value that designa tes the contained element. Tampering with the 
elements of Container is prohibited while the obj ect returned by Reference exists and has not 
been finalized.  
procedure  Assign (Target : in out Holder; Source : in Holder); 
If Target denotes the same object as Source, the operation has no effect. If Source is empty, 
Clear (Target) is called. Otherwise, Replace_Element (Target, Element (Source)) is called.  
function  Copy (Source : Holder) return Holder; 
If Source is empty, returns an empty holder cont ainer; otherwise, retu rns To_Holder (Element 
(Source)). 
procedure  Move (Target : in out Holder; Source : in out Holder); 
If Target denotes the same object as Source, then the operation has no effect. Otherwise, the 
element contained by Source (if any) is remove d from Source and inserted into Target, replacing 
any preexisting content. Source is empty after a successful call to Move. 
Bounded (Run-Time) Errors 
It is a bounded error for the actual function associated  with a generic formal subprogram, when called as 
part of an operation of this package, to tamper with  the element of any Holder parameter of the operation. 
Either Program_Error is raised, or the operation works as defined on the value of the Holder either prior 
to, or subsequent to, some or all of the modifications to the Holder. 
It is a bounded error to call any subprogram declared in  the visible part of Containers.Indefinite_Holders 
when the associated container has been finalized. If the operation takes Container as an in out  parameter, 
then it raises Constraint_Error or Program_Error. Othe rwise, the operation either proceeds as it would for 
an empty container, or it raises Constraint_Error or Program_Error.  
Erroneous Execution 
Execution is erroneous if the holder container associ ated with the result of a call to Reference or 
Constant_Reference is finalized before the resu lt object returned by the call to Reference or 
Constant_Reference is finalized. 55/3 
56/3 
57/3 
58/3 
59/3 
60/3 
61/3 
62/3 
63/3 
64/3 
65/3 
66/3 
67/3 
68/3 
69/3 
70/3 
Ada Reference Manual — 2012 Edition 
559      13 December 2012 The Generic Pack age Containers.Indefinite_Holders   A.18.18 Implementation Requirements 
No storage associated with a holder object shall be lost upon assignment or scope exit. 
The execution of an assignment_statement  for a holder container shall have the effect of copying the 
element (if any) from the source holder object to the target holder object. 
Implementation Advice 
Move should not copy the element, and should mi nimize copying of internal data structures.  
If an exception is propagated from a holder operation, no storage should be lost, nor should the element be 
removed from a holder container unle ss specified by the operation.  
A.18.19 The Generic Package Containers.Bounded_Vectors 
The language-defined generic package Containers.B ounded_Vectors provides a private type Vector and a 
set of operations. It provides the sa me operations as the package Containers.Vectors (see A.18.2), with the 
difference that the maximum storage is bounded. 
Static Semantics 
The declaration of the generic library package C ontainers.Bounded_Vectors has the same contents and 
semantics as Containers.Vectors except: 
• The pragma  Preelaborate is replaced with pragma  Pure. 
• The type Vector is declared with a di scriminant that specifies the capacity:  
  type Vector (Capacity : Count_Type) is tagged private ; 
• The type Vector needs finalization if and onl y if type Element_Type needs finalization. 
• In function Copy, if the Capacity parameter is e qual to or greater than the length of Source, the 
vector capacity exactly equals the value of the Capacity parameter. 
• The description of Reserve_Capacity is replaced with:  
If the specified Capacity is larger than the capacity of Container, then Reserve_Capacity 
propagates Capacity_Error. Otherwis e, the operation has no effect.  
Bounded (Run-Time) Errors 
It is a bounded error to assign from a bounded vector object  while tampering with elements or cursors of 
that object is prohibited. Either Program_Error is ra ised by the assignment, execution proceeds with the 
target object prohibiting tampering with elements  or cursors, or execution proceeds normally.  
Erroneous Execution 
When a bounded vector object V is finalized, if tampering with cursors is prohibited for V other than due 
to an assignment from another vect or, then execution is erroneous.  
Implementation Requirements 
For each instance of Containers.Vectors and each in stance of Containers.Bounded_Vectors, if the two 
instances meet the following conditions, then the output  generated by the Vector'Output or Vector'Write 
subprograms of either instance shall be readable by th e Vector'Input or Vector'Read of the other instance, 
respectively: 
• the Element_Type parameters of the two instances are statically matching subtypes of the same 
type; and 71/3 
72/3 
73/3 
74/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
13/3 
Ada Reference Manual — 2012 Edition 
A.18.19    The Generic Package Containers .Bounded_Vectors 13 December 2012      560 • the output generated by Element_Type'Output  or Element_Type'Write is readable by 
Element_Type'Input or Element_Type'Read, resp ectively (where Element_Type denotes the 
type of the two actual Element_Type parameters); and 
• the preceding two conditions also hold for th e Index_Type parameters of the instances.  
Implementation Advice 
Bounded vector objects should be implemented wit hout implicit pointers or dynamic allocation.  
The implementation advice for procedure Move  to minimize copying does not apply.  
A.18.20 The Generic Package 
Containers.Bounded_Doubly_Linked_Lists 
The language-defined generic package Containers .Bounded_Doubly_Linked_Lists provides a private type 
List and a set of operations. It provide s the same operations as the package 
Containers.Doubly_Linked_Lists (see A.18.3), with the difference that the maximum storage is bounded. 
Static Semantics 
The declaration of the generic library package Containers.Bounded_Doubly_Linke d_Lists has the same 
contents and semantics as Cont ainers.Doubly_Linked_Lists except: 
• The pragma  Preelaborate is replaced with pragma  Pure. 
• The type List is declared with a discriminant that specifies the capacity (maximum number of 
elements) as follows:  
  type List (Capacity : Count_Type) is tagged private ; 
• The type List needs finalization if and onl y if type Element_Type needs finalization. 
• The allocation of internal storage includes a check that the capacity is not exceeded, and 
Capacity_Error is raised  if this check fails. 
• In procedure Assign, if Source length is greater  than Target capacity, then Capacity_Error is 
propagated. 
• The function Copy is replaced with:  
  function  Copy (Source : List; Capacity : Count_Type := 0) 
     return List; 
If Capacity is 0, then the list cap acity is the length of Source; if Capacity is equal to or greater 
than the length of Source, the list capacity equals the value of the Capacity parameter; otherwise, 
the operation propagates Capacity_Error.  
• In the three-parameter procedure Splice whose S ource has type List, if the sum of the length of 
Target and the length of Source is greater than  the capacity of Target, then Splice propagates 
Capacity_Error. 
• In the four-parameter procedure Splice, if the length of Target equals the capacity of Target, 
then Splice propagates Capacity_Error. 
Bounded (Run-Time) Errors 
It is a bounded error to assign from a bounded list object wh ile tampering with elements or cursors of that 
object is prohibited. Either Program_Error is raised by the assignment, execution proceeds with the target 
object prohibiting tampering with elements or  cursors, or execution proceeds normally.  14/3 
15/3 
16/3 
17/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
Ada Reference Manual — 2012 Edition 
561      13 December 2012 The Generic Pack age Containers.Bounded_Doubly_Linked_Lists   A.18.20 Erroneous Execution 
When a bounded list object L is finalized, if tampering with cursors is prohibited for L other than due to an 
assignment from another list, th en execution is erroneous.  
Implementation Requirements 
For each instance of Containers.Doubl y_Linked_Lists and each instance of 
Containers.Bounded_Doubly_Linked_Lists, if the two instances meet th e following conditions, then the 
output generated by the List'Output or List'Write subpr ograms of either instance shall be readable by the 
List'Input or List'Read of the other instance, respectively: 
• the Element_Type parameters of the two instances are statically matching subtypes of the same 
type; and 
• the output generated by Element_Type'Output  or Element_Type'Write is readable by 
Element_Type'Input or Element_Type'Read, resp ectively (where Element_Type denotes the 
type of the two actual Element_Type parameters).  
Implementation Advice 
Bounded list objects should be impl emented without implicit pointers or dynamic allocation.  
The implementation advice for procedure Move  to minimize copying does not apply.  
A.18.21 The Generic Package Containers.Bounded_Hashed_Maps 
The language-defined generic package Containers .Bounded_Hashed_Maps provides a private type Map 
and a set of operations. It provide s the same operations as the package Containers.Hashed_Maps (see 
A.18.5), with the difference that the maximum storage is bounded. 
Static Semantics 
The declaration of the generic library package C ontainers.Bounded_Hashed_Maps has the same contents 
and semantics as Containers.Hashed_Maps except: 
• The pragma  Preelaborate is replaced with pragma  Pure. 
• The type Map is declared with discriminants that specify both the capacity (number of elements) 
and modulus (number of distinct hash va lues) of the hash table as follows:  
  type Map (Capacity : Count_Type; 
            Modulus  : Hash_Type) is tagged private ; 
• The type Map needs finalization if and only if  type Key_Type or type Element_Type needs 
finalization. 
• The description of Reserve_Capacity is replaced with:  
If the specified Capacity is larger than the capacity of Container, then Reserve_Capacity 
propagates Capacity_Error. Otherwis e, the operation has no effect.  
• An additional operation is added imme diately following Reserve_Capacity:  
  function  Default_Modulus (Capacity : Count_Type) return Hash_Type; 
Default_Modulus returns an implem entation-defined value for the num ber of distinct hash values 
to be used for the given capacity (maximum number of  elements).  
• The function Copy is replaced with:  
  function  Copy (Source   : Map; 
                 Capacity : Count_Type := 0;                  Modulus  : Hash_Type := 0) return Map; 15/3 
16/3 
17/3 
18/3 
19/3 
20/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
13/3 
Ada Reference Manual — 2012 Edition 
A.18.21    The Generic Package Containers.B ounded_Hashed_Maps 13 December 2012      562 Returns a map with key/element pairs initialized from the values in Source. If Capacity is 0, then 
the map capacity is the length of Source; if Capac ity is equal to or greater than the length of 
Source, the map capacity is the value of the Capacity parameter; otherwise, the operation 
propagates Capacity_Error.  If the Modulus argumen t is 0, then the map modulus is the value 
returned by a call to Default_Modulus with the map capacity as its argum ent; otherwise, the map 
modulus is the value of the Modulus parameter.  
Bounded (Run-Time) Errors 
It is a bounded error to assign from a bounded map object wh ile tampering with elemen ts or cursors of that 
object is prohibited. Either Program_Error is raised by the assignment, execution proceeds with the target 
object prohibiting tampering with elements or  cursors, or execution proceeds normally.  
Erroneous Execution 
When a bounded map object M is finalized, if tampering with cursors is prohibited for M other than due to 
an assignment from another map, then execution is erroneous.  
Implementation Requirements 
For each instance of Containers.Hashed_Maps and each  instance of Containers.Bounded_Hashed_Maps, if 
the two instances meet the following conditions, th en the output generated by the Map'Output or 
Map'Write subprograms of either instance shall be read able by the Map'Input or Map'Read of the other 
instance, respectively: 
• the Element_Type parameters of the two instances are statically matching subtypes of the same 
type; and 
• the output generated by Element_Type'Output  or Element_Type'Write is readable by 
Element_Type'Input or Element_Type'Read, resp ectively (where Element_Type denotes the 
type of the two actual Element_Type parameters); and 
• the preceding two conditions also hold for th e Key_Type parameters of the instances.  
Implementation Advice 
Bounded hashed map objects should be implemented w ithout implicit pointers or dynamic allocation.  
The implementation advice for procedure Move  to minimize copying does not apply.  
A.18.22 The Generic Package Containers.Bounded_Ordered_Maps 
The language-defined generic package Containers .Bounded_Ordered_Maps provides a private type Map 
and a set of operations. It provide s the same operations as the package Containers.Ordered_Maps (see 
A.18.6), with the difference that the maximum storage is bounded. 
Static Semantics 
The declaration of the generic library package C ontainers.Bounded_Ordered_Maps has the same contents 
and semantics as Containers.Ordered_Maps except: 
• The pragma  Preelaborate is replaced with pragma  Pure. 
• The type Map is declared with a discriminant that specifies the capacity (maximum number of 
elements) as follows:  
  type Map (Capacity : Count_Type) is tagged private ; 14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
20/3 
21/3 
22/3 
1/3 
2/3 
3/3 
4/3 
5/3 
Ada Reference Manual — 2012 Edition 
563      13 December 2012 The Generic Package Containers.Bounded_Ordered_Maps   A.18.22 • The type Map needs finalization if and only if  type Key_Type or type Element_Type needs 
finalization. 
• The allocation of a new node includes a ch eck that the capacity is not exceeded, and 
Capacity_Error is raised  if this check fails. 
• In procedure Assign, if Source length is greater  than Target capacity, then Capacity_Error is 
propagated. 
• The function Copy is replaced with:  
  function  Copy (Source   : Map; 
                 Capacity : Count_Type := 0) return Map; 
Returns a map with key/element pairs initialized from the values in Source. If Capacity is 0, then 
the map capacity is the length of Source; if Capac ity is equal to or greater than the length of 
Source, the map capacity is the specified value; otherwise, the operation propagates 
Capacity_Error.  
Bounded (Run-Time) Errors 
It is a bounded error to assign from a bounded map object wh ile tampering with elemen ts or cursors of that 
object is prohibited. Either Program_Error is raised by the assignment, execution proceeds with the target 
object prohibiting tampering with elements or  cursors, or execution proceeds normally.  
Erroneous Execution 
When a bounded map object M is finalized, if tampering with cursors is prohibited for M other than due to 
an assignment from another map, then execution is erroneous.  
Implementation Requirements 
For each instance of Containers.Ordered_Maps and each instance of Containers.Bounded_Ordered_Maps, 
if the two instances meet the following conditions, then the output generated by the Map'Output or 
Map'Write subprograms of either instance shall be read able by the Map'Input or Map'Read of the other 
instance, respectively: 
• the Element_Type parameters of the two instances are statically matching subtypes of the same 
type; and 
• the output generated by Element_Type'Output  or Element_Type'Write is readable by 
Element_Type'Input or Element_Type'Read, resp ectively (where Element_Type denotes the 
type of the two actual Element_Type parameters); and 
• the preceding two conditions also hold for th e Key_Type parameters of the instances.  
Implementation Advice 
Bounded ordered map objects should be  implemented without implicit pointers or dynamic allocation.  
The implementation advice for procedure Move  to minimize copying does not apply.  
A.18.23 The Generic Package Containers.Bounded_Hashed_Sets 
The language-defined generic package Containers.B ounded_Hashed_Sets provides a private type Set and 
a set of operations. It provides th e same operations as the package Containers.Hashed_Sets (see A.18.8), 
with the difference that the maximum storage is bounded. 6/3 
7/3 8/3 9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
1/3 
Ada Reference Manual — 2012 Edition 
A.18.23    The Generic Package Containers.B ounded_Hashed_Sets 13 December 2012      564 Static Semantics 
The declaration of the generic library package C ontainers.Bounded_Hashed_Sets has the same contents 
and semantics as Containers.Hashed_Sets except: 
• The pragma  Preelaborate is replaced with pragma  Pure. 
• The type Set is declared with discriminants that specify both the capacity (number of elements) 
and modulus (number of distinct hash va lues) of the hash table as follows:  
  type Set (Capacity : Count_Type; 
            Modulus  : Hash_Type) is tagged private ; 
• The type Set needs finalization if and only if type Element_Type needs finalization. 
• The description of Reserve_Capacity is replaced with:  
If the specified Capacity is larger than the capacity of Container, then Reserve_Capacity 
propagates Capacity_Error. Otherwis e, the operation has no effect.  
• An additional operation is added imme diately following Reserve_Capacity:  
  function  Default_Modulus (Capacity : Count_Type) return Hash_Type; 
Default_Modulus returns an implem entation-defined value for the num ber of distinct hash values 
to be used for the given capacity (maximum number of  elements).  
• The function Copy is replaced with:  
  function  Copy (Source   : Set; 
                 Capacity : Count_Type := 0;                  Modulus  : Hash_Type := 0) return Set; 
Returns a set whose elements are initialized from the values in Sour ce. If Capacity is 0, then the 
set capacity is the length of Source; if Capacity is  equal to or greater than the length of Source, 
the set capacity is the value of the Capacity parameter; otherwise, the operation propagates 
Capacity_Error. If the Modulus argum ent is 0, then the set modulus  is the value returned by a 
call to Default_Modulus with the set capacity as its argument; othe rwise, the set modulus is the 
value of the Modulus parameter.  
Bounded (Run-Time) Errors 
It is a bounded error to assign from a bounded set object wh ile tampering with elements or cursors of that 
object is prohibited. Either Program_Error is raised by the assignment, execution proceeds with the target 
object prohibiting tampering with elements or  cursors, or execution proceeds normally.  
Erroneous Execution 
When a bounded set object S is finalized, if tampering with cursors is prohibited for S other than due to an 
assignment from another set, then execution is erroneous.  
Implementation Requirements 
For each instance of Containers.Hashed_Sets and each  instance of Containers.Bounded_Hashed_Sets, if 
the two instances meet the following conditions, then the output generated by the Set'Output or Set'Write 
subprograms of either instance shall be readable by the Set'Input or Set'Read of the other instance, 
respectively: 
• the Element_Type parameters of the two instances are statically matching subtypes of the same 
type; and 
• the output generated by Element_Type'Output  or Element_Type'Write is readable by 
Element_Type'Input or Element_Type'Read, resp ectively (where Element_Type denotes the 
type of the two actual Element_Type parameters).  2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
Ada Reference Manual — 2012 Edition 
565      13 December 2012 The Generic P ackage Containers.Bounded_Hashed_Sets   A.18.23 Implementation Advice 
Bounded hashed set objects should be implemented w ithout implicit pointers or dynamic allocation.  
The implementation advice for procedure Move  to minimize copying does not apply.  
A.18.24 The Generic Package Containers.Bounded_Ordered_Sets 
The language-defined generic package Containers.B ounded_Ordered_Sets provides a private type Set and 
a set of operations. It provides the same operations as the package Containers.Ordered_Sets (see A.18.9), 
with the difference that the maximum storage is bounded. 
Static Semantics 
The declaration of the generic library package C ontainers.Bounded_Ordered_Sets has the same contents 
and semantics as Containers.Ordered_Sets except: 
• The pragma  Preelaborate is replaced with pragma  Pure. 
• The type Set is declared with a discriminant that specifies the capacity (maximum number of 
elements) as follows:  
  type Set (Capacity : Count_Type) is tagged private ; 
• The type Set needs finalization if and only if type Element_Type needs finalization. 
• If Insert (or Include) adds an element, a check is made that the capacity is not exceeded, and 
Capacity_Error is raised  if this check fails. 
• In procedure Assign, if Source length is greater  than Target capacity, then Capacity_Error is 
propagated. 
• The function Copy is replaced with:  
  function  Copy (Source   : Set; 
                 Capacity : Count_Type := 0) return Set; 
Returns a set whose elements are initialized from the values in Sour ce. If Capacity is 0, then the 
set capacity is the length of Source; if Capacity is  equal to or greater than the length of Source, 
the set capacity is the specified value; otherw ise, the operation propagates Capacity_Error.  
Bounded (Run-Time) Errors 
It is a bounded error to assign from a bounded set object wh ile tampering with elements or cursors of that 
object is prohibited. Either Program_Error is raised by the assignment, execution proceeds with the target 
object prohibiting tampering with elements or  cursors, or execution proceeds normally.  
Erroneous Execution 
When a bounded set object S is finalized, if tampering with cursors is prohibited for S other than due to an 
assignment from another set, then execution is erroneous.  
Implementation Requirements 
For each instance of Containers.Ordered_Sets and each  instance of Containers.Bounded_Ordered_Sets, if 
the two instances meet the following conditions, then the output generated by the Set'Output or Set'Write 
subprograms of either instance shall be readable by the Set'Input or Set'Read of the other instance, 
respectively: 
• the Element_Type parameters of the two instances are statically matching subtypes of the same 
type; and 20/3 
21/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
Ada Reference Manual — 2012 Edition 
A.18.24    The Generic Package Containers.Bounde d_Ordered_Sets 13 December 2012      566 • the output generated by Element_Type'Output  or Element_Type'Write is readable by 
Element_Type'Input or Element_Type'Read, resp ectively (where Element_Type denotes the 
type of the two actual Element_Type parameters).  
Implementation Advice 
Bounded ordered set objects should be  implemented without implicit pointers or dynamic allocation.  
The implementation advice for procedure Move  to minimize copying does not apply.  
A.18.25 The Generic Package Containers.Bounded_Multiway_Trees 
The language-defined generic package Containers.B ounded_Multiway_Trees provides a private type Tree 
and a set of operations. It provides the same operati ons as the package Contai ners.Multiway_Trees (see 
A.18.10), with the difference that the maximum storage is bounded. 
Static Semantics 
The declaration of the generic library packag e Containers.Bounded_Multiway_Trees has the same 
contents and semantics as C ontainers.Multiway_Trees except: 
• The pragma  Preelaborate is replaced with pragma  Pure. 
• The type Tree is declared with a discriminant  that specifies the capacity (maximum number of 
elements) as follows:  
  type Tree (Capacity : Count_Type) is tagged private ; 
• The type Tree needs finalization if and only if type Element_Type needs finalization. 
• The allocation of internal storage includes a check that the capacity is not exceeded, and 
Capacity_Error is raised  if this check fails. 
• In procedure Assign, if Source length is greater  than Target capacity, then Capacity_Error is 
propagated. 
• Function Copy is declared as follows:  
  function  Copy (Source : Tree; Capacity : Count_Type := 0) 
     return List; 
 If Capacity is 0, then the tree capacity is the count  of Source; if Capacity is equal to or greater 
than Source.Count, the tree capacity equals the value of the Capacity parameter; otherwise, the 
operation propagates Capacity_Error. 
• In the five-parameter procedure Splice_Subtree, if  Source is not the same object as Target, and if 
the sum of Target.Count and Subtree_Node_Count (Position) is greater than Target.Capacity, 
then Splice_Subtree propagates Capacity_Error. 
• In the five-parameter procedure Splice_Children, if Source is not the same object as Target, and 
if the sum of Target.Count and Subtree_N ode_Count (Source_Parent)-1 is greater than 
Target.Capacity, then Splice_Children propagates Capacity_Error.  
Bounded (Run-Time) Errors 
It is a bounded error to assign from a bounded tree object wh ile tampering with elements or cursors of that 
object is prohibited. Either Program_Error is raised by the assignment, execution proceeds with the target 
object prohibiting tampering with elements or  cursors, or execution proceeds normally.  16/3 
17/3 
18/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
Ada Reference Manual — 2012 Edition 
567      13 December 2012 The Generic Package Containers.Bounded_Multiway_Trees   A.18.25 Erroneous Execution 
When a bounded tree object T is finalized, if tampering with cursors is prohibited for T other than due to 
an assignment from another tree, then execution is erroneous.  
Implementation Requirements 
For each instance of Containers.Mu ltiway_Trees and each instance of 
Containers.Bounded_Multiway_Trees, if  the two instances meet the fo llowing conditions, then the output 
generated by the Tree'Output or Tree'Write subprogram s of either instance shall be readable by the 
Tree'Input or Tree'Read of the other instance, respectively: 
• the Element_Type parameters of the two instances are statically matching subtypes of the same 
type; and 
• the output generated by Element_Type'Output  or Element_Type'Write is readable by 
Element_Type'Input or Element_Type'Read, resp ectively (where Element_Type denotes the 
type of the two actual Element_Type parameters).  
Implementation Advice 
Bounded tree objects should be implemented without  implicit pointers or dynamic allocation.  
The implementation advice for procedure Move  to minimize copying does not apply.  15/3 
16/3 
17/3 
18/3 
19/3 
20/3 
Ada Reference Manual — 2012 Edition 
A.18.26    Array Sorting 13 December 2012      568 A.18.26 Array Sorting 
The language-defined generic procedures Contai ners.Generic_Array_Sort , Containers.Generic_-
Constrained_Array_Sort, and Containers.Generic_Sor t provide sorting on arbitrary array types.  
Static Semantics 
The generic library procedure Containers.Gener ic_Array_Sort has the following declaration:  
generic 
   type Index_Type is (<>); 
   type Element_Type is private ; 
   type Array_Type is array  (Index_Type range <>) of Element_Type; 
   with function  "<" (Left, Right : Element_Type) 
      return Boolean is <>; 
procedure  Ada.Containers.Generic_Array_Sort (Container : in out Array_Type); 
pragma Pure(Ada.Containers.Generic_Array_Sort); 
Reorders the elements of Container such that the elements are sorted smallest first as determined 
by the generic formal "<" operator provided. An y exception raised during evaluation of "<" is 
propagated. 
The actual function for the generic formal functi on "<" of Generic_Array_Sort is expected to 
return the same value each time it is called with a particular pair of element values. It should 
define a strict weak ordering relationship (s ee A.18); it should not modify Container. If the 
actual for "<" behaves in so me other manner, the behavior of the instance of 
Generic_Array_Sort is unspecified. The number of times Generic_Array_Sort calls "<" is 
unspecified. 
The generic library procedure Containers.Generic_Cons trained_Array_Sort has the following declaration:  
generic 
   type Index_Type is (<>); 
   type Element_Type is private ; 
   type Array_Type is array  (Index_Type) of Element_Type; 
   with function  "<" (Left, Right : Element_Type) 
      return Boolean is <>; 
procedure  Ada.Containers.Generic_Constrained_Array_Sort 
      (Container : in out Array_Type); 
pragma Pure(Ada.Containers.Generic_Constrained_Array_Sort); 
Reorders the elements of Container such that the elements are sorted smallest first as determined 
by the generic formal "<" operator provided. An y exception raised during evaluation of "<" is 
propagated. 
The actual function for the generic formal func tion "<" of Generic_Constrained_Array_Sort is 
expected to return the same value each time it is called with a particular pair of element values. 
It should define a strict weak ordering relations hip (see A.18); it should not modify Container. If 
the actual for "<" behaves in some other manner, the behavior of the instance of 
Generic_Constrained_Array_Sort is unspecified. The number of times 
Generic_Constrained_Array_Sort  calls "<" is unspecified. 
The generic library procedure Containers.Gen eric_Sort has the following declaration:  
generic 
   type Index_Type is (<>); 
   with function  Before (Left, Right : Index_Type) return Boolean; 
   with procedure  Swap (Left, Right : Index_Type); 
procedure  Ada.Containers.Generic_Sort 
      (First, Last : Index_Type'Base); pragma Pure(Ada.Containers.Generic_Sort); 1/3 
2/2 
3/2 
4/2 
5/3 
6/2 
7/2 
8/2 
9/3 
9.1/3 
9.2/3 
Ada Reference Manual — 2012 Edition 
569      13 December 2012 Array Sorting   A.18.26 Reorders the elements of an indexable structure, over the range First .. Last, such that the 
elements are sorted in the ordering determined by the generic formal function Before; Before 
should return True if Left is to be sorted befo re Right. The generic formal Before compares the 
elements having the given indices, and the generic formal Swap exchanges the values of the indicated elements. Any exception raised during ev aluation of Before or Swap is propagated. 
The actual function for the generic formal function Be fore of Generic_Sort is expected to return 
the same value each time it is called with index valu es that identify a particular pair of element 
values. It should define a strict weak orderi ng relationship (see A.18); it should not modify the 
elements. The actual function for the generic form al Swap should exchange the values of the 
indicated elements. If the actual for either Before or Swap behaves in some other manner, the behavior of Generic_Sort is unspecified. The num ber of times the Generic_Sort calls Before or 
Swap is unspecified. 
Implementation Advice 
The worst-case time complexity of a call on an instance of Containers.Generic_Array_Sort or 
Containers.Generic_Constrained_Array_Sort should be O(N**2) or better, and the average time 
complexity should be better than O(N**2), where N is the length of the Container parameter.  
Containers.Generic_Array_Sort and Containers .Generic_Constrained_Array_Sort should minimize 
copying of elements.  
The worst-case time complexity of  a call on an instance of Cont ainers.Generic_Sort should be O(N**2) or 
better, and the average time complexity should be better than O(N**2), where N is the difference between 
the Last and First parameters plus 1.  
Containers.Generic_Sort should minimize calls to the generic formal Swap.  
A.18.27 The Generic Package 
Containers.Synchronized_Queue_Interfaces 
The language-defined generic package Containers.Syn chronized_Queue_Interfaces provides interface type 
Queue, and a set of operations for that type. Interface Queue specifies a first-in, first-out queue.  
Static Semantics 
The generic library package Containers.Synchronize d_Queue_Interfaces has the following declaration:  
generic 
   type Element_Type is private ; 
package Ada.Containers.Synchronized_Queue_Interfaces is 
   pragma Pure(Synchronized_Queue_Interfaces); 
   type Queue is synchronized interface ; 
   procedure  Enqueue 
     (Container : in out Queue; 
      New_Item  : in     Element_Type) is abstract  
       with Synchronization => By_Entry; 
   procedure  Dequeue 
     (Container : in out Queue; 
      Element   :    out Element_Type) is abstract  
       with Synchronization => By_Entry; 
   function  Current_Use (Container : Queue) return Count_Type is abstract ; 
   function  Peak_Use (Container : Queue) return Count_Type is abstract ; 
end Ada.Containers.Synchronized_Queue_Interfaces; 9.3/3 
9.4/3 
10/2 
11/2 
12/3 
13/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
Ada Reference Manual — 2012 Edition 
A.18.27    The Generic Package Containers.Synchroni zed_Queue_Interfaces 13 December 2012      570 procedure  Enqueue 
  (Container : in out Queue; 
   New_Item  : in     Element_Type) is abstract ; 
A queue type that implements this interface is allowed to have a bounded capacity . If the queue 
object has a bounded capacity, and the number of ex isting elements equals  the capacity, then 
Enqueue blocks until storage becomes available;  otherwise, Enqueue doe s not block. In any 
case, it then copies New_Item onto the queue. 
procedure  Dequeue 
  (Container : in out Queue; 
   Element   :    out Element_Type) is abstract ; 
If the queue is empty, then Dequeue blocks until an item becomes available. In any case, it then 
assigns the element at the head of the queue to Element, and removes it from the queue. 
function  Current_Use (Container : Queue) return Count_Type is abstract ; 
Returns the number of elements currently in the queue. 
function  Peak_Use (Container : Queue) return Count_Type is abstract ; 
Returns the maximum number of elements that have been in the queue at any one time. 
NOTES 
51  Unlike other language-defined containers, there are no queues whose element types are indefinite. Elements of an indefinite type can be handled by defining the element of the queue to be a holder container (see A.18.18) of the indefinite type, or to be an explicit access type that designates the indefinite type. 
A.18.28 The Generic Package 
Containers.Unbounded_Synchronized_Queues 
Static Semantics 
The language-defined generic package Contai ners.Unbounded_Synchronized_Q ueues provides type 
Queue, which implements the interface type C ontainers.Synchronized_Queue_Interfaces.Queue. 
with System; 
with Ada.Containers.Synchronized_Queue_Interfaces; 
generic 
   with package  Queue_Interfaces is new 
Ada.Containers.Synchronized_Queue_Interfaces (<>);    Default_Ceiling : System.Any_Priority := System.Priority'Last; package Ada.Containers.Unbounded_Synchronized_Queues is 
   pragma Preelaborate(Unbounded_Synchronized_Queues); 
   package Implementation is 
      ... -- not specified by the language  
   end Implementation; 
   protected type  Queue 
        (Ceiling : System.Any_Priority := Default_Ceiling)            with Priority => Ceiling is 
        new Queue_Interfaces.Queue with 
      overriding  
      entry Enqueue (New_Item : in Queue_Interfaces.Element_Type); 
      overriding  
      entry Dequeue (Element : out Queue_Interfaces.Element_Type); 
      overriding  
      function  Current_Use return Count_Type; 
      overriding  
      function  Peak_Use return Count_Type; 9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
16/3 
17/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
Ada Reference Manual — 2012 Edition 
571      13 December 2012 The Generic Pack age Containers.Unbounded_Synchronized_Queues   A.18.28    private 
      ... -- not specified by the language  
   end Queue; 
private 
   ... -- not specified by the language  
end Ada.Containers.Unbounded_Synchronized_Queues; 
The type Queue is used to represent task-safe queues. 
The capacity for instances of type Queue is unbounded. 
A.18.29 The Generic Package 
Containers.Bounded_Synchronized_Queues 
Static Semantics 
The language-defined generic package Containers .Bounded_Synchronized_Queues provides type Queue, 
which implements the interface type Contai ners.Synchronized_Queue_Interfaces.Queue. 
with System; 
with Ada.Containers.Synchronized_Queue_Interfaces; 
generic 
   with package  Queue_Interfaces is new 
Ada.Containers.Synchronized_Queue_Interfaces (<>);    Default_Capacity : Count_Type;    Default_Ceiling  : System.Any_Priority := System.Priority'Last; package Ada.Containers.Bounded_Synchronized_Queues is 
   pragma Preelaborate(Bounded_Synchronized_Queues); 
   package Implementation is 
      ... -- not specified by the language  
   end Implementation; 
   protected type  Queue 
        (Capacity : Count_Type := Default_Capacity;          Ceiling  : System.Any_Priority := Default_Ceiling)            with Priority => Ceiling is 
        new Queue_Interfaces.Queue with 
      overriding  
      entry Enqueue (New_Item : in Queue_Interfaces.Element_Type); 
      overriding  
      entry Dequeue (Element : out Queue_Interfaces.Element_Type); 
      overriding  
      function  Current_Use return Count_Type; 
      overriding  
      function  Peak_Use return Count_Type; 
   private 
      ... -- not specified by the language  
   end Queue; 
private 
   ... -- not specified by the language  
end Ada.Containers.Bounded_Synchronized_Queues; 
The semantics are the same as fo r Unbounded_Synchronized_Queues, except: 
• The capacity for instances of type Queue is bounde d and specified by the discriminant Capacity.  
Implementation Advice 
Bounded queue objects should be implemented without  implicit pointers or dynamic allocation.  7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
13/3 
Ada Reference Manual — 2012 Edition 
A.18.30    The Generic Package Containers.Unbounde d_Priority_Queues 13 December 2012      572 A.18.30 The Generic Package Containers.Unbounded_Priority_Queues 
Static Semantics 
The language-defined generic package Containe rs.Unbounded_Priority_Queues provides type Queue, 
which implements the interface type Contai ners.Synchronized_Queue_Interfaces.Queue. 
with System; 
with Ada.Containers.Synchronized_Queue_Interfaces; 
generic 
   with package  Queue_Interfaces is new 
Ada.Containers.Synchronized_Queue_Interfaces (<>);    type Queue_Priority is private ; 
   with function  Get_Priority 
     (Element : Queue_Interfaces.Element_Type) return Queue_Priority is <>; 
   with function  Before 
     (Left, Right : Queue_Priority) return Boolean is <>; 
   Default_Ceiling : System.Any_Priority := System.Priority'Last; package Ada.Containers.Unbounded_Priority_Queues is 
   pragma Preelaborate(Unbounded_Priority_Queues); 
   package Implementation is 
      ... -- not specified by the language  
   end Implementation; 
   protected type  Queue 
        (Ceiling : System.Any_Priority := Default_Ceiling)            with Priority => Ceiling is 
        new Queue_Interfaces.Queue with 
      overriding  
      entry Enqueue (New_Item : in Queue_Interfaces.Element_Type); 
      overriding  
      entry Dequeue (Element : out Queue_Interfaces.Element_Type); 
      not overriding  
      procedure  Dequeue_Only_High_Priority 
        (At_Least : in     Queue_Priority; 
         Element  : in out Queue_Interfaces.Element_Type; 
         Success  :    out Boolean); 
      overriding  
      function  Current_Use return Count_Type; 
      overriding  
      function  Peak_Use return Count_Type; 
   private 
      ... -- not specified by the language  
   end Queue; 
private 
   ... -- not specified by the language  
end Ada.Containers.Unbounded_Priority_Queues; 
The type Queue is used to represent task-safe priority queues. 
The capacity for instances of type Queue is unbounded. Two elements E1 and E2 are equivalent if Before(Get_Priority( E1), Get_Priority( E2)) and 
Before(Get_Priority( E2), Get_Priority( E1)) both return False. 
The actual functions for Get_Priority and Before are e xpected to return the same value each time they are 
called with the same actuals, and should not modify their actuals. Before should define a strict weak 
ordering relationship (see A.18). If the actual functions behave in some other ma nner, the behavior of 
Unbounded_Priority_Queues is unspecified. 1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 11/3 
12/3 
13/3 14/3 
15/3 
Ada Reference Manual — 2012 Edition 
573      13 December 2012 The Generic Pack age Containers.Unbounded_Priority_Queues   A.18.30 Enqueue inserts an item according to the order sp ecified by the Before function on the result of 
Get_Priority on the elements; Before s hould return True if Left is to be  inserted before Right. If the queue 
already contains elements equivalent to New_Item, then it is inserted after the existing equivalent elements. 
For a call on Dequeue_Only_High_Priority, if the head of the nonempty queue is E, and the function 
Before(At_Least, Get_Priority( E)) returns False, then E is assigned to Element and then removed from the 
queue, and Success is set to True; otherwise, Su ccess is set to False and Element is unchanged. 
A.18.31 The Generic Package Containers.Bounded_Priority_Queues 
Static Semantics 
The language-defined generic package Containers.B ounded_Priority_Queues provides type Queue, which 
implements the interface type Containe rs.Synchronized_Queue_Interfaces.Queue. 
with System; 
with Ada.Containers.Synchronized_Queue_Interfaces; 
generic 
   with package  Queue_Interfaces is new 
Ada.Containers.Synchronized_Queue_Interfaces (<>);    type Queue_Priority is private ; 
   with function  Get_Priority 
     (Element : Queue_Interfaces.Element_Type) return Queue_Priority is <>; 
   with function  Before 
     (Left, Right : Queue_Priority) return Boolean is <>; 
   Default_Capacity : Count_Type;    Default_Ceiling  : System.Any_Priority := System.Priority'Last; package Ada.Containers.Bounded_Priority_Queues is 
   pragma Preelaborate(Bounded_Priority_Queues); 
   package Implementation is 
      ... -- not specified by the language  
   end Implementation; 
   protected type  Queue 
        (Capacity : Count_Type := Default_Capacity;          Ceiling  : System.Any_Priority := Default_Ceiling)            with Priority => Ceiling is 
      new Queue_Interfaces.Queue with 
      overriding  
      entry Enqueue (New_Item : in Queue_Interfaces.Element_Type); 
      overriding  
      entry Dequeue (Element : out Queue_Interfaces.Element_Type); 
      not overriding  
      procedure  Dequeue_Only_High_Priority 
        (At_Least : in     Queue_Priority; 
         Element  : in out Queue_Interfaces.Element_Type; 
         Success  :    out Boolean); 
      overriding  
      function  Current_Use return Count_Type; 
      overriding  
      function  Peak_Use return Count_Type; 
   private 
      ... -- not specified by the language  
   end Queue; 
private 
   ... -- not specified by the language  
end Ada.Containers.Bounded_Priority_Queues; 16/3 
17/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 11/3 
Ada Reference Manual — 2012 Edition 
A.18.31    The Generic Package Containers.Bounde d_Priority_Queues 13 December 2012      574 The semantics are the same as for Unbounded_Priority_Queues, except: 
• The capacity for instances of type Queue is bounde d and specified by the discriminant Capacity.  
Implementation Advice 
Bounded priority queue objects should be implemented without implicit pointers or dynamic allocation.  
A.18.32 Example of Container Use 
Examples 
The following example is an implementation of Dijkstra's  shortest path algorithm in a directed graph with 
positive distances. The graph is  represented by a map from nodes to sets of edges. 
with Ada.Containers.Vectors; 
with Ada.Containers.Doubly_Linked_Lists; 
use Ada.Containers; 
generic 
   type Node is range  <>; 
package Shortest_Paths is 
   type Distance is new Float range 0.0 .. Float'Last; 
   type Edge is record  
      To, From : Node;       Length   : Distance;    end record ; 
   package Node_Maps is new Vectors (Node, Node); 
   -- The algorithm builds a map to indicate the node used to reach a given  
   -- node in the shortest distance.  
   package Adjacency_Lists is new Doubly_Linked_Lists (Edge); 
   use Adjacency_Lists; 
   package Graphs is new Vectors (Node, Adjacency_Lists.List); 
   package Paths is new Doubly_Linked_Lists (Node); 
   function  Shortest_Path 
     (G : Graphs.Vector; Source : Node; Target : Node) return Paths.List 
      with Pre => G (Source) /= Adjacency_Lists.Empty_List; 
end Shortest_Paths; 
package body  Shortest_Paths is 
   function  Shortest_Path 
     (G : Graphs.Vector; Source : Node; Target : Node) return Paths.List 
   is 
      use Adjacency_Lists, Node_Maps, Paths, Graphs; 
      Reached  : array (Node) of Boolean := ( others => False); 
      -- The set of nodes whose shortest distance to the source is known.  
      Reached_From : array (Node) of Node; 
      So_Far   : array (Node) of Distance := ( others => Distance'Last); 
      The_Path : Paths.List := Paths.Empty_List;       Nearest_Distance : Distance;       Next     : Node;    begin 
      So_Far(Source)  := 0.0; 
      while not  Reached(Target) loop 
         Nearest_Distance := Distance'Last; 
         -- Find closest node not reached yet , by iterating over all nodes.  
         -- A more efficient algorithm uses a priority queue for this step.  12/3 
13/3 
14/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
Ada Reference Manual — 2012 Edition 
575      13 December 2012 Exam ple of Container Use   A.18.32          Next := Source; 
         for N in Node'First .. Node'Last loop 
            if not Reached(N) 
              and then  So_Far(N) < Nearest_Distance then 
                 Next := N;                  Nearest_Distance := So_Far(N);             end if; 
         end loop ; 
         if Nearest_Distance = Distance'Last then 
            -- No next node found, graph is not connected  
            return Paths.Empty_List; 
         else 
            Reached(Next) := True;          end if; 
         -- Update minimum distance to newly reachable nodes.  
         for E of G (Next) loop 
            if not Reached(E.To) then 
               Nearest_Distance := E.Length + So_Far(Next); 
               if Nearest_Distance < So_Far(E.To) then 
                  Reached_From(E.To) := Next;                   So_Far(E.To) := Nearest_Distance;                end if; 
            end if; 
         end loop ; 
      end loop ; 
      -- Rebuild path from target to source.  
      declare 
         N : Node := Target;       begin 
         while N /= Source loop 
            N := Reached_From(N);             Prepend (The_Path, N);          end loop ; 
      end; 
      return The_Path; 
   end; 
end Shortest_Paths; 
Note that the effect of the Constant_Indexing aspect (on type Vector) and the Implicit_Dereference aspect 
(on type Reference_Type) is that 
G (Next) 
is a convenient short hand for 
G.Constant_Reference (Next).Element. all 
Similarly, the effect of the loop: 
for E of G (Next) loop 
   if not Reached(E.To) then 
      ...    end if; 
end loop ; 13/3 
14/3 
15/3 16/3 
17/3 
18/3 
19/3 
20/3 
21/3 
22/3 
23/3 
24/3 
25/3 
26/3 
27/3 
Ada Reference Manual — 2012 Edition 
A.18.32    Example of Container Use 13 December 2012      576 is the same as: 
for C in G (Next).Iterate loop 
   declare 
      E : Edge renames G (Next)(C). all; 
   begin 
      if not Reached(E.To) then 
         ...       end if; 
   end; 
end loop ; 
which is the same as: 
declare 
   L : Adjacency_Lists.List renames G (Next); 
   C : Adjacency_Lists.Cursor := L.First; begin 
   while Has_Element (C) loop 
      declare 
         E : Edge renames L(C).all; 
      begin 
         if not Reached(E.To) then 
            ...          end if; 
      end; 
      C := L.Next (C);    end loop ; 
end; 
A.19 The Package Locales 
A locale  identifies a geopolitical place or region and its associated language, which can be used to 
determine other internationalization-related characteristics.  
Static Semantics 
The library package Locales has the following declaration:  
package Ada.Locales is 
   pragma Preelaborate(Locales); 
   pragma Remote_Types(Locales); 
   type Language_Code is array  (1 .. 3) of Character range 'a' .. 'z'; 
   type Country_Code is array  (1 .. 2) of Character range 'A' .. 'Z'; 
   Language_Unknown : constant  Language_Code := "und"; 
   Country_Unknown : constant  Country_Code := "ZZ"; 
   function  Language return Language_Code; 
   function  Country return Country_Code; 
end Ada.Locales; 
The active locale  is the locale associated with the partition of the current task. 
Language_Code is a lower-case string representation of an ISO 639-3 alpha-3 code that identifies a 
language. 
Country_Code is an upper-case string representation of an ISO 3166-1 alpha-2 code that identifies a 
country. 
Function Language returns the code of the langua ge associated with the active locale. If the 
Language_Code associated with the active locale ca nnot be determined from the environment, then 
Language returns Language_Unknown. 28/3 
29/3 
30/3 
31/3 
1/3 
2/3 
3/3 
4/3 
5/3 6/3 7/3 
8/3 
9/3 
10/3 11/3 
Ada Reference Manual — 2012 Edition 
577      13 December 2012 The Package Locales   A.19 Function Country returns the code of the country a ssociated with the active locale. If the Country_Code 
associated with the active locale cannot be determ ined from the environment, then Country returns 
Country_Unknown. 12/3 

Ada Reference Manual — 2012 Edition 
579      13 December 2012 Interface to Other Languages   B Annex B 
(normative)  
Interface to Other Languages 
This Annex describes features for writing mixe d-language programs. General interface support is 
presented first; then specific support for C, COBOL, and Fortran is defi ned, in terms of language interface 
packages for each of these languages.  
Implementation Requirements 
Support for interfacing to any foreign language is opti onal. However, an implem entation shall not provide 
any optional aspect, attribute, library unit, or pragma having the same name as an aspect, attribute, library 
unit, or pragma (respectively) specified in the subcla uses of this Annex unless the provided construct is 
either as specified in those subc lauses or is more limited in capab ility than that required by those 
subclauses. A program that attemp ts to use an unsupported capability of  this Annex shall either be 
identified by the implementation before run tim e or shall raise an exception at run time.  
B.1 Interfacing Aspects 
An interfacing  aspect is a representation as pect that is one of the asp ects Import, Export, Link_Name, 
External_Name, or Convention. 
Specifying the Import aspect  to have the value True  is used to import an entity defined in a foreign 
language into an Ada program, thus allowing a forei gn-language subprogram to be called from Ada, or a 
foreign-language variable to be accessed from Ada. In contrast, specifying the Export aspect to have the 
value True is used to export an Ada entity to a fo reign language, thus allowing an Ada subprogram to be 
called from a foreign language, or an Ada object to  be accessed from a foreign language. The Import and 
Export aspects are intended primarily for objects a nd subprograms, although impl ementations are allowed 
to support other entities. The Link_Name and External_N ame aspects are used to specify the link name 
and external name, respectively, to be used to identify imported or exported entities in the external 
environment.  
The Convention aspect is used to  indicate that an Ada entity should use the conventions of another 
language. It is intended primarily for types and “callback” subprogram s. For example, “ with  Convention 
=> Fortran” on the declaration of an array type Matrix  implies that Matrix should be represented according 
to the conventions of the supported Fortran im plementation, namely column-major order. 
A pragma  Linker_Options is used to specify the syst em linker parameters needed when a given 
compilation unit is included in a partition. 
Syntax 
The form of a pragma  Linker_Options is as follows:  
Paragraphs 5 through 7 were moved to Annex J, “Obsolescent Features”.   
  pragma  Linker_Options( string_ expression ); 
A pragma  Linker_Options is allowed only at the place of a declarative_item . 
This paragraph was deleted.  1 
2/3 
0.1/3 
1/3 
2/3 
3 
4/3 
8 
9 
9.1/3 
Ada Reference Manual — 2012 Edition 
B.1   Interfacing Aspects 13 December 2012      580 Name Resolution Rules 
The Import and Export aspects are of type Boolean. 
The Link_Name and Extern al_Name aspects are of type String.  
The expected type for the string_ expression  in pragma Linker_Options is String. 
Legality Rules 
The aspect Convention shall be specified by a convention_ identifier  which shall be the name of a 
convention . The convention names are implementation define d, except for certain language-defined ones, 
such as Ada and Intrinsic, as explained in 6.3. 1, “Conformance Rules”. A dditional convention names 
generally represent the calling conventions of fore ign languages, language impl ementations, or specific 
run-time models. The convention of a callable entity is its calling convention .  
If L is a convention_ identifier  for a language, then a type T is said to be compatible with convention L , 
(alternatively, is said to be an L-compatible type ) if any of the following conditions are met:  
• T is declared in a language interface package corresponding to L and is defined to be L-
compatible (see B.3, B.3. 1, B.3.2, B.4, B.5), 
• Convention L has been specified for T, and T is eligible for convention L ; that is:  
• T is an array type with either an unconstrai ned or statically-constrained first subtype, and 
its component type is L-compatible, 
• T is a record type that has no discriminant s and that only has components with statically-
constrained subtypes, and each component type is L-compatible, 
• T is an access-to-object type, its designated type is L-compatible, and its designated 
subtype is not an unconstrained array subtype, 
• T is an access-to-subprogram type, and its de signated profile's parameter and result types 
are all L-compatible.  
• T is derived from an L-compatible type, 
• The implementation permits T as an L-compatible type. 
If the Convention aspect is specified for a type, then the type shall either be compatible with or eligible for 
the specified convention.  
Notwithstanding any rule to the contrary, a declara tion with a True Import aspect shall not have a 
completion.  
 An entity with a True Import aspect  (or Export aspect) is said to be imported  (respectively, exported ). An 
entity shall not be both imported and exported. 
The declaration of an imported object shall not in clude an explicit initialization expression. Default 
initializations are not performed.  
The type of an imported or exported object shall be compatible with the specifi ed Convention aspect, if 
any.  
For an imported or exported subprogram, the result and parameter types shall each be compatible with the 
specified Convention aspect, if any. 
The aspect_definition  (if any) used to directly specify an Import, Export, Extern al_Name, or Link_Name 
aspect shall be a static expression. The string_ expression  of a pragma  Linker_Options shall be static. An 9.2/3 
10/3 
10.1/3 
11/3 
12 
13 
14/3 
15 
16 
17/3 
18 19 
20 
21/3 
22/3 23/3 
24 
25/3 26/3 27/3 
Ada Reference Manual — 2012 Edition 
581      13 December 2012 Interfacing Aspects   B.1 External_Name or Link_Name aspect shall be specified  only for an entity that is either imported or 
exported. 
Static Semantics 
Paragraphs 28 and 29 were deleted.   
The Convention aspect represents th e calling convention or representation convention of the entity. For an 
access-to-subprogram type, it represents the calling conve ntion of designated subprograms. In addition:  
• A True Import aspect indicates that the entity is defined externally (that is, outside the Ada 
program). This aspect is  never inherited; if not directly sp ecified, the Import aspect is False. 
• A True Export aspect indicates that the entity is us ed externally. This aspect  is never inherited; if 
not directly specified, the Export aspect is False. 
• For an entity with a True Import or Export aspect , an external name, link name, or both may also 
be specified.  
An external name  is a string value for the name used by a foreign language program either for an entity 
that an Ada program imports, or for referring to an entity that an Ada program exports. 
A link name  is a string value for the name of an exported or imported entity, based on the conventions of 
the foreign language's compiler in interfacing with the system's linker tool. 
The meaning of link names is implem entation defined. If neither a link na me nor the Address attribute of 
an imported or exported entity is specified, then a link name is chosen in an implementation-defined 
manner, based on the external name if one is specified.  
Pragma Linker_Options has the effect of passing its st ring argument as a parameter to the system linker (if 
one exists), if the immediately enclosing compilati on unit is included in the partition being linked. The 
interpretation of the string argument, and the way in which the string arguments from multiple 
Linker_Options pragmas are combined , is implementation defined.  
Dynamic Semantics 
Notwithstanding what this Internationa l Standard says elsewhere, the elaboration of a declaration with a 
True Import aspect does not create the entity. Such an elaboration has no other effect than to allow the 
defining name to denote the external entity.  
Erroneous Execution 
It is the programmer's responsibility to ensure that  the use of interfacing aspects does not violate Ada 
semantics; otherwise, progr am execution is erroneous.  
Implementation Advice 
If an implementation supports Export for a given langua ge, then it should also allow the main subprogram 
to be written in that language. It should support some  mechanism for invoking the elaboration of the Ada 
library units included in the system, and for invoking th e finalization of the environment task. On typical 
systems, the recommended mechanism is to provide two subprograms whose link names are "adainit" and 
"adafinal". Adainit should contain the elaboration c ode for library units. Adafinal should contain the 
finalization code. These subprograms should have no effect the second and s ubsequent time they are 
called.  
Automatic elaboration of preelaborated packages shoul d be provided when specifying the Export aspect as 
True is supported.  30/3 
31/3 
32/3 33/3 
34 
35 36 
37 
38/3 
38.1/3 
39/3 
40/3 
Ada Reference Manual — 2012 Edition 
B.1   Interfacing Aspects 13 December 2012      582 For each supported convention L other than Intrinsic, an implem entation should support specifying the 
Import and Export aspects for objects of L-compatible types and for subprograms, and the Convention 
aspect for L-eligible types and for subprograms, presumi ng the other language has corresponding features. 
Specifying the  Convention aspect need not be supported for scalar types.  
NOTES 
1  Implementations may place restricti ons on interfacing aspects; for example, requiring each  exported en tity to be 
declared at the library level.  
2  The Convention aspect in combination with the Import as pect indicates the conventions  for accessing external entities. 
It is possible that the actual entity is written in assembly language, but reflects the conventions of a particular language. For example, with Convention => Ada  can be used to interf ace to an assembly language  routine that obeys the 
Ada compiler's calling conventions. 
3  To obtain “call-back” to an Ada subprogram from a foreign language environment, the Convention aspect should be 
specified both for the access- to-subprogram type and the specific subpr ogram(s) to which 'A ccess is applied. 
Paragraphs 45 and 46 were deleted.   
4  See also 13.8, “Machine Code Insertions”.  5  If both External_Name and Link_Name are specified for a given entity, then the External_Name is ignored. 
This paragraph was deleted.  
Examples 
Example of interfacing pragmas:   
package Fortran_Library is 
  function  Sqrt (X : Float) return Float 
    with Import => True, Convention => Fortran; 
  type Matrix is array  (Natural range <>, Natural range <>) of Float 
    with Convention => Fortran; 
  function  Invert (M : Matrix) return Matrix 
    with Import => True, Convention => Fortran; 
end Fortran_Library; 
B.2 The Package Interfaces 
Package Interfaces is the parent of several library p ackages that declare types and other entities useful for 
interfacing to foreign languages. It al so contains some implementation-de fined types that are useful across 
more than one language (in particular for interfacing to assembly language).  
Static Semantics 
The library package Interfaces has the following skeletal declaration:  
 
package Interfaces is 
   pragma Pure(Interfaces); 
   type Integer_ n is range -2**( n-1) .. 2**( n-1) - 1;  -- 2's complement  
   type Unsigned_ n is mod 2** n; 41/3 
42/3 
43/3 
44/3 
47 
48/3 49/2 
50 
51/3 
1 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
583      13 December 2012 The Package Interfaces   B.2    function  Shift_Left  (Value : Unsigned_ n; Amount : Natural) 
      return Unsigned_ n; 
   function  Shift_Right (Value : Unsigned_ n; Amount : Natural) 
      return Unsigned_ n; 
   function  Shift_Right_Arithmetic (Value : Unsigned_ n; Amount : Natural) 
      return Unsigned_ n; 
   function  Rotate_Left  (Value : Unsigned_ n; Amount : Natural) 
      return Unsigned_ n; 
   function  Rotate_Right (Value : Unsigned_ n; Amount : Natural) 
      return Unsigned_ n; 
   ... end Interfaces; 
Implementation Requirements 
An implementation shall provide the following declara tions in the visible part of package Interfaces:  
• Signed and modular integer types of n bits, if supported by the target architecture, for each n that 
is at least the size of a storage element and that is a factor of the word size. The names of these 
types are of the form Integer_ n for the signed types, and Unsigned_ n for the modular types;  
• For each such modular type in Interfaces, shif ting and rotating subprograms as specified in the 
declaration of Interfaces above. These subprogram s are Intrinsic. They operate on a bit-by-bit 
basis, using the binary representation of th e value of the operands to yield a binary 
representation for the result. The Amount parameter gives the number of bits by which to shift or 
rotate. For shifting, zero bits are shifted in, ex cept in the case of Shif t_Right_Arithmetic, where 
one bits are shifted in if Value is at least half the modulus.  
• Floating point types corresponding to each fl oating point format fully supported by the 
hardware.  
Implementation Permissions 
An implementation may provide implementation-defined library units that are children of Interfaces, and 
may add declarations to the visible part of In terfaces in addition to the ones defined above.  
A child package of package Interfaces  with the name of a convention may be provided independently of 
whether the convention is supported by the Convention aspect and vice versa. Su ch a child package should 
contain any declarations that would be useful for in terfacing to the language (implementation) represented 
by the convention. Any declarations useful for interfacing to any language on the given hardware 
architecture should be provided directly in Interfaces.  
Implementation Advice 
This paragraph was deleted.  
An implementation supporting an interface to C, CO BOL, or Fortran should provide the corresponding 
package or packages described in the following subclauses.  
B.3 Interfacing with C and C++ 
The facilities relevant to interfacing with the C language and the corresponding subset of the C++ 
language are the package Interfaces.C  and its children, and support for specifying the Convention aspect 
with convention_ identifier s C and C_Pass_By_Copy. 
The package Interfaces.C contains the basic types, c onstants, and subprograms that allow an Ada program 
to pass scalars and strings to C and C++ functions. Wh en this subclause mentions  a C entity, the reference 
also applies to the corresponding entity in C++.  6 
7 
8 
9 
10 
11 
11.1/3 
12/2 
13/3 
1/3 
2/3 
Ada Reference Manual — 2012 Edition 
B.3   Interfacing with C and C++ 13 December 2012      584 Static Semantics 
The library package Interfaces.C has the following declaration:  
package Interfaces.C is 
   pragma Pure(C); 
   -- Declarations based on C's <limits.h>  
   CHAR_BIT  : constant  := implementation-defined ;  -- typically 8  
   SCHAR_MIN : constant  := implementation-defined ;  -- typically –128  
   SCHAR_MAX : constant  := implementation-defined ;  -- typically 127  
   UCHAR_MAX : constant  := implementation-defined ;  -- typically 255  
   -- Signed and Unsigned Integers  
   type int   is range implementation-defined ; 
   type short is range implementation-defined ; 
   type long  is range implementation-defined ; 
   type signed_char is range SCHAR_MIN .. SCHAR_MAX; 
   for signed_char'Size use CHAR_BIT; 
   type unsigned       is mod implementation-defined ; 
   type unsigned_short is mod implementation-defined ; 
   type unsigned_long  is mod implementation-defined ; 
   type unsigned_char is mod (UCHAR_MAX+1); 
   for unsigned_char'Size use CHAR_BIT; 
   subtype plain_char is implementation-defined ; 
   type ptrdiff_t is range implementation-defined ; 
   type size_t is mod implementation-defined ; 
   -- Floating Point  
   type C_float     is digits implementation-defined ; 
   type double      is digits implementation-defined ; 
   type long_double is digits implementation-defined ; 
   -- Characters and Strings  
   type char is <implementation-defined character type> ; 
   nul : constant  char := implementation-defined ; 
   function  To_C   (Item : in Character) return char; 
   function  To_Ada (Item : in char) return Character; 
   type char_array is array (size_t range <>) of aliased char 
      with Pack; 
   for char_array'Component_Size use CHAR_BIT; 
   function  Is_Nul_Terminated (Item : in char_array) return Boolean; 
   function  To_C   (Item       : in String; 
                    Append_Nul : in Boolean := True) 
      return char_array; 
   function  To_Ada (Item     : in char_array; 
                    Trim_Nul : in Boolean := True) 
      return String; 
   procedure  To_C (Item       : in  String; 
                   Target     : out char_array; 
                   Count      : out size_t; 
                   Append_Nul : in  Boolean := True); 
   procedure  To_Ada (Item     : in  char_array; 
                     Target   : out String; 
                     Count    : out Natural; 
                     Trim_Nul : in  Boolean := True); 
   -- Wide Character and Wide String  
   type wchar_t is <implementation-defined character type> ; 3 
4 
5 
6 
7 
8 
9 
10 
11 
12 13 14 15 16 17 18 19 
20/1 
21 22 
23/3 
24 
25 
26 27 
28 
29 
30/1 
Ada Reference Manual — 2012 Edition 
585      13 December 2012 Interfacing with C and C++   B.3    wide_nul : constant  wchar_t := implementation-defined ; 
   function  To_C   (Item : in Wide_Character) return wchar_t; 
   function  To_Ada (Item : in wchar_t       ) return Wide_Character; 
   type wchar_array is array (size_t range <>) of aliased wchar_t 
      with Pack; 
This paragraph was deleted.  
   function  Is_Nul_Terminated (Item : in wchar_array) return Boolean; 
   function  To_C   (Item       : in Wide_String; 
                    Append_Nul : in Boolean := True) 
      return wchar_array; 
   function  To_Ada (Item     : in wchar_array; 
                    Trim_Nul : in Boolean := True) 
      return Wide_String; 
   procedure  To_C (Item       : in  Wide_String; 
                   Target     : out wchar_array; 
                   Count      : out size_t; 
                   Append_Nul : in  Boolean := True); 
   procedure  To_Ada (Item     : in  wchar_array; 
                     Target   : out Wide_String; 
                     Count    : out Natural; 
                     Trim_Nul : in  Boolean := True); 
   -- ISO/IEC 10646:2003 compatible types defined by ISO/IEC TR 19769:2004.  
   type char16_t is <implementation-defined character type> ; 
   char16_nul : constant  char16_t := implementation-defined ; 
   function  To_C (Item : in Wide_Character) return char16_t; 
   function  To_Ada (Item : in char16_t) return Wide_Character; 
   type char16_array is array  (size_t range <>) of aliased  char16_t 
      with Pack; 
This paragraph was deleted.  
   function  Is_Nul_Terminated (Item : in char16_array) return Boolean; 
   function  To_C (Item       : in Wide_String; 
                  Append_Nul : in Boolean := True) 
      return char16_array; 
   function  To_Ada (Item     : in char16_array; 
                    Trim_Nul : in Boolean := True) 
      return Wide_String; 
   procedure  To_C (Item       : in  Wide_String; 
                   Target     : out char16_array; 
                   Count      : out size_t; 
                   Append_Nul : in  Boolean := True); 
   procedure  To_Ada (Item     : in  char16_array; 
                     Target   : out Wide_String; 
                     Count    : out Natural; 
                     Trim_Nul : in  Boolean := True); 
   type char32_t is <implementation-defined character type> ; 
   char32_nul : constant  char32_t := implementation-defined ; 
   function  To_C (Item : in Wide_Wide_Character) return char32_t; 
   function  To_Ada (Item : in char32_t) return Wide_Wide_Character; 
   type char32_array is array  (size_t range <>) of aliased  char32_t 
      with Pack; 
This paragraph was deleted.  
   function  Is_Nul_Terminated (Item : in char32_array) return Boolean; 
   function  To_C (Item       : in Wide_Wide_String; 
                  Append_Nul : in Boolean := True) 
      return char32_array; 31/1 
32 
33/3 34/3 
35 36 
37 38 
39 
39.1/2 
39.2/2 39.3/2 39.4/2 
39.5/3 39.6/3 
39.7/2 
39.8/2 
39.9/2 
39.10/2 
39.11/2 
39.12/2 39.13/2 
39.14/3 39.15/3 
39.16/2 
Ada Reference Manual — 2012 Edition 
B.3   Interfacing with C and C++ 13 December 2012      586    function  To_Ada (Item     : in char32_array; 
                    Trim_Nul : in Boolean := True) 
      return Wide_Wide_String; 
   procedure  To_C (Item       : in  Wide_Wide_String; 
                   Target     : out char32_array; 
                   Count      : out size_t; 
                   Append_Nul : in  Boolean := True); 
   procedure  To_Ada (Item     : in  char32_array; 
                     Target   : out Wide_Wide_String; 
                     Count    : out Natural; 
                     Trim_Nul : in  Boolean := True); 
   Terminator_Error : exception ; 
end Interfaces.C; 
Each of the types declared in  Interfaces.C is C-compatible. 
The types int, short, long, unsigned, ptrdiff_t, size_t, double, char, wchar_t, char16_t, and char32_t 
correspond respectively to the C types having the sa me names. The types si gned_char, unsigned_short, 
unsigned_long, unsigned_char, C_fl oat, and long_double correspond respec tively to the C types signed 
char, unsigned short, unsigned long, unsigned char, float, and long double. 
The type of the subtype plain_char is either  signed_char or unsigned_c har, depending on the C 
implementation.  
function  To_C   (Item : in Character) return char; 
function  To_Ada (Item : in char     ) return Character; 
The functions To_C and To_Ada map between th e Ada type Character and the C type char. 
function  Is_Nul_Terminated (Item : in char_array) return Boolean; 
The result of Is_Nul_Terminated is True if Item contains nul, and is False otherwise. 
function  To_C   (Item : in String;     Append_Nul : in Boolean := True) 
   return char_array; 
 function  To_Ada (Item : in char_array; Trim_Nul   : in Boolean := True) 
   return String; 
The result of To_C is a char_array value of le ngth Item'Length (if Append_Nul is False) or 
Item'Length+1 (if Append_Nul is True). The lo wer bound is 0. For each component Item(I), the 
corresponding component in the result is To_C app lied to Item(I). The value nul is appended if 
Append_Nul is True. If Append_Nul is False a nd Item'Length is 0, then To_C propagates 
Constraint_Error. 
The result of To_Ada is a String whose length is It em'Length (if Trim_Nul is  False) or the length 
of the slice of Item preceding the first nul (if Tr im_Nul is True). The lower bound of the result is 
1. If Trim_Nul is False, then for each com ponent Item(I) the corresponding component in the 
result is To_Ada applied to Item(I). If Trim_Nul is True, then for each component Item(I) before 
the first nul the corresponding component in th e result is To_Ada applied to Item(I). The 
function propagates Terminator_Error if Trim_N ul is True and Item does not contain nul. 39.17/2 
39.18/2 
39.19/2 
40 
41 
42 
43/2 
44 
45 
46 
47 
48 
49 
50/2 
51 
Ada Reference Manual — 2012 Edition 
587      13 December 2012 Interfacing with C and C++   B.3 procedure  To_C (Item       : in  String; 
                Target     : out char_array; 
                Count      : out size_t; 
                Append_Nul : in  Boolean := True); 
 procedure  To_Ada (Item     : in  char_array; 
                  Target   : out String; 
                  Count    : out Natural; 
                  Trim_Nul : in  Boolean := True); 
For procedure To_C, each element of Item is conve rted (via the To_C function) to a char, which 
is assigned to the corresponding element of Target . If Append_Nul is True, nul is then assigned 
to the next element of Target. In either case, Count is set to  the number of Target elements 
assigned. If Target is not long enough,  Constraint_Error is propagated. 
For procedure To_Ada, each element of Item (if Trim_Nul is False) or each element of Item 
preceding the first nul (if Trim_Nul is True) is  converted (via the To_Ada function) to a 
Character, which is assigned to the corresponding el ement of Target. Count is set to the number 
of Target elements assigned. If Target is not  long enough, Constraint_Error is propagated. If 
Trim_Nul is True and Item does not contai n nul, then Terminator_Error is propagated. 
function  Is_Nul_Terminated (Item : in wchar_array) return Boolean; 
The result of Is_Nul_Terminated is True if It em contains wide_nul, a nd is False otherwise. 
function  To_C   (Item : in Wide_Character) return wchar_t; 
function  To_Ada (Item : in wchar_t       ) return Wide_Character; 
To_C and To_Ada provide the mappings betw een the Ada and C wide character types. 
function  To_C   (Item       : in Wide_String; 
                 Append_Nul : in Boolean := True) 
   return wchar_array; 
 function  To_Ada (Item     : in wchar_array; 
                 Trim_Nul : in Boolean := True) 
   return Wide_String; 
 procedure  To_C (Item       : in  Wide_String; 
                Target     : out wchar_array; 
                Count      : out size_t; 
                Append_Nul : in  Boolean := True); 
 procedure  To_Ada (Item     : in  wchar_array; 
                  Target   : out Wide_String; 
                  Count    : out Natural; 
                  Trim_Nul : in  Boolean := True); 
The To_C and To_Ada subprograms that convert  between Wide_String and wchar_array have 
analogous effects to the To_C and To_Ada subprograms that convert between String and 
char_array, except that wide_nul is used instead of nul. 
function  Is_Nul_Terminated (Item : in char16_array) return Boolean; 
The result of Is_Nul_Terminated is True if It em contains char16_nul, a nd is False otherwise. 
function  To_C (Item : in Wide_Character) return char16_t; 
function  To_Ada (Item : in char16_t ) return Wide_Character; 
To_C and To_Ada provide mappings between  the Ada and C 16-bit character types. 52 
53 
54 
55 
56 
57 
58 
59 
60 
60.1/2 
60.2/2 
60.3/2 
60.4/2 
Ada Reference Manual — 2012 Edition 
B.3   Interfacing with C and C++ 13 December 2012      588 function  To_C (Item       : in Wide_String; 
               Append_Nul : in Boolean := True) 
   return char16_array; 
 function  To_Ada (Item     : in char16_array; 
                 Trim_Nul : in Boolean := True) 
   return Wide_String; 
 procedure  To_C (Item       : in  Wide_String; 
                Target     : out char16_array; 
                Count      : out size_t; 
                Append_Nul : in  Boolean := True); 
 procedure  To_Ada (Item     : in  char16_array; 
                  Target   : out Wide_String; 
                  Count    : out Natural; 
                  Trim_Nul : in  Boolean := True); 
The To_C and To_Ada subprograms that convert  between Wide_String and char16_array have 
analogous effects to the To_C and To_Ada subprograms that convert between String and 
char_array, except that char16_nul  is used instead of nul. 
function  Is_Nul_Terminated (Item : in char32_array) return Boolean; 
The result of Is_Nul_Terminated is True if It em contains char16_nul, a nd is False otherwise. 
function  To_C (Item : in Wide_Wide_Character) return char32_t; 
function  To_Ada (Item : in char32_t ) return Wide_Wide_Character; 
To_C and To_Ada provide mappings between  the Ada and C 32-bit character types. 
function  To_C (Item       : in Wide_Wide_String; 
               Append_Nul : in Boolean := True) 
   return char32_array; 
 function  To_Ada (Item     : in char32_array; 
                 Trim_Nul : in Boolean := True) 
   return Wide_Wide_String; 
 procedure  To_C (Item       : in  Wide_Wide_String; 
                Target     : out char32_array; 
                Count      : out size_t; 
                Append_Nul : in  Boolean := True); 
 procedure  To_Ada (Item     : in  char32_array; 
                  Target   : out Wide_Wide_String; 
                  Count    : out Natural; 
                  Trim_Nul : in  Boolean := True); 
The To_C and To_Ada subprograms that conve rt between Wide_Wide_String and char32_array 
have analogous effects to the To_C and To_Ada  subprograms that convert between String and 
char_array, except that char32_nul  is used instead of nul. 
The Convention aspect with convention_ identifier  C_Pass_By_Copy shall only be specified for a type. 
The eligibility rules in B.1 do not apply to conventi on C_Pass_By_Copy. Instead, a type T is eligible for 
convention C_Pass_By_Copy if T is an unchecked union type or if T is a record type that has no discriminants and that only has com ponents with statically constraine d subtypes, and each component is 
C-compatible. 
If a type is C_Pass_By_Copy-compatible, then it is also C-compatible. 60.5/2 
60.6/2 
60.7/2 
60.8/2 
60.9/2 
60.10/2 
60.11/2 
60.12/2 
60.13/3 
60.14/2 
60.15/3 
Ada Reference Manual — 2012 Edition 
589      13 December 2012 Interfacing with C and C++   B.3 Implementation Requirements 
An implementation shall support speci fying aspect Convention with a C convention_ identifier  for a C-
eligible type (see B.1). An implementation sh all support specifying aspect Convention with a 
C_Pass_By_Copy convention_ identifier  for a C_Pass_By_Copy-eligible type.  
Implementation Permissions 
An implementation may provide additional declarations in the C interface packages. 
An implementation need not support sp ecifying the Convention aspect with convention_ identifier  C in the 
following cases: 
• for a subprogram that has a parameter of an  unconstrained array subtype, unless the Import 
aspect has the value True for the subprogram; 
• for a function with an unconstrained array result subtype; 
• for an object whose nominal subtype is an unconstrained array subtype.  
Implementation Advice 
The constants nul, wide_nul, char16_nul, and char32_nul  should have a representation of zero.  
An implementation should support the following in terface correspondences between Ada and C.  
• An Ada procedure corresponds to a void-returning C function.  
• An Ada function corresponds to a non-void C function. 
• An Ada in scalar parameter is passed as a scalar argument to a C function. 
• An Ada in parameter of an access-to-object type with designated type T is passed as a t* 
argument to a C function, where t is the C type corresponding to the Ada type T. 
• An Ada access  T parameter, or an Ada out or in out  parameter of an elementary type T, is 
passed as a t* argument to a C function, where t is the C type corresponding to the Ada type T. 
In the case of an elementary out or in out  parameter, a pointer to a temporary copy is used to 
preserve by-copy semantics. 
• An Ada parameter of a (record) type T of convention C_Pass_By_Copy, of mode in, is passed as 
a t argument to a C function, where t is th e C struct corresponding to the Ada type T. 
• An Ada parameter of a record type T, of any mode, other than an in parameter of a type of 
convention C_Pass_By_Copy, is passed as a t* argum ent to a C function, where t is the C struct 
corresponding to the Ada type T. 
• An Ada parameter of an array type with com ponent type T, of any mode, is passed as a t* 
argument to a C function, where t is the C type corresponding to the Ada type T. 
• An Ada parameter of an access-to-subprogram type  is passed as a pointer to a C function whose 
prototype corresponds to the desi gnated subprogram's specification. 
• An Ada parameter of a private type is passe d as specified for the full view of the type. 
• The rules of correspondence given above for parameters of mode in also apply to the return 
object of a function. 
This paragraph was deleted.  
NOTES 
6  Values of type char_array are not implicitly terminated with nul. If a char_array is to be passed as a parameter to an imported C function requiring nul termination, it is the programmer's responsibility to obtain this effect. 61/3 
62 
62.1/3 
62.2/3 
62.3/3 
62.4/3 
62.5/3 
63 64 
65 66 67 
68 
68.1/2 
69/2 
70 
71 
71.1/3 
71.2/3 
71.3/3 
72 
Ada Reference Manual — 2012 Edition 
B.3   Interfacing with C and C++ 13 December 2012      590 7  To obtain the effect of C's sizeof(item_type), where Item_Type is the corresponding Ada type, evaluate the expression: 
size_t(Item_Type'Size/CHAR_BIT). 
This paragraph was deleted.  
8  A C function that takes a variable number of arguments can correspond to several Ada subprograms, taking various 
specific numbers and types of parameters.  
Examples 
Example of using the Interfaces.C package:   
--Calling the C Library Function strcpy  
with Interfaces.C; 
procedure  Test is 
   package C renames Interfaces.C; 
   use type C.char_array; 
   -- Call <string.h>strcpy:  
   -- C definition of strcpy:  char *str cpy(char *s1, const char *s2);  
   --    This function copies the string pointed to  by s2 (including the te rminating null character)  
   --     into the array pointed to by s1. If copying takes place between objects that overlap,  
   --     the behavior is undefined. The st rcpy function returns the value of s1.  
   -- Note: since the C function's retu rn value is of no interest, the Ada interface is a procedure  
   procedure  Strcpy (Target : out C.char_array; 
                     Source : in  C.char_array) 
      with Import => True, Convention => C, External_Name => "strcpy"; 
This paragraph was deleted.  
   Chars1 :  C.char_array(1..20); 
   Chars2 :  C.char_array(1..20); 
begin 
   Chars2(1..6) := "qwert" & C.nul; 
   Strcpy(Chars1, Chars2); -- Now Chars1(1..6) = "qwert" & C.Nul  
end Test; 73 
74/2 
75 
76 
77 
78/3 
79/3 
80 
81 82 
83 84 
Ada Reference Manual — 2012 Edition 
591      13 December 2012 The Package Interfaces.C.Strings   B.3.1 B.3.1 The Package Interfaces.C.Strings 
The package Interfaces.C.Str ings declares types and subprograms allowing an Ada program to allocate, 
reference, update, and free C-style strings. In partic ular, the private type chars_ptr corresponds to a 
common use of “char *” in C programs, and an object of  this type can be passed to a subprogram to which 
with Import => True, Convention => C  has been specified, and for which “char *” is the 
type of the argument of the C function.  
Static Semantics 
The library package Interfaces.C.Stri ngs has the following declaration:  
package Interfaces.C.Strings is 
   pragma Preelaborate(Strings); 
   type char_array_access is access all char_array; 
   type chars_ptr is private; 
   pragma Preelaborable_Initialization(chars_ptr); 
   type chars_ptr_array is array (size_t range <>) of aliased chars_ptr; 
   Null_Ptr : constant  chars_ptr; 
   function  To_Chars_Ptr (Item      : in char_array_access; 
                          Nul_Check : in Boolean := False) 
      return chars_ptr; 
   function  New_Char_Array (Chars   : in char_array) return chars_ptr; 
   function  New_String (Str : in String) return chars_ptr; 
   procedure  Free (Item : in out chars_ptr); 
   Dereference_Error : exception ; 
   function  Value (Item : in chars_ptr) return char_array; 
   function  Value (Item : in chars_ptr; Length : in size_t) 
      return char_array; 
   function  Value (Item : in chars_ptr) return String; 
   function  Value (Item : in chars_ptr; Length : in size_t) 
      return String; 
   function  Strlen (Item : in chars_ptr) return size_t; 
   procedure  Update (Item   : in chars_ptr; 
                     Offset : in size_t; 
                     Chars  : in char_array; 
                     Check  : in Boolean := True); 
   procedure  Update (Item   : in chars_ptr; 
                     Offset : in size_t; 
                     Str    : in String; 
                     Check  : in Boolean := True); 
   Update_Error : exception ; 
private 
   ... -- not specified by the language  
end Interfaces.C.Strings; 
The type chars_ptr is C-compatible and corresponds to th e use of C's “char *” for a pointer to the first char 
in a char array terminated by nul. When an object of ty pe chars_ptr is declared, its  value is by default set 
to Null_Ptr, unless the object is imported (see B.1).  1/3 
2 
3 
4 
5/2 
6/2 
7 8 
9 
10 11 12 13 14 
15 
16 
17 
18 
19 
20 
21 
22 
Ada Reference Manual — 2012 Edition 
B.3.1    The Package Interfaces.C.Strings 13 December 2012      592 function  To_Chars_Ptr (Item      : in char_array_access; 
                       Nul_Check : in Boolean := False) 
   return chars_ptr; 
If Item is null, then To_Chars_Ptr returns Null_Ptr. If Item is not null, Nul_Check is True, and 
Item. all does not contain nul, then the function propagates Terminator_Error; otherwise, 
To_Chars_Ptr performs a pointer conve rsion with no allocation of memory. 
function  New_Char_Array (Chars   : in char_array) return chars_ptr; 
This function returns a pointer to an allocated object initialized to Chars(Chars'First .. Index) & 
nul, where  
• Index = Chars'Last if Chars does not contain nul, or 
• Index is the smallest size_t value I such that Chars(I+1) = nul.  
Storage_Error is propagated if the allocation fails. 
function  New_String (Str : in String) return chars_ptr; 
This function is equivalent to New_Char_Array(To_C(Str)). 
procedure  Free (Item : in out chars_ptr); 
If Item is Null_Ptr, then Free has no effect. Otherwise, Free releases the storage occupied by 
Value(Item), and resets Item to Null_Ptr. 
function  Value (Item : in chars_ptr) return char_array; 
If Item = Null_Ptr, then Value propagates Dere ference_Error. Otherwise, Value returns the 
prefix of the array of chars pointed to by It em, up to and including the first nul. The lower bound 
of the result is 0. If Item does not point to a nul-terminated string, then execution of Value is 
erroneous. 
function  Value (Item : in chars_ptr; Length : in size_t) 
   return char_array; 
If Item = Null_Ptr, then Value propagates Dere ference_Error. Otherwise, Value returns the 
shorter of two arrays, either the first Length char s pointed to by Item, or Value(Item). The lower 
bound of the result is 0. If Length is 0, th en Value propagates Constraint_Error.  
function  Value (Item : in chars_ptr) return String; 
Equivalent to To_Ada(Val ue(Item), Trim_Nul=>True). 
function  Value (Item : in chars_ptr; Length : in size_t) 
   return String; 
Equivalent to To_Ada(Value(Item , Length) & nul, Trim_Nul=>True). 
function  Strlen (Item : in chars_ptr) return size_t; 
Returns Val'Length–1 where Val = Value(Item); propagates De reference_Error if Item = 
Null_Ptr.  
procedure  Update (Item   : in chars_ptr; 
                  Offset : in size_t; 
                  Chars  : in char_array; 
                  Check  : Boolean := True); 
If Item = Null_Ptr, then Update propagates De reference_Error. Otherwise, this procedure 
updates the value pointed to by Item, starting at position Offset, using Chars as the data to be 23 
24/3 
25 
26 
27 
28 
28.1 
29 
30 
31 
32 
33 
34/3 
35 
36/3 
37 
38 
39 
40/1 
41 
42 
43 
44/1 
Ada Reference Manual — 2012 Edition 
593      13 December 2012 The Package Interfaces.C.Strings   B.3.1 copied into the array. Overwriting the nul termin ator, and skipping with the Offset past the nul 
terminator, are both prevented if Check is True, as follows:  
• Let N = Strlen(Item). If Check is True, then:  
• If Offset+Chars'Length>N,  propagate Update_Error. 
• Otherwise, overwrite the data in the arra y pointed to by Item, starting at the char 
at position Offset, with the data in Chars.  
• If Check is False, then processing is as above, but with no check that 
Offset+Chars'Length>N.  
procedure  Update (Item   : in chars_ptr; 
                  Offset : in size_t; 
                  Str    : in String; 
                  Check  : in Boolean := True); 
Equivalent to Update(Item, Offset, T o_C(Str, Append_Nul => False), Check).  
Erroneous Execution 
Execution of any of the following is erroneous if the It em parameter is not null_pt r and Item does not point 
to a nul-terminated array of chars.  
• a Value function not taking a Length parameter, 
• the Free procedure, 
• the Strlen function.  
Execution of Free(X) is also erroneous if the ch ars_ptr X was not returned by New_Char_Array or 
New_String. 
Reading or updating a freed char_array is erroneous. Execution of Update is erroneous if Check is Fals e and a call with Check equal to True would have 
propagated Update_Error.  
NOTES 
9  New_Char_Array and New_String might be implemented either through the allocation function from the C environment (“malloc”) or through Ada dynamic memory allocation (“new”). The key points are  
• the returned value (a chars_ptr) is represented as a C “char *” so that it may be passed to C functions; 
• the allocated object should be freed by the programmer via a call of Free, not by a called C function.  45 
46 47 
48 
49 
50/2 
51 
52 
53 54 55 
56 
57 
58 
59 
60 
Ada Reference Manual — 2012 Edition 
B.3.2    The Generic Package Interfaces.C .Pointers 13 December 2012      594 B.3.2 The Generic Package Interfaces.C.Pointers 
The generic package Interfaces.C.Pointers allows the Ada programmer to perform C-style operations on 
pointers. It includes an access type Pointer, Value f unctions that dereference a Pointer and deliver the 
designated array, several pointer ar ithmetic operations, and “copy” procedures that copy the contents of a 
source pointer into the array designated by a destinati on pointer. As in C, it treats an object Ptr of type 
Pointer as a pointer to the first element of an array, so that for example, adding 1 to Ptr yields a pointer to the second element of the array. 
The generic allows two styles of usage: one in which the array is terminated by a special terminator 
element; and another in which the programme r needs to keep track of the length.  
Static Semantics 
The generic library package Interfaces.C.P ointers has the following declaration:  
generic 
   type Index is (<>); 
   type Element is private; 
   type Element_Array is array (Index range <>) of aliased Element; 
   Default_Terminator : Element; package Interfaces.C.Pointers is 
   pragma Preelaborate(Pointers); 
   type Pointer is access all Element; 
   function  Value(Ref        : in Pointer; 
                  Terminator : in Element := Default_Terminator) 
      return Element_Array; 
   function  Value(Ref    : in Pointer; 
                  Length : in ptrdiff_t) 
      return Element_Array; 
   Pointer_Error : exception ; 
   -- C-style Pointer arithmetic  
   function  "+" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer 
      with Convention => Intrinsic; 
   function  "+" (Left : in ptrdiff_t; Right : in Pointer)   return Pointer 
      with Convention => Intrinsic; 
   function  "-" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer 
      with Convention => Intrinsic; 
   function  "-" (Left : in Pointer;   Right : in Pointer) return ptrdiff_t 
      with Convention => Intrinsic; 
   procedure  Increment (Ref : in out Pointer) 
      with Convention => Intrinsic; 
   procedure  Decrement (Ref : in out Pointer) 
      with Convention => Intrinsic; 
This paragraph was deleted.  
   function  Virtual_Length (Ref        : in Pointer; 
                            Terminator : in Element := Default_Terminator) 
      return ptrdiff_t; 
   procedure  Copy_Terminated_Array 
      (Source     : in Pointer; 
       Target     : in Pointer; 
       Limit      : in ptrdiff_t := ptrdiff_t'Last; 
       Terminator : in Element :=  Default_Terminator); 
   procedure  Copy_Array (Source  : in Pointer; 
                         Target  : in Pointer; 
                         Length  : in ptrdiff_t); 
end Interfaces.C.Pointers; 1 
2 
3 
4 
5 
6 
7 8 
9 
10/3 
11/3 
12/3 
13 
14 
15 
16 
Ada Reference Manual — 2012 Edition 
595      13 December 2012 The Generic Package Interfaces.C.Pointers   B.3.2 The type Pointer is C-compatible and corresponds to one  use of C's “Element *”. An object of type Pointer 
is interpreted as a pointer to the initial Element in an Element_Array. Tw o styles are supported:  
• Explicit termination of an array value with De fault_Terminator (a special terminator value); 
• Programmer-managed length, with Default_Termin ator treated simply as a data element.  
function  Value(Ref        : in Pointer; 
               Terminator : in Element := Default_Terminator) 
   return Element_Array; 
This function returns an Element_ Array whose value is the array pointed to by Ref, up to and 
including the first Terminator; the lowe r bound of the array is Index'First. 
Interfaces.C.Strings.Dereference_Error is propagated if Ref is null. 
function  Value(Ref    : in Pointer; 
               Length : in ptrdiff_t) 
   return Element_Array; 
This function returns an Element_Array comprising the first Length elements pointed to by Ref. 
The exception Interfaces.C.Strings.Derefer ence_Error is propagated if Ref is null.  
The "+" and "–" functions perform arithmetic on Pointer values, based on the Size of the array elements. In 
each of these functions, Pointer_Error is propagated if a Pointer parameter is null.  
procedure  Increment (Ref : in out Pointer); 
Equivalent to Ref := Ref+1. 
procedure  Decrement (Ref : in out Pointer); 
Equivalent to Ref := Ref–1. 
function  Virtual_Length (Ref        : in Pointer; 
                         Terminator : in Element := Default_Terminator) 
   return ptrdiff_t; 
Returns the number of Elements, up to the one just  before the first Terminator, in Value(Ref, 
Terminator). 
procedure  Copy_Terminated_Array 
   (Source     : in Pointer; 
    Target     : in Pointer; 
    Limit      : in ptrdiff_t := ptrdiff_t'Last; 
    Terminator : in Element := Default_Terminator); 
This procedure copies Value(Source, Terminator) into the array pointed to by Target; it stops 
either after Terminator has been copied, or the number of elements copied is Limit, whichever occurs first. Dereference_Error is propa gated if either Source or Target is null.  
procedure  Copy_Array (Source  : in Pointer; 
                      Target  : in Pointer; 
                      Length  : in ptrdiff_t); 
This procedure copies the first Length elements from the array pointed to by Source, into the 
array pointed to by Target. Dereference_Error is propagated if either Source or Target is null.  
Erroneous Execution 
It is erroneous to dereference a Pointer th at does not designate an aliased Element.  
Execution of Value(Ref, Terminator) is erroneous if  Ref does not designate an aliased Element in an 
Element_Array terminated by Terminator. 17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
Ada Reference Manual — 2012 Edition 
B.3.2    The Generic Package Interfaces.C .Pointers 13 December 2012      596 Execution of Value(Ref, Length) is erroneous if Ref does not designate an aliased Element in an 
Element_Array containing at least Length Elements between the designated Element and the end of the 
array, inclusive. 
Execution of Virtual_Length(Ref, Terminator) is errone ous if Ref does not designate an aliased Element in 
an Element_Array terminated by Terminator. 
Execution of Copy_Terminated_Array(Source, Target, Lim it, Terminator) is erroneous in either of the 
following situations:  
• Execution of both Value(Source, Terminator) and Value(Source, Limit) are erroneous, or 
• Copying writes past the end of the array c ontaining the Element designated by Target.  
Execution of Copy_Array(Source, Target, Length) is erroneous if either Value(Source, Length) is 
erroneous, or copying writes past the end of the a rray containing the Element designated by Target.  
NOTES 
10  To compose a Pointer from an Element_Array, use 'Access on the first element. For example (assuming appropriate instantiations):  
Some_Array   : Element_Array(0..5) ; 
Some_Pointer : Pointer := Some_Array(0)'Access; 
Examples 
Example of Interfaces.C.Pointers:   
with Interfaces.C.Pointers; 
with Interfaces.C.Strings; 
procedure  Test_Pointers is 
   package C renames Interfaces.C; 
   package Char_Ptrs is 
      new C.Pointers (Index              => C.size_t, 
                      Element            => C.char,                       Element_Array      => C.char_array,                       Default_Terminator => C.nul); 
   use type Char_Ptrs.Pointer; 
   subtype Char_Star is Char_Ptrs.Pointer; 
   procedure  Strcpy (Target_Ptr, Source_Ptr : Char_Star) is 
      Target_Temp_Ptr : Char_Star := Target_Ptr;       Source_Temp_Ptr : Char_Star := Source_Ptr;       Element : C.char;    begin 
      if Target_Temp_Ptr = null or Source_Temp_Ptr = null then 
         raise C.Strings.Dereference_Error; 
      end if; 
      loop 
         Element             := Source_Temp_Ptr. all; 
         Target_Temp_Ptr. all := Element; 
         exit when C."="(Element, C.nul); 
         Char_Ptrs.Increment(Target_Temp_Ptr);          Char_Ptrs.Increment(Source_Temp_Ptr);       end loop; 
   end Strcpy; 
begin 
   ... end Test_Pointers; 37 
38 
39 
40 
41 42 
43 
44 
45 
46 
47 
48 
49/1 
Ada Reference Manual — 2012 Edition 
597      13 December 2012 Unchecked Union Types   B.3.3 B.3.3 Unchecked Union Types 
Specifying aspect Unchecked_Union to have the valu e True defines an interface correspondence between 
a given discriminated type and some C union. The aspect requires that the associated type shall be given a 
representation that allocates no space for its discriminant(s).  
Paragraphs 2 through 3 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
For a discriminated record type having a variant_part , the following language-defined representation 
aspect may be specified: 
Unchecked_Union 
 The type of aspect Unchecked_Union is Boolean. If directly specified, the 
aspect_definition  shall be a static expression. If not specified (including by inheritance), 
the aspect is False. 
Legality Rules 
Paragraphs 4 and 5 were deleted.   
A type for which aspect Unchecked_Union is True is called an unchecked union type . A subtype of an 
unchecked union type is defined to be an unchecked union subtype . An object of an unchecked union type 
is defined to be an unchecked union object . 
All component subtypes of an uncheck ed union type shall be C-compatible. 
If a component subtype of an unchecked union type is subject to a per-object constraint, then the 
component subtype shall be an unchecked union subtype. 
Any name that denotes a discriminant of an object of an unchecked union type shall occur within the 
declarative region of the type, and shall not occur within a record_representation_clause . 
The type of a component declared in a variant_part  of an unchecked union type shall not need finalization. 
In addition to the places where Legality Rules normally  apply (see 12.3), this rule also applies in the 
private part of an instance of a generic unit. For an  unchecked union type declared within the body of a 
generic unit, or within the body of any of its descenda nt library units, no part of the type of a component 
declared in a variant_part  of the unchecked union type shall be of a formal private type or formal private 
extension declared within the formal part of the generic unit. 
The completion of an incomplete or private type declaration having a known_discriminant_part  shall not 
be an unchecked union type. 
An unchecked union subtype shall only be passed as  a generic actual parameter if the corresponding 
formal type has no known discriminant s or is an unchecked union type. 
Static Semantics 
An unchecked union type is eligible for convention C. 
All objects of an unchecked union type have the same size. Discriminants of objects of an unchecked union type are of size zero. 1/3 
3.1/3 
3.2/3 
6/3 
7/2 
8/2 
9/3 
10/3 
11/2 
12/2 
13/2 
14/2 15/2 
Ada Reference Manual — 2012 Edition 
B.3.3    Unchecked Union Types 13 December 2012      598 Any check which would require reading a discrimina nt of an unchecked union object is suppressed (see 
11.5). These checks include: 
• The check performed when addressing a variant component (i.e., a component that was declared 
in a variant part) of an unchecked union object that the object has this component (see 4.1.3). 
• Any checks associated with a type or subtype conversion of a value of an unchecked union type 
(see 4.6). This includes, for exam ple, the check associated with  the implicit subtype conversion 
of an assignment statement. 
• The subtype membership check associated with the evaluation of a qualified expression (see 4.7) 
or an uninitialized allocator (see 4.8).  
Dynamic Semantics 
A view of an unchecked union object (includi ng a type conversion or function call) has inferable 
discriminants  if it has a constrained nominal subtype, unle ss the object is a component of an enclosing 
unchecked union object that is subject to a per-object constraint and the enclosing object lacks inferable 
discriminants. 
An expression of an unchecked union type has inferable discriminants if it is either a name of an object 
with inferable discriminants or a qualified expression whose subtype_mark  denotes a constrained subtype. 
Program_Error is raised in the following cases: 
• Evaluation of the predefined equality operator for an unchecked union type if either of the 
operands lacks infera ble discriminants. 
• Evaluation of the predefined equality operato r for a type which has a subcomponent of an 
unchecked union type whose nomin al subtype is unconstrained. 
• Evaluation of a membership test if the subtype_mark  denotes a constrained unchecked union 
subtype and the expression lack s inferable discriminants. 
• Conversion from a derived unchecked union type  to an unconstrained non-unchecked-union type 
if the operand of the conversion lacks inferable discriminants. 
• Execution of the default implementation of the Write or Read attribute of an unchecked union 
type. 
• Execution of the default implementation of the Ou tput or Input attribute of an unchecked union 
type if the type lacks default discriminant values.  
Paragraph 29 was deleted.   
NOTES 
11  The use of an unchecked union to obtain the effect of an unchecked conversion results in erroneous execution (see 11.5). Execution of the following example is erroneous even if Float'Size = Integer'Size: 
type T (Flag : Boolean := False) is 
   record 
       case Flag is 
           when False => 
               F1 : Float := 0.0;            when True => 
               F2 : Integer := 0;        end case ; 
    end record  
    with Unchecked_Union; 
X : T; 
Y : Integer := X.F2; -- erroneous 16/2 
17/2 
18/2 
19/2 
20/2 
21/2 
22/2 
23/2 
24/2 25/2 26/2 27/2 28/2 
30/2 
31/3 
32/2 
Ada Reference Manual — 2012 Edition 
599      13 December 2012 Interfacing with COBOL   B.4 B.4 Interfacing with COBOL 
The facilities relevant to interfacing with the CO BOL language are the package Interfaces.COBOL and 
support for specifying the Convention aspect with convention_ identifier  COBOL. 
The COBOL interface package supplie s several sets of facilities:  
• A set of types corresponding to the na tive COBOL types of the supported COBOL 
implementation (so-called “inter nal COBOL representations”), allowing Ada data to be passed 
as parameters to COBOL programs 
• A set of types and constants re flecting external data representa tions such as might be found in 
files or databases, allowing CO BOL-generated data to be read by an Ada program, and Ada-
generated data to be read by COBOL programs 
• A generic package for converting between an Ada decimal type value and either an internal or 
external COBOL representation  
Static Semantics 
The library package Interfaces.COBOL has the following declaration:  
package Interfaces.COBOL is 
   pragma Preelaborate(COBOL); 
-- Types and operations for in ternal data representations  
   type Floating      is digits implementation-defined ; 
   type Long_Floating is digits implementation-defined ; 
   type Binary      is range implementation-defined ; 
   type Long_Binary is range implementation-defined ; 
   Max_Digits_Binary      : constant  := implementation-defined ; 
   Max_Digits_Long_Binary : constant  := implementation-defined ; 
   type Decimal_Element  is mod implementation-defined ; 
   type Packed_Decimal is array (Positive range <>) of Decimal_Element 
      with Pack; 
   type COBOL_Character is implementation-defined character type ; 
   Ada_To_COBOL : array (Character) of COBOL_Character := implementation-defined ; 
   COBOL_To_Ada : array (COBOL_Character) of Character := implementation-defined ; 
   type Alphanumeric is array (Positive range <>) of COBOL_Character 
      with Pack; 
   function  To_COBOL (Item : in String) return Alphanumeric; 
   function  To_Ada   (Item : in Alphanumeric) return String; 
   procedure  To_COBOL (Item       : in String; 
                       Target     : out Alphanumeric; 
                       Last       : out Natural); 
   procedure  To_Ada (Item     : in Alphanumeric; 
                     Target   : out String; 
                     Last     : out Natural); 
   type Numeric is array (Positive range <>) of COBOL_Character 
      with Pack; 
-- Formats for COBOL data representations  
   type Display_Format is private; 
   Unsigned             : constant  Display_Format; 
   Leading_Separate     : constant  Display_Format; 
   Trailing_Separate    : constant  Display_Format; 
   Leading_Nonseparate  : constant  Display_Format; 
   Trailing_Nonseparate : constant  Display_Format; 1/3 
2 
3 
4 
5 
6 
7 
8 
9 
10 11 
12/3 
13 
14 15 
16/3 
17 18 
19 
20/3 
21 
22 23 
Ada Reference Manual — 2012 Edition 
B.4   Interfacing with COBOL 13 December 2012      600    type Binary_Format is private; 
   High_Order_First  : constant  Binary_Format; 
   Low_Order_First   : constant  Binary_Format; 
   Native_Binary     : constant  Binary_Format; 
   type Packed_Format is private; 
   Packed_Unsigned   : constant  Packed_Format; 
   Packed_Signed     : constant  Packed_Format; 
-- Types for external representation of COBOL binary data  
   type Byte is mod 2**COBOL_Character'Size; 
   type Byte_Array is array (Positive range <>) of Byte 
      with Pack; 
   Conversion_Error : exception ; 
   generic 
      type Num is delta <> digits <>; 
   package Decimal_Conversions is 
      -- Display Formats: data values are represented as Numeric  
      function  Valid (Item   : in Numeric; 
                      Format : in Display_Format) return Boolean; 
      function  Length (Format : in Display_Format) return Natural; 
      function  To_Decimal (Item   : in Numeric; 
                           Format : in Display_Format) return Num; 
      function  To_Display (Item   : in Num; 
                           Format : in Display_Format) return Numeric; 
      -- Packed Formats: data values ar e represented as Packed_Decimal  
      function  Valid (Item   : in Packed_Decimal; 
                      Format : in Packed_Format) return Boolean; 
      function  Length (Format : in Packed_Format) return Natural; 
      function  To_Decimal (Item   : in Packed_Decimal; 
                           Format : in Packed_Format) return Num; 
      function  To_Packed (Item   : in Num; 
                          Format : in Packed_Format) return Packed_Decimal; 
      -- Binary Formats: external data values are represented as Byte_Array  
      function  Valid (Item   : in Byte_Array; 
                      Format : in Binary_Format) return Boolean; 
      function  Length (Format : in Binary_Format) return Natural; 
      function  To_Decimal (Item   : in Byte_Array; 
                           Format : in Binary_Format) return Num; 
      function  To_Binary (Item   : in Num; 
                        Format : in Binary_Format) return Byte_Array; 
      -- Internal Binary formats: data values  are of type Binary or Long_Binary  
      function  To_Decimal (Item : in Binary)      return Num; 
      function  To_Decimal (Item : in Long_Binary) return Num; 
      function  To_Binary      (Item : in Num)  return Binary; 
      function  To_Long_Binary (Item : in Num)  return Long_Binary; 
   end Decimal_Conversions; 
private 
   ... -- not specified by the language  
end Interfaces.COBOL; 
Each of the types in Interfaces .COBOL is COBOL-compatible. 
The types Floating and Long_Floating correspond to th e native types in COBOL for data items with 
computational usage implem ented by floating point. The types Binary and Long_Binary correspond to the 24 
25 
26 
27 
28 
29/3 
30 
31 
32 
33 
34 
35 
36 37 
38 
39 
40 
41 42 
43 
44 
45 
46 
47 
48 49 
50 
51 
52 
Ada Reference Manual — 2012 Edition 
601      13 December 2012 Interfacing with COBOL   B.4 native types in COBOL for data items with binary us age, or with computati onal usage implemented by 
binary. 
Max_Digits_Binary is the largest numbe r of decimal digits in a numeric  value that is represented as 
Binary. Max_Digits_Long_Binary is the largest number of decimal digits  in a numeric value that is 
represented as Long_Binary. 
The type Packed_Decimal corresponds to COBOL's packed-decimal usage. 
The type COBOL_Character defines the run-time ch aracter set used in the COBOL implementation. 
Ada_To_COBOL and COBOL_To_Ada are the ma ppings between the Ada and COBOL run-time 
character sets.  
Type Alphanumeric corresponds to CO BOL's alphanumeric data category. 
Each of the functions To_COBOL and To_Ada  converts its paramete r based on the mappings 
Ada_To_COBOL and COBOL_To_Ada, respectively. The length of the result for each is the length of the 
parameter, and the lower bound of the result is 1. Each  component of the result is obtained by applying the 
relevant mapping to the correspondi ng component of the parameter. 
Each of the procedures To_COBOL and To_Ada copies  converted elements from It em to Target, using the 
appropriate mapping (Ada_To_COBOL or  COBOL_To_Ada, respectively). The index in Target of the last 
element assigned is returned in Last (0 if Item is a null array). If Item'Length exceeds Target'Length, Constraint_Error is propagated. 
Type Numeric corresponds to COBOL's numer ic data category with display usage. 
The types Display_Format, Binary_Format, and Pack ed_Format are used in conversions between Ada 
decimal type values and COBOL internal or external  data representations. The value of the constant 
Native_Binary is either High_Order_First or Lo w_Order_First, depending on the implementation.  
function  Valid (Item   : in Numeric; 
                Format : in Display_Format) return Boolean; 
The function Valid checks that the Item paramete r has a value consistent with the value of 
Format. If the value of Format is other than Un signed, Leading_Separate, and Trailing_Separate, 
the effect is implementation defined. If Format  does have one of these values, the following 
rules apply:  
• Format=Unsigned: if Item comprises one or more decimal digit characters, then Valid 
returns True, else it returns False. 
• Format=Leading_Separate: if Item comprise s a single occurrence of the plus or minus 
sign character, and then one or more decimal digit characters, then Valid returns True, 
else it returns False. 
• Format=Trailing_Separate: if Item comprise s one or more decimal digit characters and 
finally a plus or minus sign character, then Valid returns True, else it returns False.  
function  Length (Format : in Display_Format) return Natural; 
The Length function returns the minimal length of  a Numeric value sufficient to hold any value 
of type Num when represented as Format. 53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63/3 
64/1 
65/1 
66 
67 
Ada Reference Manual — 2012 Edition 
B.4   Interfacing with COBOL 13 December 2012      602 function  To_Decimal (Item   : in Numeric; 
                     Format : in Display_Format) return Num; 
Produces a value of type Num corresponding to It em as represented by Format. The number of 
digits after the assumed radix point in Item is  Num'Scale. Conversion_Error is propagated if the 
value represented by Item is outside the range of Num.  
function  To_Display (Item   : in Num; 
                     Format : in Display_Format) return Numeric; 
This function returns the Numeric value for It em, represented in accordance with Format. The 
length of the returned value is Length(Format ), and the lower bound is 1. Conversion_Error is 
propagated if Num is negativ e and Format is Unsigned. 
function  Valid (Item   : in Packed_Decimal; 
                Format : in Packed_Format) return Boolean; 
This function returns True if Item has a value c onsistent with Format, a nd False otherwise. The 
rules for the formation of Packed_Decima l values are implementation defined. 
function  Length (Format : in Packed_Format) return Natural; 
This function returns the minimal length of a P acked_Decimal value sufficient to hold any value 
of type Num when represented as Format. 
function  To_Decimal (Item   : in Packed_Decimal; 
                     Format : in Packed_Format) return Num; 
Produces a value of type Num corresponding to Item  as represented by Fo rmat. Num'Scale is the 
number of digits after the assumed radix point in Item. Conversion_Error is propagated if the 
value represented by Item is outside the range of Num. 
function  To_Packed (Item   : in Num; 
                    Format : in Packed_Format) return Packed_Decimal; 
This function returns the Packed_Decimal valu e for Item, represented in accordance with 
Format. The length of the returned value is  Length(Format), and the lower bound is 1. 
Conversion_Error is propagated if Num is ne gative and Format is  Packed_Unsigned. 
function  Valid (Item   : in Byte_Array; 
                Format : in Binary_Format) return Boolean; 
This function returns True if Item has a value consistent with Format, and False otherwise.  
function  Length (Format : in Binary_Format) return Natural; 
This function returns the minimal length of a By te_Array value sufficient to hold any value of 
type Num when represented as Format. 
function  To_Decimal (Item   : in Byte_Array; 
                     Format : in Binary_Format) return Num; 
Produces a value of type Num corresponding to Item  as represented by Fo rmat. Num'Scale is the 
number of digits after the assumed radix point in Item. Conversion_Error is propagated if the 
value represented by Item is outside the range of Num. 
function  To_Binary (Item   : in Num; 
                    Format : in Binary_Format) return Byte_Array; 
This function returns the Byte_Array value for It em, represented in accordance with Format. The 
length of the returned value is Lengt h(Format), and the lower bound is 1. 68 
69 
70 
71/1 
72 
73 
74 
75 
76 
77 
78 
79/1 
80 
81 
82 
83 
84 
85 
86 
87/1 
Ada Reference Manual — 2012 Edition 
603      13 December 2012 Interfacing with COBOL   B.4 function  To_Decimal (Item : in Binary)      return Num; 
 function  To_Decimal (Item : in Long_Binary) return Num; 
These functions convert from COBOL binary fo rmat to a corresponding value of the decimal 
type Num. Conversion_Error is propagate d if Item is too large for Num.  
function  To_Binary      (Item : in Num)  return Binary; 
 function  To_Long_Binary (Item : in Num)  return Long_Binary; 
These functions convert from Ada decimal to  COBOL binary format. Conversion_Error is 
propagated if the value of Item is too larg e to be represented in the result type.  
Implementation Requirements 
An implementation shall support specify ing aspect Convention with a COBOL convention _identifier  for a 
COBOL-eligible type (see B.1).  
Implementation Permissions 
An implementation may provide additi onal constants of the private type s Display_Format, Binary_Format, 
or Packed_Format.  
An implementation may provide further floating point  and integer types in Interfaces.COBOL to match 
additional native COBOL types, and may also suppl y corresponding conversion functions in the generic 
package Decimal_Conversions.  
Implementation Advice 
An Ada implementation should support the follo wing interface correspondences between Ada and 
COBOL.  
• An Ada access  T parameter is passed as a “BY REFE RENCE” data item of the COBOL type 
corresponding to T. 
• An Ada in scalar parameter is passed as a “BY CONTENT” data item of the corresponding 
COBOL type. 
• Any other Ada parameter is passed as a “B Y REFERENCE” data item of the COBOL type 
corresponding to the Ada parameter type; for scalars, a local copy is used if necessary to ensure 
by-copy semantics.  
NOTES 
12  An implementation is not required to support specifying aspect Convention for access types, nor is it required to 
support specifying aspects Import, Export, or Convention for functions.  
13  If an Ada subprogram is exported to COBOL, then a call from COBOL call may specify either “BY CONTENT” or 
“BY REFERENCE”.  88 
89 
90 
91 
92/3 
93 
94 
95 
96 
97 98 
99/3 
100 
Ada Reference Manual — 2012 Edition 
B.4   Interfacing with COBOL 13 December 2012      604 Examples 
Examples of Interfaces.COBOL:   
with Interfaces.COBOL; 
procedure  Test_Call is 
   -- Calling a foreign COBOL program  
   -- Assume that a COBOL program PROG has the following declaration  
   --  in its LINKAGE section:  
   --  01 Parameter-Area  
   --     05 NAME   PIC X(20).  
   --     05 SSN    PIC X(9).  
   --     05 SALARY PIC 99999V99 USAGE COMP.  
   -- The effect of PROG is to update SALARY based on some algorithm  
   package COBOL renames Interfaces.COBOL; 
   type Salary_Type is delta 0.01 digits 7; 
   type COBOL_Record is 
      record 
         Name   : COBOL.Numeric(1..20);          SSN    : COBOL.Numeric(1..9);          Salary : COBOL.Binary;  -- Assume Binary = 32 bits  
      end record 
      with Convention => COBOL; 
   procedure  Prog (Item : in out COBOL_Record) 
      with Import => True, Convention => COBOL; 
   package Salary_Conversions is 
      new COBOL.Decimal_Conversions(Salary_Type); 
   Some_Salary : Salary_Type := 12_345.67; 
   Some_Record : COBOL_Record :=       (Name   => "Johnson, John       ",        SSN    => "111223333",        Salary => Salary_Conversions.To_Binary(Some_Salary)); 
begin 
   Prog (Some_Record);    ... end Test_Call; 
with Interfaces.COBOL; 
with COBOL_Sequential_IO; -- Assumed to be supplied by implementation  
procedure  Test_External_Formats is 
   -- Using data created by a COBOL program  
   -- Assume that a COBOL program has created a sequential file with  
   --  the following record structure, and that we need to  
   --  process the records in an Ada program  
   --  01 EMPLOYEE-RECORD  
   --     05 NAME    PIC X(20).  
   --     05 SSN     PIC X(9).  
   --     05 SALARY  PIC 99999V99 USAGE COMP.  
   --     05 ADJUST  PIC S999V999 SIGN LEADING SEPARATE.  
   -- The COMP data is binary (32 bits), high-order byte first  
   package COBOL renames Interfaces.COBOL; 
   type Salary_Type      is delta 0.01  digits 7; 
   type Adjustments_Type is delta 0.001 digits 6; 
   type COBOL_Employee_Record_Type is  -- External representation  
      record 
         Name    : COBOL.Alphanumeric(1..20);          SSN     : COBOL.Alphanumeric(1..9);          Salary  : COBOL.Byte_Array(1..4);          Adjust  : COBOL.Numeric(1..7);  -- Sign and 6 digits  
      end record 
      with Convention => COBOL; 101 
102 
103 
104 
105 
106/3 
107/3 
108 109 
110 
111 
112 
113 
114 
115/3 
Ada Reference Manual — 2012 Edition 
605      13 December 2012 Interfacing with COBOL   B.4    package COBOL_Employee_IO is 
      new COBOL_Sequential_IO(COBOL_Employee_Record_Type); 
   use COBOL_Employee_IO; 
   COBOL_File : File_Type;    type Ada_Employee_Record_Type is  -- Internal representation  
      record 
         Name    : String(1..20);          SSN     : String(1..9);          Salary  : Salary_Type;          Adjust  : Adjustments_Type;       end record; 
   COBOL_Record : COBOL_Employee_Record_Type; 
   Ada_Record   : Ada_Employee_Record_Type; 
   package Salary_Conversions is 
      new COBOL.Decimal_Conversions(Salary_Type); 
   use Salary_Conversions; 
   package Adjustments_Conversions is 
      new COBOL.Decimal_Conversions(Adjustments_Type); 
   use Adjustments_Conversions; 
begin 
   Open (COBOL_File, Name => "Some_File"); 
   loop 
     Read (COBOL_File, COBOL_Record); 
     Ada_Record.Name := To_Ada(COBOL_Record.Name); 
     Ada_Record.SSN  := To_Ada(COBOL_Record.SSN);      Ada_Record.Salary :=         To_Decimal(COBOL_Record.Salary, COBOL.High_Order_First);      Ada_Record.Adjust :=         To_Decimal(COBOL_Record.Adjust, COBOL.Leading_Separate);      ... -- Process Ada_Record  
   end loop; 
exception  
   when End_Error => ... 
end Test_External_Formats; 
B.5 Interfacing with Fortran 
The facilities relevant to interfacing with the Fort ran language are the package Interfaces.Fortran and 
support for specifying the Convention aspect with convention_ identifier  Fortran. 
The package Interfaces.Fortran defines Ada types w hose representations are identical to the default 
representations of the Fortran intrinsic types Inte ger, Real, Double Precision, Complex, Logical, and 
Character in a supported Fortran im plementation. These Ada types can therefore be used to pass objects 
between Ada and Fortran programs.  
Static Semantics 
The library package Interfaces.Fortran  has the following declaration:  
with Ada.Numerics.Generic_Complex_Types;  -- see G.1.1  
pragma Elaborate_All(Ada.Numerics.Generic_Complex_Types); 
package Interfaces.Fortran is 
   pragma Pure(Fortran); 
   type Fortran_Integer is range implementation-defined ; 
   type Real             is digits implementation-defined ; 
   type Double_Precision is digits implementation-defined ; 
   type Logical is new Boolean; 116 
117 
118 
119 
120 
121 122 
123 124 
1/3 
2 
3 
4 
5 
6 
7 
Ada Reference Manual — 2012 Edition 
B.5   Interfacing with Fortran 13 December 2012      606    package Single_Precision_Complex_Types is 
      new Ada.Numerics.Generic_Complex_Types (Real); 
   type Complex is new Single_Precision_Complex_Types.Complex; 
   subtype Imaginary is Single_Precision_Complex_Types.Imaginary; 
   i : Imaginary renames Single_Precision_Complex_Types.i; 
   j : Imaginary renames Single_Precision_Complex_Types.j; 
   type Character_Set is implementation-defined character type ; 
   type Fortran_Character is array (Positive range <>) of Character_Set 
      with Pack; 
   function  To_Fortran (Item : in Character) return Character_Set; 
   function  To_Ada (Item : in Character_Set) return Character; 
   function  To_Fortran (Item : in String) return Fortran_Character; 
   function  To_Ada     (Item : in Fortran_Character) return String; 
   procedure  To_Fortran (Item       : in String; 
                         Target     : out Fortran_Character; 
                         Last       : out Natural); 
   procedure  To_Ada (Item     : in Fortran_Character; 
                     Target   : out String; 
                     Last     : out Natural); 
end Interfaces.Fortran; 
The types Fortran_Integer, Real, Double_Precision, L ogical, Complex, and Fortran_Character are Fortran-
compatible. 
The To_Fortran and To_Ada functions map between  the Ada type Character and the Fortran type 
Character_Set, and also between the Ada type String and the Fortran type Fortran_Character. The To_Fortran and To_Ada procedures have analogous effects to the string conversion subprograms found in 
Interfaces.COBOL.  
Implementation Requirements 
An implementation shall support specifyi ng aspect Convention with a Fortran convention _identifier  for a 
Fortran-eligible type (see B.1).  
Implementation Permissions 
An implementation may add additional declarations to  the Fortran interface packages. For example, the 
Fortran interface package for an implementation of Fortran 77 (ANSI X3.9-1978) that defines types like 
Integer* n, Real* n, Logical* n, and Complex* n may contain the declarations  of types named Integer_-
Star_ n, Real_Star_ n, Logical_Star_ n, and Complex_Star_ n. (This convention should not apply to 
Character* n, for which the Ada analog is the constrained array subtype Fortran_Character (1.. n).) 
Similarly, the Fortran interface package for an implementation of Fortran 90 that provides multiple kinds  
of intrinsic types, e.g. Integer (Kind= n), Real (Kind= n), Logical (Kind= n), Complex (Kind= n), and 
Character (Kind= n), may contain the declarations of type s with the recommended names Integer_Kind_ n, 
Real_Kind_ n, Logical_Kind_ n, Complex_Kind_ n, and Character_Kind_ n.  
Implementation Advice 
An Ada implementation should support the following in terface correspondences between Ada and Fortran:  
• An Ada procedure corresponds to a Fortran subroutine. 
• An Ada function corresponds to a Fortran function. 
• An Ada parameter of an elementary, array, or record type T is passed as a T F argument to a 
Fortran procedure, where T F is the Fortran type corresponding to the Ada type T, and where the 
INTENT attribute of the corresponding dummy ar gument matches the Ada formal parameter 8 
9 
10 
11 
12/3 
13 14 15 
16 17 
18 
19 
20/3 
21 
22 
23 
24 25 
Ada Reference Manual — 2012 Edition 
607      13 December 2012 Interfacing with Fortran   B.5 mode; the Fortran implementati on's parameter passing conventions are used. For elementary 
types, a local copy is used if necessary to ensure by-copy semantics. 
• An Ada parameter of an access-to-subprogram ty pe is passed as a reference to a Fortran 
procedure whose interface corre sponds to the designated subprogram's specification.  
NOTES 
14  An object of a Fortran-compatible record type, declared in a library package or subprogram, can correspond to a Fortran common block; the type also corresponds to a Fortran “derived type”.  
Examples 
Example of Interfaces.Fortran:   
with Interfaces.Fortran; 
use Interfaces.Fortran; 
procedure  Ada_Application is 
   type Fortran_Matrix is array (Integer range <>, 
                                 Integer range <>) of Double_Precision 
      with Convention => Fortran;                  -- stored in Fortran's  
                                                   -- column-major order  
   procedure  Invert (Rank : in Fortran_Integer; X : in out Fortran_Matrix) 
      with Import => True, Convention => Fortran; -- a Fortran subroutine  
   Rank      : constant  Fortran_Integer := 100; 
   My_Matrix : Fortran_Matrix (1 .. Rank, 1 .. Rank); 
begin 
   ... 
   My_Matrix := ...;    ...    Invert (Rank, My_Matrix);    ... 
end Ada_Application; 26 
27 
28 
29 
30/3 
31 
32 
33 
34 

Ada Reference Manual — 2012 Edition 
609      13 December 2012 Systems Programming   C Annex C 
(normative)  
Systems Programming 
The Systems Programming Annex specifies additiona l capabilities provided for low-level programming. 
These capabilities are also required in many real-time,  embedded, distributed, and information systems.  
C.1 Access to Machine Operations 
This subclause specifies rules regarding access to m achine instructions from within an Ada program.  
Implementation Requirements 
The implementation shall s upport machine code insertions (see 13.8)  or intrinsic subprograms (see 6.3.1) 
(or both). Implementation-defined attributes shall be provided to allow the use of Ada entities as operands.  
Implementation Advice 
The machine code or intrinsics support should a llow access to all operations normally available to 
assembly language programmers for the target envir onment, including privileged instructions, if any.  
The support for interfacing aspects (see Annex B) s hould include interface to assembler; the default 
assembler should be associated with the convention identifier Assembler.  
If an entity is exported to assembly language, then th e implementation should allocate it at an addressable 
location, and should ensure that it is retained by the linking process, even if not otherwise referenced from 
the Ada code. The implementation should assume th at any call to a machine code or assembler 
subprogram is allowed to read  or update every object that is specified as exported.  
Documentation Requirements 
The implementation shall document the overhead asso ciated with calling machine-code or intrinsic 
subprograms, as compared to a fully-inlined call, and to a regular out-of-line call.  
The implementation shall document the types of the package System.Machine_Code usable for machine 
code insertions, and the attributes to be used in m achine code insertions for re ferences to Ada entities.  
The implementation shall document the subprogram ca lling conventions associated with the convention 
identifiers available for use with the Convention aspect (Ada and A ssembler, at a minimum), including 
register saving, exception propa gation, parameter passing, and function value returning.  
For exported and imported subprograms, the implem entation shall document the mapping between the 
Link_Name string, if specified, or the Ada designator, if not, and the external link name used for such a 
subprogram.  
Implementation Advice 
The implementation should ensure that little or no ove rhead is associated with calling intrinsic and 
machine-code subprograms.  
It is recommended that intrinsic subprograms be pr ovided for convenient access to any machine operations 
that provide special capabilities or efficiency and th at are not otherwise available through the language 
constructs. Examples of su ch instructions include:  1 
1/3 
2 
3 
4/3 
5 
6 
7 
8/3 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
C.1   Access to Machine Operations 13 December 2012      610 • Atomic read-modify-write opera tions — e.g., test and set, compare and swap, decrement and 
test, enqueue/dequeue. 
• Standard numeric functions — e.g., sin, log. 
• String manipulation operations — e.g., translate and test. 
• Vector operations — e.g., comp are vector against thresholds. 
• Direct operations on I/O ports. 
C.2 Required Representation Support 
This subclause specifies minimal re quirements on the support for representa tion items and related features.  
Implementation Requirements 
The implementation shall support at least the functi onality defined by the recommended levels of support 
in Clause 13.  
C.3 Interrupt Support 
This subclause specifies the language -defined model for hardware interrupts in addition to mechanisms for 
handling interrupts.  
Dynamic Semantics 
An interrupt  represents a class of events that are detected by the hardware or the system software. 
Interrupts are said to occur. An occurrence  of an interrupt is separable into generation and delivery. 
Generation  of an interrupt is the event in the underlying hardware or system that makes the interrupt 
available to the program. Delivery  is the action that invokes part of  the program as response to the 
interrupt occurrence. Between generation and deliv ery, the interrupt occurrence (or interrupt) is pending . 
Some or all interrupts may be blocked . When an interrupt is blocked, a ll occurrences of that interrupt are 
prevented from being delivered. Certain interrupts are reserved . The set of reserved interrupts is 
implementation defined. A reserved interrupt is either  an interrupt for which user-defined handlers are not 
supported, or one which already has an attached ha ndler by some other impl ementation-defined means. 
Program units can be connected to nonreserved interrupt s. While connected, the program unit is said to be 
attached  to that interrupt. The execution of that program unit, the interrupt handler , is invoked upon 
delivery of the interrupt occurrence.  
While a handler is attached to an interrupt, it is ca lled once for each delivered occurrence of that interrupt. 
While the handler executes, the corresponding interrupt is blocked. 
While an interrupt is blocked, all occurrences of  that interrupt are prevented from being delivered. 
Whether such occurrences remain pending or  are lost is implementation defined. 
Each interrupt has a default treatment  which determines the system's re sponse to an occurrence of that 
interrupt when no user-defined handler is att ached. The set of possible default treatments is 
implementation defined, as is the method (if one exists) for configuring the default treatments for 
interrupts. 
An interrupt is delivered to the handler (or default treat ment) that is in effect for that interrupt at the time 
of delivery. 
An exception propagated from a handler that is invoked by an interrupt has no effect. 12 
13 
14 15 16 
1/3 
2/3 
1/3 
2 
3 
4 5 
6 
7 
Ada Reference Manual — 2012 Edition 
611      13 December 2012 Interrupt Support   C.3 If the Ceiling_Locking policy (see D.3) is in effect, the interrupt handler executes with the active priority 
that is the ceiling priority of  the corresponding protected object. 
Implementation Requirements 
The implementation shall provide a mechanism to dete rmine the minimum stack space that is needed for 
each interrupt handler and to reserve that space for the execution of the handler. This space should 
accommodate nested invocations of the ha ndler where the system permits this. 
If the hardware or the underlying system holds pendi ng interrupt occurrences, the implementation shall 
provide for later delivery of th ese occurrences to the program. 
If the Ceiling_Locking policy is not in effect, the impl ementation shall provide means for the application 
to specify whether interrupts are to be blocked during protected actions. 
Documentation Requirements 
The implementation shall document the following items:  
1. For each interrupt, which interrupts are blocked from delivery when a handler attached to that 
interrupt executes (either as a result of an interr upt delivery or of an ordinary call on a procedure 
of the corresponding protected object). 
2. Any interrupts that cannot be blocked, and the e ffect of attaching handlers to such interrupts, if 
this is permitted. 
3. Which run-time stack an interrupt handler uses when it executes as a result of an interrupt 
delivery; if this is configurable, what is the mechanism to do so; how to specify how much space 
to reserve on that stack. 
4. Any implementation- or hardwa re-specific activity that happens before a user-defined interrupt 
handler gets control (e.g., reading de vice registers, acknowledging devices). 
5. Any timing or other limita tions imposed on the execution of interrupt handlers. 
6. The state (blocked/unblocked) of the nonreserve d interrupts when the program starts; if some 
interrupts are unblocked, what is the mechanism a program can use to protect itself before it can 
attach the corresponding handlers. 
7. Whether the interrupted task is allowed to resu me execution before the interrupt handler returns. 
8. The treatment of interrupt occurrences that ar e generated while the interrupt is blocked; i.e., 
whether one or more occurrences are held for later delivery, or all are lost. 
9. Whether predefined or implementation-defined exceptions are raised as a result of the 
occurrence of any interrupt, and the mapping betw een the machine interrupts (or traps) and the 
predefined exceptions. 
10. 
 On a multi-processor, the rules governing the deliver y of an interrupt to a particular processor.  
Implementation Permissions 
If the underlying system or hardware does not allow inte rrupts to be blocked, th en no blocking is required 
as part of the execution of subprograms of a protect ed object for which one of its subprograms is an 
interrupt handler. 
In a multi-processor with more than one interrupt subsystem, it is implementation defined whether (and 
how) interrupt sources from separate subsystems sh are the same Interrupt_Id type (see C.3.2). In 
particular, the meaning of a blocked or pending interrupt  may then be applicable to one processor only.  8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23/2 
24 
Ada Reference Manual — 2012 Edition 
C.3   Interrupt Support 13 December 2012      612 Implementations are allowed to impos e timing or other limitations on the execution of interrupt handlers.  
Other forms of handlers are allowed to be supported, in which case the rules of this subclause should be 
adhered to. 
The active priority of the execution of an interrupt ha ndler is allowed to vary from one occurrence of the 
same interrupt to another. 
Implementation Advice 
If the Ceiling_Locking policy is not in effect, the impl ementation should provide means for the application 
to specify which interrupts are to be blocked during protected actions, if the underlying system allows for 
finer-grained control of interrupt blocking.  
NOTES 
1  The default treatment for an interrupt can be to keep the interrupt pending or to deliver it to an implementation-defined handler. Examples of actions that an implementation-defined handler is allowed to perform include aborting the partition, ignoring (i.e., discarding occurrences of) the interrupt, or queuing one or more occurrences of the interrupt for possible later delivery when a user-defined handler is attached to that interrupt. 
2  It is a bounded error to call Task_Identification.Current_Task (see C.7.1) from an interrupt handler. 3  The rule that an exception propagated from an interrupt handler has no effect is modeled after the rule about exceptions 
propagated out of task bodies. 
C.3.1 Protected Procedure Handlers 
Paragraphs 1 through 6 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
For a parameterless protected procedure, the follo wing language-defined representation aspects may be 
specified:  
Interrupt_Handler 
  The type of aspect Interrupt_Handler is B oolean. If directly specified, the aspect_definition 
shall be a static expression. This aspect is never inherited; if not directly specified, the 
aspect is False. 
Attach_Handler 
  The aspect Attach_Handler is an expression , which shall be of type 
Interrupts.Interrupt_Id. This aspect is never inherited. 
Legality Rules 
If either the Attach_Handler or Interrupt_Handler as pect are specified for a protected procedure, the 
corresponding protected_type_declaration  or single_protected_declaration  shall be a library-level 
declaration and shall not be declared within a gene ric body. In addition to the places where Legality Rules 
normally apply (see 12.3), this rule also applies in the private part of an instance of a generic unit. 
This paragraph was deleted.  
Dynamic Semantics 
If the Interrupt_Handler aspect of a protected proce dure is True, then the procedure may be attached 
dynamically, as a handler, to interrupts (see C.3.2). Such  procedures are allowed to be attached to multiple 
interrupts. 25 
26/3 
27 
28/2 
29 
30 
31 
6.1/3 
6.2/3 
6.3/3 
7/3 
8/3 
9/3 
Ada Reference Manual — 2012 Edition 
613      13 December 2012 Prot ected Procedure Handlers   C.3.1 The expression  specified for the Attach_Handler aspect of a protected procedure P is evaluated as part of 
the creation of the protected object that contains P. The value of the expression  identifies an interrupt. As 
part of the initialization of that object, P (the handler  procedure) is attached to the identified interrupt. A 
check is made that the corresponding interrupt is not reserved. Program_Error is ra ised if the check fails, 
and the existing treatment for the interrupt is not affected. 
If the Ceiling_Locking policy (see D.3) is in effect, th en upon the initialization of a protected object that 
contains a protected procedure for which either th e Attach_Handler aspect is specified or the  
Interrupt_Handler aspect is True, a check is made that the initial ceiling priority of the object is in the 
range of System.Interrupt_Priority. If th e check fails, Program_Error is raised. 
When a protected object is finalized, for any of its proce dures that are attached to interrupts, the handler is 
detached. If the handler was attached by a procedure in the Interrupts package or if no user handler was 
previously attached to the interrupt , the default treatment is restored. If the Attach_Handler aspect was 
specified and the most recently attached handler for th e same interrupt is the same as the one that was 
attached at the time the protected object was in itialized, the previous handler is restored.  
When a handler is attached to an interrupt, the interrupt is blocked (subj ect to the Implementation 
Permission in C.3) during the execution of every pr otected action on the protected object containing the 
handler. 
Erroneous Execution 
If the Ceiling_Locking policy (see D.3) is in effect a nd an interrupt is delivered to a handler, and the 
interrupt hardware priority is higher than the ce iling priority of the corresponding protected object, the 
execution of the program is erroneous. 
If the handlers for a given interrupt attached via aspect  Attach_Handler are not attached and detached in a 
stack-like (LIFO) order, program execution is err oneous. In particular, when a protected object is 
finalized, the execution is erroneous if any of the pr ocedures of the protected object are attached to 
interrupts via aspect Attach_Handler and the most recen tly attached handler for the same interrupt is not 
the same as the one that was attached at the time the protected object was initialized.  
Metrics 
The following metric shall be documented by the implementation:  
• The worst-case overhead for an interrupt handler th at is a parameterless protected procedure, in 
clock cycles. This is the execution time not directly  attributable to the handler procedure or the 
interrupted execution. It is estim ated as C – (A+B), where A is how long it takes to complete a 
given sequence of instructions without any interr upt, B is how long it takes to complete a normal 
call to a given protected procedure, and C is how  long it takes to complete the same sequence of 
instructions when it is interrupted by one execution of the same procedure called via an 
interrupt.  
Implementation Permissions 
When the aspects Attach_Handler or Interrupt_Handl er are specified for a protected procedure, the 
implementation is allowed to impose implementation-defined re strictions on the corresponding 
protected_type_declaration  and protected_body .  
An implementation may use a differe nt mechanism for invoking a protect ed procedure in response to a 
hardware interrupt than is used for a call to that protected procedure from a task.  
Notwithstanding what this subclause says elsewhere,  the Attach_Handler and Interrupt_Handler aspects 
are allowed to be used for ot her, implementation defined, fo rms of interrupt handlers.  10/3 
11/3 
12/3 
13 
14 
14.1/3 
15 
16/2 
17/3 
18 
19/3 
Ada Reference Manual — 2012 Edition 
C.3.1    Protected Procedure Handl ers 13 December 2012      614 Implementation Advice 
Whenever possible, the implementation should allow interrupt handlers to be called directly by the 
hardware.  
Whenever practical, the implemen tation should detect violations of any implementation-defined 
restrictions before run time.  
NOTES 
4  The Attach_Handler aspect may provide static attachment of handlers to interrupts if the implementation supports preelaboration of protected objects. (See C.4.) 
5  A protected object that has a (protected) procedure attached to an interrupt should have a ceiling priority at least as high  
as the highest processor priority at which that interrupt will ever be delivered. 
6  Protected procedures can also be attached dynamically to interrupts via operations declared in the predefined package 
Interrupts. 
7  An example of a possible implementation-defined restriction is disallowing the use of the standard storage pools within 
the body of a protected procedure that is an interrupt handler. 
C.3.2 The Package Interrupts 
Static Semantics 
The following language-defin ed packages exist:  
with System; 
with System.Multiprocessors; 
package Ada.Interrupts is 
   type Interrupt_Id is implementation-defined ; 
   type Parameterless_Handler is 
      access protected  procedure ; 
This paragraph was deleted.  
   function  Is_Reserved (Interrupt : Interrupt_Id) 
      return Boolean; 
   function  Is_Attached (Interrupt : Interrupt_Id) 
      return Boolean; 
   function  Current_Handler (Interrupt : Interrupt_Id) 
      return Parameterless_Handler; 
   procedure  Attach_Handler 
      (New_Handler : in Parameterless_Handler; 
       Interrupt   : in Interrupt_Id); 
   procedure  Exchange_Handler 
      (Old_Handler : out Parameterless_Handler; 
       New_Handler : in Parameterless_Handler; 
       Interrupt   : in Interrupt_Id); 
   procedure  Detach_Handler 
      (Interrupt : in Interrupt_Id); 
   function  Reference (Interrupt : Interrupt_Id) 
      return System.Address; 
   function  Get_CPU (Interrupt : Interrupt_Id) 
      return System.Multiprocessors.CPU_Range; 
private 
   ... -- not specified by the language  
end Ada.Interrupts; 20 
21 
22/3 
23/2 
24 25 
1 
2/3 
3/1 
4 
5 6 7 
8 
9 
10 
10.1/3 
11 
Ada Reference Manual — 2012 Edition 
615      13 December 2012 The Package Interrupts   C.3.2 package Ada.Interrupts.Names is 
   implementation-defined  : constant  Interrupt_Id := 
     implementation-defined ; 
      . . .    implementation-defined  : constant  Interrupt_Id := 
     implementation-defined ; 
end Ada.Interrupts.Names; 
Dynamic Semantics 
The Interrupt_Id type is an impl ementation-defined discrete type used to identify interrupts. 
The Is_Reserved function returns True if and only if the specified interrupt is reserved. 
The Is_Attached function returns True if and only if a user-specified interrupt handler is attached to the 
interrupt. 
The Current_Handler function returns a value that repr esents the attached handler of the interrupt. If no 
user-defined handler is attached to the interrupt, Current_Handler returns null. 
The Attach_Handler procedure attaches the specifi ed handler to the interrupt, overriding any existing 
treatment (including a user handler) in eff ect for that interrupt. If New_Handler is null, the default 
treatment is restored. If New_Handl er designates a protected procedure for which the aspect Interrupt_-
Handler is False, Program_Error is ra ised. In this case, the operation doe s not modify the existing interrupt 
treatment. 
The Exchange_Handler procedure operates in the same  manner as Attach_Handler with the addition that 
the value returned in Old_Handler designates the pr evious treatment for the specified interrupt. If the 
previous treatment is not a user-defined handler, null is returned.  
The Detach_Handler procedure restores the de fault treatment for the specified interrupt. 
For all operations defined in this package that take a parameter of type Interrupt_Id, with the exception of 
Is_Reserved and Reference, a check is made that the specified interrupt is not reserved. Program_Error is raised if this check fails. 
If, by using the Attach_Handler, Detach_Handler, or Ex change_Handler procedures, an attempt is made to 
detach a handler that was attached statically (using th e aspect Attach_Handler), the handler is not detached 
and Program_Error is raised.  
The Reference function returns a value of type System.A ddress that can be used to attach a task entry via 
an address clause (see J.7.1) to the interrupt specifi ed by Interrupt. This function raises Program_Error if 
attaching task entries to interrupts (or to th is particular interrupt) is not supported.  
The function Get_CPU returns the processor on which th e handler for Interrupt is executed. If the handler 
can execute on more than one processor the valu e System.Multiprocessors.N ot_A_Specific_CPU is 
returned. 
Implementation Requirements 
At no time during attachment or exchange of handl ers shall the current handler of the corresponding 
interrupt be undefined. 
Documentation Requirements 
If the Ceiling_Locking policy (see D.3) is in effect, the implementation shall document the default ceiling 
priority assigned to a protected object that contains  a protected procedure that specifies either the 12 
13 
14 15 
16/1 17/3 
18/1 
19 
20 
21/3 
22/2 
22.1/3 
23 
24/3 
Ada Reference Manual — 2012 Edition 
C.3.2    The Package Interrupts 13 December 2012      616 Attach_Handler or Interrupt_Handler aspects, but does not specify the Interrupt_Priority aspect. This 
default need not be the same for all interrupts.  
Implementation Advice 
If implementation-defined forms of interrupt handler  procedures are supported, such as protected 
procedures with parameters, then for each such form  of a handler, a type analogous to Parameterless_-
Handler should be specified in a child package of Interr upts, with the same operations as in the predefined 
package Interrupts. 
NOTES 
8  The package Interrupts.Names contains implementation-defined names (and constant values) for the interrupts that are supported by the implementation. 
Examples 
Example of interrupt handlers:   
Device_Priority : constant  
  array (1..5) of System.Interrupt_Priority := ( ... ); 
protected  type Device_Interface 
  (Int_Id : Ada.Interrupts.Interrupt_Id)       with Interrupt_Priority => Device_Priority(Int_Id) is 
  procedure  Handler 
     with Attach_Handler => Int_Id; 
  ...   end Device_Interface; 
  ... Device_1_Driver : Device_Interface(1);   ... Device_5_Driver : Device_Interface(5);   ... 
C.4 Preelaboration Requirements 
This subclause specifies additional implementation and documentation requirements for the Preelaborate 
pragma (see 10.2.1).  
Implementation Requirements 
The implementation shall not incur any run-time overhead for the elaboration checks of subprograms and 
protected_bodies  declared in preelaborated library units. 
The implementation shall not execute any memory write  operations after load time for the elaboration of 
constant objects declared immediately within the declar ative region of a preelaborated library package, so 
long as the subtype and initial expression (or default in itial expressions if initialized by default) of the 
object_declaration  satisfy the following restrictions. The meaning of load time  is implementation defined.  
• Any subtype_mark  denotes a statically constrained s ubtype, with statically constrained 
subcomponents, if any; 
• no subtype_mark  denotes a controlled type, a private type , a private extension, a generic formal 
private type, a generic formal derived ty pe, or a descendant of such a type; 
• any constraint  is a static constraint; 
• any allocator  is for an access-to-constant type; 
• any uses of predefined operators a ppear only within static expressions; 25 
26 
27 
28/3 
1/3 
2 
3 
4 
4.1/2 
5 
6 7 
Ada Reference Manual — 2012 Edition 
617      13 December 2012 Preelaboration Requirements   C.4 • any primaries  that are name s, other than attribute_reference s for the Access or Address 
attributes, appear only within static expressions;  
• any name  that is not part of a static expression is an expanded name or direct_name  that 
statically denotes some entity;  
• any discrete_choice  of an array_aggregate  is static; 
• no language-defined check associat ed with the elaboration of the object_declaration  can fail.  
Documentation Requirements 
The implementation shall document any circumstances under which the elaboration of a preelaborated 
package causes code to be executed at run time.  
The implementation shall document whether the method used for initialization of preelaborated variables 
allows a partition to be restarted without reloading.  
Implementation Advice 
It is recommended that preelaborated packages be impl emented in such a way that there should be little or 
no code executed at run time for the elaboration of  entities not already covered by the Implementation 
Requirements. 
C.5 Pragma Discard_Names 
A pragma  Discard_Names may be used to request a reduc tion in storage used for the names of certain 
entities.  
Syntax 
The form of a pragma  Discard_Names is as follows:  
  pragma  Discard_Names[([On => ] local_name )]; 
A pragma  Discard_Names is allowed only immediately within a declarative_part , immediately 
within a package_specification , or as a configuration pragma.  
Legality Rules 
The local_name  (if present) shall denote a nonderived enumerati on first subtype, a tagged first subtype, or 
an exception. The pragma applies to the type or exception. Without a local_name , the pragma applies to 
all such entities declared after the pr agma, within the same declarative region. Alternatively, the pragma 
can be used as a configuration pragma. If the pragma  applies to a type, then it applies also to all 
descendants of the type.  
Static Semantics 
If a local_name  is given, then a pragma  Discard_Names is a representation pragma. 
If the pragma applies to an enumeration type, then the semantics of the Wide_Wide_Image and 
Wide_Wide_Value attributes are implementation de fined for that type; the semantics of Image, 
Wide_Image, Value, and Wide_Value are still defined in terms of Wide_Wide_Image and 
Wide_Wide_Value. In addition, the semantics of Te xt_IO.Enumeration_IO are im plementation defined. If 
the pragma applies to a tagged type, then the se mantics of the Tags.Wide_Wide_Expanded_Name function 
are implementation defined for that type; the semantics of Tags.Expande d_Name and Tags.Wide_-
Expanded_Name are still defined in terms of Tags.W ide_Wide_Expanded_Name. If the pragma applies to 
an exception, then the semantics of the Ex ceptions.Wide_Wide_Excep tion_Name function are 8 
9 
10 
11 
12 
13 
14 
1 
2 
3 
4 
5 
6 
7/2 
Ada Reference Manual — 2012 Edition 
C.5   Pragma Discard_Names  13 December 2012      618 implementation defined for that exception; the se mantics of Exceptions.Ex ception_Name and Exceptions.-
Wide_Exception_Name are still defined in term s of Exceptions.Wide_Wide_Exception_Name. 
Implementation Advice 
If the pragma applies to an entity, then the implem entation should reduce the amount of storage used for 
storing names associated with that entity.  
C.6 Shared Variable Control 
This subclause defines representation aspects th at control the use of shared variables.  
Paragraphs 2 through 6 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
For an object_declaration , a component_declaration , or a full_type_declaration , the following 
representation aspects may be specified: 
Atomic The type of asp ect Atomic is Boolean. 
Independent The type of aspect Independent is Boolean. Volatile The type of aspect Volatile is Boolean. 
For a 
full_type_declaration  of an array type (including the anonymous type of an object_declaration  of an 
anonymous array object), the following re presentation aspects may be specified: 
Atomic_Components 
 The type of aspect At omic_Components is Boolean. 
Volatile_Components 
 The type of aspect Volatile_Components is Boolean. 
For a full_type_declaration  (including the anonymous type of an object_declaration  of an anonymous 
array object), the following representation aspect may be specified: 
Independent_Components 
 The type of aspect Inde pendent_Components is Boolean. 
If any of these aspects are directly specified, the aspect_definition  shall be a static expression. If not 
specified (including by inheritance), each of these aspects is False. 
An atomic  type is one for which the aspect Atomic is True. An atomic  object (including a component) is 
one for which the aspect Atomic is True, or a component of an array for which the aspect 
Atomic_Components is True for the associated type, or  any object of an atomic type, other than objects 
obtained by evaluating a slice.  
A volatile  type is one for which the aspect Volatile is True. A volatile  object (including a component) is 
one for which the aspect Volatile is True, or a co mponent of an array for which the aspect Volatile_-
Components is True for the associated type, or any object  of a volatile type. In addition, every atomic type 
or object is also defined to be volatile. Finally, if an  object is volatile, then so are all of its subcomponents 
(the same does not apply to atomic). 
When True, the aspects Indepe ndent and Independent_Components specify as independently addressable  
the named object or component(s), or in the case of a type, all objects or components of that type. All 
atomic objects are considered to be specified as independently addressable. 8 
1/3 
6.1/3 
6.2/3 
6.3/3 6.4/3 6.5/3 
6.6/3 
6.7/3 6.8/3 
6.9/3 
6.10/3 
7/3 
8/3 
8.1/3 
Ada Reference Manual — 2012 Edition 
619      13 December 2012 Shared Variable Control   C.6 Paragraph 9 was moved to Annex J, “Obsolescent Features”.   
Legality Rules 
If aspect Independent_Components is specified for a full_type_declaration , the declaration shall be that of 
an array or record type. 
It is illegal to specify either of the aspects Atomic  or Atomic_Components to have the value True for an 
object or type if the implementation cannot support the indivisible reads and updates required by the 
aspect (see below). 
It is illegal to specify the Size attribute of an atomic  object, the Component_Size attribute for an array type 
with atomic components, or the lay out attributes of an atomic com ponent, in a way that prevents the 
implementation from performing the requi red indivisible reads and updates. 
If an atomic object is passed as a parameter, then the fo rmal parameter shall either have an atomic type or 
allow pass by copy. If an atomic object is used as  an actual for a generic formal object of mode in out , 
then the type of the generic formal object shall be atomic. If the prefix  of an attribute_reference  for an 
Access attribute denotes an atomic object (includi ng a component), then the designated type of the 
resulting access type shall be atomic. If an atomic type is used as an actual for a generic formal derived type, then the ancestor of the formal type shall be atomic. Corresponding rule s apply to volatile objects 
and types. 
If a volatile type is used as an actual for a generic fo rmal array type, then the element type of the formal 
type shall be volatile. 
If an aspect Volatile, Volatile_Components, Atomic, or Atomic_Components is directly specified to have 
the value True for a stand-alone constant object, then the aspect Import shall also be specified as True for it.  
It is illegal to specify the aspect Independent or Independent_Components as True for a component, object 
or type if the implementation cannot provide the i ndependent addressability required by the aspect (see 
9.10). 
It is illegal to specify a representation aspect fo r a component, object or type for which the aspect 
Independent or Independent_Compone nts is True, in a way that pr events the implementation from 
providing the independent addressability required by the aspect. 
Paragraph 14 was moved to Annex J, “Obsolescent Features”.   
Dynamic Semantics 
For an atomic object (including an atomic component ) all reads and updates of the object as a whole are 
indivisible. 
All tasks of the program (on all processors) that read  or update volatile variables see the same order of 
updates to the variables. A use of an atomic variab le or other mechanism may be necessary to avoid 
erroneous execution and to ensure that access to nona tomic volatile variables is sequential (see 9.10). 
Two actions are sequential (see 9. 10) if each is the read or update of the same atomic object. 
If a type is atomic or volatile and it is not a by-copy type, then the type is defined to be a by-reference 
type. If any subcomponent of a type is atomic or vola tile, then the type is defined to be a by-reference 
type. 9.1/3 
10/3 
11 
12/3 
12.1/3 
13/3 
13.1/3 
13.2/3 
15 
16/3 
17 
18 
Ada Reference Manual — 2012 Edition 
C.6   Shared Variable Control 13 December 2012      620 If an actual parameter is atomic or volatile, and the corresponding formal parameter is not, then the 
parameter is passed by copy.  
Implementation Requirements 
The external effect of a program (see 1.1.3) is defi ned to include each read and update of a volatile or 
atomic object. The implementation shall not generate any memory reads or updates of atomic or volatile 
objects other than those specified by the program.  
If the Pack aspect is True for a type any of whose subcomponents are atomic, the implem entation shall not 
pack the atomic subcomponents more tightly than that for which it can support indivisible reads and 
updates.  
Implementation Advice 
A load or store of a volatile object whose size is a multiple of System.Storage_Unit and whose alignment 
is nonzero, should be implemented by accessing ex actly the bits of the object and no others.  
A load or store of an atomic object should, where possible, be implemented by a single load or store 
instruction.  
NOTES 
9  An imported volatile or atomic constant behaves as a constant (i.e. read-only) with respect to other parts of the Ada program, but can still be modified by an “external source.” 
C.7 Task Information 
This subclause describes operations a nd attributes that can be used to  obtain the identity of a task. In 
addition, a package that associates user-defined inform ation with a task is defined. Finally, a package that 
associates termination procedures with a task or set of tasks is defined.  
C.7.1 The Package Task_Identification 
Static Semantics 
The following language-defined library package exists:  
package Ada.Task_Identification is 
   pragma Preelaborate(Task_Identification); 
   type Task_Id is private; 
   pragma Preelaborable_Initialization (Task_Id); 
   Null_Task_Id : constant  Task_Id; 
   function   "=" (Left, Right : Task_Id) return Boolean; 
   function   Image                  (T : Task_Id) return String; 
   function   Current_Task     return Task_Id; 
   function   Environment_Task return Task_Id; 
   procedure  Abort_Task             (T : in Task_Id); 
   function   Is_Terminated          (T : Task_Id) return Boolean; 
   function   Is_Callable            (T : Task_Id) return Boolean; 
   function   Activation_Is_Complete (T : Task_Id) return Boolean; 
private 
   ... -- not specified by the language  
end Ada.Task_Identification; 
Dynamic Semantics 
A value of the type Task_Id identifies an existent task. The constant Null_Task_Id does not identify any 
task. Each object of the type Task_Id is defa ult initialized to the value of Null_Task_Id. 19 
20 
21/3 
22/2 
23/2 
24 
1/3 
1 
2/2 
3/3 
4/3 
5 
Ada Reference Manual — 2012 Edition 
621      13 December 2012 The Package Task_Identification   C.7.1 The function "=" returns True if and only if Left and Right identify the same task or both have the value 
Null_Task_Id. 
The function Image returns an implem entation-defined string that identif ies T. If T equals Null_Task_Id, 
Image returns an empty string.  
The function Current_Task returns a value that identifies the calling task. The function Environment_Task returns a value that identifies the environment task. The effect of Abort_Task is the same as the 
abort_statement  for the task identified by T. In addition, if T 
identifies the environment task, the en tire partition is aborted, See E.1. 
The functions Is_Terminated and Is_Callable return the value of the corresponding attribute of the task 
identified by T.  
The function Activation_Is_Complete returns True if th e task identified by T has completed its activation 
(whether successfully or not). It returns False otherwise. If T identifies the environment task, 
Activation_Is_Complete returns True after the elaboration of the library_item s of the partition has 
completed. 
For a prefix  T that is of a task type (after any implicit dereference), the following attribute is defined:  
T'Identity Yields a value of the type Task_I d that identifies the task denoted by T. 
For a prefix  E that denotes an entry_declaration , the following attribute is defined:  
E'Caller Yields a value of the type Task_Id that id entifies the task whose call is now being serviced. 
Use of this attribute is allowed only inside an accept_statement , or entry_body  after the 
entry_barrier , corresponding to the entry_declaration  denoted by E.  
Program_Error is raised if a value of Null_Tas k_Id is passed as a parameter to Abort_Task, 
Is_Terminated, and Is_Callable. 
Abort_Task is a potentially blocking operation (see 9.5.1).  
Bounded (Run-Time) Errors 
It is a bounded error to call the Current_Task function from an entry_body , interrupt handler, or 
finalization of a task attribute. Program_Error is rais ed, or an implementation-de fined value of the type 
Task_Id is returned.  
Erroneous Execution 
If a value of Task_Id is passed as a parameter to any of the operations declared in this package (or any 
language-defined child of this package), and the corresponding task object no longer exists, the execution 
of the program is erroneous.  
Documentation Requirements 
The implementation shall doc ument the effect of calling Current_Task from an entry body or interrupt 
handler.  
NOTES 
10  This package is intended for use in writing user-defined task scheduling packages and constructing server tasks. Current_Task can be used in conjunction with other operations requiring a task as an argument such as Set_Priority (see D.5). 
11  The function Current_Task and the attribute Caller can return a Task_Id value that identifies the environment task. 6 
7 8 
8.1/3 
9 
10 
10.1/3 
11 
12 
13 
14/3 
15 
16 
17/3 
18 
19 
20 
21 
Ada Reference Manual — 2012 Edition 
C.7.2    The Package Task_Attributes 13 December 2012      622 C.7.2 The Package Task_Attributes 
Static Semantics 
The following language-defined gene ric library package exists:  
with Ada.Task_Identification; use Ada.Task_Identification; 
generic 
   type Attribute is private; 
   Initial_Value : in Attribute; 
package Ada.Task_Attributes is 
   type Attribute_Handle is access all Attribute; 
   function  Value(T : Task_Id := Current_Task) 
     return Attribute; 
   function  Reference(T : Task_Id := Current_Task) 
     return Attribute_Handle; 
   procedure  Set_Value(Val : in Attribute; 
                       T : in Task_Id := Current_Task); 
   procedure  Reinitialize(T : in Task_Id := Current_Task); 
end Ada.Task_Attributes; 
Dynamic Semantics 
When an instance of Task_Attributes is elaborated in a given active partition, an object of the actual type 
corresponding to the formal type Attribute is implicitly created for each task (of that partition) that exists 
and is not yet terminated. This object acts as a user-def ined attribute of the task. A task created previously 
in the partition and not yet terminated has this attribut e from that point on. Each task subsequently created 
in the partition will have this attribute when created . In all these cases, the initial value of the given 
attribute is Initial_Value. 
The Value operation returns the value of the corresponding attribute of T. The Reference operation returns an access value th at designates the corresponding attribute of T. 
The Set_Value operation performs any finalization on the ol d value of the attribute of T and assigns Val to 
that attribute (see 5.2 and 7.6). 
The effect of the Reinitialize operation is the same as  Set_Value where the Val parameter is replaced with 
Initial_Value.  
For all the operations declared in this package, Task ing_Error is raised if the task identified by T is 
terminated. Program_Error is raised if  the value of T is Null_Task_Id. 
After a task has terminated, all of its attributes are finalized, unless they have been finalized earlier. When 
the master of an instantiation of Ada.Task_Attributes  is finalized, the corresponding attribute of each task 
is finalized, unless it has been finalized earlier.  
Bounded (Run-Time) Errors 
If the package Ada.Task_Attributes is  instantiated with a controlled type  and the controlled type has user-
defined Adjust or Finalize operations that in turn access task attributes by any of the above operations, 
then a call of Set_Value of the instantiated packag e constitutes a bounded error. The call may perform as 
expected or may result in forever blocking the calling task and subsequently some or all tasks of the 
partition.  1 
2 
3 
4 
5 6 
7 
8 
9 
10 11 
12 13 
13.1/2 
13.2/1 
Ada Reference Manual — 2012 Edition 
623      13 December 2012 The Package Task_Attributes   C.7.2 Erroneous Execution 
It is erroneous to dereference the access value returned  by a given call on Reference after a subsequent call 
on Reinitialize for the same task attribute, or  after the associated task terminates.  
If a value of Task_Id is passed as a parameter to any of the operations declared in this package and the 
corresponding task object no longer exists, th e execution of the program is erroneous. 
An access to a task attribute via a value of type A ttribute_Handle is erroneous if executed concurrently 
with another such access or a call of any of the opera tions declared in package Task_Attributes. An access 
to a task attribute is erroneous if executed concurrently with or after the finalization of the task attribute.  
Implementation Requirements 
For a given attribute of a given task, the implementa tion shall perform the operations declared in this 
package atomically with respect to any of these opera tions of the same attribute of the same task. The 
granularity of any locking mechanism necessary to ach ieve such atomicity is implementation defined.  
After task attributes are finalized, the implementa tion shall reclaim any storage associated with the 
attributes.  
Documentation Requirements 
The implementation shall document the limit on the number of attributes per task, if any, and the limit on the total storage for attribute values  per task, if such a limit exists. 
In addition, if these limits can be  configured, the implementation sha ll document how to configure them.  
Metrics 
The implementation shall document the following metrics: A task calling the following subprograms shall 
execute at a sufficiently high priority as to not be  preempted during the measur ement period. This period 
shall start just before issuing the call and end just af ter the call completes. If the attributes of task T are 
accessed by the measurement tests, no other task shall access attributes of that task during the measurement period. For all measuremen ts described here, the Attribute ty pe shall be a scalar type whose 
size is equal to the size of the predefined type Integer. For each measurement, two cases shall be 
documented: one where the accessed attributes are of th e calling task (that is, the default value for the T 
parameter is used), and the other, where T identifies another, nonterminated, task. 
The following calls (to subprograms in the Tas k_Attributes package) shall be measured:  
• a call to Value, where the re turn value is Initial_Value; 
• a call to Value, where the return value is not equal to Initial_Value; 
• a call to Reference, where the return valu e designates a value equal to Initial_Value; 
• a call to Reference, where the return value designates a value not equal to Initial_Value; 
• a call to Set_Value where the Val parameter is not equal to Initial_Value and the old attribute 
value is equal to Initial_Value; 
• a call to Set_Value where the Val parameter is not equal to Initial_Value and the old attribute 
value is not equal to Initial_Value. 
Implementation Permissions 
An implementation need not actually create the object co rresponding to a task attribute until its value is set 
to something other than that of Initial_Value, or until Reference is called for the task attribute. Similarly, 
when the value of the attribute is to be reinitialized  to that of Initial_Value, the object may instead be 14 
15 
15.1/2 
16/1 
17/2 
18 
19 
20/2 
21 
22 
23 24 25 
26/2 
27 
28 
Ada Reference Manual — 2012 Edition 
C.7.2    The Package Task_Attributes 13 December 2012      624 finalized and its storage reclaimed, to be recreated wh en needed later. While the object does not exist, the 
function Value may simply return Initial_Value,  rather than implicitly creating the object.  
An implementation is allowed to place restrictions on the maximum number of attributes a task may have, 
the maximum size of each attribute, and the total stor age size allocated for all the attributes of a task. 
Implementation Advice 
Some implementations are targeted to domains in which memory use at run time must be completely 
deterministic. For such implementations, it is recommende d that the storage for task attributes will be pre-
allocated statically and not from the heap. This can be accomplished by either placing restrictions on the number and the size of the attributes of a task, or by using the pre-allocated storage for the first N attribute objects, and the heap for the others. In the latter case, N should be documented. 
Finalization of task attributes and reclamation of associated storage should be performed as soon as 
possible after task termination.  
NOTES 
12  An attribute always exists (after instantiation), and has the initial value. It need not occupy memory until the first operation that potentially changes the attribute value. The same holds true after Reinitialize. 
13  The result of the Reference function should be used with care; it is always safe to use that result in the task body 
whose attribute is being accessed. However, when the result is being used by another task, the programmer must make sure that the task whose a ttribute is being accesse d is not yet terminated. Failing to  do so could make the program 
execution erroneous. 
C.7.3 The Package Task_Termination 
Static Semantics 
The following language-defined library package exists:  
with Ada.Task_Identification; 
with Ada.Exceptions; 
package Ada.Task_Termination is 
   pragma Preelaborate(Task_Termination); 
   type Cause_Of_Termination is (Normal, Abnormal, Unhandled_Exception); 
   type Termination_Handler is access protected procedure  
     (Cause : in Cause_Of_Termination; 
      T     : in Ada.Task_Identification.Task_Id; 
      X     : in Ada.Exceptions.Exception_Occurrence); 
   procedure  Set_Dependents_Fallback_Handler 
     (Handler: in Termination_Handler); 
   function  Current_Task_Fallback_Handler return Termination_Handler; 
   procedure  Set_Specific_Handler 
     (T       : in Ada.Task_Identification.Task_Id; 
      Handler : in Termination_Handler); 
   function  Specific_Handler (T : Ada.Task_Identification.Task_Id) 
      return Termination_Handler; 
end Ada.Task_Termination; 
Dynamic Semantics 
The type Termination_Handler identifies a protected  procedure to be executed by the implementation 
when a task terminates. Such a protected procedure is called a handler . In all cases T identifies the task 
that is terminating. If the task term inates due to completing the last stat ement of its body, or as a result of 
waiting on a terminate alternative, and the finalization of  the task completes normally, then Cause is set to 
Normal and X is set to Null_Occurrence. If the task te rminates because it is being aborted, then Cause is 29 
30/2 
30.1/2 
31 
32 
1/2 
2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
8/3 
Ada Reference Manual — 2012 Edition 
625      13 December 2012 The Package Task_Termination   C.7.3 set to Abnormal; X is set to Null_Occurrence if the fi nalization of the task completes normally. If the task 
terminates because of an exception raised by the execution of its task_body , then Cause is set to 
Unhandled_Exception; X is set to the associated ex ception occurrence if the finalization of the task 
completes normally. Independent of how the task comp letes, if finalization of the task propagates an 
exception, then Cause is either Unhandled_Exception or Abnormal, and X is an exception occurrence that 
identifies the Program_Error exception. 
Each task has two termination handlers, a fall-back handler  and a specific handler . The specific handler 
applies only to the task itself, while the fall-back handl er applies only to the dependent tasks of the task. A 
handler is said to be set if it is associated with a nonnull va lue of type Termination_Handler, and cleared  
otherwise. When a task is created, its speci fic handler and fall-back handler are cleared. 
The procedure Set_Dependents_Fallback_Handler change s the fall-back handler for the calling task: if 
Handler is null, that fall-back handler is cleared; otherwise, it is set to be Handler. all. If a fall-back handler 
had previously been set it is replaced. 
The function Current_Task_Fallback_Handler returns the fall-back handler that is currently set for the 
calling task, if one is set; otherwise, it returns null. 
The procedure Set_Specific_Handler changes the specific handler for the task identified by T: if Handler 
is null, that specific handler is cleared; otherwise, it is set to be Handler. all. If a specific handler had 
previously been set it is replaced. 
The function Specific_Handler returns the specific handler that is currently set for the task identified by T, 
if one is set; otherwise, it returns null. 
As part of the finalization of a task_body , after performing the actions specified in 7.6 for finalization of a 
master, the specific handler for the task, if one is se t, is executed. If the specific handler is cleared, a 
search for a fall-back handler proceeds by recursivel y following the master relationship for the task. If a 
task is found whose fall-back handler is set, that handler is executed; otherwise, no handler is executed. 
For Set_Specific_Handler or Specific_Handler, Tasking_E rror is raised if the task identified by T has 
already terminated. Program_Error is raised if the va lue of T is Ada.Task_Ide ntification.Null_Task_Id. 
An exception propagated from a handler that is invoked as  part of the termination of a task has no effect. 
Erroneous Execution 
For a call of Set_Specific_Handler or Specific_Handler , if the task identified by T no longer exists, the 
execution of the program is erroneous.  9/2 
10/3 
11/3 
12/3 
13/3 
14/2 
15/2 
16/2 
17/2 

Ada Reference Manual — 2012 Edition 
627      13 December 2012 Real-Time Systems   D Annex D 
(normative)  
Real-Time Systems 
This Annex specifies additional characteristics of Ada implementations intended for real-time systems 
software. To conform to this Annex, an implemen tation shall also conform to the Systems Programming 
Annex.  
Metrics 
The metrics are documentation requirements; an im plementation shall document the values of the 
language-defined metrics for at least one configurati on of hardware or an underlying system supported by 
the implementation, and shall document th e details of that configuration.  
The metrics do not necessarily yield a simple number. For some, a range is more suitable, for others a 
formula dependent on some pa rameter is appropriate, and for others, it may be more suitable to break the 
metric into several cases. Unless specified otherwise, the metrics in this annex are expressed in processor 
clock cycles. For metrics that require documenta tion of an upper bound, if there is no upper bound, the 
implementation shall report th at the metric is unbounded.  
NOTES 
1  The specification of the metrics makes a distinction between upper bounds and simple execution times. Where something is just specified as “the execution time of” a piece of  code, this leaves one the freedom to choose a 
nonpathological case. This kind of metric is of the form “there exists a program such that the value of the metric is V”. Conversely, the meaning of upper bounds is “there is no program such that the value of the metric is greater than V”. This kind of metric can only be partially tested, by finding the value of V for one or more test programs. 
2  The metrics do not cover the whole language; they are limited to features that are specified in Annex C, “Systems 
Programming” and in this Annex. The metrics are intended to provide guidance to potential users as to whether a particular implementation of such a feature is going to be adequate for a particular real-time application. As such, the metrics are aimed at known implementation choices that can result in significant performance differences. 
3  The purpose of the metrics is not necessarily to provide fine-grained quantitative results or to serve as a comparison 
between different implementations on the same or different platforms. Instead, their goal is rather qualitative; to define a standard set of approximate values that can be measured and used to estimate the general suitability of an implementation, or to evaluate the comparative utility of certain features of an implementation for a particular real-time application. 
D.1 Task Priorities 
This subclause specifies the priority  model for real-time systems. In addition, the methods for specifying 
priorities are defined.  
Paragraphs 2 through 6 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
For a task type (including the anonymous type of a single_task_declaration ), protected type (including 
the anonymous type of a single_protected_declaration ), or subprogram, the following language-defined 
representation aspects may be specified: 
Priority The aspect Priority is an expression , which shall be of type Integer. 
Interrupt_Priority 
 The aspect Interrupt_Priority is an expression , which shall be of type Integer. 1 
2 
3 
4 
5 
6 
1/3 
6.1/3 
6.2/3 
6.3/3 
Ada Reference Manual — 2012 Edition 
D.1   Task Priorities 13 December 2012      628 Legality Rules 
This paragraph was deleted.  
If the Priority aspect is sp ecified for a subprogram, the expression  shall be static, and its value shall be in 
the range of System.Priority.  
At most one of the Priority and Interrupt_Prior ity aspects may be specified for a given entity. 
Neither of the Priority or Interrupt_Priority aspect s shall be specified for a synchronized interface type. 
Static Semantics 
The following declarations exist in package System:  
subtype Any_Priority is Integer range implementation-defined ; 
subtype Priority is Any_Priority 
   range Any_Priority'First .. implementation-defined ; 
subtype Interrupt_Priority is Any_Priority 
   range Priority'Last+1 .. Any_Priority'Last; 
Default_Priority : constant  Priority := (Priority'First + Priority'Last)/2; 
The full range of priority values supported by an impl ementation is specified by the subtype Any_Priority. 
The subrange of priority values that are high enough to  require the blocking of one or more interrupts is 
specified by the subtype Interrupt_Priority. The subr ange of priority values below System.Interrupt_-
Priority'First is specified by  the subtype System.Priority. 
This paragraph was deleted.  
Dynamic Semantics 
The Priority aspect has no effect if it is specified  for a subprogram other than  the main subprogram; the 
Priority value is not associated with any task. 
A task priority  is an integer value that indicates a degr ee of urgency and is the basis for resolving 
competing demands of tasks for resources. Unless otherwise specified, whenever tasks compete for processors or other implementation- defined resources, the resources are allocated to the task with the 
highest priority value. The base priority  of a task is the priority with which it was created, or to which it 
was later set by Dynamic_Priorities.Set_Priority  (see D.5). At all times, a task also has an active priority , 
which generally reflects its base priority as we ll as any priority it inhe rits from other sources. Priority 
inheritance  is the process by which the priority of a task or other entity (e.g. a protected object; see D.3) is 
used in the evaluation of another task's active priority.  
The effect of specifying a Priority or Interr upt_Priority aspect for a protected type or 
single_protected_declaration  is discussed in D.3. 
The expression  specified for the Priority or Interrupt_Priority aspect of a task is evaluated for each task 
object (see 9.1). For the Priority aspect, the value of the expression  is converted to the subtype Priority; 
for the Interrupt_Priority aspect, this  value is converted to the subtype Any_Priority. The priority value is 
then associated with the task object whos e task declaration specifies the aspect.  
Likewise, the priority value is associated with the envi ronment task if the aspect is specified for the main 
subprogram. 
The initial value of a task's base priority is speci fied by default or by means of a Priority or 
Interrupt_Priority aspect. After a task is created, its  base priority can be changed only by a call to 
Dynamic_Priorities.Set_Priority (see D.5). The initial base priority of a task in the absence of an aspect is 
the base priority of the task that creates it at the time of creation (see 9.1). If the aspect Priority is not 7/3 
8/3 
8.1/3 
8.2/3 
9 
10 
11 
12 
13/3 
14/3 
15 
16/3 
17/3 
18/3 
19/3 
Ada Reference Manual — 2012 Edition 
629      13 December 2012 Task Priorities   D.1 specified for the main subprogram, the initial ba se priority of the environment task is 
System.Default_Priority. The task's active priority is used when the task competes for processors. 
Similarly, the task's active priority is used to  determine the task's position in any queue when 
Priority_Queuing is specified (see D.4). 
At any time, the active priority of a task is the maximu m of all the priorities the task is inheriting at that 
instant. For a task that is not held (see D.11), its ba se priority is a source of priority inheritance unless 
otherwise specified for a particular task dispatchi ng policy. Other sources of priority inheritance are 
specified under the following conditions:  
• During activation, a task being activated inherits  the active priority that  its activator (see 9.2) 
had at the time the activation was initiated. 
• During rendezvous, the task accepting the entry call inherits the priority of the entry call (see 
9.5.3 and D.4). 
• During a protected action on a protected object, a task inherits the ceiling priority of the 
protected object (see 9.5 and D.3). 
In all of these cases, the priority ceases to be inherited as soon as the condition calling for the inheritance 
no longer exists. 
Implementation Requirements 
The range of System.Interrupt_Priority  shall include at least one value. 
The range of System.Priority sh all include at least 30 values. 
NOTES 
4  The priority expression can include references to discriminants of the enclosing type. 
5  It is a consequence of the active priority rules that at the point when a task stops inheriting a priority from another 
source, its active priority is re-evaluated. This is in addition to other instances described in this Annex for such re-evaluation. 
6  An implementation may provide a nonstandard mode in which tasks inherit priorities under conditions other than those 
specified above.  
D.2 Priority Scheduling 
This subclause describes the rules that determine whic h task is selected for execution when more than one 
task is ready (see 9).  
D.2.1 The Task Dispatching Model 
The task dispatching model specifies task scheduling, based on conceptual priority-ordered ready queues.  
Static Semantics 
The following language-defined library package exists:  
package Ada.Dispatching is 
  pragma Preelaborate(Dispatching); 
  procedure  Yield; 
  Dispatching_Policy_Error : exception ; 
end Ada.Dispatching; 
Dispatching serves as the parent of other language-def ined library units concerned with task dispatching. 20/2 
21/1 
22/1 
23 24 
25 
26 
27 
28 
29/3 
1/3 
1/2 
1.1/2 
1.2/3 
1.3/3 
1.4/3 
1.5/2 
Ada Reference Manual — 2012 Edition 
D.2.1    The Task Dispatching Model 13 December 2012      630 Dynamic Semantics 
A task can become a running task  only if it is ready (see 9) and the execution resources required by that 
task are available. Processors are allocated to tasks based on each task's active priority. 
It is implementation defined whether, on a multiprocesso r, a task that is waiting for access to a protected 
object keeps its processor busy.  
Task dispatching  is the process by which one ready task is selected for execution on a processor. This 
selection is done at certain points during the execution of a task called task dispatching points . A task 
reaches a task dispatching point whenever it becomes blocked, and when it terminates. Other task dispatching points are defined throughout this Annex for specific policies.  
Task dispatching policies  are specified in terms of conceptual ready queues  and task states. A ready queue 
is an ordered list of ready tasks. Th e first position in a queue is called the head of the queue , and the last 
position is called the tail of the queue . A task is ready  if it is in a ready queue, or if it is running. Each 
processor has one ready queue for each priority value.  At any instant, each ready queue of a processor 
contains exactly the set of tasks of that priority th at are ready for execution on that processor, but are not 
running on any processor; that is, those tasks that ar e ready, are not running on any processor, and can be 
executed using that processor and other available re sources. A task can be on the ready queues of more 
than one processor.  
Each processor also has one running task , which is the task currently being executed by that processor. 
Whenever a task running on a processor reaches a task dispatching point it goes back to one or more ready queues; a task (possibly the same task) is then selected  to run on that processor. The task selected is the 
one at the head of the highest priority nonempty r eady queue; this task is then removed from all ready 
queues to which it belongs.  
A call of Yield is a task dispatching point. Yiel d is a potentially blocking operation (see 9.5.1).  
This paragraph was deleted.  
Implementation Permissions 
An implementation is allowed to define additional resources as execution res ources, and to define the 
corresponding allocation policies for them. Such resour ces may have an implementation-defined effect on 
task dispatching.  
An implementation may place implementation-defined restrictions on tasks whose active priority is in the 
Interrupt_Priority range.  
For optimization purposes, an implementation may alter th e points at which task dispatching occurs, in an 
implementation-defined manner. However, a delay_statement  always corresponds to at least one task 
dispatching point. 
NOTES 
7  Clause 9 specifies under which circumstances a task becomes ready. The ready state is affected by the rules for task activation and termination, delay statements, and entry calls. When a task is not ready, it is said to be blocked. 
8  An example of a possible implementation-defined execution resource is a page of physical memory, which needs to be 
loaded with a particular page of virtual memory before a task can continue execution. 
9  The ready queues are purely conceptual; there is no requirement that such lists physically exist in an implementation. 10  While a task is running, it is not on any ready queue. Any time the task that is running on a processor is added to a 
ready queue, a new running task is selected for that processor. 
11  In a multiprocessor system, a task can be on the ready queues of more than one processor. At the extreme, if several 
processors share the same set of ready tasks, the contents of their ready queues is identical, and so they can be viewed as 2/2 
3 
4/2 
5/2 
6/2 
7/3 
8/2 
9/2 
10 
10.1/2 
11/3 
12 13 
14 
15 
Ada Reference Manual — 2012 Edition 
631      13 December 2012 The Task Dispatching Model   D.2.1 sharing one ready queue, and can be implemented that way. Thus, the dispatching model covers multiprocessors where 
dispatching is implemented using a single ready queue, as well as those with separate dispatching domains. 
12  The priority of a task is determined by rules specified in this subclause, and under D.1, “Task Priorities”, D.3, 
“Priority Ceiling Locking”, and D.5, “Dynamic Priorities”. 
13  The setting of a task's base priority as a result of a call to Set_Priority does not always take effect immediately when 
Set_Priority is called. The effect of setting the task's base priority is deferred while the affected task performs a protected  
action. 
D.2.2 Task Dispatching Pragmas 
This subclause allows a single task dispatching policy to be defined for all priorities, or the range of 
priorities to be split into subranges that ar e assigned individual dispatching policies.  
Syntax 
The form of a pragma  Task_Dispatching_Polic y is as follows:  
  pragma  Task_Dispatching_Policy( policy_ identifier ); 
The form of a pragma  Priority_Specific_Dispat ching is as follows:  
  pragma  Priority_Specific_Dispatching ( 
     policy_ identifier , first_priority_ expression , last_priority_ expression ); 
Name Resolution Rules 
The expected type for first_priority_ expression  and last_priority_ expression  is Integer.  
Legality Rules 
The policy_ identifier  used in a pragma  Task_Dispatching_Policy shall be the name of a task dispatching 
policy.  
The policy_ identifier  used in a pragma  Priority_Specific_Dispatching shall be the name of a task 
dispatching policy. 
Both first_priority_ expression  and last_priority_ expression  shall be static expressions in the range of 
System.Any_Priority; last_priority_ expression  shall have a value greater than or equal to first_priority_ -
expression . 
Static Semantics 
Pragma  Task_Dispatching_Policy specifies th e single task dispatching policy. 
Pragma  Priority_Specific_Dispatching specifies the task dispatching policy for the specified range of 
priorities. Tasks with base priorities with in the range of priorities specified in a 
Priority_Specific_Dispatching pragma have their ac tive priorities determined according to the specified 
dispatching policy. Tasks with active priorities within the range of priorities specified in a 
Priority_Specific_Dispatching pragma are dispatched  according to the specified dispatching policy.  
If a partition contains one or more Priority_Specifi c_Dispatching pragmas, the dispatching policy for 
priorities not covered by any Priority_Specific_ Dispatching pragmas is FIFO_Within_Priorities. 
Post-Compilation Rules 
A Task_Dispatching_Policy pragma is a configuration pragma. A Priority_Specific_Dispatching pragma is 
a configuration pragma.  16 
17/2 
1/3 
2 
3 
3.1/2 
3.2/2 
3.3/2 
4/2 
4.1/2 4.2/2 
4.3/2 
4.4/2 
4.5/3 
5/2 
Ada Reference Manual — 2012 Edition 
D.2.2    Task Dispatching Pragmas 13 December 2012      632 The priority ranges specified in more than one Prio rity_Specific_Dispatching pragma within the same 
partition shall not be overlapping. 
If a partition contains one or more Priority_Sp ecific_Dispatching pragmas it shall not contain a 
Task_Dispatching_Policy pragma. 
This paragraph was deleted.  
Dynamic Semantics 
A task dispatching policy  specifies the details of task dispatching that are not covered by the basic task 
dispatching model. These rules govern when tasks are inserted into and deleted from the ready queues. A 
single task dispatching policy is specified by a Task_Dispatching_Policy pragma. Pragma 
Priority_Specific_Dispatching assigns distinct dispat ching policies to subranges of System.Any_Priority. 
If neither pragma  applies to any of the program units comprising a partition, the task dispatching policy 
for that partition is unspecified. 
If a partition contains one or more Priority_Specific_Di spatching pragmas, a task dispatching point occurs 
for the currently running task of a processor whenever  there is a nonempty ready queue for that processor 
with a higher priority than the priority of the running task. 
A task that has its base priority changed may m ove from one dispatching po licy to another. It is 
immediately subject to the new dispatching policy. 
Paragraphs 7 through 13 were moved to D.2.3.   
Implementation Requirements 
An implementation shall allow, for a single partition, both the locking policy (see D.3) to be specified as 
Ceiling_Locking and also one or more Priority_S pecific_Dispatching pragmas to be given.  
Documentation Requirements 
Paragraphs 14 through 16 were moved to D.2.3.   
Implementation Permissions 
Implementations are allowed to define  other task dispatching policies, but need not support more than one 
task dispatching policy per partition. 
An implementation need not support pragma  Priority_Specific_Dispatching if  it is infeasible to support it 
in the target environment. 
NOTES 
Paragraphs 19 through 21 were deleted.   
D.2.3 Preemptive Dispatching 
This subclause defines a preemp tive task dispatching policy.  
Static Semantics 
The policy_ identifier  FIFO_Within_Priorities is a task dispatching policy. 
Dynamic Semantics 
When FIFO_Within_Priorities is in effect, modifica tions to the ready queues occur only as follows: 5.1/2 
5.2/2 
6/2 
7/2 
7.1/2 
7.2/3 
7.3/2 
14.1/2 
18/2 
19/2 
1/3 
2/2 
3/2 
Ada Reference Manual — 2012 Edition 
633      13 December 2012 Preemptive Dispatching   D.2.3 • When a blocked task becomes ready, it is added at the tail of the ready queue for its active 
priority. 
• When the active priority of a ready task that is not running changes, or the setting of its base 
priority takes effect, the task is removed from th e ready queue for its old active priority and is 
added at the tail of the ready queue for its ne w active priority, except in the case where the 
active priority is lowered due to the loss of inher ited priority, in which case the task is added at 
the head of the ready queue for its new active priority. 
• When the setting of the base priority of a running ta sk takes effect, the task is added to the tail of 
the ready queue for its active priority. 
• When a task executes a delay_statement  that does not result in blocking, it is added to the tail of 
the ready queue for its active priority.  
Each of the events specified above is  a task dispatching point (see D.2.1). 
A task dispatching point occurs for the currently runni ng task of a processor whenever there is a nonempty 
ready queue for that processor with a higher priority than the priority of the running task. The currently 
running task is said to be preempted  and it is added at the head of th e ready queue for its active priority. 
Implementation Requirements 
An implementation shall allow, for a single partition, both the task dispatching policy to be specified as 
FIFO_Within_Priorities and also the locking policy (see D.3) to be specified as Ceiling_Locking.  
Documentation Requirements 
Priority inversion  is the duration for which a task remains at the head of the highest priority nonempty 
ready queue while the processor executes a lower priority task. The implementation shall document: 
• The maximum priority inversion a user task can  experience due to activity of the implementation 
(on behalf of lower priority tasks), and  
• whether execution of a task can be preempted  by the implementation processing of delay 
expirations for lower priority tasks, and if so, for how long.  
NOTES 
14  If the active priority of a running task is lowered due to loss of inherited priority (as it is on completion of a protecte d 
operation) and there is a ready task of the same active priority that is not running, the running task continues to run (provided that there is no higher priority task). 
15  Setting the base priority of a ready task causes the task to move to the tail of the queue for its active priority, 
regardless of whether the active priority of the task actually changes. 
D.2.4 Non-Preemptive Dispatching 
This subclause defines a non-preemp tive task dispatching policy.  
Static Semantics 
The policy_ identifier  Non_Preemptive_FIFO_Within_Prioritie s is a task dispatching policy. 
The following language-defined library package exists:  
package Ada.Dispatching.Non_Preemptive is 
  pragma Preelaborate(Non_Preemptive); 
  procedure  Yield_To_Higher; 
  procedure  Yield_To_Same_Or_Higher renames Yield; 
end Ada.Dispatching.Non_Preemptive; 4/2 
5/2 
6/2 
7/2 8/2 
9/2 
10/2 
11/2 
12/2 
13/2 
14/2 
15/2 
1/3 
2/2 
2.1/3 
2.2/3 
Ada Reference Manual — 2012 Edition 
D.2.4    Non-Preemptive Dispatch ing 13 December 2012      634 A call of Yield_To_Higher is a task dispatching point for this policy. If the task at the head of the highest 
priority ready queue has a higher active priority than  the calling task, then the calling task is preempted. 
Legality Rules 
Non_Preemptive_FIFO_Within_Priorities shall not be specified as the policy_ identifier  of pragma  
Priority_Specific_Dispatching (see D.2.2). 
Dynamic Semantics 
When Non_Preemptive_FIFO_Within_Pri orities is in effect, modifications to the ready queues occur only 
as follows: 
• When a blocked task becomes ready, it is added at the tail of the ready queue for its active 
priority. 
• When the active priority of a ready task that is not running changes, or the setting of its base 
priority takes effect, the task is removed from th e ready queue for its old active priority and is 
added at the tail of the ready queue for its new active priority. 
• When the setting of the base priority of a running ta sk takes effect, the task is added to the tail of 
the ready queue for its active priority. 
• When a task executes a delay_statement  that does not result in blocking, it is added to the tail of 
the ready queue for its active priority.  
For this policy, blocking or termination of a task, a delay_statement , a call to Yield_To_Higher, and a 
call to Yield_To_Same_Or_Higher or Yield are th e only task dispatching points (see D.2.1).  
Implementation Requirements 
An implementation shall allow, for a single partition, both the task dispatching policy to be specified as 
Non_Preemptive_FIFO_Within_Priorities and also the locking policy (see D.3) to be specified as 
Ceiling_Locking.  
Implementation Permissions 
Since implementations are allowed to round all ce iling priorities in subrange System.Priority to 
System.Priority'Last (see D.3), an implementati on may allow a task of a partition using the 
Non_Premptive_FIFO_Within_Priorities policy to execute within a prot ected object without raising its 
active priority provided the associated protected unit does not contain any subprograms with aspects 
Interrupt_Handler or Attach_Handler specified, nor doe s the unit have aspect Interrupt_Priority  specified. 
When the locking policy (see D.3) is Ceiling_Locki ng, an implementation taking advantage of this 
permission shall ensure that a call to Yield_to_Higher th at occurs within a protected action uses the ceiling 
priority of the protected object (rather than the activ e priority of the task) when determining whether to 
preempt the task.  2.3/3 
3/2 
4/2 
5/2 
6/2 
7/2 
8/2 9/3 
10/2 
11/3 
Ada Reference Manual — 2012 Edition 
635      13 December 2012 Round Robin Dispatching   D.2.5 D.2.5 Round Robin Dispatching 
This subclause defines the task dispatching policy Round_Robin_Within_Priorities and the package 
Round_Robin.  
Static Semantics 
The policy _identifier  Round_Robin_Within_Priorities is a task dispatching policy. 
The following language-defined library package exists:  
with System; 
with Ada.Real_Time; 
package Ada.Dispatching.Round_Robin is 
  Default_Quantum : constant  Ada.Real_Time.Time_Span := 
             implementation-defined ; 
  procedure  Set_Quantum (Pri     : in System.Priority; 
                         Quantum : in Ada.Real_Time.Time_Span); 
  procedure  Set_Quantum (Low, High : in System.Priority; 
                         Quantum   : in Ada.Real_Time.Time_Span); 
  function  Actual_Quantum (Pri : System.Priority) 
             return Ada.Real_Time.Time_Span; 
  function  Is_Round_Robin (Pri : System.Priority) return Boolean; 
end Ada.Dispatching.Round_Robin; 
When task dispatching policy Round_Robin_Within_Prioritie s is the single policy in effect for a partition, 
each task with priority in the range of System.I nterrupt_Priority is dispatched according to policy 
FIFO_Within_Priorities. 
Dynamic Semantics 
The procedures Set_Quantum set the required Quantum va lue for a single priority level Pri or a range of 
priority levels Low .. High. If no quantum is set fo r a Round Robin priority level, Default_Quantum is 
used. 
The function Actual_Quantum returns the actual quantum used by the implementation for the priority level 
Pri. 
The function Is_Round_Robin returns True if priority  Pri is covered by task dispatching policy 
Round_Robin_Within_Priorities; othe rwise, it returns False. 
A call of Actual_Quantum or Set_Quantum raises exception Dispatching.Dispatching_Policy_Error if a 
predefined policy other than Round_Robin_Within_Priorities applies to the specified priority or any of the 
priorities in the specified range. 
For Round_Robin_Within_Priorities, the dispatching ru les for FIFO_Within_Priorities apply with the 
following additional rules: 
• When a task is added or moved to the tail of the ready queue for its base priority, it has an 
execution time budget equal to the quantum for that priority level. This will also occur when a 
blocked task becomes executable again. 
• When a task is preempted (by a higher priority ta sk) and is added to the head of the ready queue 
for its priority level, it retains its remaining budget. 
• While a task is executing, its budget is decreas ed by the amount of ex ecution time it uses. The 
accuracy of this accounting is the same as that for execution time clocks (see D.14).  1/3 
2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
8/3 9/2 
10/2 
11/2 
12/2 
13/2 
Ada Reference Manual — 2012 Edition 
D.2.5    Round Robin Dispatching 13 December 2012      636 • When a task has exhausted its budget and is wit hout an inherited priority (and is not executing 
within a protected operation), it is moved to the tail of the ready queue for its priority level. This 
is a task dispatching point. 
Implementation Requirements 
An implementation shall allow, for a single partition, both the task dispatching policy to be specified as 
Round_Robin_Within_Priorities and also the locking policy (see D.3) to be specified as Ceiling_Locking.  
Documentation Requirements 
An implementation shall document the quantum values supported.  
An implementation shall document the accuracy with which it detects the exhaustion of the budget of a 
task.  
NOTES 
16  Due to implementation constraints, the quantum value returned by Actual_Quantum might not be identical to that set with Set_Quantum. 
17  A task that executes continuously with an inherited priority will not be subject to round robin dispatching. 
D.2.6 Earliest Deadline First Dispatching 
The deadline of a task is an indication of the urgency of the task; it represents a point on an ideal physical 
time line. The deadline might affect how resources are allocated to the task. 
This subclause defines a package for representing th e deadline of a task and a dispatching policy that 
defines Earliest Deadline First (EDF) dispatching. An aspect is defined to assign an initial deadline to a 
task. 
Paragraphs 3 through 6 were moved to Annex J, “Obsolescent Features”.   
Static Semantics 
The policy_ identifier  EDF_Across_Priorities is a task dispatching policy. 
The following language-defined library package exists:  
with Ada.Real_Time; 
with Ada.Task_Identification; 
package Ada.Dispatching.EDF is 
  subtype Deadline is Ada.Real_Time.Time; 
  Default_Deadline : constant  Deadline := 
              Ada.Real_Time.Time_Last;   procedure  Set_Deadline (D : in Deadline; 
              T : in Ada.Task_Identification.Task_Id := 
              Ada.Task_Identification.Current_Task);   procedure  Delay_Until_And_Set_Deadline ( 
              Delay_Until_Time : in Ada.Real_Time.Time; 
              Deadline_Offset : in Ada.Real_Time.Time_Span); 
  function  Get_Deadline (T : Ada.Task_Identification.Task_Id := 
              Ada.Task_Identification.Current_Task) return Deadline; 
end Ada.Dispatching.EDF; 
For a task type (including the anonymous type of a single_task_declaration ) or subprogram, the following 
language-defined representation aspect may be specified: 
Relative_Deadline 
 The aspect Relative_Deadline is an expression , which shall be of type 
Real_Time.Time_Span. 14/2 
15/2 
16/2 
17/2 
18/2 
19/2 
1/2 
2/3 
7/2 
8/2 
9/2 
9.1/3 
9.2/3 
Ada Reference Manual — 2012 Edition 
637      13 December 2012 Earliest  Deadline First Dispatching   D.2.6 Legality Rules 
The Relative_Deadline aspect shall not be  specified on a task interface type.  
Post-Compilation Rules 
If the EDF_Across_Priorities policy is specified for a partition, then the Ceiling_Locking policy (see D.3) 
shall also be specified for the partition. 
If the EDF_Across_Priorities policy appears in a Prior ity_Specific_Dispatching pragma (see D.2.2) in a 
partition, then the Ceiling_Locking policy (see D.3)  shall also be specified for the partition. 
Dynamic Semantics 
The Relative_Deadline aspect has no effect if it is  specified for a subprogram other than the main 
subprogram. 
The initial absolute deadline of a task for which asp ect Relative_Deadline is sp ecified is the value of 
Real_Time.Clock + the expression  that is the value of the aspect, where this entire expression, including 
the call of Real_Time.Clock, is evaluated between task creation and the start of its activation. If the aspect 
Relative_Deadline is not specified, then the initial absolute deadlin e of a task is the value of 
Default_Deadline. The environment task is also given an initial deadline by this rule, using the value of 
the Relative_Deadline aspect of the main subprogram (if any). 
The procedure Set_Deadline changes the absolute deadline of the task  to D. The function Get_Deadline 
returns the absolute deadline of the task. 
The procedure Delay_Until_And_Set_Deadline delays  the calling task until time Delay_Until_Time. 
When the task becomes runnable again it will ha ve deadline Delay_Until_Ti me + Deadline_Offset. 
On a system with a single processor, the setting of  the deadline of a task to the new value occurs 
immediately at the first point that is outside the execution of a protected action. If the task is currently on a ready queue it is removed and re-entered on to the r eady queue determined by the rules defined below. 
When EDF_Across_Priorities is specified for priority range Low..High  all ready queues in this range are 
ordered by deadline. The task at the head of a queue is the one with the earliest deadline. 
A task dispatching point occurs for the currently running task T to which policy EDF_Across_Priorities 
applies: 
• when a change to the deadline of T occurs; 
• there is a task on the ready queue for the active priority of T with a deadline earlier than the 
deadline of T; or 
• there is a nonempty ready queue for that processo r with a higher priority than the active priority 
of the running task. 
In these cases, the currently running task  is said to be preempted and is returned to the ready queue for its 
active priority. 
For a task T to which policy EDF_Across_Priorities applies, th e base priority is not a source of priority 
inheritance; the active priority when first activated or  while it is blocked is defined as the maximum of the 
following: 
• the lowest priority in the range specified as EDF_Across_Priorities that includes the base 
priority of T; 
• the priorities, if any, currently inherited by T; 9.3/3 
10/2 
11/2 
12/3 
13/3 
14/2 
15/2 16/2 
17/2 
18/2 
19/2 
20/2 
21/2 22/2 
23/2 
24/2 
25/2 
Ada Reference Manual — 2012 Edition 
D.2.6    Earliest Deadline First Disp atching 13 December 2012      638 • the highest priority P, if any, less than the base priority of T such that one or more tasks are 
executing within a protected object with ceiling priority P and task T has an earlier deadline than 
all such tasks; and furthermore T has an earlier deadline than all other tasks on ready queues 
with priorities in the given EDF_Across_Prio rities range that are strictly less than P.  
When a task T is first activated or becomes unblocked, it is  added to the ready queue corresponding to this 
active priority. Until it becomes blocked again, the active priority of T remains no less than this value; it 
will exceed this value only while it is inheriting a higher priority. 
When the setting of the base priority of a ready task  takes effect and the new priority is in a range 
specified as EDF_Across_Priorities, the task is a dded to the ready queue corresponding to its new active 
priority, as determined above. 
For all the operations defined in Disp atching.EDF, Tasking_Error is raised if the task identified by T has 
terminated. Program_Error is raised if  the value of T is Null_Task_Id. 
Bounded (Run-Time) Errors 
If EDF_Across_Priorities is specified for priority range Low..High , it is a bounded error to declare a 
protected object with ceiling priority Low or to assign the value Low to attribute 'Priority. In either case 
either Program_Error is raised or the ceiling of the protected object is assigned the value Low+1. 
Erroneous Execution 
If a value of Task_Id is passed as a parameter to  any of the subprograms of this package and the 
corresponding task object no longer exists, th e execution of the program is erroneous. 
Documentation Requirements 
On a multiprocessor, the implementation shall documen t any conditions that cause the completion of the 
setting of the deadline of a task to be delayed late r than what is specified for a single processor.  
NOTES 
18  If two adjacent priority ranges, A..B and B+1..C are specified to have policy EDF_Across_Priorities, then this is not 
equivalent to this policy being specified for the single range, A..C. 
19  The above rules implement the preemption-level protocol (also called Stack Resource Policy protocol) for resource 
sharing under EDF dispatching. The preemption-level for a task is denoted by its base priority. The definition of a ceiling preemption-level for a protected object follows the existing rules for ceiling locking. 
D.3 Priority Ceiling Locking 
This subclause specifies the inter actions between priority task scheduling and protected object ceilings. 
This interaction is based on the concept of the ceiling priority  of a protected object.  
Syntax 
The form of a pragma  Locking_Policy is as follows:  
  pragma  Locking_Policy( policy_ identifier );  
Legality Rules 
The policy_ identifier  shall either be Ceiling_Locking or an implementation-defined identifier .  
Post-Compilation Rules 
A Locking_Policy pragma is a configuration pragma. 26/3 
27/2 
28/2 
29/2 
30/2 
31/2 
32/2 
33/3 
34/2 
1/3 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
639      13 December 2012 Priority Ceiling Locking   D.3 Dynamic Semantics 
A locking policy specifies the details of protected object  locking. All protected objects have a priority. The 
locking policy specifies the meaning of the priority of a protected object, and the relationships between 
these priorities and task priorities. In addition, the policy specifies the state of a task when it executes a 
protected action, and how its active prior ity is affected by the locking. The locking policy  is specified by a 
Locking_Policy pragma. For implemen tation-defined locking policies, the meaning of the priority of a 
protected object is implementation defined. If no Lock ing_Policy pragma applies to any of the program 
units comprising a partition, the locking policy for that pa rtition, as well as the meaning of the priority of a 
protected object, are implementation defined.  
The expression  specified for the Priority or Interrupt_Priority aspect (see D.1) is evaluated as part of the 
creation of the corresponding protected object and c onverted to the subtype System.Any_Priority or 
System.Interrupt_Priority, respectively. The value of the expression is the initial priority of the 
corresponding protected object. If no Priority or Interr upt_Priority aspect is specified for a protected 
object, the initial priority is speci fied by the locking policy.  
There is one predefined locking policy, Ceiling_L ocking; this policy is defined as follows:  
• Every protected object has a ceiling priority , which is determined by either a Priority or 
Interrupt_Priority aspect as defined in D.1, or by  assignment to the Priority attribute as described 
in D.5.2. The ceiling priority of a protected obj ect (or ceiling, for short) is an upper bound on the 
active priority a task can have when it calls protected operations of that protected object. 
• The initial ceiling priority of a protected object is equal to the initial priority for that object. 
• If an Interrupt_Handler or Attach_Handler as pect (see C.3.1) is specified for a protected 
subprogram of a protected type that does not have  the  Interrupt_Priority aspect specified, the 
initial priority of protected objects of that type is  implementation defined, but in the range of the 
subtype System.Interrupt_Priority.  
• If neither aspect Priority nor Interrupt_Priority is specified for a protected type, and no protected 
subprogram of the type has aspect Interrupt_Ha ndler or Attach_Handler specified, then the 
initial priority of the corresponding prot ected object is System.Priority'Last. 
• While a task executes a protected action, it i nherits the ceiling priority of the corresponding 
protected object. 
• When a task calls a protected operation, a check is made that its active priority is not higher than 
the ceiling of the corresponding protected object; Pr ogram_Error is raised if this check fails. 
Bounded (Run-Time) Errors 
Following any change of priority, it is a bounded error fo r the active priority of any task with a call queued 
on an entry of a protected object to be higher than th e ceiling priority of the protected object. In this case 
one of the following applies: 
• at any time prior to executing the entry body Program_Error is raised in the calling task;  
• when the entry is open the entry body is execute d at the ceiling priority of the protected object; 
• when the entry is open the entry body is execute d at the ceiling priority of the protected object 
and then Program_Error is raised in the calling task; or  
• when the entry is open the entry body is execute d at the ceiling priority of the protected object 
that was in effect when the entry call was queued.  6/2 
6.1/3 
7 
8/3 
9/2 
10/3 
11/3 
12 
13 
13.1/2 
13.2/2 
13.3/2 13.4/2 
13.5/2 
Ada Reference Manual — 2012 Edition 
D.3   Priority Ceiling Locking 13 December 2012      640 Implementation Permissions 
The implementation is allowed to round all ceilings in a certain subrange of System.Priority or 
System.Interrupt_Priority up to the top of that subrange, uniformly.  
Implementations are allowed to define other locking policies, but need not support more than one locking 
policy per partition. 
Since implementations are allowed to place restrictions on code that runs at an interrupt-level active 
priority (see C.3.1 and D.2.1), th e implementation may im plement a language feature in terms of a 
protected object with an implementati on-defined ceiling, but the ceiling shall be no less than Priority'Last.  
Implementation Advice 
The implementation should use name s that end with “_Locking” for implementation-defined locking 
policies. 
NOTES 
20  While a task executes in a protected action, it can be preempted only by tasks whose active priorities are higher than the ceiling priority of the protected object. 
21  If a protected object has a ceiling priority in the range of Interrupt_Priority, certain interrupts are blocked while 
protected actions of that object execute. In the extreme, if the ceiling is Interrupt_Priority'Last, all blockable interrupts a re 
blocked during that time. 
22  The ceiling priority of a protected object has to be in the Interrupt_Priority range if one of its procedures is to be used  
as an interrupt handler (see C.3). 
23  When specifying the ceiling of a protected object, one should choose a value that is at least as high as the highest 
active priority at which tasks can be executing when they call protected operations of that object. In determining this value the following factors, which can affect active priority, should be considered: the effect of Set_Priority, nested protected operations, entry calls, task activation, and other implementation-defined factors. 
24  Attaching a protected procedure whose ceiling is below the interrupt hardware priority to an interrupt causes the 
execution of the program to be erroneous (see C.3.1). 
25  On a single processor implementation, the ceiling priority rules guarantee that there is no possibility of deadlock 
involving only protected subprograms (excluding the case where a protected operation calls another protected operation on the same protected object). 
D.4 Entry Queuing Policies 
This subclause specifies  a mechanism for a user  to choose an entry queuing policy . It also defines two such 
policies. Other policies are implementation defined.  
Syntax 
The form of a pragma  Queuing_Policy is as follows:  
  pragma  Queuing_Policy( policy_ identifier );  
Legality Rules 
The policy_ identifier  shall be either FIFO_Queuing, Prior ity_Queuing or an implementation-defined 
identifier . 
Post-Compilation Rules 
A Queuing_Policy pragma is a configuration pragma. 14 
15/2 
16 
17 
18 
19 
20 
21 
22 
23 
1/3 
2 
3 
4 
5 
Ada Reference Manual — 2012 Edition 
641      13 December 2012 Entry Queuing Policies   D.4 Dynamic Semantics 
A queuing policy  governs the order in which tasks are queued for entry service, and the order in which 
different entry queues are considered for service. The queuing policy is specified by a Queuing_Policy 
pragma.  
Two queuing policies, FIFO_Queuing and Priority_Que uing, are language defined. If no Queuing_Policy 
pragma applies to any of the program units comprisi ng the partition, the queuing policy for that partition is 
FIFO_Queuing. The rules for this polic y are specified in 9.5.3 and 9.7.1. 
The Priority_Queuing policy is defined as follows: 
• The calls to an entry (including a member of an  entry family) are queued in an order consistent 
with the priorities of the calls. The priority of an entry call  is initialized from the active priority 
of the calling task at the time the call is made, but can change later. Within the same priority, the 
order is consistent with the calling (or requeuing, or priority setting) time (that is, a FIFO order). 
• After a call is first queued, changes to the active pr iority of a task do not affect the priority of the 
call, unless the base priority of the task is set while the task is blocked on an entry call. 
• When the base priority of a task is set (see D.5) , if the task is blocked on an entry call, and the 
call is queued, the priority of the call is update d to the new active priority of the calling task. 
This causes the call to be removed from and then  reinserted in the queue at the new active 
priority.  
• When more than one condition  of an entry_barrier  of a protected object becomes True, and more 
than one of the respective queues is nonempty, the call with the highest priority is selected. If 
more than one such call has the same prior ity, the call that is queued on the entry whose 
declaration is first in textual order in the protected_definition  is selected. For members of the 
same entry family, the one with the lower family index is selected. 
• If the expiration time of two or more open delay_alternative s is the same and no other 
accept_alternative s are open, the sequence_of_statements  of the delay_alternative  that is first 
in textual order in the selective_accept  is executed. 
• When more than one alternative of a selective_accept  is open and has queued calls, an 
alternative whose queue has the highest-priority ca ll at its head is selected. If two or more open 
alternatives have equal-priority queue d calls, then a call on the entry in the accept_alternative  
that is first in textual order in the selective_accept  is selected. 
Implementation Permissions 
Implementations are allowed to define other queuing policies, but need not support more than one queuing 
policy per partition.  
Implementations are allowed to defer the reordering of entry queues following a change of base priority of 
a task blocked on the entry call if it is not practical to reorder the queue immediately.  
Implementation Advice 
The implementation should use name s that end with “_Queuing” fo r implementation-defined queuing 
policies. 6 
7/2 
8 
9 
10/1 
11 
12 
13 
14 
15/2 
15.1/2 
16 
Ada Reference Manual — 2012 Edition 
D.5   Dynamic Priorities 13 December 2012      642 D.5 Dynamic Priorities 
This subclause describes how the priority of an entity can be modified or queried at run time.  
D.5.1 Dynamic Priorities for Tasks 
This subclause describes how the base priority of a task can be modified or queried at run time.  
Static Semantics 
The following language-defined library package exists:  
with System; 
with Ada.Task_Identification; -- See C.7.1  
package Ada.Dynamic_Priorities is 
    pragma Preelaborate(Dynamic_Priorities); 
    procedure  Set_Priority(Priority : in System.Any_Priority; 
                           T : in Ada.Task_Identification.Task_Id := 
                           Ada.Task_Identification.Current_Task); 
    function  Get_Priority (T : Ada.Task_Identification.Task_Id := 
                           Ada.Task_Identification.Current_Task)                            return System.Any_Priority; 
end Ada.Dynamic_Priorities; 
Dynamic Semantics 
The procedure Set_Priority sets the base priority of the specified task to the specified Priority value. 
Set_Priority has no effect if the task is terminated. 
The function Get_Priority returns T's current base priority. Tasking_Error is raised if the task is 
terminated.  
Program_Error is raised by Set_Priority and Ge t_Priority if T is equal to Null_Task_Id. 
On a system with a single processor, the setting of the base priority of a task T to the new value occurs 
immediately at the first point when T is outside the execution of a protected action. 
Paragraph 11 was deleted.   
Erroneous Execution 
If any subprogram in this package is  called with a parameter T that specifies a task object that no longer 
exists, the execution of th e program is erroneous.  
Documentation Requirements 
On a multiprocessor, the implementation shall documen t any conditions that cause the completion of the 
setting of the priority of a task to be delayed late r than what is specified for a single processor.  
Metrics 
The implementation shall document the following metric:  
• The execution time of a call to Set_Priority, for the nonpreempting case, in processor clock 
cycles. This is meas ured for a call that modifies the prior ity of a ready task that is not running 
(which cannot be the calling one), where the new base  priority of the affected task is lower than 
the active priority of the calling task, and the aff ected task is not on any entry queue and is not 
executing a protected operation.  1/3 
1/3 
2 
3/2 
4 
5 6 
7 
8 9 
10/2 
12 
12.1/2 
13 
14 
Ada Reference Manual — 2012 Edition 
643      13 December 2012 Dynamic Priorities for Tasks   D.5.1 NOTES 
26  Setting a task's base priority affects task dispatching. First, it can change the task's active priority. Second, under the  
FIFO_Within_Priorities policy it always causes the task to move to the tail of the ready queue corresponding to its active priority, even if the new base priority is unchanged. 
27  Under the priority queuing policy, setting a task's base priority has an effect on a queued entry call if the task is 
blocked waiting for the call. That is, setting the base priority of a task causes the priority of a queued entry call from that  
task to be updated and the call to be removed and then reinserted in the entry queue at the new priority (see D.4), unless the call originated from the 
triggering_statement  of an asynchronous_select . 
28  The effect of two or more Set_Priority calls executed in parallel on the same task is defined as executing these calls in 
some serial order. 
29  The rule for when Tasking_Error is raised for Set_Priority or Get_Priority is different from the rule for when 
Tasking_Error is raised on an entry call (see 9.5.3). In particular, querying the priority of a completed or an abnormal task is allowed, so long as the task is not yet terminated, and setting the priority of a task is allowed for any task state (including for terminated tasks). 
30  Changing the priorities of a set of tasks can be performed by a series of calls to Set_Priority for each task separately. 
For this to work reliably, it should be done within a protected operation that has high enough ceiling priority to guarantee that the operation completes without being preempted by any of the affected tasks. 
D.5.2 Dynamic Priorities for Protected Objects 
This subclause specifies how  the priority of a protected object can be modified or queried at run time.  
Static Semantics 
The following attribute is defined for a prefix  P that denotes a protected object: 
P'Priority Denotes a non-aliased component of the protected object P. This component is of type 
System.Any_Priority and its value is the priority  of P. P'Priority denotes a variable if and 
only if P denotes a variable. A reference to th is attribute shall appear only within the body 
of P.  
The initial value of this attribute is  the initial value of the priority of the protected object, and can be 
changed by an assignment.  
Dynamic Semantics 
If the locking policy Ceiling_Locking (see D.3) is in eff ect, then the ceiling priority of a protected object P 
is set to the value of P'Priority at the end of each protected action of P. 
If the locking policy Ceiling_Locking is in effect, then for a protected object P with either an 
Attach_Handler or Interrupt_Handler aspect specified for one of its procedures, a check is made that the 
value to be assigned to P'Priority is in the range System.I nterrupt_Priority. If the check fails, 
Program_Error is raised.  
Metrics 
The implementation shall document the following metric: 
• The difference in execution time of calls to th e following procedures in protected object P: 
protected  P is 
   procedure  Do_Not_Set_Ceiling (Pr : System.Any_Priority); 
   procedure  Set_Ceiling (Pr : System.Any_Priority); 
end P; 15/2 
16 
17 
18/3 
19 
1/3 
2/2 
3/2 
4/2 
5/3 
6/3 
7/2 
8/2 
9/2 
Ada Reference Manual — 2012 Edition 
D.5.2    Dynamic Priorities for Protected Objects 13 December 2012      644 protected body  P is 
   procedure  Do_Not_Set_Ceiling (Pr : System.Any_Priority) is 
   begin 
      null; 
   end; 
   procedure  Set_Ceiling (Pr : System.Any_Priority) is 
   begin 
      P'Priority := Pr;    end; 
end P; 
NOTES 
31  Since P'Priority is a normal variable, the value following an assignment to the attribute immediately reflects the new value even though its impact on the ceiling priority of P is postponed until completion of the protected action in which it is executed.  
D.6 Preemptive Abort 
This subclause specifies requirements on the immediacy with which an aborted construct is completed.  
Dynamic Semantics 
On a system with a single processor, an aborted construct is completed immediately at the first point that 
is outside the execution of an abort-deferred operation. 
Documentation Requirements 
On a multiprocessor, the implementation shall documen t any conditions that cause the completion of an 
aborted construct to be delayed later than what is specified for a single processor.  
Metrics 
The implementation shall document the following metrics:  
• The execution time, in processor clock cycles, that it takes for an abort_statement  to cause the 
completion of the aborted task. This is measured in a situation where a task T2 preempts task T1 
and aborts T1. T1 does not have any finalization c ode. T2 shall verify that T1 has terminated, by 
means of the Terminated attribute. 
• On a multiprocessor, an upper bound in seconds, on the time that the completion of an aborted 
task can be delayed beyond the point that  it is required for a single processor. 
• An upper bound on the execution time of an asynchronous_select , in processor clock cycles. 
This is measured between a point immediately before a task T1 executes a protected operation Pr.Set that makes the 
condition  of an entry_barrier  Pr.Wait True, and the point where task T2 
resumes execution immediately after an entry call to Pr.Wait in an asynchronous_select . T1 
preempts T2 while T2 is executing the abortable part, and then blocks itself so that T2 can 
execute. The execution time of T1 is measured separately, and subtracted. 
• An upper bound on the execution time of an asynchronous_select , in the case that no 
asynchronous transfer of control takes place. Th is is measured between a point immediately 
before a task executes the asynchronous_select  with a nonnull abortable part, and the point 
where the task continues execution immediately after it. The execution time of the abortable part is subtracted.  
Implementation Advice 
Even though the abort_statement  is included in the list of potentially  blocking operations (see 9.5.1), it is 
recommended that this statement be implemented in a way that never requires the task executing the 
abort_statement  to block. 10/2 
11/2 
1/3 
2 
3 
4 
5 
6 
7/2 
8 
9 
Ada Reference Manual — 2012 Edition 
645      13 December 2012 Preemptive Abort   D.6 On a multi-processor, the delay associated with a borting a task on another processor should be bounded; 
the implementation should use periodic po lling, if necessary, to achieve this. 
NOTES 
32  Abortion does not change the active or base priority of the aborted task. 
33  Abortion cannot be more immediate than is allowed by the rules for deferral of abortion during finalization and in 
protected actions. 
D.7 Tasking Restrictions 
This subclause defines restrictions th at can be used with a pragma Rest rictions (see 13.12) to facilitate the 
construction of highly efficien t tasking run-time systems.  
Static Semantics 
The following restriction_ identifier s are language defined:  
No_Task_Hierarchy  
 No task depends on a master other than the library-level master. 
No_Nested_Finalization  
 Objects of a type that needs finalization (see 7.6) are declared only at library level. If an 
access type does not have library-level accessibility, then there are no allocator s of the type 
where the type determined by the subtype_mark  of the subtype_indication  or 
qualified_expression  needs finalization.  
No_Abort_Statements  
 There are no abort_statement s, and there is no use of a name  denoting 
Task_Identification.Abort_Task. 
No_Terminate_Alternatives  
 There are no selective_accept s with terminate_alternative s. 
No_Task_Allocators  
 There are no allocator s for task types or types c ontaining task subcomponents. 
 In the case of an initialized allocator  of an access type whose designated type is class-wide 
and limited, a check is made that the specific type of the allocated object has no task subcomponents. Program_Error is ra ised if this check fails.  
No_Implicit_Heap_Allocations  
 There are no operations that implicitly require heap storage allocation to be performed by 
the implementation. The operations that imp licitly require heap storage allocation are 
implementation defined.  
No_Dynamic_Priorities  
 There are no semantic dependences on the p ackage Dynamic_Priorities, and no occurrences 
of the attribute Priority.  
No_Dynamic_Attachment  
 There is no use of a 
name  denoting any of the operations defined in package Interrupts 
(Is_Reserved, Is_Attached, Current_Handl er, Attach_Handler, Exchange_Handler, 
Detach_Handler, and Reference).  
No_Local_Protected_Objects  
 Protected objects are declared only at library level. 
No_Local_Timing_Events  
 Timing_Events are declared only at library level. 10 
11 
12 
1/3 
2 
3/3 
4/3 
5/3 
6 
7 
7.1/3 
8 
9/2 
10/3 
10.1/3 
10.2/3 
Ada Reference Manual — 2012 Edition 
D.7   Tasking Restrictions 13 December 2012      646 No_Protected_Type_Allocators  
 There are no allocator s for protected types or types containing protected type 
subcomponents. 
 In the case of an initialized allocator  of an access type whose designated type is class-wide 
and limited, a check is made that the specific type of the allocated object has no protected subcomponents. Program_Error is ra ised if this check fails.  
No_Relative_Delay  
 There are no 
delay_relative_statement s, and there is no use of a name  that denotes the 
Timing_Events.Set_Handler subprogram that has a Time_Span parameter. 
No_Requeue_Statements  
 There are no requeue_statement s. 
No_Select_Statements  
 There are no select_statement s. 
No_Specific_Termination_Handlers  
 There is no use of a name  denoting the Set_Specific_Handler and Specific_Handler 
subprograms in Task_Termination. 
Simple_Barriers  
 The Boolean expression in each entry barrier is either a static expression or a name that 
statically denotes a component of  the enclosing protected object. 
The following restriction_parameter_ identifier s are language defined:  
Max_Select_Alternatives  
 Specifies the maximum number of alternatives in a selective_accept . 
Max_Task_Entries  
 Specifies the maximum number of entries per task. The bounds of every entry family of a 
task unit shall be static, or shall be defi ned by a discriminant of a subtype whose 
corresponding bound is static. A value of zero i ndicates that no rendezvous are possible. 
Max_Protected_Entries  
 Specifies the maximum number of entries per protected type. The bounds of every entry 
family of a protected unit shall be static, or sh all be defined by a discriminant of a subtype 
whose corresponding bound is static.  
Dynamic Semantics 
The following restriction_ identifier  is language defined: 
No_Task_Termination  
 All tasks are nonterminating. It is implementa tion-defined what happens if a task attempts 
to terminate. If there is a fall-back handler  (see C.7.3) set for the partition it should be 
called when the first task attempts to terminate.  
The following restriction_parameter_ identifier s are language defined:  
Max_Storage_At_Blocking  
 Specifies the maximum portion (in storage elements) of a task's Storage_Size that can be 
retained by a blocked task. If an implementa tion chooses to detect a violation of this 
restriction, Storage_Error should be raised; otherwise, the behavi or is implementation 
defined.  
Max_Asynchronous_Select_Nesting  
 Specifies the maximum dynamic nesting level of asynchronous_select s. A value of zero 
prevents the use of any asynchronous_select  and, if a program contains an 10.3/2 
10.4/3 
10.5/3 
10.6/3 
10.7/3 10.8/3 
10.9/3 
11 
12 
13 
14 
15/2 
15.1/2 
16 
17/1 
18/1 
Ada Reference Manual — 2012 Edition 
647      13 December 2012 Tasking Restrictions   D.7 asynchronous_select , it is illegal. If an implementation choos es to detect a violation of this 
restriction for values other than zero, Stor age_Error should be raised; otherwise, the 
behavior is implementation defined.  
Max_Tasks  Specifies the maximum number of task cr eations that may be executed over the lifetime of 
a partition, not counting the creation of the e nvironment task. A value of zero prevents any 
task creation and, if a program contains a ta sk creation, it is illegal. If an implementation 
chooses to detect a violation of this restric tion, Storage_Error should be raised; otherwise, 
the behavior is implementation defined.  
Max_Entry_Queue_Length  
 Max_Entry_Queue_Length defi nes the maximum number of calls that are queued on an 
entry. Violation of this restriction results in the raising of Program_Error at the point of the 
call or requeue. 
No_Standard_Allocators_After_Elaboration  
 Specifies that an allocator  using a standard storage pool (see 13.11) shall not occur within a 
parameterless library subprogram, nor within the handled_sequence_of_statements  of a 
task body. For the purposes of this rule, an allocator  of a type derived from a formal access 
type does not use a standard storage pool. 
 At run time, Storage_Error is raised if an allocator  using a standard storage pool is 
evaluated after the elaboration of the library_item s of the partition has completed.  
It is implementation defined whethe r the use of pragma Restrictions results in a reduction in executable 
program size, storage requirements, or execution tim e. If possible, the implementation should provide 
quantitative descriptions of such effects for each restriction.  
Implementation Advice 
When feasible, the implementation s hould take advantage of the specified restrictions to produce a more 
efficient implementation. 
NOTES 
34  The above Storage_Checks can be suppressed with pragma Suppress.  
D.8 Monotonic Time 
This subclause specifies a high-reso lution, monotonic clock package.  
Static Semantics 
The following language-defined library package exists:  
package Ada.Real_Time is 
  type Time is private; 
  Time_First : constant  Time; 
  Time_Last : constant  Time; 
  Time_Unit : constant  := implementation-defined-real-number ; 
  type Time_Span is private; 
  Time_Span_First : constant  Time_Span; 
  Time_Span_Last : constant  Time_Span; 
  Time_Span_Zero : constant  Time_Span; 
  Time_Span_Unit : constant  Time_Span; 
  Tick : constant  Time_Span; 
  function  Clock return Time; 19/1 
19.1/2 
19.2/3 
19.3/3 
20 
21 
22 
1/3 
2 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
D.8   Monotonic Time 13 December 2012      648   function  "+" (Left : Time; Right : Time_Span) return Time; 
  function  "+" (Left : Time_Span; Right : Time) return Time; 
  function  "-" (Left : Time; Right : Time_Span) return Time; 
  function  "-" (Left : Time; Right : Time) return Time_Span; 
  function  "<" (Left, Right : Time) return Boolean; 
  function  "<="(Left, Right : Time) return Boolean; 
  function  ">" (Left, Right : Time) return Boolean; 
  function  ">="(Left, Right : Time) return Boolean; 
  function  "+" (Left, Right : Time_Span) return Time_Span; 
  function  "-" (Left, Right : Time_Span) return Time_Span; 
  function  "-" (Right : Time_Span) return Time_Span; 
  function  "*" (Left : Time_Span; Right : Integer) return Time_Span; 
  function  "*" (Left : Integer; Right : Time_Span) return Time_Span; 
  function  "/" (Left, Right : Time_Span) return Integer; 
  function  "/" (Left : Time_Span; Right : Integer) return Time_Span; 
  function  "abs"(Right : Time_Span) return Time_Span; 
This paragraph was deleted.  
  function  "<" (Left, Right : Time_Span) return Boolean; 
  function  "<="(Left, Right : Time_Span) return Boolean; 
  function  ">" (Left, Right : Time_Span) return Boolean; 
  function  ">="(Left, Right : Time_Span) return Boolean; 
  function  To_Duration (TS : Time_Span) return Duration; 
  function  To_Time_Span (D : Duration) return Time_Span; 
  function  Nanoseconds  (NS : Integer) return Time_Span; 
  function  Microseconds (US : Integer) return Time_Span; 
  function  Milliseconds (MS : Integer) return Time_Span; 
  function  Seconds      (S  : Integer) return Time_Span; 
  function  Minutes      (M  : Integer) return Time_Span; 
  type Seconds_Count is range implementation-defined ; 
  procedure  Split(T : in Time; SC : out Seconds_Count; TS : out Time_Span); 
  function  Time_Of(SC : Seconds_Count; TS : Time_Span) return Time; 
private 
   ... -- not specified by the language  
end Ada.Real_Time; 
In this Annex, real time  is defined to be the physical time as obs erved in the external environment. The 
type Time is a time type  as defined by 9.6; values of this type may be used in a delay_until_statement . 
Values of this type represent segments of an id eal time line. The set of values of the type Time 
corresponds one-to-one with an implementation-defined range of  mathematical integers.  
The Time value I represents the half-open real time in terval that starts with E+I*Time_Unit and is limited 
by E+(I+1)*Time_Unit, where Time_Unit is an im plementation-defined real number and E is an 
unspecified origin point, the epoch , that is the same for all values of the type Time. It is not specified by 
the language whether the time values are synchronized with any standard time re ference. For example, E 
can correspond to the time of system initialization or it can correspond to the epoch of some time standard.  
Values of the type Time_Span represent length of r eal time duration. The set of values of this type 
corresponds one-to-one with an impl ementation-defined range of mathem atical integers. The Time_Span 
value corresponding to the integer I represen ts the real-time duration I*Time_Unit.  
Time_First and Time_Last are the smallest and largest values of the Time type, respectively. Similarly, 
Time_Span_First and Time_Span_Las t are the smallest and largest values of the Time_Span type, 
respectively. 
A value of type Seconds_Count repr esents an elapsed tim e, measured in sec onds, since the epoch. 7 
8 
9 
10 
11/1 
12 
13 
14/2 
15 
16 
17 
18 
19 
20 
21 
22 
Ada Reference Manual — 2012 Edition 
649      13 December 2012 Monotonic Time   D.8 Dynamic Semantics 
Time_Unit is the smallest amount of real time representable by the Time  type; it is expressed in seconds. 
Time_Span_Unit is the difference between two successive va lues of the Time type. It is also the smallest 
positive value of type Time_Span. Time_Unit and Time _Span_Unit represent the same real time duration. 
A clock tick  is a real time interval during which the clock value (as observed by calling the Clock 
function) remains constant. Tick is th e average length of such intervals. 
The function To_Duration converts the value TS to a value of type Duration. Similarly, the function 
To_Time_Span converts the value D to a value of type  Time_Span. For To_Dura tion, the result is rounded 
to the nearest value of type Duration (away from zero if exactly halfway between two values). If the result 
is outside the range of Duration, Constraint_Error is  raised. For To_Time_Span, the value of D is first 
rounded to the nearest integral multiple of Time_Un it, away from zero if exactly halfway between two 
multiples. If the rounded value is outside the range of Time_Span, Constraint_Erro r is raised. Otherwise, 
the value is converted to the type Time_Span. 
To_Duration(Time_Span_Zero) returns 0.0, a nd To_Time_Span(0.0) returns Time_Span_Zero. 
The functions Nanoseconds, Micr oseconds, Milliseconds, S econds, and Minutes convert the input 
parameter to a value of the type Time_Span. NS, US, MS, S, and M are interpreted as a number of 
nanoseconds, microseconds, m illiseconds, seconds, and minutes respectiv ely. The input parameter is first 
converted to seconds and rounded to the nearest integr al multiple of Time_Unit, away from zero if exactly 
halfway between two multiples. If the rounded value is outside the range of Time_Span, Constraint_Error 
is raised. Otherwise, the rounded value is  converted to the type Time_Span.  
The effects of the operators on Time and Time_Span ar e as for the operators defined for integer types.  
The function Clock returns the amount of time since the epoch. The effects of the Split and Time_Of operations are de fined as follows, treating values of type Time, 
Time_Span, and Seconds_Count as mathematical integers . The effect of Split(T,SC,TS) is to set SC and 
TS to values such that T*Time_Unit = SC*1.0 + TS*Time_Unit, and 0.0 <= TS*Time_Unit < 1.0. The 
value returned by Time_Of(SC,TS) is the value T such that T*Time _Unit = SC*1.0 + TS*Time_Unit.  
Implementation Requirements 
The range of Time values shall be sufficient to uni quely represent the range of  real times from program 
start-up to 50 years later. Tick shall be no greater th an 1 millisecond. Time_Unit shall be less than or equal 
to 20 microseconds.  
Time_Span_First shall be no greater than –3600 sec onds, and Time_Span_Last shall be no less than 3600 
seconds.  
A clock jump  is the difference between two successive distin ct values of the clock (as observed by calling 
the Clock function). There shall be no backward clock jumps. 
Documentation Requirements 
The implementation shall document the values of Ti me_First, Time_Last, Ti me_Span_First, Time_Span_-
Last, Time_Span_Unit, and Tick.  
The implementation shall doc ument the properties of the underlying tim e base used for the clock and for 
type Time, such as the range of values supported a nd any relevant aspects of the underlying hardware or 
operating system facilities used.  23 
24/2 
25 
26/2 
27 
28 29 
30 
31 
32 
33 
34 
Ada Reference Manual — 2012 Edition 
D.8   Monotonic Time 13 December 2012      650 The implementation shall document whether or not there is any sy nchronization with external time 
references, and if such synchronization exists, the sources of synchronization information, the frequency 
of synchronization, and the sy nchronization method applied.  
The implementation shall document any aspects of the ex ternal environment that could interfere with the 
clock behavior as defined in this subclause.  
Metrics 
For the purpose of the metrics defined in this subclause,  real time is defined to be the International Atomic 
Time (TAI). 
The implementation shall document the following metrics:  
• An upper bound on the real-time duration of a clock tick.  This is a value D such that if t1 and t2 
are any real times such that t1 < t2 and Clock t1 = Clock t2 then t2 – t1 <= D. 
• An upper bound on the size of a clock jump. 
• An upper bound on the drift rate  of Clock with respect to real time. This is a real number D such 
that  
E*(1–D) <= (Clock t+E – Clock t) <= E*(1+D) 
        provided that: Clock t + E*(1+D) <= Time_Last. 
• where Clock t is the value of Clock at time t, and E is  a real time duration not less than 24 hours. 
The value of E used for this metric shall be reported.  
• An upper bound on the execution time of a call to th e Clock function, in processor clock cycles. 
• Upper bounds on the execution times of the operato rs of the types Time and Time_Span, in 
processor clock cycles.  
Implementation Permissions 
Implementations targeted to  machines with word size smaller than 32 bits need not support the full range 
and granularity of the Time and Time_Span types.  
Implementation Advice 
When appropriate, implementations s hould provide configuration mechanisms  to change the value of Tick.  
It is recommended that Calendar.Cl ock and Real_Time.Clock be implem ented as transformations of the 
same time base.  
It is recommended that the “best” time base which ex ists in the underlying system be available to the 
application through Clock. “Best” may mean highest accuracy or largest range.  
NOTES 
35  The rules in this subclause do not imply that the implementation can protect the user from operator or installation errors which could result in the clock being set incorrectly. 
36  Time_Unit is the granularity of the Time type. In contrast, Tick represents the granularity of Real_Time.Clock. There 
is no requirement that these be the same. 35 
36/3 
37/3 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50/3 
51 
Ada Reference Manual — 2012 Edition 
651      13 December 2012 Delay Accuracy   D.9 D.9 Delay Accuracy 
This subclause specifies pe rformance requirements for the delay_statement . The rules apply both to 
delay_relative_statement  and to delay_until_statement . Similarly, they apply equally to a simple delay_-
statement  and to one which appears in a delay_alternative .  
Dynamic Semantics 
The effect of the delay_statement  for Real_Time.Time is defined in terms of Real_Time.Clock:  
• If C 1 is a value of Clock read before a task executes a delay_relative_statement  with duration D, 
and C 2 is a value of Clock read after the task resumes execution following that delay_statement , 
then C 2 – C 1 >= D. 
• If C is a value of Clock read after a task resumes execution following a delay_until_statement  
with Real_Time.Time value T, then C >= T.  
A simple delay_statement  with a negative or zero value for the expiration time does not cause the calling 
task to be blocked; it is nevertheless a potentially blocking operation (see 9.5.1). 
When a delay_statement  appears in a delay_alternative  of a timed_entry_call  the selection of the entry 
call is attempted, regardless of the specified expiration time. When a delay_statement  appears in a 
select_alternative , and a call is queued on one of the open entries, the selection of that entry call proceeds, 
regardless of the value of the delay expression.  
Documentation Requirements 
The implementation shall document the mini mum value of the delay expression of a 
delay_relative_statement  that causes the task to actually be blocked.  
The implementation shall document the minimum differe nce between the value of the delay expression of 
a delay_until_statement  and the value of Real_Time.Clock, that causes the task to actually be blocked.  
Metrics 
The implementation shall document the following metrics:  
• An upper bound on the execution time, in processor clock cycles, of a delay_relative_statement  
whose requested value of the delay expr ession is less than or equal to zero. 
• An upper bound on the execution time, in processor clock cycles, of a delay_until_statement  
whose requested value of the delay expressi on is less than or equal to the value of 
Real_Time.Clock at the time of executing the statement. Similarly, for Calendar.Clock. 
• An upper bound on the lateness  of a delay_relative_statement , for a positive value of the delay 
expression, in a situation where the task has suffi cient priority to preempt the processor as soon 
as it becomes ready, and does not need to wait for any other execution resources. The upper 
bound is expressed as a function of the value of th e delay expression. The lateness is obtained by 
subtracting the value of the delay expression from the actual duration . The actual duration is 
measured from a point immediately before a task executes the delay_statement  to a point 
immediately after the task resumes execution following this statement. 
• An upper bound on the lateness of a delay_until_statement , in a situation where the value of the 
requested expiration time is after the time the task begins executing the statement, the task has sufficient priority to preempt the processor as soon as it becomes ready, and it does not need to 
wait for any other execution resources. The uppe r bound is expressed as a function of the 
difference between the requested expiration time and the clock value at the time the statement begins execution. The lateness of a 
delay_until_statement  is obtained by subtracting the 1/3 
2 
3 
4 
5 
6/3 
7 
8 
9 
10 
11 
12 
13 
Ada Reference Manual — 2012 Edition 
D.9   Delay Accuracy 13 December 2012      652 requested expiration time from the real time that the task resumes execution following this 
statement.  
D.10 Synchronous Task Control 
This subclause describes a language-defined private semaphore (suspension object), which can be used for 
two-stage suspend  operations and as a simple building bloc k for implementing higher-level queues.  
Static Semantics 
The following language-defin ed package exists:  
package Ada.Synchronous_Task_Control is 
  pragma Preelaborate(Synchronous_Task_Control); 
  type Suspension_Object is limited private; 
  procedure  Set_True(S : in out Suspension_Object); 
  procedure  Set_False(S : in out Suspension_Object); 
  function  Current_State(S : Suspension_Object) return Boolean; 
  procedure  Suspend_Until_True(S : in out Suspension_Object); 
private 
     ... -- not specified by the language  
end Ada.Synchronous_Task_Control; 
The type Suspension_Object is a by-reference type. 
The following language-defin ed package exists:  
package Ada.Synchronous_Task_Control.EDF is 
   procedure  Suspend_Until_True_And_Set_Deadline 
      (S  : in out Suspension_Object; 
       TS : in     Ada.Real_Time.Time_Span); 
end Ada.Synchronous_Task_Control.EDF; 
Dynamic Semantics 
An object of the type Suspension_Object has two visi ble states: True and False. Upon initialization, its 
value is set to False.  
The operations Set_True and Set_False are atomic with respect to each other and with respect to 
Suspend_Until_True; they set the state to True and False respectively. 
Current_State returns the current state of the object.  The procedure Suspend_Until_True blocks the calling task  until the state of the object S is True; at that 
point the task becomes ready and the state of the object becomes False. 
Program_Error is raised upon calling Suspend_Until_True  if another task is already waiting on that 
suspension object. Suspend_Until_True is a potentially blocking operation (see 9.5.1). 
The procedure Suspend_Until_True_A nd_Set_Deadline blocks the calling ta sk until the state of the object 
S is True; at that point the task becomes ready w ith a deadline of Ada.Real_Time.Clock + TS, and the 
state of the object becomes False. Program_Error is raised upon calling Suspend_Until_True_And_Set_Deadline if another task  is already waiting on that suspension object. 
Suspend_Until_True_And_Set_Deadline is a potentially blocking operation.  
Implementation Requirements 
The implementation is required to allow the calling of Set_False and Set_True during any protected action, 
even one that has its ceiling prior ity in the Interrupt_Priority range. 1/3 
2 
3/2 
4 
5 
5.1/3 
5.2/3 
6/2 
7/2 
8 
9/2 
10 
10.1/3 
11 
Ada Reference Manual — 2012 Edition 
653      13 December 2012 Synchronous Task Control   D.10 NOTES 
37  More complex schemes, such as setting the deadline relative to when Set_True is called, can be programmed using a protected object.  
D.10.1 Synchronous Barriers 
This subclause introduces a language -defined package to synchronously release a group of tasks after the 
number of blocked tasks reaches a specified count value.  
Static Semantics 
The following language-defined library package exists:  
package Ada.Synchronous_Barriers is 
   pragma Preelaborate(Synchronous_Barriers); 
   subtype Barrier_Limit is Positive range 1 .. implementation-defined ; 
   type Synchronous_Barrier (Release_Threshold : Barrier_Limit) is limited 
private; 
   procedure  Wait_For_Release (The_Barrier : in out Synchronous_Barrier; 
                               Notified    :    out Boolean); 
private 
   -- not specified by the language  
end Ada.Synchronous_Barriers; 
Type Synchronous_Barrier needs finalization (see 7.6).  
Dynamic Semantics 
Each call to Wait_For_Release blocks the calling task  until the number of blocked tasks associated with 
the Synchronous_Barrier object is equal to Release_ Threshold, at which time all blocked tasks are 
released. Notified is set to True for one of the released tasks, and set to  False for all other released tasks. 
The mechanism for determining which task sets Notified to True is implementation defined. 
Once all tasks have been released, a Synchronous_B arrier object may be reused to block another 
Release_Threshold number of tasks. 
As the first step of the finalization of a Sync hronous_Barrier, each blocked task is unblocked and 
Program_Error is raised at the place of the call to Wait_For_Release. 
It is implementation defined whether an abnormal task which is waiting on a Synchronous_Barrier object 
is aborted immediately or aborted when the tasks waiting on the object are released.  
Wait_For_Release is a potentially blocking operation (see 9.5.1).  
Bounded (Run-Time) Errors 
It is a bounded error to call Wait_For_Release on a Synchronous_Barrier object after that object is 
finalized. If the error is detected, Program_Error is raised. Otherwise, the call proceeds normally, which 
may leave a task blocked forever.  12/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 7/3 
8/3 
9/3 
10/3 
11/3 
12/3 13/3 14/3 
15/3 
Ada Reference Manual — 2012 Edition 
D.11    Asynchronous Task Control 13 December 2012      654 D.11 Asynchronous Task Control 
This subclause introduces a language -defined package to do asynchronous suspend/resume on tasks. It 
uses a conceptual held priority  value to represent the task's held state.  
Static Semantics 
The following language-defined library package exists:  
with Ada.Task_Identification; 
package Ada.Asynchronous_Task_Control is 
  pragma Preelaborate(Asynchronous_Task_Control); 
  procedure  Hold(T : in Ada.Task_Identification.Task_Id); 
  procedure  Continue(T : in Ada.Task_Identification.Task_Id); 
  function  Is_Held(T : Ada.Task_Identification.Task_Id) 
   return Boolean; 
end Ada.Asynchronous_Task_Control; 
Dynamic Semantics 
After the Hold operation has been applied to a task, the task becomes held. For each processor there is a 
conceptual idle task , which is always ready. The base priority of the idle task is below System.Any_-
Priority'First. The held priority  is a constant of the type Integer whos e value is below the base priority of 
the idle task.  
For any priority below System.Any_Priority'First, the task dispatching policy is FIFO_Within_Priorities.  
The Hold operation sets the state of T to held. For a he ld task, the active priority is reevaluated as if the 
base priority of the task were the held priority.  
The Continue operation resets the state of T to not-h eld; its active priority is then reevaluated as 
determined by the task dispatching polic y associated with its base priority. 
The Is_Held function returns True if a nd only if T is in the held state.  
As part of these operations, a check is made that th e task identified by T is not terminated. Tasking_Error 
is raised if the check fails. Program_Error is raised if the value of T is Null_Task_Id. 
Erroneous Execution 
If any operation in this package is called with a para meter T that specifies a task object that no longer 
exists, the execution of th e program is erroneous.  
Implementation Permissions 
An implementation need not support Asynchronous_Task_Control if it is infeasible to support it in the 
target environment.  
NOTES 
38  It is a consequence of the priority rules that held tasks cannot be dispatched on any processor in a partition (unless they are inheriting priorities) since their priorities are defined to be below the priority of any idle task. 
39  The effect of calling Get_Priority and Set_Priority  on a Held task is the same as on any other task. 
40  Calling Hold on a held task or Continue on a non-held task has no effect. 41  The rules affecting queuing are derived from the above rules, in addition to the normal priority rules:  
• When a held task is on the ready queue, its priority is so  low as to never reach the top of the queue as long as 
there are other tasks on that queue. 
• If a task is executing in a protected action, inside a rendezvous, or is inheriting priorities from other sources 
(e.g. when activated), it continues to execute until it is no longer executing the corresponding construct. 1/3 
2 
3/2 
4/2 
4.1/2 
5/2 
6/2 
7 
8 
9 
10 
11 
12 
13 14 
15 
16 
Ada Reference Manual — 2012 Edition 
655      13 December 2012 Asynchronous Task Control   D.11 • If a task becomes held while waiting (as a caller) for a rendezvous to complete, the active priority of the 
accepting task is not affected. 
• If a task becomes held while waiting in a selective_accept , and an entry call is issued to one of the open 
entries, the corresponding accept_alternative  executes. When the rendezvous completes, the active priority of 
the accepti ng task is lowered to the held priority (unless it is still inheriting from othe r sources), and the task 
does not execute until another Continue. 
• The same holds if the held task is the only task on a protected entry queue whose barrier becomes open. The 
corresponding entry body executes. 
D.12 Other Optimizations and Determinism Rules 
This subclause describes various requirements for improving the respons e and determinism in a real-time 
system.  
Implementation Requirements 
If the implementation blocks interrupts (see C.3) not as a result of direct user action (e.g. an execution of a 
protected action) there shall be an upper bound on the duration of this blocking.  
The implementation shall recognize entry-less protect ed types. The overhead of acquiring the execution 
resource of an object of such a type (see 9.5.1) sha ll be minimized. In particular, there should not be any 
overhead due to evaluating entry_barrier  condition s.  
Unchecked_Deallocation shall be supported for terminat ed tasks that are designated by access types, and 
shall have the effect of releasing all the storage asso ciated with the task. This includes any run-time system 
or heap storage that has been implicitly a llocated for the task by the implementation. 
Documentation Requirements 
The implementation shall document the upper bound on th e duration of interrupt blocking caused by the 
implementation. If this is different  for different interrupts or interrupt priority levels, it should be 
documented for each case.  
Metrics 
The implementation shall document the following metric:  
• The overhead associated with obtaining a mutu al-exclusive access to an entry-less protected 
object. This shall be measured in the following way: 
 For a protected object of the form:  
protected  Lock is 
   procedure  Set; 
   function  Read return Boolean; 
private 
   Flag : Boolean := False; end Lock; 
protected body  Lock is 
   procedure  Set is 
   begin 
      Flag := True;    end Set; 
   function  Read return Boolean 
   Begin 
      return Flag; 
   end Read; 
end Lock; 17 
18/1 
19 
1/3 
2 
3 
4 
5 
6 
7 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
D.12    Other Optimizations and Determinism Rules 13 December 2012      656  The execution time, in processor clock cycles, of a call to Set. This shall be measured between 
the point just before issuing the call, and the point just after the call completes. The function 
Read shall be called later to verify that Set was indeed called (and not optimized away). The 
calling task shall have sufficiently high priority as to not be preempted  during the measurement 
period. The protected object shall have sufficiently  high ceiling priority to allow the task to call 
Set. 
 For a multiprocessor, if supported, the metric shall be reported for the case where no contention 
(on the execution resource) exists from tasks executing on other processors.  
D.13 The Ravenscar Profile 
This subclause defines the Ravenscar profile.  
Paragraphs 2 and 3 were moved to 13.12, “Pragma Restrictions and Pragma Profile”.   
Legality Rules 
The profile_ identifier  Ravenscar is a usage profile (see 13.12). Fo r usage profile Ravenscar, there shall be 
no profile_ pragma_argument_association s.  
Static Semantics 
The usage profile Ravenscar is equivale nt to the following set of pragmas: 
pragma Task_Dispatching_Policy (FIFO_Within_Priorities); 
pragma Locking_Policy (Ceiling_Locking); 
pragma Detect_Blocking; 
pragma Restrictions ( 
              No_Abort_Statements,               No_Dynamic_Attachment,               No_Dynamic_Priorities,               No_Implicit_Heap_Allocations,               No_Local_Protected_Objects,               No_Local_Timing_Events,               No_Protected_Type_Allocators,               No_Relative_Delay,               No_Requeue_Statements,               No_Select_Statements,               No_Specific_Termination_Handlers,               No_Task_Allocators,               No_Task_Hierarchy,               No_Task_Termination,               Simple_Barriers,               Max_Entry_Queue_Length => 1,               Max_Protected_Entries => 1,               Max_Task_Entries => 0,               No_Dependence => Ada.Asynchronous_Task_Control,               No_Dependence => Ada.Calendar,               No_Dependence => Ada.Execution_Time.Group_Budgets,               No_Dependence => Ada.Execution_Time.Timers,               No_Dependence => Ada.Task_Attributes,               No_Dependence => System.Multiprocessors.Dispatching_Domains); 
Paragraph 7 was deleted.
  
Implementation Requirements 
A task shall only be on the ready queues of one processo r, and the processor to which a task belongs shall 
be defined statically. Whenever a task running on a processor reaches a task dispatching point, it goes 
back to the ready queues of the same processor. A task with a CPU value of Not_A_Specific_CPU will 11 
12 
1/3 
4/3 
5/3 
6/3 
8/3 
Ada Reference Manual — 2012 Edition 
657      13 December 2012 The Ravenscar Profile   D.13 execute on an implementation defined processor. A ta sk without a CPU aspect will activate and execute on 
the same processor as its activating task.  
Implementation Advice 
On a multiprocessor system, an implementation s hould support a fully partitioned approach. Each 
processor should have separate  and disjoint ready queues. 
NOTES 
42  The effect of the Max_Entry_Queue_Length => 1 restriction applies only to protected entry queues due to the accompanying restriction of Max_Task_Entries => 0.  
D.14 Execution Time 
This subclause describes a language-defin ed package to meas ure execution time.  
Static Semantics 
The following language-defined library package exists:  
with Ada.Task_Identification; 
with Ada.Real_Time; use Ada.Real_Time; 
package Ada.Execution_Time is 
   type CPU_Time is private ; 
   CPU_Time_First : constant  CPU_Time; 
   CPU_Time_Last  : constant  CPU_Time; 
   CPU_Time_Unit  : constant  := implementation-defined-real-number ; 
   CPU_Tick : constant  Time_Span; 
   function  Clock 
     (T : Ada.Task_Identification.Task_Id           := Ada.Task_Identification.Current_Task)      return CPU_Time; 
   function  "+"  (Left : CPU_Time; Right : Time_Span) return CPU_Time; 
   function  "+"  (Left : Time_Span; Right : CPU_Time) return CPU_Time; 
   function  "-"  (Left : CPU_Time; Right : Time_Span) return CPU_Time; 
   function  "-"  (Left : CPU_Time; Right : CPU_Time)  return Time_Span; 
   function  "<"  (Left, Right : CPU_Time) return Boolean; 
   function  "<=" (Left, Right : CPU_Time) return Boolean; 
   function  ">"  (Left, Right : CPU_Time) return Boolean; 
   function  ">=" (Left, Right : CPU_Time) return Boolean; 
   procedure  Split 
     (T : in CPU_Time; SC : out Seconds_Count; TS : out Time_Span); 
   function  Time_Of (SC : Seconds_Count; 
                     TS : Time_Span := Time_Span_Zero) return CPU_Time; 
   Interrupt_Clocks_Supported : constant  Boolean := implementation-defined ; 
   Separate_Interrupt_Clocks_Supported : constant  Boolean := 
     implementation-defined ; 
   function  Clock_For_Interrupts return CPU_Time; 
private 
   ... -- not specified by the language  
end Ada.Execution_Time; 
The execution time  or CPU time of a given task is defined as the time spent by the system executing that 
task, including the time spent executing run-time or syst em services on its behalf. The mechanism used to 
measure execution time is implementation defined. The Boolean constant Interrupt_Clocks_Supported is 
set to True if the implementation separately accounts for the execution time of interrupt handlers. If it is 
set to False it is implementation defined which task, if  any, is charged the execution time that is consumed 9/3 
10/3 
1/3 
2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
8/2 
9/2 
9.1/3 
9.2/3 
9.3/3 
10/2 
11/3 
Ada Reference Manual — 2012 Edition 
D.14    Execution Time 13 December 2012      658 by interrupt handlers. The Boolean constant Separate _Interrupt_Clocks_Supported is set to True if the 
implementation separately accounts for the execution tim e of individual interrupt handlers (see D.14.3).  
The type CPU_Time represents the execution time of a task. The set of values of this type corresponds 
one-to-one with an implementation-defi ned range of mathematical integers. 
The CPU_Time value I represents the half-open executi on-time interval that star ts with I*CPU_Time_Unit 
and is limited by (I+1)*CPU_Time_Unit, where CPU_ Time_Unit is an implem entation-defined real 
number. For each task, the execution time value is set to zero at the creation of the task. 
CPU_Time_First and CPU_Time_Last are the smalle st and largest values of the CPU_Time type, 
respectively.  
The execution time value for the function Cloc k_For_Interrupts is initialized to zero. 
Dynamic Semantics 
CPU_Time_Unit is the smallest am ount of execution time representabl e by the CPU_Time type; it is 
expressed in seconds. A CPU clock tick  is an execution time interval during which the clock value (as 
observed by calling the Clock function) remains cons tant. CPU_Tick is the average length of such 
intervals. 
The effects of the operators on CPU_Time and Time_S pan are as for the operators defined for integer 
types. 
The function Clock returns the current execution time of the task identified by T; Tasking_Error is raised 
if that task has terminated; Program_Error is raised if  the value of T is Task_I dentification.Null_Task_Id. 
The effects of the Split and Time_Of operations are defi ned as follows, treating values of type CPU_Time, 
Time_Span, and Seconds_Count as mathematical integers . The effect of Split (T, SC, TS) is to set SC and 
TS to values such that T*CPU_Time_Un it = SC*1.0 + TS*CPU_Time_Unit, and 0.0 <= 
TS*CPU_Time_Unit < 1.0. The valu e returned by Time_Of(SC,TS) is the execution-time value T such 
that T*CPU_Time_Unit=SC *1.0 + TS*CPU_Time_Unit. 
The function Clock_For_Interrupts returns the total cumulative time spent executing within all interrupt 
handlers. This time is not allocated  to any task execution time clock. If Interrupt_Clocks_Supported is set 
to False the function raises Program_Error. 
Erroneous Execution 
For a call of Clock, if the task identified by T no l onger exists, the execution of the program is erroneous.  
Implementation Requirements 
The range of CPU_Time values shall be sufficient to  uniquely represent the range of execution times from 
the task start-up to 50 years of execution time later.  CPU_Tick shall be no greater than 1 millisecond.  
Documentation Requirements 
The implementation shall document the values of CPU_Time_First, CPU_Time _Last, CPU_Time_Unit, 
and CPU_Tick.  
The implementation shall documen t the properties of the underlyi ng mechanism used to measure 
execution times, such as the range  of values supported and any relevant aspects of the underlying 
hardware or operating system facilities used.  12/2 
13/2 
14/2 
14.1/3 
15/2 
16/2 
17/2 18/2 
18.1/3 
19/2 
20/2 
21/2 
22/2 
Ada Reference Manual — 2012 Edition 
659      13 December 2012 Execution Time   D.14 Metrics 
The implementation shall document the following metrics: 
• An upper bound on the execution-time duration of a cloc k tick. This is a value D such that if t1 
and t2 are any execution times of a given task such that t1 < t2 and Clock t1 = Clock t2 then t2 – t1 
<= D. 
• An upper bound on the size of a clock jump. A clock jump is the difference between two 
successive distinct values of an execution-time clock (as observed by calling the Clock function 
with the same Task_Id). 
• An upper bound on the execution time of a call to th e Clock function, in processor clock cycles. 
• Upper bounds on the execution times of the operators  of the type CPU_Time, in processor clock 
cycles.  
Implementation Permissions 
Implementations targeted to  machines with word size smaller than 32 bits need not support the full range 
and granularity of the CPU_Time type. 
Implementation Advice 
When appropriate, implementations should provide configuration mechan isms to change the value of 
CPU_Tick.  
D.14.1 Execution Time Timers 
This subclause describes a language-defined package that provides a facility for calling a handler when a 
task has used a defined amount of CPU time.  
Static Semantics 
The following language-defined library package exists:  
with System; 
package Ada.Execution_Time.Timers is 
   type Timer (T : not null access constant  
                       Ada.Task_Identification.Task_Id) is 
      tagged limited private ; 
   type Timer_Handler is 
      access protected procedure  (TM : in out Timer); 
   Min_Handler_Ceiling : constant  System.Any_Priority := 
   implementation-defined ; 
   procedure  Set_Handler (TM      : in out Timer; 
                          In_Time : in Time_Span; 
                          Handler : in Timer_Handler); 
   procedure  Set_Handler (TM      : in out Timer; 
                          At_Time : in CPU_Time; 
                          Handler : in Timer_Handler); 
   function  Current_Handler (TM : Timer) return Timer_Handler; 
   procedure  Cancel_Handler (TM        : in out Timer; 
                             Cancelled :    out Boolean); 
   function  Time_Remaining (TM : Timer) return Time_Span; 
   Timer_Resource_Error : exception ; 
private 
   ... -- not specified by the language  
end Ada.Execution_Time.Timers; 23/2 
24/2 
25/2 
26/2 
27/2 
28/2 
29/2 
1/3 
2/2 
3/2 
4/2 
5/2 
6/2 7/2 
8/2 
9/2 
10/2 
Ada Reference Manual — 2012 Edition 
D.14.1    Execution Time Timers 13 December 2012      660 The type Timer represents an execution-time event for a single task and is capable of detecting execution-
time overruns. The access discriminant T identifies the task concerned. The type Timer needs finalization (see 7.6). 
An object of type Timer is said to be set if it is associated with a nonnull value of type Timer_Handler and 
cleared  otherwise. All Timer objects are initially cleared.  
The type Timer_Handler identifies a protected proce dure to be executed by the implementation when the 
timer expires. Such a protected procedure is called a handler .  
Dynamic Semantics 
When a Timer object is created, or upon the first ca ll of a Set_Handler proce dure with the timer as 
parameter, the resources required to operate an execution-time timer based on the associated execution-time clock are allocated and initialized. If this operation would exceed the available resources, 
Timer_Resource_Error is raised. 
The procedures Set_Handler associate the handler  Handler with the timer TM: if Handler is null, the timer 
is cleared; otherwise, it is set. The first procedure Set_Handler load s the timer TM with an interval 
specified by the Time_Span paramete r. In this mode, the timer TM expires  when the execution time of the 
task identified by TM.T. all has increased by In_Time; if In_Time is less than or equal to zero, the timer 
expires immediately. The second pr ocedure Set_Handler loads the timer  TM with the absolute value 
specified by At_Time. In this mode, the timer TM expires when the execution time of the task identified 
by TM.T. all reaches At_Time; if the value of At_Time ha s already been reached when Set_Handler is 
called, the timer expires immediately. 
A call of a procedure Set_Handler for a timer that is already set replaces the handler and the (absolute or 
relative) execution time; if Handler is not null, the timer remains set. 
When a timer expires, the associated handler is execu ted, passing the timer as parameter. The initial action 
of the execution of the handler is to clear the event. 
The function Current_Handler returns the handler asso ciated with the timer TM  if that timer is set; 
otherwise, it returns null. 
The procedure Cancel_Handler clears the timer if it is set. Cancelled is assigned True if the timer was set 
prior to it being cleared; otherwise, it is assigned False. 
The function Time_Remaining returns the execution time interval that remains until the timer TM would 
expire, if that timer is set; othe rwise, it returns Time_Span_Zero. 
The constant Min_Handler_Ceiling is the minimum ceili ng priority required for a protected object with a 
handler to ensure that no ceiling violation will occur when that handler is invoked. 
As part of the finalization of an object of type Timer, the timer is cleared. For all the subprograms defined in this package, Task ing_Error is raised if the task identified by TM.T. all 
has terminated, and Program_Error is  raised if the value of TM.T. all is Task_Identification.Null_Task_Id. 
An exception propagated from a handler invoked as pa rt of the expiration of a timer has no effect. 
Erroneous Execution 
For a call of any of the subprograms defined in th is package, if the task identified by TM.T. all no longer 
exists, the execution of th e program is erroneous. 11/2 
12/2 
13/2 
14/2 
15/3 
16/2 
17/2 18/3 19/3 20/3 21/2 22/2 
23/2 
24/2 
25/2 
Ada Reference Manual — 2012 Edition 
661      13 December 2012 Execution Time Timers   D.14.1 Implementation Requirements 
For a given Timer object, the implementation shall perform the operations declared in this package 
atomically with respect to any of these operations on the same Timer object. The replacement of a handler by a call of Set_Handler shall be performed atomi cally with respect to the execution of the handler. 
When an object of type Timer is finalized, the system  resources used by the timer shall be deallocated. 
Implementation Permissions 
Implementations may limit the number of timers that can be defined for each task. If this limit is exceeded, 
then Timer_Resource_Error is raised. 
NOTES 
43  A Timer_Handler can be associated with several Timer objects. 
D.14.2 Group Execution Time Budgets 
This subclause describes a language-defined package to assign execution time budgets to groups of tasks.  
Static Semantics 
The following language-defined library package exists:  
with System; 
with System.Multiprocessors; 
package Ada.Execution_Time.Group_Budgets is 
  type Group_Budget(CPU : System.Multiprocessors.CPU := 
                             System.Multiprocessors.CPU'First)     is tagged limited private ; 
  type Group_Budget_Handler is access  
       protected procedure  (GB : in out Group_Budget); 
  type Task_Array is array  (Positive range <>) of 
                                  Ada.Task_Identification.Task_Id; 
  Min_Handler_Ceiling : constant  System.Any_Priority := 
    implementation-defined ; 
  procedure  Add_Task (GB : in out Group_Budget; 
                      T  : in Ada.Task_Identification.Task_Id); 
  procedure  Remove_Task (GB: in out Group_Budget; 
                         T  : in Ada.Task_Identification.Task_Id); 
  function  Is_Member (GB : Group_Budget; 
                      T : Ada.Task_Identification.Task_Id) return Boolean; 
  function  Is_A_Group_Member 
     (T : Ada.Task_Identification.Task_Id) return Boolean; 
  function  Members (GB : Group_Budget) return Task_Array; 
  procedure  Replenish (GB : in out Group_Budget; To : in Time_Span); 
  procedure  Add (GB : in out Group_Budget; Interval : in Time_Span); 
  function  Budget_Has_Expired (GB : Group_Budget) return Boolean; 
  function  Budget_Remaining (GB : Group_Budget) return Time_Span; 
  procedure  Set_Handler (GB      : in out Group_Budget; 
                         Handler : in Group_Budget_Handler); 
  function  Current_Handler (GB : Group_Budget) 
     return Group_Budget_Handler; 
  procedure  Cancel_Handler (GB        : in out Group_Budget; 
                            Cancelled : out Boolean); 
  Group_Budget_Error : exception ; 
private 
    --  not specified by the language  
end Ada.Execution_Time.Group_Budgets; 26/2 
27/2 
28/3 
29/2 
1/3 
2/2 
3/3 
4/3 5/2 
6/2 7/2 8/2 
9/2 
10/2 
11/2 
12/2 
Ada Reference Manual — 2012 Edition 
D.14.2    Group Execution Time Budgets 13 December 2012      662 The type Group_Budget represents an execution time budge t to be used by a group of tasks. The type 
Group_Budget needs finalization (see 7.6). A task can bel ong to at most one group. Tasks of any priority 
can be added to a group. 
An object of type Group_Budget has an associated nonnegative value of type Time_Span known as its 
budget , which is initially Time_Span_Zero. The ty pe Group_Budget_Handler identifies a protected 
procedure to be executed by the implementation when the budget is exhausted , that is, reaches zero. Such 
a protected procedure is called a handler .  
An object of type Group_Budget also includes a handl er, which is a value of type Group_Budget_Handler. 
The handler of the object is said to be set if it is not null and cleared  otherwise. The handler of all 
Group_Budget objects is initially cleared.  
Dynamic Semantics 
The procedure Add_Task adds the task identified by T to  the group GB; if that task is already a member of 
some other group, Group_Budget_Error is raised. 
The procedure Remove_Task removes the task identified by T from the group GB; if that task is not a 
member of the group GB, Group_Budget_Error is raised. After successful execution of this procedure, the 
task is no longer a member of any group. 
The function Is_Member returns True if the task iden tified by T is a member of the group GB; otherwise, 
it returns False. 
The function Is_A_Group_Member return s True if the task identified by T is a member of some group; 
otherwise, it returns False. 
The function Members returns an array of values of  type Task_Identification.Task_Id identifying the 
members of the group GB. The order of the components of the array is unspecified. 
The procedure Replenish loads the group budget GB w ith To as the Time_Span value. The exception 
Group_Budget_Error is raised if the Time_Span va lue To is nonpositive. Any execution on CPU of any 
member of the group of tasks results in the budge t counting down, unless e xhausted. When the budget 
becomes exhausted (reaches Time_Span_Zero), the associ ated handler is executed if the handler of group 
budget GB is set. Nevertheless, the tasks continue to execute. 
The procedure Add modifies the budget of the group GB. A positive value for Interval increases the 
budget. A negative value for Interval reduces the budge t, but never below Time _Span_Zero. A zero value 
for Interval has no effect. A call of procedure A dd that results in the value of the budget going to 
Time_Span_Zero causes the associated handler to be ex ecuted if the handler of the group budget GB is set. 
The function Budget_Has_Expired returns True if  the budget of group GB is exhausted (equal to 
Time_Span_Zero); otherwise, it returns False. 
The function Budget_Remaining returns the remaini ng budget for the group GB. If the budget is exhausted 
it returns Time_Span_Zero. This is  the minimum value for a budget. 
The procedure Set_Handler associates the handler  Handler with the Group_Budget GB: if Handler is null, 
the handler of Group_Budget is cl eared; otherwise, it is set. 
A call of Set_Handler for a Group_Budget that already ha s a handler set replaces the handler; if Handler is 
not null, the handler for Group_Budget remains set. 
The function Current_Handler returns the handler asso ciated with the group budget GB if the handler for 
that group budget is set; otherwise, it returns null. 13/2 
14/2 
15/2 
16/2 
17/2 
18/3 
19/3 20/2 21/3 
22/2 
23/3 
24/2 25/3 26/2 27/3 
Ada Reference Manual — 2012 Edition 
663      13 December 2012 Group Execution Time Budgets   D.14.2 The procedure Cancel_Handler clears the handler for the group budget if it is set. Cancelled is assigned 
True if the handler for the group budget was set prior to  it being cleared; otherwise, it is assigned False. 
The constant Min_Handler_Ceiling is the minimum ceili ng priority required for a protected object with a 
handler to ensure that no ceiling violation will occur when that handler is invoked. 
The precision of the accounting of task execution time to a Group_Budget is the same as that defined for 
execution-time clocks from the parent package. 
As part of the finalization of an object of ty pe Group_Budget all member tasks are removed from the 
group identified by that object. 
If a task is a member of a Group_Budget when it terminates, then as part of the finalization of the task it is 
removed from the group. 
For all the operations defined in this package, Task ing_Error is raised if the task identified by T has 
terminated, and Program_Error is raised if the va lue of T is Task_Identification.Null_Task_Id. 
An exception propagated from a handler invoked when the budget of a group of tasks becomes exhausted 
has no effect. 
Erroneous Execution 
For a call of any of the subprograms defined in this p ackage, if the task identified by T no longer exists, 
the execution of the pr ogram is erroneous.  
Implementation Requirements 
For a given Group_Budget object, the implementation sh all perform the operations  declared in this 
package atomically with respect to any of these operations on the same Group_Budget object. The 
replacement of a handler, by a call of Set_Handler, sh all be performed atomically with respect to the 
execution of the handler.  
NOTES 
44  Clearing or setting of the handler of a group budget does not change the current value of the budget. Exhaustion or loading of a budget does not change whether the handler of the group budget is set or cleared. 
45  A Group_Budget_Handler can be associated with several Group_Budget objects.  
D.14.3 Execution Time of Interrupt Handlers 
This subclause describes a language-d efined package to meas ure the execution time of interrupt handlers.  
Static Semantics 
The following language-defined library package exists:  
with Ada.Interrupts; 
package Ada.Execution_Time.Interrupts is 
   function  Clock (Interrupt : Ada.Interrupts.Interrupt_Id) 
        return CPU_Time; 
   function  Supported (Interrupt : Ada.Interrupts.Interrupt_Id) 
        return Boolean; 
end Ada.Execution_Time.Interrupts; 
The execution time or CPU time of a gi ven interrupt Interrupt is defined as the time spent by the system 
executing interrupt handlers identified by Interrupt, including the time spent executing run-time or system 
services on its behalf. The mechanism used to measure execution time is implementation defined. Time spent executing interrupt handlers is distinct from time spent executing any task.  28/3 
29/2 30/2 31/2 32/3 33/2 34/2 
35/2 
36/2 
37/2 
38/2 
1/3 
2/3 
3/3 
4/3 
Ada Reference Manual — 2012 Edition 
D.14.3    Execution Time of Interrupt Handlers 13 December 2012      664 For each interrupt, the execution time value is initially set to zero.  
Dynamic Semantics 
The function Clock returns the current cumulative execu tion time of the interrupt identified by Interrupt. If 
Separate_Interrupt_Clocks_Supported is set to  False the function raises Program_Error. 
The function Supported returns True if the implem entation is monitoring th e execution time of the 
interrupt identified by Interrupt; otherwise, it retu rns False. For any Interrupt_Id Interrupt for which 
Supported(Interrupt) returns False, the function Clock(Interrupt) will return a value equal to 
Ada.Execution_Time.Time_Of(0). 
D.15 Timing Events 
This subclause describes a language-defined package to  allow user-defined protected procedures to be 
executed at a specified time without the n eed for a task or a delay statement.  
Static Semantics 
The following language-defined library package exists:  
package Ada.Real_Time.Timing_Events is 
  type Timing_Event is tagged limited private ; 
  type Timing_Event_Handler 
       is access protected procedure  (Event : in out Timing_Event); 
  procedure  Set_Handler (Event   : in out Timing_Event; 
                         At_Time : in Time; 
                         Handler : in Timing_Event_Handler); 
  procedure  Set_Handler (Event   : in out Timing_Event; 
                         In_Time : in Time_Span; 
                         Handler : in Timing_Event_Handler); 
  function  Current_Handler (Event : Timing_Event) 
       return Timing_Event_Handler; 
  procedure  Cancel_Handler (Event     : in out Timing_Event; 
                            Cancelled : out Boolean); 
  function  Time_Of_Event (Event : Timing_Event) return Time; 
private 
  ... -- not specified by the language  
end Ada.Real_Time.Timing_Events; 
The type Timing_Event represents a tim e in the future when an event is  to occur. The type Timing_Event 
needs finalization (see 7.6). 
An object of type Timing_Event is said to be set if it is associated with a nonnull value of type 
Timing_Event_Handler and cleared  otherwise. All Timing_Event objects are initially cleared.  
The type Timing_Event_Handler identifies a protected  procedure to be executed by the implementation 
when the timing event occurs. Such a protected procedure is called a handler .  
Dynamic Semantics 
The procedures Set_Handler associate the handler  Handler with the event Event: if Handler is null, the 
event is cleared; otherwise, it is se t. The first procedure Set_Handler sets the execution time for the event 
to be At_Time. The second procedure Set_Handler  sets the execution time for the event to be 
Real_Time.Clock + In_Time. 
A call of a procedure Set_Handler for an event that is already set replaces the handler and the time of 
execution; if Handler is not null, the event remains set. 5/3 
6/3 
7/3 
1/3 
2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
8/2 
9/2 
10/2 
11/3 
12/2 
Ada Reference Manual — 2012 Edition 
665      13 December 2012 Timing Events   D.15 As soon as possible after the time set for the event, the handler is execute d, passing the event as parameter. 
The handler is only executed if the timing event is in  the set state at the time of execution. The initial 
action of the execution of the handler is to clear the event. 
If the Ceiling_Locking policy (see D.3) is in effect wh en a procedure Set_Handler is called, a check is 
made that the ceiling priority of Handler. all is Interrupt_Priority'Last. If the check fails, Program_Error is 
raised. 
If a procedure Set_Handler is called with zero or ne gative In_Time or with At_Time indicating a time in 
the past, then the handler is execu ted as soon as possible after the co mpletion of the call of Set_Handler. 
The function Current_Handler returns the handler associ ated with the event Even t if that event is set; 
otherwise, it returns null. 
The procedure Cancel_Handler clears the event if it is set. Cancelled is assigned True if the event was set 
prior to it being cleared; otherwise, it is assigned False. 
The function Time_Of_Event returns the time of the event if the event is se t; otherwise, it returns 
Real_Time.Time_First. 
As part of the finalization of an object of type Timing_Event, the Timing_Event is cleared. If several timing events are set for the same time, they are executed in FIFO order of being set. 
An exception propagated from a handler invoked by a timing event has no effect. 
Implementation Requirements 
For a given Timing_Event object, the implementation shall perform the operati ons declared in this 
package atomically with respect to any of th ese operations on the same Timing_Event object. The 
replacement of a handler by a call of Set_Handler shall be performed atomically with respect to the execution of the handler. 
Metrics 
The implementation shall document the following metric:  
• An upper bound on the lateness of the execution of a handler. That is, the maximum time 
between the time specified for the event and when a handler is actually invoked assuming no 
other handler or task is executing during this interval. 
Implementation Advice 
The protected handler procedure should be executed dir ectly by the real-time cl ock interrupt mechanism. 
NOTES 
46  Since a call of Set_Handler is not a potentially blocking operation, it can be called from within a handler. 
47  A Timing_Event_Handler can be associated with several Timing_Event objects. 13/2 
14/2 
15/3 
16/3 17/3 18/3 19/2 
20/2 21/2 
22/2 
23/2 
24/3 
25/2 
26/2 
27/2 
Ada Reference Manual — 2012 Edition 
D.16    Multiprocessor Implementation 13 December 2012      666 D.16 Multiprocessor Implementation 
This subclause allows implem entations on multiprocessor platforms to be configured.  
Static Semantics 
The following language-defined library package exists:  
package System.Multiprocessors is 
   pragma Preelaborate(Multiprocessors); 
   type CPU_Range is range  0 .. implementation-defined ; 
   Not_A_Specific_CPU : constant  CPU_Range := 0; 
   subtype CPU is CPU_Range range 1 .. CPU_Range'Last; 
   function  Number_Of_CPUs return CPU; 
end System.Multiprocessors; 
A call of Number_Of_CPUs returns the number of pro cessors available to the program. Within a given 
partition, each call on Number_Of_CPUs  will return the same value. 
For a task type (including the anonymous type of a single_task_declaration ) or subprogram, the following 
language-defined representation aspect may be specified: 
CPU The aspect CPU is an expression , which shall be of type 
System.Multiprocessors.CPU_Range. 
Legality Rules 
If the CPU aspect is speci fied for a subprogram, the expression  shall be static. 
The CPU aspect shall not be specified on a task interface type. 
Dynamic Semantics 
The expression  specified for the CPU aspect of a task is evaluated for each task object (see 9.1). The CPU 
value is then associated with the task object  whose task declaration specifies the aspect. 
The CPU aspect has no effect if it is specified for a subprogram other than th e main subprogram; the CPU 
value is not associated with any task. 
The CPU value is associated with the environment ta sk if the CPU aspect is specified for the main 
subprogram. If the CPU aspect is not  specified for the main subprogram  it is implementation defined on 
which processor the environment task executes.  
The CPU value determines the processor on which the task  will activate and execute; the task is said to be 
assigned to that processor. If the CPU value is Not_ A_Specific_CPU, then the task is not assigned to a 
processor. A task without a CPU aspect specified w ill activate and execute on the same processor as its 
activating task if the activating task is assigned a processor. If the CPU value is not in the range of 
System.Multiprocessors.CPU_Range or is greater than  Number_Of_CPUs the task is defined to have 
failed, and it becomes a completed task (see 9.2). 1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 13/3 
14/3 
Ada Reference Manual — 2012 Edition 
667      13 December 2012 Multiprocessor Dispatching Domains   D.16.1 D.16.1 Multiprocessor Dispatching Domains 
This subclause allows implementa tions on multiprocessor platforms to be partitioned into distinct 
dispatching domains during program startup. 
Static Semantics 
The following language-defined library package exists:  
with Ada.Real_Time; 
with Ada.Task_Identification; 
package System.Multiprocessors.Dispatching_Domains is 
   Dispatching_Domain_Error : exception ; 
   type Dispatching_Domain (<>) is limited private ; 
   System_Dispatching_Domain : constant  Dispatching_Domain; 
   function  Create (First, Last : CPU) return Dispatching_Domain; 
   function  Get_First_CPU (Domain : Dispatching_Domain) return CPU; 
   function  Get_Last_CPU  (Domain : Dispatching_Domain) return CPU; 
   function  Get_Dispatching_Domain 
      (T   : Ada.Task_Identification.Task_Id :=                  Ada.Task_Identification.Current_Task)            return Dispatching_Domain; 
   procedure  Assign_Task 
      (Domain : in out Dispatching_Domain; 
       CPU    : in     CPU_Range := Not_A_Specific_CPU; 
       T      : in     Ada.Task_Identification.Task_Id := 
                 Ada.Task_Identification.Current_Task); 
   procedure  Set_CPU 
      (CPU : in CPU_Range; 
       T   : in Ada.Task_Identification.Task_Id := 
                 Ada.Task_Identification.Current_Task); 
   function  Get_CPU 
      (T   : Ada.Task_Identification.Task_Id :=                  Ada.Task_Identification.Current_Task)            return CPU_Range; 
   procedure  Delay_Until_And_Set_CPU 
      (Delay_Until_Time : in Ada.Real_Time.Time; CPU : in CPU_Range); 
private 
   ... -- not specified by the language  
end System.Multiprocessors.Dispatching_Domains; 
The type Dispatching_Domain repres ents a series of processors on which a task may execute. Each 
processor is contained within exactly one Dispatch ing_Domain. System_Dispatc hing_Domain contains the 
processor or processors on which the environment task  executes. At program start-up all processors are 
contained within Syst em_Dispatching_Domain. 
For a task type (including the anonymous type of a single_task_declaration ), the following language-
defined representation aspect may be specified: 
Dispatching_Domain 
 The value of aspect Di spatching_Domain is an expression , which shall be of type 
Dispatching_Domains.Dispatching_D omain. This aspect is the domain to which the task (or 
all objects of the task type) are assigned. 
Legality Rules 
The Dispatching_Domain aspect shall not  be specified for a task interface. 1/3 
2/3 
3/3 
4/3 
5/3 6/3 7/3 8/3 9/3 
10/3 
11/3 
12/3 
13/3 
14/3 
15/3 
16/3 
17/3 
18/3 
19/3 
Ada Reference Manual — 2012 Edition 
D.16.1    Multiprocessor Dispatching Domains 13 December 2012      668 Dynamic Semantics 
The expression specified for the Dispatching_Domain as pect of a task is evaluated for each task object 
(see 9.1). The Dispatching_Domain valu e is then associated with the ta sk object whose task declaration 
specifies the aspect. 
If a task is not explicitly assigned to any domain, it is assigned to that of the activating task. A task always 
executes on some CPU in its domain. 
If both Dispatching_Domain and CPU are specified for a task, and the CPU value is not contained within 
the range of processors for the domain (and is not Not_A_Specific_CPU), the activation of the task is 
defined to have failed, and it b ecomes a completed task (see 9.2). 
The function Create creates and returns a Dispatching_D omain containing all the processors in the range 
First .. Last. These processors are removed from Sy stem_Dispatching_Domain. A call of Create will raise 
Dispatching_Domain_Error if any designated processor is not currently in Sy stem_Dispatching_Domain, 
or if the system cannot support a dis tinct domain over the processors identified, or if a processor has a task 
assigned to it, or if the allocation would leave Sy stem_Dispatching_Domain empty. A call of Create will 
raise Dispatching_Domain_Error if the calling task is not  the environment task, or if Create is called after 
the call to the main subprogram. 
The function Get_First_CPU returns the first CPU in Domain; Get_Last_CPU returns the last one. 
The function Get_Dispatching_Domain returns the Di spatching_Domain on which the task is assigned. 
A call of the procedure Assign_Task assigns task T to  the CPU within Dispatching_Domain Domain. Task 
T can now execute only on CPU unless CPU designates Not_A_Specific_CPU, in which case it can execute on any processor within Domain. The excepti on Dispatching_Domain_Error is propagated if T is 
already assigned to a Dispatching_Domain other than System_Dispatching_Domain, or if CPU is not one 
of the processors of Domain (and is not Not_ A_Specific_CPU). A call of Assign_Task is a task 
dispatching point for task T unless T is inside of a pr otected action, in which case the effect on task T is 
delayed until its next task dispatching point. If T is th e Current_Task the effect is immediate if T is not 
inside a protected action, otherwise the effect  is as soon as practical. Assigning a task to 
System_Dispatching_Domain that  is already assigned to that domain has no effect. 
A call of procedure Set_CPU assigns task T to th e CPU. Task T can now execute only on CPU, unless 
CPU designates Not_A_Specific_CPU, in which case it can execute on any processor within its Dispatching_Domain. The exception Dispatching_Domain_Error is propagated if CPU is not one of the 
processors of the Dispatching_Domain on which T is  assigned (and is not Not_A_Specific_CPU). A call 
of Set_CPU is a task dispatching point for task T unle ss T is inside of a protected action, in which case the 
effect on task T is delayed until its next task disp atching point. If T is the Current_Task the effect is 
immediate if T is not inside a protected action,  otherwise the effect is  as soon as practical. 
The function Get_CPU returns the processor assigned to task T, or Not_A_Specific_CPU if the task is not 
assigned to a processor. 
A call of Delay_Until_And_Set_CPU delays the calling task for the designated time and then assigns the 
task to the specified processor when the delay expires. The exception Dispatching_Domain_Error is 
propagated if P is not one of the processors of  the calling task's Dispatching_Domain (and is not 
Not_A_Specific_CPU). 20/3 
21/3 
22/3 
23/3 
24/3 
25/3 26/3 
27/3 
28/3 
29/3 
Ada Reference Manual — 2012 Edition 
669      13 December 2012 Multiprocessor Dispatching Domains   D.16.1 Implementation Requirements 
The implementation shall perfo rm the operations Assign_Tas k, Set_CPU, Get_CPU and 
Delay_Until_And_Set_CPU atomically with resp ect to any of these operations on the same 
dispatching_domain, processor or task. 
Implementation Advice 
Each dispatching domain should have se parate and disjoint ready queues. 
Documentation Requirements 
The implementation shall document th e processor(s) on which the clock interrupt is handled and hence 
where delay queue and ready queue manipulations occu r. For any Interrupt_Id whose handler can execute 
on more than one processor the implementation shall also document this set of processors. 
Implementation Permissions 
An implementation may limit the number of dispat ching domains that can be created and raise 
Dispatching_Domain_Error if an attemp t is made to exceed this number. 30/3 
31/3 
32/3 
33/3 

Ada Reference Manual — 2012 Edition 
671      13 December 2012 Distributed Systems   E Annex E 
(normative)  
Distributed Systems 
This Annex defines facilities for supporting the impl ementation of distributed systems using multiple 
partitions working cooperatively as part of a single Ada program.  
Post-Compilation Rules 
A distributed system  is an interconnection of one or more processing nodes  (a system resource that has 
both computational and storage capabilities), and zero or more storage nodes  (a system resource that has 
only storage capabilities, with the storage addressable by one or more processing nodes). 
A distributed program  comprises one or more partitions that execute independently (except when they 
communicate) in a distributed system. 
The process of mapping the partitions of a program to the nodes in a distributed system is called 
configuring the partitions of the program .  
Implementation Requirements 
The implementation shall provide means for explicitly  assigning library units to a partition and for the 
configuring and execution of a program consisting of  multiple partitions on a distributed system; the 
means are implementation defined.  
Implementation Permissions 
An implementation may require that the set of pro cessing nodes of a distributed  system be homogeneous. 
NOTES 
1  The partitions comprising a program may be executed on differently configured distributed systems or on a nondistributed system without requiring recompilation. A distributed program may be partitioned differently from the same set of library units without recompilation. The resulting execution is semantically equivalent. 
2  A distributed program retains the same type safety as the equivalent single partition program. 
E.1 Partitions 
The partitions of a distributed program are classified as either active or passive.  
Post-Compilation Rules 
An active partition  is a partition as defined in 10.2. A passive partition  is a partition that has no thread of 
control of its own, whose library  units are all preelaborated, a nd whose data and subprograms are 
accessible to one or more active partitions.  
A passive partition shall include only library_item s that either are declared pure or are shared passive (see 
10.2.1 and E.2.1). 
An active partition shall be configured on a processing node. A passive partition shall be configured either 
on a storage node or on a processing node. 
The configuration of the partitions of a program onto a distributed system shall be consistent with the 
possibility for data references or calls between the partitions implied by their semantic dependences. Any 
reference to data or call of a s ubprogram across partitions is called a remote access .  1 
2 
3 
4 
5 
6 
7 
8 
1 
2 
3 
4 5 
Ada Reference Manual — 2012 Edition 
E.1   Partitions 13 December 2012      672 Dynamic Semantics 
A library_item  is elaborated as part of the elaboration of  each partition that includes it. If a normal library 
unit (see E.2) has state, then a separate copy of the state exists in each active pa rtition that elaborates it. 
The state evolves independently in each such partition. 
An active partition terminates  when its environment task terminates. A partition becomes inaccessible  if it 
terminates or if it is aborted . An active partition is aborted when its  environment task is aborted. In 
addition, if a partition fails during its elaborati on, it becomes inaccessible to other partitions. Other 
implementation-defined events can also re sult in a partition becoming inaccessible.  
For a prefix  D that denotes a library-level declaration, excep ting a declaration of or within a declared-pure 
library unit, the following attribute is defined:  
D'Partition_Id 
 Denotes a value of the type universal_integer  that identifies the partition in which D was 
elaborated. If D denotes the declaration of a remote call interface library unit (see E.2.3) the given partition is the one where the body of D was elaborated.  
Bounded (Run-Time) Errors 
It is a bounded error for there to be cyclic elabor ation dependences between the active partitions of a 
single distributed program. The possible effects, in each of the partitions involved, are deadlock during 
elaboration, or the raising of Co mmunication_Error or Program_Error.  
Implementation Permissions 
An implementation may allow multiple active or passive  partitions to be configured on a single processing 
node, and multiple passive partitions to be confi gured on a single storage node. In these cases, the 
scheduling policies, treatment of priorities, and mana gement of shared resources  between these partitions 
are implementation defined.  
An implementation may allow separate copies of an active partition to be configured on different 
processing nodes, and to provide appropr iate interactions between the copi es to present a consistent state 
of the partition to other active partitions.  
In an implementation, the partitions of a distributed pr ogram need not be loaded and elaborated all at the 
same time; they may be loaded and elaborated one at a time over an extended period of time. An implementation may provide facilities to abort and relo ad a partition during the execution of a distributed 
program. 
An implementation may allow the state of some of the partitions of a distributed program to persist while 
other partitions of the program terminate and are later reinvoked.  
NOTES 
3  Library units are grouped into partitions after compile time, but before run time. At compile time, only the relevant library unit properties are identified using categorization pragmas. 
4  The value returned by the Partition_Id attribute can be used as a parameter to implementation-provided subprograms in 
order to query information about the partition. 6 
7 
8/1 
9 
10/2 
11 
12 
13 
14 
15 
16 
Ada Reference Manual — 2012 Edition 
673      13 December 2012 Categor ization of Library Units   E.2 E.2 Categorization of Library Units 
Library units can be categorized according to the ro le they play in a distributed program. Certain 
restrictions are associated with each category to ensure  that the semantics of a distributed program remain 
close to the semantics for a nondistributed program. 
A categorization pragma  is a library unit pragma (see 10. 1.5) that specifies a corresponding categorization 
aspect . A categorization aspect restricts the declarations, child units, or semantic dependences of the 
library unit to which it applies. A categorized library unit  is a library unit that has a categorization aspect 
that is True. 
The pragmas Shared_Passive, Remote_Types, and Remote_Call_Interface are categorization pragmas, and 
the associated aspects are categorization aspects. In addition, for the purposes of  this Annex, the aspect 
Pure (see 10.2.1) is considered a categorization aspect  and the pragma Pure is considered a categorization 
pragma. 
A library package or generic library package is called a shared passive  library unit if the Shared_Passive 
aspect of the unit is True.  A library pack age or generic library package is called a remote types  library 
unit if the Remote_Types aspect of the unit is True.  A library unit is called a remote call interface  if the 
Remote_Call_Interface aspect of the unit is True. A normal library unit  is one for which no categorization 
aspect is True.  
The various categories of library units and the associ ated restrictions are described in this and the 
following subclauses. The categories are related hierarchi cally in that the library units of one category can 
depend semantically only on library units of that categor y or an earlier one in the hierarchy, except that the 
body of a remote types or remote call interface library  unit is unrestricted, the declaration of a remote 
types or remote call interface library unit may depend on preelaborated normal library units that are mentioned only in private with clauses, a nd all categories can depend on limited views. 
The overall hierarchy (including declared pure) is as follows, with a lower-numbered category being 
“earlier in the hierarchy” in the sense of the previous paragraph:  
1. Declared Pure 
2. Shared Passive 3. Remote Types 4. Remote Call Interface 5. Normal (no restrictions)  
Paragraphs 7 through 11 were deleted.   
Declared pure and shared passive library units are pr eelaborated. The declaration of a remote types or 
remote call interface library unit is required to be preelaborable.  
Paragraph 13 was deleted.   
Implementation Permissions 
Implementations are allowed to defi ne other categorization pragmas. 1 
2/3 
3/3 
4/3 
5/3 
6/3 
6.1/3 
6.2/3 6.3/3 6.4/3 6.5/3 
12 
14 
Ada Reference Manual — 2012 Edition 
E.2.1    Shared Passive Library Units 13 December 2012      674 E.2.1 Shared Passive Library Units 
A shared passive library unit is used for managi ng global data shared between active partitions. The 
restrictions on shared passive library units prevent the data or tasks of one active partition from being 
accessible to another active partition through references implicit in objects declared in the shared passive 
library unit.  
Syntax 
The form of a pragma  Shared_Passive is as follows:  
  pragma  Shared_Passive[( library_unit_ name )]; 
Legality Rules 
A pragma  Shared_Passive is used to specify that a library unit is a shared passive library unit , namely that 
the Shared_Passive aspect of the library unit is True . The following restrictions apply to such a library 
unit: 
• it shall be preelaborable (see 10.2.1);  
• it shall depend semantically only upon declared pure or shared passive library_item s;  
• it shall not contain a library-level declaration of an access type that designates a class-wide type, 
task type, or protected type with entry_declaration s.  
Notwithstanding the definition of accessibility given in 3. 10.2, the declaration of a library unit P1 is not 
accessible from within the declarative region of a shared  passive library unit P2, unless the shared passive 
library unit P2 depends semantically on P1.  
Static Semantics 
A shared passive library unit is preelaborated. 
Post-Compilation Rules 
A shared passive library unit shall be assigned to  at most one partition within a given program. 
Notwithstanding the rule given in 10.2, a compilation unit in a given partition does not need  (in the sense 
of 10.2) the shared passive library units on which it depends semantically to be included in that same 
partition; they will typically reside in separate passive partitions. 
E.2.2 Remote Types Library Units 
A remote types library unit supports the definition of types intended for use in communication between 
active partitions.  
Syntax 
The form of a pragma  Remote_Types is as follows:  
  pragma  Remote_Types[( library_unit_ name )]; 
Legality Rules 
A pragma  Remote_Types is used to sp ecify that a library unit is a remote types library unit , namely that 
the Remote_Types aspect of the libra ry unit is True. The following restrictions apply to the declaration of 
such a library unit: 
• it shall be preelaborable; 1 
2 
3 
4/3 
5 
6/3 7/1 
8 
9 
10 
11 
1 
2 
3 
4/3 
5 
Ada Reference Manual — 2012 Edition 
675      13 December 2012 Remote Types Library Units   E.2.2 • it shall depend semantically only on declared pure library_item s, shared passive library units, 
other remote types library units, or preelaborated  normal library units that are mentioned only in 
private with clauses; 
• it shall not contain the declaration of any variab le within the visible part of the library unit;  
• the full view of each type declared in the visibl e part of the library unit that has any available 
stream attributes shall support ex ternal streaming (see 13.13.2).  
A named access type declared in the visible part of a remote types or remote call interface library unit is 
called a remote access type . Such a type shall be: 
• an access-to-subprogram type, or 
• a general access type that designates a class-wide limited private type, a class-wide limited 
interface type, or a class-wide private extensi on all of whose ancestors are either private 
extensions, limited interface types, or limited private types.  
A type that is derived from a remote access type is also a remote access type. 
The following restrictions apply to the us e of a remote access-to-subprogram type:  
• A value of a remote access-to-subprogram type shall be converted only to or from another 
(subtype-conformant) remote access-to-subprogram type; 
• The prefix  of an Access attribute_reference  that yields a value of a remote access-to-
subprogram type shall statically denote a (subtype-conformant) remote subprogram.  
The following restrictions apply to the use of a remote access-to-class-wide type:  
• The primitive subprograms of the corresponding sp ecific type shall only have access parameters 
if they are controlling formal parameters. Th e primitive functions of the corresponding specific 
type shall only have an access result if it is  a controlling access result. Each noncontrolling 
formal parameter and noncontrolling result type shall support external streaming (see 13.13.2); 
• The corresponding specific type shall not have a primitive procedure with the Synchronization 
aspect specified unless the synchronization_kind  is Optional (see 9.5); 
• A value of a remote access-to-class-wide type shall be explicitly converted only to another 
remote access-to-class-wide type; 
• A value of a remote access-to-class-wide type sh all be dereferenced (or implicitly converted to 
an anonymous access type) only as part of a dispatching call where the value designates a 
controlling operand of the call (see E.4, “Remote S ubprogram Calls”); 
• A controlling access result value for a primitive function with any controlling operands of the 
corresponding specific type shall either be explic itly converted to a remote access-to-class-wide 
type or be part of a dispatching call where th e value designates a controlling operand of the call; 
• The Storage_Pool attribute is not defined for a remote access-to-class-wide type; the expected 
type for an allocator  shall not be a remote access-to-class-wide type. A remote access-to-class-
wide type shall not be an actual parameter for a generic formal access type. The Storage_Size attribute of a remote access-to-class-wide type yields 0; it is not allowed in an 
attribute_definition_clause .  
NOTES 
5  A remote types library unit need not be pure, and the types it defines may include levels of indirection implemented by using access types. User-specified Read and Write attributes (see 13.13.2) provide for sending values of such a type between active partitions, with Write marshalling the representation, and Read unmarshalling any levels of indirection. 
6  The value of a remote acce ss-to-class-wide lim ited interface can designate  an object of a nonlim ited type de rived from 
the interface. 6/3 
7 
8/2 
9/3 
9.1/1 
9.2/3 
9.3/1 
10 
11/2 
12 13 
14/3 
14.1/3 
15 16 
16.1/3 
17/2 
18 
19/3 
Ada Reference Manual — 2012 Edition 
E.2.2    Remote Types Library Units 13 December 2012      676 7  A remote access type may designate a class-wide synchronized, protected, or task interface type.  
E.2.3 Remote Call Interface Library Units 
A remote call interface library unit can be used as an interface for remote procedure calls (RPCs) (or 
remote function calls) between active partitions.  
Syntax 
The form of a pragma  Remote_Call_Interface is as follows:  
  pragma  Remote_Call_Interface[( library_unit_ name )]; 
The form of a pragma  All_Calls_Remote is as follows:  
  pragma  All_Calls_Remote[( library_unit_ name )]; 
A pragma  All_Calls_Remote is a library unit pragma.  
Legality Rules 
A pragma  Remote_Call_Interface is used to specify that a library unit is a remote call interface (RCI) , 
namely that the Remote_Call_Interface aspect of the library unit is True. A subprogram declared in the 
visible part of such a library unit, or declared by such a library unit, is called a remote subprogram . 
The declaration of an RCI library unit shall be preel aborable (see 10.2.1), and shall depend semantically 
only upon declared pure library_item s, shared passive library units, remote types library units, other 
remote call interface library units, or preelaborated nor mal library units that are mentioned only in private 
with clauses. 
In addition, the following restrictions apply to an RCI library unit:  
• its visible part shall not contain the declaration of a variable;  
• its visible part shall not contain the declaration of a limited type;  
• its visible part shall not contain a nested generic_declaration ;  
• it shall not be, nor shall its visible part contain,  the declaration of a subprogram for which aspect 
Inline is True; 
• it shall not be, nor shall its visible part  contain, a subprogram (or access-to-subprogram) 
declaration whose profile has a parameter or re sult of a type that does not support external 
streaming (see 13.13.2); 
• any public child of the library unit shall be a remote call interface library unit.  
A pragma All_Calls_Remote sets the All_Calls_Remote representation asp ect of the library unit to which 
the pragma applies to the value True. If the All_Calls_R emote aspect of a library unit is True, the library 
unit shall be a remote call interface. 
Post-Compilation Rules 
A remote call interface library unit shall be assigned to  at most one partition of a given program. A remote 
call interface library unit whose parent is also an RCI library unit shall be assigned only to the same partition as its parent.  
Notwithstanding the rule given in 10.2, a compilation unit in a given partition that semantically depends 
on the declaration of an RCI library unit, needs  (in the sense of 10.2) only the declaration of the RCI 
library unit, not the body, to be included in that same partition. Therefore, the body of an RCI library unit is included only in the partition to which th e RCI library unit is explicitly assigned. 20/3 
1 
2 
3 
4 
5 
6 
7/3 
8/3 
9/1 
10/1 
11/1 12/1 13/3 
14/3 
15 
16/3 
17 
18 
Ada Reference Manual — 2012 Edition 
677      13 December 2012 Remote Call Interface Library Units   E.2.3 Implementation Requirements 
If aspect All_Calls_Remote is True for a given RCI library unit, then the implementation shall route any 
call to a subprogram of the RCI unit from outside th e declarative region of the unit through the Partition 
Communication Subsystem (PCS); see E.5. Calls to such subprograms fro m within the declarative region 
of the unit are defined to be local and shall not go through the PCS.  
Implementation Permissions 
An implementation need not support the Remote _Call_Interface pragma or aspect nor the 
All_Calls_Remote pragma. Explicit message-based communication between active partitions can be 
supported as an alternative to RPC.  
E.3 Consistency of a Distributed System 
This subclause defines attributes and rules associated with verifyi ng the consistency of a distributed 
program.  
Static Semantics 
For a prefix  P that statically denotes a program unit,  the following attributes are defined:  
P'Version Yields a value of the predefined type String that identifies the version of the compilation 
unit that contains the declar ation of the program unit. 
P'Body_Version 
 Yields a value of the predefined type Stri ng that identifies the version of the compilation 
unit that contains the body (but not any subunits) of the program unit.  
The version  of a compilation unit changes whenever the compilation unit changes in a semantically 
significant way. This International Standard does not define the exact meaning of "semantically 
significant". It is unspecified whether there are othe r events (such as recompila tion) that result in the 
version of a compilation unit changing.  
If P is not a library unit, and P has no completion, then P'Body_Version returns the Body_Version of the 
innermost program unit enclosing the d eclaration of P. If P is a library unit, and P has no completion, then 
P'Body_Version returns a value that is different from Body_Version of any version of P that has a 
completion.  
Bounded (Run-Time) Errors 
In a distributed program, a library unit is consistent  if the same version of its declaration is used 
throughout. It is a bounded error to elaborate a partition of a distributed program that contains a compilation unit that depends on a different version of the declaration of a shared passive or RCI library 
unit than that included in the partition to which the sh ared passive or RCI library unit was assigned. As a 
result of this error, Program_Error can be raised in one or both partitions during elaboration; in any case, 
the partitions become inaccessible to one another.  
E.4 Remote Subprogram Calls 
A remote subprogram call  is a subprogram call that invokes the execution of a subprogram in another 
partition. The partition that originates  the remote subprogram call is the calling partition , and the partition 
that executes the corresponding subprogram body is the called partition . Some remote procedure calls are 19/3 
20/3 
1/3 
2/1 
3 
4 
5/1 
5.1/1 
6 
1 
Ada Reference Manual — 2012 Edition 
E.4   Remote Subprogram Calls 13 December 2012      678 allowed to return prior to the completi on of subprogram execution. These are called asynchronous remote 
procedure calls . 
There are three different ways of performing a remote subprogram call:  
• As a direct call on a (remote) subprogram exp licitly declared in a remote call interface; 
• As an indirect call through a value of a remote access-to-subprogram type; 
• As a dispatching call with a controlling operand designated by a value of a remote access-to-
class-wide type.  
The first way of calling corresponds to a static  binding between the calling and the called partition. The 
latter two ways correspond to a dynamic  binding between the calling and the called partition. 
Remote types library units (see E.2.2) and remote call interface library units (see E.2.3) define the remote 
subprograms or remote access types used for remote subprogram calls.  
Legality Rules 
In a dispatching call with two or more controlling operands, if one controlling operand is designated by a 
value of a remote access-to-class-wide type, then all shall be.  
Dynamic Semantics 
For the execution of a remote subprogram call, subprogr am parameters (and later the results, if any) are 
passed using a stream-oriented representation (see 13. 13.1) which is suitable for transmission between 
partitions. This action is called marshalling . Unmarshalling  is the reverse action of reconstructing the 
parameters or results from the stream-oriented represen tation. Marshalling is performed initially as part of 
the remote subprogram call in the calling partition; unm arshalling is done in the called partition. After the 
remote subprogram completes, marshalling is performed  in the called partition, and finally unmarshalling 
is done in the calling partition. 
A calling stub  is the sequence of code that replaces the subprogram body of a remotely called subprogram 
in the calling partition. A receiving stub  is the sequence of code (the “wrapper”) that receives a remote 
subprogram call on the called partition and invokes the appropriate subprogram body.  
Remote subprogram calls are executed at most once, th at is, if the subprogram call returns normally, then 
the called subprogram's body was executed exactly once. 
The task executing a remote subprogram call blocks until the subprogram in the called partition returns, 
unless the call is asynchronous. For an asynchronous re mote procedure call, the calling task can become 
ready before the procedure in the called partition returns. 
If a construct containing a remote call is aborted, the remote subprogram call is cancelled . Whether the 
execution of the remote subprogram is immediately a borted as a result of the cancellation is implemen-
tation defined.  
If a remote subprogram call is received by a calle d partition before the partition has completed its 
elaboration, the call is kept pending until the called pa rtition completes its elaboration (unless the call is 
cancelled by the calling partition prior to that). 
If an exception is propagated by a remotely called s ubprogram, and the call is not  an asynchronous call, 
the corresponding exception is reraised at the point of  the remote subprogram call. For an asynchronous 
call, if the remote procedure call returns prior to the completion of the remotely called subprogram, any 
exception is lost. 2 
3 
4 5 
6 
7/3 
8 
9 
10 
11 
12 
13 
14 
15 
Ada Reference Manual — 2012 Edition 
679      13 December 2012 Remote Subprogram Calls   E.4 The exception Communication_Error (see E.5) is raised if a remote call cannot be completed due to 
difficulties in communicating with the called partition. 
All forms of remote subprogr am calls are potentially bloc king operations (see 9.5.1).  
In a remote subprogram call with a fo rmal parameter of a class-wide type, a check is made that the tag of 
the actual parameter identifies a tagged type declared in  a declared-pure or shared passive library unit, or 
in the visible part of a remote types or remote call interface library unit. Program_Error is raised if this check fails. In a remote function call which returns a class-wide type, the same check is made on the function result.  
In a dispatching call with two or more controlling ope rands that are designated by values of a remote 
access-to-class-wide type, a check is made (in additi on to the normal Tag_Check — see 11.5) that all the 
remote access-to-class-wide values originated from Access 
attribute_reference s that were evaluated by 
tasks of the same active partition. Constrai nt_Error is raised if  this check fails.  
Implementation Requirements 
The implementation of remote subprogram calls sha ll conform to the PCS interface as defined by the 
specification of the language-defined package Syst em.RPC (see E.5). The calling stub shall use the 
Do_RPC procedure unless the remote procedure call is asynchronous in which case Do_APC shall be 
used. On the receiving side, the corresponding receivi ng stub shall be invoked by the RPC-receiver.  
With respect to shared variables in shared pa ssive library units, the execution of the corresponding 
subprogram body of a synchronous remote procedure call is  considered to be part of the execution of the 
calling task. The execution of the corresponding subprogr am body of an asynchronous remote procedure 
call proceeds in parallel with the calling task and doe s not signal the next action of the calling task (see 
9.10).  
NOTES 
8  A given active partition can both make and receive remote subprogram calls. Thus, an active partition can act as both a 
client and a server. 
9  If a given exception is propagated by a remote subprogram call, but the exception does not exist in the calling partition, 
the exception can be handled by an others  choice or be propagated to and handled by a third partition.  
E.4.1 Asynchronous Remote Calls 
This subclause introduces the aspect Asynchronous which can be sp ecified to allow a remote subprogram 
call to return prior to completion of the execu tion of the corresponding remote subprogram body.  
Paragraphs 2 through 7 were deleted.   
Static Semantics 
For a remote procedure, the following language-def ined representation aspect may be specified:  
Asynchronous The type of aspect Asynchr onous is Boolean. If directly specified, the aspect_definition  
shall be a static expression. If not specified, the aspect is False. 
For a remote access type, the following language-defin ed representation aspect may be specified:  
Asynchronous The type of aspect Asynchr onous is Boolean. If directly specified, the aspect_definition  
shall be a static expression. If not specified (inc luding by inheritance), the aspect is False.  16 
17 
18/1 
19 
20 
20.1/1 
21 
22 
1/3 
8/3 
8.1/3 
8.2/3 
8.3/3 
Ada Reference Manual — 2012 Edition 
E.4.1    Asynchronous Remote Calls 13 December 2012      680 Legality Rules 
If aspect Asynchronous is specified for a remote proce dure, the formal parameters of the procedure shall 
all be of mode in. 
If aspect Asynchronous is specified for a remote acce ss type, the type shall be a remote access-to-class-
wide type, or the type shall be a remote access-to-p rocedure type with the formal parameters of the 
designated profile of the type all of mode in.  
Dynamic Semantics 
A remote call is asynchronous  if it is a call to a procedure, or a call through a value of an access-to-
procedure type, for which aspect Asyn chronous is True. In addition, if aspect Asynchronous is True for a 
remote access-to-class-wide type, then a dispatch ing call on a procedure with a controlling operand 
designated by a value of the type is asynchronous if th e formal parameters of the procedure are all of mode 
in.  
Implementation Requirements 
Asynchronous remote procedure calls shall be impl emented such that the corresponding body executes at 
most once as a result of the call.  
E.4.2 Example of Use of a Remote Access-to-Class-Wide Type 
Examples 
Example of using a remote access-to-class-wide ty pe to achieve dynamic binding across active partitions:   
package Tapes is 
   pragma Pure(Tapes); 
   type Tape is abstract tagged limited private ; 
   -- Primitive dispatching operations where  
   -- Tape is controlling operand  
   procedure  Copy (From, To : access Tape; Num_Recs : in Natural) is 
abstract ; 
   procedure  Rewind (T : access Tape) is abstract ; 
   -- More operations  
private 
   type Tape is ... 
end Tapes; 
with Tapes; 
package Name_Server is 
   pragma Remote_Call_Interface; 
   -- Dynamic binding to remote operations is achieved  
   -- using the access-to-limited-class-wide type Tape_Ptr  
   type Tape_Ptr is access all  Tapes.Tape'Class; 
   -- The following statically bound remote operations  
   -- allow for a name-server capability in this example  
   function   Find     (Name : String) return Tape_Ptr; 
   procedure  Register (Name : in String; T : in Tape_Ptr); 
   procedure  Remove   (T : in Tape_Ptr); 
   -- More operations  
end Name_Server; 
package Tape_Driver is 
  -- Declarations are not shown, they are irrelevant here  
end Tape_Driver; 8.4/3 
8.5/3 
9/3 
10 
1 
2 
3 
4 
Ada Reference Manual — 2012 Edition 
681      13 December 2012 Example of Use of  a Remote Access-to-Class-Wide Type   E.4.2 with Tapes, Name_Server; 
package body  Tape_Driver is 
   type New_Tape is new Tapes.Tape with ... 
   procedure  Copy 
    (From, To : access New_Tape; Num_Recs: in Natural) is 
   begin 
     . . .    end Copy; 
   procedure  Rewind (T : access New_Tape) is 
   begin 
      . . .    end Rewind; 
   -- Objects remotely accessible through use  
   -- of Name_Server operations  
   Tape1, Tape2 : aliased New_Tape; 
begin 
   Name_Server.Register ("NINE-TRACK",  Tape1'Access);    Name_Server.Register ("SEVEN-TRACK", Tape2'Access); end Tape_Driver; 
with Tapes, Name_Server; 
-- Tape_Driver is not needed and thus not mentioned in the 
with_clause  
procedure  Tape_Client is 
   T1, T2 : Name_Server.Tape_Ptr; begin 
   T1 := Name_Server.Find ("NINE-TRACK");    T2 := Name_Server.Find ("SEVEN-TRACK");    Tapes.Rewind (T1);    Tapes.Rewind (T2);    Tapes.Copy (T1, T2, 3); end Tape_Client; 
Notes on the example :  
This paragraph was deleted.  
• The package Tapes provides the necessary declar ations of the type and its primitive operations. 
• Name_Server is a remote call interface package and is elaborated in a separate active partition to 
provide the necessary naming services (such as Register and Find) to the entire distributed 
program through remote subprogram calls. 
• Tape_Driver is a normal package that is elabor ated in a partition configured on the processing 
node that is connected to the tape device(s). The abstract operations are overridden to support 
the locally declared tape devices (Tape1, Tape2). The package is not visible to its clients, but it 
exports the tape devices (as remote objects) th rough the services of the Name_Server. This 
allows for tape devices to be dynamically a dded, removed or replaced without requiring the 
modification of the clients' code. 
• The Tape_Client procedure references only declarations in the Tapes and Name_Server 
packages. Before using a tape for the first time, it needs to query the Name_Server for a system-wide identity for that tape. From then on, it can use that identity to access the tape device. 
• Values of remote access type Tape_Ptr include the necessary information to complete the remote 
dispatching operations that result from derefe rencing the controlling operands T1 and T2. 5 
6 
7 
8/1 
9 
10 
11 
12 
13 
Ada Reference Manual — 2012 Edition 
E.5   Partition Communication Subsystem 13 December 2012      682 E.5 Partition Communication Subsystem 
The Partition Communication Subsystem  (PCS) provides facilities for supporting communication between 
the active partitions of a distributed program. The p ackage System.RPC is a language-defined interface to 
the PCS.  
Static Semantics 
The following language-defined library package exists:  
with Ada.Streams; -- see 13.13.1  
package System.RPC is 
   type Partition_Id is range  0 .. implementation-defined ; 
   Communication_Error : exception ; 
   type Params_Stream_Type ( 
      Initial_Size : Ada.Streams.Stream_Element_Count) is new 
      Ada.Streams.Root_Stream_Type with private; 
   procedure  Read( 
      Stream : in out Params_Stream_Type; 
      Item : out Ada.Streams.Stream_Element_Array; 
      Last : out Ada.Streams.Stream_Element_Offset); 
   procedure  Write( 
      Stream : in out Params_Stream_Type; 
      Item : in Ada.Streams.Stream_Element_Array); 
   -- Synchronous call  
   procedure  Do_RPC( 
      Partition  : in Partition_Id; 
      Params     : access Params_Stream_Type; 
      Result     : access Params_Stream_Type); 
   -- Asynchronous call  
   procedure  Do_APC( 
      Partition  : in Partition_Id; 
      Params     : access Params_Stream_Type); 
   -- The handler for incoming RPCs  
   type RPC_Receiver is access procedure ( 
      Params     : access Params_Stream_Type; 
      Result     : access Params_Stream_Type); 
   procedure  Establish_RPC_Receiver( 
      Partition : in Partition_Id; 
      Receiver  : in RPC_Receiver); 
private 
   ... -- not specified by the language  
end System.RPC; 
A value of the type Partition_Id is  used to identify a partition.  
An object of the type Params_Stream_T ype is used for identifying the par ticular remote subprogram that is 
being called, as well as marshalli ng and unmarshalling the parameters or result of a remote subprogram 
call, as part of sending them between partitions. 
The Read and Write procedures override the corresponding abstract operations for the type 
Params_Stream_Type. 
Dynamic Semantics 
The Do_RPC and Do_APC procedures send a message to the active partition identified by the Partition 
parameter.  1/2 
2 
3 
4 
5 6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
Ada Reference Manual — 2012 Edition 
683      13 December 2012 Partition Communication Subsystem   E.5 After sending the message, Do_RPC blocks the calli ng task until a reply message comes back from the 
called partition or some error is detected by the underlying communication system in which case 
Communication_Error is raised at th e point of the call to Do_RPC.  
Do_APC operates in the same way as Do_RPC except that it is allowed to return immediately after 
sending the message. 
Upon normal return, the stream designated by the Result parameter of Do_RPC contains the reply 
message. 
The procedure System.RPC.Establish_RPC_Receiver is called once, immediately after elaborating the 
library units of an active partition (that is, right after the elaboration of the partition ) if the partition 
includes an RCI library unit, but prior to invoking the main subprogram, if any. The Partition parameter is 
the Partition_Id of the active partition being ela borated. The Receiver parameter designates an 
implementation-provided procedure called the RPC-receiver  which will handle all RPCs received by the 
partition from the PCS. Establish_RPC_Receiver saves a reference to the RPC-receiver; when a message 
is received at the called partition, the RPC-receiver is called with the Params stream containing the 
message. When the RPC-receiver returns, the contents of the stream designated by Result is placed in a message and sent back to the calling partition.  
If a call on Do_RPC is aborted, a cancellation message is  sent to the called partition, to request that the 
execution of the remotely called subprogram be aborted.  
The subprograms declared in System.RPC  are potentially blocking operations.  
Implementation Requirements 
The implementation of the RPC-receiver shall be reen trant, thereby allowing concurrent calls on it from 
the PCS to service concurrent remote subprogram calls into the partition.  
An implementation shall not restrict the replacement of the body of System.RPC. An implementation shall 
not restrict children of System.RPC. The related im plementation permissions in the introduction to Annex 
A do not apply.  
If the implementation of System.RPC is provided by  the user, an implementa tion shall support remote 
subprogram calls as specified.  
Documentation Requirements 
The implementation of the PCS shall document whet her the RPC-receiver is invoked from concurrent 
tasks. If there is an upper limit on the number of such  tasks, this limit shall be documented as well, 
together with the mechan isms to configure it (i f this is supported).  
Implementation Permissions 
The PCS is allowed to contain implementation- defined interfaces for explicit message passing, 
broadcasting, etc. Similarly, it is allowed to provide additional interfaces to query the state of some remote 
partition (given its partition ID) or of the PCS itself,  to set timeouts and retry parameters, to get more 
detailed error status, etc. These additional interfaces s hould be provided in child packages of System.RPC.  
A body for the package System.RPC need not  be supplied by the implementation.  
An alternative declaration is allowed for package Sy stem.RPC as long as it provides a set of operations 
that is substantially equivalent to the specification defined in this subclause.  18 
19 
20 21 
22 
23 
24 
24.1/1 
24.2/1 
25 
26 
27 
27.1/3 
Ada Reference Manual — 2012 Edition 
E.5   Partition Communication Subsystem 13 December 2012      684 Implementation Advice 
Whenever possible, the PCS on the called partition should allow for multiple tasks to call the RPC-
receiver with different messages and should allow them to block until the corresponding subprogram body 
returns.  
The Write operation on a stream of type Params_Stream _Type should raise Storage_Error if it runs out of 
space trying to write the Item into the stream.  
NOTES 
10  The package System.RPC is not designed for direct calls by user programs. It is instead designed for use in the implementation of remote subpr ograms calls, being calle d by the calling stubs generated for a remote call in terface library 
unit to initiate a remote call, and in turn calling back to  an RPC-receiver that dispatches to the r eceiving stubs ge nerated 
for the body of a remote call interface, to handle a remote call received from elsewhere.  28 
29 
30 
Ada Reference Manual — 2012 Edition 
685      13 December 2012 Information Systems   F Annex F 
(normative)  
Information Systems 
This Annex provides a set of facilities relevant to  Information Systems programming. These fall into 
several categories:  
• an attribute definition clause specifying Machine_Radix for a decimal subtype; 
• the package Decimal, which declares a set of  constants defining the implementation's capacity 
for decimal types, and a generic pr ocedure for decimal division; and 
• the child packages Text_IO.Editing, Wide_Tex t_IO.Editing, and Wide_Wide_Text_IO.Editing, 
which support formatted and localized output of d ecimal data, based on “picture String” values.  
See also: 3.5.9, “Fixed Point Types” ; 3.5.10, “Operations of Fixed Poin t Types”; 4.6, “Type Conversions”; 
13.3, “Operational and Representa tion Attributes”; A.10.9, “Input-O utput for Real Types”; B.3, 
“Interfacing with C and C++”; B.4, “Inte rfacing with COBOL”; A nnex G, “Numerics”. 
The character and string handling packages in Anne x A, “Predefined Language Environment” are also 
relevant for Information Systems.  
Implementation Advice 
If COBOL (respectively, C) is widely supported in th e target environment, im plementations supporting the 
Information Systems Annex should provide the child package Interfaces.COBOL (respectively, 
Interfaces.C) specified in Annex B and should support a convention_ identifier  of COBOL (respectively, C) 
for the Convention aspect (see Annex B), thus allo wing Ada programs to interface with programs written 
in that language.  
F.1 Machine_Radix Attribute Definition Clause 
Static Semantics 
Machine_Radix may be specified for a decimal first subtype (see 3.5.9) via an attribute_definition_clause ; 
the expression of such a clause shall be static, and its value shall be 2 or 10. A value of 2 implies a binary 
base range; a value of 10 implies a decimal base range.  
Implementation Advice 
Packed decimal should be used as the internal representation for objects of subtype S when 
S'Machine_Radix = 10.  
Examples 
Example of Machine_Radix attribute definition clause:   
type Money is delta 0.01 digits 15; 
for Money'Machine_Radix use 10; 1 
2 
3 
4/2 5/2 
6 
7/3 
1 
2 
3 
4 
Ada Reference Manual — 2012 Edition 
F.2   The Package Decimal 13 December 2012      686 F.2 The Package Decimal 
Static Semantics 
The library package Decimal has the following declaration:  
package Ada.Decimal is 
   pragma Pure(Decimal); 
   Max_Scale : constant  := implementation-defined ; 
   Min_Scale : constant  := implementation-defined ; 
   Min_Delta : constant  := 10.0**(-Max_Scale); 
   Max_Delta : constant  := 10.0**(-Min_Scale); 
   Max_Decimal_Digits : constant  := implementation-defined ; 
   generic 
      type Dividend_Type  is delta <> digits <>; 
      type Divisor_Type   is delta <> digits <>; 
      type Quotient_Type  is delta <> digits <>; 
      type Remainder_Type is delta <> digits <>; 
   procedure  Divide (Dividend  : in Dividend_Type; 
                     Divisor   : in Divisor_Type; 
                     Quotient  : out Quotient_Type; 
                     Remainder : out Remainder_Type) 
      with Convention => Intrinsic; 
end Ada.Decimal; 
Max_Scale is the largest N such that 10.0**(–N) is allowed as a decimal type's delta. Its type is 
universal_integer . 
Min_Scale is the smallest N such that 10.0**(–N) is allowed as a decimal type's delta. Its type is 
universal_integer . 
Min_Delta is the smallest value allowed for delta  in a decimal_fixed_point_definition . Its type is 
universal_real . 
Max_Delta is the largest value allowed for delta  in a decimal_fixed_point_definition . Its type is 
universal_real . 
Max_Decimal_Digits is the largest value allowed for digits  in a decimal_fixed_point_definition . Its type is 
universal_integer .  
Static Semantics 
The effect of Divide is as follows. The value of Q uotient is Quotient_Type(Dividend/Divisor). The value 
of Remainder is Remainder_Type(In termediate), where Intermediate is the difference between Dividend 
and the product of Divisor and Quotien t; this result is co mputed exactly.  
Implementation Requirements 
Decimal.Max_Decimal_Digits shall be at least 18. 
Decimal.Max_Scale shall be at least 18. Decimal.Min_Scale shall be at most 0.  
NOTES 
1  The effect of division yielding a quotient with control over rounding versus truncation is obtained by applying either the function attribute Quotient_Type'Round or the conversion Quotient_Type to the expression Dividend/Divisor.  1 
2 
3 4 5 
6/3 
7 
8 
9 
10 11 12 
13 
14 
15 16 
17 
Ada Reference Manual — 2012 Edition 
687      13 December 2012 Edited Output for Decimal Types   F.3 F.3 Edited Output for Decimal Types 
The child packages Text_IO.Editing, Wide_Text_IO .Editing, and Wide_Wide_Text_IO.Editing provide 
localizable formatted text output, known as edited output , for decimal types. An edited output string is a 
function of a numeric value, program -specifiable locale elements, and a format control value. The numeric 
value is of some decimal type. The locale elements are:  
• the currency string; 
• the digits group separator character; 
• the radix mark character; and 
• the fill character that replaces lead ing zeros of the numeric value.  
For Text_IO.Editing the edited output and currency strings  are of type String, and the locale characters are 
of type Character. For Wide_Text_IO.Editing th eir types are Wide_String and Wide_Character, 
respectively. For Wide_Wide_Text_IO.Editing thei r types are Wide_Wide_String and Wide_Wide_-
Character, respectively. 
Each of the locale elements has a default valu e that can be replaced or explicitly overridden. 
A format-control value is of the private type Pictur e; it determines the com position of the edited output 
string and controls the form and placement of the sign,  the position of the locale elements and the decimal 
digits, the presence or absence of a radix mark, suppr ession of leading zeros, and insertion of particular 
character values. 
A Picture object is composed from a String value, known as a picture String , that serves as a template for 
the edited output string, and a Boolean value that controls whether a string of all space characters is produced when the number's value is zero. A picture String comprises a sequence of one- or two-Character 
symbols, each serving as a placeholder for a charact er or string at a corresponding position in the edited 
output string. The picture String symbols fall into se veral categories based on their effect on the edited 
output string:  
 Decimal Digit:  '9' 
 Radix Control:  '.'  'V'  Sign Control:  '+'  '–'  '<'  '>'  "CR"  "DB"  Currency Control:  '$'  '#'  Zero Suppression:  'Z'  '*'  Simple Insertion:  '_'  'B'  '0'  '/' 
The entries are not case-sensitive. Mixed- or lower- case forms for "CR" and "DB", and lower-case forms 
for 'V', 'Z', and 'B', have the same effect as the upper-case symbols shown. 
An occurrence of a '9' Character in  the picture String represents a decimal digit position in the edited 
output string. 
A radix control Character in the picture String indicat es the position of the radix mark in the edited output 
string: an actual character position for '.', or an assumed position for 'V'. 
A sign control Character in the picture String affects the form of the sign in the edited output string. The 
'<' and '>' Character values indicate parentheses for ne gative values. A Character '+', '–', or '<' appears 
either singly, signifying a fixed-position sign in th e edited output, or repeated, signifying a floating-
position sign that is preceded by zero or more space characters and that replaces a leading 0. 1/2 
2 
3 4 5 
6/2 
7 
8 
9 
10 
11 
12 13 14 
Ada Reference Manual — 2012 Edition 
F.3   Edited Output for Decimal Types 13 December 2012      688 A currency control Character in the picture String i ndicates an occurrence of the currency string in the 
edited output string. The '$' Character represents the co mplete currency string; the '#' Character represents 
one character of the currency string. A '$' Character appears either singly, indicating a fixed-position currency string in the edited output, or repeated, indi cating a floating-position currency string that occurs 
in place of a leading 0. A sequence of '#' Character values indicates either a fixed- or floating-position 
currency string, depending on context. 
A zero suppression Character in the picture String allows  a leading zero to be replaced by either the space 
character (for 'Z') or th e fill character (for '*'). 
A simple insertion Character in the picture String represen ts, in general, either itself (if '/' or '0'), the space 
character (if 'B'), or the digits group separator character (if '_'). In some contexts it is treated as part of a 
floating sign, floating currency,  or zero suppression string. 
An example of a picture String is "<###Z_ZZ9.99>". If the currency string is "kr", the separator character 
is ',', and the radix mark is '. ' then the edited output string values for the decimal values 32.10 and –
5432.10 are "bbkrbbb32.10b" and "(bkr5,432.10)", respectiv ely, where 'b' indicates the space character. 
The generic packages Text_IO.Decima l_IO, Wide_Text_IO.Decimal_IO, and 
Wide_Wide_Text_IO.Decimal_IO (s ee A.10.9, “Input-Output for Real Types”) provide text input and 
nonedited text output for decimal types.  
NOTES 
2  A picture String is of type Standard.String, for all of Text_IO.Editing, Wide_Text_IO.Editing, and Wide_Wide_Text_IO.Editing.  
F.3.1 Picture String Formation 
A well-formed picture String , or simply picture String , is a String value that conforms to the syntactic 
rules, composition constraints, and character repli cation conventions specified  in this subclause.  
Dynamic Semantics 
This paragraph was deleted.  
picture_string  ::= 
   fixed_$_picture_string  
 | fixed_#_picture_string  
 | floating_currency_picture_string  
 | non_currency_picture_string  
 15 
16 
17 
18/2 
19/2 
20/2 
1/3 
2/1 
3 
Ada Reference Manual — 2012 Edition 
689      13 December 2012 Pi cture String Formation   F.3.1 fixed_$_picture_string  ::= 
   [fixed_LHS_sign ] fixed_$_char  {direct_insertion } [zero_suppression ] 
     number  [RHS_sign ] 
  | [
fixed_LHS_sign  {direct_insertion }] [zero_suppression ] 
     number  fixed_$_char  {direct_insertion } [RHS_sign ] 
  | 
floating_LHS_sign  number  fixed_$_char  {direct_insertion } [RHS_sign ] 
  | [
fixed_LHS_sign ] fixed_$_char  {direct_insertion } 
     all_zero_suppression_number  {direct_insertion }  [RHS_sign ] 
  | [
fixed_LHS_sign  {direct_insertion }] all_zero_suppression_number  {direct_insertion } 
     fixed_$_char  {direct_insertion } [RHS_sign ] 
  | 
all_sign_number  {direct_insertion } fixed_$_char  {direct_insertion } [RHS_sign ] 
 
fixed_#_picture_string  ::= 
   [fixed_LHS_sign ] single_#_currency  {direct_insertion } 
     [zero_suppression ] number  [RHS_sign ] 
  | [
fixed_LHS_sign ] multiple_#_currency  {direct_insertion } 
     zero_suppression  number  [RHS_sign ] 
  | [
fixed_LHS_sign  {direct_insertion }] [zero_suppression ] 
     number  fixed_#_currency  {direct_insertion } [RHS_sign ] 
  | 
floating_LHS_sign  number  fixed_#_currency  {direct_insertion } [RHS_sign ] 
  | [
fixed_LHS_sign ] single_#_currency  {direct_insertion } 
     all_zero_suppression_number  {direct_insertion } [RHS_sign ] 
  | [
fixed_LHS_sign ] multiple_#_currency  {direct_insertion } 
     all_zero_suppression_number  {direct_insertion } [RHS_sign ] 
  | [
fixed_LHS_sign  {direct_insertion }] all_zero_suppression_number  {direct_insertion } 
     fixed_#_currency  {direct_insertion } [RHS_sign ] 
  | 
all_sign_number  {direct_insertion } fixed_#_currency  {direct_insertion } [RHS_sign ] 
 
floating_currency_picture_string  ::= 
   [fixed_LHS_sign ] {direct_insertion } floating_$_currency  number  [RHS_sign ] 
 | [fixed_LHS_sign ] {direct_insertion } floating_#_currency  number  [RHS_sign ] 
 | [fixed_LHS_sign ] {direct_insertion } all_currency_number  {direct_insertion } [RHS_sign ] 
 4 
5 
6 
Ada Reference Manual — 2012 Edition 
F.3.1    Picture String Formati on 13 December 2012      690 non_currency_picture_string  ::= 
   [fixed_LHS_sign  {direct_insertion }] zero_suppression  number  [RHS_sign ] 
 | [floating_LHS_sign ] number  [RHS_sign ] 
 | [fixed_LHS_sign  {direct_insertion }] all_zero_suppression_number  {direct_insertion } 
     [RHS_sign ] 
 | all_sign_number  {direct_insertion } 
 | fixed_LHS_sign  direct_insertion  {direct_insertion } number  [RHS_sign ] 
 
fixed_LHS_sign  ::=  LHS_Sign  
LHS_Sign  ::=  + | – | < 
 
fixed_$_char  ::= $ 
 
direct_insertion  ::=  simple_insertion  
simple_insertion  ::=  _ | B | 0 | / 
 
zero_suppression  ::=  Z {Z | context_sensitive_insertion } | fill_string  
context_sensitive_insertion  ::=  simple_insertion  
 
fill_string  ::=  * {* | context_sensitive_insertion } 
 
number  ::= 
   fore_digits  [radix  [aft_digits ] {direct_insertion }] 
 | radix  aft_digits  {direct_insertion } 
fore_digits  ::= 9 {9 | direct_insertion } 
aft_digits  ::=  {9 | direct_insertion } 9 
radix  ::= . | V 
 
RHS_sign  ::= + | – | > | CR | DB 
 
floating_LHS_sign  ::= 
   LHS_Sign  {context_sensitive_insertion } LHS_Sign  {LHS_Sign  | context_sensitive_insertion } 
 
single_#_currency  ::= # 
multiple_#_currency  ::= ## {#} 
 
fixed_#_currency  ::= single_#_currency  | multiple_#_currency  
 
floating_$_currency  ::= 
   $ { context_sensitive_insertion } $ {$ | context_sensitive_insertion } 
 
floating_#_currency  ::= 
   # { context_sensitive_insertion } # {# | context_sensitive_insertion } 
 
all_sign_number  ::=  all_sign_fore  [radix  [all_sign_aft ]] [>] 7 
8 
9 
10 11 
12 
13 
14 
15 16 
17 
18 19 
20 21 
22 
23 
24 25 
26 
27 
Ada Reference Manual — 2012 Edition 
691      13 December 2012 Pi cture String Formation   F.3.1 all_sign_fore  ::= 
   sign_char  {context_sensitive_insertion } sign_char  {sign_char  | context_sensitive_insertion } 
all_sign_aft  ::= { all_sign_aft_char } sign_char  
 
all_sign_aft_char  ::=  sign_char  | context_sensitive_insertion  
sign_char  ::= + | – | < 
 
all_currency_number  ::=  all_currency_fore  [radix  [all_currency_aft ]] 
all_currency_fore  ::= 
   currency_char  {context_sensitive_insertion } 
     currency_char  {currency_char  | context_sensitive_insertion } 
all_currency_aft  ::= { all_currency_aft_char } currency_char  
 
all_currency_aft_char  ::= currency_char  | context_sensitive_insertion  
currency_char  ::= $ | # 
 
all_zero_suppression_number  ::=  all_zero_suppression_fore  [ radix  [all_zero_suppression_aft ]] 
all_zero_suppression_fore  ::= 
   zero_suppression_char  {zero_suppression_char  | context_sensitive_insertion } 
all_zero_suppression_aft  ::= { all_zero_suppression_aft_char } zero_suppression_char  
 
all_zero_suppression_aft_char  ::=  zero_suppression_char  | context_sensitive_insertion  
zero_suppression_char  ::= Z | * 
The following composition constraints apply to a picture String:  
• A floating_LHS_sign  does not have occurrences of different LHS_Sign  Character values. 
• If a picture String has '<' as fixed_LHS_sign , then it has '>' as RHS_sign . 
• If a picture String has '<' in a floating_LHS_sign  o r  i n  a n  all_sign_number , then it has an 
occurrence of '>'. 
• If a picture String has '+' or '–' as fixed_LHS_sign , in a floating_LHS_sign , or in an 
all_sign_number , then it has no RHS_sign  or '>' character. 
• An instance of all_sign_number  does not have occurrences of different sign_char  Character 
values. 
• An instance of all_currency_number  does not have occurrences of different currency_char  
Character values. 
• An instance of all_zero_suppression_number  does not have occurrences of different zero_-
suppression_char  Character values, except for possible cas e differences between 'Z' and 'z'.  
A replicable Character  is a Character that, by the above rules,  can occur in two c onsecutive positions in a 
picture String. 
A Character replication  is a String  
char & '(' & spaces & count_string  & ')' 
where char is a replicable Character, spaces  is a String (possibly empty) comprising only space Character 
values, and count_string  is a String of one or more decimal digit Character values. A Character replication 28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 42 
43/1 
44 45 46 47 
48 
49 
50 
Ada Reference Manual — 2012 Edition 
F.3.1    Picture String Formati on 13 December 2012      692 in a picture String has the same effect as (and is said to be equivalent to ) a String comprising n consecutive 
occurrences of char, where n=Integer'Value( count_string ). 
An expanded picture String  is a picture String containing no Character replications.  
NOTES 
3  Although a sign to the left of the number can float, a sign to the right of the number is in a fixed position.  
F.3.2 Edited Output Generation 
Dynamic Semantics 
The contents of an edited output string are based on:  
• A value, Item, of some decimal type Num, 
• An expanded picture String Pic_String, 
• A Boolean value, Blank_When_Zero, 
• A Currency string, 
• A Fill character, 
• A Separator character, and 
• A Radix_Mark character.  
The combination of a True value for Blank_When_Zero a nd a '*' character in Pic_String is inconsistent; no 
edited output string is defined.  
A layout error is identified in the rules below if l eading nonzero digits of Item, character values of the 
Currency string, or a negative sign would be truncated ; in such cases no edited output string is defined. 
The edited output string has lower bound 1 a nd upper bound N where N = Pic_String'Length + 
Currency_Length_Adjustment – Radix_Adjustment, and  
• Currency_Length_Adjustment = Currency'Length – 1 if there is some occurrence of '$' in 
Pic_String, and 0 otherwise. 
• Radix_Adjustment = 1 if there is an occurrence of 'V' or 'v' in Pic_Str, and 0 otherwise.  
Let the magnitude of Item be expressed as a base-10 number I p···I 1.F1···F q, called the displayed  magnitude  
of Item, where:  
• q = Min(Max(Num'Scale, 0), n) where n is 0 if Pic_String has no radix  and is otherwise the 
number of digit positions following radix  in Pic_String, where a digit position corresponds to an 
occurrence of '9', a zero_suppression_char  (for an all_zero_suppression_number ), a 
currency_char  (for an all_currency_number ), or a sign_char  (for an all_sign_number ). 
• I p /= 0 if p>0.  
If n < Num'Scale, then the above number is the result of rounding (away from 0 if exactly midway 
between values). 
If Blank_When_Zero = True and the displayed magnitude  of Item is zero, then the edited output string 
comprises all space character values. Otherwise, the pict ure String is treated as a sequence of instances of 
syntactic categories based on the rule s in F.3.1, and the edited output st ring is the concatenation of string 
values derived from these categories according to the following mapping rules. 51 
52 
1 
2 
3 4 5 6 7 8 9 
10 11 12 
13 
14 
15 
16 
17 
18 
Ada Reference Manual — 2012 Edition 
693      13 December 2012 Edited Output Generation   F.3.2 Table F-1 shows the mapping from a sign control sym bol to a corresponding character or string in the 
edited output. In the columns showing the edited output , a lower-case 'b' represents the space character. If 
there is no sign control symbol but the value of Item is negative, a layout error occurs and no edited output 
string is produced. 
  
 Table F-1: Edited Output for Sign Control Symbols  
 Sign Control 
Symbol  Edited Output for 
Nonnegative 
Number  Edited Output for  
Negative Number  
 '+' '+' '–' 
 '–' 'b' '–' 
 '<' 'b' '(' 
 '>' 'b' ')' 
 "CR" "bb" "CR" 
 "DB" "bb" "DB" 
  
An instance of fixed_LHS_sign  maps to a character as shown in Table F-1. 
An instance of fixed_$_char  maps to Currency. 
An instance of direct_insertion  maps to Separator if direct_insertion  = '_', and to the direct_insertion  
Character otherwise. 
An instance of number  maps to a string integer_part  & radix_part  & fraction_part  where:  
• The string for integer_part  is obtained as follows:  
1. Occurrences of '9' in fore_digits  of number  are replaced from right to left with the decimal 
digit character values for I 1, ..., I p, respectively. 
2. Each occurrence of '9' in fore_digits  to the left of the leftmost '9' replaced according to rule 
1 is replaced with '0'. 
3. If p exceeds the number of occurrences of '9' in fore_digits  of number , then the excess 
leftmost digits are eligible for use in the mapping of an instance of zero_suppression , 
floating_LHS_sign , floating_$_currency , or floating_#_currency  to the left of number ; if 
there is no such instance, then a layout erro r occurs and no edited output string is produced.  
• The radix_part  is:  
• "" if number  does not include a radix , if radix  = 'V', or if radix  = 'v' 
• Radix_Mark if number  includes '.' as radix   
• The string for fraction_part  is obtained as follows:  
1. Occurrences of '9' in aft_digits  of number  are replaced from left to right with the decimal 
digit character values for F 1, ... F q. 
2. Each occurrence of '9' in aft_digits  to the right of the rightmost '9' replaced according to 
rule 1 is replaced by '0'.  
An instance of zero_suppression  maps to the string obtained as follows:  19 
20 
21 22 
23 
24 
25 
26 27 
28 
29 
30 31 
32 
33 34 
Ada Reference Manual — 2012 Edition 
F.3.2    Edited Output Generation 13 December 2012      694 1. The rightmost 'Z', 'z', or '*' Character values are replaced with the excess digits (if any) from the 
integer_part  of the mapping of the number  to the right of the zero_suppression  instance, 
2. A context_sensitive_insertion  Character is replaced as though it were a direct_insertion  
Character, if it occurs to the right  of some 'Z', 'z', or '*' in zero_suppression  that has been 
mapped to an excess digit, 
3. Each Character to the left of the leftmost  Character replaced according to rule 1 above is 
replaced by:  
• the space character if the zero suppre ssion Character is 'Z' or 'z', or 
• the Fill character if the zero suppression Character is '*'.  
4. A layout error occurs if some excess digits remain after all 'Z', 'z', and '*' Character values in 
zero_suppression  have been replaced via rule 1; no edited output string is produced.  
An instance of RHS_sign  maps to a character or st ring as shown in Table F-1. 
An instance of floating_LHS_sign  maps to the string obtained as follows.  
1. Up to all but one of the rightmost LHS_Sign  Character values are replaced by the excess digits 
(if any) from the integer_part  of the mapping of the number  to the right of the 
floating_LHS_sign  instance. 
2. The next Character to the left is replaced w ith the character given by the entry in Table F-1 
corresponding to the LHS_Sign  Character. 
3. A context_sensitive_insertion  Character is replaced as though it were a direct_insertion  
Character, if it occurs to the right of the leftmost LHS_Sign  character replaced according to rule 
1. 
4. Any other Character is replaced by the space character.. 5. A layout error occurs if some excess digits remain after replacement via rule 1; no edited output 
string is produced.  
An instance of 
fixed_#_currency  maps to the Currency string with n space character values concatenated 
on the left (if the instance does not follow a radix ) or on the right (if the instance does follow a radix ), 
where n is the difference between the length of the fixed_#_currency  instance and Currency'Length. A 
layout error occurs if Currency'Length exceeds the length of the fixed_#_currency  instance; no edited 
output string is produced. 
An instance of floating_$_currency  maps to the string obtained as follows:  
1. Up to all but one of the rightmost '$' Character values are replaced with the excess digits (if any) 
from the integer_part  of the mapping of the number  to the right of the floating_$_currency  
instance. 
2. The next Character to the left is replaced by the Currency string. 3. A 
context_sensitive_insertion  Character is replaced as though it were a direct_insertion  
Character, if it occurs to the right of the leftmost '$' Character replaced via rule 1. 
4. Each other Character is replaced by the space character. 5. A layout error occurs if some excess digits remain after replacement by rule 1; no edited output 
string is produced.  
An instance of 
floating_#_currency  maps to the string obtained as follows:  35 
36 
37 
38 
39 40 
41 
42 43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
Ada Reference Manual — 2012 Edition 
695      13 December 2012 Edited Output Generation   F.3.2 1. Up to all but one of the rightmost '#' Character values are replaced with the excess digits (if any) 
from the integer_part  of the mapping of the number  to the right of the floating_#_currency  
instance. 
2. The substring whose last Character occurs at the position immediately preceding the leftmost 
Character replaced via rule 1, and whose length is Currency'Length, is replaced by the Currency 
string. 
3. A context_sensitive_insertion  Character is replaced as though it were a direct_insertion  
Character, if it occurs to the right of the leftmost '#' replaced via rule 1. 
4. Any other Character is replaced by the space character. 5. A layout error occurs if some excess digits remain after replacement rule 1, or if there is no 
substring with the required length for replacemen t rule 2; no edited output string is produced.  
An instance of 
all_zero_suppression_number  maps to:  
• a string of all spaces if the displayed magnitude of Item is zero, the zero_suppression_char  is 
'Z' or 'z', and the instance of all_zero_suppression_number  does not have a radix  at its last 
character position; 
• a string containing the Fill character in each  position except for the character (if any) 
corresponding to radix , if zero_suppression_char  = '*' and the displayed magnitude of Item is 
zero; 
• otherwise, the same result as if each zero_suppression_char  in all_zero_suppression_aft  were 
'9', interpreting the instance of all_zero_suppression_number  as either zero_suppression  
number  (if a radix  and all_zero_suppression_aft  are present), or as zero_suppression  
otherwise.  
An instance of all_sign_number  maps to:  
• a string of all spaces if the displayed magnitude of Item is zero and the instance of 
all_sign_number  does not have a radix  at its last character position; 
• otherwise, the same result as if each sign_char  in all_sign_number_aft  were '9', interpreting the 
instance of all_sign_number  as either floating_LHS_sign  number  (if a radix  and 
all_sign_number_aft  are present), or as floating_LHS_sign  otherwise.  
An instance of all_currency_number  maps to:  
• a string of all spaces if the displayed magnitude of Item is zero and the instance of 
all_currency_number  does not have a radix  at its last character position; 
• otherwise, the same result as if each currency_char  in all_currency_number_aft  were '9', 
interpreting the instance of all_currency_number  as floating_$_currency  number  or 
floating_#_currency  number  (if a radix  and all_currency_number_aft  are present), or as 
floating_$_currency  or floating_#_currency  otherwise.  
Examples 
In the result string values shown below,  'b' represents the space character.  
Item:         Picture and Result Strings: 
123456.78     Picture:  "-###**_***_**9.99" 
              Result:   "bbb$***123,456.78"                         "bbFF***123.456,78" (currency = "FF",                                              separator = '.',                                              radix mark = ',') 56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73/3 
Ada Reference Manual — 2012 Edition 
F.3.2    Edited Output Generation 13 December 2012      696 123456.78     Picture:  "-$**_***_**9.99" 
              Result:   "b$***123,456.78"                        "bFF***123.456,78" (currency = "FF",                                            separator = '.',                                            radix mark = ',') 
0.0          Picture: "-$$$$$$.$$" 
             Result:  "bbbbbbbbbb" 
0.20         Picture: "-$$$$$$.$$" 
             Result:  "bbbbbb$.20" 
-1234.565    Picture: "<<<<_<<<.<<###>" 
             Result:  "bb(1,234.57DMb)"  (currency = "DM") 
12345.67     Picture: "###_###_##9.99" 
             Result:  "bbCHF12,345.67"   (currency = "CHF") 
F.3.3 The Package Text_IO.Editing 
The package Text_IO.Editing provides a private type Picture with associated operations, and a generic 
package Decimal_Output. An object of type Picture is composed from a well-formed picture String (see 
F.3.1) and a Boolean item indicating whether a zero num eric value will result in an edited output string of 
all space characters. The package Decimal_Output contains edited output subprograms implementing the 
effects defined in F.3.2.  
Static Semantics 
The library package Text_IO.Editing has the following declaration:  
package Ada.Text_IO.Editing is 
   type Picture is private; 
   function  Valid (Pic_String      : in String; 
                   Blank_When_Zero : in Boolean := False) return Boolean; 
   function  To_Picture (Pic_String      : in String; 
                        Blank_When_Zero : in Boolean := False) 
      return Picture; 
   function  Pic_String      (Pic : in Picture) return String; 
   function  Blank_When_Zero (Pic : in Picture) return Boolean; 
   Max_Picture_Length  : constant  := implementation_defined ; 
   Picture_Error       : exception ; 
   Default_Currency    : constant  String    := "$"; 
   Default_Fill        : constant  Character := '*'; 
   Default_Separator   : constant  Character := ','; 
   Default_Radix_Mark  : constant  Character := '.'; 
   generic 
      type Num is delta <> digits <>; 
      Default_Currency   : in String    := Text_IO.Editing.Default_Currency; 
      Default_Fill       : in Character := Text_IO.Editing.Default_Fill; 
      Default_Separator  : in Character := 
                              Text_IO.Editing.Default_Separator;       Default_Radix_Mark : in Character := 
                              Text_IO.Editing.Default_Radix_Mark;    package Decimal_Output is 
      function  Length (Pic      : in Picture; 
                       Currency : in String := Default_Currency) 
         return Natural; 
      function  Valid (Item     : in Num; 
                      Pic      : in Picture; 
                      Currency : in String := Default_Currency) 
         return Boolean; 74/1 
75 
76 77 78 
1 
2 
3 
4 5 
6 
7 
8 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
697      13 December 2012 The Package Text_IO.Editing   F.3.3       function  Image (Item       : in Num; 
                      Pic        : in Picture; 
                      Currency   : in String    := Default_Currency; 
                      Fill       : in Character := Default_Fill; 
                      Separator  : in Character := Default_Separator; 
                      Radix_Mark : in Character := Default_Radix_Mark) 
         return String; 
      procedure  Put (File       : in File_Type; 
                     Item       : in Num; 
                     Pic        : in Picture; 
                     Currency   : in String    := Default_Currency; 
                     Fill       : in Character := Default_Fill; 
                     Separator  : in Character := Default_Separator; 
                     Radix_Mark : in Character := Default_Radix_Mark); 
      procedure  Put (Item       : in Num; 
                     Pic        : in Picture; 
                     Currency   : in String    := Default_Currency; 
                     Fill       : in Character := Default_Fill; 
                     Separator  : in Character := Default_Separator; 
                     Radix_Mark : in Character := Default_Radix_Mark); 
      procedure  Put (To         : out String; 
                     Item       : in Num; 
                     Pic        : in Picture; 
                     Currency   : in String    := Default_Currency; 
                     Fill       : in Character := Default_Fill; 
                     Separator  : in Character := Default_Separator; 
                     Radix_Mark : in Character := Default_Radix_Mark); 
   end Decimal_Output; 
private 
   ... -- not specified by the language  
end Ada.Text_IO.Editing; 
The exception Constraint_Error is rais ed if the Image function or any of the Put procedures is invoked 
with a null string for Currency.  
function  Valid (Pic_String      : in String; 
                Blank_When_Zero : in Boolean := False) return Boolean; 
Valid returns True if Pic_String is a well-formed  picture String (see F.3.1) the length of whose 
expansion does not exceed Max_Pic ture_Length, and if either Blank_When_Zero is False or 
Pic_String contains no '*'. 
function  To_Picture (Pic_String      : in String; 
                     Blank_When_Zero : in Boolean := False) 
   return Picture; 
To_Picture returns a result Picture such that th e application of the function Pic_String to this 
result yields an expanded picture String e quivalent to Pic_String, and such that 
Blank_When_Zero applied to the result Pictur e is the same value as the parameter 
Blank_When_Zero. Picture_Error is raised if not Valid(Pic_String, Blank_When_Zero). 
function  Pic_String      (Pic : in Picture) return String; 
 function  Blank_When_Zero (Pic : in Picture) return Boolean; 
If Pic is To_Picture(String_Item, Boolean_Item) for some String_Item and Boolean_Item, then:  
• Pic_String(Pic) returns an expanded pictur e String equivalent to String_Item and with 
any lower-case letter replaced with its corresponding upper-case form, and 
• Blank_When_Zero(Pic) returns Boolean_Item.  
If Pic_1 and Pic_2 are objects of type Picture,  then "="(Pic_1, Pic_2) is True when  13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
Ada Reference Manual — 2012 Edition 
F.3.3    The Package Text_IO.Editing 13 December 2012      698 • Pic_String(Pic_1) = Pic_String(Pic_2), and 
• Blank_When_Zero(Pic_1) = Blank_When_Zero(Pic_2).  
function  Length (Pic      : in Picture; 
                 Currency : in String := Default_Currency) 
   return Natural; 
Length returns Pic_String(Pic)'Length + Cu rrency_Length_Adjustmen t – Radix_Adjustment 
where  
• Currency_Length_Adjustment =  
• Currency'Length – 1 if there is some occurrence of '$' in Pic_String(Pic), and 
• 0 otherwise.  
• Radix_Adjustment =  
• 1 if there is an occurrence of 'V' or 'v' in Pic_Str(Pic), and 
• 0 otherwise.  
function  Valid (Item     : in Num; 
                Pic      : in Picture; 
                Currency : in String := Default_Currency) 
   return Boolean; 
Valid returns True if Image(Item, Pic, Currency)  does not raise Layout_Error, and returns False 
otherwise. 
function  Image (Item       : in Num; 
                Pic        : in Picture; 
                Currency   : in String    := Default_Currency; 
                Fill       : in Character := Default_Fill; 
                Separator  : in Character := Default_Separator; 
                Radix_Mark : in Character := Default_Radix_Mark) 
   return String; 
Image returns the edited output String as de fined in F.3.2 for Item, Pic_String(Pic), 
Blank_When_Zero(Pic), Currency, Fill, Separato r, and Radix_Mark. If these rules identify a 
layout error, then Image raises the exception Layout_Error. 
procedure  Put (File       : in File_Type; 
               Item       : in Num; 
               Pic        : in Picture; 
               Currency   : in String    := Default_Currency; 
               Fill       : in Character := Default_Fill; 
               Separator  : in Character := Default_Separator; 
               Radix_Mark : in Character := Default_Radix_Mark); 
 procedure  Put (Item       : in Num; 
               Pic        : in Picture; 
               Currency   : in String    := Default_Currency; 
               Fill       : in Character := Default_Fill; 
               Separator  : in Character := Default_Separator; 
               Radix_Mark : in Character := Default_Radix_Mark); 
Each of these Put procedures outputs Image(Item , Pic, Currency, Fill, Separator, Radix_Mark) 
consistent with the conventions for Put for ot her real types in case of bounded line length (see 
A.10.6, “Get and Put Procedures”). 27 
28 
29 
30 
31 
32 
33 34 
35 
36 
37 
38 
39 
40 
41 
42 
Ada Reference Manual — 2012 Edition 
699      13 December 2012 The Package Text_IO.Editing   F.3.3 procedure  Put (To         : out String; 
               Item       : in Num; 
               Pic        : in Picture; 
               Currency   : in String    := Default_Currency; 
               Fill       : in Character := Default_Fill; 
               Separator  : in Character := Default_Separator; 
               Radix_Mark : in Character := Default_Radix_Mark); 
Put copies Image(Item, Pic, Currency, Fill, Sepa rator, Radix_Mark) to the given string, right 
justified. Otherwise, unassigned Character valu es in To are assigned the space character. If 
To'Length is less than the length of the string re sulting from Image, then Layout_Error is raised.  
Implementation Requirements 
Max_Picture_Length shall be at least 30. The impl ementation shall support currency strings of length up 
to at least 10, both for Default_Currency in an inst antiation of Decimal_Output, and for Currency in an 
invocation of Image or any of the Put procedures.  
NOTES 
4  The rules for edited output are based on COBOL (ANSI X3.23:1985, endorsed by ISO as ISO 1989-1985), with the following differences:  
• The COBOL provisions for picture string localization and for 'P' format are absent from Ada. 
• The following Ada facilities are not in COBOL:  
• currency symbol placement after the number, 
• localization of edited output string for multi-character currency string values, including support for both 
length-preserving and length-expanding currency symbols in picture strings 
• localization of the radix mark, digits separator, and fill character, and 
• parenthesization of negative values.  
The value of 30 for Max_Picture_Length is the same limit as in COBOL.  
F.3.4 The Package Wide_Text_IO.Editing 
Static Semantics 
The child package Wide_Text_IO.Editing has the sa me contents as Text_IO.Editing, except that:  
• each occurrence of Character is replaced by Wide_Character, 
• each occurrence of Text_IO is replaced by Wide_Text_IO, 
• the subtype of Default_Currency is Wide_String rather than String, and 
• each occurrence of String in the generic package Decimal_Output is replaced by Wide_String.  
NOTES 
5  Each of the functions Wide_Text_IO.Editing.Valid, To_Picture, and Pic_String has String (versus Wide_String) as its parameter or result subtype, since a picture String is not localizable.  
F.3.5 The Package Wide_Wide_Text_IO.Editing 
Static Semantics 
The child package Wide_Wide_Text_IO.Editing has the same contents as Text_IO.Editing, except that:  
• each occurrence of Character is replaced by Wide_Wide_Character, 
• each occurrence of Text_IO is replaced by Wide_Wide_Text_IO, 
• the subtype of Default_Currency is Wi de_Wide_String rather than String, and 43 
44/3 
45 
46 
47 
48 
49 
50 
51 
52 
52.1 
1 
2 
3 4 5 
6 
1/2 
2/2 
3/2 4/2 
Ada Reference Manual — 2012 Edition 
F.3.5    The Package Wide_Wide_Text_IO.Editing 13 December 2012      700 • each occurrence of String in the generic package Decimal_Output is replaced by 
Wide_Wide_String.  
NOTES 
6  Each of the functions Wide_Wide_Text_IO.Editing.Valid, To_Picture, and Pic_String has String (versus Wide_Wide_String) as its parameter or result subtype, since a picture String is not localizable.  5/2 
6/2 
Ada Reference Manual — 2012 Edition 
701      13 December 2012 Numerics   G Annex G 
(normative)  
Numerics 
The Numerics Annex specifies  
• features for complex arithmetic, including complex I/O; 
• a mode (“strict mode”), in which the predefined  arithmetic operations of floating point and fixed 
point types and the functions and operations of various predefined packages have to provide 
guaranteed accuracy or conform to other numeric performance requirements, which the Numerics Annex also specifies; 
• a mode (“relaxed mode”), in which no accuracy or other numeric performance requirements 
need be satisfied, as for implementations  not conforming to the Numerics Annex; 
• models of floating point and fixed point arithme tic on which the accuracy requirements of strict 
mode are based; 
• the definitions of the model-orie nted attributes of floating point types that apply in the strict 
mode; and 
• features for the manipulation of real and complex vectors and matrices.  
Implementation Advice 
If Fortran (respectively, C) is widely supported in th e target environment, im plementations supporting the 
Numerics Annex should provide the child package Inte rfaces.Fortran (respectively,  Interfaces.C) specified 
in Annex B and should support a convention_ identifier  of Fortran (respectively, C) for the Convention 
aspect (see Annex B), thus allowing Ada programs to  interface with programs written in that language.  
G.1 Complex Arithmetic 
Types and arithmetic operations for complex arithme tic are provided in Generic_Complex_Types, which 
is defined in G.1.1. Implementati on-defined approximations to the comp lex analogs of the mathematical 
functions known as the “elementary functions” are provided by the subprograms in Generic_Complex_-
Elementary_Functions, which is define d in G.1.2. Both of these library  units are generic children of the 
predefined package Numerics (see A. 5). Nongeneric equivalents of these generic packages for each of the 
predefined floating point types are also provided as children of Numerics.  
G.1.1 Complex Types 
Static Semantics 
The generic library package Numerics.Generic_C omplex_Types has the following declaration:  
generic 
   type Real is digits <>; 
package Ada.Numerics.Generic_Complex_Types is 
   pragma Pure(Generic_Complex_Types); 
   type Complex is 
      record 
         Re, Im : Real'Base;       end record; 1 
2 
3 
4 
5/2 6/2 
6.1/2 
7/3 
1 
1 
2/1 
3 
Ada Reference Manual — 2012 Edition 
G.1.1    Complex Types 13 December 2012      702    type Imaginary is private; 
   pragma Preelaborable_Initialization(Imaginary); 
   i : constant  Imaginary; 
   j : constant  Imaginary; 
   function  Re (X : Complex)   return Real'Base; 
   function  Im (X : Complex)   return Real'Base; 
   function  Im (X : Imaginary) return Real'Base; 
   procedure  Set_Re (X  : in out Complex; 
                     Re : in     Real'Base); 
   procedure  Set_Im (X  : in out Complex; 
                     Im : in     Real'Base); 
   procedure  Set_Im (X  :    out Imaginary; 
                     Im : in     Real'Base); 
   function  Compose_From_Cartesian (Re, Im : Real'Base) return Complex; 
   function  Compose_From_Cartesian (Re     : Real'Base) return Complex; 
   function  Compose_From_Cartesian (Im     : Imaginary) return Complex; 
   function  Modulus (X     : Complex) return Real'Base; 
   function  "abs"   (Right : Complex) return Real'Base renames Modulus; 
   function  Argument (X     : Complex)   return Real'Base; 
   function  Argument (X     : Complex; 
                      Cycle : Real'Base) return Real'Base; 
   function  Compose_From_Polar (Modulus, Argument        : Real'Base) 
      return Complex; 
   function  Compose_From_Polar (Modulus, Argument, Cycle : Real'Base) 
      return Complex; 
   function  "+"       (Right : Complex) return Complex; 
   function  "-"       (Right : Complex) return Complex; 
   function  Conjugate (X     : Complex) return Complex; 
   function  "+" (Left, Right : Complex) return Complex; 
   function  "-" (Left, Right : Complex) return Complex; 
   function  "*" (Left, Right : Complex) return Complex; 
   function  "/" (Left, Right : Complex) return Complex; 
   function  "**" (Left : Complex; Right : Integer) return Complex; 
   function  "+"       (Right : Imaginary) return Imaginary; 
   function  "-"       (Right : Imaginary) return Imaginary; 
   function  Conjugate (X     : Imaginary) return Imaginary renames "-"; 
   function  "abs"     (Right : Imaginary) return Real'Base; 
   function  "+" (Left, Right : Imaginary) return Imaginary; 
   function  "-" (Left, Right : Imaginary) return Imaginary; 
   function  "*" (Left, Right : Imaginary) return Real'Base; 
   function  "/" (Left, Right : Imaginary) return Real'Base; 
   function  "**" (Left : Imaginary; Right : Integer) return Complex; 
   function  "<"  (Left, Right : Imaginary) return Boolean; 
   function  "<=" (Left, Right : Imaginary) return Boolean; 
   function  ">"  (Left, Right : Imaginary) return Boolean; 
   function  ">=" (Left, Right : Imaginary) return Boolean; 
   function  "+" (Left : Complex;   Right : Real'Base) return Complex; 
   function  "+" (Left : Real'Base; Right : Complex)   return Complex; 
   function  "-" (Left : Complex;   Right : Real'Base) return Complex; 
   function  "-" (Left : Real'Base; Right : Complex)   return Complex; 
   function  "*" (Left : Complex;   Right : Real'Base) return Complex; 
   function  "*" (Left : Real'Base; Right : Complex)   return Complex; 
   function  "/" (Left : Complex;   Right : Real'Base) return Complex; 
   function  "/" (Left : Real'Base; Right : Complex)   return Complex; 4/2 
5 6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
Ada Reference Manual — 2012 Edition 
703      13 December 2012 Complex Types   G.1.1    function  "+" (Left : Complex;   Right : Imaginary) return Complex; 
   function  "+" (Left : Imaginary; Right : Complex)   return Complex; 
   function  "-" (Left : Complex;   Right : Imaginary) return Complex; 
   function  "-" (Left : Imaginary; Right : Complex)   return Complex; 
   function  "*" (Left : Complex;   Right : Imaginary) return Complex; 
   function  "*" (Left : Imaginary; Right : Complex)   return Complex; 
   function  "/" (Left : Complex;   Right : Imaginary) return Complex; 
   function  "/" (Left : Imaginary; Right : Complex)   return Complex; 
   function  "+" (Left : Imaginary; Right : Real'Base) return Complex; 
   function  "+" (Left : Real'Base; Right : Imaginary) return Complex; 
   function  "-" (Left : Imaginary; Right : Real'Base) return Complex; 
   function  "-" (Left : Real'Base; Right : Imaginary) return Complex; 
   function  "*" (Left : Imaginary; Right : Real'Base) return Imaginary; 
   function  "*" (Left : Real'Base; Right : Imaginary) return Imaginary; 
   function  "/" (Left : Imaginary; Right : Real'Base) return Imaginary; 
   function  "/" (Left : Real'Base; Right : Imaginary) return Imaginary; 
private 
   type Imaginary is new Real'Base; 
   i : constant  Imaginary := 1.0; 
   j : constant  Imaginary := 1.0; 
end Ada.Numerics.Generic_Complex_Types; 
The library package Numerics.Complex_Types is declar ed pure and defines the same  types, constants, and 
subprograms as Numerics.Generic _Complex_Types, except that th e predefined type Float is 
systematically substituted for Real'Bas e throughout. Nongeneric equivalents of 
Numerics.Generic_Complex_Types for each of the ot her predefined floating point types are defined 
similarly, with the names Numerics.Short_Comp lex_Types, Numerics.Long_Complex_Types, etc.  
Complex is a visible type with Cartesian components.  Imaginary is a private type; its full type is derived from Real'Base.  
The arithmetic operations and the Re, Im, Modulus, Ar gument, and Conjugate functions have their usual 
mathematical meanings. When applied to a parame ter of pure-imaginary type, the “imaginary-part” 
function Im yields the value of its parameter, as the corresponding real value. The remaining subprograms 
have the following meanings:  
• The Set_Re and Set_Im procedures replace th e designated component of a complex parameter 
with the given real value; applied to a parame ter of pure-imaginary type , the Set_Im procedure 
replaces the value of that parameter with the imaginary value corresponding to the given real 
value. 
• The Compose_From_Cartesian function construc ts a complex value from the given real and 
imaginary components. If only one component is gi ven, the other component is implicitly zero. 
• The Compose_From_Polar functi on constructs a complex value from the given modulus (radius) 
and argument (angle). When the value of the pa rameter Modulus is positive (resp., negative), the 
result is the complex value represented by the point in the complex plane lying at a distance from the origin given by the absolute value of Modulus and forming an angle measured 
counterclockwise from the positive (resp., negative) r eal axis given by the value of the parameter 
Argument.  
When the Cycle parameter is specified, the result of the Argument function and the parameter Argument 
of the Compose_From_Polar function are measured in units such that a full cycle of revolution has the 
given value; otherwise, they are measured in radians. 
The computed results of the mathematically multiv alued functions are rendered single-valued by the 
following conventions, which are meant to imply the principal branch:  20 
21 
22 
23 
24 
25/1 
26/2 
27 28 
29 
30 
31 
32 
33 
Ada Reference Manual — 2012 Edition 
G.1.1    Complex Types 13 December 2012      704 • The result of the Modulus function is nonnegative. 
• The result of the Argument function is in the qua drant containing the point in the complex plane 
represented by the parameter X. This may be an y quadrant (I through IV); thus, the range of the 
Argument function is approximately – π to π (–Cycle/2.0 to Cycle/2.0, if the parameter Cycle is 
specified). When the point represented by the parameter X lies on the negative real axis, the result approximates  
• π (resp., – π) when the sign of the imaginary compone nt of X is positive (resp., negative), if 
Real'Signed_Zeros is True; 
• π, if Real'Signed_Zeros is False.  
• Because a result lying on or near one of the axes may not be exactly representable, the 
approximation inherent in computing the result may place it in an adjacent quadrant, close to but on the wrong side of the axis.  
Dynamic Semantics 
The exception Numerics.Argument_Error is raised by  the Argument and Compos e_From_Polar functions 
with specified cycle, signaling a parameter value outside the domain of the corresponding mathematical 
function, when the value of the parameter Cycle is zero or negative. 
The exception Constraint_Error is raised by the divi sion operator when the value of the right operand is 
zero, and by the exponentiation operator when the valu e of the left operand is zero and the value of the 
exponent is negative, provided that Real'Machine_Ov erflows is True; when Real'Machine_Overflows is 
False, the result is unspecified. Constraint_Error can also be raised when a finite result overflows (see G.2.6).  
Implementation Requirements 
In the implementation of Numerics .Generic_Complex_Types, the range of intermediate values allowed 
during the calculation of a final result shall not be aff ected by any range constraint of the subtype Real.  
In the following cases, evaluation of a co mplex arithmetic operation shall yield the prescribed result , 
provided that the preceding rules do not call for an exception to be raised:  
• The results of the Re, Im, and Compose_From_Cartesian functions are exact. 
• The real (resp., imaginary) component of the re sult of a binary addition operator that yields a 
result of complex type is exact when either of its  operands is of pure-imag inary (resp., real) type.  
• The real (resp., imaginary) component of the resu lt of a binary subtraction operator that yields a 
result of complex type is exact when its right  operand is of pure-imaginary (resp., real) type. 
• The real component of the result of the Conj ugate function for the complex type is exact. 
• When the point in the complex plane represen ted by the parameter X lies on the nonnegative real 
axis, the Argument function yi elds a result of zero.  
• When the value of the parameter Modulus is zero, the Compose_From_P olar function yields a 
result of zero. 
• When the value of the parameter Argument is equa l to a multiple of the quarter cycle, the result 
of the Compose_From_Polar functi on with specified cycle lies on one of the axes. In this case, 
one of its components is zero, and the other has the magnitude of the parameter Modulus. 
• Exponentiation by a zero exponent yields th e value one. Exponentiation by a unit exponent 
yields the value of the left operand. Exponen tiation of the value one yields the value one. 
Exponentiation of the value zero yields the valu e zero, provided that the exponent is nonzero. 34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 46 
47 
48 49 
50 
Ada Reference Manual — 2012 Edition 
705      13 December 2012 Complex Types   G.1.1 When the left operand is of pure-imaginary type, one component of the result of the 
exponentiation operator is zero.  
When the result, or a result component, of any ope rator of Numerics.Generic_Complex_Types has a 
mathematical definition in terms of a single arithme tic or relational operation, that result or result 
component exhibits the accuracy of the corresponding operation of the type Real. 
Other accuracy requirements for the Modulus, Argum ent, and Compose_From_Polar functions, and 
accuracy requirements for the multiplication of a pair of complex operands or for division by a complex 
operand, all of which apply only in th e strict mode, are given in G.2.6. 
The sign of a zero result or zero result component yiel ded by a complex arithmetic operation or function is 
implementation defined when R eal'Signed_Zeros is True.  
Implementation Permissions 
The nongeneric equivalent packages may, but need not, be actual instantiations of the generic package for 
the appropriate predefined type. 
Implementations may obtain the result of exponentia tion of a complex or pure-imaginary operand by 
repeated complex multiplication, with arbitrary associa tion of the factors and with a possible final complex 
reciprocation (when the exponent is negative). Implem entations are also permitted to obtain the result of 
exponentiation of a complex operand, but not of a pur e-imaginary operand, by converting the left operand 
to a polar representation; exponentiating the modulus  by the given exponent; multiplying the argument by 
the given exponent; and reconverting to a Cartesian representation. Because of this implementation 
freedom, no accuracy requirement is imposed on comple x exponentiation (except for the prescribed results 
given above, which apply regardless of the implementation method chosen).  
Implementation Advice 
Because the usual mathematical meaning of multiplica tion of a complex operand and a real operand is that 
of the scaling of both components of the former by the latter, an implementati on should not perform this 
operation by first promoting the real operand to complex type and then performing a full complex 
multiplication. In systems that, in the future, suppor t an Ada binding to IEC 559:1989, the latter technique 
will not generate the required result when one of the components of the complex operand is infinite. 
(Explicit multiplication of the infinite component by the zero component obtained during promotion yields 
a NaN that propagates into the final result.) Analogous  advice applies in the case of multiplication of a 
complex operand and a pure-imaginary operand, and in th e case of division of a complex operand by a real 
or pure-imaginary operand.  
Likewise, because the usual mathematical meaning of  addition of a complex operand and a real operand is 
that the imaginary operand remains unchanged, an im plementation should not perform this operation by 
first promoting the real operand to complex type and then performing a full complex addition. In 
implementations in which the Signed_Z eros attribute of the component ty pe is True (and which therefore 
conform to IEC 559:1989 in regard to the handling of th e sign of zero in predefined arithmetic operations), 
the latter technique will not generate the required re sult when the imaginary component of the complex 
operand is a negatively signed zero. (Explicit additi on of the negative zero to the zero obtained during 
promotion yields a positive zero.) Analogous advice app lies in the case of addition of a complex operand 
and a pure-imaginary operand, and in the case of s ubtraction of a complex operand and a real or pure-
imaginary operand. 
Implementations in which Real'Signe d_Zeros is True should attempt to provide a rational treatment of the 
signs of zero results and result components. As one example, the result of the Argument function should 
have the sign of the imaginary component of the parameter X when the point represented by that 51 
52 
53 
54 
55/2 
56 
57 
58 
Ada Reference Manual — 2012 Edition 
G.1.1    Complex Types 13 December 2012      706 parameter lies on the positive real axis; as another, th e sign of the imaginary component of the Compose_-
From_Polar function should be the same as (resp., th e opposite of) that of the Argument parameter when 
that parameter has a value of zero and the Modulus parameter has a nonnegative (resp., negative) value.  
G.1.2 Complex Elementary Functions 
Static Semantics 
The generic library package Numerics.Generic_C omplex_Elementary_Functions has the following 
declaration:  
with Ada.Numerics.Generic_Complex_Types; 
generic 
   with package Complex_Types is 
         new Ada.Numerics.Generic_Complex_Types (<>); 
   use Complex_Types; 
package Ada.Numerics.Generic_Complex_Elementary_Functions is 
   pragma Pure(Generic_Complex_Elementary_Functions); 
   function  Sqrt (X : Complex)   return Complex; 
   function  Log  (X : Complex)   return Complex; 
   function  Exp  (X : Complex)   return Complex; 
   function  Exp  (X : Imaginary) return Complex; 
   function  "**" (Left : Complex;   Right : Complex)   return Complex; 
   function  "**" (Left : Complex;   Right : Real'Base) return Complex; 
   function  "**" (Left : Real'Base; Right : Complex)   return Complex; 
   function  Sin (X : Complex) return Complex; 
   function  Cos (X : Complex) return Complex; 
   function  Tan (X : Complex) return Complex; 
   function  Cot (X : Complex) return Complex; 
   function  Arcsin (X : Complex) return Complex; 
   function  Arccos (X : Complex) return Complex; 
   function  Arctan (X : Complex) return Complex; 
   function  Arccot (X : Complex) return Complex; 
   function  Sinh (X : Complex) return Complex; 
   function  Cosh (X : Complex) return Complex; 
   function  Tanh (X : Complex) return Complex; 
   function  Coth (X : Complex) return Complex; 
   function  Arcsinh (X : Complex) return Complex; 
   function  Arccosh (X : Complex) return Complex; 
   function  Arctanh (X : Complex) return Complex; 
   function  Arccoth (X : Complex) return Complex; 
end Ada.Numerics.Generic_Complex_Elementary_Functions; 
The library package Numerics.Complex_Elementary_F unctions is declared pure and defines the same 
subprograms as Numerics.Generic_Com plex_Elementary_Functions, except that the predefined type Float 
is systematically substituted for Real'Base, and th e Complex and Imaginary types exported by Numerics.-
Complex_Types are systematically substituted fo r Complex and Imaginary, throughout. Nongeneric 
equivalents of Numerics.Generic_Complex_Element ary_Functions corresponding to each of the other 
predefined floating point types are defined sim ilarly, with the names Numerics.Short_Complex_-
Elementary_Functions, Numerics.Long_Com plex_Elementary_Functions, etc.  
The overloading of the Exp function for the pure-imaginar y type is provided to give the user an alternate 
way to compose a complex value from a given modulus and argument. In addition to Compose_From_-Polar(Rho, Theta) (see G.1.1), the programmer may write Rho * Exp(i * Theta). 
The imaginary (resp., real) component of the parameter X of the forward hyperbolic (resp., trigonometric) 
functions and of the Exp function (a nd the parameter X, itself, in the case of the overloading of the Exp 1 
2/2 
3 
4 
5 
6 
7 
8 
9/1 
10 
11 
Ada Reference Manual — 2012 Edition 
707      13 December 2012 Complex Elementary Functions   G.1.2 function for the pure-imaginary type) represents an angle measured in radians, as does the imaginary 
(resp., real) component of the result of the Log and inverse hyperbolic (resp., trigonometric) functions. 
The functions have their usual ma thematical meanings. However, the arbitrariness inherent in the 
placement of branch cuts, across which some of the co mplex elementary functions exhibit discontinuities, 
is eliminated by the following conventions:  
• The imaginary component of th e result of the Sqrt and Log functions is discontinuous as the 
parameter X crosses the negative real axis. 
• The result of the exponentiation operator when  the left operand is of complex type is 
discontinuous as that operand crosses the negative real axis. 
• The imaginary component of the result of th e Arcsin, Arccos, and Arctanh functions is 
discontinuous as the parameter X crosses the real ax is to the left of –1.0 or the right of 1.0. 
• The real component of the result of the Arctan  and Arcsinh functions is discontinuous as the 
parameter X crosses the imaginary axis below – i or above i. 
• The real component of the result of the Arcco t function is discontinuous as the parameter X 
crosses the imaginary axis below – i or above i. 
• The imaginary component of the Arccosh functi on is discontinuous as the parameter X crosses 
the real axis to the left of 1.0. 
• The imaginary component of the result of the Ar ccoth function is discontinuous as the parameter 
X crosses the real axis between –1.0 and 1.0.  
The computed results of the mathematically multiv alued functions are rendered single-valued by the 
following conventions, which are meant to imply that the principal branch  is an analytic continuation of 
the corresponding real-valued function in Numerics.G eneric_Elementary_Functions. (For Arctan and 
Arccot, the single-argument function in question is th at obtained from the two-argument version by fixing 
the second argument to be  its default value.)  
• The real component of the result of the Sqrt and Arccosh functions is nonnegative. 
• The same convention applies to the imaginary component of the result of the Log function as 
applies to the result of the natural-cy cle version of the Argument function of 
Numerics.Generic_Compl ex_Types (see G.1.1). 
• The range of the real (resp., im aginary) component of the result of the Arcsin and Arctan (resp., 
Arcsinh and Arctanh) functions is approximately – π/2.0 to π/2.0. 
• The real (resp., imaginary) component of th e result of the Arccos and Arccot (resp., Arccoth) 
functions ranges from 0.0 to approximately π. 
• The range of the imaginary component of the re sult of the Arccosh function is approximately – π 
to π.  
In addition, the exponentiation operator inherits  the single-valuedness of the Log function.  
Dynamic Semantics 
The exception Numerics.Argument_Erro r is raised by the exponentiati on operator, signaling a parameter 
value outside the domain of the corre sponding mathematical function, when the value of the left operand is 
zero and the real component of the exponent (or the e xponent itself, when it is of real type) is zero. 
The exception Constraint_Error is raised, signaling a pole of the mathematical function (analogous to 
dividing by zero), in the following cases, provided th at Complex_Types.Real'Machine_Overflows is True:  
• by the Log, Cot, and Coth functions, wh en the value of the parameter X is zero; 12 
13 
14 
15/2 16/2 17/2 
18 19 
20/2 
21 
22 
23 
24 25 26 
27 
28 
29 
Ada Reference Manual — 2012 Edition 
G.1.2    Complex Elementary Functions 13 December 2012      708 • by the exponentiation operator, when the value of the left operand is zero and the real 
component of the exponent (or the exponent itsel f, when it is of real type) is negative; 
• by the Arctan and Arccot functions, when the value of the parameter X is ± i; 
• by the Arctanh and Arccoth functions, when the value of the parameter X is ± 1.0.  
Constraint_Error can also be raised when a fin ite result overflows (see G.2.6); this may occur for 
parameter values sufficiently near poles, and, in the case of some of  the functions, for parameter values 
having components of sufficiently large magnitude . When Complex_Types.Real'Machine_Overflows is 
False, the result at poles is unspecified.  
Implementation Requirements 
In the implementation of Numerics .Generic_Complex_Elementary_Functi ons, the range of intermediate 
values allowed during the calculation of a final result sh all not be affected by any range constraint of the 
subtype Complex_Types.Real.  
In the following cases, evaluation of a complex elementary function shall yield the prescribed result  (or a 
result having the prescribed component), provided that  the preceding rules do not call for an exception to 
be raised:  
• When the parameter X has the value zero, the Sqrt, Sin, Arcsin, Tan, Arctan, Sinh, Arcsinh, 
Tanh, and Arctanh functions yield a result of zer o; the Exp, Cos, and Cosh functions yield a 
result of one; the Arccos and Arccot functions yield a real result; and the Arccoth function yields an imaginary result. 
• When the parameter X has the value one, the Sq rt function yields a result of one; the Log, 
Arccos, and Arccosh functions yield a result of zero;  and the Arcsin function yields a real result. 
• When the parameter X has the value –1.0,  the Sqrt function yields the result  
• i (resp., – i), when the sign of the imaginary compone nt of X is positive (resp., negative), if 
Complex_Types.Real'Signed_Zeros is True; 
• i, if Complex_Types.Real'Signed_Zeros is False;  
• When the parameter X has the value –1.0, the Log function yields an imaginary result; and the 
Arcsin and Arccos functions yield a real result. 
• When the parameter X has the value ± i, the Log function yields an imaginary result. 
• Exponentiation by a zero exponent yields th e value one. Exponentiation by a unit exponent 
yields the value of the left operand (as a comple x value). Exponentiation of the value one yields 
the value one. Exponentiation of the value zero yields the value zero.  
Other accuracy requirements for the complex elementary functions, which apply only in the strict mode, 
are given in G.2.6. 
The sign of a zero result or zero result component yielded by a complex elementary function is 
implementation defined when Complex_T ypes.Real'Signed_Zeros is True.  
Implementation Permissions 
The nongeneric equivalent packages may, but need not , be actual instantiations of the generic package 
with the appropriate predefined nongeneric equivalent of Numerics.Generic_Compl ex_Types; if they are, 
then the latter shall have been obtained by actua l instantiation of Numerics .Generic_Complex_Types. 30 
31 
32 33 
34 
35 
36 
37 
38 
39 
40 
41/2 
42 
43 
44 
45 
46 
Ada Reference Manual — 2012 Edition 
709      13 December 2012 Complex Elementary Functions   G.1.2 The exponentiation operator may be implemented in te rms of the Exp and Log functions. Because this 
implementation yields poor accuracy in some parts of  the domain, no accuracy requirement is imposed on 
complex exponentiation. 
The implementation of the Exp function of a comple x parameter X is allowed to raise the exception 
Constraint_Error, signaling overflow, when the real co mponent of X exceeds an unspecified threshold that 
is approximately log(Complex_Types.Real'Safe_Last).  This permission recognizes the impracticality of 
avoiding overflow in the marginal case that the expone ntial of the real component of X exceeds the safe 
range of Complex_Types.Real but both components of the final result do not. Similarly, the Sin and Cos 
(resp., Sinh and Cosh) functions are allowed to rais e the exception Constraint_Error, signaling overflow, 
when the absolute value of the imaginary (resp ., real) component of the parameter X exceeds an 
unspecified threshold that is approximately l og(Complex_Types.Real'Safe_Last) + log(2.0). This 
permission recognizes the impracticality of avoiding overfl ow in the marginal case that the hyperbolic sine 
or cosine of the imaginary (resp., real) component of  X exceeds the safe range of Complex_Types.Real but 
both components of the final result do not.  
Implementation Advice 
Implementations in which Complex_T ypes.Real'Signed_Zeros is True s hould attempt to provide a rational 
treatment of the signs of zero results and result components. For example, many of the complex 
elementary functions have components that are odd func tions of one of the parameter components; in these 
cases, the result component should have the sign of th e parameter component at the origin. Other complex 
elementary functions have zero co mponents whose sign is opposite that of a parameter component at the 
origin, or is always positive or always negative.  
G.1.3 Complex Input-Output 
The generic package Text_IO.Complex_IO defines pr ocedures for the formatted input and output of 
complex values. The generic actual parameter in an in stantiation of Text_IO.Complex_IO is an instance of 
Numerics.Generic_Complex_Types fo r some floating point subtype. Exceptional conditions are reported 
by raising the appropriate exception defined in Text_IO.  
Static Semantics 
The generic library package Text_IO.Comp lex_IO has the following declaration:  
with Ada.Numerics.Generic_Complex_Types; 
generic 
   with package Complex_Types is 
         new Ada.Numerics.Generic_Complex_Types (<>); 
package Ada.Text_IO.Complex_IO is 
   use Complex_Types; 
   Default_Fore : Field := 2; 
   Default_Aft  : Field := Real'Digits - 1;    Default_Exp  : Field := 3; 
   procedure  Get (File  : in  File_Type; 
                  Item  : out Complex; 
                  Width : in  Field := 0); 
   procedure  Get (Item  : out Complex; 
                  Width : in  Field := 0); 47 
48 
49 
1 
2 
3 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
G.1.3    Complex Input-Output 13 December 2012      710    procedure  Put (File : in File_Type; 
                  Item : in Complex; 
                  Fore : in Field := Default_Fore; 
                  Aft  : in Field := Default_Aft; 
                  Exp  : in Field := Default_Exp); 
   procedure  Put (Item : in Complex; 
                  Fore : in Field := Default_Fore; 
                  Aft  : in Field := Default_Aft; 
                  Exp  : in Field := Default_Exp); 
   procedure  Get (From : in  String; 
                  Item : out Complex; 
                  Last : out Positive); 
   procedure  Put (To   : out String; 
                  Item : in  Complex; 
                  Aft  : in  Field := Default_Aft; 
                  Exp  : in  Field := Default_Exp); 
end Ada.Text_IO.Complex_IO; 
The library package Complex_Text_IO defines the same subprograms as Text_IO.Complex_IO, except 
that the predefined type Float is system atically substituted for Real, and the type 
Numerics.Complex_Types.Complex is systemati cally substituted for Complex throughout. Nongeneric 
equivalents of Text_IO.Complex_IO corresponding to each of the other predefined floating point types are 
defined similarly, with the names Short_Co mplex_Text_IO, Long_Complex_Text_IO, etc.  
The semantics of the Get and Put procedures are as follows:  
procedure  Get (File  : in  File_Type; 
               Item  : out Complex; 
               Width : in  Field := 0); 
procedure  Get (Item  : out Complex; 
               Width : in  Field := 0); 
The input sequence is a pair of optionally signed real literals representing the real and imaginary 
components of a complex value. These com ponents have the format defined for the 
corresponding Get procedure of an instance of Text_IO.Float_IO (see A.10.9) for the base 
subtype of Complex_Types.Real. The pair of components may be sepa rated by a comma or 
surrounded by a pair of parentheses or both. Blanks are freely allowed before each of the 
components and before the pare ntheses and comma, if either is used. If the value of the 
parameter Width is zero, then  
• line and page terminators are also allowed in these places; 
• the components shall be separated by at least one blank or line terminator if the 
comma is omitted; and 
• reading stops when the right parenthesis ha s been read, if the input sequence includes a 
left parenthesis, or when the imaginar y component has been read, otherwise.  
If a nonzero value of Width is supplied, then 
• the components shall be separated by at l east one blank if the comma is omitted; and 
• exactly Width characters are read, or the characters (possibly none) up to a line 
terminator, whichever comes first (b lanks are included in the count).  
Returns, in the parameter Item, the value of  type Complex that corresponds to the input 
sequence. 
The exception Text_IO.Data_Error is raised if the input sequence does not have the required 
syntax or if the components of the complex value obtained are not of the base subtype of Complex_Types.Real. 7 
8 
9 
9.1/2 
10 
11 
12/1 
13 
14 
15 
15.1 
16 
17 
18 
19 
Ada Reference Manual — 2012 Edition 
711      13 December 2012 Complex Input-Output   G.1.3 procedure  Put (File : in File_Type; 
               Item : in Complex; 
               Fore : in Field := Default_Fore; 
               Aft  : in Field := Default_Aft; 
               Exp  : in Field := Default_Exp); 
procedure  Put (Item : in Complex; 
               Fore : in Field := Default_Fore; 
               Aft  : in Field := Default_Aft; 
               Exp  : in Field := Default_Exp); 
Outputs the value of the parameter Item as a pa ir of decimal literals representing the real and 
imaginary components of the complex value, using the syntax of an aggregate. More 
specifically,  
• outputs a left parenthesis; 
• outputs the value of the real component of the parameter Item with the format defined 
by the corresponding Put procedure of an instance of Text_IO.Float_IO for the base subtype of Complex_Types.Real, using the given values of Fore, Aft, and Exp; 
• outputs a comma; 
• outputs the value of the imaginary component  of the parameter Item with the format 
defined by the corresponding Put procedure of an instance of Text_IO.Float_IO for the 
base subtype of Complex_Types.Real, using th e given values of Fore, Aft, and Exp; 
• outputs a right parenthesis.  
procedure  Get (From : in  String; 
               Item : out Complex; 
               Last : out Positive); 
Reads a complex value from the beginning of the given string, following the same rule as the 
Get procedure that reads a complex value from a f ile, but treating the end of the string as a file 
terminator. Returns, in the parameter Item, the value of type Complex that corresponds to the 
input sequence. Returns in Last the index value su ch that From(Last) is the last character read. 
The exception Text_IO.Data_Error is raised if the input sequence does not have the required 
syntax or if the components of the complex value obtained are not of the base subtype of Complex_Types.Real. 
procedure  Put (To   : out String; 
               Item : in  Complex; 
               Aft  : in  Field := Default_Aft; 
               Exp  : in  Field := Default_Exp); 
Outputs the value of the parameter Item to the given string as a pair of decimal literals 
representing the real and imaginary components of  the complex value, using the syntax of an 
aggregate. More specifically,  
• a left parenthesis, the real component, a nd a comma are left justified in the given 
string, with the real component having the format defined by the Put procedure (for 
output to a file) of an instance of Text_IO.Float_IO for the base subtype of Complex_Types.Real, using a value of zero fo r Fore and the given values of Aft and 
Exp; 
• the imaginary component and a right parenthe sis are right justified in the given string, 
with the imaginary component having the fo rmat defined by the Put procedure (for 
output to a file) of an instance of Text_IO.Float_IO for the base subtype of Complex_Types.Real, using a value for Fore th at completely fills the remainder of the 
string, together with the given values of Aft and Exp.  20 
21 
22 
23 
24 
25 
26 
27 
28/2 
29 
30 
31 
32 
33 
Ada Reference Manual — 2012 Edition 
G.1.3    Complex Input-Output 13 December 2012      712 The exception Text_IO.Layout_Error is raised if  the given string is too short to hold the 
formatted output.  
Implementation Permissions 
Other exceptions declared (by renaming) in Text_IO may be raised by the preceding procedures in the appropriate circumstances, as for the corre sponding procedures of Text_IO.Float_IO.  
G.1.4 The Package Wide_Text_IO.Complex_IO 
Static Semantics 
Implementations shall also provide the generic library package Wide_Text_IO.Complex_IO. Its 
declaration is obtained from that of Text_IO.Co mplex_IO by systematically replacing Text_IO by 
Wide_Text_IO and String by Wide_Str ing; the description of its beha vior is obtained by additionally 
replacing references to particular characters (comma s, parentheses, etc.) by  those for the corresponding 
wide characters.  
G.1.5 The Package Wide_Wide_Text_IO.Complex_IO 
Static Semantics 
Implementations shall also provide the generic lib rary package Wide_Wide_Text_IO.Complex_IO. Its 
declaration is obtained from that of Text_IO.Co mplex_IO by systematically replacing Text_IO by 
Wide_Wide_Text_IO and String by Wi de_Wide_String; the description of  its behavior is obtained by 
additionally replacing references to particular charact ers (commas, parentheses,  etc.) by those for the 
corresponding wide wide characters.  
G.2 Numeric Performance Requirements 
Implementation Requirements 
Implementations shall provide a user-selectable mode in which the accuracy and other numeric performance requirements detailed in the following subcla uses are observed. This mode, referred to as the 
strict mode , may or may not be the default mode; it directly affects the results of the predefined arithmetic 
operations of real types and the results of the s ubprograms in children of the Numerics package, and 
indirectly affects the operations in other language de fined packages. Implementa tions shall also provide 
the opposing mode, which is known as the relaxed mode .  
Implementation Permissions 
Either mode may be the default mode.  
The two modes need not actually be different.  34 
35 
1 
1/2 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
713      13 December 2012 Model of Floating Point Arithmetic   G.2.1 G.2.1 Model of Floating Point Arithmetic 
In the strict mode, the predefined operations of a floating point type shall satisfy the accuracy 
requirements specified here and shall avoid or signal overflow in the situa tions described. This behavior is 
presented in terms of a model of floating point arith metic that builds on the concept of the canonical form 
(see A.5.3).  
Static Semantics 
Associated with each floating point type is an infinite set of model numbers. The model numbers of a type are used to define the accuracy requirements that have to be satisfied by certain predefined operations of 
the type; through certain attributes of  the model numbers, they are also used to explain the meaning of a 
user-declared floating point type declaration. The mode l numbers of a derived type are those of the parent 
type; the model numbers of a s ubtype are those of its type. 
The model numbers  of a floating point type T are zero and all the values expressible in the canonical form 
(for the type T), in which mantissa  has T'Model_Mantissa digits and exponent  has a value greater than or 
equal to T'Model_Emin. (These attr ibutes are defined in G.2.2.)  
A model interval  of a floating point type is any interval whose bounds are model numbe rs of the type. The 
model interval  of a type T associated with a value  v is the smallest model interval of T that includes v. 
(The model interval associated with a model num ber of a type consists of that number only.)  
Implementation Requirements 
The accuracy requirements for the evaluation of certain predefined operations of floating point types are as 
follows.  
An operand interval  is the model interval, of the type specified for the operand of an operation, associated 
with the value of the operand. 
For any predefined arithmetic operation that yields a result of a floating point type T, the required bounds 
on the result are given by a model interval of T (called the result interval ) defined in terms of the operand 
values as follows:  
• The result interval is the smallest model interval of T that includes the minimum and the 
maximum of all the values obtained by applying the (exact) mathematical operation to values 
arbitrarily selected from the respective operand intervals.  
The result interval of an exponentiation is obtaine d by applying the above rule to the sequence of 
multiplications defined by the exponent, assuming arbitr ary association of the factors, and to the final 
division in the case of a negative exponent. 
The result interval of a conversion of a numeric value to  a floating point type T is the model interval of T 
associated with the operand value, except when the source expression is of a fixed point type with a small  
that is not a power of T'Machine_Radix or is a fi xed point multiplication or division either of whose 
operands has a small  that is not a power of T'Machine_Radix;  in these cases, the result interval is 
implementation defined.  
For any of the foregoing operations, the implementation shall deliver a value that belongs to the result 
interval when both bounds of the result interval are in th e safe range of the result type T, as determined by 
the values of T'Safe_First and T'Safe_Last; otherwise,  
• if T'Machine_Overflows is True , the implementation shall either deliver a value that belongs to 
the result interval or raise Constraint_Error; 1 
2 
3 
4 
5 
6 7 
8 
9 
10 
11 
12 
Ada Reference Manual — 2012 Edition 
G.2.1    Model of Floating Point Arithmetic 13 December 2012      714 • if T'Machine_Overflows is False, th e result is implementation defined.  
For any predefined relation on operands of a floating point type T, the implementation may deliver any 
value (i.e., either True or False) obtained by appl ying the (exact) mathematical comparison to values 
arbitrarily chosen from the respective operand intervals. 
The result of a membership test is defined in terms of comparisons of the operand value with the lower and 
upper bounds of the given range or type mark (the  usual rules apply to these comparisons).  
Implementation Permissions 
If the underlying floating point hardware implements di vision as multiplication by a reciprocal, the result 
interval for division (and exponentiation by a ne gative exponent) is implementation defined.  
G.2.2 Model-Oriented Attributes of Floating Point Types 
In implementations that support the Nu merics Annex, the model-oriented attributes of floating point types 
shall yield the values defined here, in both the st rict and the relaxed modes. These definitions add 
conditions to those in A.5.3.  
Static Semantics 
For every subtype S of a floating point type T:  
S'Model_Mantissa  
 Yields the number of digits in the mantissa of the canonical form of  the model numbers of T 
(see A.5.3). The value of this attribute shall be greater than or equal to  
d · log(10) / log( T'Machine_Radix)  + g 
 where d is the requested decimal precision of T, and g is 0 if T'Machine_Radix is a positive 
power of 10 and 1 otherwise. In addition, T'Model_Mantissa shall be less than or equal to 
the value of T'Machine_Mantissa. This attribute yields a value of the type 
universal_integer .  
S'Model_Emin  
 Yields the minimum exponent of the ca nonical form of the model numbers of T (see A.5.3). 
The value of this attribute shall be gr eater than or equal to the value of T'Machine_Emin. 
This attribute yields a value of the type universal_integer .  
S'Safe_First  
 Yields the lower bound of the safe range of T. The value of this attribute shall be a model 
number of T and greater than or equal to the lower bound of the base range of T. In 
addition, if T is declared by a floating_point_definition  or is derived from such a type, and 
the floating_point_definition  includes a real_range_specification  specifying a lower bound 
of lb, then the value of this attribute shall be less than or equal to lb; otherwise, it shall be 
less than or equal to –10.0 4 · d, where d is the requested decimal precision of T. This 
attribute yields a value of the type universal_real . 
S'Safe_Last  
 Yields the upper bound of the safe range of T. The value of this attribute shall be a model 
number of T and less than or equal to the upper bound of the base range of T. In addition, if 
T is declared by a floating_point_definition  or is derived from such a type, and the 
floating_point_definition  includes a real_range_specification  specifying an upper bound of 
ub, then the value of this attribute shall be greater than or equal to ub; otherwise, it shall be 
greater than or equal to 10.0 4 · d, where d is the requested decimal precision of T. This 
attribute yields a value of the type universal_real . 13 
14 
15 
16 
1 
2 
3/2 
3.1/2 
3.2/2 
4 
5 
6 
Ada Reference Manual — 2012 Edition 
715      13 December 2012 Model-Oriented Attributes of Floating Point Types   G.2.2 S'Model  Denotes a function (of a parameter X) whose specification is given in A.5.3. If X is a model 
number of T, the function yields X; otherwise, it yields the value obtained by rounding or 
truncating X to either one of the adjacent model numbers of T. Constraint_Error is raised if 
the resulting model number is outside the safe  range of S. A zero result has the sign of X 
when S'Signed_Zeros is True.  
Subject to the constraints given above, the values of S'Model_Mantissa and S'Safe_Last are to be 
maximized, and the values of S'Model_Emin and S' Safe_First minimized, by the implementation as 
follows:  
• First, S'Model_Mantissa is set to the largest value for wh ich values of S'Model_Emin, 
S'Safe_First, and S'Safe_Last can be chosen so that the implementation satisfies the strict-mode requirements of G.2.1 in terms of  the model numbers and safe range  induced by these attributes. 
• Next, S'Model_Emin is set to the smallest value for which values of S'Safe_First and 
S'Safe_Last can be chosen so that the implemen tation satisfies the stri ct-mode requirements of 
G.2.1 in terms of the model numbers and safe  range induced by these attributes and the 
previously determined value of S'Model_Mantissa. 
• Finally, S'Safe_First and S'Safe_L ast are set (in either order) to the smallest and largest values, 
respectively, for which the implementation satisfi es the strict-mode requi rements of G.2.1 in 
terms of the model numbers and safe range induced by these attributes and the previously 
determined values of S'Model_ Mantissa and S'Model_Emin.  
G.2.3 Model of Fixed Point Arithmetic 
In the strict mode, the predefined arithmetic operations of a fixed point type shall satisfy the accuracy 
requirements specified here and shall avoid or signal overflow in  the situations described.  
Implementation Requirements 
The accuracy requirements for the predefined fixed point arithmetic operations and conversions, and the 
results of relations on fixed poi nt operands, are given below.  
The operands of the fixed point adding operators, abso lute value, and comparisons have the same type. 
These operations are required to yiel d exact results, unless they overflow. 
Multiplications and divisions are allowed between operands  of any two fixed point types; the result has to 
be (implicitly or explicitly) converted to some othe r numeric type. For purposes of defining the accuracy 
rules, the multiplication or division and the convers ion are treated as a single operation whose accuracy 
depends on three types (those of the operands and the re sult). For decimal fixed point types, the attribute 
T'Round may be used to imply explic it conversion with rounding (see 3.5.10). 
When the result type is a floating point type, the accuracy is as given in G.2.1. For some combinations of 
the operand and result types in the remaining cases, the re sult is required to belong to a small set of values 
called the perfect result set ; for other combinations, it is required me rely to belong to a generally larger 
and implementation-defined set of values called the close result set . When the result type is a decimal 
fixed point type, the perfect result set contains a singl e value; thus, operations on decimal types are always 
fully specified.  
When one operand of a fixed-fixed mu ltiplication or division is of type universal_real , that operand is not 
implicitly converted in the usual sense, since the c ontext does not determine a unique target type, but the 
accuracy of the result of the multiplication or division (i.e., whether the result has to belong to the perfect 
result set or merely the close result set) depends on the value of the operand of type universal_real  and on 
the types of the other operand and of the result.  7 
8 
9 
10 
11/3 
1 
2 
3 4 
5 
6 
Ada Reference Manual — 2012 Edition 
G.2.3    Model of Fixed Point Arithmetic 13 December 2012      716 For a fixed point multiplication or divisi on whose (exact) mathematical result is v, and for the conversion 
of a value v to a fixed point type, the perfect result set and close result set are defined as follows:  
• If the result type is an ordinary fixed point type with a small  of s,  
• if v is an integer multiple of s, then the perfect result set contains only the value v; 
• otherwise, it contains the integer multiple of s just below v and the integer multiple of s just 
above v.  
 The close result set is an implementation-de fined set of consecutive integer multiples of s 
containing the perfect result set as a subset. 
• If the result type is a decimal type with a small  of s,  
• if v is an integer multiple of s, then the perfect result set contains only the value v; 
• otherwise, if truncation applies, then  it contains only the integer multiple of s in the 
direction toward zero, whereas if rounding applie s, then it contains only the nearest integer 
multiple of s (with ties broken by rounding away from zero).  
 The close result set is an implementation-de fined set of consecutive integer multiples of s 
containing the perfect result set as a subset.  
• If the result type is an integer type,  
• if v is an integer, then the perfect  result set contains only the value v; 
• otherwise, it contains the integer nearest to the value v (if v lies equally distant from two 
consecutive integers, the perfect result set contains the one that is further from zero).  
 The close result set is an implementation-defi ned set of consecutive integers containing the 
perfect result set as a subset.  
The result of a fixed point multiplication or division sha ll belong either to the perfect result set or to the 
close result set, as described below,  if overflow does not occur. In the following cases, if the result type is 
a fixed point type, let s be its small ; otherwise, i.e. when the resu lt type is an integer type, let s be 1.0.  
• For a multiplication or division neither of whose operands is of type universal_real , let l and r 
be the smalls  of the left and right operands. For a multiplication, if ( l · r) / s is an integer or the 
reciprocal of an integer (the smalls  are said to be “compatible” in this case), the result shall 
belong to the perfect result set; otherwise, it bel ongs to the close result set. For a division, if l / (r 
· s) is an integer or the reciprocal of an integer (i.e., the smalls  are compatible), the result shall 
belong to the perfect result set; otherwise,  it belongs to the close result set.  
• For a multiplication or division having one universal_real  operand with a value of v, note that it 
is always possible to factor v as an integer multiple of a “compatible” small , but the integer 
multiple may be “too big.” If there exists a factori zation in which that multiple is less than some 
implementation-defined limit, th e result shall belong to the perfect result set; otherwise, it 
belongs to the close result set.  
A multiplication P * Q of an operand of a fixed point ty pe F by an operand of an integer type I, or vice-
versa, and a division P / Q of an operand of a fixed point type F by an operand of an integer type I, are also 
allowed. In these cases, the result has a type of F; explicit conversion of the result is never required. The 
accuracy required in these cas es is the same as that required for a multiplication F(P * Q) or a division F(P 
/ Q) obtained by interpreting the operand of the in teger type to have a fixed point type with a small  of 1.0. 
The accuracy of the result of a conversion from an intege r or fixed point type to a fixed point type, or from 
a fixed point type to an integer type, is the same as  that of a fixed point multiplication of the source value 
by a fixed point operand having a small  of 1.0 and a value of 1.0, as given by the foregoing rules. The 
result of a conversion from a floating point type to a fi xed point type shall belong to the close result set. 7 
8 
9 
10 
11 12 
13 
14/3 
15 
16 
17 
18 
19 20 
21 
22 
23 
24 
Ada Reference Manual — 2012 Edition 
717      13 December 2012 Model of Fixed Point Arithmetic   G.2.3 The result of a conversion of a universal_real  operand to a fixed point type shall belong to the perfect 
result set. 
The possibility of overflow in the result of a pred efined arithmetic operation or conversion yielding a 
result of a fixed point type T is analogous to that fo r floating point types, except for being related to the 
base range instead of the safe range. If all of the perm itted results belong to the base range of T, then the 
implementation shall deliver one of the permitted results; otherwise,  
• if T'Machine_Overflows is True, the implemen tation shall either deliver one of the permitted 
results or raise Constraint_Error; 
• if T'Machine_Overflows is False, th e result is implementation defined.  
G.2.4 Accuracy Requirements for the Elementary Functions 
In the strict mode, the performance of Numerics.Generic _Elementary_Functions shall be as specified here.  
Implementation Requirements 
When an exception is not raised, the result of evaluating a function in an instance EF of 
Numerics.Generic_Elementar y_Functions belongs to a result interval , defined as the smallest model 
interval of EF.Float_Type that contains all the values of the form f · (1.0 + d), where f is the exact value of 
the corresponding mathematical functi on at the given parameter values, d is a real number, and | d| is less 
than or equal to the function's maximum relative error . The function delivers a value that belongs to the 
result interval when both of its bounds belong to the safe range of EF.Float_Type; otherwise,  
• if EF.Float_Type'Machine_Overflows is True, the function either delivers a value that belongs 
to the result interval or raises Constraint_Error, signaling overflow; 
• if EF.Float_Type'Machine_Overflows is False, the result is implementation defined.  
The maximum relative error exhibited by each function is as follows:  
• 2.0 · EF.Float_Type'Model_Epsilon, in the case of the Sqrt, Sin, and Cos functions; 
• 4.0 · EF.Float_Type'Model_Epsilon, in the case of  the Log, Exp, Tan, Cot, and inverse 
trigonometric functions; and 
• 8.0 · EF.Float_Type'Model_Epsilon, in the case of the forward and i nverse hyperbolic functions.  
The maximum relative error exhibited by the exponentia tion operator, which depends on the values of the 
operands, is (4.0 + |Right · log(Left)| / 32.0) · EF.Float_Type'Model_Epsilon. 
The maximum relative error given above applies throughout the domain of the forward trigonometric 
functions when the Cycle parameter is specified. When the Cycle parameter is omitted, the maximum 
relative error given above applies only when the absolu te value of the angle parameter X is less than or 
equal to some implementation-defined angle threshold , which shall be at least EF.Float_Type'Machine_-
Radix EF.Float_Type'Machine_Mantissa/2 . Beyond the angle threshold, the accuracy of the forward trigonometric 
functions is implementation defined.  
The prescribed results specified in A.5.1 for certain  functions at particular parameter values take 
precedence over the maximum relative error bounds; effec tively, they narrow to a single value the result 
interval allowed by the maximum relative error bounds. A dditional rules with a similar effect are given by 
table G-1 for the inverse trigonometric functions, at particular parameter values for which the 
mathematical result is possi bly not a model number of EF.Float_Type (or is, indeed, even transcendental). 
In each table entry, the values of the parameters are such that the result lies on the axis between two 25 
26 
27 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11/2 
Ada Reference Manual — 2012 Edition 
G.2.4    Accuracy Requirements for the Elemen tary Functions 13 December 2012      718 quadrants; the corresponding accuracy rule, which takes precedence over the maximum relative error 
bounds, is that the result interval  is the model interval of EF.Float_Type associated with the exact 
mathematical result given in the table. 
This paragraph was deleted.  
The last line of the table is meant to apply when EF.Float_Type'Signed_Zeros is False; the two lines just 
above it, when EF.Float_Type'Signed_Zeros is True and th e parameter Y has a zero value with the 
indicated sign. 
  
 Table G-1: Tightly Approximated Elementary Function Results  
 Function  Value of X  Value of Y  Exact 
Result  
when Cycle 
Specified  Exact 
Result  
when Cycle  
Omitted  
 Arcsin 1.0 n.a. Cycle/4.0 π/2.0 
 Arcsin –1.0 n.a. –Cycle/4.0 –π/2.0 
 Arccos 0.0 n.a. Cycle/4.0 π/2.0 
 Arccos –1.0 n.a. Cycle/2.0 π 
 Arctan and Arccot 0.0 positive Cycle/4.0 π/2.0 
 Arctan and Arccot 0.0 negative –Cycle/4.0 –π/2.0 
 Arctan and Arccot negative +0.0 Cycle/2.0 π 
 Arctan and Arccot negative –0.0 –Cycle/2.0 –π 
 Arctan and Arccot negative 0.0 Cycle/2.0 π 
  
The amount by which the result of an inverse tri gonometric function is allowed to spill over into a 
quadrant adjacent to the one corresponding to the principa l branch, as given in A.5.1, is limited. The rule 
is that the result belongs to th e smallest model interval of EF.Float_Type that contains both boundaries of 
the quadrant corresponding to the principal branch. This rule also takes precedence over the maximum 
relative error bounds, effectively narrowing the result interval allowed by them. 
Finally, the following specifications also take precedence over the maximum relative error bounds:  
• The absolute value of the result of the Sin, Cos, and Tanh functions never exceeds one. 
• The absolute value of the result of th e Coth function is never less than one. 
• The result of the Cosh function is never less than one.  
Implementation Advice 
The versions of the forward trigonom etric functions without a Cycle pa rameter should not be implemented 
by calling the corresponding version with a Cycle pa rameter of 2.0*Numerics.Pi, since this will not 
provide the required accuracy in some portions of the domain. For the same reason, the version of Log without a Base parameter should not be implemente d by calling the corresponding version with a Base 
parameter of Numerics.e.  12/1 
13 
14 
15 
16 
17 18 
19 
Ada Reference Manual — 2012 Edition 
719      13 December 2012 Performance Requirements for Random Number Generation   G.2.5 G.2.5 Performance Requirements for Random Number Generation 
In the strict mode, the performan ce of Numerics.Float_Random and Nu merics.Discrete_Random shall be 
as specified here.  
Implementation Requirements 
Two different calls to the time-dependent Reset proce dure shall reset the generator to different states, 
provided that the calls are separated in time by at  least one second and not more than fifty years. 
The implementation's representations of generator states and its algor ithms for generating random numbers 
shall yield a period of at least 231–2; much longer periods are desirable but not required. 
The implementations of Numerics .Float_Random.Random and Numeri cs.Discrete_Random .Random shall 
pass at least 85% of the individual trials in a suite of statistical tests. For Numerics.Float_Random, the 
tests are applied directly to the floating point values  generated (i.e., they are not converted to integers 
first), while for Numerics.Discrete_ Random they are applied to the gene rated values of various discrete 
types. Each test suite performs 6 different tests, with each test repeated 10 times, yielding a total of 60 individual trials. An individual trial is deemed to pass if the chi-square value (or other statistic) calculated 
for the observed counts or distribution falls within the range of values corresponding to the 2.5 and 97.5 
percentage points for the relevant degrees of freedom (i.e., it shall be neither too high nor too low). For the 
purpose of determining the degrees  of freedom, measurement categories are combined whenever the 
expected counts are fewer than 5.  
G.2.6 Accuracy Requirements for Complex Arithmetic 
In the strict mode, the performance of Numerics .Generic_Complex_Types and Numerics.Generic_-
Complex_Elementary_Functions shall be as specified here.  
Implementation Requirements 
When an exception is not raised, the result of evaluating a real function of an instance CT of 
Numerics.Generic_Complex_Types (i.e., a f unction that yields a value of subtype CT.Real'Base or 
CT.Imaginary) belongs to a result interval defined as for a real elementary function (see G.2.4). 
When an exception is not raised, each component of th e result of evaluating a complex function of such an 
instance, or of an instance of Numerics.Gen eric_Complex_Elementary_ Functions obtained by 
instantiating the latter with CT (i.e., a function that yields a value of subtype CT.Complex), also belongs to 
a result interval . The result intervals for the components of the result are either defined by a maximum 
relative error  bound or by a maximum box error  bound. When the result interval for the real (resp., 
imaginary) component is defined by maximum relative e rror, it is defined as for that of a real function, 
relative to the exact value of the real (resp., im aginary) part of the result of the corresponding 
mathematical function. When define d by maximum box error, the result interval for a component of the 
result is the smallest model interval of CT.Real that contains all the valu es of the corresponding part of f · 
(1.0 + d), where f is the exact complex value of the corre sponding mathematical function at the given 
parameter values, d is complex, and | d| is less than or equal to the gi ven maximum box error. The function 
delivers a value that belongs to the result interval (or a value both of whose components belong to their 
respective result intervals) when both bounds of the result interval(s) belong to the safe range of CT.Real; 
otherwise,  1 
2 
3 4 
1 
2 
3 
Ada Reference Manual — 2012 Edition 
G.2.6    Accuracy Requirements for Complex Arithmetic 13 December 2012      720 • if CT.Real'Machine_Overflows is True, the function e ither delivers a value that belongs to the 
result interval (or a value both of whose compone nts belong to their respective result intervals) 
or raises Constraint_Error, signaling overflow; 
• if CT.Real'Machine_Overflows is False, the result is implementation defined.  
The error bounds for particular complex functions are ta bulated in table G-2. In the table, the error bound 
is given as the coefficient of CT.Real'Model_Epsilon. 
This paragraph was deleted.  
  
 Table G-2: Error Bounds for Particular Complex Functions  
 Function or Operator  Nature of  
Result  Nature of  
Bound  Error Bound  
 Modulus real max. rel. error 3.0 
 Argument real max. rel. error 4.0 
 Compose_From_Polar comple x max. rel. error 3.0 
 "*" (both operands complex) complex max. box error 5.0 
 "/" (right operand complex) complex max. box error 13.0 
 Sqrt complex max. rel. error 6.0 
 Log complex max. box error 13.0 
 Exp (complex parameter) comp lex max. rel. error 7.0 
 Exp (imaginary parameter) co mplex max. rel. error 2.0 
 Sin, Cos, Sinh, and Cosh co mplex max. rel. error 11.0 
 Tan, Cot, Tanh, and Coth co mplex max. rel. error 35.0 
 inverse trigonometric comple x max. rel. error 14.0 
 inverse hyperbolic comple x max. rel. error 14.0 
  
The maximum relative error given above applies throughout the domai n of the Compose_From_Polar 
function when the Cycle parameter is specified. Wh en the Cycle parameter is omitted, the maximum 
relative error applies only when the absolute value of the parameter Argument is less than or equal to the 
angle threshold (see G.2.4). For the Exp function, a nd for the forward hyperbolic (resp., trigonometric) 
functions, the maximum relative error given above likew ise applies only when the absolute value of the 
imaginary (resp., real) component of the parameter X (or the absolute value of the parameter itself, in the 
case of the Exp function with a parameter of pure-im aginary type) is less than or equal to the angle 
threshold. For larger angles, the accuracy is implementation defined.  
The prescribed results specified in G.1.2 for certain  functions at particular parameter values take 
precedence over the error bounds; effectively, they narrow to a single value the result interval allowed by 
the error bounds for a component of the result. Additiona l rules with a similar effect are given below for 
certain inverse trigonometric and inverse hyperbolic f unctions, at particular parameter values for which a 
component of the mathematical result is transcende ntal. In each case, the accuracy rule, which takes 
precedence over the error bounds, is that the result interv al for the stated result component is the model 
interval of CT.Real associated with the component's exact ma thematical value. The cases in question are 
as follows:  4 
5 
6/2 
7/1 
8 
9 
Ada Reference Manual — 2012 Edition 
721      13 December 2012 Accuracy Requirements for Complex Arithmetic   G.2.6 • When the parameter X has the value zero, the r eal (resp., imaginary) component of the result of 
the Arccot (resp., Arccoth) function is in the model interval of CT.Real associated with the value 
π/2.0. 
• When the parameter X has the value one, the real  component of the result of the Arcsin function 
is in the model interval of CT.Real associated with the value π/2.0. 
• When the parameter X has the value –1.0, the r eal component of the result of the Arcsin (resp., 
Arccos) function is in the model interval of CT.Real associated with the value – π/2.0 (resp., π).  
The amount by which a component of the result of an inverse trigonometric or inverse hyperbolic function 
is allowed to spill over into a quadrant adjacent to th e one corresponding to the principal branch, as given 
in G.1.2, is limited. The rule is that the re sult belongs to the smallest model interval of CT.Real that 
contains both boundaries of the quadrant corresponding to  the principal branch. This rule also takes 
precedence over the maximum error bounds, effectively narrowing the result interval allowed by them. 
Finally, the results allowed by the error bounds are na rrowed by one further rule: The absolute value of 
each component of the result of the Exp function, for a pure-imaginary parameter, never exceeds one.  
Implementation Advice 
The version of the Compose_From_Polar function w ithout a Cycle parameter should not be implemented 
by calling the corresponding version with a Cycle pa rameter of 2.0*Numerics.Pi, since this will not 
provide the required accuracy in some portions of the domain.  
G.3 Vector and Matrix Manipulation 
Types and operations for the manipulation of real vectors and matrices are provided in 
Generic_Real_Arrays, which is defi ned in G.3.1. Types and operations  for the manipulation of complex 
vectors and matrices are provided in Generic_Complex_A rrays, which is defined in G.3.2. Both of these 
library units are generic children of the predefined package Numerics (see A.5). Nongeneric equivalents of 
these packages for each of the predefined floating point  types are also provided as children of Numerics.  
G.3.1 Real Vectors and Matrices 
Static Semantics 
The generic library package Numerics.Generic _Real_Arrays has the following declaration:  
generic 
   type Real is digits  <>; 
package Ada.Numerics.Generic_Real_Arrays is 
   pragma Pure(Generic_Real_Arrays); 
   -- Types 
   type Real_Vector is array  (Integer range <>) of Real'Base; 
   type Real_Matrix is array  (Integer range <>, Integer range <>) 
                                                   of Real'Base; 
   -- Subprograms for Real_Vector types  
   -- Real_Vector arithmetic operations  
   function  "+"   (Right : Real_Vector)       return Real_Vector; 
   function  "-"   (Right : Real_Vector)       return Real_Vector; 
   function  "abs" (Right : Real_Vector)       return Real_Vector; 
   function  "+"   (Left, Right : Real_Vector) return Real_Vector; 
   function  "-"   (Left, Right : Real_Vector) return Real_Vector; 
   function  "*"   (Left, Right : Real_Vector) return Real'Base; 10 
11 
12 
13/2 
14 
15 
1/2 
1/2 
2/2 
3/2 
4/2 
5/2 
6/2 7/2 
8/2 
9/2 
Ada Reference Manual — 2012 Edition 
G.3.1    Real Vectors and Matri ces 13 December 2012      722    function  "abs" (Right : Real_Vector)       return Real'Base; 
   -- Real_Vector scaling operations  
   function  "*" (Left : Real'Base;   Right : Real_Vector) 
      return Real_Vector; 
   function  "*" (Left : Real_Vector; Right : Real'Base) 
      return Real_Vector; 
   function  "/" (Left : Real_Vector; Right : Real'Base) 
      return Real_Vector; 
   -- Other Real_Vector operations  
   function  Unit_Vector (Index : Integer; 
                         Order : Positive;                          First : Integer := 1) return Real_Vector; 
   -- Subprograms for Real_Matrix types  
   -- Real_Matrix arithmetic operations  
   function  "+"       (Right : Real_Matrix) return Real_Matrix; 
   function  "-"       (Right : Real_Matrix) return Real_Matrix; 
   function  "abs"     (Right : Real_Matrix) return Real_Matrix; 
   function  Transpose (X     : Real_Matrix) return Real_Matrix; 
   function  "+" (Left, Right : Real_Matrix) return Real_Matrix; 
   function  "-" (Left, Right : Real_Matrix) return Real_Matrix; 
   function  "*" (Left, Right : Real_Matrix) return Real_Matrix; 
   function  "*" (Left, Right : Real_Vector) return Real_Matrix; 
   function  "*" (Left : Real_Vector; Right : Real_Matrix) 
      return Real_Vector; 
   function  "*" (Left : Real_Matrix; Right : Real_Vector) 
      return Real_Vector; 
   -- Real_Matrix scaling operations  
   function  "*" (Left : Real'Base;   Right : Real_Matrix) 
      return Real_Matrix; 
   function  "*" (Left : Real_Matrix; Right : Real'Base) 
      return Real_Matrix; 
   function  "/" (Left : Real_Matrix; Right : Real'Base) 
      return Real_Matrix; 
   -- Real_Matrix inversion and related operations  
   function  Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector; 
   function  Solve (A, X : Real_Matrix) return Real_Matrix; 
   function  Inverse (A : Real_Matrix) return Real_Matrix; 
   function  Determinant (A : Real_Matrix) return Real'Base; 
   -- Eigenvalues and vectors of a real symmetric matrix  
   function  Eigenvalues (A : Real_Matrix) return Real_Vector; 
   procedure  Eigensystem (A       : in  Real_Matrix; 
                          Values  : out Real_Vector; 
                          Vectors : out Real_Matrix); 
   -- Other Real_Matrix operations  
   function  Unit_Matrix (Order            : Positive; 
                         First_1, First_2 : Integer := 1)                                             return Real_Matrix; 
end Ada.Numerics.Generic_Real_Arrays; 
The library package Numerics.Real_A rrays is declared pure and define s the same types and subprograms 
as Numerics.Generic_Real_Arra ys, except that the predefined type Fl oat is systematically substituted for 
Real'Base throughout. Nongeneric equivalents for each of  the other predefined floating point types are 
defined similarly, with the names Numerics.S hort_Real_Arrays, Numerics.Long_Real_Arrays, etc.  
Two types are defined and exported by Numerics.Gen eric_Real_Arrays. The com posite type Real_Vector 
is provided to represent a vector with components of  type Real; it is defined as an unconstrained, one-10/2 
11/2 12/2 
13/2 
14/2 
15/2 
16/2 17/2 
18/2 
19/2 
20/2 
21/2 
22/2 
23/2 
24/2 
25/2 
26/2 27/2 
28/2 
29/2 
30/2 
31/2 
32/2 
Ada Reference Manual — 2012 Edition 
723      13 December 2012 Real  Vectors and Matrices   G.3.1 dimensional array with an index of type Integer. Th e composite type Real_Matri x is provided to represent 
a matrix with components of type Real; it is define d as an unconstrained, two-dimensional array with 
indices of type Integer. 
The effect of the various subprograms is as describe d below. In most cases the subprograms are described 
in terms of corresponding scalar operations of the type  Real; any exception raised by those operations is 
propagated by the array operation. Moreover, the accur acy of the result for each individual component is 
as defined for the scalar opera tion unless stated otherwise. 
In the case of those operations which are defined to involve an inner product , Constraint_Error may be 
raised if an intermediate result is outside the range  of Real'Base even though the mathematical final result 
would not be. 
function  "+"   (Right : Real_Vector) return Real_Vector; 
function  "-"   (Right : Real_Vector) return Real_Vector; 
function  "abs" (Right : Real_Vector) return Real_Vector; 
Each operation returns the result of applying th e corresponding operation of the type Real to 
each component of Right. The index range of the result is Right'Range. 
function  "+" (Left, Right : Real_Vector) return Real_Vector; 
function  "-" (Left, Right : Real_Vector) return Real_Vector; 
Each operation returns the result of applying th e corresponding operation of the type Real to 
each component of Left and the matching component  of Right. The index range of the result is 
Left'Range. Constraint_Error is raised if Left'Length is not equal to Right'Length. 
function  "*" (Left, Right : Real_Vector) return Real'Base; 
This operation returns the inner product of Left  and Right. Constraint_Error is raised if 
Left'Length is not equal to Right'Length.  This operation involves an inner product. 
function  "abs" (Right : Real_Vector) return Real'Base; 
This operation returns the L2-norm of Right (the square root of the inner product of the vector 
with itself). 
function  "*" (Left : Real'Base; Right : Real_Vector) return Real_Vector; 
This operation returns the result of multiplying each component of Right by the scalar Left using 
the "*" operation of the type Real. The index range of the result is Right'Range. 
function  "*" (Left : Real_Vector; Right : Real'Base) return Real_Vector; 
function  "/" (Left : Real_Vector; Right : Real'Base) return Real_Vector; 
Each operation returns the result of applying th e corresponding operation of the type Real to 
each component of Left and to the scalar Right . The index range of the result is Left'Range. 
function  Unit_Vector (Index : Integer; 
                      Order : Positive;                       First : Integer := 1) return Real_Vector; 
This function returns a unit vector  with Order components and a lower bound of First. All 
components are set to 0.0 except for the Index com ponent which is set to 1.0. Constraint_Error is 
raised if Index < First, Index > First + Orde r – 1 or if First + Order – 1 > Integer'Last. 
function  "+"   (Right : Real_Matrix) return Real_Matrix; 
function  "-"   (Right : Real_Matrix) return Real_Matrix; 
function  "abs" (Right : Real_Matrix) return Real_Matrix; 
Each operation returns the result of applying th e corresponding operation of the type Real to 
each component of Right. The index ranges of the result are those of Right. 33/2 
34/2 
35/2 
36/2 
37/2 
38/2 
39/2 
40/2 
41/2 
42/2 
43/2 
44/2 
45/2 
46/2 
47/2 
48/2 
49/2 
50/2 
Ada Reference Manual — 2012 Edition 
G.3.1    Real Vectors and Matri ces 13 December 2012      724 function  Transpose (X : Real_Matrix) return Real_Matrix; 
This function returns the transpose of a matrix X. The first and second index ranges of the result 
are X'Range(2) and X'Range(1) respectively. 
function  "+" (Left, Right : Real_Matrix) return Real_Matrix; 
function  "-" (Left, Right : Real_Matrix) return Real_Matrix; 
Each operation returns the result of applying th e corresponding operation of the type Real to 
each component of Left and the matching component  of Right. The index ranges of the result are 
those of Left. Constraint_Error is raised if Left 'Length(1) is not equal to Right'Length(1) or 
Left'Length(2) is not equal to Right'Length(2). 
function  "*" (Left, Right : Real_Matrix) return Real_Matrix; 
This operation provides the standard mathematical  operation for matrix multiplication. The first 
and second index ranges of the result are Left 'Range(1) and Right'Range(2) respectively. 
Constraint_Error is raised if Left'Length(2) is not equal to Right'Length(1). This operation 
involves inner products. 
function  "*" (Left, Right : Real_Vector) return Real_Matrix; 
This operation returns the outer product of a (colum n) vector Left by a (row) vector Right using 
the operation "*" of the type Real for computi ng the individual components. The first and second 
index ranges of the result are Left'R ange and Right'Range respectively. 
function  "*" (Left : Real_Vector; Right : Real_Matrix) return Real_Vector; 
This operation provides the standard mathematical  operation for multiplication of a (row) vector 
Left by a matrix Right. The index range of the (row) vector result is Right'Range(2). 
Constraint_Error is raised if Left'Length is not  equal to Right'Length(1). This operation involves 
inner products. 
function  "*" (Left : Real_Matrix; Right : Real_Vector) return Real_Vector; 
This operation provides the standard mathematical  operation for multiplication of a matrix Left 
by a (column) vector Right. The index range of the (column) vector result is Left'Range(1). 
Constraint_Error is raised if Left'Length(2) is not equal to Right'Length.  This operation involves 
inner products. 
function  "*" (Left : Real'Base; Right : Real_Matrix) return Real_Matrix; 
This operation returns the result of multiplying each component of Right by the scalar Left using 
the "*" operation of the type Real. The index ranges of the result are those of Right. 
function  "*" (Left : Real_Matrix; Right : Real'Base) return Real_Matrix; 
function  "/" (Left : Real_Matrix; Right : Real'Base) return Real_Matrix; 
Each operation returns the result of applying th e corresponding operation of the type Real to 
each component of Left and to the scalar Right. The index ranges of the result are those of Left. 
function  Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector; 
This function returns a vector Y such that X is (nearly) equal to A * Y. This is the standard 
mathematical operation for solving a single set of  linear equations. The index range of the result 
is A'Range(2). Constraint_Error is raised if  A'Length(1), A'Length(2), and X'Length are not 
equal. Constraint_Error is raised if the matrix A is ill-conditioned. 
function  Solve (A, X : Real_Matrix) return Real_Matrix; 
This function returns a matrix Y such that X is (nearly) equal to A * Y. This is the standard 
mathematical operation for solving several sets  of linear equations. The index ranges of the 51/2 
52/2 
53/2 
54/2 
55/2 
56/2 
57/2 
58/2 
59/2 
60/2 
61/2 
62/2 
63/2 
64/2 
65/2 
66/2 
67/2 
68/2 
69/2 
70/2 
Ada Reference Manual — 2012 Edition 
725      13 December 2012 Real  Vectors and Matrices   G.3.1 result are A'Range(2) and X'Range(2). Constraint _Error is raised if A'Length(1), A'Length(2), 
and X'Length(1) are not equal. Constraint_Error is raised if the matrix A is ill-conditioned. 
function  Inverse (A : Real_Matrix) return Real_Matrix; 
This function returns a matrix B such that A * B is (nearly) equal to the unit matrix. The index 
ranges of the result are A'Range(2) and A'Range(1). Constraint_Error is raised if A'Length(1) is 
not equal to A'Length(2). Constraint_Error is raised if the matrix A is ill-conditioned. 
function  Determinant (A : Real_Matrix) return Real'Base; 
This function returns the determinant of the matrix  A. Constraint_Error is raised if A'Length(1) 
is not equal to A'Length(2). 
function  Eigenvalues(A : Real_Matrix) return Real_Vector; 
This function returns the eigenvalues of the symme tric matrix A as a vector sorted into order 
with the largest first. Constraint _Error is raised if A'Length(1) is not equal to A'Length(2). The 
index range of the result is A'Range(1). Argumen t_Error is raised if the matrix A is not 
symmetric. 
procedure  Eigensystem(A       : in  Real_Matrix; 
                      Values  : out Real_Vector; 
                      Vectors : out Real_Matrix); 
This procedure computes both th e eigenvalues and eigenvectors of the symmetric matrix A. The 
out parameter Values is the same as that obt ained by calling the function Eigenvalues. The out 
parameter Vectors is a matrix whose columns are the eigenvectors of the matrix A. The order of 
the columns corresponds to the order of the ei genvalues. The eigenvectors are normalized and 
mutually orthogonal (they are orthonormal), incl uding when there are repeated eigenvalues. 
Constraint_Error is raised if A'Length(1) is not equal to A'Length(2), or if Values'Range is not 
equal to A'Range(1), or if the index ranges of th e parameter Vectors are not equal to those of A. 
Argument_Error is raised if the matrix A is not  symmetric. Constraint_Error is also raised in 
implementation-defined circumst ances if the algorithm used does not converge quickly enough. 
function  Unit_Matrix (Order            : Positive; 
                      First_1, First_2 : Integer := 1) return Real_Matrix; 
This function returns a square unit matrix  with Order**2 components and lower bounds of 
First_1 and First_2 (for the first and second inde x ranges respectively). All components are set to 
0.0 except for the main diagonal, whose components are set to 1.0. Constraint_Error is raised if 
First_1 + Order – 1 > Integer'Last or  First_2 + Order – 1 > Integer'Last. 
Implementation Requirements 
Accuracy requirements for the subprograms Solve, I nverse, Determinant, Eige nvalues and Eigensystem 
are implementation defined.  
For operations not involving an inner product, the accuracy requirements are those of the corresponding 
operations of the type Real in both the st rict mode and the relaxed mode (see G.2). 
For operations involving an inner produc t, no requirements are specified in the relaxed mode. In the strict 
mode the modulus of the absolu te error of the inner product X*Y shall not exceed g*abs(X)*abs(Y) where 
g is defined as  
g = X'Length * Real'Machine_Radix**(1 – Real'Model_Mantissa) 
For the L2-norm, no accuracy requirements are specified in the relaxed mode. In the strict mode the 
relative error on the norm shall not exceed g / 2.0 + 3.0 * Real'Model_Epsilon where g is defined as above. 71/2 
72/2 
73/2 
74/2 
75/2 
76/2 
77/2 
78/3 
79/2 
80/2 
81/2 
82/2 83/2 
84/2 
85/2 
Ada Reference Manual — 2012 Edition 
G.3.1    Real Vectors and Matri ces 13 December 2012      726 Documentation Requirements 
Implementations shall document any techniques used to reduce cancellation errors such as extended 
precision arithmetic.  
Implementation Permissions 
The nongeneric equivalent packages may, but need not, be actual instantiations of the generic package for 
the appropriate predefined type. 
Implementation Advice 
Implementations should impl ement the Solve and Inverse functions using established techniques such as 
LU decomposition with row interchanges followed by back and forward substituti on. Implementations are 
recommended to refine the result by performing an itera tion on the residuals; if this is done, then it should 
be documented.  
It is not the intention that any special provision s hould be made to determine whether a matrix is ill-
conditioned or not. The naturally occurring overflow (including division by zero) which will result from 
executing these functions with an ill- conditioned matrix and thus raise Constraint_Error is sufficient.  
The test that a matrix is symmetric should be perfo rmed by using the equality operator to compare the 
relevant components.  
An implementation should minimize the circumstances under which the algorithm used for Eigenvalues 
and Eigensystem fails to converge.  
G.3.2 Complex Vectors and Matrices 
Static Semantics 
The generic library package Numerics.Generic_C omplex_Arrays has the following declaration:  
with Ada.Numerics.Generic_Real_Arrays, Ada.Numerics.Generic_Complex_Types; 
generic 
   with package  Real_Arrays   is new 
      Ada.Numerics.Generic_Real_Arrays   (<>);    use Real_Arrays; 
   with package  Complex_Types is new 
      Ada.Numerics.Generic_Complex_Types (Real);    use Complex_Types; 
package Ada.Numerics.Generic_Complex_Arrays is 
   pragma Pure(Generic_Complex_Arrays); 
   -- Types 
   type Complex_Vector is array  (Integer range <>) of Complex; 
   type Complex_Matrix is array  (Integer range <>, 
                                 Integer range <>) of Complex; 
   -- Subprograms for Complex_Vector types  
   -- Complex_Vector selection, c onversion and composition operations  
   function  Re (X : Complex_Vector) return Real_Vector; 
   function  Im (X : Complex_Vector) return Real_Vector; 
   procedure  Set_Re (X  : in out Complex_Vector; 
                     Re : in     Real_Vector); 
   procedure  Set_Im (X  : in out Complex_Vector; 
                     Im : in     Real_Vector); 
   function  Compose_From_Cartesian (Re     : Real_Vector) 
      return Complex_Vector; 
   function  Compose_From_Cartesian (Re, Im : Real_Vector) 
      return Complex_Vector; 86/2 
87/2 
88/3 
89/2 
90/2 
91/3 
1/2 
2/2 
3/2 
4/2 
5/2 
6/2 7/2 
8/2 
9/2 
Ada Reference Manual — 2012 Edition 
727      13 December 2012 Complex Vectors and Matrices   G.3.2    function  Modulus  (X     : Complex_Vector) return Real_Vector; 
   function  "abs"    (Right : Complex_Vector) return Real_Vector 
                                                 renames Modulus; 
   function  Argument (X     : Complex_Vector) return Real_Vector; 
   function  Argument (X     : Complex_Vector; 
                      Cycle : Real'Base)      return Real_Vector; 
   function  Compose_From_Polar (Modulus, Argument : Real_Vector) 
      return Complex_Vector; 
   function  Compose_From_Polar (Modulus, Argument : Real_Vector; 
                                Cycle             : Real'Base)       return Complex_Vector; 
   -- Complex_Vector arithmetic operations  
   function  "+"       (Right  : Complex_Vector) return Complex_Vector; 
   function  "-"       (Right  : Complex_Vector) return Complex_Vector; 
   function  Conjugate (X      : Complex_Vector) return Complex_Vector; 
   function  "+"  (Left, Right : Complex_Vector) return Complex_Vector; 
   function  "-"  (Left, Right : Complex_Vector) return Complex_Vector; 
   function  "*"  (Left, Right : Complex_Vector) return Complex; 
   function  "abs"     (Right : Complex_Vector) return Real'Base; 
   -- Mixed Real_Vector and Complex_Vector arithmetic operations  
   function  "+" (Left  : Real_Vector; 
                 Right : Complex_Vector) return Complex_Vector; 
   function  "+" (Left  : Complex_Vector; 
                 Right : Real_Vector)    return Complex_Vector; 
   function  "-" (Left  : Real_Vector; 
                 Right : Complex_Vector) return Complex_Vector; 
   function  "-" (Left  : Complex_Vector; 
                 Right : Real_Vector)    return Complex_Vector; 
   function  "*" (Left  : Real_Vector;    Right : Complex_Vector) 
      return Complex; 
   function  "*" (Left  : Complex_Vector; Right : Real_Vector) 
      return Complex; 
   -- Complex_Vector scaling operations  
   function  "*" (Left  : Complex; 
                 Right : Complex_Vector) return Complex_Vector; 
   function  "*" (Left  : Complex_Vector; 
                 Right : Complex)        return Complex_Vector; 
   function  "/" (Left  : Complex_Vector; 
                 Right : Complex)        return Complex_Vector; 
   function  "*" (Left  : Real'Base; 
                 Right : Complex_Vector) return Complex_Vector; 
   function  "*" (Left  : Complex_Vector; 
                 Right : Real'Base)      return Complex_Vector; 
   function  "/" (Left  : Complex_Vector; 
                 Right : Real'Base)      return Complex_Vector; 
   -- Other Complex_Vector operations  
   function  Unit_Vector (Index : Integer; 
                         Order : Positive;                          First : Integer := 1) return Complex_Vector; 
   -- Subprograms for Complex_Matrix types  
   -- Complex_Matrix selection, c onversion and composition operations  
   function  Re (X : Complex_Matrix) return Real_Matrix; 
   function  Im (X : Complex_Matrix) return Real_Matrix; 
   procedure  Set_Re (X  : in out Complex_Matrix; 
                     Re : in     Real_Matrix); 
   procedure  Set_Im (X  : in out Complex_Matrix; 
                     Im : in     Real_Matrix); 10/2 
11/2 
12/2 
13/2 
14/2 
15/2 
16/3 17/2 18/2 
19/2 
20/2 
21/2 
22/2 
23/2 
24/2 
25/2 
26/2 27/2 
28/2 
Ada Reference Manual — 2012 Edition 
G.3.2    Complex Vectors and Matrices 13 December 2012      728    function  Compose_From_Cartesian (Re     : Real_Matrix) 
      return Complex_Matrix; 
   function  Compose_From_Cartesian (Re, Im : Real_Matrix) 
      return Complex_Matrix; 
   function  Modulus  (X     : Complex_Matrix) return Real_Matrix; 
   function  "abs"    (Right : Complex_Matrix) return Real_Matrix 
                                                 renames Modulus; 
   function  Argument (X     : Complex_Matrix) return Real_Matrix; 
   function  Argument (X     : Complex_Matrix; 
                      Cycle : Real'Base)      return Real_Matrix; 
   function  Compose_From_Polar (Modulus, Argument : Real_Matrix) 
      return Complex_Matrix; 
   function  Compose_From_Polar (Modulus, Argument : Real_Matrix; 
                                Cycle             : Real'Base)       return Complex_Matrix; 
   -- Complex_Matrix arithmetic operations  
   function  "+"       (Right : Complex_Matrix) return Complex_Matrix; 
   function  "-"       (Right : Complex_Matrix) return Complex_Matrix; 
   function  Conjugate (X     : Complex_Matrix) return Complex_Matrix; 
   function  Transpose (X     : Complex_Matrix) return Complex_Matrix; 
   function  "+" (Left, Right : Complex_Matrix) return Complex_Matrix; 
   function  "-" (Left, Right : Complex_Matrix) return Complex_Matrix; 
   function  "*" (Left, Right : Complex_Matrix) return Complex_Matrix; 
   function  "*" (Left, Right : Complex_Vector) return Complex_Matrix; 
   function  "*" (Left  : Complex_Vector; 
                 Right : Complex_Matrix) return Complex_Vector; 
   function  "*" (Left  : Complex_Matrix; 
                 Right : Complex_Vector) return Complex_Vector; 
   -- Mixed Real_Matrix and Complex_Matrix arithmetic operations  
   function  "+" (Left  : Real_Matrix; 
                 Right : Complex_Matrix) return Complex_Matrix; 
   function  "+" (Left  : Complex_Matrix; 
                 Right : Real_Matrix)    return Complex_Matrix; 
   function  "-" (Left  : Real_Matrix; 
                 Right : Complex_Matrix) return Complex_Matrix; 
   function  "-" (Left  : Complex_Matrix; 
                 Right : Real_Matrix)    return Complex_Matrix; 
   function  "*" (Left  : Real_Matrix; 
                 Right : Complex_Matrix) return Complex_Matrix; 
   function  "*" (Left  : Complex_Matrix; 
                 Right : Real_Matrix)    return Complex_Matrix; 
   function  "*" (Left  : Real_Vector; 
                 Right : Complex_Vector) return Complex_Matrix; 
   function  "*" (Left  : Complex_Vector; 
                 Right : Real_Vector)    return Complex_Matrix; 
   function  "*" (Left  : Real_Vector; 
                 Right : Complex_Matrix) return Complex_Vector; 
   function  "*" (Left  : Complex_Vector; 
                 Right : Real_Matrix)    return Complex_Vector; 
   function  "*" (Left  : Real_Matrix; 
                 Right : Complex_Vector) return Complex_Vector; 
   function  "*" (Left  : Complex_Matrix; 
                 Right : Real_Vector)    return Complex_Vector; 
   -- Complex_Matrix scaling operations  
   function  "*" (Left  : Complex; 
                 Right : Complex_Matrix) return Complex_Matrix; 
   function  "*" (Left  : Complex_Matrix; 
                 Right : Complex)        return Complex_Matrix; 
   function  "/" (Left  : Complex_Matrix; 
                 Right : Complex)        return Complex_Matrix; 29/2 
30/2 
31/2 32/2 
33/2 
34/2 
35/2 
36/2 
37/2 
38/2 
39/2 
40/2 
41/2 
42/2 
43/2 
Ada Reference Manual — 2012 Edition 
729      13 December 2012 Complex Vectors and Matrices   G.3.2    function  "*" (Left  : Real'Base; 
                 Right : Complex_Matrix) return Complex_Matrix; 
   function  "*" (Left  : Complex_Matrix; 
                 Right : Real'Base)      return Complex_Matrix; 
   function  "/" (Left  : Complex_Matrix; 
                 Right : Real'Base)      return Complex_Matrix; 
   -- Complex_Matrix inversion and related operations  
   function  Solve (A : Complex_Matrix; X : Complex_Vector) 
      return Complex_Vector; 
   function  Solve (A, X : Complex_Matrix) return Complex_Matrix; 
   function  Inverse (A : Complex_Matrix) return Complex_Matrix; 
   function  Determinant (A : Complex_Matrix) return Complex; 
   -- Eigenvalues and vectors of a Hermitian matrix  
   function  Eigenvalues(A : Complex_Matrix) return Real_Vector; 
   procedure  Eigensystem(A       : in  Complex_Matrix; 
                         Values  : out Real_Vector; 
                         Vectors : out Complex_Matrix); 
   -- Other Complex_Matrix operations  
   function  Unit_Matrix (Order            : Positive; 
                         First_1, First_2 : Integer := 1)                                             return Complex_Matrix; 
end Ada.Numerics.Generic_Complex_Arrays; 
The library package Numerics.Complex_Arrays is declared pure and defines the same types and 
subprograms as Numerics.Generic _Complex_Arrays, except that th e predefined type Float is 
systematically substituted for Real'Base, and th e Real_Vector and Real_Matrix types exported by 
Numerics.Real_Arrays are systematically substituted for Real_Vector and Real_Matrix, and the Complex 
type exported by Numerics.Complex_Types is sy stematically substituted for Complex, throughout. 
Nongeneric equivalents for each of the other predefined floating point types are defined similarly, with the 
names Numerics.Short_Complex_Arrays, Numerics.Long_Complex_Arrays, etc. 
Two types are defined and exported by Numerics .Generic_Complex_Arrays . The composite type 
Complex_Vector is provided to represent a vector with  components of type Complex; it is defined as an 
unconstrained one-dimensional array with an index of type Integer. The composite type Complex_Matrix 
is provided to represent a matrix with components of type Complex; it is defined as an unconstrained, two-
dimensional array with indices of type Integer. 
The effect of the various subprograms is as described be low. In many cases they are described in terms of 
corresponding scalar operations in Numerics.Generic _Complex_Types. Any exception raised by those 
operations is propagated by the array subprogram. Mo reover, any constraints on the parameters and the 
accuracy of the result for each individual compone nt are as defined for the scalar operation. 
In the case of those operations which are defined to involve an inner product , Constraint_Error may be 
raised if an intermediate result has a component outside the range of Real'Base even though the final 
mathematical result would not. 
function  Re (X : Complex_Vector) return Real_Vector; 
function  Im (X : Complex_Vector) return Real_Vector; 
Each function returns a vector of the specified Cartesian components of X. The index range of 
the result is X'Range. 
procedure  Set_Re (X  : in out Complex_Vector; Re : in Real_Vector); 
procedure  Set_Im (X  : in out Complex_Vector; Im : in Real_Vector); 
Each procedure replaces the specified (Cartesian) component of each of the components of X by 
the value of the matching component of Re or Im; the other (Cartesian) component of each of 44/2 
45/2 
46/2 
47/2 
48/2 49/2 
50/2 
51/2 
52/2 
53/2 
54/2 
55/2 
56/2 
57/2 
58/2 
59/2 
60/2 
Ada Reference Manual — 2012 Edition 
G.3.2    Complex Vectors and Matrices 13 December 2012      730 the components is unchanged. Constraint_Error is ra ised if X'Length is not equal to Re'Length or 
Im'Length. 
function  Compose_From_Cartesian (Re     : Real_Vector) 
   return Complex_Vector; 
function  Compose_From_Cartesian (Re, Im : Real_Vector) 
   return Complex_Vector; 
Each function constructs a vector of Complex re sults (in Cartesian representation) formed from 
given vectors of Cartesian components; when only the real components are given, imaginary 
components of zero are assumed. The index range of the result is Re'Range. Constraint_Error is 
raised if Re'Length is not equal to Im'Length. 
function  Modulus  (X     : Complex_Vector) return Real_Vector; 
function  "abs"    (Right : Complex_Vector) return Real_Vector 
                                              renames Modulus; 
function  Argument (X     : Complex_Vector) return Real_Vector; 
function  Argument (X     : Complex_Vector; 
                   Cycle : Real'Base)      return Real_Vector; 
Each function calculates and returns a vector of  the specified polar components of X or Right 
using the corresponding function in numerics.gene ric_complex_types. The index range of the 
result is X'Range or Right'Range. 
function  Compose_From_Polar (Modulus, Argument : Real_Vector) 
   return Complex_Vector; 
function  Compose_From_Polar (Modulus, Argument : Real_Vector; 
                             Cycle             : Real'Base)    return Complex_Vector; 
Each function constructs a vector of Complex re sults (in Cartesian representation) formed from 
given vectors of polar components usi ng the corresponding function in numerics.-
generic_complex_types on matchi ng components of Modulus and Ar gument. The index range of 
the result is Modulus'Range. Constraint_Error is  raised if Modulus'Length is not equal to 
Argument'Length. 
function  "+" (Right : Complex_Vector) return Complex_Vector; 
function  "-" (Right : Complex_Vector) return Complex_Vector; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of Right. The index range of the result is Right'Range. 
function  Conjugate (X : Complex_Vector) return Complex_Vector; 
This function returns the result of applying th e appropriate function Conjugate in numerics.-
generic_complex_types to each component of X.  The index range of the result is X'Range. 
function  "+" (Left, Right : Complex_Vector) return Complex_Vector; 
function  "-" (Left, Right : Complex_Vector) return Complex_Vector; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of Left and the matching component of Right. The index range of the result is Left'Range. Constraint _Error is raised if Left'Length is not equal to 
Right'Length. 
function  "*" (Left, Right : Complex_Vector) return Complex; 
This operation returns the inner product of Left  and Right. Constraint_Error is raised if 
Left'Length is not equal to Right'Length.  This operation involves an inner product. 61/2 
62/2 
63/2 
64/2 
65/2 
66/2 
67/2 
68/2 
69/2 
70/2 
71/2 
72/2 
73/2 
74/2 
Ada Reference Manual — 2012 Edition 
731      13 December 2012 Complex Vectors and Matrices   G.3.2 function  "abs" (Right : Complex_Vector) return Real'Base; 
This operation returns the Hermitian L2-norm of Ri ght (the square root of the inner product of 
the vector with its conjugate). 
function  "+" (Left  : Real_Vector; 
              Right : Complex_Vector) return Complex_Vector; 
function  "+" (Left  : Complex_Vector; 
              Right : Real_Vector)    return Complex_Vector; 
function  "-" (Left  : Real_Vector; 
              Right : Complex_Vector) return Complex_Vector; 
function  "-" (Left  : Complex_Vector; 
              Right : Real_Vector)    return Complex_Vector; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of Left and the matching component of Right. The index range of the result is Left'Range. Constraint _Error is raised if Left'Length is not equal to 
Right'Length. 
function  "*" (Left : Real_Vector;    Right : Complex_Vector) return Complex; 
function  "*" (Left : Complex_Vector; Right : Real_Vector)    return Complex; 
Each operation returns the inner product of Left  and Right. Constraint_Error is raised if 
Left'Length is not equal to Right'Length. These operations involve an inner product. 
function  "*" (Left : Complex; Right : Complex_Vector) return Complex_Vector; 
This operation returns the result of multiplying each component of Right by the complex number 
Left using the appropriate operation "*" in numer ics.generic_complex_types. The index range of 
the result is Right'Range. 
function  "*" (Left : Complex_Vector; Right : Complex) return Complex_Vector; 
function  "/" (Left : Complex_Vector; Right : Complex) return Complex_Vector; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of the vector Left and the complex number Right. The index range of the result is Left'Range. 
function  "*" (Left : Real'Base; 
              Right : Complex_Vector) return Complex_Vector; 
This operation returns the result of multiplying each component of Right by the real number Left 
using the appropriate operation "*" in numerics. generic_complex_types. The index range of the 
result is Right'Range. 
function  "*" (Left : Complex_Vector; 
              Right : Real'Base) return Complex_Vector; 
function  "/" (Left : Complex_Vector; 
              Right : Real'Base) return Complex_Vector; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of the vector Left and the real number Right. The index range of the result is Left'Range. 
function  Unit_Vector (Index : Integer; 
                      Order : Positive;                       First : Integer := 1) return Complex_Vector; 
This function returns a unit vector  with Order components and a lower bound of First. All 
components are set to (0.0, 0.0) except for the Index component which is set to (1.0, 0.0). 
Constraint_Error is raised if Index < First, Inde x > First + Order – 1, or if First + Order – 1 > 
Integer'Last. 75/3 
76/2 
77/2 
78/2 
79/2 
80/2 
81/2 
82/2 
83/2 
84/2 
85/2 
86/2 
87/2 
88/2 
89/2 
90/2 
Ada Reference Manual — 2012 Edition 
G.3.2    Complex Vectors and Matrices 13 December 2012      732 function  Re (X : Complex_Matrix) return Real_Matrix; 
function  Im (X : Complex_Matrix) return Real_Matrix; 
Each function returns a matrix of the specified Cartesian components of X. The index ranges of 
the result are those of X. 
procedure  Set_Re (X : in out Complex_Matrix; Re : in Real_Matrix); 
procedure  Set_Im (X : in out Complex_Matrix; Im : in Real_Matrix); 
Each procedure replaces the specified (Cartesian) component of each of the components of X by 
the value of the matching component of Re or Im; the other (Cartesian) component of each of the components is unchanged. Constraint_Error is  raised if X'Length(1) is not equal to 
Re'Length(1) or Im'Length(1) or if X'Length(2) is not equal to Re'Length(2) or Im'Length(2). 
function  Compose_From_Cartesian (Re     : Real_Matrix) 
   return Complex_Matrix; 
function  Compose_From_Cartesian (Re, Im : Real_Matrix) 
   return Complex_Matrix; 
Each function constructs a matrix of Complex re sults (in Cartesian representation) formed from 
given matrices of Cartesian components; when only the real components are given, imaginary 
components of zero are assumed. The inde x ranges of the result are those of Re. 
Constraint_Error is raised if Re'Length(1) is not  equal to Im'Length(1) or Re'Length(2) is not 
equal to Im'Length(2). 
function  Modulus  (X     : Complex_Matrix) return Real_Matrix; 
function  "abs"    (Right : Complex_Matrix) return Real_Matrix 
                                              renames Modulus; 
function  Argument (X     : Complex_Matrix) return Real_Matrix; 
function  Argument (X     : Complex_Matrix; 
                   Cycle : Real'Base)      return Real_Matrix; 
Each function calculates and returns a matrix of  the specified polar components of X or Right 
using the corresponding function in numerics.gene ric_complex_types. The index ranges of the 
result are those of X or Right. 
function  Compose_From_Polar (Modulus, Argument : Real_Matrix) 
   return Complex_Matrix; 
function  Compose_From_Polar (Modulus, Argument : Real_Matrix; 
                             Cycle             : Real'Base)    return Complex_Matrix; 
Each function constructs a matrix of Complex re sults (in Cartesian representation) formed from 
given matrices of polar components usi ng the corresponding function in numerics.-
generic_complex_types on matc hing components of Modulus a nd Argument. The index ranges 
of the result are those of Modulus. Constraint_Erro r is raised if Modulus'Length(1) is not equal 
to Argument'Length(1) or Modulus'Length( 2) is not equal to Argument'Length(2). 
function  "+" (Right : Complex_Matrix) return Complex_Matrix; 
function  "-" (Right : Complex_Matrix) return Complex_Matrix; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of Right . The index ranges of the result are those of 
Right. 
function  Conjugate (X : Complex_Matrix) return Complex_Matrix; 
This function returns the result of applying th e appropriate function Conjugate in numerics.-
generic_complex_types to each component of X. The index ranges of the result are those of X. 91/2 
92/2 
93/2 
94/2 
95/2 
96/2 
97/2 
98/2 
99/2 
100/2 
101/2 
102/2 
103/2 
104/2 
Ada Reference Manual — 2012 Edition 
733      13 December 2012 Complex Vectors and Matrices   G.3.2 function  Transpose (X : Complex_Matrix) return Complex_Matrix; 
This function returns the transpose of a matrix X. The first and second index ranges of the result 
are X'Range(2) and X'Range(1) respectively. 
function  "+" (Left, Right : Complex_Matrix) return Complex_Matrix; 
function  "-" (Left, Right : Complex_Matrix) return Complex_Matrix; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of Left and the matching component of Right. The index ranges of the result are those of Left. Constr aint_Error is raised if Left'Length(1) is not 
equal to Right'Length(1) or Left'Lengt h(2) is not equal to Right'Length(2). 
function  "*" (Left, Right : Complex_Matrix) return Complex_Matrix; 
This operation provides the standard mathematical  operation for matrix multiplication. The first 
and second index ranges of the result are Left 'Range(1) and Right'Range(2) respectively. 
Constraint_Error is raised if Left'Length(2) is not equal to Right'Length(1). This operation 
involves inner products. 
function  "*" (Left, Right : Complex_Vector) return Complex_Matrix; 
This operation returns the outer product of a (colum n) vector Left by a (row) vector Right using 
the appropriate operation "*" in numerics.generi c_complex_types for computing the individual 
components. The first and sec ond index ranges of the result ar e Left'Range and Right'Range 
respectively. 
function  "*" (Left  : Complex_Vector; 
              Right : Complex_Matrix) return Complex_Vector; 
This operation provides the standard mathematical  operation for multiplication of a (row) vector 
Left by a matrix Right. The index range of the (row) vector result is Right'Range(2). 
Constraint_Error is raised if Left'Length is not  equal to Right'Length(1). This operation involves 
inner products. 
function  "*" (Left  : Complex_Matrix; 
              Right : Complex_Vector) return Complex_Vector; 
This operation provides the standard mathematical  operation for multiplication of a matrix Left 
by a (column) vector Right. The index range of the (column) vector result is Left'Range(1). 
Constraint_Error is raised if Left'Length(2) is not equal to Right'Length.  This operation involves 
inner products. 
function  "+" (Left  : Real_Matrix; 
              Right : Complex_Matrix) return Complex_Matrix; 
function  "+" (Left  : Complex_Matrix; 
              Right : Real_Matrix)    return Complex_Matrix; 
function  "-" (Left  : Real_Matrix; 
              Right : Complex_Matrix) return Complex_Matrix; 
function  "-" (Left  : Complex_Matrix; 
              Right : Real_Matrix)    return Complex_Matrix; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of Left and the matching component of Right. The index ranges of the result are those of Left. Constr aint_Error is raised if Left'Length(1) is not 
equal to Right'Length(1) or Left'Lengt h(2) is not equal to Right'Length(2). 105/2 
106/2 
107/2 
108/2 
109/2 
110/2 
111/2 
112/2 
113/2 
114/2 
115/2 
116/2 
117/2 
118/2 
Ada Reference Manual — 2012 Edition 
G.3.2    Complex Vectors and Matrices 13 December 2012      734 function  "*" (Left  : Real_Matrix; 
              Right : Complex_Matrix) return Complex_Matrix; 
function  "*" (Left  : Complex_Matrix; 
              Right : Real_Matrix)    return Complex_Matrix; 
Each operation provides the standard mathematical  operation for matrix multiplication. The first 
and second index ranges of the result are Left 'Range(1) and Right'Range(2) respectively. 
Constraint_Error is raised if Left'Length(2) is  not equal to Right'Length(1). These operations 
involve inner products. 
function  "*" (Left  : Real_Vector; 
              Right : Complex_Vector) return Complex_Matrix; 
function  "*" (Left  : Complex_Vector; 
              Right : Real_Vector)    return Complex_Matrix; 
Each operation returns the outer product of a (colum n) vector Left by a (row) vector Right using 
the appropriate operation "*" in numerics.generi c_complex_types for computing the individual 
components. The first and sec ond index ranges of the result ar e Left'Range and Right'Range 
respectively. 
function  "*" (Left  : Real_Vector; 
              Right : Complex_Matrix) return Complex_Vector; 
function  "*" (Left  : Complex_Vector; 
              Right : Real_Matrix)    return Complex_Vector; 
Each operation provides the standard mathematical  operation for multiplication of a (row) vector 
Left by a matrix Right. The index range of the (row) vector result is Right'Range(2). 
Constraint_Error is raised if Left'Length is not equal to Right'Length(1). These operations 
involve inner products. 
function  "*" (Left  : Real_Matrix; 
              Right : Complex_Vector) return Complex_Vector; 
function  "*" (Left  : Complex_Matrix; 
              Right : Real_Vector)    return Complex_Vector; 
Each operation provides the standard mathematical  operation for multiplication of a matrix Left 
by a (column) vector Right. The index range of the (column) vector result is Left'Range(1). 
Constraint_Error is raised if Left'Length(2) is not equal to Right'Length. These operations 
involve inner products. 
function  "*" (Left : Complex; Right : Complex_Matrix) return Complex_Matrix; 
This operation returns the result of multiplying each component of Right by the complex number 
Left using the appropriate operation "*" in num erics.generic_complex_types. The index ranges 
of the result are those of Right. 
function  "*" (Left : Complex_Matrix; Right : Complex) return Complex_Matrix; 
function  "/" (Left : Complex_Matrix; Right : Complex) return Complex_Matrix; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of the matrix Left and the complex number Right. The index ranges of the result are those of Left. 
function  "*" (Left : Real'Base; 
              Right : Complex_Matrix) return Complex_Matrix; 
This operation returns the result of multiplying each component of Right by the real number Left 
using the appropriate operation "*" in numerics. generic_complex_types. The index ranges of the 
result are those of Right. 119/2 
120/2 
121/2 
122/2 
123/2 
124/2 
125/2 
126/2 
127/2 
128/2 
129/2 
130/2 
131/2 
132/2 
Ada Reference Manual — 2012 Edition 
735      13 December 2012 Complex Vectors and Matrices   G.3.2 function  "*" (Left : Complex_Matrix; 
              Right : Real'Base) return Complex_Matrix; 
function  "/" (Left : Complex_Matrix; 
              Right : Real'Base) return Complex_Matrix; 
Each operation returns the result of appl ying the corresponding operation in numerics.-
generic_complex_types to each component of the matrix Left and the real number Right. The index ranges of the result are those of Left. 
function  Solve (A : Complex_Matrix; X : Complex_Vector) return 
Complex_Vector; 
This function returns a vector Y such that X is (nearly) equal to A * Y. This is the standard 
mathematical operation for solving a single set of  linear equations. The index range of the result 
is A'Range(2). Constraint_Error is raised if  A'Length(1), A'Length(2), and X'Length are not 
equal. Constraint_Error is raised if the matrix A is ill-conditioned. 
function  Solve (A, X : Complex_Matrix) return Complex_Matrix; 
This function returns a matrix Y such that X is (nearly) equal to A * Y. This is the standard 
mathematical operation for solving several sets  of linear equations. The index ranges of the 
result are A'Range(2) and X'Range(2). Constraint _Error is raised if A'Length(1), A'Length(2), 
and X'Length(1) are not equal. Constraint_Error is raised if the matrix A is ill-conditioned. 
function  Inverse (A : Complex_Matrix) return Complex_Matrix; 
This function returns a matrix B such that A * B is (nearly) equal to the unit matrix. The index 
ranges of the result are A'Range(2) and A'Range(1). Constraint_Error is raised if A'Length(1) is 
not equal to A'Length(2). Constraint_Error is raised if the matrix A is ill-conditioned. 
function  Determinant (A : Complex_Matrix) return Complex; 
This function returns the determinant of the matrix  A. Constraint_Error is raised if A'Length(1) 
is not equal to A'Length(2). 
function  Eigenvalues(A : Complex_Matrix) return Real_Vector; 
This function returns the eigenvalues of the Herm itian matrix A as a vector sorted into order 
with the largest first. Constraint _Error is raised if A'Length(1) is not equal to A'Length(2). The 
index range of the result is A'Range(1). Argumen t_Error is raised if the matrix A is not 
Hermitian. 
procedure  Eigensystem(A       : in  Complex_Matrix; 
                      Values  :  out Real_Vector; 
                      Vectors :  out Complex_Matrix); 
This procedure computes both the eigenvalues a nd eigenvectors of the Hermitian matrix A. The 
out parameter Values is the same as that obt ained by calling the function Eigenvalues. The out 
parameter Vectors is a matrix whose columns are the eigenvectors of the matrix A. The order of 
the columns corresponds to the order of the eigenvalues. The eigenvectors are mutually 
orthonormal, including when there are repeated eigenvalues. Constraint_Error is raised if 
A'Length(1) is not equal to A'Length(2), or if Valu es'Range is not equal to A'Range(1), or if the 
index ranges of the parameter Vect ors are not equal to those of A.  Argument_Error is raised if 
the matrix A is not Hermitian. Constraint_Erro r is also raised in implementation-defined 
circumstances if the algorithm used does not converge quickly enough. 133/2 
134/2 
135/2 
136/2 
137/2 
138/2 
139/2 
140/2 
141/2 
142/2 
143/2 
144/2 
145/2 
146/3 
Ada Reference Manual — 2012 Edition 
G.3.2    Complex Vectors and Matrices 13 December 2012      736 function  Unit_Matrix (Order            : Positive; 
                      First_1, First_2 : Integer := 1)                                          return Complex_Matrix; 
This function returns a square unit matrix  with Order**2 components and lower bounds of 
First_1 and First_2 (for the first and second inde x ranges respectively). All components are set to 
(0.0, 0.0) except for the main diagonal, whose co mponents are set to (1.0, 0.0). Constraint_Error 
is raised if First_1 + Order – 1 > Integer' Last or First_2 + Order – 1 > Integer'Last. 
Implementation Requirements 
Accuracy requirements for the subprograms Solve, I nverse, Determinant, Eige nvalues and Eigensystem 
are implementation defined.  
For operations not involving an inner product, the accuracy requirements are those of the corresponding 
operations of the type Real'Base and Complex in bot h the strict mode and the relaxed mode (see G.2). 
For operations involving an inner produc t, no requirements are specified in the relaxed mode. In the strict 
mode the modulus of the absolu te error of the inner product X*Y shall not exceed g*abs(X)*abs(Y) where 
g is defined as  
g = X'Length * Real'Machine_Radix**(1 – Real'Model_Mantissa) 
    for mixed complex and real operands 
g = sqrt(2.0) * X'Length * Real'Machine_Radix**(1 – Real'Model_Mantissa) 
    for two complex operands 
For the L2-norm, no accuracy requirements are specified in the relaxed mode. In the strict mode the 
relative error on the norm shall not exceed g / 2.0 + 3.0 * Real'Model_Epsilon where g has the definition 
appropriate for two complex operands. 
Documentation Requirements 
Implementations shall document any techniques used to reduce cancellation errors such as extended precision arithmetic.  
Implementation Permissions 
The nongeneric equivalent packages may, but need not, be actual instantiations of the generic package for 
the appropriate predefined type. 
Although many operations are defined in terms of ope rations from numerics.generic_complex_types, they 
need not be implemented by calling those operati ons provided that the effect is the same.  
Implementation Advice 
Implementations should im plement the Solve and Inverse functi ons using established techniques. 
Implementations are recommended to refine the result by  performing an iteration on the residuals; if this is 
done, then it should be documented.  
It is not the intention that any special provision s hould be made to determine whether a matrix is ill-
conditioned or not. The naturally occurring overflow (including division by zero) which will result from 
executing these functions with an ill- conditioned matrix and thus raise Constraint_Error is sufficient.  
The test that a matrix is Hermitian should use the equality operator to compare the real components and 
negation followed by equality to compare the imaginary components (see G.2.1).  
An implementation should minimize the circumstances under which the algorithm used for Eigenvalues 
and Eigensystem fails to converge.  147/2 
148/2 
149/2 
150/2 151/2 
152/2 
153/2 154/2 
155/2 
156/2 
157/2 
158/3 
159/2 
160/2 
160.1/3 
Ada Reference Manual — 2012 Edition 
737      13 December 2012 Complex Vectors and Matrices   G.3.2 Implementations should not perform operations on mixed complex and r eal operands by first converting 
the real operand to complex. See G.1.1.  161/2 

Ada Reference Manual — 2012 Edition 
739      13 December 2012 High Integrity Systems   H Annex H 
(normative)  
High Integrity Systems 
This Annex addresses requi rements for high integrity systems (i ncluding safety-critical systems and 
security-critical systems). It provides facilities and specifies documentation requirements that relate to 
several needs:  
• Understanding program execution; 
• Reviewing object code; 
• Restricting language constructs whose usage might complicate the demonstration of program 
correctness  
Execution understandability is supported by pragma Norm alize_Scalars, and also by requirements for the 
implementation to document the eff ect of a program in the presence of a bounded error or where the 
language rules leave the effect unspecified.  
The pragma s Reviewable and Restrictions relate to the other requirements addre ssed by this Annex.  
NOTES 
1  The Valid attribute (see 13.9.2) is also useful in addressing these needs, to avoid problems that could otherwise arise from scalars that have values outside their declared range constraints.  
H.1 Pragma Normalize_Scalars 
This pragma ensures that an otherw ise uninitialized scalar object is set to a predictable value, but out of 
range if possible.  
Syntax 
The form of a pragma  Normalize_Scalars is as follows:  
  pragma  Normalize_Scalars;  
Post-Compilation Rules 
Pragma Normalize_Scalars is a configuration pragma. It applies to all compilation_unit s included in a 
partition.  
Documentation Requirements 
If a pragma  Normalize_Scalars applies, the implementati on shall document the implicit initial values for 
scalar subtypes, and shall identify each case in which such a value is used and is not an invalid representation.  
Implementation Advice 
Whenever possible, the implicit initial values for a s calar subtype should be an invalid representation (see 
13.9.1).  
NOTES 
2  The initialization requirement applies to uninitialized scalar objects that are subcomponents of composite objects, to allocated objects, and to stand-alone objects. It also applies to scalar out parameters. Scalar subcomponents of composite 
out parameters are initialized to the corresponding part of the actual, by virtue of 6.4.1. 1/2 
2 
3 4 
4.1 
5 
6 
1 
2 
3 
4 
5/2 
6/2 
7 
Ada Reference Manual — 2012 Edition 
H.1   Pragma Normalize_Scalars 13 December 2012      740 3  The initialization requirement does not apply to a scalar for which pragma Import has been specified, since initialization 
of an imported object is performed solely by the foreign language environment (see B.1). 
4  The use of pragma Normalize_Scalars in conjunction with Pragma Restrictions(No_Exceptions) may result in 
erroneous execution (see H.4).  
H.2 Documentation of Im plementation Decisions 
Documentation Requirements 
The implementation shall document the range of effect s for each situation that the language rules identify 
as either a bounded error or as having an unspecified effect. If the implementation can constrain the effects 
of erroneous execution for a given construct, then it shall document such cons traints. The documentation 
might be provided either independently of any compila tion unit or partition, or as part of an annotated 
listing for a given unit or partition.  See also 1.1.3, and 1.1.2.  
NOTES 
5  Among the situations to be documented are the conventions chosen for parameter passing, the methods used for the management of run-time storage, and the method used to evaluate numeric expressions if this involves extended range or extra precision.  
H.3 Reviewable Object Code 
Object code review and validation are supported by pragmas Reviewable and Inspection_Point.  
H.3.1 Pragma Reviewable 
This pragma directs the implementation to provide in formation to facilitate analysis and review of a 
program's object code, in particular to allow dete rmination of execution time and storage usage and to 
identify the correspondence between the source and object programs.  
Syntax 
The form of a pragma  Reviewable is as follows:  
  pragma  Reviewable;  
Post-Compilation Rules 
Pragma Reviewable is a configuration pragma. It applies to all compilation_unit s included in a partition.  
Implementation Requirements 
The implementation shall provide the following information for any compilation unit to which such a 
pragma applies:  
• Where compiler-generated run-time checks remain;  
• An identification of any construct with a language -defined check that is recognized prior to run 
time as certain to fail if executed (even if  the generation of run-time checks has been 
suppressed);  
• For each read of a scalar object, an identification of the read as either “known to be initialized,” 
or “possibly uninitialized,” independent of wh ether pragma Normalize_Scalars applies;  
• Where run-time support routines are implicitly invoked;  8 
9 
1 
2 
1 
1 
2 
3 
4 
5 
6 
7 
8/2 
9 
Ada Reference Manual — 2012 Edition 
741      13 December 2012 Pragma Reviewable   H.3.1 • An object code listing, including:  
• Machine instructions, w ith relative offsets;  
• Where each data object is stored during its lifetime;  
• Correspondence with the source program, including an identification of the code produced 
per declaration and per statement.  
• An identification of each construct for which the implementation detects the possibility of 
erroneous execution;  
• For each subprogram, block, task, or other constr uct implemented by reserving and subsequently 
freeing an area on a run-time stack, an identificati on of the length of the fixed-size portion of the 
area and an indication of whether the non-fixed size portion is reserved on the stack or in a dynamically-managed storage region.  
The implementation shall provide the following informati on for any partition to which the pragma applies:  
• An object code listing of the entire partition, in cluding initialization and finalization code as well 
as run-time system components, a nd with an identification of those instructions and data that 
will be relocated at load time;  
• A description of the run-time model relevant to the partition.  
The implementation shall provide control- and data -flow information, both within each compilation unit 
and across the compilation units of the partition.  
Implementation Advice 
The implementation should provide th e above information in both a human -readable and machine-readable 
form, and should document the latte r so as to ease further processing by automated tools.  
Object code listings should be provided both in a sym bolic format and also in an appropriate numeric 
format (such as hexadecimal or octal).  
NOTES 
6  The order of elaboration of library units will be documented even in the absence of pragma  Reviewable (see 10.2).  
H.3.2 Pragma Inspection_Point 
An occurrence of a pragma Inspection_Point identifie s a set of objects each of whose values is to be 
available at the point(s) during program execution corresponding to the position of the pragma in the 
compilation unit. The purpose of such a prag ma is to facilitate code validation.  
Syntax 
The form of a pragma  Inspection_Point is as follows:  
  pragma  Inspection_Point[( object_ name  {, object_ name })];  
Legality Rules 
A pragma Inspection_Point is allowed wherever a declarative_item  or statement  is allowed. Each 
object_ name shall statically denote the declaration of an object.  
Static Semantics 
An inspection point  is a point in the object code corresponding to the occurrence of a pragma Inspection_-
Point in the compilation unit. An object is inspectable  at an inspection point if the corresponding pragma 10 
11 
12 13 
14 15 
16 
17 
18 
18.1 
19 
20 
21 
1 
2 
3 
4 
5/2 
Ada Reference Manual — 2012 Edition 
H.3.2    Pragma Inspection_Point 13 December 2012      742 Inspection_Point either has an argument denoting that  object, or has no arguments and the declaration of 
the object is visible at the inspection point.  
Dynamic Semantics 
Execution of a pragma Inspection_Point has no effect.  
Implementation Requirements 
Reaching an inspection point is an external interaction with respect to the values of the inspectable objects 
at that point (see 1.1.3).  
Documentation Requirements 
For each inspection point, the implementation shall identify a mapping between each inspectable object 
and the machine resources (such as memory locations or registers) from which the object's value can be obtained.  
NOTES 
7  The implementation is not allowed to perform “dead store elimination” on the last assignment to a variable prior to a point where the variable is inspectable. Thus an inspection point has the effect of an implicit read of each of its inspectable  
objects. 
8  Inspection points are useful in maintaining a correspondence between the state of the program in source code terms, and 
the machine state during the program's execution. Assertions about the values of program objects can be tested in machine terms at inspection points. Object code between inspection points can be processed by automated tools to verify programs mechanically.  
9  The identification of the mapping from source program objects to machine resources is allowed to be in the form of an 
annotated object listing, in human-readable or tool-processable form.  
H.4 High Integrity Restrictions 
This subclause defines restrictions that can be used  with pragma Restrictions  (see 13.12); these facilitate 
the demonstration of program correctness by allo wing tailored versions of the run-time system.  
Static Semantics 
This paragraph was deleted.  
The following restriction_ identifier s are language defined: 
Tasking-related restriction:  
No_Protected_Types  
 There are no declarations of protected types or protected objects.  
Memory-management related restrictions:  
No_Allocators  
 There are no occurrences of an allocator . 
No_Local_Allocators  
 Allocator s are prohibited in subprograms, generic subprograms, tasks, and entry bodies.  
No_Anonymous_Allocators  
 There are no allocator s of anonymous access types. 
No_Coextensions  
 There are no coextensions. See 3.10.2. 6 
7 
8 
9/2 
10 
11 
1/3 
2/2 
3/2 
4 
5 
6 
7 
8/1 
8.1/3 8.2/3 
Ada Reference Manual — 2012 Edition 
743      13 December 2012 High Integrity Restrictions   H.4 No_Access_Parameter_Allocators  
 Allocator s are not permitted as the actual parameter to an access parameter. See 6.1. 
 This paragraph was deleted.  
Immediate_Reclamation  
 Except for storage occupied by objects created by allocator s and not deallocated via 
unchecked deallocation, any storage reserved at run time for an object is immediately reclaimed when the object no longer exists.  
Exception-related restriction:  
No_Exceptions  
 
Raise_statement s and exception_handler s are not allowed. No language-defined run-time 
checks are generated; however, a run-time check  performed automatically by the hardware 
is permitted.  
Other restrictions:  
No_Floating_Point  
 Uses of predefined floating point types a nd operations, and declarations of new floating 
point types, are not allowed.  
No_Fixed_Point  
 Uses of predefined fixed point types and ope rations, and declarations of new fixed point 
types, are not allowed.  
 This paragraph was deleted.  
No_Access_Subprograms  
 The declaration of access-to-subprogram types is not allowed.  
No_Unchecked_Access  
 The Unchecked_Access attribute is not allowed. 
No_Dispatch  Occurrences of T'Class are not  allowed, for any (tagged) subtype T. 
No_IO  Semantic dependence on any of the libra ry units Sequential_IO, Direct_IO, Text_IO, 
Wide_Text_IO, Wide_Wide_Text_IO, or Stream_IO is not allowed.  
No_Delay  Delay_Statement s and semantic dependence on pack age Calendar are not allowed.  
No_Recursion  
 As part of the execution of a subprogr am, the same subprogram is not invoked. 
No_Reentrancy  
 During the execution of a subprogram by a task, no other task invokes the same 
subprogram. 
Implementation Requirements 
An implementation of th is Annex shall support:  
• the restrictions defined in this subclause; and 
• the following restrictions defined in D. 7: No_Task_Hierarchy, No_Abort_Statement, 
No_Implicit_Heap_Allocation, No_Standar d_Allocators_After_Elaboration; and 
• the pragma  Profile(Ravenscar); and  
• the following uses of restriction_parameter_ identifier s defined in D.7, which are checked prior 
to program execution:  
• Max_Task_Entries => 0, 8.3/3 
9/2 
10 
11 
12 
13 
14 
15 
16/2 
17 
18 19 
20/2 
21 
22 
23 
23.1/2 
23.2/2 
23.3/3 
23.4/2 
23.5/2 
23.6/2 
Ada Reference Manual — 2012 Edition 
H.4   High Integrity Restrictions 13 December 2012      744 • Max_Asynchronous_Select_Nesting => 0, and 
• Max_Tasks => 0.  
If an implementation supports pragma  Restrictions for a particular argument, then except for the 
restrictions No_Unchecked_Deallocation, N o_Unchecked_Conversion, No_Access_Subprograms, 
No_Unchecked_Access, No_Specifi cation_of_Aspect, No_Use_of_Attri bute, No_Use_of_Pragma, and 
the equivalent use of No_Dependence, the associat ed restriction applies to the run-time system.  
Documentation Requirements 
If a pragma Restrictions(No_Exceptions) is specified, the implementation shall document the effects of all 
constructs where language-defined checks are still pe rformed automatically (for example, an overflow 
check performed by the processor).  
Erroneous Execution 
Program execution is erroneous if pragma Restri ctions(No_Exceptions) has been specified and the 
conditions arise under which a generated langua ge-defined run-time check would fail.  
Program execution is erroneous if pragma Restri ctions(No_Recursion) has been specified and a 
subprogram is invoked as part of its  own execution, or if pragma Restrictions(No_Reentrancy) has been 
specified and during the execution of a subprogram by a task, another task invokes the same subprogram.  
NOTES 
10  Uses of restriction_parameter_ identifier  No_Dependence defined in 13.12.1: No_Dependence => Ada.Unchecked_-
Deallocation and No_Dependence => Ada.Unchecked_Conversion may be appropriate for high-integrity systems. Other uses of No_Dependence can also be appropriate for high-integrity systems.  
H.5 Pragma Detect_Blocking 
The following pragma  forces an implementation to detect potentially blocking operations within a 
protected operation.  
Syntax 
The form of a pragma  Detect_Blocking is as follows:  
  pragma  Detect_Blocking;  
Post-Compilation Rules 
A pragma  Detect_Blocking is a configuration pragma.  
Dynamic Semantics 
An implementation is required to detect a potentially  blocking operation within a protected operation, and 
to raise Program_Error (see 9.5.1).  
Implementation Permissions 
An implementation is allowed to reject a compilation_unit  if a potentially blocking operation is present 
directly within an entry_body  or the body of a protected subprogram.  
NOTES 
11  An operation that causes a task to be blocked within a foreign language domain is not defined to be potentially blocking, and need not be detected.  23.7/2 
23.8/2 
24/3 
25 
26 
27 
28/2 
1/2 
2/2 
3/2 
4/2 
5/2 
6/2 
7/2 
Ada Reference Manual — 2012 Edition 
745      13 December 2012 Pragma Partition_Elaboration_Policy   H.6 H.6 Pragma Partition_Elaboration_Policy 
This subclause defines a pragma  for user control over elaboration policy.  
Syntax 
The form of a pragma  Partition_Elaboration_Policy is as follows:  
  pragma  Partition_Elaboration_Policy ( policy_ identifier ); 
The policy_ identifier  shall be either Sequential, Concurrent or an implementation-defined identifier.  
Post-Compilation Rules 
A pragma  Partition_Elaboration_Policy is a configuration pr agma. It specifies the elaboration policy for a 
partition. At most one elaboration polic y shall be specified for a partition. 
If the Sequential policy is specified for a partition, then pragma Restrictions (No_Task_Hierarchy) shall 
also be specified for the partition.  
Dynamic Semantics 
Notwithstanding what this Internationa l Standard says elsewhere, this pragma  allows partition elaboration 
rules concerning task activation and interr upt attachment to be changed. If the policy_ identifier  is 
Concurrent, or if there is no pragma Partition_Elabora tion_Policy defined for the partition, then the rules 
defined elsewhere in this Standard apply. 
If the partition elaboration policy is Sequential, th en task activation and interrupt attachment are 
performed in the following sequence of steps: 
• The activation of all library-level tasks and th e attachment of interrupt handlers are deferred 
until all library units are elaborated. 
• The interrupt handlers are attached by the environment task. 
• The environment task is suspended while the library-level tasks are activated. 
• The environment task executes the main subprogr am (if any) concurren tly with these executing 
tasks.  
If several dynamic interrupt handler attachments for the same interrupt are deferred, then the most recent 
call of Attach_Handler or Exchange_Handler  determines which handler is attached. 
If any deferred task activation fails, Tasking_Error is ra ised at the beginning of the sequence of statements 
of the body of the environment task prior to calling the main subprogram. 
Implementation Advice 
If the partition elaboration policy is Sequential and the Environment task becomes permanently blocked 
during elaboration, then the partition is deadlo cked and it is recommended that the partition be 
immediately terminated.  
Implementation Permissions 
If the partition elaboration policy is Sequential and an y task activation fails, then an implementation may 
immediately terminate the active partition to mitigate the hazard posed by continuing to execute with a 
subset of the tasks being active.  1/3 
2/2 
3/2 
4/2 
5/2 
6/3 
7/2 
8/2 
9/2 
10/2 
11/2 12/2 
13/2 
14/2 
15/3 
16/3 
Ada Reference Manual — 2012 Edition 
H.6   Pragma Partition_Elaboration_Policy 13 December 2012      746 NOTES 
12  If any deferred task activation fails, the environment task is unable to handle the Tasking_Error exception and completes immediately. By contrast, if the partition elaboration policy is Concurrent, then this exception could be handled within a library unit.  17/2 
Ada Reference Manual — 2012 Edition 
747      13 December 2012 Obsolescent Features   J Annex J 
(normative)  
Obsolescent Features 
This Annex contains descriptions of features of th e language whose functionality is largely redundant with 
other features defined by this Inte rnational Standard. Use of these f eatures is not recommended in newly 
written programs. Use of these features can be  prevented by using pragma Restrictions 
(No_Obsolescent_Featur es), see 13.12.1.  
J.1 Renamings of Library Units 
Static Semantics 
The following library_unit_renaming_declaration s exist:  
with Ada.Unchecked_Conversion; 
generic function  Unchecked_Conversion renames Ada.Unchecked_Conversion; 
with Ada.Unchecked_Deallocation; 
generic procedure  Unchecked_Deallocation renames Ada.Unchecked_Deallocation; 
with Ada.Sequential_IO; 
generic package Sequential_IO renames Ada.Sequential_IO; 
with Ada.Direct_IO; 
generic package Direct_IO renames Ada.Direct_IO; 
with Ada.Text_IO; 
package Text_IO renames Ada.Text_IO; 
with Ada.IO_Exceptions; 
package IO_Exceptions renames Ada.IO_Exceptions; 
with Ada.Calendar; 
package Calendar renames Ada.Calendar; 
with System.Machine_Code; 
package Machine_Code renames System.Machine_Code; --  If supported.  
Implementation Requirements 
The implementation shall allow the user to replace these renamings.  
J.2 Allowed Replacements of Characters 
Syntax 
The following replacements are allowed for the ve rtical line, number sign, and quotation mark 
characters:  
• A vertical line character (|) can be replaced by an exclamation mark (!) where used as a 
delimiter. 
• The number sign characters (#) of a based_literal  can be replaced by colons (:) provided 
that the replacement is done for both occurrences.  
• The quotation marks (") used as string brack ets at both ends of a string literal can be 
replaced by percent signs (%) provided that the enclosed sequence of characters contains no 
quotation mark, and provided that both stri ng brackets are replaced. Any percent sign 
within the sequence of characters shall then be doubled and each such doubled percent sign is interpreted as a single percent sign character value.  1/2 
1 
2 
3 4 5 6 7 8 9 
10 
1 
2 
3 4 
Ada Reference Manual — 2012 Edition 
J.2   Allowed Replacements of Ch aracters 13 December 2012      748 These replacements do not change the meaning of the program.  
J.3 Reduced Accuracy Subtypes 
A digits_constraint  may be used to define a floating point subtype with a new value for its requested 
decimal precision, as reflected by its Digits attribute. Similarly, a delta_constraint  may be used to define 
an ordinary fixed point subtype with a new value for its delta , as reflected by its Delta attribute.  
Syntax 
delta_constraint ::= delta  static_ expression  [range_constraint ] 
Name Resolution Rules 
The expression  of a delta_constraint  is expected to be of any real type.  
Legality Rules 
The expression  of a delta_constraint  shall be static. 
For a subtype_indication  with a delta_constraint , the subtype_mark  shall denote an ordinary fixed point 
subtype. 
For a subtype_indication  with a digits_constraint , the subtype_mark  shall denote either a decimal fixed 
point subtype or a floating point subtype (notwithst anding the rule given in 3.5.9 that only allows a 
decimal fixed point subtype).  
Static Semantics 
A subtype_indication  with a subtype_mark  that denotes an ordinary fixed point subtype and a 
delta_constraint  defines an ordinary fixed point subtype with a delta  given by the value of the expression  
of the delta_constraint . If the delta_constraint  includes a range_constraint , then the ordinary fixed point 
subtype is constrained by the range_constraint . 
A subtype_indication  with a subtype_mark  that denotes a floating point subtype and a digits_constraint  
defines a floating point subtype with a requested deci mal precision (as reflected by its Digits attribute) 
given by the value of the expression  of the digits_constraint . If the digits_constraint  includes a range_-
constraint , then the floating point subtype is constrained by the range_constraint .  
Dynamic Semantics 
A delta_constraint  is compatible  with an ordinary fixed point subtype if the value of the expression  is no 
less than the delta  of the subtype, and the range_constraint , if any, is compatib le with the subtype. 
A digits_constraint  is compatible  with a floating point subtype if the value of the expression  is no greater 
than the requested decimal precision of the subtype, and the range_constraint , if any, is compatible with 
the subtype. 
The elaboration of a delta_constraint  consists of the elaboration of the range_constraint , if any.  5 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
Ada Reference Manual — 2012 Edition 
749      13 December 2012 The Constrained Attribute   J.4 J.4 The Constrained Attribute 
Static Semantics 
For every private subtype S, the following attribute is defined:  
S'Constrained 
 Yields the value False if S denotes an unconstrained nonformal private subtype with 
discriminants; also yields the value False if S denotes a generic formal private subtype, and 
the associated actual subtype is either an unc onstrained subtype with discriminants or an 
unconstrained array subtype; yields the value True  otherwise. The value of this attribute is 
of the predefined subtype Boolean.  
J.5 ASCII 
Static Semantics 
The following declaration exists in th e declaration of package Standard:  
package ASCII is 
  --   Control characters:  
  NUL   : constant  Character := nul;  SOH   : constant  Character := soh; 
  STX   : constant  Character := stx;  ETX   : constant  Character := etx; 
  EOT   : constant  Character := eot;  ENQ   : constant  Character := enq; 
  ACK   : constant  Character := ack;  BEL   : constant  Character := bel; 
  BS    : constant  Character := bs;  HT    : constant  Character := ht; 
  LF    : constant  Character := lf;  VT    : constant  Character := vt; 
  FF    : constant  Character := ff;  CR    : constant  Character := cr; 
  SO    : constant  Character := so;  SI    : constant  Character := si; 
  DLE   : constant  Character := dle;  DC1   : constant  Character := dc1; 
  DC2   : constant  Character := dc2;  DC3   : constant  Character := dc3; 
  DC4   : constant  Character := dc4;  NAK   : constant  Character := nak; 
  SYN   : constant  Character := syn;  ETB   : constant  Character := etb; 
  CAN   : constant  Character := can;  EM    : constant  Character := em; 
  SUB   : constant  Character := sub;  ESC   : constant  Character := esc; 
  FS    : constant  Character := fs;  GS    : constant  Character := gs; 
  RS    : constant  Character := rs;  US    : constant  Character := us; 
  DEL   : constant  Character := del; 
  --  Other characters:  
  Exclam   : constant  Character:= '!'; Quotation : constant  Character:= '"'; 
  Sharp    : constant  Character:= '#'; Dollar    : constant  Character:= '$'; 
  Percent  : constant  Character:= '%'; Ampersand : constant  Character:= '&'; 
  Colon    : constant  Character:= ':'; Semicolon : constant  Character:= ';'; 
  Query    : constant  Character:= '?'; At_Sign   : constant  Character:= '@'; 
  L_Bracket: constant  Character:= '['; Back_Slash: constant  Character:= '\'; 
  R_Bracket: constant  Character:= ']'; Circumflex: constant  Character:= '^'; 
  Underline: constant  Character:= '_'; Grave     : constant  Character:= '`'; 
  L_Brace  : constant  Character:= '{'; Bar       : constant  Character:= '|'; 
  R_Brace  : constant  Character:= '}'; Tilde     : constant  Character:= '~'; 
  --  Lower case letters:  
  LC_A: constant  Character:= 'a'; 
  ...   LC_Z: constant  Character:= 'z'; 
end ASCII; 1 
2 
1 
2 
3 4 
5 
6 
7 
8 
9 
Ada Reference Manual — 2012 Edition 
J.6   Numeric_Error 13 December 2012      750 J.6 Numeric_Error 
Static Semantics 
The following declaration exists in th e declaration of package Standard:  
Numeric_Error : exception  renames Constraint_Error; 
J.7 At Clauses 
Syntax 
at_clause ::= for direct_name  use at expression ; 
Static Semantics 
An at_clause  of the form “for x use at y;” is equivalent to an attribute_definition_clause  of the form “for 
x'Address use y;”.  
J.7.1 Interrupt Entries 
Implementations are permitted to allow the attachment of  task entries to interrupts via the address clause. 
Such an entry is referred to as an interrupt entry . 
The address of the task entry corresponds to a hardwa re interrupt in an impl ementation-defined manner. 
(See Ada.Interrupts.Reference in C.3.2.)  
Static Semantics 
The following attribute is defined: 
For any task entry X:  
X'Address  For a task entry whose address is specified (an interrupt entry ), the value refers to the 
corresponding hardware interrupt. For such an entry, as for any other task entry, the meaning of this value is implemen tation defined. The value of this attribute is of the type of 
the subtype System.Address. 
 Address may be specified for single entries via an 
attribute_definition_clause .  
Dynamic Semantics 
As part of the initialization of a task object, the addre ss clause for an interrupt entry is elaborated, which 
evaluates the expression  of the address clause. A check is made that the address specified is associated 
with some interrupt to which a task entry may be attached. If this check fails, Program_Error is raised. 
Otherwise, the interrupt entry is attached to the interrupt associat ed with the specified address. 
Upon finalization of the task object, the interrupt entry, if any, is detached from the corresponding 
interrupt and the default treatment is restored. 
While an interrupt entry is attached to an interrupt, the interrupt is reserved (see C.3). 
An interrupt delivered to a task entry acts as a call to the entry issued by a hardware task whose priority is 
in the System.Interrupt_Priority ra nge. It is implementation defined wh ether the call is performed as an 
ordinary entry call, a timed entry call, or a cond itional entry call; which kind of call is performed can 
depend on the specific interrupt. 1 
2 
1 
2 
1 
2 
3 
4 5 
6 
7 
8 
9 
10 
Ada Reference Manual — 2012 Edition 
751      13 December 2012 Interrupt Entries   J.7.1 Bounded (Run-Time) Errors 
It is a bounded error to evaluate E'Caller (see C.7.1) in an accept_statement  for an interrupt entry. The 
possible effects are the same as for calling Current_Task from an entry body.  
Documentation Requirements 
The implementation shall document to which interrupts a task entry may be attached.  
The implementation shall document whether the invocati on of an interrupt entry has the effect of an 
ordinary entry call, conditional call, or a timed call,  and whether the effect varies in the presence of 
pending interrupts.  
Implementation Permissions 
The support for this s ubclause is optional. 
Interrupts to which the implementation allows a task en try to be attached may be designated as reserved 
for the entire duration of program execution; that is, not just when they have an interrupt entry attached to 
them. 
Interrupt entry calls may be implemented by havi ng the hardware execute directly the appropriate 
accept_statement . Alternatively, the implementation is allowed to provide an internal interrupt handler to 
simulate the effect of a normal task calling the entry. 
The implementation is allowed to im pose restrictions on the specifications  and bodies of tasks that have 
interrupt entries. 
It is implementation defined whethe r direct calls (from the program) to interrupt entries are allowed. 
If a select_statement  contains both a terminate_alternative  and an accept_alternative  for an interrupt 
entry, then an implementation is allowed to im pose further requirements for the selection of the 
terminate_alternative  in addition to those given in 9.3.  
NOTES 
1  Queued interrupts correspond to ordinary entry calls. Interrupts that are lost if not immediately processed correspond to conditional entry calls. It is a consequence of the priority rules that an 
accept_statement  executed in response to an 
interrupt can be executed with the active priority at which the hardware generates the interrupt, taking precedence over lower priority tasks, without a scheduling action. 
2  Control information that is supplied upon an interrupt can be passed to an associated interrupt entry as one or more 
parameters of mode in.  
Examples 
Example of an interrupt entry:   
task Interrupt_Handler is 
  entry Done; 
  for Done'Address use 
Ada.Interrupts.Reference(Ada.Interrupts.Names.Device_Done); end Interrupt_Handler; 11 
12 
13 
14 
15 
16/1 
17 
18 
19 
20/1 
21 
22 
23 
Ada Reference Manual — 2012 Edition 
J.8   Mod Clauses 13 December 2012      752 J.8 Mod Clauses 
Syntax 
mod_clause ::= at mod  static_ expression ; 
Static Semantics 
A record_representation_clause  of the form:  
for r use 
    record at mod a; 
        ...     end record; 
is equivalent to:  
for r'Alignment use a; 
for r use 
    record 
        ...     end record; 
J.9 The Storage_Size Attribute 
Static Semantics 
For any task subtype T, the following attribute is defined:  
T'Storage_Size  
 Denotes an implementation-defined value of type universal_integer  representing the 
number of storage elements reserved for a task of the subtype T.  
 Storage_Size may be specified for a task first subtype that is not an interface via an 
attribute_definition_clause . When the attribute is specified, the Storage_Size aspect is 
specified to be the value of the given expression .  
J.10 Specific Suppression of Checks 
Pragma Suppress can be used to suppress checks on specific entities.  
Syntax 
The form of a specific Suppress pragma  is as follows:  
  pragma  Suppress( identifier , [On =>] name );  
Legality Rules 
The identifier  shall be the name of a check (see 11.5). The name  shall statically denote some entity. 
For a specific Suppress pragma  that is immediately within a package_specification , the name  shall 
denote an entity (or several overloaded subpr ograms) declared immediately within the package_-
specification .  
Static Semantics 
A specific Suppress pragma  applies to the named check from the place of the pragma  to the end of the 
innermost enclosing declar ative region, or, if the pragma  is given in a package_specification , to the end 
of the scope of the named entity. The pragma  applies only to the named entity, or, for a subtype, on 1 
2 
3/3 
4 
5 
1 
2 
3/3 
1/2 
2/2 
3/2 
4/2 
5/2 
6/2 
Ada Reference Manual — 2012 Edition 
753      13 December 2012 Specific Suppression of Checks   J.10 objects and values of its type. A specific Suppress pragma  suppresses the named check for any entities to 
which it applies (see 11.5). Which checks are associated  with a specific entity is not defined by this 
International Standard. 
Implementation Permissions 
An implementation is allowed to pl ace restrictions on specific Suppress pragma s.  
NOTES 
3  An implementation may support a similar On parameter on pragma  Unsuppress (see 11.5).  
J.11 The Class Attribute of Untagged Incomplete Types 
Static Semantics 
For the first subtype S of a type T declared by an incomplete_type_declaration  that is not tagged, the 
following attribute is defined:  
S'Class  Denotes the first subtype of the incomplete class-wide type rooted at T. The completion of 
T shall declare a tagged type. Such an attribute reference shall occur in the same library unit 
as the incomplete_type_declaration .  
J.12 Pragma Interface 
Syntax 
In addition to an identifier, the reserved word interface  is allowed as a pragma name, to provide 
compatibility with a prior edition of  this International Standard.  
J.13 Dependence Restriction Identifiers 
The following restrictions involve dependence on sp ecific language-defined units. The more general 
restriction No_Dependence (see 13.12.1) should be used for this purpose.  
Static Semantics 
The following restriction_ identifier s exist: 
No_Asynchronous_Control  
 Semantic dependence on the predefined package Asynchronous_Task_Control is not 
allowed. 
No_Unchecked_Conversion  
 Semantic dependence on the predefined ge neric function Unchecked_Conversion is not 
allowed. 
No_Unchecked_Deallocation  
 Semantic dependence on the predefined gene ric procedure Unchecked_Deallocation is not 
allowed. 7/2 
8/2 
1/2 
2/2 
1/2 
1/2 
2/2 
3/2 
4/2 
5/2 
Ada Reference Manual — 2012 Edition 
J.14    Character and Wide_Character Conve rsion Functions 13 December 2012      754 J.14 Character and Wide_Cha racter Conversion Functions 
Static Semantics 
The following declarations exist in the decl aration of package Ada.Characters.Handling: 
   function  Is_Character (Item : in Wide_Character) return Boolean 
      renames Conversions.Is_Character; 
   function  Is_String    (Item : in Wide_String)    return Boolean 
      renames Conversions.Is_String; 
   function  To_Character (Item       : in Wide_Character; 
                         Substitute : in Character := ' ') 
                         return Character 
      renames Conversions.To_Character; 
   function  To_String    (Item       : in Wide_String; 
                          Substitute : in Character := ' ') 
                          return String 
      renames Conversions.To_String; 
   function  To_Wide_Character (Item : in Character) return Wide_Character 
      renames Conversions.To_Wide_Character; 
   function  To_Wide_String    (Item : in String)    return Wide_String 
      renames Conversions.To_Wide_String; 
J.15 Aspect-related Pragmas 
Pragmas can be used as an alternative to asp ect_specifications to specify certain aspects. 
J.15.1 Pragma Inline 
Syntax 
The form of a pragma  Inline, which is a program unit pr agma (see 10.1.5), is as follows:  
  pragma  Inline ( name {, name });  
Legality Rules 
The pragma  shall apply to one or more callable entities or generic subprograms.  
Static Semantics 
Pragma  Inline specifies that the Inline aspect (see 6.3.2) for each entity denoted by each name  given in 
the pragma  has the value True. 
Implementation Permissions 
An implementation may allow a pragma  Inline that has an argument which is a direct_name  denoting a 
subprogram_body  of the same declarative_part . 
NOTES 
4  The name in a pragma  Inline may denote more than one entity in the case of overloading. Such a pragma  applies to all 
of the denoted entities.  1/2 
2/2 
3/2 
4/2 
5/2 
6/2 
1/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
Ada Reference Manual — 2012 Edition 
755      13 December 2012 Pragma No_Return   J.15.2 J.15.2 Pragma No_Return 
Syntax 
The form of a pragma  No_Return, which is a representati on pragma (see 13.1), is as follows:  
  pragma  No_Return ( procedure_ local_name {, procedure_ local_name });  
Legality Rules 
Each procedure_ local_name  shall denote one or more procedures or generic procedures. The 
procedure_ local_name  shall not denote a null procedure nor an instance of a generic unit.  
Static Semantics 
Pragma  No_Return specifies that the No_Return aspect  (see 6.5.1) for each procedure denoted by each 
local_name  given in the pragma  has the value True.  
J.15.3 Pragma Pack 
Syntax 
The form of a pragma  Pack, which is a representation pragma (see 13.1), is as follows:  
  pragma  Pack ( first_subtype_ local_name );  
Legality Rules 
The first_subtype_ local_name  of a pragma  Pack shall denote a composite subtype.  
Static Semantics 
Pragma  Pack specifies that the Pack aspect (see 13.2) for the type denoted by first_subtype_ local_name  
has the value True.  
J.15.4 Pragma Storage_Size 
Syntax 
The form of a pragma  Storage_Size is as follows:  
  pragma  Storage_Size ( expression ); 
A pragma  Storage_Size is allowed only immediately within a task_definition .  
Name Resolution Rules 
The expression  of a pragma  Storage_Size is expected to be of any integer type.  
Static Semantics 
The pragma  Storage_Size sets the Storage_Size aspect (see 13.3) of the type defined by the immediately 
enclosing task_definition  to the value of the expression  of the pragma .  1/3 
2/3 
3/3 
4/3 
1/3 
2/3 
3/3 
4/3 
1/3 
2/3 
3/3 
4/3 
5/3 
Ada Reference Manual — 2012 Edition 
J.15.5    Interfacing Pragmas 13 December 2012      756 J.15.5 Interfacing Pragmas 
Syntax 
An interfacing pragma  is a representation prag ma that is one of the pragma s Import, Export, or 
Convention. Their forms are as follows:  
  pragma  Import( 
     [Convention =>] convention_ identifier , [Entity =>] local_name  
  [, [External_Name =>] external_name_string_ expression ] 
  [, [Link_Name =>] link_name_string_ expression ]); 
  pragma  Export( 
     [Convention =>] convention_ identifier , [Entity =>] local_name  
  [, [External_Name =>] external_name_string_ expression ] 
  [, [Link_Name =>] link_name_string_ expression ]); 
  pragma  Convention([Convention =>] convention_ identifier ,[Entity =>] local_name ); 
For pragma s Import and Export, the argument for Li nk_Name shall not be given without the 
pragma_argument_ identifier  unless the argument for Ex ternal_Name is given.  
Name Resolution Rules 
 The expected type for an external_name_string_ expression  and a link_name_string_ expression  in an 
interfacing pragma is String.  
Legality Rules 
The convention_ identifier  of an interfacing pragma shall be the name of a convention (see B.1). 
A pragma  Import shall be the completion of a declaration. Notwithstanding any rule to the contrary, a 
pragma  Import may serve as the completion of any kind of (explicit) declaration if supported by an 
implementation for that kind of d eclaration. If a completion is a pragma  Import, then it shall appear in the 
same declarative_part , package_specification , task_definition , or protected_definition  as the declaration. 
For a library unit, it shall appear in the same compilation , before any subsequent compilation_unit s other 
than pragma s. If the local_name  denotes more than one entity, then the pragma  Import is the completion 
of all of them. 
The external_name_string_ expression  and link_name_string_ expression  of a pragma  Import or Export 
shall be static. 
The local_name  of each of these pragmas shall denote a declaration that may have the similarly named 
aspect specified.  
Static Semantics 
An interfacing pragma specifies various aspects of the entity denoted by the local_name  as follows:  
• The Convention aspect (see B.1) is convention_ identifier . 
• A pragma  Import specifies that the Import aspect (see B.1) is True. 
• A pragma  Export specifies that the Expor t aspect (see B.1) is True. 
• For both pragma  Import and Export, if an external name is given in the pragma, the 
External_Name aspect (see B.1) is specified to be external_name_string_ expression . If a link 
name is given in the pragma, the Link_Name aspect (see B.1) is specified to be the 
link_name_string_ expression .  1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 
13/3 14/3 15/3 
Ada Reference Manual — 2012 Edition 
757      13 December 2012 Pragma Unchecked_Union   J.15.6 J.15.6 Pragma Unchecked_Union 
Syntax 
The form of a pragma  Unchecked_Union, which is a representa tion pragma (see 13.1), is as follows:  
  pragma  Unchecked_Union ( first_subtype_ local_name );  
Legality Rules 
The first_subtype_ local_name  of a pragma  Unchecked_Union shall denote an unconstrained 
discriminated record subtype having a variant_part .  
Static Semantics 
A pragma  Unchecked_Union specifies that the Unchecked_U nion aspect (see B.3.3) for the type denoted 
by first_subtype_ local_name  has the value True.  
J.15.7 Pragmas Interrupt_Handler and Attach_Handler 
Syntax 
The form of a pragma  Interrupt_Handler is as follows:  
  pragma  Interrupt_Handler ( handler_ name ); 
The form of a pragma  Attach_Handler is as follows:  
  pragma  Attach_Handler ( handler_ name , expression );  
Name Resolution Rules 
For the Interrupt_Handler and Attach_Handler pragmas, the handler_ name  shall resolve to denote a 
protected procedure with a parameterless profile. 
For the Attach_Handler pragma, the expected type for the expression is Interrupts.Interrupt_Id (see C.3.2).  
Legality Rules 
The Attach_Handler and Interrupt_Handler prag mas are only allowed immediately within the 
protected_definition  where the corresponding subprogram  is declared. The corresponding 
protected_type_declaration  or single_protected_declaration  shall be a library-level declaration, and shall 
not be declared within a generic body. In addition to the places where Legality Rules normally apply (see 
12.3), these rules also apply in the private part of an instance of a generic unit.  
Static Semantics 
For an implementation that supports Annex C, a pragma Interrupt_Handler  specifies the Interrupt_Handler 
aspect (see C.3.1) for the protected procedure handler_ name  to have the value True. For an 
implementation that supports Annex C,  a pragma Attach_Handler specifies  the Attach_Handler aspect (see 
C.3.1) for the protected procedure handler_ name  to have the value of the given expression  as evaluated 
at object creation time.  1/3 
2/3 
3/3 
4/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
Ada Reference Manual — 2012 Edition 
J.15.8    Shared Variable Pragmas 13 December 2012      758 J.15.8 Shared Variable Pragmas 
Syntax 
The form for pragma s Atomic, Volatile, Independe nt, Atomic_Components, and 
Volatile_Components, and Independe nt_Components is as follows:  
  pragma  Atomic ( local_name ); 
  pragma  Volatile ( local_name ); 
  pragma  Independent ( component_ local_name ); 
  pragma  Atomic_Components ( array_ local_name ); 
  pragma  Volatile_Components ( array_ local_name ); 
  pragma  Independent_Components ( local_name ); 
Name Resolution Rules 
The local_name  in an Atomic or Volatile pragma shall resolve to denote either an object_declaration , a 
noninherited component_declaration , or a full_type_declaration . The component_ local_name  in an 
Independent pragma shall resolve to denote a noninherited component_declaration . The 
array_ local_name  in an Atomic_Components or Volatile_Compone nts pragma shall resolve to denote the 
declaration of an array type or an array object of an anonymous type. The local_name  in an 
Independent_Components pragma shall re solve to denote the declaration of an array or record type or an 
array object of an anonymous type.  
Static Semantics 
These pragma s are representation pragmas (see 13.1). Each of these pragma s specifies that the similarly 
named aspect (see C.6) of the type, object, or component denoted by its  argument is True.  
Legality Rules 
The local_name  of each of these pragma s shall denote a declaration that  may have the similarly named 
aspect specified.  
J.15.9 Pragma CPU 
Syntax 
The form of a pragma  CPU is as follows:  
  pragma  CPU ( expression ); 
Name Resolution Rules 
The expected type for the expression  of a pragma  CPU is System.Multiprocessors.CPU_Range.  
Legality Rules 
A CPU pragma is allowed only immediately within a task_definition , or the declarative_part  of a 
subprogram_body . 
For a CPU pragma that appears in the declarative_part  of a subprogram_body , the expression  shall be 
static.  1/3 
2/3 
3/3 4/3 5/3 6/3 7/3 
8/3 
9/3 
10/3 
1/3 
2/3 
3/3 
4/3 
5/3 
Ada Reference Manual — 2012 Edition 
759      13 December 2012 Pragma CPU   J.15.9 Static Semantics 
For an implementation th at supports Annex D, a pragma  CPU specifies the value of the CPU aspect (see 
D.16). If the pragma  appears in a task_definition , the expression  is associated with the aspect for the task 
type or single_task_declaration  that contains the pragma ; otherwise, the expression  is associated with 
the aspect for the subprogr am that contains the pragma .  
J.15.10 Pragma Dispatching_Domain 
Syntax 
The form of a pragma  Dispatching_Domain is as follows:  
  pragma  Dispatching_Domain ( expression ); 
Name Resolution Rules 
The expected type for the expression  is 
System.Multiprocessors.Dispatchi ng_Domains.Dispatching_Domain.  
Legality Rules 
A Dispatching_Domain pragma is a llowed only immediately within a task_definition .  
Static Semantics 
For an implementation that supports  Annex D, a pragma Dispatching_D omain specifies the value of the 
Dispatching_Domain aspect (see D.16.1). The expression  is associated with the aspect for the task type or 
single_task_declaration  that contains the pragma.  
J.15.11 Pragmas Priority and Interrupt_Priority 
Syntax 
The form of a pragma  Priority is as follows:  
  pragma  Priority ( expression ); 
The form of a pragma  Interrupt_Priority is as follows:  
  pragma  Interrupt_Priority [( expression );] 
Name Resolution Rules 
The expected type for the expression  in a Priority or Interrupt_P riority pragma is Integer.  
Legality Rules 
A Priority pragma is allowed only immediately within a task_definition , a protected_definition , or the 
declarative_part  of a subprogram_body . An Interrupt_Priority pragma is allowed only immediately 
within a task_definition  or a protected_definition . 
For a Priority pragma that appears in the declarative_part  of a subprogram_body , the expression  shall be 
static, and its value shall be in the range of System.Priority.  
Static Semantics 
For an implementation th at supports Annex D, a pragma  Priority specifies the valu e of the Priority aspect 
(see D.1) and a pragma  Interrupt_Priority specifies the value of the Interrupt_Priority aspect as follows: 6/3 
1/3 
2/3 
3/3 
4/3 
5/3 
1/3 
2/3 
3/3 
4/3 
5/3 
6/3 
7/3 
8/3 
Ada Reference Manual — 2012 Edition 
J.15.11    Pragmas Priority and Interrupt_Priority 13 December 2012      760 • If the pragma  appears in a task_definition , the expression  is associated with the aspect for the 
task type or single_task_declaration  that contains the pragma ; 
• If the pragma  appears in a protected_definition , the expression  is associated with the aspect for 
the protected type or single_protected_declaration  that contains the pragma ; 
• If the pragma  appears in the declarative_part  of a subprogram_body , the expression  is 
associated with the aspect for the subprogram that contains the pragma . 
If there is no expression  in an Interrupt_Priority pragma, the Interrupt_Priority aspect has the value 
Interrupt_Priority'Last.  
J.15.12 Pragma Relative_Deadline 
Syntax 
The form of a pragma  Relative_Deadline is as follows:  
  pragma  Relative_Deadline ( relative_deadline_ expression ); 
Name Resolution Rules 
The expected type for a relative_deadline_ expression  is Real_Time.Time_Span.  
Legality Rules 
A Relative_Deadline pragma is a llowed only immediately within a task_definition  or the declarative_part  
of a subprogram_body .  
Static Semantics 
For an implementation th at supports Annex D, a pragma  Relative_Deadline specifies the value of the 
Relative_Deadline aspect (see D.2.6). If the pragma  appears in a task_definition , the expression  is 
associated with the aspect for the task type or single_task_declaration  that contains the pragma ; 
otherwise, the expression  is associated with the aspect fo r the subprogram that contains the pragma .  
J.15.13 Pragma Asynchronous 
Syntax 
The form of a pragma  Asynchronous, which is a representati on pragma (see 13.1), is as follows:  
  pragma  Asynchronous ( local_name );  
Static Semantics 
For an implementation that supports  Annex E, a pragma Asynchronous specifies that the Asynchronous 
aspect (see E.4.1) for the procedure or type denoted by local_name  has the value True.  
Legality Rules 
The local_name  of a pragma Asynchronous shall denote a decl aration that may have aspect Asynchronous 
specified.  9/3 
10/3 11/3 12/3 
1/3 
2/3 
3/3 
4/3 
5/3 
1/3 
2/3 
3/3 
4/3 
Ada Reference Manual — 2012 Edition 
761      13 December 2012 Language-Def ined Aspects and Attributes   Annex K Annex K 
(informative)  
Language-Defined Aspects and Attributes 
This annex summarizes the definiti ons given elsewhere of the language-defined aspects and attributes. 
Some aspects have corresponding attributes, as noted.  
K.1 Language-Defined Aspects 
This subclause summarizes the definitions given else where of the language-defined aspects. Aspects are 
properties of entities that can be specified by the Ad a program; unless otherwise specified below, aspects 
can be specified using an aspect_specification . 
Address Machine address of an entity. See 13.3. 
Alignment (object) 
 Alignment of an object. See 13.3. 
Alignment (subtype) 
 Alignment of a subtype. See 13.3. 
All_Calls_Remote 
 All remote procedure calls should use the Pa rtition Communication Subsystem, even if they 
are local. See E.2.3. 
Asynchronous Remote procedure calls are asynchronous ; the caller continues without waiting for the call 
to return. See E.4.1. 
Atomic Declare that a type, object, or component is atomic. See C.6. 
Atomic_Components 
 Declare that the components of an arra y type or object are atomic. See C.6. 
Attach_Handler 
 Protected procedure is attached to an interrupt. See C.3.1. 
Bit_Order Order of bit numbering in a record_representation_clause . See 13.5.3. 
Coding Internal representation of enumeration literals. Specified by an 
enumeration_representation_clause , not by an aspect_specification . See 13.4. 
Component_Size 
 Size in bits of a component of an array type. See 13.3. 
Constant_Indexing 
 Defines function(s) to implement user-defined indexed_component s. See 4.1.6. 
Convention Calling convention or other convention us ed for interfacing to other languages. See B.1. 
CPU Processor on which a given task should run. See D.16. 
Default_Component_Value 
 Default value for the components of an  array-of-scalar subtype. See 3.6. 
Default_Iterator 
 Default iterator to be used in for loops. See 5.5.1. 
Default_Storage_Pool 
 Default storage pool for a generic instance. See 13.11.3. 1/3 
1/3 
2/3 
3/3 
4/3 5/3 
6/3 
7/3 
8/3 
9/3 
10/3 
11/3 
12/3 13/3 14/3 
15/3 16/3 
17/3 18/3 
Ada Reference Manual — 2012 Edition 
K.1   Language-Defined Aspects 13 December 2012      762 Default_Value 
 Default value for a scalar subtype. See 3.5. 
Dispatching_Domain 
 Domain (group of processors) on which a given task should run. See D.16.1. 
Dynamic_Predicate 
 Condition that must hold true for objects of a given subtype; the subtype is not static. See 
3.2.4. 
Elaborate_Body 
 A given package must have a body, and that  body is elaborated immediately after the 
declaration. See 10.2.1. 
Export Entity is exported to another language. See B.1. External_Name 
 Name used to identify an impor ted or exported entity. See B.1. 
External_Tag Unique identifier for a tagged type in streams. See 13.3. 
Implicit_Dereference 
 Mechanism for user-defined implicit . all. See 4.1.5. 
Import Entity is imported from another language. See B.1. Independent Declare that a type, object, or com ponent is independently addressable. See C.6. 
Independent_Components 
 Declare that the components of an array or record type, or an array object, are 
independently addressable. See C.6. 
Inline For efficiency, Inline calls are requested for a subprogram. See 6.3.2. 
Input Function to read a value from a stream for a given type, including any bounds and 
discriminants. See 13.13.2. 
Interrupt_Handler 
 Protected procedure may be attached to interrupts. See C.3.1. 
Interrupt_Priority 
 Priority of a task object or type, or priority of a protected object or type; the priority is in 
the interrupt range. See D.1. 
Iterator_Element 
 Element type to be used for us er-defined iterators. See 5.5.1. 
Layout (record) 
 Layout of record components. Specified by a 
record_representation_clause , not by an 
aspect_specification . See 13.5.1. 
Link_Name Linker symbol used to identify an imported or exported entity. See B.1. 
Machine_Radix 
 Radix (2 or 10) that is used to repr esent a decimal fixed point type. See F.1. 
No_Return A procedure will not return normally. See 6.5.1. Output Procedure to write a value to a stream for a given type, including any bounds and 
discriminants. See 13.13.2. 
Pack Minimize storage when laying out records and arrays. See 13.2. Post Postcondition; a condition that must  hold true after a call. See 6.1.1. 19/3 
20/3 21/3 
22/3 
23/3 
24/3 
25/3 
26/3 
27/3 
28/3 29/3 
30/3 
31/3 
32/3 33/3 
34/3 
35/3 
36/3 
37/3 
38/3 
39/3 
40/3 
41/3 
Ada Reference Manual — 2012 Edition 
763      13 December 2012 Language-Defined Aspects   K.1 Post'Class Postcondition inherited on type derivation. See 6.1.1. 
Pre Precondition; a condition that must hold true before a call. See 6.1.1. 
Pre'Class Precondition inherited on type derivation. See 6.1.1. 
Preelaborate Code execution during elaboration is  avoided for a given package. See 10.2.1. 
Priority Priority of a task object or type, or prior ity of a protected object or type; the priority is not 
in the interrupt range. See D.1. 
Pure Side effects are avoided in the s ubprograms of a given package. See 10.2.1. 
Read Procedure to read a value from a stream for a given type. See 13.13.2. Record layout See Layout. See 13.5.1. Relative_Deadline 
 Task parameter used in Earliest Deadline First Dispatching. See D.2.6. 
Remote_Call_Interface 
 Subprograms in a given package may be used  in remote procedure calls. See E.2.3. 
Remote_Types Types in a given package may be used in remote procedure calls. See E.2.2. 
Shared_Passive 
 A given package is used to represent shared memory in a distributed system. See E.2.1. 
Size (object) Size in bits of an object. See 13.3. Size (subtype) 
 Size in bits of a subtype. See 13.3. 
Small Scale factor for a fixed point type. See 3.5.10. Static_Predicate 
 Condition that must hold true for objects of a given subtype; the subtype may be static. See 
3.2.4. 
Storage_Pool Pool of memory from which new will allocate for a given access type. See 13.11. 
Storage_Size (access) 
 Sets memory size for allocations for an access type. See 13.11. 
Storage_Size (task) 
 Size in storage elements reserved for a task type or single task object. See 13.3. 
Stream_Size Size in bits used to represent elementary objects in a stream. See 13.13.2. Synchronization 
 Defines whether a given primitive operati on of a synchronized interface must be 
implemented by an entry or pr otected procedure. See 9.5. 
Type_Invariant 
 A condition that must hold true for all objects of a type. See 7.3.2. 
Type_Invariant'Class 
 A condition that must hold true for all objects in a class of types. See 7.3.2. 
Unchecked_Union 
 Type is used to interface to a C union type. See B.3.3. 
Variable_Indexing 
 Defines function(s) to implement user-defined 
indexed_component s. See 4.1.6. 
Volatile Declare that a type, object, or component is volatile. See C.6. 42/3 
43/3 44/3 45/3 46/3 
47/3 
48/3 49/3 50/3 
51/3 52/3 
53/3 
54/3 
55/3 
56/3 
57/3 
58/3 
59/3 
60/3 61/3 
62/3 
63/3 
64/3 65/3 66/3 67/3 
Ada Reference Manual — 2012 Edition 
K.1   Language-Defined Aspects 13 December 2012      764 Volatile_Components 
 Declare that the components of an array type or object are volatile. See C.6. 
Write Procedure to write a value to a stream for a given type. See 13.13.2. 
K.2 Language-Defined Attributes 
This subclause summarizes the defin itions given elsewhere of the language -defined attributes. Attributes 
are properties of entities that can be queried by an Ada program. 
P'Access For a prefix  P that denotes a subprogram: 
 P'Access yields an access value that designate s the subprogram denoted by P. The type of 
P'Access is an access-to-subprogram type ( S), as determined by the expected type. See 
3.10.2. 
X'Access For a prefix  X that denotes an aliased view of an object: 
 X'Access yields an access value that designates the object denoted by X. The type of 
X'Access is an access-to-object type, as determ ined by the expected type. The expected 
type shall be a general access type. See 3.10.2. 
X'Address For a prefix  X that denotes an object, program unit, or label: 
 Denotes the address of the first of the storage elements allocated to X. For a program unit or 
label, this value refers to  the machine code associated with the corresponding body or 
statement . The value of this attribute is of type System.Address. See 13.3. 
S'Adjacent For every subtype S of a floating point type T: 
 S'Adjacent denotes a function with the following specification:  
function  S'Adjacent ( X, Towards : T) 
  return T 
 If Towards  = X, the function yields X; otherwise, it yields the machine number of the type T 
adjacent to X in the direction of Towards , if that machine number exists. If the result would 
be outside the base range of S, Constraint_Error is raised. When T'Signed_Zeros is True, a 
zero result has the sign of X. When Towards  is zero, its sign has no bearing on the result. 
See A.5.3. 
S'Aft For every fixed point subtype S:  S'Aft yields the number of decimal digits needed after the decimal point to accommodate 
the delta  of the subtype S, unless the delta  of the subtype S is greater than 0.1, in which 
case the attribute yields the va lue one. (S'Aft is the smallest positive integer N for which 
(10**N)*S'Delta is greater than or equal to one.)  The value of this attribute is of the type 
universal_integer . See 3.5.10. 
S'Alignment For every subtype S:  The value of this attribute is of type universal_integer , and nonnegative. 
 For an object X of subtype S, if S'Alignmen t is not zero, then X'Alignment is a nonzero 
integral multiple of S'Alignment unless specifi ed otherwise by a representation item. See 
13.3. 
X'Alignment For a 
prefix  X that denotes an object: 
 The value of this attribute is of type universal_integer , and nonnegative; zero means that 
the object is not necessarily aligned on a st orage element boundary. If X'Alignment is not 68/3 
69/3 
1/3 
2 
3 
4 
5 
6/1 
7 
8 
9 
10 
11 
12 
13 
13.1/2 
13.2/2 13.3/2 
14/1 
15 
Ada Reference Manual — 2012 Edition 
765      13 December 2012 Language-Defined Attributes   K.2 zero, then X is aligned on a storage unit boundary  and X'Address is an integral multiple of 
X'Alignment (that is, the Addre ss modulo the Alignment is zero). 
 See 13.3. S'Base For every scalar subtype S:  S'Base denotes an unconstrained subtype of th e type of S. This unconstrained subtype is 
called the base subtype  of the type. See 3.5. 
S'Bit_Order For every specific record subtype S:  Denotes the bit ordering for the type of S.  The value of this attribute is of type 
System.Bit_Order. See 13.5.3. 
P'Body_Version 
 For a 
prefix  P that statically denotes a program unit: 
 Yields a value of the predefined type Stri ng that identifies the version of the compilation 
unit that contains the body (but not any subunits) of the progr am unit. See E.3. 
T'Callable For a prefix  T that is of a task type (after any implicit dereference): 
 Yields the value True when the task denoted by T is callable , and False otherwise; See 9.9. 
E'Caller For a prefix  E that denotes an entry_declaration : 
 Yields a value of the type Task_Id that iden tifies the task whose call is now being serviced. 
Use of this attribute is allowed only inside an accept_statement , or entry_body  after the 
entry_barrier , corresponding to the entry_declaration  denoted by E. See C.7.1. 
S'Ceiling For every subtype S of a floating point type T: 
 S'Ceiling denotes a function with the following specification:  
function  S'Ceiling ( X : T) 
  return T 
 The function yields the value X, i.e., the smallest (most negative) integral value greater 
than or equal to X. When X is zero, the result has the sign of X; a zero result otherwise has a 
negative sign when S'Signed_Zeros is True. See A.5.3. 
S'Class For every subtype S of a tagged type T (specific or class-wide): 
 S'Class denotes a subtype of the class-wide type (called T'Class in this International 
Standard) for the class rooted at T (or if S already denotes a class-wide subtype, then 
S'Class is the same as S). 
 S'Class is unconstrained. Howeve r, if S is constrained, then the values of S'Class are only 
those that when converted to the type T belong to S. See 3.9. 
S'Class For every subtype S of an untagged private type whose full view is tagged: 
 Denotes the class-wide subtype corresponding to  the full view of S. This attribute is 
allowed only from the beginning of the private pa rt in which the full view is declared, until 
the declaration of the full view. After the full view, the Class attribute of the full view can 
be used. See 7.3.1. 
X'Component_Size 
 For a prefix  X that denotes an array subtype or array object (after any implicit dereference): 
 Denotes the size in bits of components of the type  of X. The value of this attribute is of type 
universal_integer . See 13.3. 
S'Compose For every subtype S of a floating point type T: 16/2 
17 18 
19 
20 
21/1 
22 23 
24 25 
26/3 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36/1 
37 38 
Ada Reference Manual — 2012 Edition 
K.2   Language-Defined Attributes 13 December 2012      766  S'Compose denotes a function w ith the following specification:  
function  S'Compose ( Fraction : T; 
                    Exponent : universal_integer ) 
  return T 
 Let v be the value Fraction  · T'Machine_RadixExponent –k, where k is the normalized exponent 
of Fraction . If v is a machine number of the type T, or if | v| ≥ T'Model_Small, the function 
yields v; otherwise, it yields either one of  the machine numbers of the type T adjacent to v. 
Constraint_Error is optionally raised if v is outside the base range of S. A zero result has the 
sign of Fraction  when S'Signed_Zeros is True. See A.5.3. 
A'Constrained 
 For a prefix  A that is of a discriminated type (after any implicit dereference): 
 Yields the value True if A denotes a consta nt, a value, a tagged object, or a constrained 
variable, and False otherwise. See 3.7.2. 
S'Copy_Sign For every subtype S of a floating point type T: 
 S'Copy_Sign denotes a function with the following specification:  
function  S'Copy_Sign ( Value, Sign : T) 
  return T 
 If the value of Value  is nonzero, the function yields a result whose magnitude is that of 
Value  and whose sign is that of Sign; otherwise, it yields the va lue zero. Constraint_Error is 
optionally raised if the result is outside the base range of S. A zero result has the sign of 
Sign when S'Signed_Zeros is True. See A.5.3. 
E'Count For a prefix  E that denotes an entry of a task or protected unit: 
 Yields the number of calls presently queued on the entry E of the current instance of the 
unit. The value of this a ttribute is of the type universal_integer . See 9.9. 
S'Definite For a prefix  S that denotes a formal indefinite subtype: 
 S'Definite yields True if the actual subtyp e corresponding to S is definite; otherwise, it 
yields False. The value of this attribute is  of the predefined type Boolean. See 12.5.1. 
S'Delta For every fixed point subtype S:  S'Delta denotes the delta  of the fixed point subtype S. The value of this attribute is of the 
type universal_real . See 3.5.10. 
S'Denorm For every subtype S of a floating point type T: 
 Yields the value True if every value expressible in the form 
     ± mantissa  · T'Machine_Radix
T'Machine_Emin 
 where mantissa  is a nonzero T'Machine_Mantissa-digit fraction in the number base 
T'Machine_Radix, the first digit of which is zero, is a machine numbe r (see 3.5.7) of the 
type T; yields the value False otherwise. The value of  this attribute is of the predefined type 
Boolean. See A.5.3. 
S'Digits For every floating point subtype S:  S'Digits denotes the requested decimal preci sion for the subtype S. The value of this 
attribute is of the type universal_integer . See 3.5.8. 
S'Digits For every decimal fixed point subtype S:  S'Digits denotes the digits  of the decimal fixed point subtype S, which corresponds to the 
number of decimal digits that are representable in objects of the subtype. The value of this 
attribute is of the type universal_integer . See 3.5.10. 39 
40 
41 
42 
43/3 
44 
45 
46 
47 
48 
49 
50/1 
51/3 
52 
53 
54 
55 
56 
57 
58 
59 
Ada Reference Manual — 2012 Edition 
767      13 December 2012 Language-Defined Attributes   K.2 S'Exponent For every subtype S of a floating point type T: 
 S'Exponent denotes a function with the following specification:  
function  S'Exponent ( X : T) 
  return universal_integer  
 The function yields the normalized exponent of X. See A.5.3. 
S'External_Tag 
 For every subtype S of a tagged type T (specific or class-wide): 
 S'External_Tag denotes an external string repr esentation for S'Tag; it is of the predefined 
type String. External_Tag may be specified for a specific tagged type via an 
attribute_definition_clause ; the expression of such a clause shall be static. The default 
external tag representation is implemen tation defined. See 13.13.2. See 13.3. 
A'First For a prefix  A that is of an array type (after any implicit dereference), or denotes a 
constrained array subtype: 
 A'First denotes the lower bound of the first i ndex range; its type is the corresponding index 
type. See 3.6.2. 
S'First For every scalar subtype S:  S'First denotes the lower bound of the range of S.  The value of this attribute is of the type 
of S. See 3.5. 
A'First(N) For a 
prefix  A that is of an array type (after any implicit dereference), or denotes a 
constrained array subtype: 
 A'First(N) denotes the lower bound of the N- th index range; its type is the corresponding 
index type. See 3.6.2. 
R.C'First_Bit 
 For a component C of a composite, non-array object R: 
 If the nondefault bit ordering applies to the composite type, and if a component_clause  
specifies the placement of C, denotes the value given for the first_bit  of the 
component_clause ; otherwise, denotes the offset, from the start of the first of the storage 
elements occupied by C, of the first bit occupied  by C. This offset is  measured in bits. The 
first bit of a storage element is numbered zero. The value of this attribute is of the type 
universal_integer . See 13.5.2. 
S'First_Valid 
 For every static discrete subtype S for which there exists at least one value belonging to S 
that satisfies any predicate of S: 
 S'First_Valid denotes the smallest value that belongs to S and satisfies the predicate of S. 
The value of this attribute is of the type of S. See 3.5.5. 
S'Floor For every subtype S of a floating point type T: 
 S'Floor denotes a function with the following specification:  
function  S'Floor ( X : T) 
  return T 
 The function yields the value X, i.e., the largest (most positive)  integral value less than or 
equal to X. When X is zero, the result has the sign of X; a zero result otherwise has a 
positive sign. See A.5.3. 
S'Fore For every fixed point subtype S: 60 
61 
62 
63 
64 
65 
66/1 
67 68 
69 
70/1 
71 72 
73/2 
73.1/3 
73.2/3 
74 
75 
76 
77 
78 
Ada Reference Manual — 2012 Edition 
K.2   Language-Defined Attributes 13 December 2012      768  S'Fore yields the minimum number of characters needed before the decimal point for the 
decimal representation of any value of the s ubtype S, assuming that the representation does 
not include an exponent, but includes a one-charact er prefix that is either a minus sign or a 
space. (This minimum number does not include superfluous zeros or underlines, and is at 
least 2.) The value of this attribute is of the type universal_integer . See 3.5.10. 
S'Fraction For every subtype S of a floating point type T: 
 S'Fraction denotes a function with the following specification:  
function  S'Fraction ( X : T) 
  return T 
 The function yields the value X · T'Machine_Radix–k, where k is the normalized exponent of 
X. A zero result, which can only occur when X is zero, has the sign of X. See A.5.3. 
X'Has_Same_Storage 
 For a prefix  X that denotes an object: 
 X'Has_Same_Storage denotes a func tion with the following specification: 
function  X'Has_Same_Storage ( Arg : any_type) 
  return Boolean 
 The actual parameter shall be a name that denotes an object. The object denoted by the 
actual parameter can be of any type. This function evaluates the names of the objects 
involved and returns True if the representation of the object denoted by the actual parameter occupies exactly the same bits as the representation of the object denoted by X; otherwise, it returns False. See 13.3. 
E'Identity For a 
prefix  E that denotes an exception: 
 E'Identity returns the unique identity of the exception. The type of this attribute is 
Exception_Id. See 11.4.1. 
T'Identity For a prefix  T that is of a task type (after any implicit dereference): 
 Yields a value of the type Task_Id that id entifies the task denoted by T. See C.7.1. 
S'Image For every scalar subtype S:  S'Image denotes a function with the following specification:  
function  S'Image( Arg : S'Base) 
  return String 
 The function returns an image of the value of Arg as a String. See 3.5. 
S'Class'Input 
 For every subtype S'Class of a class-wide type T'Class: 
 S'Class'Input denotes a function with the following specification:  
function  S'Class'Input( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class) 
   return T'Class 
 First reads the external tag from Stream  and determines the corresponding internal tag (by 
calling Tags.Descendant_Tag(String'Input( Stream ), S'Tag) which might raise Tag_Error — 
see 3.9) and then dispatches to  the subprogram denoted by the Input attribute of the specific 
type identified by the internal tag; returns th at result. If the specific type identified by the 
internal tag is abstract, Constr aint_Error is raised. See 13.13.2. 
S'Input For every subtype S of a specific type T: 
 S'Input denotes a function with the following specification:  79 
80 
81 
82 
83 
83.1/3 83.2/3 
83.3/3 
83.4/3 
84/1 
85 
86 
87 88 89 
90 
91/3 
92 
93 
94/2 
95/3 
96 
97 
Ada Reference Manual — 2012 Edition 
769      13 December 2012 Language-Defined Attributes   K.2 function  S'Input( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class) 
   return T 
 S'Input reads and returns one value from Stream , using any bounds or discriminants written 
by a corresponding S'Output to determ ine how much to read. See 13.13.2. 
A'Last For a prefix  A that is of an array type (after any implicit dereference), or denotes a 
constrained array subtype: 
 A'Last denotes the upper bound of the first i ndex range; its type is the corresponding index 
type. See 3.6.2. 
S'Last For every scalar subtype S:  S'Last denotes the upper bound of the range of S. Th e value of this attribute is of the type of 
S. See 3.5. 
A'Last(N) For a 
prefix  A that is of an array type (after any implicit dereference), or denotes a 
constrained array subtype: 
 A'Last(N) denotes the upper bound of the N-th  index range; its type is the corresponding 
index type. See 3.6.2. 
R.C'Last_Bit 
 For a component C of a composite, non-array object R: 
 If the nondefault bit ordering applies to the composite type, and if a component_clause  
specifies the placement of C, denotes the value given for the last_bit  of the 
component_clause ; otherwise, denotes the offset, from the start of the first of the storage 
elements occupied by C, of the last bit occupied  by C. This offset is  measured in bits. The 
value of this attribute is of the type universal_integer . See 13.5.2. 
S'Last_Valid 
 For every static discrete subtype S for which there exists at least one value belonging to S 
that satisfies any predicate of S: 
 S'Last_Valid denotes the largest value that bel ongs to S and satisfies the predicate of S. The 
value of this attribute is of  the type of S. See 3.5.5. 
S'Leading_Part 
 For every subtype S of a floating point type T: 
 S'Leading_Part denotes a function with the following specification:  
function  S'Leading_Part ( X : T; 
                         Radix_Digits  : universal_integer ) 
  return T 
 Let v be the value T'Machine_Radixk–Radix_Digits, where k is the normalized exponent of X. The 
function yields the value  
• X/v · v, when X is nonnegative and Radix_Digits  is positive; 
• X/v · v, when X is negative and Radix_Digits  is positive.  
 Constraint_Error is raised when Radix_Digits  is zero or negative. A zero result, which can 
only occur when X is zero, has the sign of X. See A.5.3. 
A'Length For a prefix  A that is of an array type (after any implicit dereference), or denotes a 
constrained array subtype: 
 A'Length denotes the number of values of the first index range (zero for a null range); its 
type is universal_integer . See 3.6.2. 98/2 
99 
100/1 
101 102 
103 
104/1 
105 106 
107/2 
107.1/3 
107.2/3 
108 109 
110 
111 
112 
113 114 
115/1 
116 
Ada Reference Manual — 2012 Edition 
K.2   Language-Defined Attributes 13 December 2012      770 A'Length(N) For a prefix  A that is of an array type (after any implicit dereference), or denotes a 
constrained array subtype: 
 A'Length(N) denotes the number of values of the N-th index range (zero for a null range); 
its type is universal_integer . See 3.6.2. 
S'Machine For every subtype S of a floating point type T: 
 S'Machine denotes a function with the following specification:  
function  S'Machine ( X : T) 
  return T 
 If X is a machine number of the type T, the function yields X; otherwise, it yields the value 
obtained by rounding or truncating X to either one of the adjacent machine numbers of the 
type T. Constraint_Error is raised if rounding or truncating X to the precision of the 
machine numbers results in a va lue outside the base range of S. A zero result has the sign of 
X when S'Signed_Zeros is True. See A.5.3. 
S'Machine_Emax 
 For every subtype S of a floating point type T: 
 Yields the largest (most positive) value of exponent  such that every value expressible in the 
canonical form (for the type T), having a mantissa  of T'Machine_Mantissa digits, is a 
machine number (see 3.5.7) of the type T. This attribute yields a value of the type 
universal_integer . See A.5.3. 
S'Machine_Emin 
 For every subtype S of a floating point type T: 
 Yields the smallest (m ost negative) value of exponent  such that every value expressible in 
the canonical form (for the type T), having a mantissa  of T'Machine_Mantissa digits, is a 
machine number (see 3.5.7) of the type T. This attribute yields a value of the type 
universal_integer . See A.5.3. 
S'Machine_Mantissa 
 For every subtype S of a floating point type T: 
 Yields the largest value of p such that every value expressible in the canonical form (for the 
type T), having a p-digit mantissa  and an exponent  between T'Machine_Emin and 
T'Machine_Emax, is a machine number (see 3.5.7) of the type T. This attribute yields a 
value of the type universal_integer . See A.5.3. 
S'Machine_Overflows 
 For every subtype S of a floating point type T: 
 Yields the value True if overflow and divide -by-zero are detected and reported by raising 
Constraint_Error for every predefined opera tion that yields a result of the type T; yields the 
value False otherwise. The valu e of this attribute is of the predefined type Boolean. See 
A.5.3. 
S'Machine_Overflows 
 For every subtype S of a fixed point type T: 
 Yields the value True if overflow and divide -by-zero are detected and reported by raising 
Constraint_Error for every predefined opera tion that yields a result of the type T; yields the 
value False otherwise. The valu e of this attribute is of the predefined type Boolean. See 
A.5.4. 
S'Machine_Radix 
 For every subtype S of a floating point type T: 117/1 
118 119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
Ada Reference Manual — 2012 Edition 
771      13 December 2012 Language-Defined Attributes   K.2  Yields the radix of the hardware representation of the type T. The value of this attribute is 
of the type universal_integer . See A.5.3. 
S'Machine_Radix 
 For every subtype S of a fixed point type T: 
 Yields the radix of the hardware representation of the type T. The value of this attribute is 
of the type universal_integer . See A.5.4. 
S'Machine_Rounding 
 For every subtype S of a floating point type T: 
 S'Machine_Rounding denotes a function with the following specification:  
function  S'Machine_Rounding ( X : T) 
  return T 
 The function yields the integral value nearest to X. If X lies exactly halfway between two 
integers, one of those integers is returned, but  which of them is returned is unspecified. A 
zero result has the sign of X when S'Signed_Zeros is True. This function provides access to 
the rounding behavior which is most effici ent on the target processor. See A.5.3. 
S'Machine_Rounds 
 For every subtype S of a floating point type T: 
 Yields the value True if rounding is perform ed on inexact results of every predefined 
operation that yields a result of the type T; yields the value False otherwise. The value of 
this attribute is of the predefined type Boolean. See A.5.3. 
S'Machine_Rounds 
 For every subtype S of a fixed point type T: 
 Yields the value True if rounding is perform ed on inexact results of every predefined 
operation that yields a result of the type T; yields the value False otherwise. The value of 
this attribute is of the predefined type Boolean. See A.5.4. 
S'Max For every scalar subtype S:  S'Max denotes a function with the following specification:  
function  S'Max( Left, Right : S'Base) 
  return S'Base 
 The function returns the greater of the values of the two parameters. See 3.5. 
S'Max_Alignment_For_Allocation 
 For every subtype S: 
 Denotes the maximum value for Alignment that  could be requested by the implementation 
via Allocate for an access type whose designated subtype is S. The value of this attribute is of type universal_integer . See 13.11.1. 
S'Max_Size_In_Storage_Elements 
 For every subtype S: 
 Denotes the maximum value for Size_In_Storage _Elements that could be requested by the 
implementation via Allocate for an access type whose designated subtype is S. The value of this attribute is of type universal_integer . See 13.11.1. 
S'Min For every scalar subtype S:  S'Min denotes a function with the following specification:  
function  S'Min( Left, Right : S'Base) 
  return S'Base 134 
135 136 
136.1/2 136.2/2 
136.3/2 
136.4/2 
137 
138 
139 
140 
141 
142 
143 
144 
144.1/3 
144.2/3 
145 
146/3 
147 
148 
149 
Ada Reference Manual — 2012 Edition 
K.2   Language-Defined Attributes 13 December 2012      772  The function returns the lesser of the va lues of the two parameters. See 3.5. 
S'Mod For every modular subtype S:  S'Mod denotes a function with the following specification: 
function  S'Mod ( Arg : universal_integer ) 
  return S'Base 
 This function returns Arg mod  S'Modulus, as a value of th e type of S. See 3.5.4. 
S'Model For every subtype S of a floating point type T: 
 S'Model denotes a function with the following specification:  
function  S'Model ( X : T) 
  return T 
 If the Numerics Annex is not supported, the meaning of this attri bute is implementation 
defined; see G.2.2 for the definition that  applies to implementations supporting the 
Numerics Annex. See A.5.3. 
S'Model_Emin 
 For every subtype S of a floating point type T: 
 If the Numerics Annex is not supported, this  attribute yields an implementation defined 
value that is greater than or equal to the value of T'Machine_Emin. See G.2.2 for further 
requirements that apply to implementations supporting the Numerics Annex. The value of 
this attribute is of the type universal_integer . See A.5.3. 
S'Model_Epsilon 
 For every subtype S of a floating point type T: 
 Yields the value T'Machine_Radix1 – T'Model_Mantissa. The value of this attribute is of the type 
universal_real . See A.5.3. 
S'Model_Mantissa 
 For every subtype S of a floating point type T: 
 If the Numerics Annex is not supported, this  attribute yields an implementation defined 
value that is greater than or equal to d · log(10) / log( T'Machine_Radix)  + 1, where d is 
the requested decimal precision of T, and less than or equal to the value of 
T'Machine_Mantissa. See G.2.2 for further re quirements that apply to implementations 
supporting the Numerics Annex. The value of this attribute is of the type universal_integer . 
See A.5.3. 
S'Model_Small 
 For every subtype S of a floating point type T: 
 Yields the value T'Machine_RadixT'Model_Emin – 1. The value of this attribute is of the type 
universal_real . See A.5.3. 
S'Modulus For every modular subtype S:  S'Modulus yields the modulus of the type of S, as a value of the type universal_integer . See 
3.5.4. 
X'Old For a 
prefix  X that denotes an object of a nonlimited type: 
 For each X'Old in a postcondition expression th at is enabled, a constant is implicitly 
declared at the beginning of the subprogram or entr y. The constant is of the type of X and is 
initialized to the result of evaluating X (as an  expression) at the point of the constant 
declaration. The value of X'Old in the postcond ition expression is the value of this constant; 
the type of X'Old is the type of X. These imp licit constant declarations occur in an arbitrary 
order. See 6.1.1. 150 
150.1/2 150.2/2 
150.3/2 
150.4/2 
151 152 
153 
154 
155 
156 
157 
158 159 160 
161 
162 163 
164 
164.1/3 
164.2/3 
Ada Reference Manual — 2012 Edition 
773      13 December 2012 Language-Defined Attributes   K.2 S'Class'Output 
 For every subtype S'Class of a class-wide type T'Class: 
 S'Class'Output denotes a procedure with the following specification:  
procedure  S'Class'Output( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item   : in T'Class) 
 First writes the external tag of Item to Stream  (by calling String'Output( Stream , Tags.-
External_Tag( Item'Tag)) — see 3.9) and then dispatches  to the subprogram denoted by the 
Output attribute of the specific type identified by the tag. Tag_Error is raised if the tag of 
Item identifies a type declared at an accessibility  level deeper than that of S. See 13.13.2. 
S'Output For every subtype S of a specific type T: 
 S'Output denotes a procedure with the following specification:  
procedure  S'Output( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item : in T) 
 S'Output writes the value of Item to Stream , including any bounds or discriminants. See 
13.13.2. 
X'Overlaps_Storage 
 For a prefix  X that denotes an object: 
 X'Overlaps_Storage denotes a func tion with the following specification: 
function  X'Overlaps_Storage ( Arg : any_type) 
  return Boolean 
 The actual parameter shall be a name that denotes an object. The object denoted by the 
actual parameter can be of any type. This function evaluates the names of the objects 
involved and returns True if the representation of the object denoted by the actual parameter shares at least one bit with the representation of the object denoted by X; 
otherwise, it returns False. See 13.3. 
D'Partition_Id 
 For a 
prefix  D that denotes a library-level declarati on, excepting a declaration of or within a 
declared-pure library unit: 
 Denotes a value of the type universal_integer  that identifies the partition in which D was 
elaborated. If D denotes the declaration of a remote call interface library unit (see E.2.3) the given partition is the one where the body of D was elaborated. See E.1. 
S'Pos For every discrete subtype S:  S'Pos denotes a function with the following specification:  
function  S'Pos( Arg : S'Base) 
  return universal_integer  
 This function returns the position number of the value of Arg, as a value of type 
universal_integer . See 3.5.5. 
R.C'Position For a component C of  a composite, non-array object R: 
 If the nondefault bit ordering applies to the composite type, and if a component_clause  
specifies the placement of C, denotes the value given for the position  of the 
component_clause ; otherwise, denotes the same valu e as R.C'Address – R'Address. The 
value of this attribute is of the type universal_integer . See 13.5.2. 
S'Pred For every scalar subtype S:  S'Pred denotes a function with the following specification:  165 
166 
167/2 
168/2 
169 
170 
171/2 
172 
172.1/3 172.2/3 
172.3/3 
172.4/3 
173/1 
174 
175 
176 
177 
178 
179 
180/2 
181 
182 
Ada Reference Manual — 2012 Edition 
K.2   Language-Defined Attributes 13 December 2012      774 function  S'Pred( Arg : S'Base) 
  return S'Base 
 For an enumeration type, the function retu rns the value whose position number is one less 
than that of the value of Arg; Constraint_Error is raised if th ere is no such value of the type. 
For an integer type, the function returns the result of subtracting one from the value of Arg. 
For a fixed point type, the function returns the result of subtracting small  from the value of 
Arg. For a floating point type, the function return s the machine number (as defined in 3.5.7) 
immediately below the value of Arg; Constraint_Error is raised if there is no such machine 
number. See 3.5. 
P'Priority For a prefix  P that denotes a protected object: 
 Denotes a non-aliased component of the protect ed object P. This component is of type 
System.Any_Priority and its value is the priority  of P. P'Priority denotes a variable if and 
only if P denotes a variable. A reference to th is attribute shall appear only within the body 
of P. See D.5.2. 
A'Range For a prefix  A that is of an array type (after any implicit dereference), or denotes a 
constrained array subtype: 
 A'Range is equivalent to the range  A'First .. A'Last, except that the prefix  A is only 
evaluated once. See 3.6.2. 
S'Range For every scalar subtype S:  S'Range is equivalent to the 
range  S'First .. S'Last. See 3.5. 
A'Range(N) For a prefix  A that is of an array type (after any implicit dereference), or denotes a 
constrained array subtype: 
 A'Range(N) is equivalent to the range A'First(N) .. A'Last(N), except that the prefix  A is 
only evaluated once. See 3.6.2. 
S'Class'Read For every subtype S'Class of a class-wide type T'Class: 
 S'Class'Read denotes a procedure with the following specification:  
procedure  S'Class'Read( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item : out T'Class) 
 Dispatches to the subprogram denoted by the Read attribute of the specific type identified 
by the tag of Item. See 13.13.2. 
S'Read For every subtype S of a specific type T: 
 S'Read denotes a procedure with the following specification:  
procedure  S'Read( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item : out T) 
 S'Read reads the value of Item from Stream . See 13.13.2. 
S'Remainder For every subtype S of a floating point type T: 
 S'Remainder denotes a function w ith the following specification:  
function  S'Remainder ( X, Y : T) 
  return T 
 For nonzero Y, let v be the value X – n · Y, where n is the integer nearest to the exact value 
of X/Y; if |n – X/Y| = 1/2, then n is chosen to be even. If v is a machine number of the type 
T, the function yields v; otherwise, it yields zero. C onstraint_Error is raised if Y is zero. A 
zero result has the sign of X when S'Signed_Zeros is True. See A.5.3. 183 
184 
184.1/2 
184.2/2 
185/1 
186 187 
188 
189/1 
190 191 
192 
193/2 
194 
195 
196 
197/2 
198 
199 200 
201 
202 
Ada Reference Manual — 2012 Edition 
775      13 December 2012 Language-Defined Attributes   K.2 F'Result For a prefix  F that denotes a function declaration: 
 Within a postcondition expression for function F,  denotes the result object of the function. 
The type of this attribute is that of the function result except within a Post'Class 
postcondition expression for a function with a controlling result or with a controlling access 
result. For a controlling result, the type of the attribute is T'Class, where T is the function 
result type. For a controlling access result, the ty pe of the attribute is an anonymous access 
type whose designated type is T'Class, where T is the designated type of the function result 
type. See 6.1.1. 
S'Round For every decimal fixed point subtype S:  S'Round denotes a function with the following specification:  
function  S'Round( X : universal_real ) 
  return S'Base 
 The function returns the value obtained by  rounding X (away from 0, if X is midway 
between two values of the type of S). See 3.5.10. 
S'Rounding For every subtype S of a floating point type T: 
 S'Rounding denotes a function with the following specification:  
function  S'Rounding ( X : T) 
  return T 
 The function yields the integral value nearest to X, rounding away from zero if X lies 
exactly halfway between two integers. A zero result has the sign of X when S'Signed_Zeros 
is True. See A.5.3. 
S'Safe_First 
 For every subtype S of a floating point type T: 
 Yields the lower bound of the safe range (see 3.5.7) of the type T. If the Numerics Annex is 
not supported, the value of this attribute is  implementation defined; see G.2.2 for the 
definition that applies to implementations supporting the Numerics Annex. The value of 
this attribute is of the type universal_real . See A.5.3. 
S'Safe_Last For every subtype S of a floating point type T: 
 Yields the upper bound of the safe range (see 3.5.7) of the type T. If the Numerics Annex is 
not supported, the value of this attribute is  implementation defined; see G.2.2 for the 
definition that applies to implementations supporting the Numerics Annex. The value of 
this attribute is of the type universal_real . See A.5.3. 
S'Scale For every decimal fixed point subtype S:  S'Scale denotes the scale  of the subtype S, defined as the value N such that S'Delta = 
10.0**(–N). The scale indicates the position of th e point relative to the rightmost significant 
digits of values of subtype S. The va lue of this attribute is of the type universal_integer . 
See 3.5.10. 
S'Scaling For every subtype S of a floating point type T: 
 S'Scaling denotes a function with the following specification:  
function  S'Scaling ( X : T; 
                    Adjustment  : universal_integer ) 
  return T 
 Let v be the value X · T'Machine_RadixAdjustment. If v is a machine number of the type T, or if 
|v| ≥ T'Model_Small, the function yields v; otherwise, it yields either one of the machine 
numbers of the type T adjacent to v. Constraint_Error is optionally raised if v is outside the 
base range of S. A zero result has the sign of X when S'Signed_Zeros is True. See A.5.3. 202.1/3 
202.2/3 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
Ada Reference Manual — 2012 Edition 
K.2   Language-Defined Attributes 13 December 2012      776 S'Signed_Zeros 
 For every subtype S of a floating point type T: 
 Yields the value True if the hardware representation for the type T has the capability of 
representing both positively and negatively signed zeros, these being generated and used by 
the predefined operations of the type T as specified in IEC 559:1989; yields the value False 
otherwise. The value of this attribute is of the predefined type Boolean. See A.5.3. 
S'Size For every subtype S:  If S is definite, denotes the size (in bits) that the implementati on would choose for the 
following objects of subtype S:  
• A record component of subtype S when the record type is packed. 
• The formal parameter of an instan ce of Unchecked_Conversion that converts 
from subtype S to some other subtype.  
 If S is indefinite, the meaning is implementati on defined. The value of this attribute is of 
the type universal_integer . See 13.3. 
X'Size For a 
prefix  X that denotes an object: 
 Denotes the size in bits of the representation of  the object. The value of this attribute is of 
the type universal_integer . See 13.3. 
S'Small For every fixed point subtype S:  S'Small denotes the small  of the type of S. The value of this attribute is of the type 
universal_real . See 3.5.10. 
S'Storage_Pool 
 For every access-to-object subtype S: 
 Denotes the storage pool of the type of S. The type of this attribute is Root_Storage_-
Pool'Class. See 13.11. 
S'Storage_Size 
 For every access-to-object subtype S: 
 Yields the result of calling Storage_Size(S' Storage_Pool), which is intended to be a 
measure of the number of storag e elements reserved for the pool . The type of this attribute 
is universal_integer . See 13.11. 
T'Storage_Size 
 For a 
prefix  T that denotes a task object (after any implicit dereference): 
 Denotes the number of storage elements reserved for the task. The value of this attribute is 
of the type universal_integer . The Storage_Size includes the size of the task's stack, if any. 
The language does not specify whether or not it includes other storage associated with the 
task (such as the “task control block” us ed by some implemen tations.) See 13.3. 
S'Stream_Size 
 For every subtype S of an elementary type T: 
 Denotes the number of bits read from or writte n to a stream by the default implementations 
of S'Read and S'Write. Hence, the number of stream elements required per item of 
elementary type T is: 
T'Stream_Size / Ada.Streams.Stream_Element'Size 
 The value of this attribute is of type universal_integer  and is a multiple of 
Stream_Element'Size. See 13.13.2. 
S'Succ For every scalar subtype S: 221 
222 
223 
224 
225 
226 
227 
228/1 
229 
230 
231 
232 233 234 235 
236/1 
237 
237.1/3 
237.2/3 
237.3/2 
237.4/2 
238 
Ada Reference Manual — 2012 Edition 
777      13 December 2012 Language-Defined Attributes   K.2  S'Succ denotes a function with the following specification:  
function  S'Succ( Arg : S'Base) 
  return S'Base 
 For an enumeration type, the function return s the value whose position number is one more 
than that of the value of Arg; Constraint_Error is raised if th ere is no such value of the type. 
For an integer type, the function returns the result of adding one to the value of Arg. For a 
fixed point type, the function returns the result of adding small  to the value of Arg. For a 
floating point type, the function returns th e machine number (as defined in 3.5.7) 
immediately above the value of Arg; Constraint_Error is raised if there is no such machine 
number. See 3.5. 
S'Tag For every subtype S of a tagged type T (specific or class-wide): 
 S'Tag denotes the tag of the type T (or if T is class-wide, the tag of the root type of the 
corresponding class). The value of this a ttribute is of type Tag. See 3.9. 
X'Tag For a prefix  X that is of a class-wide tagged type (after any implicit dereference): 
 X'Tag denotes the tag of X. The value of this attribute is of type Tag. See 3.9. 
T'Terminated For a prefix  T that is of a task type (after any implicit dereference): 
 Yields the value True if the task denoted by T is terminated, and False otherwise. The value 
of this attribute is of the pr edefined type Boolean. See 9.9. 
S'Truncation For every subtype S of a floating point type T: 
 S'Truncation denotes a function with the following specification:  
function  S'Truncation ( X : T) 
  return T 
 The function yields the value X when X is negative, and X otherwise. A zero result has 
the sign of X when S'Signed_Zeros is True. See A.5.3. 
S'Unbiased_Rounding 
 For every subtype S of a floating point type T: 
 S'Unbiased_Rounding denotes a function with the following specification:  
function  S'Unbiased_Rounding ( X : T) 
  return T 
 The function yields the integral value nearest to X, rounding toward the even integer if X 
lies exactly halfway between two integers. A zero result has the sign of X when 
S'Signed_Zeros is True. See A.5.3. 
X'Unchecked_Access 
 For a prefix  X that denotes an aliased view of an object: 
 All rules and semantics that apply to  X'Access (see 3.10.2) apply also to 
X'Unchecked_Access, except that, for the purposes  of accessibility rules and checks, it is as 
if X were declared immediately within a library package. See 13.10. 
S'Val For every discrete subtype S:  S'Val denotes a function with the following specification:  
function  S'Val( Arg : universal_integer ) 
  return S'Base 
 This function returns a value of the type of S whose position number equals the value of 
Arg. See 3.5.5. 
X'Valid For a prefix  X that denotes a scalar object (after any implicit dereference): 239 
240 
241 
242 
243 
244 
245 246 247 
248 
249 
250 
251 
252 253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
Ada Reference Manual — 2012 Edition 
K.2   Language-Defined Attributes 13 December 2012      778  Yields True if and only if the object denoted by X is normal, has a valid representation, and 
the predicate of the nominal subtype of X evaluate s to True. The value of this attribute is of 
the predefined type Boolean. See 13.9.2. 
S'Value For every scalar subtype S:  S'Value denotes a function with the following specification:  
function  S'Value( Arg : String) 
  return S'Base 
 This function returns a value given an image of the value as a String, ignoring any leading 
or trailing spaces. See 3.5. 
P'Version For a prefix  P that statically denotes a program unit: 
 Yields a value of the predefined type Stri ng that identifies the version of the compilation 
unit that contains the declarati on of the program unit. See E.3. 
S'Wide_Image For every scalar subtype S:  S'Wide_Image denotes a function with the following specification:  
function  S'Wide_Image( Arg : S'Base) 
  return Wide_String 
 The function returns an image of the value of Arg as a Wide_String. See 3.5. 
S'Wide_Value 
 For every scalar subtype S: 
 S'Wide_Value denotes a function with the following specification:  
function  S'Wide_Value( Arg : Wide_String) 
  return S'Base 
 This function returns a value given an image of the value as a Wide_String, ignoring any 
leading or trailing spaces. See 3.5. 
S'Wide_Wide_Image 
 For every scalar subtype S: 
 S'Wide_Wide_Image denotes a functi on with the following specification:  
function  S'Wide_Wide_Image( Arg : S'Base) 
  return Wide_Wide_String 
 The function returns an image  of the value of Arg, that is, a sequence of characters 
representing the value in display form. See 3.5. 
S'Wide_Wide_Value 
 For every scalar subtype S: 
 S'Wide_Wide_Value denotes a functi on with the following specification:  
function  S'Wide_Wide_Value( Arg : Wide_Wide_String) 
  return S'Base 
 This function returns a value given an image of the value as a Wide_Wide_String, ignoring 
any leading or trailing spaces. See 3.5. 
S'Wide_Wide_Width 
 For every scalar subtype S: 
 S'Wide_Wide_Width denotes the maximum le ngth of a Wide_Wide_String returned by 
S'Wide_Wide_Image over all values of the subtyp e S. It denotes zero for a subtype that has 
a null range. Its type is universal_integer . See 3.5. 263/3 
264 
265 
266 
267 
268/1 
269 
270 
271 
272 
273/3 
274 
275 
276 
277 
277.1/2 277.2/2 
277.3/2 
277.4/2 
277.5/2 277.6/2 
277.7/2 
277.8/2 
277.9/2 
277.10/2 
Ada Reference Manual — 2012 Edition 
779      13 December 2012 Language-Defined Attributes   K.2 S'Wide_Width 
 For every scalar subtype S: 
 S'Wide_Width denotes the maximum length of  a Wide_String returned by S'Wide_Image 
over all values of the subtype S. It denotes zer o for a subtype that has a null range. Its type 
is universal_integer . See 3.5. 
S'Width For every scalar subtype S:  S'Width denotes the maximum le ngth of a String returned by S'Image over all values of the 
subtype S. It denotes zero for a subtype that has a null range. Its type is universal_integer . 
See 3.5. 
S'Class'Write 
 For every subtype S'Class of a class-wide type T'Class: 
 S'Class'Write denotes a procedure with the following specification:  
procedure  S'Class'Write( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item   : in T'Class) 
 Dispatches to the subprogram denoted by the Write attribute of the specific type identified 
by the tag of Item. See 13.13.2. 
S'Write For every subtype S of a specific type T: 
 S'Write denotes a procedure with the following specification:  
procedure  S'Write( 
   Stream : not null access  Ada.Streams.Root_Stream_Type'Class; 
   Item : in T) 
 S'Write writes the value of Item to Stream . See 13.13.2. 278 
279 
280 
281 
282 
283 
284/2 
285 
286 
287 
288/2 
289 

Ada Reference Manual — 2012 Edition 
781      13 December 2012 Language-Defined Pragmas   Annex L Annex L 
(informative)  
Language-Defined Pragmas 
This Annex summarizes the definitions given elsewhere of the language-defined pragmas. 
pragma  All_Calls_Remote[( library_unit_ name )]; — See E.2.3. 
pragma  Assert([Check =>] boolean_ expression [, [Message =>] string_ expression ]); — See 11.4.2. 
pragma  Assertion_Policy( policy_ identifier ); — See 11.4.2. 
pragma  Assertion_Policy( 
         assertion_ aspect_mark  => policy_ identifier  
     {, assertion_ aspect_mark  => policy_ identifier }); — See 11.4.2. 
This paragraph was deleted.   
pragma  Asynchronous ( local_name ); — See J.15.13. 
This paragraph was deleted.   
pragma  Atomic ( local_name ); — See J.15.8. 
This paragraph was deleted.   
pragma  Atomic_Components ( array_ local_name ); — See J.15.8. 
This paragraph was deleted.   
pragma  Attach_Handler ( handler_ name , expression ); — See J.15.7. 
This paragraph was deleted.   
This paragraph was deleted.   
pragma  Convention([Convention =>] convention_ identifier ,[Entity =>] local_name ); — See J.15.5. 
pragma  CPU ( expression ); — See J.15.9. 
pragma  Default_Storage_Pool ( storage_pool_indicator ); — See 13.11.3. 
pragma  Detect_Blocking; — See H.5. 
pragma  Discard_Names[([On => ] local_name )]; — See C.5. 
pragma  Dispatching_Domain ( expression ); — See J.15.10. 
pragma  Elaborate( library_unit_ name {, library_unit_ name }); — See 10.2.1. 
pragma  Elaborate_All( library_unit_ name {, library_unit_ name }); — See 10.2.1. 
pragma  Elaborate_Body[( library_unit_ name )]; — See 10.2.1. 
This paragraph was deleted.   
pragma  Export( 
     [Convention =>] convention_ identifier , [Entity =>] local_name  
  [, [External_Name =>] external_name_string_ expression ] 1 
2 
2.1/2 2.2/2 2.3/3 
3/3 
3.1/3 
4/3 
4.1/3 
5/3 
5.1/3 
6/3 
6.1/3 
7/3 8/3 
8.1/3 8.2/3 8.3/3 8.4/2 
9 
9.1/3 
10 11 12 
13/3 
13.1/3 
Ada Reference Manual — 2012 Edition 
Annex L    Language-Defined Pragmas 13 December 2012      782   [, [Link_Name =>] link_name_string_ expression ]); — See J.15.5. 
This paragraph was deleted.   
pragma  Import( 
     [Convention =>] convention_ identifier , [Entity =>] local_name  
  [, [External_Name =>] external_name_string_ expression ] 
  [, [Link_Name =>] link_name_string_ expression ]); — See J.15.5. 
pragma  Independent ( component_ local_name ); — See J.15.8. 
pragma  Independent_Components ( local_name ); — See J.15.8. 
This paragraph was deleted.   
pragma  Inline ( name {, name }); — See J.15.1. 
pragma  Inspection_Point[( object_ name  {, object_ name })]; — See H.3.2. 
This paragraph was deleted.   
pragma  Interrupt_Handler ( handler_ name ); — See J.15.7. 
This paragraph was deleted.   
pragma  Interrupt_Priority [( expression );] — See J.15.11. 
pragma  Linker_Options( string_ expression ); — See B.1. 
pragma  List( identifier ); — See 2.8. 
pragma  Locking_Policy( policy_ identifier ); — See D.3. 
This paragraph was deleted.   
pragma  No_Return ( procedure_ local_name {, procedure_ local_name }); — See J.15.2. 
pragma  Normalize_Scalars; — See H.1. 
pragma  Optimize( identifier ); — See 2.8. 
This paragraph was deleted.   
pragma  Pack ( first_subtype_ local_name ); — See J.15.3. 
pragma  Page; — See 2.8. 
pragma  Partition_Elaboration_Policy ( policy_ identifier ); — See H.6. 
pragma  Preelaborable_Initialization( direct_name ); — See 10.2.1. 
pragma  Preelaborate[( library_unit_ name )]; — See 10.2.1. 
This paragraph was deleted.   
pragma  Priority ( expression ); — See J.15.11. 
pragma  Priority_Specific_Dispatching ( 
     policy_ identifier , first_priority_ expression , last_priority_ expression ); — See D.2.2. 
pragma  Profile ( profile_ identifier  {, profile_ pragma_argument_association }); — See 13.12. 14/3 
14.1/3 
14.2/3 
14.3/3 
15/3 
15.1/3 
16 
17/3 
17.1/3 
18/3 
18.1/3 
19 20 21 
21.1/3 21.2/3 
22 23 
24/3 
24.1/3 
25 
25.1/2 25.2/2 
26 
27/3 
27.1/3 27.2/2 
27.3/3 
Ada Reference Manual — 2012 Edition 
783      13 December 2012 Language-Defined Pragmas   Annex L This paragraph was deleted.   
pragma  Pure[( library_unit_ name )]; — See 10.2.1. 
pragma  Queuing_Policy( policy_ identifier ); — See D.4. 
This paragraph was deleted.   
pragma  Relative_Deadline ( relative_deadline_ expression ); — See J.15.12. 
pragma  Remote_Call_Interface[( library_unit_ name )]; — See E.2.3. 
pragma  Remote_Types[( library_unit_ name )]; — See E.2.2. 
pragma  Restrictions( restriction {, restriction }); — See 13.12. 
pragma  Reviewable; — See H.3.1. 
pragma  Shared_Passive[( library_unit_ name )]; — See E.2.1. 
This paragraph was deleted.   
pragma  Storage_Size ( expression ); — See J.15.4. 
pragma  Suppress( identifier ); — See 11.5. 
pragma  Task_Dispatching_Policy( policy_ identifier ); — See D.2.2. 
This paragraph was deleted.   
pragma  Unchecked_Union ( first_subtype_ local_name ); — See J.15.6. 
pragma  Unsuppress( identifier ); — See 11.5. 
This paragraph was deleted.   
pragma  Volatile ( local_name ); — See J.15.8. 
This paragraph was deleted.   
pragma  Volatile_Components ( array_ local_name ); — See J.15.8. 27.4/3 
28 29 
29.1/3 29.2/3 
30 31 32 33 34 
35/3 
35.1/3 
36 37 
37.1/3 37.2/3 37.3/2 
38/3 
38.1/3 
39/3 
39.1/3 

Ada Reference Manual — 2012 Edition 
785      13 December 2012 Summary of Documentation Requirements   Annex M Annex M 
(informative)  
Summary of Documentation Requirements 
The Ada language allows for certain target machin e dependences in a controlled manner. Each Ada 
implementation must document many ch aracteristics and properties of the target system. This International 
Standard contains specific documen tation requirements. In addition, many characteristics that require 
documentation are identified throughout this Internati onal Standard as being implementation defined. 
Finally, this International Standard  requires documentation of whether implementation advice is followed. 
The following subclauses provide summaries  of these documentation requirements.  
M.1 Specific Documentation Requirements 
In addition to implementation-defined characteristics, each Ada implementation must document various 
properties of the implementation:  
• The behavior of implementati ons in implementation-defined s ituations shall be documented — 
see M.2, “Implementation-Defined Charact eristics” for a listing. See 1.1.3(19). 
• The set of values that a user-defined Allo cate procedure needs to accept for the Alignment 
parameter. How the standard stor age pool is chosen, and how stor age is allocated by standard 
storage pools. See 13.11(22). 
• The algorithm used for random number generation,  including a description of its period. See 
A.5.2(44). 
• The minimum time interval between calls to the time-dependent Reset procedure that is 
guaranteed to initiate different ra ndom number sequences. See A.5.2(45). 
• The conditions under which Io_Exceptions.N ame_Error, Io_Exceptions.Use_Error, and 
Io_Exceptions.Device_Error ar e propagated. See A.13(15). 
• The behavior of package Environment_Variable s when environment variables are changed by 
external mechanisms. See A.17(30/2). 
• The overhead of calling machine-code or intrinsic subprograms. See C.1(6). 
• The types and attributes used in machine code insertions. See C.1(7). 
• The subprogram calling conventions for all s upported convention identifiers. See C.1(8/3). 
• The mapping between the Link_Name or Ada designa tor and the external link name. See C.1(9). 
• The treatment of interrupts. See C.3(22). 
• The metrics for interrupt handlers. See C.3.1(16). 
• If the Ceiling_Locking policy is in effect, the defa ult ceiling priority for a protected object that 
specifies an interrupt handl er aspect. See C.3.2(24/3). 
• Any circumstances when the elaboration of a pr eelaborated package causes code to be executed. 
See C.4(12). 
• Whether a partition can be restarted without reloading. See C.4(13). 
• The effect of calling Current_Task from an en try body or interrupt handler. See C.7.1(19). 1/3 
1/2 
2/2 
3/2 
4/2 
5/2 6/2 7/2 8/2 
9/2 
10/2 11/2 12/2 13/2 14/3 
15/2 16/2 
17/2 
Ada Reference Manual — 2012 Edition 
M.1   Specific Documentation Requi rements 13 December 2012      786 • For package Task_Attributes, limits on the number and size of task attributes, and how to 
configure any limits. See C.7.2(19). 
• The metrics for the Task_Attributes package. See C.7.2(27). 
• The details of the configuration used to ge nerate the values of all metrics. See D(2). 
• The maximum priority inversion a user task can experience from the implementation. See 
D.2.3(12/2). 
• The amount of time that a task  can be preempted for processing on behalf of lower-priority 
tasks. See D.2.3(13/2). 
• The quantum values supported for round robin dispatching. See D.2.5(16/2). 
• The accuracy of the detection of the exhaustion of the budget of a task for round robin 
dispatching. See D.2.5(17/2). 
• Any conditions that cause the completion of the setting of the deadline of a task to be delayed 
for a multiprocessor. See D.2.6(32/2). 
• Any conditions that cause the completion of the setti ng of the priority of a task to be delayed for 
a multiprocessor. See D.5.1(12.1/2). 
• The metrics for Set_Priority. See D.5.1(14). 
• The metrics for setting the priority of a protected object. See D.5.2(10). 
• On a multiprocessor, any conditions that cause the completion of an aborted construct to be 
delayed later than what is specified for a single processor. See D.6(3). 
• The metrics for aborts. See D.6(8). 
• The values of Time_First, Time_Last, Time _Span_First, Time_Span_L ast, Time_Span_Unit, 
and Tick for package Real_Time. See D.8(33). 
• The properties of the underlying time base used in package Real _Time. See D.8(34). 
• Any synchronization of package Real_Time w ith external time references. See D.8(35). 
• Any aspects of the external environment that  could interfere with package Real_Time. See 
D.8(36/3). 
• The metrics for package Real_Time. See D.8(45). 
• The minimum value of the delay expression of a delay_relative_statement  that causes a task to 
actually be blocked. See D.9(7). 
• The minimum difference between the value of the delay expression of a delay_until_statement  
and the value of Real_Time.Clock, that causes the task to actually be blocked. See D.9(8). 
• The metrics for delay statements. See D.9(13). 
• The upper bound on the duration of interrupt bl ocking caused by the implementation. See 
D.12(5). 
• The metrics for entry-less protected objects. See D.12(12). 
• The values of CPU_Time_First, CPU_Time_Las t, CPU_Time_Unit, and CPU_Tick of package 
Execution_Time. See D.14(21/2). 
• The properties of the mechanism used to implement package Execu tion_Time, including the 
values of the constants defined in the package. See D.14(22/2). 
• The metrics for execution time. See D.14(27). 18/2 
19/2 
20/2 21/2 
22/2 23/2 
24/2 
25/2 26/2 27/2 
28/2 29/2 
30/2 
31/2 
32/2 
33/2 34/2 
35/2 
36/2 
37/2 38/2 
39/2 
40/2 
41/2 
42/3 43/2 
Ada Reference Manual — 2012 Edition 
787      13 December 2012 Specific Documentation Requirements   M.1 • The metrics for timing events. See D.15(24). 
• The processor(s) on which the clock interrupt is handled; the processors on which each 
Interrupt_Id can be handled. See D.16.1(32). 
• Whether the RPC-receiver is invoked from concurrent  tasks, and if so, the number of such tasks. 
See E.5(25). 
• Any techniques used to reduce cancellation erro rs in Numerics.Generic_Real_Arrays shall be 
documented. See G.3.1(86/2). 
• Any techniques used to reduce cancellation erro rs in Numerics.Generic_Complex_Arrays shall 
be documented. See G.3.2(155/2). 
• If a pragma  Normalize_Scalars applies, the implicit in itial values of scalar subtypes shall be 
documented. Such a value should be an invalid re presentation when possible; any cases when is 
it not shall be documented. See H.1(5/2). 
• The range of effects for each bounded error and each  unspecified effect. If the effects of a given 
erroneous construct are constrained, the c onstraints shall be documented. See H.2(1). 
• For each inspection point, a mapping between each inspectable object and the machine resources 
where the object's value can be obtained shall be provided. See H.3.2(8). 
• If a pragma Restrictions(No_Exceptions) is specified, the effects of all constructs where 
language-defined checks are still performed. See H.4(25). 
• The interrupts to which a task entry may be attached. See J.7.1(12). 
• The type of entry call invoked for an interrupt entry. See J.7.1(13). 
M.2 Implementation-Defined Characteristics 
The Ada language allows for certain machine de pendences in a controlled manner. Each Ada 
implementation must document all implementation-defined characteristics:  
• Whether or not each recommendation given in Implementation Advice is followed — see M.3, 
“Implementation Advice” for a listing. See 1.1.2(37). 
• Capacity limitations of the implementation. See 1.1.3(3). 
• Variations from the standard that are impracti cal to avoid given the implementation's execution 
environment. See 1.1.3(6). 
• Which code_statement s cause external interactions. See 1.1.3(10). 
• The coded representation for the text  of an Ada program. See 2.1(4/3). 
• The semantics of an Ada program whose text is  not in Normalization Fo rm KC. See 2.1(4.1/3). 
• This paragraph was deleted.  
• The representation for an end of line. See 2.2(2/3). 
• Maximum supported line length and le xical element length. See 2.2(14). 
• Implementation-defined pragmas. See 2.8(14). 
• Effect of pragma Optimize. See 2.8(27). 
• The sequence of characters of the value returned  by S'Wide_Image when some of the graphic 
characters of S'Wide_Wide_Image are not de fined in Wide_Character. See 3.5(30/3). 44/2 
44.1/3 
45/2 46/2 47/2 48/2 
49/2 
50/2 51/2 52/2 
53/2 
1/2 
2/2 
3 
4 
5 
6 
6.1/2 
7/2 
8 9 
10 11 
11.1/2 
Ada Reference Manual — 2012 Edition 
M.2   Implementation-Defined Charact eristics 13 December 2012      788 • The sequence of characters of the value retu rned by S'Image when some of the graphic 
characters of S'Wide_Wide_Image are not defined in Character. See 3.5(37/3). 
• The predefined integer types decl ared in Standard. See 3.5.4(25). 
• Any nonstandard integer types and the ope rators defined for them. See 3.5.4(26). 
• Any nonstandard real types and the opera tors defined for them. See 3.5.6(8). 
• What combinations of requested decimal pr ecision and range are supported for floating point 
types. See 3.5.7(7). 
• The predefined floating point types declared in Standard. See 3.5.7(16). 
• The small  of an ordinary fixed point type. See 3.5.9(8/2). 
• What combinations of small , range, and digits  are supported for fixed point types. See 3.5.9(10). 
• The result of Tags.Wide_Wide_Expanded_Nam e for types declared within an unnamed 
block_statement . See 3.9(10). 
• The sequence of characters of the value re turned by Tags.Expanded_Name (respectively, 
Tags.Wide_Expanded_Name) when some of the graphic characters of Tags.Wide_Wide_Expanded_Name are not defined in  Character (respectively, Wide_Character). 
See 3.9(10.1/2). 
• Implementation-defined a ttributes. See 4.1.4(12/1). 
• Rounding of real static expressions which are exactly half-way between  two machine numbers. 
See 4.9(38/2). 
• Any implementation-defined time types. See 9.6(6/3). 
• The time base associated with relative delays. See 9.6(20). 
• The time base of the type Calendar.Time. See 9.6(23). 
• The time zone used for package Calendar operations. See 9.6(24/2). 
• Any limit on 
delay_until_statement s of select_statement s. See 9.6(29). 
• The result of Calendar.Formating.Image if its  argument represents more than 100 hours. See 
9.6.1(86/2). 
• This paragraph was deleted.  
• The representation for a compilation . See 10.1(2). 
• Any restrictions on compilation s that contain multiple compilation_unit s. See 10.1(4). 
• The mechanisms for creating an environmen t and for adding and replacing compilation units. 
See 10.1.4(3/2). 
• The mechanisms for adding a compilation unit mentioned in a limited_with_clause  to an 
environment. See 10.1.4(3/2). 
• The manner of explicitly assigning library units to a partition. See 10.2(2). 
• The implementation-defined means,  if any, of specifying which compilation units are needed by 
a given compilation unit. See 10.2(2). 
• The manner of designating the main subprogram of a partition. See 10.2(7). 
• The order of elaboration of library_item s. See 10.2(18). 
• Parameter passing and function return for the main subprogram. See 10.2(21). 12/2 
13 
14 15 16 
17 
18 19 
20/2 
20.1/2 
21 
21.1/2 
22 
23 24 
25/2 
26 
26.1/2 
27/3 
28 29 30 
30.1/2 
31 
32 
33 
34 35 
Ada Reference Manual — 2012 Edition 
789      13 December 2012 Implemen tation-Defined Characteristics   M.2 • The mechanisms for building and running partitions. See 10.2(24). 
• The details of program execution, incl uding program termination. See 10.2(25). 
• The semantics of any nonactive partitions s upported by the implementation. See 10.2(28/3). 
• The information returned by Ex ception_Message. See 11.4.1(10.1/3). 
• The result of Exceptions.Wide_Wide_Excepti on_Name for exceptions d eclared within an 
unnamed block_statement . See 11.4.1(12). 
• The sequence of characters of the value retu rned by Exceptions.Excep tion_Name (respectively, 
Exceptions.Wide_Exception_Nam e) when some of the graphic characters of 
Exceptions.Wide_Wide_Excepti on_Name are not defined in Character (respectively, 
Wide_Character). See 11.4.1(12.1/2). 
• The information returned by Ex ception_Information. See 11.4.1(13/2). 
• Implementation-defined policy_ identifier s and assertion_ aspect_mark s allowed in a pragma  
Assertion_Policy. See 11.4.2(9/3). 
• The default assertion policy. See 11.4.2(10). 
• Implementation-defined check names. See 11.5(27). 
• Existence and meaning of second parameter of pragma  Unsuppress. See 11.5(27.1/2). 
• The cases that cause conflicts between the representation of the ancestors of a type_declaration . 
See 13.1(13.1/3). 
• The interpretation of each representation aspect. See 13.1(20). 
• Any restrictions placed upon the specificati on of representation aspects. See 13.1(20). 
• Implementation-defined aspects, inluding the synt ax for specifying such aspects and the legality 
rules for such aspects. See 13.1.1(38). 
• The set of machine scalars. See 13.3(8.1/3). 
• The meaning of Size for inde finite subtypes. See 13.3(48). 
• The default external representati on for a type tag. See 13.3(75/3). 
• What determines whether a compilation unit is th e same in two different partitions. See 13.3(76). 
• Implementation-defined co mponents. See 13.5.1(15). 
• If Word_Size = Storage_Unit, the de fault bit ordering. See 13.5.3(5). 
• The contents of the visible part of package System. See 13.7(2). 
• The range of Storage_Elements .Storage_Offset, the modulus of 
Storage_Elements.Storage_Element, and the decl aration of Storage_Elements.Integer_Address.. 
See 13.7.1(11). 
• The contents of the visible part of pack age System.Machine_Code, and the meaning of 
code_statement s. See 13.8(7). 
• The result of unchecked conversion for instances  with scalar result types whose result is not 
defined by the language. See 13.9(11). 
• The effect of unchecked conversion for instances  with nonscalar result types whose effect is not 
defined by the language. See 13.9(11). 
• This paragraph was deleted.  36 
37 38 39 
40/2 
40.1/2 
41 
41.1/3 
41.2/2 
42 
42.1/2 42.2/2 
43/3 
44/3 
44.1/3 
44.2/2 
45 46 47 48 49 
50/2 
50.1/2 
51 
51.1/2 
52/2 53/2 
Ada Reference Manual — 2012 Edition 
M.2   Implementation-Defined Charact eristics 13 December 2012      790 • Whether or not the implementation provides use r-accessible names for the standard pool type(s). 
See 13.11(17). 
• The meaning of Storage_Size when neither the Storage_Size nor the Storage_Pool is specified 
for an access type. See 13.11(18). 
• This paragraph was deleted.  
• This paragraph was deleted.  
• Implementation-defined restrictions allowed in a pragma  Restrictions. See 13.12(8.7/3). 
• The consequences of viola ting limitations on Restrictions pragma s. See 13.12(9). 
• Implementation-defined usage profiles allowed in a pragma  Profile. See 13.12(15). 
• The contents of the stream elements read a nd written by the Read and Write attributes of 
elementary types. See 13.13.2(9). 
• The names and characteristics of the numeric subt ypes declared in the visible part of package 
Standard. See A.1(3). 
• The values returned by St rings.Hash. See A.4.9(3/2). 
• The accuracy actually achieved by the elementary functions. See A.5.1(1). 
• The sign of a zero result from some of the operators or functions in 
Numerics.Generic_Elementary_Functions, when  Float_Type'Signed_Zeros is True. See 
A.5.1(46). 
• The value of Numerics.Float_Ra ndom.Max_Image_Width. See A.5.2(27). 
• The value of Numerics.Discrete_Ra ndom.Max_Image_Width. See A.5.2(27). 
• This paragraph was deleted.  
• The string representation of a random num ber generator's state. See A.5.2(38). 
• This paragraph was deleted.  
• The values of the Model_Mantissa, Model_Em in, Model_Epsilon, Model, Safe_First, and 
Safe_Last attributes, if the Numerics Annex is not supported. See A.5.3(72). 
• This paragraph was deleted.  
• The value of Buffer_Size in Storage_IO. See A.9(10). 
• The external files associated with the standard  input, standard output, a nd standard error files. 
See A.10(5). 
• The accuracy of the value pr oduced by Put. See A.10.9(36). 
• Current size for a stream file for which positioning is not supported. See A.12.1(1.1/1). 
• The meaning of Argument_Count, Ar gument, and Command_Name for package 
Command_Line. The bounds of type Command_Line.Exit_Status. See A.15(1). 
• The interpretation of file names and directory names. See A.16(46/2). 
• The maximum value for a file size in Directories. See A.16(87/2). 
• The result for Directories.Size for a directory or special file See A.16(93/2). 
• The result for Directories.Modification_Time fo r a directory or special file. See A.16(95/2). 
• The interpretation of a nonnull search pa ttern in Directories. See A.16(104/3). 54 
55/2 56/2 
57/3 
57.1/3 
58 
58.1/3 
59/2 
60 
60.1/2 
61 62 
63 
64 
65/2 
66 
67/2 
68 
69/2 
70 
71/2 
72 
72.1/1 
73/2 
73.1/2 
73.2/2 73.3/2 73.4/2 73.5/2 
Ada Reference Manual — 2012 Edition 
791      13 December 2012 Implemen tation-Defined Characteristics   M.2 • The results of a Directories search if the contents  of the directory are altered while a search is in 
progress. See A.16(110/3). 
• The definition and meaning of an environment variable. See A.17(1/2). 
• The circumstances where an environment variable cannot be defined. See A.17(16/2). 
• Environment names for which Set has the effect of Clear. See A.17(17/2). 
• The value of Containers.Has h_Type'Modulus. The value of C ontainers.Count_Type'Last. See 
A.18.1(7/2). 
• Implementation-defined conve ntion names. See B.1(11/3). 
• The meaning of link names. See B.1(36). 
• The manner of choosing link names when neither the link name nor the address of an imported 
or exported entity is specified. See B.1(36). 
• The effect of pragma Linker_Options. See B.1(37). 
• The contents of the visible part of package In terfaces and its language-defined descendants. See 
B.2(1). 
• Implementation-defined children of package Interfaces. See B.2(11). 
• The definitions of certain types and constants in Interfaces.C. See B.3(41). 
• The types Floating, Long_Floating, Bina ry, Long_Binary, Decimal_Element, and 
COBOL_Character; and the initializations of the variables Ada_To_COBOL and 
COBOL_To_Ada, in Interfaces.COBOL. See B.4(50). 
• The types Fortran_Integer, Real, Double_Precision,  and Character_Set in Interfaces.Fortran. See 
B.5(17). 
• Implementation-defined intrin sic subprograms. See C.1(1/3). 
• This paragraph was deleted.  
• This paragraph was deleted.  
• Any restrictions on a protected procedure or its  containing type when an aspect Attach_handler 
or Interrupt_Handler is specified. See C.3.1(17). 
• Any other forms of interrupt handler supported by the Attach_Handler and Interrupt_Handler 
aspects. See C.3.1(19). 
• This paragraph was deleted.  
• The semantics of pragma Discard_Names. See C.5(7). 
• The result of the Task_Identifica tion.Image attribute. See C.7.1(7). 
• The value of Current_Task when in a protected en try, interrupt handler, or finalization of a task 
attribute. See C.7.1(17/3). 
• This paragraph was deleted.  
• Granularity of locking for Ta sk_Attributes. See C.7.2(16/1). 
• This paragraph was deleted.  
• This paragraph was deleted.  
• The declarations of Any_Prio rity and Priority. See D.1(11). 
• Implementation-defined execu tion resources. See D.1(15). 73.6/2 
73.7/2 
73.8/2 73.9/2 
73.10/2 
74 
75 76 
77 
78 
79/2 
79.1/2 
80/1 
80.1/1 
81/2 
82/2 83/2 
83.1/3 
83.2/3 
84/2 
85 86 
87/2 
88/2 
88.1/1 
89/2 90/2 
91 92 
Ada Reference Manual — 2012 Edition 
M.2   Implementation-Defined Charact eristics 13 December 2012      792 • Whether, on a multiprocessor, a task that is waiting for access to a protected object keeps its 
processor busy. See D.2.1(3). 
• The effect of implementation-defined execution resources on task dispatching. See D.2.1(9/2). 
• This paragraph was deleted.  
• This paragraph was deleted.  
• Implementation defined task disp atching policies. See D.2.2(19). 
• The value of Default_Quantum in Dispatching.Round_Robin. See D.2.5(4). 
• Implementation-defined policy_ identifier s allowed in a pragma  Locking_Policy. See D.3(4). 
• The locking policy if no Locking_Policy pragma applies to any unit of a partition. See D.3(6). 
• Default ceiling priorities. See D.3(10/3). 
• The ceiling of any protected object used internally by the implementation. See D.3(16). 
• Implementation-defined queui ng policies. See D.4(1/3). 
• This paragraph was deleted.  
• Any operations that implicitly require heap storage allocation. See D.7(8). 
• When restriction No_Task_Termination applies to a partition, what happens when a task 
terminates. See D.7(15.1/2). 
• The behavior when restriction Max_Stora ge_At_Blocking is violated. See D.7(17/1). 
• The behavior when restriction Max_Asynchr onous_Select_Nesting is vi olated. See D.7(18/1). 
• The behavior when restriction Ma x_Tasks is violated. See D.7(19). 
• Whether the use of pragma Restrictions results in a reduction in program code or data size or 
execution time. See D.7(20). 
• This paragraph was deleted.  
• This paragraph was deleted.  
• The value of Barrier_Limit'Last in Synchronous_Barriers. See D.10.1(4/3). 
• When an aborted task that is waiting on a Sy nchronous_Barrier is aborted. See D.10.1(13/3). 
• This paragraph was deleted.  
• The processor on which a task with a CPU va lue of a Not_A_Specific_CPU will execute when 
the Ravenscar profile is in effect. See D.13(8). 
• The value of Min_Handler_Ceiling in Execution_Time.Group_Budgets. See D.14.2(7/2). 
• The value of CPU_Range'Last in Sy stem.Multiprocessors. See D.16(4/3). 
• The processor on which the environment task execu tes in the absence of a value for the aspect 
CPU. See D.16(13/3). 
• The means for creating and executing distributed programs. See E(5). 
• Any events that can result in a pa rtition becoming inaccessible. See E.1(7). 
• The scheduling policies, treatment of priorities,  and management of shared resources between 
partitions in certain  cases. See E.1(11). 
• This paragraph was deleted.  93 
94/2 
95/2 96/2 97/2 
97.1/2 
98 
98.1/2 
99 
100 101 
102/2 
103 
103.1/2 
103.2/2 
103.3/2 103.4/2 
104/2 
105/2 
106/2 
106.1/3 106.2/3 
107/2 
107.1/3 
107.2/3 
107.3/3 107.4/3 
108 
109 110 
111/1 
Ada Reference Manual — 2012 Edition 
793      13 December 2012 Implemen tation-Defined Characteristics   M.2 • Whether the execution of the remote subprogr am is immediately aborted as a result of 
cancellation. See E.4(13). 
• The range of type System.RPC.Partition_Id. See E.5(14). 
• This paragraph was deleted.  
• Implementation-defined interfaces in the PCS. See E.5(26). 
• The values of named numbers in the package Decimal. See F.2(7). 
• The value of Max_Picture_Length in th e package Text_IO.Editing See F.3.3(16). 
• The value of Max_Picture_Length in the package Wide_Text_IO.Editing See F.3.4(5). 
• The value of Max_Picture_Length in the p ackage Wide_Wide_Text_IO.Editing See F.3.5(5). 
• The accuracy actually achieved by the complex elementary functions and by other complex 
arithmetic operations. See G.1(1). 
• The sign of a zero result (or a component thereof) from any operator or function in 
Numerics.Generic_Complex_Types, when R eal'Signed_Zeros is True. See G.1.1(53). 
• The sign of a zero result (or a component thereof) from any operator or function in 
Numerics.Generic_Complex_Elementary_Functi ons, when Complex_Types.Real'Signed_Zeros 
is True. See G.1.2(45). 
• Whether the strict mode or the rela xed mode is the default. See G.2(2). 
• The result interval in certain cases of  fixed-to-float conversion. See G.2.1(10). 
• The result of a floating point arithmetic operation in overflow situations, when the 
Machine_Overflows attribute of the re sult type is False. See G.2.1(13). 
• The result interval for division (or exponentia tion by a negative exponent), when the floating 
point hardware implements division as mu ltiplication by a reciprocal. See G.2.1(16). 
• The definition of close result set , which determines the accuracy of certain fixed point 
multiplications and divisions. See G.2.3(5). 
• Conditions on a universal_real  operand of a fixed point multiplication or division for which the 
result shall be in the perfect result set . See G.2.3(22). 
• The result of a fixed point arithmetic ope ration in overflow situations, when the 
Machine_Overflows attribute of the re sult type is False. See G.2.3(27). 
• The result of an elementary function reference in overflow situations, when the 
Machine_Overflows attribute of the re sult type is False. See G.2.4(4). 
• The value of the angle threshold , within which certain elementa ry functions, complex arithmetic 
operations, and complex elementary functions yi eld results conforming to a maximum relative 
error bound. See G.2.4(10). 
• The accuracy of certain elementary functions for parameters beyond the angle threshold. See 
G.2.4(10). 
• The result of a complex arithmetic operation or  complex elementary function reference in 
overflow situations, when the Machine_Overflow s attribute of the corresponding real type is 
False. See G.2.6(5). 
• The accuracy of certain complex arithmetic opera tions and certain complex elementary functions 
for parameters (or components thereof) be yond the angle threshold. See G.2.6(8). 
• The accuracy requirements for the subprograms So lve, Inverse, Determinant, Eigenvalues and 
Eigensystem for type Real_Matrix. See G.3.1(81/2). 112 
112.1/2 
113/2 
114 115 116 117 
117.1/2 
118 
119 120 
121 
122 123 
124 125 126 127 128 129 
130 
131 
132 
132.1/2 
Ada Reference Manual — 2012 Edition 
M.2   Implementation-Defined Charact eristics 13 December 2012      794 • The accuracy requirements for the subprograms So lve, Inverse, Determinant, Eigenvalues and 
Eigensystem for type Comple x_Matrix. See G.3.2(149/2). 
• This paragraph was deleted.  
• This paragraph was deleted.  
• This paragraph was deleted.  
• This paragraph was deleted.  
• Implementation-defined policy_ identifier s allowed in a pragma  Partition_Elaboration_Policy. 
See H.6(4/2). 
M.3 Implementation Advice 
This International Standard some times gives advice about handling cer tain target machine dependences. 
Each Ada implementation must document whether that advice is followed:  
• Program_Error should be raised when an unsuppor ted Specialized Needs Annex feature is used 
at run time. See 1.1.3(20). 
• Implementation-defined extensions to the func tionality of a language-defined library unit should 
be provided by adding children to the library unit. See 1.1.3(21). 
• If a bounded error or erroneous execution is de tected, Program_Error should be raised. See 
1.1.5(12). 
• Implementation-defined pragma s should have no semantic eff ect for error-free programs. See 
2.8(16/3). 
• Implementation-defined pragmas should not make an illegal program legal, unless they complete 
a declaration or configure the library_item s in an environment. See 2.8(19). 
• Long_Integer should be declared in Standard if  the target supports 32-bit arithmetic. No other 
named integer subtypes should be d eclared in Standard. See 3.5.4(28). 
• For a two's complement target, modular types with a binary modulus up to System.Max_Int*2+2 
should be supported. A nonbinary modulus up to  Integer'Last should be supported. See 
3.5.4(29). 
• Program_Error should be raised for the evaluation of S'Pos for an enumeration type, if the value 
of the operand does not correspond to the internal code for any enumeration literal of the type. 
See 3.5.5(8). 
• Long_Float should be declared in Standard if th e target supports 11 or more digits of precision. 
No other named float subtypes should be  declared in Standard. See 3.5.7(17). 
• Multidimensional arrays should be represente d in row-major order, unless the array has 
convention Fortran. See 3.6.2(11/3). 
• Tags.Internal_Tag should return the tag of a ty pe, if one exists, whose innermost master is a 
master of the point of the function call.. See 3.9(26.1/3). 
• A real static expression with a nonformal type that  is not part of a larger static expression should 
be rounded the same as the target system. See 4.9(38.1/2). 
• The value of Duration'Small should be no greater than 100 microseconds. See 9.6(30). 
• The time base for delay_relative_statement s should be monotonic. See 9.6(31). 132.2/2 
133/2 
134/2 135/2 136/2 
136.1/2 
1/2 
2/2 
3/2 4/2 5/2 6/2 7/2 8/2 
9/2 
10/2 
11/2 12/3 13/2 14/2 
15/2 
Ada Reference Manual — 2012 Edition 
795      13 December 2012 Implementation Advice   M.3 • Leap seconds should be supported if the target system supports them. Ot herwise, operations in 
Calendar.Formatting should return  results consistent with no leap seconds. See 9.6.1(89/2). 
• When applied to a generic unit, a program unit pragma that is not a library unit pragma should 
apply to each instance of the generic unit for which there is not an overriding pragma applied directly to the instance. See 10.1.5(10/1). 
• A type declared in a preelaborated package should have the same representation in every 
elaboration of a given version of the package. See 10.2.1(12). 
• Exception_Information should provide informati on useful for debugging, and should include the 
Exception_Name and Exception_M essage. See 11.4.1(19). 
• Exception_Message by default should be short,  provide information useful for debugging, and 
should not include the Excep tion_Name. See 11.4.1(19). 
• Code executed for checks that have been suppressed should be minimized. See 11.5(28). 
• The recommended level of support for all re presentation items should be followed. See 
13.1(28/3). 
• Storage allocated to objects of a packed  type should be minimized. See 13.2(6). 
• The recommended level of support for the Pack  aspect should be followed. See 13.2(9). 
• For an array X, X'Address should point at the fi rst component of the array rather than the array 
bounds. See 13.3(14). 
• The recommended level of support for the Addre ss attribute should be followed. See 13.3(19). 
• For any tagged specific subtype S, S'Class'Alignment should equal S'Alignment. See 13.3(28). 
• The recommended level of support for the Alignm ent attribute should be followed. See 13.3(35). 
• The Size of an array object should not include its bounds. See 13.3(41.1/2). 
• If the Size of a subtype allows for efficient i ndependent addressability, then the Size of most 
objects of the subtype should equal th e Size of the subtype. See 13.3(52). 
• A Size clause on a composite subtype should not a ffect the internal layout of components. See 
13.3(53). 
• The recommended level of support for the Size attribute should be followed. See 13.3(56). 
• The recommended level of support for the Com ponent_Size attribute should be followed. See 
13.3(73). 
• The recommended level of support for 
enumeration_representation_clause s should be 
followed. See 13.4(10). 
• The recommended level of support for record_representation_clause s should be followed. See 
13.5.1(22). 
• If a component is represented using a pointer to the actual data of the component which is 
contiguous with the rest of the object, then the storage place attributes should reflect the place of 
the actual data. If a component is allocated disc ontiguously from the rest of the object, then a 
warning should be generated upon re ference to one of its storage place attributes. See 13.5.2(5). 
• The recommended level of support for the nonde fault bit ordering should be followed. See 
13.5.3(8). 
• Type System.Address should be a private type. See 13.7(37). 
• Operations in System and its children should re flect the target environment; operations that do 
not make sense should raise Program_Error. See 13.7.1(16). 16/2 
17/2 
18/2 
19/2 20/2 21/2 
22/2 
23/2 
24/3 25/2 
26/2 
26.1/3 
27/2 28/2 29/2 
30/2 31/2 
32/2 
33/2 34/2 35/2 
36/2 
37/2 
38/2 
Ada Reference Manual — 2012 Edition 
M.3   Implementation Advice 13 December 2012      796 • Since the Size of an array object generally does not include its bounds, the bounds should not be 
part of the converted data in an inst ance of Unchecked_Conversion. See 13.9(14/2). 
• There should not be unnecessary run-time checks on the result of an Unchecked_Conversion; the 
result should be returned by reference when possible. Restrictions on Unchecked_Conversions 
should be avoided. See 13.9(15). 
• The recommended level of support for Unch ecked_Conversion should be followed. See 
13.9(17). 
• Any cases in which heap storage is dynamically a llocated other than as part of the evaluation of 
an allocator  should be documented. See 13.11(23). 
• A default storage pool for an access-to-consta nt type should not have overhead to support 
deallocation of individual objects. See 13.11(24). 
• Usually, a storage pool for an access discriminant  or access parameter should be created at the 
point of an allocator , and be reclaimed when the designated object becomes inaccessible. For 
other anonymous access types, the pool should be  created at the point where the type is 
elaborated and need not support deallocation of individual objects. See 13.11(25). 
• For a standard storage pool, an instance of Unchecked_Deallocation should actually reclaim the 
storage. See 13.11.2(17). 
• A call on an instance of Unchecked_Deallo cation with a nonnull access value should raise 
Program_Error if the actual access type of the instance is a type for which the Storage_Size has been specified to be zero or is defined by  the language to be zero. See 13.11.2(17.1/3). 
• If not specified, the value of Stream_Size for an  elementary type should be the number of bits 
that corresponds to the minimum number of stream elements required by the first subtype of the 
type, rounded up to the nearest factor or multiple of  the word size that is also a multiple of the 
stream element size. See 13.13.2(1.6/2). 
• The recommended level of support for the Str eam_Size attribute should be followed. See 
13.13.2(1.8/2). 
• If an implementation provides additional named pr edefined integer types, then the names should 
end with “Integer”. If an implementation provi des additional named predefined floating point 
types, then the names should end with “Float”. See A.1(52). 
• Implementation-defined operati ons on Wide_Character, Wide_String, Wide_Wide_Character, 
and Wide_Wide_String should be child units of  Wide_Characters or Wide_Wide_Characters. 
See A.3.1(7/3). 
• The string returned by Wide_Characters.Hand ling.Character_Set_Version should include either 
“10646:” or “Unicode”. See A.3.5(62). 
• Bounded string objects should not be implemented by implicit pointers and dynamic allocation. 
See A.4.4(106). 
• Strings.Hash should be good a hash function, retu rning a wide spread of values for different 
string values, and similar strings should rarely  return the same value. See A.4.9(12/2). 
• If an implementation supports other string encodi ng schemes, a child of Ada.Strings similar to 
UTF_Encoding should be de fined. See A.4.11(107/3). 
• Any storage associated with an object of type  Generator of the random number packages should 
be reclaimed on exit from the scope of the object. See A.5.2(46). 
• Each value of Initiator passed to Reset for the random number packages should initiate a distinct 
sequence of random numbers, or, if that is not possi ble, be at least a rapidly varying function of 
the initiator value. See A.5.2(47). 39/2 
40/2 
41/2 
42/2 43/2 44/2 
45/2 
45.1/3 
46/2 
47/2 
48/2 
49/2 
49.1/3 
50/2 51/2 
51.1/3 
52/2 53/2 
Ada Reference Manual — 2012 Edition 
797      13 December 2012 Implementation Advice   M.3 • Get_Immediate should be implemented with  unbuffered input; input should be available 
immediately; line-editing should be disabled. See A.10.7(23). 
• Package Directories.Information should be provide d to retrieve other information about a file. 
See A.16(124/2). 
• Directories.Start_Search and Directories. Search should raise Name_Error for malformed 
patterns. See A.16(125). 
• Directories.Rename should be  supported at least when both New_Name and Old_Name are 
simple names and New_ Name does not identify an existing external file. See A.16(126/2). 
• Directories.Hierarchical_File_N ames should be provided for syst ems with hierarchical file 
naming, and should not be provided on other systems. See A.16.1(36/3). 
• If the execution environment supports subprocesses,  the current environment variables should be 
used to initialize the environment vari ables of a subprocess. See A.17(32/2). 
• Changes to the environment variables made outside the control of Environment_Variables 
should be reflected immediately. See A.17(33/2). 
• Containers.Hash_Type'Modulus should be at least 2**32. Containers.Count_Type'Last should 
be at least 2**31–1. See A.18.1(8/2). 
• The worst-case time complexity of El ement for Containers.Vector should be O(log N). See 
A.18.2(256/2). 
• The worst-case time complexity of Append with Count = 1 when N is less than the capacity for 
Containers.Vector should be O(log N). See A.18.2(257/2). 
• The worst-case time complexity of Prepend with Count = 1 and Delete_First with Count=1 for 
Containers.Vectors should be O(N log N). See A.18.2(258/2). 
• The worst-case time complexity of a call on procedure Sort of an instance of 
Containers.Vectors.Generic_Sorting should be O(N**2), and the average time complexity 
should be better than O(N**2). See A.18.2(259/2). 
• Containers.Vectors.Generic_Sor ting.Sort and Containers.Vector s.Generic_Sorting.Merge should 
minimize copying of elements. See A.18.2(260/2). 
• Containers.Vectors.Move should not copy elem ents, and should minimize copying of internal 
data structures. See A.18.2(261/2). 
• If an exception is propagated from a vector operation, no storage should be lost, nor any 
elements removed from a vector unless speci fied by the operation. See A.18.2(262/2). 
• The worst-case time complexity of  Element, Insert with Count=1 , and Delete with Count=1 for 
Containers.Doubly_Linked_Lists should be O(log N). See A.18.3(160/2). 
• A call on procedure Sort of an instance of  Containers.Doubly_Linke d_Lists.Generic_Sorting 
should have an average time complexity better than O(N**2) and worst case no worse than 
O(N**2). See A.18.3(161/2). 
• Containers.Doubly_Linked_Lists.Move should not copy elements, and should minimize copying 
of internal data structures. See A.18.3(162/2). 
• If an exception is propagated from a list operation,  no storage should be lost, nor any elements 
removed from a list unless specified by the operation. See A.18.3(163/2). 
• Move for a map should not copy elements, a nd should minimize copying of internal data 
structures. See A.18.4(83/2). 54/2 
55/2 56/3 57/2 
57.1/3 
58/2 59/2 60/2 61/2 62/2 63/2 64/2 
65/2 
66/2 67/2 68/2 69/2 
70/2 
71/2 72/2 
Ada Reference Manual — 2012 Edition 
M.3   Implementation Advice 13 December 2012      798 • If an exception is propagated from a map operation,  no storage should be lost, nor any elements 
removed from a map unless specified by the operation. See A.18.4(84/2). 
• The average time complexity of Element, Insert, Include, Replace, Delete, Exclude and Find 
operations that take a key parameter for Containers.Hashed_Maps should be O(log N). The 
average time complexity of the subprograms of Containers.Hashed_Maps that take a cursor 
parameter should be O(1). The average time complexity of 
Containers.Hashed_Maps.Rese rve_Capacity should be O(N). See A.18.5(62/2). 
• The worst-case time complexity of Element, Insert, Include, Replace, Delete, Exclude and Find 
operations that take a key parameter for Containers.Ordered_Maps should be O((log N)**2) or 
better. The worst-case time comp lexity of the subprograms of Containers.Ordered_Maps that 
take a cursor parameter should be O(1). See A.18.6(95/2). 
• Move for sets should not copy elements, a nd should minimize copying of internal data 
structures. See A.18.7(104/2). 
• If an exception is propagated from a set operation,  no storage should be lost, nor any elements 
removed from a set unless specified by the operation. See A.18.7(105/2). 
• The average time complexity of the Insert, Include, Replace, Delete, Exclude and Find 
operations of Containers.Hashed_Sets that  take an element parameter should be O(log N). The 
average time complexity of the subprograms of Containers.Hashed_Sets that take a cursor 
parameter should be O(1). The average time complexity of Containers.Hashed_Sets.-
Reserve_Capacity should be O(N). See A.18.8(88/2). 
• The worst-case time complexity of the Insert, Include, Replace, Delete, Exclude and Find 
operations of Containers.Ordered_Sets that  take an element parameter should be O((log N)**2). 
The worst-case time complexity of the subprograms of Containe rs.Ordered_Sets that take a 
cursor parameter should be O(1). See A.18.9(116/2). 
• The worst-case time complexity of the Element,  Parent, First_Child, Last_Child, Next_Sibling, 
Previous_Sibling, Insert_Child with  Count=1, and Delete operations of 
Containers.Multiway_Trees should be O(log N). See A.18.10(231/3). 
• Containers.Multiway_Trees.Move  should not copy elements, and should minimize copying of 
internal data structures. See A.18.10(232/3). 
• If an exception is propagated from a tree operation,  no storage should be lost, nor any elements 
removed from a tree unless specified by the operation. See A.18.10(233/3). 
• Containers.Indefinite_Holders.Move should not copy the element, and should minimize copying 
of internal data structures. See A.18.18(73/3). 
• If an exception is propagated from a holder opera tion, no storage should be lost, nor should the 
element be removed from a holder containe r unless specified by the operation. See 
A.18.18(74/3). 
• Bounded vector objects should be implemented w ithout implicit pointers or dynamic allocation. 
See A.18.19(16/3). 
• The implementation advice for procedure Move  to minimize copying does not apply to bounded 
vectors. See A.18.19(17/3). 
• Bounded list objects should be implemented without  implicit pointers or dynamic allocation. See 
A.18.20(19/3). 
• The implementation advice for procedure Move  to minimize copying does not apply to bounded 
lists. See A.18.20(20/3). 73/2 
74/2 
75/2 
76/2 
77/2 78/2 
79/2 
79.1/3 
79.2/3 
79.3/3 79.4/3 79.5/3 
79.6/3 
79.7/3 79.8/3 79.9/3 
Ada Reference Manual — 2012 Edition 
799      13 December 2012 Implementation Advice   M.3 • Bounded hashed map objects should be implem ented without implicit pointers or dynamic 
allocation. See A.18.21(21/3). 
• The implementation advice for procedure Move  to minimize copying does not apply to bounded 
hashed maps. See A.18.21(22/3). 
• Bounded ordered map objects should be implem ented without implicit pointers or dynamic 
allocation. See A.18.22(18/3). 
• The implementation advice for procedure Move  to minimize copying does not apply to bounded 
ordered maps. See A.18.22(19/3). 
• Bounded hashed set objects should be implem ented without implicit pointers or dynamic 
allocation. See A.18.23(20/3). 
• The implementation advice for procedure Move  to minimize copying does not apply to bounded 
hashed sets. See A.18.23(21/3). 
• Bounded ordered set objects should be implem ented without implicit pointers or dynamic 
allocation. See A.18.24(17/3). 
• The implementation advice for procedure Move  to minimize copying does not apply to bounded 
ordered sets. See A.18.24(18/3). 
• Bounded tree objects should be implemented wit hout implicit pointers or dynamic allocation. 
See A.18.25(19/3). 
• The implementation advice for procedure Move  to minimize copying does not apply to bounded 
trees. See A.18.25(20/3). 
• Containers.Generic_Array_Sort and Containe rs.Generic_Constrained_Array_Sort should have 
an average time complexity better than O(N**2) and worst case no worse than O(N**2). See 
A.18.26(10/2). 
• Containers.Generic_Array_Sort and Contai ners.Generic_Constrained_Array_Sort should 
minimize copying of elements. See A.18.26(11/2). 
• Containers.Generic_Sort should have an  average time complexity better than O(N**2) and worst 
case no worse than O(N**2). See A.18.26(12/3). 
• Containers.Generic_Sort should minimize calls to the generic formal Swap. See A.18.26(13/3). 
• Bounded queue objects should be implemented wit hout implicit pointers or dynamic allocation. 
See A.18.29(13/3). 
• Bounded priority queue objects should be impl emented without implicit pointers or dynamic 
allocation. See A.18.31(14/3). 
• If  Export is supported for a language, the main program should be able to be written in that 
language. Subprograms named "adain it" and "adafinal" should be provided for elaboration and 
finalization of the environment task. See B.1(39/3). 
• Automatic elaboration of preelaborated packag es should be provided when specifying the Export 
aspect as True is s upported. See B.1(40/3). 
• For each supported convention L other than Intrinsic, specifying the aspects Import and Export 
should be supported for objects of L-compatible types and for subprograms, and aspect 
Convention should be supported for L-eligible types and for subprograms. See B.1(41/3). 
• If an interface to C, COBOL, or Fortran is provided, the corresponding package or packages 
described in Annex B, “Interface to Other Langua ges” should also be provided. See B.2(13/3). 79.10/3 
79.11/3 79.12/3 79.13/3 79.14/3 79.15/3 79.16/3 79.17/3 79.18/3 79.19/3 
80/2 
81/2 
81.1/3 81.2/3 
81.3/3 
81.4/3 
82/3 
83/3 
84/3 
85/2 
Ada Reference Manual — 2012 Edition 
M.3   Implementation Advice 13 December 2012      800 • The constants nul, wide_nul, char16_nul, and char 32_nul in package Interfaces.C should have a 
representation of zero. See B.3(62.5/3). 
• If C interfacing is supported, the interface correspondences between Ada and C should be 
supported. See B.3(71). 
• If COBOL interfacing is supported, the inte rface correspondences be tween Ada and COBOL 
should be supported. See B.4(98). 
• If Fortran interfacing is supported, the inte rface correspondences between Ada and Fortran 
should be supported. See B.5(26). 
• The machine code or intrinsics support should allow access to all operations normally available 
to assembly language programmers for the target environment. See C.1(3). 
• Interface to assembler should be supported; the de fault assembler should be associated with the 
convention identifier Assembler. See C.1(4/3). 
• If an entity is exported to assembly language, then the implementation should allocate it at an 
addressable location even if not otherwise refe renced from the Ada code. A call to a machine 
code or assembler subprogram should be treated as if it could read or update every object that is 
specified as exported. See C.1(5). 
• Little or no overhead should be associated with  calling intrinsic and machine-code subprograms. 
See C.1(10). 
• Intrinsic subprograms should be provided to acce ss any machine operations that provide special 
capabilities or efficiency not normally available. See C.1(16). 
• If the Ceiling_Locking policy is not in effect a nd the target system allows for finer-grained 
control of interrupt blocking, a means for the a pplication to specify which interrupts are to be 
blocked during protected actions s hould be provided. See C.3(28/2). 
• Interrupt handlers should be called dir ectly by the hardware. See C.3.1(20). 
• Violations of any implementati on-defined restrictions on interr upt handlers should be detected 
before run time. See C.3.1(21). 
• If implementation-defined forms of interrupt ha ndler procedures are supported, then for each 
such form of a handler, a type analogous to Para meterless_Handler should be specified in a child 
package of Interrupts, with the same operations as in the predefined package Interrupts. See 
C.3.2(25). 
• Preelaborated packages should be implemented su ch that little or no code is executed at run time 
for the elaboration of entities. See C.4(14). 
• If pragma  Discard_Names applies to an entity, then  the amount of storage used for storing 
names associated with that entity  should be reduced. See C.5(8). 
• A load or store of a volatile object whose size is a multiple of System.Storage_Unit and whose 
alignment is nonzero, should be implemented by  accessing exactly the bits of the object and no 
others. See C.6(22/2). 
• A load or store of an atomic object should be im plemented by a single load or store instruction. 
See C.6(23/2). 
• If the target domain requires deterministic memory  use at run time, storage for task attributes 
should be pre-allocated statically and the num ber of attributes pre-allocated should be 
documented. See C.7.2(30). 
• Finalization of task attributes and reclamation of associated storage should be performed as soon 
as possible after task termination. See C.7.2(30.1/2). 86/2 
87/2 88/2 89/2 90/2 91/2 92/2 
93/2 
94/2 95/2 
96/2 
97/2 
98/2 
99/2 
100/2 101/2 
102/2 
103/2 
104/2 
Ada Reference Manual — 2012 Edition 
801      13 December 2012 Implementation Advice   M.3 • Names that end with “_Locking” should be us ed for implementation-defined locking policies. 
See D.3(17). 
• Names that end with “_Queuing” should be us ed for implementation-defined queuing policies. 
See D.4(16). 
• The abort_statement  should not require the task executing the statement to block. See D.6(9). 
• On a multi-processor, the delay associated with  aborting a task on another processor should be 
bounded. See D.6(10). 
• When feasible, specified restrictions should be used to produce a more e fficient implementation. 
See D.7(21). 
• When appropriate, mechanisms to change the value of Tick should be provided. See D.8(47). 
• Calendar.Clock and Real_Time. Clock should be transformations of the same time base. See 
D.8(48). 
• The “best” time base which exis ts in the underlying system should be available to the application 
through Real_Time.Clock. See D.8(49). 
• On a multiprocessor system, each processor should have a separate and disjoint ready queue. See 
D.13(9). 
• When appropriate, implementations should provi de configuration mechanisms to change the 
value of Execution_Time.CP U_Tick. See D.14(29/2). 
• For a timing event, the handler should be execu ted directly by the real-time clock interrupt 
mechanism. See D.15(25). 
• Each dispatching domain should have separate  and disjoint ready queues. See D.16.1(31). 
• The PCS should allow for multiple tasks to call the RPC-receiver. See E.5(28). 
• The System.RPC.Write operation should raise Stor age_Error if it runs out of space when writing 
an item. See E.5(29). 
• If COBOL (respectively, C) is supported in the target environment, then interfacing to COBOL 
(respectively, C) should be supported as  specified in Annex B. See F(7/3). 
• Packed decimal should be used as the in ternal representation for objects of subtype S when 
S'Machine_Radix = 10. See F.1(2). 
• If Fortran (respectively, C) is supported in the target environment, then interfacing to Fortran 
(respectively, C) should be supported as  specified in Annex B. See G(7/3). 
• Mixed real and complex operations (as well as  pure-imaginary and complex operations) should 
not be performed by converting the real (re sp. pure-imaginary) operand to complex. See 
G.1.1(56). 
• If Real'Signed_Zeros is True for Numerics.Gen eric_Complex_Types, a rational treatment of the 
signs of zero results and result compone nts should be provided. See G.1.1(58). 
• If Complex_Types.Real'Signed_Zeros is True for Numerics.Generic_Complex_Elementary_-
Functions, a rational treatment of the signs of  zero results and result components should be 
provided. See G.1.2(49). 
• For elementary functions, the forward trigonometric functions w ithout a Cycle parameter should 
not be implemented by calling the corresponding ve rsion with a Cycle parameter. Log without a 
Base parameter should not be implemented by  calling Log with a Base parameter. See 
G.2.4(19). 105/2 
106/2 107/2 
108/2 
109/2 110/2 
111/2 
112/2 
112.1/3 
113/2 114/2 
114.1/3 
115/2 116/2 
117/2 118/2 119/2 120/2 
121/3 
122/3 
123/2 
Ada Reference Manual — 2012 Edition 
M.3   Implementation Advice 13 December 2012      802 • For complex arithmetic, the Compose_From_Pol ar function without a Cycle parameter should 
not be implemented by calling Compose_From_Polar with a Cy cle parameter. See G.2.6(15). 
• Solve and Inverse for Numerics.Generic_Real_A rrays should be implemen ted using established 
techniques such as LU decomposition and the re sult should be refined by an iteration on the 
residuals. See G.3.1(88/3). 
• The equality operator should be used to test th at a matrix in Numerics .Generic_Real_Arrays is 
symmetric. See G.3.1(90/2). 
• An implementation should minimize the circ umstances under which the algorithm used for 
Numerics.Generic_Real_Arrays.Eigenvalues a nd Numerics.Generic_Real_Arrays.Eigensystem 
fails to converge. See G.3.1(91/3). 
• Solve and Inverse for Numerics.Generic_C omplex_Arrays should be  implemented using 
established techniques and the result should be refined by an iteration on the residuals. See 
G.3.2(158/3). 
• The equality and negation operators should be us ed to test that a matrix is Hermitian. See 
G.3.2(160/2). 
• An implementation should minimize the circ umstances under which the algorithm used for 
Numerics.Generic_Comple x_Arrays.Eigenvalues and 
Numerics.Generic_Complex_Arrays.Eigensystem  fails to converge. See G.3.2(160.1/3). 
• Mixed real and complex operations should not be  performed by converting the real operand to 
complex. See G.3.2(161/2). 
• The information produced by pragma  Reviewable should be provided in both a human-readable 
and machine-readable form, and the latter form should be documen ted. See H.3.1(19). 
• Object code listings should be provided both in a symbolic format and in  a numeric format. See 
H.3.1(20). 
• If the partition elaboration policy is Sequential and the Environment task becomes permanently 
blocked during elaboration, then the partition s hould be immediately terminated. See H.6(15/3). 124/2 
125/2 
126/2 
126.1/3 
127/2 
128/2 
128.1/3 
129/2 
130/2 131/2 132/3 
Ada Reference Manual — 2012 Edition 
803      13 December 2012 Glossary   Annex N Annex N 
(informative)  
Glossary 
This Annex contains informal descri ptions of some of the terms used in this International Standard. The 
index provides references to more formal definitions of all of the terms used in this International Standard. 
Abstract type.  An abstract type is a tagged type intended fo r use as an ancestor of other types, but which 
is not allowed to have objects of its own. 
Access type.  An access type has values that designate alia sed objects. Access types correspond to “pointer 
types” or “reference types” in some other languages. 
Aliased.  An aliased view of an object is one that can be designated by an access value. Objects allocated 
by allocators are aliased. Objects can also be exp licitly declared as aliased with the reserved word aliased . 
The Access attribute can be used to create an access value designating an aliased object. 
Ancestor.  An ancestor of a type is the type itself or, in  the case of a type derived from other types, its 
parent type or one of its progenitor types or one of their ancestors. Note that ancestor and descendant are 
inverse relationships. 
Array type.  An array type is a composite  type whose components are all of the same type. Components 
are selected by indexing. 
Aspect.  An aspect is a specifiable property of an  entity. An aspect may be specified by an 
aspect_specification  on the declaration of the entity. Some aspects may be queried via attributes. 
Assertion.  An assertion is a boolean expression that appears in any of the following: a pragma  Assert, a 
predicate, a precondition, a postcondition, an invariant, a constraint, or a null exclusion. An assertion is 
expected to be True at run time at certain specified places. 
Category (of types).  A category of types is a set of types with  one or more common properties, such as 
primitive operations. A category of types that is  closed under derivation is also known as a class . 
Character type.  A character type is an enumeration type whose values include characters. 
Class (of types).  A class is a set of types that is closed unde r derivation, which means that if a given type 
is in the class, then all types derived from that type ar e also in the class. The set of types of a class share 
common properties, such as their primitive operations. 
Compilation unit.  The text of a program can be submitted to the compiler in one or more compilation s. 
Each compilation  is a succession of compilation_unit s. A compilation_unit  contains either the declaration, 
the body, or a renaming of a program unit. 
Composite type.  A composite type may have components. 
Construct.  A construct  is a piece of text (explicit or implicit) that is an instance of a syntactic category 
defined under “Syntax”. 
Container.  A container is an object that contain other obj ects all of the same type, which could be class-
wide. Several predefined container types are provide d by the children of package Ada.Containers (see 
A.18.1). 1/2 
1.1/2 
2 3 
3.1/2 
4 
4.1/3 4.2/3 
4.3/2 
5 
6/2 
7 
8/2 
9 
9.1/3 
Ada Reference Manual — 2012 Edition 
Annex N    Glossary 13 December 2012      804 Controlled type.  A controlled type supports user-defined assi gnment and finalization. Objects are always 
finalized before being destroyed. 
Declaration.  A declaration  is a language construct that associates  a name with (a view of) an entity. A 
declaration may appear explicitly in the program text (an explicit  declaration), or may be supposed to 
occur at a given place in the text as a consequence of the semantics of another construct (an implicit  
declaration). 
This paragraph was deleted.   
Derived type.  A derived type is a type defined in terms of one or more other types given in a derived type 
definition. The first of those types is the parent ty pe of the derived type and any others are progenitor 
types. Each class containing the parent type or a progenitor type also contains the derived type. The 
derived type inherits properties such as com ponents and primitive operations from the parent and 
progenitors. A type together with the types derived fro m it (directly or indirectly) form a derivation class. 
Descendant.  A type is a descendant of itself, its parent a nd progenitor types, and their ancestors. Note that 
descendant and ancestor ar e inverse relationships. 
Discrete type.  A discrete type is either an integer type or an enumeration type. Discrete types may be 
used, for example, in case_statement s and as array indices. 
Discriminant.  A discriminant is a parameter for a composite  type. It can control, for example, the bounds 
of a component of the type if the co mponent is an array. A di scriminant for a task type can be used to pass 
data to a task of the type upon creation. 
Elaboration.  The process by which a declaration achieves its run-time effect is called elaboration. 
Elaboration is one of the forms of execution. 
Elementary type.  An elementary type does not have components. 
Enumeration type.  An enumeration type is defined by an e numeration of its values, which may be named 
by identifiers or character literals. 
Evaluation.  The process by which an expression achieve s its run-time effect is called evaluation. 
Evaluation is one of the forms of execution. 
Exception.  An exception  represents a kind of exceptional situation; an occurrence of such a situation (at 
run time) is called an exception occurrence . To raise  an exception is to abandon normal program 
execution so as to draw attention to the fact that  the corresponding situation has arisen. Performing some 
actions in response to the aris ing of an exception is called handling  the exception.  
Execution.  The process by which a construct achieves its run-time effect is called execution . Execution of 
a declaration is also called elaboration . Execution of an expression is also called evaluation . 
Function.  A function is a form of subprogram that retu rns a result and can be called as part of an 
expression. 
Generic unit.  A generic unit is a template for a (nongeneric) program unit; the template can be 
parameterized by objects, types, s ubprograms, and packages. An instance of a generic unit is created by a 
generic_instantiation . The rules of the language are enforced when a generic unit is compiled, using a 
generic contract model; additional checks are performed  upon instantiation to verify the contract is met. 
That is, the declaration of a generic unit represen ts a contract between the body of the generic and 
instances of the generic. Generic units can be used to perform the role that macros sometimes play in other 
languages. 10 
11 
12/2 
13/2 
13.1/2 
14 
15/2 
15.1/2 
16 
17 
17.1/2 
18 
19 
19.1/2 
20 
Ada Reference Manual — 2012 Edition 
805      13 December 2012 Glossary   Annex N Incomplete type.  An incomplete type gives a view of a type that reveals only some of its properties. The 
remaining properties are provided by the full view gi ven elsewhere. Incomplete types can be used for 
defining recursive data structures. 
Indexable container type.  An indexable container type is one that  has user-defined behavior for indexing, 
via the Constant_Indexing or Variable_Indexing aspects. 
Integer type.  Integer types comprise the signed integer type s and the modular types. A signed integer type 
has a base range that includes bot h positive and negative numbers, and has operations that may raise an 
exception when the result is outside the base range. A modular type has a base range whose lower bound is 
zero, and has operations with “wra paround” semantics. Modular types subsume what are called “unsigned 
types” in some other languages. 
Interface type.  An interface type is a form of abstract ta gged type which has no co mponents or concrete 
operations except possibly null procedures. Interface types are used for composing other interfaces and tagged types and thereby provide multiple inheritance. Only an interface type can be used as a progenitor 
of another type. 
Invariant.  A invariant is an assertion that is expected to  be True for all objects of a given private type 
when viewed from outside the defining package. 
Iterable container type.  An iterable container type is one that ha s user-defined behavior for iteration, via 
the Default_Iterator and Iterator_Element aspects. 
Iterator.  An iterator is a construct that is used to loop ove r the elements of an array or container. Iterators 
may be user defined, and may perform arbitrary computations to access elements from a container. 
Library unit.  A library unit is a separately compiled program  unit, and is always a package, subprogram, 
or generic unit. Library units may have other (logica lly nested) library units as children, and may have 
other program units physically nested within them. A root library unit, together with its children and 
grandchildren and so on, form a subsystem . 
Limited type.  A limited type is a type for which copying (such as in an 
assignment_statement ) is not 
allowed. A nonlimited type is a type for which copying is allowed. 
Object.  An object is either a constant or a variable. An object contains a value. An object is created by an 
object_declaration  or by an allocator . A formal parameter is (a view of) an object. A subcomponent of an 
object is an object. 
Overriding operation.  An overriding operation is one that re places an inherited primitive operation. 
Operations may be marked explicitly as overriding or not overriding. 
Package.  Packages are program units that  allow the specification of groups of logically related entities. 
Typically, a package contains the declaration of a type  (often a private type or private extension) along 
with the declarations of primitive subprograms of the type, which can be called from outside the package, 
while their inner workings rema in hidden from outside users. 
Parent.  The parent of a derived type is the first type gi ven in the definition of the derived type. The parent 
can be almost any kind of type, including an interface type. 
Partition.  A partition  is a part of a program. Each partition consis ts of a set of library units. Each partition 
may run in a separate address space, possibly on a se parate computer. A program may contain just one 
partition. A distributed program typically contains multiple partitions, which can execute concurrently. 20.1/2 
20.2/3 
21 
21.1/2 
21.2/3 
21.3/3 21.4/3 
22 
23/2 
24 
24.1/2 
25 
25.1/2 
26 
Ada Reference Manual — 2012 Edition 
Annex N    Glossary 13 December 2012      806 Postcondition.  A postcondition is an assertion that is exp ected to be True when a given subprogram 
returns normally. 
Pragma.  A pragma is a compiler directive. There are langua ge-defined pragmas that give instructions for 
optimization, listing control, etc. An implementa tion may support additional (implementation-defined) 
pragmas. 
Precondition.  A precondition is an assertion that is expect ed to be True when a given subprogram is 
called. 
Predicate.  A predicate is an assertion that is expected to be True for all objects of a given subtype. 
Primitive operations.  The primitive operations of a type ar e the operations (such as subprograms) 
declared together with the type decl aration. They are inherited by other types in the same class of types. 
For a tagged type, the primitive subprograms are dispatching subprograms, providing run-time polymorphism. A dispatching subprogram may be called with statically tagged operands, in which case the 
subprogram body invoked is determined  at compile time. Alternatively,  a dispatching subprogram may be 
called using a dispatching call, in which case the subprogram body invoked is de termined at run time. 
Private extension.  A private extension is a type that extends  another type, with the additional properties 
hidden from its clients. 
Private type.  A private type gives a view of a type that re veals only some of its properties. The remaining 
properties are provided by the full view given else where. Private types can be used for defining 
abstractions that hide unnecessa ry details from their clients. 
Procedure.  A procedure is a form of subprogram that does not return a result and can only be called by a 
statement . 
Progenitor.  A progenitor of a derived type is one of the ty pes given in the definition of the derived type 
other than the first. A progenitor is always an interface type. Interfaces, tasks, and protected types may also have progenitors. 
Program.  A program  is a set of partitions , each of which may execute in a separate address space, 
possibly on a separate computer. A partiti on consists of a set of library units. 
Program unit.  A program unit  is either a package, a task unit, a protected unit, a protected entry, a 
generic unit, or an explicitly declared subprogram ot her than an enumeration literal. Certain kinds of 
program units can be separately compiled. Alternativel y, they can appear physically nested within other 
program units. 
Protected type.  A protected type is a composite type whose components are accessible only through one 
of its protected operations which synchr onize concurrent access by multiple tasks. 
Real type.  A real type has values that are approximations  of the real numbers. Floating point and fixed 
point types are real types. 
Record extension.  A record extension is a type that ex tends another type by adding additional 
components. 
Record type.  A record type is a composite type consisting of zero or more  named components, possibly of 
different types. 
Reference type.  A reference type is one that has user-defined behavior for “. all”, defined by the 
Implicit_Dereference aspect. 26.1/3 
27 
27.1/3 
27.2/3 
28 
29/2 
30/2 
30.1/2 
30.2/2 
31 
32 
33/2 
34 35 36 
36.1/3 
Ada Reference Manual — 2012 Edition 
807      13 December 2012 Glossary   Annex N Renaming.  A renaming_declaration  is a declaration that does not defi ne a new entity, but instead defines 
a view of an existing entity. 
Scalar type.  A scalar type is either a discrete type or a real type. 
Storage pool.  Each access-to-object type has an associated storage pool object. The storage for an object 
created by an allocator  comes from the storage pool of the type of the allocator . Some storage pools may 
be partitioned into subpools in order to support finer-grained storage management. 
Stream.  A stream is a sequence of elemen ts that can be used, along with th e stream-oriented attributes, to 
support marshalling and unmarshalling of values of most types. 
Subprogram.  A subprogram is a section of a program that can be executed in various contexts. It is 
invoked by a subprogram call that may qualify the effect of the subprogram through the passing of 
parameters. There are two forms of subprograms: func tions, which return values, and procedures, which 
do not. 
Subtype.  A subtype is a type together with optional c onstraints, null exclusions, and predicates, which 
constrain the values of the subtype to  satisfy certain conditions. The values of a subtype are a subset of the 
values of its type. 
Synchronized.  A synchronized entity is one that will work safely with multiple tasks at one time. A 
synchronized interface can be an ancestor of a task or a protected type. Such a task or protected type is 
called a synchronized tagged type. 
Tagged type.  The objects of a tagged type have a run-time type  tag, which indicates the specific type with 
which the object was originally created. An operand of a class-wide tagged type can be used in a 
dispatching call; the tag indicates which subprogram body to invoke. Nondispatching calls, in which the 
subprogram body to invoke is determined at compile  time, are also allowed. Tagged types may be 
extended with additional components. 
Task type.  A task type is a composite type used to re present active entities which execute concurrently 
and which can communicate via queued task entries. The top-level task of a partition is called the 
environment task. 
Type.  Each object has a type. A type has an associated set of values, and a set of primitive operations  
which implement the fundamental aspects of  its semantics. Types are grouped into categories . Most 
language-defined categories of types are also classes  of types. 
View.  A view of an entity reveals some or all of the properties of the entity. A single entity may have 
multiple views. 36.2/2 
37 
37.1/3 
37.2/3 
37.3/2 
38/3 
38.1/2 
39 
40/2 
41/2 
42/2 

Ada Reference Manual — 2012 Edition 
809      13 December 2012 Syntax Summary   Annex P Annex P 
(informative)  
Syntax Summary 
This Annex summarizes the complete syntax of the language. See 1.1.4 for a description of the notation 
used. 
2.3: 
identifier ::=   
   identifier_start  {identifier_start  | identifier_extend } 
2.3: 
identifier_start ::=   
     letter_uppercase  
   | letter_lowercase  
   | letter_titlecase  
   | letter_modifier  
   | letter_other  
   | number_letter  
2.3: 
identifier_extend ::=   
     mark_non_spacing  
   | mark_spacing_combining  
   | number_decimal  
   | punctuation_connector  
2.4: 
numeric_literal ::=  decimal_literal  | based_literal  
2.4.1: 
decimal_literal ::=  numeral  [.numeral ] [exponent ] 
2.4.1: 
numeral ::=  digit {[underline ] digit} 
2.4.1: 
exponent ::=  E [+] numeral  | E – numeral  
2.4.1: 
digit ::=  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
2.4.2: 
based_literal ::=   
   base  # based_numeral  [.based_numeral ] # [exponent ] 
2.4.2: 
base ::=  numeral  
2.4.2: 
based_numeral ::=   
   extended_digit  {[underline ] extended_digit } 
2.4.2: 
extended_digit ::=  digit | A | B | C | D | E | F 
2.5: 
character_literal ::=  'graphic_character ' 
2.6: 
string_literal ::=  "{string_element }" 
2.6: 
string_element ::=  "" | non_quotation_mark_ graphic_character  
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      810 2.7: 
comment ::=  --{non_end_of_line_ character } 
2.8: 
pragma ::=   
   pragma  identifier  [(pragma_argument_association  {, pragma_argument_association })]; 
2.8: 
pragma_argument_association ::=   
     [pragma_argument_ identifier  =>] name  
   | [pragma_argument_ identifier  =>] expression  
   | pragma_argument_ aspect_mark  =>  name  
   | pragma_argument_ aspect_mark  =>  expression  
3.1: 
basic_declaration ::=   
     type_declaration  | subtype_declaration  
   | object_declaration  | number_declaration  
   | subprogram_declaration  | abstract_subprogram_declaration  
   | null_procedure_declaration  | expression_function_declaration  
   | package_declaration  | renaming_declaration  
   | exception_declaration  | generic_declaration  
   | generic_instantiation  
3.1: 
defining_identifier ::=  identifier  
3.2.1: 
type_declaration ::=   full_type_declaration  
   | incomplete_type_declaration  
   | private_type_declaration  
   | private_extension_declaration  
3.2.1: 
full_type_declaration ::=   
     type defining_identifier  [known_discriminant_part ] is type_definition  
        [ aspect_specification ]; 
   | task_type_declaration  
   | protected_type_declaration  
3.2.1: 
type_definition ::=   
     enumeration_type_definition  | integer_type_definition  
   | real_type_definition  | array_type_definition  
   | record_type_definition  | access_type_definition  
   | derived_type_definition  | interface_type_definition  
3.2.2: 
subtype_declaration ::=   
   subtype  defining_identifier  is subtype_indication  
        [ aspect_specification ]; 
3.2.2: 
subtype_indication ::=   [null_exclusion ] subtype_mark  [constraint ] 
3.2.2: 
subtype_mark ::=  subtype_ name  
3.2.2: 
constraint ::=  scalar_constraint  | composite_constraint  
3.2.2: 
scalar_constraint ::=   
     range_constraint  | digits_constraint  | delta_constraint  
3.2.2: 
Ada Reference Manual — 2012 Edition 
811      13 December 2012 Syntax Summary   Annex P composite_constraint ::=   
     index_constraint  | discriminant_constraint  
3.3.1: 
object_declaration ::=   
    defining_identifier_list  : [aliased ] [constant ] subtype_indication  [:= expression ] 
        [ aspect_specification ]; 
  | defining_identifier_list  : [aliased ] [constant ] access_definition  [:= expression ] 
        [ aspect_specification ]; 
  | defining_identifier_list  : [aliased ] [constant ] array_type_definition  [:= expression ] 
        [ aspect_specification ]; 
  | single_task_declaration  
  | single_protected_declaration  
3.3.1: 
defining_identifier_list ::=   
  defining_identifier  {, defining_identifier } 
3.3.2: 
number_declaration ::=   
     defining_identifier_list  : constant  := static_ expression ; 
3.4: 
derived_type_definition ::=   
    [abstract ] [limited ] new parent_ subtype_indication  [[and interface_list ] record_extension_part ] 
3.5: 
range_constraint ::=   range  range  
3.5: 
range ::=   range_attribute_reference  
   | simple_expression  .. simple_expression  
3.5.1: 
enumeration_type_definition ::=   
   (enumeration_literal _specification  {, enumeration_literal _specification }) 
3.5.1: 
enumeration_literal _specification ::=   defining_identifier  | defining_character_literal  
3.5.1: 
defining_character_literal ::=  character_literal  
3.5.4: 
integer_type_definition ::=  signed_integer_type_definition  | modular_type_definition  
3.5.4: 
signed_integer_type_definition ::=  range  static_ simple_expression  .. static_ simple_expression  
3.5.4: 
modular_type_definition ::=  mod  static_ expression  
3.5.6: 
real_type_definition ::=   
   floating_point_definition  | fixed_point_definition  
3.5.7: 
floating_point_definition ::=   
  digits  static_ expression  [real_range_specification ] 
3.5.7: 
real_range_specification ::=   
  range  static_ simple_expression  .. static_ simple_expression  
3.5.9: 
fixed_point_definition ::=  ordinary_fixed_point_definition  | decimal_fixed_point_definition  
3.5.9: 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      812 ordinary_fixed_point_definition ::=   
   delta  static_ expression   real_range_specification  
3.5.9: 
decimal_fixed_point_definition ::=   
   delta  static_ expression  digits  static_ expression  [real_range_specification ] 
3.5.9: 
digits_constraint ::=   
   digits  static_ expression  [range_constraint ] 
3.6: 
array_type_definition ::=   
   unconstrained_array_definition  | constrained_array_definition  
3.6: 
unconstrained_array_definition ::=   
   array (index_subtype_definition  {, index_subtype_definition }) of component_definition  
3.6: 
index_subtype_definition ::=  subtype_mark  range  <> 
3.6: 
constrained_array_definition ::=   
   array  (discrete_subtype_definition  {, discrete_subtype_definition }) of component_definition  
3.6: 
discrete_subtype_definition ::=  discrete_ subtype_indication  | range  
3.6: 
component_definition ::=   
   [aliased ] subtype_indication  
 | [aliased ] access_definition  
3.6.1: 
index_constraint ::=   (discrete_range  {, discrete_range }) 
3.6.1: 
discrete_range ::=  discrete_ subtype_indication  | range  
3.7: 
discriminant_part ::=  unknown_discriminant_part  | known_discriminant_part  
3.7: 
unknown_discriminant_part ::=  (<>) 
3.7: 
known_discriminant_part ::=   
   (discriminant_specification  {; discriminant_specification }) 
3.7: 
discriminant_specification ::=   
   defining_identifier_list  : [null_exclusion ] subtype_mark  [:= default_expression ] 
 | defining_identifier_list  : access_definition  [:= default_expression ] 
3.7: 
default_expression ::=  expression  
3.7.1: 
discriminant_constraint ::=   
   (discriminant_association  {, discriminant_association }) 
3.7.1: 
discriminant_association ::=   
   [discriminant_ selector_name  {| discriminant_ selector_name } =>] expression  
3.8: 
record_type_definition ::=  [[abstract ] tagged ] [limited ] record_definition  
Ada Reference Manual — 2012 Edition 
813      13 December 2012 Syntax Summary   Annex P 3.8: 
record_definition ::=   
    record  
       component_list  
    end record  
  | null record  
3.8: 
component_list ::=   
      component_item  {component_item } 
   | {component_item } variant_part  
   |  null; 
3.8: 
component_item ::=  component_declaration  | aspect_clause  
3.8: 
component_declaration ::=   
   defining_identifier_list  : component_definition  [:= default_expression ] 
        [ aspect_specification ]; 
3.8.1: 
variant_part ::=   
   case discriminant_ direct_name  is 
       variant  
      { variant } 
   end case; 
3.8.1: 
variant ::=   
   when  discrete_choice_list  => 
      component_list  
3.8.1: 
discrete_choice_list ::=  discrete_choice  {| discrete_choice } 
3.8.1: 
discrete_choice ::=  choice_expression  | discrete_ subtype_indication  | range  | others  
3.9.1: 
record_extension_part ::=  with  record_definition  
3.9.3: 
abstract_subprogram_declaration ::=   
    [overriding_indicator ] 
    subprogram_spec ification  is abstract  
        [ aspect_specification ]; 
3.9.4: 
interface_type_definition ::=   
    [limited  | task | protected  | synchronized ] interface  [and interface_list ] 
3.9.4: 
interface_list ::=  interface_ subtype_mark  {and interface_ subtype_mark } 
3.10: 
access_type_definition ::=   
    [null_exclusion ] access_to_object_definition  
  | [null_exclusion ] access_to_subprogram_definition  
3.10: 
access_to_object_definition ::=   
    access  [general_access_modifier ] subtype_indication  
3.10: 
general_access_modifier ::=  all | constant  
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      814 3.10: 
access_to_subprogram_definition ::=   
    access  [protected ] procedure  parameter_profile  
  | access  [protected ] function   parameter_and_result_profile  
3.10: 
null_exclusion ::=  not null 
3.10: 
access_definition ::=   
    [null_exclusion ] access  [constant ] subtype_mark  
  | [null_exclusion ] access  [protected ] procedure  parameter_profile  
  | [null_exclusion ] access  [protected ] function  parameter_and_result_profile  
3.10.1: 
incomplete_type_declaration ::=  type defining_identifier  [discriminant_part ] [is tagged ]; 
3.11: 
declarative_part ::=  {declarative_item } 
3.11: 
declarative_item ::=   
    basic_declarative_item  | body  
3.11: 
basic_declarative_item ::=   
    basic_declaration  | aspect_clause  | use_clause  
3.11: 
body ::=  proper_body  | body_stub  
3.11: 
proper_body ::=   
    subprogram_body  | package_body  | task_body  | protected_body  
4.1: 
name ::=   
     direct_name  | explicit_dereference  
   | indexed_component  | slice  
   | selected_component  | attribute_reference  
   | type_conversion  | function_call  
   | character_literal  | qualified_expression  
   | generalized_reference  | generalized_indexing  
4.1: 
direct_name ::=  identifier  | operator_symbol  
4.1: 
prefix ::=  name  | implicit_dereference  
4.1: 
explicit_dereference ::=  name .all 
4.1: 
implicit_dereference ::=  name  
4.1.1: 
indexed_component ::=  prefix (expression  {, expression }) 
4.1.2: 
slice ::=  prefix (discrete_range ) 
4.1.3: 
selected_component ::=  prefix  . selector_name  
4.1.3: 
selector_name ::=  identifier  | character_literal  | operator_symbol  
4.1.4: 
Ada Reference Manual — 2012 Edition 
815      13 December 2012 Syntax Summary   Annex P attribute_reference ::=  prefix 'attribute_designator  
4.1.4: 
attribute_designator ::=   
    identifier [(static_ expression )] 
  | Access | Delta | Digits | Mod 
4.1.4: 
range_attribute_reference ::=  prefix 'range_attribute_designator  
4.1.4: 
range_attribute_designator ::=  Range[( static_ expression )] 
4.1.5: 
generalized_reference ::=  reference_object_ name  
4.1.6: 
generalized_indexing ::=  indexable_container_object_ prefix  actual_parameter_part  
4.3: 
aggregate ::=  record_aggregate  | extension_aggregate  | array_aggregate  
4.3.1: 
record_aggregate ::=  (record_component_association_list ) 
4.3.1: 
record_component_association_list ::=   
    record_component_association  {, record_component_association } 
  | null record  
4.3.1: 
record_component_association ::=   
    [component_choice_list  =>] expression  
   | component_choice_list  => <> 
4.3.1: 
component_choice_list ::=   
     component_ selector_name  {| component_ selector_name } 
   | others  
4.3.2: 
extension_aggregate ::=   
    (ancestor_part  with  record_component_association_list ) 
4.3.2: 
ancestor_part ::=  expression  | subtype_mark  
4.3.3: 
array_aggregate ::=   
  positional_array_aggregate  | named_array_aggregate  
4.3.3: 
positional_array_aggregate ::=   
    (expression , expression  {, expression }) 
  | (expression  {, expression }, others  => expression ) 
  | (expression  {, expression }, others  => <>) 
4.3.3: 
named_array_aggregate ::=   
    (array_component_association  {, array_component_association }) 
4.3.3: 
array_component_association ::=   
    discrete_choice_list  => expression  
  | discrete_choice_list  => <> 
4.4: 
expression ::=   
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      816      relation  {and relation }  | relation  {and then  relation } 
   | relation  {or relation }  | relation  {or else relation } 
   | relation  {xor relation } 
4.4: 
choice_expression ::=   
     choice_relation  {and choice_relation } 
   | choice_relation  {or choice_relation } 
   | choice_relation  {xor choice_relation } 
   | choice_relation  {and then  choice_relation } 
   | choice_relation  {or else  choice_relation } 
4.4: 
choice_relation ::=   
     simple_expression  [relational_operator  simple_expression ] 
4.4: 
relation ::=   
     simple_expression  [relational_operator  simple_expression ] 
   | simple_expression  [not] in membership_choice_list  
4.4: 
membership_choice_list ::=  membership_choice  {| membership_choice } 
4.4: 
membership_choice ::=  choice_expression  | range  | subtype_mark  
4.4: 
simple_expression ::=  [unary_adding_operator ] term {binary_adding_operator  term} 
4.4: 
term ::=  factor  {multiplying_operator  factor } 
4.4: 
factor ::=  primary  [** primary ] | abs primary  | not primary  
4.4: 
primary ::=   
   numeric_literal  | null | string_literal  | aggregate  
 | name  | allocator  | (expression ) 
 | (conditional_expression ) | (quantified_expression ) 
4.5: 
logical_operator ::=    and | or  | xor 
4.5: 
relational_operator ::=    =   | /=  | <   | <= | > | >= 
4.5: 
binary_adding_operator ::=    +   | –   | & 
4.5: 
unary_adding_operator ::=    +   | – 
4.5: 
multiplying_operator ::=    *   | /   | mod  | rem 
4.5: 
highest_precedence_operator ::=    **  | abs | not 
4.5.7: 
conditional_expression ::=  if_expression  | case_expression  
4.5.7: 
if_expression ::=   
   if condition  then  dependent_ expression  
   {elsif condition  then  dependent_ expression } 
   [else dependent_ expression ] 
Ada Reference Manual — 2012 Edition 
817      13 December 2012 Syntax Summary   Annex P 4.5.7: 
condition ::=  boolean_ expression  
4.5.7: 
case_expression ::=   
    case selecting_ expression  is 
    case_expression_alternative  {, 
    case_expression_alternative } 
4.5.7: 
case_expression_alternative ::=   
    when  discrete_choice_list  => 
        dependent_ expression  
4.5.8: 
quantified_expression ::=  for quantifier  loop_parameter_s pecification  => predicate  
  | for quantifier  iterator_spec ification  => predicate  
4.5.8: 
quantifier ::=  all | some  
4.5.8: 
predicate ::=  boolean_ expression  
4.6: 
type_conversion ::=   
    subtype_mark (expression ) 
  | subtype_mark (name ) 
4.7: 
qualified_expression ::=   
   subtype_mark '(expression ) | subtype_mark 'aggregate  
4.8: 
allocator ::=   
   new [subpool_specification ] subtype_indication  
 | new [subpool_specification ] qualified_expression  
4.8: 
subpool_specification ::=  (subpool_handle_ name ) 
5.1: 
sequence_of_statements ::=  statement  {statement } {label } 
5.1: 
statement ::=   
   {label } simple_statement  | {label } compound_statement  
5.1: 
simple_statement ::=  null_statement  
   | assignment_statement  | exit_statement  
   | goto_statement  | procedure_call_statement  
   | simple_return_statement  | entry_call_statement  
   | requeue_statement  | delay_statement  
   | abort_statement  | raise_statement  
   | code_statement  
5.1: 
compound_statement ::=   
     if_statement  | case_statement  
   | loop_statement  | block_statement  
   | extended_return_statement  
   | accept_statement  | select_statement  
5.1: 
null_statement ::=  null; 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      818 5.1: 
label ::=  <<label_ statement_identifier >> 
5.1: 
statement_identifier ::=  direct_name  
5.2: 
assignment_statement ::=   
   variable_ name  := expression ; 
5.3: 
if_statement ::=   
    if condition  then  
      sequence_of_statements  
   {elsif condition  then  
      sequence_of_statements } 
   [else 
      sequence_of_statements ] 
    end if; 
5.4: 
case_statement ::=   
   case selecting_ expression  is 
       case_statement_alternative  
      { case_statement_alternative } 
   end case; 
5.4: 
case_statement_alternative ::=   
   when  discrete_choice_list  => 
      sequence_of_statements  
5.5: 
loop_statement ::=   
   [loop_ statement_identifier :] 
      [iteration_scheme ] loop 
         sequence_of_statements  
       end loop [loop_ identifier ]; 
5.5: 
iteration_scheme ::=  while  condition  
   | for loop_parameter_s pecification  
   | for iterator_spec ification  
5.5: 
loop_parameter_spec ification ::=   
   defining_identifier  in [reverse ] discrete_subtype_definition  
5.5.2: 
iterator_specification ::=   
    defining_identifier  in [reverse ] iterator_ name  
  | defining_identifier  [: subtype_indication ] of [reverse ] iterable_ name  
5.6: 
block_statement ::=   
   [block_ statement_identifier :] 
       [ declare  
            declarative_part ] 
        begin  
            handled_sequence_of_statements  
        end [block_ identifier ]; 
5.7: 
exit_statement ::=   
   exit [loop_ name ] [when  condition ]; 
Ada Reference Manual — 2012 Edition 
819      13 December 2012 Syntax Summary   Annex P 5.8: 
goto_statement ::=  goto label_ name ; 
6.1: 
subprogram_declaration ::=   
    [overriding_indicator ] 
    subprogram_spec ification  
        [ aspect_specification ]; 
6.1: 
subprogram_specification ::=   
    procedure_spec ification  
  | function_specification  
6.1: 
procedure_specification ::=  procedure  defining_program_unit_name  parameter_profile  
6.1: 
function_specification ::=  function  defining_designator  parameter_and_result_profile  
6.1: 
designator ::=  [parent_unit_name  . ]identifier  | operator_symbol  
6.1: 
defining_designator ::=  defining_program_unit_name  | defining_operator_symbol  
6.1: 
defining_program_unit_name ::=  [parent_unit_name  . ]defining_identifier  
6.1: 
operator_symbol ::=  string_literal  
6.1: 
defining_operator_symbol ::=  operator_symbol  
6.1: 
parameter_profile ::=  [formal_part ] 
6.1: 
parameter_and_result_profile ::=   
    [formal_part ] return  [null_exclusion ] subtype_mark  
  | [formal_part ] return  access_definition  
6.1: 
formal_part ::=   
   (parameter_spec ification  {; parameter_spec ification }) 
6.1: 
parameter_specification ::=   
    defining_identifier_list  : [aliased ] mode  [null_exclusion ] subtype_mark  [:= default_expression ] 
  | defining_identifier_list  : access_definition  [:= default_expression ] 
6.1: 
mode ::=  [in] | in out | out 
6.3: 
subprogram_body ::=   
    [overriding_indicator ] 
    subprogram_spec ification  
       [ aspect_specification ] is 
       declarative_part  
    begin  
        handled_sequence_of_statements  
    end [designator ]; 
6.4: 
procedure_call_statement ::=   
    procedure_ name ; 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      820   | procedure_ prefix  actual_parameter_part ; 
6.4: 
function_call ::=   
    function_ name  
  | function_ prefix  actual_parameter_part  
6.4: 
actual_parameter_part ::=   
    (parameter_association  {, parameter_association }) 
6.4: 
parameter_association ::=   
   [formal_parameter_ selector_name  =>] explicit_actual_parameter  
6.4: 
explicit_actual_parameter ::=  expression  | variable_ name  
6.5: 
simple_return_statement ::=  return  [expression ]; 
6.5: 
extended_return_object_declaration ::=   
    defining_identifier  : [aliased ][constant ] return_subtype_indication  [:= expression ] 
6.5: 
extended_return_statement ::=   
    return  extended_return_object_declaration  [do 
        handled_sequence_of_statements  
    end return ]; 
6.5: 
return_subtype_indication ::=  subtype_indication  | access_definition  
6.7: 
null_procedure_declaration ::=   
   [overriding_indicator ] 
   procedure_spec ification  is null 
       [ aspect_specification ]; 
6.8: 
expression_function_declaration ::=   
   [overriding_indicator ] 
   function_specification  is 
       ( expression ) 
       [ aspect_specification ]; 
7.1: 
package_declaration ::=  package_specification ; 
7.1: 
package_specification ::=   
    package  defining_program_unit_name  
        [ aspect_specification ] is 
      { basic_declarative_item } 
   [private  
      { basic_declarative_item }] 
    end [[parent_unit_name .]identifier ] 
7.2: 
package_body ::=   
    package  body  defining_program_unit_name  
        [ aspect_specification ] is 
       declarative_part  
   [begin  
        handled_sequence_of_statements ] 
Ada Reference Manual — 2012 Edition 
821      13 December 2012 Syntax Summary   Annex P     end [[parent_unit_name .]identifier ]; 
7.3: 
private_type_declaration ::=   
   type defining_identifier  [discriminant_part ] is [[abstract ] tagged ] [limited ] private  
      [aspect_specification ]; 
7.3: 
private_extension_declaration ::=   
   type defining_identifier  [discriminant_part ] is 
     [abstract ] [limited  | synchronized ] new ancestor_ subtype_indication  
     [and interface_list ] with private  
       [ aspect_specification ]; 
8.3.1: 
overriding_indicator ::=  [not] overriding  
8.4: 
use_clause ::=  use_package_clause  | use_type_clause  
8.4: 
use_package_clause ::=  use package_ name  {, package_ name }; 
8.4: 
use_type_clause ::=  use [all] type subtype_mark  {, subtype_mark }; 
8.5: 
renaming_declaration ::=   
      object_renaming_declaration  
    | exception_renaming_declaration  
    | package_renaming_declaration  
    | subprogram_renaming_declaration  
    | generic_renaming_declaration  
8.5.1: 
object_renaming_declaration ::=   
    defining_identifier  : [null_exclusion ] subtype_mark  renames  object_ name  
        [ aspect_specification ]; 
  | defining_identifier  : access_definition  renames  object_ name  
        [ aspect_specification ]; 
8.5.2: 
exception_renaming_declaration ::=  defining_identifier  : exception  renames  exception_ name  
   [aspect_specification ]; 
8.5.3: 
package_renaming_declaration ::=  package  defining_program_unit_name  renames  package_ name  
   [aspect_specification ]; 
8.5.4: 
subprogram_renaming_declaration ::=   
    [overriding_indicator ] 
    subprogram_spec ification  renames  callable_entity_ name  
        [ aspect_specification ]; 
8.5.5: 
generic_renaming_declaration ::=   
    generic package  defining_program_unit_name  renames  generic_package_ name  
        [ aspect_specification ]; 
  | generic procedure  defining_program_unit_name  renames  generic_procedure_ name  
        [ aspect_specification ]; 
  | generic function  defining_program_unit_name  renames  generic_function_ name  
        [ aspect_specification ]; 
9.1: 
task_type_declaration ::=   
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      822    task type defining_identifier  [known_discriminant_part ] 
        [ aspect_specification ] [is 
     [new interface_list  with ] 
     task_definition ]; 
9.1: 
single_task_declaration ::=   
   task defining_identifier   
        [ aspect_specification ][is 
     [new interface_list  with ] 
     task_definition ]; 
9.1: 
task_definition ::=   
     {task_item } 
  [ private  
     {task_item }] 
  end [task_ identifier ] 
9.1: 
task_item ::=  entry_declaration  | aspect_clause  
9.1: 
task_body ::=   
   task body  defining_identifier  
        [ aspect_specification ] is 
     declarative_part  
   begin  
     handled_sequence_of_statements  
   end [task_ identifier ]; 
9.4: 
protected_type_declaration ::=   
  protected  type defining_identifier  [known_discriminant_part ] 
        [ aspect_specification ] is 
     [new interface_list  with ] 
     protected_definition ; 
9.4: 
single_protected_declaration ::=   
  protected  defining_identifier  
        [ aspect_specification ] is 
     [new interface_list  with ] 
     protected_definition ; 
9.4: 
protected_definition ::=   
    { protected_operation_declaration  } 
[ private  
    { protected_element_declaration  } ] 
  end [protected_ identifier ] 
9.4: 
protected_operation_declaration ::=  subprogram_declaration  
     | entry_declaration  
     | aspect_clause  
9.4: 
protected_element_declaration ::=  protected_operation_declaration  
     | component_declaration  
9.4: 
protected_body ::=   
  protected  body  defining_identifier  
        [ aspect_specification ] is 
Ada Reference Manual — 2012 Edition 
823      13 December 2012 Syntax Summary   Annex P    { protected_operation_item  } 
  end [protected_ identifier ]; 
9.4: 
protected_operation_item ::=  subprogram_declaration  
     | subprogram_body  
     | entry_body  
     | aspect_clause  
9.5: 
synchronization_kind ::=  By_Entry | By_Protected_Procedure | Optional 
9.5.2: 
entry_declaration ::=   
   [overriding_indicator ] 
   entry  defining_identifier  [(discrete_subtype_definition )] parameter_profile  
      [aspect_specification ]; 
9.5.2: 
accept_statement ::=   
   accept  entry_ direct_name  [(entry_index )] parameter_profile  [do 
     handled_sequence_of_statements  
   end [entry_ identifier ]]; 
9.5.2: 
entry_index ::=  expression  
9.5.2: 
entry_body ::=   
  entry  defining_identifier   entry_body_formal_part   entry_barrier  is 
    declarative_part  
  begin  
    handled_sequence_of_statements  
  end [entry_ identifier ]; 
9.5.2: 
entry_body_formal_part ::=  [(entry_index_spec ification )] parameter_profile  
9.5.2: 
entry_barrier ::=  when  condition  
9.5.2: 
entry_index_specification ::=  for defining_identifier  in discrete_subtype_definition  
9.5.3: 
entry_call_statement ::=  entry_ name  [actual_parameter_part ]; 
9.5.4: 
requeue_statement ::=  requeue  procedure_or_entry_ name  [with  abort ]; 
9.6: 
delay_statement ::=  delay_until_statement  | delay_relative_statement  
9.6: 
delay_until_statement ::=  delay until  delay_ expression ; 
9.6: 
delay_relative_statement ::=  delay  delay_ expression ; 
9.7: 
select_statement ::=   
   selective_accept  
  | timed_entry_call  
  | conditional_entry_call  
  | asynchronous_select  
9.7.1: 
selective_accept ::=   
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      824   select  
   [guard ] 
     select_alternative  
{ or 
   [guard ] 
     select_alternative  } 
[ else 
   sequence_of_statements  ] 
  end select ; 
9.7.1: 
guard ::=  when  condition  => 
9.7.1: 
select_alternative ::=   
   accept_alternative  
  | delay_alternative  
  | terminate_alternative  
9.7.1: 
accept_alternative ::=   
  accept_statement  [sequence_of_statements ] 
9.7.1: 
delay_alternative ::=   
  delay_statement  [sequence_of_statements ] 
9.7.1: 
terminate_alternative ::=  terminate ; 
9.7.2: 
timed_entry_call ::=   
  select  
   entry_call_alternative  
  or 
   delay_alternative  
  end select ; 
9.7.2: 
entry_call_alternative ::=   
  procedure_or_entry_call  [sequence_of_statements ] 
9.7.2: 
procedure_or_entry_call ::=   
  procedure_call_statement  | entry_call_statement  
9.7.3: 
conditional_entry_call ::=   
  select  
   entry_call_alternative  
  else 
   sequence_of_statements  
  end select ; 
9.7.4: 
asynchronous_select ::=   
  select  
   triggering_alternative  
  then abort  
   abortable_part  
  end select ; 
9.7.4: 
triggering_alternative ::=  triggering_statement  [sequence_of_statements ] 
9.7.4: 
Ada Reference Manual — 2012 Edition 
825      13 December 2012 Syntax Summary   Annex P triggering_statement ::=  procedure_or_entry_call  | delay_statement  
9.7.4: 
abortable_part ::=  sequence_of_statements  
9.8: 
abort_statement ::=  abort  task_ name  {, task_ name }; 
10.1.1: 
compilation ::=  {compilation_unit } 
10.1.1: 
compilation_unit ::=   
    context_clause  library_item  
  | context_clause  subunit  
10.1.1: 
library_item ::=  [private ] library_unit_declaration  
  | library_unit_body  
  | [private ] library_unit_renaming_declaration  
10.1.1: 
library_unit_declaration ::=   
     subprogram_declaration  | package_declaration  
   | generic_declaration  | generic_instantiation  
10.1.1: 
library_unit_renaming_declaration ::=   
   package_renaming_declaration  
 | generic_renaming_declaration  
 | subprogram_renaming_declaration  
10.1.1: 
library_unit_body ::=  subprogram_body  | package_body  
10.1.1: 
parent_unit_name ::=  name  
10.1.2: 
context_clause ::=  {context_item } 
10.1.2: 
context_item ::=  with_clause  | use_clause  
10.1.2: 
with_clause ::=  limited_with_clause  | nonlimited_with_clause  
10.1.2: 
limited_with_clause ::=  limited  [private ] with  library_unit_ name  {, library_unit_ name }; 
10.1.2: 
nonlimited_with_clause ::=  [private ] with  library_unit_ name  {, library_unit_ name }; 
10.1.3: 
body_stub ::=  subprogram_body_stub  | package_body_stub  | task_body_stub  | protected_body_stub  
10.1.3: 
subprogram_body_stub ::=   
   [overriding_indicator ] 
   subprogram_spec ification  is separate  
      [aspect_specification ]; 
10.1.3: 
package_body_stub ::=   
   package  body  defining_identifier  is separate  
      [aspect_specification ]; 
10.1.3: 
task_body_stub ::=   
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      826    task body  defining_identifier  is separate  
      [aspect_specification ]; 
10.1.3: 
protected_body_stub ::=   
   protected  body  defining_identifier  is separate  
      [aspect_specification ]; 
10.1.3: 
subunit ::=  separate  (parent_unit_name ) proper_body  
11.1: 
exception_declaration ::=  defining_identifier_list  : exception  
   [aspect_specification ]; 
11.2: 
handled_sequence_of_statements ::=   
     sequence_of_statements  
  [exception  
     exception_handler  
    {exception_handler }] 
11.2: 
exception_handler ::=   
  when  [choice_parameter _specification :] exception_choice  {| exception_choice } => 
     sequence_of_statements  
11.2: 
choice_parameter_s pecification ::=  defining_identifier  
11.2: 
exception_choice ::=  exception_ name  | others  
11.3: 
raise_statement ::=  raise ; 
      | raise  exception_ name  [with  string_ expression ]; 
12.1: 
generic_declaration ::=  generic_subprogram_declaration  | generic_package_declaration  
12.1: 
generic_subprogram_declaration ::=   
     generic_formal_part   subprogram_spec ification  
        [ aspect_specification ]; 
12.1: 
generic_package_declaration ::=   
     generic_formal_part   package_specification ; 
12.1: 
generic_formal_part ::=  generic  {generic_formal_parameter_declaration  | use_clause } 
12.1: 
generic_formal_parameter_declaration ::=   
      formal_object_declaration  
    | formal_type_declaration  
    | formal_subprogram_declaration  
    | formal_package_declaration  
12.3: 
generic_instantiation ::=   
     package  defining_program_unit_name  is 
         new generic_package_ name  [generic_actual_part ] 
            [ aspect_specification ]; 
   | [overriding_indicator ] 
     procedure  defining_program_unit_name  is 
         new generic_procedure_ name  [generic_actual_part ] 
Ada Reference Manual — 2012 Edition 
827      13 December 2012 Syntax Summary   Annex P             [ aspect_specification ]; 
   | [overriding_indicator ] 
     function  defining_designator  is 
         new generic_function_ name  [generic_actual_part ] 
            [ aspect_specification ]; 
12.3: 
generic_actual_part ::=   
   (generic_association  {, generic_association }) 
12.3: 
generic_association ::=   
   [generic_formal_parameter_ selector_name  =>] explicit_generic_ac tual_parameter  
12.3: 
explicit_generic_act ual_parameter ::=  expression  | variable_ name  
   | subprogram_ name  | entry_ name  | subtype_mark  
   | package_instance_ name  
12.4: 
formal_object_declaration ::=   
    defining_identifier_list  : mode  [null_exclusion ] subtype_mark  [:= default_expression ] 
        [ aspect_specification ]; 
  |  defining_identifier_list  : mode  access_definition  [:= default_expression ] 
        [ aspect_specification ]; 
12.5: 
formal_type_declaration ::=   
      formal_complete_type_declaration  
    | formal_incomplete_type_declaration  
12.5: 
formal_complete_type_declaration ::=   
    type defining_identifier [discriminant_part ] is formal_type_definition  
        [ aspect_specification ]; 
12.5: 
formal_incomplete_type_declaration ::=   
    type defining_identifier [discriminant_part ] [is tagged ]; 
12.5: 
formal_type_definition ::=   
      formal_private_type_definition  
    | formal_derived_type_definition  
    | formal_discrete_type_definition  
    | formal_signed_integer_type_definition  
    | formal_modular_type_definition  
    | formal_floating_point_definition  
    | formal_ordinary_fixed_point_definition  
    | formal_decimal_fix ed_point_definition  
    | formal_array_type_definition  
    | formal_access_type_definition  
    | formal_interface_type_definition  
12.5.1: 
formal_private_type_definition ::=  [[abstract ] tagged ] [limited ] private  
12.5.1: 
formal_derived_type_definition ::=   
     [abstract ] [limited  | synchronized ] new subtype_mark  [[and interface_list ]with  private ] 
12.5.2: 
formal_discrete_type_definition ::=  (<>) 
12.5.2: 
formal_signed_integer_type_definition ::=  range  <> 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      828 12.5.2: 
formal_modular_type_definition ::=  mod  <> 
12.5.2: 
formal_floating_point_definition ::=  digits  <> 
12.5.2: 
formal_ordinary_fixed_point_definition ::=  delta  <> 
12.5.2: 
formal_decimal_fixed_point_definition ::=  delta  <> digits  <> 
12.5.3: 
formal_array_type_definition ::=  array_type_definition  
12.5.4: 
formal_access_type_definition ::=  access_type_definition  
12.5.5: 
formal_interface_type_definition ::=  interface_type_definition  
12.6: 
formal_subprogram_declaration ::=  formal_concrete_subprogram_declaration  
    | formal_abstract_subprogram_declaration  
12.6: 
formal_concrete_subprogram_declaration ::=   
     with  subprogram_spec ification  [is subprogram_default ] 
        [ aspect_specification ]; 
12.6: 
formal_abstract_subprogram_declaration ::=   
     with  subprogram_spec ification  is abstract  [subprogram_default ] 
        [ aspect_specification ]; 
12.6: 
subprogram_default ::=  default_name  | <> | null 
12.6: 
default_name ::=  name  
12.7: 
formal_package_declaration ::=   
    with  package  defining_identifier  is new generic_package_ name   formal_package_actual_part  
        [ aspect_specification ]; 
12.7: 
formal_package_actual_part ::=   
    ([others  =>] <>) 
  | [generic_actual_part ] 
  | (formal_package_association  {, formal_package_association } [, others  => <>]) 
12.7: 
formal_package_association ::=   
    generic_association  
  | generic_formal_parameter_ selector_name  => <> 
13.1: 
aspect_clause ::=  attribute_definition_clause  
      | enumeration_repres entation_clause  
      | record_representation_clause  
      | at_clause  
13.1: 
local_name ::=  direct_name  
      | direct_name 'attribute_designator  
      | library_unit_ name  
Ada Reference Manual — 2012 Edition 
829      13 December 2012 Syntax Summary   Annex P 13.1.1: 
aspect_specification ::=   
   with  aspect_mark  [=> aspect_definition ] {, 
           aspect_mark  [=> aspect_definition ] } 
13.1.1: 
aspect_mark ::=  aspect_ identifier ['Class] 
13.1.1: 
aspect_definition ::=  name  | expression  | identifier  
13.3: 
attribute_definition_clause ::=   
      for local_name 'attribute_designator  use expression ; 
    | for local_name 'attribute_designator  use name ; 
13.4: 
enumeration_represent ation_clause ::=   
    for first_subtype_ local_name  use enumeration_aggregate ; 
13.4: 
enumeration_aggregate ::=  array_aggregate  
13.5.1: 
record_representation_clause ::=   
    for first_subtype_ local_name  use 
      record  [mod_clause ] 
        { component_clause } 
      end record ; 
13.5.1: 
component_clause ::=   
    component_ local_name  at position  range  first_bit  .. last_bit ; 
13.5.1: 
position ::=  static_ expression  
13.5.1: 
first_bit ::=  static_ simple_expression  
13.5.1: 
last_bit ::=  static_ simple_expression  
13.8: 
code_statement ::=  qualified_expression ; 
13.11.3: 
storage_pool_indicator ::=  storage_pool_ name  | null 
13.12: 
restriction ::=  restriction_ identifier  
    | restriction_parameter_ identifier  => restriction_parameter_argument  
13.12: 
restriction_parameter_argument ::=  name  | expression  
J.3: 
delta_constraint ::=  delta  static_ expression  [range_constraint ] 
J.7: 
at_clause ::=  for direct_name  use at expression ; 
J.8: 
mod_clause ::=  at mod  static_ expression ; 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      830 Syntax Cross Reference  
 
In the following syntax cross reference, each synt actic category is followed by the subclause number 
where it is defined. In addition, each syntactic category S is followed by a list of the categories that use S 
in their definitions. For example, the first listing below shows that abort_statement  appears in the 
definition of simple_statement .  
abort_statement  9.8 
 simple_statement  5.1 
abortable_part  9.7.4 
 asynchronous_select  9.7.4 
abstract_subprogram_declaration  3.9.3 
 basic_declaration  3.1 
accept_alternative  9.7.1 
 select_alternative  9.7.1 
accept_statement  9.5.2 
 accept_alternative  9.7.1 
 compound_statement  5.1 
access_definition  3.10 
 component_definition  3.6 
 discriminant_specification  3.7 
 formal_object_declaration  12.4 
 object_declaration  3.3.1 
 object_renaming_declaration  8.5.1 
 parameter_and_result_profile  6.1 
 parameter_spec ification  6.1 
 return_subtype_indication  6.5 
access_to_object_definition  3.10 
 access_type_definition  3.10 
access_to_subprogram_definition  3.10 
 access_type_definition  3.10 
access_type_definition  3.10 
 formal_access_type_definition  12.5.4 
 type_definition  3.2.1 
actual_parameter_part  6.4 
 entry_call_statement  9.5.3 
 function_call  6.4 
 generalized_indexing  4.1.6 
 procedure_call_statement  6.4 
aggregate  4.3 
 primary  4.4 
 qualified_expression  4.7 
allocator  4.8 
 primary  4.4 
ancestor_part  4.3.2 
 extension_aggregate  4.3.2 array_aggregate  4.3.3 
 aggregate  4.3 
 enumeration_aggregate  13.4 
array_component_association  4.3.3 
 named_array_aggregate  4.3.3 
array_type_definition  3.6 
 formal_array_type_definition  12.5.3 
 object_declaration  3.3.1 
 type_definition  3.2.1 
aspect_clause  13.1 
 basic_declarative_item  3.11 
 component_item  3.8 
 protected_operation_declaration  9.4 
 protected_operation_item  9.4 
 task_item  9.1 
aspect_definition  13.1.1 
 aspect_specification  13.1.1 
aspect_mark  13.1.1 
 aspect_specification  13.1.1 
 pragma_argument_association  2.8 
aspect_specification  13.1.1 
 abstract_subprogram_declaration  3.9.3 
 component_declaration  3.8 
 entry_declaration  9.5.2 
 exception_declaration  11.1 
 exception_renaming_declaration  8.5.2 
 expression_function_declaration  6.8 
 formal_abstract_subprogram_declaration  12.6 
 formal_complete_type_declaration  12.5 
 formal_concrete_subprogram_declaration  12.6 
 formal_object_declaration  12.4 
 formal_package_declaration  12.7 
 full_type_declaration  3.2.1 
 generic_instantiation  12.3 
 generic_renaming_declaration  8.5.5 
 generic_subprogram_declaration  12.1 
 null_procedure_declaration  6.7 
 object_declaration  3.3.1 
 object_renaming_declaration  8.5.1 
 package_body  7.2 
 package_body_stub  10.1.3 
 package_renaming_declaration  8.5.3 
 package_specification  7.1 
 private_extension_declaration  7.3 1/3 
Ada Reference Manual — 2012 Edition 
831      13 December 2012 Syntax Summary   Annex P  private_type_declaration  7.3 
 protected_body  9.4 
 protected_body_stub  10.1.3 
 protected_type_declaration  9.4 
 single_protected_declaration  9.4 
 single_task_declaration  9.1 
 subprogram_body  6.3 
 subprogram_body_stub  10.1.3 
 subprogram_declaration  6.1 
 subprogram_renaming_declaration  8.5.4 
 subtype_declaration  3.2.2 
 task_body  9.1 
 task_body_stub  10.1.3 
 task_type_declaration  9.1 
assignment_statement  5.2 
 simple_statement  5.1 
asynchronous_select  9.7.4 
 select_statement  9.7 
at_clause  J.7 
 aspect_clause  13.1 
attribute_definition_clause  13.3 
 aspect_clause  13.1 
attribute_designator  4.1.4 
 attribute_definition_clause  13.3 
 attribute_reference  4.1.4 
 local_name  13.1 
attribute_reference  4.1.4 
 name  4.1 
base  2.4.2 
 based_literal  2.4.2 
based_literal  2.4.2 
 numeric_literal  2.4 
based_numeral  2.4.2 
 based_literal  2.4.2 
basic_declaration  3.1 
 basic_declarative_item  3.11 
basic_declarative_item  3.11 
 declarative_item  3.11 
 package_specification  7.1 
binary_adding_operator  4.5 
 simple_expression  4.4 
block_statement  5.6 
 compound_statement  5.1 
body  3.11 
 declarative_item  3.11 
body_stub  10.1.3 
 body  3.11 case_expression  4.5.7 
 conditional_expression  4.5.7 
case_expression_alternative  4.5.7 
 case_expression  4.5.7 
case_statement  5.4 
 compound_statement  5.1 
case_statement_alternative  5.4 
 case_statement  5.4 
character  2.1 
 comment  2.7 
character_literal  2.5 
 defining_character_literal  3.5.1 
 name  4.1 
 selector_name  4.1.3 
choice_expression  4.4 
 discrete_choice  3.8.1 
 membership_choice  4.4 
choice_parameter _specification  11.2 
 exception_handler  11.2 
choice_relation  4.4 
 choice_expression  4.4 
code_statement  13.8 
 simple_statement  5.1 
compilation_unit  10.1.1 
 compilation  10.1.1 
component_choice_list  4.3.1 
 record_component_association  4.3.1 
component_clause  13.5.1 
 record_representation_clause  13.5.1 
component_declaration  3.8 
 component_item  3.8 
 protected_element_declaration  9.4 
component_definition  3.6 
 component_declaration  3.8 
 constrained_array_definition  3.6 
 unconstrained_array_definition  3.6 
component_item  3.8 
 component_list  3.8 
component_list  3.8 
 record_definition  3.8 
 variant  3.8.1 
composite_constraint  3.2.2 
 constraint  3.2.2 
compound_statement  5.1 
 statement  5.1 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      832 condition  4.5.7 
 entry_barrier  9.5.2 
 exit_statement  5.7 
 guard  9.7.1 
 if_expression  4.5.7 
 if_statement  5.3 
 iteration_scheme  5.5 
conditional_entry_call  9.7.3 
 select_statement  9.7 
conditional_expression  4.5.7 
 primary  4.4 
constrained_array_definition  3.6 
 array_type_definition  3.6 
constraint  3.2.2 
 subtype_indication  3.2.2 
context_clause  10.1.2 
 compilation_unit  10.1.1 
context_item  10.1.2 
 context_clause  10.1.2 
decimal_fixed_point_definition  3.5.9 
 fixed_point_definition  3.5.9 
decimal_literal  2.4.1 
 numeric_literal  2.4 
declarative_item  3.11 
 declarative_part  3.11 
declarative_part  3.11 
 block_statement  5.6 
 entry_body  9.5.2 
 package_body  7.2 
 subprogram_body  6.3 
 task_body  9.1 
default_expression  3.7 
 component_declaration  3.8 
 discriminant_specification  3.7 
 formal_object_declaration  12.4 
 parameter_spec ification  6.1 
default_name  12.6 
 subprogram_default  12.6 
defining_character_literal  3.5.1 
 enumeration_literal _specification  3.5.1 
defining_designator  6.1 
 function_specification  6.1 
 generic_instantiation  12.3 
defining_identifier  3.1 
 choice_parameter _specification  11.2 
 defining_identifier_list  3.3.1 
 defining_program_unit_name  6.1 
 entry_body  9.5.2  entry_declaration  9.5.2 
 entry_index_spec ification  9.5.2 
 enumeration_literal _specification  3.5.1 
 exception_renaming_declaration  8.5.2 
 extended_return_object_declaration  6.5 
 formal_complete_type_declaration  12.5 
 formal_incomplete_type_declaration  12.5 
 formal_package_declaration  12.7 
 full_type_declaration  3.2.1 
 incomplete_type_declaration  3.10.1 
 iterator_spec ification  5.5.2 
 loop_parameter_s pecification  5.5 
 object_renaming_declaration  8.5.1 
 package_body_stub  10.1.3 
 private_extension_declaration  7.3 
 private_type_declaration  7.3 
 protected_body  9.4 
 protected_body_stub  10.1.3 
 protected_type_declaration  9.4 
 single_protected_declaration  9.4 
 single_task_declaration  9.1 
 subtype_declaration  3.2.2 
 task_body  9.1 
 task_body_stub  10.1.3 
 task_type_declaration  9.1 
defining_identifier_list  3.3.1 
 component_declaration  3.8 
 discriminant_specification  3.7 
 exception_declaration  11.1 
 formal_object_declaration  12.4 
 number_declaration  3.3.2 
 object_declaration  3.3.1 
 parameter_spec ification  6.1 
defining_operator_symbol  6.1 
 defining_designator  6.1 
defining_program_unit_name  6.1 
 defining_designator  6.1 
 generic_instantiation  12.3 
 generic_renaming_declaration  8.5.5 
 package_body  7.2 
 package_renaming_declaration  8.5.3 
 package_specification  7.1 
 procedure_spec ification  6.1 
delay_alternative  9.7.1 
 select_alternative  9.7.1 
 timed_entry_call  9.7.2 
delay_relative_statement  9.6 
 delay_statement  9.6 
delay_statement  9.6 
 delay_alternative  9.7.1 
 simple_statement  5.1 
 triggering_statement  9.7.4 
delay_until_statement  9.6 
 delay_statement  9.6 
Ada Reference Manual — 2012 Edition 
833      13 December 2012 Syntax Summary   Annex P delta_constraint  J.3 
 scalar_constraint  3.2.2 
derived_type_definition  3.4 
 type_definition  3.2.1 
designator  6.1 
 subprogram_body  6.3 
digit 2.4.1 
 extended_digit  2.4.2 
 numeral  2.4.1 
digits_constraint  3.5.9 
 scalar_constraint  3.2.2 
direct_name  4.1 
 accept_statement  9.5.2 
 at_clause  J.7 
 local_name  13.1 
 name  4.1 
 statement_identifier  5.1 
 variant_part  3.8.1 
discrete_choice  3.8.1 
 discrete_choice_list  3.8.1 
discrete_choice_list  3.8.1 
 array_component_association  4.3.3 
 case_expression_alternative  4.5.7 
 case_statement_alternative  5.4 
 variant  3.8.1 
discrete_range  3.6.1 
 index_constraint  3.6.1 
 slice  4.1.2 
discrete_subtype_definition  3.6 
 constrained_array_definition  3.6 
 entry_declaration  9.5.2 
 entry_index_spec ification  9.5.2 
 loop_parameter_s pecification  5.5 
discriminant_association  3.7.1 
 discriminant_constraint  3.7.1 
discriminant_constraint  3.7.1 
 composite_constraint  3.2.2 
discriminant_part  3.7 
 formal_complete_type_declaration  12.5 
 formal_incomplete_type_declaration  12.5 
 incomplete_type_declaration  3.10.1 
 private_extension_declaration  7.3 
 private_type_declaration  7.3 
discriminant_specification  3.7 
 known_discriminant_part  3.7 
entry_barrier  9.5.2 
 entry_body  9.5.2 
entry_body  9.5.2  protected_operation_item  9.4 
entry_body_formal_part  9.5.2 
 entry_body  9.5.2 
entry_call_alternative  9.7.2 
 conditional_entry_call  9.7.3 
 timed_entry_call  9.7.2 
entry_call_statement  9.5.3 
 procedure_or_entry_call  9.7.2 
 simple_statement  5.1 
entry_declaration  9.5.2 
 protected_operation_declaration  9.4 
 task_item  9.1 
entry_index  9.5.2 
 accept_statement  9.5.2 
entry_index_spec ification  9.5.2 
 entry_body_formal_part  9.5.2 
enumeration_aggregate  13.4 
 enumeration_repres entation_clause  13.4 
enumeration_literal _specification  3.5.1 
 enumeration_type_definition  3.5.1 
enumeration_repres entation_clause  13.4 
 aspect_clause  13.1 
enumeration_type_definition  3.5.1 
 type_definition  3.2.1 
exception_choice  11.2 
 exception_handler  11.2 
exception_declaration  11.1 
 basic_declaration  3.1 
exception_handler  11.2 
 handled_sequence_of_statements  11.2 
exception_renaming_declaration  8.5.2 
 renaming_declaration  8.5 
exit_statement  5.7 
 simple_statement  5.1 
explicit_actual_parameter  6.4 
 parameter_association  6.4 
explicit_dereference  4.1 
 name  4.1 
explicit_generic_ac tual_parameter  12.3 
 generic_association  12.3 
exponent  2.4.1 
 based_literal  2.4.2 
 decimal_literal  2.4.1 
expression  4.4 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      834  ancestor_part  4.3.2 
 array_component_association  4.3.3 
 aspect_definition  13.1.1 
 assignment_statement  5.2 
 at_clause  J.7 
 attribute_definition_clause  13.3 
 attribute_designator  4.1.4 
 case_expression  4.5.7 
 case_expression_alternative  4.5.7 
 case_statement  5.4 
 condition  4.5.7 
 decimal_fixed_point_definition  3.5.9 
 default_expression  3.7 
 delay_relative_statement  9.6 
 delay_until_statement  9.6 
 delta_constraint  J.3 
 digits_constraint  3.5.9 
 discriminant_association  3.7.1 
 entry_index  9.5.2 
 explicit_actual_parameter  6.4 
 explicit_generic_ac tual_parameter  12.3 
 expression_function_declaration  6.8 
 extended_return_object_declaration  6.5 
 floating_point_definition  3.5.7 
 if_expression  4.5.7 
 indexed_component  4.1.1 
 mod_clause  J.8 
 modular_type_definition  3.5.4 
 number_declaration  3.3.2 
 object_declaration  3.3.1 
 ordinary_fixed_point_definition  3.5.9 
 position  13.5.1 
 positional_array_aggregate  4.3.3 
 pragma_argument_association  2.8 
 predicate  4.5.8 
 primary  4.4 
 qualified_expression  4.7 
 raise_statement  11.3 
 range_attribute_designator  4.1.4 
 record_component_association  4.3.1 
 restriction_parameter_argument  13.12 
 simple_return_statement  6.5 
 type_conversion  4.6 
expression_function_declaration  6.8 
 basic_declaration  3.1 
extended_digit  2.4.2 
 based_numeral  2.4.2 
extended_return_object_declaration  6.5 
 extended_return_statement  6.5 
extended_return_statement  6.5 
 compound_statement  5.1 
extension_aggregate  4.3.2 
 aggregate  4.3 
factor  4.4 
 term 4.4 first_bit  13.5.1 
 component_clause  13.5.1 
fixed_point_definition  3.5.9 
 real_type_definition  3.5.6 
floating_point_definition  3.5.7 
 real_type_definition  3.5.6 
formal_abstract_subprogram_declaration  12.6 
 formal_subprogram_declaration  12.6 
formal_access_type_definition  12.5.4 
 formal_type_definition  12.5 
formal_array_type_definition  12.5.3 
 formal_type_definition  12.5 
formal_complete_type_declaration  12.5 
 formal_type_declaration  12.5 
formal_concrete_subprogram_declaration  12.6 
 formal_subprogram_declaration  12.6 
formal_decimal_fix ed_point_definition  12.5.2 
 formal_type_definition  12.5 
formal_derived_type_definition  12.5.1 
 formal_type_definition  12.5 
formal_discrete_type_definition  12.5.2 
 formal_type_definition  12.5 
formal_floating_point_definition  12.5.2 
 formal_type_definition  12.5 
formal_incomplete_type_declaration  12.5 
 formal_type_declaration  12.5 
formal_interface_type_definition  12.5.5 
 formal_type_definition  12.5 
formal_modular_type_definition  12.5.2 
 formal_type_definition  12.5 
formal_object_declaration  12.4 
 generic_formal_parameter_declaration  12.1 
formal_ordinary_fixed_point_definition  12.5.2 
 formal_type_definition  12.5 
formal_package_actual_part  12.7 
 formal_package_declaration  12.7 
formal_package_association  12.7 
 formal_package_actual_part  12.7 
formal_package_declaration  12.7 
 generic_formal_parameter_declaration  12.1 
formal_part  6.1 
 parameter_and_result_profile  6.1 
 parameter_profile  6.1 
formal_private_type_definition  12.5.1 
Ada Reference Manual — 2012 Edition 
835      13 December 2012 Syntax Summary   Annex P  formal_type_definition  12.5 
formal_signed_integer_type_definition  12.5.2 
 formal_type_definition  12.5 
formal_subprogram_declaration  12.6 
 generic_formal_parameter_declaration  12.1 
formal_type_declaration  12.5 
 generic_formal_parameter_declaration  12.1 
formal_type_definition  12.5 
 formal_complete_type_declaration  12.5 
full_type_declaration  3.2.1 
 type_declaration  3.2.1 
function_call  6.4 
 name  4.1 
function_specification  6.1 
 expression_function_declaration  6.8 
 subprogram_spec ification  6.1 
general_access_modifier  3.10 
 access_to_object_definition  3.10 
generalized_indexing  4.1.6 
 name  4.1 
generalized_reference  4.1.5 
 name  4.1 
generic_actual_part  12.3 
 formal_package_actual_part  12.7 
 generic_instantiation  12.3 
generic_association  12.3 
 formal_package_association  12.7 
 generic_actual_part  12.3 
generic_declaration  12.1 
 basic_declaration  3.1 
 library_unit_declaration  10.1.1 
generic_formal_parameter_declaration  12.1 
 generic_formal_part  12.1 
generic_formal_part  12.1 
 generic_package_declaration  12.1 
 generic_subprogram_declaration  12.1 
generic_instantiation  12.3 
 basic_declaration  3.1 
 library_unit_declaration  10.1.1 
generic_package_declaration  12.1 
 generic_declaration  12.1 
generic_renaming_declaration  8.5.5 
 library_unit_renaming_declaration  10.1.1 
 renaming_declaration  8.5 
generic_subprogram_declaration  12.1  generic_declaration  12.1 
goto_statement  5.8 
 simple_statement  5.1 
graphic_character  2.1 
 character_literal  2.5 
 string_element  2.6 
guard  9.7.1 
 selective_accept  9.7.1 
handled_sequence_of_statements  11.2 
 accept_statement  9.5.2 
 block_statement  5.6 
 entry_body  9.5.2 
 extended_return_statement  6.5 
 package_body  7.2 
 subprogram_body  6.3 
 task_body  9.1 
identifier  2.3 
 accept_statement  9.5.2 
 aspect_definition  13.1.1 
 aspect_mark  13.1.1 
 attribute_designator  4.1.4 
 block_statement  5.6 
 defining_identifier  3.1 
 designator  6.1 
 direct_name  4.1 
 entry_body  9.5.2 
 loop_statement  5.5 
 package_body  7.2 
 package_specification  7.1 
 pragma  2.8 
 pragma_argument_association  2.8 
 protected_body  9.4 
 protected_definition  9.4 
 restriction  13.12 
 selector_name  4.1.3 
 task_body  9.1 
 task_definition  9.1 
identifier_extend  2.3 
 identifier  2.3 
identifier_start  2.3 
 identifier  2.3 
if_expression  4.5.7 
 conditional_expression  4.5.7 
if_statement  5.3 
 compound_statement  5.1 
implicit_dereference  4.1 
 prefix  4.1 
incomplete_type_declaration  3.10.1 
 type_declaration  3.2.1 
index_constraint  3.6.1 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      836  composite_constraint  3.2.2 
index_subtype_definition  3.6 
 unconstrained_array_definition  3.6 
indexed_component  4.1.1 
 name  4.1 
integer_type_definition  3.5.4 
 type_definition  3.2.1 
interface_list  3.9.4 
 derived_type_definition  3.4 
 formal_derived_type_definition  12.5.1 
 interface_type_definition  3.9.4 
 private_extension_declaration  7.3 
 protected_type_declaration  9.4 
 single_protected_declaration  9.4 
 single_task_declaration  9.1 
 task_type_declaration  9.1 
interface_type_definition  3.9.4 
 formal_interface_type_definition  12.5.5 
 type_definition  3.2.1 
iteration_scheme  5.5 
 loop_statement  5.5 
iterator_spec ification  5.5.2 
 iteration_scheme  5.5 
 quantified_expression  4.5.8 
known_discriminant_part  3.7 
 discriminant_part  3.7 
 full_type_declaration  3.2.1 
 protected_type_declaration  9.4 
 task_type_declaration  9.1 
label  5.1 
 sequence_of_statements  5.1 
 statement  5.1 
last_bit  13.5.1 
 component_clause  13.5.1 
letter_lowercase  ... 
 identifier_start  2.3 
letter_modifier  ... 
 identifier_start  2.3 
letter_other  ... 
 identifier_start  2.3 
letter_titlecase  ... 
 identifier_start  2.3 
letter_uppercase  ... 
 identifier_start  2.3 
library_item  10.1.1 
 compilation_unit  10.1.1 
library_unit_body  10.1.1  library_item  10.1.1 
library_unit_declaration  10.1.1 
 library_item  10.1.1 
library_unit_renaming_declaration  10.1.1 
 library_item  10.1.1 
limited_with_clause  10.1.2 
 with_clause  10.1.2 
local_name  13.1 
 attribute_definition_clause  13.3 
 component_clause  13.5.1 
 enumeration_repres entation_clause  13.4 
 record_representation_clause  13.5.1 
loop_parameter_s pecification  5.5 
 iteration_scheme  5.5 
 quantified_expression  4.5.8 
loop_statement  5.5 
 compound_statement  5.1 
mark_non_spacing  ... 
 identifier_extend  2.3 
mark_spacing_combining  ... 
 identifier_extend  2.3 
membership_choice  4.4 
 membership_choice_list  4.4 
membership_choice_list  4.4 
 relation  4.4 
mod_clause  J.8 
 record_representation_clause  13.5.1 
mode  6.1 
 formal_object_declaration  12.4 
 parameter_spec ification  6.1 
modular_type_definition  3.5.4 
 integer_type_definition  3.5.4 
multiplying_operator  4.5 
 term 4.4 
name  4.1 
 abort_statement  9.8 
 aspect_definition  13.1.1 
 assignment_statement  5.2 
 attribute_definition_clause  13.3 
 default_name  12.6 
 entry_call_statement  9.5.3 
 exception_choice  11.2 
 exception_renaming_declaration  8.5.2 
 exit_statement  5.7 
 explicit_actual_parameter  6.4 
 explicit_dereference  4.1 
 explicit_generic_ac tual_parameter  12.3 
 formal_package_declaration  12.7 
Ada Reference Manual — 2012 Edition 
837      13 December 2012 Syntax Summary   Annex P  function_call  6.4 
 generalized_reference  4.1.5 
 generic_instantiation  12.3 
 generic_renaming_declaration  8.5.5 
 goto_statement  5.8 
 implicit_dereference  4.1 
 iterator_spec ification  5.5.2 
 limited_with_clause  10.1.2 
 local_name  13.1 
 nonlimited_with_clause  10.1.2 
 object_renaming_declaration  8.5.1 
 package_renaming_declaration  8.5.3 
 parent_unit_name  10.1.1 
 pragma_argument_association  2.8 
 prefix  4.1 
 primary  4.4 
 procedure_call_statement  6.4 
 raise_statement  11.3 
 requeue_statement  9.5.4 
 restriction_parameter_argument  13.12 
 storage_pool_indicator  13.11.3 
 subpool_specification  4.8 
 subprogram_renaming_declaration  8.5.4 
 subtype_mark  3.2.2 
 type_conversion  4.6 
 use_package_clause  8.4 
named_array_aggregate  4.3.3 
 array_aggregate  4.3.3 
nonlimited_with_clause  10.1.2 
 with_clause  10.1.2 
null_exclusion  3.10 
 access_definition  3.10 
 access_type_definition  3.10 
 discriminant_specification  3.7 
 formal_object_declaration  12.4 
 object_renaming_declaration  8.5.1 
 parameter_and_result_profile  6.1 
 parameter_spec ification  6.1 
 subtype_indication  3.2.2 
null_procedure_declaration  6.7 
 basic_declaration  3.1 
null_statement  5.1 
 simple_statement  5.1 
number_decimal  ... 
 identifier_extend  2.3 
number_declaration  3.3.2 
 basic_declaration  3.1 
number_letter  ... 
 identifier_start  2.3 
numeral  2.4.1 
 base  2.4.2 
 decimal_literal  2.4.1 
 exponent  2.4.1 numeric_literal  2.4 
 primary  4.4 
object_declaration  3.3.1 
 basic_declaration  3.1 
object_renaming_declaration  8.5.1 
 renaming_declaration  8.5 
operator_symbol  6.1 
 defining_operator_symbol  6.1 
 designator  6.1 
 direct_name  4.1 
 selector_name  4.1.3 
ordinary_fixed_point_definition  3.5.9 
 fixed_point_definition  3.5.9 
overriding_indicator  8.3.1 
 abstract_subprogram_declaration  3.9.3 
 entry_declaration  9.5.2 
 expression_function_declaration  6.8 
 generic_instantiation  12.3 
 null_procedure_declaration  6.7 
 subprogram_body  6.3 
 subprogram_body_stub  10.1.3 
 subprogram_declaration  6.1 
 subprogram_renaming_declaration  8.5.4 
package_body  7.2 
 library_unit_body  10.1.1 
 proper_body  3.11 
package_body_stub  10.1.3 
 body_stub  10.1.3 
package_declaration  7.1 
 basic_declaration  3.1 
 library_unit_declaration  10.1.1 
package_renaming_declaration  8.5.3 
 library_unit_renaming_declaration  10.1.1 
 renaming_declaration  8.5 
package_specification  7.1 
 generic_package_declaration  12.1 
 package_declaration  7.1 
parameter_and_result_profile  6.1 
 access_definition  3.10 
 access_to_subprogram_definition  3.10 
 function_specification  6.1 
parameter_association  6.4 
 actual_parameter_part  6.4 
parameter_profile  6.1 
 accept_statement  9.5.2 
 access_definition  3.10 
 access_to_subprogram_definition  3.10 
 entry_body_formal_part  9.5.2 
 entry_declaration  9.5.2 
 procedure_spec ification  6.1 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      838 parameter_spec ification  6.1 
 formal_part  6.1 
parent_unit_name  10.1.1 
 defining_program_unit_name  6.1 
 designator  6.1 
 package_body  7.2 
 package_specification  7.1 
 subunit  10.1.3 
position  13.5.1 
 component_clause  13.5.1 
positional_array_aggregate  4.3.3 
 array_aggregate  4.3.3 
pragma_argument_association  2.8 
 pragma  2.8 
predicate  4.5.8 
 quantified_expression  4.5.8 
prefix  4.1 
 attribute_reference  4.1.4 
 function_call  6.4 
 generalized_indexing  4.1.6 
 indexed_component  4.1.1 
 procedure_call_statement  6.4 
 range_attribute_reference  4.1.4 
 selected_component  4.1.3 
 slice  4.1.2 
primary  4.4 
 factor  4.4 
private_extension_declaration  7.3 
 type_declaration  3.2.1 
private_type_declaration  7.3 
 type_declaration  3.2.1 
procedure_call_statement  6.4 
 procedure_or_entry_call  9.7.2 
 simple_statement  5.1 
procedure_or_entry_call  9.7.2 
 entry_call_alternative  9.7.2 
 triggering_statement  9.7.4 
procedure_spec ification  6.1 
 null_procedure_declaration  6.7 
 subprogram_spec ification  6.1 
proper_body  3.11 
 body  3.11 
 subunit  10.1.3 
protected_body  9.4 
 proper_body  3.11 
protected_body_stub  10.1.3 
 body_stub  10.1.3 protected_definition  9.4 
 protected_type_declaration  9.4 
 single_protected_declaration  9.4 
protected_element_declaration  9.4 
 protected_definition  9.4 
protected_operation_declaration  9.4 
 protected_definition  9.4 
 protected_element_declaration  9.4 
protected_operation_item  9.4 
 protected_body  9.4 
protected_type_declaration  9.4 
 full_type_declaration  3.2.1 
punctuation_connector  ... 
 identifier_extend  2.3 
qualified_expression  4.7 
 allocator  4.8 
 code_statement  13.8 
 name  4.1 
quantified_expression  4.5.8 
 primary  4.4 
quantifier  4.5.8 
 quantified_expression  4.5.8 
raise_statement  11.3 
 simple_statement  5.1 
range  3.5 
 discrete_choice  3.8.1 
 discrete_range  3.6.1 
 discrete_subtype_definition  3.6 
 membership_choice  4.4 
 range_constraint  3.5 
range_attribute_designator  4.1.4 
 range_attribute_reference  4.1.4 
range_attribute_reference  4.1.4 
 range  3.5 
range_constraint  3.5 
 delta_constraint  J.3 
 digits_constraint  3.5.9 
 scalar_constraint  3.2.2 
real_range_specification  3.5.7 
 decimal_fixed_point_definition  3.5.9 
 floating_point_definition  3.5.7 
 ordinary_fixed_point_definition  3.5.9 
real_type_definition  3.5.6 
 type_definition  3.2.1 
record_aggregate  4.3.1 
 aggregate  4.3 
record_component_association  4.3.1 
Ada Reference Manual — 2012 Edition 
839      13 December 2012 Syntax Summary   Annex P  record_component_association_list  4.3.1 
record_component_association_list  4.3.1 
 extension_aggregate  4.3.2 
 record_aggregate  4.3.1 
record_definition  3.8 
 record_extension_part  3.9.1 
 record_type_definition  3.8 
record_extension_part  3.9.1 
 derived_type_definition  3.4 
record_representation_clause  13.5.1 
 aspect_clause  13.1 
record_type_definition  3.8 
 type_definition  3.2.1 
relation  4.4 
 expression  4.4 
relational_operator  4.5 
 choice_relation  4.4 
 relation  4.4 
renaming_declaration  8.5 
 basic_declaration  3.1 
requeue_statement  9.5.4 
 simple_statement  5.1 
restriction_parameter_argument  13.12 
 restriction  13.12 
return_subtype_indication  6.5 
 extended_return_object_declaration  6.5 
scalar_constraint  3.2.2 
 constraint  3.2.2 
select_alternative  9.7.1 
 selective_accept  9.7.1 
select_statement  9.7 
 compound_statement  5.1 
selected_component  4.1.3 
 name  4.1 
selective_accept  9.7.1 
 select_statement  9.7 
selector_name  4.1.3 
 component_choice_list  4.3.1 
 discriminant_association  3.7.1 
 formal_package_association  12.7 
 generic_association  12.3 
 parameter_association  6.4 
 selected_component  4.1.3 
sequence_of_statements  5.1 
 abortable_part  9.7.4 
 accept_alternative  9.7.1  case_statement_alternative  5.4 
 conditional_entry_call  9.7.3 
 delay_alternative  9.7.1 
 entry_call_alternative  9.7.2 
 exception_handler  11.2 
 handled_sequence_of_statements  11.2 
 if_statement  5.3 
 loop_statement  5.5 
 selective_accept  9.7.1 
 triggering_alternative  9.7.4 
signed_integer_type_definition  3.5.4 
 integer_type_definition  3.5.4 
simple_expression  4.4 
 choice_relation  4.4 
 first_bit  13.5.1 
 last_bit  13.5.1 
 range  3.5 
 real_range_specification  3.5.7 
 relation  4.4 
 signed_integer_type_definition  3.5.4 
simple_return_statement  6.5 
 simple_statement  5.1 
simple_statement  5.1 
 statement  5.1 
single_protected_declaration  9.4 
 object_declaration  3.3.1 
single_task_declaration  9.1 
 object_declaration  3.3.1 
slice  4.1.2 
 name  4.1 
statement  5.1 
 sequence_of_statements  5.1 
statement_identifier  5.1 
 block_statement  5.6 
 label  5.1 
 loop_statement  5.5 
string_element  2.6 
 string_literal  2.6 
string_literal  2.6 
 operator_symbol  6.1 
 primary  4.4 
subpool_specification  4.8 
 allocator  4.8 
subprogram_body  6.3 
 library_unit_body  10.1.1 
 proper_body  3.11 
 protected_operation_item  9.4 
subprogram_body_stub  10.1.3 
 body_stub  10.1.3 
Ada Reference Manual — 2012 Edition 
Annex P    Syntax Summary 13 December 2012      840 subprogram_declaration  6.1 
 basic_declaration  3.1 
 library_unit_declaration  10.1.1 
 protected_operation_declaration  9.4 
 protected_operation_item  9.4 
subprogram_default  12.6 
 formal_abstract_subprogram_declaration  12.6 
 formal_concrete_subprogram_declaration  12.6 
subprogram_renaming_declaration  8.5.4 
 library_unit_renaming_declaration  10.1.1 
 renaming_declaration  8.5 
subprogram_spec ification  6.1 
 abstract_subprogram_declaration  3.9.3 
 formal_abstract_subprogram_declaration  12.6 
 formal_concrete_subprogram_declaration  12.6 
 generic_subprogram_declaration  12.1 
 subprogram_body  6.3 
 subprogram_body_stub  10.1.3 
 subprogram_declaration  6.1 
 subprogram_renaming_declaration  8.5.4 
subtype_declaration  3.2.2 
 basic_declaration  3.1 
subtype_indication  3.2.2 
 access_to_object_definition  3.10 
 allocator  4.8 
 component_definition  3.6 
 derived_type_definition  3.4 
 discrete_choice  3.8.1 
 discrete_range  3.6.1 
 discrete_subtype_definition  3.6 
 iterator_spec ification  5.5.2 
 object_declaration  3.3.1 
 private_extension_declaration  7.3 
 return_subtype_indication  6.5 
 subtype_declaration  3.2.2 
subtype_mark  3.2.2 
 access_definition  3.10 
 ancestor_part  4.3.2 
 discriminant_specification  3.7 
 explicit_generic_ac tual_parameter  12.3 
 formal_derived_type_definition  12.5.1 
 formal_object_declaration  12.4 
 index_subtype_definition  3.6 
 interface_list  3.9.4 
 membership_choice  4.4 
 object_renaming_declaration  8.5.1 
 parameter_and_result_profile  6.1 
 parameter_spec ification  6.1 
 qualified_expression  4.7 
 subtype_indication  3.2.2 
 type_conversion  4.6 
 use_type_clause  8.4 
subunit  10.1.3 
 compilation_unit  10.1.1 task_body  9.1 
 proper_body  3.11 
task_body_stub  10.1.3 
 body_stub  10.1.3 
task_definition  9.1 
 single_task_declaration  9.1 
 task_type_declaration  9.1 
task_item  9.1 
 task_definition  9.1 
task_type_declaration  9.1 
 full_type_declaration  3.2.1 
term 4.4 
 simple_expression  4.4 
terminate_alternative  9.7.1 
 select_alternative  9.7.1 
timed_entry_call  9.7.2 
 select_statement  9.7 
triggering_alternative  9.7.4 
 asynchronous_select  9.7.4 
triggering_statement  9.7.4 
 triggering_alternative  9.7.4 
type_conversion  4.6 
 name  4.1 
type_declaration  3.2.1 
 basic_declaration  3.1 
type_definition  3.2.1 
 full_type_declaration  3.2.1 
unary_adding_operator  4.5 
 simple_expression  4.4 
unconstrained_array_definition  3.6 
 array_type_definition  3.6 
underline  ... 
 based_numeral  2.4.2 
 numeral  2.4.1 
unknown_discriminant_part  3.7 
 discriminant_part  3.7 
use_clause  8.4 
 basic_declarative_item  3.11 
 context_item  10.1.2 
 generic_formal_part  12.1 
use_package_clause  8.4 
 use_clause  8.4 
use_type_clause  8.4 
 use_clause  8.4 
Ada Reference Manual — 2012 Edition 
841      13 December 2012 Syntax Summary   Annex P variant  3.8.1 
 variant_part  3.8.1 
variant_part  3.8.1  component_list  3.8 
with_clause  10.1.2 
 context_item  10.1.2 

Ada Reference Manual — 2012 Edition 
843      13 December 2012 Language-Defined Entities   Annex Q Annex Q 
(informative)  
Language-Defined Entities 
This annex lists the language-defined  entities of the language. A list of language-defined library units can 
be found in Annex A, “Predefi ned Language Environment”.  
Q.1 Language-Defined Packages 
This subclause lists all la nguage-defined packages.  
  
Ada   A.2(2) 
Address_To_Access_Conversions    child of  System   13.7.2(2) 
Arithmetic    child of  Ada.Calendar   9.6.1(8/2) 
ASCII    in Standard   A.1(36.3/2) 
Assertions    child of  Ada   11.4.2(12/2) 
Asynchronous_Task_Control    child of  Ada   D.11(3/2) 
Bounded    child of  Ada.Strings   A.4.4(3) 
Bounded_IO    child of  Ada.Text_IO   A.10.11(3/2) 
   child of  Ada.Wide_Text_IO   A.11(4/3) 
   child of  Ada.Wide_Wide_Text_IO   A.11(4/3) 
Bounded_Priority_Queues    child of  Ada.Containers   A.18.31(2/3) 
Bounded_Synchronized_Queues    child of  Ada.Containers   A.18.29(2/3) 
C    child of  Interfaces   B.3(4) 
Calendar    child of  Ada   9.6(10) 
Characters    child of  Ada   A.3.1(2) 
COBOL    child of  Interfaces   B.4(7) 
Command_Line    child of  Ada   A.15(3) 
Complex_Arrays    child of  Ada.Numerics   G.3.2(53/2) 
Complex_Elementary_Functions    child of  Ada.Numerics   G.1.2(9/1) 
Complex_Text_IO    child of  Ada   G.1.3(9.1/2) 
Complex_Types    child of  Ada.Numerics   G.1.1(25/1) 
Complex_IO    child of  Ada.Text_IO   G.1.3(3) 
   child of  Ada.Wide_Text_IO   G.1.4(1)    child of  Ada.Wide_Wide_Text_IO   G.1.5(1/2) 
Constants    child of  Ada.Strings.Maps   A.4.6(3/2) 
Containers    child of  Ada   A.18.1(3/2) 
Conversions    child of  Ada.Characters   A.3.4(2/2) 
   child of  Ada.Strings.UTF_Encoding   A.4.11(15/3) 
Decimal    child of  Ada   F.2(2) 
Decimal_Conversions    in Interfaces.COBOL   B.4(31) 
Decimal_IO    in Ada.Text_IO   A.10.1(73) 
Decimal_Output    in Ada.Text_IO.Editing   F.3.3(11) 
Direct_IO    child of  Ada   A.8.4(2) 
Directories    child of  Ada   A.16(3/2) 
Discrete_Random    child of  Ada.Numerics   A.5.2(17) 
Dispatching    child of  Ada   D.2.1(1.2/3) 
Dispatching_Domains    child of  System.Multiprocessors   D.16.1(3/3) 
Doubly_Linked_Lists    child of  Ada.Containers   A.18.3(5/3) 
Dynamic_Priorities    child of  Ada   D.5.1(3/2) 
EDF    child of  Ada.Dispatching   D.2.6(9/2) 
   child of  Ada.Synchronous_Task_Control   D.10(5.2/3) 
Editing    child of  Ada.Text_IO   F.3.3(3) 
   child of  Ada.Wide_Text_IO   F.3.4(1) 
   child of  Ada.Wide_Wide_Text_IO   F.3.5(1/2) 
Elementary_Functions    child of  Ada.Numerics   A.5.1(9/1) 
Enumeration_IO    in Ada.Text_IO   A.10.1(79) 1/2 
1/3 
Ada Reference Manual — 2012 Edition 
Q.1   Language-Defined Packages 13 December 2012      844 Environment_Variables 
   child of  Ada   A.17(3/2) 
Exceptions    child of  Ada   11.4.1(2/2) 
Execution_Time    child of  Ada   D.14(3/2) 
Finalization    child of  Ada   7.6(4/3) 
Fixed    child of  Ada.Strings   A.4.3(5) 
Fixed_IO    in Ada.Text_IO   A.10.1(68) 
Float_Random    child of  Ada.Numerics   A.5.2(5) 
Float_Text_IO    child of  Ada   A.10.9(33) 
Float_Wide_Text_IO    child of  Ada   A.11(2/2) 
Float_Wide_Wide_Text_IO    child of  Ada   A.11(3/2) 
Float_IO    in Ada.Text_IO   A.10.1(63) 
Formatting    child of  Ada.Calendar   9.6.1(15/2) 
Fortran    child of  Interfaces   B.5(4) 
Generic_Complex_Arrays    child of  Ada.Numerics   G.3.2(2/2) 
Generic_Complex_Elementary_Functions    child of  Ada.Numerics   G.1.2(2/2) 
Generic_Complex_Types    child of  Ada.Numerics   G.1.1(2/1) 
Generic_Dispatching_Constructor    child of  Ada.Tags   3.9(18.2/3) 
Generic_Elementary_Functions    child of  Ada.Numerics   A.5.1(3) 
Generic_Bounded_Length    in Ada.Strings.Bounded   A.4.4(4) 
Generic_Keys    in Ada.Containers.Hashed_Sets   A.18.8(50/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(62/2) 
Generic_Real_Arrays    child of  Ada.Numerics   G.3.1(2/2) 
Generic_Sorting    in Ada.Containers.Doubly_Linked_Lists   A.18.3(47/2) 
   in Ada.Containers.Vectors   A.18.2(75/2) 
Group_Budgets    child of  Ada.Execution_Time   D.14.2(3/3) 
Handling    child of  Ada.Characters   A.3.2(2/2) 
   child of  Ada.Wide_Characters   A.3.5(3/3) 
   child of  Ada.Wide_Wide_Characters   A.3.6(1/3) 
Hashed_Maps    child of  Ada.Containers   A.18.5(2/3) 
Hashed_Sets    child of  Ada.Containers   A.18.8(2/3) 
Hierarchical_File_Names    child of  Ada.Directories   A.16.1(3/3) 
Indefinite_Doubly_Linked_Lists    child of  Ada.Containers   A.18.12(2/3) Indefinite_Hashed_Maps 
   child of  Ada.Containers   A.18.13(2/3) 
Indefinite_Hashed_Sets    child of  Ada.Containers   A.18.15(2/3) 
Indefinite_Holders    child of  Ada.Containers   A.18.18(5/3) 
Indefinite_Multiway_Trees    child of  Ada.Containers   A.18.17(2/3) 
Indefinite_Ordered_Maps    child of  Ada.Containers   A.18.14(2/3) 
Indefinite_Ordered_Sets    child of  Ada.Containers   A.18.16(2/3) 
Indefinite_Vectors    child of  Ada.Containers   A.18.11(2/3) 
Information    child of  Ada.Directories   A.16(124/2) 
Integer_Text_IO    child of  Ada   A.10.8(21) 
Integer_Wide_Text_IO    child of  Ada   A.11(2/2) 
Integer_Wide_Wide_Text_IO    child of  Ada   A.11(3/2) 
Integer_IO    in Ada.Text_IO   A.10.1(52) 
Interfaces   B.2(3) Interrupts    child of  Ada   C.3.2(2/3) 
   child of  Ada.Execution_Time   D.14.3(3/3) 
IO_Exceptions    child of  Ada   A.13(3) 
Iterator_Interfaces    child of  Ada   5.5.1(2/3) 
Latin_1    child of  Ada.Characters   A.3.3(3) 
List_Iterator_Interfaces    in Ada.Containers.Doubly_Linked_Lists   A.18.3(9.2/3) 
Locales    child of  Ada   A.19(3/3) 
Machine_Code    child of  System   13.8(7) 
Map_Iterator_Interfaces    in Ada.Containers.Hashed_Maps   A.18.5(6.2/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(7.2/3) 
Maps    child of  Ada.Strings   A.4.2(3/2) 
Modular_IO    in Ada.Text_IO   A.10.1(57) 
Multiprocessors    child of  System   D.16(3/3) 
Multiway_Trees    child of  Ada.Containers   A.18.10(7/3) 
Names    child of  Ada.Interrupts   C.3.2(12) 
Non_Preemptive    child of  Ada.Dispatching   D.2.4(2.2/3) 
Numerics    child of  Ada   A.5(3/2) 
Ordered_Maps    child of  Ada.Containers   A.18.6(2/3) 
Ada Reference Manual — 2012 Edition 
845      13 December 2012 Language-Defined Packages   Q.1 Ordered_Sets 
   child of  Ada.Containers   A.18.9(2/3) 
Pointers    child of  Interfaces.C   B.3.2(4) 
Real_Arrays    child of  Ada.Numerics   G.3.1(31/2) 
Real_Time    child of  Ada   D.8(3) 
Round_Robin    child of  Ada.Dispatching   D.2.5(4/2) 
RPC    child of  System   E.5(3) 
Sequential_IO    child of  Ada   A.8.1(2) 
Set_Iterator_Interfaces    in Ada.Containers.Hashed_Sets   A.18.8(6.2/3) 
   in Ada.Containers.Ordered_Sets   A.18.9(7.2/3) 
Single_Precision_Complex_Types    in Interfaces.Fortran   B.5(8) 
Standard   A.1(4) Storage_Elements    child of  System   13.7.1(2/2) 
Storage_IO    child of  Ada   A.9(3) 
Storage_Pools    child of  System   13.11(5) 
Stream_IO    child of  Ada.Streams   A.12.1(3/3) 
Streams    child of  Ada   13.13.1(2) 
Strings    child of  Ada   A.4.1(3) 
   child of  Ada.Strings.UTF_Encoding   A.4.11(22/3) 
   child of  Interfaces.C   B.3.1(3) 
Subpools    child of  System.Storage_Pools   13.11.4(3/3) 
Synchronized_Queue_Interfaces    child of  Ada.Containers   A.18.27(3/3) 
Synchronous_Barriers    child of  Ada   D.10.1(3/3) 
Synchronous_Task_Control    child of  Ada   D.10(3/2) 
System   13.7(3/2) Tags    child of  Ada   3.9(6/2) 
Task_Attributes    child of  Ada   C.7.2(2) 
Task_Identification    child of  Ada   C.7.1(2/2) 
Task_Termination    child of  Ada   C.7.3(2/2) 
Text_Streams    child of  Ada.Text_IO   A.12.2(3) 
   child of  Ada.Wide_Text_IO   A.12.3(3) 
   child of  Ada.Wide_Wide_Text_IO   A.12.4(3/2) 
Text_IO    child of  Ada   A.10.1(2) 
Time_Zones    child of  Ada.Calendar   9.6.1(2/2) Timers 
   child of  Ada.Execution_Time   D.14.1(3/2) 
Timing_Events    child of  Ada.Real_Time   D.15(3/2) 
Tree_Iterator_Interfaces    in Ada.Containers.Multiway_Trees   A.18.10(13/3) 
Unbounded    child of  Ada.Strings   A.4.5(3) 
Unbounded_IO    child of  Ada.Text_IO   A.10.12(3/2) 
   child of  Ada.Wide_Text_IO   A.11(5/3) 
   child of  Ada.Wide_Wide_Text_IO   A.11(5/3) 
Unbounded_Priority_Queues    child of  Ada.Containers   A.18.30(2/3) 
Unbounded_Synchronized_Queues    child of  Ada.Containers   A.18.28(2/3) 
UTF_Encoding    child of  Ada.Strings   A.4.11(3/3) 
Vector_Iterator_Interfaces    in Ada.Containers.Vectors   A.18.2(11.2/3) 
Vectors    child of  Ada.Containers   A.18.2(6/3) 
Wide_Bounded    child of  Ada.Strings   A.4.7(1/3) 
Wide_Constants    child of  Ada.Strings.Wide_Maps   A.4.7(1/3), A.4.8(28/2) 
Wide_Equal_Case_Insensitive    child of  Ada.Strings   A.4.7(1/3) 
Wide_Fixed    child of  Ada.Strings   A.4.7(1/3) 
Wide_Hash    child of  Ada.Strings   A.4.7(1/3) 
Wide_Hash_Case_Insensitive    child of  Ada.Strings   A.4.7(1/3) 
Wide_Maps    child of  Ada.Strings   A.4.7(3) 
Wide_Text_IO    child of  Ada   A.11(2/2) 
Wide_Unbounded    child of  Ada.Strings   A.4.7(1/3) 
Wide_Characters    child of  Ada   A.3.1(4/2) 
Wide_Strings    child of  Ada.Strings.UTF_Encoding   A.4.11(30/3) 
Wide_Wide_Constants    child of  Ada.Strings.Wide_Wide_Maps   A.4.8(1/3) 
Wide_Wide_Equal_Case_Insensitive    child of  Ada.Strings   A.4.8(1/3) 
Wide_Wide_Hash    child of  Ada.Strings   A.4.8(1/3) 
Wide_Wide_Hash_Case_Insensitive    child of  Ada.Strings   A.4.8(1/3) 
Wide_Wide_Text_IO    child of  Ada   A.11(3/2) 
Wide_Wide_Bounded    child of  Ada.Strings   A.4.8(1/3) 
Wide_Wide_Characters    child of  Ada   A.3.1(6/2) 
Wide_Wide_Fixed    child of  Ada.Strings   A.4.8(1/3) 
Ada Reference Manual — 2012 Edition 
Q.1   Language-Defined Packages 13 December 2012      846 Wide_Wide_Maps 
   child of  Ada.Strings   A.4.8(3/2) 
Wide_Wide_Strings    child of  Ada.Strings.UTF_Encoding   A.4.11(38/3) Wide_Wide_Unbounded 
   child of  Ada.Strings   A.4.8(1/3) 
Q.2 Language-Defined Types and Subtypes 
This subclause lists all language -defined types and subtypes.  
  
Address 
   in System   13.7(12) 
Alignment    in Ada.Strings   A.4.1(6) 
Alphanumeric    in Interfaces.COBOL   B.4(16/3) 
Any_Priority subtype of  Integer 
   in System   13.7(16) 
Attribute_Handle    in Ada.Task_Attributes   C.7.2(3) 
Barrier_Limit subtype of  Positive 
   in Ada.Synchronous_Barriers   D.10.1(4/3) 
Binary    in Interfaces.COBOL   B.4(10) 
Binary_Format    in Interfaces.COBOL   B.4(24) 
Bit_Order    in System   13.7(15/2) 
Boolean    in Standard   A.1(5) 
Bounded_String    in Ada.Strings.Bounded   A.4.4(6) 
Buffer_Type subtype of  Storage_Array 
   in Ada.Storage_IO   A.9(4) 
Byte    in Interfaces.COBOL   B.4(29/3) 
Byte_Array    in Interfaces.COBOL   B.4(29/3) 
C_float    in Interfaces.C   B.3(15) 
Cause_Of_Termination    in Ada.Task_Termination   C.7.3(3/2) 
char    in Interfaces.C   B.3(19) 
char16_array    in Interfaces.C   B.3(39.5/3) 
char16_t    in Interfaces.C   B.3(39.2/2) 
char32_array    in Interfaces.C   B.3(39.14/3) 
char32_t    in Interfaces.C   B.3(39.11/2) 
char_array    in Interfaces.C   B.3(23/3) 
char_array_access    in Interfaces.C.Strings   B.3.1(4) Character 
   in Standard   A.1(35/3) 
Character_Mapping    in Ada.Strings.Maps   A.4.2(20/2) 
Character_Mapping_Function    in Ada.Strings.Maps   A.4.2(25) 
Character_Range    in Ada.Strings.Maps   A.4.2(6) 
Character_Ranges    in Ada.Strings.Maps   A.4.2(7) 
Character_Sequence subtype of  String 
   in Ada.Strings.Maps   A.4.2(16) 
Character_Set    in Ada.Strings.Maps   A.4.2(4/2) 
   in Interfaces.Fortran   B.5(11) 
chars_ptr    in Interfaces.C.Strings   B.3.1(5/2) 
chars_ptr_array    in Interfaces.C.Strings   B.3.1(6/2) 
COBOL_Character    in Interfaces.COBOL   B.4(13) 
Complex    in Ada.Numerics.Generic_Complex_Types   G.1.1(3) 
   in Interfaces.Fortran   B.5(9) 
Complex_Matrix    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(4/2) 
Complex_Vector    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(4/2) 
Constant_Reference_Type    in Ada.Containers.Indefinite_Holders   A.18.18(16/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(28/3) 
Controlled    in Ada.Finalization   7.6(5/2) 
Count    in Ada.Direct_IO   A.8.4(4) 
   in Ada.Streams.Stream_IO   A.12.1(7) 
   in Ada.Text_IO   A.10.1(5) 
Count_Type    in Ada.Containers   A.18.1(5/2) 
Country_Code    in Ada.Locales   A.19(4/3) 
CPU subtype of  CPU_Range 
   in System.Multiprocessors   D.16(4/3) 
CPU_Range    in System.Multiprocessors   D.16(4/3) 
CPU_Time    in Ada.Execution_Time   D.14(4/2) 1/3 
Ada Reference Manual — 2012 Edition 
847      13 December 2012 Language-Defined Types and Subtypes   Q.2 Cursor 
   in Ada.Containers.Doubly_Linked_Lists   A.18.3(7/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(4/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(4/2) 
   in Ada.Containers.Multiway_Trees   A.18.10(9/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(5/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(5/2) 
   in Ada.Containers.Vectors   A.18.2(9/2) 
Day_Count    in Ada.Calendar.Arithmetic   9.6.1(10/2) 
Day_Duration subtype of  Duration 
   in Ada.Calendar   9.6(11/2) 
Day_Name    in Ada.Calendar.Formatting   9.6.1(17/2) 
Day_Number subtype of  Integer 
   in Ada.Calendar   9.6(11/2) 
Deadline subtype of  Time 
   in Ada.Dispatching.EDF   D.2.6(9/2) 
Decimal_Element    in Interfaces.COBOL   B.4(12/3) 
Direction    in Ada.Strings   A.4.1(6) 
Directory_Entry_Type    in Ada.Directories   A.16(29/2) 
Dispatching_Domain    in System.Multiprocessors.Dispatching_Domains   
D.16.1(5/3) 
Display_Format    in Interfaces.COBOL   B.4(22) 
double    in Interfaces.C   B.3(16) 
Double_Precision    in Interfaces.Fortran   B.5(6) 
Duration    in Standard   A.1(43) 
Encoding_Scheme    in Ada.Strings.UTF_Encoding   A.4.11(4/3) 
Exception_Id    in Ada.Exceptions   11.4.1(2/2) 
Exception_Occurrence    in Ada.Exceptions   11.4.1(3/2) 
Exception_Occurrence_Access    in Ada.Exceptions   11.4.1(3/2) 
Exit_Status    in Ada.Command_Line   A.15(7) 
Extended_Index subtype of  Index_Type'Base 
   in Ada.Containers.Vectors   A.18.2(7/2) 
Field subtype of  Integer 
   in Ada.Text_IO   A.10.1(6) 
File_Access    in Ada.Text_IO   A.10.1(18) 
File_Kind    in Ada.Directories   A.16(22/2) 
File_Mode    in Ada.Direct_IO   A.8.4(4) 
   in Ada.Sequential_IO   A.8.1(4) 
   in Ada.Streams.Stream_IO   A.12.1(6) 
   in Ada.Text_IO   A.10.1(4) 
File_Size    in Ada.Directories   A.16(23/2) File_Type 
   in Ada.Direct_IO   A.8.4(3) 
   in Ada.Sequential_IO   A.8.1(3) 
   in Ada.Streams.Stream_IO   A.12.1(5) 
   in Ada.Text_IO   A.10.1(3) 
Filter_Type    in Ada.Directories   A.16(30/2) 
Float    in Standard   A.1(21) 
Floating    in Interfaces.COBOL   B.4(9) 
Fortran_Character    in Interfaces.Fortran   B.5(12/3) 
Fortran_Integer    in Interfaces.Fortran   B.5(5) 
Forward_Iterator    in Ada.Iterator_Interfaces   5.5.1(3/3) 
Generator    in Ada.Numerics.Discrete_Random   A.5.2(19) 
   in Ada.Numerics.Float_Random   A.5.2(7) 
Group_Budget    in Ada.Execution_Time.Group_Budgets   D.14.2(4/3) 
Group_Budget_Handler    in Ada.Execution_Time.Group_Budgets   D.14.2(5/2) 
Hash_Type    in Ada.Containers   A.18.1(4/2) 
Holder    in Ada.Containers.Indefinite_Holders   A.18.18(6/3) 
Hour_Number subtype of  Natural 
   in Ada.Calendar.Formatting   9.6.1(20/2) 
Imaginary    in Ada.Numerics.Generic_Complex_Types   G.1.1(4/2) 
Imaginary subtype of  Imaginary 
   in Interfaces.Fortran   B.5(10) 
int    in Interfaces.C   B.3(7) 
Integer    in Standard   A.1(12) 
Integer_Address    in System.Storage_Elements   13.7.1(10/3) 
Interrupt_Id    in Ada.Interrupts   C.3.2(2/3) 
Interrupt_Priority subtype of  Any_Priority 
   in System   13.7(16) 
ISO_646 subtype of  Character 
   in Ada.Characters.Handling   A.3.2(9) 
Language_Code    in Ada.Locales   A.19(4/3) 
Leap_Seconds_Count subtype of  Integer 
   in Ada.Calendar.Arithmetic   9.6.1(11/2) 
Length_Range subtype of  Natural 
   in Ada.Strings.Bounded   A.4.4(8) 
Limited_Controlled    in Ada.Finalization   7.6(7/2) 
List    in Ada.Containers.Doubly_Linked_Lists   A.18.3(6/3) 
Logical    in Interfaces.Fortran   B.5(7) 
long    in Interfaces.C   B.3(7) 
Ada Reference Manual — 2012 Edition 
Q.2   Language-Defined Types and Subtypes 13 December 2012      848 Long_Binary 
   in Interfaces.COBOL   B.4(10) 
long_double    in Interfaces.C   B.3(17) 
Long_Floating    in Interfaces.COBOL   B.4(9) 
Map    in Ada.Containers.Hashed_Maps   A.18.5(3/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(4/3) 
Membership    in Ada.Strings   A.4.1(6) 
Minute_Number subtype of  Natural 
   in Ada.Calendar.Formatting   9.6.1(20/2) 
Month_Number subtype of  Integer 
   in Ada.Calendar   9.6(11/2) 
Name    in System   13.7(4) 
Name_Case_Kind    in Ada.Directories   A.16(20.1/3) 
Natural subtype of  Integer 
   in Standard   A.1(13) 
Number_Base subtype of  Integer 
   in Ada.Text_IO   A.10.1(6) 
Numeric    in Interfaces.COBOL   B.4(20/3) 
Packed_Decimal    in Interfaces.COBOL   B.4(12/3) 
Packed_Format    in Interfaces.COBOL   B.4(26) 
Parameterless_Handler    in Ada.Interrupts   C.3.2(2/3) 
Params_Stream_Type    in System.RPC   E.5(6) 
Partition_Id    in System.RPC   E.5(4) 
Picture    in Ada.Text_IO.Editing   F.3.3(4) 
plain_char    in Interfaces.C   B.3(11) 
Pointer    in Interfaces.C.Pointers   B.3.2(5) 
Positive subtype of  Integer 
   in Standard   A.1(13) 
Positive_Count subtype of  Count 
   in Ada.Direct_IO   A.8.4(4) 
   in Ada.Streams.Stream_IO   A.12.1(7) 
   in Ada.Text_IO   A.10.1(5) 
Priority subtype of  Any_Priority 
   in System   13.7(16) 
ptrdiff_t    in Interfaces.C   B.3(12) 
Queue    in Ada.Containers.Bounded_Priority_Queues   A.18.31(4/3) 
   in Ada.Containers.Bounded_Synchronized_Queues   
A.18.29(4/3) 
   in Ada.Containers.Synchronized_Queue_Interfaces   
A.18.27(4/3) 
   in Ada.Containers.Unbounded_Priority_Queues   
A.18.30(4/3)    in Ada.Containers.Unbounded_Synchronized_Queues   
A.18.28(4/3) 
Real    in Interfaces.Fortran   B.5(6) 
Real_Matrix    in Ada.Numerics.Generic_Real_Arrays   G.3.1(4/2) 
Real_Vector    in Ada.Numerics.Generic_Real_Arrays   G.3.1(4/2) 
Reference_Type    in Ada.Containers.Doubly_Linked_Lists   A.18.3(17.2/3) 
   in Ada.Containers.Hashed_Maps   A.18.5(17.2/3) 
   in Ada.Containers.Hashed_Sets   A.18.8(58.1/3) 
   in Ada.Containers.Indefinite_Holders   A.18.18(17/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(29/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(16.2/3) 
   in Ada.Containers.Ordered_Sets   A.18.9(73.1/3) 
   in Ada.Containers.Vectors   A.18.2(34.2/3) 
Reversible_Iterator    in Ada.Iterator_Interfaces   5.5.1(4/3) 
Root_Storage_Pool    in System.Storage_Pools   13.11(6/2) 
Root_Storage_Pool_With_Subpools    in System.Storage_Pools.Subpools   13.11.4(4/3) 
Root_Stream_Type    in Ada.Streams   13.13.1(3/2) 
Root_Subpool    in System.Storage_Pools.Subpools   13.11.4(5/3) 
RPC_Receiver    in System.RPC   E.5(11) 
Search_Type    in Ada.Directories   A.16(31/2) 
Second_Duration subtype of  Day_Duration 
   in Ada.Calendar.Formatting   9.6.1(20/2) 
Second_Number subtype of  Natural 
   in Ada.Calendar.Formatting   9.6.1(20/2) 
Seconds_Count    in Ada.Real_Time   D.8(15) 
Set    in Ada.Containers.Hashed_Sets   A.18.8(3/3) 
   in Ada.Containers.Ordered_Sets   A.18.9(4/3) 
short    in Interfaces.C   B.3(7) 
signed_char    in Interfaces.C   B.3(8) 
size_t    in Interfaces.C   B.3(13) 
State    in Ada.Numerics.Discrete_Random   A.5.2(23) 
   in Ada.Numerics.Float_Random   A.5.2(11) 
Storage_Array    in System.Storage_Elements   13.7.1(5) 
Storage_Count subtype of  Storage_Offset 
   in System.Storage_Elements   13.7.1(4) 
Storage_Element    in System.Storage_Elements   13.7.1(5) 
Storage_Offset    in System.Storage_Elements   13.7.1(3) 
Stream_Access    in Ada.Streams.Stream_IO   A.12.1(4) 
   in Ada.Text_IO.Text_Streams   A.12.2(3) 
Ada Reference Manual — 2012 Edition 
849      13 December 2012 Language-Defined Types and Subtypes   Q.2    in Ada.Wide_Text_IO.Text_Streams   A.12.3(3) 
   in Ada.Wide_Wide_Text_IO.Text_Streams   A.12.4(3/2) 
Stream_Element    in Ada.Streams   13.13.1(4/1) 
Stream_Element_Array    in Ada.Streams   13.13.1(4/1) 
Stream_Element_Count subtype of  Stream_Element_Offset 
   in Ada.Streams   13.13.1(4/1) 
Stream_Element_Offset    in Ada.Streams   13.13.1(4/1) 
String    in Standard   A.1(37/3) 
String_Access    in Ada.Strings.Unbounded   A.4.5(7) 
Subpool_Handle    in System.Storage_Pools.Subpools   13.11.4(6/3) 
Suspension_Object    in Ada.Synchronous_Task_Control   D.10(4) 
Synchronous_Barrier    in Ada.Synchronous_Barriers   D.10.1(5/3) 
Tag    in Ada.Tags   3.9(6/2) 
Tag_Array    in Ada.Tags   3.9(7.3/2) 
Task_Array    in Ada.Execution_Time.Group_Budgets   D.14.2(6/2) 
Task_Id    in Ada.Task_Identification   C.7.1(2/2) 
Termination_Handler    in Ada.Task_Termination   C.7.3(4/2) 
Time    in Ada.Calendar   9.6(10) 
   in Ada.Real_Time   D.8(4) 
Time_Offset    in Ada.Calendar.Time_Zones   9.6.1(4/2) 
Time_Span    in Ada.Real_Time   D.8(5) 
Timer    in Ada.Execution_Time.Timers   D.14.1(4/2) 
Timer_Handler    in Ada.Execution_Time.Timers   D.14.1(5/2) 
Timing_Event    in Ada.Real_Time.Timing_Events   D.15(4/2) 
Timing_Event_Handler    in Ada.Real_Time.Timing_Events   D.15(4/2) 
Tree    in Ada.Containers.Multiway_Trees   A.18.10(8/3) 
Trim_End    in Ada.Strings   A.4.1(6) 
Truncation    in Ada.Strings   A.4.1(6) 
Type_Set    in Ada.Text_IO   A.10.1(7) 
Unbounded_String    in Ada.Strings.Unbounded   A.4.5(4/2) 
Uniformly_Distributed subtype of  Float 
   in Ada.Numerics.Float_Random   A.5.2(8) unsigned 
   in Interfaces.C   B.3(9) 
unsigned_char    in Interfaces.C   B.3(10) 
unsigned_long    in Interfaces.C   B.3(9) 
unsigned_short    in Interfaces.C   B.3(9) 
UTF_16_Wide_String subtype of  Wide_String 
   in Ada.Strings.UTF_Encoding   A.4.11(7/3) 
UTF_8_String subtype of  String 
   in Ada.Strings.UTF_Encoding   A.4.11(6/3) 
UTF_String subtype of  String 
   in Ada.Strings.UTF_Encoding   A.4.11(5/3) 
Vector    in Ada.Containers.Vectors   A.18.2(8/3) 
wchar_array    in Interfaces.C   B.3(33/3) 
wchar_t    in Interfaces.C   B.3(30/1) 
Wide_Character    in Standard   A.1(36.1/3) 
Wide_Character_Mapping    in Ada.Strings.Wide_Maps   A.4.7(20/2) 
Wide_Character_Mapping_Function    in Ada.Strings.Wide_Maps   A.4.7(26) 
Wide_Character_Range    in Ada.Strings.Wide_Maps   A.4.7(6) 
Wide_Character_Ranges    in Ada.Strings.Wide_Maps   A.4.7(7) 
Wide_Character_Sequence subtype of  Wide_String 
   in Ada.Strings.Wide_Maps   A.4.7(16) 
Wide_Character_Set    in Ada.Strings.Wide_Maps   A.4.7(4/2) 
Wide_String    in Standard   A.1(41/3) 
Wide_Wide_Character    in Standard   A.1(36.2/3) 
Wide_Wide_Character_Mapping    in Ada.Strings.Wide_Wide_Maps   A.4.8(20/2) 
Wide_Wide_Character_Mapping_Function    in Ada.Strings.Wide_Wide_Maps   A.4.8(26/2) 
Wide_Wide_Character_Range    in Ada.Strings.Wide_Wide_Maps   A.4.8(6/2) 
Wide_Wide_Character_Ranges    in Ada.Strings.Wide_Wide_Maps   A.4.8(7/2) 
Wide_Wide_Character_Sequence subtype of  
Wide_Wide_String 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(16/2) 
Wide_Wide_Character_Set    in Ada.Strings.Wide_Wide_Maps   A.4.8(4/2) 
Wide_Wide_String    in Standard   A.1(42.1/3) 
Year_Number subtype of  Integer 
   in Ada.Calendar   9.6(11/2) 
Ada Reference Manual — 2012 Edition 
Q.3   Language-Defined Subprograms 13 December 2012      850 Q.3 Language-Defined Subprograms 
This subclause lists all la nguage-defined subprograms.  
  
Abort_Task in Ada.Task_Identification   C.7.1(3/3) 
Activation_Is_Complete    in Ada.Task_Identification   C.7.1(4/3) 
Actual_Quantum    in Ada.Dispatching.Round_Robin   D.2.5(4/2) 
Ada.Unchecked_Deallocate_Subpool    child of  Ada   13.11.5(3/3) 
Add    in Ada.Execution_Time.Group_Budgets   D.14.2(9/2) 
Add_Task    in Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Adjust in Ada.Finalization   7.6(6/2) 
Allocate    in System.Storage_Pools   13.11(7) 
   in System.Storage_Pools.Subpools   13.11.4(14/3) 
Allocate_From_Subpool    in System.Storage_Pools.Subpools   13.11.4(11/3) 
Ancestor_Find    in Ada.Containers.Multiway_Trees   A.18.10(40/3) 
Append    in Ada.Containers.Doubly_Linked_Lists   A.18.3(23/2) 
   in Ada.Containers.Vectors   A.18.2(46/2), A.18.2(47/2) 
   in Ada.Strings.Bounded   A.4.4(13), A.4.4(14), A.4.4(15), 
A.4.4(16), A.4.4(17), A.4.4(18), A.4.4(19), A.4.4(20) 
   in Ada.Strings.Unbounded   A.4.5(12), A.4.5(13), A.4.5(14) 
Append_Child    in Ada.Containers.Multiway_Trees   A.18.10(52/3) 
Arccos    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(5) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(6) 
Arccosh    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(7) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(7) 
Arccot    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(5) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(6) 
Arccoth    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(7) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(7) 
Arcsin    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(5) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(6) 
Arcsinh    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(7) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(7) Arctan 
   in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(5) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(6) 
Arctanh    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(7) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(7) 
Argument    in Ada.Command_Line   A.15(5) 
   in Ada.Numerics.Generic_Complex_Arrays   G.3.2(10/2), 
G.3.2(31/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(10) 
Argument_Count in Ada.Command_Line   A.15(4) 
Assert in Ada.Assertions   11.4.2(14/2) 
Assign    in Ada.Containers.Doubly_Linked_Lists   A.18.3(17.5/3) 
   in Ada.Containers.Hashed_Maps   A.18.5(17.7/3) 
   in Ada.Containers.Hashed_Sets   A.18.8(17.3/3) 
   in Ada.Containers.Indefinite_Holders   A.18.18(20/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(32/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(16.7/3) 
   in Ada.Containers.Ordered_Sets   A.18.9(16.3/3) 
   in Ada.Containers.Vectors   A.18.2(34.7/3) 
Assign_Task    in System.Multiprocessors.Dispatching_Domains   
D.16.1(11/3) 
Attach_Handler in Ada.Interrupts   C.3.2(7) 
Base_Name in Ada.Directories   A.16(19/2) 
Blank_When_Zero    in Ada.Text_IO.Editing   F.3.3(7) 
Bounded_Slice in Ada.Strings.Bounded   A.4.4(28.1/2), 
A.4.4(28.2/2) 
Budget_Has_Expired    in Ada.Execution_Time.Group_Budgets   D.14.2(9/2) 
Budget_Remaining    in Ada.Execution_Time.Group_Budgets   D.14.2(9/2) 
Cancel_Handler    in Ada.Execution_Time.Group_Budgets   D.14.2(10/2) 
   in Ada.Execution_Time.Timers   D.14.1(7/2) 
   in Ada.Real_Time.Timing_Events   D.15(5/2) 
Capacity    in Ada.Containers.Hashed_Maps   A.18.5(8/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(10/2) 
   in Ada.Containers.Vectors   A.18.2(19/2) 
Ceiling    in Ada.Containers.Ordered_Maps   A.18.6(41/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(51/2), A.18.9(71/2) 
Character_Set_Version    in Ada.Wide_Characters.Handling   A.3.5(4/3) 
Child_Count    in Ada.Containers.Multiway_Trees   A.18.10(46/3) 1/3 
Ada Reference Manual — 2012 Edition 
851      13 December 2012 Language-Defined Subprograms   Q.3 Child_Depth 
   in Ada.Containers.Multiway_Trees   A.18.10(47/3) 
Clear    in Ada.Containers.Doubly_Linked_Lists   A.18.3(13/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(12/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(14/2) 
   in Ada.Containers.Indefinite_Holders   A.18.18(11/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(23/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(11/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(13/2) 
   in Ada.Containers.Vectors   A.18.2(24/2) 
   in Ada.Environment_Variables   A.17(7/2) 
Clock    in Ada.Calendar   9.6(12) 
   in Ada.Execution_Time   D.14(5/2) 
   in Ada.Execution_Time.Interrupts   D.14.3(3/3) 
   in Ada.Real_Time   D.8(6) 
Clock_For_Interrupts    in Ada.Execution_Time   D.14(9.3/3) 
Close    in Ada.Direct_IO   A.8.4(8) 
   in Ada.Sequential_IO   A.8.1(8) 
   in Ada.Streams.Stream_IO   A.12.1(10) 
   in Ada.Text_IO   A.10.1(11) 
Col in Ada.Text_IO   A.10.1(37) 
Command_Name in Ada.Command_Line   A.15(6) 
Compose    in Ada.Directories   A.16(20/2) 
   in Ada.Directories.Hierarchical_File_Names   A.16.1(14/3) 
Compose_From_Cartesian    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(9/2), 
G.3.2(29/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(8) 
Compose_From_Polar    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(11/2), 
G.3.2(32/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(11) 
Conjugate    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(13/2), 
G.3.2(34/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(12), 
G.1.1(15) 
Constant_Reference    in Ada.Containers.Doubly_Linked_Lists   A.18.3(17.3/3) 
   in Ada.Containers.Hashed_Maps   A.18.5(17.3/3), 
A.18.5(17.5/3) 
   in Ada.Containers.Hashed_Sets   A.18.8(17.2/3), 
A.18.8(58.3/3) 
   in Ada.Containers.Indefinite_Holders   A.18.18(18/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(30/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(16.3/3), 
A.18.6(16.5/3) 
   in Ada.Containers.Ordered_Sets   A.18.9(16.2/3), 
A.18.9(73.3/3) 
   in Ada.Containers.Vectors   A.18.2(34.3/3), A.18.2(34.5/3) 
Containing_Directory    in Ada.Directories   A.16(17/2) 
   in Ada.Directories.Hierarchical_File_Names   A.16.1(11/3) Contains 
   in Ada.Containers.Doubly_Linked_Lists   A.18.3(43/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(32/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(44/2), A.18.8(57/2) 
   in Ada.Containers.Multiway_Trees   A.18.10(41/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(42/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(52/2), A.18.9(72/2) 
   in Ada.Containers.Vectors   A.18.2(71/2) 
Continue    in Ada.Asynchronous_Task_Control   D.11(3/2) 
Convert    in Ada.Strings.UTF_Encoding.Conversions   A.4.11(16/3), 
A.4.11(17/3), A.4.11(18/3), A.4.11(19/3), A.4.11(20/3) 
Copy    in Ada.Containers.Doubly_Linked_Lists   A.18.3(17.6/3) 
   in Ada.Containers.Hashed_Maps   A.18.5(17.8/3) 
   in Ada.Containers.Hashed_Sets   A.18.8(17.4/3) 
   in Ada.Containers.Indefinite_Holders   A.18.18(21/3), 
A.18.20(10/3), A.18.21(13/3), A.18.22(10/3), A.18.23(13/3), A.18.24(10/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(33/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(16.8/3) 
   in Ada.Containers.Ordered_Sets   A.18.9(16.4/3) 
   in Ada.Containers.Vectors   A.18.2(34.8/3) 
Copy_Array in Interfaces.C.Pointers   B.3.2(15) 
Copy_File in Ada.Directories   A.16(13/2) 
Copy_Subtree    in Ada.Containers.Multiway_Trees   A.18.10(54/3) 
Copy_Terminated_Array    in Interfaces.C.Pointers   B.3.2(14) 
Cos    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(4) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(5) 
Cosh    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(6) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(7) 
Cot    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(4) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(5) 
Coth    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(6) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(7) 
Count    in Ada.Strings.Bounded   A.4.4(48), A.4.4(49), A.4.4(50) 
   in Ada.Strings.Fixed   A.4.3(13), A.4.3(14), A.4.3(15) 
   in Ada.Strings.Unbounded   A.4.5(43), A.4.5(44), A.4.5(45) 
Country in Ada.Locales   A.19(6/3) 
Create    in Ada.Direct_IO   A.8.4(6) 
   in Ada.Sequential_IO   A.8.1(6) 
   in Ada.Streams.Stream_IO   A.12.1(8) 
   in Ada.Text_IO   A.10.1(9) 
   in System.Multiprocessors.Dispatching_Domains   
D.16.1(7/3) 
Create_Directory in Ada.Directories   A.16(7/2) 
Create_Path in Ada.Directories   A.16(9/2) 
Ada Reference Manual — 2012 Edition 
Q.3   Language-Defined Subprograms 13 December 2012      852 Create_Subpool 
   in System.Storage_Pools.Subpools   13.11.4(7/3) 
Current_Directory in Ada.Directories   A.16(5/2) 
Current_Error in Ada.Text_IO   A.10.1(17), A.10.1(20) 
Current_Handler    in Ada.Execution_Time.Group_Budgets   D.14.2(10/2) 
   in Ada.Execution_Time.Timers   D.14.1(7/2) 
   in Ada.Interrupts   C.3.2(6) 
   in Ada.Real_Time.Timing_Events   D.15(5/2) 
Current_Input in Ada.Text_IO   A.10.1(17), A.10.1(20) 
Current_Output in Ada.Text_IO   A.10.1(17), A.10.1(20) 
Current_State    in Ada.Synchronous_Task_Control   D.10(4) 
Current_Task    in Ada.Task_Identification   C.7.1(3/3) 
Current_Task_Fallback_Handler    in Ada.Task_Termination   C.7.3(5/2) 
Current_Use    in Ada.Containers.Bounded_Priority_Queues   A.18.31(7/3) 
   in Ada.Containers.Bounded_Synchronized_Queues   
A.18.29(6/3) 
   in Ada.Containers.Synchronized_Queue_Interfaces   
A.18.27(7/3) 
   in Ada.Containers.Unbounded_Priority_Queues   
A.18.30(7/3) 
   in Ada.Containers.Unbounded_Synchronized_Queues   
A.18.28(6/3) 
Day    in Ada.Calendar   9.6(13) 
   in Ada.Calendar.Formatting   9.6.1(23/2) 
Day_of_Week    in Ada.Calendar.Formatting   9.6.1(18/2) 
Deallocate    in System.Storage_Pools   13.11(8) 
   in System.Storage_Pools.Subpools   13.11.4(15/3) 
Deallocate_Subpool    in System.Storage_Pools.Subpools   13.11.4(12/3) 
Decode    in Ada.Strings.UTF_Encoding.Strings   A.4.11(26/3), 
A.4.11(27/3), A.4.11(28/3) 
   in Ada.Strings.UTF_Encoding.Wide_Strings   A.4.11(34/3), 
A.4.11(35/3), A.4.11(36/3) 
   in Ada.Strings.UTF_Encoding.Wide_Wide_Strings   
A.4.11(42/3), A.4.11(43/3), A.4.11(44/3) 
Decrement in Interfaces.C.Pointers   B.3.2(11/3) 
Default_Modulus    in Ada.Containers.Indefinite_Holders   A.18.21(10/3), 
A.18.23(10/3) 
Default_Subpool_for_Pool    in System.Storage_Pools.Subpools   13.11.4(13/3) 
Delay_Until_And_Set_CPU    in System.Multiprocessors.Dispatching_Domains   
D.16.1(14/3) 
Delay_Until_And_Set_Deadline    in Ada.Dispatching.EDF   D.2.6(9/2) 
Delete    in Ada.Containers.Doubly_Linked_Lists   A.18.3(24/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(25/2), A.18.5(26/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(24/2), A.18.8(25/2), 
A.18.8(55/2)    in Ada.Containers.Ordered_Maps   A.18.6(24/2), 
A.18.6(25/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(23/2), A.18.9(24/2), 
A.18.9(68/2) 
   in Ada.Containers.Vectors   A.18.2(50/2), A.18.2(51/2) 
   in Ada.Direct_IO   A.8.4(8) 
   in Ada.Sequential_IO   A.8.1(8) 
   in Ada.Streams.Stream_IO   A.12.1(10) 
   in Ada.Strings.Bounded   A.4.4(64), A.4.4(65) 
   in Ada.Strings.Fixed   A.4.3(29), A.4.3(30) 
   in Ada.Strings.Unbounded   A.4.5(59), A.4.5(60) 
   in Ada.Text_IO   A.10.1(11) 
Delete_Children    in Ada.Containers.Multiway_Trees   A.18.10(53/3) 
Delete_Directory in Ada.Directories   A.16(8/2) 
Delete_File in Ada.Directories   A.16(11/2) 
Delete_First    in Ada.Containers.Doubly_Linked_Lists   A.18.3(25/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(26/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(25/2) 
   in Ada.Containers.Vectors   A.18.2(52/2) 
Delete_Last    in Ada.Containers.Doubly_Linked_Lists   A.18.3(26/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(27/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(26/2) 
   in Ada.Containers.Vectors   A.18.2(53/2) 
Delete_Leaf    in Ada.Containers.Multiway_Trees   A.18.10(35/3) 
Delete_Subtree    in Ada.Containers.Multiway_Trees   A.18.10(36/3) 
Delete_Tree in Ada.Directories   A.16(10/2) 
Depth    in Ada.Containers.Multiway_Trees   A.18.10(19/3) 
Dequeue    in Ada.Containers.Bounded_Priority_Queues   A.18.31(5/3) 
   in Ada.Containers.Bounded_Synchronized_Queues   
A.18.29(5/3) 
   in Ada.Containers.Synchronized_Queue_Interfaces   
A.18.27(6/3) 
   in Ada.Containers.Unbounded_Priority_Queues   
A.18.30(5/3) 
   in Ada.Containers.Unbounded_Synchronized_Queues   
A.18.28(5/3) 
Dequeue_Only_High_Priority    in Ada.Containers.Bounded_Priority_Queues   A.18.31(6/3) 
   in Ada.Containers.Unbounded_Priority_Queues   
A.18.30(6/3) 
Dereference_Error    in Interfaces.C.Strings   B.3.1(12) 
Descendant_Tag in Ada.Tags   3.9(7.1/2) 
Detach_Handler in Ada.Interrupts   C.3.2(9) 
Determinant    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(46/2) 
   in Ada.Numerics.Generic_Real_Arrays   G.3.1(24/2) 
Difference    in Ada.Calendar.Arithmetic   9.6.1(12/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(32/2), A.18.8(33/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(33/2), A.18.9(34/2) 
Divide in Ada.Decimal   F.2(6/3) 
Do_APC in System.RPC   E.5(10) 
Ada Reference Manual — 2012 Edition 
853      13 December 2012 Language-Defined Subprograms   Q.3 Do_RPC in System.RPC   E.5(9) 
Eigensystem    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(49/2) 
   in Ada.Numerics.Generic_Real_Arrays   G.3.1(27/2) 
Eigenvalues    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(48/2) 
   in Ada.Numerics.Generic_Real_Arrays   G.3.1(26/2) 
Element    in Ada.Containers.Doubly_Linked_Lists   A.18.3(14/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(14/2), A.18.5(31/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(15/2), A.18.8(52/2) 
   in Ada.Containers.Indefinite_Holders   A.18.18(12/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(24/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(13/2), 
A.18.6(39/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(14/2), A.18.9(65/2) 
   in Ada.Containers.Vectors   A.18.2(27/2), A.18.2(28/2) 
   in Ada.Strings.Bounded   A.4.4(26) 
   in Ada.Strings.Unbounded   A.4.5(20) 
Encode    in Ada.Strings.UTF_Encoding.Strings   A.4.11(23/3), 
A.4.11(24/3), A.4.11(25/3) 
   in Ada.Strings.UTF_Encoding.Wide_Strings   A.4.11(31/3), 
A.4.11(32/3), A.4.11(33/3) 
   in Ada.Strings.UTF_Encoding.Wide_Wide_Strings   
A.4.11(39/3), A.4.11(40/3), A.4.11(41/3) 
Encoding in Ada.Strings.UTF_Encoding   A.4.11(13/3) 
End_Of_File    in Ada.Direct_IO   A.8.4(16) 
   in Ada.Sequential_IO   A.8.1(13) 
   in Ada.Streams.Stream_IO   A.12.1(12) 
   in Ada.Text_IO   A.10.1(34) 
End_Of_Line in Ada.Text_IO   A.10.1(30) 
End_Of_Page in Ada.Text_IO   A.10.1(33) 
End_Search in Ada.Directories   A.16(33/2) 
Enqueue    in Ada.Containers.Bounded_Priority_Queues   A.18.31(5/3) 
   in Ada.Containers.Bounded_Synchronized_Queues   
A.18.29(5/3) 
   in Ada.Containers.Synchronized_Queue_Interfaces   
A.18.27(5/3) 
   in Ada.Containers.Unbounded_Priority_Queues   
A.18.30(5/3) 
   in Ada.Containers.Unbounded_Synchronized_Queues   
A.18.28(5/3) 
Environment_Task    in Ada.Task_Identification   C.7.1(3/3) 
Equal_Case_Insensitive    child of  Ada.Strings   A.4.10(2/3) 
   child of  Ada.Strings.Bounded   A.4.10(7/3) 
   child of  Ada.Strings.Fixed   A.4.10(5/3) 
   child of  Ada.Strings.Unbounded   A.4.10(10/3) 
Equal_Subtree    in Ada.Containers.Multiway_Trees   A.18.10(14/3) 
Equivalent_Elements    in Ada.Containers.Hashed_Sets   A.18.8(46/2), A.18.8(47/2), 
A.18.8(48/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(3/2) Equivalent_Keys 
   in Ada.Containers.Hashed_Maps   A.18.5(34/2), 
A.18.5(35/2), A.18.5(36/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(3/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(63/2) 
Equivalent_Sets    in Ada.Containers.Hashed_Sets   A.18.8(8/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(9/2) 
Establish_RPC_Receiver in System.RPC   E.5(12) 
Exception_Identity in Ada.Exceptions   11.4.1(5/2) 
Exception_Information    in Ada.Exceptions   11.4.1(5/2) 
Exception_Message in Ada.Exceptions   11.4.1(4/3) 
Exception_Name in Ada.Exceptions   11.4.1(2/2), 11.4.1(5/2) 
Exchange_Handler in Ada.Interrupts   C.3.2(8) 
Exclude    in Ada.Containers.Hashed_Maps   A.18.5(24/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(23/2), A.18.8(54/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(23/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(22/2), A.18.9(67/2) 
Exists    in Ada.Directories   A.16(24/2) 
   in Ada.Environment_Variables   A.17(5/2) 
Exp    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(3) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(4) 
Expanded_Name in Ada.Tags   3.9(7/2) 
Extension in Ada.Directories   A.16(18/2) 
External_Tag in Ada.Tags   3.9(7/2) 
Finalize in Ada.Finalization   7.6(6/2), 7.6(8/2) 
Find    in Ada.Containers.Doubly_Linked_Lists   A.18.3(41/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(30/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(43/2), A.18.8(56/2) 
   in Ada.Containers.Multiway_Trees   A.18.10(38/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(38/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(49/2), A.18.9(69/2) 
   in Ada.Containers.Vectors   A.18.2(68/2) 
Find_In_Subtree    in Ada.Containers.Multiway_Trees   A.18.10(39/3) 
Find_Index in Ada.Containers.Vectors   A.18.2(67/2) 
Find_Token    in Ada.Strings.Bounded   A.4.4(50.1/3), A.4.4(51) 
   in Ada.Strings.Fixed   A.4.3(15.1/3), A.4.3(16) 
   in Ada.Strings.Unbounded   A.4.5(45.1/3), A.4.5(46) 
First    in Ada.Containers.Doubly_Linked_Lists   A.18.3(33/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(27/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(40/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(28/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(41/2) 
   in Ada.Containers.Vectors   A.18.2(58/2) 
   in Ada.Iterator_Interfaces   5.5.1(3/3) 
First_Child    in Ada.Containers.Multiway_Trees   A.18.10(60/3) 
First_Child_Element    in Ada.Containers.Multiway_Trees   A.18.10(61/3) 
Ada Reference Manual — 2012 Edition 
Q.3   Language-Defined Subprograms 13 December 2012      854 First_Element 
   in Ada.Containers.Doubly_Linked_Lists   A.18.3(34/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(29/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(42/2) 
   in Ada.Containers.Vectors   A.18.2(59/2) 
First_Index in Ada.Containers.Vectors   A.18.2(57/2) 
First_Key    in Ada.Containers.Ordered_Maps   A.18.6(30/2) 
Floor    in Ada.Containers.Ordered_Maps   A.18.6(40/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(50/2), A.18.9(70/2) 
Flush    in Ada.Streams.Stream_IO   A.12.1(25/1) 
   in Ada.Text_IO   A.10.1(21/1) 
Form    in Ada.Direct_IO   A.8.4(9) 
   in Ada.Sequential_IO   A.8.1(9) 
   in Ada.Streams.Stream_IO   A.12.1(11) 
   in Ada.Text_IO   A.10.1(12) 
Free    in Ada.Strings.Unbounded   A.4.5(7) 
   in Interfaces.C.Strings   B.3.1(11) 
Full_Name in Ada.Directories   A.16(15/2), A.16(39/2) 
Generic_Array_Sort    child of  Ada.Containers   A.18.26(3/2) 
Generic_Constrained_Array_Sort    child of  Ada.Containers   A.18.26(7/2) 
Generic_Sort    child of  Ada.Containers   A.18.26(9.2/3) 
Get    in Ada.Text_IO   A.10.1(41), A.10.1(47), A.10.1(54), 
A.10.1(55), A.10.1(59), A.10.1(60), A.10.1(65), A.10.1(67), A.10.1(70), A.10.1(72), A.10.1(75), A.10.1(77), A.10.1(81), A.10.1(83) 
   in Ada.Text_IO.Complex_IO   G.1.3(6), G.1.3(8) 
Get_CPU    in Ada.Interrupts   C.3.2(10.1/3) 
   in System.Multiprocessors.Dispatching_Domains   
D.16.1(13/3) 
Get_Deadline in Ada.Dispatching.EDF   D.2.6(9/2) 
Get_Dispatching_Domain    in System.Multiprocessors.Dispatching_Domains   
D.16.1(10/3) 
Get_First_CPU    in System.Multiprocessors.Dispatching_Domains   
D.16.1(8/3) 
Get_Immediate in Ada.Text_IO   A.10.1(44), A.10.1(45) 
Get_Last_CPU    in System.Multiprocessors.Dispatching_Domains   
D.16.1(9/3) 
Get_Line    in Ada.Text_IO   A.10.1(49), A.10.1(49.1/2) 
   in Ada.Text_IO.Bounded_IO   A.10.11(8/2), A.10.11(9/2), 
A.10.11(10/2), A.10.11(11/2) 
   in Ada.Text_IO.Unbounded_IO   A.10.12(8/2), A.10.12(9/2), 
A.10.12(10/2), A.10.12(11/2) 
Get_Next_Entry in Ada.Directories   A.16(35/2) 
Get_Priority    in Ada.Dynamic_Priorities   D.5.1(5) Has_Element 
   in Ada.Containers.Doubly_Linked_Lists   A.18.3(9.1/3) 
   in Ada.Containers.Hashed_Maps   A.18.5(6.1/3) 
   in Ada.Containers.Hashed_Sets   A.18.8(6.1/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(12/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(7.1/3) 
   in Ada.Containers.Ordered_Sets   A.18.9(7.1/3) 
   in Ada.Containers.Vectors   A.18.2(11.1/3) 
Hash    child of  Ada.Strings   A.4.9(2/3) 
   child of  Ada.Strings.Bounded   A.4.9(7/3) 
   child of  Ada.Strings.Unbounded   A.4.9(10/3) 
Hash_Case_Insensitive    child of  Ada.Strings   A.4.9(11.2/3) 
   child of  Ada.Strings.Bounded   A.4.9(11.7/3) 
   child of  Ada.Strings.Fixed   A.4.9(11.5/3) 
   child of  Ada.Strings.Unbounded   A.4.9(11.10/3) 
Head    in Ada.Strings.Bounded   A.4.4(70), A.4.4(71) 
   in Ada.Strings.Fixed   A.4.3(35), A.4.3(36) 
   in Ada.Strings.Unbounded   A.4.5(65), A.4.5(66) 
Hold in Ada.Asynchronous_Task_Control   D.11(3/2) 
Hour in Ada.Calendar.Formatting   9.6.1(24/2) 
Im    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(7/2), 
G.3.2(27/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(6) 
Image    in Ada.Calendar.Formatting   9.6.1(35/2), 9.6.1(37/2) 
   in Ada.Numerics.Discrete_Random   A.5.2(26) 
   in Ada.Numerics.Float_Random   A.5.2(14) 
   in Ada.Task_Identification   C.7.1(3/3) 
   in Ada.Text_IO.Editing   F.3.3(13) 
Include    in Ada.Containers.Hashed_Maps   A.18.5(22/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(21/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(21/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(20/2) 
Increment in Interfaces.C.Pointers   B.3.2(11/3) 
Index    in Ada.Direct_IO   A.8.4(15) 
   in Ada.Streams.Stream_IO   A.12.1(23) 
   in Ada.Strings.Bounded   A.4.4(43.1/2), A.4.4(43.2/2), 
A.4.4(44), A.4.4(45), A.4.4(45.1/2), A.4.4(46) 
   in Ada.Strings.Fixed   A.4.3(8.1/2), A.4.3(8.2/2), A.4.3(9), 
A.4.3(10), A.4.3(10.1/2), A.4.3(11) 
   in Ada.Strings.Unbounded   A.4.5(38.1/2), A.4.5(38.2/2), 
A.4.5(39), A.4.5(40), A.4.5(40.1/2), A.4.5(41) 
Index_Non_Blank    in Ada.Strings.Bounded   A.4.4(46.1/2), A.4.4(47) 
   in Ada.Strings.Fixed   A.4.3(11.1/2), A.4.3(12) 
   in Ada.Strings.Unbounded   A.4.5(41.1/2), A.4.5(42) 
Initial_Directory    in Ada.Directories.Hierarchical_File_Names   A.16.1(12/3) 
Initialize in Ada.Finalization   7.6(6/2), 7.6(8/2) 
Insert    in Ada.Containers.Doubly_Linked_Lists   A.18.3(19/2), 
A.18.3(20/2), A.18.3(21/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(19/2), 
A.18.5(20/2), A.18.5(21/2) 
Ada Reference Manual — 2012 Edition 
855      13 December 2012 Language-Defined Subprograms   Q.3    in Ada.Containers.Hashed_Sets   A.18.8(19/2), A.18.8(20/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(18/2), 
A.18.6(19/2), A.18.6(20/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(18/2), A.18.9(19/2) 
   in Ada.Containers.Vectors   A.18.2(36/2), A.18.2(37/2), 
A.18.2(38/2), A.18.2(39/2), A.18.2(40/2), A.18.2(41/2), A.18.2(42/2), A.18.2(43/2) 
   in Ada.Strings.Bounded   A.4.4(60), A.4.4(61) 
   in Ada.Strings.Fixed   A.4.3(25), A.4.3(26) 
   in Ada.Strings.Unbounded   A.4.5(55), A.4.5(56) 
Insert_Child    in Ada.Containers.Multiway_Trees   A.18.10(48/3), 
A.18.10(49/3), A.18.10(50/3) 
Insert_Space    in Ada.Containers.Vectors   A.18.2(48/2), A.18.2(49/2) 
Interface_Ancestor_Tags in Ada.Tags   3.9(7.4/2) 
Internal_Tag in Ada.Tags   3.9(7/2) 
Intersection    in Ada.Containers.Hashed_Sets   A.18.8(29/2), A.18.8(30/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(30/2), A.18.9(31/2) 
Inverse    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(46/2) 
   in Ada.Numerics.Generic_Real_Arrays   G.3.1(24/2) 
Is_A_Group_Member    in Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Is_Abstract in Ada.Tags   3.9(7.5/3) 
Is_Alphanumeric    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(12/3) 
Is_Attached in Ada.Interrupts   C.3.2(5) 
Is_Basic in Ada.Characters.Handling   A.3.2(4/3) 
Is_Callable    in Ada.Task_Identification   C.7.1(4/3) 
Is_Character    in Ada.Characters.Conversions   A.3.4(3/2) 
Is_Control    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(5/3) 
Is_Current_Directory_Name    in Ada.Directories.Hierarchical_File_Names   A.16.1(7/3) 
Is_Decimal_Digit    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(10/3) 
Is_Descendant_At_Same_Level    in Ada.Tags   3.9(7.1/2) 
Is_Digit    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(9/3) 
Is_Empty    in Ada.Containers.Doubly_Linked_Lists   A.18.3(12/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(11/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(13/2) 
   in Ada.Containers.Indefinite_Holders   A.18.18(10/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(16/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(10/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(12/2) 
   in Ada.Containers.Vectors   A.18.2(23/2) 
Is_Full_Name    in Ada.Directories.Hierarchical_File_Names   A.16.1(8/3) 
Is_Graphic    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(19/3) 
Is_Held    in Ada.Asynchronous_Task_Control   D.11(3/2) 
Is_Hexadecimal_Digit    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(11/3) 
Is_In    in Ada.Strings.Maps   A.4.2(13) 
   in Ada.Strings.Wide_Maps   A.4.7(13) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(13/2) 
Is_ISO_646 in Ada.Characters.Handling   A.3.2(10) 
Is_Leaf    in Ada.Containers.Multiway_Trees   A.18.10(21/3) 
Is_Letter    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(6/3) 
Is_Line_Terminator    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(14/3) 
Is_Lower    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(7/3) 
Is_Mark    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(15/3) 
Is_Member    in Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Is_Nul_Terminated in Interfaces.C   B.3(24), B.3(35), 
B.3(39.16/2), B.3(39.7/2) 
Is_Open    in Ada.Direct_IO   A.8.4(10) 
   in Ada.Sequential_IO   A.8.1(10) 
   in Ada.Streams.Stream_IO   A.12.1(12) 
   in Ada.Text_IO   A.10.1(13) 
Is_Other_Format    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(16/3) 
Is_Parent_Directory_Name    in Ada.Directories.Hierarchical_File_Names   A.16.1(6/3) 
Is_Punctuation_Connector    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(17/3) 
Is_Relative_Name    in Ada.Directories.Hierarchical_File_Names   A.16.1(9/3) 
Is_Reserved in Ada.Interrupts   C.3.2(4) 
Is_Root    in Ada.Containers.Multiway_Trees   A.18.10(20/3) 
Is_Root_Directory_Name    in Ada.Directories.Hierarchical_File_Names   A.16.1(5/3) 
Is_Round_Robin    in Ada.Dispatching.Round_Robin   D.2.5(4/2) 
Is_Simple_Name    in Ada.Directories.Hierarchical_File_Names   A.16.1(4/3) 
Is_Sorted    in Ada.Containers.Doubly_Linked_Lists   A.18.3(48/2) 
   in Ada.Containers.Vectors   A.18.2(76/2) 
Is_Space    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(18/3) 
Ada Reference Manual — 2012 Edition 
Q.3   Language-Defined Subprograms 13 December 2012      856 Is_Special 
   in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(13/3) 
Is_String    in Ada.Characters.Conversions   A.3.4(3/2) 
Is_Subset    in Ada.Containers.Hashed_Sets   A.18.8(39/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(40/2) 
   in Ada.Strings.Maps   A.4.2(14) 
   in Ada.Strings.Wide_Maps   A.4.7(14) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(14/2) 
Is_Terminated    in Ada.Task_Identification   C.7.1(4/3) 
Is_Upper    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   A.3.5(8/3) 
Is_Wide_Character    in Ada.Characters.Conversions   A.3.4(3/2) 
Is_Wide_String    in Ada.Characters.Conversions   A.3.4(3/2) 
Iterate    in Ada.Containers.Doubly_Linked_Lists   A.18.3(45/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(37/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(49/2) 
   in Ada.Containers.Multiway_Trees   A.18.10(42/3), 
A.18.10(44/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(50/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(60/2) 
   in Ada.Containers.Vectors   A.18.2(73/2) 
   in Ada.Environment_Variables   A.17(8/3) 
Iterate_Children    in Ada.Containers.Multiway_Trees   A.18.10(68/3), 
A.18.10(70/3) 
Iterate_Subtree    in Ada.Containers.Multiway_Trees   A.18.10(43/3), 
A.18.10(45/3) 
Key    in Ada.Containers.Hashed_Maps   A.18.5(13/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(51/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(12/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(64/2) 
Kind in Ada.Directories   A.16(25/2), A.16(40/2) 
Language in Ada.Locales   A.19(6/3) 
Last    in Ada.Containers.Doubly_Linked_Lists   A.18.3(35/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(31/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(43/2) 
   in Ada.Containers.Vectors   A.18.2(61/2) 
   in Ada.Iterator_Interfaces   5.5.1(4/3) 
Last_Child    in Ada.Containers.Multiway_Trees   A.18.10(62/3) 
Last_Child_Element    in Ada.Containers.Multiway_Trees   A.18.10(63/3) 
Last_Element    in Ada.Containers.Doubly_Linked_Lists   A.18.3(36/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(32/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(44/2) 
   in Ada.Containers.Vectors   A.18.2(62/2) 
Last_Index in Ada.Containers.Vectors   A.18.2(60/2) Last_Key 
   in Ada.Containers.Ordered_Maps   A.18.6(33/2) 
Length    in Ada.Containers.Doubly_Linked_Lists   A.18.3(11/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(10/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(12/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(9/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(11/2) 
   in Ada.Containers.Vectors   A.18.2(21/2) 
   in Ada.Strings.Bounded   A.4.4(9) 
   in Ada.Strings.Unbounded   A.4.5(6) 
   in Ada.Text_IO.Editing   F.3.3(11) 
   in Interfaces.COBOL   B.4(34), B.4(39), B.4(44) 
Less_Case_Insensitive    child of  Ada.Strings   A.4.10(13/3) 
   child of  Ada.Strings.Bounded   A.4.10(18/3) 
   child of  Ada.Strings.Fixed   A.4.10(16/3) 
   child of  Ada.Strings.Unbounded   A.4.10(21/3) 
Line in Ada.Text_IO   A.10.1(38) 
Line_Length in Ada.Text_IO   A.10.1(25) 
Log    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(3) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(4) 
Look_Ahead in Ada.Text_IO   A.10.1(43) 
Members    in Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Merge    in Ada.Containers.Doubly_Linked_Lists   A.18.3(50/2) 
   in Ada.Containers.Vectors   A.18.2(78/2) 
Microseconds in Ada.Real_Time   D.8(14/2) 
Milliseconds in Ada.Real_Time   D.8(14/2) 
Minute in Ada.Calendar.Formatting   9.6.1(25/2) 
Minutes in Ada.Real_Time   D.8(14/2) 
Mode    in Ada.Direct_IO   A.8.4(9) 
   in Ada.Sequential_IO   A.8.1(9) 
   in Ada.Streams.Stream_IO   A.12.1(11) 
   in Ada.Text_IO   A.10.1(12) 
Modification_Time in Ada.Directories   A.16(27/2), A.16(42/2) 
Modulus    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(10/2), 
G.3.2(30/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(9) 
Month    in Ada.Calendar   9.6(13) 
   in Ada.Calendar.Formatting   9.6.1(22/2) 
More_Entries in Ada.Directories   A.16(34/2) 
Move    in Ada.Containers.Doubly_Linked_Lists   A.18.3(18/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(18/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(18/2) 
   in Ada.Containers.Indefinite_Holders   A.18.18(22/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(34/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(17/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(17/2) 
   in Ada.Containers.Vectors   A.18.2(35/2) 
   in Ada.Strings.Fixed   A.4.3(7) 
Name    in Ada.Direct_IO   A.8.4(9) 
Ada Reference Manual — 2012 Edition 
857      13 December 2012 Language-Defined Subprograms   Q.3    in Ada.Sequential_IO   A.8.1(9) 
   in Ada.Streams.Stream_IO   A.12.1(11) 
   in Ada.Text_IO   A.10.1(12) 
Name_Case_Equivalence    in Ada.Directories   A.16(20.2/3) 
Nanoseconds in Ada.Real_Time   D.8(14/2) 
New_Char_Array    in Interfaces.C.Strings   B.3.1(9) 
New_Line in Ada.Text_IO   A.10.1(28) 
New_Page in Ada.Text_IO   A.10.1(31) 
New_String in Interfaces.C.Strings   B.3.1(10) 
Next    in Ada.Containers.Doubly_Linked_Lists   A.18.3(37/2), 
A.18.3(39/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(28/2), A.18.5(29/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(41/2), A.18.8(42/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(34/2), 
A.18.6(35/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(45/2), A.18.9(46/2) 
   in Ada.Containers.Vectors   A.18.2(63/2), A.18.2(64/2) 
   in Ada.Iterator_Interfaces   5.5.1(3/3) 
Next_Sibling    in Ada.Containers.Multiway_Trees   A.18.10(64/3), 
A.18.10(66/3) 
Node_Count    in Ada.Containers.Multiway_Trees   A.18.10(17/3) 
Null_Task_Id    in Ada.Task_Identification   C.7.1(2/2) 
Number_Of_CPUs    in System.Multiprocessors   D.16(5/3) 
Open    in Ada.Direct_IO   A.8.4(7) 
   in Ada.Sequential_IO   A.8.1(7) 
   in Ada.Streams.Stream_IO   A.12.1(9) 
   in Ada.Text_IO   A.10.1(10) 
Overlap    in Ada.Containers.Hashed_Sets   A.18.8(38/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(39/2) 
Overwrite    in Ada.Strings.Bounded   A.4.4(62), A.4.4(63) 
   in Ada.Strings.Fixed   A.4.3(27), A.4.3(28) 
   in Ada.Strings.Unbounded   A.4.5(57), A.4.5(58) 
Page in Ada.Text_IO   A.10.1(39) 
Page_Length in Ada.Text_IO   A.10.1(26) 
Parent    in Ada.Containers.Multiway_Trees   A.18.10(59/3) 
Parent_Tag in Ada.Tags   3.9(7.2/2) 
Peak_Use    in Ada.Containers.Bounded_Priority_Queues   A.18.31(7/3) 
   in Ada.Containers.Bounded_Synchronized_Queues   
A.18.29(6/3) 
   in Ada.Containers.Synchronized_Queue_Interfaces   
A.18.27(7/3) 
   in Ada.Containers.Unbounded_Priority_Queues   
A.18.30(7/3) 
   in Ada.Containers.Unbounded_Synchronized_Queues   
A.18.28(6/3) 
Pic_String in Ada.Text_IO.Editing   F.3.3(7) 
Pool_of_Subpool    in System.Storage_Pools.Subpools   13.11.4(9/3) Prepend 
   in Ada.Containers.Doubly_Linked_Lists   A.18.3(22/2) 
   in Ada.Containers.Vectors   A.18.2(44/2), A.18.2(45/2) 
Prepend_Child    in Ada.Containers.Multiway_Trees   A.18.10(51/3) 
Previous    in Ada.Containers.Doubly_Linked_Lists   A.18.3(38/2), 
A.18.3(40/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(36/2), 
A.18.6(37/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(47/2), A.18.9(48/2) 
   in Ada.Containers.Vectors   A.18.2(65/2), A.18.2(66/2) 
   in Ada.Iterator_Interfaces   5.5.1(4/3) 
Previous_Sibling    in Ada.Containers.Multiway_Trees   A.18.10(65/3), 
A.18.10(67/3) 
Put    in Ada.Text_IO   A.10.1(42), A.10.1(48), A.10.1(55), 
A.10.1(60), A.10.1(66), A.10.1(67), A.10.1(71), A.10.1(72), A.10.1(76), A.10.1(77), A.10.1(82), A.10.1(83) 
   in Ada.Text_IO.Bounded_IO   A.10.11(4/2), A.10.11(5/2) 
   in Ada.Text_IO.Complex_IO   G.1.3(7), G.1.3(8) 
   in Ada.Text_IO.Editing   F.3.3(14), F.3.3(15), F.3.3(16) 
   in Ada.Text_IO.Unbounded_IO   A.10.12(4/2), A.10.12(5/2) 
Put_Line    in Ada.Text_IO   A.10.1(50) 
   in Ada.Text_IO.Bounded_IO   A.10.11(6/2), A.10.11(7/2) 
   in Ada.Text_IO.Unbounded_IO   A.10.12(6/2), A.10.12(7/2) 
Query_Element    in Ada.Containers.Doubly_Linked_Lists   A.18.3(16/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(16/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(17/2) 
   in Ada.Containers.Indefinite_Holders   A.18.18(14/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(26/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(15/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(16/2) 
   in Ada.Containers.Vectors   A.18.2(31/2), A.18.2(32/2) 
Raise_Exception in Ada.Exceptions   11.4.1(4/3) 
Random    in Ada.Numerics.Discrete_Random   A.5.2(20) 
   in Ada.Numerics.Float_Random   A.5.2(8) 
Re    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(7/2), 
G.3.2(27/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(6) 
Read    in Ada.Direct_IO   A.8.4(12) 
   in Ada.Sequential_IO   A.8.1(12) 
   in Ada.Storage_IO   A.9(6) 
   in Ada.Streams   13.13.1(5) 
   in Ada.Streams.Stream_IO   A.12.1(15), A.12.1(16) 
   in System.RPC   E.5(7) 
Reference    in Ada.Containers.Doubly_Linked_Lists   A.18.3(17.4/3) 
   in Ada.Containers.Hashed_Maps   A.18.5(17.4/3), 
A.18.5(17.6/3) 
   in Ada.Containers.Indefinite_Holders   A.18.18(19/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(31/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(16.4/3), 
A.18.6(16.6/3) 
Ada Reference Manual — 2012 Edition 
Q.3   Language-Defined Subprograms 13 December 2012      858    in Ada.Containers.Vectors   A.18.2(34.4/3), A.18.2(34.6/3) 
   in Ada.Interrupts   C.3.2(10) 
   in Ada.Task_Attributes   C.7.2(5) 
Reference_Preserving_Key    in Ada.Containers.Hashed_Sets   A.18.8(58.2/3), 
A.18.8(58.4/3) 
   in Ada.Containers.Ordered_Sets   A.18.9(73.2/3), 
A.18.9(73.4/3) 
Reinitialize in Ada.Task_Attributes   C.7.2(6) 
Relative_Name    in Ada.Directories.Hierarchical_File_Names   A.16.1(13/3) 
Remove_Task    in Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Rename in Ada.Directories   A.16(12/2) 
Replace    in Ada.Containers.Hashed_Maps   A.18.5(23/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(22/2), A.18.8(53/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(22/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(21/2), A.18.9(66/2) 
Replace_Element    in Ada.Containers.Doubly_Linked_Lists   A.18.3(15/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(15/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(16/2) 
   in Ada.Containers.Indefinite_Holders   A.18.18(13/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(25/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(14/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(15/2) 
   in Ada.Containers.Vectors   A.18.2(29/2), A.18.2(30/2) 
   in Ada.Strings.Bounded   A.4.4(27) 
   in Ada.Strings.Unbounded   A.4.5(21) 
Replace_Slice    in Ada.Strings.Bounded   A.4.4(58), A.4.4(59) 
   in Ada.Strings.Fixed   A.4.3(23), A.4.3(24) 
   in Ada.Strings.Unbounded   A.4.5(53), A.4.5(54) 
Replenish    in Ada.Execution_Time.Group_Budgets   D.14.2(9/2) 
Replicate in Ada.Strings.Bounded   A.4.4(78), A.4.4(79), 
A.4.4(80) 
Reraise_Occurrence in Ada.Exceptions   11.4.1(4/3) 
Reserve_Capacity    in Ada.Containers.Hashed_Maps   A.18.5(9/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(11/2) 
   in Ada.Containers.Vectors   A.18.2(20/2) 
Reset    in Ada.Direct_IO   A.8.4(8) 
   in Ada.Numerics.Discrete_Random   A.5.2(21), A.5.2(24) 
   in Ada.Numerics.Float_Random   A.5.2(9), A.5.2(12) 
   in Ada.Sequential_IO   A.8.1(8) 
   in Ada.Streams.Stream_IO   A.12.1(10) 
   in Ada.Text_IO   A.10.1(11) 
Reverse_Elements    in Ada.Containers.Doubly_Linked_Lists   A.18.3(27/2) 
   in Ada.Containers.Vectors   A.18.2(54/2) 
Reverse_Find    in Ada.Containers.Doubly_Linked_Lists   A.18.3(42/2) 
   in Ada.Containers.Vectors   A.18.2(70/2) 
Reverse_Find_Index    in Ada.Containers.Vectors   A.18.2(69/2) Reverse_Iterate 
   in Ada.Containers.Doubly_Linked_Lists   A.18.3(46/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(51/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(61/2) 
   in Ada.Containers.Vectors   A.18.2(74/2) 
Reverse_Iterate_Children    in Ada.Containers.Multiway_Trees   A.18.10(69/3) 
Root in Ada.Containers.Multiway_Trees   A.18.10(22/3) 
Save    in Ada.Numerics.Discrete_Random   A.5.2(24) 
   in Ada.Numerics.Float_Random   A.5.2(12) 
Save_Occurrence in Ada.Exceptions   11.4.1(6/2) 
Second in Ada.Calendar.Formatting   9.6.1(26/2) 
Seconds    in Ada.Calendar   9.6(13) 
   in Ada.Real_Time   D.8(14/2) 
Seconds_Of in Ada.Calendar.Formatting   9.6.1(28/2) 
Set in Ada.Environment_Variables   A.17(6/2) 
Set_Bounded_String    in Ada.Strings.Bounded   A.4.4(12.1/2) 
Set_Col in Ada.Text_IO   A.10.1(35) 
Set_CPU    in System.Multiprocessors.Dispatching_Domains   
D.16.1(12/3) 
Set_Deadline in Ada.Dispatching.EDF   D.2.6(9/2) 
Set_Dependents_Fallback_Handler    in Ada.Task_Termination   C.7.3(5/2) 
Set_Directory in Ada.Directories   A.16(6/2) 
Set_Error in Ada.Text_IO   A.10.1(15) 
Set_Exit_Status in Ada.Command_Line   A.15(9) 
Set_False    in Ada.Synchronous_Task_Control   D.10(4) 
Set_Handler    in Ada.Execution_Time.Group_Budgets   D.14.2(10/2) 
   in Ada.Execution_Time.Timers   D.14.1(7/2) 
   in Ada.Real_Time.Timing_Events   D.15(5/2) 
Set_Im    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(8/2), 
G.3.2(28/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(7) 
Set_Index    in Ada.Direct_IO   A.8.4(14) 
   in Ada.Streams.Stream_IO   A.12.1(22) 
Set_Input in Ada.Text_IO   A.10.1(15) 
Set_Length in Ada.Containers.Vectors   A.18.2(22/2) 
Set_Line in Ada.Text_IO   A.10.1(36) 
Set_Line_Length in Ada.Text_IO   A.10.1(23) 
Set_Mode in Ada.Streams.Stream_IO   A.12.1(24) 
Set_Output in Ada.Text_IO   A.10.1(15) 
Set_Page_Length in Ada.Text_IO   A.10.1(24) 
Set_Pool_of_Subpool    in System.Storage_Pools.Subpools   13.11.4(10/3) 
Set_Priority    in Ada.Dynamic_Priorities   D.5.1(4) 
Set_Quantum    in Ada.Dispatching.Round_Robin   D.2.5(4/2) 
Set_Re    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(8/2), 
G.3.2(28/2) 
   in Ada.Numerics.Generic_Complex_Types   G.1.1(7) 
Ada Reference Manual — 2012 Edition 
859      13 December 2012 Language-Defined Subprograms   Q.3 Set_Specific_Handler 
   in Ada.Task_Termination   C.7.3(6/2) 
Set_True    in Ada.Synchronous_Task_Control   D.10(4) 
Set_Unbounded_String    in Ada.Strings.Unbounded   A.4.5(11.1/2) 
Set_Value in Ada.Task_Attributes   C.7.2(6) 
Simple_Name    in Ada.Directories   A.16(16/2), A.16(38/2) 
   in Ada.Directories.Hierarchical_File_Names   A.16.1(10/3) 
Sin    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(4) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(5) 
Sinh    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(6) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(7) 
Size    in Ada.Direct_IO   A.8.4(15) 
   in Ada.Directories   A.16(26/2), A.16(41/2) 
   in Ada.Streams.Stream_IO   A.12.1(23) 
Skip_Line in Ada.Text_IO   A.10.1(29) 
Skip_Page in Ada.Text_IO   A.10.1(32) 
Slice    in Ada.Strings.Bounded   A.4.4(28) 
   in Ada.Strings.Unbounded   A.4.5(22) 
Solve    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(46/2) 
   in Ada.Numerics.Generic_Real_Arrays   G.3.1(24/2) 
Sort    in Ada.Containers.Doubly_Linked_Lists   A.18.3(49/2) 
   in Ada.Containers.Vectors   A.18.2(77/2) 
Specific_Handler    in Ada.Task_Termination   C.7.3(6/2) 
Splice    in Ada.Containers.Doubly_Linked_Lists   A.18.3(30/2), 
A.18.3(31/2), A.18.3(32/2) 
Splice_Children    in Ada.Containers.Multiway_Trees   A.18.10(57/3), 
A.18.10(58/3) 
Splice_Subtree    in Ada.Containers.Multiway_Trees   A.18.10(55/3), 
A.18.10(56/3) 
Split    in Ada.Calendar   9.6(14) 
   in Ada.Calendar.Formatting   9.6.1(29/2), 9.6.1(32/2), 
9.6.1(33/2), 9.6.1(34/2) 
   in Ada.Execution_Time   D.14(8/2) 
   in Ada.Real_Time   D.8(16) 
Sqrt    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(3) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(4) 
Standard_Error in Ada.Text_IO   A.10.1(16), A.10.1(19) 
Standard_Input in Ada.Text_IO   A.10.1(16), A.10.1(19) 
Standard_Output in Ada.Text_IO   A.10.1(16), A.10.1(19) 
Start_Search in Ada.Directories   A.16(32/2) 
Storage_Size    in System.Storage_Pools   13.11(9)    in System.Storage_Pools.Subpools   13.11.4(16/3) 
Stream    in Ada.Streams.Stream_IO   A.12.1(13) 
   in Ada.Text_IO.Text_Streams   A.12.2(4) 
   in Ada.Wide_Text_IO.Text_Streams   A.12.3(4) 
   in Ada.Wide_Wide_Text_IO.Text_Streams   A.12.4(4/2) 
Strlen in Interfaces.C.Strings   B.3.1(17) 
Sub_Second in Ada.Calendar.Formatting   9.6.1(27/2) 
Subtree_Node_Count    in Ada.Containers.Multiway_Trees   A.18.10(18/3) 
Supported    in Ada.Execution_Time.Interrupts   D.14.3(3/3) 
Suspend_Until_True    in Ada.Synchronous_Task_Control   D.10(4) 
Suspend_Until_True_And_Set_Deadline    in Ada.Synchronous_Task_Control.EDF   D.10(5.2/3) 
Swap    in Ada.Containers.Doubly_Linked_Lists   A.18.3(28/2) 
   in Ada.Containers.Multiway_Trees   A.18.10(37/3) 
   in Ada.Containers.Vectors   A.18.2(55/2), A.18.2(56/2) 
Swap_Links    in Ada.Containers.Doubly_Linked_Lists   A.18.3(29/2) 
Symmetric_Difference    in Ada.Containers.Hashed_Sets   A.18.8(35/2), A.18.8(36/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(36/2), A.18.9(37/2) 
Tail    in Ada.Strings.Bounded   A.4.4(72), A.4.4(73) 
   in Ada.Strings.Fixed   A.4.3(37), A.4.3(38) 
   in Ada.Strings.Unbounded   A.4.5(67), A.4.5(68) 
Tan    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(4) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(5) 
Tanh    in Ada.Numerics.Generic_Complex_Elementary_Functions   
G.1.2(6) 
   in Ada.Numerics.Generic_Elementary_Functions   A.5.1(7) 
Time_Of    in Ada.Calendar   9.6(15) 
   in Ada.Calendar.Formatting   9.6.1(30/2), 9.6.1(31/2) 
   in Ada.Execution_Time   D.14(9/2) 
   in Ada.Real_Time   D.8(16) 
Time_Of_Event    in Ada.Real_Time.Timing_Events   D.15(6/2) 
Time_Remaining    in Ada.Execution_Time.Timers   D.14.1(8/2) 
To_Ada    in Interfaces.C   B.3(22), B.3(26), B.3(28), B.3(32), B.3(37), 
B.3(39), B.3(39.10/2), B.3(39.13/2), B.3(39.17/2), B.3(39.19/2), B.3(39.4/2), B.3(39.8/2) 
   in Interfaces.COBOL   B.4(17), B.4(19) 
   in Interfaces.Fortran   B.5(13), B.5(14), B.5(16) 
To_Address    in System.Address_To_Access_Conversions   13.7.2(3/3) 
   in System.Storage_Elements   13.7.1(10/3) 
To_Basic in Ada.Characters.Handling   A.3.2(6), A.3.2(7) 
To_Binary in Interfaces.COBOL   B.4(45), B.4(48) 
To_Bounded_String    in Ada.Strings.Bounded   A.4.4(11) 
Ada Reference Manual — 2012 Edition 
Q.3   Language-Defined Subprograms 13 December 2012      860 To_C in Interfaces.C   B.3(21), B.3(25), B.3(27), B.3(32), 
B.3(36), B.3(38), B.3(39.13/2), B.3(39.16/2), B.3(39.18/2), B.3(39.4/2), B.3(39.7/2), B.3(39.9/2) 
To_Character    in Ada.Characters.Conversions   A.3.4(5/2) 
To_Chars_Ptr in Interfaces.C.Strings   B.3.1(8) 
To_COBOL in Interfaces.COBOL   B.4(17), B.4(18) 
To_Cursor in Ada.Containers.Vectors   A.18.2(25/2) 
To_Decimal in Interfaces.COBOL   B.4(35), B.4(40), B.4(44), 
B.4(47) 
To_Display in Interfaces.COBOL   B.4(36) 
To_Domain    in Ada.Strings.Maps   A.4.2(24) 
   in Ada.Strings.Wide_Maps   A.4.7(24) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(24/2) 
To_Duration in Ada.Real_Time   D.8(13) 
To_Fortran in Interfaces.Fortran   B.5(13), B.5(14), B.5(15) 
To_Holder    in Ada.Containers.Indefinite_Holders   A.18.18(9/3) 
To_Index in Ada.Containers.Vectors   A.18.2(26/2) 
To_Integer in System.Storage_Elements   13.7.1(10/3) 
To_ISO_646 in Ada.Characters.Handling   A.3.2(11), A.3.2(12) 
To_Long_Binary in Interfaces.COBOL   B.4(48) 
To_Lower    in Ada.Characters.Handling   A.3.2(6), A.3.2(7) 
   in Ada.Wide_Characters.Handling   A.3.5(20/3), A.3.5(21/3) 
To_Mapping    in Ada.Strings.Maps   A.4.2(23) 
   in Ada.Strings.Wide_Maps   A.4.7(23) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(23/2) 
To_Packed in Interfaces.COBOL   B.4(41) 
To_Picture in Ada.Text_IO.Editing   F.3.3(6) 
To_Pointer    in System.Address_To_Access_Conversions   13.7.2(3/3) 
To_Range    in Ada.Strings.Maps   A.4.2(24) 
   in Ada.Strings.Wide_Maps   A.4.7(25) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(25/2) 
To_Ranges    in Ada.Strings.Maps   A.4.2(10) 
   in Ada.Strings.Wide_Maps   A.4.7(10) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(10/2) 
To_Sequence    in Ada.Strings.Maps   A.4.2(19) 
   in Ada.Strings.Wide_Maps   A.4.7(19) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(19/2) 
To_Set    in Ada.Containers.Hashed_Sets   A.18.8(9/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(10/2) 
   in Ada.Strings.Maps   A.4.2(8), A.4.2(9), A.4.2(17), 
A.4.2(18) 
   in Ada.Strings.Wide_Maps   A.4.7(8), A.4.7(9), A.4.7(17), 
A.4.7(18) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(8/2), A.4.8(9/2), 
A.4.8(17/2), A.4.8(18/2) 
To_String    in Ada.Characters.Conversions   A.3.4(5/2) 
   in Ada.Strings.Bounded   A.4.4(12) 
   in Ada.Strings.Unbounded   A.4.5(11) 
To_Time_Span in Ada.Real_Time   D.8(13) To_Unbounded_String 
   in Ada.Strings.Unbounded   A.4.5(9), A.4.5(10) 
To_Upper    in Ada.Characters.Handling   A.3.2(6), A.3.2(7) 
   in Ada.Wide_Characters.Handling   A.3.5(20/3), A.3.5(21/3) 
To_Vector in Ada.Containers.Vectors   A.18.2(13/2), 
A.18.2(14/2) 
To_Wide_Character    in Ada.Characters.Conversions   A.3.4(4/2), A.3.4(5/2) 
To_Wide_String    in Ada.Characters.Conversions   A.3.4(4/2), A.3.4(5/2) 
To_Wide_Wide_Character    in Ada.Characters.Conversions   A.3.4(4/2) 
To_Wide_Wide_String    in Ada.Characters.Conversions   A.3.4(4/2) 
Translate    in Ada.Strings.Bounded   A.4.4(53), A.4.4(54), A.4.4(55), 
A.4.4(56) 
   in Ada.Strings.Fixed   A.4.3(18), A.4.3(19), A.4.3(20), 
A.4.3(21) 
   in Ada.Strings.Unbounded   A.4.5(48), A.4.5(49), A.4.5(50), 
A.4.5(51) 
Transpose    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(34/2) 
   in Ada.Numerics.Generic_Real_Arrays   G.3.1(17/2) 
Trim    in Ada.Strings.Bounded   A.4.4(67), A.4.4(68), A.4.4(69) 
   in Ada.Strings.Fixed   A.4.3(31), A.4.3(32), A.4.3(33), 
A.4.3(34) 
   in Ada.Strings.Unbounded   A.4.5(61), A.4.5(62), A.4.5(63), 
A.4.5(64) 
Unbounded_Slice    in Ada.Strings.Unbounded   A.4.5(22.1/2), A.4.5(22.2/2) 
Unchecked_Conversion    child of  Ada   13.9(3/3) 
Unchecked_Deallocation    child of  Ada   13.11.2(3/3) 
Union    in Ada.Containers.Hashed_Sets   A.18.8(26/2), A.18.8(27/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(27/2), A.18.9(28/2) 
Unit_Matrix    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(51/2) 
   in Ada.Numerics.Generic_Real_Arrays   G.3.1(29/2) 
Unit_Vector    in Ada.Numerics.Generic_Complex_Arrays   G.3.2(24/2) 
   in Ada.Numerics.Generic_Real_Arrays   G.3.1(14/2) 
Update in Interfaces.C.Strings   B.3.1(18), B.3.1(19) 
Update_Element    in Ada.Containers.Doubly_Linked_Lists   A.18.3(17/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(17/2) 
   in Ada.Containers.Indefinite_Holders   A.18.18(15/3) 
   in Ada.Containers.Multiway_Trees   A.18.10(27/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(16/2) 
   in Ada.Containers.Vectors   A.18.2(33/2), A.18.2(34/2) 
Update_Element_Preserving_Key    in Ada.Containers.Hashed_Sets   A.18.8(58/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(73/2) 
Update_Error in Interfaces.C.Strings   B.3.1(20) 
UTC_Time_Offset    in Ada.Calendar.Time_Zones   9.6.1(6/2) 
Ada Reference Manual — 2012 Edition 
861      13 December 2012 Language-Defined Subprograms   Q.3 Valid 
   in Ada.Text_IO.Editing   F.3.3(5), F.3.3(12) 
   in Interfaces.COBOL   B.4(33), B.4(38), B.4(43) 
Value    in Ada.Calendar.Formatting   9.6.1(36/2), 9.6.1(38/2) 
   in Ada.Environment_Variables   A.17(4.1/3), A.17(4/2) 
   in Ada.Numerics.Discrete_Random   A.5.2(26) 
   in Ada.Numerics.Float_Random   A.5.2(14) 
   in Ada.Strings.Maps   A.4.2(21) 
   in Ada.Strings.Wide_Maps   A.4.7(21) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(21/2) 
   in Ada.Task_Attributes   C.7.2(4) 
   in Interfaces.C.Pointers   B.3.2(6), B.3.2(7) 
   in Interfaces.C.Strings   B.3.1(13), B.3.1(14), B.3.1(15), 
B.3.1(16) 
Virtual_Length    in Interfaces.C.Pointers   B.3.2(13) 
Wait_For_Release    in Ada.Synchronous_Barriers   D.10.1(6/3) 
Wide_Equal_Case_Insensitive    child of  Ada.Strings.Wide_Bounded   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Fixed   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Unbounded   A.4.7(1/3) 
Wide_Hash    child of  Ada.Strings.Wide_Bounded   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Fixed   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Unbounded   A.4.7(1/3) 
Wide_Hash_Case_Insensitive    child of  Ada.Strings.Wide_Bounded   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Fixed   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Unbounded   A.4.7(1/3) 
Wide_Exception_Name in Ada.Exceptions   11.4.1(2/2), 
11.4.1(5/2) Wide_Expanded_Name in Ada.Tags   3.9(7/2) 
Wide_Wide_Equal_Case_Insensitive    child of  Ada.Strings.Wide_Wide_Bounded   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Fixed   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Unbounded   A.4.8(1/3) 
Wide_Wide_Hash    child of  Ada.Strings.Wide_Wide_Bounded   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Fixed   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Unbounded   A.4.8(1/3) 
Wide_Wide_Hash_Case_Insensitive    child of  Ada.Strings.Wide_Wide_Bounded   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Fixed   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Unbounded   A.4.8(1/3) 
Wide_Wide_Exception_Name    in Ada.Exceptions   11.4.1(2/2), 11.4.1(5/2) 
Wide_Wide_Expanded_Name in Ada.Tags   3.9(7/2) 
Write    in Ada.Direct_IO   A.8.4(13) 
   in Ada.Sequential_IO   A.8.1(12) 
   in Ada.Storage_IO   A.9(7) 
   in Ada.Streams   13.13.1(6) 
   in Ada.Streams.Stream_IO   A.12.1(18), A.12.1(19) 
   in System.RPC   E.5(8) 
Year    in Ada.Calendar   9.6(13) 
   in Ada.Calendar.Formatting   9.6.1(21/2) 
Yield in Ada.Dispatching   D.2.1(1.3/3) 
Yield_To_Higher    in Ada.Dispatching.Non_Preemptive   D.2.4(2.2/3) 
Yield_To_Same_Or_Higher    in Ada.Dispatching.Non_Preemptive   D.2.4(2.2/3) 
Q.4 Language-Defined Exceptions 
This subclause lists all la nguage-defined exceptions.  
  
Argument_Error 
   in Ada.Numerics   A.5(3/2) 
Assertion_Error    in Ada.Assertions   11.4.2(13/2) 
Capacity_Error    in Ada.Containers   A.18.1(5.1/3) 
Communication_Error    in System.RPC   E.5(5) 
Constraint_Error    in Standard   A.1(46) 
Conversion_Error    in Interfaces.COBOL   B.4(30) 
Data_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Storage_IO   A.9(9) 
   in Ada.Streams.Stream_IO   A.12.1(26)    in Ada.Text_IO   A.10.1(85) 
Device_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.Directories   A.16(43/2) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
Dispatching_Domain_Error    in System.Multiprocessors.Dispatching_Domains   
D.16.1(4/3) 
Dispatching_Policy_Error    in Ada.Dispatching   D.2.1(1.4/3) 
Encoding_Error    in Ada.Strings.UTF_Encoding   A.4.11(8/3) 
End_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.IO_Exceptions   A.13(4) 1/3 
Ada Reference Manual — 2012 Edition 
Q.4   Language-Defined Exceptions 13 December 2012      862    in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
Group_Budget_Error    in Ada.Execution_Time.Group_Budgets   D.14.2(11/2) 
Index_Error    in Ada.Strings   A.4.1(5) 
Layout_Error    in Ada.IO_Exceptions   A.13(4) 
   in Ada.Text_IO   A.10.1(85) 
Length_Error    in Ada.Strings   A.4.1(5) 
Mode_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
Name_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.Directories   A.16(43/2) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
Pattern_Error    in Ada.Strings   A.4.1(5) 
Picture_Error    in Ada.Text_IO.Editing   F.3.3(9) 
Pointer_Error    in Interfaces.C.Pointers   B.3.2(8) Program_Error 
   in Standard   A.1(46) 
Status_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.Directories   A.16(43/2) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
Storage_Error    in Standard   A.1(46) 
Tag_Error    in Ada.Tags   3.9(8) 
Tasking_Error    in Standard   A.1(46) 
Terminator_Error    in Interfaces.C   B.3(40) 
Time_Error    in Ada.Calendar   9.6(18) 
Timer_Resource_Error    in Ada.Execution_Time.Timers   D.14.1(9/2) 
Translation_Error    in Ada.Strings   A.4.1(5) 
Unknown_Zone_Error    in Ada.Calendar.Time_Zones   9.6.1(5/2) 
Use_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.Directories   A.16(43/2) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
Q.5 Language-Defined Objects 
This subclause lists all la nguage-defined constants, variables, na med numbers, and enumeration literals.  
  
ACK in Ada.Characters.Latin_1   A.3.3(5) 
Acute in Ada.Characters.Latin_1   A.3.3(22) 
Ada_To_COBOL in Interfaces.COBOL   B.4(14) 
Alphanumeric_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
Ampersand in Ada.Characters.Latin_1   A.3.3(8) 
APC in Ada.Characters.Latin_1   A.3.3(19) 
Apostrophe in Ada.Characters.Latin_1   A.3.3(8) 
Asterisk in Ada.Characters.Latin_1   A.3.3(8) 
Basic_Map    in Ada.Strings.Maps.Constants   A.4.6(5) 
Basic_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
BEL in Ada.Characters.Latin_1   A.3.3(5) 
BOM_16 in Ada.Strings.UTF_Encoding   A.4.11(12/3) 
BOM_16BE in Ada.Strings.UTF_Encoding   A.4.11(10/3) 
BOM_16LE in Ada.Strings.UTF_Encoding   A.4.11(11/3) 
BOM_8 in Ada.Strings.UTF_Encoding   A.4.11(9/3) 
BPH in Ada.Characters.Latin_1   A.3.3(17) Broken_Bar in Ada.Characters.Latin_1   A.3.3(21/3) 
BS in Ada.Characters.Latin_1   A.3.3(5) 
Buffer_Size in Ada.Storage_IO   A.9(4) 
CAN in Ada.Characters.Latin_1   A.3.3(6) 
CCH in Ada.Characters.Latin_1   A.3.3(18) 
Cedilla in Ada.Characters.Latin_1   A.3.3(22) 
Cent_Sign in Ada.Characters.Latin_1   A.3.3(21/3) 
char16_nul in Interfaces.C   B.3(39.3/2) 
char32_nul in Interfaces.C   B.3(39.12/2) 
CHAR_BIT in Interfaces.C   B.3(6) 
Character_Set    in Ada.Strings.Wide_Maps   A.4.7(46/2) 
   in Ada.Strings.Wide_Maps.Wide_Constants   A.4.8(48/2) 
Circumflex in Ada.Characters.Latin_1   A.3.3(12) 
COBOL_To_Ada in Interfaces.COBOL   B.4(15) 
Colon in Ada.Characters.Latin_1   A.3.3(10) 
Comma in Ada.Characters.Latin_1   A.3.3(8) 
Commercial_At    in Ada.Characters.Latin_1   A.3.3(10) 1/3 
Ada Reference Manual — 2012 Edition 
863      13 December 2012 Language-Defined Objects   Q.5 Control_Set 
   in Ada.Strings.Maps.Constants   A.4.6(4) 
Copyright_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
Country_Unknown in Ada.Locales   A.19(5/3) 
CPU_Tick in Ada.Execution_Time   D.14(4/2) 
CPU_Time_First in Ada.Execution_Time   D.14(4/2) 
CPU_Time_Last in Ada.Execution_Time   D.14(4/2) 
CPU_Time_Unit in Ada.Execution_Time   D.14(4/2) 
CR in Ada.Characters.Latin_1   A.3.3(5) 
CSI in Ada.Characters.Latin_1   A.3.3(19) 
Currency_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
DC1 in Ada.Characters.Latin_1   A.3.3(6) 
DC2 in Ada.Characters.Latin_1   A.3.3(6) 
DC3 in Ada.Characters.Latin_1   A.3.3(6) 
DC4 in Ada.Characters.Latin_1   A.3.3(6) 
DCS in Ada.Characters.Latin_1   A.3.3(18) 
Decimal_Digit_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
Default_Aft    in Ada.Text_IO   A.10.1(64), A.10.1(69), A.10.1(74) 
   in Ada.Text_IO.Complex_IO   G.1.3(5) 
Default_Base in Ada.Text_IO   A.10.1(53), A.10.1(58) 
Default_Bit_Order in System   13.7(15/2) 
Default_Currency    in Ada.Text_IO.Editing   F.3.3(10) 
Default_Deadline    in Ada.Dispatching.EDF   D.2.6(9/2) 
Default_Exp    in Ada.Text_IO   A.10.1(64), A.10.1(69), A.10.1(74) 
   in Ada.Text_IO.Complex_IO   G.1.3(5) 
Default_Fill in Ada.Text_IO.Editing   F.3.3(10) 
Default_Fore    in Ada.Text_IO   A.10.1(64), A.10.1(69), A.10.1(74) 
   in Ada.Text_IO.Complex_IO   G.1.3(5) 
Default_Priority in System   13.7(17) 
Default_Quantum    in Ada.Dispatching.Round_Robin   D.2.5(4/2) 
Default_Radix_Mark    in Ada.Text_IO.Editing   F.3.3(10) 
Default_Separator    in Ada.Text_IO.Editing   F.3.3(10) 
Default_Setting in Ada.Text_IO   A.10.1(80) 
Default_Width in Ada.Text_IO   A.10.1(53), A.10.1(58), 
A.10.1(80) 
Degree_Sign in Ada.Characters.Latin_1   A.3.3(22) 
DEL in Ada.Characters.Latin_1   A.3.3(14) 
Diaeresis in Ada.Characters.Latin_1   A.3.3(21/3) 
Division_Sign    in Ada.Characters.Latin_1   A.3.3(26) 
DLE in Ada.Characters.Latin_1   A.3.3(6) 
Dollar_Sign in Ada.Characters.Latin_1   A.3.3(8) 
e in Ada.Numerics   A.5(3/2) 
EM in Ada.Characters.Latin_1   A.3.3(6) 
Empty_Holder    in Ada.Containers.Indefinite_Holders   A.18.18(7/3) 
Empty_List    in Ada.Containers.Doubly_Linked_Lists   A.18.3(8/2) Empty_Map 
   in Ada.Containers.Hashed_Maps   A.18.5(5/2) 
   in Ada.Containers.Ordered_Maps   A.18.6(6/2) 
Empty_Set    in Ada.Containers.Hashed_Sets   A.18.8(5/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(6/2) 
Empty_Tree    in Ada.Containers.Multiway_Trees   A.18.10(10/3) 
Empty_Vector    in Ada.Containers.Vectors   A.18.2(10/2) 
ENQ in Ada.Characters.Latin_1   A.3.3(5) 
EOT in Ada.Characters.Latin_1   A.3.3(5) 
EPA in Ada.Characters.Latin_1   A.3.3(18) 
Equals_Sign in Ada.Characters.Latin_1   A.3.3(10) 
ESA in Ada.Characters.Latin_1   A.3.3(17) 
ESC in Ada.Characters.Latin_1   A.3.3(6) 
ETB in Ada.Characters.Latin_1   A.3.3(6) 
ETX in Ada.Characters.Latin_1   A.3.3(5) 
Exclamation in Ada.Characters.Latin_1   A.3.3(8) 
Failure in Ada.Command_Line   A.15(8) 
Feminine_Ordinal_Indicator    in Ada.Characters.Latin_1   A.3.3(21/3) 
FF in Ada.Characters.Latin_1   A.3.3(5) 
Fine_Delta in System   13.7(9) 
Fraction_One_Half    in Ada.Characters.Latin_1   A.3.3(22) 
Fraction_One_Quarter    in Ada.Characters.Latin_1   A.3.3(22) 
Fraction_Three_Quarters    in Ada.Characters.Latin_1   A.3.3(22) 
Friday in Ada.Calendar.Formatting   9.6.1(17/2) 
FS in Ada.Characters.Latin_1   A.3.3(6) 
Full_Stop in Ada.Characters.Latin_1   A.3.3(8) 
Graphic_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
Grave in Ada.Characters.Latin_1   A.3.3(13) 
Greater_Than_Sign    in Ada.Characters.Latin_1   A.3.3(10) 
GS in Ada.Characters.Latin_1   A.3.3(6) 
Hexadecimal_Digit_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
High_Order_First    in Interfaces.COBOL   B.4(25) 
   in System   13.7(15/2) 
HT in Ada.Characters.Latin_1   A.3.3(5) 
HTJ in Ada.Characters.Latin_1   A.3.3(17) 
HTS in Ada.Characters.Latin_1   A.3.3(17) 
Hyphen in Ada.Characters.Latin_1   A.3.3(8) 
i    in Ada.Numerics.Generic_Complex_Types   G.1.1(5) 
   in Interfaces.Fortran   B.5(10) 
Identity    in Ada.Strings.Maps   A.4.2(22) 
   in Ada.Strings.Wide_Maps   A.4.7(22) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(22/2) 
Interrupt_Clocks_Supported    in Ada.Execution_Time   D.14(9.1/3) 
Inverted_Exclamation    in Ada.Characters.Latin_1   A.3.3(21/3) 
Ada Reference Manual — 2012 Edition 
Q.5   Language-Defined Objects 13 December 2012      864 Inverted_Question 
   in Ada.Characters.Latin_1   A.3.3(22) 
IS1 in Ada.Characters.Latin_1   A.3.3(16) 
IS2 in Ada.Characters.Latin_1   A.3.3(16) 
IS3 in Ada.Characters.Latin_1   A.3.3(16) 
IS4 in Ada.Characters.Latin_1   A.3.3(16) 
ISO_646_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
j    in Ada.Numerics.Generic_Complex_Types   G.1.1(5) 
   in Interfaces.Fortran   B.5(10) 
Language_Unknown in Ada.Locales   A.19(5/3) 
LC_A in Ada.Characters.Latin_1   A.3.3(13) 
LC_A_Acute in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Circumflex    in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Diaeresis    in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Grave in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Ring in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Tilde in Ada.Characters.Latin_1   A.3.3(25) 
LC_AE_Diphthong    in Ada.Characters.Latin_1   A.3.3(25) 
LC_B in Ada.Characters.Latin_1   A.3.3(13) 
LC_C in Ada.Characters.Latin_1   A.3.3(13) 
LC_C_Cedilla    in Ada.Characters.Latin_1   A.3.3(25) 
LC_D in Ada.Characters.Latin_1   A.3.3(13) 
LC_E in Ada.Characters.Latin_1   A.3.3(13) 
LC_E_Acute in Ada.Characters.Latin_1   A.3.3(25) 
LC_E_Circumflex    in Ada.Characters.Latin_1   A.3.3(25) 
LC_E_Diaeresis    in Ada.Characters.Latin_1   A.3.3(25) 
LC_E_Grave in Ada.Characters.Latin_1   A.3.3(25) 
LC_F in Ada.Characters.Latin_1   A.3.3(13) 
LC_G in Ada.Characters.Latin_1   A.3.3(13) 
LC_German_Sharp_S    in Ada.Characters.Latin_1   A.3.3(24) 
LC_H in Ada.Characters.Latin_1   A.3.3(13) 
LC_I in Ada.Characters.Latin_1   A.3.3(13) 
LC_I_Acute in Ada.Characters.Latin_1   A.3.3(25) 
LC_I_Circumflex    in Ada.Characters.Latin_1   A.3.3(25) 
LC_I_Diaeresis    in Ada.Characters.Latin_1   A.3.3(25) 
LC_I_Grave in Ada.Characters.Latin_1   A.3.3(25) 
LC_Icelandic_Eth    in Ada.Characters.Latin_1   A.3.3(26) 
LC_Icelandic_Thorn    in Ada.Characters.Latin_1   A.3.3(26) 
LC_J in Ada.Characters.Latin_1   A.3.3(13) 
LC_K in Ada.Characters.Latin_1   A.3.3(13) 
LC_L in Ada.Characters.Latin_1   A.3.3(13) 
LC_M in Ada.Characters.Latin_1   A.3.3(13) 
LC_N in Ada.Characters.Latin_1   A.3.3(13) 
LC_N_Tilde in Ada.Characters.Latin_1   A.3.3(26) 
LC_O in Ada.Characters.Latin_1   A.3.3(13) 
LC_O_Acute in Ada.Characters.Latin_1   A.3.3(26) LC_O_Circumflex 
   in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Diaeresis    in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Grave in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Oblique_Stroke    in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Tilde in Ada.Characters.Latin_1   A.3.3(26) 
LC_P in Ada.Characters.Latin_1   A.3.3(14) 
LC_Q in Ada.Characters.Latin_1   A.3.3(14) 
LC_R in Ada.Characters.Latin_1   A.3.3(14) 
LC_S in Ada.Characters.Latin_1   A.3.3(14) 
LC_T in Ada.Characters.Latin_1   A.3.3(14) 
LC_U in Ada.Characters.Latin_1   A.3.3(14) 
LC_U_Acute in Ada.Characters.Latin_1   A.3.3(26) 
LC_U_Circumflex    in Ada.Characters.Latin_1   A.3.3(26) 
LC_U_Diaeresis    in Ada.Characters.Latin_1   A.3.3(26) 
LC_U_Grave in Ada.Characters.Latin_1   A.3.3(26) 
LC_V in Ada.Characters.Latin_1   A.3.3(14) 
LC_W in Ada.Characters.Latin_1   A.3.3(14) 
LC_X in Ada.Characters.Latin_1   A.3.3(14) 
LC_Y in Ada.Characters.Latin_1   A.3.3(14) 
LC_Y_Acute in Ada.Characters.Latin_1   A.3.3(26) 
LC_Y_Diaeresis    in Ada.Characters.Latin_1   A.3.3(26) 
LC_Z in Ada.Characters.Latin_1   A.3.3(14) 
Leading_Nonseparate    in Interfaces.COBOL   B.4(23) 
Leading_Separate in Interfaces.COBOL   B.4(23) 
Left_Angle_Quotation    in Ada.Characters.Latin_1   A.3.3(21/3) 
Left_Curly_Bracket    in Ada.Characters.Latin_1   A.3.3(14) 
Left_Parenthesis    in Ada.Characters.Latin_1   A.3.3(8) 
Left_Square_Bracket    in Ada.Characters.Latin_1   A.3.3(12) 
Less_Than_Sign    in Ada.Characters.Latin_1   A.3.3(10) 
Letter_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
LF in Ada.Characters.Latin_1   A.3.3(5) 
Low_Line in Ada.Characters.Latin_1   A.3.3(12) 
Low_Order_First    in Interfaces.COBOL   B.4(25) 
   in System   13.7(15/2) 
Lower_Case_Map    in Ada.Strings.Maps.Constants   A.4.6(5) 
Lower_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
Macron in Ada.Characters.Latin_1   A.3.3(21/3) 
Masculine_Ordinal_Indicator    in Ada.Characters.Latin_1   A.3.3(22) 
Max_Base_Digits in System   13.7(8) 
Max_Binary_Modulus in System   13.7(7) 
Max_Decimal_Digits in Ada.Decimal   F.2(5) 
Max_Delta in Ada.Decimal   F.2(4) 
Max_Digits in System   13.7(8) 
Ada Reference Manual — 2012 Edition 
865      13 December 2012 Language-Defined Objects   Q.5 Max_Digits_Binary in Interfaces.COBOL   B.4(11) 
Max_Digits_Long_Binary    in Interfaces.COBOL   B.4(11) 
Max_Image_Width    in Ada.Numerics.Discrete_Random   A.5.2(25) 
   in Ada.Numerics.Float_Random   A.5.2(13) 
Max_Int in System   13.7(6) 
Max_Length in Ada.Strings.Bounded   A.4.4(5) 
Max_Mantissa in System   13.7(9) 
Max_Nonbinary_Modulus in System   13.7(7) 
Max_Picture_Length    in Ada.Text_IO.Editing   F.3.3(8) 
Max_Scale in Ada.Decimal   F.2(3) 
Memory_Size in System   13.7(13) 
Micro_Sign in Ada.Characters.Latin_1   A.3.3(22) 
Middle_Dot in Ada.Characters.Latin_1   A.3.3(22) 
Min_Delta in Ada.Decimal   F.2(4) 
Min_Handler_Ceiling    in Ada.Execution_Time.Group_Budgets   D.14.2(7/2) 
   in Ada.Execution_Time.Timers   D.14.1(6/2) 
Min_Int in System   13.7(6) 
Min_Scale in Ada.Decimal   F.2(3) 
Minus_Sign in Ada.Characters.Latin_1   A.3.3(8) 
Monday in Ada.Calendar.Formatting   9.6.1(17/2) 
Multiplication_Sign    in Ada.Characters.Latin_1   A.3.3(24) 
MW in Ada.Characters.Latin_1   A.3.3(18) 
NAK in Ada.Characters.Latin_1   A.3.3(6) 
Native_Binary in Interfaces.COBOL   B.4(25) 
NBH in Ada.Characters.Latin_1   A.3.3(17) 
NBSP in Ada.Characters.Latin_1   A.3.3(21/3) 
NEL in Ada.Characters.Latin_1   A.3.3(17) 
No_Break_Space    in Ada.Characters.Latin_1   A.3.3(21/3) 
No_Element    in Ada.Containers.Doubly_Linked_Lists   A.18.3(9/2) 
   in Ada.Containers.Hashed_Maps   A.18.5(6/2) 
   in Ada.Containers.Hashed_Sets   A.18.8(6/2) 
   in Ada.Containers.Multiway_Trees   A.18.10(11/3) 
   in Ada.Containers.Ordered_Maps   A.18.6(7/2) 
   in Ada.Containers.Ordered_Sets   A.18.9(7/2) 
   in Ada.Containers.Vectors   A.18.2(11/2) 
No_Index in Ada.Containers.Vectors   A.18.2(7/2) 
No_Tag in Ada.Tags   3.9(6.1/2) 
Not_A_Specific_CPU    in System.Multiprocessors   D.16(4/3) 
Not_Sign in Ada.Characters.Latin_1   A.3.3(21/3) 
NUL    in Ada.Characters.Latin_1   A.3.3(5) 
   in Interfaces.C   B.3(20/1) 
Null_Address in System   13.7(12) 
Null_Bounded_String    in Ada.Strings.Bounded   A.4.4(7) 
Null_Id in Ada.Exceptions   11.4.1(2/2) 
Null_Occurrence in Ada.Exceptions   11.4.1(3/2) 
Null_Ptr in Interfaces.C.Strings   B.3.1(7) 
Null_Set    in Ada.Strings.Maps   A.4.2(5) 
   in Ada.Strings.Wide_Maps   A.4.7(5) 
   in Ada.Strings.Wide_Wide_Maps   A.4.8(5/2) Null_Unbounded_String 
   in Ada.Strings.Unbounded   A.4.5(5) 
Number_Sign in Ada.Characters.Latin_1   A.3.3(8) 
OSC in Ada.Characters.Latin_1   A.3.3(19) 
Packed_Signed in Interfaces.COBOL   B.4(27) 
Packed_Unsigned in Interfaces.COBOL   B.4(27) 
Paragraph_Sign    in Ada.Characters.Latin_1   A.3.3(22) 
Percent_Sign    in Ada.Characters.Latin_1   A.3.3(8) 
Pi in Ada.Numerics   A.5(3/2) 
Pilcrow_Sign    in Ada.Characters.Latin_1   A.3.3(22) 
PLD in Ada.Characters.Latin_1   A.3.3(17) 
PLU in Ada.Characters.Latin_1   A.3.3(17) 
Plus_Minus_Sign    in Ada.Characters.Latin_1   A.3.3(22) 
Plus_Sign in Ada.Characters.Latin_1   A.3.3(8) 
PM in Ada.Characters.Latin_1   A.3.3(19) 
Pound_Sign in Ada.Characters.Latin_1   A.3.3(21/3) 
PU1 in Ada.Characters.Latin_1   A.3.3(18) 
PU2 in Ada.Characters.Latin_1   A.3.3(18) 
Question in Ada.Characters.Latin_1   A.3.3(10) 
Quotation in Ada.Characters.Latin_1   A.3.3(8) 
Registered_Trade_Mark_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
Reserved_128    in Ada.Characters.Latin_1   A.3.3(17) 
Reserved_129    in Ada.Characters.Latin_1   A.3.3(17) 
Reserved_132    in Ada.Characters.Latin_1   A.3.3(17) 
Reserved_153    in Ada.Characters.Latin_1   A.3.3(19) 
Reverse_Solidus    in Ada.Characters.Latin_1   A.3.3(12) 
RI in Ada.Characters.Latin_1   A.3.3(17) 
Right_Angle_Quotation    in Ada.Characters.Latin_1   A.3.3(22) 
Right_Curly_Bracket    in Ada.Characters.Latin_1   A.3.3(14) 
Right_Parenthesis    in Ada.Characters.Latin_1   A.3.3(8) 
Right_Square_Bracket    in Ada.Characters.Latin_1   A.3.3(12) 
Ring_Above in Ada.Characters.Latin_1   A.3.3(22) 
RS in Ada.Characters.Latin_1   A.3.3(6) 
Saturday in Ada.Calendar.Formatting   9.6.1(17/2) 
SCHAR_MAX in Interfaces.C   B.3(6) 
SCHAR_MIN in Interfaces.C   B.3(6) 
SCI in Ada.Characters.Latin_1   A.3.3(19) 
Section_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
Semicolon in Ada.Characters.Latin_1   A.3.3(10) 
Separate_Interrupt_Clocks_Supported    in Ada.Execution_Time   D.14(9.2/3) 
SI in Ada.Characters.Latin_1   A.3.3(5) 
SO in Ada.Characters.Latin_1   A.3.3(5) 
Soft_Hyphen in Ada.Characters.Latin_1   A.3.3(21/3) 
SOH in Ada.Characters.Latin_1   A.3.3(5) 
Ada Reference Manual — 2012 Edition 
Q.5   Language-Defined Objects 13 December 2012      866 Solidus in Ada.Characters.Latin_1   A.3.3(8) 
SOS in Ada.Characters.Latin_1   A.3.3(19) 
SPA in Ada.Characters.Latin_1   A.3.3(18) 
Space    in Ada.Characters.Latin_1   A.3.3(8) 
   in Ada.Strings   A.4.1(4/2) 
Special_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
SS2 in Ada.Characters.Latin_1   A.3.3(17) 
SS3 in Ada.Characters.Latin_1   A.3.3(17) 
SSA in Ada.Characters.Latin_1   A.3.3(17) 
ST in Ada.Characters.Latin_1   A.3.3(19) 
Storage_Unit in System   13.7(13) 
STS in Ada.Characters.Latin_1   A.3.3(18) 
STX in Ada.Characters.Latin_1   A.3.3(5) 
SUB in Ada.Characters.Latin_1   A.3.3(6) 
Success in Ada.Command_Line   A.15(8) 
Sunday in Ada.Calendar.Formatting   9.6.1(17/2) 
Superscript_One    in Ada.Characters.Latin_1   A.3.3(22) 
Superscript_Three    in Ada.Characters.Latin_1   A.3.3(22) 
Superscript_Two    in Ada.Characters.Latin_1   A.3.3(22) 
SYN in Ada.Characters.Latin_1   A.3.3(6) 
System_Dispatching_Domain    in System.Multiprocessors.Dispatching_Domains   
D.16.1(6/3) 
System_Name in System   13.7(4) 
Thursday in Ada.Calendar.Formatting   9.6.1(17/2) 
Tick    in Ada.Real_Time   D.8(6) 
   in System   13.7(10) 
Tilde in Ada.Characters.Latin_1   A.3.3(14) 
Time_First in Ada.Real_Time   D.8(4) 
Time_Last in Ada.Real_Time   D.8(4) 
Time_Span_First in Ada.Real_Time   D.8(5) 
Time_Span_Last in Ada.Real_Time   D.8(5) 
Time_Span_Unit in Ada.Real_Time   D.8(5) 
Time_Span_Zero in Ada.Real_Time   D.8(5) 
Time_Unit in Ada.Real_Time   D.8(4) 
Trailing_Nonseparate    in Interfaces.COBOL   B.4(23) 
Trailing_Separate in Interfaces.COBOL   B.4(23) 
Tuesday in Ada.Calendar.Formatting   9.6.1(17/2) 
UC_A_Acute in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Circumflex    in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Diaeresis    in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Grave in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Ring in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Tilde in Ada.Characters.Latin_1   A.3.3(23) 
UC_AE_Diphthong    in Ada.Characters.Latin_1   A.3.3(23) UC_C_Cedilla 
   in Ada.Characters.Latin_1   A.3.3(23) 
UC_E_Acute in Ada.Characters.Latin_1   A.3.3(23) 
UC_E_Circumflex    in Ada.Characters.Latin_1   A.3.3(23) 
UC_E_Diaeresis    in Ada.Characters.Latin_1   A.3.3(23) 
UC_E_Grave in Ada.Characters.Latin_1   A.3.3(23) 
UC_I_Acute in Ada.Characters.Latin_1   A.3.3(23) 
UC_I_Circumflex    in Ada.Characters.Latin_1   A.3.3(23) 
UC_I_Diaeresis    in Ada.Characters.Latin_1   A.3.3(23) 
UC_I_Grave in Ada.Characters.Latin_1   A.3.3(23) 
UC_Icelandic_Eth    in Ada.Characters.Latin_1   A.3.3(24) 
UC_Icelandic_Thorn    in Ada.Characters.Latin_1   A.3.3(24) 
UC_N_Tilde in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Acute in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Circumflex    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Diaeresis    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Grave in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Oblique_Stroke    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Tilde in Ada.Characters.Latin_1   A.3.3(24) 
UC_U_Acute in Ada.Characters.Latin_1   A.3.3(24) 
UC_U_Circumflex    in Ada.Characters.Latin_1   A.3.3(24) 
UC_U_Diaeresis    in Ada.Characters.Latin_1   A.3.3(24) 
UC_U_Grave in Ada.Characters.Latin_1   A.3.3(24) 
UC_Y_Acute in Ada.Characters.Latin_1   A.3.3(24) 
UCHAR_MAX in Interfaces.C   B.3(6) 
Unbounded in Ada.Text_IO   A.10.1(5) 
Unsigned in Interfaces.COBOL   B.4(23) 
Upper_Case_Map    in Ada.Strings.Maps.Constants   A.4.6(5) 
Upper_Set    in Ada.Strings.Maps.Constants   A.4.6(4) 
US in Ada.Characters.Latin_1   A.3.3(6) 
Vertical_Line    in Ada.Characters.Latin_1   A.3.3(14) 
VT in Ada.Characters.Latin_1   A.3.3(5) 
VTS in Ada.Characters.Latin_1   A.3.3(17) 
Wednesday in Ada.Calendar.Formatting   9.6.1(17/2) 
Wide_Character_Set    in Ada.Strings.Wide_Maps.Wide_Constants   A.4.8(48/2) 
wide_nul in Interfaces.C   B.3(31/1) 
Wide_Space in Ada.Strings   A.4.1(4/2) 
Wide_Wide_Space in Ada.Strings   A.4.1(4/2) 
Word_Size in System   13.7(13) 
Yen_Sign in Ada.Characters.Latin_1   A.3.3(21/3) 
Ada Reference Manual — 2012 Edition 
867      13 December 2012 Index Index 
Index entries are given by paragraph number.  
  
 
& operator   4.4(1/3), 4.5.3(3) 
  * operator   4.4(1/3), 4.5.5(1) ** operator   4.4(1/3), 4.5.6(7)   + operator   4.4(1/3), 4.5.3(1), 4.5.4(1)   - operator   4.4(1/3), 4.5.3(1), 4.5.4(1)   / operator   4.4(1/3), 4.5.5(1) /= operator   4.4(1/3), 4.5.2(1), 6.6(6/3)   10646:2011, ISO/IEC standard   1.2(8/3) 14882:2011, ISO/IEC standard   1.2(9/3) 1539-1:2004, ISO/IEC standard   1.2(3/2) 19769:2004, ISO/IEC technical report   
1.2(10/2) 
1989:2002, ISO standard   1.2(4/2)   3166-1:2006, ISO/IEC standard   
1.2(4.1/3) 
  639-3:2007, ISO standard   1.2(1.1/3) 6429:1992, ISO/IEC standard   1.2(5) 646:1991, ISO/IEC standard   1.2(2)   8859-1:1998, ISO/IEC standard   1.2(6/3)   9899:2011, ISO/IEC standard   1.2(7/3)   < operator   4.4(1/3), 4.5.2(1) <= operator   4.4(1/3), 4.5.2(1)   = operator   4.4(1/3), 4.5.2(1)   > operator   4.4(1/3), 4.5.2(1) >= operator   4.4(1/3), 4.5.2(1)  
A 
 AARM   0.2(5/3) abnormal completion   7.6.1(2/2) abnormal state of an object   13.9.1(4)    [partial ]   9.8(21), 11.6(6/3), A.13(17) 
abnormal task   9.8(4) abort    of a partition   E.1(7)    of a task   9.8(4)    of the execution of a construct   9.8(5) abort completion point   9.8(15) abort-deferred operation   9.8(5) abort_statement   9.8(2)    used   5.1(4/2), P 
Abort_Task    in Ada.Task_Identification   C.7.1(3/3) 
abortable_part   9.7.4(5)    used   9.7.4(2), P 
abs operator   4.4(1/3), 4.5.6(1) absolute value   4.4(1/3), 4.5.6(1) abstract data type (ADT)    See private types and private 
extensions   7.3(1) 
   See also  abstract type   3.9.3(1/2) 
abstract subprogram   3.9.3(1/2), 
3.9.3(3/2) 
abstract type   3.9.3(1.2/2), 3.9.3(1/2), 
N(1.1/2) 
abstract_subprogram_declaration   
3.9.3(1.1/3) 
   used   3.1(3/3), P 
accept_alternative   9.7.1(5)    used   9.7.1(4), P 
accept_statement   9.5.2(3)    used   5.1(5/2), 9.7.1(5), P 
acceptable interpretation   8.6(14) Access attribute   3.10.2(24/1), 
3.10.2(32/3) 
   See also  Unchecked_Access attribute   
13.10(3) 
access discriminant   3.7(9/2) access parameter   6.1(24/2) access paths    distinct   6.2(12/3) access result type   6.1(24/2) access type   3.10(1), N(2)    subpool   13.11.4(22/3) access types    input-output unspecified   A.7(6) access value   3.10(1) access-to-constant type   3.10(10) access-to-object type   3.10(7/1) access-to-subprogram type   3.10(7/1), 
3.10(11) 
access-to-variable type   3.10(10) Access_Check   11.5(11/2)    [partial ]   4.1(13), 4.1.5(8/3), 4.6(51/3), 
4.8(10.4/3) 
access_definition   3.10(6/2) 
   used   3.3.1(2/3), 3.6(7/2), 3.7(5/2), 
6.1(13/2), 6.1(15/3), 6.5(2.3/2), 8.5.1(2/3), 12.4(2/3), P 
access_to_object_defin ition   3.10(3) 
   used   3.10(2/2), P access_to_subprogram_definition   
3.10(5) 
   used   3.10(2/2), P 
access_type_definition   3.10(2/2)    used   3.2.1(4/2), 12.5.4(2), P 
accessibility    distributed   3.10.2(32.1/3)    from shared passive library units   
E.2.1(8) 
accessibility level   3.10.2(3/2) accessibility rule    Access attribute   3.10.2(28/3), 
3.10.2(32/3) 
   requeue statement   9.5.4(6/3)    type conversion   4.6(24.17/3), 
4.6(24.21/2) 
   type conversion, array components   
4.6(24.6/2) 
Accessibility_Check   11.5(19.1/2)    [partial ]   3.10.2(29), 4.6(39.1/2), 
4.6(48/3), 4.8(10.1/3), 6.5(8/3), 6.5(21/3), 13.11.4(25/3), 13.11.4(26/3), E.4(18/1) 
accessible partition   E.1(7) accuracy   4.6(32), G.2(1) ACK    in Ada.Characters.Latin_1   A.3.3(5) 
acquire    execution resource associated with 
protected object   9.5.1(5) 
activation    of a task   9.2(1) activation failure   9.2(1) Activation_Is_Complete    in Ada.Task_Identification   C.7.1(4/3) 
activator    of a task   9.2(5) active locale   A.19(8/3) active partition   10.2(28/3), E.1(2) active priority   D.1(15) actual   12.3(7/3) actual duration   D.9(12) actual parameter    for a formal parameter   6.4.1(3) actual subtype   3.3(23/3), 12.5(4)    of an object   3.3.1(9/2) actual type   12.5(4) actual_parameter_part   6.4(4)    used   4.1.6(10/3), 6.4(2), 6.4(3), 
9.5.3(2), P 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      868 Actual_Quantum 
   in Ada.Dispatching.Round_Robin   
D.2.5(4/2) 
Acute    in Ada.Characters.Latin_1   A.3.3(22) 
Ada   A.2(2) Ada calling convention   6.3.1(3/3) Ada.Ada.Unchecked_Deallocate_Subpool 
  13.11.5(3/3) 
Ada.Assertions   11.4.2(12/2) Ada.Asynchronous_Task_Control   
D.11(3/2) 
Ada.Calendar   9.6(10) Ada.Calendar.Arithmetic   9.6.1(8/2) Ada.Calendar.Formatting   9.6.1(15/2) Ada.Calendar.Time_Zones   9.6.1(2/2) Ada.Characters   A.3.1(2) Ada.Characters.Conversions   A.3.4(2/2) Ada.Characters.Handling   A.3.2(2/2) Ada.Characters.Latin_1   A.3.3(3) Ada.Command_Line   A.15(3) Ada.Complex_Text_IO   G.1.3(9.1/2) Ada.Containers   A.18.1(3/2) Ada.Containers.Bounded_Priority_Queue
s   A.18.31(2/3) 
Ada.Containers.Bounded_Synchronized_
Queues   A.18.29(2/3) 
Ada.Containers.Doubly_Linked_Lists   
A.18.3(5/3) 
Ada.Containers.Generic_Array_Sort   
A.18.26(3/2) 
Ada.Containers.Generic_Constrained_Arr
ay_Sort   A.18.26(7/2) 
Ada.Containers.Generic_Sort   
A.18.26(9.2/3) 
Ada.Containers.Hashed_Maps   
A.18.5(2/3) 
Ada.Containers.Hashed_Sets   A.18.8(2/3) Ada.Containers.Indefinite_Doubly_Linke
d_Lists   A.18.12(2/3) 
Ada.Containers.Indefinite_Hashed_Maps   
A.18.13(2/3) 
Ada.Containers.Indefinite_Hashed_Sets   
A.18.15(2/3) 
Ada.Containers.Indefinite_Holders   
A.18.18(5/3) 
Ada.Containers.Indefinite_Multiway_Tree
s   A.18.17(2/3) 
Ada.Containers.Indefinite_Ordered_Maps 
  A.18.14(2/3) 
Ada.Containers.Indefinite_Ordered_Sets   
A.18.16(2/3) 
Ada.Containers.Indefinite_Vectors   
A.18.11(2/3) 
Ada.Containers.Multiway_Trees   
A.18.10(7/3) 
Ada.Containers.Ordered_Maps   
A.18.6(2/3) 
Ada.Containers.Ordered_Sets   
A.18.9(2/3) Ada.Containers.Synchronized_Queue_Inte
rfaces   A.18.27(3/3) 
Ada.Containers.Unbounded_Priority_Que
ues   A.18.30(2/3) 
Ada.Containers.Unbounded_Synchronize
d_Queues   A.18.28(2/3) 
Ada.Containers.Vectors   A.18.2(6/3) Ada.Decimal   F.2(2) Ada.Direct_IO   A.8.4(2) Ada.Directories   A.16(3/2) Ada.Directories.Hierarchical_File_Names 
  A.16.1(3/3) 
Ada.Directories.Information   A.16(124/2) Ada.Dispatching   D.2.1(1.2/3) Ada.Dispatching.EDF   D.2.6(9/2) Ada.Dispatching.Non_Preemptive   
D.2.4(2.2/3) 
Ada.Dispatching.Round_Robin   
D.2.5(4/2) 
Ada.Dynamic_Priorities   D.5.1(3/2) Ada.Environment_Variables   A.17(3/2) Ada.Exceptions   11.4.1(2/2) Ada.Execution_Time   D.14(3/2) Ada.Execution_Time.Group_Budgets   
D.14.2(3/3) 
Ada.Execution_Time.Interrupts   
D.14.3(3/3) 
Ada.Execution_Time.Timers   D.14.1(3/2) Ada.Finalization   7.6(4/3) Ada.Float_Text_IO   A.10.9(33) Ada.Float_Wide_Text_IO   A.11(2/2) Ada.Float_Wide_Wide_Text_IO   
A.11(3/2) 
Ada.Integer_Text_IO   A.10.8(21) Ada.Integer_Wide_Text_IO   A.11(2/2) Ada.Integer_Wide_Wide_Text_IO   
A.11(3/2) 
Ada.Interrupts   C.3.2(2/3) Ada.Interrupts.Names   C.3.2(12) Ada.IO_Exceptions   A.13(3) Ada.Iterator_Interfaces   5.5.1(2/3) Ada.Locales   A.19(3/3) Ada.Numerics   A.5(3/2) Ada.Numerics.Complex_Arrays   
G.3.2(53/2) 
Ada.Numerics.Complex_Elementary_-
Functions   G.1.2(9/1) 
Ada.Numerics.Complex_Types   
G.1.1(25/1) 
Ada.Numerics.Discrete_Random   
A.5.2(17) 
Ada.Numerics.Elementary_Functions   
A.5.1(9/1) 
Ada.Numerics.Float_Random   A.5.2(5) Ada.Numerics.Generic_Complex_Arrays   
G.3.2(2/2) 
Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(2/2) 
Ada.Numerics.Generic_Complex_Types   
G.1.1(2/1) Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(3) 
Ada.Numerics.Generic_Real_Arrays   
G.3.1(2/2) 
Ada.Numerics.Real_Arrays   G.3.1(31/2) Ada.Real_Time   D.8(3) Ada.Real_Time.Timing_Events   
D.15(3/2) 
Ada.Sequential_IO   A.8.1(2) Ada.Storage_IO   A.9(3) Ada.Streams   13.13.1(2) Ada.Streams.Stream_IO   A.12.1(3/3) Ada.Strings   A.4.1(3) Ada.Strings.Bounded   A.4.4(3) Ada.Strings.Bounded.Equal_Case_Insensi
tive   A.4.10(7/3) 
Ada.Strings.Bounded.Hash   A.4.9(7/3) Ada.Strings.Bounded.Hash_Case_Insensit
ive   A.4.9(11.7/3) 
Ada.Strings.Bounded.Less_Case_Insensiti
ve   A.4.10(18/3) 
Ada.Strings.Equal_Case_Insensitive   
A.4.10(2/3) 
Ada.Strings.Fixed   A.4.3(5) Ada.Strings.Fixed.Equal_Case_Insensitive
   A.4.10(5/3) 
Ada.Strings.Fixed.Hash_Case_Insensitive 
  A.4.9(11.5/3) 
Ada.Strings.Fixed.Less_Case_Insensitive   
A.4.10(16/3) 
Ada.Strings.Hash   A.4.9(2/3) Ada.Strings.Hash_Case_Insensitive   
A.4.9(11.2/3) 
Ada.Strings.Less_Case_Insensitive   
A.4.10(13/3) 
Ada.Strings.Maps   A.4.2(3/2) Ada.Strings.Maps.Constants   A.4.6(3/2) Ada.Strings.Unbounded   A.4.5(3) Ada.Strings.Unbounded.Equal_Case_Inse
nsitive   A.4.10(10/3) 
Ada.Strings.Unbounded.Hash   
A.4.9(10/3) 
Ada.Strings.Unbounded.Hash_Case_Insen
sitive   A.4.9(11.10/3) 
Ada.Strings.Unbounded.Less_Case_Insen
sitive   A.4.10(21/3) 
Ada.Strings.UTF_Encoding   A.4.11(3/3) Ada.Strings.UTF_Encoding.Conversions   
A.4.11(15/3) 
Ada.Strings.UTF_Encoding.Strings   
A.4.11(22/3) 
Ada.Strings.UTF_Encoding.Wide_Strings
   A.4.11(30/3) 
Ada.Strings.UTF_Encoding.Wide_Wide_
Strings   A.4.11(38/3) 
Ada.Strings.Wide_Bounded   A.4.7(1/3) Ada.Strings.Wide_Bounded.Wide_-
Equal_Case_Insensitive   A.4.7(1/3) 
Ada.Strings.Wide_Bounded.Wide_Hash   
A.4.7(1/3) 
Ada Reference Manual — 2012 Edition 
869      13 December 2012 Index Ada.Strings.Wide_Bounded.Wide_-
Hash_Case_Insensitive   A.4.7(1/3) 
Ada.Strings.Wide_-
Equal_Case_Insensitive   A.4.7(1/3) 
Ada.Strings.Wide_Fixed   A.4.7(1/3) Ada.Strings.Wide_Fixed.Wide_-
Equal_Case_Insensitive   A.4.7(1/3) 
Ada.Strings.Wide_Fixed.Wide_Hash   
A.4.7(1/3) 
Ada.Strings.Wide_Fixed.Wide_-
Hash_Case_Insensitive   A.4.7(1/3) 
Ada.Strings.Wide_Hash   A.4.7(1/3) Ada.Strings.Wide_-
Hash_Case_Insensitive   A.4.7(1/3) 
Ada.Strings.Wide_Maps   A.4.7(3) Ada.Strings.Wide_Maps.Wide_-
Constants   A.4.7(1/3), A.4.8(28/2) 
Ada.Strings.Wide_Unbounded   
A.4.7(1/3) 
Ada.Strings.Wide_Unbounded.Wide_-
Equal_Case_Insensitive   A.4.7(1/3) 
Ada.Strings.Wide_Unbounded.Wide_-
Hash   A.4.7(1/3) 
Ada.Strings.Wide_Unbounded.Wide_-
Hash_Case_Insensitive   A.4.7(1/3) 
Ada.Strings.Wide_Wide_Bounded   
A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Bounded.Wide_Wide_-Equal_Case_Insensitive   A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Bounded.Wide_Wide_Hash   A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Bounded.Wide_Wide_-Hash_Case_Insensitive   A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Equal_Case_Insensitive   A.4.8(1/3) 
Ada.Strings.Wide_Wide_Fixed   
A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Fixed.Wide_Wide_-Equal_Case_Insensitive   A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Fixed.Wide_Wide_Hash   A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Fixed.Wide_Wide_-Hash_Case_Insensitive   A.4.8(1/3) 
Ada.Strings.Wide_Wide_Hash   
A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Hash_Case_Insensitive   A.4.8(1/3) 
Ada.Strings.Wide_Wide_Maps   
A.4.8(3/2) 
Ada.Strings.Wide_Wide_-
Maps.Wide_Wide_Constants   A.4.8(1/3) 
Ada.Strings.Wide_Wide_Unbounded   
A.4.8(1/3) Ada.Strings.Wide_Wide_-
Unbounded.Wide_Wide_-Equal_Case_Insensitive   A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Unbounded.Wide_Wide_Hash   A.4.8(1/3) 
Ada.Strings.Wide_Wide_-
Unbounded.Wide_Wide_-Hash_Case_Insensitive   A.4.8(1/3) 
Ada.Synchronous_Barriers   D.10.1(3/3) Ada.Synchronous_Task_Control   
D.10(3/2) 
Ada.Synchronous_Task_Control.EDF   
D.10(5.2/3) 
Ada.Tags   3.9(6/2) Ada.Tags.Generic_Dispatching_-
Constructor   3.9(18.2/3) 
Ada.Task_Attributes   C.7.2(2) Ada.Task_Identification   C.7.1(2/2) Ada.Task_Termination   C.7.3(2/2) Ada.Text_IO   A.10.1(2) Ada.Text_IO.Bounded_IO   A.10.11(3/2) Ada.Text_IO.Complex_IO   G.1.3(3) Ada.Text_IO.Editing   F.3.3(3) Ada.Text_IO.Text_Streams   A.12.2(3) Ada.Text_IO.Unbounded_IO   
A.10.12(3/2) 
Ada.Unchecked_Conversion   13.9(3/3) Ada.Unchecked_Deallocate_Subpool    child of  Ada   13.11.5(3/3) 
Ada.Unchecked_Deallocation   
13.11.2(3/3) 
Ada.Wide_Characters   A.3.1(4/2) Ada.Wide_Characters.Handling   
A.3.5(3/3) 
Ada.Wide_Text_IO   A.11(2/2) Ada.Wide_Text_IO.Bounded_IO   
A.11(4/3) 
Ada.Wide_Text_IO.Complex_IO   
G.1.4(1) 
Ada.Wide_Text_IO.Editing   F.3.4(1) Ada.Wide_Text_IO.Text_Streams   
A.12.3(3) 
Ada.Wide_Text_IO.Unbounded_IO   
A.11(5/3) 
Ada.Wide_Wide_Characters   A.3.1(6/2) Ada.Wide_Wide_Characters.Handling   
A.3.6(1/3) 
Ada.Wide_Wide_Text_IO   A.11(3/2) Ada.Wide_Wide_Text_IO.Bounded_IO   
A.11(4/3) 
Ada.Wide_Wide_Text_IO.Complex_IO   
G.1.5(1/2) 
Ada.Wide_Wide_Text_IO.Editing   
F.3.5(1/2) 
Ada.Wide_Wide_Text_IO.Text_Streams   
A.12.4(3/2) 
Ada.Wide_Wide_-
Text_IO.Unbounded_IO   A.11(5/3) Ada_To_COBOL 
   in Interfaces.COBOL   B.4(14) 
adafinal   B.1(39/3) adainit   B.1(39/3) Add    in 
Ada.Execution_Time.Group_Budgets   D.14.2(9/2) 
Add_Task    in 
Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
address    arithmetic   13.7.1(6)    comparison   13.7(14/3)    in System   13.7(12) 
Address aspect   13.3(12) Address attribute   13.3(11), J.7.1(5) Address clause   13.3(7/2), 13.3(12) Address_To_Access_Conversions    child of  System   13.7.2(2) 
Adjacent attribute   A.5.3(48) Adjust   7.6(2)    in Ada.Finalization   7.6(6/2) 
adjusting the value of an object   7.6(15), 
7.6(16/3) 
adjustment   7.6(15), 7.6(16/3)    as part of assignment   5.2(14/3) ADT (abstract data type)    See private types and private 
extensions   7.3(1) 
   See also  abstract type   3.9.3(1/2) 
advice   1.1.2(37) Aft attribute   3.5.10(5) aggregate   4.3(1), 4.3(2)    used   4.4(7/3), 4.7(2), P 
   See also  composite type   3.2(2/2) 
aliased   3.10(9/3), N(3) aliasing    See distinct access paths   6.2(12/3) 
Alignment    in Ada.Strings   A.4.1(6) 
Alignment (subtype) aspect   13.3(26.4/2) Alignment attribute   13.3(23/2), 
13.3(26.2/2) 
Alignment clause   13.3(7/2), 13.3(25/2), 
13.3(26.4/2) 
All_Calls_Remote aspect   E.2.3(16/3) All_Calls_Remote pragma   E.2.3(5), L(2) All_Checks   11.5(25/3) Allocate    in System.Storage_Pools   13.11(7) 
   in System.Storage_Pools.Subpools   
13.11.4(14/3) 
Allocate_From_Subpool    in System.Storage_Pools.Subpools   
13.11.4(11/3) 
Allocation_Check   11.5(19.2/2)    [partial ]   4.8(10.2/2), 4.8(10.3/2), 
4.8(10.4/3), 13.11.4(30/3) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      870 allocator   4.8(2/3) 
   used   4.4(7/3), P 
Alphanumeric    in Interfaces.COBOL   B.4(16/3) 
alphanumeric character    a category of Character   A.3.2(31) Alphanumeric_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
ambiguous   8.6(30) ambiguous cursor    of a vector   A.18.2(240/2) ampersand   2.1(15/3)    in Ada.Characters.Latin_1   A.3.3(8) 
ampersand operator   4.4(1/3), 4.5.3(3) ancestor   N(3.1/2)    of a library unit   10.1.1(11)    of a tree node   A.18.10(4/3)    of a type   3.4.1(10/2)    ultimate   3.4.1(10/2) ancestor subtype    of a formal derived type   12.5.1(5/3)    of a private_extension_declaration   
7.3(8) 
ancestor type    of an extension_aggregate   4.3.2(5/3) Ancestor_Find    in Ada.Containers.Multiway_Trees   
A.18.10(40/3) 
ancestor_part   4.3.2(3)    used   4.3.2(2), P 
and operator   4.4(1/3), 4.5.1(2) and then (short-circuit control form)   
4.4(1/3), 4.5.1(1) 
angle threshold   G.2.4(10) Annex    informative   1.1.2(18)    normative   1.1.2(14)    Specialized Needs   1.1.2(7) Annotated Ada Reference Manual   
0.2(5/3) 
anonymous access type    3.10(12/3) 
anonymous allocator   3.10.2(14/3) anonymous array type   3.3.1(1/3) anonymous protected type   3.3.1(1/3) anonymous task type   3.3.1(1/3) anonymous type   3.2.1(7/2) Any_Priority subtype of  Integer 
   in System   13.7(16) 
APC    in Ada.Characters.Latin_1   A.3.3(19) 
apostrophe   2.1(15/3)    in Ada.Characters.Latin_1   A.3.3(8) 
Append    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(23/2) 
   in Ada.Containers.Vectors   
A.18.2(46/2), A.18.2(47/2)    in Ada.Strings.Bounded   A.4.4(13), 
A.4.4(14), A.4.4(15), A.4.4(16), A.4.4(17), A.4.4(18), A.4.4(19), A.4.4(20) 
   in Ada.Strings.Unbounded   A.4.5(12), 
A.4.5(13), A.4.5(14) 
Append_Child    in Ada.Containers.Multiway_Trees   
A.18.10(52/3) 
applicable index constraint   4.3.3(10) application areas   1.1.2(7) applies    aspect   13.1.1(23/3), 13.1.1(27/3), 
13.1.1(29/3), 13.1.1(30/3) 
apply    to a callable construct by a return 
statement   6.5(4/2) 
   to a loop_statement by an 
exit_statement   5.7(4) 
   to a program unit by a program unit 
pragma   10.1.5(2) 
arbitrary order   1.1.4(18)    allowed   2.8(12), 3.3.1(20/2), 3.5(9), 
3.6(22/2), 3.11(10/1), 3.11(11/3), 3.11(13), 4.1.1(7), 4.1.2(7), 4.3(5), 4.3.1(19), 4.3.2(7), 4.3.3(22), 4.3.3(23), 4.5.2(27/3), 4.8(10/2), 5.2(7), 6.1.1(26/3), 6.1.1(34/3), 6.1.1(35/3), 6.4(10/2), 6.4.1(17), 7.6(12), 7.6(16/3), 7.6.1(9/3), 7.6.1(11.1/3), 7.6.1(20.2/3), 9.7.1(15), 9.8(4), 12.3(20), 13.11.5(7/3), K.2(164.2/3) 
Arccos    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(5) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(6) 
Arccosh    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(7) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(7) 
Arccot    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(5) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(6) 
Arccoth    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(7) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(7) 
Arcsin    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(5) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(6) Arcsinh 
   in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(7) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(7) 
Arctan    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(5) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(6) 
Arctanh    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(7) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(7) 
Argument    in Ada.Command_Line   A.15(5) 
   in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(10/2), G.3.2(31/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(10) 
argument of a pragma   2.8(9) Argument_Count    in Ada.Command_Line   A.15(4) 
Argument_Error    in Ada.Numerics   A.5(3/2) 
Arithmetic    child of  Ada.Calendar   9.6.1(8/2) 
array   3.6(1) array component expression   4.3.3(6) array component iterator   5.5.2(3/3) array for a loop   5.5.2(11/3) array indexing    See indexed_component   4.1.1(1) 
array slice   4.1.2(1) array type   3.6(1), N(4) array_aggregate   4.3.3(2)    used   4.3(2), 13.4(3), P 
array_component_association   4.3.3(5/2)    used   4.3.3(4), P 
array_type_definition   3.6(2)    used   3.2.1(4/2), 3.3.1(2/3), 12.5.3(2), P 
ASCII    package physically nested within the 
declaration of Standard   A.1(36.3/2) 
   in Standard   A.1(36.3/2) 
aspect   13.1(0.1/3), K.1(1/3), N(4.1/3)    interfacing   B.1(0.1/3)    predicate   3.2.4(1/3) aspect of representation   13.1(8/3) aspect_clause   13.1(2/1)    used   3.8(5/1), 3.11(4/1), 9.1(5/1), 
9.4(5/1), 9.4(8/1), P 
aspect_definition   13.1.1(4/3)    used   13.1.1(2/3), P 
aspect_mark   13.1.1(3/3)    used   2.8(3/3), 11.4.2(6.1/3), 
13.1.1(2/3), L(2.3/3), P 
aspect_specification   13.1.1(2/3) 
Ada Reference Manual — 2012 Edition 
871      13 December 2012 Index    used   3.2.1(3/3), 3.2.2(2/3), 3.3.1(2/3), 
3.8(6/3), 3.9.3(1.1/3), 6.1(2/3), 6.3(2/3), 6.7(2/3), 6.8(2/3), 7.1(3/3), 7.2(2/3), 7.3(2/3), 7.3(3/3), 8.5.1(2/3), 8.5.2(2/3), 8.5.3(2/3), 8.5.4(2/3), 8.5.5(2/3), 9.1(2/3), 9.1(3/3), 9.1(6/3), 9.4(2/3), 9.4(3/3), 9.4(7/3), 9.5.2(2/3), 10.1.3(3/3), 10.1.3(4), 10.1.3(5), 10.1.3(6), 11.1(2/3), 12.1(3/3), 12.3(2/3), 12.4(2/3), 12.5(2.1/3), 12.6(2.1/3), 12.6(2.2/3), 12.7(2/3), P 
aspects    Address   13.3(12)    Alignment (subtype)   13.3(26.4/2)    All_Calls_Remote   E.2.3(16/3)    Asynchronous   E.4.1(8.1/3)    Atomic   C.6(6.2/3)    Atomic_Components   C.6(6.6/3)    Attach_Handler   C.3.1(6.3/3)    Bit_Order   13.5.3(4)    Coding   13.4(7)    Component_Size   13.3(70)    Constant_Indexing   4.1.6(2/3)    Convention   B.1(2/3)    CPU   D.16(8/3)    Default_Component_Value   3.6(22.2/3)    Default_Iterator   5.5.1(8/3)    Default_Storage_Pool   13.11.3(5/3)    Default_Value   3.5(56.3/3)    Dispatching_Domain   D.16.1(18/3)    Dynamic_Predicate   3.2.4(1/3)    Elaborate_Body   10.2.1(26.1/3)    Export   B.1(1/3)    External_Name   B.1(1/3)    External_Tag   13.3(75/3), K.2(65)    Implicit_Dereference   4.1.5(2/3)    Import   B.1(1/3)    Independent   C.6(6.3/3)    Independent_Components   C.6(6.9/3)    Inline   6.3.2(5.1/3)    Input   13.13.2(38/3)    Interrupt_Handler   C.3.1(6.2/3)    Interrupt_Priority   D.1(6.3/3)    Iterator_Element   5.5.1(9/3)    Layout   13.5(1)    Link_Name   B.1(1/3)    Machine_Radix   F.1(1)    No_Return   6.5.1(3.2/3)    Output   13.13.2(38/3)    Pack   13.2(5.1/3)    Post   6.1.1(4/3)    Post'Class   6.1.1(5/3)    Pre   6.1.1(2/3)    Pre'Class   6.1.1(3/3)    Preelaborate   10.2.1(11/3)    Priority   D.1(6.2/3)    Pure   10.2.1(17/3)    Read   13.13.2(38/3)    Record layout   13.5(1)    Relative_Deadline   D.2.6(9.2/3)    Remote_Call_Interface   E.2.3(7/3) 
   Remote_Types   E.2.2(4/3)    Shared_Passive   E.2.1(4/3)    Size (object)   13.3(41)    Size (subtype)   13.3(48)    Small   3.5.10(2/1)    Static_Predicate   3.2.4(1/3)    Storage_Pool   13.11(15)    Storage_Size (access)   13.11(15)    Storage_Size (task)   13.3(65.2/3)    Stream_Size   13.13.2(1.5/2)    Synchronization   9.5(12/3)    Type_Invariant   7.3.2(2/3)    Type_Invariant'Class   7.3.2(3/3)    Unchecked_Union   B.3.3(3.2/3)    Variable_Indexing   4.1.6(3/3)    Volatile   C.6(6.4/3)    Volatile_Components   C.6(6.7/3)    Write   13.13.2(38/3) assembly language   C.1(4/3) Assert    in Ada.Assertions   11.4.2(14/2) 
Assert pragma   11.4.2(3/2), L(2.1/2) assertion   N(4.2/3) assertion expressions   11.4.2(1.1/3) assertion policy    Assert pragma   11.4.2(18/3) Assertion_Error    raised by failure of assertion   
11.4.2(18/3) 
   raised by failure of run-time check   
3.2.4(31/3), 4.6(57/3), 6.1.1(32/3), 6.1.1(33/3), 6.1.1(35/3), 7.3.2(22/3) 
   in Ada.Assertions   11.4.2(13/2) 
Assertion_Policy pragma   11.4.2(6.1/3), 
11.4.2(6/2), L(2.2/2), L(2.3/3) 
assertions   11.4.2(1.1/3)    child of  Ada   11.4.2(12/2) 
Assign    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(17.5/3) 
   in Ada.Containers.Hashed_Maps   
A.18.5(17.7/3) 
   in Ada.Containers.Hashed_Sets   
A.18.8(17.3/3) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(20/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(32/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(16.7/3) 
   in Ada.Containers.Ordered_Sets   
A.18.9(16.3/3) 
   in Ada.Containers.Vectors   
A.18.2(34.7/3) 
   See assignment operation   5.2(3) 
Assign_Task    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(11/3) assigning back of parameters   6.4.1(17) 
assignment    user-defined   7.6(1) assignment operation   5.2(3), 5.2(12), 
7.6(13) 
   during elaboration of an 
object_declaration   3.3.1(18/2) 
   during evaluation of a 
generic_association for a formal object of mode in   12.4(11) 
   during evaluation of a 
parameter_association   6.4.1(11) 
   during evaluation of an aggregate   
4.3(5) 
   during evaluation of an initialized 
allocator   4.8(7/2) 
   during evaluation of an uninitialized 
allocator   4.8(9/2) 
   during evaluation of concatenation   
4.5.3(10) 
   during execution of a for loop   5.5(9/3)    during execution of an 
assignment_statement   5.2(12) 
   during parameter copy back   6.4.1(17) assignment_statement   5.2(2)    used   5.1(4/2), P 
associated components    of a record_component_association   
4.3.1(10) 
associated declaration    of an aspect specification   13.1.1(1/3) associated discriminants    of a named discriminant_association   
3.7.1(5) 
   of a positional discriminant_association   
3.7.1(5) 
associated entity    of an aspect specification   13.1.1(5/3) associated object    of a value of a by-reference type   
6.2(10/3) 
asterisk   2.1(15/3)    in Ada.Characters.Latin_1   A.3.3(8) 
asynchronous    remote procedure call   E.4.1(9/3) Asynchronous aspect   E.4.1(8.1/3) Asynchronous pragma   J.15.13(2/3), 
L(3.1/3) 
asynchronous remote procedure call   
E.4(1) 
asynchronous_select   9.7.4(2)    used   9.7(2), P 
Asynchronous_Task_Control    child of  Ada   D.11(3/2) 
at-most-once execution   E.4(11) at_clause   J.7(1)    used   13.1(2/1), P 
atomic   C.6(7/3) Atomic aspect   C.6(6.2/3) Atomic pragma   J.15.8(2/3), L(4.1/3) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      872 Atomic_Components aspect   C.6(6.6/3) 
Atomic_Components pragma   J.15.8(5/3), 
L(5.1/3) 
Attach_Handler    in Ada.Interrupts   C.3.2(7) 
Attach_Handler aspect   C.3.1(6.3/3) Attach_Handler pragma   J.15.7(4/3), 
L(6.1/3) 
attaching    to an interrupt   C.3(2) attribute   4.1.4(1), K.2(1/3)    representation   13.3(1/1)    specifiable   13.3(5/3)    specifying   13.3(1/1) attribute_definition_clause   13.3(2)    used   13.1(2/1), P 
attribute_designator   4.1.4(3/2)    used   4.1.4(2), 13.1(3), 13.3(2), P 
Attribute_Handle    in Ada.Task_Attributes   C.7.2(3) 
attribute_reference   4.1.4(2)    used   4.1(2/3), P 
attributes    Access   3.10.2(24/1), 3.10.2(32/3)    Address   13.3(11), J.7.1(5)    Adjacent   A.5.3(48)    Aft   3.5.10(5)    Alignment   13.3(23/2), 13.3(26.2/2)    Base   3.5(15)    Bit_Order   13.5.3(4)    Body_Version   E.3(4)    Callable   9.9(2)    Caller   C.7.1(14/3)    Ceiling   A.5.3(33)    Class   3.9(14), 7.3.1(9), J.11(2/2)    Component_Size   13.3(69)    Compose   A.5.3(24)    Constrained   3.7.2(3/3), J.4(2)    Copy_Sign   A.5.3(51)    Count   9.9(5)    Definite   12.5.1(23/3)    Delta   3.5.10(3)    Denorm   A.5.3(9)    Digits   3.5.8(2/1), 3.5.10(7)    Exponent   A.5.3(18)    External_Tag   13.3(75/3)    First   3.5(12), 3.6.2(3)    First(N)   3.6.2(4)    First_Bit   13.5.2(3/2)    First_Valid   3.5.5(7.2/3)    Floor   A.5.3(30)    Fore   3.5.10(4)    Fraction   A.5.3(21)    Has_Same_Storage   13.3(73.2/3)    Identity   11.4.1(9), C.7.1(12)    Image   3.5(35)    Input   13.13.2(22), 13.13.2(32)    Last   3.5(13), 3.6.2(5)    Last(N)   3.6.2(6)    Last_Bit   13.5.2(4/2)    Last_Valid   3.5.5(7.3/3) 
   Leading_Part   A.5.3(54)    Length   3.6.2(9)    Length(N)   3.6.2(10)    Machine   A.5.3(60)    Machine_Emax   A.5.3(8)    Machine_Emin   A.5.3(7)    Machine_Mantissa   A.5.3(6)    Machine_Overflows   A.5.3(12), 
A.5.4(4) 
   Machine_Radix   A.5.3(2), A.5.4(2)    Machine_Rounding   A.5.3(41.1/2)    Machine_Rounds   A.5.3(11), A.5.4(3)    Max   3.5(19)    Max_Alignment_For_Allocation   
13.11.1(4/3) 
   Max_Size_In_Storage_Elements   
13.11.1(3/3) 
   Min   3.5(16)    Mod   3.5.4(16.1/2)    Model   A.5.3(68), G.2.2(7)    Model_Emin   A.5.3(65), G.2.2(4)    Model_Epsilon   A.5.3(66)    Model_Mantissa   A.5.3(64), G.2.2(3/2)    Model_Small   A.5.3(67)    Modulus   3.5.4(17)    Old   6.1.1(26/3)    Output   13.13.2(19), 13.13.2(29)    Overlaps_Storage   13.3(73.6/3)    Partition_Id   E.1(9)    Pos   3.5.5(2)    Position   13.5.2(2/2)    Pred   3.5(25)    Priority   D.5.2(3/2)    Range   3.5(14), 3.6.2(7)    Range(N)   3.6.2(8)    Read   13.13.2(6), 13.13.2(14)    Remainder   A.5.3(45)    Result   6.1.1(29/3)    Round   3.5.10(12)    Rounding   A.5.3(36)    Safe_First   A.5.3(71), G.2.2(5)    Safe_Last   A.5.3(72), G.2.2(6)    Scale   3.5.10(11)    Scaling   A.5.3(27)    Signed_Zeros   A.5.3(13)    Size   13.3(40), 13.3(45)    Small   3.5.10(2/1)    Storage_Pool   13.11(13)    Storage_Size   13.3(60/3), 13.11(14), 
J.9(2) 
   Stream_Size   13.13.2(1.2/3)    Succ   3.5(22)    Tag   3.9(16), 3.9(18)    Terminated   9.9(3)    Truncation   A.5.3(42)    Unbiased_Rounding   A.5.3(39)    Unchecked_Access   13.10(3), H.4(18)    Val   3.5.5(5)    Valid   13.9.2(3/3), H(6)    Value   3.5(52) 
   Version   E.3(3)    Wide_Image   3.5(28)    Wide_Value   3.5(40)    Wide_Wide_Image   3.5(27.1/2)    Wide_Wide_Value   3.5(39.1/2)    Wide_Wide_Width   3.5(37.1/2)    Wide_Width   3.5(38)    Width   3.5(39)    Write   13.13.2(3), 13.13.2(11) available    stream attribute   13.13.2(39/2)  
B 
 Backus-Naur Form (BNF)    complete listing   P    cross reference   P    notation   1.1.4(3)    under Syntax heading   1.1.2(25) Barrier_Limit subtype of  Positive 
   in Ada.Synchronous_Barriers   
D.10.1(4/3) 
base   2.4.2(3), 2.4.2(6)    used   2.4.2(2), P 
base 16 literal   2.4.2(1) base 2 literal   2.4.2(1) base 8 literal   2.4.2(1) Base attribute   3.5(15) base decimal precision    of a floating point type   3.5.7(9)    of a floating point type   3.5.7(10) base priority   D.1(15) base range    of a decimal fixed point type   3.5.9(16)    of a fixed point type   3.5.9(12)    of a floating point type   3.5.7(8), 
3.5.7(10) 
   of a modular type   3.5.4(10)    of a scalar type   3.5(6)    of a signed integer type   3.5.4(9)    of an ordinary fixed point type   
3.5.9(13) 
base subtype    of a type   3.5(15) Base_Name    in Ada.Directories   A.16(19/2) 
based_literal   2.4.2(2)    used   2.4(2), P 
based_numeral   2.4.2(4)    used   2.4.2(2), P 
basic letter    a category of Character   A.3.2(27) basic_declaration   3.1(3/3)    used   3.11(4/1), P 
basic_declarative_item   3.11(4/1)    used   3.11(3), 7.1(3/3), P 
Basic_Map    in Ada.Strings.Maps.Constants   
A.4.6(5) 
Ada Reference Manual — 2012 Edition 
873      13 December 2012 Index Basic_Set 
   in Ada.Strings.Maps.Constants   
A.4.6(4) 
become nonlimited   7.3.1(5/1), 7.5(16) BEL    in Ada.Characters.Latin_1   A.3.3(5) 
belong    to a range   3.5(4)    to a subtype   3.2(8/2) belongs    subpool to a pool   13.11.4(20/3) bibliography   1.2(1/3) big endian   13.5.3(2) binary    literal   2.4.2(1)    in Interfaces.COBOL   B.4(10) 
binary adding operator   4.5.3(1) binary literal   2.4.2(1) binary operator   4.5(9) binary_adding_operator   4.5(4)    used   4.4(4), P 
Binary_Format    in Interfaces.COBOL   B.4(24) 
bit field    See record_representation_clause   
13.5.1(1) 
bit ordering   13.5.3(2) bit string    See logical operators on boolean arrays   
4.5.1(2) 
Bit_Order    in System   13.7(15/2) 
Bit_Order aspect   13.5.3(4) Bit_Order attribute   13.5.3(4) Bit_Order clause   13.3(7/2), 13.5.3(4) blank    in text input for enumeration and 
numeric types   A.10.6(5/2) 
Blank_When_Zero    in Ada.Text_IO.Editing   F.3.3(7) 
block_statement   5.6(2)    used   5.1(5/2), P 
blocked    [partial ]   D.2.1(11/3) 
   a task state   9(10)    during an entry call   9.5.3(19)    execution of a selective_accept   
9.7.1(16) 
   on a delay_statement   9.6(21)    on an accept_statement   9.5.2(24)    waiting for activations to complete   
9.2(5) 
   waiting for dependents to terminate   
9.3(5) 
blocked interrupt   C.3(2) blocking, potentially   9.5.1(8)    Abort_Task   C.7.1(16)    delay_statement   9.6(34), D.9(5)    remote subprogram call   E.4(17)    RPC operations   E.5(23)    Suspend_Until_True   D.10(10) 
BMP   3.5.2(2/3), 3.5.2(3/3) BNF (Backus-Naur Form)    complete listing   P    cross reference   P    notation   1.1.4(3)    under Syntax heading   1.1.2(25) body   3.11(5), 3.11.1(1/3)    used   3.11(3), P 
body_stub   10.1.3(2)    used   3.11(5), P 
Body_Version attribute   E.3(4) BOM_16    in Ada.Strings.UTF_Encoding   
A.4.11(12/3) 
BOM_16BE    in Ada.Strings.UTF_Encoding   
A.4.11(10/3) 
BOM_16LE    in Ada.Strings.UTF_Encoding   
A.4.11(11/3) 
BOM_8    in Ada.Strings.UTF_Encoding   
A.4.11(9/3) 
Boolean   3.5.3(1)    in Standard   A.1(5) 
boolean type   3.5.3(1) Bounded    child of  Ada.Strings   A.4.4(3) 
bounded error   1.1.2(31), 1.1.5(8)    cause   4.8(11.1/2), 6.2(12/3), 
7.6.1(14/1), 9.4(20.1/2), 9.5.1(8), 9.8(20/3), 10.2(26), 13.9.1(9), 13.11.2(11), A.17(25/2), A.18.2(238/3), A.18.2(239/2), A.18.2(243/2), A.18.3(152.1/3), A.18.3(152.2/3), A.18.3(152/2), A.18.4(75.1/3), A.18.4(75.2/3), A.18.7(96.13/3), A.18.7(96.14/3), A.18.10(220/3), A.18.10(221/3), A.18.18(68/3), A.18.18(69/3), A.18.19(10/3), A.18.20(14/3), A.18.21(15/3), A.18.22(12/3), A.18.23(15/3), A.18.24(12/3), A.18.25(14/3), C.7.1(17/3), C.7.2(13.2/1), D.2.6(30/2), D.3(13.1/2), E.1(10/2), E.3(6), J.7.1(11) 
Bounded_IO    child of  Ada.Text_IO   A.10.11(3/2) 
   child of  Ada.Wide_Text_IO   A.11(4/3) 
   child of  Ada.Wide_Wide_Text_IO   
A.11(4/3) 
Bounded_Priority_Queues    child of  Ada.Containers   A.18.31(2/3) 
Bounded_Slice    in Ada.Strings.Bounded   A.4.4(28.1/2), 
A.4.4(28.2/2) 
Bounded_String    in Ada.Strings.Bounded   A.4.4(6) Bounded_Synchronized_Queues 
   child of  Ada.Containers   A.18.29(2/3) 
bounds    of a discrete_range   3.6.1(6)    of an array   3.6(13)    of the index range of an 
array_aggregate   4.3.3(24) 
box    compound delimiter   3.6(15) BPH    in Ada.Characters.Latin_1   A.3.3(17) 
broadcast signal    See protected object   9.4(1) 
   See requeue   9.5.4(1) 
Broken_Bar    in Ada.Characters.Latin_1   A.3.3(21/3) 
BS    in Ada.Characters.Latin_1   A.3.3(5) 
budget   D.14.2(14/2) Budget_Has_Expired    in 
Ada.Execution_Time.Group_Budgets   D.14.2(9/2) 
Budget_Remaining    in 
Ada.Execution_Time.Group_Budgets   D.14.2(9/2) 
Buffer_Size    in Ada.Storage_IO   A.9(4) 
Buffer_Type subtype of  Storage_Array 
   in Ada.Storage_IO   A.9(4) 
build-in-place    See built in place 
built in place   7.6(17.1/3) 
by copy parameter passing   6.2(2) by reference parameter passing   6.2(2) by-copy type   6.2(3/3) by-reference type   6.2(4)    atomic or volatile   C.6(18) Byte    in Interfaces.COBOL   B.4(29/3) 
   See storage element   13.3(8) 
byte sex    See ordering of storage elements in a 
word   13.5.3(5) 
Byte_Array    in Interfaces.COBOL   B.4(29/3) 
 
C 
 C    child of  Interfaces   B.3(4) 
C interface   B.3(1/3) C standard   1.2(7/3) C++ standard   1.2(9/3) C_float    in Interfaces.C   B.3(15) 
Calendar    child of  Ada   9.6(10) 
call   6(2/3) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      874    master of   3.10.2(10.1/3) 
call on a dispatching operation   3.9.2(2/3) callable   9.9(2) Callable attribute   9.9(2) callable construct   6(2/3) callable entity   6(2/3) called partition   E.4(1) Caller attribute   C.7.1(14/3) calling convention   6.3.1(2/1), B.1(11/3)    Ada   6.3.1(3/3)    associated with a designated profile   
3.10(11) 
   entry   6.3.1(13)    Intrinsic   6.3.1(4)    protected   6.3.1(12) calling partition   E.4(1) calling stub   E.4(10) CAN    in Ada.Characters.Latin_1   A.3.3(6) 
Cancel_Handler    in 
Ada.Execution_Time.Group_Budgets   D.14.2(10/2) 
   in Ada.Execution_Time.Timers   
D.14.1(7/2) 
   in Ada.Real_Time.Timing_Events   
D.15(5/2) 
cancellation    of a delay_statement   9.6(22/3)    of an entry call   9.5.3(20) cancellation of a remote subprogram call   
E.4(13) 
canonical form   A.5.3(3) canonical order of array components   
5.5.2(11/3) 
canonical semantics   11.6(2/3) canonical-form representation   A.5.3(10) capacity    of a hashed map   A.18.5(41/2)    of a hashed set   A.18.8(63/2)    of a queue   A.18.27(10/3)    of a vector   A.18.2(2/2)    in Ada.Containers.Hashed_Maps   
A.18.5(8/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(10/2) 
   in Ada.Containers.Vectors   
A.18.2(19/2) 
Capacity_Error    in Ada.Containers   A.18.1(5.1/3) 
case insensitive   2.3(5/3) case_expression   4.5.7(5/3)    used   4.5.7(2/3), P 
case_expression_alternative   4.5.7(6/3)    used   4.5.7(5/3), P 
case_statement   5.4(2/3)    used   5.1(5/2), P 
case_statement_alternative   5.4(3)    used   5.4(2/3), P cast 
   See type conversion   4.6(1/3) 
   See unchecked type conversion   13.9(1) 
catch (an exception)    See handle   11(1/3) 
categorization aspect   E.2(2/3) categorization pragma   E.2(2/3)    Remote_Call_Interface   E.2.3(2)    Remote_Types   E.2.2(2)    Shared_Passive   E.2.1(2) categorized library unit   E.2(2/3) category    of types   3.2(2/2), 3.4(1.1/2) category (of types)   N(4.3/2) category determined for a formal type   
12.5(6/3) 
catenation operator    See concatenation operator   4.4(1/3) 
   See concatenation operator   4.5.3(3) 
Cause_Of_Termination    in Ada.Task_Termination   C.7.3(3/2) 
CCH    in Ada.Characters.Latin_1   A.3.3(18) 
cease to exist    object   7.6.1(11/3), 13.11.2(10/2)    type   7.6.1(11/3) Cedilla    in Ada.Characters.Latin_1   A.3.3(22) 
Ceiling    in Ada.Containers.Ordered_Maps   
A.18.6(41/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(51/2), A.18.9(71/2) 
Ceiling attribute   A.5.3(33) ceiling priority    of a protected object   D.3(8/3) Ceiling_Check    [partial ]   C.3.1(11/3), D.3(13) 
Ceiling_Locking locking policy   D.3(7) Cent_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
change of representation   13.6(1/3) char    in Interfaces.C   B.3(19) 
char16_array    in Interfaces.C   B.3(39.5/3) 
char16_nul    in Interfaces.C   B.3(39.3/2) 
char16_t    in Interfaces.C   B.3(39.2/2) 
char32_array    in Interfaces.C   B.3(39.14/3) 
char32_nul    in Interfaces.C   B.3(39.12/2) 
char32_t    in Interfaces.C   B.3(39.11/2) 
char_array    in Interfaces.C   B.3(23/3) 
char_array_access    in Interfaces.C.Strings   B.3.1(4) CHAR_BIT 
   in Interfaces.C   B.3(6) 
Character   3.5.2(2/3)    used   2.7(2), P 
   in Standard   A.1(35/3) 
character encoding   A.4.11(46/3) character plane   2.1(1/3) character set   2.1(1/3) character set standard    16 and 32-bit   1.2(8/3)    7-bit   1.2(2)    8-bit   1.2(6/3)    control functions   1.2(5) character type   3.5.2(1), N(5) character_literal   2.5(2)    used   3.5.1(4), 4.1(2/3), 4.1.3(3), P 
Character_Mapping    in Ada.Strings.Maps   A.4.2(20/2) 
Character_Mapping_Function    in Ada.Strings.Maps   A.4.2(25) 
Character_Range    in Ada.Strings.Maps   A.4.2(6) 
Character_Ranges    in Ada.Strings.Maps   A.4.2(7) 
Character_Sequence subtype of  String 
   in Ada.Strings.Maps   A.4.2(16) 
Character_Set    in Ada.Strings.Maps   A.4.2(4/2) 
   in Ada.Strings.Wide_Maps   A.4.7(46/2) 
   in Ada.Strings.Wide_Maps.Wide_-
Constants   A.4.8(48/2) 
   in Interfaces.Fortran   B.5(11) 
Character_Set_Version    in Ada.Wide_Characters.Handling   
A.3.5(4/3) 
characteristics    [partial ]   3.4(7/3) 
Characters    child of  Ada   A.3.1(2) 
chars_ptr    in Interfaces.C.Strings   B.3.1(5/2) 
chars_ptr_array    in Interfaces.C.Strings   B.3.1(6/2) 
check    language-defined   11.5(2/3), 11.6(1/3) check, language-defined    Access_Check   4.1(13), 4.1.5(8/3), 
4.6(51/3), 4.8(10.4/3) 
   Accessibility_Check   3.10.2(29), 
4.6(39.1/2), 4.6(48/3), 4.8(10.1/3), 6.5(8/3), 6.5(21/3), 13.11.4(25/3), 13.11.4(26/3), E.4(18/1) 
   Allocation_Check   4.8(10.2/2), 
4.8(10.3/2), 4.8(10.4/3), 13.11.4(30/3) 
   Ceiling_Check   C.3.1(11/3), D.3(13)    controlled by assertion policy   
3.2.4(31/3), 4.6(51/3), 6.1.1(32/3), 6.1.1(33/3), 6.1.1(35/3), 7.3.2(9/3) 
Ada Reference Manual — 2012 Edition 
875      13 December 2012 Index    Discriminant_Check   4.1.3(15), 4.3(6), 
4.3.2(8/3), 4.6(43), 4.6(45), 4.6(51/3), 4.6(52), 4.7(4), 4.8(10/2), 6.5(5.11/3) 
   Division_Check   3.5.4(20), 4.5.5(22), 
A.5.1(28), A.5.3(47), G.1.1(40), G.1.2(28), K.2(202) 
   Elaboration_Check   3.11(9)    Index_Check   4.1.1(7), 4.1.2(7), 
4.3.3(29/3), 4.3.3(30), 4.5.3(8), 4.6(51/3), 4.7(4), 4.8(10/2) 
   Length_Check   4.5.1(8), 4.6(37), 
4.6(52) 
   Overflow_Check   3.5.4(20), 4.4(11), 
4.5.7(21/3), 5.4(13), G.2.1(11), G.2.2(7), G.2.3(25), G.2.4(2), G.2.6(3) 
   Partition_Check   E.4(19)    Range_Check   3.2.2(11), 3.5(24), 
3.5(27), 3.5(39.12/3), 3.5(39.4/3), 3.5(39.5/3), 3.5(43/3), 3.5(55/3), 3.5.5(7), 3.5.9(19), 4.2(11), 4.3.3(28), 4.5.1(8), 4.5.6(6), 4.5.6(13), 4.6(28), 4.6(38), 4.6(46), 4.6(51/3), 4.7(4), 13.13.2(35/3), A.5.2(39), A.5.3(26), A.5.3(29), A.5.3(50), A.5.3(53), A.5.3(59), A.5.3(62), K.2(11), K.2(114), K.2(122), K.2(184), K.2(220), K.2(241), K.2(41), K.2(47) 
   Reserved_Check   C.3.1(10/3)    Storage_Check   11.1(6), 13.3(67), 
13.11(17), D.7(17/1), D.7(18/1), D.7(19/1) 
   Tag_Check   3.9.2(16), 4.6(42), 4.6(52), 
5.2(10), 6.5(8.1/3) 
checking pragmas   11.5(1/2) child    of a library unit   10.1.1(1) Child_Count    in Ada.Containers.Multiway_Trees   
A.18.10(46/3) 
Child_Depth    in Ada.Containers.Multiway_Trees   
A.18.10(47/3) 
choice parameter   11.2(9) choice_expression   4.4(2.1/3)    used   3.8.1(5/3), 4.4(3.2/3), P 
choice_parameter_specification   11.2(4)    used   11.2(3), P 
choice_relation   4.4(2.2/3)    used   4.4(2.1/3), P 
Circumflex    in Ada.Characters.Latin_1   A.3.3(12) 
class    of types   3.2(2/2), 3.4(1.1/2)    See also  package   7(1) 
   See also  tag   3.9(3) 
class (of types)   N(6/2) Class attribute   3.9(14), 7.3.1(9), 
J.11(2/2) 
class factory   3.9(30/2) class-wide postcondition expression   
6.1.1(5/3) 
class-wide precondition expression   
6.1.1(3/3) 
class-wide type   3.4.1(4), 3.7(26) cleanup    See finalization   7.6.1(1) 
clear    execution timer object   D.14.1(12/2)    group budget object   D.14.2(15/2)    timing event object   D.15(9/2)    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(13/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(12/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(14/2) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(11/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(23/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(11/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(13/2) 
   in Ada.Containers.Vectors   
A.18.2(24/2) 
   in Ada.Environment_Variables   
A.17(7/2) 
cleared    termination handler   C.7.3(9/2) clock   9.6(6/3)    in Ada.Calendar   9.6(12) 
   in Ada.Execution_Time   D.14(5/2) 
   in Ada.Execution_Time.Interrupts   
D.14.3(3/3) 
   in Ada.Real_Time   D.8(6) 
clock jump   D.8(32) clock tick   D.8(23) Clock_For_Interrupts    in Ada.Execution_Time   D.14(9.3/3) 
Close    in Ada.Direct_IO   A.8.4(8) 
   in Ada.Sequential_IO   A.8.1(8) 
   in Ada.Streams.Stream_IO   A.12.1(10) 
   in Ada.Text_IO   A.10.1(11) 
close result set   G.2.3(5) closed entry   9.5.3(5)    of a protected object   9.5.3(7/3)    of a task   9.5.3(6/3) closed under derivation   3.4(28), N(6/2) closure    downward   3.10.2(37/2) COBOL    child of  Interfaces   B.4(7) 
COBOL interface   B.4(1/3) COBOL standard   1.2(4/2) COBOL_Character    in Interfaces.COBOL   B.4(13) COBOL_To_Ada 
   in Interfaces.COBOL   B.4(15) 
code point    for characters   3.5.2(2/3) code_statement   13.8(2)    used   5.1(4/2), P 
Coding aspect   13.4(7) coextension    of an object   3.10.2(14.4/3) Col    in Ada.Text_IO   A.10.1(37) 
collection    of an access type   7.6.1(11.1/3) colon   2.1(15/3)    in Ada.Characters.Latin_1   A.3.3(10) 
column number   A.10(9) comma   2.1(15/3)    in Ada.Characters.Latin_1   A.3.3(8) 
Command_Line    child of  Ada   A.15(3) 
Command_Name    in Ada.Command_Line   A.15(6) 
comment   2.7(2) comments, instructions for submission   
0.2(58/1) 
Commercial_At    in Ada.Characters.Latin_1   A.3.3(10) 
Communication_Error    in System.RPC   E.5(5) 
comparison operator    See relational operator   4.5.2(1) 
compatibility    composite_constraint with an access 
subtype   3.10(15/2) 
   constraint with a subtype   3.2.2(12)    delta_constraint with an ordinary fixed 
point subtype   J.3(9) 
   digits_constraint with a decimal fixed 
point subtype   3.5.9(18) 
   digits_constraint with a floating point 
subtype   J.3(10) 
   discriminant constraint with a subtype   
3.7.1(10) 
   index constraint with a subtype   3.6.1(7)    range with a scalar subtype   3.5(8)    range_constraint with a scalar subtype   
3.5(8) 
compatible    a type, with a convention   B.1(12) compilation   10.1.1(2)    separate   10.1(1) Compilation unit   10.1(2), 10.1.1(9), N(7) compilation units needed    by a compilation unit   10.2(2)    remote call interface   E.2.3(18)    shared passive library unit   E.2.1(11) compilation_unit   10.1.1(3)    used   10.1.1(2), P 
compile-time error   1.1.2(27), 1.1.5(4) compile-time semantics   1.1.2(28) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      876 complete context   8.6(4) 
completely defined   3.11.1(8) completion    abnormal   7.6.1(2/2)    compile-time concept   3.11.1(1/3)    normal   7.6.1(2/2)    run-time concept   7.6.1(2/2) completion and leaving (completed and 
left)   7.6.1(2/2) 
completion legality    [partial ]   3.10.1(13) 
   entry_body   9.5.2(16) Complex    in Ada.Numerics.Generic_Complex_-
Types   G.1.1(3) 
   in Interfaces.Fortran   B.5(9) 
Complex_Arrays    child of  Ada.Numerics   G.3.2(53/2) 
Complex_Elementary_Functions    child of  Ada.Numerics   G.1.2(9/1) 
Complex_IO    child of  Ada.Text_IO   G.1.3(3) 
   child of  Ada.Wide_Text_IO   G.1.4(1) 
   child of  Ada.Wide_Wide_Text_IO   
G.1.5(1/2) 
Complex_Matrix    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(4/2) 
Complex_Text_IO    child of  Ada   G.1.3(9.1/2) 
Complex_Types    child of  Ada.Numerics   G.1.1(25/1) 
Complex_Vector    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(4/2) 
component   3.2(2/2)    of a type   3.2(6/2) component subtype   3.6(10) component_choice_list   4.3.1(5)    used   4.3.1(4/2), P 
component_clause   13.5.1(3)    used   13.5.1(2), P 
component_declaration   3.8(6/3)    used   3.8(5/1), 9.4(6), P 
component_definition   3.6(7/2)    used   3.6(3), 3.6(5), 3.8(6/3), P 
component_item   3.8(5/1)    used   3.8(4), P 
component_list   3.8(4)    used   3.8(3), 3.8.1(3), P 
Component_Size aspect   13.3(70) Component_Size attribute   13.3(69) Component_Size clause   13.3(7/2), 
13.3(70) 
components    of a record type   3.8(9/2) Compose 
   in Ada.Directories   A.16(20/2) 
   in 
Ada.Directories.Hierarchical_File_Names   A.16.1(14/3) 
Compose attribute   A.5.3(24) Compose_From_Cartesian    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(9/2), G.3.2(29/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(8) 
Compose_From_Polar    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(11/2), G.3.2(32/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(11) 
composite type   3.2(2/2), N(8/2) composite_constraint   3.2.2(7)    used   3.2.2(5), P 
compound delimiter   2.2(10) compound_statement   5.1(5/2)    used   5.1(3), P 
concatenation operator   4.4(1/3), 4.5.3(3) concrete subprogram    See nonabstract subprogram   3.9.3(1/2) 
concrete type    See nonabstract type   3.9.3(1/2) 
concurrent processing    See task   9(1/3) 
condition   4.5.7(4/3)    used   4.5.7(3/3), 5.3(2), 5.5(3/3), 5.7(2), 
9.5.2(7), 9.7.1(3), P 
   See also  exception   11(1/3) 
conditional_entry_call   9.7.3(2)    used   9.7(2), P 
conditional_expression   4.5.7(2/3)    used   4.4(7/3), P 
configuration    of the partitions of a program   E(4) configuration pragma   10.1.5(8)    Assertion_Policy   11.4.2(7/3)    Detect_Blocking   H.5(4/2)    Discard_Names   C.5(4)    Locking_Policy   D.3(5)    Normalize_Scalars   H.1(4)    Partition_Elaboration_Policy   H.6(5/2)    Priority_Specific_Dispatching   
D.2.2(5/2) 
   Profile   13.12(14/3)    Queuing_Policy   D.4(5)    Restrictions   13.12(8/3)    Reviewable   H.3.1(4)    Suppress   11.5(5/2)    Task_Dispatching_Policy   D.2.2(5/2)    Unsuppress   11.5(5/2) confirming    aspect specification   13.1(18.2/3)    representation item   13.1(18.2/3)    representation value   13.1(18.2/3) conformance   6.3.1(1)    of an implementation with the Standard   
1.1.3(1) 
   See also  full conformance, mode 
conformance, subtype conformance, type conformance 
Conjugate    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(13/2), G.3.2(34/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(12), G.1.1(15) 
consistency    among compilation units   10.1.4(5) constant   3.3(13/3)    result of a function_call   6.4(12/2)    See also  literal   4.2(1) 
   See also  static   4.9(1) 
constant indexing   4.1.6(12/3) constant object   3.3(13/3) constant view   3.3(13/3) Constant_Indexing aspect   4.1.6(2/3) Constant_Reference    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(17.3/3) 
   in Ada.Containers.Hashed_Maps   
A.18.5(17.3/3), A.18.5(17.5/3) 
   in Ada.Containers.Hashed_Sets   
A.18.8(17.2/3), A.18.8(58.3/3) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(18/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(30/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(16.3/3), A.18.6(16.5/3) 
   in Ada.Containers.Ordered_Sets   
A.18.9(16.2/3), A.18.9(73.3/3) 
   in Ada.Containers.Vectors   
A.18.2(34.3/3), A.18.2(34.5/3) 
Constant_Reference_Type    in Ada.Containers.Indefinite_Holders   
A.18.18(16/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(28/3) 
Constants    child of  Ada.Strings.Maps   A.4.6(3/2) 
constituent    of a construct   1.1.4(17) constrained   3.2(9)    known to be   3.3(23.1/3)    object   3.3.1(9/2)    object   6.4.1(16)    subtype   3.2(9), 3.4(6), 3.5(7), 
3.5.1(10), 3.5.4(9), 3.5.4(10), 3.5.7(11), 3.5.9(13), 3.5.9(16), 3.6(15), 3.6(16), 3.7(26), 3.9(15) 
   subtype   3.10(14/3)    subtype   K.2(33) Constrained attribute   3.7.2(3/3), J.4(2) constrained by its initial value   3.3.1(9/2)    [partial ]   4.8(6/3), 6.5(5.11/3) 
constrained_array_definition   3.6(5) 
Ada Reference Manual — 2012 Edition 
877      13 December 2012 Index    used   3.6(2), P 
constraint   3.2.2(5)    [partial ]   3.2(7/2) 
   of a first array subtype   3.6(16)    of a subtype   3.2(8/2)    of an object   3.3.1(9/2)    used   3.2.2(3/2), P 
Constraint_Error    raised by failure of run-time check   
3.2.2(12), 3.5(24), 3.5(27), 3.5(39.12/3), 3.5(39.4/3), 3.5(39.5/3), 3.5(43/3), 3.5(55/3), 3.5.4(20), 3.5.5(7), 3.5.9(19), 3.9.2(16), 4.1(13), 4.1.1(7), 4.1.2(7), 4.1.3(15), 4.1.5(8/3), 4.2(11), 4.3(6), 4.3.2(8/3), 4.3.3(31), 4.4(11), 4.5(10), 4.5(11), 4.5(12), 4.5.1(8), 4.5.3(8), 4.5.5(22), 4.5.6(6), 4.5.6(12), 4.5.6(13), 4.5.7(21/3), 4.6(28), 4.6(57/3), 4.6(60), 4.7(4), 4.8(10.4/3), 4.8(10/2), 5.2(10), 5.4(13), 6.5(5.11/3), 6.5(8.1/3), 11.1(4), 11.4.1(14/2), 11.5(10), 13.9.1(9), 13.13.2(35/3), A.4.3(109), A.4.7(47), A.4.8(51/2), A.5.1(28), A.5.1(34), A.5.2(39), A.5.2(40.1/1), A.5.3(26), A.5.3(29), A.5.3(47), A.5.3(50), A.5.3(53), A.5.3(59), A.5.3(62), A.15(14), B.3(53), B.3(54), B.4(58), E.4(19), G.1.1(40), G.1.2(28), G.2.1(12), G.2.2(7), G.2.3(26), G.2.4(3), G.2.6(4), K.2(11), K.2(114), K.2(122), K.2(184), K.2(202), K.2(220), K.2(241), K.2(261), K.2(41), K.2(47) 
   in Standard   A.1(46) 
Construct   1.1.4(16), N(9) constructor    See initialization   3.3.1(18/2) 
   See initialization   7.6(1) 
   See initialization expression   3.3.1(4) 
   See Initialize   7.6(1) 
   See initialized allocator   4.8(4) 
container   N(9.1/3)    cursor   A.18(2/2)    list   A.18.3(1/2)    map   A.18.4(1/2)    set   A.18.7(1/2)    vector   A.18.2(1/2) container element iterator   5.5.2(3/3) Containers    child of  Ada   A.18.1(3/2) 
Containing_Directory    in Ada.Directories   A.16(17/2) 
   in 
Ada.Directories.Hierarchical_File_Names   A.16.1(11/3) Contains 
   in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(43/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(32/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(44/2), A.18.8(57/2) 
   in Ada.Containers.Multiway_Trees   
A.18.10(41/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(42/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(52/2), A.18.9(72/2) 
   in Ada.Containers.Vectors   
A.18.2(71/2) 
context free grammar    complete listing   P    cross reference   P    notation   1.1.4(3)    under Syntax heading   1.1.2(25) context_clause   10.1.2(2)    used   10.1.1(3), P 
context_item   10.1.2(3)    used   10.1.2(2), P 
contiguous representation    [partial ]   13.5.2(5), 13.7.1(12), 13.9(9), 
13.9(17/3), 13.11(21.6/3) 
Continue    in Ada.Asynchronous_Task_Control   
D.11(3/2) 
control character    a category of Character   A.3.2(22)    a category of Character   A.3.3(4), 
A.3.3(15) 
   See also  format_effector   2.1(13/3) 
Control_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
Controlled    in Ada.Finalization   7.6(5/2) 
controlled type   7.6(2), 7.6(9/2), N(10) controlling access result   3.9.2(2/3) controlling formal parameter   3.9.2(2/3) controlling operand   3.9.2(2/3) controlling result   3.9.2(2/3) controlling tag    for a call on a dispatching operation   
3.9.2(1/2) 
controlling tag value   3.9.2(14)    for the expression in an 
assignment_statement   5.2(9) 
controlling type    of a 
formal_abstract_subprogram_declaration   12.6(8.4/3) 
convention   6.3.1(2/1), B.1(11/3) Convention aspect   B.1(2/3) Convention pragma   J.15.5(4/3), L(8.1/3) conversion   4.6(1/3), 4.6(28)    access   4.6(24.11/2), 4.6(24.18/2), 
4.6(24.19/2), 4.6(47) 
   arbitrary order   1.1.4(18)    array   4.6(24.2/2), 4.6(36)    composite (non-array)   4.6(21/3), 
4.6(40) 
   enumeration   4.6(21.1/2), 4.6(34)    numeric   4.6(24.1/2), 4.6(29)    unchecked   13.9(1)    value   4.6(5/2)    view   4.6(5/2) Conversion_Error    in Interfaces.COBOL   B.4(30) 
Conversions    child of  Ada.Characters   A.3.4(2/2) 
   child of  Ada.Strings.UTF_Encoding   
A.4.11(15/3) 
Convert    in 
Ada.Strings.UTF_Encoding.Conversions   A.4.11(16/3), A.4.11(17/3), A.4.11(18/3), A.4.11(19/3), A.4.11(20/3) 
convertible   4.6(4/3)    required   4.6(24.13/2), 4.6(24.4/2), 
8.6(27.1/3) 
Copy    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(17.6/3) 
   in Ada.Containers.Hashed_Maps   
A.18.5(17.8/3) 
   in Ada.Containers.Hashed_Sets   
A.18.8(17.4/3) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(21/3), A.18.20(10/3), A.18.21(13/3), A.18.22(10/3), A.18.23(13/3), A.18.24(10/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(33/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(16.8/3) 
   in Ada.Containers.Ordered_Sets   
A.18.9(16.4/3) 
   in Ada.Containers.Vectors   
A.18.2(34.8/3) 
copy back of parameters   6.4.1(17) copy parameter passing   6.2(2) Copy_Array    in Interfaces.C.Pointers   B.3.2(15) 
Copy_File    in Ada.Directories   A.16(13/2) 
Copy_Sign attribute   A.5.3(51) Copy_Subtree    in Ada.Containers.Multiway_Trees   
A.18.10(54/3) 
Copy_Terminated_Array    in Interfaces.C.Pointers   B.3.2(14) 
Copyright_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
core language   1.1.2(2) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      878 corresponding constraint   3.4(6) 
corresponding discriminants   3.7(18) corresponding index    for an array_aggregate   4.3.3(8) corresponding subtype   3.4(18/3) corresponding value    of the target type of a conversion   
4.6(28) 
Cos    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(4) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(5) 
Cosh    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(6) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(7) 
Cot    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(4) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(5) 
Coth    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(6) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(7) 
Count    in Ada.Direct_IO   A.8.4(4) 
   in Ada.Streams.Stream_IO   A.12.1(7) 
   in Ada.Strings.Bounded   A.4.4(48), 
A.4.4(49), A.4.4(50) 
   in Ada.Strings.Fixed   A.4.3(13), 
A.4.3(14), A.4.3(15) 
   in Ada.Strings.Unbounded   A.4.5(43), 
A.4.5(44), A.4.5(45) 
   in Ada.Text_IO   A.10.1(5) 
Count attribute   9.9(5) Count_Type    in Ada.Containers   A.18.1(5/2) 
Country    in Ada.Locales   A.19(6/3) 
Country code standard   1.2(4.1/3) Country_Code    in Ada.Locales   A.19(4/3) 
Country_Unknown    in Ada.Locales   A.19(5/3) 
cover    a type   3.4.1(9)    of a choice and an exception   11.2(6) cover a value    by a discrete_choice   3.8.1(9)    by a discrete_choice_list   3.8.1(13) CPU aspect   D.16(8/3) CPU clock tick   D.14(15/2) CPU pragma   J.15.9(2/3), L(8.2/3) CPU subtype of  CPU_Range 
   in System.Multiprocessors   D.16(4/3) CPU time 
   of a task   D.14(11/3) CPU_Range    in System.Multiprocessors   D.16(4/3) 
CPU_Tick    in Ada.Execution_Time   D.14(4/2) 
CPU_Time    in Ada.Execution_Time   D.14(4/2) 
CPU_Time_First    in Ada.Execution_Time   D.14(4/2) 
CPU_Time_Last    in Ada.Execution_Time   D.14(4/2) 
CPU_Time_Unit    in Ada.Execution_Time   D.14(4/2) 
CR    in Ada.Characters.Latin_1   A.3.3(5) 
create   3.1(12)    in Ada.Direct_IO   A.8.4(6) 
   in Ada.Sequential_IO   A.8.1(6) 
   in Ada.Streams.Stream_IO   A.12.1(8) 
   in Ada.Text_IO   A.10.1(9) 
   in 
System.Multiprocessors.Dispatching_Domains   D.16.1(7/3) 
Create_Directory    in Ada.Directories   A.16(7/2) 
Create_Path    in Ada.Directories   A.16(9/2) 
Create_Subpool    in System.Storage_Pools.Subpools   
13.11.4(7/3) 
creation    of a protected object   C.3.1(10/3)    of a return object   6.5(5.11/3)    of a tag   13.14(20/2)    of a task object   D.1(17/3)    of an object   3.3(1) critical section    See intertask communication   9.5(1) 
CSI    in Ada.Characters.Latin_1   A.3.3(19) 
Currency_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
current column number   A.10(9) current index    of an open direct file   A.8(4)    of an open stream file   A.12.1(1.1/1) current instance    of a generic unit   8.6(18)    of a type   8.6(17/3) current line number   A.10(9) current mode    of an open file   A.7(7) current page number   A.10(9) Current size    of a stream file   A.12.1(1.1/1)    of an external file   A.8(3) Current_Directory    in Ada.Directories   A.16(5/2) Current_Error 
   in Ada.Text_IO   A.10.1(17), A.10.1(20) 
Current_Handler    in 
Ada.Execution_Time.Group_Budgets   D.14.2(10/2) 
   in Ada.Execution_Time.Timers   
D.14.1(7/2) 
   in Ada.Interrupts   C.3.2(6) 
   in Ada.Real_Time.Timing_Events   
D.15(5/2) 
Current_Input    in Ada.Text_IO   A.10.1(17), A.10.1(20) 
Current_Output    in Ada.Text_IO   A.10.1(17), A.10.1(20) 
Current_State    in Ada.Synchronous_Task_Control   
D.10(4) 
Current_Task    in Ada.Task_Identification   C.7.1(3/3) 
Current_Task_Fallback_Handler    in Ada.Task_Termination   C.7.3(5/2) 
Current_Use    in 
Ada.Containers.Bounded_Priority_Queues   A.18.31(7/3) 
   in 
Ada.Containers.Bounded_Synchronized_Queues   A.18.29(6/3) 
   in 
Ada.Containers.Synchronized_Queue_Interfaces   A.18.27(7/3) 
   in 
Ada.Containers.Unbounded_Priority_Queues   A.18.30(7/3) 
   in 
Ada.Containers.Unbounded_Synchronized_Queues   A.18.28(6/3) 
cursor    ambiguous   A.18.2(240/2)    for a container   A.18(2/2)    invalid   A.18.2(248/2), A.18.3(153/2), 
A.18.4(76/2), A.18.7(97/2), A.18.10(222/3) 
   in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(7/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(4/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(4/2) 
   in Ada.Containers.Multiway_Trees   
A.18.10(9/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(5/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(5/2) 
   in Ada.Containers.Vectors   A.18.2(9/2) 
 
D 
 
Ada Reference Manual — 2012 Edition 
879      13 December 2012 Index dangling references 
   prevention via accessibility rules   
3.10.2(3/2) 
Data_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Storage_IO   A.9(9) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
date and time formatting standard   
1.2(5.1/2) 
Day    in Ada.Calendar   9.6(13) 
   in Ada.Calendar.Formatting   
9.6.1(23/2) 
Day_Count    in Ada.Calendar.Arithmetic   9.6.1(10/2) 
Day_Duration subtype of  Duration 
   in Ada.Calendar   9.6(11/2) 
Day_Name    in Ada.Calendar.Formatting   
9.6.1(17/2) 
Day_Number subtype of  Integer 
   in Ada.Calendar   9.6(11/2) 
Day_of_Week    in Ada.Calendar.Formatting   
9.6.1(18/2) 
DC1    in Ada.Characters.Latin_1   A.3.3(6) 
DC2    in Ada.Characters.Latin_1   A.3.3(6) 
DC3    in Ada.Characters.Latin_1   A.3.3(6) 
DC4    in Ada.Characters.Latin_1   A.3.3(6) 
DCS    in Ada.Characters.Latin_1   A.3.3(18) 
Deadline subtype of  Time 
   in Ada.Dispatching.EDF   D.2.6(9/2) 
Deallocate    in System.Storage_Pools   13.11(8) 
   in System.Storage_Pools.Subpools   
13.11.4(15/3) 
Deallocate_Subpool    in System.Storage_Pools.Subpools   
13.11.4(12/3) 
deallocation of storage   13.11.2(1) Decimal    child of  Ada   F.2(2) 
decimal digit    a category of Character   A.3.2(28) decimal fixed point type   3.5.9(1), 
3.5.9(6) 
Decimal_Conversions    in Interfaces.COBOL   B.4(31) 
Decimal_Digit_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) Decimal_Element 
   in Interfaces.COBOL   B.4(12/3) 
decimal_fixed_point_definition   3.5.9(4)    used   3.5.9(2), P 
Decimal_IO    in Ada.Text_IO   A.10.1(73) 
decimal_literal   2.4.1(2)    used   2.4(2), P 
Decimal_Output    in Ada.Text_IO.Editing   F.3.3(11) 
Declaration   3.1(5), 3.1(6/3), N(11) declaration list    declarative_part   3.11(6.1/2)    package_specification   7.1(6/2) declarative region    of a construct   8.1(1) declarative_item   3.11(3)    used   3.11(2), P 
declarative_part   3.11(2)    used   5.6(2), 6.3(2/3), 7.2(2/3), 9.1(6/3), 
9.5.2(5), P 
declare   3.1(8), 3.1(12) declared pure   10.2.1(17/3) Decode    in Ada.Strings.UTF_Encoding.Strings   
A.4.11(26/3), A.4.11(27/3), A.4.11(28/3) 
   in 
Ada.Strings.UTF_Encoding.Wide_Strings   A.4.11(34/3), A.4.11(35/3), A.4.11(36/3) 
   in 
Ada.Strings.UTF_Encoding.Wide_Wide_Strings   A.4.11(42/3), A.4.11(43/3), A.4.11(44/3) 
Decrement    in Interfaces.C.Pointers   B.3.2(11/3) 
deeper    accessibility leve l   3.10.2(3/2) 
   statically   3.10.2(4), 3.10.2(17) default constant indexing function   
5.5.1(16/3) 
default cursor subtype   5.5.1(8/3) default directory   A.16(48/2) default element subtype   5.5.1(9/3) default entry queuing policy   9.5.3(17) default iterator function   5.5.1(8/3) default iterator subtype   5.5.1(8/3) default pool   13.11.3(4.1/3) default treatment   C.3(5) default variable indexing function   
5.5.1(21/3) 
Default_Aft    in Ada.Text_IO   A.10.1(64), 
A.10.1(69), A.10.1(74) 
   in Ada.Text_IO.Complex_IO   G.1.3(5) 
Default_Base    in Ada.Text_IO   A.10.1(53), A.10.1(58) 
Default_Bit_Order    in System   13.7(15/2) Default_Component_Value aspect   
3.6(22.2/3) 
Default_Currency    in Ada.Text_IO.Editing   F.3.3(10) 
Default_Deadline    in Ada.Dispatching.EDF   D.2.6(9/2) 
Default_Exp    in Ada.Text_IO   A.10.1(64), 
A.10.1(69), A.10.1(74) 
   in Ada.Text_IO.Complex_IO   G.1.3(5) 
default_expression   3.7(6)    used   3.7(5/2), 3.8(6/3), 6.1(15/3), 
12.4(2/3), P 
Default_Fill    in Ada.Text_IO.Editing   F.3.3(10) 
Default_Fore    in Ada.Text_IO   A.10.1(64), 
A.10.1(69), A.10.1(74) 
   in Ada.Text_IO.Complex_IO   G.1.3(5) 
Default_Iterator aspect   5.5.1(8/3) Default_Modulus    in Ada.Containers.Indefinite_Holders   
A.18.21(10/3), A.18.23(10/3) 
default_name   12.6(4)    used   12.6(3/2), P 
Default_Priority    in System   13.7(17) 
Default_Quantum    in Ada.Dispatching.Round_Robin   
D.2.5(4/2) 
Default_Radix_Mark    in Ada.Text_IO.Editing   F.3.3(10) 
Default_Separator    in Ada.Text_IO.Editing   F.3.3(10) 
Default_Setting    in Ada.Text_IO   A.10.1(80) 
Default_Storage_Pool aspect   
13.11.3(5/3) 
Default_Storage_Pool pragma   
13.11.3(3/3), L(8.3/3) 
Default_Subpool_for_Pool    in System.Storage_Pools.Subpools   
13.11.4(13/3) 
Default_Value aspect   3.5(56.3/3) Default_Width    in Ada.Text_IO   A.10.1(53), 
A.10.1(58), A.10.1(80) 
deferred constant   7.4(2/3) deferred constant declaration   3.3.1(6/3), 
7.4(2/3) 
defining name   3.1(10) defining_character_literal   3.5.1(4)    used   3.5.1(3), P 
defining_designator   6.1(6)    used   6.1(4.2/2), 12.3(2/3), P 
defining_identifier   3.1(4) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      880    used   3.2.1(3/3), 3.2.2(2/3), 3.3.1(3), 
3.5.1(3), 3.10.1(2/2), 5.5(4), 5.5.2(2/3), 6.1(7), 6.5(2.1/3), 7.3(2/3), 7.3(3/3), 8.5.1(2/3), 8.5.2(2/3), 9.1(2/3), 9.1(3/3), 9.1(6/3), 9.4(2/3), 9.4(3/3), 9.4(7/3), 9.5.2(2/3), 9.5.2(5), 9.5.2(8), 10.1.3(4), 10.1.3(5), 10.1.3(6), 11.2(4), 12.5(2.1/3), 12.5(2.2/3), 12.7(2/3), P 
defining_identifier_list   3.3.1(3)    used   3.3.1(2/3), 3.3.2(2), 3.7(5/2), 
3.8(6/3), 6.1(15/3), 11.1(2/3), 12.4(2/3), P 
defining_operator_symbol   6.1(11)    used   6.1(6), P 
defining_program_unit_name   6.1(7)    used   6.1(4.1/2), 6.1(6), 7.1(3/3), 
7.2(2/3), 8.5.3(2/3), 8.5.5(2/3), 12.3(2/3), P 
Definite attribute   12.5.1(23/3) definite subtype   3.3(23/3) definition   3.1(7) Degree_Sign    in Ada.Characters.Latin_1   A.3.3(22) 
DEL    in Ada.Characters.Latin_1   A.3.3(14) 
delay_alternative   9.7.1(6)    used   9.7.1(4), 9.7.2(2), P 
delay_relative_statement   9.6(4)    used   9.6(2), P 
delay_statement   9.6(2)    used   5.1(4/2), 9.7.1(6), 9.7.4(4/2), P 
Delay_Until_And_Set_CPU    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(14/3) 
Delay_Until_And_Set_Deadline    in Ada.Dispatching.EDF   D.2.6(9/2) 
delay_until_statement   9.6(3)    used   9.6(2), P 
Delete    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(24/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(25/2), A.18.5(26/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(24/2), A.18.8(25/2), A.18.8(55/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(24/2), A.18.6(25/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(23/2), A.18.9(24/2), A.18.9(68/2) 
   in Ada.Containers.Vectors   
A.18.2(50/2), A.18.2(51/2) 
   in Ada.Direct_IO   A.8.4(8) 
   in Ada.Sequential_IO   A.8.1(8) 
   in Ada.Streams.Stream_IO   A.12.1(10) 
   in Ada.Strings.Bounded   A.4.4(64), 
A.4.4(65)    in Ada.Strings.Fixed   A.4.3(29), 
A.4.3(30) 
   in Ada.Strings.Unbounded   A.4.5(59), 
A.4.5(60) 
   in Ada.Text_IO   A.10.1(11) 
Delete_Children    in Ada.Containers.Multiway_Trees   
A.18.10(53/3) 
Delete_Directory    in Ada.Directories   A.16(8/2) 
Delete_File    in Ada.Directories   A.16(11/2) 
Delete_First    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(25/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(26/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(25/2) 
   in Ada.Containers.Vectors   
A.18.2(52/2) 
Delete_Last    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(26/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(27/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(26/2) 
   in Ada.Containers.Vectors   
A.18.2(53/2) 
Delete_Leaf    in Ada.Containers.Multiway_Trees   
A.18.10(35/3) 
Delete_Subtree    in Ada.Containers.Multiway_Trees   
A.18.10(36/3) 
Delete_Tree    in Ada.Directories   A.16(10/2) 
delimiter   2.2(8/2) delivery    of an interrupt   C.3(2) delta    of a fixed point type   3.5.9(1) Delta attribute   3.5.10(3) delta_constraint   J.3(2)    used   3.2.2(6), P 
Denorm attribute   A.5.3(9) denormalized number   A.5.3(10) denote   8.6(16)    informal definition   3.1(8)    name used as a pragma argument   
8.6(32) 
depend on a discriminant    for a component   3.7(20)    for a constraint or 
component_definition   3.7(19) 
dependence    elaboration   10.2(9)    of a task on a master   9.3(1)    of a task on another task   9.3(4)    semantic   10.1.1(26/2) 
depth    accessibility leve l   3.10.2(3/2) 
   in Ada.Containers.Multiway_Trees   
A.18.10(19/3) 
depth-first order   A.18.10(5/3) Dequeue    in 
Ada.Containers.Bounded_Priority_Queues   A.18.31(5/3) 
   in 
Ada.Containers.Bounded_Synchronized_Queues   A.18.29(5/3) 
   in 
Ada.Containers.Synchronized_Queue_Interfaces   A.18.27(6/3) 
   in 
Ada.Containers.Unbounded_Priority_Queues   A.18.30(5/3) 
   in 
Ada.Containers.Unbounded_Synchronized_Queues   A.18.28(5/3) 
Dequeue_Only_High_Priority    in 
Ada.Containers.Bounded_Priority_Queues   A.18.31(6/3) 
   in 
Ada.Containers.Unbounded_Priority_Queues   A.18.30(6/3) 
dereference   4.1(8) Dereference_Error    in Interfaces.C.Strings   B.3.1(12) 
derivation class    for a type   3.4.1(2/2) derived from    directly or indirectly   3.4.1(2/2) derived type   3.4(1/2), N(13/2)    [partial ]   3.4(24) 
derived_type_definition   3.4(2/2)    used   3.2.1(4/2), P 
descendant   10.1.1(11), N(13.1/2)    at run-time   3.9(12.3/3)    of a tree node   A.18.10(4/3)    of a type   3.4.1(10/2)    of an incomplete view   7.3.1(5.2/3)    of the full view of a type   7.3.1(5.1/3)    relationship with scope   8.2(4) Descendant_Tag    in Ada.Tags   3.9(7.1/2) 
designate   3.10(1) designated profile    of an access-to-subprogram type   
3.10(11) 
   of an anonymous access type   
3.10(12/3) 
designated subtype    of a named access type   3.10(10)    of an anonymous access type   
3.10(12/3) 
Ada Reference Manual — 2012 Edition 
881      13 December 2012 Index designated type 
   of a named access type   3.10(10)    of an anonymous access type   
3.10(12/3) 
designator   6.1(5)    used   6.3(2/3), P 
destructor    See finalization   7.6(1) 
   See finalization   7.6.1(1) 
Detach_Handler    in Ada.Interrupts   C.3.2(9) 
Detect_Blocking pragma   H.5(3/2), 
L(8.4/2) 
Determinant    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(46/2) 
   in Ada.Numerics.Generic_Real_Arrays   
G.3.1(24/2) 
determined category for a formal type   
12.5(6/3) 
determines    a type by a subtype_mark   3.2.2(8) Device_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.Directories   A.16(43/2) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
Diaeresis    in Ada.Characters.Latin_1   A.3.3(21/3) 
Difference    in Ada.Calendar.Arithmetic   9.6.1(12/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(32/2), A.18.8(33/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(33/2), A.18.9(34/2) 
digit   2.4.1(4.1/2)    used   2.4.1(3), 2.4.2(5), P 
digits    of a decimal fixed point subtype   
3.5.9(6), 3.5.10(7) 
Digits attribute   3.5.8(2/1), 3.5.10(7) digits_constraint   3.5.9(5)    used   3.2.2(6), P 
dimensionality    of an array   3.6(12) direct access   A.8(3) direct file   A.8(1/2) Direct_IO    child of  Ada   A.8.4(2) 
direct_name   4.1(3)    used   3.8.1(2), 4.1(2/3), 5.1(8), 9.5.2(3), 
10.2.1(4.2/2), 13.1(3), J.7(1), L(25.2/2), P 
Direction    in Ada.Strings   A.4.1(6) directly specified 
   of a representation aspect of an entity   
13.1(8/3) 
   of an operational aspect of an entity   
13.1(8.1/3) 
directly visible   8.3(2), 8.3(21)    within a pragma in a context_clause   
10.1.6(3) 
   within a pragma that appears at the place 
of a compilation unit   10.1.6(5) 
   within a use_clause in a context_clause   
10.1.6(3) 
   within a with_clause   10.1.6(2/2)    within the parent_unit_name of a library 
unit   10.1.6(2/2) 
   within the parent_unit_name of a 
subunit   10.1.6(4) 
Directories    child of  Ada   A.16(3/2) 
directory   A.16(45/2) directory entry   A.16(49/2) directory name   A.16(46/2) Directory_Entry_Type    in Ada.Directories   A.16(29/2) 
disabled    predicate checks   3.2.4(7/3) Discard_Names pragma   C.5(3), L(9) discontiguous representation    [partial ]   13.5.2(5), 13.7.1(12), 13.9(9), 
13.9(17/3), 13.11(21.6/3) 
discrete array type   4.5.2(1) discrete type   3.2(3), 3.5(1), N(14) discrete_choice   3.8.1(5/3)    used   3.8.1(4), P 
discrete_choice_list   3.8.1(4)    used   3.8.1(3), 4.3.3(5/2), 4.5.7(6/3), 
5.4(3), P 
Discrete_Random    child of  Ada.Numerics   A.5.2(17) 
discrete_range   3.6.1(3)    used   3.6.1(2), 4.1.2(2), P 
discrete_subtype_definition   3.6(6)    used   3.6(5), 5.5(4), 9.5.2(2/3), 9.5.2(8), 
P 
discriminant   3.2(5/2), 3.7(1/2), N(15/2)    of a variant_part   3.8.1(6)    use in a record definition   3.8(12/3) discriminant_association   3.7.1(3)    used   3.7.1(2), P 
Discriminant_Check   11.5(12)    [partial ]   4.1.3(15), 4.3(6), 4.3.2(8/3), 
4.6(43), 4.6(45), 4.6(51/3), 4.6(52), 4.7(4), 4.8(10/2), 6.5(5.11/3) 
discriminant_constraint   3.7.1(2)    used   3.2.2(7), P 
discriminant_part   3.7(2/2)    used   3.10.1(2/2), 7.3(2/3), 7.3(3/3), 
12.5(2.1/3), 12.5(2.2/3), P 
discriminant_specification   3.7(5/2)    used   3.7(4), P discriminants 
   known   3.7(26)    unknown   3.7(26) discriminated type   3.7(8/2) dispatching   3.9(3)    child of  Ada   D.2.1(1.2/3) 
dispatching call    on a dispatching operation   3.9.2(1/2) dispatching operation   3.9.2(1/2), 
3.9.2(2/3) 
   [partial ]   3.9(1) 
dispatching point   D.2.1(4/2)    [partial ]   D.2.3(8/2), D.2.4(9/3) 
dispatching policy for tasks    [partial ]   D.2.1(5/2) 
dispatching, task   D.2.1(4/2) Dispatching_Domain    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(5/3) 
Dispatching_Domain aspect   
D.16.1(18/3) 
Dispatching_Domain pragma   
J.15.10(2/3), L(9.1/3) 
Dispatching_Domain_Error    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(4/3) 
Dispatching_Domains    child of  System.Multiprocessors   
D.16.1(3/3) 
Dispatching_Policy_Error    in Ada.Dispatching   D.2.1(1.4/3) 
Display_Format    in Interfaces.COBOL   B.4(22) 
displayed magnitude (of a decimal value)   
F.3.2(14) 
disruption of an assignment   9.8(21), 
13.9.1(5) 
   [partial ]   11.6(6/3) 
distinct access paths   6.2(12/3) distributed accessibility   3.10.2(32.1/3) distributed program   E(3) distributed system   E(2) distributed systems   C(1) divide   2.1(15/3)    in Ada.Decimal   F.2(6/3) 
divide operator   4.4(1/3), 4.5.5(1) Division_Check   11.5(13/2)    [partial ]   3.5.4(20), 4.5.5(22), 
A.5.1(28), A.5.3(47), G.1.1(40), G.1.2(28), K.2(202) 
Division_Sign    in Ada.Characters.Latin_1   A.3.3(26) 
DLE    in Ada.Characters.Latin_1   A.3.3(6) 
Do_APC    in System.RPC   E.5(10) 
Do_RPC    in System.RPC   E.5(9) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      882 documentation (required of an 
implementation)   1.1.3(18), M.1(1/2), M.2(1/2), M.3(1/2) 
documentation requirements   1.1.2(34), 
M(1/3) 
   summary of requirements   M.1(1/2) Dollar_Sign    in Ada.Characters.Latin_1   A.3.3(8) 
dot   2.1(15/3) dot selection    See selected_component   4.1.3(1) 
double    in Interfaces.C   B.3(16) 
Double_Precision    in Interfaces.Fortran   B.5(6) 
Doubly_Linked_Lists    child of  Ada.Containers   A.18.3(5/3) 
downward closure   3.10.2(37/2) drift rate   D.8(41) Duration    in Standard   A.1(43) 
dynamic binding    See dispatching operation   3.9(1) 
dynamic semantics   1.1.2(30) Dynamic_Predicate aspect   3.2.4(1/3) Dynamic_Priorities    child of  Ada   D.5.1(3/2) 
dynamically determined tag   3.9.2(1/2) dynamically enclosing    of one execution by another   11.4(2) dynamically tagged   3.9.2(5/2)  
E 
 e    in Ada.Numerics   A.5(3/2) 
EDF    child of  Ada.Dispatching   D.2.6(9/2) 
   child of  
Ada.Synchronous_Task_Control   D.10(5.2/3) 
EDF_Across_Priorities task dispatching 
policy   D.2.6(7/2) 
edited output   F.3(1/2) Editing    child of  Ada.Text_IO   F.3.3(3) 
   child of  Ada.Wide_Text_IO   F.3.4(1) 
   child of  Ada.Wide_Wide_Text_IO   
F.3.5(1/2) 
effect    external   1.1.3(8) efficiency   11.5(29), 11.6(1/3) Eigensystem    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(49/2) 
   in Ada.Numerics.Generic_Real_Arrays   
G.3.1(27/2) Eigenvalues 
   in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(48/2) 
   in Ada.Numerics.Generic_Real_Arrays   
G.3.1(26/2) 
Elaborate pragma   10.2.1(20), L(10) Elaborate_All pragma   10.2.1(21), L(11) Elaborate_Body aspect   10.2.1(26.1/3) Elaborate_Body pragma   10.2.1(22), 
L(12) 
elaborated   3.11(8) elaboration   3.1(11), N(15.1/2), N(19)    abstract_subprogram_declaration   
3.9.3(11.1/2) 
   access_definition   3.10(17/2)    access_type_definition   3.10(16)    array_type_definition   3.6(21)    aspect_clause   13.1(19/1)    choice_parameter_specification   11.4(7)    component_declaration   3.8(17)    component_definition   3.6(22/2), 
3.8(18/2) 
   component_list   3.8(17)    declaration with a True Import aspect   
B.1(38/3) 
   declarative_part   3.11(7)    deferred constant declaration   7.4(10/3)    delta_constraint   J.3(11)    derived_type_definition   3.4(26)    digits_constraint   3.5.9(19)    discrete_subtype_definition   3.6(22/2)    discriminant_constraint   3.7.1(12)    entry_declaration   9.5.2(22/1)    enumeration_type_definition   3.5.1(10)    exception_declaration   11.1(5)    expression_function_declaration   
6.8(8/3) 
   fixed_point_definition   3.5.9(17)    floating_point_definition   3.5.7(13)    full type definition   3.2.1(11)    full_type_declaration   3.2.1(11)    generic body   12.2(2)    generic_declaration   12.1(10)    generic_instantiation   12.3(20)    incomplete_type_declaration   
3.10.1(12) 
   index_constraint   3.6.1(8)    integer_type_definition   3.5.4(18)    loop_parameter_specification   5.5(9/3)    nongeneric package_body   7.2(6)    nongeneric subprogram_body   6.3(6)    null_procedure_declaration   6.7(5/3)    number_declaration   3.3.2(7)    object_declaration   3.3.1(15)    of library units for a foreign language 
main subprogram   B.1(39/3) 
   package_body of Standard   A.1(50)    package_declaration   7.1(8)    partition   E.1(6)    partition   E.5(21)    per-object constraint   3.8(18.1/1) 
   pragma   2.8(12)    private_extension_declaration   7.3(17)    private_type_declaration   7.3(17)    protected declaration   9.4(12)    protected_body   9.4(15)    protected_definition   9.4(13)    range_constraint   3.5(9)    real_type_definition   3.5.6(5)    record_definition   3.8(16)    record_extension_part   3.9.1(5)    record_type_definition   3.8(16)    renaming_declaration   8.5(3)    single_protected_declaration   9.4(12)    single_task_declaration   9.1(10)    subprogram_declaration   6.1(31/2)    subtype_declaration   3.2.2(9)    subtype_indication   3.2.2(9)    task declaration   9.1(10)    task_body   9.1(13)    task_definition   9.1(11)    use_clause   8.4(12)    variant_part   3.8.1(22) elaboration control   10.2.1(1) elaboration dependence    library_item on another   10.2(9) Elaboration_Check   11.5(20)    [partial ]   3.11(9) 
element    of a storage pool   13.11(11)    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(14/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(14/2), A.18.5(31/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(15/2), A.18.8(52/2) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(12/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(24/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(13/2), A.18.6(39/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(14/2), A.18.9(65/2) 
   in Ada.Containers.Vectors   
A.18.2(27/2), A.18.2(28/2) 
   in Ada.Strings.Bounded   A.4.4(26) 
   in Ada.Strings.Unbounded   A.4.5(20) 
elementary type   3.2(2/2), N(16) Elementary_Functions    child of  Ada.Numerics   A.5.1(9/1) 
eligible    a type, for a convention   B.1(14/3) else part    of a selective_accept   9.7.1(11) EM    in Ada.Characters.Latin_1   A.3.3(6) 
embedded systems   C(1), D(1) empty element    of a vector   A.18.2(4/2) 
Ada Reference Manual — 2012 Edition 
883      13 December 2012 Index empty holder   A.18.18(3/3) 
Empty_Holder    in Ada.Containers.Indefinite_Holders   
A.18.18(7/3) 
Empty_List    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(8/2) 
Empty_Map    in Ada.Containers.Hashed_Maps   
A.18.5(5/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(6/2) 
Empty_Set    in Ada.Containers.Hashed_Sets   
A.18.8(5/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(6/2) 
Empty_Tree    in Ada.Containers.Multiway_Trees   
A.18.10(10/3) 
Empty_Vector    in Ada.Containers.Vectors   
A.18.2(10/2) 
enabled    invariant expression   7.3.2(21/3)    postcondition expression   6.1.1(19/3)    precondition expression   6.1.1(19/3)    predicate checks   3.2.4(7/3) encapsulation    See package   7(1) 
enclosing    immediately   8.1(13) Encode    in Ada.Strings.UTF_Encoding.Strings   
A.4.11(23/3), A.4.11(24/3), A.4.11(25/3) 
   in 
Ada.Strings.UTF_Encoding.Wide_Strings   A.4.11(31/3), A.4.11(32/3), A.4.11(33/3) 
   in 
Ada.Strings.UTF_Encoding.Wide_Wide_Strings   A.4.11(39/3), A.4.11(40/3), A.4.11(41/3) 
Encoding    in Ada.Strings.UTF_Encoding   
A.4.11(13/3) 
encoding scheme   A.4.11(46/3) Encoding_Error    in Ada.Strings.UTF_Encoding   
A.4.11(8/3) 
Encoding_Scheme    in Ada.Strings.UTF_Encoding   
A.4.11(4/3) 
end of a line   2.2(2/3) End_Error    raised by failure of run-time check   
13.13.2(37/1) 
   in Ada.Direct_IO   A.8.4(18) 
   in Ada.IO_Exceptions   A.13(4)    in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
End_Of_File    in Ada.Direct_IO   A.8.4(16) 
   in Ada.Sequential_IO   A.8.1(13) 
   in Ada.Streams.Stream_IO   A.12.1(12) 
   in Ada.Text_IO   A.10.1(34) 
End_Of_Line    in Ada.Text_IO   A.10.1(30) 
End_Of_Page    in Ada.Text_IO   A.10.1(33) 
End_Search    in Ada.Directories   A.16(33/2) 
endian    big   13.5.3(2)    little   13.5.3(2) ENQ    in Ada.Characters.Latin_1   A.3.3(5) 
Enqueue    in 
Ada.Containers.Bounded_Priority_Queues   A.18.31(5/3) 
   in 
Ada.Containers.Bounded_Synchronized_Queues   A.18.29(5/3) 
   in 
Ada.Containers.Synchronized_Queue_Interfaces   A.18.27(5/3) 
   in 
Ada.Containers.Unbounded_Priority_Queues   A.18.30(5/3) 
   in 
Ada.Containers.Unbounded_Synchronized_Queues   A.18.28(5/3) 
entity    [partial ]   3.1(1) 
entry    closed   9.5.3(5)    open   9.5.3(5)    single   9.5.2(20) entry call   9.5.3(1)    simple   9.5.3(1) entry calling convention   6.3.1(13) entry family   9.5.2(20) entry index subtype   3.8(18/2), 9.5.2(20) entry queue   9.5.3(12) entry queuing policy   9.5.3(17)    default policy   9.5.3(17) entry_barrier   9.5.2(7)    used   9.5.2(5), P 
entry_body   9.5.2(5)    used   9.4(8/1), P 
entry_body_formal_part   9.5.2(6)    used   9.5.2(5), P 
entry_call_alternative   9.7.2(3/2)    used   9.7.2(2), 9.7.3(2), P 
entry_call_statement   9.5.3(2)    used   5.1(4/2), 9.7.2(3.1/2), P 
entry_declaration   9.5.2(2/3)    used   9.1(5/1), 9.4(5/1), P 
entry_index   9.5.2(4)    used   9.5.2(3), P 
entry_index_specification   9.5.2(8)    used   9.5.2(6), P 
enumeration literal   3.5.1(6/3) enumeration type   3.2(3), 3.5.1(1), N(17) enumeration_aggregate   13.4(3)    used   13.4(2), P 
Enumeration_IO    in Ada.Text_IO   A.10.1(79) 
enumeration_literal_specification   
3.5.1(3) 
   used   3.5.1(2), P 
enumeration_representation_clause   
13.4(2) 
   used   13.1(2/1), P 
enumeration_type_definition   3.5.1(2)    used   3.2.1(4/2), P 
environment   10.1.4(1) environment declarative_part   10.1.4(1)    for the environment task of a partition   
10.2(13) 
environment task   10.2(8) environment variable   A.17(1/2) Environment_Task    in Ada.Task_Identification   C.7.1(3/3) 
Environment_Variables    child of  Ada   A.17(3/2) 
EOT    in Ada.Characters.Latin_1   A.3.3(5) 
EPA    in Ada.Characters.Latin_1   A.3.3(18) 
epoch   D.8(19) equal operator   4.4(1/3), 4.5.2(1) Equal_Case_Insensitive    child of  Ada.Strings   A.4.10(2/3) 
   child of  Ada.Strings.Bounded   
A.4.10(7/3) 
   child of  Ada.Strings.Fixed   A.4.10(5/3) 
   child of  Ada.Strings.Unbounded   
A.4.10(10/3) 
Equal_Subtree    in Ada.Containers.Multiway_Trees   
A.18.10(14/3) 
equality operator   4.5.2(1)    special inheritance rule for tagged 
types   3.4(17/2), 4.5.2(14/3) 
equals sign   2.1(15/3) Equals_Sign    in Ada.Characters.Latin_1   A.3.3(10) 
equivalent element    of a hashed set   A.18.8(64/2)    of an ordered set   A.18.9(78/2) equivalent key    of a hashed map   A.18.5(42/2)    of an ordered map   A.18.6(55/2) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      884 Equivalent_Elements 
   in Ada.Containers.Hashed_Sets   
A.18.8(46/2), A.18.8(47/2), A.18.8(48/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(3/2) 
Equivalent_Keys    in Ada.Containers.Hashed_Maps   
A.18.5(34/2), A.18.5(35/2), A.18.5(36/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(3/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(63/2) 
Equivalent_Sets    in Ada.Containers.Hashed_Sets   
A.18.8(8/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(9/2) 
erroneous execution   1.1.2(32), 1.1.5(10)    cause   3.7.2(4), 3.9(25.3/2), 6.4.1(18/3), 
9.8(21), 9.10(11), 11.5(26), 13.3(13/3), 13.3(27), 13.3(28/2), 13.9.1(8), 13.9.1(12/3), 13.9.1(13/3), 13.11(21), 13.11.2(16/3), 13.13.2(53/2), A.10.3(22/1), A.12.1(36.1/1), A.13(17), A.17(28/2), A.18.2(252/2), A.18.3(157/2), A.18.4(80/2), A.18.7(101/2), A.18.18(70/3), A.18.19(11/3), A.18.20(15/3), A.18.21(16/3), A.18.22(13/3), A.18.23(16/3), A.18.24(13/3), A.18.25(15/3), B.1(38.1/3), B.3.1(51), B.3.1(55), B.3.1(56), B.3.1(57), B.3.2(35), B.3.2(36), B.3.2(37), B.3.2(38), B.3.2(39), B.3.2(42), C.3.1(14), C.3.1(14.1/3), C.7.1(18), C.7.2(14), C.7.2(15), C.7.2(15.1/2), D.2.6(31/2), D.5.1(12), D.11(9), D.14(19/2), D.14.1(25/2), D.14.2(35/2), H.4(26), H.4(27) 
error    compile-time   1.1.2(27), 1.1.5(4)    link-time   1.1.2(29), 1.1.5(4)    run-time   1.1.2(30), 1.1.5(6), 11.5(2/3), 
11.6(1/3) 
   See also  bounded error, erroneous 
execution 
ESA    in Ada.Characters.Latin_1   A.3.3(17) 
ESC    in Ada.Characters.Latin_1   A.3.3(6) 
Establish_RPC_Receiver    in System.RPC   E.5(12) 
ETB    in Ada.Characters.Latin_1   A.3.3(6) 
ETX    in Ada.Characters.Latin_1   A.3.3(5) 
evaluation   3.1(11), N(17.1/2), N(19)    aggregate   4.3(5) 
   allocator   4.8(7/2)    array_aggregate   4.3.3(21)    attribute_reference   4.1.4(11)    case_expression   4.5.7(21/3)    concatenation   4.5.3(5)    dereference   4.1(13)    discrete_range   3.6.1(8)    extension_aggregate   4.3.2(7)    generalized_reference   4.1.5(8/3)    generic_association   12.3(21)    generic_association for a formal object 
of mode in   12.4(11) 
   if_expression   4.5.7(20/3)    indexed_component   4.1.1(7)    initialized allocator   4.8(7/2)    membership test   4.5.2(27/3)    name   4.1(11/2)    name that has a prefix   4.1(12)    null literal   4.2(9)    numeric literal   4.2(9)    parameter_association   6.4.1(7)    prefix   4.1(12)    primary that is a name   4.4(10)    qualified_expression   4.7(4)    quantified_expression   4.5.8(6/3)    range   3.5(9)    range_attribute_reference   4.1.4(11)    record_aggregate   4.3.1(18)    record_component_association_list   
4.3.1(19) 
   selected_component   4.1.3(14)    short-circuit control form   4.5.1(7)    slice   4.1.2(7)    string_literal   4.2(10)    uninitialized allocator   4.8(8)    Val   3.5.5(7), K.2(261)    Value   3.5(55/3)    value conversion   4.6(28)    view conversion   4.6(52)    Wide_Value   3.5(43/3)    Wide_Wide_Value   3.5(39.4/3) Exception   11(1/3), 11.1(1), N(18) exception function   6.8(6/3) exception occurrence   11(1/3) exception_choice   11.2(5)    used   11.2(3), P 
exception_declaration   11.1(2/3)    used   3.1(3/3), P 
exception_handler   11.2(3)    used   11.2(2), P 
Exception_Id    in Ada.Exceptions   11.4.1(2/2) 
Exception_Identity    in Ada.Exceptions   11.4.1(5/2) 
Exception_Information    in Ada.Exceptions   11.4.1(5/2) 
Exception_Message    in Ada.Exceptions   11.4.1(4/3) Exception_Name 
   in Ada.Exceptions   11.4.1(2/2), 
11.4.1(5/2) 
Exception_Occurrence    in Ada.Exceptions   11.4.1(3/2) 
Exception_Occurre nce_Access 
   in Ada.Exceptions   11.4.1(3/2) 
exception_renaming_declaration   
8.5.2(2/3) 
   used   8.5(2), P 
Exceptions    child of  Ada   11.4.1(2/2) 
Exchange_Handler    in Ada.Interrupts   C.3.2(8) 
Exclamation    in Ada.Characters.Latin_1   A.3.3(8) 
exclamation point   2.1(15/3) Exclude    in Ada.Containers.Hashed_Maps   
A.18.5(24/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(23/2), A.18.8(54/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(23/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(22/2), A.18.9(67/2) 
excludes null    subtype   3.10(13.1/2) execution   3.1(11), N(19)    abort_statement   9.8(4)    aborting the execution of a construct   
9.8(5) 
   accept_statement   9.5.2(24)    Ada program   9(1/3)    assignment_statement   5.2(7), 7.6(17), 
7.6.1(12/2) 
   asynchronous_select with a 
delay_statement trigger   9.7.4(7) 
   asynchronous_select with a procedure 
call trigger   9.7.4(6/2) 
   asynchronous_select with an entry call 
trigger   9.7.4(6/2) 
   block_statement   5.6(5)    call on a dispatching operation   
3.9.2(14) 
   call on an inherited subprogram   
3.4(27/2) 
   case_statement   5.4(11/3)    conditional_entry_call   9.7.3(3)    delay_statement   9.6(20)    dynamically enclosing   11.4(2)    entry_body   9.5.2(26)    entry_call_statement   9.5.3(8)    exit_statement   5.7(5)    extended_return_statement   6.5(5.11/3)    goto_statement   5.8(5)    handled_sequence_of_statements   
11.2(10) 
   handler   11.4(7)    if_statement   5.3(5/3) 
Ada Reference Manual — 2012 Edition 
885      13 December 2012 Index    instance of Unchecked_Deallocation   
7.6.1(10) 
   loop_statement   5.5(7)    loop_statement with a for 
iteration_scheme   5.5(9/3) 
   loop_statement with a while 
iteration_scheme   5.5(8) 
   null_statement   5.1(13)    partition   10.2(25)    pragma   2.8(12)    program   10.2(25)    protected subprogram call   9.5.1(3)    raise_statement with an 
exception_name   11.3(4/2) 
   re-raise statement   11.3(4/2)    remote subprogram call   E.4(9)    requeue protected entry   9.5.4(9)    requeue task entry   9.5.4(8)    requeue_statement   9.5.4(7/3)    selective_accept   9.7.1(15)    sequence_of_statements   5.1(15)    simple_return_statement   6.5(6/2)    subprogram call   6.4(10/2)    subprogram_body   6.3(7)    task   9.2(1)    task_body   9.2(1)    timed_entry_call   9.7.2(4/2) execution resource    associated with a protected object   
9.4(18) 
   required for a task to run   9(10) execution time    of a task   D.14(11/3) Execution_Time    child of  Ada   D.14(3/2) 
exhaust    a budget   D.14.2(14/2) exist    cease to   7.6.1(11/3), 13.11.2(10/2) Exists    in Ada.Directories   A.16(24/2) 
   in Ada.Environment_Variables   
A.17(5/2) 
exit_statement   5.7(2)    used   5.1(4/2), P 
Exit_Status    in Ada.Command_Line   A.15(7) 
Exp    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(3) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(4) 
expanded name   4.1.3(4) Expanded_Name    in Ada.Tags   3.9(7/2) 
expected profile   8.6(26)    accept_statement entry_direct_name   
9.5.2(11) 
   Access attribute_reference prefix   
3.10.2(2.3/2)    attribute_definition_clause name   
13.3(4) 
   character_literal   4.2(3)    formal subprogram actual   12.6(6)    formal subprogram default_name   
12.6(5) 
   name in an aspect_specification   
13.1.1(8/3) 
   subprogram_renaming_declaration   
8.5.4(3) 
expected type   8.6(20/2)    abort_statement task_name   9.8(3)    access attribute_reference   3.10.2(2/2)    Access attribute_reference prefix   
3.10.2(2.3/2) 
   actual parameter   6.4.1(3)    aggregate   4.3(3/2)    allocator   4.8(3/3)    array_aggregate   4.3.3(7/2)    array_aggregate component expression   
4.3.3(7/2) 
   array_aggregate discrete_choice   
4.3.3(8) 
   assignment_statement expression   
5.2(4/2) 
   assignment_statement variable_name   
5.2(4/2) 
   Attach_Handler pragma second 
argument   J.15.7(6/3) 
   attribute_definition_clause expression or 
name   13.3(4) 
   attribute_designator expression   
4.1.4(7) 
   case_expression selecting_expression   
4.5.7(15/3) 
   case_expression_alternative 
discrete_choice   4.5.7(15/3) 
   case_statement selecting_expression   
5.4(4/3) 
   case_statement_alternative 
discrete_choice   5.4(4/3) 
   character_literal   4.2(3)    code_statement   13.8(4)    component_clause expressions   
13.5.1(7) 
   component_declaration 
default_expression   3.8(7) 
   condition   4.5.7(14/3)    CPU pragma argument   J.15.9(3/3)    decimal fixed point type digits   3.5.9(6)    delay_relative_statement expression   
9.6(5) 
   delay_until_statement expression   
9.6(5) 
   delta_constraint expression   J.3(3)    dependent_expression   4.5.7(8/3)    dereference name   4.1(8)    discrete_subtype_definition range   
3.6(8) 
   discriminant default_expression   3.7(7)    discriminant_association expression   
3.7.1(6) 
   Dispatching_Domains pragma 
argument   J.15.10(3/3) 
   entry_index   9.5.2(11)    enumeration_representation_clause 
expressions   13.4(4) 
   expression in an aspect_specification   
13.1.1(7/3) 
   expression of a 
Default_Component_Value aspect   3.6(22.4/3) 
   expression of a Default_Value aspect   
3.5(56.5/3) 
   expression of a predicate aspect   
3.2.4(2/3) 
   expression of expression function   
6.8(3/3) 
   expression of 
extended_return_statement   6.5(3/2) 
   expression of simple_return_statement   
6.5(3/2) 
   extension_aggregate   4.3.2(4/2)    extension_aggregate ancestor 
expression   4.3.2(4/2) 
   external name   J.15.5(6/3)    first_bit   13.5.1(7)    fixed point type delta   3.5.9(6)    generic formal in object actual   12.4(4)    generic formal object 
default_expression   12.4(3) 
   index_constraint discrete_range   
3.6.1(4) 
   indexable_container_object_prefix   
4.1.6(11/3) 
   indexed_component expression   
4.1.1(4) 
   Interrupt_Priority pragma argument   
J.15.11(5/3) 
   invariant expression   7.3.2(4/3)    iterable_name   5.5.2(3/3)    iterator_name   5.5.2(3/3)    last_bit   13.5.1(7)    link name   J.15.5(6/3)    linker options   B.1(10.1/3)    membership test simple_expression   
4.5.2(3/3) 
   modular_type_definition expression   
3.5.4(5) 
   name in an aspect_specification   
13.1.1(7/3) 
   number_declaration expression   
3.3.2(3) 
   object in an aspect_specification   
13.1.1(6/3) 
   object_declaration initialization 
expression   3.3.1(4) 
   parameter default_expression   6.1(17)    position   13.5.1(7)    postcondition expression   6.1.1(6/3) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      886    precondition expression   6.1.1(6/3) 
   Priority pragma argument   J.15.11(5/3)    quantified_expression   4.5.8(5/3)    range simple_expressions   3.5(5)    range_attribute_designator expression   
4.1.4(7) 
   range_constraint range   3.5(5)    real_range_specification bounds   
3.5.7(5) 
   record_aggregate   4.3.1(8/2)    record_component_association 
expression   4.3.1(10) 
   reference_object_name   4.1.5(5/3)    Relative_Deadline pragma argument   
J.15.12(3/3) 
   requested decimal precision   3.5.7(4)    restriction parameter expression   
13.12(5) 
   selecting_expression case_expression   
4.5.7(15/3) 
   selecting_expression case_statement   
5.4(4/3) 
   short-circuit control form relation   
4.5.1(1) 
   signed_integer_type_definition 
simple_expression   3.5.4(5) 
   slice discrete_range   4.1.2(4)    Storage_Size pragma argument   
J.15.4(4/3) 
   string_literal   4.2(4)    subpool_handle_name   4.8(3/3)    type_conversion operand   4.6(6)    variant_part discrete_choice   3.8.1(6) expiration time    [partial ]   9.6(1) 
   for a delay_relative_statement   9.6(20)    for a delay_until_statement   9.6(20) expires    execution timer   D.14.1(15/3) explicit declaration   3.1(5), N(11) explicit initial value   3.3.1(1/3) explicit_actual_parameter   6.4(6)    used   6.4(5), P 
explicit_dereference   4.1(5)    used   4.1(2/3), P 
explicit_generic_actual_parameter   
12.3(5) 
   used   12.3(4), P 
explicitly aliased parameter   6.1(23.1/3) explicitly assign   10.2(2) explicitly limited record   3.8(13.1/3) exponent   2.4.1(4), 4.5.6(11/3)    used   2.4.1(2), 2.4.2(2), P 
Exponent attribute   A.5.3(18) exponentiation operator   4.4(1/3), 4.5.6(7) Export aspect   B.1(1/3) Export pragma   J.15.5(3/3), L(13.1/3) exported entity   B.1(23/3) expression   4.4(1/3), 4.4(2)    predicate-static   3.2.4(15/3)    used   2.8(3/3), 3.3.1(2/3), 3.3.2(2), 
3.5.4(4), 3.5.7(2), 3.5.9(3), 3.5.9(4), 3.5.9(5), 3.7(6), 3.7.1(3), 4.1.1(2), 4.1.4(3/2), 4.1.4(5), 4.3.1(4/2), 4.3.2(3), 4.3.3(3/2), 4.3.3(5/2), 4.4(7/3), 4.5.7(3/3), 4.5.7(4/3), 4.5.7(5/3), 4.5.7(6/3), 4.5.8(3/3), 4.6(2), 4.7(2), 5.2(2), 5.4(2/3), 6.4(6), 6.5(2.1/3), 6.5(2/2), 6.8(2/3), 9.5.2(4), 9.6(3), 9.6(4), 11.3(2/2), 11.4.2(3/2), 12.3(5), 13.1.1(4/3), 13.3(2), 13.5.1(4), 13.12(4.1/2), B.1(8), B.1(10.1/3), D.2.2(3.2/2), J.3(2), J.7(1), J.8(1), J.15.4(2/3), J.15.5(2/3), J.15.5(3/3), J.15.7(4/3), J.15.9(2/3), L(2.1/2), L(6.1/3), L(8.2/3), L(13.1/3), L(14.1/3), L(19), L(27.2/2), L(35.1/3), P 
expression_function_declaration   6.8(2/3)    used   3.1(3/3), P 
extended_digit   2.4.2(5)    used   2.4.2(4), P 
Extended_Index subtype of  
Index_Type'Base 
   in Ada.Containers.Vectors   A.18.2(7/2) 
extended_return_object_declaration   
6.5(2.1/3) 
   used   6.5(2.2/3), P 
extended_return_statement   6.5(2.2/3)    used   5.1(5/2), P 
extension    of a private type   3.9(2.1/2), 3.9.1(1/2)    of a record type   3.9(2.1/2), 3.9.1(1/2)    of a type   3.9(2/2), 3.9.1(1/2)    in Ada.Directories   A.16(18/2) 
extension_aggregate   4.3.2(2)    used   4.3(2), P 
external call   9.5(4/3) external effect    of the execution of an Ada program   
1.1.3(8) 
   volatile/atomic objects   C.6(20) external file   A.7(1) external interaction   1.1.3(8) external name   B.1(34) external requeue   9.5(7) external streaming    type supports   13.13.2(52/3) External_Name aspect   B.1(1/3) External_Tag    in Ada.Tags   3.9(7/2) 
External_Tag aspect   13.3(75/3), K.2(65) External_Tag attribute   13.3(75/3) External_Tag clause   13.3(7/2), 
13.3(75/3), K.2(65) 
extra permission to avoid raising 
exceptions   11.6(5) 
extra permission to reorder actions   
11.6(6/3) 
 F 
 factor   4.4(6)    used   4.4(5), P 
factory   3.9(30/2) failure    of a language-defined check   11.5(2/3)    in Ada.Command_Line   A.15(8) 
fall-back handler   C.7.3(9/2) False   3.5.3(1) family    entry   9.5.2(20) Feminine_Ordinal_Indicator    in Ada.Characters.Latin_1   A.3.3(21/3) 
FF    in Ada.Characters.Latin_1   A.3.3(5) 
Field subtype of  Integer 
   in Ada.Text_IO   A.10.1(6) 
FIFO_Queuing queuing policy   D.4(7/2) FIFO_Within_Priorities task dispatching 
policy   D.2.3(2/2) 
file    as file object   A.7(2/3) file name   A.16(46/2) file terminator   A.10(7) File_Access    in Ada.Text_IO   A.10.1(18) 
File_Kind    in Ada.Directories   A.16(22/2) 
File_Mode    in Ada.Direct_IO   A.8.4(4) 
   in Ada.Sequential_IO   A.8.1(4) 
   in Ada.Streams.Stream_IO   A.12.1(6) 
   in Ada.Text_IO   A.10.1(4) 
File_Size    in Ada.Directories   A.16(23/2) 
File_Type    in Ada.Direct_IO   A.8.4(3) 
   in Ada.Sequential_IO   A.8.1(3) 
   in Ada.Streams.Stream_IO   A.12.1(5) 
   in Ada.Text_IO   A.10.1(3) 
Filter_Type    in Ada.Directories   A.16(30/2) 
finalization    of a master   7.6.1(4)    of a protected object   9.4(20)    of a protected object   C.3.1(12/3)    of a task object   J.7.1(8)    of an object   7.6.1(5)    of environment task for a foreign 
language main subprogram   B.1(39/3) 
   child of  Ada   7.6(4/3) 
Finalize   7.6(2)    in Ada.Finalization   7.6(6/2), 7.6(8/2) 
Find    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(41/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(30/2) 
Ada Reference Manual — 2012 Edition 
887      13 December 2012 Index    in Ada.Containers.Hashed_Sets   
A.18.8(43/2), A.18.8(56/2) 
   in Ada.Containers.Multiway_Trees   
A.18.10(38/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(38/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(49/2), A.18.9(69/2) 
   in Ada.Containers.Vectors   
A.18.2(68/2) 
Find_In_Subtree    in Ada.Containers.Multiway_Trees   
A.18.10(39/3) 
Find_Index    in Ada.Containers.Vectors   
A.18.2(67/2) 
Find_Token    in Ada.Strings.Bounded   A.4.4(50.1/3), 
A.4.4(51) 
   in Ada.Strings.Fixed   A.4.3(15.1/3), 
A.4.3(16) 
   in Ada.Strings.Unbounded   
A.4.5(45.1/3), A.4.5(46) 
Fine_Delta    in System   13.7(9) 
First    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(33/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(27/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(40/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(28/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(41/2) 
   in Ada.Containers.Vectors   
A.18.2(58/2) 
   in Ada.Iterator_Interfaces   5.5.1(3/3) 
First attribute   3.5(12), 3.6.2(3) first element    of a hashed set   A.18.8(68/2)    of a set   A.18.7(6/2)    of an ordered set   A.18.9(81/3) first node    of a hashed map   A.18.5(46/2)    of a map   A.18.4(6/2)    of an ordered map   A.18.6(58/3) first subtype   3.2.1(6), 3.4.1(5) First(N) attribute   3.6.2(4) first_bit   13.5.1(5)    used   13.5.1(3), P 
First_Bit attribute   13.5.2(3/2) First_Child    in Ada.Containers.Multiway_Trees   
A.18.10(60/3) 
First_Child_Element    in Ada.Containers.Multiway_Trees   
A.18.10(61/3) First_Element 
   in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(34/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(29/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(42/2) 
   in Ada.Containers.Vectors   
A.18.2(59/2) 
First_Index    in Ada.Containers.Vectors   
A.18.2(57/2) 
First_Key    in Ada.Containers.Ordered_Maps   
A.18.6(30/2) 
First_Valid attribute   3.5.5(7.2/3) Fixed    child of  Ada.Strings   A.4.3(5) 
fixed point type   3.5.9(1) Fixed_IO    in Ada.Text_IO   A.10.1(68) 
fixed_point_definition   3.5.9(2)    used   3.5.6(2), P 
Float   3.5.7(12), 3.5.7(14)    in Standard   A.1(21) 
Float_IO    in Ada.Text_IO   A.10.1(63) 
Float_Random    child of  Ada.Numerics   A.5.2(5) 
Float_Text_IO    child of  Ada   A.10.9(33) 
Float_Wide_Text_IO    child of  Ada   A.11(2/2) 
Float_Wide_Wide_Text_IO    child of  Ada   A.11(3/2) 
Floating    in Interfaces.COBOL   B.4(9) 
floating point type   3.5.7(1) floating_point_definition   3.5.7(2)    used   3.5.6(2), P 
Floor    in Ada.Containers.Ordered_Maps   
A.18.6(40/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(50/2), A.18.9(70/2) 
Floor attribute   A.5.3(30) Flush    in Ada.Streams.Stream_IO   
A.12.1(25/1) 
   in Ada.Text_IO   A.10.1(21/1) 
Fore attribute   3.5.10(4) form    of an external file   A.7(1)    in Ada.Direct_IO   A.8.4(9) 
   in Ada.Sequential_IO   A.8.1(9) 
   in Ada.Streams.Stream_IO   A.12.1(11) 
   in Ada.Text_IO   A.10.1(12) 
formal object, generic   12.4(1) formal package, generic   12.7(1) formal parameter 
   of a subprogram   6.1(17) formal subprogram, generic   12.6(1) formal subtype   12.5(5) formal type   12.5(5) formal_abstract_subprogram_declaration   
12.6(2.2/3) 
   used   12.6(2/2), P 
formal_access_type_defi nition   12.5.4(2) 
   used   12.5(3/2), P 
formal_array_type_definition   12.5.3(2)    used   12.5(3/2), P 
formal_complete_type_declaration   
12.5(2.1/3) 
   used   12.5(2/3), P 
formal_concrete_subprogram_declaration 
  12.6(2.1/3) 
   used   12.6(2/2), P 
formal_decimal_fixed_point_definition   
12.5.2(7) 
   used   12.5(3/2), P 
formal_derived_type_definition   
12.5.1(3/2) 
   used   12.5(3/2), P 
formal_discrete_type_definition   
12.5.2(2) 
   used   12.5(3/2), P 
formal_floating_point_definition   
12.5.2(5) 
   used   12.5(3/2), P 
formal_incomplete_type_declaration   
12.5(2.2/3) 
   used   12.5(2/3), P 
formal_interface_ty pe_definition   
12.5.5(2/2) 
   used   12.5(3/2), P 
formal_modular_type_definition   
12.5.2(4) 
   used   12.5(3/2), P 
formal_object_declaration   12.4(2/3)    used   12.1(6), P 
formal_ordinary_fixed_point_definition   
12.5.2(6) 
   used   12.5(3/2), P 
formal_package_actual_part   12.7(3/2)    used   12.7(2/3), P 
formal_package_association   12.7(3.1/2)    used   12.7(3/2), P 
formal_package_declaration   12.7(2/3)    used   12.1(6), P 
formal_part   6.1(14)    used   6.1(12), 6.1(13/2), P 
formal_private_type_definition   12.5.1(2)    used   12.5(3/2), P 
formal_signed_integer_type_definition   
12.5.2(3) 
   used   12.5(3/2), P 
formal_subprogram_declaration   
12.6(2/2) 
   used   12.1(6), P 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      888 formal_type_declaration   12.5(2/3) 
   used   12.1(6), P 
formal_type_definition   12.5(3/2)    used   12.5(2.1/3), P 
format_effector   2.1(13/3) Formatting    child of  Ada.Calendar   9.6.1(15/2) 
Fortran    child of  Interfaces   B.5(4) 
Fortran interface   B.5(1/3) Fortran standard   1.2(3/2) Fortran_Character    in Interfaces.Fortran   B.5(12/3) 
Fortran_Integer    in Interfaces.Fortran   B.5(5) 
forward iterator   5.5.2(4/3) Forward_Iterator    in Ada.Iterator_Interfaces   5.5.1(3/3) 
Fraction attribute   A.5.3(21) Fraction_One_Half    in Ada.Characters.Latin_1   A.3.3(22) 
Fraction_One_Quarter    in Ada.Characters.Latin_1   A.3.3(22) 
Fraction_Three_Quarters    in Ada.Characters.Latin_1   A.3.3(22) 
Free    in Ada.Strings.Unbounded   A.4.5(7) 
   in Interfaces.C.Strings   B.3.1(11) 
freed    See nonexistent   13.11.2(10/2) 
freeing storage   13.11.2(1) freezing    by a constituent of a construct   
13.14(4/1) 
   by an expression   13.14(8/3)    by an implicit call   13.14(8.1/3)    by an object name   13.14(8/3)    class-wide type caused by the freezing 
of the specific type   13.14(15) 
   constituents of a full type definition   
13.14(15) 
   designated subtype caused by an 
allocator   13.14(13) 
   entity   13.14(2)    entity caused by a body   13.14(3/3)    entity caused by a construct   13.14(4/1)    entity caused by a name   13.14(11)    entity caused by the end of an enclosing 
construct   13.14(3/3) 
   expression of an expression function by 
a call   13.14(10.1/3) 
   expression of an expression function by 
Access attribute   13.14(10.3/3) 
   expression of an expression function by 
an instantiation   13.14(10.2/3) 
   first subtype caused by the freezing of 
the type   13.14(15) 
   generic_instantiation   13.14(5/3)    nominal subtype caused by a name   
13.14(11)    object_declaration   13.14(6) 
   profile   13.14(2.1/3)    profile of a callable entity by an 
instantiation   13.14(10.2/3) 
   profile of a function call   13.14(10.1/3)    specific type caused by the freezing of 
the class-wide type   13.14(15) 
   subtype caused by a record extension   
13.14(7) 
   subtype caused by an implicit 
conversion   13.14(8.2/1) 
   subtype caused by an implicit 
dereference   13.14(11.1/1) 
   subtypes of the profile of a callable 
entity   13.14(14/3) 
   type caused by a range   13.14(12)    type caused by an expression   13.14(10)    type caused by the freezing of a 
subtype   13.14(15) 
freezing points    entity   13.14(2) Friday    in Ada.Calendar.Formatting   
9.6.1(17/2) 
FS    in Ada.Characters.Latin_1   A.3.3(6) 
full conformance    for discrete_subtype_definitions   
6.3.1(24) 
   for expressions   6.3.1(19)    for known_discriminant_parts   
6.3.1(23) 
   for profiles   6.3.1(18/3)    required   3.10.1(4/3), 6.3(4), 6.7(2.1/3), 
6.8(4/3), 7.3(9), 8.3(12.3/2), 8.5.4(5/3), 9.5.2(14), 9.5.2(16), 9.5.2(17), 10.1.3(11), 10.1.3(12) 
full constant declaration   3.3.1(6/3)    corresponding to a formal object of 
mode in   12.4(10/2) 
full declaration   7.4(2/3) full name    of a file   A.16(47/2) full stop   2.1(15/3) full type   3.2.1(8/2) full type definition   3.2.1(8/2) full view    of a type   3.2.1(8/2) Full_Name    in Ada.Directories   A.16(15/2), 
A.16(39/2) 
Full_Stop    in Ada.Characters.Latin_1   A.3.3(8) 
full_type_declaration   3.2.1(3/3)    used   3.2.1(2), P 
function   6(1), N(19.1/2)    expression   6.8(6/3)    with a controlling access result   
3.9.2(2/3) 
   with a controlling result   3.9.2(2/3) function call 
   master of   3.10.2(10.1/3) function instance   12.3(13) function_call   6.4(3)    used   4.1(2/3), P 
function_specification   6.1(4.2/2)    used   6.1(4/2), 6.8(2/3), P 
 
G 
 general access type   3.10(7/1), 3.10(8) general_access_modifier   3.10(4)    used   3.10(3), P 
generalized iterator   5.5.2(3/3) generalized_indexing   4.1.6(10/3)    used   4.1(2/3), P 
generalized_reference   4.1.5(4/3)    used   4.1(2/3), P 
generation    of an interrupt   C.3(2) Generator    in Ada.Numerics.Discrete_Random   
A.5.2(19) 
   in Ada.Numerics.Float_Random   
A.5.2(7) 
generic actual   12.3(7/3) generic actual parameter   12.3(7/3) generic actual subtype   12.5(4) generic actual type   12.5(4) generic body   12.2(1) generic contract issue   10.2.1(10/2)    [partial ]   3.2.4(29/3), 3.4(5.1/3), 
3.7(10/3), 3.7.1(7/3), 3.9.1(3/2), 3.9.4(17/2), 3.10.2(28.1/3), 3.10.2(32/3), 4.1.6(9/3), 4.5.2(9.8/3), 4.6(24.17/3), 4.6(24.21/2), 4.8(5.6/3), 4.9(37/2), 6.5.1(6/2), 7.3(8), 8.3(26/2), 8.3.1(7/2), 8.5.1(4.6/2), 8.5.1(5/3), 8.5.4(4.3/2), 9.1(9.9/2), 9.4(11.13/2), 9.4(11.8/2), 9.5(17/3), 9.5.2(13.4/2), 10.2.1(11.7/3), 10.2.1(11/3), 10.2.1(17/3), 12.4(8.5/2), 12.6(8.3/2), 13.11.2(3.1/3), 13.11.4(23/3), B.3.3(10/3), C.3.1(7/3), J.15.7(7/3) 
generic formal   12.1(9) generic formal object   12.4(1) generic formal package   12.7(1) generic formal subprogram   12.6(1) generic formal subtype   12.5(5) generic formal type   12.5(5) generic function   12.1(8/2) generic package   12.1(8/2) generic procedure   12.1(8/2) generic subprogram   12.1(8/2) generic unit   12(1), N(20)    See also  dispatching operation   3.9(1) 
generic_actual_part   12.3(3)    used   12.3(2/3), 12.7(3/2), P 
Generic_Array_Sort    child of  Ada.Containers   A.18.26(3/2) 
Ada Reference Manual — 2012 Edition 
889      13 December 2012 Index generic_association   12.3(4) 
   used   12.3(3), 12.7(3.1/2), P 
Generic_Bounded_Length    in Ada.Strings.Bounded   A.4.4(4) 
Generic_Complex_Arrays    child of  Ada.Numerics   G.3.2(2/2) 
Generic_Complex_Elementary_Functions    child of  Ada.Numerics   G.1.2(2/2) 
Generic_Complex_Types    child of  Ada.Numerics   G.1.1(2/1) 
Generic_Constrained_Array_Sort    child of  Ada.Containers   A.18.26(7/2) 
generic_declaration   12.1(2)    used   3.1(3/3), 10.1.1(5), P 
Generic_Dispatching_Constructor    child of  Ada.Tags   3.9(18.2/3) 
Generic_Elementary_Functions    child of  Ada.Numerics   A.5.1(3) 
generic_formal_parameter_declaration   
12.1(6) 
   used   12.1(5), P 
generic_formal_part   12.1(5)    used   12.1(3/3), 12.1(4), P 
generic_instantiation   12.3(2/3)    used   3.1(3/3), 10.1.1(5), P 
Generic_Keys    in Ada.Containers.Hashed_Sets   
A.18.8(50/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(62/2) 
generic_package_declaration   12.1(4)    used   12.1(2), P 
Generic_Real_Arrays    child of  Ada.Numerics   G.3.1(2/2) 
generic_renaming_declaration   8.5.5(2/3)    used   8.5(2), 10.1.1(6), P 
Generic_Sort    child of  Ada.Containers   A.18.26(9.2/3) 
Generic_Sorting    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(47/2) 
   in Ada.Containers.Vectors   
A.18.2(75/2) 
generic_subprogram_declaration   
12.1(3/3) 
   used   12.1(2), P 
Get    in Ada.Text_IO   A.10.1(41), 
A.10.1(47), A.10.1(54), A.10.1(55), A.10.1(59), A.10.1(60), A.10.1(65), A.10.1(67), A.10.1(70), A.10.1(72), A.10.1(75), A.10.1(77), A.10.1(81), A.10.1(83) 
   in Ada.Text_IO.Complex_IO   G.1.3(6), 
G.1.3(8) 
Get_CPU    in Ada.Interrupts   C.3.2(10.1/3) 
   in 
System.Multiprocessors.Dispatching_Domains   D.16.1(13/3) Get_Deadline 
   in Ada.Dispatching.EDF   D.2.6(9/2) 
Get_Dispatching_Domain    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(10/3) 
Get_First_CPU    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(8/3) 
Get_Immediate    in Ada.Text_IO   A.10.1(44), A.10.1(45) 
Get_Last_CPU    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(9/3) 
Get_Line    in Ada.Text_IO   A.10.1(49), 
A.10.1(49.1/2) 
   in Ada.Text_IO.Bounded_IO   
A.10.11(8/2), A.10.11(9/2), A.10.11(10/2), A.10.11(11/2) 
   in Ada.Text_IO.Unbounded_IO   
A.10.12(8/2), A.10.12(9/2), A.10.12(10/2), A.10.12(11/2) 
Get_Next_Entry    in Ada.Directories   A.16(35/2) 
Get_Priority    in Ada.Dynamic_Priorities   D.5.1(5) 
global to   8.1(15) Glossary   N(1/2) goto_statement   5.8(2)    used   5.1(4/2), P 
govern a variant   3.8.1(20) govern a variant_part   3.8.1(20) grammar    complete listing   P    cross reference   P    notation   1.1.4(3)    resolution of ambiguity   8.6(3)    under Syntax heading   1.1.2(25) graphic character    a category of Character   A.3.2(23) graphic_character   2.1(14/3)    used   2.5(2), 2.6(3), P 
Graphic_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
Grave    in Ada.Characters.Latin_1   A.3.3(13) 
greater than operator   4.4(1/3), 4.5.2(1) greater than or equal operator   4.4(1/3), 
4.5.2(1) 
greater-than sign   2.1(15/3) Greater_Than_Sign    in Ada.Characters.Latin_1   A.3.3(10) 
Group_Budget    in 
Ada.Execution_Time.Group_Budgets   D.14.2(4/3) Group_Budget_Error 
   in 
Ada.Execution_Time.Group_Budgets   D.14.2(11/2) 
Group_Budget_Handler    in 
Ada.Execution_Time.Group_Budgets   D.14.2(5/2) 
Group_Budgets    child of  Ada.Execution_Time   
D.14.2(3/3) 
GS    in Ada.Characters.Latin_1   A.3.3(6) 
guard   9.7.1(3)    used   9.7.1(2), P 
 
H 
 handle    an exception   11(1/3), N(18)    an exception occurrence   11.4(1), 
11.4(7) 
   subpool   13.11.4(18/3) handled_sequence_of_statements   11.2(2)    used   5.6(2), 6.3(2/3), 6.5(2.2/3), 
7.2(2/3), 9.1(6/3), 9.5.2(3), 9.5.2(5), P 
handler    execution timer   D.14.1(13/2)    group budget   D.14.2(14/2)    interrupt   C.3(2)    termination   C.7.3(8/3)    timing event   D.15(10/2) Handling    child of  Ada.Characters   A.3.2(2/2) 
   child of  Ada.Wide_Characters   
A.3.5(3/3) 
   child of  Ada.Wide_Wide_Characters   
A.3.6(1/3) 
Has_Element    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(9.1/3) 
   in Ada.Containers.Hashed_Maps   
A.18.5(6.1/3) 
   in Ada.Containers.Hashed_Sets   
A.18.8(6.1/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(12/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(7.1/3) 
   in Ada.Containers.Ordered_Sets   
A.18.9(7.1/3) 
   in Ada.Containers.Vectors   
A.18.2(11.1/3) 
Has_Same_Storage attribute   13.3(73.2/3) Hash    child of  Ada.Strings   A.4.9(2/3) 
   child of  Ada.Strings.Bounded   
A.4.9(7/3) 
   child of  Ada.Strings.Unbounded   
A.4.9(10/3) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      890 Hash_Case_Insensitive 
   child of  Ada.Strings   A.4.9(11.2/3) 
   child of  Ada.Strings.Bounded   
A.4.9(11.7/3) 
   child of  Ada.Strings.Fixed   
A.4.9(11.5/3) 
   child of  Ada.Strings.Unbounded   
A.4.9(11.10/3) 
Hash_Type    in Ada.Containers   A.18.1(4/2) 
Hashed_Maps    child of  Ada.Containers   A.18.5(2/3) 
Hashed_Sets    child of  Ada.Containers   A.18.8(2/3) 
Head    in Ada.Strings.Bounded   A.4.4(70), 
A.4.4(71) 
   in Ada.Strings.Fixed   A.4.3(35), 
A.4.3(36) 
   in Ada.Strings.Unbounded   A.4.5(65), 
A.4.5(66) 
head (of a queue)   D.2.1(5/2) heap management    user-defined   13.11(1)    See also  allocator   4.8(1) 
held priority   D.11(4/2) heterogeneous input-output   A.12.1(1) hexadecimal    literal   2.4.2(1) hexadecimal digit    a category of Character   A.3.2(30) hexadecimal literal   2.4.2(1) Hexadecimal_Digit_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
hidden from all visibility   8.3(5), 8.3(14)    by lack of a with_clause   8.3(20/2)    for a declaration completed by a 
subsequent declaration   8.3(19) 
   for overridden declaration   8.3(15)    within the declaration itself   8.3(16) hidden from direct visibility   8.3(5), 
8.3(21) 
   by an inner homograph   8.3(22)    where hidden from all visibility   8.3(23) hiding   8.3(5) Hierarchical_File_Names    child of  Ada.Directories   A.16.1(3/3) 
High_Order_First   13.5.3(2)    in Interfaces.COBOL   B.4(25) 
   in System   13.7(15/2) 
highest precedence operator   4.5.6(1) highest_precedence_opera tor   4.5(7) 
Hold    in Ada.Asynchronous_Task_Control   
D.11(3/2) 
Holder    in Ada.Containers.Indefinite_Holders   
A.18.18(6/3) 
homograph   8.3(8) Hour 
   in Ada.Calendar.Formatting   
9.6.1(24/2) 
Hour_Number subtype of  Natural 
   in Ada.Calendar.Formatting   
9.6.1(20/2) 
HT    in Ada.Characters.Latin_1   A.3.3(5) 
HTJ    in Ada.Characters.Latin_1   A.3.3(17) 
HTS    in Ada.Characters.Latin_1   A.3.3(17) 
Hyphen    in Ada.Characters.Latin_1   A.3.3(8) 
hyphen-minus   2.1(15/3)  
I 
 i    in Ada.Numerics.Generic_Complex_-
Types   G.1.1(5) 
   in Interfaces.Fortran   B.5(10) 
identifier   2.3(2/2)    used   2.8(2), 2.8(3/3), 2.8(21), 2.8(23), 
3.1(4), 4.1(3), 4.1.3(3), 4.1.4(3/2), 5.5(2), 5.6(2), 6.1(5), 7.1(3/3), 7.2(2/3), 9.1(4), 9.1(6/3), 9.4(4), 9.4(7/3), 9.5.2(3), 9.5.2(5), 11.4.2(6.1/3), 11.4.2(6/2), 11.5(4.1/2), 11.5(4/2), 13.1.1(3/3), 13.1.1(4/3), 13.12(4/2), 13.12(11/3), D.2.2(3), D.2.2(3.2/2), D.3(3), D.3(4), D.4(3), D.4(4), H.6(3/2), J.10(3/2), J.15.5(2/3), J.15.5(3/3), J.15.5(4/3), L(2.2/2), L(2.3/3), L(8.1/3), L(13.1/3), L(14.1/3), L(20), L(21), L(23), L(25.1/2), L(27.2/2), L(27.3/3), L(29), L(36), L(37), L(37.3/2), M.2(98), P 
identifier specific to a pragma   2.8(10/3) identifier_extend   2.3(3.1/3)    used   2.3(2/2), P 
identifier_start   2.3(3/2)    used   2.3(2/2), P 
Identity    in Ada.Strings.Maps   A.4.2(22) 
   in Ada.Strings.Wide_Maps   A.4.7(22) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(22/2) 
Identity attribute   11.4.1(9), C.7.1(12) idle task   D.11(4/2) if_expression   4.5.7(3/3)    used   4.5.7(2/3), P 
if_statement   5.3(2)    used   5.1(5/2), P 
illegal    construct   1.1.2(27)    partition   1.1.2(29) Im 
   in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(7/2), G.3.2(27/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(6) 
image    of a value   3.5(27.3/2), 3.5(30/3), 
K.2(273/3), K.2(277.4/2) 
   in Ada.Calendar.Formatting   
9.6.1(35/2), 9.6.1(37/2) 
   in Ada.Numerics.Discrete_Random   
A.5.2(26) 
   in Ada.Numerics.Float_Random   
A.5.2(14) 
   in Ada.Task_Identification   C.7.1(3/3) 
   in Ada.Text_IO.Editing   F.3.3(13) 
Image attribute   3.5(35) Imaginary    in Ada.Numerics.Generic_Complex_-
Types   G.1.1(4/2) 
Imaginary subtype of  Imaginary 
   in Interfaces.Fortran   B.5(10) 
immediate scope    of (a view of) an entity   8.2(11)    of a declaration   8.2(2) Immediate_Reclamation restriction   
H.4(10) 
immediately enclosing   8.1(13) immediately visible   8.3(4), 8.3(21) immediately within   8.1(13) immutably limited   7.5(8.1/3) implementation advice   1.1.2(37)    summary of advice   M.3(1/2) implementation defined   1.1.3(18)    summary of characteristics   M.2(1/2) implementation permissions   1.1.2(36) implementation requirements   1.1.2(33) implementation-dependent    See unspecified   1.1.3(18) 
implemented    by a protected entry   9.4(11.1/3)    by a protected subprogram   9.4(11.1/3)    by a task entry   9.1(9.2/3) implicit conversion    legality   8.6(27.1/3) implicit declaration   3.1(5), N(11) implicit initial values    for a subtype   3.3.1(10) implicit subtype conversion   4.6(59), 
4.6(60) 
   Access attribute   3.10.2(30)    access discriminant   3.7(27/2)    array bounds   4.6(38)    array index   4.1.1(7)    assignment to view conversion   4.6(55)    assignment_statement   5.2(11)    bounds of a decimal fixed point type   
3.5.9(16) 
   bounds of a fixed point type   3.5.9(14)    bounds of a range   3.5(9), 3.6(18) 
Ada Reference Manual — 2012 Edition 
891      13 December 2012 Index    choices of aggregate   4.3.3(22) 
   component defaults   3.3.1(13/3)    default value of a scalar   3.3.1(11.1/3)    delay expression   9.6(20)    derived type discriminants   3.4(21)    discriminant values   3.7.1(12)    entry index   9.5.2(24)    expressions in aggregate   4.3.1(19)    expressions of aggregate   4.3.3(23)    function return   6.5(5.11/3), 6.5(6/2)    generic formal object of mode in   
12.4(11) 
   inherited enumeration literal   3.4(29)    initialization expression   3.3.1(17)    initialization expression of allocator   
4.8(7/2) 
   Interrupt_Priority aspect   D.1(17/3), 
D.3(6.1/3) 
   named number value   3.3.2(6)    operand of concatenation   4.5.3(9)    parameter passing   6.4.1(10), 6.4.1(11), 
6.4.1(17) 
   Priority aspect   D.1(17/3), D.3(6.1/3)    qualified_expression   4.7(4)    reading a view conversion   4.6(56)    result of inherited function   3.4(27/2) implicit_dereference   4.1(6)    used   4.1(4), P 
Implicit_Dereference aspect   4.1.5(2/3) Import aspect   B.1(1/3) Import pragma   J.15.5(2/3), L(14.1/3) imported entity   B.1(23/3) in (membership test)   4.4(1/3), 4.5.2(2/3) inaccessible partition   E.1(7) inactive    a task state   9(10) Include    in Ada.Containers.Hashed_Maps   
A.18.5(22/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(21/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(21/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(20/2) 
included    one range in another   3.5(4) incomplete type   3.2(4.1/2), 3.10.1(2.1/2), 
N(20.1/2) 
incomplete view   3.10.1(2.1/2)    tagged   3.10.1(2.1/2) incomplete_type_declaration   3.10.1(2/2)    used   3.2.1(2), P 
Increment    in Interfaces.C.Pointers   B.3.2(11/3) 
indefinite subtype   3.3(23/3), 3.7(26) Indefinite_Doubly_Linked_Lists    child of  Ada.Containers   A.18.12(2/3) 
Indefinite_Hashed_Maps    child of  Ada.Containers   A.18.13(2/3) Indefinite_Hashed_Sets 
   child of  Ada.Containers   A.18.15(2/3) 
Indefinite_Holders    child of  Ada.Containers   A.18.18(5/3) 
Indefinite_Multiway_Trees    child of  Ada.Containers   A.18.17(2/3) 
Indefinite_Ordered_Maps    child of  Ada.Containers   A.18.14(2/3) 
Indefinite_Ordered_Sets    child of  Ada.Containers   A.18.16(2/3) 
Indefinite_Vectors    child of  Ada.Containers   A.18.11(2/3) 
Independent aspect   C.6(6.3/3) Independent pragma   J.15.8(4/3), 
L(14.2/3) 
independent subprogram   11.6(6/3) Independent_Components aspect   
C.6(6.9/3) 
Independent_Components pragma   
J.15.8(7/3), L(14.3/3) 
independently addressable   9.10(1/3)    specified   C.6(8.1/3) index    of an element of an open direct file   
A.8(3) 
   in Ada.Direct_IO   A.8.4(15) 
   in Ada.Streams.Stream_IO   A.12.1(23) 
   in Ada.Strings.Bounded   A.4.4(43.1/2), 
A.4.4(43.2/2), A.4.4(44), A.4.4(45), A.4.4(45.1/2), A.4.4(46) 
   in Ada.Strings.Fixed   A.4.3(8.1/2), 
A.4.3(8.2/2), A.4.3(9), A.4.3(10), A.4.3(10.1/2), A.4.3(11) 
   in Ada.Strings.Unbounded   
A.4.5(38.1/2), A.4.5(38.2/2), A.4.5(39), A.4.5(40), A.4.5(40.1/2), A.4.5(41) 
index range   3.6(13) index subtype   3.6(9) index type   3.6(9) Index_Check   11.5(14)    [partial ]   4.1.1(7), 4.1.2(7), 4.3.3(29/3), 
4.3.3(30), 4.5.3(8), 4.6(51/3), 4.7(4), 4.8(10/2) 
index_constraint   3.6.1(2)    used   3.2.2(7), P 
Index_Error    in Ada.Strings   A.4.1(5) 
Index_Non_Blank    in Ada.Strings.Bounded   A.4.4(46.1/2), 
A.4.4(47) 
   in Ada.Strings.Fixed   A.4.3(11.1/2), 
A.4.3(12) 
   in Ada.Strings.Unbounded   
A.4.5(41.1/2), A.4.5(42) 
index_subtype_definition   3.6(4)    used   3.6(3), P 
indexable container object   4.1.6(5/3) indexable container type   4.1.6(5/3), 
N(20.2/3) indexed_component   4.1.1(2) 
   used   4.1(2/3), P 
indexing    constant   4.1.6(12/3)    variable   4.1.6(16/3) individual membership test   4.5.2(26.1/3) indivisible   C.6(10/3) inferable discriminants   B.3.3(20/2) Information    child of  Ada.Directories   A.16(124/2) 
information hiding    See package   7(1) 
   See private types and private 
extensions   7.3(1) 
information systems   C(1), F(1) informative   1.1.2(18) inherently mutable object   3.3(13/3) inheritance    See derived types and classes   3.4(1/2) 
   See also  tagged types and type 
extension   3.9(1) 
inherited    from an ancestor type   3.4.1(11) inherited component   3.4(11), 3.4(12) inherited discriminant   3.4(11) inherited entry   3.4(12) inherited protected subprogram   3.4(12) inherited subprogram   3.4(17/2) Initial_Directory    in 
Ada.Directories.Hierarchical_File_Names   A.16.1(12/3) 
initialization    of a protected object   9.4(14)    of a protected object   C.3.1(10/3), 
C.3.1(11/3) 
   of a task object   9.1(12/1), J.7.1(7)    of an object   3.3.1(18/2) initialization expression   3.3.1(1/3), 
3.3.1(4) 
Initialize   7.6(2)    in Ada.Finalization   7.6(6/2), 7.6(8/2) 
initialized allocator   4.8(4) initialized by default   3.3.1(18/2) Inline aspect   6.3.2(5.1/3) Inline pragma   J.15.1(2/3), L(15.1/3) innermost dynamically enclosing   11.4(2) input   A.6(1/2) Input aspect   13.13.2(38/3) Input attribute   13.13.2(22), 13.13.2(32) Input clause   13.3(7/2), 13.13.2(38/3) input-output    unspecified for access types   A.7(6) Insert    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(19/2), A.18.3(20/2), A.18.3(21/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(19/2), A.18.5(20/2), A.18.5(21/2) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      892    in Ada.Containers.Hashed_Sets   
A.18.8(19/2), A.18.8(20/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(18/2), A.18.6(19/2), A.18.6(20/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(18/2), A.18.9(19/2) 
   in Ada.Containers.Vectors   
A.18.2(36/2), A.18.2(37/2), A.18.2(38/2), A.18.2(39/2), A.18.2(40/2), A.18.2(41/2), A.18.2(42/2), A.18.2(43/2) 
   in Ada.Strings.Bounded   A.4.4(60), 
A.4.4(61) 
   in Ada.Strings.Fixed   A.4.3(25), 
A.4.3(26) 
   in Ada.Strings.Unbounded   A.4.5(55), 
A.4.5(56) 
Insert_Child    in Ada.Containers.Multiway_Trees   
A.18.10(48/3), A.18.10(49/3), A.18.10(50/3) 
Insert_Space    in Ada.Containers.Vectors   
A.18.2(48/2), A.18.2(49/2) 
inspectable object   H.3.2(5/2) inspection point   H.3.2(5/2) Inspection_Point pragma   H.3.2(3), L(16) instance    of a generic function   12.3(13)    of a generic package   12.3(13)    of a generic procedure   12.3(13)    of a generic subprogram   12.3(13)    of a generic unit   12.3(1) instructions for comment submission   
0.2(58/1) 
int    in Interfaces.C   B.3(7) 
Integer   3.5.4(11), 3.5.4(21)    in Standard   A.1(12) 
integer literal   2.4(1) integer literals   3.5.4(14), 3.5.4(30) integer type   3.5.4(1), N(21) Integer_Address    in System.Storage_Elements   
13.7.1(10/3) 
Integer_IO    in Ada.Text_IO   A.10.1(52) 
Integer_Text_IO    child of  Ada   A.10.8(21) 
integer_type_definition   3.5.4(2)    used   3.2.1(4/2), P 
Integer_Wide_Text_IO    child of  Ada   A.11(2/2) 
Integer_Wide_Wide_Text_IO    child of  Ada   A.11(3/2) 
interaction    between tasks   9(1/3) interface   3.9.4(4/2)    limited   3.9.4(5/2)    nonlimited   3.9.4(5/2) 
   protected   3.9.4(5/2)    synchronized   3.9.4(5/2)    task   3.9.4(5/2)    type   3.9.4(4/2) interface to assembly language   C.1(4/3) 
interface to C   B.3(1/3) interface to COBOL   B.4(1/3) interface to Fortran   B.5(1/3) interface to other languages   B(1) 
interface type   N(21.1/2) Interface_Ancestor_Tags    in Ada.Tags   3.9(7.4/2) 
interface_list   3.9.4(3/2)    used   3.4(2/2), 3.9.4(2/2), 7.3(3/3), 
9.1(2/3), 9.1(3/3), 9.4(2/3), 9.4(3/3), 12.5.1(3/2), P 
interface_type_definiti on   3.9.4(2/2) 
   used   3.2.1(4/2), 12.5.5(2/2), P 
Interfaces   B.2(3) Interfaces.C   B.3(4) Interfaces.C.Pointers   B.3.2(4) Interfaces.C.Strings   B.3.1(3) Interfaces.COBOL   B.4(7) Interfaces.Fortran   B.5(4) interfacing aspect   B.1(0.1/3) interfacing pragma   J.15.5(1/3)    Convention   J.15.5(1/3)    Export   J.15.5(1/3)    Import   J.15.5(1/3) internal call   9.5(3/3) internal code   13.4(7) internal requeue   9.5(7) Internal_Tag    in Ada.Tags   3.9(7/2) 
interpretation    of a complete context   8.6(10)    of a constituent of a complete context   
8.6(15) 
   overload resolution   8.6(14) interrupt   C.3(2)    example using asynchronous_select   
9.7.4(10), 9.7.4(12) 
interrupt entry   J.7.1(5) interrupt handler   C.3(2) Interrupt_Clocks_Supported    in Ada.Execution_Time   D.14(9.1/3) 
Interrupt_Handler aspect   C.3.1(6.2/3) Interrupt_Handler pragma   J.15.7(2/3), 
L(17.1/3) 
Interrupt_Id    in Ada.Interrupts   C.3.2(2/3) 
Interrupt_Priority aspect   D.1(6.3/3) Interrupt_Priority pragma   J.15.11(4/3), 
L(18.1/3) 
Interrupt_Priority subtype of  Any_Priority 
   in System   13.7(16) Interrupts 
   child of  Ada   C.3.2(2/3) 
   child of  Ada.Execution_Time   
D.14.3(3/3) 
Intersection    in Ada.Containers.Hashed_Sets   
A.18.8(29/2), A.18.8(30/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(30/2), A.18.9(31/2) 
intertask communication   9.5(1)    See also  task   9(1/3) 
Intrinsic calling convention   6.3.1(4) invalid cursor    of a list container   A.18.3(153/2)    of a map   A.18.4(76/2)    of a set   A.18.7(97/2)    of a tree   A.18.10(222/3)    of a vector   A.18.2(248/2) invalid representation   13.9.1(9) invariant   N(21.2/3) invariant check   7.3.2(9/3) invariant expression   7.3.2(2/3) Inverse    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(46/2) 
   in Ada.Numerics.Generic_Real_Arrays   
G.3.1(24/2) 
Inverted_Exclamation    in Ada.Characters.Latin_1   A.3.3(21/3) 
Inverted_Question    in Ada.Characters.Latin_1   A.3.3(22) 
involve an inner product    complex   G.3.2(56/2)    real   G.3.1(34/2) IO_Exceptions    child of  Ada   A.13(3) 
IS1    in Ada.Characters.Latin_1   A.3.3(16) 
IS2    in Ada.Characters.Latin_1   A.3.3(16) 
IS3    in Ada.Characters.Latin_1   A.3.3(16) 
IS4    in Ada.Characters.Latin_1   A.3.3(16) 
Is_A_Group_Member    in 
Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Is_Abstract    in Ada.Tags   3.9(7.5/3) 
Is_Alphanumeric    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(12/3) 
Is_Attached    in Ada.Interrupts   C.3.2(5) 
Is_Basic    in Ada.Characters.Handling   A.3.2(4/3) 
Is_Callable    in Ada.Task_Identification   C.7.1(4/3) 
Ada Reference Manual — 2012 Edition 
893      13 December 2012 Index Is_Character 
   in Ada.Characters.Conversions   
A.3.4(3/2) 
Is_Control    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(5/3) 
Is_Current_Directory_Name    in 
Ada.Directories.Hierarchical_File_Names   A.16.1(7/3) 
Is_Decimal_Digit    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(10/3) 
Is_Descendant_At_Same_Level    in Ada.Tags   3.9(7.1/2) 
Is_Digit    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(9/3) 
Is_Empty    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(12/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(11/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(13/2) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(10/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(16/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(10/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(12/2) 
   in Ada.Containers.Vectors   
A.18.2(23/2) 
Is_Full_Name    in 
Ada.Directories.Hierarchical_File_Names   A.16.1(8/3) 
Is_Graphic    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(19/3) 
Is_Held    in Ada.Asynchronous_Task_Control   
D.11(3/2) 
Is_Hexadecimal_Digit    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(11/3) 
Is_In    in Ada.Strings.Maps   A.4.2(13) 
   in Ada.Strings.Wide_Maps   A.4.7(13) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(13/2) 
Is_ISO_646    in Ada.Characters.Handling   A.3.2(10) Is_Leaf 
   in Ada.Containers.Multiway_Trees   
A.18.10(21/3) 
Is_Letter    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(6/3) 
Is_Line_Terminator    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(14/3) 
Is_Lower    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(7/3) 
Is_Mark    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(15/3) 
Is_Member    in 
Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Is_Nul_Terminated    in Interfaces.C   B.3(24), B.3(35), 
B.3(39.16/2), B.3(39.7/2) 
Is_Open    in Ada.Direct_IO   A.8.4(10) 
   in Ada.Sequential_IO   A.8.1(10) 
   in Ada.Streams.Stream_IO   A.12.1(12) 
   in Ada.Text_IO   A.10.1(13) 
Is_Other_Format    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(16/3) 
Is_Parent_Directory_Name    in 
Ada.Directories.Hierarchical_File_Names   A.16.1(6/3) 
Is_Punctuation_Connector    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(17/3) 
Is_Relative_Name    in 
Ada.Directories.Hierarchical_File_Names   A.16.1(9/3) 
Is_Reserved    in Ada.Interrupts   C.3.2(4) 
Is_Root    in Ada.Containers.Multiway_Trees   
A.18.10(20/3) 
Is_Root_Directory_Name    in 
Ada.Directories.Hierarchical_File_Names   A.16.1(5/3) 
Is_Round_Robin    in Ada.Dispatching.Round_Robin   
D.2.5(4/2) Is_Simple_Name 
   in 
Ada.Directories.Hierarchical_File_Names   A.16.1(4/3) 
Is_Sorted    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(48/2) 
   in Ada.Containers.Vectors   
A.18.2(76/2) 
Is_Space    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(18/3) 
Is_Special    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(13/3) 
Is_String    in Ada.Characters.Conversions   
A.3.4(3/2) 
Is_Subset    in Ada.Containers.Hashed_Sets   
A.18.8(39/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(40/2) 
   in Ada.Strings.Maps   A.4.2(14) 
   in Ada.Strings.Wide_Maps   A.4.7(14) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(14/2) 
Is_Terminated    in Ada.Task_Identification   C.7.1(4/3) 
Is_Upper    in Ada.Characters.Handling   A.3.2(4/3) 
   in Ada.Wide_Characters.Handling   
A.3.5(8/3) 
Is_Wide_Character    in Ada.Characters.Conversions   
A.3.4(3/2) 
Is_Wide_String    in Ada.Characters.Conversions   
A.3.4(3/2) 
ISO 1989:2002   1.2(4/2) ISO 639-3:2007   1.2(1.1/3) ISO 8601:2004   1.2(5.1/2) ISO/IEC 10646:2011   1.2(8/3), 
3.5.2(2/3), 3.5.2(3/3), 3.5.2(4/3) 
ISO/IEC 14882:2011   1.2(9/3) ISO/IEC 1539-1:2004   1.2(3/2) ISO/IEC 3166-1:2006   1.2(4.1/3) ISO/IEC 6429:1992   1.2(5) ISO/IEC 646:1991   1.2(2) ISO/IEC 8859-1:1998   1.2(6/3) ISO/IEC 9899:2011   1.2(7/3) ISO/IEC TR 19769:2004   1.2(10/2) ISO_646 subtype of  Character 
   in Ada.Characters.Handling   A.3.2(9) 
ISO_646_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      894 issue 
   an entry call   9.5.3(8) italics    nongraphic characters   3.5.2(2/3)    pseudo-names of anonymous types   
3.2.1(7/2), A.1(2) 
   syntax rules   1.1.4(14)    terms introduced or defined   1.3(1/2) iterable container object   5.5.1(11/3) iterable container object for a loop   
5.5.2(12/3) 
iterable container type   5.5.1(11/3), 
N(21.3/3) 
Iterate    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(45/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(37/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(49/2) 
   in Ada.Containers.Multiway_Trees   
A.18.10(42/3), A.18.10(44/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(50/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(60/2) 
   in Ada.Containers.Vectors   
A.18.2(73/2) 
   in Ada.Environment_Variables   
A.17(8/3) 
Iterate_Children    in Ada.Containers.Multiway_Trees   
A.18.10(68/3), A.18.10(70/3) 
Iterate_Subtree    in Ada.Containers.Multiway_Trees   
A.18.10(43/3), A.18.10(45/3) 
iteration cursor subtype   5.5.1(6/3) iteration_scheme   5.5(3/3)    used   5.5(2), P 
iterator   N(21.4/3)    array component   5.5.2(3/3)    container element   5.5.2(3/3)    forward   5.5.2(4/3)    generalized   5.5.2(3/3)    reverse   5.5.2(4/3) iterator object   5.5.1(6/3) iterator type   5.5.1(6/3) Iterator_Element aspect   5.5.1(9/3) Iterator_Interfaces    child of  Ada   5.5.1(2/3) 
iterator_specification   5.5.2(2/3)    used   4.5.8(1/3), 5.5(3/3), P 
 
J 
 j    in Ada.Numerics.Generic_Complex_-
Types   G.1.1(5) 
   in Interfaces.Fortran   B.5(10) 
 K 
 Key    in Ada.Containers.Hashed_Maps   
A.18.5(13/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(51/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(12/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(64/2) 
Kind    in Ada.Directories   A.16(25/2), 
A.16(40/2) 
known discriminants   3.7(26) known to be constrained   3.3(23.1/3) known to denote the same object   
6.4.1(6.4/3) 
known to refer to the same object   
6.4.1(6.11/3) 
known_discriminant_part   3.7(4)    used   3.2.1(3/3), 3.7(2/2), 9.1(2/3), 
9.4(2/3), P 
 
L 
 label   5.1(7)    used   5.1(2/3), 5.1(3), P 
Landau symbol O(X)   A.18(3/2) language    interface to assembly   C.1(4/3)    interface to non-Ada   B(1) 
   in Ada.Locales   A.19(6/3) 
Language code standard   1.2(1.1/3) language-defined categories    [partial ]   3.2(10/2) 
language-defined category    of types   3.2(2/2) language-defined check   11.5(2/3), 
11.6(1/3) 
language-defined class    [partial ]   3.2(10/2) 
   of types   3.2(2/2) Language-defined constants   Q.5(1/3) Language-defined exceptions   Q.4(1/3) Language-Defined Library Units   A(1) Language-defined objects   Q.5(1/3) Language-defined packages   Q.1(1/3) Language-defined subprograms   Q.3(1/3) Language-defined subtypes   Q.2(1/3) Language-defined types   Q.2(1/3) Language-defined values   Q.5(1/3) Language_Code    in Ada.Locales   A.19(4/3) 
Language_Unknown    in Ada.Locales   A.19(5/3) Last 
   in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(35/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(31/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(43/2) 
   in Ada.Containers.Vectors   
A.18.2(61/2) 
   in Ada.Iterator_Interfaces   5.5.1(4/3) 
Last attribute   3.5(13), 3.6.2(5) last element    of a hashed set   A.18.8(68/2)    of a set   A.18.7(6/2)    of an ordered set   A.18.9(81/3) last node    of a hashed map   A.18.5(46/2)    of a map   A.18.4(6/2)    of an ordered map   A.18.6(58/3) Last(N) attribute   3.6.2(6) last_bit   13.5.1(6)    used   13.5.1(3), P 
Last_Bit attribute   13.5.2(4/2) Last_Child    in Ada.Containers.Multiway_Trees   
A.18.10(62/3) 
Last_Child_Element    in Ada.Containers.Multiway_Trees   
A.18.10(63/3) 
Last_Element    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(36/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(32/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(44/2) 
   in Ada.Containers.Vectors   
A.18.2(62/2) 
Last_Index    in Ada.Containers.Vectors   
A.18.2(60/2) 
Last_Key    in Ada.Containers.Ordered_Maps   
A.18.6(33/2) 
Last_Valid attribute   3.5.5(7.3/3) lateness   D.9(12) Latin-1   3.5.2(2/3) Latin_1    child of  Ada.Characters   A.3.3(3) 
Layout aspect   13.5(1) Layout_Error    in Ada.IO_Exceptions   A.13(4) 
   in Ada.Text_IO   A.10.1(85) 
LC_A    in Ada.Characters.Latin_1   A.3.3(13) 
LC_A_Acute    in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Circumflex    in Ada.Characters.Latin_1   A.3.3(25) 
Ada Reference Manual — 2012 Edition 
895      13 December 2012 Index LC_A_Diaeresis 
   in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Grave    in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Ring    in Ada.Characters.Latin_1   A.3.3(25) 
LC_A_Tilde    in Ada.Characters.Latin_1   A.3.3(25) 
LC_AE_Diphthong    in Ada.Characters.Latin_1   A.3.3(25) 
LC_B    in Ada.Characters.Latin_1   A.3.3(13) 
LC_C    in Ada.Characters.Latin_1   A.3.3(13) 
LC_C_Cedilla    in Ada.Characters.Latin_1   A.3.3(25) 
LC_D    in Ada.Characters.Latin_1   A.3.3(13) 
LC_E    in Ada.Characters.Latin_1   A.3.3(13) 
LC_E_Acute    in Ada.Characters.Latin_1   A.3.3(25) 
LC_E_Circumflex    in Ada.Characters.Latin_1   A.3.3(25) 
LC_E_Diaeresis    in Ada.Characters.Latin_1   A.3.3(25) 
LC_E_Grave    in Ada.Characters.Latin_1   A.3.3(25) 
LC_F    in Ada.Characters.Latin_1   A.3.3(13) 
LC_G    in Ada.Characters.Latin_1   A.3.3(13) 
LC_German_Sharp_S    in Ada.Characters.Latin_1   A.3.3(24) 
LC_H    in Ada.Characters.Latin_1   A.3.3(13) 
LC_I    in Ada.Characters.Latin_1   A.3.3(13) 
LC_I_Acute    in Ada.Characters.Latin_1   A.3.3(25) 
LC_I_Circumflex    in Ada.Characters.Latin_1   A.3.3(25) 
LC_I_Diaeresis    in Ada.Characters.Latin_1   A.3.3(25) 
LC_I_Grave    in Ada.Characters.Latin_1   A.3.3(25) 
LC_Icelandic_Eth    in Ada.Characters.Latin_1   A.3.3(26) 
LC_Icelandic_Thorn    in Ada.Characters.Latin_1   A.3.3(26) 
LC_J    in Ada.Characters.Latin_1   A.3.3(13) 
LC_K    in Ada.Characters.Latin_1   A.3.3(13) 
LC_L    in Ada.Characters.Latin_1   A.3.3(13) 
LC_M    in Ada.Characters.Latin_1   A.3.3(13) 
LC_N    in Ada.Characters.Latin_1   A.3.3(13) LC_N_Tilde 
   in Ada.Characters.Latin_1   A.3.3(26) 
LC_O    in Ada.Characters.Latin_1   A.3.3(13) 
LC_O_Acute    in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Circumflex    in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Diaeresis    in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Grave    in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Oblique_Stroke    in Ada.Characters.Latin_1   A.3.3(26) 
LC_O_Tilde    in Ada.Characters.Latin_1   A.3.3(26) 
LC_P    in Ada.Characters.Latin_1   A.3.3(14) 
LC_Q    in Ada.Characters.Latin_1   A.3.3(14) 
LC_R    in Ada.Characters.Latin_1   A.3.3(14) 
LC_S    in Ada.Characters.Latin_1   A.3.3(14) 
LC_T    in Ada.Characters.Latin_1   A.3.3(14) 
LC_U    in Ada.Characters.Latin_1   A.3.3(14) 
LC_U_Acute    in Ada.Characters.Latin_1   A.3.3(26) 
LC_U_Circumflex    in Ada.Characters.Latin_1   A.3.3(26) 
LC_U_Diaeresis    in Ada.Characters.Latin_1   A.3.3(26) 
LC_U_Grave    in Ada.Characters.Latin_1   A.3.3(26) 
LC_V    in Ada.Characters.Latin_1   A.3.3(14) 
LC_W    in Ada.Characters.Latin_1   A.3.3(14) 
LC_X    in Ada.Characters.Latin_1   A.3.3(14) 
LC_Y    in Ada.Characters.Latin_1   A.3.3(14) 
LC_Y_Acute    in Ada.Characters.Latin_1   A.3.3(26) 
LC_Y_Diaeresis    in Ada.Characters.Latin_1   A.3.3(26) 
LC_Z    in Ada.Characters.Latin_1   A.3.3(14) 
Leading_Nonseparate    in Interfaces.COBOL   B.4(23) 
Leading_Part attribute   A.5.3(54) Leading_Separate    in Interfaces.COBOL   B.4(23) 
leaf node    of a tree   A.18.10(4/3) Leap_Seconds_Count subtype of  Integer 
   in Ada.Calendar.Arithmetic   9.6.1(11/2) 
leaving   7.6.1(3/2) left   7.6.1(3/2) 
left parenthesis   2.1(15/3) Left_Angle_Quotation    in Ada.Characters.Latin_1   A.3.3(21/3) 
Left_Curly_Bracket    in Ada.Characters.Latin_1   A.3.3(14) 
Left_Parenthesis    in Ada.Characters.Latin_1   A.3.3(8) 
Left_Square_Bracket    in Ada.Characters.Latin_1   A.3.3(12) 
legal    construct   1.1.2(27)    partition   1.1.2(29) legality rules   1.1.2(27) length    of a dimension of an array   3.6(13)    of a list container   A.18.3(3/2)    of a map   A.18.4(5/2)    of a one-dimensional array   3.6(13)    of a set   A.18.7(5/2)    of a vector container   A.18.2(2/2)    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(11/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(10/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(12/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(9/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(11/2) 
   in Ada.Containers.Vectors   
A.18.2(21/2) 
   in Ada.Strings.Bounded   A.4.4(9) 
   in Ada.Strings.Unbounded   A.4.5(6) 
   in Ada.Text_IO.Editing   F.3.3(11) 
   in Interfaces.COBOL   B.4(34), B.4(39), 
B.4(44) 
Length attribute   3.6.2(9) Length(N) attribute   3.6.2(10) Length_Check   11.5(15)    [partial ]   4.5.1(8), 4.6(37), 4.6(52) 
Length_Error    in Ada.Strings   A.4.1(5) 
Length_Range subtype of  Natural 
   in Ada.Strings.Bounded   A.4.4(8) 
less than operator   4.4(1/3), 4.5.2(1) less than or equal operator   4.4(1/3), 
4.5.2(1) 
less-than sign   2.1(15/3) Less_Case_Insensitive    child of  Ada.Strings   A.4.10(13/3) 
   child of  Ada.Strings.Bounded   
A.4.10(18/3) 
   child of  Ada.Strings.Fixed   
A.4.10(16/3) 
   child of  Ada.Strings.Unbounded   
A.4.10(21/3) 
Less_Than_Sign    in Ada.Characters.Latin_1   A.3.3(10) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      896 letter 
   a category of Character   A.3.2(24) letter_lowercase   2.1(9/2)    used   2.3(3/2), P 
letter_modifier   2.1(9.2/2)    used   2.3(3/2), P 
letter_other   2.1(9.3/2)    used   2.3(3/2), P 
Letter_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
letter_titlecase   2.1(9.1/2)    used   2.3(3/2), P 
letter_uppercase   2.1(8/2)    used   2.3(3/2), P 
level    accessibility   3.10.2(3/2)    library   3.10.2(22) lexical element   2.2(1) lexicographic order   4.5.2(26/3) LF    in Ada.Characters.Latin_1   A.3.3(5) 
library   10.1.4(9)    [partial ]   10.1.1(9) 
   informal introduction   10(2)    See also  library level, library unit, 
library_item 
library level   3.10.2(22) Library unit   10.1(3), 10.1.1(9), N(22)    informal introduction   10(2)    See also  language-defined library units 
library unit pragma   10.1.5(7/3)    All_Calls_Remote   E.2.3(6)    categorization pragmas   E.2(2/3)    Elaborate_Body   10.2.1(24)    Preelaborate   10.2.1(4)    Pure   10.2.1(15) library_item   10.1.1(4)    informal introduction   10(2)    used   10.1.1(3), P 
library_unit_body   10.1.1(7)    used   10.1.1(4), P 
library_unit_declaration   10.1.1(5)    used   10.1.1(4), P 
library_unit_renaming_declaration   
10.1.1(6) 
   used   10.1.1(4), P 
lifetime   3.10.2(3/2) limited interface   3.9.4(5/2) limited type   7.5(3/3), N(23/2)    becoming nonlimited   7.3.1(5/1), 
7.5(16) 
   immutably   7.5(8.1/3) limited view   10.1.1(12.1/2) Limited_Controlled    in Ada.Finalization   7.6(7/2) 
limited_with_clause   10.1.2(4.1/2)    used   10.1.2(4/2), P 
line   2.2(2/3)    in Ada.Text_IO   A.10.1(38) line terminator   A.10(7) 
Line_Length    in Ada.Text_IO   A.10.1(25) 
link name   B.1(35) link-time error    See post-compilation error   1.1.2(29) 
   See post-compilation error   1.1.5(4) 
Link_Name aspect   B.1(1/3) Linker_Options pragma   B.1(8), L(19) linking    See partition building   10.2(2) 
List    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(6/3) 
list container   A.18.3(1/2) List pragma   2.8(21), L(20) List_Iterator_Interfaces    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(9.2/3) 
literal   4.2(1)    based   2.4.2(1)    decimal   2.4.1(1)    numeric   2.4(1)    See also  aggregate   4.3(1) 
little endian   13.5.3(2) load time   C.4(3) local to   8.1(14) local_name   13.1(3)    used   13.3(2), 13.4(2), 13.5.1(2), 
13.5.1(3), C.5(3), J.15.2(2/3), J.15.3(2/3), J.15.5(2/3), J.15.5(3/3), J.15.5(4/3), J.15.6(2/3), J.15.8(2/3), J.15.8(3/3), J.15.8(4/3), J.15.8(5/3), J.15.8(6/3), J.15.8(7/3), J.15.13(2/3), L(3.1/3), L(4.1/3), L(5.1/3), L(8.1/3), L(9), L(13.1/3), L(14.1/3), L(14.2/3), L(14.3/3), L(21.2/3), L(24.1/3), L(37.2/3), L(38.1/3), L(39.1/3), P 
locale   A.19(1/3)    active   A.19(8/3) Locales    child of  Ada   A.19(3/3) 
locking policy   D.3(6/2)    Ceiling_Locking   D.3(7) Locking_Policy pragma   D.3(3), L(21) Log    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(3) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(4) 
Logical    in Interfaces.Fortran   B.5(7) 
logical operator   4.5.1(2)    See also  not operator   4.5.6(3) 
logical_operator   4.5(2) long    in Interfaces.C   B.3(7) 
Long_Binary    in Interfaces.COBOL   B.4(10) long_double 
   in Interfaces.C   B.3(17) 
Long_Float   3.5.7(15), 3.5.7(16), 
3.5.7(17) 
Long_Floating    in Interfaces.COBOL   B.4(9) 
Long_Integer   3.5.4(22), 3.5.4(25), 
3.5.4(28) 
Look_Ahead    in Ada.Text_IO   A.10.1(43) 
loop cursor   5.5.2(12/3) loop iterator   5.5.2(10/3)    container element iterator   5.5.2(12/3) loop parameter   5.5(6), 5.5.2(7/3) loop_parameter_specification   5.5(4)    used   4.5.8(1/3), 5.5(3/3), P 
loop_statement   5.5(2)    used   5.1(5/2), P 
low line   2.1(15/3) low-level programming   C(1) Low_Line    in Ada.Characters.Latin_1   A.3.3(12) 
Low_Order_First   13.5.3(2)    in Interfaces.COBOL   B.4(25) 
   in System   13.7(15/2) 
lower bound    of a range   3.5(4) lower-case letter    a category of Character   A.3.2(25) Lower_Case_Map    in Ada.Strings.Maps.Constants   
A.4.6(5) 
Lower_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
 
M 
 Machine attribute   A.5.3(60) machine code insertion   13.8(1), C.1(2) machine numbers    of a fixed point type   3.5.9(8/2)    of a floating point type   3.5.7(8) machine scalar   13.3(8.1/3) Machine_Code    child of  System   13.8(7) 
Machine_Emax attribute   A.5.3(8) Machine_Emin attribute   A.5.3(7) Machine_Mantissa attribute   A.5.3(6) Machine_Overflows attribute   A.5.3(12), 
A.5.4(4) 
Machine_Radix aspect   F.1(1) Machine_Radix attribute   A.5.3(2), 
A.5.4(2) 
Machine_Radix clause   13.3(7/2), F.1(1) Machine_Rounding attribute   
A.5.3(41.1/2) 
Machine_Rounds attribute   A.5.3(11), 
A.5.4(3) 
Ada Reference Manual — 2012 Edition 
897      13 December 2012 Index macro 
   See generic unit   12(1) 
Macron    in Ada.Characters.Latin_1   A.3.3(21/3) 
main subprogram    for a partition   10.2(7) malloc    See allocator   4.8(1) 
Map    in Ada.Containers.Hashed_Maps   
A.18.5(3/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(4/3) 
map container   A.18.4(1/2) Map_Iterator_Interfaces    in Ada.Containers.Hashed_Maps   
A.18.5(6.2/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(7.2/3) 
Maps    child of  Ada.Strings   A.4.2(3/2) 
mark_non_spacing   2.1(9.4/2), 2.1(9.5/2)    used   2.3(3.1/3), P 
mark_spacing_combining    used   2.3(3.1/3), P 
marshalling   E.4(9) Masculine_Ordinal_Indicator    in Ada.Characters.Latin_1   A.3.3(22) 
master   7.6.1(3/2) master of a call   3.10.2(10.1/3) match    a character to a pattern character   
A.4.2(54) 
   a character to a pattern character, with 
respect to a character mapping function   A.4.2(64) 
   a string to a pattern string   A.4.2(54) matching components   4.5.2(16) Max attribute   3.5(19) Max_Alignment_For_Allocation 
attribute   13.11.1(4/3) 
Max_Asynchronous_Select_Nesting 
restriction   D.7(18/1) 
Max_Base_Digits   3.5.7(6)    in System   13.7(8) 
Max_Binary_Modulus   3.5.4(7)    in System   13.7(7) 
Max_Decimal_Digits    in Ada.Decimal   F.2(5) 
Max_Delta    in Ada.Decimal   F.2(4) 
Max_Digits   3.5.7(6)    in System   13.7(8) 
Max_Digits_Binary    in Interfaces.COBOL   B.4(11) 
Max_Digits_Long_Binary    in Interfaces.COBOL   B.4(11) 
Max_Entry_Queue_Length restriction   
D.7(19.1/2) Max_Image_Width 
   in Ada.Numerics.Discrete_Random   
A.5.2(25) 
   in Ada.Numerics.Float_Random   
A.5.2(13) 
Max_Int   3.5.4(14)    in System   13.7(6) 
Max_Length    in Ada.Strings.Bounded   A.4.4(5) 
Max_Mantissa    in System   13.7(9) 
Max_Nonbinary_Modulus   3.5.4(7)    in System   13.7(7) 
Max_Picture_Length    in Ada.Text_IO.Editing   F.3.3(8) 
Max_Protected_Entries restriction   
D.7(14) 
Max_Scale    in Ada.Decimal   F.2(3) 
Max_Select_Alternatives restriction   
D.7(12) 
Max_Size_In_Storage_Elements 
attribute   13.11.1(3/3) 
Max_Storage_At_Blocking restriction   
D.7(17/1) 
Max_Task_Entries restriction   D.7(13) Max_Tasks restriction   D.7(19/1) maximum box error    for a component of the result of 
evaluating a complex function   G.2.6(3) 
maximum line length   A.10(11) maximum page length   A.10(11) maximum relative error    for a component of the result of 
evaluating a complex function   G.2.6(3) 
   for the evaluation of an elementary 
function   G.2.4(2) 
Members    in 
Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Membership    in Ada.Strings   A.4.1(6) 
membership test   4.5.2(2/3) membership_choice   4.4(3.2/3)    used   4.4(3.1/3), P 
membership_choice_list   4.4(3.1/3)    used   4.4(3/3), P 
Memory_Size    in System   13.7(13) 
mentioned    in a with_clause   10.1.2(6/2) Merge    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(50/2) 
   in Ada.Containers.Vectors   
A.18.2(78/2) message 
   See dispatching call   3.9.2(1/2) 
method    See dispatching subprogram   3.9.2(1/2) 
metrics   1.1.2(35) Micro_Sign    in Ada.Characters.Latin_1   A.3.3(22) 
Microseconds    in Ada.Real_Time   D.8(14/2) 
Middle_Dot    in Ada.Characters.Latin_1   A.3.3(22) 
Milliseconds    in Ada.Real_Time   D.8(14/2) 
Min attribute   3.5(16) Min_Delta    in Ada.Decimal   F.2(4) 
Min_Handler_Ceiling    in 
Ada.Execution_Time.Group_Budgets   D.14.2(7/2) 
   in Ada.Execution_Time.Timers   
D.14.1(6/2) 
Min_Int   3.5.4(14)    in System   13.7(6) 
Min_Scale    in Ada.Decimal   F.2(3) 
minus   2.1(15/3) minus operator   4.4(1/3), 4.5.3(1), 
4.5.4(1) 
Minus_Sign    in Ada.Characters.Latin_1   A.3.3(8) 
Minute    in Ada.Calendar.Formatting   
9.6.1(25/2) 
Minute_Number subtype of  Natural 
   in Ada.Calendar.Formatting   
9.6.1(20/2) 
Minutes    in Ada.Real_Time   D.8(14/2) 
mixed-language programs   B(1), C.1(4/3) Mod attribute   3.5.4(16.1/2) mod operator   4.4(1/3), 4.5.5(1) mod_clause   J.8(1)    used   13.5.1(2), P 
mode   6.1(16)    used   6.1(15/3), 12.4(2/3), P 
   in Ada.Direct_IO   A.8.4(9) 
   in Ada.Sequential_IO   A.8.1(9) 
   in Ada.Streams.Stream_IO   A.12.1(11) 
   in Ada.Text_IO   A.10.1(12) 
mode conformance   6.3.1(16/3)    required   8.5.4(4/3), 8.5.4(5/3), 
12.6(7/3), 12.6(8/3), 13.3(6) 
mode of operation    nonstandard   1.1.5(11)    standard   1.1.5(11) Mode_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      898    in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
Model attribute   A.5.3(68), G.2.2(7) model interval   G.2.1(4)    associated with a value   G.2.1(4) model number   G.2.1(3) model-oriented attributes    of a floating point subtype   A.5.3(63) Model_Emin attribute   A.5.3(65), 
G.2.2(4) 
Model_Epsilon attribute   A.5.3(66) Model_Mantissa attribute   A.5.3(64), 
G.2.2(3/2) 
Model_Small attribute   A.5.3(67) Modification_Time    in Ada.Directories   A.16(27/2), 
A.16(42/2) 
modular type   3.5.4(1) Modular_IO    in Ada.Text_IO   A.10.1(57) 
modular_type_definition   3.5.4(4)    used   3.5.4(2), P 
module    See package   7(1) 
modulus    of a modular type   3.5.4(7)    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(10/2), G.3.2(30/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(9) 
Modulus attribute   3.5.4(17) Monday    in Ada.Calendar.Formatting   
9.6.1(17/2) 
Month    in Ada.Calendar   9.6(13) 
   in Ada.Calendar.Formatting   
9.6.1(22/2) 
Month_Number subtype of  Integer 
   in Ada.Calendar   9.6(11/2) 
More_Entries    in Ada.Directories   A.16(34/2) 
Move    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(18/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(18/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(18/2) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(22/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(34/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(17/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(17/2) 
   in Ada.Containers.Vectors   
A.18.2(35/2) 
   in Ada.Strings.Fixed   A.4.3(7) multi-dimensional array   3.6(12) 
Multiplication_Sign    in Ada.Characters.Latin_1   A.3.3(24) 
multiply   2.1(15/3) multiply operator   4.4(1/3), 4.5.5(1) multiplying operator   4.5.5(1) multiplying_operator   4.5(6)    used   4.4(5), P 
Multiprocessors    child of  System   D.16(3/3) 
Multiway_Trees    child of  Ada.Containers   A.18.10(7/3) 
mutates   7.6(17.6/3) MW    in Ada.Characters.Latin_1   A.3.3(18) 
 
N 
 n-dimensional array_aggregate   4.3.3(6) NAK    in Ada.Characters.Latin_1   A.3.3(6) 
name   4.1(2/3)    [partial ]   3.1(1) 
   of (a view of) an entity   3.1(8)    of a pragma   2.8(9)    of an external file   A.7(1)    used   2.8(3/3), 3.2.2(4), 4.1(4), 4.1(5), 
4.1(6), 4.1.5(4/3), 4.4(7/3), 4.6(2), 4.8(2.1/3), 5.2(2), 5.5.2(2/3), 5.7(2), 5.8(2), 6.4(2), 6.4(3), 6.4(6), 8.4(3), 8.5.1(2/3), 8.5.2(2/3), 8.5.3(2/3), 8.5.4(2/3), 8.5.5(2/3), 9.5.3(2), 9.5.4(2/3), 9.8(2), 10.1.1(8), 10.1.2(4.1/2), 10.1.2(4.2/2), 10.2.1(3), 10.2.1(14), 10.2.1(20), 10.2.1(21), 10.2.1(22), 11.2(5), 11.3(2/2), 12.3(2/3), 12.3(5), 12.6(4), 12.7(2/3), 13.1(3), 13.1.1(4/3), 13.3(2), 13.11.3(3.1/3), 13.12(4.1/2), E.2.1(3), E.2.2(3), E.2.3(3), E.2.3(5), H.3.2(3), J.10(3/2), J.15.1(2/3), J.15.7(2/3), J.15.7(4/3), L(2), L(6.1/3), L(10), L(11), L(12), L(15.1/3), L(16), L(17.1/3), L(26), L(28), L(30), L(31), L(34), P 
   in Ada.Direct_IO   A.8.4(9) 
   in Ada.Sequential_IO   A.8.1(9) 
   in Ada.Streams.Stream_IO   A.12.1(11) 
   in Ada.Text_IO   A.10.1(12) 
   in System   13.7(4) 
name resolution rules   1.1.2(26/3) Name_Case_Equivalence    in Ada.Directories   A.16(20.2/3) 
Name_Case_Kind    in Ada.Directories   A.16(20.1/3) 
Name_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.Directories   A.16(43/2) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15)    in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
named    in a use clause   8.4(7.1/2)    in a with_clause   10.1.2(6/2) named association   6.4(7), 6.4.1(2/3), 
12.3(6) 
named component association   4.3.1(6) named discriminant association   3.7.1(4) named entry index   9.5.2(21) named number   3.3(24) named parameter association   6.4.1(2/3) named type   3.2.1(7/2) named_array_aggregate   4.3.3(4)    used   4.3.3(2), P 
Names    child of  Ada.Interrupts   C.3.2(12) 
Nanoseconds    in Ada.Real_Time   D.8(14/2) 
Native_Binary    in Interfaces.COBOL   B.4(25) 
Natural   3.5.4(12) Natural subtype of  Integer 
   in Standard   A.1(13) 
NBH    in Ada.Characters.Latin_1   A.3.3(17) 
NBSP    in Ada.Characters.Latin_1   A.3.3(21/3) 
needed    of a compilation unit by another   
10.2(2) 
   remote call interface   E.2.3(18)    shared passive library unit   E.2.1(11) needed component    extension_aggregate 
record_component_association_list   4.3.2(6) 
   record_aggregate 
record_component_association_list   4.3.1(9) 
needs finalization   7.6(9.1/2)    language-defined type   A.4.5(72.1/2), 
A.5.2(15.1/2), A.5.2(27.1/2), A.8.1(17/2), A.8.4(20/2), A.10.1(86/2), A.12.1(27.1/2), A.16(102/2), A.18.2(147.3/3), A.18.2(84/2), A.18.3(56/2), A.18.3(86.3/3), A.18.4(4/2), A.18.4(41.3/3), A.18.7(4/2), A.18.7(36.2/3), A.18.7(96.2/3), A.18.10(124/3), A.18.10(73/3), A.18.18(27/3), A.18.18(54/3), D.14.2(13/2), D.15(8/2) 
NEL    in Ada.Characters.Latin_1   A.3.3(17) 
new    See allocator   4.8(1) 
New_Char_Array    in Interfaces.C.Strings   B.3.1(9) 
Ada Reference Manual — 2012 Edition 
899      13 December 2012 Index New_Line 
   in Ada.Text_IO   A.10.1(28) 
New_Page    in Ada.Text_IO   A.10.1(31) 
New_String    in Interfaces.C.Strings   B.3.1(10) 
Next    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(37/2), A.18.3(39/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(28/2), A.18.5(29/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(41/2), A.18.8(42/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(34/2), A.18.6(35/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(45/2), A.18.9(46/2) 
   in Ada.Containers.Vectors   
A.18.2(63/2), A.18.2(64/2) 
   in Ada.Iterator_Interfaces   5.5.1(3/3) 
Next_Sibling    in Ada.Containers.Multiway_Trees   
A.18.10(64/3), A.18.10(66/3) 
No_Abort_Statements restriction   
D.7(5/3) 
No_Access_Parameter_Allocators 
restriction   H.4(8.3/3) 
No_Access_Subprograms restriction   
H.4(17) 
No_Allocators restriction   H.4(7) No_Anonymous_Allocators restriction   
H.4(8.1/3) 
No_Break_Space    in Ada.Characters.Latin_1   A.3.3(21/3) 
No_Coextensions restriction   H.4(8.2/3) No_Delay restriction   H.4(21) No_Dependence restriction   13.12.1(6/2) No_Dispatch restriction   H.4(19) No_Dynamic_Attachment restriction   
D.7(10/3) 
No_Dynamic_Priorities restriction   
D.7(9/2) 
No_Element    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(9/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(6/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(6/2) 
   in Ada.Containers.Multiway_Trees   
A.18.10(11/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(7/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(7/2) 
   in Ada.Containers.Vectors   
A.18.2(11/2) 
No_Exceptions restriction   H.4(12) No_Fixed_Point restriction   H.4(15) No_Floating_Point restriction   H.4(14) No_Implementation_Aspect_Specification
s restriction   13.12.1(1.1/3) 
No_Implementation_Attributes 
restriction   13.12.1(2/2) 
No_Implementation_Identifiers 
restriction   13.12.1(2.1/3) 
No_Implementation_Pragmas restriction   
13.12.1(3/2) 
No_Implementation_Units restriction   
13.12.1(3.1/3) 
No_Implicit_Heap_Allocations 
restriction   D.7(8) 
No_Index    in Ada.Containers.Vectors   A.18.2(7/2) 
No_IO restriction   H.4(20/2) No_Local_Allocators restriction   H.4(8/1) No_Local_Protected_Objects restriction   
D.7(10.1/3) 
No_Local_Timing_Events restriction   
D.7(10.2/3) 
No_Nested_Finalization restriction   
D.7(4/3) 
No_Obsolescent_Features restriction   
13.12.1(4/3) 
No_Protected_Type_Allocators 
restriction   D.7(10.3/2) 
No_Protected_Types restriction   H.4(5) No_Recursion restriction   H.4(22) No_Reentrancy restriction   H.4(23) No_Relative_Delay restriction   
D.7(10.5/3) 
No_Requeue_Statements restriction   
D.7(10.6/3) 
No_Return aspect   6.5.1(3.2/3) No_Return pragma   J.15.2(2/3), L(21.2/3) No_Select_Statements restriction   
D.7(10.7/3) 
No_Specific_Termination_Handlers 
restriction   D.7(10.8/3) 
No_Specification_of_Aspect restriction   
13.12.1(6.1/3) 
No_Standard_Allocators_After_Elaborati
on restriction   D.7(19.2/3) 
No_Tag    in Ada.Tags   3.9(6.1/2) 
No_Task_Allocators restriction   D.7(7) No_Task_Hierarchy restriction   D.7(3/3) No_Task_Termination restriction   
D.7(15.1/2) 
No_Terminate_Alternatives restriction   
D.7(6) 
No_Unchecked_Access restriction   
H.4(18) 
No_Use_Of_Attribute restriction   
13.12.1(6.2/3) 
No_Use_Of_Pragma restriction   
13.12.1(6.3/3) 
node    of a list   A.18.3(2/2)    of a map   A.18.4(5/2)    of a tree   A.18.10(2/3) 
Node_Count    in Ada.Containers.Multiway_Trees   
A.18.10(17/3) 
nominal subtype   3.3(23/3), 3.3.1(8/2)    associated with a dereference   4.1(9/3)    associated with a type_conversion   
4.6(27) 
   associated with an indexed_component   
4.1.1(5) 
   of a component   3.6(20)    of a formal parameter   6.1(23/2)    of a function result   6.1(23/2)    of a generic formal object   12.4(9/2)    of a record component   3.8(14)    of the result of a function_call   
6.4(12/2) 
Non_Preemptive    child of  Ada.Dispatching   D.2.4(2.2/3) 
Non_Preemptive_FIFO_Within_Priorities 
task disp. policy   D.2.4(2/2) 
nonconfirming    aspect specification   13.1(18.2/3)    representation item   13.1(18.2/3)    representation value   13.1(18.2/3) nondispatching call    on a dispatching operation   3.9.2(1/2) nonexistent   13.11.2(10/2), 13.11.2(16/3) nongraphic character   3.5(27.5/2) nonlimited interface   3.9.4(5/2) nonlimited type   7.5(7)    becoming nonlimited   7.3.1(5/1), 
7.5(16) 
nonlimited_with_clause   10.1.2(4.2/2)    used   10.1.2(4/2), P 
nonnormative    See informative   1.1.2(18) 
nonreturning   6.5.1(3.2/3) nonstandard integer type   3.5.4(26) nonstandard mode   1.1.5(11) nonstandard real type   3.5.6(8) normal completion   7.6.1(2/2) normal library unit   E.2(4/3) normal state of an object   11.6(6/3), 
13.9.1(4) 
   [partial ]   9.8(21), A.13(17) 
Normalize_Scalars pragma   H.1(3), L(22) normalized exponent   A.5.3(14) normalized number   A.5.3(10) normative   1.1.2(14) not equal operator   4.4(1/3), 4.5.2(1) not in (membership test)   4.4(1/3), 
4.5.2(2/3) 
not operator   4.4(1/3), 4.5.6(3) Not_A_Specific_CPU    in System.Multiprocessors   D.16(4/3) 
Not_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
notes   1.1.2(38) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      900 notwithstanding   7.6(17.5/3), 10.1.6(6/2), 
B.1(22/3), B.1(38/3), C.3.1(19/3), E.2.1(8), E.2.1(11), E.2.3(18), H.6(7/2), J.3(6) 
   [partial ]   J.15.5(8/3) 
NUL    in Ada.Characters.Latin_1   A.3.3(5) 
   in Interfaces.C   B.3(20/1) 
null access value   4.2(9) null array   3.6.1(7) null constraint   3.2(7/2) null extension   3.9.1(4.1/2) null pointer    See null access value   4.2(9) 
null procedure   6.7(3/3) null range   3.5(4) null record   3.8(15) null slice   4.1.2(7) null string literal   2.6(6) null value    of an access type   3.10(13/2) Null_Address    in System   13.7(12) 
Null_Bounded_String    in Ada.Strings.Bounded   A.4.4(7) 
null_exclusion   3.10(5.1/2)    used   3.2.2(3/2), 3.7(5/2), 3.10(2/2), 
3.10(6/2), 6.1(13/2), 6.1(15/3), 8.5.1(2/3), 12.4(2/3), P 
Null_Id    in Ada.Exceptions   11.4.1(2/2) 
Null_Occurrence    in Ada.Exceptions   11.4.1(3/2) 
null_procedure_declaration   6.7(2/3)    used   3.1(3/3), P 
Null_Ptr    in Interfaces.C.Strings   B.3.1(7) 
Null_Set    in Ada.Strings.Maps   A.4.2(5) 
   in Ada.Strings.Wide_Maps   A.4.7(5) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(5/2) 
null_statement   5.1(6)    used   5.1(4/2), P 
Null_Task_Id    in Ada.Task_Identification   C.7.1(2/2) 
Null_Unbounded_String    in Ada.Strings.Unbounded   A.4.5(5) 
number sign   2.1(15/3) Number_Base subtype of  Integer 
   in Ada.Text_IO   A.10.1(6) 
number_decimal   2.1(10/2)    used   2.3(3.1/3), P 
number_declaration   3.3.2(2)    used   3.1(3/3), P 
number_letter   2.1(10.1/2)    used   2.3(3/2), P 
Number_Of_CPUs    in System.Multiprocessors   D.16(5/3) Number_Sign 
   in Ada.Characters.Latin_1   A.3.3(8) 
numeral   2.4.1(3)    used   2.4.1(2), 2.4.1(4), 2.4.2(3), P 
Numeric    in Interfaces.COBOL   B.4(20/3) 
numeric type   3.5(1) numeric_literal   2.4(2)    used   4.4(7/3), P 
numerics   G(1)    child of  Ada   A.5(3/2) 
 
O 
 O(f(N))   A.18(3/2) object   3.3(2), N(24)    [partial ]   3.2(1) 
object-oriented programming (OOP)    See dispatching operations of tagged 
types   3.9.2(1/2) 
   See tagged types and type extensions   
3.9(1) 
object_declaration   3.3.1(2/3)    used   3.1(3/3), P 
object_renaming_declaration   8.5.1(2/3)    used   8.5(2), P 
obsolescent feature   J(1/2) occur immediately within   8.1(13) occurrence    of an interrupt   C.3(2) octal    literal   2.4.2(1) octal literal   2.4.2(1) Old attribute   6.1.1(26/3) one's complement    modular types   3.5.4(27) one-dimensional array   3.6(12) only as a completion    entry_body   9.5.2(16) OOP (object-oriented programming)    See dispatching operations of tagged 
types   3.9.2(1/2) 
   See tagged types and type extensions   
3.9(1) 
opaque type    See private types and private 
extensions   7.3(1) 
Open    in Ada.Direct_IO   A.8.4(7) 
   in Ada.Sequential_IO   A.8.1(7) 
   in Ada.Streams.Stream_IO   A.12.1(9) 
   in Ada.Text_IO   A.10.1(10) 
open alternative   9.7.1(14) open entry   9.5.3(5)    of a protected object   9.5.3(7/3)    of a task   9.5.3(6/3) operand    of a qualified_expression   4.7(3)    of a type_conversion   4.6(3) operand interval   G.2.1(6) operand type 
   of a type_conversion   4.6(3) operates on a type   3.2.3(1/2) operational aspect   13.1(8.1/3)    specifiable attributes   13.3(5/3) operational item   13.1(1.1/1) operator   6.6(1)    &   4.4(1/3), 4.5.3(3)    *   4.4(1/3), 4.5.5(1)    **   4.4(1/3), 4.5.6(7)    +   4.4(1/3), 4.5.3(1), 4.5.4(1)    -   4.4(1/3), 4.5.3(1), 4.5.4(1)    /   4.4(1/3), 4.5.5(1)    /=   4.4(1/3), 4.5.2(1)    <   4.4(1/3), 4.5.2(1)    <=   4.4(1/3), 4.5.2(1)    =   4.4(1/3), 4.5.2(1)    >   4.4(1/3), 4.5.2(1)    >=   4.4(1/3), 4.5.2(1)    abs   4.4(1/3), 4.5.6(1)    ampersand   4.4(1/3), 4.5.3(3)    and   4.4(1/3), 4.5.1(2)    binary   4.5(9)    binary adding   4.5.3(1)    concatenation   4.4(1/3), 4.5.3(3)    divide   4.4(1/3), 4.5.5(1)    equal   4.4(1/3), 4.5.2(1)    equality   4.5.2(1)    exponentiation   4.4(1/3), 4.5.6(7)    greater than   4.4(1/3), 4.5.2(1)    greater than or equal   4.4(1/3), 4.5.2(1)    highest precedence   4.5.6(1)    less than   4.4(1/3), 4.5.2(1)    less than or equal   4.4(1/3), 4.5.2(1)    logical   4.5.1(2)    minus   4.4(1/3), 4.5.3(1), 4.5.4(1)    mod   4.4(1/3), 4.5.5(1)    multiply   4.4(1/3), 4.5.5(1)    multiplying   4.5.5(1)    not   4.4(1/3), 4.5.6(3)    not equal   4.4(1/3), 4.5.2(1)    or   4.4(1/3), 4.5.1(2)    ordering   4.5.2(1)    plus   4.4(1/3), 4.5.3(1), 4.5.4(1)    predefined   4.5(9)    relational   4.5.2(1)    rem   4.4(1/3), 4.5.5(1)    times   4.4(1/3), 4.5.5(1)    unary   4.5(9)    unary adding   4.5.4(1)    user-defined   6.6(1)    xor   4.4(1/3), 4.5.1(2) operator precedence   4.5(1) operator_symbol   6.1(9)    used   4.1(3), 4.1.3(3), 6.1(5), 6.1(11), P 
optimization   11.5(29), 11.6(1/3) Optimize pragma   2.8(23), L(23) or else (short-circuit control form)   
4.4(1/3), 4.5.1(1) 
or operator   4.4(1/3), 4.5.1(2) 
Ada Reference Manual — 2012 Edition 
901      13 December 2012 Index Ordered_Maps 
   child of  Ada.Containers   A.18.6(2/3) 
Ordered_Sets    child of  Ada.Containers   A.18.9(2/3) 
ordering operator   4.5.2(1) ordinary file   A.16(45/2) ordinary fixed point type   3.5.9(1), 
3.5.9(8/2) 
ordinary_fixed_point_definition   3.5.9(3)    used   3.5.9(2), P 
OSC    in Ada.Characters.Latin_1   A.3.3(19) 
other_control   2.1(13.1/2) other_format   2.1(10.3/2) other_private_use   2.1(13.2/2) other_surrogate   2.1(13.3/2) output   A.6(1/2) Output aspect   13.13.2(38/3) Output attribute   13.13.2(19), 13.13.2(29) Output clause   13.3(7/2), 13.13.2(38/3) overall interpretation    of a complete context   8.6(10) Overflow_Check   11.5(16)    [partial ]   3.5.4(20), 4.4(11), 
4.5.7(21/3), 5.4(13), G.2.1(11), G.2.2(7), G.2.3(25), G.2.4(2), G.2.6(3) 
Overlap    in Ada.Containers.Hashed_Sets   
A.18.8(38/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(39/2) 
Overlaps_Storage attribute   13.3(73.6/3) overload resolution   8.6(1/3) overloadable   8.3(7) overloaded   8.3(6)    enumeration literal   3.5.1(9) overloading rules   1.1.2(26/3), 8.6(2) overridable   8.3(9/1) override   8.3(9/1), 12.3(17)    a primitive subprogram   3.2.3(7/2)    when implemented by   9.1(9.2/3), 
9.4(11.1/3) 
overriding operation   N(24.1/2) overriding_indicator   8.3.1(2/2)    used   3.9.3(1.1/3), 6.1(2/3), 6.3(2/3), 
6.7(2/3), 6.8(2/3), 8.5.4(2/3), 9.5.2(2/3), 10.1.3(3/3), 12.3(2/3), P 
Overwrite    in Ada.Strings.Bounded   A.4.4(62), 
A.4.4(63) 
   in Ada.Strings.Fixed   A.4.3(27), 
A.4.3(28) 
   in Ada.Strings.Unbounded   A.4.5(57), 
A.4.5(58) 
 
P 
 Pack aspect   13.2(5.1/3) Pack pragma   J.15.3(2/3), L(24.1/3) Package   7(1), N(25) package instance   12.3(13) 
package_body   7.2(2/3)    used   3.11(6), 10.1.1(7), P 
package_body_stub   10.1.3(4)    used   10.1.3(2), P 
package_declaration   7.1(2)    used   3.1(3/3), 10.1.1(5), P 
package_renaming_declaration   
8.5.3(2/3) 
   used   8.5(2), 10.1.1(6), P 
package_specification   7.1(3/3)    used   7.1(2), 12.1(4), P 
packed   13.2(5.1/3) Packed_Decimal    in Interfaces.COBOL   B.4(12/3) 
Packed_Format    in Interfaces.COBOL   B.4(26) 
Packed_Signed    in Interfaces.COBOL   B.4(27) 
Packed_Unsigned    in Interfaces.COBOL   B.4(27) 
padding bits   13.1(7/2) Page    in Ada.Text_IO   A.10.1(39) 
Page pragma   2.8(22), L(25) page terminator   A.10(7) Page_Length    in Ada.Text_IO   A.10.1(26) 
Paragraph_Sign    in Ada.Characters.Latin_1   A.3.3(22) 
parallel processing    See task   9(1/3) 
parameter    explicitly aliased   6.1(23.1/3)    See formal parameter   6.1(17) 
   See generic formal parameter   12(1) 
   See also  discriminant   3.7(1/2) 
   See also  loop parameter   5.5(6) 
parameter assigning back   6.4.1(17) parameter copy back   6.4.1(17) parameter mode   6.1(18/3) parameter passing   6.4.1(1) parameter_and_result_profile   6.1(13/2)    used   3.10(5), 3.10(6/2), 6.1(4.2/2), P 
parameter_association   6.4(5)    used   6.4(4), P 
parameter_profile   6.1(12)    used   3.10(5), 3.10(6/2), 6.1(4.1/2), 
9.5.2(2/3), 9.5.2(3), 9.5.2(6), P 
parameter_specification   6.1(15/3)    used   6.1(14), P 
Parameterless_Handler    in Ada.Interrupts   C.3.2(2/3) 
Params_Stream_Type    in System.RPC   E.5(6) 
parent   N(25.1/2)    in Ada.Containers.Multiway_Trees   
A.18.10(59/3) 
parent body    of a subunit   10.1.3(8/2) parent declaration 
   of a library unit   10.1.1(10)    of a library_item   10.1.1(10) parent subtype   3.4(3/2) parent type   3.4(3/2) parent unit    of a library unit   10.1.1(10) Parent_Tag    in Ada.Tags   3.9(7.2/2) 
parent_unit_name   10.1.1(8)    used   6.1(5), 6.1(7), 7.1(3/3), 7.2(2/3), 
10.1.3(7), P 
part    of a type   3.2(6/2)    of an object or value   3.2(6/2) partial view    of a type   7.3(4) partition   10.2(2), N(26) partition building   10.2(2) partition communication subsystem 
(PCS)   E.5(1/2) 
Partition_Check    [partial ]   E.4(19) 
Partition_Elaboration_Policy pragma   
H.6(3/2), L(25.1/2) 
Partition_Id    in System.RPC   E.5(4) 
Partition_Id attribute   E.1(9) pass by copy   6.2(2) pass by reference   6.2(2) passive partition   E.1(2) Pattern_Error    in Ada.Strings   A.4.1(5) 
PCS (partition communication 
subsystem)   E.5(1/2) 
Peak_Use    in 
Ada.Containers.Bounded_Priority_Queues   A.18.31(7/3) 
   in 
Ada.Containers.Bounded_Synchronized_Queues   A.18.29(6/3) 
   in 
Ada.Containers.Synchronized_Queue_Interfaces   A.18.27(7/3) 
   in 
Ada.Containers.Unbounded_Priority_Queues   A.18.30(7/3) 
   in 
Ada.Containers.Unbounded_Synchronized_Queues   A.18.28(6/3) 
pending interrupt occurrence   C.3(2) per-object constraint   3.8(18/2) per-object expression   3.8(18/2) percent sign   2.1(15/3) Percent_Sign    in Ada.Characters.Latin_1   A.3.3(8) 
perfect result set   G.2.3(5) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      902 periodic task 
   example   9.6(39)    See delay_until_statement   9.6(39) 
Pi    in Ada.Numerics   A.5(3/2) 
Pic_String    in Ada.Text_IO.Editing   F.3.3(7) 
Picture    in Ada.Text_IO.Editing   F.3.3(4) 
picture String    for edited output   F.3.1(1/3) Picture_Error    in Ada.Text_IO.Editing   F.3.3(9) 
Pilcrow_Sign    in Ada.Characters.Latin_1   A.3.3(22) 
plain_char    in Interfaces.C   B.3(11) 
plane    character   2.1(1/3) PLD    in Ada.Characters.Latin_1   A.3.3(17) 
PLU    in Ada.Characters.Latin_1   A.3.3(17) 
plus operator   4.4(1/3), 4.5.3(1), 4.5.4(1) plus sign   2.1(15/3) Plus_Minus_Sign    in Ada.Characters.Latin_1   A.3.3(22) 
Plus_Sign    in Ada.Characters.Latin_1   A.3.3(8) 
PM    in Ada.Characters.Latin_1   A.3.3(19) 
point   2.1(15/3) Pointer    in Interfaces.C.Pointers   B.3.2(5) 
   See access value   3.10(1) 
   See type System.Address   13.7(34/2) 
pointer type    See access type   3.10(1) 
Pointer_Error    in Interfaces.C.Pointers   B.3.2(8) 
Pointers    child of  Interfaces.C   B.3.2(4) 
polymorphism   3.9(1), 3.9.2(1/2) pool    default   13.11.3(4.1/3)    subpool   13.11.4(18/3) pool element   3.10(7/1), 13.11(11) pool type   13.11(11) pool-specific access type   3.10(7/1), 
3.10(8) 
Pool_of_Subpool    in System.Storage_Pools.Subpools   
13.11.4(9/3) 
Pos attribute   3.5.5(2) position   13.5.1(4)    used   13.5.1(3), P 
Position attribute   13.5.2(2/2) position number   3.5(1)    of an enumeration value   3.5.1(7)    of an integer value   3.5.4(15) positional association   6.4(7), 6.4.1(2/3), 
12.3(6) 
positional component association   
4.3.1(6) 
positional discriminant association   
3.7.1(4) 
positional parameter association   
6.4.1(2/3) 
positional_array_aggregate   4.3.3(3/2)    used   4.3.3(2), P 
Positive   3.5.4(12) Positive subtype of  Integer 
   in Standard   A.1(13) 
Positive_Count subtype of  Count 
   in Ada.Direct_IO   A.8.4(4) 
   in Ada.Streams.Stream_IO   A.12.1(7) 
   in Ada.Text_IO   A.10.1(5) 
possible interpretation   8.6(14)    for direct_names   8.3(24)    for selector_names   8.3(24) Post aspect   6.1.1(4/3) Post'Class aspect   6.1.1(5/3) post-compilation error   1.1.2(29) post-compilation rules   1.1.2(29) postcondition   N(26.1/3) postcondition check   6.1.1(35/3) postcondition expression    class-wide   6.1.1(5/3)    specific   6.1.1(4/3) potentially blocking operation   9.5.1(8)    Abort_Task   C.7.1(16)    delay_statement   9.6(34), D.9(5)    remote subprogram call   E.4(17)    RPC operations   E.5(23)    Suspend_Until_True   D.10(10) potentially unevaluated expression   
6.1.1(20/3) 
potentially use-visible   8.4(8/3)    [partial ]   12.6(9.2/3) 
Pound_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
Pragma   2.8(1), 2.8(2), L(1), N(27) pragma argument   2.8(9) pragma name   2.8(9) pragma, categorization   E.2(2/3)    Remote_Call_Interface   E.2.3(2)    Remote_Types   E.2.2(2)    Shared_Passive   E.2.1(2) pragma, configuration   10.1.5(8)    Assertion_Policy   11.4.2(7/3)    Detect_Blocking   H.5(4/2)    Discard_Names   C.5(4)    Locking_Policy   D.3(5)    Normalize_Scalars   H.1(4)    Partition_Elaboration_Policy   H.6(5/2)    Priority_Specific_Dispatching   
D.2.2(5/2) 
   Profile   13.12(14/3)    Queuing_Policy   D.4(5)    Restrictions   13.12(8/3)    Reviewable   H.3.1(4) 
   Suppress   11.5(5/2)    Task_Dispatching_Policy   D.2.2(5/2)    Unsuppress   11.5(5/2) pragma, identifier specific to   2.8(10/3) pragma, interfacing    Convention   J.15.5(1/3)    Export   J.15.5(1/3)    Import   J.15.5(1/3) pragma, library unit   10.1.5(7/3)    All_Calls_Remote   E.2.3(6)    categorization pragmas   E.2(2/3)    Elaborate_Body   10.2.1(24)    Preelaborate   10.2.1(4)    Pure   10.2.1(15) pragma, program unit   10.1.5(2)    Inline   J.15.1(1/3)    library unit pragmas   10.1.5(7/3) pragma, representation   13.1(1/1)    Asynchronous   J.15.13(1/3)    Atomic   J.15.8(9/3)    Atomic_Components   J.15.8(9/3)    Convention   J.15.5(1/3)    Discard_Names   C.5(6)    Export   J.15.5(1/3)    Import   J.15.5(1/3)    Independent   J.15.8(9/3)    Independent_Components   J.15.8(9/3)    No_Return   J.15.2(1/3)    Pack   J.15.3(1/3)    Unchecked_Union   J.15.6(1/3)    Volatile   J.15.8(9/3)    Volatile_Components   J.15.8(9/3) pragma_argument_association   2.8(3/3)    used   2.8(2), 13.12(11/3), L(27.3/3), P 
pragmas    All_Calls_Remote   E.2.3(5), L(2)    Assert   11.4.2(3/2), L(2.1/2)    Assertion_Policy   11.4.2(6.1/3), 
11.4.2(6/2), L(2.2/2), L(2.3/3) 
   Asynchronous   J.15.13(2/3), L(3.1/3)    Atomic   J.15.8(2/3), L(4.1/3)    Atomic_Components   J.15.8(5/3), 
L(5.1/3) 
   Attach_Handler   J.15.7(4/3), L(6.1/3)    Convention   J.15.5(4/3), L(8.1/3)    CPU   J.15.9(2/3), L(8.2/3)    Default_Storage_Pool   13.11.3(3/3), 
L(8.3/3) 
   Detect_Blocking   H.5(3/2), L(8.4/2)    Discard_Names   C.5(3), L(9)    Dispatching_Domain   J.15.10(2/3), 
L(9.1/3) 
   Elaborate   10.2.1(20), L(10)    Elaborate_All   10.2.1(21), L(11)    Elaborate_Body   10.2.1(22), L(12)    Export   J.15.5(3/3), L(13.1/3)    Import   J.15.5(2/3), L(14.1/3)    Independent   J.15.8(4/3), L(14.2/3) 
Ada Reference Manual — 2012 Edition 
903      13 December 2012 Index    Independent_Components   J.15.8(7/3), 
L(14.3/3) 
   Inline   J.15.1(2/3), L(15.1/3)    Inspection_Point   H.3.2(3), L(16)    Interrupt_Handler   J.15.7(2/3), 
L(17.1/3) 
   Interrupt_Priority   J.15.11(4/3), 
L(18.1/3) 
   Linker_Options   B.1(8), L(19)    List   2.8(21), L(20)    Locking_Policy   D.3(3), L(21)    No_Return   J.15.2(2/3), L(21.2/3)    Normalize_Scalars   H.1(3), L(22)    Optimize   2.8(23), L(23)    Pack   J.15.3(2/3), L(24.1/3)    Page   2.8(22), L(25)    Partition_Elaboration_Policy   H.6(3/2), 
L(25.1/2) 
   Preelaborable_Initialization   
10.2.1(4.2/2), L(25.2/2) 
   Preelaborate   10.2.1(3), L(26)    Priority   J.15.11(2/3), L(27.1/3)    Priority_Specific_Dispatching   
D.2.2(3.2/2), L(27.2/2) 
   Profile   13.12(11/3), L(27.3/3)    Pure   10.2.1(14), L(28)    Queuing_Policy   D.4(3), L(29)    Relative_Deadline   J.15.12(2/3), 
L(29.2/3) 
   Remote_Call_Interface   E.2.3(3), L(30)    Remote_Types   E.2.2(3), L(31)    Restrictions   13.12(3), L(32)    Reviewable   H.3.1(3), L(33)    Shared_Passive   E.2.1(3), L(34)    Storage_Size   J.15.4(2/3), L(35.1/3)    Suppress   11.5(4/2), J.10(3/2), L(36)    Task_Dispatching_Policy   D.2.2(3), 
L(37) 
   Unchecked_Union   J.15.6(2/3), 
L(37.2/3) 
   Unsuppress   11.5(4.1/2), L(37.3/2)    Volatile   J.15.8(3/3), L(38.1/3)    Volatile_Components   J.15.8(6/3), 
L(39.1/3) 
Pre aspect   6.1.1(2/3) Pre'Class aspect   6.1.1(3/3) precedence of operators   4.5(1) precondition   N(27.1/3) precondition check    class-wide   6.1.1(33/3)    specific   6.1.1(32/3) precondition expression    class-wide   6.1.1(3/3)    specific   6.1.1(2/3) Pred attribute   3.5(25) predecessor element    of an ordered set   A.18.9(81/3) predecessor node    of an ordered map   A.18.6(58/3) predefined environment   A(1) predefined exception   11.1(4) 
predefined library unit    See language-defined library units 
predefined operation    of a type   3.2.3(1/2) predefined operations    of a discrete type   3.5.5(10/3)    of a fixed point type   3.5.10(17)    of a floating point type   3.5.8(3)    of a record type   3.8(24)    of an access type   3.10.2(34/2)    of an array type   3.6.2(15) predefined operator   4.5(9)    [partial ]   3.2.1(9) 
predefined type   3.2.1(10)    See language-defined types 
predicate   4.5.8(3/3), N(27.2/3)    of a subtype   3.2.4(6/3)    used   4.5.8(1/3), P 
predicate aspect   3.2.4(1/3) predicate check    allocator   3.2.4(31/3)    enabled   3.2.4(7/3)    in out parameters   3.2.4(31/3)    object_declaration   3.2.4(31/3)    subtype conversion   4.6(51/3) predicate evaluated    membership   4.5.2(29/3)    Valid attribute   13.9.2(3/3), K.2(263/3) predicate specification   3.2.4(1/3) predicate-static   3.2.4(15/3) preelaborable    of an elaborable construct   10.2.1(5) preelaborable initialization   
10.2.1(11.1/2) 
Preelaborable_Initialization pragma   
10.2.1(4.2/2), L(25.2/2) 
Preelaborate aspect   10.2.1(11/3) Preelaborate pragma   10.2.1(3), L(26) preelaborated   10.2.1(11/3)    [partial ]   10.2.1(11/3), E.2.1(9) 
preempt    a running task   D.2.3(9/2) preference    for root numeric operators and ranges   
8.6(29) 
   for universal access equality opera tors   
8.6(29.1/3) 
preference control    See requeue   9.5.4(1) 
prefix   4.1(4)    of a prefixed view   4.1.3(9.2/3)    used   4.1.1(2), 4.1.2(2), 4.1.3(2), 
4.1.4(2), 4.1.4(4), 4.1.6(10/3), 6.4(2), 6.4(3), P 
prefixed view   4.1.3(9.2/3) prefixed view profile   6.3.1(24.1/2) Prepend 
   in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(22/2) 
   in Ada.Containers.Vectors   
A.18.2(44/2), A.18.2(45/2) 
Prepend_Child    in Ada.Containers.Multiway_Trees   
A.18.10(51/3) 
prescribed result    for the evaluation of a complex 
arithmetic operation   G.1.1(42) 
   for the evaluation of a complex 
elementary function   G.1.2(35) 
   for the evaluation of an elementary 
function   A.5.1(37) 
Previous    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(38/2), A.18.3(40/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(36/2), A.18.6(37/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(47/2), A.18.9(48/2) 
   in Ada.Containers.Vectors   
A.18.2(65/2), A.18.2(66/2) 
   in Ada.Iterator_Interfaces   5.5.1(4/3) 
Previous_Sibling    in Ada.Containers.Multiway_Trees   
A.18.10(65/3), A.18.10(67/3) 
primary   4.4(7/3)    used   4.4(6), P 
primitive function   A.5.3(17) primitive operation    [partial ]   3.2(1) 
primitive operations   N(28)    of a type   3.2.3(1/2) primitive operator    of a type   3.2.3(8) primitive subprograms    of a type   3.2.3(2) priority   D.1(15)    of a protected object   D.3(6/2) Priority aspect   D.1(6.2/3) Priority attribute   D.5.2(3/2) priority inheritance   D.1(15) priority inversion   D.2.3(11/2) priority of an entry call   D.4(9) Priority pragma   J.15.11(2/3), L(27.1/3) Priority subtype of  Any_Priority 
   in System   13.7(16) 
Priority_Queuing queuing policy   D.4(8) Priority_Specific_Dispatching pragma   
D.2.2(3.2/2), L(27.2/2) 
private declaration of a library unit   
10.1.1(12) 
private descendant    of a library unit   10.1.1(12) private extension   3.2(4.1/2), 3.9(2.1/2), 
3.9.1(1/2), N(29/2) 
   [partial ]   7.3(14), 12.5.1(5/3) 
private library unit   10.1.1(12) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      904 private operations   7.3.1(1) 
private part   8.2(5)    of a package   7.1(6/2)    of a protected unit   9.4(11/2)    of a task unit   9.1(9) private type   3.2(4.1/2), N(30/2)    [partial ]   7.3(14) 
private types and private extensions   
7.3(1) 
private_extension_declaration   7.3(3/3)    used   3.2.1(2), P 
private_type_declaration   7.3(2/3)    used   3.2.1(2), P 
procedure   6(1), N(30.1/2)    null   6.7(3/3) procedure instance   12.3(13) procedure_call_statement   6.4(2)    used   5.1(4/2), 9.7.2(3.1/2), P 
procedure_or_entry_call   9.7.2(3.1/2)    used   9.7.2(3/2), 9.7.4(4/2), P 
procedure_specification   6.1(4.1/2)    used   6.1(4/2), 6.7(2/3), P 
processing node   E(2) profile   6.1(22)    associated with a dereference   4.1(10)    fully conformant   6.3.1(18/3)    mode conformant   6.3.1(16/3)    No_Implementation_Extensions   
13.12.1(10/3) 
   subtype conformant   6.3.1(17/3)    type conformant   6.3.1(15/2) Profile pragma   13.12(11/3), L(27.3/3) profile resolution rule    name with a given expected profile   
8.6(26) 
progenitor   N(30.2/2) progenitor subtype   3.9.4(9/2) progenitor type   3.9.4(9/2) program   10.2(1), N(31) program execution   10.2(1) program library    See library   10(2) 
   See library   10.1.4(9) 
Program unit   10.1(1), N(32) program unit pragma   10.1.5(2)    Inline   J.15.1(1/3)    library unit pragmas   10.1.5(7/3) Program_Error 
   raised by failure of run-time check   
1.1.3(20), 1.1.5(8), 1.1.5(12), 3.5.5(8), 3.10.2(29), 3.11(14), 4.6(57/3), 4.8(10.1/3), 4.8(10.2/2), 4.8(10.3/2), 4.8(10.4/3), 6.2(12/3), 6.4(11/2), 6.5(8/3), 6.5(21/3), 6.5.1(9/2), 7.6.1(15), 7.6.1(16/2), 7.6.1(17), 7.6.1(17.2/1), 7.6.1(18/2), 8.5.4(8.1/1), 9.4(20), 9.5.1(17), 9.5.3(7/3), 9.7.1(21), 9.8(20/3), 10.2(26), 11.1(4), 11.5(19), 12.5.1(23.3/2), 13.7.1(16), 13.9.1(9), 13.11.2(13), 13.11.2(14), 13.11.4(27/3), 13.11.4(30/3), A.5.2(40.1/1), A.7(14/3), B.3.3(22/2), C.3.1(10/3), C.3.1(11/3), C.3.2(17/3), C.3.2(20), C.3.2(21/3), C.3.2(22/2), C.7.1(15), C.7.1(17/3), C.7.2(13), D.3(13), D.3(13.2/2), D.3(13.4/2), D.5.1(9), D.5.2(6/3), D.7(7.1/3), D.7(10.4/3), D.7(19.1/2), D.10(10), D.11(8), E.1(10/2), E.3(6), E.4(18/1), J.7.1(7) 
   in Standard   A.1(46) 
prohibited    tampering with a holder   A.18.18(35/3)    tampering with a list   A.18.3(69.1/3)    tampering with a map   A.18.4(15.1/3)    tampering with a set   A.18.7(14.1/3)    tampering with a tree   A.18.10(90/3)    tampering with a vector   A.18.2(97.1/3) propagate   11.4(1)    an exception occurrence by an 
execution, to a dynamically enclosing execution   11.4(6) 
proper_body   3.11(6)    used   3.11(5), 10.1.3(7), P 
protected action   9.5.1(4)    complete   9.5.1(6)    start   9.5.1(5) protected calling convention   6.3.1(12) protected declaration   9.4(1) protected entry   9.4(1) protected function   9.5.1(1) protected interface   3.9.4(5/2) protected object   9(3), 9.4(1) protected operation   9.4(1) protected procedure   9.5.1(1) protected subprogram   9.4(1), 9.5.1(1) protected tagged type   3.9.4(6/2) protected type   N(33/2) protected unit   9.4(1) protected_body   9.4(7/3)    used   3.11(6), P 
protected_body_stub   10.1.3(6)    used   10.1.3(2), P 
protected_definition   9.4(4)    used   9.4(2/3), 9.4(3/3), P 
protected_element_declaration   9.4(6)    used   9.4(4), P protected_operation_declaration   9.4(5/1) 
   used   9.4(4), 9.4(6), P 
protected_operation_item   9.4(8/1)    used   9.4(7/3), P 
protected_type_declaration   9.4(2/3)    used   3.2.1(3/3), P 
ptrdiff_t    in Interfaces.C   B.3(12) 
PU1    in Ada.Characters.Latin_1   A.3.3(18) 
PU2    in Ada.Characters.Latin_1   A.3.3(18) 
public declaration of a library unit   
10.1.1(12) 
public descendant    of a library unit   10.1.1(12) public library unit   10.1.1(12) punctuation_connector   2.1(10.2/2)    used   2.3(3.1/3), P 
pure   10.2.1(15.1/3) Pure aspect   10.2.1(17/3) Pure pragma   10.2.1(14), L(28) Put    in Ada.Text_IO   A.10.1(42), 
A.10.1(48), A.10.1(55), A.10.1(60), A.10.1(66), A.10.1(67), A.10.1(71), A.10.1(72), A.10.1(76), A.10.1(77), A.10.1(82), A.10.1(83) 
   in Ada.Text_IO.Bounded_IO   
A.10.11(4/2), A.10.11(5/2) 
   in Ada.Text_IO.Complex_IO   G.1.3(7), 
G.1.3(8) 
   in Ada.Text_IO.Editing   F.3.3(14), 
F.3.3(15), F.3.3(16) 
   in Ada.Text_IO.Unbounded_IO   
A.10.12(4/2), A.10.12(5/2) 
Put_Line    in Ada.Text_IO   A.10.1(50) 
   in Ada.Text_IO.Bounded_IO   
A.10.11(6/2), A.10.11(7/2) 
   in Ada.Text_IO.Unbounded_IO   
A.10.12(6/2), A.10.12(7/2) 
 
Q 
 qualified_expression   4.7(2)    used   4.1(2/3), 4.8(2/3), 13.8(2), P 
quantified expressions   4.5.8(5/3) quantified_expression   4.5.8(1/3)    used   4.4(7/3), P 
quantifier   4.5.8(2/3)    used   4.5.8(1/3), P 
Query_Element    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(16/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(16/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(17/2) 
Ada Reference Manual — 2012 Edition 
905      13 December 2012 Index    in Ada.Containers.Indefinite_Holders   
A.18.18(14/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(26/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(15/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(16/2) 
   in Ada.Containers.Vectors   
A.18.2(31/2), A.18.2(32/2) 
Question    in Ada.Characters.Latin_1   A.3.3(10) 
Queue    in 
Ada.Containers.Bounded_Priority_Queues   A.18.31(4/3) 
   in 
Ada.Containers.Bounded_Synchronized_Queues   A.18.29(4/3) 
   in 
Ada.Containers.Synchronized_Queue_Interfaces   A.18.27(4/3) 
   in 
Ada.Containers.Unbounded_Priority_Queues   A.18.30(4/3) 
   in 
Ada.Containers.Unbounded_Synchronized_Queues   A.18.28(4/3) 
queuing policy   D.4(1/3), D.4(6)    FIFO_Queuing   D.4(7/2)    Priority_Queuing   D.4(8) Queuing_Policy pragma   D.4(3), L(29) Quotation    in Ada.Characters.Latin_1   A.3.3(8) 
quotation mark   2.1(15/3) quoted string    See string_literal   2.6(1) 
 
R 
 raise    an exception   11(1/3)    an exception   11.3(4/2)    an exception   N(18)    an exception occurrence   11.4(3) Raise_Exception    in Ada.Exceptions   11.4.1(4/3) 
raise_statement   11.3(2/2)    used   5.1(4/2), P 
Random    in Ada.Numerics.Discrete_Random   
A.5.2(20) 
   in Ada.Numerics.Float_Random   
A.5.2(8) 
random number   A.5.2(1) range   3.5(3), 3.5(4)    of a scalar subtype   3.5(7)    used   3.5(2), 3.6(6), 3.6.1(3), 3.8.1(5/3), 
4.4(3.2/3), P 
Range attribute   3.5(14), 3.6.2(7) Range(N) attribute   3.6.2(8) 
range_attribute_designator   4.1.4(5)    used   4.1.4(4), P 
range_attribute_reference   4.1.4(4)    used   3.5(3), P 
Range_Check   11.5(17)    [partial ]   3.2.2(11), 3.5(24), 3.5(27), 
3.5(39.12/3), 3.5(39.4/3), 3.5(39.5/3), 3.5(43/3), 3.5(55/3), 3.5.5(7), 3.5.9(19), 4.2(11), 4.3.3(28), 4.5.1(8), 4.5.6(6), 4.5.6(13), 4.6(28), 4.6(38), 4.6(46), 4.6(51/3), 4.7(4), 13.13.2(35/3), A.5.2(39), A.5.3(26), A.5.3(29), A.5.3(50), A.5.3(53), A.5.3(59), A.5.3(62), K.2(11), K.2(114), K.2(122), K.2(184), K.2(220), K.2(241), K.2(41), K.2(47) 
range_constraint   3.5(2)    used   3.2.2(6), 3.5.9(5), J.3(2), P 
Ravenscar   D.13(1/3) RCI    generic   E.2.3(7/3)    library unit   E.2.3(7/3)    package   E.2.3(7/3) Re    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(7/2), G.3.2(27/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(6) 
re-raise statement   11.3(3) read    the value of an object   3.3(14)    in Ada.Direct_IO   A.8.4(12) 
   in Ada.Sequential_IO   A.8.1(12) 
   in Ada.Storage_IO   A.9(6) 
   in Ada.Streams   13.13.1(5) 
   in Ada.Streams.Stream_IO   A.12.1(15), 
A.12.1(16) 
   in System.RPC   E.5(7) 
Read aspect   13.13.2(38/3) Read attribute   13.13.2(6), 13.13.2(14) Read clause   13.3(7/2), 13.13.2(38/3) ready    a task state   9(10) ready queue   D.2.1(5/2) ready task   D.2.1(5/2) Real    in Interfaces.Fortran   B.5(6) 
real literal   2.4(1) real literals   3.5.6(4) real time   D.8(18) real type   3.2(3), 3.5.6(1), N(34) real-time systems   C(1), D(1) Real_Arrays    child of  Ada.Numerics   G.3.1(31/2) 
Real_Matrix    in Ada.Numerics.Generic_Real_Arrays   
G.3.1(4/2) 
real_range_specification   3.5.7(3)    used   3.5.7(2), 3.5.9(3), 3.5.9(4), P Real_Time 
   child of  Ada   D.8(3) 
real_type_definition   3.5.6(2)    used   3.2.1(4/2), P 
Real_Vector    in Ada.Numerics.Generic_Real_Arrays   
G.3.1(4/2) 
receiving stub   E.4(10) reclamation of storage   13.11.2(1) recommended level of support   13.1(20/3)    Address attribute   13.3(15)    Alignment attribute for objects   
13.3(33) 
   Alignment attribute for subtypes   
13.3(29) 
   aspect Pack   13.2(7/3)    bit ordering   13.5.3(7)    Component_Size attribute   13.3(71)    enumeration_representation_clause   
13.4(9) 
   record_representation_clause   
13.5.1(17) 
   required in Systems Programming 
Annex   C.2(2/3) 
   Size attribute   13.3(42/2), 13.3(54)    Stream_Size attribute   13.13.2(1.7/2)    unchecked conversion   13.9(16)    with respect to nonstatic expressions   
13.1(21/3) 
record   3.8(1)    explicitly limited   3.8(13.1/3) record extension   3.4(5/2), 3.9.1(1/2), 
N(35) 
Record layout aspect   13.5(1) record type   3.8(1), N(36) record_aggregate   4.3.1(2)    used   4.3(2), P 
record_component_association   4.3.1(4/2)    used   4.3.1(3), P 
record_component_association_list   
4.3.1(3) 
   used   4.3.1(2), 4.3.2(2), P 
record_definition   3.8(3)    used   3.8(2), 3.9.1(2), P 
record_extension_part   3.9.1(2)    used   3.4(2/2), P 
record_representation_clause   13.5.1(2)    used   13.1(2/1), P 
record_type_definition   3.8(2)    used   3.2.1(4/2), P 
reentrant   A(3/2) Reference    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(17.4/3) 
   in Ada.Containers.Hashed_Maps   
A.18.5(17.4/3), A.18.5(17.6/3) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(19/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(31/3) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      906    in Ada.Containers.Ordered_Maps   
A.18.6(16.4/3), A.18.6(16.6/3) 
   in Ada.Containers.Vectors   
A.18.2(34.4/3), A.18.2(34.6/3) 
   in Ada.Interrupts   C.3.2(10) 
   in Ada.Task_Attributes   C.7.2(5) 
reference discriminant   4.1.5(3/3) reference object   4.1.5(3/3) reference parameter passing   6.2(2) reference type   4.1.5(3/3), N(36.1/3) Reference_Preserving_Key    in Ada.Containers.Hashed_Sets   
A.18.8(58.2/3), A.18.8(58.4/3) 
   in Ada.Containers.Ordered_Sets   
A.18.9(73.2/3), A.18.9(73.4/3) 
Reference_Type    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(17.2/3) 
   in Ada.Containers.Hashed_Maps   
A.18.5(17.2/3) 
   in Ada.Containers.Hashed_Sets   
A.18.8(58.1/3) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(17/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(29/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(16.2/3) 
   in Ada.Containers.Ordered_Sets   
A.18.9(73.1/3) 
   in Ada.Containers.Vectors   
A.18.2(34.2/3) 
references   1.2(1/3) Registered_Trade_Mark_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
Reinitialize    in Ada.Task_Attributes   C.7.2(6) 
relation   4.4(3/3)    used   4.4(2), P 
relational operator   4.5.2(1) relational_operator   4.5(3)    used   4.4(2.2/3), 4.4(3/3), P 
Relative_Deadline aspect   D.2.6(9.2/3) Relative_Deadline pragma   J.15.12(2/3), 
L(29.2/3) 
Relative_Name    in 
Ada.Directories.Hierarchical_File_Names   A.16.1(13/3) 
relaxed mode   G.2(1) release    execution resource associated with 
protected object   9.5.1(6) 
rem operator   4.4(1/3), 4.5.5(1) Remainder attribute   A.5.3(45) remote access   E.1(5) remote access type   E.2.2(9/3) remote access-to-class-wide type   
E.2.2(9/3) remote access-to-subpr ogram type   
E.2.2(9/3) 
remote call interface   E.2(4/3), E.2.3(7/3) remote procedure call    asynchronous   E.4.1(9/3) remote subprogram   E.2.3(7/3) remote subprogram binding   E.4(1) remote subprogram call   E.4(1) remote types library unit   E.2(4/3), 
E.2.2(4/3) 
Remote_Call_Interface aspect   E.2.3(7/3) Remote_Call_Interface pragma   E.2.3(3), 
L(30) 
Remote_Types aspect   E.2.2(4/3) Remote_Types pragma   E.2.2(3), L(31) Remove_Task    in 
Ada.Execution_Time.Group_Budgets   D.14.2(8/2) 
Rename    in Ada.Directories   A.16(12/2) 
renamed entity   8.5(3) renamed view   8.5(3) renaming   N(36.2/2) renaming-as-body   8.5.4(1/3) renaming-as-declaration   8.5.4(1/3) renaming_declaration   8.5(2)    used   3.1(3/3), P 
rendezvous   9.5.2(25) Replace    in Ada.Containers.Hashed_Maps   
A.18.5(23/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(22/2), A.18.8(53/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(22/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(21/2), A.18.9(66/2) 
Replace_Element    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(15/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(15/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(16/2) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(13/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(25/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(14/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(15/2) 
   in Ada.Containers.Vectors   
A.18.2(29/2), A.18.2(30/2) 
   in Ada.Strings.Bounded   A.4.4(27) 
   in Ada.Strings.Unbounded   A.4.5(21) Replace_Slice 
   in Ada.Strings.Bounded   A.4.4(58), 
A.4.4(59) 
   in Ada.Strings.Fixed   A.4.3(23), 
A.4.3(24) 
   in Ada.Strings.Unbounded   A.4.5(53), 
A.4.5(54) 
Replenish    in 
Ada.Execution_Time.Group_Budgets   D.14.2(9/2) 
Replicate    in Ada.Strings.Bounded   A.4.4(78), 
A.4.4(79), A.4.4(80) 
representation    change of   13.6(1/3) representation aspect   13.1(8/3)    coding   13.4(7)    convention, calling convention   
B.1(1/3) 
   export   B.1(1/3)    external_name   B.1(1/3)    import   B.1(1/3)    layout   13.5(1)    link_name   B.1(1/3)    record layout   13.5(1)    specifiable attributes   13.3(5/3)    storage place   13.5(1) representation attribute   13.3(1/1) representation item   13.1(1/1) representation of an object   13.1(7/2) representation pragma   13.1(1/1)    Asynchronous   J.15.13(1/3)    Atomic   J.15.8(9/3)    Atomic_Components   J.15.8(9/3)    Convention   J.15.5(1/3)    Discard_Names   C.5(6)    Export   J.15.5(1/3)    Import   J.15.5(1/3)    Independent   J.15.8(9/3)    Independent_Components   J.15.8(9/3)    No_Return   J.15.2(1/3)    Pack   J.15.3(1/3)    Unchecked_Union   J.15.6(1/3)    Volatile   J.15.8(9/3)    Volatile_Components   J.15.8(9/3) representation-oriented attributes    of a fixed point subtype   A.5.4(1)    of a floating point subtype   A.5.3(1) representation_clause    See aspect_clause   13.1(4/1) 
represented in canonical form   A.5.3(10) requested decimal precision    of a floating point type   3.5.7(4) requeue   9.5.4(1) requeue target   9.5.4(3/3) requeue-with-abort   9.5.4(13) requeue_statement   9.5.4(2/3)    used   5.1(4/2), P 
require overriding   3.9.3(6/2) 
Ada Reference Manual — 2012 Edition 
907      13 December 2012 Index requires a completion   3.11.1(1/3), 
3.11.1(6/3) 
   declaration for which aspect 
Elaborate_Body is True   10.2.1(25/3) 
   declaration of a partial view   7.3(4)    declaration to which a pragma 
Elaborate_Body applies   10.2.1(25/3) 
   deferred constant declaration   7.4(2/3)    generic_package_declaration   7.1(5/2)    generic_subprogram_declaration   
6.1(20/3) 
   incomplete_type_declaration   
3.10.1(3/3) 
   package_declaration   7.1(5/2)    protected entry_declaration   9.5.2(16)    protected_declaration   9.4(11.2/2)    subprogram_declaration   6.1(20/3)    task_declaration   9.1(9.3/2) requires late initialization   3.3.1(8.1/2) requires overriding    [partial ]   6.1.1(16/3) 
Reraise_Occurrence    in Ada.Exceptions   11.4.1(4/3) 
Reserve_Capacity    in Ada.Containers.Hashed_Maps   
A.18.5(9/2) 
   in Ada.Containers.Hashed_Sets   
A.18.8(11/2) 
   in Ada.Containers.Vectors   
A.18.2(20/2) 
reserved interrupt   C.3(2) reserved word   2.9(2/3) Reserved_128    in Ada.Characters.Latin_1   A.3.3(17) 
Reserved_129    in Ada.Characters.Latin_1   A.3.3(17) 
Reserved_132    in Ada.Characters.Latin_1   A.3.3(17) 
Reserved_153    in Ada.Characters.Latin_1   A.3.3(19) 
Reserved_Check    [partial ]   C.3.1(10/3) 
Reset    in Ada.Direct_IO   A.8.4(8) 
   in Ada.Numerics.Discrete_Random   
A.5.2(21), A.5.2(24) 
   in Ada.Numerics.Float_Random   
A.5.2(9), A.5.2(12) 
   in Ada.Sequential_IO   A.8.1(8) 
   in Ada.Streams.Stream_IO   A.12.1(10) 
   in Ada.Text_IO   A.10.1(11) 
resolution rules   1.1.2(26/3) resolve    overload resolution   8.6(14) restriction   13.12(4/2)    used   13.12(3), L(32) 
restriction_parameter_argument   
13.12(4.1/2) 
   used   13.12(4/2), P restrictions 
   Immediate_Reclamation   H.4(10)    Max_Asynchronous_Select_Nesting   
D.7(18/1) 
   Max_Entry_Queue_Length   D.7(19.1/2)    Max_Protected_Entries   D.7(14)    Max_Select_Alternatives   D.7(12)    Max_Storage_At_Blocking   D.7(17/1)    Max_Task_Entries   D.7(13)    Max_Tasks   D.7(19/1)    No_Abort_Statements   D.7(5/3)    No_Access_Parameter_Allocators   
H.4(8.3/3) 
   No_Access_Subprograms   H.4(17)    No_Allocators   H.4(7)    No_Anonymous_Allocators   H.4(8.1/3)    No_Asynchronous_Control   J.13(3/2)    No_Coextensions   H.4(8.2/3)    No_Delay   H.4(21)    No_Dependence   13.12.1(6/2)    No_Dispatch   H.4(19)    No_Dynamic_Attachment   D.7(10/3)    No_Dynamic_Priorities   D.7(9/2)    No_Exceptions   H.4(12)    No_Fixed_Point   H.4(15)    No_Floating_Point   H.4(14)    No_Implementation_Aspect_Specificati
ons   13.12.1(1.1/3) 
   No_Implementation_Attributes   
13.12.1(2/2) 
   No_Implementation_Identifiers   
13.12.1(2.1/3) 
   No_Implementation_Pragmas   
13.12.1(3/2) 
   No_Implementation_Units   
13.12.1(3.1/3) 
   No_Implicit_Heap_Allocations   D.7(8)    No_IO   H.4(20/2)    No_Local_Allocators   H.4(8/1)    No_Local_Protected_Objects   
D.7(10.1/3) 
   No_Local_Timing_Events   D.7(10.2/3)    No_Nested_Finalization   D.7(4/3)    No_Obsolescent_Features   13.12.1(4/3)    No_Protected_Type_Allocators   
D.7(10.3/2) 
   No_Protected_Types   H.4(5)    No_Recursion   H.4(22)    No_Reentrancy   H.4(23)    No_Relative_Delay   D.7(10.5/3)    No_Requeue_Statements   D.7(10.6/3)    No_Select_Statements   D.7(10.7/3)    No_Specific_Termination_Handlers   
D.7(10.8/3) 
   No_Specification_of_Aspect   
13.12.1(6.1/3) 
   No_Standard_Allocators_After_Elabora
tion   D.7(19.2/3) 
   No_Task_Allocators   D.7(7)    No_Task_Hierarchy   D.7(3/3)    No_Task_Termination   D.7(15.1/2) 
   No_Terminate_Alternatives   D.7(6)    No_Unchecked_Access   H.4(18)    No_Unchecked_Conversion   J.13(4/2)    No_Unchecked_Deallocation   J.13(5/2)    No_Use_Of_Attribute   13.12.1(6.2/3)    No_Use_Of_Pragma   13.12.1(6.3/3)    Simple_Barriers   D.7(10.9/3) Restrictions pragma   13.12(3), L(32) Result attribute   6.1.1(29/3) result interval    for a component of the result of 
evaluating a complex function   G.2.6(3) 
   for the evaluation of a predefined 
arithmetic operation   G.2.1(8) 
   for the evaluation of an elementary 
function   G.2.4(2) 
result subtype    of a function   6.5(3/2) return object    extended_return_statement   6.5(5.10/3)    simple_return_statement   6.5(6/2) return statement   6.5(1/2) return_subtype_indication   6.5(2.3/2)    used   6.5(2.1/3), P 
reverse iterator   5.5.2(4/3) Reverse_Elements    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(27/2) 
   in Ada.Containers.Vectors   
A.18.2(54/2) 
Reverse_Find    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(42/2) 
   in Ada.Containers.Vectors   
A.18.2(70/2) 
Reverse_Find_Index    in Ada.Containers.Vectors   
A.18.2(69/2) 
Reverse_Iterate    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(46/2) 
   in Ada.Containers.Ordered_Maps   
A.18.6(51/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(61/2) 
   in Ada.Containers.Vectors   
A.18.2(74/2) 
Reverse_Iterate_Children    in Ada.Containers.Multiway_Trees   
A.18.10(69/3) 
Reverse_Solidus    in Ada.Characters.Latin_1   A.3.3(12) 
reversible iterable container object   
5.5.1(11/3) 
reversible iterable container type   
5.5.1(11/3) 
reversible iterator object   5.5.1(6/3) reversible iterator type   5.5.1(6/3) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      908 Reversible_Iterator 
   in Ada.Iterator_Interfaces   5.5.1(4/3) 
Reviewable pragma   H.3.1(3), L(33) RI    in Ada.Characters.Latin_1   A.3.3(17) 
right parenthesis   2.1(15/3) Right_Angle_Quotation    in Ada.Characters.Latin_1   A.3.3(22) 
Right_Curly_Bracket    in Ada.Characters.Latin_1   A.3.3(14) 
Right_Parenthesis    in Ada.Characters.Latin_1   A.3.3(8) 
Right_Square_Bracket    in Ada.Characters.Latin_1   A.3.3(12) 
Ring_Above    in Ada.Characters.Latin_1   A.3.3(22) 
root    of a tree   A.18.10(3/3)    in Ada.Containers.Multiway_Trees   
A.18.10(22/3) 
root library unit   10.1.1(10) root node    of a tree   A.18.10(3/3) root type    of a class   3.4.1(2/2) root_integer   3.5.4(14)    [partial ]   3.4.1(8) 
root_real   3.5.6(3)    [partial ]   3.4.1(8) 
Root_Storage_Pool    in System.Storage_Pools   13.11(6/2) 
Root_Storage_Pool_With_Subpools    in System.Storage_Pools.Subpools   
13.11.4(4/3) 
Root_Stream_Type    in Ada.Streams   13.13.1(3/2) 
Root_Subpool    in System.Storage_Pools.Subpools   
13.11.4(5/3) 
rooted at a type   3.4.1(2/2) roots the subtree   A.18.10(3/3) rotate   B.2(9) Round attribute   3.5.10(12) Round_Robin    child of  Ada.Dispatching   D.2.5(4/2) 
Round_Robin_Within_Priorities task 
dispatching policy   D.2.5(2/2) 
Rounding attribute   A.5.3(36) RPC    child of  System   E.5(3) 
RPC-receiver   E.5(21) RPC_Receiver    in System.RPC   E.5(11) 
RS    in Ada.Characters.Latin_1   A.3.3(6) 
run-time check    See language-defined check   11.5(2/3) 
run-time error   1.1.2(30), 1.1.5(6), 
11.5(2/3), 11.6(1/3) 
run-time polymorphism   3.9.2(1/2) run-time semantics   1.1.2(30) 
run-time type    See tag   3.9(3) 
running a program    See program execution   10.2(1) 
running task   D.2.1(6/2)  
S 
 safe range    of a floating point type   3.5.7(9)    of a floating point type   3.5.7(10) Safe_First attribute   A.5.3(71), G.2.2(5) Safe_Last attribute   A.5.3(72), G.2.2(6) safety-critical systems   H(1/2) satisfies    a discriminant constraint   3.7.1(11)    a range constraint   3.5(4)    a subtype predicate   3.2.4(32/3)    an index constraint   3.6.1(7)    for an access value   3.10(15/2) Saturday    in Ada.Calendar.Formatting   
9.6.1(17/2) 
Save    in Ada.Numerics.Discrete_Random   
A.5.2(24) 
   in Ada.Numerics.Float_Random   
A.5.2(12) 
Save_Occurrence    in Ada.Exceptions   11.4.1(6/2) 
scalar type   3.2(3), 3.5(1), N(37) scalar_constraint   3.2.2(6)    used   3.2.2(5), P 
scale    of a decimal fixed point subtype   
3.5.10(11), K.2(216) 
Scale attribute   3.5.10(11) Scaling attribute   A.5.3(27) SCHAR_MAX    in Interfaces.C   B.3(6) 
SCHAR_MIN    in Interfaces.C   B.3(6) 
SCI    in Ada.Characters.Latin_1   A.3.3(19) 
scope    informal definition   3.1(8)    of (a view of) an entity   8.2(11)    of a declaration   8.2(10)    of a use_clause   8.4(6)    of a with_clause   10.1.2(5)    of an aspect_specification   8.2(10.1/3)    of an attribute_definition_clause   
8.2(10.1/3) 
Search_Type    in Ada.Directories   A.16(31/2) 
Second    in Ada.Calendar.Formatting   
9.6.1(26/2) Second_Duration subtype of  
Day_Duration 
   in Ada.Calendar.Formatting   
9.6.1(20/2) 
Second_Number subtype of  Natural 
   in Ada.Calendar.Formatting   
9.6.1(20/2) 
Seconds    in Ada.Calendar   9.6(13) 
   in Ada.Real_Time   D.8(14/2) 
Seconds_Count    in Ada.Real_Time   D.8(15) 
Seconds_Of    in Ada.Calendar.Formatting   
9.6.1(28/2) 
Section_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
secure systems   H(1/2) select an entry call    from an entry queue   9.5.3(13), 
9.5.3(16) 
   immediately   9.5.3(8) select_alternative   9.7.1(4)    used   9.7.1(2), P 
select_statement   9.7(2)    used   5.1(5/2), P 
selected_component   4.1.3(2)    used   4.1(2/3), P 
selection    of an entry caller   9.5.2(24) selective_accept   9.7.1(2)    used   9.7(2), P 
selector_name   4.1.3(3)    used   3.7.1(3), 4.1.3(2), 4.3.1(5), 6.4(5), 
12.3(4), 12.7(3.1/2), P 
semantic dependence    of one compilation unit upon another   
10.1.1(26/2) 
semicolon   2.1(15/3)    in Ada.Characters.Latin_1   A.3.3(10) 
separate compilation   10.1(1) Separate_Interrupt_Clocks_Supported    in Ada.Execution_Time   D.14(9.2/3) 
separator   2.2(3/2) separator_line   2.1(12/2) separator_paragraph   2.1(12.1/2) separator_space   2.1(11/2) sequence of characters    of a string_literal   2.6(5) sequence_of_statements   5.1(2/3)    used   5.3(2), 5.4(3), 5.5(2), 9.7.1(2), 
9.7.1(5), 9.7.1(6), 9.7.2(3/2), 9.7.3(2), 9.7.4(3), 9.7.4(5), 11.2(2), 11.2(3), P 
sequential    actions   9.10(11), C.6(17) sequential access   A.8(2) sequential file   A.8(1/2) Sequential_IO    child of  Ada   A.8.1(2) 
Ada Reference Manual — 2012 Edition 
909      13 December 2012 Index service 
   an entry queue   9.5.3(13) set    execution timer object   D.14.1(12/2)    group budget object   D.14.2(15/2)    termination handler   C.7.3(9/2)    timing event object   D.15(9/2)    in Ada.Containers.Hashed_Sets   
A.18.8(3/3) 
   in Ada.Containers.Ordered_Sets   
A.18.9(4/3) 
   in Ada.Environment_Variables   
A.17(6/2) 
set container   A.18.7(1/2) Set_Bounded_String    in Ada.Strings.Bounded   A.4.4(12.1/2) 
Set_Col    in Ada.Text_IO   A.10.1(35) 
Set_CPU    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(12/3) 
Set_Deadline    in Ada.Dispatching.EDF   D.2.6(9/2) 
Set_Dependents_Fallback_Handler    in Ada.Task_Termination   C.7.3(5/2) 
Set_Directory    in Ada.Directories   A.16(6/2) 
Set_Error    in Ada.Text_IO   A.10.1(15) 
Set_Exit_Status    in Ada.Command_Line   A.15(9) 
Set_False    in Ada.Synchronous_Task_Control   
D.10(4) 
Set_Handler    in 
Ada.Execution_Time.Group_Budgets   D.14.2(10/2) 
   in Ada.Execution_Time.Timers   
D.14.1(7/2) 
   in Ada.Real_Time.Timing_Events   
D.15(5/2) 
Set_Im    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(8/2), G.3.2(28/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(7) 
Set_Index    in Ada.Direct_IO   A.8.4(14) 
   in Ada.Streams.Stream_IO   A.12.1(22) 
Set_Input    in Ada.Text_IO   A.10.1(15) 
Set_Iterator_Interfaces    in Ada.Containers.Hashed_Sets   
A.18.8(6.2/3) 
   in Ada.Containers.Ordered_Sets   
A.18.9(7.2/3) Set_Length 
   in Ada.Containers.Vectors   
A.18.2(22/2) 
Set_Line    in Ada.Text_IO   A.10.1(36) 
Set_Line_Length    in Ada.Text_IO   A.10.1(23) 
Set_Mode    in Ada.Streams.Stream_IO   A.12.1(24) 
Set_Output    in Ada.Text_IO   A.10.1(15) 
Set_Page_Length    in Ada.Text_IO   A.10.1(24) 
Set_Pool_of_Subpool    in System.Storage_Pools.Subpools   
13.11.4(10/3) 
Set_Priority    in Ada.Dynamic_Priorities   D.5.1(4) 
Set_Quantum    in Ada.Dispatching.Round_Robin   
D.2.5(4/2) 
Set_Re    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(8/2), G.3.2(28/2) 
   in Ada.Numerics.Generic_Complex_-
Types   G.1.1(7) 
Set_Specific_Handler    in Ada.Task_Termination   C.7.3(6/2) 
Set_True    in Ada.Synchronous_Task_Control   
D.10(4) 
Set_Unbounded_String    in Ada.Strings.Unbounded   
A.4.5(11.1/2) 
Set_Value    in Ada.Task_Attributes   C.7.2(6) 
shared passive library unit   E.2(4/3), 
E.2.1(4/3) 
shared variable    protection of   9.10(1/3) Shared_Passive aspect   E.2.1(4/3) Shared_Passive pragma   E.2.1(3), L(34) shift   B.2(9) short    in Interfaces.C   B.3(7) 
short-circuit control form   4.5.1(1) Short_Float   3.5.7(16) Short_Integer   3.5.4(25) SI    in Ada.Characters.Latin_1   A.3.3(5) 
signal    as defined between actions   9.10(2)    See interrupt   C.3(1/3) 
signal (an exception)    See raise   11(1/3) 
signal handling    example   9.7.4(10) signed integer type   3.5.4(1) signed_char    in Interfaces.C   B.3(8) signed_integer_type_definition   3.5.4(3) 
   used   3.5.4(2), P 
Signed_Zeros attribute   A.5.3(13) simple entry call   9.5.3(1) simple name    of a file   A.16(47/2) Simple_Barriers restriction   D.7(10.9/3) simple_expression   4.4(4)    used   3.5(3), 3.5.4(3), 3.5.7(3), 
4.4(2.2/3), 4.4(3/3), 13.5.1(5), 13.5.1(6), P 
Simple_Name    in Ada.Directories   A.16(16/2), 
A.16(38/2) 
   in 
Ada.Directories.Hierarchical_File_Names   A.16.1(10/3) 
simple_return_statement   6.5(2/2)    used   5.1(4/2), P 
simple_statement   5.1(4/2)    used   5.1(3), P 
Sin    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(4) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(5) 
single    class expected type   8.6(27/2) single entry   9.5.2(20) Single_Precision_Complex_Types    in Interfaces.Fortran   B.5(8) 
single_protected_declaration   9.4(3/3)    used   3.3.1(2/3), P 
single_task_declaration   9.1(3/3)    used   3.3.1(2/3), P 
Sinh    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(6) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(7) 
size    of an object   13.1(7/2)    in Ada.Direct_IO   A.8.4(15) 
   in Ada.Directories   A.16(26/2), 
A.16(41/2) 
   in Ada.Streams.Stream_IO   A.12.1(23) 
Size (object) aspect   13.3(41) Size (subtype) aspect   13.3(48) Size attribute   13.3(40), 13.3(45) Size clause   13.3(7/2), 13.3(41), 13.3(48) size_t    in Interfaces.C   B.3(13) 
Skip_Line    in Ada.Text_IO   A.10.1(29) 
Skip_Page    in Ada.Text_IO   A.10.1(32) 
slice   4.1.2(2)    used   4.1(2/3), P 
   in Ada.Strings.Bounded   A.4.4(28) 
   in Ada.Strings.Unbounded   A.4.5(22) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      910 small 
   of a fixed point type   3.5.9(8/2) Small aspect   3.5.10(2/1) Small attribute   3.5.10(2/1) Small clause   3.5.10(2/1), 13.3(7/2) SO    in Ada.Characters.Latin_1   A.3.3(5) 
Soft_Hyphen    in Ada.Characters.Latin_1   A.3.3(21/3) 
SOH    in Ada.Characters.Latin_1   A.3.3(5) 
solidus   2.1(15/3)    in Ada.Characters.Latin_1   A.3.3(8) 
Solve    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(46/2) 
   in Ada.Numerics.Generic_Real_Arrays   
G.3.1(24/2) 
Sort    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(49/2) 
   in Ada.Containers.Vectors   
A.18.2(77/2) 
SOS    in Ada.Characters.Latin_1   A.3.3(19) 
SPA    in Ada.Characters.Latin_1   A.3.3(18) 
Space    in Ada.Characters.Latin_1   A.3.3(8) 
   in Ada.Strings   A.4.1(4/2) 
special file   A.16(45/2) special graphic character    a category of Character   A.3.2(32) Special_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
Specialized Needs Annexes   1.1.2(7) specifiable    of Address for entries   J.7.1(6)    of Address for stand-alone objects and 
for program units   13.3(12) 
   of Alignment for first subtypes   
13.3(26.4/2) 
   of Alignment for objects   13.3(25/2)    of Bit_Order for record types and record 
extensions   13.5.3(4) 
   of Component_Size for array types   
13.3(70) 
   of External_Tag for a tagged type   
13.3(75/3), K.2(65) 
   of Input for a type   13.13.2(38/3)    of Machine_Radix for decimal first 
subtypes   F.1(1) 
   of Output for a type   13.13.2(38/3)    of Read for a type   13.13.2(38/3)    of Size for first subtypes   13.3(48)    of Size for stand-alone objects   13.3(41)    of Small for fixed point types   
3.5.10(2/1)    of Storage_Pool for a nonderived 
access-to-object type   13.11(15) 
   of Storage_Size for a nonderived access-
to-object type   13.11(15) 
   of Storage_Size for a task first subtype   
J.9(3/3) 
   of Write for a type   13.13.2(38/3) specifiable (of an attribute and for an 
entity)   13.3(5/3) 
specific handler   C.7.3(9/2) specific postcondition expression   
6.1.1(4/3) 
specific precondition expression   
6.1.1(2/3) 
specific type   3.4.1(3/2) Specific_Handler    in Ada.Task_Termination   C.7.3(6/2) 
specified    of an aspect of representation of an 
entity   13.1(17) 
   of an operational aspect of an entity   
13.1(18.1/1) 
specified (not!)   1.1.3(18) specified as independently addressable   
C.6(8.1/3) 
specified discriminant   3.7(18) Splice    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(30/2), A.18.3(31/2), A.18.3(32/2) 
Splice_Children    in Ada.Containers.Multiway_Trees   
A.18.10(57/3), A.18.10(58/3) 
Splice_Subtree    in Ada.Containers.Multiway_Trees   
A.18.10(55/3), A.18.10(56/3) 
Split    in Ada.Calendar   9.6(14) 
   in Ada.Calendar.Formatting   
9.6.1(29/2), 9.6.1(32/2), 9.6.1(33/2), 9.6.1(34/2) 
   in Ada.Execution_Time   D.14(8/2) 
   in Ada.Real_Time   D.8(16) 
Sqrt    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(3) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(4) 
SS2    in Ada.Characters.Latin_1   A.3.3(17) 
SS3    in Ada.Characters.Latin_1   A.3.3(17) 
SSA    in Ada.Characters.Latin_1   A.3.3(17) 
ST    in Ada.Characters.Latin_1   A.3.3(19) 
stand-alone constant   3.3.1(23/3)    corresponding to a formal object of 
mode in   12.4(10/2) 
stand-alone object   3.3.1(1/3)    [partial ]   12.4(10/2) 
stand-alone variable   3.3.1(23/3) Standard   A.1(4) standard error file   A.10(6) standard input file   A.10(5) standard mode   1.1.5(11) standard output file   A.10(5) standard storage pool   13.11(17) Standard_Error    in Ada.Text_IO   A.10.1(16), A.10.1(19) 
Standard_Input    in Ada.Text_IO   A.10.1(16), A.10.1(19) 
Standard_Output    in Ada.Text_IO   A.10.1(16), A.10.1(19) 
Start_Search    in Ada.Directories   A.16(32/2) 
State    in Ada.Numerics.Discrete_Random   
A.5.2(23) 
   in Ada.Numerics.Float_Random   
A.5.2(11) 
statement   5.1(3)    used   5.1(2/3), P 
statement_identifier   5.1(8)    used   5.1(7), 5.5(2), 5.6(2), P 
static   4.9(1)    constant   4.9(24)    constraint   4.9(27)    delta constraint   4.9(29)    digits constraint   4.9(29)    discrete_range   4.9(25)    discriminant constraint   4.9(31)    expression   4.9(2)    function   4.9(18)    index constraint   4.9(30)    range   4.9(25)    range constraint   4.9(29)    scalar subtype   4.9(26/3)    string subtype   4.9(26/3)    subtype   4.9(26/3)    subtype   12.4(9/2) static semantics   1.1.2(28) Static_Predicate aspect   3.2.4(1/3) statically    constrained   4.9(32)    denote   4.9(14) statically compatible    for a constraint and a scalar subtype   
4.9.1(4/3) 
   for a constraint and an access or 
composite subtype   4.9.1(4/3) 
   for two subtypes   4.9.1(5/3) statically deeper   3.10.2(4), 3.10.2(17) statically determined tag   3.9.2(1/2)    [partial ]   3.9.2(15), 3.9.2(19) 
statically matching    effect on subtype-specific aspects   
13.1(14) 
   for constraints   4.9.1(1/2)    for ranges   4.9.1(3) 
Ada Reference Manual — 2012 Edition 
911      13 December 2012 Index    for subtypes   4.9.1(2/3) 
   required   3.9.2(10/2), 3.10.2(27.1/2), 
4.6(24.15/2), 4.6(24.5/2), 6.3.1(16.3/3), 6.3.1(17/3), 6.3.1(23), 6.5(5.2/3), 7.3(13), 8.5.1(4.2/2), 12.4(8.1/2), 12.5.1(14), 12.5.3(6), 12.5.3(7), 12.5.4(3), 12.7(7) 
statically tagged   3.9.2(4/2) statically unevaluated   4.9(32.1/3) Status_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.Directories   A.16(43/2) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
storage deallocation    unchecked   13.11.2(1) storage element   13.3(8) storage management    user-defined   13.11(1) storage node   E(2) storage place    of a component   13.5(1)    representation aspect   13.5(1) storage place attributes    of a component   13.5.2(1) storage pool   3.10(7/1), N(37.1/3)    default   13.11.3(4.1/3) storage pool element   13.11(11) storage pool that supports subpools   
13.11.4(18/3) 
storage pool type   13.11(11) Storage_Array    in System.Storage_Elements   13.7.1(5) 
Storage_Check   11.5(23)    [partial ]   11.1(6), 13.3(67), 13.11(17), 
D.7(17/1), D.7(18/1), D.7(19/1) 
Storage_Count subtype of  Storage_Offset 
   in System.Storage_Elements   13.7.1(4) 
Storage_Element    in System.Storage_Elements   13.7.1(5) 
Storage_Elements    child of  System   13.7.1(2/2) 
Storage_Error    raised by failure of run-time check   
4.8(14), 8.5.4(8.1/1), 11.1(4), 11.1(6), 11.5(23), 13.3(67), 13.11(17), 13.11(18), A.7(14/3), D.7(17/1), D.7(18/1), D.7(19.3/3), D.7(19/1) 
   in Standard   A.1(46) 
Storage_IO    child of  Ada   A.9(3) 
Storage_Offset    in System.Storage_Elements   13.7.1(3) 
Storage_Pool aspect   13.11(15) Storage_Pool attribute   13.11(13) Storage_Pool clause   13.3(7/2), 13.11(15) storage_pool_indicator   13.11.3(3.1/3)    used   13.11.3(3/3), L(8.3/3) Storage_Pools 
   child of  System   13.11(5) 
Storage_Size    in System.Storage_Pools   13.11(9) 
   in System.Storage_Pools.Subpools   
13.11.4(16/3) 
Storage_Size (access) aspect   13.11(15) Storage_Size (task) aspect   13.3(65.2/3) Storage_Size attribute   13.3(60/3), 
13.11(14), J.9(2) 
Storage_Size clause   13.3(7/2), 13.11(15) Storage_Size pragma   J.15.4(2/3), 
L(35.1/3) 
Storage_Unit    in System   13.7(13) 
stream   13.13(1), N(37.2/3)    in Ada.Streams.Stream_IO   A.12.1(13) 
   in Ada.Text_IO.Text_Streams   
A.12.2(4) 
   in Ada.Wide_Text_IO.Text_Streams   
A.12.3(4) 
   in Ada.Wide_Wide_Text_IO.Text_-
Streams   A.12.4(4/2) 
stream file   A.8(1/2) stream type   13.13(1) Stream_Access    in Ada.Streams.Stream_IO   A.12.1(4) 
   in Ada.Text_IO.Text_Streams   
A.12.2(3) 
   in Ada.Wide_Text_IO.Text_Streams   
A.12.3(3) 
   in Ada.Wide_Wide_Text_IO.Text_-
Streams   A.12.4(3/2) 
Stream_Element    in Ada.Streams   13.13.1(4/1) 
Stream_Element_Array    in Ada.Streams   13.13.1(4/1) 
Stream_Element_Count subtype of  
Stream_Element_Offset 
   in Ada.Streams   13.13.1(4/1) 
Stream_Element_Offset    in Ada.Streams   13.13.1(4/1) 
Stream_IO    child of  Ada.Streams   A.12.1(3/3) 
Stream_Size aspect   13.13.2(1.5/2) Stream_Size attribute   13.13.2(1.2/3) Stream_Size clause   13.3(7/2) Streams    child of  Ada   13.13.1(2) 
strict mode   G.2(1) strict weak ordering   A.18(5/3) String    in Standard   A.1(37/3) 
string type   3.6.3(1) String_Access    in Ada.Strings.Unbounded   A.4.5(7) 
string_element   2.6(3)    used   2.6(2), P 
string_literal   2.6(2)    used   4.4(7/3), 6.1(9), P Strings 
   child of  Ada   A.4.1(3) 
   child of  Ada.Strings.UTF_Encoding   
A.4.11(22/3) 
   child of  Interfaces.C   B.3.1(3) 
Strlen    in Interfaces.C.Strings   B.3.1(17) 
structure    See record type   3.8(1) 
STS    in Ada.Characters.Latin_1   A.3.3(18) 
STX    in Ada.Characters.Latin_1   A.3.3(5) 
SUB    in Ada.Characters.Latin_1   A.3.3(6) 
Sub_Second    in Ada.Calendar.Formatting   
9.6.1(27/2) 
subaggregate    of an array_aggregate   4.3.3(6) subcomponent   3.2(6/2) subpool   13.11.4(18/3) subpool access type   13.11.4(22/3) subpool handle   13.11.4(18/3) Subpool_Handle    in System.Storage_Pools.Subpools   
13.11.4(6/3) 
subpool_specification   4.8(2.1/3)    used   4.8(2/3), P 
Subpools    child of  System.Storage_Pools   
13.11.4(3/3) 
subprogram   6(1), N(37.3/2)    abstract   3.9.3(3/2) subprogram call   6.4(1) subprogram instance   12.3(13) subprogram_body   6.3(2/3)    used   3.11(6), 9.4(8/1), 10.1.1(7), P 
subprogram_body_stub   10.1.3(3/3)    used   10.1.3(2), P 
subprogram_declaration   6.1(2/3)    used   3.1(3/3), 9.4(5/1), 9.4(8/1), 
10.1.1(5), P 
subprogram_default   12.6(3/2)    used   12.6(2.1/3), 12.6(2.2/3), P 
subprogram_renaming_declaration   
8.5.4(2/3) 
   used   8.5(2), 10.1.1(6), P 
subprogram_specification   6.1(4/2)    used   3.9.3(1.1/3), 6.1(2/3), 6.3(2/3), 
8.5.4(2/3), 10.1.3(3/3), 12.1(3/3), 12.6(2.1/3), 12.6(2.2/3), P 
subsystem   10.1(3), N(22) subtree    node which roots   A.18.10(3/3)    of a tree   A.18.10(3/3) Subtree_Node_Count    in Ada.Containers.Multiway_Trees   
A.18.10(18/3) 
subtype   3.2(8/2), N(38/3) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      912    constraint of   3.2(8/2) 
   type of   3.2(8/2)    values belonging to   3.2(8/2) subtype (of an object)    See actual subtype of an object   
3.3(23/3) 
   See actual subtype of an object   
3.3.1(9/2) 
subtype conformance   6.3.1(17/3)    [partial ]   3.10.2(34/2), 9.5.4(17) 
   required   3.9.2(10/2), 3.10.2(32/3), 
4.6(24.20/3), 8.5.1(4.3/2), 8.5.4(5/3), 9.1(9.7/2), 9.1(9.8/2), 9.4(11.6/2), 9.4(11.7/2), 9.5.4(5/3), 12.4(8.2/2), 12.5.4(5/3) 
subtype conversion    See type conversion   4.6(1/3) 
   See also  implicit subtype conversion   
4.6(1/3) 
subtype-specific    of a representation item   13.1(8/3)    of an aspect   13.1(8/3) subtype_declaration   3.2.2(2/3)    used   3.1(3/3), P 
subtype_indication   3.2.2(3/2)    used   3.2.2(2/3), 3.3.1(2/3), 3.4(2/2), 
3.6(6), 3.6(7/2), 3.6.1(3), 3.8.1(5/3), 3.10(3), 4.8(2/3), 5.5.2(2/3), 6.5(2.3/2), 7.3(3/3), P 
subtype_mark   3.2.2(4)    used   3.2.2(3/2), 3.6(4), 3.7(5/2), 
3.9.4(3/2), 3.10(6/2), 4.3.2(3), 4.4(3.2/3), 4.6(2), 4.7(2), 6.1(13/2), 6.1(15/3), 8.4(4/3), 8.5.1(2/3), 12.3(5), 12.4(2/3), 12.5.1(3/2), P 
subtypes    of a profile   6.1(25) subunit   10.1.3(7), 10.1.3(8/2)    of a program unit   10.1.3(8/2)    used   10.1.1(3), P 
Succ attribute   3.5(22) Success    in Ada.Command_Line   A.15(8) 
successor element    of a hashed set   A.18.8(68/2)    of a set   A.18.7(6/2)    of an ordered set   A.18.9(81/3) successor node    of a hashed map   A.18.5(46/2)    of a map   A.18.4(6/2)    of an ordered map   A.18.6(58/3) Sunday    in Ada.Calendar.Formatting   
9.6.1(17/2) 
super    See view conversion   4.6(5/2) 
Superscript_One    in Ada.Characters.Latin_1   A.3.3(22) 
Superscript_Three    in Ada.Characters.Latin_1   A.3.3(22) Superscript_Two 
   in Ada.Characters.Latin_1   A.3.3(22) 
support external streaming   13.13.2(52/3) Supported    in Ada.Execution_Time.Interrupts   
D.14.3(3/3) 
Suppress pragma   11.5(4/2), J.10(3/2), 
L(36) 
suppressed check   11.5(8/2) Suspend_Until_True    in Ada.Synchronous_Task_Control   
D.10(4) 
Suspend_Until_True_And_Set_Deadline    in 
Ada.Synchronous_Task_Control.EDF   D.10(5.2/3) 
Suspension_Object    in Ada.Synchronous_Task_Control   
D.10(4) 
Swap    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(28/2) 
   in Ada.Containers.Multiway_Trees   
A.18.10(37/3) 
   in Ada.Containers.Vectors   
A.18.2(55/2), A.18.2(56/2) 
Swap_Links    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(29/2) 
Symmetric_Difference    in Ada.Containers.Hashed_Sets   
A.18.8(35/2), A.18.8(36/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(36/2), A.18.9(37/2) 
SYN    in Ada.Characters.Latin_1   A.3.3(6) 
synchronization   9(1/3) Synchronization aspect   9.5(12/3) synchronization_kind   9.5(10/3) synchronized   N(38.1/2) synchronized interface   3.9.4(5/2) synchronized tagged type   3.9.4(6/2) Synchronized_Queue_Interfaces    child of  Ada.Containers   A.18.27(3/3) 
Synchronous_Barrier    in Ada.Synchronous_Barriers   
D.10.1(5/3) 
Synchronous_Barriers    child of  Ada   D.10.1(3/3) 
Synchronous_Task_Control    child of  Ada   D.10(3/2) 
syntactic category   1.1.4(15) syntax    complete listing   P(1)    cross reference   P(1)    notation   1.1.4(3)    under Syntax heading   1.1.2(25) System   13.7(3/2) System.Address_To_Access_-
Conversions   13.7.2(2) System.Machine_Code   13.8(7) 
System.Multiprocessors   D.16(3/3) System.Multiprocessors.Dispatching_Do
mains   D.16.1(3/3) 
System.RPC   E.5(3) System.Storage_Elements   13.7.1(2/2) System.Storage_Pools   13.11(5) System.Storage_Pools.Subpools   
13.11.4(3/3) 
System_Dispatching_Domain    in 
System.Multiprocessors.Dispatching_Domains   D.16.1(6/3) 
System_Name    in System   13.7(4) 
systems programming   C(1)  
T 
 Tag    in Ada.Tags   3.9(6/2) 
Tag attribute   3.9(16), 3.9(18) tag indeterminate   3.9.2(6/2) tag of an object   3.9(3)    class-wide object   3.9(22)    object created by an allocator   3.9(21)    preserved by type conversion and 
parameter passing   3.9(25) 
   returned by a function   3.9(23), 
3.9(24/2) 
   stand-alone object, component, or 
aggregate   3.9(20) 
Tag_Array    in Ada.Tags   3.9(7.3/2) 
Tag_Check   11.5(18)    [partial ]   3.9.2(16), 4.6(42), 4.6(52), 
5.2(10), 6.5(8.1/3) 
Tag_Error    in Ada.Tags   3.9(8) 
tagged incomplete view   3.10.1(2.1/2) tagged type   3.9(2/2), N(39)    protected   3.9.4(6/2)    synchronized   3.9.4(6/2)    task   3.9.4(6/2) Tags    child of  Ada   3.9(6/2) 
Tail    in Ada.Strings.Bounded   A.4.4(72), 
A.4.4(73) 
   in Ada.Strings.Fixed   A.4.3(37), 
A.4.3(38) 
   in Ada.Strings.Unbounded   A.4.5(67), 
A.4.5(68) 
tail (of a queue)   D.2.1(5/2) tamper with cursors    of a list   A.18.3(62/2)    of a map   A.18.4(8/2)    of a set   A.18.7(8/2)    of a tree   A.18.10(81/3)    of a vector   A.18.2(91/2) 
Ada Reference Manual — 2012 Edition 
913      13 December 2012 Index tamper with elements 
   of a holder   A.18.18(30/3)    of a list   A.18.3(67/2)    of a map   A.18.4(13/2)    of a set   A.18.7(13/2)    of a tree   A.18.10(87/3)    of a vector   A.18.2(95/2) tampering    prohibited for a holder   A.18.18(35/3)    prohibited for a list   A.18.3(69.1/3)    prohibited for a map   A.18.4(15.1/3)    prohibited for a set   A.18.7(14.1/3)    prohibited for a tree   A.18.10(90/3)    prohibited for a vector   A.18.2(97.1/3) Tan    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(4) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(5) 
Tanh    in Ada.Numerics.Generic_Complex_-
Elementary_Functions   G.1.2(6) 
   in Ada.Numerics.Generic_Elementary_-
Functions   A.5.1(7) 
target    of an assignment operation   5.2(3)    of an assignment_statement   5.2(3) target object    of a requeue_statement   9.5(7)    of the name of an entry or a protected 
subprogram   9.5(2/3) 
target statement    of a goto_statement   5.8(3) target subtype    of a type_conversion   4.6(3) task   9(1/3)    activation   9.2(1)    completion   9.3(1)    dependence   9.3(1)    execution   9.2(1)    termination   9.3(1) task declaration   9.1(1) task dispatching   D.2.1(4/2) task dispatching point   D.2.1(4/2)    [partial ]   D.2.3(8/2), D.2.4(9/3) 
task dispatching policy   D.2.2(7/2)    [partial ]   D.2.1(5/2) 
   EDF_Across_Priorities   D.2.6(7/2)    FIFO_Within_Priorities   D.2.3(2/2)    Non_Preemptive_FIFO_Within_-
Priorities   D.2.4(2/2) 
   Round_Robin_Within_Priorities   
D.2.5(2/2) 
task interface   3.9.4(5/2) task priority   D.1(15) task state    abnormal   9.8(4)    blocked   9(10)    callable   9.9(2)    held   D.11(4/2)    inactive   9(10) 
   ready   9(10)    terminated   9(10) task tagged type   3.9.4(6/2) task type   N(40/2) task unit   9(9) Task_Array    in 
Ada.Execution_Time.Group_Budgets   D.14.2(6/2) 
Task_Attributes    child of  Ada   C.7.2(2) 
task_body   9.1(6/3)    used   3.11(6), P 
task_body_stub   10.1.3(5)    used   10.1.3(2), P 
task_definition   9.1(4)    used   9.1(2/3), 9.1(3/3), P 
Task_Dispatching_Policy pragma   
D.2.2(3), L(37) 
Task_Id    in Ada.Task_Identification   C.7.1(2/2) 
Task_Identification    child of  Ada   C.7.1(2/2) 
task_item   9.1(5/1)    used   9.1(4), P 
Task_Termination    child of  Ada   C.7.3(2/2) 
task_type_declaration   9.1(2/3)    used   3.2.1(3/3), P 
Tasking_Error    raised by failure of run-time check   
9.2(5), 9.5.3(21), 11.1(4), 13.11.2(13), 13.11.2(14), C.7.2(13), D.5.1(8), D.11(8) 
   in Standard   A.1(46) 
template   12(1)    for a formal package   12.7(4)    See generic unit   12(1) 
term   4.4(5)    used   4.4(4), P 
terminal interrupt    example   9.7.4(10) terminate_alternative   9.7.1(7)    used   9.7.1(4), P 
terminated    a task state   9(10) Terminated attribute   9.9(3) termination    of a partition   E.1(7) termination handler   C.7.3(8/3)    fall-back   C.7.3(9/2)    specific   C.7.3(9/2) Termination_Handler    in Ada.Task_Termination   C.7.3(4/2) 
Terminator_Error    in Interfaces.C   B.3(40) 
tested type    of a membership test   4.5.2(3/3) text of a program   2.2(1) Text_IO 
   child of  Ada   A.10.1(2) 
Text_Streams    child of  Ada.Text_IO   A.12.2(3) 
   child of  Ada.Wide_Text_IO   A.12.3(3) 
   child of  Ada.Wide_Wide_Text_IO   
A.12.4(3/2) 
throw (an exception)    See raise   11(1/3) 
Thursday    in Ada.Calendar.Formatting   
9.6.1(17/2) 
tick   2.1(15/3)    in Ada.Real_Time   D.8(6) 
   in System   13.7(10) 
Tilde    in Ada.Characters.Latin_1   A.3.3(14) 
Time    in Ada.Calendar   9.6(10) 
   in Ada.Real_Time   D.8(4) 
time base   9.6(6/3) time limit    example   9.7.4(12) time type   9.6(6/3) Time-dependent Reset procedure    of the random number generator   
A.5.2(34) 
time-out    example   9.7.4(12)    See asynchronous_select   9.7.4(12) 
   See selective_accept   9.7.1(1) 
   See timed_entry_call   9.7.2(1/2) 
Time_Error    in Ada.Calendar   9.6(18) 
Time_First    in Ada.Real_Time   D.8(4) 
Time_Last    in Ada.Real_Time   D.8(4) 
Time_Of    in Ada.Calendar   9.6(15) 
   in Ada.Calendar.Formatting   
9.6.1(30/2), 9.6.1(31/2) 
   in Ada.Execution_Time   D.14(9/2) 
   in Ada.Real_Time   D.8(16) 
Time_Of_Event    in Ada.Real_Time.Timing_Events   
D.15(6/2) 
Time_Offset    in Ada.Calendar.Time_Zones   
9.6.1(4/2) 
Time_Remaining    in Ada.Execution_Time.Timers   
D.14.1(8/2) 
Time_Span    in Ada.Real_Time   D.8(5) 
Time_Span_First    in Ada.Real_Time   D.8(5) 
Time_Span_Last    in Ada.Real_Time   D.8(5) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      914 Time_Span_Unit 
   in Ada.Real_Time   D.8(5) 
Time_Span_Zero    in Ada.Real_Time   D.8(5) 
Time_Unit    in Ada.Real_Time   D.8(4) 
Time_Zones    child of  Ada.Calendar   9.6.1(2/2) 
timed_entry_call   9.7.2(2)    used   9.7(2), P 
Timer    in Ada.Execution_Time.Timers   
D.14.1(4/2) 
timer interrupt    example   9.7.4(12) Timer_Handler    in Ada.Execution_Time.Timers   
D.14.1(5/2) 
Timer_Resource_Error    in Ada.Execution_Time.Timers   
D.14.1(9/2) 
Timers    child of  Ada.Execution_Time   
D.14.1(3/2) 
times operator   4.4(1/3), 4.5.5(1) timing    See delay_statement   9.6(1) 
Timing_Event    in Ada.Real_Time.Timing_Events   
D.15(4/2) 
Timing_Event_Handler    in Ada.Real_Time.Timing_Events   
D.15(4/2) 
Timing_Events    child of  Ada.Real_Time   D.15(3/2) 
To_Ada    in Interfaces.C   B.3(22), B.3(26), 
B.3(28), B.3(32), B.3(37), B.3(39), B.3(39.10/2), B.3(39.13/2), B.3(39.17/2), B.3(39.19/2), B.3(39.4/2), B.3(39.8/2) 
   in Interfaces.COBOL   B.4(17), B.4(19) 
   in Interfaces.Fortran   B.5(13), B.5(14), 
B.5(16) 
To_Address    in System.Address_To_Access_-
Conversions   13.7.2(3/3) 
   in System.Storage_Elements   
13.7.1(10/3) 
To_Basic    in Ada.Characters.Handling   A.3.2(6), 
A.3.2(7) 
To_Binary    in Interfaces.COBOL   B.4(45), B.4(48) 
To_Bounded_String    in Ada.Strings.Bounded   A.4.4(11) To_C 
   in Interfaces.C   B.3(21), B.3(25), 
B.3(27), B.3(32), B.3(36), B.3(38), B.3(39.13/2), B.3(39.16/2), B.3(39.18/2), B.3(39.4/2), B.3(39.7/2), B.3(39.9/2) 
To_Character    in Ada.Characters.Conversions   
A.3.4(5/2) 
To_Chars_Ptr    in Interfaces.C.Strings   B.3.1(8) 
To_COBOL    in Interfaces.COBOL   B.4(17), B.4(18) 
To_Cursor    in Ada.Containers.Vectors   
A.18.2(25/2) 
To_Decimal    in Interfaces.COBOL   B.4(35), B.4(40), 
B.4(44), B.4(47) 
To_Display    in Interfaces.COBOL   B.4(36) 
To_Domain    in Ada.Strings.Maps   A.4.2(24) 
   in Ada.Strings.Wide_Maps   A.4.7(24) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(24/2) 
To_Duration    in Ada.Real_Time   D.8(13) 
To_Fortran    in Interfaces.Fortran   B.5(13), B.5(14), 
B.5(15) 
To_Holder    in Ada.Containers.Indefinite_Holders   
A.18.18(9/3) 
To_Index    in Ada.Containers.Vectors   
A.18.2(26/2) 
To_Integer    in System.Storage_Elements   
13.7.1(10/3) 
To_ISO_646    in Ada.Characters.Handling   A.3.2(11), 
A.3.2(12) 
To_Long_Binary    in Interfaces.COBOL   B.4(48) 
To_Lower    in Ada.Characters.Handling   A.3.2(6), 
A.3.2(7) 
   in Ada.Wide_Characters.Handling   
A.3.5(20/3), A.3.5(21/3) 
To_Mapping    in Ada.Strings.Maps   A.4.2(23) 
   in Ada.Strings.Wide_Maps   A.4.7(23) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(23/2) 
To_Packed    in Interfaces.COBOL   B.4(41) 
To_Picture    in Ada.Text_IO.Editing   F.3.3(6) To_Pointer 
   in System.Address_To_Access_-
Conversions   13.7.2(3/3) 
To_Range    in Ada.Strings.Maps   A.4.2(24) 
   in Ada.Strings.Wide_Maps   A.4.7(25) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(25/2) 
To_Ranges    in Ada.Strings.Maps   A.4.2(10) 
   in Ada.Strings.Wide_Maps   A.4.7(10) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(10/2) 
To_Sequence    in Ada.Strings.Maps   A.4.2(19) 
   in Ada.Strings.Wide_Maps   A.4.7(19) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(19/2) 
To_Set    in Ada.Containers.Hashed_Sets   
A.18.8(9/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(10/2) 
   in Ada.Strings.Maps   A.4.2(8), 
A.4.2(9), A.4.2(17), A.4.2(18) 
   in Ada.Strings.Wide_Maps   A.4.7(8), 
A.4.7(9), A.4.7(17), A.4.7(18) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(8/2), A.4.8(9/2), A.4.8(17/2), A.4.8(18/2) 
To_String    in Ada.Characters.Conversions   
A.3.4(5/2) 
   in Ada.Strings.Bounded   A.4.4(12) 
   in Ada.Strings.Unbounded   A.4.5(11) 
To_Time_Span    in Ada.Real_Time   D.8(13) 
To_Unbounded_String    in Ada.Strings.Unbounded   A.4.5(9), 
A.4.5(10) 
To_Upper    in Ada.Characters.Handling   A.3.2(6), 
A.3.2(7) 
   in Ada.Wide_Characters.Handling   
A.3.5(20/3), A.3.5(21/3) 
To_Vector    in Ada.Containers.Vectors   
A.18.2(13/2), A.18.2(14/2) 
To_Wide_Character    in Ada.Characters.Conversions   
A.3.4(4/2), A.3.4(5/2) 
To_Wide_String    in Ada.Characters.Conversions   
A.3.4(4/2), A.3.4(5/2) 
To_Wide_Wide_Character    in Ada.Characters.Conversions   
A.3.4(4/2) 
To_Wide_Wide_String    in Ada.Characters.Conversions   
A.3.4(4/2) 
Ada Reference Manual — 2012 Edition 
915      13 December 2012 Index token 
   See lexical element   2.2(1) 
Trailing_Nonseparate    in Interfaces.COBOL   B.4(23) 
Trailing_Separate    in Interfaces.COBOL   B.4(23) 
transfer of control   5.1(14/2) Translate    in Ada.Strings.Bounded   A.4.4(53), 
A.4.4(54), A.4.4(55), A.4.4(56) 
   in Ada.Strings.Fixed   A.4.3(18), 
A.4.3(19), A.4.3(20), A.4.3(21) 
   in Ada.Strings.Unbounded   A.4.5(48), 
A.4.5(49), A.4.5(50), A.4.5(51) 
Translation_Error    in Ada.Strings   A.4.1(5) 
Transpose    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(34/2) 
   in Ada.Numerics.Generic_Real_Arrays   
G.3.1(17/2) 
Tree    in Ada.Containers.Multiway_Trees   
A.18.10(8/3) 
Tree_Iterator_Interfaces    in Ada.Containers.Multiway_Trees   
A.18.10(13/3) 
triggering_alternative   9.7.4(3)    used   9.7.4(2), P 
triggering_statement   9.7.4(4/2)    used   9.7.4(3), P 
Trim    in Ada.Strings.Bounded   A.4.4(67), 
A.4.4(68), A.4.4(69) 
   in Ada.Strings.Fixed   A.4.3(31), 
A.4.3(32), A.4.3(33), A.4.3(34) 
   in Ada.Strings.Unbounded   A.4.5(61), 
A.4.5(62), A.4.5(63), A.4.5(64) 
Trim_End    in Ada.Strings   A.4.1(6) 
True   3.5.3(1) Truncation    in Ada.Strings   A.4.1(6) 
Truncation attribute   A.5.3(42) Tuesday    in Ada.Calendar.Formatting   
9.6.1(17/2) 
two's complement    modular types   3.5.4(29) type   3.2(1), N(41/2)    abstract   3.9.3(1.2/2)    needs finalization   7.6(9.1/2)    of a subtype   3.2(8/2)    synchronized tagged   3.9.4(6/2)    See also  tag   3.9(3) 
   See also  language-defined types 
type conformance   6.3.1(15/2)    [partial ]   3.4(17/2), 8.3(8), 8.3(26/2), 
10.1.4(4/3)    required   3.11.1(5), 4.1.4(14/2), 8.6(26), 
9.1(9.2/3), 9.1(9.5/3), 9.4(11.1/3), 9.4(11.4/3), 9.5.4(3/3), 12.4(5/2) 
type conversion   4.6(1/3)    access   4.6(24.11/2), 4.6(24.18/2), 
4.6(24.19/2), 4.6(47) 
   arbitrary order   1.1.4(18)    array   4.6(24.2/2), 4.6(36)    composite (non-array)   4.6(21/3), 
4.6(40) 
   enumeration   4.6(21.1/2), 4.6(34)    numeric   4.6(24.1/2), 4.6(29)    unchecked   13.9(1)    See also  qualified_expression   4.7(1) 
type conversion, implicit    See implicit subtype conversion   
4.6(1/3) 
type extension   3.9(2/2), 3.9.1(1/2) type of a discrete_range   3.6.1(4) type of a range   3.5(4) type parameter    See discriminant   3.7(1/2) 
type profile    See profile, type conformant   
6.3.1(15/2) 
type resolution rules   8.6(20/2)    if any type in a specified class of types is 
expected   8.6(21) 
   if expected type is specific   8.6(22)    if expected type is universal or class-
wide   8.6(21) 
type tag    See tag   3.9(3) 
type-related    aspect   13.1(8.1/3)    aspect   13.1(8/3)    operational item   13.1(8.1/3)    representation item   13.1(8/3) type_conversion   4.6(2)    used   4.1(2/3), P 
   See also  unchecked type conversion   
13.9(1) 
type_declaration   3.2.1(2)    used   3.1(3/3), P 
type_definition   3.2.1(4/2)    used   3.2.1(3/3), P 
Type_Invariant aspect   7.3.2(2/3) Type_Invariant'Class aspect   7.3.2(3/3) Type_Set    in Ada.Text_IO   A.10.1(7) 
types    of a profile   6.1(29)  
U 
 UC_A_Acute    in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Circumflex    in Ada.Characters.Latin_1   A.3.3(23) UC_A_Diaeresis 
   in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Grave    in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Ring    in Ada.Characters.Latin_1   A.3.3(23) 
UC_A_Tilde    in Ada.Characters.Latin_1   A.3.3(23) 
UC_AE_Diphthong    in Ada.Characters.Latin_1   A.3.3(23) 
UC_C_Cedilla    in Ada.Characters.Latin_1   A.3.3(23) 
UC_E_Acute    in Ada.Characters.Latin_1   A.3.3(23) 
UC_E_Circumflex    in Ada.Characters.Latin_1   A.3.3(23) 
UC_E_Diaeresis    in Ada.Characters.Latin_1   A.3.3(23) 
UC_E_Grave    in Ada.Characters.Latin_1   A.3.3(23) 
UC_I_Acute    in Ada.Characters.Latin_1   A.3.3(23) 
UC_I_Circumflex    in Ada.Characters.Latin_1   A.3.3(23) 
UC_I_Diaeresis    in Ada.Characters.Latin_1   A.3.3(23) 
UC_I_Grave    in Ada.Characters.Latin_1   A.3.3(23) 
UC_Icelandic_Eth    in Ada.Characters.Latin_1   A.3.3(24) 
UC_Icelandic_Thorn    in Ada.Characters.Latin_1   A.3.3(24) 
UC_N_Tilde    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Acute    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Circumflex    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Diaeresis    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Grave    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Oblique_Stroke    in Ada.Characters.Latin_1   A.3.3(24) 
UC_O_Tilde    in Ada.Characters.Latin_1   A.3.3(24) 
UC_U_Acute    in Ada.Characters.Latin_1   A.3.3(24) 
UC_U_Circumflex    in Ada.Characters.Latin_1   A.3.3(24) 
UC_U_Diaeresis    in Ada.Characters.Latin_1   A.3.3(24) 
UC_U_Grave    in Ada.Characters.Latin_1   A.3.3(24) 
UC_Y_Acute    in Ada.Characters.Latin_1   A.3.3(24) 
UCHAR_MAX    in Interfaces.C   B.3(6) 
ultimate ancestor    of a type   3.4.1(10/2) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      916 unary adding operator   4.5.4(1) 
unary operator   4.5(9) unary_adding_operator   4.5(5)    used   4.4(4), P 
Unbiased_Rounding attribute   A.5.3(39) Unbounded    child of  Ada.Strings   A.4.5(3) 
   in Ada.Text_IO   A.10.1(5) 
Unbounded_IO    child of  Ada.Text_IO   A.10.12(3/2) 
   child of  Ada.Wide_Text_IO   A.11(5/3) 
   child of  Ada.Wide_Wide_Text_IO   
A.11(5/3) 
Unbounded_Priority_Queues    child of  Ada.Containers   A.18.30(2/3) 
Unbounded_Slice    in Ada.Strings.Unbounded   
A.4.5(22.1/2), A.4.5(22.2/2) 
Unbounded_String    in Ada.Strings.Unbounded   A.4.5(4/2) 
Unbounded_Synchronized_Queues    child of  Ada.Containers   A.18.28(2/3) 
unchecked storage deallocation   
13.11.2(1) 
unchecked type conversion   13.9(1) unchecked union object   B.3.3(6/3) unchecked union subtype   B.3.3(6/3) unchecked union type   B.3.3(6/3) Unchecked_Access attribute   13.10(3), 
H.4(18) 
   See also  Access attribute   3.10.2(24/1) 
Unchecked_Conversion    child of  Ada   13.9(3/3) 
Unchecked_Deallocation    child of  Ada   13.11.2(3/3) 
Unchecked_Union aspect   B.3.3(3.2/3) Unchecked_Union pragma   J.15.6(2/3), 
L(37.2/3) 
unconstrained   3.2(9)    object   3.3.1(9/2)    object   6.4.1(16)    subtype   3.2(9), 3.4(6), 3.5(7), 
3.5.1(10), 3.5.4(9), 3.5.4(10), 3.5.7(11), 3.5.9(13), 3.5.9(16), 3.6(15), 3.6(16), 3.7(26), 3.9(15) 
   subtype   3.10(14/3)    subtype   K.2(33) unconstrained_array_definition   3.6(3)    used   3.6(2), P 
undefined result   11.6(5) underline   2.1(15/3)    used   2.4.1(3), 2.4.2(4), P 
Uniformly_Distributed subtype of  Float 
   in Ada.Numerics.Float_Random   
A.5.2(8) 
uninitialized allocator   4.8(4) uninitialized variables   13.9.1(2)    [partial ]   3.3.1(21/3) union 
   C   B.3.3(1/3)    in Ada.Containers.Hashed_Sets   
A.18.8(26/2), A.18.8(27/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(27/2), A.18.9(28/2) 
unit consistency   E.3(6) unit matrix    complex matrix   G.3.2(148/2)    real matrix   G.3.1(80/2) unit vector    complex vector   G.3.2(90/2)    real vector   G.3.1(48/2) Unit_Matrix    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(51/2) 
   in Ada.Numerics.Generic_Real_Arrays   
G.3.1(29/2) 
Unit_Vector    in Ada.Numerics.Generic_Complex_-
Arrays   G.3.2(24/2) 
   in Ada.Numerics.Generic_Real_Arrays   
G.3.1(14/2) 
universal type   3.4.1(6/2) universal_access    [partial ]   3.4.1(6/2), 4.2(8/2) 
universal_fixed    [partial ]   3.4.1(6/2), 3.5.6(4) 
universal_integer    [partial ]   3.4.1(6/2), 3.5.4(14), 
3.5.4(30), 4.2(8/2) 
universal_real    [partial ]   3.4.1(6/2), 3.5.6(4), 4.2(8/2) 
unknown discriminants   3.7(26) unknown_discriminant_part   3.7(3)    used   3.7(2/2), P 
Unknown_Zone_Error    in Ada.Calendar.Time_Zones   
9.6.1(5/2) 
unmarshalling   E.4(9) unpolluted   13.13.1(2) unsigned    in Interfaces.C   B.3(9) 
   in Interfaces.COBOL   B.4(23) 
unsigned type    See modular type   3.5.4(1) 
unsigned_char    in Interfaces.C   B.3(10) 
unsigned_long    in Interfaces.C   B.3(9) 
unsigned_short    in Interfaces.C   B.3(9) 
unspecified   1.1.3(18)    [partial ]   2.1(5/3), 3.9(4/2), 3.9(12.5/3), 
4.5.2(13), 4.5.2(24.2/1), 4.5.5(21), 6.1.1(34/3), 6.1.1(35/3), 6.2(11/3), 7.2(5/3), 7.6(17.4/3), 9.8(14), 9.10(1/3), 10.2(26), 11.1(6), 11.4.1(10.1/3), 11.5(27/2), 13.1(18), 13.7.2(5/2), 13.9.1(7), 13.11(20), 13.11(21.6/3), 13.13.2(36/2), A.1(1/3), A.5.1(34), A.5.2(28), A.5.2(34), A.5.3(41.3/2), A.7(6), A.10(8), A.10.7(8/3), A.10.7(12/3), A.10.7(17.3/2), A.10.7(19), A.14(1), A.18.2(231/3), A.18.2(252/2), A.18.2(83/2), A.18.3(145/3), A.18.3(157/2), A.18.3(55/2), A.18.4(3/2), A.18.4(80/2), A.18.5(43/2), A.18.5(44/2), A.18.5(45/2), A.18.5(46/2), A.18.6(56/3), A.18.6(57/2), A.18.7(3/2), A.18.7(101/2), A.18.7(87/2), A.18.7(88/2), A.18.8(65/2), A.18.8(66.1/3), A.18.8(66/2), A.18.8(67/2), A.18.8(68/2), A.18.8(86/2), A.18.8(87/2), A.18.9(114/2), A.18.9(79.1/3), A.18.9(79/3), A.18.9(80/2), A.18.10(227/3), A.18.10(72/3), A.18.26(5/3), A.18.26(9.4/3), A.18.26(9/3), D.2.2(7.1/2), D.8(19), E.3(5/1), G.1.1(40), G.1.2(33), G.1.2(48), H(4.1), H.2(1), K.2(136.4/2) 
Unsuppress pragma   11.5(4.1/2), 
L(37.3/2) 
update    the value of an object   3.3(14)    in Interfaces.C.Strings   B.3.1(18), 
B.3.1(19) 
Update_Element    in Ada.Containers.Doubly_Linked_-
Lists   A.18.3(17/2) 
   in Ada.Containers.Hashed_Maps   
A.18.5(17/2) 
   in Ada.Containers.Indefinite_Holders   
A.18.18(15/3) 
   in Ada.Containers.Multiway_Trees   
A.18.10(27/3) 
   in Ada.Containers.Ordered_Maps   
A.18.6(16/2) 
   in Ada.Containers.Vectors   
A.18.2(33/2), A.18.2(34/2) 
Update_Element_Preserving_Key    in Ada.Containers.Hashed_Sets   
A.18.8(58/2) 
   in Ada.Containers.Ordered_Sets   
A.18.9(73/2) 
Update_Error    in Interfaces.C.Strings   B.3.1(20) 
upper bound    of a range   3.5(4) 
Ada Reference Manual — 2012 Edition 
917      13 December 2012 Index upper-case letter 
   a category of Character   A.3.2(26) Upper_Case_Map    in Ada.Strings.Maps.Constants   
A.4.6(5) 
Upper_Set    in Ada.Strings.Maps.Constants   
A.4.6(4) 
US    in Ada.Characters.Latin_1   A.3.3(6) 
usage name   3.1(10) use-visible   8.3(4), 8.4(9) use_clause   8.4(2)    used   3.11(4/1), 10.1.2(3), 12.1(5), P 
Use_Error    in Ada.Direct_IO   A.8.4(18) 
   in Ada.Directories   A.16(43/2) 
   in Ada.IO_Exceptions   A.13(4) 
   in Ada.Sequential_IO   A.8.1(15) 
   in Ada.Streams.Stream_IO   A.12.1(26) 
   in Ada.Text_IO   A.10.1(85) 
use_package_clause   8.4(3)    used   8.4(2), P 
use_type_clause   8.4(4/3)    used   8.4(2), P 
user-defined assignment   7.6(1) user-defined heap management   13.11(1) user-defined operator   6.6(1) user-defined storage management   
13.11(1) 
UTC_Time_Offset    in Ada.Calendar.Time_Zones   
9.6.1(6/2) 
UTF-16   A.4.11(46/3) UTF-8   A.4.11(46/3) UTF_16_Wide_String subtype of  
Wide_String 
   in Ada.Strings.UTF_Encoding   
A.4.11(7/3) 
UTF_8_String subtype of  String 
   in Ada.Strings.UTF_Encoding   
A.4.11(6/3) 
UTF_Encoding    child of  Ada.Strings   A.4.11(3/3) 
UTF_String subtype of  String 
   in Ada.Strings.UTF_Encoding   
A.4.11(5/3) 
 
V 
 Val attribute   3.5.5(5) Valid    in Ada.Text_IO.Editing   F.3.3(5), 
F.3.3(12) 
   in Interfaces.COBOL   B.4(33), B.4(38), 
B.4(43) 
Valid attribute   13.9.2(3/3), H(6) Value 
   in Ada.Calendar.Formatting   
9.6.1(36/2), 9.6.1(38/2) 
   in Ada.Environment_Variables   
A.17(4.1/3), A.17(4/2) 
   in Ada.Numerics.Discrete_Random   
A.5.2(26) 
   in Ada.Numerics.Float_Random   
A.5.2(14) 
   in Ada.Strings.Maps   A.4.2(21) 
   in Ada.Strings.Wide_Maps   A.4.7(21) 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(21/2) 
   in Ada.Task_Attributes   C.7.2(4) 
   in Interfaces.C.Pointers   B.3.2(6), 
B.3.2(7) 
   in Interfaces.C.Strings   B.3.1(13), 
B.3.1(14), B.3.1(15), B.3.1(16) 
Value attribute   3.5(52) value conversion   4.6(5/2) values    belonging to a subtype   3.2(8/2) variable   3.3(13/3) variable indexing   4.1.6(16/3) variable object   3.3(13/3) variable view   3.3(13/3) Variable_Indexing aspect   4.1.6(3/3) variant   3.8.1(3)    used   3.8.1(2), P 
   See also  tagged type   3.9(1) 
variant_part   3.8.1(2)    used   3.8(4), P 
Vector    in Ada.Containers.Vectors   A.18.2(8/3) 
vector container   A.18.2(1/2) Vector_Iterator_Interfaces    in Ada.Containers.Vectors   
A.18.2(11.2/3) 
Vectors    child of  Ada.Containers   A.18.2(6/3) 
version    of a compilation unit   E.3(5/1) Version attribute   E.3(3) vertical line   2.1(15/3) Vertical_Line    in Ada.Characters.Latin_1   A.3.3(14) 
view   3.1(7), N(42/2)    of a subtype (implied)   3.1(7.1/3)    of a type (implied)   3.1(7.1/3)    of an object (implied)   3.1(7.1/3) view conversion   4.6(5/2) virtual function    See dispatching subprogram   3.9.2(1/2) 
Virtual_Length    in Interfaces.C.Pointers   B.3.2(13) 
visibility    direct   8.3(2), 8.3(21)    immediate   8.3(4), 8.3(21)    use clause   8.3(4), 8.4(9) visibility rules   8.3(1) visible   8.3(2), 8.3(14) 
   aspect_specification   8.3(23.1/3)    attribute_definition_clause   8.3(23.1/3)    within a pragma in a context_clause   
10.1.6(3) 
   within a pragma that appears at the place 
of a compilation unit   10.1.6(5) 
   within a use_clause in a context_clause   
10.1.6(3) 
   within a with_clause   10.1.6(2/2)    within the parent_unit_name of a library 
unit   10.1.6(2/2) 
   within the parent_unit_name of a 
subunit   10.1.6(4) 
visible part   8.2(5)    of a formal package   12.7(10/2)    of a generic unit   8.2(8)    of a package (other than a generic 
formal package)   7.1(6/2) 
   of a protected unit   9.4(11/2)    of a task unit   9.1(9)    of a view of a callable entity   8.2(6)    of a view of a composite type   8.2(7) volatile   C.6(8/3) Volatile aspect   C.6(6.4/3) Volatile pragma   J.15.8(3/3), L(38.1/3) Volatile_Components aspect   C.6(6.7/3) Volatile_Components pragma   
J.15.8(6/3), L(39.1/3) 
VT    in Ada.Characters.Latin_1   A.3.3(5) 
VTS    in Ada.Characters.Latin_1   A.3.3(17) 
 
W 
 Wait_For_Release    in Ada.Synchronous_Barriers   
D.10.1(6/3) 
wchar_array    in Interfaces.C   B.3(33/3) 
wchar_t    in Interfaces.C   B.3(30/1) 
Wednesday    in Ada.Calendar.Formatting   
9.6.1(17/2) 
well-formed picture String    for edited output   F.3.1(1/3) Wide_Bounded    child of  Ada.Strings   A.4.7(1/3) 
Wide_Character   3.5.2(3/3)    in Standard   A.1(36.1/3) 
Wide_Character_Mapping    in Ada.Strings.Wide_Maps   A.4.7(20/2) 
Wide_Character_Mapping_Function    in Ada.Strings.Wide_Maps   A.4.7(26) 
Wide_Character_Range    in Ada.Strings.Wide_Maps   A.4.7(6) 
Wide_Character_Ranges    in Ada.Strings.Wide_Maps   A.4.7(7) 
Ada Reference Manual — 2012 Edition 
Index 13 December 2012      918 Wide_Character_Sequence subtype of  
Wide_String 
   in Ada.Strings.Wide_Maps   A.4.7(16) 
Wide_Character_Set    in Ada.Strings.Wide_Maps   A.4.7(4/2) 
   in Ada.Strings.Wide_Maps.Wide_-
Constants   A.4.8(48/2) 
Wide_Characters    child of  Ada   A.3.1(4/2) 
Wide_Constants    child of  Ada.Strings.Wide_Maps   
A.4.7(1/3), A.4.8(28/2) 
Wide_Equal_Case_Insensitive    child of  Ada.Strings   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Bounded   
A.4.7(1/3) 
   child of  Ada.Strings.Wide_Fixed   
A.4.7(1/3) 
   child of  Ada.Strings.Wide_Unbounded   
A.4.7(1/3) 
Wide_Exception_Name    in Ada.Exceptions   11.4.1(2/2), 
11.4.1(5/2) 
Wide_Expanded_Name    in Ada.Tags   3.9(7/2) 
Wide_Fixed    child of  Ada.Strings   A.4.7(1/3) 
Wide_Hash    child of  Ada.Strings   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Bounded   
A.4.7(1/3) 
   child of  Ada.Strings.Wide_Fixed   
A.4.7(1/3) 
   child of  Ada.Strings.Wide_Unbounded   
A.4.7(1/3) 
Wide_Hash_Case_Insensitive    child of  Ada.Strings   A.4.7(1/3) 
   child of  Ada.Strings.Wide_Bounded   
A.4.7(1/3) 
   child of  Ada.Strings.Wide_Fixed   
A.4.7(1/3) 
   child of  Ada.Strings.Wide_Unbounded   
A.4.7(1/3) 
Wide_Image attribute   3.5(28) Wide_Maps    child of  Ada.Strings   A.4.7(3) 
wide_nul    in Interfaces.C   B.3(31/1) 
Wide_Space    in Ada.Strings   A.4.1(4/2) 
Wide_String    in Standard   A.1(41/3) 
Wide_Strings    child of  Ada.Strings.UTF_Encoding   
A.4.11(30/3) 
Wide_Text_IO    child of  Ada   A.11(2/2) 
Wide_Unbounded    child of  Ada.Strings   A.4.7(1/3) 
Wide_Value attribute   3.5(40) Wide_Wide_Bounded 
   child of  Ada.Strings   A.4.8(1/3) 
Wide_Wide_Character   3.5.2(4/3)    in Standard   A.1(36.2/3) 
Wide_Wide_Character_Mapping    in Ada.Strings.Wide_Wide_Maps   
A.4.8(20/2) 
Wide_Wide_Character_Mapping_Functio
n 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(26/2) 
Wide_Wide_Character_Range    in Ada.Strings.Wide_Wide_Maps   
A.4.8(6/2) 
Wide_Wide_Character_Ranges    in Ada.Strings.Wide_Wide_Maps   
A.4.8(7/2) 
Wide_Wide_Character_Sequence subtype 
of Wide_Wide_String 
   in Ada.Strings.Wide_Wide_Maps   
A.4.8(16/2) 
Wide_Wide_Character_Set    in Ada.Strings.Wide_Wide_Maps   
A.4.8(4/2) 
Wide_Wide_Characters    child of  Ada   A.3.1(6/2) 
Wide_Wide_Constants    child of  Ada.Strings.Wide_Wide_Maps   
A.4.8(1/3) 
Wide_Wide_Equal_Case_Insensitive    child of  Ada.Strings   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_-
Bounded   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Fixed   
A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_-
Unbounded   A.4.8(1/3) 
Wide_Wide_Exception_Name    in Ada.Exceptions   11.4.1(2/2), 
11.4.1(5/2) 
Wide_Wide_Expanded_Name    in Ada.Tags   3.9(7/2) 
Wide_Wide_Fixed    child of  Ada.Strings   A.4.8(1/3) 
Wide_Wide_Hash    child of  Ada.Strings   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_-
Bounded   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Fixed   
A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_-
Unbounded   A.4.8(1/3) 
Wide_Wide_Hash_Case_Insensitive    child of  Ada.Strings   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_-
Bounded   A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_Fixed   
A.4.8(1/3) 
   child of  Ada.Strings.Wide_Wide_-
Unbounded   A.4.8(1/3) Wide_Wide_Image attribute   3.5(27.1/2) 
Wide_Wide_Maps    child of  Ada.Strings   A.4.8(3/2) 
Wide_Wide_Space    in Ada.Strings   A.4.1(4/2) 
Wide_Wide_String    in Standard   A.1(42.1/3) 
Wide_Wide_Strings    child of  Ada.Strings.UTF_Encoding   
A.4.11(38/3) 
Wide_Wide_Text_IO    child of  Ada   A.11(3/2) 
Wide_Wide_Unbounded    child of  Ada.Strings   A.4.8(1/3) 
Wide_Wide_Value attribute   3.5(39.1/2) Wide_Wide_Width attribute   3.5(37.1/2) Wide_Width attribute   3.5(38) Width attribute   3.5(39) with_clause   10.1.2(4/2)    mentioned in   10.1.2(6/2)    named in   10.1.2(6/2)    used   10.1.2(3), P 
within    immediately   8.1(13) word   13.3(8) Word_Size    in System   13.7(13) 
Write    in Ada.Direct_IO   A.8.4(13) 
   in Ada.Sequential_IO   A.8.1(12) 
   in Ada.Storage_IO   A.9(7) 
   in Ada.Streams   13.13.1(6) 
   in Ada.Streams.Stream_IO   A.12.1(18), 
A.12.1(19) 
   in System.RPC   E.5(8) 
Write aspect   13.13.2(38/3) Write attribute   13.13.2(3), 13.13.2(11) Write clause   13.3(7/2), 13.13.2(38/3)  
X 
 xor operator   4.4(1/3), 4.5.1(2)  
Y 
 Year    in Ada.Calendar   9.6(13) 
   in Ada.Calendar.Formatting   
9.6.1(21/2) 
Year_Number subtype of  Integer 
   in Ada.Calendar   9.6(11/2) 
Yen_Sign    in Ada.Characters.Latin_1   A.3.3(21/3) 
Yield    in Ada.Dispatching   D.2.1(1.3/3) 
Yield_To_Higher    in Ada.Dispatching.Non_Preemptive   
D.2.4(2.2/3) 
Ada Reference Manual — 2012 Edition 
919      13 December 2012 Index Yield_To_Same_Or_Higher 
   in Ada.Dispatching.Non_Preemptive   
D.2.4(2.2/3) 
 

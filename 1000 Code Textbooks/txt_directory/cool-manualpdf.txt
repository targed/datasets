CoolAid: The Cool Reference Manual¤
1 Introduction
This manual describes the programming language Cool: the Classroom Object- Oriented Language. Cool
is a small language that can be implemented with reasonable e®ort in a one semester course. Still, Cool
retains many of the features of modern programming languages including objects, static typing, and
automatic memory management.
Cool programs are sets of classes . A class encapsulates the variables and procedures of a data type.
Instances of a class are objects . In Cool, classes and types are identi¯ed; i.e., every class de¯nes a type.
Classes permit programmers to de¯ne new types and associated procedures (or methods ) speci¯c to those
types. Inheritance allows new types to extend the behavior of existing types.
Cool is an expression language. Most Cool constructs are expressions, and every expression has a
value and a type. Cool is type safe : procedures are guaranteed to be applied to data of the correct type.
While static typing imposes a strong discipline on programming in Cool, it guarantees that no runtime
type errors can arise in the execution of Cool programs.
This manual is divided into informal and formal components. For a short, informal overview, the ¯rst
12 pages (through Section 9) su±ces. The formal description begins with Section 10.
2 Getting Started
The reader who wants to get a sense for Cool at the outset should begin by reading, and then write their
own cool-programs and run them. Cool source ¯les have extension .cland Cool assembly ¯les have
extension .s. The Cool compiler is coolc (note that cool is a Linux-binary ¯le). To compile a program:
coolc [ -o fileout ] file1.cl file2.cl ... filen.cl
The compiler compiles the ¯les file1.cl through filen.cl as if they were concatenated together.
Each ¯le must de¯ne a set of complete classes|class de¯nitions may not be split across ¯les. The -o
option speci¯es an optional name to use for the output assembly code. If fileout is not supplied, the
output assembly is named file1.s .
The coolc compiler generates MIPS assembly code. Because not all of the machines the course is
using are MIPS-based, Cool programs are run on a MIPS simulator called spim. To run a cool program,
type
% spim
(spim) load "file.s"
(spim) run
¤Copyright c°1995-2000 by Alex Aiken. All rights reserved.
1
To run a di®erent program during the same spim session, it is necessary to reinitialize the state of the
simulator before loading the new assembly ¯le:
(spim) reinit
An alternative|and faster|way to invoke spim is with a ¯le:
spim -file file.s
This form loads the ¯le, runs the program, and exits spim when the program terminates. Be sure that
thespim we provided is actually used. There may be another version of spim installed in on some
systems, but it will not execute Cool programs. The spim manual is available in the resources folder of
the repository.
The following is a complete transcript of the compilation and execution of list.cl . This program is
very silly, but it does serve to illustrate many of the features of Cool.
% coolc list.cl
% spim
SPIM Version 5.4 of Jan. 17, 1994
Copyright 1990-1994 by James R. Larus (larus@cs.wisc.edu).
All Rights Reserved.
See the file README a full copyright notice.
Loaded: /usa/pollock/public/cool02/lib/trap.handler
(spim) load "list.s"
(spim) run
How many numbers to sort?5
0
1
2
3
4
COOL program successfully executed
(spim) exit
%
3 Classes
All code in Cool is organized into classes. Each class de¯nition must be contained in a single source ¯le,
but multiple classes may be de¯ned in the same ¯le. Class de¯nitions have the form:
class <type> [ inherits <type> ] {
<feature_list>
};
The notation [ ...] denotes an optional construct. All class names are globally visible. Class names
begin with an uppercase letter. Classes may not be rede¯ned.
2
3.1 Features
The body of a class de¯nition consists of a list of feature de¯nitions. A feature is either an attribute or
amethod . An attribute of class Aspeci¯es a variable that is part of the state of objects of class A. A
method of class Ais a procedure that may manipulate the variables and objects of class A.
One of the major themes of modern programming languages is information hiding , which is the idea
that certain aspects of a data type's implementation should be abstract and hidden from users of the
data type. Cool supports information hiding through a simple mechanism: all attributes have scope local
to the class, and all methods have global scope. Thus, the only way to provide access to object state in
Cool is through methods.
Feature names must begin with a lowercase letter. No method name may be de¯ned multiple times in
a class, and no attribute name may be de¯ned multiple times in a class, but a method and an attribute
may have the same name.
A fragment from list.cl illustrates simple cases of both attributes and methods:
class Cons inherits List {
xcar : Int;
xcdr : List;
isNil() : Bool { false };
init(hd : Int, tl : List) : Cons {
{
xcar <- hd;
xcdr <- tl;
self;
}
}
...
};
In this example, the class Cons has two attributes xcar and xcdr and two methods isNil and init.
Note that the types of attributes, as well as the types of formal parameters and return types of methods,
are explicitly declared by the programmer.
Given object cof class Cons and object lof class List, we can set the xcar andxcdr ¯elds by using
the method init:
c.init(1,l)
This notation is object-oriented dispatch . There may be many de¯nitions of init methods in many
di®erent classes. The dispatch looks up the class of the object cto decide which init method to invoke.
Because the class of cisCons, the init method in the Cons class is invoked. Within the invocation, the
variables xcar andxcdr refer to c's attributes. The special variable self refers to the object on which
the method was dispatched, which, in the example, is citself.
There is a special form new C that generates a fresh object of class C. An object can be thought of as
a record that has a slot for each of the attributes of the class as well as pointers to the methods of the
class. A typical dispatch for the init method is:
3
(new Cons).init(1,new Nil)
This example creates a new cons cell and initializes the \car" of the cons cell to be 1and the \cdr" to
benew Nil .1There is no mechanism in Cool for programmers to deallocate objects. Cool has automatic
memory management ; objects that cannot be used by the program are deallocated by a runtime garbage
collector.
Attributes are discussed further in Section 5 and methods are discussed further in Section 6.
3.2 Inheritance
If a class de¯nition has the form
class A inherits B { ... };
then class Ainherits the features of B. In this case Bis the parent class of AandAis achild class of B.
The semantics of A inherits B is that Ahas all of the features de¯ned in Bin addition to its own
features. In the case that a parent and child both de¯ne the same method name, then the de¯nition
given in the child class takes precedence. It is illegal to rede¯ne attribute names. Furthermore, for type
safety, it is necessary to place some restrictions on how methods may be rede¯ned (see Section 6).
There is a distinguished class Object . If a class de¯nition does not specify a parent class, then the
class inherits from Object by default. A class may inherit only from a single class; this is aptly called
\single inheritance."2The parent-child relation on classes de¯nes a graph. This graph may not contain
cycles. For example, if Ainherits from B, then Bmust not inherit from A. Furthermore, if Ainherits from
B, then Bmust have a class de¯nition somewhere in the program. Because Cool has single inheritance, it
follows that if both of these restrictions are satis¯ed, then the inheritance graph forms a tree with Object
as the root.
In addition to Object , Cool has four other basic classes :Int,String ,Bool, and IO. The basic classes
are discussed in Section 8.
4 Types
In Cool, every class name is also a type. In addition, there is a type SELF TYPE that can be used in
special circumstances.
Atype declaration has the form x:C, where xis a variable and Cis a type. Every variable must have a
type declaration at the point it is introduced, whether that is in a let,case, or as the formal parameter
of a method. The types of all attributes must also be declared.
The basic type rule in Cool is that if a method or variable expects a value of type A, then any value
of type Bmay be used instead, provided that Ais an ancestor of Bin the class hierarchy. In other words,
ifBinherits from A, either directly or indirectly, then a Bcan be used wherever an Awould su±ce.
When an object of class Bmay be used in place of an object of class A, we say that Bconforms toA
or that B·A. As discussed above, conformance is de¯ned in terms of the inheritance graph.
De¯nition 4.1 (Conformance) LetA;B;andCbe types.
²A·Afor all types A
1In this example, Nilis assumed to be a subtype of List.
2Some object-oriented languages allow a class to inherit from multiple classes, which is equally aptly called \multiple
inheritance."
4
²ifAinherits from B, then A·B
²ifA·BandB·Cthen A·C
Because Object is the root of the class hierarchy, it follows that A·Object for all types A.
4.1 SELF TYPE
The type SELF TYPE is used to refer to the type of the self variable. This is useful in classes that will
be inherited by other classes, because it allows the programmer to avoid specifying a ¯xed ¯nal type at
the time the class is written. For example, the program
class Silly {
copy() : SELF_TYPE { self };
};
class Sally inherits Silly { };
class Main {
x : Sally <- (new Sally).copy();
main() : Sally { x };
};
Because SELF TYPE is used in the de¯nition of the copy method, we know that the result of copy is the
same as the type of the self parameter. Thus, it follows that (new Sally).copy() has type Sally ,
which conforms to the declaration of attribute x.
Note that the meaning of SELF TYPE is not ¯xed, but depends on the class in which it is used. In
general, SELF TYPE may refer to the class Cin which it appears, or any class that conforms to C. When it
is useful to make explicit what SELF TYPE may refer to, we use the name of the class Cin which SELF TYPE
appears as an index SELF TYPE C. This subscript notation is not part of Cool syntax|it is used merely
to make clear in what class a particular occurrence of SELF TYPE appears.
From De¯nition 4.1, it follows that SELF TYPE X·SELF TYPE X. There is also a special conformance
rule for SELF TYPE:
SELF TYPE C·BifC·B
Finally, SELF TYPE may be used in the following places: new SELF TYPE, as the return type of a
method, as the declared type of a letvariable, or as the declared type of an attribute. No other uses of
SELF TYPE are permitted.
4.2 Type Checking
The Cool type system guarantees at compile time that execution of a program cannot result in runtime
type errors. Using the type declarations for identi¯ers supplied by the programmer, the type checker
infers a type for every expression in the program.
It is important to distinguish between the type assigned by the type checker to an expression at compile
time, which we shall call the static type of the expression, and the type(s) to which the expression may
evaluate during execution, which we shall call the dynamic types.
5
The distinction between static and dynamic types is needed because the type checker cannot, at
compile time, have perfect information about what values will be computed at runtime. Thus, in general,
the static and dynamic types may be di®erent. What we require, however, is that the type checker's
static types be sound with respect to the dynamic types.
De¯nition 4.2 For any expression e, let Debe a dynamic type of eand let Sebe the static type inferred
by the type checker. Then the type checker is sound if for all expressions eit is the case that De·Se.
Put another way, we require that the type checker err on the side of overestimating the type of an
expression in those cases where perfect accuracy is not possible. Such a type checker will never accept
a program that contains type errors. However, the price paid is that the type checker will reject some
programs that would actually execute without runtime errors.
5 Attributes
An attribute de¯nition has the form
<id> : <type> [ <- <expr> ];
The expression is optional initialization that is executed when a new object is created. The static type
of the expression must conform to the declared type of the attribute. If no initialization is supplied, then
the default initialization is used (see below).
When a new object of a class is created, all of the inherited and local attributes must be initialized.
Inherited attributes are initialized ¯rst in inheritance order beginning with the attributes of the greatest
ancestor class. Within a given class, attributes are initialized in the order they appear in the source text.
Attributes are local to the class in which they are de¯ned or inherited. Inherited attributes cannot
be rede¯ned.
5.1 Void
All variables in Cool are initialized to contain values of the appropriate type. The special value void
is a member of all types and is used as the default initialization for variables where no initialization is
supplied by the user. Note that there is no name for void in Cool; the only way to create a void value
is to declare a variable of some class other than Int,String , orBool and allow the default initialization
to occur.
There is a special form isvoid expr that tests whether a value is void (see Section 7.11). In addition,
void values may be tested for equality. A void value may be passed as an argument, assigned to a variable,
or otherwise used in any context where any value is legitimate, except that a dispatch to or case on void
generates a runtime error.
Variables of the basic classes Int,Bool, and String are initialized specially; see Section 8.
6 Methods
A method de¯nition has the form
<id>(<id> : <type>,...,<id> : <type>): <type> { <expr> };
6
There may be zero or more formal parameters. The identi¯ers used in the formal parameter list must
be distinct. The type of the method body must conform to the declared return type. When a method is
invoked, the formal parameters are bound to the actual arguments and the expression is evaluated; the
resulting value is the meaning of the method invocation. A formal parameter hides any de¯nition of an
attribute of the same name.
To ensure type safety, there are restrictions on the rede¯nition of inherited methods. The rule is
simple: If a class Ainherits a method ffrom an ancestor class B, then Amay override the inherited
de¯nition of fprovided the number of arguments, the types of the formal parameters, and the return
type are exactly the same in both de¯nitions.
To see why some restriction is necessary on the rede¯nition of inherited methods, consider the following
example:
class A {
f(): Int { 1 };
};
class B inherits A {
f(): String { "1" };
};
Letabe an object with dynamic type A. Then
a.f() + 1
is a well-formed expression with value 2. However, we cannot substitute a value of type Bfora, as it would
result in adding a string to a number. Thus, if methods can be rede¯ned arbitrarily, then subclasses may
not simply extend the behavior of their parents, and much of the usefulness of inheritance, as well as
type safety, is lost.
7 Expressions
Expressions are the largest syntactic category in Cool.
7.1 Constants
The simplest expressions are constants. The boolean constants are true andfalse . Integer constants are
unsigned strings of digits such as 0,123, and 007. String constants are sequences of characters enclosed
in double quotes, such as "This is a string." String constants may be at most 1024 characters long.
There are other restrictions on strings; see Section 10.
The constants belong to the basic classes Bool,Int, and String . The value of a constant is an object
of the appropriate basic class.
7.2 Identi¯ers
The names of local variables, formal parameters of methods, self, and class attributes are all expressions.
The identi¯er self may be referenced, but it is an error to assign to self or to bind self in a let, a
case, or as a formal parameter. It is also illegal to have attributes named self.
7
Local variables and formal parameters have lexical scope. Attributes are visible throughout a class in
which they are declared or inherited, although they may be hidden by local declarations within expres-
sions. The binding of an identi¯er reference is the innermost scope that contains a declaration for that
identi¯er, or to the attribute of the same name if there is no other declaration. The exception to this
rule is the identi¯er self, which is implicitly bound in every class.
7.3 Assignment
An assignment has the form
<id> <- <expr>
The static type of the expression must conform to the declared type of the identi¯er. The value is the
value of the expression. The static type of an assignment is the static type of <expr> .
7.4 Dispatch
There are three forms of dispatch in Cool. The three forms di®er only in how the called method is
selected. The most commonly used form of dispatch is
<expr>.<id>(<expr>,...,<expr>)
Consider the dispatch e0:f(e1; : : : ; en). To evaluate this expression, the arguments are evaluated in left-
to-right order, from e1toen. Next, e0is evaluated and its class Cnoted (if e0isvoid a runtime error is
generated). Finally, the method fin class Cis invoked, with the value of e0bound to self in the body
offand the actual arguments bound to the formals as usual. The value of the expression is the value
returned by the method invocation.
Type checking a dispatch involves several steps. Assume e0has static type A. (Recall that this type
is not necessarily the same as the type Cabove. Ais the type inferred by the type checker; Cis the class
of the object computed at runtime, which is potentially any subclass of A.) Class Amust have a method
f, the dispatch and the de¯nition of fmust have the same number of arguments, and the static type of
theith actual parameter must conform to the declared type of the ith formal parameter.
Iffhas return type BandBis a class name, then the static type of the dispatch is B. Otherwise, if f
has return type SELF TYPE, then the static type of the dispatch is A. To see why this is sound, note that
theself parameter of the method fconforms to type A. Therefore, because freturns SELF TYPE, we can
infer that the result must also conform to A. Inferring accurate static types for dispatch expressions is
what justi¯es including SELF TYPE in the Cool type system.
The other forms of dispatch are:
<id>(<expr>,...,<expr>)
<expr>@<type>.id(<expr>,...,<expr>)
The ¯rst form is shorthand for self.<id>(<expr>,...,<expr>) .
The second form provides a way of accessing methods of parent classes that have been hidden by
rede¯nitions in child classes. Instead of using the class of the leftmost expression to determine the
method, the method of the class explicitly speci¯ed is used. For example, e@B.f() invokes the method
fin class Bon the object that is the value of e. For this form of dispatch, the static type to the left of
\@"must conform to the type speci¯ed to the right of \@".
8
7.5 Conditionals
A conditional has the form
if <expr> then <expr> else <expr> fi
The semantics of conditionals is standard. The predicate is evaluated ¯rst. If the predicate is true,
then the then branch is evaluated. If the predicate is false , then the else branch is evaluated. The
value of the conditional is the value of the evaluated branch.
The predicate must have static type Bool. The branches may have any static types. To specify the
static type of the conditional, we de¯ne an operation t(pronounced \join") on types as follows. Let
A,B,D be any types other than SELF TYPE. The least type of a set of types means the least element with
respect to the conformance relation ·.
AtB= the least type Csuch that A·CandB·C
SELF TYPE DtSELF TYPE D=SELF TYPE D
SELF TYPE DtA=DtA
AtSELF TYPE D=AtD
LetTand Fbe the static types of the branches of the conditional. Then the static type of the
conditional is TtF.
7.6 Loops
A loop has the form
while <expr> loop <expr> pool
The predicate is evaluated before each iteration of the loop. If the predicate is false , the loop terminates
andvoid is returned. If the predicate is true, the body of the loop is evaluated and the process repeats.
The predicate must have static type Bool. The body may have any static type. The static type of a
loop expression is Object .
7.7 Blocks
A block has the form
{ <expr>; ... <expr>; }
The expressions are evaluated in left-to-right order. Every block has at least one expression; the value
of a block is the value of the last expression. The expressions of a block may have any static types. The
static type of a block is the static type of the last expression.
An occasional source of confusion in Cool is the use of semi-colons. Semi-colons are used as terminators
in lists of expressions (e.g., the block syntax above) and not as expression separators. Semi-colons also
terminate other Cool constructs, see Section 11 for details.
9
7.8 Let
A let expression has the form
let <id1> : <type1> [ <- <expr1> ], ..., <idn> : <typen> [ <- <exprn> ] in <expr>
The optional expressions are initialization ; the other expression is the body. A letis evaluated as
follows. First <expr1> is evaluated and the result bound to <id1> . Then <expr2> is evaluated and the
result bound to <id2> , and so on, until all of the variables in the letare initialized. (If the initialization
of<idk> is omitted, the default initialization of type <typek> is used.) Next the body of the letis
evaluated. The value of the letis the value of the body.
The letidenti¯ers <id1>,...,<idn> are visible in the body of the let. Furthermore, identi¯ers
<id1>,...,<idk> are visible in the initialization of <idm> for any m > k .
If an identi¯er is de¯ned multiple times in a let, later bindings hide earlier ones. Identi¯ers introduced
byletalso hide any de¯nitions for the same names in containing scopes. Every letexpression must
introduce at least one identi¯er.
The type of an initialization expression must conform to the declared type of the identi¯er. The type
ofletis the type of the body.
The scope of a letextends as far (encompasses as many tokens) as possible.
7.9 Case
A case expression has the form
case <expr0> of
<id1> : <type1> => <expr1>;
. . .
<idn> : <typen> => <exprn>;
esac
Case expressions provide runtime type tests on objects. First, expr0 is evaluated and its dynamic type
Cnoted (if expr0 evaluates to void a run-time error is produced). Next, from among the branches the
branch with the least type <typek> such that C·<typek> is selected. The identi¯er <idk> is bound
to the value of <expr0> and the expression <exprk> is evaluated. The result of the case is the value
of<exprk> . If no branch can be selected for evaluation, a run-time error is generated. Every case
expression must have at least one branch.
For each branch, let Tibe the static type of <expri> . The static type of a case expression isF
1·i·nTi.
The identi¯er idintroduced by a branch of a case hides any variable or attribute de¯nition for idvisible
in the containing scope.
The case expression has no special construct for a \default" or \otherwise" branch. The same a®ect
is achieved by including a branch
x : Object => ...
because every type is ·toObject .
The case expression provides programmers a way to insert explicit runtime type checks in situa-
tions where static types inferred by the type checker are too conservative. A typical situation is that
a programmer writes an expression eand type checking infers that ehas static type A. However, the
programmer may know that, in fact, the dynamic type of eis always Bfor some B·A. This information
can be captured using a case expression:
10
case e of x : B => ...
In the branch the variable xis bound to the value of ebut has the more speci¯c static type B.
7.10 New
Anewexpression has the form
new <type>
The value is a fresh object of the appropriate class. If the type is SELF TYPE, then the value is a fresh
object of the class of self in the current scope. The static type is <type> .
7.11 Isvoid
The expression
isvoid expr
evaluates to true ifexpr isvoid and evaluates to false ifexpr is not void.
7.12 Arithmetic and Comparison Operations
Cool has four binary arithmetic operations: +, -, *, / . The syntax is
expr1 <op> expr2
To evaluate such an expression ¯rst expr1 is evaluated and then expr2 . The result of the operation is
the result of the expression.
The static types of the two sub-expressions must be Int. The static type of the expression is Int.
Cool has only integer division.
Cool has three comparison operations: <, <=, = . For <and <=the rules are exactly the same as
for the binary arithmetic operations, except that the result is a Bool. The comparison =is a special
case. If either <expr1> or<expr2> has static type Int,Bool, orString , then the other must have the
same static type. Any other types, including SELF TYPE, may be freely compared. On non-basic objects,
equality simply checks for pointer equality (i.e., whether the memory addresses of the objects are the
same). Equality is de¯ned for void.
In principle, there is nothing wrong with permitting equality tests between, for example, Bool and
Int. However, such a test must always be false and almost certainly indicates some sort of programming
error. The Cool type checking rules catch such errors at compile-time instead of waiting until runtime.
Finally, there is one arithmetic and one logical unary operator. The expression ~<expr> is the integer
complement of <expr> . The expression <expr> must have static type Intand the entire expression
has static type Int. The expression not <expr> is the boolean complement of <expr> . The expression
<expr> must have static type Bool and the entire expression has static type Bool.
11
8 Basic Classes
8.1 Object
The Object class is the root of the inheritance graph. Methods with the following declarations are
de¯ned:
abort() : Object
type_name() : String
copy() : SELF_TYPE
The method abort halts program execution with an error message. The method type name returns a
string with the name of the class of the object. The method copy produces a shallow copy of the object.3
8.2 IO
The IOclass provides the following methods for performing simple input and output operations:
out_string(x : String) : SELF_TYPE
out_int(x : Int) : SELF_TYPE
in_string() : String
in_int() : Int
The methods outstring and outintprint their argument and return their self parameter. The
method instring reads a string from the standard input, up to but not including a newline character.
The method inintreads a single integer, which may be preceded by whitespace. Any characters following
the integer, up to and including the next newline, are discarded by inint.
A class can make use of the methods in the IOclass by inheriting from IO. It is an error to rede¯ne
theIOclass.
8.3 Int
The Intclass provides integers. There are no methods special to Int. The default initialization for
variables of type Intis 0 (not void). It is an error to inherit from or rede¯ne Int.
8.4 String
The String class provides strings. The following methods are de¯ned:
length() : Int
concat(s : String) : String
substr(i : Int, l : Int) : String
The method length returns the length of the self parameter. The method concat returns the string
formed by concatenating safter self. The method substr returns the substring of its self parameter
beginning at position iwith length l; string positions are numbered beginning at 0. A runtime error is
generated if the speci¯ed substring is out of range.
The default initialization for variables of type String is""(not void). It is an error to inherit from
or rede¯ne String .
3A shallow copy of acopies aitself, but does not recursively copy objects that apoints to.
12
8.5 Bool
The Bool class provides true and false . The default initialization for variables of type Bool isfalse
(not void). It is an error to inherit from or rede¯ne Bool.
9 Main Class
Every program must have a class Main. Furthermore, the Main class must have a method main that
takes no formal parameters. The main method must be de¯ned in class Main (not inherited from another
class). A program is executed by evaluating (new Main).main() .
The remaining sections of this manual provide a more formal de¯nition of Cool. There are four sections
covering lexical structure (Section 10), grammar (Section 11), type rules (Section 12), and operational
semantics (Section 13).
10 Lexical Structure
The lexical units of Cool are integers, type identi¯ers, object identi¯ers, special notation, strings, key-
words, and white space.
10.1 Integers, Identi¯ers, and Special Notation
Integers are non-empty strings of digits 0-9. Identi¯ers are strings (other than keywords) consisting of
letters, digits, and the underscore character. Type identi¯ers begin with a capital letter; object identi¯ers
begin with a lower case letter. There are two other identi¯ers, selfandSELF TYPE that are treated
specially by Cool but are not treated as keywords. The special syntactic symbols (e.g., parentheses,
assignment operator, etc.) are given in Figure 1.
10.2 Strings
Strings are enclosed in double quotes "..." . Within a string, a sequence ` nc' denotes the character `c',
with the exception of the following:
nb backspace
nt tab
nn newline
nf formfeed
A non-escaped newline character may not appear in a string:
"This is not
OK"
A string may not contain EOF. A string may not contain the null (character n0). Any other character
may be included in a string. Strings cannot cross ¯le boundaries.
13
10.3 Comments
There are two forms of comments in Cool. Any characters between two dashes \ { {" and the next
newline (or EOF, if there is no next newline) are treated as comments. Comments may also be written
by enclosing text in ( ¤: : :¤). The latter form of comment may be nested. Comments cannot cross ¯le
boundaries.
10.4 Keywords
The keywords of cool are: class, else, false, ¯, if, in, inherits, isvoid, let, loop, pool, then, while,
case, esac, new, of, not, true. Except for the constants true andfalse , keywords are case insensitive.
To conform to the rules for other objects, the ¯rst letter of true andfalse must be lowercase; the trailing
letters may be upper or lower case.
10.5 White Space
White space consists of any sequence of the characters: blank, newline, nf;nr;nt;nv.
11 Cool Syntax
Figure 1 provides a speci¯cation of Cool syntax. The speci¯cation is not context-free; for convenience,
we also use some regular expression notation. Speci¯cally, A¤means zero or more A's in succession; A+
means one or more A's. The special notation A;¤means zero or more A's terminated by semicolons. The
special notation A;¤means zero or more A's separated by commas. Separators di®er from terminators
in that the terminator always appears at the end of the list; a separator is never included at the end of
a list. In Cool, semicolons are always terminators and commas are always separators. Items in square
brackets [ : : :] are optional. Double braces [ [ ] ] are not part of Cool; they are used in the grammar as a
meta-symbol to show association of grammar operations.
11.1 Precedence
The precedence of in¯x binary and pre¯x unary operations, from highest to lowest, is given by the
following table:
.
@
~
isvoid
* /
+ -
<= < =
not
<-
All binary operations are left-associative, with the exception of assignment, which is right-associative,
and the three comparison operations, which do not associate.
14
program ::= class;+
class ::=class TYPE [ inherits TYPE] ffeature ;¤g
feature ::= ID( formal ;¤) : TYPE fexprg
jID : TYPE [ <-expr ]
formal ::= ID : TYPE
expr ::= ID <-expr
jexpr[@TYPE] :ID(expr;¤)
jID(expr;¤)
jifexprthen exprelse expr¯
jwhile exprloop exprpool
j f expr;+g
jlet[ [ID : TYPE [ <-expr ];] ]+inexpr
jcase exprof[ [ID : TYPE = >expr; ] ]+esac
jnew TYPE
jisvoid expr
jexpr +expr
jexpr¡expr
jexpr¤expr
jexpr=expr
j~expr
jexpr<expr
jexpr<=expr
jexpr=expr
jnotexpr
j(expr)
jID
jinteger
jstring
jtrue
jfalse
Figure 1: Cool syntax.
15
12 Type Rules
This section formally de¯nes the type rules of Cool. The type rules de¯ne the type of every Cool expression
in a given context. The context is the type environment , which describes the type of every unbound
identi¯er appearing in an expression. The type environment is described in Section 12.1. Section 12.2
gives the type rules.
12.1 Type Environments
To a ¯rst approximation, type checking in Cool can be thought of as a bottom-up algorithm: the type of
an expression eis computed from the (previously computed) types of e's subexpressions. For example,
an integer 1has type Int; there are no subexpressions in this case. As another example, if enhas type
X, then the expression fe1;: : :;en;ghas type X.
A complication arises in the case of an expression v, where vis an object identi¯er. It is not possible
to say what the type of vis in a strictly bottom-up algorithm; we need to know the type declared for v
in the larger expression. Such a declaration must exist for every object identi¯er in valid Cool programs.
To capture information about the types of identi¯ers, we use a type environment . The environment
consists of three parts: a method environment M, an object environment O, and the name of the
current class in which the expression appears. The method environment and object environment are
both functions (also called mappings ). The object environment is a function of the form
O(v) =T
which assigns the type Tto object identi¯er v. The method environment is more complex; it is a function
of the form
M(C; f) = (T1; : : : ; T n¡1; Tn)
where Cis a class name (a type), fis a method name, and t1; : : : ; t nare types. The tuple of types is
thesignature of the method. The interpretation of signatures is that in class Cthe method fhas formal
parameters of types ( t1; : : : ; t n¡1)|in that order|and a return type tn.
Two mappings are required instead of one because object names and method names do not clash|i.e.,
there may be a method and an object identi¯er of the same name.
The third component of the type environment is the name of the current class, which is needed for
type rules involving SELF TYPE.
Every expression eis type checked in a type environment; the subexpressions of emay be type
checked in the same environment or, if eintroduces a new object identi¯er, in a modi¯ed environment.
For example, consider the expression
let c : Int <- 33 in
...
The letexpression introduces a new variable cwith type Int. Let Obe the object component of the
type environment for the let. Then the body of the letis type checked in the object type environment
O[Int=c ]
where the notation O[T=c] is de¯ned as follows:
O[T=c](c) = T
O[T=c](d) = O(d) ifd6=c
16
12.2 Type Checking Rules
The general form a type checking rule is:
...
O; M; C `e:T
The rule should be read: In the type environment for objects O, methods M, and containing class C, the
expression ehas type T. The dots above the horizontal bar stand for other statements about the types
of sub-expressions of e. These other statements are hypotheses of the rule; if the hypotheses are satis¯ed,
then the statement below the bar is true.
The rule for object identi¯ers is simply that if the environment assigns an identi¯er Idtype T, then
Idhas type T.
O(Id) =T
O; M; C `Id:T[Var]
The rule for assignment to a variable is more complex:
O(Id) =T
O; M; C `e1:T0
T0·T
O; M; C `IdÃe1:T0[ASSIGN]
Note that this type rule|as well as others|use the conformance relation ·(see Section 3.2). The rule
says that the assigned expression e1must have a type T0that conforms to the type Tof the identi¯er Id
in the type environment. The type of the whole expression is T0.
The type rules for constants are all easy:
O; M; C `true :Bool[True]
O; M; C `false :Bool[False]
iis an integer constant
O; M; C `i:Int[Int]
sis a string constant
O; M; C `s:String[String]
There are two cases for new, one for new SELF TYPE and one for any other form:
T0=(
SELF TYPE CifT=SELF TYPE
Totherwise
O; M; C `new T :T0[New]
17
Dispatch expressions are the most complex to type check.
O; M; C `e0:T0
O; M; C `e1:T1
...
O; M; C `en:Tn
T0
0=(
CifT0=SELF TYPE C
T0otherwise
M(T0
0; f) = (T0
1; : : : ; T0
n; T0
n+1)
Ti·T0
i1·i·n
Tn+1=(
T0ifT0
n+1=SELF TYPE
T0
n+1otherwise
O; M; C `e0:f(e1; : : : ; e n) :Tn+1[Dispatch]
O; M; C `e0:T0
O; M; C `e1:T1
...
O; M; C `en:Tn
T0·T
M(T; f) = (T0
1; : : : ; T0
n; T0
n+1)
Ti·T0
i1·i·n
Tn+1=(
T0ifT0
n+1=SELF TYPE
T0
n+1otherwise
O; M; C `e0@T:f(e1; : : : ; e n) :Tn+1[StaticDispatch]
To type check a dispatch, each of the subexpressions must ¯rst be type checked. The type T0ofe0
determines the which declaration of the method fis used. The argument types of the dispatch must
conform to the declared argument types. Note that the type of the result of the dispatch is either the
declared return type or T0in the case that the declared return type is SELF TYPE. The only di®erence in
type checking a static dispatch is that the class Tof the method fis given in the dispatch, and the type
T0must conform to T.
The type checking rules for ifandf-gexpressions are straightforward. See Section 7.5 for the
de¯nition of the toperation.
O; M; C `e1:Bool
O; M; C `e2:T2
O; M; C `e3:T3
O; M; C `ife1then e2elsee3¯ :T2tT3[If]
O; M; C `e1:T1
O; M; C `e2:T2
...
O; M; C `en:Tn
O; M; C ` fe1;e2;: : : e n;g:Tn[Sequence]
18
The letrule has some interesting aspects.
T0
0=(
SELF TYPE CifT0=SELF TYPE
T0otherwise
O; M; C `e1:T1
T1·T0
0
O[T0
0=x]; M; C `e2:T2
O; M; C `letx:T0Ãe1ine2:T2[Let-Init]
First, the initialization e1is type checked in an environment without a de¯nition for x. Thus, the variable
xcannot be used in e1unless it already has a de¯nition in an outer scope. Second, the body e2is type
checked in the environment Oextended with the typing x:T0
0. Third, note that the type of xmay be
SELF TYPE.
T0
0=(
SELF TYPE CifT0=SELF TYPE
T0otherwise
O[T0
0=x]; M; C `e1:T1
O; M; C `letx:T0ine1:T1[Let-No-Init]
The rule for letwith no initialization simply omits the conformance requirement. We give type rules
only for a letwith a single variable. Typing a multiple let
let x 1: T1[Ãe1];x2: T2[Ãe2]; : : : ; xn: Tn[Ãen] in e
is de¯ned to be the same as typing
let x 1: T1[Ãe1] in (let x 2: T2[Ãe2]; : : : ; xn: Tn[Ãen] in e )
O; M; C `e0:T0
O[T1=x1]; M; C `e1:T0
1...
O[Tn=xn]; M; C `en:T0
n
O; M; C `casee0ofx1:T1)e1;: : : x n:Tn)en; esac :F
1·i·nT0
i[Case]
Each branch of a case is type checked in an environment where variable xihas type Ti. The type of
the entire case is the join of the types of its branches. The variables declared on each branch of a case
must all have distinct types.
O; M; C `e1:Bool
O; M; C `e2:T2
O; M; C `while e1loop e2pool : Object[Loop]
The predicate of a loop must have type Bool; the type of the entire loop is always Object . An isvoid
test has type Bool:
O; M; C `e1:T1
O; M; C `isvoid e1:Bool[Isvoid]
With the exception of the rule for equality, the type checking rules for the primitive logical, compar-
ison, and arithmetic operations are easy.
O; M; C `e1:Bool
O; M; C ` :e1:Bool[Not]
19
O; M; C `e1:Int
O; M; C `e2:Int
op2 f<;·g
O; M; C `e1op e 2:Bool[Compare]
O; M; C `e1:Int
O; M; C `~e1:Int[Neg]
O; M; C `e1:Int
O; M; C `e2:Int
op2 f¤;+;¡; =g
O; M; C `e1op e 2:Int[Arith]
The wrinkle in the rule for equality is that any types may be freely compared except Int, String
andBool, which may only be compared with objects of the same type.
O; M; C `e1:T1
O; M; C `e2:T2
T12 fInt; String; Bool g _T22 fInt; String; Bool g )T1=T2
O; M; C `e1=e2:Bool[Equal]
The ¯nal cases are type checking rules for attributes and methods. For a class C, let the object
environment OCgive the types of all attributes of C(including any inherited attributes). More formally,
ifxis an attribute (inherited or not) of C, and the declaration of xisx:T, then
OC(x) =(
SELF TYPE CifT=SELF TYPE
Totherwise
The method environment Mis global to the entire program and de¯nes for every class Cthe signatures
of all of the methods of C(including any inherited methods).
The two rules for type checking attribute de¯ninitions are similar the rules for let. The essential
di®erence is that attributes are visible within their initialization expressions. Note that self is bound in
the initialization.
OC(x) =T0
OC[SELF TYPE C=self]; M; C `e1:T1
T1·T0
OC; M; C `x:T0Ãe1;[Attr-Init]
OC(x) =T
OC; M; C `x:T;[Attr-No-Init]
The rule for typing methods checks the body of the method in an environment where OCis extended
with bindings for the formal parameters and self. The type of the method body must conform to the
declared return type.
M(C; f) = (T1; : : : ; T n; T0)
OC[SELF TYPE C=self][T1=x1]: : :[Tn=xn]; M; C `e:T0
0
T0
0·(
SELF TYPE CifT0=SELF TYPE
T0otherwise
OC; M; C `f(x1:T1; : : : ; x n:Tn) :T0feg;[Method]
20
13 Operational Semantics
This section contains a mostly formal presentation of the operational semantics for the Cool language. The
operational semantics de¯ne for every Cool expression what value it should produce in a given context.
The context has three components: an environment, a store, and a self object. These components are
described in the next section. Section 13.2 de¯nes the syntax used to refer to Cool objects, and Section
13.3 de¯nes the syntax used to refer to class de¯nitions.
Keep in mind that a formal semantics is a speci¯cation only|it does not describe an implementation.
The purpose of presenting the formal semantics is to make clear all the details of the behavior of Cool
expressions. How this behavior is implemented is another matter.
13.1 Environment and the Store
Before we can present a semantics for Cool we need a number of concepts and a considerable amount of
notation. An environment is a mapping of variable identi¯ers to locations . Intuitively, an environment
tells us for a given identi¯er the address of the memory location where that identi¯er's value is stored.
For a given expression, the environment must assign a location to all identi¯ers to which the expression
may refer. For the expression, e.g., a+b, we need an environment that maps ato some location and b
to some location. We'll use the following syntax to describe environments, which is very similar to the
syntax of type assumptions used in Section 12.
E= [a:l1; b:l2]
This environment maps ato location l1, and bto location l2.
The second component of the context for the evaluation of an expression is the store. The store maps
locations to values, where values in Cool are just objects. Intuitively, a store tells us what value is stored
in a given memory location. For the moment, assume all values are integers. A store is similar to an
environment:
S= [l1!55; l2!77]
This store maps location l1to value 55 and location l2to value 77.
Given an environment and a store, the value of an identi¯er can be found by ¯rst looking up the
location that the identi¯er maps to in the environment and then looking up the location in the store.
E(a) = l1
S(l1) = 55
Together, the environment and the store de¯ne the execution state at a particular step of the evaluation
of a Cool expression. The double indirection from identi¯ers to locations to values allows us to model
variables. Consider what happens if the value 99 is assigned variable ain the environment and store
de¯ned above. Assigning to a variable means changing the value to which it refers but not its location.
To perform the assignment, we look up the location for ain the environment Eand then change the
mapping for the obtained location to the new value, giving a new store S0.
E(a) = l1
S0=S[99=l1]
The syntax S[v=l] denotes a new store that is identical to the store S, except that S0maps location lto
value v. For all locations l0where l06=l, we still have S0(l0) =S(l0).
21
The store models the contents of memory of the computer during program execution. Assigning to a
variable modi¯es the store.
There are also situations in which the environment is modi¯ed. Consider the following Cool fragment:
let c : Int <- 33 in
c
When evaluating this expression, we must introduce the new identi¯er cinto the environment before
evaluating the body of the let. If the current environment and state are EandS, then we create a new
environment E0and a new store S0de¯ned by:
lc=newloc (S)
E0=E[lc=c]
S0=S[33=lc]
The ¯rst step is to allocate a location for the variable c. The location should be fresh, meaning that the
current store does not have a mapping for it. The function newloc () applied to a store gives us an unused
location in that store. We then create a new environment E0, which maps ctolcbut also contains all
of the mappings of Efor identi¯ers other than c. Note that if calready has a mapping in E, the new
environment E0hides this old mapping. We must also update the store to map the new location to a
value. In this case lcmaps to the value 33, which is the initial value for cas de¯ned by the let-expression.
The example in this subsection oversimpli¯es Cool environments and stores a bit, because simple
integers are not Cool values. Even integers are full-°edged objects in Cool.
13.2 Syntax for Cool Objects
Every Cool value is an object. Objects contain a list of named attributes, a bit like records in C. In
addition, each object belongs to a class. We use the following syntax for values in Cool:
v=X(a1=l1; a2=l2; : : : ; a n=ln)
Read the syntax as follows: The value vis a member of class Xcontaining the attributes a1; : : : ; a nwhose
locations are l1; : : : ; l n. Note that the attributes have an associated location. Intuitively this means that
there is some space in memory reserved for each attribute.
For base objects of Cool (i.e., Ints,String s, and Bools) we use a special case of the above syntax.
Base objects have a class name, but their attributes are not like attributes of normal classes, because
they cannot be modi¯ed. Therefore, we describe base objects using the following syntax:
Int(5)
Bool(true)
String (4;"Cool ")
ForInts and Bools, the meaning is obvious. String s contain two parts, the length and the actual
sequence of ASCII characters.
13.3 Class de¯nitions
In the rules presented in the next section, we need a way to refer to the de¯nitions of attributes and
methods for classes. Suppose we have the following Cool class de¯nition:
22
class B {
s : String <- "Hello";
g (y:String) : Int {
y.concat(s)
};
f (x:Int) : Int {
x+1
};
};
class A inherits B {
a : Int;
b : B <- new B;
f(x:Int) : Int {
x+a
};
};
Two mappings, called class andimplementation , are associated with class de¯nitions. The class
mapping is used to get the attributes, as well as their types and initializations, of a particular class:
class (A) = (s:String Ã"Hello "; a:IntÃ0; b:BÃnew B )
Note that the information for class Acontains everything that it inherited from class B, as well as its own
de¯nitions. If Bhad inherited other attributes, those attributes would also appear in the information for
A. The attributes are listed in the order they are inherited and then in source order: all the attributes
from the greatest ancestor are listed ¯rst in the order in which they textually appear, then the attributes
of the next greatest ancestor, and so on, on down to the attributes de¯ned in the particular class. We
rely on this order in describing how new objects are initialized.
The general form of a class mapping is:
class (X) = (a1:T1Ãe1; : : : ; a n:TnÃen)
Note that every attribute has an initializing expression, even if the Cool program does not specify one for
each attribute. The default initialization for a variable or attribute is the default of its type. The default
ofIntis 0, the default of String is"", the default of Bool isfalse , and the default of any other type
isvoid.4The default of type Tis written DT.
The implementation mapping gives information about the methods of a class. For the above example,
implementation of A is de¯ned as follows:
implementation (A; f) = ( x; x+a)
implementation (A; g) = ( y; y:concat (s))
In general, for a class Xand a method m,
implementation (X; m ) = (x1; x2; : : : ; x n; ebody)
speci¯es that method mwhen invoked from class X, has formal parameters x1; : : : ; x n, and the body of
the method is expression ebody.
4A tiny point: We are allowing void to be used as an expression here. There is no expression for void available to Cool
programmers.
23
13.4 Operational Rules
Equipped with environments, stores, objects, and class de¯nitions, we can now attack the operational
semantics for Cool. The operational semantics is described by rules similar to the rules used in type
checking. The general form of the rules is:
...
so; S; E `e1:v; S0
The rule should be read as: In the context where selfis the object so, the store is S, and the environment
isE, the expression e1evaluates to object vand the new store is S0. The dots above the horizontal bar
stand for other statements about the evaluation of sub-expressions of e1.
Besides an environment and a store, the evaluation context contains a self object so. The self object
is just the object to which the identi¯er self refers if self appears in the expression. We do not place
self in the environment and store because self is not a variable|it cannot be assigned to. Note that
the rules specify a new store after the evaluation of an expression. The new store contains all changes to
memory resulting as side e®ects of evaluating expression e1.
The rest of this section presents and brie°y discusses each of the operational rules. A few cases are
not covered; these are discussed at the end of the section.
so; S 1; E`e1:v1; S2
E(Id) =l1
S3=S2[v1=l1]
so; S 1; E`IdÃe1:v1; S3[Assign]
An assignment ¯rst evaluates the expression on the right-hand side, yielding a value v1. This value is
stored in memory at the address for the identi¯er.
The rules for identi¯er references, self, and constants are straightforward:
E(Id) =l
S(l) =v
so; S; E `Id:v; S[Var]
so; S; E `self : so; S[Self]
so; S; E `true : Bool(true); S[True]
so; S; E `false : Bool(false ); S[False]
iis an integer constant
so; S; E `i:Int(i); S[Int]
sis a string constant
l=length (s)
so; S; E `s:String (l; s); S[String]
24
Anewexpression is more complicated than one might expect:
T0=(
XifT=SELF TYPE andso=X(: : :)
Totherwise
class (T0) = (a1:T1Ãe1; : : : ; a n:TnÃen)
li=newloc (S1);fori= 1: : : n and each liis diistinct
v1=T0(a1=l1; : : : ; a n=ln)
S2=S1[DT1=l1; : : : ; D Tn=ln]
v1; S2;[a1:l1; : : : ; a n:ln]` fa1Ãe1;: : :;anÃen;g:v2; S3
so; S 1; E`newT:v1; S3[New]
The tricky thing in a newexpression is to initialize the attributes in the right order. Note also that,
during initialization, attributes are bound to the default of the appropriate class.
so; S 1; E`e1:v1; S2
so; S 2; E`e2:v2; S3
...
so; S n; E`en:vn; Sn+1
so; S n+1; E`e0:v0; Sn+2
v0=X(a1=la1; : : : ; a m=lam)
implementation (X; f) = (x1; : : : ; x n; en+1)
lxi=newloc (Sn+2);fori= 1: : : n and each lxiis distinct
Sn+3=Sn+2[v1=lx1; : : : ; v n=lxn]
v0; Sn+3;[a1:la1; : : : ; a m:lam; x1:lx1; : : : ; x n:lxn]`en+1:vn+1; Sn+4
so; S 1; E`e0:f(e1; : : : ; e n) :vn+1; Sn+4[Dispatch]
so; S 1; E`e1:v1; S2
so; S 2; E`e2:v2; S3
...
so; S n; E`en:vn; Sn+1
so; S n+1; E`e0:v0; Sn+2
v0=X(a1=la1; : : : ; a m=lam)
implementation (T; f) = (x1; : : : ; x n; en+1)
lxi=newloc (Sn+2);fori= 1: : : n and each lxiis distinct
Sn+3=Sn+2[v1=lx1; : : : ; v n=lxn]
v0; Sn+3;[a1:la1; : : : ; a m:lam; x1:lx1; : : : ; x n:lxn]`en+1:vn+1; Sn+4
so; S 1; E`e0@T:f(e1; : : : ; e n) :vn+1; Sn+4[StaticDispatch]
The two dispatch rules do what one would expect. The arguments are evaluated and saved. Next, the
expression on the left-hand side of the \." is evaluated. In a normal dispatch, the class of this expression
is used to determine the method to invoke; otherwise the class is speci¯ed in the dispatch itself.
so; S 1; E`e1:Bool(true); S2
so; S 2; E`e2:v2; S3
so; S 1; E`ife1then e2elsee3¯ :v2; S3[If-True]
25
so; S 1; E`e1:Bool(false ); S2
so; S 2; E`e3:v3; S3
so; S 1; E`ife1then e2elsee3¯ :v3; S3[If-False]
There are no surprises in the if-then-else rules. Note that value of the predicate is a Bool object, not a
boolean.
so; S 1; E`e1:v1; S2
so; S 2; E`e2:v2; S3
...
so; S n; E`en:vn; Sn+1
so; S 1; E` fe1;e2;: : :;en;g:vn; Sn+1[Sequence]
Blocks are evaluated from the ¯rst expression to the last expression, in order. The result is the result of
the last expression.
so; S 1; E`e1:v1; S2
l1=newloc (S2)
S3=S2[v1=l1]
E0=E[l1=Id]
so; S 3; E0`e2:v2; S4
so; S 1; E`letId:T1Ãe1ine2:v2; S4[Let]
Aletevaluates any initialization code, assigns the result to the variable at a fresh location, and evaluates
the body of the let. (If there is no initialization, the variable is initialized to the default value of T1.)
We give the operational semantics only for the case of letwith a single variable. The semantics of a
multiple let
let x 1: T1Ãe1;x2: T2Ãe2; : : : ; xn: TnÃenin e
is de¯ned to be the same as
let x 1: T1Ãe1in (let x 2: T2Ãe2; : : : ; xn: TnÃenin e )
so; S 1; E`e0:v0; S2
v0=X(: : :)
Ti= closest ancestor of XinfT1; : : : ; T ng
l0=newloc (S2)
S3=S2[v0=l0]
E0=E[l0=Idi]
so; S 3; E0`ei:v1; S4
so; S 1; E`casee0ofId1:T1)e1;: : :;Idn:Tn)en; esac : v1; S4[Case]
Note that the case rule requires that the class hierarchy be available in some form at runtime, so that
the correct branch of the case can be selected. This rule is otherwise straightforward.
so; S 1; E`e1:Bool(true); S2
so; S 2; E`e2:v2; S3
so; S 3; E`while e1loop e2pool : void; S 4
so; S 1; E`while e1loop e2pool : void; S 4[Loop-True]
26
so; S 1; E`e1:Bool(false ); S2
so; S 1; E`while e1loop e2pool : void; S 2[Loop-False]
There are two rules for while : one for the case where the predicate is true and one for the case where the
predicate is false . Both cases are straightforward. The two rules for isvoid are also straightforward:
so; S 1; E`e1:void; S 2
so; S 1; E`isvoid e1:Bool(true); S2[IsVoid-True]
so; S 1; E`e1:X(: : :); S2
so; S 1; E`isvoid e1:Bool(false ); S2[IsVoid-False]
The remainder of the rules are for the primitive arithmetic, logical, and comparison operations except
equality. These are all easy rules.
so; S 1; E`e1:Bool(b); S2
v1=Bool(:b)
so; S 1; E`note1:v1; S2[Not]
so; S 1; E`e1:Int(i1); S2
so; S 2; E`e2:Int(i2); S3
op2 f· ; <g
v1=(
Bool(true);ifi1op i2
Bool(false );otherwise
so; S 1; E`e1op e 2:v1; S3[Comp]
so; S 1; E`e1:Int(i1); S2
v1=Int(¡i1)
so; S 1; E`~e1:v1; S2[Neg]
so; S 1; E`e1:Int(i1); S2
so; S 2; E`e2:Int(i2); S3
op2 f¤;+;¡; =g
v1=Int(i1op i2)
so; S 1; E`e1op e 2:v1; S3[Arith]
Cool Ints are 32-bit two's complement signed integers; the arithmetic operations are de¯ned accordingly.
The notation and rules given above are not powerful enough to describe how objects are tested for
equality, or how runtime exceptions are handled. For these cases we resort to an English description.
Ine1=e2, ¯rst e1is evaluated and then e2is evaluated. The two objects are compared for equality
by ¯rst comparing their pointers (addresses). If they are the same, the objects are equal. The value
void is not equal to any object except itself. If the two objects are of type String ,Bool, orInt, their
respective contents are compared.
In addition, the operational rules do not specify what happens in the event of a runtime error.
Execution aborts when a runtime error occurs. The following list speci¯es all possible runtime errors.
1.A dispatch (static or dynamic) on void.
2.A case on void.
27
3.Execution of a case statement without a matching branch.
4.Division by zero.
5.Substring out of range.
6.Heap over°ow.
Finally, the rules given above do not explain the execution behaviour for dispatches to primitive
methods de¯ned in the Object ,IO, orString classes. Descriptions of these primitive methods are given
in Sections 8.3-8.5.
14 Acknowledgements
Cool is based on Sather164, which is itself based on the language Sather. Portions of this document
were cribbed from the Sather164 manual; in turn, portions of the Sather164 manual are based on Sather
documentation written by Stephen M. Omohundro.
A number people have contributed to the design and implementation of Cool, including Manuel
FÄ ahndrich, David Gay, Douglas Hauge, Megan Jacoby, Tendo Kayiira, Carleton Miyamoto, and Michael
Stoddart. Joe Darcy updated Cool to the current version.
28

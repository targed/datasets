Ada Distilled   by Richard Riehle
Page  1 of 113An Introduction to Ada Programming
for
Experienced  Computer Programmers
by
Richard Riehle
AdaWorks Software Engineering
http://www.adaworks.com
Copyright 2002, AdaWorks Software Engineering
Public Edition.  Permission to copy if AdaWorks is acknowledged in copies
Version: July 2003
Ada Distilled   by Richard Riehle
Page 2 of 113Acknowledgments
 There are always a lot of people involved in the creation of any book, even  one as
small and modest as this one.    Those who have contributed to the best features of this
book include my students at Naval Postgra duate School,  Mr. Michael Berenato of
Computer Sciences Corporation, Mr. Ed Colbert of Absolute Software, and many
students from Lockheed-Martin Corporation,  Computer Sciences Corporation,  British
Aerospace,  various branches of the uniformed services, to name a few.   I also owe aspecial thanks to Dr. Ben Brosgol, Dr. R obert Dewar, Mr. Mark Gerhardt, and Dr.
Mantak Shing for what I have learned from th em.   Also thanks to the contributors to
comp.lang.ada Usenet forum and the Team_Ada Listserve.  Phil Thornley deservesextra credit for his detailed reading of the manuscript and many corrections.
Special thanks goes to Ed Colbert for his careful study of some of my program
examples.   He is one of those people who can spot a program error at fifty paces.Using this unique skill, Ed brought many e rrors, some big and some small, to my
attention.  Also thanks to more recent input from Phil Thornley and Adrian Hoe.
Any other errors are strictly mine.   Any mistakes in wording, spelling, or facts are
mine and mine alone.
I hope this book will be valuable to the intended audience.   It is moderate in its intent:
help the beginning Ada programmer get a good start with some useful examples of
working code.  More advanced books are listed in the bibliography.   The seriousstudent should also have one of those books at hand when starting in on a real project.
                          Richard Riehle
Intended Audience for this Book
This book is aimed at experienced programmers w ho want to learn Ada at the programming level.
It is not a "...for dummies" book, nor is it in tended as a program design book.   Instead, we
highlight some key features of the Ada language , with coded examples, that are essential for
getting started as an Ada programmer.
Ada is a rich and flexibile language used for de signing large-scale software systems.   This book
emphasizes syntax, control structures, subprogram  rules, and how-to coding issues rather than
design issues.   There are other really fine books ava ilable that deal with design. Also, this is not a
comprehensive treatment of the Ada language.   The bibliography lists some books that can help
you once you have finished the material in this book.
Think of this a quick-start book, one that enables you, the experienced programmer, to get into the
Ada language quickly and easily.   The examples  use text-oriented programs for simplicity of
learning. If you prefer to do the exercises for a GUI environment, check out the sites listed forcompilers and tools so you can download bindi ngs for programming in a variety of windowing
environments, including  Wintel, Linux, and Unix.   Of particular interest to those wanting to
explore Window style programming are GtkAda, CLAW, GWindows, and JEWL.  The last of
these, JEWL, is especially useful if you have no prior experience writing Windows programs.
                                 Happy Coding,
                                                             Richard Riehle
Ada Distilled   by Richard Riehle
Page 3 of 113Table of Contents
TABLE OF CO NTENTS.............................................................................................................. ............... 3
1. WHAT IS ADA DISTILLED? ...................................................................................................... .......... 4
2. SUMMARY OF LANGUAGE......................................................................................................... ....... 5
3. TYPES AND THE TYPE MODEL .................................................................................................... .. 16
4. CONTROL STRUCTURES FOR ALGORITHMS............................................................................ 26
5. ACCESS TYPES (POINTERS) ..................................................................................................... ....... 33
6. SUBPROGRAMS................................................................................................................. .................. 40
7. PACKAGE DESIGN.............................................................................................................. ................ 47
8. CHILD LIBRARY UNITS ......................................................................................................... ........... 52
9. OBJECT-ORIENTED PROGRAMMING WITH PACKAGES....................................................... 5710. USING STANDARD LIBRARIES AND ANNEXES ....................................................................... 6411.  EXCEPTION MANAGEMENT ...................................................................................................... .. 71
12. GENERIC COMPONENTS......................................................................................................... ....... 74
13. NEW NAMES FROM OLD ONES .................................................................................................... 82
14. CONCURRENCY WITH TASKING................................................................................................. 87A.  ANNEXES, APPENDICE S AND STANDARD LIBRARIES.......................................................... 92
ANNEX L PRAGMAS - LANGUAGE-DEFI NED COMPILER DIRECTIVES............................... 104
WINDOWS 95/98/NT/XP/ME /2000 PROGRAMMING ...................................................................... 105
C.  BIBLIOGRAPHY............................................................................................................... ................ 107
The Ada language is designed to maximize th e possibilities for error detection early in the development process.   This reduces  the overall
cost of software development since it is known that errors corrected early, will cost less than those detected late.  No other language, not
C++, not Java, not Eiffel, provides the leve l of support for safety-critical software f ound in Ada.   Developers can and do mak e mistakes,
even using Ada, but the probability of such  mistakes is substantially less when usi ng Ada than it is when using other languages .
Therefore, when failure is not acceptable, during development or during software execution, the wise developer will select Ada.
Although Ada is not as popular as some of the more well-known langua ges, it has substantial benefits over most of them when sof tware
dependability is a primary objective.  In a ddition, contemporary Ada is as appropriate  for developing GUI-based applications, i nformation
systems applications, and computationally intensive systems as  any existing language.  It is truly a general-purpose language, well-suited
to any kind of software problem you might encounter.Author's Observation and Opinion
Ada Distilled   by Richard Riehle
Page 4 of 1131. What is Ada Distilled?
This book is for  experienced programmers new to Ada.  Heavily commented example programs help
experienced programmer experiment with Ada.  This is not a comprehensive book on the entire Adalanguage. In particular, we say very little about  Ada.Finalization, Stor age Pool Management,
Representation Specifications,  Concurrency, and othe r more advanced topics.  Other books, listed in the
bibliography, cover advanced topics.   This book is an entry point to your study of Ada.
The text is organized around example programs with line-by-line comments.  Ada comments are the
double-hyphen and continue to the end of a line.   Comments might be explanatory notes and/or
corresponding section of the Ada Language Reference Manual (ALRM) in the format of ALRM X.5.3/22.
with Ada.Text_IO; --  1  10.1.2, A.10 Context clause
procedure   Hello  is --  2  6.3       Specification with "is "
begin --  3  6.3       Start algorithmic code
Ada.Text_IO.Put_Line(“Hello Ada”); --  4  A.10.6 Executable source code
end Hello; --  5   6.3       End of procedure scope
where each line is numbered.  The 10.1.2 and 6.3, etc. refer to ALRM Chapters 6.3, 10.1.2. A.10.6 refers to
Annex A.10.6.   There is occasional commentary  by  source code line number.  The line numbers are not
part of Ada, but provided on our examples for ease of commentary.  Boxed notes are also included forsome examples.    The preceding example shows one of these as:
1.1 Ada Compilers and Tools
Ada 95 compilers support a wide range of platforms.    A free, open source, compiler, GNAT, based on
GNU technology, can be downloaded from the Web.   Commercial Ada compilers and tools are availablefrom:  Ada Core Technologies (GNAT), DDC-I, Rati onal (recently acquired by IBM), RR Software, Irvine
Compiler Corporation, Green Hills, SofCheck, Aonix, and OC Systems.    Free editors, including AdaGide,are useful for developing small Ada programs.  More information on tools, including GUI developmenttools, can be accessed using one of the URL's men tioned in the introduction a nd in the bibliography.
Development tools exist for many operating systems.   These include CLAW for Microsoft Operating
Systems, and GtkAda for other GUI environments including Microsoft operating systems, Linux, BSD,OS/2, Java Virtual Machine, and every variety of Unix.  The AdaGide editor is available for MS Windows.
1.2 Ada Education
The bibliography of this book lists some of the books and educational resources available to the student of
Ada.   Some colleges and universities offer Ada courses.  In addition, companies such as AdaWorksSoftware Engineering provide classes for any one interested in Ada software development.
1.3 Ada Software Practice
There is a lot of misinformation about Ada.   One misconception is that it is a large, bloated language
designed by committee.   This is not true.    Ada is designed around a few simple principles that provide thearchitecture for the language syntax and semantics.  Once you understand these principles,  Ada will be as
easy as many other languages.  We highlight some of those design principles in this book.  One importantprinciple is that the Ada compiler never assumes anything. Everything is explicit.  Nothing in Ada isimplicit.  This helps the compiler help you write more dependable code. Oh, and you'll rarely need thedebugger once you are experienced with Ada.   Also , your Ada programs will usually compile to nearly
any contemporary platform and execute on that platform without change.A hello program in Ada.This will compile
and execute with
any Ada com piler.
If the software must absolutely work wit hout error, where a software accident could
kill or maim, Ada is the correct choice.
Ada Distilled   by Richard Riehle
Page 5 of 1132. Summary of Language
2.1 Goals and Philosophy
Every programming language is intended to satisfy some  purpose, some set of goals.  Sometimes the goals
are stated in terms of a programming paradigm.  For example, a goal might be to design an object-orientedprogramming language.  Another goal might call for a language that conforms to some existing
programming model with extensions to satisfy some new notions of programming techniques.  Ada's goals
correspond to the final product of the software process.   Ada is not designed to satisfy an academic notion
of how programs should be designe d and written.  Ada's Goals are:
• High reliability and dependability for safety-critical environments,
• Maintainable over a long span by someone who has never seen the code before,
• Emphasis on program readability in stead of program writeability,
• Capability for efficient software development using reusable components
In summary,  Ada is designed to maximize the error checking a compiler can do early in the development
process.  Each syntactic construct is intended to help the compiler meet this goal.  This means some Adasyntax may initially seem extraneous but has an important role in alerting the compiler to potential errors inyour code. The default for every Ada construct is safe.   Ada allows you to relax that default when
necessary.  Contrast Ada's default of safe with most of the C family of languages where the default is
usually, unsafe .  The safety default is one of Ada's most im portant contributions to engineering software.
Another important idea is expressiveness  over expressibility .  Nearly any idea can be expressed in any
programming language.  That is not good enough.  Ada puts emphasis on expressiveness, not just
expressibility.  In Ada, we map the solution to the problem rather than the problem to the solution.
2.2 Elementary Syntax
2.2.1 Identifiers
Identifiers in Ada are not case sensitive.   The identifiers Niacin, NIACIN, NiAcIn will be interpreted by
the compiler as the same.  Underbars are common in Ada source code identifiers; e.g. Down_The_Hatch.
There is a worldwide shortage of curly braces.  Cons equently, Ada does not use { and }.   Also, Ada does
not use square braces such as [  and ] .  Ada has sixt y-nine reserved words.   Reserved words will usually
be shown in bold-face type in this book. ( See Appendix A for a complete list of reserved words ).
2.2.2 Statements, Scope Resolution, Visibility
An Ada statement is terminated with a semicolon.   The entire scope of a statement is contained within the
start of that statement and the corresponding semi colon.   Compound statements are permitted.  A
compound statement has an explicit end of scope clause.   A statement may be a subprogram call, a simple
expression, or an assignment statement.   Here are some sample statements:
X := C * (A + B); --  1  Simple assignment statement
Move (X , Y); --  2 A procedure call statement
if A = B then --  3 Start a compound if statement
J := Ada.Numerics.Pi * Diameter; --  4 Compute the circumference of a circle
else --  5 Part of compound if statement
J := Ada.Numerics.Pi * Radius ** 2; --  6 Compute area of a circle
end  if ; --  7 End of compound statement scope
if  (A and B) or  ((X and T)  and  (P or Q)) then  --  8 Parentheses required in mixed and/or construct
Compute(A); --  9 Call Compute subprogram
else -- 10 Part of compound statement
Compute(P); -- 11 Subprogram call statement
end  if ; -- 12 End of compound statement scopeAda is not an acronym.  It is the name of the daughter of the English Poet, Lord Byron.   She
is credited with being the "first comput er programmer" because of the prescience
demonstrated in her early writings that descri bed Charles Babbage's Analytical Engine. She
was honored for this contribution by  having a language named after her.
The syntax of Ada is actually easy to learn and use.  It is only when you get further in your study that you
will discover its full power.  Just as there is "no ro yal road to mathematics," there is no royal road to
software engineering.  Ada can help, but much of  programming still requires diligent study and practice.
Ada's unique idea of visibility often cau ses difficulties for new Ada programmers.
Once you understand visibility, nearly everythi ng else about Ada will be clear  to you.Yes, you can hack solutions
in Ada if you want.However, it is intended as alanguage for disciplineddesign and construction ofhigh reliability software.
No curl y braces in Ada
Ada Distilled   by Richard Riehle
Page 6 of 113Note on Line 8 that an Ada conditional statement cannot mix and and or unless the expression includes
parentheses.  This eliminates problems associated with such expressions. It also eliminates arguments
about precedence of mixed expressi ons, and errors due to incorr ect assumptions about precedence.
2.2.3 Methods (Operators and Operations)
Methods in Ada are subprograms (procedures/functi ons) and include both ope rators and operations.
Operators include the symbols:   =, /=, <, >, <=, >=, &,  +, -, /, *.   Other operators are the reserved words,
and, or, xor, not, abs, rem, mod.   One issue that annoys newcomers to Ada is the strictness of the
visibility  rules associated with operators.  We will discuss the visibility rules and techniques for using them
sensibly in Section 2.4 and elsewhere in this book.  For detailed operator rules,  see ALRM 4.5.
All other methods are called operations.  One operation, assignment  uses the compound symbol:   := . The
Ada programmer may not directly overload the assignment operation.  Assignment is predefined for mostAda types.  It is prohibited for limited  types.  We describe limited types later in this book.
The Ada programmer may declare type-specific methods .  An experienced Ada designer uses the package
specification for declaring such methods, and for overriding/overloading existing methods.
The membership test, not considered an operation by the language, has important method-like properties.
Membership test uses the reserved word  in.   Combine the word in with the word not (not in ) for a
negative membership test.   Membership testing is permitted for every Ada type, including limited types.
2.3 Library and Compilation Units
2.3.1 Library Units
An Ada program is composed of library units .   A library unit is a unit that can be referred to using a with
clause.  The technical name for the with clause is context clause .  A context clause  is a little like a #include
compiler directive in other languages, but with impor tant differences.  A library unit must successfully
compile before the compiler will recognize it in a context clause .  Each compiled unit is placed in a
[sometimes virtual] library.  Unlike a # include  , the context clause  does not make elements of a library unit
visible.  Instead, a context clause  simply puts the library unit in scope, making it potentially visible.
A library unit may be a package  or a subprogram .  Subprograms are either functions  or  procedures .
1) package A collection of resources with something in common, usually a data type.
2) procedure A simple executable series of decla rations and associated algorithmic code .
3) function An executable entity which always returns a data type result.
4) child unit A package, procedure, or function that is a child of a package.
An Ada library unit  consists of a specification part and implementation part.   The implementation is
sometimes called a body . For a subprogram the specification part could be coded as,
procedure   Open (F : in out  File); --  Procedure specification; requires body .
function   Is_Open (F : File) return  Boolean; --  Function specifica tion; requires body
A package is a collection of services (public and private), usually related through some data type.  Most
Ada library units will be packages .  A package specification include s type declarations, subprograms
(procedures and functions), and exceptions.   Also, a package usually consists of a specification part
(public and private) and an implementation part.  The implementation part of a package is called the
package body .  A package specification almost always (not always) requires a package body.A single library unit may be composed of more than one compilation unit.   This is
called separate compilation.   Ada ensures th at separately compiled units preserve their
continuity in relationship to related units.  That is, date and time checking, library name
resolution, and date and time checking of co mpiled units ensures every unit is always in
phase with every other relate d complation and library unit
C/C++ programmer note:  An Ada
subprogram specification is analogous to,but not identical to, a function prototype.See 4.2.2
Note: Library
units may begeneric.  Seechapter 12.
Ada Distilled   by Richard Riehle
Page 7 of 113Here is a typical specification for a package library unit.  The speci fication has two parts, public and
private.  A client of a package can access only specification's public part , not its private part.
package  Machinery_1_3 is --  1 Package specification; requires body
type Machine is private ; --  2 Specifies the visible part of the data type ;
procedure  Turn_On  (M : in out  Machine); --  3 procedure specification
procedure  Turn_Off (M : in out  Machine); --  4 procedure specification
function   Is_On (M : in Machine) return  Boolean; --  5 function   specification
private --  6 private part hidden from a client of contract
type Machine is record --  7 full definition of the publicly declared type
Turned_On : Boolean := False; --  8 component of the type; OOP attribute
end record ; --  9 scope terminator for the component
end Machinery_1_3; -- 10 scope terminator for the specification
Here is a possible package body, which implements the specification.  It is separately compiled.
package body  Machinery_1_3 is --  1 Package body; implements specification declarations
procedure  Turn_On  (M : in out  Machine) is --  2 Repeat procedure specifica tion; compiler checks this
begin --  3 Starts algorithmic section of procedure
M.Turned_ON := True ; --  4 Simple assignment statement of boolean value
end Turn_On; --  5 Procedure scope terminator is required
procedure  Turn_Off (M : in out  Machine) is --  6 Must match profile in specification
begin --  7 Algorithms between begin and end
M.Turned_On := False; --  8 M.Turned called dot notation
end Turn_Off; --  9 Name is optional but end is required
function   Is_On (M : in Machine) return  Boolean is -- 10 In mode is like a constant; it may
begin -- 11                      not be on left side of assignment
return  M.Turned_On; -- 12 return statement required of every function
end Is_On; -- 13 Scope terminator for function
end Machinery_1_3; -- 14 End of all declarations for this package
Most often, the specification and the body are compiled separately.  A specification must compile without
errors before its body can be compiled.  The Ada comp iler will issue a fatal error if the body is out of phase
with the specification.   A programmer creating a client  of the package, can only see the public part of the
specification.  The specification is a contract  with a client of the package.  The contract must be sufficient
for the client to engage the promised services.  Every declaration in the specification must conform,
exactly, to the code in the body. The Ada compiler detects non-conformance to ensure consistency over thelifetime of the whole library unit.  A change to a specification requires recompilation of the body.  Achange to the body does not require recompilation of the specification.  Consider this client subprogram:
with  Machinery_1_3; --  1 Context clause. Puts Machinery_1_3 in scope
procedure  Test_Machinery_1_3 is --  2 Specifxication for the procedure
Widget : Machinery_1_3.Machine; --  3 Local object of type Machine
begin --  4 Starts the algorithmic section of this procedure
Machinery_1_3.Turn_On (M => Widget); --  5 Call the Turn_On using dot notation and named association
Machinery_1_3.Turn_Off (M => Widget); --  6 Call the Turn_On using dot notation and named association
end Test_Machinery_1_3; --  7 Scope of subprogram termi nates with the end clause
A client of the package, such as Test_Machinery_1_3, never ha s visibility to the private part or the body of
the package.  Its only v iew is to the public part.   However, the entire packag e is in scope, including the
body.   The body is completely hidden from all views from outside the package even though it in scope.Public part
Private part
Body
Note the use of named association in the procedure call.   The syntax includes the compound symbol   =>  where the
formal parameter is on the left and the actual parameter is on the right.   This Ada feature helps to make code more
readable and eliminates a lot of errors in the final source code.  Named associa tion is optional, but it is very powerful
and used often in production code .
Ada Distilled   by Richard Riehle
Page 8 of 1132.3.2 Compilation Units
As noted earlier, library units can be composed of smaller units called compilation units .   The library unit
is the full entity referenced in a context clause .  An Ada package, as a libra ry unit, is usually compiled as
two compilation units:  package specification and pack age body.  Do not think of a package specification
as a C++ .h file.  The Ada rules are more rigorous th an those for C++  .h files.  The package body does not
need to with its own specification.   A package body can be further subdivided into even smaller
compilation units called subunits .  Subunits, used wisely, benefit the maintenance cycle of existing Ada
programs.
The specification of Machinery_1_3 in the previous section can be compiled by itself.  Later, the package
body can be compiled.   The procedure Test_Machinery_1_3 may be compiled before the package body ofMachinery_1_3.   The test program  cannot be linked until all separately compiled units are compiled.
The package body for Machinery_1_3 could have been coded for separate compilation as,
 
package  body  Machinery_1_3 is --  1
procedure  Turn_On  (M : in out  Machine) is separate ; --  2
procedure  Turn_Off (M : in out  Machine) is separate ; --  3
function   Is_On (M : in Machine) --  4
return  Boolean is separate; --  5
end Machinery_1_3; --  6
Compilation units in most Ada programs will be a p ackage specification and package body.  Sometimes, as
in lines 2, 3, 5,  you may see a subprogram specification compiled with the word separate  instead of an  ...
is ... end  implementation.   This implies separate compilation of the body for that subprogram.
Ada does not force separate compilation, but some Ada compilers do. An implementation is free to impose
this requirement.   The standards for most Ada de velopment shops also require separate compilation.
An Ada package may have child library  units.   A package, such as pack age Machinery, may be the root of
a tree of child library  units.    This provides a unique opportunity for separate compilation and extension.
Here is an example of parent-child library units.
package  Messenger is --  1 Package specification; requires body
type Message is private ; --  2 Visible part of the data type; name only
function  Create (S : String) return  Message; --  3 function specification
procedure  Send     (M   in Message); --  4 procedure specification
procedure  Receive (M : out Message); --  5 procedure specification
function   Size (M : in Message) return  Natural; --  6 function specification
private --  7 private part hidden from a client of contract
type Message is record --  8 full definition of the publicly declared type
Text : String (1..120) := ( others  => ' '); --  9 string component of the type; OOP attribute
Length :  Natural := 0; -- 10 how many of the 120 values are in use
end record ; -- 11 scope terminator for the component
end Messenger; -- 12 scope terminator for the specification
with Ada.Calendar;
package  Messenger.Dated is --  1 Package specification; requires body
type Dated_Message is private ; --  2 Visible part of the data type; name only
function   Create (M : in Message) --  3 function specification
                           return  Dated_Message; --  4 function always specifies a return type
private --  5 private part hidden from a client of contract
type Dated_Message is record --  6 full definition of the publicly declared type
Text : Message; --  7 string component of the type; OOP attribute
Date  : Ada.Calendar.Time; --  8 how many of the 120 values are in use
end record ; --  9 scope terminator for the component
end Messenger.Dated; -- 10 scope terminator for the specificationA subprogram declared is separate  places a subunit in the library.  The
subunit may have its own context clauses, its own local variables, and itsown algorithmic code.   Also, each subunit may be compiled independentlyonce its parent has been successfully compiled.  This means easier, faster
maintenance and better unit testing.   During development, each subunit can
be assigned to a different programmer
Parent
Library
Unit
Child
Library
UnitSee Chapter 8 for more on child library units.
Note how a child librar y unit is formed usin g the parent name followed b y a dot and the child
Ada Distilled   by Richard Riehle
Page 9 of 113At first, a child library unit might be mistaken as a form of inheritance. The experienced OOP practitioner
will see that it is not inheritance; the is_a is relationship is absent.   Rather, it allows one to extend the
original package and add more features.  The declarative region  for Messenger has been extended to
include the declarations of Messenger.Dated.   Any client of Messenger.Dated has direct visibility to thepublic declarations of Messenger.    The private pa rt of Messenger.Dated and the body of Messenger.Dated
has direct visibility to the priv ate and public parts of Messenger.
Dated_Message is implemented is a has_a  relationship.  This means that Dated_Message contains a value
of type Message.    Dated_Message  cannot be converted to an object of type Message.   They are two
distinct types, even though one is nested within another.
2.4 Scope and Visibility
Failure to understand the difference between scope  and visibility  causes more problems for new Ada
programmers than any other single topic. It is an idea central to the design of a ll Ada software. There is an
entire ALRM chapter devoted  to it, Chapter 8.  A with clause puts a library unit into scope; but none of the
resources of that unit are directly visible  to a client.   This is different from a #include in the C family of
languages.  Separating scope  from visibility  is an important software engineering concept. It is seldom
designed into other programming langua ges. This book has many coded ex amples that illustrate visibility
rules. Ada has several techniques for making in-scope  elements directly visible.
2.4.1 Scope
Every Ada statement has an enclosing scope.   Sometimes  the scope is easy to see in the source code. There
is an entry point (declare, subprogram identifier, com posite type identifier, package identifier, etc.) and an
explicit point of termination.   Explicit terminations are coded with an end statement.  Anytime you see an
end clause, you know it is closing a scope.   Scope can be nested.   For example, a procedure may be
declared inside another procedure.  The scope of context clause ( with clause) is not as obvious.  The
context clause puts the full resources of a library  unit in scope, but makes none directly visible.
A pure interpretation of the scope mechanism might better describe this in terms of a declarative region .   However, since this book is
intended as an introduction to the practical aspects of the Ada, we limit our discussion to a more pragmatic view of the visibi lity
mechanism. For a more rigorous  description, please consult the Ada LRM, Chapter 8.
A with  (context) clause implies a dependency on the library  unit named in that clause.   This dependency
can be at either the specification level of the withing library unit or deferred to the body of that unit.
2.4.2 Visibility
An entity may be in scope but not directly visibile.   This concept is better developed in Ada than in mostprogramming languages.  Throughout Ada Distilled you will see visibility examples such as:
• use clauses makes all public resources of a package directly visible
• use type clauses makes public operators directly visible for designated type
• entity dot notation entity in notation is directly vi sible; usually the best option
• renaming , locally, of operations/operators usually best option for making operators directly visible
During development, an Ada compiler error message may advise you that some entity is not
visible at the point where it is declared or used.  Most often a visibility problem will relate tooperators (2.7). One of the mechanisms  from the above list can make that entity visible.   It will be easier to
demonstrate visibility in the code examples than to  trudge through a tedious jungle of prose.  Watch for
uses of the visibility mechanisms above in our coded examples.Some programmers find the concept of visibility  more difficult than any other part of Ada.
Once they really understand visibility, ev erything else in language makes sense.
NOTE: ISO
Standard C++namespace  adopts a
weakened form ofAda's scope andvisibility model.
Understanding visibility is the key to understanding Ada.Important
The general rule for
the use clause is tonot use it.  However,for lots of programswhere dependabilityand maintainabilityare less important(e.g., experimentalprograms), one mayuse the use clausefreely to simplify thecoding process.
Ada Distilled   by Richard Riehle
Page 10 of 1132.5  Declarations, Elaboration, Dependencies
Most Ada software systems are composed of many independent components, most in the form of packages.
These packages are associ ated with each other thr ough context clauses  (i.e., with clause).
Notice that dependencies between library units can be  deferred to the package body.  This unique feature
of Ada is based on the integral nature of library units and takes advantage of the separate compilation
capability.   Ada gives us the best of both capabilities.   We can minimize the design dependencies bydeclaring context clauses for the package body instead for the package specification.  This eliminates the
need to re-compile (or re-examine ) the relationships each time we make  a change somewhere in our design.
An Ada program includes declarations and executable statements.    A package specification is a set of
declarations.   The package body may also contain loca lized declarations.   The scope of the declarations
can be thought of as a declarative region .    In the declarative region, declarations are in scope but not
necessarily visible.  Declarations in a package body are in the declarative region, but are not visible to aclient or child library unit.
2.5.1 Elaboration
Declarations must be elaborated be fore the program can begin its algorithmic part.  Elaboration is the set of
actions a program must complete before it can begi n its algorithmic actions. It  usually takes place without
action by the programmer. Ada does provide some pragmas  (compiler directives) for control over the
timing and order of elaboration.     Usually, elabor ation occurs at execution time.    A programmer may
specify compile-time elaboration through pragma Preelaborate or pragma Pure.   If that compile-timeelaboration is possible, it may occur acco rding to the semantics of each pragma.
Library units named in a context ( with) clause must be elaborated before  they are actually available to a
client.   When there are multiple context clauses, each must be ela borated.  In some circumstances,
resources of one library unit must finish elaborating before another library unit complete its elaboration.
2.5.2 Ada Comb
An Ada program unit may sometimes be viewed in terms of the "Ada Comb," an idea first introduced to
me years ago by Mr. Mark Gerhardt.    The Ada Comb demonstrates how declarations and algorithms arerelated within an implementation; i.e, subprogram body, task body, declare block, package body, etc.
kind-of-unit  unit-name -- 1 
procedure, function, package body, declare block, etc .
local declarations -- 2 Must be elaborated prior to begin statement
begin -- 3 Elaboration is done.  Now start executing statements
handled-sequence-of-statements -- 4 Handled because of the exception handler entry
exception -- 5 Optional.  Not every comb needs this .
sequence-of-statements -- 6 This is the area for exception handler code
end unit-name; -- 7 Every comb requires a scope terminatorwith A;
with B;with C;package Q is  ...end Q;with A;with B;with C;package R  is  ...end R;
with E;with F;package body R is  ...end R;with R;package T  is  ...end T;
with A;package body T  is  ...end T;with T;package body Q is  ...end Q;specification specification specification
body body body
Elaboration brings declarations into existence, usually at run-time
Ada Distilled   by Richard Riehle
Page 11 of 113Ada is a block-structured language.  Local declarations may contain: other subprogram declarations
(including their body), instances of types, instances of generic units, tasks or task types, protected objectsor protected types, use clauses, compiler directives (p ragmas),  local type decl arations,  constants, and
anything else that falls into the cat egory of the items just listed.  Ev en though the list of legal entities in a
declaration is long, only a few elements are actually used in practice. Be aware of the Ada Comb whenstudying the subprograms and algorithmic structures in this book.
The handled-sequence-of-statements  includes statements that operate  on declarations.  This includes
assignment, comparisons, transfers of control, algor ithmic code.   More specifically, we see the three
fundamental control structures of the structure theore m (Jacopini and Böhm): sequence, iteration, selection.
You may also see a declare block, with local declarations, within the handled-sequence-of-statements.
with  Ada.Text_IO; --  1 Is elaborated before being used
with  Machinery; --  2 Is elaborated before being used
procedure  Ada_Comb_Example_1 is --  3 Name of enclosing unit
Data :  Machinery.Machine; --  4 Declarations  local to enclosing unit
begin --  5
declare --  6 Can declare local variables in this block
Data : Integer := 42; --  7 The name, Data, hides the global declarations
begin --  8 Integer Data now is visible; Outer Data is not
Data := Data + 1; --  9 Handled sequence of statements
exception -- 10 Start exception handler part of unit
when  some-exception  => -- 11 Name the exception after reserved word, when
    -- sequence of statements -- 12 Any legal sequence of statements here
 end; -- 13 End of scope of declare block
end Ada_Comb_Example_1; -- 14 End of enclosing scope
The Ada comb may be found in most algorithmic units.  This includes procedures, functions, package
bodies, task bodies, and declare blocks.  These units may also include some kind of identifier (label).   Inproduction code, it is helpful to include the label at th e beginning of the comb as well as at the end of it.
Here is a variation on the previous example
procedure  Ada_Comb_Example_2 is --  1 Name of procedure
Data :  Float := 0.0; --  2 Floating point declaration in scope
begin --  3
      Integer_Block: --  4 A label for the declare block
declare --  5 Can declare local variables in this block
Data : Integer := 42; --  6 The name, Data, hides the global declarations
begin --  7 Integer Data now is visible; Float Data is not directly visible
Data := Data + 1; --  8 Simple incrementing statement
exception --  9 Localized exception handling region
  when  Constraint_Error => ... -- 10 Statements to handle the exception
 end Integer_Block; -- 11 Named end of scope for declare block
Data := Data + 451.0; -- 12 Float data is once more visible
end Ada_Comb_Example_2; -- 13 End of scope of procedure
The second example has an exception handler localized in the declare block.  Note the identifier (label) for
this declare block.    A block label is any user-defined name followed by a colon.   The block repeats theidentifier at the end of its scope.    In the scope of the declare block, the floating point variable with thesame name as the item in the declare block is automa tically made invisible. Because it is still in scope, it
could be made visible with  dot notation  (Ada_Comb_E xample_2.Data ...).   Try to avoid identical names
within the same scope.   In large-scale systems with many library units, avoiding this is not alwayspossible.
Ada Distilled   by Richard Riehle
Page 12 of 1132.6 Variables and Constants
A variable is an entity that can change its value within your program.  That is, you may assign new values
to it after it is declared.   A constant, once declared with an assigned value, may not be changed during itslifetime in your program.   Variables and constants may be declared in a certa in place in your program,
called the declarative part .   Every variable and constant must be associated with some type.   The basic
syntax for a variable declaration is,
name_of_variable : name_of_type; -- for a scalar or constrained composite type
name_of_variable : name_of_type(constraint) ; -- for an unconstrained composite type
Declarations  for predefined types ( see package Standard in the appendices of this book )
Value : Integer; --  see Annex A.1, package Standard
Degrees : Float; --  see Annex A.1, package Standard
Sentinel : Character; --  see Annex A.1, package Standard
Result : Boolean; --  see Annex A.1, package Standard
Text : String(1..120); --  Must always constrain a string variable
We could also initialize a variable at the time it is declared,
Channel : Integer := 42; -- "...life, the universe, and everything ."
Pi : Float := Ada.Numerics.Pi; --   from Annex A.5, ALRM
ESC : Character := Ada.Characters.Latin_1.ESC; -- from Annex A, ALRM
Is_On : Boolean := True; -- from Annex A.1, ALRM
Text : String(1..120) := ( others => '*'); -- Every element initialized to asterisk
2.7 Operations and Operators
Ada distinguishes between operations and operators.   Operators are usually the infix methods used for
arithmetic, comparison, and logical statements.   Operators present a visibility problem for a new Adaprogrammer.   Watch for the discussion of operator visibility that follows in this section.
2.7.1 Assignment Operation
Somewhere among his published aphorisms and depreca tions, Edsger Dijkstra observes that too few
programmers really understand the complexities of the assignment statement.   I have not been able to
excavate the exact quote from those of his publications immediately at hand.   It is true, however, thatassignment is increasingly complicated as new programming languages are invented.   Ada is no exception,and may actually have more complicated rules about assignment than some other languages.
The Ada assignment operation, := ,  is a compound symbol composed of a colon symbol and equal symbol.
It is predefined for every Ada type except limited types.     It is illegal, in Ada, to directly overload,rename, or alias the assignment operation.   In a statement such as,
         A := B + C * (F / 3);the expression on the right side of the assignment opera tion is evaluated and the result of that evaluation is
placed in the location designated by th e variable on the left side.    A ll the variables on both sides must be
of the same type.   In an expression,
         X := Y;
Note: Although Ada does not allow direct overl oading of the assignment operator, it is sometimes useful to do that kind of over loading, and
Ada has a facility for designing in this feature safely  but indirectly, by derivi ng from a controlled type.Reminder:  the assignment operator is legal  only on non- limited types.   Also, both sides of the assignment
operator must conform to each other.  Composite types must have the same size and constraints.:=String is defined in package St andard as an unconstrained arrayStrings in Ada have index
values of subtype positivewhich means the lowestpossible value for a stringindex is 1, not zero.
Ada Distilled   by Richard Riehle
Page 13 of 113X and Y must both be of the same type.   If values in an assignment statement are not of the same type, the
programmer may, under strictly defined rules, conve rt Y to a type corresponding to the type of X.
type X_Type is ... -- Ellipses are not part of the Ada language; used for simplification here
type Y_Type is ...
X := X_Type(Y); -- When type conversion is legal between the types
Type conversion is not legal between all types.  If both types are numeric, the conversion is probably legal.
If one type is derived from another, it is legal. Otherwise, type conversion is probably not legal.
Assignment may be more complicated if the source and target objects in the assigment statement are
composite types.   It is especially complicated if those composite types include pointers (access values) that
reference some other object.   In this case, access value components may create entertaining problems for
the programmer.   For this reason, composite types constructed from pointers should be limited types .
For limited types, one would define a Deep Copy  procedure.  Ada makes it illegal to directly overload the
assignment operator.   Study an example of a deep copy in the generic Queue_Manager later in this book.
Sometimes two types are so completely different that assignment must be performed using a special
generic function, Ada.Unchecked_Conversion.    Do not be too hasty to use this function.  Often there is
another option.    Note the following example:
with  Ada.Unchecked_Conversion; --  1  Chapter 13 or ALRM
procedure  Unchecked_Example is --  2  Generally speaking, don't do this
type Vector is array  (1 .. 4) of Integer; --  3  Array with four components
  for Vector'Size use 4 * Integer'Size; --  4  Define number of bits for the array
type Data is record --  5
       V1,  V2, V3, V4 : Integer; --  6  A record with four components
 end record ; --  7
   for Data'Size use 4 * Integer'Size; --  8  Same number of bits as the array
function  Convert is new  Unchecked_Conversion --  9
                               (Source => Vector, Target => Data); -- 10  Convert a Vector to a Data
The_Vector : Vector := (2, 4, 6, 8); -- 11  Intilialize a Vector with values
   The_Data   : Data   := (1, 3, 5, 7); -- 12  Intilialize a Record  with values
begin -- 13
The_Data := Convert(The_Vector); -- 14  Assignment via unchecked conversion
end Unchecked_Example; -- 15
Even though Line 14 probably works ju st fine in all cases, many Ada practitioners will prefer to do the
assignments one at a time from the components of Vector  to the components of Data.   There will be more
code, but selected component assignment is guara nteed to work under all circumstances.  Unchecked
conversion may be less certain unless you are careful about what you are doing.
2.7.2 Other Operations
There are several reserved words that behave  like operations.   Most of these such as abort , delay ,
accept , select , and terminate  are related to tasking.   Others include raise  (for exceptions), goto ,
and null .   Some Ada practitioners might not agree with the notion that these are operations, however, in
any other language they would be so considered.
Other operations, for non-limited types, are described in Chapter Four of the Ada Language Reference
Manual.   Again, these might not be  thought of as operations, but they do have functi onality that leads us to
classify them as operations.   These include array slicing ,  type conversion ,  type qualification ,  dynamic
allocation  of access objects, and attribute modification  (Annex  K of ALRM).
Because Ada supports object technol ogy, the designer is allowed to  create, overload, and override
operations (except assignment) and  operators.  S ubprogram (procedure and function) specifications may
Ada Distilled   by Richard Riehle
Page 14 of 113be declared in the public part of a package specificati on.   They are implemented in the body of a package.
For example, in a stack package, the operations might be Push, Pop, Is_Full, Is_Empty.  For abstract data
types, the operations are described as subprograms on the type.
2.7.3 Operators
As mentioned in Section 3.2.2, Ada distinguishes be tween operators and operations.  This distinction is
useful for visibility management.  Operators may be overloaded.
Operators can be thought of as functions.   For example, for a type, T, function signatures might be:
    function  "="  (Left, Right : T) return Boolean;  -- signature for equality operator
    function  ">=" (Left, Right : T) return Boolean;  -- signature for equality operator
    function  "+"  (Left, Right : T) return T;        -- signature for addition operator
This signature style applies to all operators.  The na me of the operator is named in double quotes as if it
were a string.  You may overload operators for your own types.  In Ada, the return type is part of the
signature.  There is a special visibility clause that makes all the operators for a named type fully visible:
          use type  typename ;         -- typename is the name of the type in sc ope.  It might need to be dot qualified
Some designers prefer to make selected operators visible using the renames clause instead of the the use
type  clause.  For example, if type T is defined in package P,
function  "+"  (Left, Right : P.T) return P.T renames P."+"; -- makes "+" directly visible
The above function renames the additi on operator for a specific type.  It uses dot notation to reference the
package in which the type is defined.   You can code this in the declarations of a unit that has a contextclause for (for example) P and a type P.T.   This make s the plus operator directly visible in the immediately
enclosing scope.   Many Ada practitioners feel this is a better engineering solution to controlling visibilitythan any of the other options.  It does have the eff ect of ensuring that no accide ntal coding of some other
operator is possible since only this one is directly visible.
2.8 Elementary Sequential Programs
Ada supports two kinds of subprograms:  procedures  and functions . A subprogram may be a standalone
library unit.   Often it a subprogram is declared in some other unit such as a package specification.  The
implementation part of the subprogram is called the "body."  The body for Open might be coded as:
procedure   Open(F : in out File) is -- 1 Note the reserved word, is
   -- optional local declarations -- 2 Between  is and begin , local declarations
begin -- 3 Subprogram body requires a begin
   -- some sequence of statements -- 4 Some statements or reserved word  null;
end Open; -- Most standards require repeating the identifier here -- 5 End required;  Identifier optional but usual
Sometimes we code the subprogram specification and body together, as just shown. There are many cases
of this in the example subprograms in this book.   The optional local declarations  on Line 2 are local to the
subprogram.  That is, they are never visible to another unit.    This is one more level of visibility .  When
you fully understand the visibility rule s, you will understand most of Ada.There is a more in-depth discussion of this topic in Chapter  6 .Understandin g visibilit y is the ke y to understandin g Ada
Ada Distilled   by Richard Riehle
Page 15 of 1132.8.1  Subprogram Parameters
Subprograms may have formal parameters.  Formal parameters must have a name , a type, and a mode .  A
mode tells the compiler how a parameter will be used in a subprogram. The parameter mode  may be in,
out, in out , or access .  The following table simplifies the concept of parameter mode:
Mode           Function     Procedure         Assigment Operator Position
in Yes Yes Only right side of := (a constant in subprogram)
out No Yes Right or Left side of := (but has no initial value)
in out No Yes Right or Left side of := (has initial value)
access Yes Yes Only right side of :=  (but might assign to component)
The table is an over-simplification. It will work well for you as a programmer.  Just understand that out
mode  parameters are not called with an initial value, and access  mode parameters ( See Chapter 5 ) are
pointing to some other data.  Th e data being accessed may be modifi ed even though the access value itself
may not.  Examples of parameters and their modes within a subprogram,
2.8.2  Subprogram Specifications with Parameters
procedure  Clear (The_List : in out  List); -- The_List can be on either side of :=
function  Is_Empty (The_List : in  List) return Boolean; -- The_List can be on right side of :=
function  Is_Full (The_List : List) return  Boolean; -- default in mode
procedure  Get (The_List : in List; Data : out Item); -- two modes;  two parameters
procedure  Set_Col (To : in Positive_Count := 1); -- default value for in mode
procedure  Update (The_List : in out  List; Data : in Item); -- two modes; two parameters
function  Item_Count (The_List : access  List) return  Natural; -- The_List can be on right side of :=
procedure  Item_Count (The_List : access  List; -- The_List can be on allowed on right of :=
                                Count    : out Count); --  unitialized; left or right of :=
function  M_Data (Azimuth, Elevation, Time : Float) return  Float; -- Three parameters, same type
A call to a formal parameter with an actual parameter should usually include named association .
Consider function M_Data, above.   Which is mo re readable and more likely to be accurate?
                R := M_Data (42.8, 16.2, 32.8);
R := M_Data (Elevation => 16.2, Time => 32.8, Azimuth => 42.8);
Consider a problem that often occurs in languages such as C or C++ with three parameters of the same
type:
                int mdata (int x, int y, int z) { ... }In C, there is no easy way to explicitly ensure correct actual values are being sent to the right formal
arguments.  Consequently, it is easy to accidentally call a function with the wrong data, even if that data is
of the correct type.  Some more recent la nguages have adopted this feature from Ada.
Ada programmers, using named association, prevent this  kind of accident because errors are easily detected
by the compiler.  This can save countless hours of debugging time.   Later, when someone needs tomaintain a program using named association there is less difficulty determining what parameters are beingused and when.  This is especially useful for para meter lists where some of the formal parameters have
default values.What happens if the wr ong parameters of the right type are passed?The compound symbol means associate the formal
parameter with the named actual parameter.
Named association enables explicit interfaces.  This is an importan t engineering principle for software.Named association
where actual
parameter is
associated with
formal formal
Ada Distilled   by Richard Riehle
Page 16 of 1133. Types and the Type Model
3.1 Rigorous Type Rules
Type safety is the language feature for which Ada is best known.  It is actually only one of the many strong
points in Ada. The following discussion will clarify how it works. A type, in Ada, consists of four parts,
1. A name for the type
2. A set of operations for the type
3. A set of values for the type
4. A set of rules governing type relationships;  e.g., a wall between objects of differing types
The last feature, the wall, is the default of the Ada typing model.  Ada does provide capabilities for getting
around  or over the wall, but the wall is always there.  There are two general categories of type, elementaryand composite.  A composite type is a record or an array.  Everything else, for our purposes in this book, is
an elementary type. ( Note : there are minor exceptions to this definition when you get into more advanced
Ada).  Some types are predefined in a package Standard (see this Appendix A of this book). From theobject-oriented viewpoint, a type has state , operations to modify  state and operations to query  state.
3.2 Type Safety
A better way to view strong typing is to think in terms of type safety .  Every construct in Ada is type safe.
For Ada, type safe is the default. For most languages, type safe is not the default.   In still other languages,
type safety is an illusion because of structural equivalence or imp licit type promotion.  Ada does not
support either of those concepts b ecause they are not type-safe.  An  Ada designer declares data types,
usually in a package  specification.  The declared types include a constrained set of values and operations
appropriate to the problem being solved.    This ensures a rigorous contract between the client of a type andthe promise made by the package  in which the type is defined.
3.3 Declaring and Defining Types
3.3.1 Categories of types
Ada types can be viewed in two broad categories:  limited , and non-limited .  A type with a limited  view
cannot be used with the := expression, ever.    All other types can be used with := as long as thatassignment is between compatible (or converted view of) types.    Ada defines certain types as always
limited.   These include task types, protected types, and record types with access discriminants.
Types in Ada may be considered in terms of their view.   A type may be defined with a public view  which
can be seen by a client of the type, and a non-public view  that is seen by the implementation of the type.
We sometimes speak of the partial view  of the type.  A partial view is a public view with a corresponding
non-public view. Partial views are usually defined as private or limited private.  Also, the public view of atype may be limited where the implementation view of that same type may be non-limited.  Ada does notdefine a protected view directly analogous to C++ or Java.   However, some of the essential properties of
that view are available as necessary.
Another important category is private  type versus non-private  type.   A limited type may also be private.
A type with a private view may also have a view that is not private.    Any Ada data type may have a viewthat is private with a corresponding view that is not private.   The predefined operations for a non-limitedprivate type include:  := operation, = operator, /= opera tor.    Any other operations for a private type must
be declared explicitly by the package specification in which th e type is publicly declared.Ada has no structural equivalence as found in C, C++, and Modula-3.  Strict  name equivalence
model.  Ada has no automatic promotion of type s from one level to another.  We enjoy better
type safety under these rules. Even Java falls shor t of Ada when considering type safety.  This is
one reason Ada is the right choice for safety-c ritical and human-rated software applications.
Ada Distilled   by Richard Riehle
Page 17 of 1133.3.2 A Package of Non-private Type Definitions
In addition to predefined types decl are in package Standard, the designer  may also define types.  These
may be constrained or unconstrained, limited or non lim ited.  Here are some sample type declarations.
package Own_Types is
type Color is (Red, Orange, Yellow, Green, Blue, Indigo, Violet); --  1 An enumerated type ;
-- an  ordered set of values; not a sy nonym for a set of  integer values --  2 A single line comment
type Farenheit is digits  7 range  -473.0..451.0; --  3 Floating point type
type Money is delta  0.01 digits  12; --  4 Financial data type for accounting
type Quarndex is range  -3_000..10_000; --  5 Integer type; note underbar notation
type Vector is array (1..100) of Farenheit; --  6 Constrained array type
type Color_Mix  is array (Color) of Boolean; --  7 Constrained by Color set
type Inventory is record --  8 A constrained record type
    Description : String(1..80) :=  ( others  => ' '); --  9 Initialized string type record component
    Identifier  : Positive; -- 10 A positive type record component
end record ; -- 11 End of record scope required by Ada
type Inventory_Pointer  is access all Inventory; -- 12 Declaring a pointer type in Ada
type QData is array (Positive range  <>) of Quarndex; -- 13 Unconstrained array type
type Account is tagged record -- 14 See next example: 1.5.3.3
    ID               : String (1..20); -- 15 Uninitialized string type component
    Amount      : Money := 0.0; -- 16 See line 4 of this package
end record ; -- 17 Required by language
type Account_Ref  is access all Account'Class; -- 19 Classwide pointer type for tagged type
end Own_Types;
3.3.3  A Private type Package
package Own_Private_Types is --  1
type Inventory is limited private; --  2  Partial definition of limited private type
type Inventory_Pointer  is access all Inventory; --  3 Declaring a pointer type in Ada
procedure Create(Inv :  in out Inventory); --  4 Create an empty instance of Inventory
-- More operations for type Inventory --  5
type Account is tagged private ; --  6 Partial definition of a tagged type
type Account_Ref  is access all Account'Class; --  7 Classwide pointer type for tagged type
procedure Create (Inv : in out Inventory ); --  8 Creates an empty Inventory record
function Create (D : String; ID : Positive)  return Account_Ref; --  9 returns access to new Inventory record
-- More operations for tagged  type,  Account -- 10
private -- 11 Begin private part of package
type Inventory is record -- 12 A constrained record type
    Description : String(1..80) :=  ( others  => ' '); -- 13 Initialized string type record component
    Identifier  : Positive; -- 14 A positive type record component
end record ; -- 15 End of record scope required by Ada
-- 16
type Account is tagged record -- 17 Extensible record tagged type
    ID          : String(1..12); -- 18 Uninitialized string type component
    Amount      : Float := 0.0; -- 19 A float type record component
end record ; -- 20 Required by language
end Own_Private_Types; -- 21
Note the signature of the Create procedure on Line 4.   Since the inventory type is limited private , we would often want the mode of
parameter list to be in out .  However, it is legal to have mode of out only.
3.4 Deriving and Extending Types
A new type may be derived from an existing type. Using the definitions from the previous package,
type Repair_Parts_Inventory  is new  Inventory; -- no extension  of  parent record is possible here
-- because it is not a tagged type
where Repair_Parts inherits all the operations and da ta definitions included in its parent type.  Also,Public view of
specification
Private  viewofs
pecification
Ada Distilled   by Richard Riehle
Page 18 of 113type Liability is new  Account -- 1 extended from tagged parent, lines 6, 17-20, above
with  record -- 2 required ;phrase for this construct
Credit_Value : Float; -- 3 extends with third component of the record
Debit_Value  : Float; -- 4 fourth component of the record
end record ; -- 5 record now extended with four elements
in which Liability, derived from Account , inherits all the operations and components of its parent type but
also adds two more components.  This means that Li ability now has four components, not just two.   This
is called extensible type inheritance.  From the above list of types, one mi ght have a access (pointer)
variable,
Current_Account  : Account_Ref;   --   Points to Account or Liability objects
which can point to objects of any type derived from Account.  That is, any type in Account'Class.  Thispermits the construction of heterogeneous data structures.
3.5 Operations on Types
As mentioned in Section 2.7.3, Ada distinguishes between operators  and operations .  Legal syntax for
operations on types is defined in 4.5 of  the ALRM.   In general the rules are pretty simple. A limited type
has no language-defined operations, not even the := (a ssignment) operation.  Every other type has :=, at
minimum.   The following table summarizes some (not all) of these possibilities.
3.6 Where to Declare a Type
Usually, a type will be declared in  a package specification along with its  exported operations.   Therefore,
package Machinery is --  1  Package specification; requires bod y
type Machine is private ; --  2  Specifies the visible part of the data type;
procedure  Turn_On  (M : in out  Machine); --  3  procedure specification
procedure  Turn_Off (M : in out  Machine); --   4  procedure specification
function   Is_On (M : in Machine) return  Boolean; --   5  function specification
function   ">" (L, R : Machine) return  Boolean; --  6  Declare the ">" function for private type
private --  7   private part hidden from a client of contract
type Machine is record --  8   full definition of the publicly declared type
Turned_On : Boolean := False; --  9   component of the type; OOP attribute
end record ; -- 10  scope terminator for the component
end Machinery; -- 11 scope terminator for the specificationNote: membership test not officially an  operation or operator.  It  cannot be overloaded. It is  available for limited types. := = <, >, <=, >= & +, -, *, / abs rem/mod in not in
A. Non-Limited Types Y Y         .. ..     ..  ..     .. Y   Y
     1. Elementary Y Y         .. ..      ..  ..      .. Y   Y
          a. Scalar Y Y         Y ..      ..  ..      .. Y   Y
              1) Discrete Y Y         Y ..      ..  ..      .. Y   Y
                    Enumerated Y Y         Y ..     ..  ..      .. Y   Y
                    Integer Y Y         Y ..     Y  Y      Y Y   Y
                    Modular (Unsigned) Y Y         Y ..    Y  N      Y Y   Y
              2) Not Discrete Y Y         Y ..    ..  ..      N Y   Y
                    Float Y Y         Y ..    Y  Y      N Y   Y
                    Fixed Y Y         Y ..    Y  Y      N Y   Y
                    Decimal Y Y         Y ..    Y  Y      N Y   Y
     2. Composite Y Y        .. ..    N  N      N Y   Y
           1) Record Y Y         N ..    N  N      N Y   Y
           2) Array .. ..       .. Y    N  N      N Y   Y
               Constrained Y Y        Y Y    N  N      N Y   Y
               Unconstrained .. ..        N ..    N  N      N Y   Y
      3. Private Y        N      N  N      N Y   Y
B. Limited N N        N N      N  N      N Y   Y
C. May Overload? N Y        Y Y      Y  Y      Y N   N
Ada Distilled   by Richard Riehle
Page 19 of 113will imply that the public operations available to a c lient of Machinery,  fo r the type Machine, are:
• pre-defined assignment and test for equality and inequality
• procedures Turn_On and Turn_Off
• functions  Is_On and ">"
• no other operations on type Machine are available in package Machinery.
The language defined operations for a private type, Machine, are only assignment ( := ) , Equality ( = ),
and Inequality ( /=).   All other operations and operators for Machine must be explicitly declared in the
contract, i.e., the package specifica tion. The package has overloaded the ">" operator, so a client of this
package can do a greater than  compare on two machine objects.
3.7 The Wall Between Types
The fourth property for a type, the wall, is illustrated using the following declarations,
package  Some_Types is --  1 Declare specification name
type Channel is range  2..136; --  2 A constrained integer
type Signal is new  Integer --  3 Derived from Standard.Integer
                           range  1..150 --  4          with a range constraint
type Level is digits  7; --  5 A floating point type
subtype  Small_Signal is Signal --  6 No wall with objects of type Signal
                    range  2..14; --  7        but smaller range than Signal
type Color is (Red, Yellow, Green, Blue); --  8 Enumerated type with four values
type Light is (Red, Yellow, Green); --  9 Another enumerated type
type Traffic is new  Color -- 10 Derived from Color but with a
                       range  Red..Green; -- 11               smaller range of values .
end Some_Types; -- 12 .
Warning. Most Ada practitioners recommend against this  kind of package.  It works well for our teaching
example, but is poor design prac tice.   Generally, a package s hould be designed so each type is
accompanied by an explicit set of exported operati ons rather than depending on those predefined.
3.7.1  Type Rule Examples
The following procedure uses the package, Some_Types. It illustrates how the typing rules work.
Therefore, this procedure will not compile  for reasons shown.  A corrected example will follow .
with  Some_Types; --  1 No corresponding use clause; in scope only
procedure  Will_Not_Compile is --  2 Correct.  Too many errors for this to com pile
  Ch1,  Ch2, Ch3   : Some_Types.Channel    := 42; --  3 Notice the dot notation in declaration
  Sig1, Sig2            : Some_Types.Signal       := 27; --  4 Dot notatation makes type Signal visible
  Level_1, Level_2 : Some_Types.Level        := 360.0; --  5 Dot notation again.  No use clause so this is required
  Tiny  : Some_Types.Small_Signal := 4; --  6  Color_1, Color_2 : Some_Types.Color       := Some_Types.Red; --  7 Dot notation required here
  Light_1, Light_2  : Some_Types.Light       := Some_Types.Red; --  8  Tr1, Tr2, Tr3        : Some_Types.Traffic     := Some_Types.Red;  --  9
begin -- 10
Ch3 := Ch1 + ch2;  -- 11 Cannot compile;  + operator not directly visible
Level_1 := Ch1;    -- 12  Incompatible data types
Tiny := Sig1;        -- 13 This is OK  because of subtype
Color_1 := Light_1;  -- 14 Incompatible types in expression
Light_2 := Tr1;      -- 15 Incompatible types
Light_3 := Some_Types.Light(Color_1); -- 16 Type conversion not permitted for these types
Tr3 := Color_1;      -- 17 Incompatible types
Tr1 := Some_Types.Traffic'Succ(Tr2);  -- 18 This statement is OK
end Will_Not_Compile; -- 19
The following example corrects some of the problems with the preceding one.   Note the need for type
conversion.   We include an example of unchecked c onversion.   Generally, unch ecked conversion is a badNote: by a "wall" we mean that values of differing types may not be directly mixed in
expressions.  Type conversion  can sometimes help you across the wall.  Other times, more
roundabout approaches are required.  This is in keep ing with Ada's charter to be as type safe asNote: subprograms (procedures and functions) are analogous to methods
or member functions in other languages. Most of the time these are
public , but sometimes it is useful to make them private.
Ada Distilled   by Richard Riehle
Page 20 of 113idea.  The default in Ada is to prevent  such conversions.  However, Ada does allow one to relax the default
so operations can be closer to what is  permitted in C and C++, when necessary.
with  Some_Types; --  1 Context clause from prior example
with  Ada.Unchecked_Conversion; --  2 Context clause for generic  Ada library function
use  Ada; --  3 Makes package Ada directly visible
procedure  Test_Some_Types is --  4 Name for unparameterized procedure
  Ch1,  Ch2, Ch3     : Some_Types.Channel      := 42; --  5 Initialize declared variables
  Sig1, Sig2              : Some_Types.Signal       := 27; --  6 Note dot notation in declared variables
  Level_1, Level_2   : Some_Types.Level        := 360.0; --  7 Declared variables with dot notation
  Tiny                       : Some_Types.Small_Signal := 4; --  8  Color_1, Color_2   : Some_Types.Color        := Some_Types.Red; --  9 Enumerated type declarations
  Light_1, Light_2    : Some_Types.Light        := Some_Types.Red; -- 10  Tr1, Tr2, Tr3          : Some_Types.Traffic      := Some_Types.Red;  -- 11
  use type Some_Types.Channel; -- 12 Makes operators visible for this type
  function  Convert is new  Unchecked_Conversion -- 13 Enable asssignment between variables of
      (Source => Some_Types.Light, Target => Some_Types.Traffic); -- 14 differing types without compile-time checking
begin -- 15
   Ch3 := Ch1 + ch2;                     -- 16 use type makes + operator visible
   Level_1 := Some_Types.Level(Ch1);     -- 17 Type conversion legal between numeric types
   Tiny := Sig1;                         -- 18 This will compile because of subtype
   Tr3 := Some_Types.Traffic(Color_1);   -- 19 OK. Traffic is  derived from Color
   Tr1 := Some_Types.Traffic'Succ(Tr2);  -- 21 This statement is OK
   Tr2 := Convert(Light_1);              -- 22 Assign dissimilar data without checking
       Light_2  := Convert(TR3);              --  Illegal    Illegal   Illegal -- 23 Convert is only one direction
end Test_Some_Types; -- 24
Notice that operations are not permitted between incompatible types even if they have a set of values with
identical names and internal structure.   In this regard, Ada is more strongly typed than most otherlanguages, including the Modula family and the C/C++ family.   Type conversion is legal, in Ada, whenone type is derived from a nother such as types defi ned under the substitutability rules of object technology.
3.7.2  Subtype Declarations
Ada has a reserved word, subtype .  This is not the same as a subclass in other languages. If a subtype  of a
type is declared, operations between itself and its pa rent are legal without the need for type conversion.
procedure  Subtype_Examples is --  1 Subprogram specification
type Frequency is digits  12; --  2 Floating point type definition
subtype Full_Frequency is Frequency range  0.0 .. 100_000.0; --  3 subtype definition
subtype High_Frequency is Frequency range  20_000.0 .. 100_000.0; --  4 subtype definition
subtype Low_Frequency is Frequency range  0.0 .. 20_000.0; --  5 sutype definition
    FF : Full_Frequency := 0.0; --  6 Variable declaration
HF : High_Frequency := 50_000.0; --  7 Variable declaration
LF :  Low_Frequency :=  15_000.0; --  8 Variable declaration
begin --  9
FF  := HF; -- 10 OK; no possible constraint error
FF  := LF; -- 11 OK; no possible constraint error
LF  := FF; -- 12 Legal, but potential constraint error
HF  := LF; -- 13 Legal, but potential constraint error
end Subtype_Examples is -- 14
3.8 Elementary Types
Elementary types are of two main categories,  scalar  and access .  An access type is a kind of pointer and is
discussed in Chapter 5 of this book.   Scalar types are discrete  and real.    Discrete types are enumerated
types and integer types.  Technically, integer types are also enumerated types with the added functionalityof arithmetic operators.  Numeric discrete  types are signed and unsigned integers.
Non-discrete, real numbers include floating point, or dinary fixed point, and decimal fixed point. The Ada
programmer never uses pre-defi ned real types for safety-cr itical, production quality software.There is a slight deviation in orthogonality in m eaning of subtypes in the Ada Language Reference
Manual.   This discussion relates to the reserved word, subt ype, not the com piler desi gn model.
Ada Distilled   by Richard Riehle
Page 21 of 113All scalar types may be defined in terms of precision and acceptable range of values.   The designer is even
allowed to specify the internal representa tion (number of bits) for a scalar value.
type Index is mod  2**16 -- an unsigned number type
for Index'Size use 16 -- allot sixteen bits for this type
type Int16 is range  -2 ** 15.. 2**15 - 1; -- a signed integer number type
for Int16'Size use 16; -- allot sixteen bits for this type
type Int32 is range  -2 ** 31 .. 2**31 - 1 -- a signed integer numeric type
for Int32'Size use 32; -- allot 32 bits for this type
3.9 Composite Types
Composite types contain objects/values of some other type.  There are four general categories of composite
types:  arrays , records , task types , and protected types .  An array has components of the same type.   A
record may have components of different types. Ta sk types and protected types are discussed later.
3.9.1 Arrays
An array may have components of any type as long as they are all the same storage size.   Ada has three
main options for array definition: anonymous, type-bas ed unconstrained, type-based constrained.   Other
combinations are possible, but not discussed in this book.   Ada allo ws true multi-dimensional arrays, as
well as arrays of arrays.  Two common formats for a one dimensional array are:
type Array_Type is array (Index_Type range  <>) of Component_Type; --  One  dimensional unconstrained array
type Array_Type is array (Range_Constraint) of Component_Type; --  One  dimensional constrained array
Ada also has something called anonymous arrays.  An anonymous array is less flexible than a typed array
and cannot be passed as a parameter to a subprogr am.   We will not use them much in this book.
3.9.1.1 Array Procedural Example
The following procedure demonstrates a constrained array  and an unconstrained array , along with
declarations and some procedural behavior.   The cons trained array is a boolean array.  We show this array
because of its special properties when  used with logical or, and, and xor.   The unconstrained array simply
demonstrates that an unconstrained array mu st be constrained before it may be used.
with  Ada.Text_IO; --  1 Context clause
use  Ada; --  2 Visibility clause
procedure  Array_Definitions is --  3
   package  BIO is new  Text_IO.Enumeration_IO(Enum => Boolean); --  5 IO package for Boolean type
   type Boolean_Set is array (1..4) of Boolean; --  6 Constrained boolean array
   pragma  Pack(Boolean_Set); --  7 Forces array to four bits
    for Boolean_Set'Alignment use 2; --  7.1 Align storage on 2 bytes
  type Float_Vector is array (Natural range  <>) of Float; --  8 Unconstrained array
                  -- Note that the index is of type Natural and can be  any range of values from 0 through Integer'Last
   B1 : Boolean_Set := (True, True, True, False); --  9
   B2 : Boolean_Set := (False, False, True, False); -- 10   B3 : Boolean_Set := (True, True, False, True); -- 11   F1 : Float_Vector(0..9) ; -- 12   F2 : Float_Vector(1..10); -- 13
   procedure  Display (Data : Boolean_Set; Comment : String) is -- 14
   begin -- 15
       Text_IO.Put(Comment); -- 16
for I in Data'Range loop  -- 
Cannot run off the end of an array -- 17procedure Display factors
out the responsibility fordisplaying the results of theboolean operations in thebody of this example.Bitwise Logical operatorsand, or, and xor may beused on a boolean array.
Ada Distilled   by Richard Riehle
Page 22 of 113                    BIO.Put(Data(I)); -- 18
                    Text_IO.Put(" "); -- 19
     end loop ; -- 20
       Text_IO.New_Line; -- 21
   end Display; -- 22
begin -- 23
    F1(2) := F2(4); -- 24 Simple component assignment
    F1(5..7) := F2(6..8);   -- This is sometimes called "sliding " -- 25 Assign slices of different sizes
    Display (B1, "B1 is "); Display(B2, "B3 is "); Display(B3, "B3 is "); -- 26
    Display (B2, "B2 is "); -- 27
    B3 := B1 and B2; -- 28 Logical and of B1 and B2
    Display(B3, "B1 and B2 = "); -- 29
    B3 := B1 or B2; -- 30 Logical or of B1 and B2
    Display(B3, "B1 or B2 = "); -- 31
    B3 := B1 xor B2; -- 32 Logical xor of B1 and B2
    Display(B3, "B1 xor B2 = "); -- 33
end Array_Definitions; -- 34
Line 8, in the previous program illustrates an unconstrained array.  When an array is declared as
unconstrained, a constrained instance of it is required be fore it can be used in an algorithm. Here are some
other examples of one dimensional, arrays, constrained and unconstrained:
type Float_Vector is array (Integer range  <>) of Float; --  One  dimensional unconstrained array
type Float_Vector is array (-473..451) of Float; --  One  dimensional constrained array
type Day is (Sunday, Monday, Tuesday, We dnesday, Thursday, Friday, Saturday);
type Float_Vector is array (Day) of Integer; --  One  dimensional constrained array
Note that an array index can be any discrete type a nd does not have to begin with zero.  Also, type String,
defined in package Standard is defined as an unconstrained array with a Positive index type.   All theoperations permitted on ordinary arrays are also permitted on Strings.
3.9.1.2 Multi-dimensional Arrays
Ada allows both multiple-dimension arrays such as those found in Fortran or arrays of arrays such as those
in the C family of languages.   There is no language  defined limit of number of dimensions. For example,
type Float_Matrix is array (Integer range  <>, Positive range  <>) of Float; --   Two dimensional array
type Bool_Matrix is array (Natural range  <>, --   First dimension of three
Positive range  <>, --   Second dimension of three
Color    range  <>) of Boolean; --   Third dimension of three
type Mat_Vector is array  (Positive range  <>) of Float_Matrix( 1..20, 5..15); --   One dimension of two dimensions
3.9.1.3 Array Initialization
In Ada, arrays may be initialized using a concept called an aggregate .  The word aggregate is not a
reserved word, but it is an important part of th e language.   An unconstrained array may include an
aggregate at the time it is constrained.   Any array may be re-initialized with a new aggregate in thealgorithmic part of a module.   The rule is that an aggregate must be complete.  That is, every componentmust be included in the aggregate.  Here are some examples, using the definitions already shown in this
section (2.5.9.1).
For one dimensional array:
V1 : Float_Vector (1..6) := ( others  => 0.0); --  Instance initialized to all 0. 0
V2 : Float_Vector (1..3) := (1 => 12.3, 3 => 6.2, 2 => 9.4); --  Instance with initial values
V3 : Float_Vector (0..120) := (0 => 2.6, 120 => 7.5, others   => 9.4); --  others must appear lastSee unconstrained array, Float_Vector , defined in the previous section.
Ada Distilled   by Richard Riehle
Page 23 of 113V4 : Float_Vector (12..80) := (12 => 16.3, 20 => 6.2, others   => 1.5); --  Instance with initial values
V5 : Float_Vector (-473..-1) := ( others   => Float'First); --  Negative index range
In the above instances, V1 has six elements and is initialized to all 0.0, V2 has three elements and is
initialized using named association.   Named association  allows the programmer to associate a component
value with a named index.   V3 has 121 elements. It is initialized using named association with an others
option.   V4 has 68 elements, starting with an index of 12.
In Ada, an integer type index value may begin anywhe re in the number range.  It may even be a negative
value, as in example V5.   The value of V4'First  is 12.   The index bound of V4'Range  is 12 through 80.
For a two dimensional array:
       M1 : Float_Matrix(1..10, 1..10) :=  ( 1   => (1  => 0.0,  others   => 1.0), --  1 Named association for each
                                                                10 => (10  => 0.0, others   => 1.0),--  2 dimension of the array and
                                                                others  => (others  => 1.0)); --  3 others specified last
If you wanted to write a loop that would use Text_IO to display all of the values for M1 on a console, it
might look like the following code,
for I in M1'Range( 1) --  1 Range(1) specifies first dimension of array
       loop --  2 outer loop; should have been named
          for J in M1'Range( 2) --  3 Range(2) specifies second dimension of array
              loop --  4 Always name nested loops in production code
                 Text_IO.Put(Float'Image(M1(I, J)) & "  " ); --  5 Convert component to text and print it
              end loop ; --  6
           Text_IO.New_Line; --  7 Carriage return/Line feed on display
       end loop ; --  8
3.9.1.4 Array Catenation
One of the more useful operations on arrays is catena tion.  Catenation is predefined in the language using
the ampersand (&) symbol.   As with most operators , you may overload the catenator operator.  The rules
for catenation are in ALRM 4.5.3/4. Taking the Floa t_Vector, defined above, we can have the following:
V10 : Float_Vector (1..10) := V1 & V2 & 42.9; --  Catenate 42.9, V1 and V2
Often it is useful to catenate a value of a different type after converting it to an appropriate representation.
Let's say we have a variable,
      Bango : Integer := 451;   -- bango is the Japanese word for number .
Suppose we want to display the value of Bango on the video display.  We could do the following:
   Ada.Text_IO.Put_Line("Paper burns at " & Integer'Image(Bango) & " Farenheit ");This prints a string to the screen.  The ampersand caten ates the result of the image attribute (as if it were a
built-in function) which in turn is catenated to the constant string, Farenheit, (notice the leading space to
make formatting more readable).    Attributes help to make Ada programs more portable.Some prefer the word c oncatenation; same idea.
Ada Distilled   by Richard Riehle
Page 24 of 1133.9.2 Records
Ada records come in several forms, many of which are not covered in this book.    Some of the record
forms such as variant records, unconstrained records, and discriminated records, are not important to thenovice. This book is not concerned with advanced or se ldom used language features.   However, we will
include a few examples of constrained records,  some records with a single discriminants , and some taggedrecords for the student's future study.  The following Ada package specfication decl ares some record types.
package  Record_Declarations is --  1 This specification might re quire a pragma Elaborate_Body
type Library_Book is --  2 Simple constrained record
record --  3 reserved word, record
ISBN : String (1..12); --  4 String component
Title   : String(1..30); --  5 String component
Author : String(1..40); --  6 String component
Purchase_Price : Float; --  7 Floating point component
Copies_Available : Natural; --  8 Subtype natural from package Standard
end record ;  --  9 Must identify end of scope of each record
-- 10
type Message_1 is -- 11 Simple record with an
record -- 12                 unconstrained data type
Text : Unbounded_String; -- 13 See ALRM A.4.5
Length :  Natural; -- 14 See package Standard
end record ;  -- 15
-- 16
type Message_2 (Size : Positive) is -- 17 Record with a discriminant
record -- 18 This must be constrained before
Text :  String(1..Size); -- 19 it  may be used.  Note that the Size
Length :  Natural; -- 20 has a corresponding entry in the record
end record ;  -- 21 Dynamically allocated records might not
-- 22 be as efficient as you would like .
type Message_3 (Size : Positive := 1) is -- 23 Record with a default discriminant
record -- 24 This may be constrained or may use
Text :  String(1..Size); -- 25 the default constraint.  There are more
Length :  Natural; -- 26 rules for this, but we defer them to an
end record ;  -- 27 advancd discussion of the language
-- 28
type Message_4 is tagged -- 29  A tagged type.  This may be extended
.record -- 30                                    with more components
Text : Unbounded_String; -- 31  Unbounded String(See Ada.Fixed.Unbounded).
Length :  Natural; -- 32
end record ;  -- 33
. -- 34
 type  Message_5 is new Message_4 with -- 35 Derived from a tagged type and one
record -- 36 additional component.  This record now  x
Stamp : Calendar.Time -- 37 has a total of three components, those
end record ;  -- 38                               it inherits and the one defined within it .
-- 39
type Message_6 is -- 40 Record containing another record
record -- 41
Message_Data : Message_1; -- 42 See line  11
Library_Data   : Library_Book; -- 43 See line 2
end record ;  -- 44 .
end Record_Declarations; -- 45 This package might requi re a pragma Elaborate_BodyNote that some Ada
practitioners believe thiskind of record is not agood idea.   Since theSize might be variable atrun-time, each compilerwill have a unique wayof addressing how tobest implement the codetype extension
Ada Distilled   by Richard Riehle
Page 25 of 113The package, Record_Declarations, has no subprogram s.  Therefore, the rules of the language might
require a special pragma (compiler directive) to advise the compiler when there is a package body.
Note that, on line 35, the type Message_5 is derived from and extended from Message_4.   This is a form
of inheritance.   We could have the following:
M4 : Message_4;
  M5 : Message_5;               ...       M4 :=  Message_4(M5);     --
 provide a Message_4 view of the object of derived type, Message_5
or
    M5 := (M4  with  Library_Book); -- extends M5 with necessary components during assignment
In the case of the assignment to M4,  th e target of the assignment is provided a view of M5 that is restricted
to components in a type Message_4.    However, th e tag of the object does not change and the content
remains stable.    This has important implications.    Consider the following package.
with Record_Declarations; use Record_Declarations; --  1
package  Messenger_Processes is --  2
procedure  Display (The_Data : Message_4) ;
--  3
procedure  Display (The_Data : Message_5);
--  4
procedure  Print (Print_Data : Message_4'Class); --  5
procedure  Process (Process_Data : in out  Message_4); --  6
end Messenger_Process; --  7
package  body  Messenger_Processes is --  1
procedure  Display (The_Data : Message_4) is --  2
begin -- 3
     -- display the data for Message_4 -- 4
end Display; -- 5
procedure  Display (The_Data : Message_5) is --   6
begin --   7
     -- display the data for Message_5 --   8
end Display; --   9
procedure  Print (Print_Data : Message_4'Class) is --  10
begin --  11
      Display (Print_Data); --  12
end Print; --  13
procedure  Process (Process_Data : in out  Message_4) is --  14
begin --  15
      -- perform some algorithms --  16
      Print(Process_Data); --  17
end Process; --  18
end Messenger_Process; --  19
Suppose we called Process with the following statement:
Process(Message_4(M5));       -- see the immeditately preceding example
The procedure Process does its work and then calls Print.  Print has a classwide parameter.  The tag of the
object operated upon in Process corresponds to Message_5.   The result is a call to the correct version of
Display for Messsage_5 because of the ta g.   All information originally in cluded in M5 is intact because a
view conversion does not change the data or the tag.   This is called re-dispatching .     For a full discussion
of inheritance and dispatching, see Chapter Nine of this  book.
Ada Distilled   by Richard Riehle
Page 26 of 1134. Control Structures for Algorithms
Even in an object-oriented language, there comes the point where we must actually code the algorithmic
implementation.  Ada has a rich set of algorithmic c onstructs that are easy to code and easy to read.
4.1 Iteration Algorithms in Ada
One of the three fundamental building blocks of every computer program is iteration.  In nearly every
serious program there is at least one loop.  I realize some enthusiasts of recursion and/or functionalprogramming (LISP, ML, CLOS, Haskell, etc.) may object to this statement.
4.1.1 For Loops
A for loop is simple in Ada.  Every loop must have an end loop .  The type of the index is derived from the
type of the range variables.  The scope of the index is the scope of the loop.  The index is never visible
outside the loop.  Also, during each ite ration of the loop, the index is a constant  within the loop; that is, the
index of a loop may not be altered via assignment.    Iteration safety is fundamental to Ada.
with  Ada.Integer_Text_IO; -- 1 Put Library Unit in Scope; A.10.8/21
procedure  Sawatdee (Start, Stop : in Integer ) is-- 2 "Good morning" in Thailand;  6.2
begin -- 3 Required to initiated sequence of statements
for I in Start..Stop -- 4 I is a constant to the loop in each iteration; 5.5/9
loop -- 5 Reserved word loop is required; 5.5
Ada.Integer_Text_IO.Put(I); -- 6 Note the use of “dot notation” to achieve visibility; A.10.8
end loop ; -- 7 end loop is required for every loop; 5.5
end SaWatDee;  -- Ada is not case sensitive ! --  8 Note the label for the enclosing procedure;  6
An Ada enumerated type is an ordered set and may be used as the index of a loop. Also, the machine
values for the enumerated type are not necessarily simple numbers as they are in C of C++.  You will notneed to do arithmetic on them.  For an enumerated type, declared as:
type Week is (Sun, Mon, Tue, Wed, Thu, Fri, Sat);    -- An enumerated type is an ordered set; (Sun < Mon )
consider the following loop.
with   Ada.Text_IO; -- 1 Put Library Unit in Scope;  8.2, 10.1.2
procedure  Dobroe_Uutra  is -- 2 "Good morning" in Russian
begin -- 3 Required to initiated sequence of statemen ts
Loop_Name: -- 4 This is a named loop;  good coding style; 5.5
for Index in Week -- 5 Loop index may be any discrete type
loop -- 6 Reserved word loop is required; 5.5
Ada.Text_IO.Put(Week’Image(Index)); -- 7 ‘Image converts Value to  Text for  printing
end loop Loop_Name; --  8 The name is required if the loop is named; 5.5
end Dobroe_Uutra; --  9 Note the label for the enclosing procedure
Next consider an anonymous array with a range from fi fteen through sixty.   We can traverse this with a
simple loop statement and a 'Range attribute.  There can be no indexing off the end of the array.
  Set : array  (15..60) of Integer;   
consider the following loop with a loop label,
with  Text_IO; --   1  Put Library Unit in Scope
procedure  Magandang_Umaga is --   2  "Good morning" in Tagalog (language of Phillipines )
begin --   3  Required to initiated sequence of statementsTest before loopThe famous proof in Italian by Jacopini a nd Bohm is important here since it is a founda tion idea for program structure.   From their proof, we understand the
three fundamental control structures for im perative lan guages to be:  se quence , iteration , and selection
Always labelloops inproduction code.It helps with bothmaintenance anddocumentation
an anonymous array;  one of a kind;  no named type
Ada Distilled   by Richard Riehle
Page 27 of 113Outer: --   4  This is a named loop;  good coding style
for Index in  Set’Range --   5  Index'First = 15;  Index'Last = 60
loop --   6  Traverse the anonymous array
Text_IO.Put(Integer’Image(Index)); --   7  ’Image converts Integer to Text for printing
Text_IO.Put_Line(Integer’Image(Set(Index))); --   8   Print the value in the array using ‘Image
Inner: --   9  Give the inner loop a name
for Day in Week loop -- 10  Note how we use type name for the range
   Text_IO.Put(Week’Image(Day)); -- 11  Convert the Day to Text for  printing
end loop Inner; -- 12  The name of the loop is required
end loop Outer; -- 13  The name is required if the loop is named
end Magandang_Umaga; -- 14 Note the label for the enclosing procedure
Lines 7, 8, and 11 have code with the 'Image  attr ibute.  Check ALRM, Annex K/88 for details.  Line 5
could have been coded as,  for Index in Set'First .. Set'Last loop …
Sometimes you need to traverse a for loop in reve rse.  Line 5, above could have been coded as,
for Index in  reverse  Set’Range --   5  Cannot code:  for Index in 60..15 loop
A for loop might be used to traverse a two dimensi onal array.  A nested loop will be required.  Always
label each loop when coding a nested loop.   Here is the declaration of such an array.
type Matrix is array  (Positive range  <>, Natural range  <>) of Integer;   -- an unconstrained Matrix
procedure Process (M :  in out Matrix)  is -- 1 Specification for the procedure
begin -- 2 Simple begin
Outer: -- 3 Label for outer loop
for  I in M'Range(1) loop -- 4 M'Range(1)  is first dimension of array
Inner: -- 5 Label for nested loop
for  J  in M'Range(2) loop -- 6 M'Range(2) is second dimension
-- do some actions on the matrix -- 7 Algorithmic statements
end loop Inner; --  8 Inner end loop
end loop Outer; --  9 Outer end loop
end Process; --  10 End of procedure scope
4.1.2 While Loops  ALRM 5.5
A while loop is often the preferred type of loop in structured programming.
with Text_IO; --   1 Put a library unit in scope
procedure  Jo_Regelt is --   2 "Good morning" in Hungarian
The_File : Text_IO.File_Type; --   3 Declare internal file handle
As_Input :  constant  Text_IO.File_Mode := Text_IO.In_File; --   4 Is it input or output
External_Name : String := “C:\Data\My.Txt”; --   5 Declare the external file name
The_Data : String (1..80); --   6 A simple string variable ;
Line_Length : Natural; --   7 For the input line parameter
begin --   8 Required to initiate a sequence of statements
Text_IO.Open(The_File, As_Input, External_Name); --   9 See Text_IO for  the types of the parameters
Input_Routine: --  10 You may name any kind of loop, and should!
while  not Text_IO.End_Of_File(The_File) --  11 Read The_File until finding the EOF mark
loop --  12 Reserved word loop is required
Text_IO.Get_Line(The_File, The_Data, Line_Length); --  13 Get a delimited string  from the file
Text_IO.Put_Line(The_Data(1..Line_Length)); --  14 Echo the string with carriage / return line feed
end loop Input_Routine; --  15 end loop name is required if the loop is named
end Jo_Regelt; --  16 Note the label for the enclosing procedure
The following while loop uses the Get_Immediate feature of Ada.Text_IO, ALRM A.10.1/44.
with  Ada.Text_IO; --  1 Correct context clause
with  Ada.Characters.Latin_1; --  2 Replaces Ada 83 package ASCIIAlways use
loop labelswhen codingnested loop
structuresRemember, the
apostrophe whenused as a qualifierin a statment ispronounced "tick"
Ada Distilled   by Richard Riehle
Page 28 of 113procedure  Hello_By_Input is --  3 Long procedure name
  ESC   : Character renames  Ada.Characters.Latin_1.Esc; --  4 A.3.3/5; Ada is not case sensitive
  Input  : Character := Ada.Characters.Latin_1.Space; --  5 Initial value for Variable
  Index : Natural := 0; --  6 package Standard,   A.1/13
  Hello : String(1..80) := ( others  => Input); --  7 Input is intialized as space
begin --  8 Normally comment this line
Ada.Text_IO.Get_Immediate(Input); --  9  ALRM A.101./44
while  Input /= ESC loop   -- /= is Ada "not equal" symbol -- 10 Negative condition while loop
Ada.Text_IO.Put(Input);  -- Echo input -- 11 Only Echo if it is not ESC
Index := Index + 1; -- 12 Need to maintain own index
Hello(Index) := Input; -- 13 Assign the input to the string
 Ada.Text_IO.Get_Immediate(Input); -- 14 No need to press enter key
    end loop ; -- 15 Every loop needs an end loop
  Ada.Text_IO.New_Line; -- 16 Carriage Return/ Line Feed
  Ada.Text_IO.Put_Line(Hello); -- 17 Put the string and advance one  line
end Hello_By_Input; -- 18 Must be same name as procedure
The above loop could be coded to avoid the while  condition and simply do an exit.  This would eliminate
the initial Get_Immediate on Line 9 but would require an if statement to effect the exit.
Sometimes we want to exit a loop before we reach the pre-defined conditions.  This can be used for a loop
with no conditions or a loop in which some associated value goes abnormal.  Exit can emulate the Pascal
repeat  ... until  construct.  There are several forms of the exit:  exit when , if condition  then exit , and the
simple unconditional exit. For each form, the careful programme r will include the name of the loop.
4.1.3 Exit Loop  ALRM 5.7
with Text_IO; --   1 Put a library unit in scope
procedure  Salaam_Ahlay_Kham  is --   2 Parameterless declaration
The_File : Text_IO.File_Type; --   3 Declare internal file handle
As_Input : Text_IO.File_Mode := Text_IO.In_File; --   4 Is it input or output
External_Name : String := “C:\Data\My.Txt”; --   5 Declare the external file name
The_Data : String(1..80) := ( others  => ‘ ‘); --   6 Constrained, initialized string
Line_Length : Natural; --   7 For the input line parameter
begin --   8 Required to initiated sequence of statements
Text_IO.Open(The_File, As_Input, External_Name); --   9 See Text_IO for  the types of the parameters
Controlled_Input: --  10 You may name any kind of loop, and should
loop --  11 Unconditional loop statement
Text_IO.Get(The_File, The_Data, Line_Length); --  12 Get a delimited string  from the file
exit Controlled_Input  --  13 Note the use of the label name
when   The_Data(1..2) = “##”; --  14 A conditional exit;  should always be labled
Text_IO.Put_Line(The_Data(1..Line_Length)); --  15 Print the string with carriage return/line feed
end loop Controlled_Input; --  16 The name is required if the loop is named
end Salaam_Ahlay_Kham; --  17 Note the label for the enclosing procedure
Pay attention to line 10 in this example.  A loop label makes this kind of loop easier to maintain.  Many
Ada practitioners suggest you never use an exit without a label. For consistency checking, the compiler
will require the name of the loop at the end loop statement if there is a label.  Here is some alternative
syntax for lines 13 through 14 of the loop in P5, above,
if The_Data(1..2) = "##" then --  13 An if statement to control the exit
exit Controlled_Input;  --  14 Exit a loop with a  label name
else --
... --
end if;- -
The exit statement only works within a loop.  The syntax and rules of the if statement are discussed in the
next section.Test after loop
Ada Distilled   by Richard Riehle
Page 29 of 1134.2 Selection Statements
Selection comes in two flavors.  There is the alternation form, usually represented as an if ...end if , and the
multiway selection, often coded as a case ... end case .  Ada allows a multiway selection with an elsif in an
if statement.  As is true of every elementary stru cture, there is an entry point and a well-defined end of
scope.
4.2.1 If Statements  ALRM 5.3
The ordinary if statement in Ada is not very comp licated.  The rule is that every if must have an “ end if .”
Also, unlike Pascal, an if condition may be compound.  There is a reserved word, elsif, which permits a
kind of multi-way condition selection.   The following example is somewh at contrived, but it does illustrate
the idea of the if along with the elsif.  The most important thing to observe about elsif is that it might drop
through all conditions if none are true.  Therefore, y ou will almost always want a final else, even though it
is not required by the language.  If you fall through all possibilities in a function you may never reach a
return statement which will cause the RTE to raise a Program_Error  (ALRM, A.1/46) as an exception.
function  Select_Option (A,B,C : Float) return  Float  is --   1 Parameterized  function
Result : Float := 0.0; --   2 Local Variable for return statement .
begin --   3 Required to initiate sequence of statements
if A > B then --   4 Simple logical comparison
Result := A  ** 2; --   5 Exponentiation of A; 4.5.6/7
elsif  A < B then --   6 Note the spelling;4.5.2/9
Result := B ** 2; --   7 4.5.6/7
elsif A <= C then --   8 4.5.2/9
Result := C * B; --   9 4.5.5
else -- 10 Optional else; but always include it
Result := C * A; -- 11 4.5.5
end if ; -- 12 Try to have only one return statement .
return  Result; -- 13 If no return is found, compiler will reject the code
end Select_Option - - 14 Always label a subprogram end statement
The if statement is legal for nearly every Ada data type.  Some types designated as limited have no
predefined equality or relational testing but do permit membership if tests.   Record types and private types
have predefined if tests for equality and membership.   The creator of a limited type may define an equality
or relational operator.  For a private type or record the designer may overload equality or define a relationaloperator.  Sometimes it is better to create an entirel y new operation such as Is_Equal or Is_Greater  For
example, using the data type, Inventory, defined in Section 3.3..3, Line 12.
function  "=" (L, R : Inventory) return  Boolean; --  Specify an equality operator; operator overloading
function  Is_Equal (L, R : Inventory) return  Boolean; --  Specify an equality operation;   Could be more readable
function  ">" (L, R : Inventory) return  Boolean; --  Specify an greater-than operator
An implementation of  "=" might look like this
function  "=" (L, R : Inventory) return  Boolean is --  1 Redefines (overloads) an equal operator
begin --  2 The usual begin statement
    return  L.ID = R.ID; --  3 Compare only the ID part.
end "="; --  4 Required scope terminator
An implementation of  ">" might look like this
function  ">" (L, R : Inventory) return  Boolean is --  1 Redefines (overloads) ">" operatorIn code exam ples, see procedure
Ada Distilled   by Richard Riehle
Page 30 of 113begin --  2 The usual begin statement
    return  L.ID > R.ID; --  3 Compare only the ID part.
end "="; --  4 Required scope terminator
There is also a form of the if statement called short-circuit form.   This takes two syntactic formats :and
then   and or else .  The and then   format explicitly indicates that when comparison of the first operand
fails, ignore the second operand.   The or else  format says if expression in the first operand is not TRUE,
evaluate the second operand.  If it is TRUE, th en don't bother to evaluate the second operand.
4.2.2 Membership Testing  4.5.2/2
Sometimes you want a simple membership test.  The in and not in  options permit testing membership of a
value within a type or type range.  Membership test is permitted for any data type.
function Continue(Data : Item) return  Boolean  is --  1 Parameterized  function
Result : Boolean  :=  False; --  2 Initialized return variable .
begin -- Continue --  3 Comment the begin statement
if  Data in 1..20 then   --  4 Simple membership test for a range
Result := True; --  5 Set the result
end if ; --  6 Always need an end if
return  Result; --  7 At least one return statement; required
end Continue; --  8 Always label the end statement
or for a data type derived from another type
type Bounded_Integer is new  Integer range  -473..451 ;  -- Derived type; derived from Standard Integer
procedure Demand --  1 Procedure Identifier
                      (Data : in out  Bounded_Integer'Base) is --  2 Parameter list for Base type
Local : Bounded_Integer'Base := 0; --  3 Initialized variable .
begin -- Demand --  4 Comment the begin statement
Data := Data + Local; --  5 Increment by value of Local
if Data in Bounded_Integer then   --  6 Simple membership test for a range
null; --  7 Some Action
end if ; --  8 Always need an end if.
end Demand; --  9 Use a label for the end statement
4.2.3 Case Statements  ALRM 5.4
Ada case statements are easy and consistent.  Unlike pa thological case constructs in the C family of
languages, Ada never requires a “break” statement.  A case statement only applies to a discrete type suchas an integer or enumerated type.  When coding a case statement, all possible cases must be covered.  The
following case statement illustrates several of these ideas.  Consider an enumerated type, Color defined as:
type Color  is (White, Red, Orange, Yellow,  Chartreuse, Green, -- The values are the names of the
                Blue, Indigo, Violet, Black,  Brown);  -- colors. No need for numerics
The following function evaluates many of the alternatives.
function Evaluate  (C : Color)  return  Integer  is --   1 Simple function declaration
Result : Integer := 0; --   2 Local variable
begin -- Evaluate --   3 Comment the begin statement
case C is --   4 Start a case statement
when  Red => Result := 1; --   5 The => is an association symbol
when  Blue =>Result := 2; --   6 Am I blue? Set result to 2
when  Black .. Brown => Result := 3; --   7 For black through brown ...
when  Orange | Indigo => Result := 4; --   8 For either orange or indigo
when  others  => Result := 5; --   9 others  required for unspecified cases .
end case ; -- 10 Must use others  if any cases are not specified
return Result; -- 11 Compiler will look for a return  statementTip: This is one of those powerful Ada s yntactic constructs that can make code more re adable and easier  to  maintain.
It is not always a good idea to
initialize variables.  You mightget a valid result even if there is
an error in the al
gorithm.
Ada Distilled   by Richard Riehle
Page 31 of 113end Evaluate; -- 12
Sometimes, when a case statement result requires a long sequence of statements, consider using a begin ..
end block sequences ( see above discussion on blocks ).  Always label a begin ..end block.
function  Decide  (C : Color)  return  Integer  is --   1 Simple function declaration
Result : Integer := 0; --   2 Local variable
begin-- Decide --   3 Comment the begin statement
case C is --   4 Start a case statement
when  Red => --   5 One of the enumerated values
begin --   6  An unlabeled begin ... end sequence; see 4. 4
    -- sequence-of-statements --   7 Any sequence of Ada statemen ts
end; --   8 Unlabeled end statement
when  Blue => --   9 One of the enumerated values
Label_1: -- 10 Better style; use a block label
begin -- 11 Alternative:  consider calling nested subprogram
     -- sequence-of-statements -- 12 A labeled begin require s label name at end
end Label_1; -- 13 The label is required for the end statement
when  others  => -- 14  Ada requires others if some choices are unmentioned
Label_2: -- 15 Yes. Still using the label; label an embedded begin block
begin -- 16
   -- handled-sequence-of-statements -- 17 We expect a local exception handler .
exception -- 18 This is a good use of begin...end blocks
   -- sequence-of-statements -- 19 The exception handling statements
end Label_2; -- 20 The compiler will look for this
end case ; -- 21 Scope terminator is required
return Result; -- 22 Compiler will look for a return statement
end Decide; -- 23 As usual, label the end statement
On line 14, the when others  is required when some possible choices are not explicitly stated.  An Ada
compiler checks for the label at the end of a labeled begin..end block.  If there is a when others  and there
are no other choices, the compiler issues an error messa ge.   Lastly, a choice may be stated only once. If
you repeat the same choice, the Ada compiler w ill pummel you about the head and shoulders soundly.
4.3 Blocks
As shown in the preceding example, Ada allows th e programmer to label in-line blocks of code.
Sometimes these are labled loops. Other times they are simply short algorithmic fragments.  A block mayeven include localized declarations.  This kind of  block is called a "declare block."   Some Ada
programming managers think in-line declare blocks are a reflection of poor program planning.    In spite ofthat, they appear often in production code.  In fact, a declare block is the only way to declare a localvariable for a code fragment.
4.3.1 Begin ... End Blocks   ALRM 5.6
This is a useful feature of Ada for trapping exceptions and sometimes for debugging.  Good coding stylesuggests that they be labeled.  Some Ada practiti oners suggest using a labe led begin end with a case
statement as noted in Section 3.3.3 of this book.
with Ada.Text_IO, --   1 Note the comma instead of semicolon
Ada.Integer_Text_IO; --   2 Predefined package for Integer I/O
function Get return  Integer  is --   3 Parameterless function
package  IIO renames  Ada.Integer_Text_IO; --   4 Make the name shorter via renames clause
package  TIO renames  Ada.Text_IO; --   5 Make the name shorter
Data : Integer := -0; --   6 In scope for all of  P8
Try_Limit : constant  := 3;  -- universal integer constant --   7 A constant  cannot be changed
Try_Count : Natural := 0; --   8 Natural cannot be less than zero
Ada Distilled   by Richard Riehle
Page 32 of 113begin --   9 Required to initiated sequence of statements
Input_Loop: -- 10 Optional label for the loop
loop -- 11 Required reserved word
Try_Block: -- 12 Always name a begin..end block
begin -- 13 Start begin ... end block
Try_Count := Try_Count + 1; -- 14 Increment a variable by one
IIO.Get(Data); -- 15 Convert external text to internal number
exit Input_Loop; -- 16 unconditional loop exit
exception -- 17 Placed between begin ... end sequence
when  TIO.Data_Error => -- 18 Exception handling
if Try_Count > Try_Limit then -- 19 Decide whether to exit the loop
    Text_IO.Put_Line(“Too many tries"); -- 20 Because the Try_Count is too high
    exit Input_Loop; -- 21 exit the loop
end if ; -- 22 Every if requires an end if
end Try_Block; -- 23 The label is required if block is labeled
end loop  Input_Loop; -- 24 Loop is labeled so label is required
return   Data; -- 25  One return statement for this function
end Get; -- 26 Always label a subprogram end statement
4.3.2 Declare Blocks  ALRM 5.6
A declare  block is an in-line block of code which includes some local declarations.  The scope of the
declarations ends with the end statement of the block.  If any local na me is the same as some other name in
the enclosing scope, the local name is the only one directly visible.
with Text_IO;  ( properly, Ada.Text_IO, but this works too ) --   1  Put a library unit in scope
procedure  Tip_A is --   2  Parameterless declaration
Rare_E : Float := 2.72; -- natural number, e --   3  A rare E; see ALRM A.5
Data : Integer := 42; --   4  In scope for entire procedure
begin --   5  Required to initiate sequence of statements
Text_IO.Put(Integer’Image(Data)); --   6  What will print? Integer is converted to a string
declare --   7   begin a new scope (declarative region )
Data : Float := 3.14; -- a short slice of pi --   8  Hide visibility of Integer, Data; see ALRM A.5
begin --   9  [optionally Handled ] sequence of statements
Text_IO.Put(Float’Image(Data)); --  10 X‘Image is allowed for Floating Point
end; --  11 A scope terminator is required
Text_IO.Put(Float'Image(Rare_E)); --  12 A long way to tip a rare e.
end Tip_A; --  13 Always include a unit name
You may want to access the Data from an outer scope w ithin a declare block.  Names in an outer scope,
with names in conflict with those within a declare block, can be made visible with “dot notation.” It issometimes observed that declare blocks can be used for ad hoc  routines that someone forgot to design into
the software.  For this reason, some Ada practitioners recommend frugality when using them.  Also,because declare blocks can be so easily sprinkled through the code, it is  essential that production declare
blocks are always labeled.  The following declare block illustrates several of these points.
with Ada.Text_IO; --   1 Put a library unit in scope and make it directly visible
with Ada.Integer_Text_IO, Ada.Float_Text_IO; --   2 Predefined numeric IO packages
with  Ada.Numerics; --   3 ALRM, Annex A. 5
procedure  P7 is --   4 Parameterless declaration
package  IIO renames  Ada.Integer_Text_IO; --   5 Make the name shorter via a renames clause
X : Integer := 42; --   6 In scope for entire procedure
begin --   7 Required to initiate sequence of statements
IIO.Put(X); --   8 What will print?
Local_Block: --   9 Always name a declare block
declare -- 10 begin a new scope (declarative region )
use Ada.Float_Text_IO; -- 11 controversial localization of use clause
X : Float := Ada.Numerics.Pi; -- 12 Hide visibility of global Integer, P7.X
begin -- 13 [optionally Handled ] sequence of statements
Put(X); -- 14 Put is visible because of  “use clause”
IIO.Put(P7.X); -- 15 Dot qualifier  makes Integer X visible
end Local_Block; -- 16 Labeled end  name requi red for labeled block
end P7; -- 17 Always label a subprogram end statement
Tip:  Consider promoting a declare block to a local (nested) pa rameterless procedure in the decl arations of the enclosing unit.    This is
more maintainable.    It can be made  more efficient with an inline pragma.
Ada Distilled   by Richard Riehle
Page  33 of 1135. Access Types (Pointers)
5.1 Overview of Access Types
The British computing pioneer, Maurice Wilkes, is credited with inventing indirection .  Indirection is a
generalized notion of a pointer.   According to Dr. Wilkes, "There is no problem in computer programmingthat cannot be solved by not adding yet one more leve l of indirection."   Pointers, in many languages have
been problematic.   The C family of languages encourages one to do arithmetic on pointers, therebycreating some really tricky errors .  Ada pointers, called access types,  do not have default capability for
pointer arithmetic.  Java, to its credit, adopted some of the Ada philosophy on pointers.    Whenever we usethe term pointer in Ada, we really mean access  type or access object.  When we refer to an access type, we
are referring to a pointer with a default a se t of safe rules and no arithmetic operators.
There are three forms of access type.
                        Access Type Form                                                    Terminology           
• Access to a value in a storage pool storage pool access type
• Access to a declared value general access type
• Access to a supbprogram (procedure or function) access to subprogram type
Every access type is type speci fic to some designated type.
type Reference is access  Integer; -- Can only point to predefined type Integer; storage pool  access type
type Float_Reference is access all  Float; -- Can only point to predefined type Float; general access type
type Container is limited private ; -- Defines a data type with limited format; ordinary limited type
type Container_Pointer is access all  Container;  -- Can only point to objects of type Container; access to a limited type
type Method is access procedure … ;  -- Points to a procedure with corresponding parameter profile
type Method is access function … ;  -- Points to function with corresponding parameter profile and return type
5.2 Storage Pool Access Type
A storage pool access type requires an a ssociated set of storage locations fo r its allocation.  This might be a
simple heap operation, or the serious Ada programme r can override the operations in System.Storage_Pool
to enable some form of automatic garb age collection within a bounded storage space.
with Ada.Integer_Text_IO;  use Ada; --  1  Library package for Integer IO
procedure  Access_Type_1 is --  2
type Integer_Pointer is access  Integer; --  3 Storage pool access type
Number : Integer := 42; --  4 Declared value
Location : Integer_Pointer; --  5 Storage pool access value
begin --  6
Location := new Integer; --  7 The word new is an allocator
Location. all := Number; --  8 all permits reference to the data being referenced
Integer_Text_IO.Put(Location); --  9 Illegal.  Location is not an Integer type
Integer_Text_IO.Put(Location. all); -- 10 Legal.  Location.all is data of Integer type
end Access_Type_1; -- 11
Line 3 declares a type that points [only] to objects of type Integer.   It cannot point to any other type.
There is no pointer type in Ada that allows one to point to different types (except for classwide types).
Line 4 declares an object of the pointer type.   It has no value.  The default initial value is null.  An Ada
pointer can never point to some undefined location in memory.   Line 7 uses the reserved word new.   In
this context, new is an allocator .   An allocator reserves memory, at  run time, for an object of some data
type.  On Line 7, the address of that memory is assigned to the variable named Location.   The pointernamed Location is not an Integer.   Instead, it points to a storage location that contains an integer.Storage pool access types will require some
kind of storage pool management since objectsare dynamically allocated to an area ofmemory, possibly the “Heap.”    Ada does notrequire automatic garbage collection but somecompilers may provide it.  Otherwise, use thepackage System.Storage_Pools defined inALRM Chapter 13.We don't really have true pointers in Ada.  The use ofthe word pointer is simply to acknowledge acorresponding capability via access types.   Theimportant thing is that the default for Ada access typesis safe, unlike pointers in the C family of languages; no
void pointers in Ada.
Ada Distilled   by Richard Riehle
Page 34 of 113Ada, by default, prohibits arithmetic on a pointer.  The following statement is not allowed in Ada.
Location := Location + 1;   -- illegal.  No pointer arithmetic allowed
Line 8 refers to Location.all.   This how one refe rs to the data in the memory where Location points.
Notice that Line 9 will be rejected by the compiler, but Line 10 would compile OK.
5.3 General Access Type
A general access type provides additional capabilities to the storage pool access type.  It permits storage
allocation like storage pool access types.  It also a llows access to declared obj ects when those objects are
labeled aliased .   Returning the example above,
with Ada.Integer_Text_IO;  use Ada; --   1  Library package for Integer IO
procedure  Access_Type_2 is --   2
type Integer_Pointer is access  all Integer; --   3 General access type; requires all
N1 : aliased  Integer := 42; --   4 Aliased declared value
N2 : Integer := 360; --   5 Non-aliased declared value
Location : Integer_Pointer; --   6 General access type value
begin --   7
Location := N1'Access; --   8 Point to value declared on Line 4
Integer_Text_IO.Put(Location); --   9 Illegal.  Location is not an Integer type
Integer_Text_IO.Put(Location. all); -- 10 Legal.  Location.all is data of Integer type
Location := N2'Access; -- 11 Illegal. N2 was not aliased
end Access_Type_2; -- 12
The first difference in this example is on Line 3.   Integer_Pointer is a general access type  because the
declaration includes the word, all.   The next difference is Line 4.   N1 is an aliased  declared value.  A
general access type may only reference a liased values.  The reserved word, aliased ,  is required under most
circumstances.   Tagged type parameters for subprogram s are automatically aliased.  Line 8 is a direct
assignment to an aliased value.   This is legal.  Contrast this with Line 11, which is not legal.   Do you seethat Line 11 is not legal because  N2, on line 5,  is not aliased?
5.3.1 Preventing General Access Type Errors
There is a potential danger with direct assignment to pointers.  This danger is present all the time in the C
family of languages.   What happens when a data item goes out of scope and still has some other variable
pointing to it?   Ada has compiler rules to prevent this.   The following example illustrates this.
with Ada.Integer_Text_IO;  use Ada; --   1  Library package for Integer IO
procedure  Access_Type_3 is --   2
type Integer_Pointer is access  all Integer; --   3 General access type; requires all
Location : Integer_Pointer; --   4 General access type value
begin --   5
declare --   6 A declare block with local scope
N1 : aliased  Integer := 42; --   7 Declare an aliased value locally
begin --   8
Location := N1'Access; --   9 Point to value declared on Line 4
end; -- 10 End of declare block scope
end Access_Type_3; -- 11 Compilation failed!  Sorry about that. ☺
The Ada compiler will reject this progr am.  The rule is that the general access type declaration must be at
the same level (same scope) as its corresponding variables.   If you look at this example carefully, you willIf one really needs to do pointer arithmetic, it is possible thr ough a special packages from Chap ter 13 of the ALRM,  package
System.Address_To_Access_Conversions and pack age   System.Storage_Elements.   In practice, pointer arithmetic is unnecessary.
Ada Distilled   by Richard Riehle
Page 35 of 113see that, when the declare block leaves its scope, Location would still be pointing to a value that has
disappeared.    Instead of using ‘Access on line 9,  the programmer could have coded ‘Unchecked_Access,
thereby bypassing the compile-time checks.   Wisdom would dictate thinking very carefully beforeresorting to the use of any “unchecked” feature of  the language.    The word “unchecked” means the
compiler does not check the validity or legality of your code.   It is almost always an unsafe programmingpractice.
While the accessibility rules (See 5.3.2) might seem a drawback, they are easily managed in practice.
Often it is enough to simply declare a local gene ral access type and use it in a call to appropriate
subprograms.  The following example shows how this could happen.
procedure  Access_Type_4 is   --  1
function  Spritz (I : access  Integer) return  Integer is --  2
begin --  3
return  I.all + 1; --  4
end Spritz;  --  5
begin --  6
declare --  7
type Integer_Pointer is access all  Integer; --  8
Location : Integer_Pointer; --  9
N1 : aliased  Integer := 42; -- 10
N2 : Integer := 0; -- 11
begin -- 12 
Location := N1'Access; -- 13 Assign location of N1 to Location
N2 := Spritz(Location); -- 14 Call function with access variable parameter
end; -- 15
end Access_Type_4; -- 16
On line 14, a local access variable is used to call a function that has an access parameter.   The access
parameter is anonymous.  We may not assign a locati on to it.   However, it would be legal to code.
I.all := I. all + 1;  -- N1 would also be incremented by 1
return  I.all;
This code would change the actual value of what Location is pointing to.  Avoid doing this sort of thing.
If you were to print the value for both N1 and N2, you would see the number 43.   Some practitionersconsider this a side-effect.  Side-effects are rare in Ada and usually considered bad programming style.
5.3.2 The Accessibility Rules
ALRM Section 3.10.2, paragraphs 3 through 22, describe the accessibility ru les.   The purpose of the rules
is to prevent dangling references.   That is,  when  a variable is no longer in scope,  there should be no
access value trying to reference it.  Th is is checked by the compiler.   Under some rare circumstances, it
might not be checked until run-time.
The rules can be summarized in terms of  the lifetime of the access type itself.     An object referenced by the
'Access attribute may not exist longer that the the access ty pe to which it applies.    Also,  if an object is
referenced with the 'Access attribute,  it must be able to exist as long as the access type.    The following
three examples illustrate the point.
procedure  Accessibility_Problem_1 is -- 1
   type Integer_Reference is access all  Integer; -- 2 General access type in scope
   Reference : Integer_Reference; -- 3 Access value in immediate scope
   Data : aliased  Integer; -- 4 Data at the same accessibility level
begin -- 5
   Reference := Data'Access; -- 6 OK because types and declarationsNot good coding style.   Avoid these kinds of
side-effect statements.  This is the one and onlyplace where C++ can be more reliable than Adabecause of the way C++ controls constants.
All uses of the general access type are localizedand the lifetime of each entity is appropriate to theothers.  There  will be no potential danglingreferences when the declar e block leaves its scope.
But this is a very naughty thing to do.   Shame on
you if you do it!
This example will work just fine.  No data will be
left dangling when the scope is exited.   Lifetimeof all entities is the same.
Ada Distilled   by Richard Riehle
Page 36 of 113end Accessibility_Problem_1; -- 7 are at the same accessibility level
procedure  Accessibility_Problem_2 is -- 1
   type Integer_Reference is access all  Integer; -- 2 General access type
   Reference : Integer_Reference; -- 3 Access value
begin -- 4
   declare -- 5
      Data : aliased  Integer; -- 6 An aliased integer value
   begin -- 7
      Reference := Data'Access; -- 8 Will not compile; at wrong level of
   end; -- 9 accessibility for corresponding types .
end Accessibility_Problem_2;  -- 10
procedure  Accessibility_Problem_3 is -- 1
   type Integer_Reference is access all  Integer; -- 2
begin -- 3
   declare -- 4
      Reference : Integer_Reference; -- 5
      Data : aliased  Integer; -- 6
   begin -- 7
      Reference := Data'Access; -- 8
   end; -- 9
end Accessibility_Problem_3; -- 10
5.4 Access to Subprogram Types
One of the problems with the Ada 83/87 standard for Ada was the unavailability of some kind of pointer
capability for subprograms.     The current Ada standard  does permit this.    The rules for formation of such
an access type are rather simple.   The rules for visibility and accessibility of access to subprogram types
are often difficult to manage in one’s design.
5.4.1 Declaring an Access to Subprogram Type
• The type must have a parameter list co rresponding to the subprogram being accessed
• The return type of a function access type mu st match that of the function being accessed
• Variables of the type may access any subprogram with a conforming profile
Examples:
type Action is access procedure (Data : in out  Integer);
type Channel is access procedure (M : in out  Message; L : out Natural);
type Condition_Stub is access function  (Expression : Boolean) return  Boolean;
type Compute is access  function  (L, R : Float) return  Float;
5.4.2 Using an access to Subprogram Type
5.4.2.1 A Procedure Example
The following example demonstrates how to create an arra y of procedures.   This is often useful when you
have multiple procedures with the same profile but different behaviors.    In this example we have kept thebehavior simple to avoid confusion.   The astute reader will immediately see the possibilities.
with  Ada.Integer_Text_IO; --  1 ALRM Annex A
with  Ada.Text_IO; --  2 ALRM Annex A
use  Ada; --  3 Makes Ada directly visibleThis will not compile.  When
the program exits the declareblock, an outer pointer namedReference would still bepointing to data that no longerexisted.   This is not simply adangling reference.  It is areference to data that is nolonger valid.  The Ada compilerwill not let you do this.
This will not compile.  Youmight think that putting theactual pointer in the same localscope as the data being referencewould work.  The rule is thataccess value named Referencemust exist at least as lon
g as the
The signature (parameter profile)
of each subprogram access typemust exactly match anysubprogram being accessed.
Ada Distilled   by Richard Riehle
Page 37 of 113procedure  Array_Of_Procedures is --  4 Name of enclosing procedure
type Action is access procedure  (Data : in out  Integer); --  5 Access to subprogram definition
   procedure  Process (D : in out  Integer) is --  6 Procedure with correct profile
  begin --  7
       D := D + D; --  8 Details;  procedure behavior
   end Process; --  9 end of scope of procedure
   type Process_Set is array (1..10) of Action;    -- 10 Array type  of access types
  Index :  Positive; -- 11 Used for array index later
   Value :  Integer := 0; -- 12 Used for actual parameter
   The_Process : Process_Set := ( others  => Process'Access); -- 13 access object array with aggregate
begin -- 14
  loop -- 15
   Text_IO.Put("Enter Index(1..10): "); -- 16   Integer_Text_IO.Get(Index); -- 17
   exit when  Index not in  1..10; -- 18 
membership test for exit
   Text_IO.New_Line; -- 19
   Text_IO.Put("Enter Integer Value: "); -- 20   Integer_Text_IO.Get(Value); -- 21   The_Process(Index)(Data => Value); -- 22 
Named association clarifies
   Text_IO.New_Line; -- 23   Text_IO.Put("The result for Index " & Positive'Image(Index) -- 24
                                 & "is"  & Integer'Image(Value)); -- 25
   end loop ; -- 26
end Array_Of_Procedures; -- 27
5.4.2.2 A function Example
The following function example has behavior similar to the previous example.   It has been altered a little
bit to illustrate some additional capabilities.
with  Ada.Text_IO; use Ada; --  1  
procedure  Function_Access_Type is --  2
   type Real is digits  12; --  3 Define a floating point type
package  FIO is new  Text_IO.Float_IO(Num => Real); --  4 Instantiate IO package
   function  Method (D : in Real) return  Real is --  5 function w/correct profile
   begin --  6
       return  D + D; --  7
   end Method; --  8
  type Compute is access  function  (D : in Real) return  Real; --  9 Corresponding access type
Result, Value :  Real := 0.0; -- 10
   procedure  Process (Behavior : Compute; Input  : in  Real; -- 11 Note first parameter type
                                                    Output : out Real) is -- 12
   begin -- 13
      Output := Behavior(Input); -- 14 Reference to a function
   end Process; -- 15
begin -- 16
  loop -- 17 
   Text_IO.New_Line; -- 18   Text_IO.Put("Enter Real Value (0 to exit): "); -- 19   FIO.Get(Value); -- 20
   exit when  Value = 0.0;  -- 21
   Process(Behavior => Method'Access, Input => Value, Output => Result); -- 22 
Key statement in example
   Text_IO.New_Line; -- 23
   Text_IO.Put_Line("The result is "); -- 24   FIO.Put(Result, Fore => 4, Aft => 3, Exp => 0); -- 25   Text_IO.New_Line; -- 26
  end loop ;  -- 27
end Function_Access_Type; -- 28
Ada Distilled   by Richard Riehle
Page 38 of 1135.4.2.2 A Package Example
Many newcomers to Ada find the accessibility rule s frustrating when trying to implement access to
subprogram solutions across packages.   The accessibility rule remains th e same, but one must design a bit
more carefully to ensure that acce ss types are at the same level (hav e the same lifetime) as their access
objects and vice versa. The  following packag e specification declares some access types.
package  Reference_Types is --  1
  type Int_32 is range  -2**31..2**31 - 1; --  2 a signed integer with range
  for  Int_32'Size use 32; --  3 use 32 bits for the integer
 type Data_Set is array  (Natural range  <>) of Int_32; --  4 unconstrained array of int_32
  type Data_Set_Reference is access all  Data_Set; --  5 pointer type to the array type
  type Validate_Routine is access  function (Data : Int_32) --  6 access type that points to  a
                                     return  Boolean; --  7  function; access to function
  type Process_Method is access  Procedure(Data : Int_32); --  8 access type points to
  procedure  Process  (Data : in out  Data_Set; --  9                           procedure
                                         Method : in Process_Method); -- 10
  function   Validate (Data : access  Data_Set; -- 11 access parameter;  in mode
                                      Validator : in Validate_Routine) return  Boolean; -- 12 access to function parameter
  function   Validate (Data : in Data_Set; -- 13 access parameter;  in mode
                                      Validator : in Validate_Routine) return  Boolean; -- 14 access to function parameter
end Reference_Types; -- 15
There are a few new ideas in this package.  Line 2 has a signed integer type with a range that can be
represented in thirty-two bits.   On line 3 we force the representation to thirty-two bits using the 'Sizeclause.   See  the Annex K attributes for the definition of this clause.   On lines 6 through 8 we declaresome access to subprogram types which for paramete rs in lines 9 through 15.  The following package
contains declarations for functions for our final example.  It depends on  package Reference_Types.
with  Reference_Types; --  1
package  Reference_Functions is --  2
  function   My_Process return  Reference_Types.Process_Method; --  3
  function   My_Validator return  Reference_Types.Validate_Routine; --  4
end Reference_Functions; --  5 
Implementation for both packages will be presented a little later.  Here is a little test procedure.
with  Reference_Types; --  1  Put reference types in scope
with  Reference_Functions; --  2 Reference functions in scope
with   Ada.Text_IO; --  3
procedure  Test_Reference_Types is --  4
    Test_Data : Reference_Types.Int_32 := 42; --  5
    package  Int_32_IO is new  Ada.Text_IO. --  6
                     Inte ger_IO(Num => Reference_Types.Int_32); --  7
    Test_Data_Set : Reference_Types.Data_Set(0..20) --  8
                                 := ( others  => Test_Data); --  9
begin -- 10
  Reference_Types.Process (Data   => Test_Data_Set, -- 11                                              Method => Reference_Functions.My_Process); -- 12
end Test_Reference_Types; -- 13
Line 6 simply demonstrates an instantiation of an I/O package for the Int_32 type.   Line 11 calls the
procedure, Process from Reference_Types and give s it an actual parameter of My_Process from the
package containing the Reference_Func tions.  So far, everything is at the same level of accessibility. Here
are the package bodies for Reference_Types and Reference_Functions.Note that this package is a the
same level, the package level asthe access types in  packageReference_Types
Note that Lines 11 and 12 make acall to a procedure using a"pointer" to a function as theactual parameter .
Ada Distilled   by Richard Riehle
Page 39 of 113package  body  Reference_Types is --  1
  procedure  Process  (Data : in out  Data_Set; --  2
                      Method : in Process_Method) is --  3
  begin --  4
      for I in Data'Range --  5
         loop --  6
             Method(Data(I)); --  7
         end loop; --  8
  end Process; --  9
  function   Validate (Data : access  Data_Set; -- 10 
                                 Validator : in Validate_Routine) return  Boolean is -- 11
  begin -- 12
       return  Validate(Data. all, Validator); -- 13
  end Validate; -- 14
  -- 15
  function   Validate (Data : in Data_Set; -- 16
                                  Validator : in Validate_Routine) return  Boolean is -- 17
      Without_Error : Boolean := True; -- 18
  begin -- 19
     for I in Data'Range -- 20
         loop -- 21
             Without_Error := Validator(Data => Data(I)); -- 22
             exit when not  Without_Error; -- 23
         end loop ; -- 24
     return  Without_Error; -- 25
  end Validate; -- 26
end Reference_Types; -- 27
package  body  Reference_Functions is --  1
  procedure  My_Process (Data : Reference_Types.Int_32) is --  2
  begin --  3
     null; --  4
  end My_Process; --  5
  function  My_Validator (Data : Reference_Types.Int_32) return  Boolean is --  6
  begin --  7
     return  True; --  8
  end My_Validator; --  9
  function  My_Process return  Reference_Types.Process_Method is -- 10
      Test_Process    : Reference_Ty pes.Process_Method := My_Process'Access; -- 11
  begin -- 12
     return  Test_Process; -- 13
  end My_Process; -- 14
  function  My_Validator return  Reference_Types.Validate_Routine is -- 15
      Test_Validation : Reference_Types.Validate_Routine -- 16                     := My_Validator'Access; -- 17
  begin -- 18
    return  Test_Validation; -- 19
  end My_Validator; -- 20
end Reference_Functions; -- 21
Study these to determine where the 'Access  attribute is applied.   Note how this can actually work and still
prevent the dangling references.   Accessibility rules are there to keep you from making stupid errors.Method is an access
value thatreferences aprocedure.
Validate is anaccess value thatreferences afunction .
Ada Distilled   by Richard Riehle
Page  40 of 1136. Subprograms
Subprograms are either functions or procedures.  A subprogram may have parameters or not.  Subprogram
parameters were introduced in an earlier section. The algorithmic code in your program will almost alwaysbe contained within some kind of subprogram (or a task).  A subprogram may have locally declaredvariables, locally declared types, and locally nested subprograms or packages.
6.1 Procedures
6.1.1 Procedure Format and Syntax
A procedure in Ada may be used to implement algorithms.   As shown earlier, procedure have a rich set of
parameter types and parameter modes.   The format of a procedure body is,
procedure   Ahoy_There  is --  1 Procedure declaration with no parameters ; 6.3
     -- procedure declarations --  2 Local to this procedure
begin --  3 Begins sequence of algorithmic statements; 6.3
-- handled sequence of statements --  4 Handled by exception handler on error A.10.6
exception --  5 An optional exception handler for the procedure
-- a sequence of statements handling the exception --  6 Any handling statements legal
end Ahoy_There ; --  4 Scope terminator with name of unit 6.3
6.1.2 Procedure Compilation Units
Note the four parts to the procedure.  This is sometimes called the "Ada comb." You may compile a
procedure specification as a source file  separately from its implementation.
with  Ada.Text_IO; --  1 Put Text_IO library unit in scope; 10.1.2, A.10
procedure   Simple_2; --  2 Specification for a procedure may be compiled 6.3
The implementation may be coded and compiled later.   The implementation for Simple_2 could be,
procedure   Simple_2  is --  1 Parameterless declaration; 6.3
begin --  2 Begins sequence of algorithmic statements; 6.3
Ada.Text_IO.Put_Line(“Hello Ada”); --  3 Dot notation makes Put_Line visible A.10.6
end Simple_2 ; --  4 Scope terminator with name of unit 6.3
Another version of this might execute the Put_Line some given number of times using a  for loop .   A for
loop includes an index value declared locally to the loop and a range of values for the index.  The loop will
then iterate the number of times indicated by the index range.  For example,
with  Ada.Text_IO; --  1 Put Text_IO library unit in scope; 10.1.2, A.10
procedure   Simple_3  is --  2 Parameterless declaration; 6.3
begin --  3 Begins sequence of algorithmic statements; 6.3
for Index  in 1..10  loop --  4 Specification of a for loop
Ada.Text_IO.Put_Line(“Hello Ada”); --  5 Dot notation makes Put_Line visible A.10.6
end  loop ; --  6 End of loop scope.  End of loop index scope
end Simple_3 ; --  7 Scope terminator with name of unit 6.3
A variation on the previous program uses some local declarations, a function with a parameter and a simple
call from the main part of the procedure.
with  Ada.Text_IO; --  1  Put Ada.Text_IO Library Unit in scope
procedure   Simple_4  is --  2 Declaration for parameterless procedure
function  Is_Valid (S : String) --  3 Declaration for a function with a parameter
              return  Boolean is --  4 Specify the type of the return value
... --  5 three dots not legal Adaprocedures and functions
with clause could
be moved to
Ada Distilled   by Richard Riehle
Page 41 of 113end Is_Valid; --  6 End of scope for function Is_Valid
Text : String (1..80); --  7 Declare a String variable with constraint
Len  : Natural; --  8 Uninitialized variable
begin --  9  Begin handled-sequence-of-statments
Ada.Text_IO.Get_Line(Text, Len); -- 10 Call to Get_Line procedure with two parameters
if Is_Valid(Text(1..Len)) then -- 11 Call the function with string parameter
Text_IO.Put_Line(Text(1..Len)); -- 12 Put string w/carriage return and line feed
end  if ; -- 13 Ends scope of if statement
end Simple_4 ; -- 14 Ends scope of Simple_2
6.1.3  A Main Subprogram
A main subprogram is not required, but most programs have one.  Here is an example of a main procedure.
with  Application;  -- This could be any Application package --  1 Put package Application in scope;  10.1.2,
procedure   Main  is --  2 Parameterless declaration; 6.3
    The_Application : Application.Application_Type; --  3 Some kind of  type for the application
begin-- Main --  4 Begins Main subprogram; 6.3
Restart_Iterator: --  5 We want a non-stop system so we
loop --  6 create a restart iterator  as a loop.
Application_Control: --  7 Label the Application control block
begin-- Application_Control --  8 No harm in commenting every begin
Application.Start(Data => The_Application); --  9 Start the application code
Application.Stop(Data => The_Application); -- 10 Stop the application code
exit Restart_Iterator; -- 11 If all goes well, exit the loop here .
exception -- 12 If there is an exception anywhere, do this.
when  others  => -- 13 Others captures any kind of exception
Application.Cleanup(Data => The_Application); -- 14 Start the cleanup before Restarting
Application.Restart  (Data => The_Application); -- 15 Now restart the application
end Application_Control; -- 16 Block label required because it is labeled
end loop Restart_Iterator; -- 17 Loop label required because it is labeled
Application.Finalization (Data => The_Application); -- 18 The finalization routines for application
end Main; -- 19 Scope terminator with unit name  6.3
6.1.4 Procedure Parameters
Any procedure or function may have parameters.  The following example is a variation on the Diamond
procedure and demonstrates the use of named associa tion in calling formal parameters.  The syntax for
named association is  ( formal-parameter-name => actual-parameter-name ).  This example was originally designed
and programmed by a young US Marine Corps Lance Corporal who, at the time, had a high-schooleducation.  Notice that he used elementary algebra to write this program with only one loop and simplycalled the inner procedure by changing the algebraic signs  of the actual parameters.  While this code can be
improved , it demonstrates how this young Mari ne thought about the problem before coding it.
-- ================================================== --  1
-- diamond.ada --  2
-- Solution to Diamond Problem by LCPL Mathiowetz, USMC --  3
-- Camp Kinser, Okinawa.  June 1993.  AdaWorks Intro to Ada Class --  4
-- ================================================== --  5 .
with  ada.text_io; use Ada;  -- Makes all of package Ada visible --  6 Only Text_IO is required for this program
procedure  Diamond is --  7  Specification with no parameters
package  TIO renames  Text_IO; --  8  A shortened name for Text_IO
subtype  Column is TIO.Positive_Count; --  9  Subtype may be used with its parent type
Center : constant  := 37; -- 10 A named constant
Left_Temp, Right_Temp : Integer := Center; -- 11 Temporary values, initialized
Plus_2     : constant  :=  2; -- 12 Positve constant value
Minus_2 : constant  := -2; -- 13 Negative constant value
procedure  Draw (Left, Right, Depth : in Integer) is -- 14 Nested procedure with parameter list
Symbol : String(1..1) := "X"; -- 15 The character we will print
Left_Col, Right_Col : Column; -- 16 These are probably extraneous
begin -- 17 We are in a nested procedureTechnically, a main subprogram is either a procedur e or function.   Most often it is a procedure.
When it is a function, the return value is  an inte ger to the o peratin g system as in Unix or Linux.
These first five lines illustrate astyle for documenting an Ada sourcecode unit.   The author of this solutionwas a USMC Lance Corporal with aHigh School education.
Ada Distilled   by Richard Riehle
Page 42 of 113        for Index in 1..Depth loop -- 18  Index declared here; type is range type
          if Left_Temp = Center then -- 19 Is it time to Put the center character ?
             TIO.Set_Col(Center); -- 20 Using renamed Text_IO.Count
             TIO.Put(Symbol); -- 21
          else -- 22
             Left_Col  := Column(Left_Temp); -- 23 Extraneous assignment on these two lines ;
             Right_Col := Column(Right_Temp); -- 24 we could do type conversion in Set_Col
             TIO.Set_Col(Left_Col); -- 25 TIO.Set_Col(Column(Right_Temp))
             TIO.Put(Symbol); -- 26 might be better coding on line 25 and 27
             TIO.Set_Col(Right_Col); -- 27
             TIO.Put(Symbol); -- 28 Symbol on line 15
          end if ; -- 29
          TIO.New_Line; -- 30
          Left_Temp  := Left_Temp  + Left; -- 31 Arithmetic on Temporary values using
          Right_Temp := Right_Temp + Right; -- 32 algebraic addition on negative parameter
        end loop ; -- 33
    end Draw; -- 34  End of nested procedure
begin  -- Diamond -- 35  Always comment this kind of thing
    Draw (Left => Minus_2, Right => Plus_2,  Depth =>  9); -- 36 Use named association for these calls .
    Draw (Left => Plus_2,  Right => Minus_2, Depth => 10); -- 37 Reverse the signs to get a different shape
end Diamond; -- 38 End of unit with named unit at end
Sometimes we want a variable to enter the procedure with one value and exit with a new value.  Here is a
simple procedure which uses in out   parameter mode.  Although this example is trivially simple, it can be
extended to a large range of other data types where one must alter that state of an object in some carefully
controlled way.
procedure  Update (Data : in  out Integer) is -- 1  in out  allowed on either side of  :=
begin -- 2  start algorithmic part of procedure
Data := Data + 1; -- 3  In with one value; out with a new value
end Update; -- 4  end of unit with unit name
Other times, it is useful to get a variable with an in value and return some other value within a procedure
parameter list.  This is not always a good design model since it leads us to combine two ideas, modifier andquery, into a single operation.  Many  OOP practitioners suggest that m odifiers and queries  should be kept
separate.  This example shows an update operation on an AVL Tree in which the procedure returns aBoolean to indicate whether the tree is now in balance.
procedure  Balance (The_Tree : in out  AVL_Tree;  Balanced : out Boolean) is-- 1 Dynamically, self-balancing tree
begin -- 2  built on access types for flexibility .
-- long, complex, dynamically self-balancing algorithm -- 3 node rotations: LL, LR, RR, RL
Balanced :=   -- a boolean result from the balancing algorithm -- 4 Must be checked by caller
end Balance; -- 5
The problem with the above example is that, any subprogram making the call, must also be sure to check
the Boolean result.  If the Balanced  parameter is not evaluated, the Boolean out parameter is of no value.
procedure  Insert (Tree : in  out AVL_Tree;  Value : in Item) is -- 1 From collection of AVL_Tree methods
OK_To_Proceed : Boolean := False; -- 2 Should be initialized
begin -- Insert -- 3 Good practice to comment a begin
-- algorithm to insert a node in the tree -- 4 Pre-order, in-order, post-order?
Balance(The_Tree => Tree, Balanced => OK_To_Proceed); -- 5 Named association call
if OK_To_Proceed then -- 6 If you fail to do this check, you are
-- some additional source code here -- 7 Making use of  the out parameter of
end if ; -- 8                                        type Boolean.
end Insert; -- 9 If  name is supplied, compiler checks .
Some Ada practitioners believe it is better to raise  an exception  in a function than to return a Boolean out
parameter in a procedure.  Their rationale for this is that an exception  cannot be ignored, but an out
parameter, is easy to overlook or ignore.
Ada Distilled   by Richard Riehle
Page 43 of 1136.2 Functions
A function must return a result of the type indicated in its profile.  The compiler will check this and
disallow a wrong return type.   A function may be called in an assignment statement or as an argumentwithin another function or procedure call.   Ada al so allows pointers (access types) to functions and
procedures.
6.2.1 Function Format and Design
The Is_Valid function from a previous section might be coded to look like this,
function  Is_Valid (S : String) --  1 Default mode is in for type String
          return  Boolean is --  2 Boolean defined in package Standard
Result : Boolean := True; --  3 Return type named Result as local variable
begin --  4 Begin the handled-sequence of statements
for I in S'Range loop --  5 I takes the index type of String:  Positive
case S(I) is --  6 Examine a single character from the String
when  'a'..'z' | 'A'..'Z' => --  7 Check both upper and lower case
        null; --  8 No break statement is required
when  others  => --  9 others required if not all options are covered
        Result := False; -- 10 Simple assignment of Boolean value
        exit; -- 11 exit leaves the loop.  all indices are reset
end case ; -- 12 Every control structure requires terminator
end loop ; -- 13 Ends the scope of the loop including,  I
return  Result; -- 14 Compiler requires a return statement
end Is_Valid; -- 15 Scope terminator for the function. Required .
6.2.2  Function Examples
The next program is an example of an Ada function.  This function simply evaluates the greater of two
values in a parameter list and returns it.  Every function must have at least one return statement.
function   Largest (L, R : Integer) return  Integer is --  1 Parameterized function declaration; 6.3
begin --  2 Begins sequence of algorithmic statements; 6.3
if  L > R then --  3 Compare L to R  
return  L; --  4 function must return a value of return type 6.3
else --  5 If the comparison is false 5.3
return  R; --  6 Another return;  would a single return be better ?
end if ; --  7 Every if must have a corresponding end if. 5.3
end Largest; --  8 Scope terminator with name of unit 6.3
To call this function you will use an assignment statement.
with Largest ; --  1 with is permitted for library unit function
procedure Hrothgar  (Y, Z :  in  Integer; X : out Integer) is--  2  Note the modes of the parameter list
begin --  3
X := Largest(L => Y,  R => Z); --  4 Named Association syntax  6.3
end Hrothgar; --  5 As usual, include the name with the end statement
Line 4 shows named association  syntax.  In this case, L  and R name the formal parameters. Y and Z name
the actual parameters.  The arrow, in the form of =>, a ssociates the actual paramter with the formal.  This is
a powerful feature, unique to Ada, that makes s ource code more readable and more maintainable.
Suppose we have a record type called Stack.  It contains two components.  Every type ... is record
declaration must contain an end record   statement.  In the Stack reco rd, shown below, there is also a
component of an array type.  This is a constrained array of type Stack_Data.
type Stack_Data is array (1..1000) of Integer; --  1  Constrained array type definition for Integers
type Stack is record --  2  Record type format
Ada Distilled   by Richard Riehle
Page 44 of 113Data : Stack_Data; --  3  Array component within a record
Top  : Natural := 0; --  4  Natural data type;  note the initialization
end record ; --  5  Every record structure requires an end record
Here is a function that returns a boolean value for a record type, Stack, that contains a component, Top
function   Is_Empty (S : Stack) return  Boolean  is --  1  Parameterized function declaration;  6.3
Result : Boolean := False; --  2  A locally declared result variable
begin --  3  Begins sequence of algorithmic statements;  6.3
if  S.Top = 0 then  -- Equality test --  4  Syntax for an if statement; then is required
Result := True; --  5  Assignment statement based on true path
else --  6  An else takes the false path
Result := False; --  7  Another assignment
end if; --  8  An if requires an end if;  checked by compiler
return  Result; --  9  A function must contain at least one return  
end Is_Empty; --  10 Scope terminator with name of unit 6.3
Would it be better to have c oded the Is_Empty function as,
function   Is_Empty (S : Stack) return  Boolean  is --  1 Parameterized function declaration; 6.3
begin --  2 Begins sequence of algorithmic statements; 6.3
return  S.Top = 0; --  3 Compare S.Top to Zero True or False
end Is_Empty; --  4 Scope terminator with name of unit 6.3
Function parameters modes are only allowed to be in or access .  The default mode is always in. An in
parameter is the equivalent of a constant  to the function.  One may never assign a value to an in mode
parameter value.  Consider enumerated type, Mont h, and cycle through the months, returning to January
when you reach December.  Consider,
type Month is (January, February, March, April, May, June, Ju ly, August, September, October, November, December);
function  Next (Value : Month) return  Month  is -- 1  Declare a parameterized function
begin -- 2  No other declarations
if  Value = Month’Last then -- 3  Month'Last is December
return  Month’First; -- 4  Month'First is January
else -- 5  The usual behavior of else
return  Month’Succ(Value); -- 6  Month'Succ(June) is July
end if ; -- 7  End Scope of if statement
end Next; -- 8  End scope of function
Consider another type, Vector, de fined as an unconstrained array:
type Vector  is array  (Positive range  <>) of Float;    -- An unconstrained array;  must be constrained when used
with an exception defined in a visible package specification as:
Range_Imbalance : exception ;    -- An exception declaration, visi ble somewhere in the design
                    -- Note:  an exception is not a data type
function   “+”  (L, R : Vector) return  Vector  is --  1 Overloading an infix operator
Result : Vector (L’Range) := ( others  => 0.0); --  2 Constrain and initialize the result array
begin --  3
if L’Length  /= R’Length then --  4 Ensure R and L are of the same length
raise  Range_Imbalance; --  5 Raise user-defined exception shown above .
end if ; --  6 We never reach this point if exception is raised
for Index  in L’Range --  7  The 'Range attribute generalizes the Index
loop --  8  Index only lives the scope of the loop
Result (Index) := L(Index) + R(Index); --  9  Index is a constant in the loop
end loop ; -- 10 The end of scope for the loop
return  Result; -- 11 No exception handler.  The exception is propogated
end  “+”; -- 12                    to the calling subprogram.  Looks for handler .
Ada Distilled   by Richard Riehle
Page 45 of 113If the exception is not handled locally, the RTE w ill unwind through the calling stack searching for a
handler.  If none is found, the program will crash and burn .  You might want to have a function with an
access parameter.  This has potential side effect s.  Consider the following record definition,
type Data is record  --  1  Define a record type with a name
Value : Integer := 0; --   2  Initialize the values  when possible
Description : String(1..20); --   3  Probably should be initialized
end record ;- -   4  Scope terminator for the record data
type Ref is access all Data;  --  5  Define a  pointer to the record
You could have a function,
function   Is_Zero  (The_Data : access  Data) return  Boolean  is--  1  Note access parameter
begin -- 2  Of course, by now you know this
return  The_Data.Value = 0; -- 3  Return result of equality test
end Is_Zero; --  4  Scope terminator for the function
The Ada compiler will reject the following code,
function   Fix_It_A  (The_Data : access  Data) return  Ref  is -- 1 Access parameter and access result
       Fix_It_Data : Ref := new Data'(some initial values); -- 2  Declare some initialized access object
begin -- 3  Of course, by now you know this
The_Data := Fix_It_Data;  -- illegal, illegal, illegal -- 4  No assignment allowed to parameter value
return  The_Data; -- 5  Will never get to this; will not compile
end Fix_It_A; -- 6  Scope terminator for the function
but the compiler will accept the following  modifi cation of a componenent of an access object,
function   Fix_It_B  (The_Data : access  Data) return  Ref  is -- 1 Access parameter and access result
       Fix_It_Data : Integer := 25; -- 2  Declare initialized Integer  object
begin -- 3
The_Data.Value := Fix_It_Data; -- 4  Assignment allowed to component
return  The_Data; -- 5  Yes. Returns updated value for The_Data
end Fix_It_B; -- 6  Always include the name of the function
This is one of Ada's rare weaknesses vis a vi s C++.  In C++ we can declare a function as const  or a
parameter as const .   This may be fixed in a future ISO Ada so the access parameter can be constant .
One of the useful algor ithmic capabilities of modern programming languages is recursion .  For a recursive
solution, the subprogram must include a way to terminate before it runs out of memory.    The followingacademic example for a recursive function,  is se ldom a practical in real  progamming applications.
function  Factorial (N : Natural ) --  1
                          return  Positive is --  2 Must have a return type
begin --  3 Start of algorithmic part
if  N <= 1 then --  4 Less than or equal to ...
return  1; --  5 Lowest positive value
else --  6 Alternative path
return  N * Factorial (N - 1); --  7 The recursive call; function calls itself
end if; --  8 Terminate if statement
end Factorial;  --  9 Scope of the recursive function
Many sort routines, tree searching routines, and other algorithms use recursion.   It is possible to do this in
Ada because every subprogram call is re-entrant.   Each internal call of itself puts a result in a stack frame .
When the algorithm reaches a stoppi ng point, based on the if statemen t, it unwinds itself from the stack
frame entries with a final result of the computation.   The following program will work to test the Factorialprogram,
Ada Distilled   by Richard Riehle
Page 46 of 113with  Factorial; --  1 Yes, you may with a subprogram
with  Ada.Integer_Text_IO; --  2 I/O for Standard Integer
with  Ada.Text_IO; --  3 Character and String I/ O
use  Ada; --  4 Make Ada visible; not a problem
procedure  Test_Factorial is --  5 Specification with "is "
  Data : Natural := 0; --  6 In scope up to end of procedure
begin --  7 You know what this means by now
  Text_IO.Put("Enter Positive Integer: "); --  8 Display a prompt on the screen
  Integer_Text_IO.Get(Data); --  9 Get an integer from the keyboard
  Integer_Text_IO.Put(Factorial(Data)); -- 10 Display an integer on the screen
end Test_Factorial; -- 11 End of declarative region for procedure
It is important to understand that recusion can resu lt in a Storage_Error (see package Standard). Also,
intelligent use of Ada's visib ility rules can often prevent acci dental, infinite recursion.
A function can be compiled by itself in the library.   Even more interesting is that a function specification
can be compiled into the library by itself.    When the specification is compiled it must be completed laterwith an implementation.   This is identical to the procedure example, Simple_2, in 6.1.2 above.
6.3 Subprograms in A Package
An Ada package specification may group a set of subprogram declarations.  No implementation code ispermitted in the specification.   The implementation will be in the package body .   This is more fully
covered in Chapter 7, below.  Here is a simple package specification with a corresponding body.  First thespecification:
package  Kia_Ora is --  1 Hello in Maori,early language of New Zealand
  procedure  Kia_Menemene; --  2 Be happy, in Maori
function     Menemene return  Boolean; --  3 Are you happy?
end Kia_Ora; --  4 end of pacakge specification
Then a package body highlighting separate compilation:
package  body  Kia_Ora is --  1 Now includes the word, body
  procedure  Kia_Menemene is separate ; --  2 Defer actual implementation for the subprograms
    function     Menemene return  Boolean is separate ; --  3 to separate  compilation units .
end Kia_Ora; --  4
The separately compiled procedure could be coded:
separate  (Kia_Ora) --  1 Note absence of semicolon
procedure  Kia_Menemene is --  2 Makes maintenance much ea sier in small chunks
begin --  3
-- some implementation code here --  4 Any standard Ada algorithmic code here
end Kia_Menemene;Note: Although this is the usual
example given in textbooks toillustrate recursion, it is not alwaysthe best way to accomplishfactorial computation.
Ada Distilled   by Richard Riehle
Page  47 of 1137. Package Design
At the beginning of this book, we showed an example of an Ada package.  Most Ada programs are
designed with packages.   In fact, a single program is usually composed of many  packages.  A package is a
module  for collecting related information and services.  It can be thought of as a contract  for services.
The user of that contract may be thought of as a client .   In this sense, a client may us some of the services
but not want to use all of those services.  Ada allo ws a client to indentify only those services needed,
through its visibility rules, even though all servi ces might be in scope and potentially visible.
The services are in the form of type definitions, data declarations, and subprograms.  A well-designed
package will rarely have data declarations as part of  the contract.  Instead, re ferences to data should be
through a call to some subprogram.
7.1 A Simple Package
We revise the specification fo r the earlier Messenger package.
package  Messenger is --  1 An Ada Module
type Message is private ; --  2 A partial definition of message
function  Null_Message return  Message; --  3 Gives a null message
function  Create (S : String) return  Message; --  4 Make a message from a String
function  Get return  Message; --  5 Get  message from keyboard
procedure  Put (M : in Message); --  6 Put Message to Screen
procedure  Clear (M : in out  Message); --  7 Set message to null message
function  Text (M : Message) return  String; --  8 The string portion of  message
function  Length (M : Message) return  Natural; --  9 How many of characters
private -- 10 Begin private part of package
type Message is record -- 11 Full definition of message
Data : String(1..200) := ( others  => ' '); -- 12 Message content; initialized
Len  : Natural := 0; -- 13 Message size; initialized
end record ; -- 14 End of message definition
end Messenger; -- 15 End of the specification
Notice there is no algorithmic code in a package specifi cation.  Ada lets you declare all the subprograms in
the specification.  The implementation is in another compilation unit called the package body but thespecification and body are both part of the same library unit.  The specification is a contract with a client.It tells what it will do, not how it will be done.   Ada is forbids algorithmic code in the specification part.
A client of package Messenger is only able to see lines 1 through 9 of the specification.  The rest (lines 10
through 14) is only in the specification to satisfy the requirements of the Ada compiler.   We call lines 1through 9 the public part of the specification and lines 10 through 14, the private part.  The private part ofan Ada package specification is somewhat analogous to a C++ class protected part.    A child library unit
may have some visibility to private part just as C++ derived class has visibility to a protected part of itsparent class.   We examine these visibility issues later.
The package Messenger exports some services as subpr ograms. The algorithmic (procedural) part of these
subprograms must be coded  someplace.   Ada forbid s algorithms in the packag e specification. Algorithms
must be coded in the package body. Subprogram declarations in the specification require a correspondingimplementation in the body. The package body depends  on successful compilation of its fully conforming
package specification.   The Ada compiler checks this dependency through compilation unit date and time
stamps.   The package body is an integral part of the library unit.   The package body never needs to with
the package specification because both are part of the same library unit.Public Part
Private
Ada Distilled   by Richard Riehle
Page 48 of 1137.2 Package Body
Not every package needs a package body.  In practice, only packag es that declare public subprograms need
a body.  Now and then a package may require a body even if it does not export a subprogram.   This wouldbe the exception rather than the rule.  This exception to the rule is also rigorously managed by thecompiler.
 Here is a package body for Messenger.
package body  Messenger is --  1
function  Create (S : String) return  Message is --  2
begin --  3
-- algorithm to create object of type Message --  4
-- must have at least one return statement --  5
end Create; --  6
function  Get return  Message is --  7
begin --  8
-- algorithm to Get a message from some container or input device --  9
-- must have at least one return statement -- 10
end Get ; -- 11
procedure  Put (M : in Message) is -- 12
begin -- 13
-- algorithm goes here -- 14
end Put; -- 15
procedure  Clear (M : in out  Message) is -- 16
begin -- 17
-- algorithm to clear the Message -- 18
end Clear; -- 19
function  Text (M : Message) return  String is -- 20
begin -- 21
-- algorithm, if necessary -- 22
-- must have at least one return statement -- 23
end Text; -- 24
function  Length (M : Message) return  Natural is -- 25
begin -- 26
-- algorithm to get length of Message Text -- 27
-- must have at least one return statement -- 28
end Length; -- 29
end Messenger; -- 30
Neither a client or child of packag e Messenger ever has visibility to th e package body.   We say that the
implementation (always in a package body) is encapsulated .
7.3 More Simple Package Examples
7.3.1 Monetary Conversion Package
Here is another simple package specification.  An implementation would convert currencies.
package  Conversions is --  1
type Money is delta  0.0001 digits  12; --  2 a decimal fixed-point type
type Yen is new  Money; --  3 derive from Money
type Dollars is new  Money; --  4 derive from Money
function  Convert (Y : Yen; Rate : Money) return  Dollars; --  5 declare a function specification
function  Convert (D : Dollars; Rate : Money) return  Yen; --  6 declare a function specification
Conversion_Error  :  exception; --  7 declare an exception
end Conversions; --  8
package body  Conversions is --  1
function  Convert (Y : Yen; Rate : Money) return  Dollars is --  2
Result : Dollars := 0.0; --  3 declare result of return typeAn acceptable variation on this body
would be to code each subprogram with
the reserved word separate .   For
example,
procedure  Put
  (M : in Message) is separate ;
This would cause a stub for a subunit to
be created in the libra ry for the completed
code corresponding to procedure Put.This technique is useful when one wantsto divide the implementation of a packageover a team of several people, or preservethe confidentiality of a particular piece ofsource code.
Ada Distilled   by Richard Riehle
Page 49 of 113begin --  4 stub out the function temporarily
  return Result; --  5 after algorithm to do conversion
end Convert; --  6
function  Convert (D : Dollars; Rate : Money) return  Yen is --  7
Result : Yen := 0.0; --  8 declare result of return type
begin --  9 temporarily stub out the begin..end part
  return Result; -- 10  after algorithm to do conversion
end Convert; -- 11
end Conversions; -- 12
The technique here is to stub out a function.   Notice we must first declare a Result of the return type. Then
we can code the return statement in the begin..end pa rt.   A procedure can be stubbed out with the reserved
word, null.  A function must have at least one return statement.  This technique satisfies that requirement.
7.3.2 Simple Statistics Package
Here is another kind of package. This package provides a simple set of statistical services.
package Statistics is --  1 Specification declaration
type Data  is array  (Positive range  <>) of Float; --  2 An  unconstrained array .
function Mean     (The_Data : Data) return Float; --   3 Computes the statistical Mean
function Mode     (The_Data : Data) return Float; --   4 Computes the statistical Mode
function Max      (The_Data : Data) return Float ;--  5 Computes Maximum Value of  arrray
function Min      (The_Data : Data) return Float; --   6 Computes Minimum Value of array
function Variance  (The_Data : Data) return Float; --   7 Computes Statistical Variance
function StdDev   (The_Data : Data) return Float; --   8 Computes Standard Deviation
end Statistics; --   9  Package specification requires end
The following procedure is a clie nt of the Statistics package.
with Statistics; --   1  Put Statistics library unit in scope
with Ada.Float_Text_IO; --   2  Library unit for floating point I/O
use  Ada; --   3  Makes Ada visible; discussed later
procedure Compute_Statistics  is --  4  A stand-alone procedure
  Stat_Data : Statistics.Data(1..100); --   5  An array of float; note the constraint
begin --  6  Starts the algorithmic part of procedure
  for Index in Stat_Data'Range --   7  Specification of a for loop; more later
 loop --  8  Every loop must have the word loop
      Float_Text_IO.Get(Stat_Data(Index)); --   9  Fill the array with data
    end loop; -- 10 Every loop must have an end loop
  Float_Text_IO.Put(Statistics.Mean(Stat_Data)); --  11 Call Statistics.Mean and output result
  Float_Text_IO.Put(Statistics.StdDev(Stat_Data)); --  12 Call Statistics.StdDev and output result
end Compute_Statistics ; -- 13 End of the procedure scope
The with statement on Line 1 puts the resources of the Statistics package in sc ope. The Variance function
may be called by referencing Statistics.Variance.   Line 2 puts the language-defined library unit,
Ada.Float_Text_IO in scope.  Line 3 makes the parent of   Float_Text_IO directly visible.  Therefore, the
Get operation of Float_Text_IO on Line 9 is legal.  Program declarations are between the is on Line 4 and
the begin  on Line 6.   On Line 5, the declaration is for data of the array type Statistics.Data.  Since
Statistics.Data is declared with no actual range in the Statistics package, the programmer must specifybeginning and ending index values.  Ada allows starting indexes other than zero.  The defined index for an
array type may even include a range of negative values.
The expression, Stat_Data'Range in the loop specification, indicates that  the loop will traverse the entire
array, beginning with the first value through the last valu e.   The loop index, Index, will start with the first
value in the Range and proceed to the end.  The Get operation on Line 9 is defined in the package
Ada.Float_Text_IO.   Because we have a use clause for Ada on Line 3, we may reference it as shown.
The same is true for the Put operations on Lines 11 a nd 12.   We call the Mean and StdDev functions from
Statistics.   These functions take a parameter of type Data and return a floating point value.
Ada Distilled   by Richard Riehle
Page 50 of 1137.4 Simple Mathematics Packages
Ada has a rich set of capabilities for numeric algorithms.  One of the key packages is Ada.Numerics.  This
package has some child packages.  The most important are Ada.Nume rics.Generic_Elementary_Functions,
Ada.Numerics.Float_Random, and Ada.Numerics.Discrete_Random.  It also defines, in Annex G, a modelfor strict  and relaxed  mode for floating point values.   
(Also see the discussion on attributes in this book .)
7.4.1 Example without Numerics Library
This example will compile and execute.  However, it is better to use the language-defined libraries.
with  Ada.Text_IO; --  1 Put Text_IO library unit in scope; 10.1.2, A.10
with Ada.Float_Text_IO; --  2 Predefined in Annex A A.10.9/33
procedure   Pi_Symbol  is --  3 Parameterless declaration; 6.3
Pi : constant  Float := 3.1415; --  4 Should have used Ada.Numerics for this
Radius : Float := 12.0; --  5 Ordinary Floating point initialized
Area : Float := 0.0; --  6 I somtimes initialize all variables; not required here
begin --  7 Begins sequence of algorithmic statements; 6.3
Area := Pi * Radius ** 2; --  8 Pi is also pre-defined in Ada.Numerics
Ada.Float_Text_IO.Put(Area); --  9 Dot notation makes Put visible A.10.6
end Pi_Symbol; -- 10 Scope terminator with name of unit 6.3
7.4.2 Using Numerics Library
A better approach to  declaring Pi and and using Ada for number crunching is to use the language-defined
numerics libraries.   The following program illustrates some ideas from this set of libraries.
with  Ada.Text_IO; --   1 Put Text_IO library unit in scope; 10.1.2, A.10
with Ada.Float_Text_IO; --   2 A.10.9/33
with Ada.Numerics.Generic_Elementary_Functions; --   3 A.5.1
use Ada; --   4 Gives direct visibility to all of package Ada 8.4
procedure   Compute_Trigs  is --   5 Parameterless declaration; 6.3
package Compute is new Ada. --   6 A.2  A new instance with a new name
Numerics. --   7 A.5 Root package for numerics
Generic_Elementary_Functions --   8 A.5.1  Contains Trig and other functions
(Float_Type => Float); --   9 A.1/25 for definition of type Float
Pi  : Float := Ada.Numerics.Pi; --  10 Pi is defined in Ada.Numerics
Radius : Float := 12.0; --  11 Ordinary Floating point initialized
Area : Float := 0.0; --  12 Not everyone agrees that initialization is a good idea!
SQRT_Result : Float := 0.0; --  13 For our Square root computation
begin --  14 Begins sequence of algorithmic statements; 6.3
Area := Pi* Radius ** 2; --  15 Compute the area of the circle
Ada.Float_Text_IO.Put(Area); --  16 dot notation makes Put visible A.10.6
Sqrt_Result := Compute.Sqrt(Area); --  17 Note use of Compute with dot notation
end Compute_Trigs; --  18 Scope terminator with name of unit 6.3
Note :  Not everyone agrees with line 12, above.  Some developers prefer not  to initialize variables because they might contribute t o unexpected errors during maintenance.
Ada Distilled   by Richard Riehle
Page 51 of 1137.4.3 Precompile Numerics Library
Sometimes it is useful to precompile a generic library package for a frequently used data type.  The math
library is one such package, especi ally if you are using the same floating point type over and over in your
application.
Suppose you have declared the following example somewhere in your design,
package  Defined_Types is
        type Real is digits  7 range  -2.0 ** 32 .. 2.0 ** 32;
end Defined_Types;
Ada allows you to precompile the generic elementary functions package for this type so it could be brought
into scope through a simple "with" clause.   For example,
with  Ada.Numerics.Generic_Elementary_Functions;
with  Defined_Types;
package  Real_Functions is new  Ada.Numerics.
                                                  Generic_Elementary_Functions(Defined_Types.Real);
Now, you can access this package easily by " with  Real_Functions" in a context clause.
7.4.4 Mathematical Expressions
The following examples demonstrate the use of the gene ric mathematics package with calls to some of the
functions in that package.  Note that the default type for trigonometric functions is in Radians.
with  Defined_Types; --  1
with  Real_Functions; --  2
with  Generic_Utilities; --  3
procedure  Test_Math_Functions is --  4
   subtype  Degree  is Defined_Types.Real range  1.0..360.0; --  5
   subtype  Radian  is Defined_Types.Real range  0.0..2.0 * 3.14; --  6
   function  To_Degrees is new  Generic_Utilities.To_Degrees(Degree => Degree, Radian => Radian); --  7
   function  To_Radians is new  Generic_Utilities.To_Radians(Degree => Degree, Radian => Radian); --  8
   R1, R2, R3, R4 : Radian := 0.0; --  9   D1 : Degree := 90.0; -- 10
   D2 : Degree := 360.0; -- 11
begin -- 12
R1 := To_Radians(D1); -- 13
R2 := Real_Functions.Sin(X  => R1); -- 14
R2 := Real_Functions.Sin(X  => R1, Cycle  => D2); -- 15
R2 := Real_Functions.ArcSinh(X  => R1); -- 16
R3 := Real_Functions.ArcCot(X  => R1, Cycle  => 40.0); -- 17
R4 := Real_Functions.Cos(X  => R1, Cycle  => D2); -- 18
R1 := To_Radians(D2); -- 19R3 := Real_Functions.Tan(X  => R1); -- 20
D2 := To_Degrees(R2); -- 21
end Test_Math_Functions; -- 22
The package Generic_Utilities is not desc ribed in this book.  It is one the program files in the ZIP file of
programs available with this book.   For functions with no cycle parameter, assume a natural cycle of 2 Pi,which means all calculations are done in radians.   Lines 17 shows that you can provide other parametervalues for the cycle parameter.This fragment of code can actually be compiled as a new library unit that can be
referenced in a context clause throu gh a with clause
Ada Distilled   by Richard Riehle
Page  52 of 1138. Child Library Units
An Ada package may have a child.   The child ma y be another package or a subprogram.  A subprogram
may not have a child.   Most of the time, design child lib rary units as packages so they can be extended.  A
child package specification is just like any other package specification.
.
8.1 Kinds of Child Library Units
Child library units may be packages, functions, or procedures.   A function or procedure may not have
additional children.   Ada supports both public and private child library units.   A child unit is public, bydefault.   The identifier of a public child may appear  in any context clause anywhere in a system.   A
private child may only appear in a context clause for a body (e.g., package body) when that body is for aspecification with the same root (parent, grandparent, etc.).   It is also possible to have generic child libraryunits.   However, children of generic units must also be generic.
8.2 Visibility Rules
Visibility Rules are a little trickybut easy once you grok them.
8.3 Root Packages
Sometimes we want to design a root package that is the home node for a hierarchy or subsystem of otherlibrary units.   A root package can vary greatly in its form.  Sometimes a root package contains nothing bua few exception declarations.  Other times it is more co mplex, possibly with specia lized type declarations.
the general rule is to keep the r oot package as simple as possible  Here is one possible root packagePublic part of child has
direct visibility topublic part of parentprivate part of child hasdirect visibility to privateand public part of parent
client has no direct visibilityto any unit referred to in acontext clausepackage  P.Q is
  type T2 is new T1 with private ;
  procedure  Make(X : in out  T2);
  function   OK (X : in T2) return  Boolean;
private
  type T2 is new T1 with  record  ....
end P.Q;P
P.Qpackage  body  P is
  procedure  Make(X : in out  T1) is ... end Make;
  function   OK (X : in T1) return  Boolean is ... end OK;
end P;
package  body  P.Q is
  procedure  Make(X : in out  T2) is ... end Make;
  function   OK (X : in T2) return  Boolean is ... end OK;
end P.Q;
with  P.Q;
procedure  P_Q_Client is
     ...
begin
     ...
end P_Q_Client;private part of child has direct visib ility to private and pub lic part of parentpackage  P is
  type T1 is tagged private ;
  procedure  Make(X : in out  T1);
  function   OK (X : in T1) return  Boolean;
private
  type T1 is tagged record  .. end record ;
end P;
There is direct upward visibility from a child to its parent.  The
private part and body of a child  can see the private and public
part of a parent or grandparent.    No unit ever has directvisibility to a package body.    A c lient never has direct visibility
to any other unit.    The client  must use one of the visibility
mechanisms to get direct visibility.    The direct visibility of child
units continues all through the parent child hierarchy.
Grandchildren bodies can s ee grandparent private parts.
a) Public part of child has direct visibility to public part of parent
b) Private part of child has direct visibility  to private and public part of parent.
c) Body of child has direct visibility to  private and public part of parent.
d) Grandchild units have direct visib ility that corresponds to child units.
e) Private unit can only be with'ed by body of   unit if both have same root package .
Ada Distilled   by Richard Riehle
Page 53 of 113package  Root is --  1 Declare a root package specification
Bad_Bad_Bad : exception ; --  2 An exception declaration which will be
No_No_No :    exception ; --  3 visible throughout the entire hierarchy .
type Number is private ; --  4 A partial definition for a type
function  "+" (N  : Number)  return  Number; --  5 Overloading equivalent to i++
 function  "-" (N  : Number)  return  Number; --  6 Overloading equivalent to i--
 function  Set (To : Integer) return  Number; --  7 Set number  to a value
 function  Integer_Is(N : Number) return  Integer; --  8 Convert number to an Integer
private --  9 Begin the private part of package
  type Number is range  -2**31..2**31-1; -- 10 Full definition of the private type
end Root; -- 11 End of scope for package specification
This package illustrates a possible design for a root p ackage.  This is simply a model, not a suggested
design approach.  Here is a simple child  package of the preceding Root package.
package  Root.Application is
type Application_Type is privat e;        -- partial definition of type
procedure  Create (A : in out  Application_Type);
function    Is_Empty(A : Application_Type) return  Boolean;
-- more operations(modifier and query methods)
private
type Application_Type is ... ;               -- full definition of private type
end Root.Application;
8.4 Classwide Child Package
Earlier in this book we had a root package that resembled the following,
package Abstract_Machinery is --  Package specification; requires body
type Machine is abstract tagged private ; -- Specifies the visible part of the data type ;
type Reference is access all  Machine'Class; -- Tagged type should have classwide access
function  Create (Desc : String) -- Parameter for Create
               return  Machine'Class; -- Tagged return type should be classwide
procedure  Turn_On  (M : in out  Machine); --  procedure specification; modifier method
procedure  Turn_Off (M : in out  Machine); --  procedure specification; modifier method
function   Is_On (M : in Machine) return  Boolean; --  function specification; query method
private --  private part hidden from a client of contract
type Machine is abstract tagged record --  full definition of the publicly declared type
Turned_On : Boolean := False; --  component of the type; OOP attribute
Description : String(1..120); --  Constrained array component
end record ; --  scope terminator for the component
end Abstract_Machinery; --  scope terminator for the specification
This could be a base (root) package for machines that can be turned on and off.    The data type, Machine,
is declared abstract.  That means no instances of it are allowed.  One could create some child packages for
this, combining child library units and inheritance.
package Abstract_Machinery.Classwide is --  1  Package specification; requires body
type FIFO_Container(Size : Positive) --  2  Parameterized type; make it any size
     is limited private ; --  3  No assignment ever allowed for limited view of a type
procedure  Put(CM   : in out  FIFO_Container; --  4  Put into the next ava ilable Container location
            Data : access  Machine'Class); --  5  Any member of class, Machine
procedure Get(CM   : in out  FIFO_Container) --  6 Get, destructively, first item, from the Container
          Data : access  Machine'Class); --  7 Any member in derivati on tree for Machine'class
private --  8 Start hidden part of the package; never visible to a client
type Machine_Data is array --  9 Define an unconstrained array
      (Positive range  <>) of Reference; -- 10 The array is pointers to Machine'Class
type FIFO_Container(Size : Positive) is -- 11 Full definition of parameterized type; parameter call a discriminant
record -- 12 in the format of a record
Current : Natural; -- 13 What is the current item; this  is an index into the array
Data    : Machine_Data(1..Size); -- 14 Pointer array to Machine derivations
end record ; -- 15 Terminate scope of the record
end Abstract_Machinery.Classwide; -- 16 scope terminator for the ch ild library unit specificationDot notation to signifies that Application is a
child unit of package R oot.  Public part of
Application has direct visibility to public part
of package Root.   Privat e part of Application
has direct visibility to private and public partof package Root.
Visible
part of
contract.
Not
visible
to client
of
contract.
Ada Distilled   by Richard Riehle
Page 54 of 113The preceding classwide child  package lets you put any object of type Machine'Class into a container.
This is quite a handy thing to be able to do.   Th is is a heterogeneous container for different kinds of
machines.
8.5 Private Child Library Unit
Sometimes we want to promote the internals of a p ackage to the level of a separate package.  The
following example is a simplified contrivance that is intended to show how one might refactor a design intobetter abstractions.   We use the language featur e called, private child units to accomplish this.
Consider a package that has a simple specification where the public methods are implemented in package
body.   The example package, shown below, does some simple message handling, but also stores andretrieves each message from a fixed size array.    A r eal application would be mo re designed to more robust
standards, but we keep this simple to illustrate our central point.
8.5.3.1  Root Package for Application
package  Application is --  1 Declare a root package for application
   type Assertion is access  function  return  Boolean; --  2 A pointer  (access type) to a function
   Precondition_Error  : exception ; --  3
   Postcondition_Error : exception ; --  4
   Invariant_Error     : exception ; --  5
end Application; --  6
This style of package should be se lf-evident by now.  It  is nothing more than an access type  to a
parameterless function and few exceptions that can be raised throughout the parent-child hierarchy.
8.5.3.2 Child of Application Root
This is a child package of th e root package in 8.1.2.1.    It has dir ect visibility to all of the public features of
the parent package.   The pre- and post-conditions are access parameters in the procedures.  This is possible
because the functions are at the same accessibility level as the access type in package Application.
package  Application.Messenger is --  1 A child of package Application
type Message is tagged  private ; --  2 A simple tagged type; public view
  type Reference is access  all Message'Class; --  3 Always include a classwide access
  function  Require_Not_Empty return  Boolean; --  4 Pre-condition
  function  Ensure_Length_Adjusted return  Boolean; --  5 Post-condition
  function  Require_Not_Full return  Boolean; --  6 Pre-condition
procedure  Make(M : in out Message; S : String); --  7
procedure  Get --  7.1
                (M : out Message; --  8
                 Precondition  : Assertion := Require_Not_Empty'Access; --  9 Access to a subprogram
                 Postcondition : Assertion := Ensure_Length_Adjusted'Access); -- 10 Access to subprogram
procedure  Put -- 10.1
 (M : in  Message; -- 11
               Precondition  : Assertion := Require_Not_Full'Access; -- 12 Access to subprogram
               Postcondition : Assertion := Ensure_Length_Adjusted'Access); -- 13 Access to subprogram
  function   Len (M : in Message) return  Natural; -- 14
private -- 15
type Message is tagged  record -- 16 Full definition of tagged type
     Text   : String(1..120); -- 17
     Length : Natural := 0; -- 18
  end record ; -- 19
end Application.Messenger; -- 20Three exceptions, each of which will be
directly visible throughout the entirehierarchy of child  library units.
Ada Distilled   by Richard Riehle
Page 55 of 1138.5.3.3  A Private Child Package
A private child library unit may only be referenced by a context clause in the body of a unit rooted at the
same level as the direct parent unit.   In this case, Messenger is the parent of this private package.
private  package  Application.Messenger.Storage is  -- Note the word private  and dot notation --  1
type Message_Container is private ; --  2
procedure  Insert_At_End     (Into : in out Message_Container; M : in  Message'Class); --  3
   procedure  Get_First_Message (From : in out Message_Container; M : out Message'Class); --  4
 private --  5
   type Container is array (1..500) of Reference; --  6
   type Message_Container is --  7
        record --  8
            Data  : Container;   -- An array of 500 Message'Class access values --  9
            Count : Natural := 0; -- 10
        end record ; -- 11
end Application.Messenger.Storage; -- 12
8.5.3.4 The Body of Application.Messenger
This exmple, by itself, is not to be taken too seriously.   You will enjoy designing your own version when
you study this feature in more depth.   It does comp ile and execute.  However, we  have not defined all the
algorithms and functionality that you might want for a robust application.
with  Application.Messenger.Storage;          -- Context clause only permitted in body of sibling package --  1
package  body  Application.Messenger is --  2
   The_Storage_Container : Application.Messenger.Storage. --  3                                                   Message_Container; --  4
   procedure  Get (M : out Message; --  5
                              Precondition  : Assertion := Require_Not_Empty'Access; --  6
                              Postcondition : Assertion := Ensure_Length_Adjusted'Access) is --  7
   begin --  8
      if Require_Not_Empty then --  9
        Application.Messe nger.Storage.Get_First_Message -- 10
                  (From => The_Storage_Container, M => M);  -- 
Note use of named association -- 11
      end if; -- 12
      if Ensure_Length_Adjusted then -- 13
               null;                -- This would usually contain act ual code but we stubbed it out. -- 14
      end if; -- 15
   end Get; -- 16
   function  Len (M : in Message) return  Natural is -- 17
   begin -- 18
      return  M.Length; -- 19
   end Len; -- 20
   procedure  Make (M : in out Message; S : String) is -- 21
   begin -- 22
      if  S'Length > M.Text'Length then -- 23
            raise  PreCondition_Error; -- 24
      else -- 25
            M.Text(1..S'Length) := S(S'Range); -- 26
      end if; -- 27
      M.Length := S'Length; -- 28
   end Make; -- 29
   procedure  Put (M : in  Message; -- 30
                             Precondition  : Assertion := Require_Not_Full'Access; -- 31
                            Postcondition : Assertion := Ensure_Length_Adjusted'Access) is -- 32
   begin -- 33
      Application.Messenger.Storage.Insert_At_ End(Into => The_Storage_Container, M => M); -- 34Important Ada Design Feature
This private  package
specification is achild of Messengerwhich is a child ofApplication.Note
Ada Distilled   by Richard Riehle
Page 56 of 113   end Put; -- 35
   function  Require_Not_Empty return  Boolean is -- 36
      Result : Boolean := False; -- 37
   begin -- 38
        return  Result; -- 39
   end Require_Not_Empty; -- 40
   function  Ensure_Length_Adjusted return  Boolean is      -- 41
       Result : Boolean := False; -- 42
   begin -- 43
        return  Result; -- 44
   end Ensure_Length_Adjusted; -- 45
   function  Require_Not_Full return  Boolean is     -- 46
       Result : Boolean := False; -- 47
   begin -- 48
        return  Result; -- 49
   end Require_Not_Full; -- 50
end Application.Messenger; -- 51
8.5.3.5 Body for The Private Child Unit
This example is all done except for the body of the private child unit.  Notice that we have stubbed out
some of the implementation.   This also compiles and executes.  You will want to expand on thefunctionality.  You might even want to change the implementation of the container to something moregeneric.
with  Ada.Unchecked_Deallocation; --  1
package  body  Application.Messenger.Storage is --  2
procedure  Free is new Ada.Unchecked_Deallocation --  3
                                               (Object => Message'Class, --  4                                                    Name   => Reference); --  5
procedure  Get_First_Message (From : in out Message_Container; M : out Message'Class) is--  6
      Work_Container : Container := From.Data; --  7
  begin --  8
      M := From.Data(1). all; --  9
      Free(From.Data(1)); -- 10      From.Data(1..From.Count ) := From.Data(2..From.Data'Last); -- 11
end Get_First_Message; -- 12
procedure  Insert_At_End (Into : in out Message_Container; M : in  Message'Class) is -- 13
begin -- 14
      if  Into.Count < Container'Length then -- 15
         Into.Count := Into.Count + 1; -- 16
         Into.Data(Into.Count) := new Message'(M); -- 17
      else -- 18
              raise  PreCondition_Error; -- 19
      end if; -- 20
   end Insert_At_End; -- 21
end Application.Messenger.Storage; -- 22
8.6 Summary
Child library units are one of the most powerful features of the current Ada standard.  When you have
practised with them long enough, you will find many ways to use them to factor your designs into smaller,
more compact, and more maintainable compilation units.
Ada Distilled   by Richard Riehle
Page  57 of 1139. Object-Oriented Programming With Packages
Ada includes support for extensible inheritance, polymorphism, and dynamic binding. These are three key
features of object-oriented programming (OOP).  Ada enables this through the extensible tagged type.
9.1 An Object-Oriented Type
Consider this package containing a tagged type.  Every instance of a tagged type contains an internal tag.A tagged type may be extended with additional components.
package  Machinery is --  1  An Ada Module
type Machine is tagged  private ; --  2  A tagged  partial definition of message
type Reference is access all Machine’Class; --  3  A classwide access type
procedure  Turn_On (M : in out  Machine); --  5  Turn on the machine
procedure  Turn_Off (M : in out  Machine); --  6  Turn off the Machine
function  Is_On  (M : Machine) return  Boolean; --  7 Is the Machine turned on?
private --  8  Begin private part of package
type Machine  is tagged record --  9  Full tagged definition of message
Is_On : Boolean := False; -- 10  Machine content; initialized
end record ; -- 11 End of machine definition
end Machinery; -- 12 End of the package specification
9.2 A Possible Client of the Type
A client of package Messenger might be set up as,
with  Messenger; -- 1 A context clause
procedure Messenger_Processor ...  end Messenger_Processor; -- 2 Three dots are not legal Ada
The context clause, with  Messenger, makes package Messenger and all its public services available, but
not directly visible, to Messenger_Processor.   Public services can be made visible through a use clause, ause type clause, renaming of the operations, or simple dot notation.
9.3 Inheritance and Extension
The Machinery package specification, with its tagged type, Machine, illustrates some important ideas inAda.   A tagged type may be extended.  Therefore, one could have a client package, Rotating_Machinery,
with  Machinery; --  1
package  Rotating_Machinery is --  2
type Rotational is new Machinery.Machine with private; --  3  Inherits Machine methods & data
procedure  Turn_On (M : in out  Rotational); --  4  Overrides Machinery.Turn_On
procedure  Turn_Off (M : in out  Rotational); --  5  Overrides Machinery.Turn_Off
procedure  Set_Speed(M : in out  Rotational;  S : in Positive); --  6  New primitive operation
private --  7
type Rotational  is new Machinery.Machine --  8
with record --  9
   RPM  :  Natural :=  0; -- 10 New component in derivation
end record ; -- 11
end Rotating_Machinery; -- 12
The Rotating_Machinery package declares a data type th at extends the content of the parent type.  The
type, Rotational now contains two components.  It ha s the one originally included in Machine plus the one
we added in the type derivation statement.An Ada package is not a first-class object. You cannot
create instances of a package, unless it is a generic package.
Ada Distilled   by Richard Riehle
Page 58 of 1139.4 Dynamic Polymorphism
9.4.1 Dispatching with Primitive Operations
The operations Turn_On, Turn_Off, Is_On, and Set_Speed are called primitive operations .   They can be
called dynamically, depending on the tag of the object . The following procedure demonstrates one way to
do this.  Note:  the actual procedure to be called cannot be determined until run-time in this example.
with  Machinery, Rotating_Machinery; --  1  Context clause
with  Ada.Integer_Text_IO; --  2  Enables the input of the array index
procedure  Dynamic_Binding_Example_1 is --  3  Specification for the example procedure
Data : array  (1..2) of Machinery.Reference := --  4 Anonymous array of access objects
     (1 => new Machinery.Machine, --  5 Dynamically allocate new Object
      2 => new Rotating_Machinery.Rotational); --  6 Dynamically allocate new Object
Index : Natural range  1..2 := 0; --  7  Use this to ind ex into the array
begin --  8
Ada.Integer_Text_IO.Get(Index); --  9  Get the index for the next statement
Machinery.Turn_On(Data(Index). all); -- 10 Dynamically call one of the Turn_On methods
end Dynamic_Binding_Example_1; -- 11
The next example does essentially what the previous example did.  However, this example illustrates how
to code a classwide procedure.   Once again, the version of Turn_On to choose is known only at run-time.
with  Machinery, Rotating_Machinery; --  1 With both packages; no use clause required
with  Ada.Integer_Text_IO; --  2  Enables the input of the array index
procedure  Dynamic_Binding_Example_2 is --  3  Specification for the example procedure
Data : array  (1..2) of Machinery.Reference := --  4 Anonymous array of access objects
      (1 => new Machinery.Machine, --  5 Dynamically allocate new Object
       2 => new Rotating_Machinery.Rotational); --  6 Dynamically allocate new Object
Index : Natural range  0..2 := 0; --  7  Use this to ind ex into the array
procedure  Start(M : Machine’Class) is --  8  Procedure with classwide parameter
begin --  9
Machinery.Turn_On(M); -- 10  Turn_On is dynamically determined via the tag
end Start; -- 11
begin -- 12
Ada.Integer_Text_IO.Get(Index); -- 13 Get the index for the next statement
Start(M => Data(Index). all)); -- 14 Call the classwide procedure
end Dynamic_Binding_Example_2; -- 15
Here is still one more example that illustrates the usefulness of a function that returns a classwide value..
with  Machinery, Rotating_Machinery; --  1  No use clause is required for this example
with  Ada.Integer_Text_IO; --  2  Enables the input of the array index
procedure  Dynamic_Binding_Example_3 is --  3  Specification for the example procedure
Index : Natural range  0..2 := 0; --  4  Use this to ind ex into the array
function  Get (The_Index : Natural) return  Machine’Class  is --  5  Procedure with classwide parameter
Data : array  (1..2) of Machinery.Reference := --  6 Anoymous array of access objects
        (1 => new Machinery.Machine, --  7 Dynamically allocate new Object
   2 => new Rotating_Machinery.Rotational); --  8 Dynamically allocate new Object
begin --  9
return  Data(Index). all)); -- 10   return the data access by Data(Index )
end Get; -- 11
begin -- 12
Ada.Integer_Text_IO.Get(Index); -- 13 Get the index for the next statement
declare -- 14 Start a local declare block
The_Machine : Machine’Class := Get(Index); -- 15 Declare and constrain classwide variable
begin -- 16
Turn_On(The_Machine); -- 17 Call classwide procedure
end; -- 18
end Dynamic_Binding_Example_3; -- 19Dynamic BindingDynamic Binding
Dynamic BindingEssential for true object-oriented programming
Ada Distilled   by Richard Riehle
Page 59 of 1139.4.2  Dynamic Binding with Mixed Library Units
Ada makes the dynamic binding (dispatching) feature really easy to use in your object-oriented
programming design.   The following example shows a derivation class with a combined set of basepackages, child units, and client units.  Notice that the ba se type is an abstract type.   This means there can
be no instances of Machine, only of non-abstract derivations from Machine.   Abstract type Machine is thebase type of Machine'Class.
package Machinery is --  1
   type Machine is abstract  tagged private;    --  2       
   type Reference is access all Machine'Class; --  3
   type Machine_Set is --  4
             array (Positive range <>) of Reference; --  5
   procedure  Turn_On  (M : in out Machine) is abstract ; --  6
   procedure  Turn_Off (M : in out Machine) is abstract ; --  7
   function  Is_On (M : in Machine) return Boolean; --  8
private --  9
   type Machine is abstract  tagged record          -- 10
      Is_On : Boolean := False; -- 11
   end record; -- 12
end Machinery; -- 13
package Machinery.Rotating is --  1
   type Rotator_Type is new Machine with private; --  2
   type Rotator_Type _Reference is access --  3
                   Rotator_Type_Type'Class; --  4
   procedure  Turn_On  (R : in out Rotator_Type); --  5
   procedure  Turn_Off (R : in out Rotator_Type); --  6
   procedure  Set_RPM  (R : in out Rotator_Type; --  7
                       Speed : Natural); --  8
   function   RPM_Is   (R : in Rotator_Type) --  9
                            return Natural; -- 10
private -- 11
   type Rotator_Type is new Machine with record -- 12
      RPM : Natural := 0; -- 13
   end record; -- 14
end Machinery.Rotating; -- 15
with Machinery; --  1
package Oscillator is --  2
   type Oscillator_Type is --  3
         new Machinery.Machine with private; --  4
   type Reference is --  5
            access all Oscillator_Type'Class; --  6
   procedure  Turn_On  (OS : in out Oscillator_Type); --  7
   procedure  Turn_Off (OS : in out Oscillator_Type); --  8
   procedure  Set_Frequency(OS : in out Oscillator_Type; --  9
                           To : in Float); -- 10
   function   Frequency_Is(OS : Oscillator_Type) -- 11
                          return Float; -- 12
private -- 13
   type Oscillator_Type is new Machinery.Machine -- 14
       with record                       -- 15
         Frequency : Float := 0.0; -- 16
       end record; -- 17
end Oscillator; -- 18
with Ada.Text_IO; --  1 pre-defined library unit
with Ada.Integer_Text_IO; --  2 pre-defined library unit
use  Ada; --  3 parent of pre-defined library units
with Machinery.Rotating; --  4 context clause for library unit
with Oscillator; --  5 client unit
procedure  Test_Machinery is --  6
   package Rotating  renames Machinery.Rotating; --  7 shorter name with renames clause
   The_Machinery : Machinery.Machine_Set(1..2):=  --  8 array instance, constrainedThis package defines an abstrract
type (class root) along with twoabstract methods.   Note theimportant access type Reference thatcan access any type derived from theabstract type .
This is a child p ackage of Machinery.
It contains a derivation from theabstract type, Machine.  Note that dotnotation is unnecessary because thechild unit has direct visibility to thepublic part of the parent unit.
We inherit the Is_On function and
override the Turn_On and Turn_Offmethods.
This is a client p ackage of Machinery.
It contains a derivation from theabstract type, Machine.  Note that dotnotation is required because the clientunit has no direct visibility to the
public part of the parent unit.
We inherit the Is_On function and
override the Turn_On and Turn_Offmethods.  We also add another methodto set Frequency and one to get thecurrent value of  FrequencyFollowed by a child  library unit specification with an extended ty pe; direct visibility; dot notation unnecessary.
Followed by a client  library unit specification with an extende d type; no direct visibility; dot notation is necessary.
Followed by a client  procedure; client never has direct visibility; dot notation is necessary to achieve visibility.important
Ada Distilled   by Richard Riehle
Page 60 of 113      (1 => new Oscillator.Oscillator_Type, --  9 dynamic storage allocator
       2 => new Rotating.Rotator_Type); -- 10 dynamic storage allocator
   Input : Integer; -- 11 will be used as array index
begin -- 12
   loop -- 13
     Text_IO.Put("Enter either a 1 or a 2 "); -- 14 get the array index
     Integer_Text_IO.Get(Input); -- 15
     exit when Input not in 1..2; -- 16 Notice membership test here
     Machinery.Turn_On(The_Machinery(Input). all); -- 17 dynamic binding
   end loop ; -- 18
end Test_Machinery; -- 19                                      
This version of Test_Machinery demonstrates two kinds  of dynamic binding.  In one case the derived type,
Rotator_Type is declared in a child library unit.   In the other, the derived type is declared in a client unit.There are no visibility clauses in Test_Machinery for an y of the Machinery'Class types.   When we all
Machinery.Turn_On or Machinery.Tu rn_Off, on the abstract type, M achine, we dynamically call the
correct version of Turn_On or Turn_Off because of the tag of the actual parameter in the call.
We could easily extend this design with more client packages.   The dynamic dispatching model will
remain in operational regardless of how many library units are added.
Dispatching works because of the tag.  For each deri vation of a tagged type the compiler creates a dispatch
table on the primitive operations for that type.  The dispatch table is linked into the combined set of libraryunits so it is easily reachable from anywhere in the program.
The tag binds each object directly to its dispatch table.   Anytime a primitive operation is called, the tag
directs the call to the dispatch table which, in -turn, references the appropriate primitive operation.  Thisworks well when you have the objects heterogenuously stored in a list, array, or table.   This property iscalled object persistence.   Ada allo ws object persistence even in files.
9.4.3  Parameter Lists With Multiple Tagged Types
It is illegal to have a primitive operation with more than one definite tagged type in the parameter list.
However, a primitive operation may have one definite type and multiple classwide tagged types.  Thefollowing example demonstrates this.   First we have the package specification.
package Double_Tagged_Type is --  1
type T1 is tagged private ; --  2
   type T1_Reference is access all  T1'Class; --  3
   type T1_Class is array  (Positive range <>) of T1_Reference; --  4
   type T2 is new T1 with private ; --  5
   procedure  Process(D1 : in out T1; D2 : in out T1'Class); --  6
   procedure  Process(D2 : in out T2; D1 : in out T1'Class); --  7
   procedure  Process_All(D1 : in out T1'Class; D2 : in out T1'Class); --  8
private --  9
type T1 is tagged null record ; -- 10
   type T2 is new T1 with null record ; -- 11
end Double_Tagged_Type; -- 12
This package contains a root type at Line 2 and a de rivation at Line 5.  The two procedures named Process
are overloaded and disambigua ted because of the definite tagged type as a first parameter.  Both versions
of Process are primitive methods (and will dispatch) for the named definite types.  One of the types in each
parameter list must be classwide or this would not compile.   Next we look at the package body.
with Ada.Text_IO; --  1
use  Ada; --  2
package body  Double_Tagged_Type is --  3
   procedure  Process (D1 : in out T1; D2 : in out T1'Class) is--  4
   begin --  5
      Text_IO.Put("D1 is concrete T1 and D2 is classwide" ); --  6
   end Process; --  7primitive operation
must be primitivefor only one type;the other parametermay be classwide
Call this with one definitetype and another that isclasswide. It does notmatter which comes firstsince we have a primitivefor both versions.line 8 is not actuallynecessary;  it issimply here toillustrate a pointabout classwidemethods.
Ada Distilled   by Richard Riehle
Page 61 of 113   procedure  Process (D2 : in out T2; --  8 definite parameter
                D1 : in out T1'Class) is --  9 classwide parameter
   begin -- 10
      Text_IO.Put("D2 is concrete T1 and D1 is classwide" ); -- 11
   end Process; -- 12
   procedure  Process_All (D1 : in out T1'Class; -- 13 classwide parameter
                          D2 : in out T1'Class) is -- 14 classwide parameter
   begin -- 15
       Process(D1, D2); -- 16
   end Process_All; -- 17
end Double_Tagged_Type; -- 18
We could easily have designed this without the Pro cess_All procedure, but including it demonstrates the
power of a fully classwide subprogram. For example, it is often useful to have a function that returns aclasswide type.   In this package, we might  have wanted to create a function such as,
function  Get (From : T1_Class; Index : Integer) return T1'Class;
The Get function would be espcially useful if we had a lot of derivations from T1 and a large array of such
objects.   In the Double_Tagged_Type example, Get is  unnecessary.   Keep it in mind for future designs.
The following client of this package demonstrates how dynamic dispatching might take form.
with  Double_Tagged_Type; --  1 package defined above
with  Ada.Text_IO; --  2 package from Ada Annex A
with  Ada.Integer_Text_IO; --  3 Library instantiation
use  Ada; --  4 OK occurrence of visibility clause
procedure  Test_Double_Tagged_Type is --  5
   Data : Double_Tagged_Type.T1_Class (1..6) := --  6
           (1 => new Double_Tagged_Type.T1, --  7
            2 => new Double_Tagged_Type.T2, --  8
            3 => new Double_Tagged_Type.T1, --  9
            4 => new Double_Tagged_Type.T2, -- 10 dynamic allocation of instances
            5 => new Double_Tagged_Type.T1, -- 11
            6 => new Double_Tagged_Type.T2); -- 12
   Input_1, Input_2 : Integer := 0; -- 13 for indices into the array
begin -- 14
   loop -- 15
     Text_IO.Put("Enter First Integer Value:  "); -- 16 prompt for keyboard input
     Integer_Text_IO.Get(Input_1); -- 17 get index value for array
     exit when  Input_1 not in 1..6; -- 18 early loop exit
     Text_IO.New_Line; -- 19 carriage-return/line-feed
     Text_IO.Put("Enter First Integer Value:  "); -- 20 prompt for keyboard input
     Integer_Text_IO.Get(Input_2); -- 21 get index value for array
     exit when  Input_2 not in 1..6; -- 22
     Double_Tagged_Type.Process_All(Data(Input_1). all, -- 23
                                     Data(Input_2). all); -- 24
     Text_IO.New_Line; -- 25
   end loop ; -- 26
end Test_Double_Tagged_Type; -- 27
9.4.4 Dispatching on File Data
If you have your Ada Language Referen ce Manual handy, look for a package called
Ada.Streams.Stream_IO in Annex A.   This is a special input-output package that lets you store a taggedtype with its tag intact.  You can design Stream_IO files that are sequential or using some direct access
method.   Because the tag is stored in the file, each  object is virtually bound to its set of operations.  We
start with the following package of tagged types and their associated methods:
package Machinery_For_Streams is --  1 An Ada Module
   type Machine is abstract tagged private ;           --  2 Tagged  partial definitionarray of access objects;
dyanamically allocated ina ragged array
dynamic dispatching on methodProcess_All; this could avoid theProcess_All call and call Processdirectly;  this will alsodynamically dispatch.Primitive method thatincludes a classwideformal parameter.
Ada Distilled   by Richard Riehle
Page 62 of 113       type Reference is access all  Machine'Class;        --  3  Classwide access type
   type Machine_Set is array (Positive range <>) --  4 Array of access values
                  of Reference; --  5
   procedure  Turn_On  (M : in out Machine) --  6 Turn on the machine
   procedure  Turn_Off (M : in out Machine); --  7 Turn off the Machine
   function  Is_On  (M : Machine) return Boolean;      --  8 Is the Machine turned on?
   type Machine_1 is new Machine with private;        --  9
   function  Create(S : String := "Machn_1") return Machine_1; -- 10
   procedure  Turn_On  (M1 : in out Machine_1); -- 11 Turn on the machine_1
   procedure  Turn_Off (M1 : in out Machine_1);        -- 12 Turn off the Machine_1
   type Machine_2 is new Machine with private ;        -- 13
   function  Create(S : String := "Machn_2") return Machine_2; -- 14
   procedure  Turn_On  (M2 : in out Machine_2); -- 15 Turn on the machine_2
   procedure  Turn_Off (M2 : in out Machine_2);        -- 16 Turn off the Machine_2
   type Machine_3 is new Machine_1 with private ;      -- 17
   function  Create(S : String := "Machn_3") return Machine_3; -- 18
   procedure  Turn_On  (M3 : in out Machine_3); -- 19 Turn on the machine_3
   procedure  Turn_Off (M3 : in out Machine_3);        -- 20 Turn off the Machine_3
   type Machine_4 is new Machine_3 with private ;      -- 21
   function  Create(S : String := "Machn_4") return Machine_4; -- 22
   procedure  Turn_On  (M4 : in out Machine_4); -- 23 Turn on the machine_4
   procedure  Turn_Off (M4 : in out Machine_4);        -- 24 Turn off the Machine_4
   function  Get (From : Machine_Set)                  -- 25
                              return Machine'Class;   -- 26
private  -- 27 Begin private part  
   type Machine is tagged                              -- 28 Full tagged definition
     record                                           -- 29
       Identifier : String(1..7) := ( others => ' ');  -- 30 Machine content
       Is_On : Boolean := False;                      -- 31 Machine content;
     end record ;                                      -- 32 End of machine definition
   type Machine_1 is new Machine with null record ;    -- 33
   type Machine_2 is new Machine with null record ;    -- 34
   type Machine_3 is new Machine_1 with null record ;  -- 35
   type Machine_4 is new Machine_3 with null record ;  -- 36
end Machinery_For_Streams; -- 37 End of specification
Now we can create two procdedures using Stream_IO to  store the items of type Machine'Class in a file
along with their tags.    This permits the program to  dispatch automatically on each item as it is retrieved
from the file and called by the Turn_On operation.  The first procedure will output the data with its tag tothe Stream_IO file.
with Ada.Streams.Stream_Io; --  1 Stream_IO from Annex A
use  Ada.Streams; --  2
with Ada.Text_IO; --  3
use  Ada; --  4
with Machinery_For_Streams; --  5
procedure  Stream_Output_For_Machine is --  6
   The_File  : Stream_Io.File_Type; --  7
   Reference : Stream_Io.Stream_Access; --  8 Access value
   Data : Machinery_For_Streams.Machine_Set(1..9) --  9
        := (1 => new Machinery_For_Streams.Machine_1, -- 10 Dynamic allocation of instances
            2 => new Machinery_For_Streams.Machine_2, -- 11
            3 => new Machinery_For_Streams.Machine_3, -- 12
            4 => new Machinery_For_Streams.Machine_3, -- 13
            5 => new Machinery_For_Streams.Machine_2, -- 14
            6 => new Machinery_For_Streams.Machine_1, -- 15
            7 => new Machinery_For_Streams.Machine_4, -- 16
            8 => new Machinery_For_Streams.Machine_1, -- 17
            9 => new Machinery_For_Streams.Machine_4); -- 18 End of dynamic allocation
   File_Name    : String(1..80) := ( others => ' '); -- 19 External file name
   File_Name_Length : Natural; -- 20
begin -- 21
   Text_IO.Put("Enter File Name: "); -- 22
   Text_IO.Get_Line(File_Name, File_Name_Length); -- 23   Stream_Io.Create(File => The_File, -- 24                    Mode => Stream_IO.Out_File, -- 25                    Name => File_Name(1..File_Name_Length)); -- 26   Reference := Stream_Io.Stream(The_File); -- 27Allocate some data
in an array for thestream file .
Create a Stream_IO output file.
Ada Distilled   by Richard Riehle
Page 63 of 113   for I in Data'Range -- 28
         loop -- 29
           Machinery_For_Streams. -- 31
           Machine'Class'Output(Reference, Data(I). all); -- 32
   end loop ; -- 33
   Stream_Io.Close(The_File); -- 34
end Stream_Output_For_Machine; -- 35
The preceding procedure will put tagged data in the output  file.  The next procedure will retrieve the data
and call, polymorphically, the Turn_On method.
with Ada.Streams.Stream_Io; --  1
use  Ada.Streams; --  2
with Ada.Text_IO; --  3
use  Ada; --  4
with Machinery_For_Streams; --  5
procedure  Stream_Input_For_Machine is --  6
   The_File  : Stream_Io.File_Type; --  7
   Reference : Stream_Io.Stream_Access; --  8
   File_Name    : String(1..80) := ( others => ' '); --  9
   File_Name_Length : Natural; -- 10
begin -- 11
   Text_IO.Put("Enter File Name: "); -- 12
   Text_IO.Get_Line(File_Name, File_Name_Length); -- 13   Stream_Io.Open(File => The_File, -- 14                  Mode => Stream_IO.In_File, -- 15                  Name => File_Name(1..File_Name_Length)); -- 16
   Reference := Stream_Io.Stream(The_File); -- 17 Sequential Stream File
   while not Stream_Io.End_Of_File (The_File) -- 18
       loop -- 19
           declare -- 20
             Data : Machinery_For_Streams.Machine'Class -- 21 Data in a declare block
                    := Machinery_For_Streams. -- 22 so it can be dynamically
                       Machine'Class'Input(Reference); -- 23   initialized as classwide
           begin -- 24
               Machinery_For_Streams.Turn_On(Data); -- 25 Dispatching Call
           end; -- 26
       end loop ; -- 27
   Stream_Io.Close(The_File); -- 28
end Stream_Input_For_Machine; -- 29
This is a sequential Stream_IO file.   It would be  perfectly OK to create a random access file using some
kind of key processing algorithm such as a B-Tree.   In this case, you would be able to create a true object-oriented database system.  People have used Ada fo r object-oriented database applications successfully.
On Lines 21 through 23 we initialize the declaration Da ta when it is declared.   A tagged object must
always be initialized when it is declared.  Initialization may be static or dynamic.  In this example, theinitialization is dynamic.   This is analogous to an unc onstrained array such as a type String, where the size
of the object is not known until run-time.    The earlier example of a Get function also illustrates a
technique for dynanically constraining a tagged object declaration.Output data
from array to
stream file.
Get taggeddata from aStream file.
Ada Distilled   by Richard Riehle
Page  64 of 11310. Using Standard Libraries and Annexes
The Ada language standard is published in two parts:  Core language and Annexes .  The Annexes, labled
A through H,  include some standard libary units.   One library unit in Annex A, package Standard , is
always in scope and always visible.  Other libraries support special needs such as real-time system
development, platform-specific systems programming, di stributed systems, and safety and security.   Still
other units support input-output, string handling, and mathematical functions.
The most commonly used and misused library unit is package Standard, where a ll the predefined types
(Boolean, Integer, Float, Character and String) are declared.    Never use Standard numeric types for
production software.  Annexes A th rough K constitute some implementa tions of the language, but never
define new syntax or semantics.   Annex K defines th e equivalent of intrinsic functions, called Attributes in
Ada, that enable portability of algorithmic design.
10.1  Attributes for Portability (ALRM Annex K)
Attributes enhance your ability to create flexibile, portable, and easy to read code. Many attributes behavelike built-in functions.    The format for an attribute is a prefix of a  type or object name along followed by
an apostrophe, followed by the attribute itself.  Attributes may have parameters. The format is,
        Q'Attribute   
where there is no parameter for the attribute
          Q'Attribute(parameter) where there is a parameter for the attibute
In an expression, an attribute might be coded as,
X := Q'Attribute   where there is no parameter for the attribute
          X := Q'Attribute(parameter) where there is a parameter for the attibute
for X use Y'Attribute in a representation specification clause
along with other kinds of attri bute expressions such as conditi onal and declarative statements.
The prefix Q, shown above can be replaced by any of a number of Ada entities.   When the attributes are
defined in Annex K, they are shown with a prefix that indicates what kind of prefix is required.   Thepossibilities are summarized in the following table.
Examples of attributes are:
Integer'Last The last value in the set for predefined type Integer
Float'Last The last value for predefined type Float
T1'Callable Is task T1 still callable
Vector'Last Where Vector is an array, Last is largest index value
Vector'Length Where Vector is an array, Length is the length of the array
Byte'Size The number of bits in type Byte
X'Valid Is instance named X a valid re presentation of its own type?Legend for Attribute Prefixes
P Subprogram
X an object or varible name
S type or subtype identifier
E entry or exception
T task
R record       (component is R.C')
A arrayThe term, attribute, was used in Ada before it became a term in OOP.
It has a different meaning from that in  the OOP communiity.
The apostrophe is
pronounced, "tic."  Inthis example we wouldsay, Q tic Attribute
Ada Distilled   by Richard Riehle
Page 65 of 113Each attribute is rigorously define d for its associated entity.   As mentioned above, ma ny attibutes make
floating point operations more precise.   Other attri butes allow one to generalize an algorithm so it can be
used for any type in a given set of types.   Consider the following generic function, Next.
generic --  1
type Element is (<>); --  2
function  Next (Data : Element) return  Element; --  3
function  Next (Data : Element) return  Element is --  1
begin --  2
 if Data = Element'Last then --  3
return  Element'First; --  4
else --  5
return  Element'Succ(Data); --  6
end if; --  7
end Next; --  8
Notice how we are able to use attibutes in this  algorithm to generalize the code.  Element can be
instantiated with any discrete type.    This is a powerful feature of Ada.  It has been copied by otherlanguages, but never quite as well as originally designed in Ada.
10.1.1 Classification of Attributes
Some attributes are unique to specific types.  Others  are for machine/platform representation specifications.
Still others are specific to object-oriented programming.  The following charts organize some commonattributes according to typical usage.
The floating-point attributes are particularly useful for numerically intensive applications such as scientific,
engineering, and analytical programs.   In particular, note the presence of both Machine number and Modelnumber attributes.   These can be used to create highly portable numerical software.  Some of the aboveattributes also apply to fixed-point types.
The following attributes are available fo r any scalar type.   As a reminder,  scalar types include all integers,
enumeration types, floating-point types and fixed-point types.   Scalar does not include records, arrays,
access types, private types, task  types, or protected types.Generic formal discrete type parameter
Body of generic function; note the use
of  attributes 'Last,  'First, and 'Succt
o generaliz e the algorithm .
Floating Point Attributes  (where S is name of a floating point type )
S'Adjacent S'Fraction S'Machine_Radix S'Safe_First
S'Ceiling S'Leading_Part S'Model S'Safe_LastS'Compose S'Machine S'Model_Emin S'ScalingS'Copy_Sign S'Machine_Emax S'Model_Epsilon S'Signed_ZerosS'Denorm S'Machine_Emin S'Model_Mantissa S'Unbiased_RoundingS'Digits S'Machine_Mantissa S'Model_SmallS'Exponent S'Machine_Overflows S'RemainderS'Floor S'Machine_Radix S'Rounding
Scalar Type Attributes  (where S is name of a scalar type )
S'Base S'Pred S'Wide_Image
S'First S'Range S'Wide_ValueS'Image S'Succ S'Wide_WidthS'Last S'Valid S'WidthS'Max S'ValueS'Min
Ada Distilled   by Richard Riehle
Page 66 of 113Of special interest in this list are the attributes,  S'Base  and S'Valid .    The ' Base attribute encompasses the
range supported for every unconstrained object of the type.    It enables the designer to create functions thatensure there will be no constraint_error due to overflow of intermediate range overflow.    The Validattribute is used to test the result of an expression befo re using that result in another expression.  It is also
useful in avoiding exceptions when usi ng features such as unchecked_conversion.
Array attributes are among the most useful in developing portable Ada code.  The are especially good to
use in generic reusable components designed as unconstrained array types.
Actually, all the attributes in th e preceding box in which the class doe s not appear are used for Stream
operations.  We include them together because they are most often used in conjunction with an object-
oriented programming design.
The above attributes cover everything from tasks to ex ceptions.    As with other attributes, these can be
used to make a design more portable.  We have desc ribed the attributes declared in Annex K of the Ada
Language Reference Manual.  A compiler publisher is  permitted to add attri butes for their specific
compiler.  For example, the GNAT compiler has a special attribute, Unre stricted_Access, which
corresponds to Unchecked_Access for subprogram access objects.
10.2 String Examples
String handling is a simple idea that often becomes complicated in some programming environments.  Inparticular, C, C++, and COBOL have made string handling more difficult than it needs to be.  Ada isespecially handy for string manipulation.   Not only is an Ada string easy to declare and process, thepredefined libraries (in Annex A) support most of the operations one might want to do on strings.  Ada
supports three kinds of strings:  fixed strings, bounded strings, and unbounded strings.  One kind of string
may easily be converted into another kind of string.  Fixed strings are those defined in package Standard.
The following program illustrates several additional f eatures of the language.  Notice the syntax for
declaring a constant .  On line 3, if the string variable is declared with a range constraint, the initializing
string must have exactly the same number of characters.  On line 4, if there is no range constraint, the indexArray Type/Object Attributes  (where A is name of a array type or array object )
A'First A'Last(N) A'Range(N) A'Constrained
A'First(N) A'Range A'Length A'Component_SizeA'Last A'Length(N)
Other Attributes  (where prefix is as shown in the legend box at the beginning of this section )
P'Access X'Access S'Aft X'Alignment
S'Bit_Order P'Body_Version T'Callable E'CallerE'Count S'Definite S'Delta E'IdentityT'Identity R.C'First_Bit R.C'Last_Bit S'ModulusD'Partition_ID S'Pos R.C'Position S'ScaleS'Size X'Size S'Small S'Storage_PoolT'Terminated S'Val T'Storage_Size S'Storage_SizeP'Version X'Unchecked_AccessObject-Oriented Progamming Attributes  (Using legend from beginning of this section )
S'Class S'Class'Input S'Input S'Class'Output
S'Output S'Class'Read S'Read S'TagX'Tag S'Class'Write S'Write
Ada Distilled   by Richard Riehle
Page 67 of 113of the first character is 1 and the index of the last ch aracter is whatever the character count might be, in this
case 9.  Line 15 “slides” a string slice from one string into a slice in another string using the assignmentoperator and parenthetical notation to de signate the source and target slices.
with  Ada.Text_IO; --  1 Put Ada.Text_IO library unit in scope; 10.1.2, A.10
procedure   Bon_Jour  is --  2 Parameterless declaration; 6.3
Hello : String (1..5) := “Salut”; --  3 Number of characters must match range; 4.1, A.1/37
Howdy : String := “Howdy Joe”; --  4 Compiler determines constraint  from string; 2.6, 3.3.1/13
Bon_Jour : constant  String := “Bon Jour”; --  5 A true constant ;  cannot be altered; 3.3.1/5-6
begin --  6 Begins sequence of algorithmic statements; 6.3
Ada.Text_IO.Put(Hello); --  7 Put a string with no carriage return; A.10.6
Ada.Text_IO.Set_Col(20); --  8 On same line, position cursor at column 20; A.10.5
Ada.Text_IO.Put_Line(Hello); --  9 Put a string with a carriage return / line feed; A.10.7
Ada.Text_IO.Put(Howdy); -- 10 Put a string with no carriage return; A.10.7
Ada.Text_IO.Set_Col (20); -- 11 Set the cursor to column  20 / line feed; A.10.5
Ada.Text_IO.Put(Howdy); -- 12 Put a string with no carriage return / line feed; A.10. 7
Ada.Text_IO.New_Line(2); -- 13 Position cursor to a new line;  double space; A.10.5
Ada.Text_IO.Put_Line(Bon_Jour); -- 14 Put a constant  to the screen with CR/LF; A.10.7
Howdy(7..9) := Bon_Jour(1..3); -- 15 Slide (assign) one string slice into another; 4.1.2
Ada.Text_IO.Put_Line (Howdy); -- 16 Put the modified string with CR/LF; A.10.7
end Bon_Jour; -- 17 Note the label for the enclosing procedure; 6.3
There are better alternatives for String handling in a set of packages in Annex A.4  Here is a simple
example of one of the packages.   This is easier than string slicing and other low-level code.
10.2.1 Using the Fixed Strings Package
with  Ada.Text_IO; --  1 Put Ada.Text_IO library unit in scope; 10.1.2, A.10
with Ada.Strings.Fixed; --  2 A language defined string package A.4.1, A.4.3
use  Ada; --  3 Makes all of package Ada visible
procedure   Ni_Hao_Ma  is --  4 Hello in Mandarin Chinese 6.3
Greeting : String(1..80); --  5 80 character string;  String defined  in package Standard   ALRM A.1
Farewell : String(1..120); --  6 120 character string
begin --  7 Start sequence of statements
Ada.Strings.Fixed.Move(Greeting, Farewell); --  8 Move shorter string to longer string; may also move longer to shorter
end Ni_Hao_Ma; --  9 End of procedure scope .
10.2.2 Bounded Strings
It is also possible to do operations on Bounded a nd Unbounded_Strings.   Bounded strings are those with
a fixed size at compilation time through a generic instantiation.
10.2.3 Unbounded Strings
Unbounded strings are those which can be of any size,  mixed size, etc.    Many compilers will do
automatic garbage collection of unbounded strings. If you want to try these two features of the language,they are defined in Annex A.4 of the Ada Language Reference Manual.
Consider the following program that lets you concatenate data to an unbounded string,  convert that string
to a standard fixed string, and then print it out to the screen.
This is useful when you  have a n eed for an input buffer of unknown size.
with  Ada.Strings.Unbounded; --  1
with  Ada.Text_IO; --  2
use  Ada; use Strings; --  3
procedure  Unbounded_String_Demonstration is --  4
   Input  : Character := ' '; --  5 Element of the buffer
   Output : String (1..80) := ( others  => ' '); --  6 Fixed length output stringUnbounded strings are usually
implemented with automaticgarbage collection.  This savesstorage but any  kind ofautomatic garbage collection istime non-determinate.ALRM A.4.4.4       package Ada.Strings.BoundedALRM A.4.4.4       package Ada.Strings.Fixed
ALRM A.4.4.4       package Ada.Strings.UnBoundedAda Language Reference Manual
Ada Distilled   by Richard Riehle
Page 68 of 113   Buffer : Unbounded.Unbounded_String; --  7 An unbounded buffer of input
   Length : Natural; --  8 Size of the buffer
begin --  9
   loop -- 10
     Text_IO.Put("Enter a character: "); -- 11     Text_IO.Get(Input); -- 12 
Get the character
     exit when  Input = '~'; -- 13 Exit when tilde is entered
     Unbounded.Append(Source => Buffer, New_Item => Input); -- 14 Add the character to the buffer
   end loop ; -- 15
   Length := Unbounded.Length(Buffer); -- 16 How big is the buffer?
   Output(1..Length) := Unbounded.To_String(Buffer); -- 17 Copy the buffer to a String
   Text_IO.Put_Line(Output(1..Length)); -- 18 Output the entire string
end Unbounded_String_Demonstration; -- 19
10.2.4 Other String Operations
There are many other facilities for string handling in Ada.   We show here an example from another useful
library, package Ada.Characters.   Here is a little package that converts lower case letters to upper case.
with  Ada.Text_IO; --  1 Put Ada.Text_IO library unit in scope; 10.1.2, A.10
with Ada.Characters.Handling; --  2 Character Handling Operations A.3.2
use  Ada; --  3 Makes package Ada visible
procedure   Arirang  is --  4 Famous Korean love song 6.3
   Data : String := "arirang"; --  5  initialized lower case character string
begin --  6 Start sequence of statements
   Text_IO.Put(Characters.Handling.To_Upper(Data)); --  7 Convert output to upper case characters and print it
end Arirang; --  8 End of procedure scope.
10.3 Converting Strings to Other Types
Sometimes it is necessary to represent a string value in  some other format.  Other times we need to convert
some other type to a string representation.    One could easily write a small generic subprogram toaccomplish this.   Also, Ada provides an unchecked conversion capability.  Unchecked features are seldom
used since they circumvent the fundamental philosophy  of Ada:  every construct should be, by default,
safe.
10.3.1  Converting a String to an Scalar Type
The following procedure demonstrates many  of the features of the language for converting a string to an integer, a
string to a floating point, a string to an unsigne d number, and a string to an enumerated value .
with Ada.Text_IO; --  1
with Ada.Integer_Text_IO; --  2
with Ada.Float_Text_IO; --  3
use  Ada;  -- It is generally OK to use a visibility clause for package Ada --  4
procedure  String_To_Scalar_Demonstration is --  5
  type Spectrum is (Red, Orange, Yellow, Green, Blue, Indigo, Violet); --  6
  type Unsigned is mod 2**8; -- Reminder :  mod  defines an unsigned integer type  --  7
  Num   : Integer  := 0; --  8
  FNum  : Float    := 0.0; --  9
  Color : Spectrum := Blue; -- 10  MNum  : Unsigned := 0; -- 11
  Text  : String(1..10); -- 12
  Text_Integer  : String := "451"; -- 13  Text_Float    : String := "360.0"; -- 14  Text_Color    : String := "Orange"; -- 15  Text_Unsigned : String := "42"; -- 16  Integer_Last  : Natural; -- 17
  Float_Last    : Natural; -- 18
  Spectrum_Last : Natural; -- 19
  Modular_Last  : Natural; -- 20
  package SIO is new Text_IO.Enumeration_IO(Enum => Spectrum); -- 21
Instantiate IO
packages for eachdata type that needsconversion to or froma string.Note the man y variations possible
Good use of named
association
Ada Distilled   by Richard Riehle
Page 69 of 113  package MIO is new Text_IO.Modular_IO    (Num  => Unsigned); -- 22
  package IIO is new Text_IO.Integer_IO    (Num  => Integer); -- 23
  package FIO is new Text_IO.Float_IO      (Num  => Float); -- 24
begin -- 25
  Text_IO.Put_Line("The String Values are: "); -- 26
  Text_IO.Put("Orange for Enumerated Type          "); -- 27  Text_IO.Put_Line("451  for Integer Type  "); -- 28  Text_IO.Put("360.0  for Float Type               "); -- 29  Text_IO.Put_Line("42  for Unsigned Type  "); -- 30  Text_IO.New_Line; -- 31
  -- Example 1; using the Value attribute -- 32
  Text_IO.New_Line; -- 33
  Text_IO.Put_Line(" >>> Example 1; Using 'Value Attribute <<< "); -- 34  Color := Spectrum'Value(Text_Color); -- 35
  Num   := Integer'Value(Text_Integer); -- See Annex K for meaning of  'Value -- 36
  FNum  := Float'Value(Text_Float); -- 37  MNum  := Unsigned'Value(Text_Unsigned); -- 38
  SIO.Put(Color);   Text_IO.New_Line; -- I/O for Spectrum data type -- 39
  IIO.Put(Num);     Text_IO.New_Line; -- I/O for Integer data type -- 40
  FIO.Put(Fnum);    Text_IO.New_Line; -- I/O for Float data type -- 41
  MIO.Put(MNum);    Text_IO.New_Line; -- I/O for Modular data type -- 42
  Text_IO.New_Line; -- 43
  -- Example 2; using the procedures of pre-instantiated packages -- 44
  Text_IO.Put_Line(" >>>> Example 2; using pre-instantiated packages << " ); -- 45  Integer_Text_IO.Get(From => Text_Integer, Item => Num,Last => Integer_Last); -- 46  Float_Text_IO.Get(From => Text_Float, Item => FNum,Last => Float_Last); -- 47  Integer_Text_IO.Put(Num); Text_IO.New_Line; -- 48  Float_Text_IO.Put  (FNum, Fore => 3, Aft => 3, Exp => 0);  -- 49  Text_IO.New_Line(2); -- 50
  -- Example 3; using your own instantiated packages -- 51
  Text_IO.Put_Line("   >>>> Example 3; Using own instantiations <<<< "); -- 52  Text_IO.New_Line; -- 53
  SIO.Get(From => Text_Color, Item => Color, Last => Spectrum_Last);   -- 54  MIO.Get(From => Text_Unsigned, Item => MNum, Last => Modular_Last); -- 55  IIO.Get(From => Text_Integer, Item => Num, Last => Integer_Last);     -- 56  FIO.Get(From => Text_Float, Item => FNum, Last => Float_Last); -- 57
  -- Now Write the Results to the Screen -- 58
  SIO.Put(Item => Color);  Text_IO.New_Line; -- 59  IIO.Put(Item => Num);    Text_IO.New_Line; -- 60  FIO.Put(Item => FNum, Fore => 3, Aft => 3, Exp => 0); -- 61  Text_IO.New_Line; -- 62
  MIO.Put(Item => MNum);   -- 63  Text_IO.New_Line(2); -- 64
  Text_IO.Put_Line(" **** End of String_To_Scalar_Demonstration **** "); -- 65
end String_To_Scalar_Demonstration; -- 66
10.3.2 Converting a Scalar to a String
This program is the opposite of the one in 10.2.2, above.    We can convert almost any kind of scalar value
to a string.    The package, Ada.Text_IO contains ne sted generic packages that make it easy to convert any
kind of number to a string.   The programmer may also use the X'Image attribute (See ALRM Annex K)from an internal (machine base d) representation to a string.
with  Ada.Text_IO, Ada.Integer_Text_IO, Ada.Float_Text_IO; --  1
use  Ada; --  2 May safely use Ada
procedure  Scalar_To_String_Demonstration  is --  3 Convert a string to a scalar object
  type Spectrum  is (Red, Orange, Yellow, Green, Blue, Indigo, Violet); --  4 Enumerated type
  type Unsigned  is mod  2**8; --  5 Unsigned modular type
  Num   : Integer  := 451; --  6 Combustion point of paper in farenheit
  FNum  : Float    := 360.0; --  7 Don't go off on a tangent
  Color : Spectrum := Blue; --  8 Hmmmm.  "You don't look bluish."
  MNum  : Unsigned := 42; --  9 Life, the Universe, and Everything
  Text  : String(1..10); -- 10
  package  SIO is new  Text_IO.Enumeration_IO(Enum => Spectrum); -- 11 Instantiate IO for enumerated type
  package  MIO  is new  Text_IO.Modular_IO    (Num  => Unsigned); -- 12 Instantiate IO for modular type
  package  IIO is new  Text_IO.Integer_IO        (Num  => Integer); -- 13 Instantiate IO for predefined Integer
  package  FIO is new  Text_IO.Float_IO          (Num  => Float); -- 14 Instantiate IO for predefined Float
begin -- 15
  Text_IO.Put_Line(" Example 1; Using 'Image Attribute "); -- 17 Example 1; using the image attributeNote the man y variations possiblePreamble stuff so reader can
see how the programcorresponds to reality
Named association
Named association
Ada Distilled   by Richard Riehle
Page 70 of 113  Text_IO.Put_Line(Spectrum'Image(Color)); -- 18
  Text_IO.Put_Line(Unsigned'Image(MNum)); -- 19  Text_IO.Put_Line(Integer'Image(Num)); -- 20  Text_IO.Put_Line(Float'Image(FNum)); -- 21  Text_IO.New_Line; -- 22  Text_IO.Put_Line(" Example 2; using pre-instantiated packages " ); -- 24  Example 2; pre-instantiated packages
  Integer_Text_IO.Put(Num); Text_IO.New_Line; -- 25  Float_Text_IO.Put  (FNum, Fore => 3, Aft => 3, Exp => 0);  -- 26  Named association for parameters
  Text_IO.New_Line(2); -- 27  Example 3; own  instantiated packages
  Text_IO.Put_Line(" Example 3; Using own  instantiations  "); -- 29
  SIO.Put(Color);   Text_IO.New_Line; -- 30 Two statements on single line
  MIO.Put(MNum);    Text_IO.New_Line; -- 31  IIO.Put(Num);     Text_IO.New_Line; -- 32  FIO.Put(FNum, Fore => 3, Aft => 3, Exp => 0);    -- 33 Named association for parameters
  Text_IO.New_Line(2); -- 34         -- Example 4; convert to text and then print -- 35
  Text_IO.Put_Line("Example 4; Convert to text,  then print "); -- 36
  SIO.Put(To => Text, Item => Color); -- 37 Named association for parameters
  Text_IO.Put_Line(Text); -- 38  MIO.Put(To => Text, Item => MNum); -- 39  Text_IO.Put_Line(Text); -- 40  IIO.Put(To => Text, Item => Num); -- 41  Text_IO.Put_Line(Text); -- 42  FIO.Put(To => Text, Item => FNum, Aft => 3, Exp => 0); -- 43  Text_IO.Put_Line(Text); -- 44  Text_IO.New_Line; -- 45  Text_IO.Put_Line("End of Image_Demonstration "); -- 46
end Scalar_To_String_Demonstration; -- 47
10.4 Wide Strings
Both Ada and Java are designed to support internationa l (Unicode) character sets.  Ada calls this wide-
strings.   We will add some examples of wide string processing in a future edition of Ada Distilled.Output using the 'Image attributes from
Annex K.  Leading space for positivevalues.  Leading sign for negative values.
Convert each value to a Stringand then print it.  This is built-into Ada.Text_IO.  Don't writeyour own version of this.
Ada Distilled   by Richard Riehle
Page 71 of 113Reminder:
Every Ada program
body can be viewedin  terms of the Adacomb even if onetooth of the comb isnot shown.11.  Exception Management
Ada 83 was one of the first languages to include ex ception management.  Nearly all modern programming
languages now have this feature.     Exceptions are an essential feature of typed-languages that supportencapsulation.   Think of an exception  handler as a ki nd of software circuit-break er.  Just a real circuit-
breaker prevents your house from catching fire, the software circuit-breaker can prevent your program
from aborting at uncontrollable points during execution.
Ada 95 has four predefined exceptions and allows th e programmer to declare ex ceptions specific to the
problem being solved.  Pred efined exceptions from packag e Standard (Annex A.1) are:
Constraint_Error,  Storage_Error,  Program_Error,  Tasking_Error
Input/output errors in package IO_Exceptions (Annex A.13) are,
Status_Error, Mode_Error, Nam e_Error, Use_Error, Device_Error,
End_Error, Data_Error, Layout_Error
Other Annex packages define other kinds of excepti ons.  Exceptions appear in  library packages from
various software repositories, including the many fr eeware packages availabl e from Internet sources.
11.1 Handling an Exception  (ALRM 11.4)
An exception handler must appear in a begin ...end sequence.  Therfore it might appear as,
function   Ohm (Volt, Amp : Float) return  Float  is --  1 Parameterized function declaration ; 6.3
Result : Float := 0.0; --  2 Initialized local variable
begin --  3 Begins algorithmic statements;  6.3
Result := Volt / Amp; --  4 Simple division; cannot divide by zero
    return Result; --  5
exception --  6 If we try to divide by zero, land here .
when  Constraint_Error => --  7 Raised on divide-by-zero; handle it here .
Text_IO.Put_Line(“Divide by Zero”); --  8 Display the error  on the console
raise ; --  9 Re-raises the exception after handling it .
end Ohm; -- 10 Scope terminator with name of unit 6.3
It is better not to return an invalid value from a function so it is useful to raise an exception. Sometimes
you want a begin  ... exception  ... end sequence in-line in other code.  To call the function Ohm from a
procedure, we would want another exception handler.  Since the handler re-raised the same exception (on
line 8), we need another handler in the calling subprogram.
with Ada.Exceptions;  with   Ohm; --   1 Chapter 11.4.1 ALRM; also, see the end of this chapter
with Ada.Text_IO;      use    Ada; --   2 OK for use clause on package Ada
procedure   Electric (Amp, Volt : in Float; --   3 In mode parameters
                                  Resistance : out Float)  is --   4  Out mode parameter; 6.3
function  MSG (X :.Exceptions.Exception_Occurrence) --   5 Profile for Exception_Message function
return  String --   6 Return type for Exception_Message
renames  Exceptions.Exception_Message; --   7 Rename it to three character  function name
begin --   8 Begins sequence of algorithmic statements; 6.3
Resistance := Ohm(Amp => Amp, Volt => Volt); --   9 Simple division operation;  cannot divide by zero
exception -- 10 If we try to divide by zero, land here .
when  Electric_Error: -- 11 data type is  Ada.Exceptions.Exception_Occurrence
                           Constraint_Error => -- 12 This error is raised on divide-by-zero; handle it here .
Text_IO.Put_Line(MSG(Electric_Error)); -- 13 See lines 5-7;  renamed Exception_Message function
Exceptions.Reraise_Occurre nce(Electric_Error); -- 14 Procedure for re-raising the exception by occurrence name
end Electric; -- 15 Scope terminator with name of unit 6.3
Ada Distilled   by Richard Riehle
Page 72 of 11311.2 Declaring your Own Exceptions
Ada allows user-defined exceptions.  These can  be declared and raised by the designer.
with Ada.Exceptions; use Ada; --   1 Chapter 11.4.1 ALRM
package   Exception_Manager  is --   2 A typical exception/error management package
Overflow            : exception ; --   3 Own named exception;  User-defined exception
Underflow          : exception ; --   4 Ada exception is not a first class object
Divide_By_Zero : exception ; --   5 This could be handy for some applications
type Exception_Store is tagged limited private ; --   6 A place to store exception occurrences
type Reference is access all  Exception_Store’Class; --   7 In case you need to reference this in another way
procedure  Save ... --   8 Saves an exception to Exception_Store
 procedure  Log ... --   9 Logs an exception
procedure  Display ... -- 10 Displays and exception
private -- 11 Useful to have more operations before this
type Exception_Set  is array  (1..100) -- 12 Array of access values to Exception_Occurrence
of  Exceptions.Excepti on_Occurrence_Access; -- 13 Exception_Occurrence_Access is an access type
type Exception_Store is tagged -- 14 A record containing an array of exceptions
record -- 15
Current_Exception : Natural := 0; -- 16 And index over the Exception_Set
Exception_Set; -- 17 Instance of type from Lines 12-13
end record ; -- 18
end Exception_Manager; -- 19 Package scope terminator
with Exception_Manager; --  1 Put Exception_Manager package in scope
package  Application_With_Exception is --  2
type Application_Type is private ; --  3 Private here is partial definition of type
procedure  Start       (Data : in out  Application_Type); --  4 Create and initialize the application
procedure  Restart   (Data : in out  Application_Type); --  5 If there is an exception, you may need to restart
procedure  Stop       (Data : in out  Application_Type); --  6 Stop the application; may be able to restart
procedure  Cleanup (Data : in out  Application_Type); --  7 When there is an error, call this procedure
procedure  Finalization (Data : in out  Application_Type); --  8 Not be confused with Ada.Finalization
Application_Exception :  exception; --  9 Your locally defined exception for this package
private -- 10  Nothing is public from here forward
   type Application_Type is ... -- requires full definition of type -- 11 Full definition of the private type
end Application_With_Exception; -- 12 End of the specification unit. Needs a body .
In the Application_With_Exception package, any one of the subprograms defined might raise an
Application_Exception or some other kind of exception.   Since we have not used any of the resources of
Exception_Manager, it would be better to defer its context clause (put it in scope) in the package body.
with Exception_Manager; --  1  Localize the context clause to package body
package  body  Application_With_Exception is --  2
         -- Implementation code for the package body --  3
end Application_With_Exception; --  4
11.3 Raising Exceptions
Exceptions should indicate a strange event that cannot be handled with the usual coding conventions.  Ada
95 includes an attribute, X'Valid, to help the devel oper avoid exceptions on scalar types.  Consider this
program that uses X'Valid.
First an exception should be visible for the user.
procedure  Test_The_Valid_Attribute is --   1
   type Real is digits  7; --   2
   type Number is range  0..32_767; --   3
   type Compound is --   4
     record --   5
                   Weight : Real := 42.0; --   6                     Height : Number; --   7Scalar types declared within the record
definition.  X'Valid will not work on arecord but can be used on scalarcomponents.Given:  the following visible declaration:
     Compound_Data_Error : exception ;ellipses are not part of Ada
Ada Distilled   by Richard Riehle
Page 73 of 113                    Width  : Number; --   8
     end record ;  --   9
   Data : Compound := (80.0, 64, 97);  --  10 Record initilialized with aggregate
begin --  11
  if Data.Weight'Valid then --  12 Test the Weight to see if it is valid
      null; --  13 Usually some sequence of statements
   elsif Data.Height'Valid then --  14 Test the Height to see if it is valid
null; --  15 Usually some sequence of statements
   elsif Data.Width'Valid then --  16 Test the Widht to see if it is valid
null; --  17 Usually some sequence of statements
   else --  18 An else part is usually a good idea
      raise  Compound_Data_Error; --  19 Failed all around; raise an exception
   end if; --  20
end Test_The_Valid_Attribute; --  21
Not all Ada designers agree with the above example.    It is your responsibility to decide whether this
appropriate in designing your software.   The importa nt consideration is that you may define and raise
exceptions when you determine they are necessary.  Object-oriented programming has a strong bias towardencapsulation.   When encapsulation is strong, an exception may be the appropriate technique to notify aclient that something has gone wrong within the software object they are using.
11.4 Package Ada.Exceptions
The following language-defined can be useful for some kinds of applications.
package  Ada.Exceptions is      -- This is an Ada language defined package --  1 ALRM 11.4.1
type Exception_Id is private ; --  2 predefined assignment
Null_Id : constant  Exception_Id; --  3 this is called a deferred constant
function  Exception_Name(Id : Exception_Id) return  String; --  4 Associate a string with an exception
type Exception_Occurrence is limited private ; --  5 no assignment operation
type Exception_Occurrence_Access is access all  Exception_Occurrence; --  6 useful for a limited private type
Null_Occurrence : constant  Exception_Occurrence; --  7 Deferred constant; no assignment
procedure  Raise_Exception(E : in Exception_Id; Message : in String := ""); --  8 Exception_ID from line 2
function  Exception_Message(X : Exception_Occurrence) return  String; --  9 String value of exception message
procedure  Reraise_Occurrence(X : in Exception_Occurrence); -- 10 After handling, raise it again
function  Exception_Identity(X : Exception_Occurrence) return  Exception_Id; -- 11 Exception_ID from line 2
function  Exception_Name(X : Exception_Occurrence) return  String; -- 12 String value of Exception_Occurrence
-- Same as Exception_Name(Exception_Identity(X)). -- 13
function  Exception_Information(X : Exception_Occurrence) return  String; -- 14 Some compilers give lots of info here
procedure  Save_Occurrence(Target : out Exception_Occurrence; -- 15 A lot like a copy or assignment
                          Source : in Exception_Occurrence); -- 16
function  Save_Occurrence(Source : Exception_Occurrence) -- 17 Create an access object
                         return  Exception_Occurrence_Access; -- 18
private -- 19
... -- not specified by the language -- 20
end Ada.Exceptions; -- 21
One can design with this package so objects of type Exception_Occurren ce are stored in a volatile data
structure (list, array, etc) and held for later processing.  Any exception can be converted into a text formatand stored as text in a log file.   This feature is useful for non-stop systems that require handling exceptionsbut cannot stop executing for each pr ocessing anomaly.  Even though standard Ada exceptions are not
first-class objects, the availa bility of Exception_ID and Excepti on_Occurrence gives the designer an
opportunity to promote them to first-class objects.    This enables the efficiency associated with ordinaryAda exceptions with the less efficient option of designing them as objects.Ada 95 only
Ada Distilled   by Richard Riehle
Page 74 of 11312. Generic Components
12.1 Generic Subprograms
In Ada, an algorithm or object can be designed as ty pe-independent, and can be put in the library as a
generic reusable component.  There are huge libraries  of generic Ada components already in place such as
the Public Ada Library.  Here are examples of simple generic subprograms.  The first example is ageneralization of the Next function shown earlier.  Firs t we are required to define the generic specification.
generic -- 1 Reserved word for defining templates
type Item  is (<>);  -- Any discrete type -- 2 Generic formal Parameter   (GFP )
function  Next (Value :  Item ) return  Item; -- 3 Specification for generic subprogram
We would not be allowed to code a generic specification with an is such as,
generic -- 1 As in line 1, above
type Item  is (<>); -- 2 As in line 2, above
function  Next (Value :  Item ) return  Item is -- 3 Illegal; Specification required
          ... -- 4 body of function
end Next; -- 5 before implementation
because any generic subprogram must be first specifi ed as a specification.  The specification may actually
be compiled or may be declared in the specification of a package.
Then we code the actual algorithm.  Notice that the algorithm does not ch ange at all for the earlier version
of function Next, even though we may now use it for any discrete data type.
function  Next (Value : Item) return   Item  is -- 1 Item is a generic formal parameter
begin -- 2 No local declarations for this function
if Item’Succ(Value) = Item’Last then -- 3 A good use of attribute; see ALRM K/104
return  Item’First; -- 4 ALRM 6.3
else -- 5 ALRM 5.3
return  Item’Succ(Value); -- 6 Note two returns;  may not be good idea
end if ; -- 7 ALRM 5.3
end Next; -- 8 Always include the function identifier
This function can be instantiated for any discrete data type.  Given the following types, write a few little
procedures to cycle through the types,
type Month is (January, Februrary, March, April, May, June, Ju ly, August, September, October, November, December);
type Color is (Red, Orange, Yellow, Green, Blue, Indigo, Violet) ;   -- our friend, Roy G.  Biv.
type Day is (Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday);
type Priority is (Very_Low, Low, Sorta_Medium, Medium, Getti ng_Higher,  High, Very_High, The_Very_Top);
The next generic subprogram is th e famous, but simple Swap proce dure.  Recall that every non-limited
type including a private type has the predefined operators, =, /=, and operation := (assignment).  Therefore,we can instantiate the Swap procedure with any non-limite d type in Ada.   That is, a private generic formal
parameter, as defined on line 2 below,  can be associated with any non-limited type
generic -- 1 Start the generic formal parameters
type Element (<>)  is private ; -- 2 Unconstrained generic parameter
procedure  Swap (Left, Right :  in  out  Element) ; -- 3 Usually compiled separately
First we code the the specification then the actual implementation.  Notice the algorithm in the
implementation works for any non-limited data type.Illegal
Ada Distilled   by Richard Riehle
Page 75 of 113procedure  Swap (Left, Right :  in  out  Element)  is -- 1 Compile separately in its own body file
Temp : Element := Left; -- 2 Must be constrained in declaration
begin -- 3
Left := Right; -- 4 First part of exchange
Right := Temp; -- 5 Second part of exchange
end Swap; -- 6
An algorithm does not get much easier than the Swap procedure.  What should be clear from seeing
generic Swap is that you can use this technique to generalize hundreds of other algorithms on your ownprojects.  You can also use this technique to easily share algorithmic code with your colleagues.
Sometimes it is useful to collect generic subprogram specifications some common properties in one
package. For example, usi ng those already described,
package  Utilities is -- A handy package at the project-specific level
generic
type Item is private ; -- A constrained generic formal parameter
procedure  Swap(L, R : in out  Item);
generic
type Item is (<>); -- A discrete type generic formal parameter
function  Next (Data : Item) return  Item;
generic
type Item is (<>); -- A discrete type generic formal parameter
function  Prev (Data : Item) return  Item;
-- more generic subprograms as appropriate  to your particular project needs
end Utilities;
The Utilities package can be used to collect common generic algorithms. This set of small reusable
components is useful for creating larger components;  i.e., build new generics from existing generics.
12.2 Other Generic Formal Parameters
A generic formal type parameter is possible for any type; e.g.,  access type s, derived types, array types, and
even limited types.  For limited types, the designe r must include a corresponding set of generic formal
operations.  Even for other types, generic formal opera tions are often useful.  Consider this private type.
generic -- Start the generic formal parameters
type Item is private ;  -- Predefined assignment and equality --  Generic formal type parameter
with function ">" (L, R : Item )  return Boolean ; --  Generic formal ">" operator
with function "<" (L, R : Item)  return Boolean; -- Generic formal "<" operator
package  Doubly_Linked_Ring_1  is -- Generic reusable data structure
-- Specification of a Doubly_Li nked_Ring data strructure --
end Doubly_Linked_Ring_1; --
In the example for the Doubly_Linked_Ring_1, we know that implementation requires some operations
beyond simple test for  equality.   The only operator predefined for a private type is test for equality.
Consequently, we may include parameters for other ope rators.  These "own code" operators are instantiated
by the client of the package.  Before looking at the instantiation of this example, study the followingexample that is preferred by many designers of resuable generic data structure components.
generic --  1 start a generic package specification
type Item is private ; --  2 Predefined assignment and equality
type Item_Reference  is access all Item; --  3 general access type formal parameter
with function Is_Equal (L, R : Item )  return Boolean; --  4 formal parameter for own code "="
with function Is_Less_Than  (L, R : Item)  return Boolean; --  5 formal parameter for own code "<"
with function Is_Greater_Than  (L, R : Item)  return Boolean; --  6 formal paramter for own code ">"
package  Doubly_Linked_Ring_2  is --  7 Generic reusable data structure
type Ring  is limited private ; --  8 limited private type for containerMany Ada designers
prefer to use function
names instead of
function operators for
generic formal
subprogram
parameters.Tip:
You can createthis kind ofutility packagefor algorithmsunique to yourteam's project.
Ada Distilled   by Richard Riehle
Page 76 of 113-- Specification of a Doubly_Li nked_Ring data strructure --  9 more operations on limited type
end Doubly_Linked_Ring_2; -- 10 end of package specification
Although test for equality is predefined for a private type,  the test is on the binary value of the data not on
its selected components.  If the actual parameter is a r ecord or constrained array,  a pure binary comparison
may not give the intended result.  Instead, by associ ating a generic actual operation with a generic formal
operation, the client of the generi c package can ensure th e structure behaves according to a given record
key definition.   Also, by  including an access type for the generic fo rmal private type,  the client may have
lists of lists, trees of queues, lists of rings, etc.   This example instantiates the Doubly_Linked_Ring_2.
with  Doubly_Linked_Ring_2 ;
procedure  Test_Doubly_Linked_Ring_2 is
type Stock is record
Stock_Key :  Positive;Description : String (1..20);
end record;
type Stock_Reference is access all  Stock;
function  Is_Equal (L, R : Stock) return Boolean is
begin
return  L.Key = R.Key;
end Is_Equal;
function  ">" ...   -- 
Overload ">"   Implement using the sa me rules as in function Is_Equal, above
function  "<" ...
package  Stockkeeper  is new  Doubly_Linked_Ring_2( Item => Stock,
 Item_Reference => Stock_Reference, Is_Equal => Is_Equal, Is_Less_Than => "<", Is_Greater_Than => ">");
The Ring : Stockkeeper.Ring;The_Data  : Stock;
begin
-- Insert and remove stuff from the Ring
end Test_Doubly_Linked_Ring_2;
Sometimes it is convenient to combine a set of generic formal parameters into a signature package.   A
signature package can be reused over and over to  instantiate many different kinds of other generic
packages.   A signature package will often have nothing in it except the generic parameters.   It must beinstantiated before it can be used.   This is an advanced topic.  Here is one small oversimplified example,derived and extended into a fully coded program ,  adapted  from the Ada 95 Language Rationale.
package  Mapping_Example is -- Begin the enclosing package specification --  1
   generic --  2
      type Mapping_Type is private ; --  3
      type Key is limited private ; --  4
      type Value is limited private ; --  5
      with  procedure  Add       (M : in out  Mapping_Type; K : in Key; V : in Value); --  6
      with  procedure  Remove (M : in out  Mapping_Type; K : in Key; V : in Value); --  7
      with  procedure  Apply    (M : in out  Mapping_Type; K : in Key; V : in Value); --  8
  package  Mapping is end  Mapping; --  9 Signature package
       -- Now declare the specification for the ge neric procedure in the same package --  9.1
  generic  -- 10
          with  package  Mapping_Operations is new  Mapping (<>); -- 11 See line 9, above
          use Mapping_Operations; -- 12 Use clause OK here
             -- This is a generic formal package paramet er instead of a generic formal subprogram -- 13
   procedure  Do_Something(M : in out  Mapping_Type; K : in Key; V : in Value); -- 14 Generic procedure
      end  Mapping_Example; -- End of the enclosing package specification -- 15Note the generic
formal parametersfor the signaturepackage, Mapping.The packagecontains no otheroperations. This islegal and handyThe Key is only one field of the record .
Compare only the record Key, not the whole record .
Notice the use of
named association;good for readabilityand documentation
Ada Distilled   by Richard Riehle
Page 77 of 113Lines 2 through 9 define the generic formal signature  that will become our generic formal pacakage
parameter for the Do_Something procedure.  This model has no specification and therefore will not have abody.  It is typical of a generic formal signature to be  a set of parameters for later instantiation.   The code
on Line 11 is the syntax for a generic formal package parameter.  The parenthetical box  (<>) may have theformal parameters associated with actual pa rameters if any are visible at this point.
The code beginning on Line 13 is a generic procedure declaration.  By making it a simple procedure with
its own formal parameters we keep this example simple.  The package body for Mapping_Example willsimply implement the procedure Do_Something.
package body  Mapping_Example is --  1 Implementation of the
  procedure  Do_Something(M : in out  Mapping_Type; --  2        generic formal program
                         K : in Key; --  3
                         V : in Value) is --  4
  begin -- Do_Something --  5
           Mapping_Operations.Add(M, K, V); --  6
  end Do_Something; --  7
end Mapping_Example; --  8
The comment the begin statement on Line 5 to emphasizes that it belongs to Do_Something.  The call on
Line 6 is to the Add procedure in the generic form al parameter list for Mapping_Operations.  Dot notation
makes clear the referencing of the formal parameter name, not the “is new” name. Here is an example of
how to instantiate the units in Mapping_Example:
with  Mapping_Example; --  1
procedure  Test_Mapping_Example is --  2
   Map_Key : Integer := 0; --  3   Map_Data : Character := 'A'; --  4   Map_Value : Integer := Map_Key; --  5
  procedure  Add   (M : in out  Character; K : Integer; V : Integer) is --  6
begin --  7
      null; -- 
Stubbed out; usually is the algorithmic part of the code --  8
   end Add; --  9
     procedure  Remove (M : in out  Character; K : Integer; V : Integer) is -- 10
begin -- 11
      null; -- Stubbed out; usually is the algorithmic part of the code -- 12
   end Remove; -- 13
   procedure  Apply (M : in out  Character; K : Integer; V : Integer) is -- 14
begin -- 15
      null; -- Stubbed out; usually is the algorithmic part of the code -- 16
   end Apply; -- 17
               -- 18
   package  Character_Mapping is new  Mapping_Example.Mapping -- 19
               (Mapping_Type => Character, -- 20
                Key          => Integer, -- 21                Value        => Integer, -- 22                Add          => Add, -- 23                Remove       => Remove, -- 24                Apply        => Apply); -- 25
   procedure  Do_Something_To_Map -- 26
          is new  Mapping_Example.Do_Something -- 27
                (Mappi ng_Operations => Character_Mapping); -- 28
begin -- 29
   Do_Something_To_Map (M => Map_Data, -- 30
                       K => Map_Key, -- 31                       V => Map_Value); -- 32
end Test_Mapping_Example; -- 33Implementation
of proceduresintended to beused as genericformalsubprogram
parameters.
Instantiation ofthe signaturepackage usinggeneric actualparameters .
Instantiation of
generic packageassociating thegeneric formalpackageparameter withgeneric actualfrom lines 19-25.
Ada Distilled   by Richard Riehle
Page 78 of 11312.3 Longer Generic Code Example
Just as you can create simple generic subprograms, as shown above, you can also generalize entire
packages.  This book has some examples of how to do this.  Here is an example of a generic containerpackage which corresponds to some of the the generi c packages you will see wh en programming with Ada.
This package is a managed  FIFO Queue_Manager which includes an iterator .  A managed data structure
is one which includes some kind of automatic garbage collection .   An iterator  is a mechanism by which
you may non-destructively visit every node of a data structure.  There are two fundamental kinds of
iterators, active  and passive .  A passive iterator  is somewhat safer than an active iterator.  Also, a passive
iterator requires less work from the client.  We show a package with an active iterator .
with  Ada.Finalization; --  1
use  Ada; --  2 Make package Ada visible
generic --  3
   type Element is tagged private ;         -- A more robust design might derive Element --  4
                                                         -- from Ada.Finalization.Controlled --  5
   with function   Is_Valid(Data : Element) return  Boolean; --  6
package  Queue_Manager_1 is --  7
type List is limited private ; --  8 No assignment possible
type List_Reference is access all  List; --  9 We can assign access values
type List_Item is new  Element with private ; -- 10 Inherits from Element
type Item_Reference is access all  List_Item'Class; -- 11 Classwide access type
-- A classwide access type permitting a heterogenuous queue -- 12
procedure  Clear (L : in out  List); -- 13 Empties the list
procedure  Insert_At_Head (L : in out  List; I : in     List_Item'Class); -- 14 Self-documenting Method
procedure  Insert_At_Head (L : access  List; I : access  List_Item'Class); -- 15
-- A more complete design would include added options for the Insert operation -- 16
procedure  Copy (Source : in List; Target : in out  List); -- 17
function  Remove_From_Tail (L : access  List) return  List_Item'Class; -- 18 Self-documenting Method
-- A more complete design would include  added options for the Remove operation -- 19
function  "=" (L, R : List) return  Boolean; -- 20 Overload Equality Test
function   Node_Count (L : access  List) return  Natural; -- 21 Self-documenting Query
function   Is_Empty (L : access  List) return  Boolean; -- 22 Self-documenting Query
--  ===============  Define the Active  Iterator   ===================== -- 23
type Iterator is private ; -- 24
procedure  Initialize_Iterator(This     :  in out  Iterator; The_List : access  List); -- 25
function   Next(This : in Iterator) return  Iterator; -- 26
function   Get (This : in Iterator) return  List_Item'Class; -- 27
function   Get (This : in Iterator) return  Item_Reference; -- 28
function   Is_Done(This : in Iterator) return  Boolean; -- 29
-- 30
Iterator_Error : exception ;    -- 31
private  -- 32
use Ada.Finalization; -- 33 Use clause OK here
type List_Node; -- 34 Incomplete type definition
type Link is access all  List_Node; -- 35 Reference to List_Node
type Iterator is new  Link; -- 36 Derive Iterator from Link
type List_Item is new  Element with null record ; -- 37 Empty tagged record
type List_Node is new  Controlled with -- Derived from a controlled type -- 38 Define a List_Node
record -- 39
Data : Item_Reference; -- 40 Item is a pointer
Next : Link; -- 41 List_Node pointer
Prev : Link; -- 42 List_Node pointer
end record ; -- 43
type List is new  Limited_Controlled with   -- Derived from limited controlled type -- 44
record -- 45
Count : Natural := 0; -- 46Head    : Link; -- 47 List_Node pointer
Tail       : Link; -- 48 List_Node pointer
Current : Link; -- 49 List_Node pointer
Ada Distilled   by Richard Riehle
Page 79 of 113end record ; -- 50
procedure  Finalize(One_Node : in out  List_Node); -- 51 reclaim Node storage
procedure  Finalize(The_List : in out  List); -- 52 reclaim List storage
end Queue_Manager_1; -- 53
An active iterator would require the client to write  a loop which successively calls the Next function
followed by a Get function.  An active iterator is not quite as safe as a passive iterator, but it can be aneffective building block for contructing passive itera tors.  Since the list is potentially heterogenuous, the
Get returns a classwide type.  This can be used in  conjuction with dispatching operations.  Here is an
annotated package body for the above specification.  This is a long set of source code but it should beuseful to the student because of its  near completeness.  It also serv es as a model for creating other data
structures.  This package body was compiled using the GNAT Ada compiler.
with Text_IO; --  1
with Ada.Exceptions; --  2
with Unchecked_Deallocation; --  3
package body Queue_Manager_1 is --  4
-- This instantiation enables destructi on of unreferenced allocated storage --  5
   procedure  Free_Node is new Unchecked_Deallocation --  6
             (Object => List_Node, --  7
              Name   => Link); --  8
-- This instantiation enables destruction of unreferenced Data items --  9
   procedure  Free_Item is new Unchecked_Deallocation -- 10
             (Object => List_Item'Class, -- 11
              Name   => Item_Reference); -- 12
-- We override Ada.Finalizaion for a single node -- 13
   procedure  Finalize(One_Node : in out List_Node) is -- 14
   begin -- 15
Free_Item (One_Node.Data); -- 16
     Free_Node (One_Node.Next); -- 17
   end Finalize; -- 18
-- When the list goes out of scope, this is called to clean up the storage -- 19
   procedure  Finalize(The_List : in out List) is -- 20
   begin -- 21
-- Use the Iterator to traverse the list and call Free_Item;  add this code yourself -- 22
      Free_Node (The_List.Current); -- 23      Free_Node (The_List.Tail); -- 24      Free_Node (The_List.Head); -- 25
   end Finalize; -- 26
-- The name says what it does.  Note the allocation of a temp. Finalization will  -- 27
-- occur to ensure there is no left over storage .  -- 28
   procedure  Insert_At_Head (L : in out List; -- 29
                             I : in     List_Item'Class) is -- 30
        Temp_Item : Item := new List_Item'(I); -- 31
        Temp : Link := new List_Node'(Controlled with -- 32
                                      Data => Temp_Item, -- 33
                                      Next => null, -- 34
                                      Prev => null); -- 35
   begin -- 36
      if Is_Empty(L'Access) -- 37
      then -- 38
         L.Head := Temp; -- 39
         L.Tail := Temp; -- 40
      else -- 41
         L.Head.Prev := Temp; -- 42
         Temp.Next := L.Head; -- 43         L.Head := Temp; -- 44
      end if; -- 45
      L.Count := L.Count + 1; -- 46
   end Insert_At_Head; -- 47
-- This is implemented in terms of the non- access version.  Simply makes it convenient -- 48
-- to call this with access to  object values, general or storage-pool access values . -- 49
   procedure  Insert_At_Head (L : access List; -- 50
                             I : access List_Item'Class) is -- 51package
body
Ada Distilled   by Richard Riehle
Page 80 of 113   begin -- 52
      Insert_At_Head(L => L. all, -- 53
                     I => I. all); -- 54
   end Insert_At_Head; -- 55
-- We implement this as a function inste ad of a procedure with in out modes -- 56
-- because this can be used in an expression to constrain a classwide variable -- 57
-- For example,  X : List_I tem’Class := Remove(L); -- 58
  function  Remove_From_Tail (L : access List) -- 59
                              return List_Item'Class is -- 60
       Result : Item := L.Tail.Data; -- 61
   begin -- 62
       L.Tail := L.Tail.Prev; -- 63
       L.Count := L.Count - 1; -- 64
Free_Item(L.Tail.Next.Data); -- 65Free_Node(L.Tail.Next); -- 66
       return Result. all; -- 67
   end Remove_From_Tail; -- 68
-- You might want a more robust “=“.  For example, it might be better to traverse -- 69
-- each list, node by node, to ensure  that each element is the same .  -- 70
   function  "=" (L, R : List) return Boolean is -- 71
   begin -- 72
       return L.Count = R.Count; -- 73
   end "="; -- 74
-- The name says it.  Simply returns how many nodes in this list .  -- 75
   function   Node_Count (L : access List) return Natural is -- 76
   begin -- 77
      return L.Count; -- 78
   end Node_Count; -- 79
-- This will not be correct unless you keep care ful count of the inserted and deleted nodes. -- 80
   function   Is_Empty(L : access List) return Boolean is -- 81
begin -- 82
       return L.Count = 0; -- 83
end Is_Empty; -- 84
-- We made List a limited private to prevent aut omatic assignment.  Instead, we design -- 85
-- this “deep copy” procedure to  ensure there will be two separate copies of the data -- 86
   procedure  Copy (Source : in List; -- 87
                   Target : in out List) is -- 88
        type Item_Ref is access all  List_Item'Class; -- 89
        Temp : Link := Source.Tail;   -- 90
        Local_Data : Item_Reference;  -- 91
begin -- 92
   Clear(Target); -- Be sure the target is initialized before copying . -- 93
loop -- 94
exit when Temp = null; -- 95
Local_Data := new List_Item'(Temp.Data. all); -- 96
declare -- 97
  Local_List_Item -- 98
            : List_Item'Class := Local_Data. all; -- 99
begin -- 100
   Insert_At_Head(Target, Local_List_Item); -- 101
end; -- 102
Temp := Temp.Prev; -- 103
end loop ; -- 104
end Copy; -- 105
-- This is pretty simple.   It is also an important part of the overall design . -- 106
procedure  Clear (L : in out List) is -- 107
begin -- 108
L.Head    := null; -- 109
L.Tail    := null; -- 110
L.Current := null; -- 111
L.Count   := 0; -- 112
end Clear; -- 113
procedure  Initialize_Iterator(This     : in out Iterator; -- 114
                      The_List : access List) is -- 115Also need to free data storage in this routine
Ada Distilled   by Richard Riehle
Page 81 of 113begin -- 116
This := Iterator(The_List.Head); -- 117
end Initialize_Iterator; -- 118
function  Next(This : access Iterator)  return Iterator is -- 119
begin -- 120
return Next(This. all); -- 121
end Next; -- 122
function  Next (This : Iterator) return Iterator is -- 123
begin -- 124
return Iterator(This.Next); -- 125
end Next; -- 126
function   Get (This : in Iterator) -- 127
                 return List_Item'Class is -- 128
begin -- 129
return This.Data.all; -- 130
end Get; -- 131
function   Get (This : in Iterator) return Item_Reference is -- 132
begin -- 133
return This.Data; -- 134
end Get; -- 135
function   Is_Done(This : in Iterator) return Boolean is -- 136
begin -- 137
return This = null; -- 138
end Is_Done; -- 139
function   Is_Done(This : access Iterator) -- 140
                     return Boolean is -- 141
begin -- 142
return Is_Done(This.all); -- 143
end Is_Done; -- 144
end Queue_Manager_1; -- 145
12.3 Generics and Software Reuse
Be sure to let the others on your project know about generic components you might design.   Watch for
opportunities during design and code walkthroughs to promote code th at is specific to one type into a
generic component.   This is a project manager's responsibility.
Don't write code that already exists in libraries.   Most data structures and common algorithms are already
written and residing in compone nt repositories.    Some of those re positories are commercial. Others are
open source and free.  For military systems, there are lib raries of classified com ponents that can be helpful
in building weapon systems.
One strategy is to define, at the beginning of the project, what kinds of components are likely to be needed.
Select a dozen or so of these from existing libraries.  Require that everyone on the project, during the early
stages of development, use the same generic linked-list,  sort routine, etc.    This will help you produce a
working solution early.  Later, if there is a need for refinement, you can search for components that moreclosely accomplish your needs.
Ada Distilled   by Richard Riehle
Page  82 of 11313. New Names from Old Ones
Renaming is sometimes controversial.  Some people like it.  Others hate it.   The important things to
understand are:
1. Renaming does not create new data space.  It simply pr ovides compiler with a new name for an existing entity.
2. Don't rename same item over and ove r with new names;  you will confuse colleagues -- and yourself.
3. Use renaming to simplify your code.  A new name  can sometimes make the code easier to read.
13.1 Making a Long Name Shorter
This section demonstrates some useful ideas such as renaming long package names, commenting the begin
statement, getting a line of data from a terminal using Get_Line, and catenating two strings.  Also, note that
a string may be initialized to all spaces using the others   => aggregate notation.
with  Text_IO, Ada.Integer_Text_IO; --  1 Put Text_IO library unit in scope;  A.10.8/21
procedure   Gun_Aydin  is --  2 "Good morning" in Turkish;  6.1
package  TIO renames  Text_IO; --  3 Shorten a long name with renaming;  8.5.3
package  IIO renames  Ada.Integer_Text_IO; --  4 Shorter name is same as full name to compiler;  8.5.3
Text_Data  : String (1..80) := ( others  => ‘ ‘);--  5 others => ‘ ‘ iniitalizes string to spaces;  4.3.3
Len : Natural; --  4 To be used as parameter in Get_Line;   A.10.7
begin-- Hello_2 --  6 Good idea to comment every begin statement;  2.7/2
TIO.Put(“Enter Data: “); --  7 Put a string prompt with no carriage return;  A.10
TIO.Get_Line(Text_Data, Len); --  8 After cursor, get a line of text with its length;  A.10
IIO.Put (Len); --  9 Convert number to text and print it; A.10 and line 4
TIO.Put_Line(“   “ & Text_Data(1..Len)); -- 10 Put catenated string with carriage return;  4.4.1
end Gun_Aydin; -- 11 end Label same as procedure name;  6.3
13.2 Renaming an Operator  ALRM 8.5
Sometimes an operator for a type declared in a with'ed  package is in scope but not visible .  The rules of
Ada require that no entity in scope is directly visible to a client until it is explicitly made visible.   Anoperator is one of the symbol-based operations such as "+", "/", ">", or "=".    A use clause  makes
operators directly visible, but a use clause also makes too many other entities directly visible.   You canselectively makeoperators visible through renaming as shown on lines 6 and 8 below.
Renaming makes a specific operator visible without making all other operators visible.  In the following
procedure, which draws a text-based diamond on the screen, we rename the packages to make their namesshorter and rename the “+” and “-” operators for Text_IO.Count to make them explicitly visible.
with  ada.text_io; --   1 A.10;  context clause .
with  ada.integer_text_Io; --   2 A.10.8/21
procedure  diamond1 is --   3 Parameterless procedure
  package  TIO renames  ada.text_io; --   4 Rename a library unit;  8.5.3
  package  IIO renames  ada.integer_text_io; --   5 Renames;  8.5.3
  function  "+" (L, R : TIO.Count) return  TIO.Count --   6 Rename Operator;  8.5.4
                                  renames  TIO."+"; --   7 Makes the  operators directly
  function  "-" (L, R : TIO.Count) return  TIO.Count --   8          visible for  "+" and "-" to avoid
                                 renames  TIO."-"; --   9           the need for a "use" clause .
  Center : constant  TIO.Count     := 37; -- 10 type-specific constant; named number
  Left_Col, Right_Col : TIO.Count := Center; -- 11 type-specific variables
  Symbol : constant  Character := 'X'; -- 12 a character type constant
  Spacing : TIO.Count := 1; -- 13 Local variables for counting
  Increment : TIO.Count := 2; -- 14 Initialize the variable
begin-- Diamond1 -- 15 Always declare comment at begin
   TIO.Set_Col(Center); -- 16 Set the column on the screen
Ada Distilled   by Richard Riehle
Page 83 of 113   TIO.Put(Symbol); -- 17 Put a single character to video display
   for I in 1..8 loop -- 18 begin a for loop with constants
      TIO.New_Line(Spacing); -- 19 Advance one line at a time
      Left_Col := Left_Col - Increment; -- 20 See lines 8 & 9, above
      Right_Col := Right_Col + Increment; -- 21 Data type and operator visibility
      TIO.Set_Col(Left_Col); -- 22
      TIO.Put(Symbol); -- 23
      TIO.Set_Col(Right_Col); -- 24
      TIO.Put(Symbol); -- 25
   end loop ; -- 26
   for I in 9..15 loop -- 27
      TIO.New_Line(Spacing); -- 28
      Left_Col := Left_Col + Increment; -- 29 Increment the Left Column by 1
      Right_Col := Right_Col - Increment; -- 30 Increment the Right Column by 1
      TIO.Set_Col(Left_Col); -- 31 Set the column
      TIO.Put(Symbol); -- 32 Print the symbol
      TIO.Set_Col(Right_Col); -- 33 Set the column
      TIO.Put(Symbol); -- 34 Print the symbol
   end loop ; -- 35 Loop requires an end loop
   TIO.Set_Col(Center); -- 36 Set the column for final character output
   TIO.Put(Symbol); -- 37 The last character for the diamond
end Diamond1; -- 38 End of scope and declarative region
Always plan ahead to ease operator usage through caref ul package design.  In the following example, the
operators are renamed in a nested package wh ich can be made visible with a use clause.
package  Nested is --   1  Package specification
type T1 is private ;  -- this is called a partial view of the type --   2  Only =, /=, and :=
type Status is (Off, Low, Medium, High, Ultra_High, Dangerous); --   3  Enumerated type; full set
-- operations on T1 and Status --   4     of infix operators is available
package  Operators is --   5  A nested package specification
function  “>=“ (L, R : Status) return  Boolean --   6  Profile for a function and
           renames  Nested.”>=“; --   7          renames for the >= operator
function  “=“ (L, R : Status) return  Boolean --   8  Profile for an = function and
           renames  Nested.” =“; --   9 renames of the = operator
end Operators; -- 10  Nested specifcation requires end
private -- 11  Private part of package
type T1 is ... -- 12  Full definition of type from line 2
end Nested; -- 13  Always include the identifier
The above package can be accessed via a “with Nested;” context clause followed by a “use
Nested.Operators;” to make the comparison operators explicitly visible.  Not everyone will approve of thisapproach, but it has been employed in many Ada desi gns to simplify the use of infix operators because it
eliminates the need for localized renaming.  We caution you to use this technique with discretion.
with  Nested; -- 1 Always include the identifier
procedure Test_Nested  is -- 2 A simple procedure body
use Nested.Operators; -- 3 Use clause for  nested package
X, Y : Nested.Status :=  Nested.Status'First; -- 4 Declare some Status objects
begin -- Test_Nested -- 5 Always include Identifier
-- Get some values for X, and Y -- 6 This code is commented
if X = Nested.Status'Last then -- 7 = is made directly visible at line 3
-- Some statements here -- 8
end if ; -- 9 Of course.  End if required
end Test_Nested; --10 Always use identifier with end
The code just shown illustrates a technique for letting the client make the selected operators directly visible
via a use clause on the nested package sp ecification.  I prefer this solution to use type  (ALRM 8.4/4)
because it only makes a restricted set of operators visi ble.   The downside of this is that it requires the
designer to think ahead.   Thinking ahead is all too rare for package designers.Could also be
designed as achild package
Ada Distilled   by Richard Riehle
Page 84 of 11313.3 Renaming an Exception
Sometimes it is useful to rename an exception locally to where it will be used.  For example,
  with  Ada.IO_Exceptions;
package  My_IO is
-- various IO services
-- Data_Error : exception renames  Ada.IO_Exceptions.Data_Error;
...
end My_IO;
13.4 Renaming a Component
One of the most frequently overlooked features of Ada renaming is the option of giving a component of a
composite type its own name.
with Ada.Text_IO;
package  Rename_A_Variable is
-- various IO services
-- Record_Count : renames  Ada.Text_IO.Count;
...
end Rename_A_Variable;
13.4.1  Renaming an Array Slice
Suppose you have the following string,
Name : String(1..60);  --  A String is a special kind of array that must be constrained
where 1..30 is the last name, 31..59 is the first name and 60 is the middle initial.  You could do the
following.
declare
Last : String  renames  Name(1..30);
First : String  renames  Name(31.29);
Middle : String  renames  Name(60.60);
begin
Ada.Text_IO.Put_Line(Last);
Ada.Text_IO.Put_Line(First);Ada.Text_IO.Put_Line(Middle);
end;
where each Put_Line references a named object instead of a range of indices.   Notice that the object still
holds the same indices.  Also, the renamed range constrains the named object.  No new space is declared.
The renaming simply gives a new name for existing data.
13.4.2  Renaming a Record Component
Consider the following definitions,
subtype  Number_Symbol is Character range  '0'..'9';
subtype  Address_Character is Character range  Ada.Characters.Latin_1.Space
                                      .. Ada.Characters.Latin_1.LC_Z; -- Notice continuation of range to this line
type Address_Data is array (Positive range  <>) of Address_Character;
type Number_Data is array (Positive range  <>) of Number_Symbol;In this example, you can rename slices of
arrays including String arrays.  Each slicewill have its own name that can be used inany statement where that type is legal.
Ada Distilled   by Richard Riehle
Page 85 of 113type Phone_Number is record
Country_Code : Number_Data(1..2);Area_Code : Number _ Data (1..3);Prefix : Number_ Data (1..3);Last_Four : Number_ Data (1..4);
end record ;
type Address_Record is
The_Phone : Phone_Number;Street_Address_1 :  Address_Data(1..30);Street_Address_2 :  Address_Data(1..20);City    : Address_Data (1..25);State  : Address_Data(1..2);Zip: Number _ Data (1..5);Plus_4 : Number_ Data (1..4);
end record ;
One_Address_Record : Address_Record;
Now you can rename an inner component for direct re ferencing in your program.  For example, to rename
the Area_Code in a declare block,
declare
AC : Number_ Data renames  One_Address_Record .The_Phone.Area_Code;
begin
-- Operations directly on variable AC
end;
The declaration of AC does not create any new data  space.  Instead, it localizes the name for the
component nested more deeply within the record.  If the record had deeply nested components that you
needed in an algorithm, this renaming could be a powerful technique for simplifying the names within thatalgorithm.
13.5 Renaming a Library Unit
Suppose you have a package in your library that everyone on the project uses.   Further, suppose thatpackage has a long name.  You can with that library unit, rename it, and compile it back into the libaraywith the new name.   Anytime you with the new name, it is the same as withing the original.
-- The following code compiles a renam ed library unit into the library
with  Ada.Generic_Elementary_Functions;
package  Elementary_Functions renames  Ada.Generic_Elementary_Functions;
with  Graphics.Common_Display_Types;
package  CDT renames  Graphics.Common_Display_Types;
Take care when doing this kind of thing.   You don't want to confuse others on the project by making up
new names that no one knows about.  Also, renaming can be a problem wh en the renamed entity is too far
from its original definition or description.
13.6. Renaming an Object or Value
This can be especially troublesome when done too ofte n.   I recall a project where the same value was
renamed about seven times throughout a succession of packages.  Each ne w name had meaning within the
context of the new package but was increasingly untr aceable the further one got from its original value.Inner record
Inner record
contained inouter record
Nested data
Ada Distilled   by Richard Riehle
Page 86 of 113package  Messenger is --  1  Specification Declaration
type Message is tagged private ; --  2 Partial definition , tagged type
type Message_Pointer is access all  Message'Class; --  3 Classwide access type (pointer)
procedure  Create(M : in out  Message; --  4 Operation on the type
                 S  : in String); --  5 Second parameter for Operation
procedure  Clear (M : in out  Message); --  6 Clear all fields of the Message
function   Message_Text (M : Message) return  String; --  7 Return the Data of Message
function   Message_Length(M : Message) return  Natural; --  8 Return the Length of Message
private --  9 Private part of specification
type String_Pointer is access all  String; -- 10 Private pointer declaration
type Message is tagged record -- 11 Full definition of  type Message type
Data   : String_Pointer; -- 12 Component of Message record
Length : Natural; -- 13 Component of Message record
end record ; -- 14 Ends scope of Message record
end Messenger; -- 15 End scope of specification
13.7. Renaming a Type or Subprogram
The rename option does not apply to a type declaration.  However, if you look back at the example of
subtypes elsewhere in this book, you will see that a subtype can be  used any place its parent type can
be used.   John English, in his JEWL package fo r Windows development, use this capability in clever
ways.
Professor English first declares certain types using the spelling of his native England and they renames
them for his cousins across the pond.   Consider the following examples from JEWL.
Original type declaration
type Colour is ...
Renamed by a subtype declaration;
subtype Color is Color;
Original subprogram declaration.
function  Centre return Alignment_Type;
Renamed by a renaming declaration;
function  Center return Alignment_Type renames Centre;
13.8. Notes on renaming
Ada developers are cautious about rena ming.   If the renames is used to localize the effect of an entity, or
clarify the understanding of that entity, it can be a good thing.   If the renaming is applied to a global
variable or to some entity at a great distance from its original declaration,  readability might be reduced.
Use renaming to improve readability, understandability , and maintainability for the programmer who will
need to update your program after you are finished with it.   Array renaming, while often handy,  canintroduce confusion for a programmer unaccustomed to it.Full private
type definition
Ada Distilled   by Richard Riehle
Page 87 of 11314. Concurrency with Tasking
Ada is unique among general purpose programming language s in its support for concurrency.  There are
two models for Ada concurrency:  multitasking , and distributed  objects .  The latter, distributed objects is
beyond the scope of this book.  We focus this discu ssion on multitasking.  In Ada this is simply called
tasking.    Tasking is implemented using standard Ada language syntax and semantics along with two
additional types:  task types  and protected types .   The syntax and semantics of task types and protected
types is described in Chapter 9 of the Ada Language Reference Manual (ALRM).   The semantics areaugmented in Annex D and Annex C of the ALRM.
Each task is a sequential entity that may operate concurrently with, and communicate with, other tasks.   A
task object may be either an anonymous type or an object of a task type.
14.1 Fundamental Ideas
Tasks are concurrent active  objects.   The word active  in that sentence is important.   An active object is
called a task in Ada.  Once it is created and activat ed a task is in one of two states:  executing  or
suspended .    Ada can support multiple active tasks.  In  a single processor implementation, only one task
can be executing at any instant.  In  this environment, other active tasks are suspended.   When one active
task begins to execute, all other tasks are suspended.   Tasks can be assigned priorities so they can entersuspended/executing states accordi ng to a scheduling algorithm.  Th e underlying Ada Run-time Executive
(it comes with every Ada compiler) has a scheduler that controls  tasks according to a scheduling model.
The scheduling model may vary according th e the needs of the execution environment.
Tasks may be designed so they communicate with  each other.  The communication is called a rendezvous .
One task communicates with another by placing requests for rendezvous in the entry queue  of the called
task.    The calling task goes into a suspended stat e until the entry (request for rendezvous) in the queue is
consumed and and processed by the called task .    The called task does not know its caller.
14.2 A Keyboard Entry Example
Task may be anonymous or instances of task types. The following tasks are anonymous. They are
concurrently active.  Only one execu tes while the others are suspended.
package  Set_Of_Tasks is
task T1; --   1    object of anonymous task type
task T2 is --   2    communicating object
entry  A; --   3    entry point to task
entry  B; --   4    entry point to task
end T2; --   5    end of task specification
task T3 is --   6    communicating task object
entry  X(I : in Character); --   7    parameterized entry point
entry  Y(I : out Character); --   8    parameterized entry point
end T3; --   9    end of task specification
end Set_Of_Tasks; -- 10  end of package specification
A task has two parts: specification and body.  A task  may not be a library unit and cannot be compiled by
itself.  A task must be declared inside some other library unit.  In the example, above, there are three taskspecifications within a p ackage specification.   The body of each task will be within the body of the
package.    For example,
Ada Distilled   by Richard Riehle
Page 88 of 113with Ada.Text_IO; --  1 Context clause
with Ada.Characters.Latin_1; --  2 For referencing special characters
use  Ada; --  3 Make package Ada visible
use  Characters; --  4 Make package Characters visible
package body Set_Of_Tasks is --  5 Enclosing scope for the task bodies
   task body T1 is --  6 Implement task T1
     Input  : Character; --  7 Local variable
     Output : Character; --  8 Local variable
     Column : Positive := 1; --  9 Could be Text_IO.Positive_Count
   begin -- 10
     loop -- 11
      Text_IO.Get_Immediate (Input); -- 12 Input character with no return key entry
      exit when Input = '~'; -- 13 If the character is a tilde, exit the loop
      T3.X(Input); -- 14 Put entry in queue for T3.X; suspend
      T2.A; -- 15 Put entry in queue for T2.A; suspend
      T2.B; -- 16 Put entry in queue for T2B; suspend
      T3.Y(Output); -- 17 Put entry in queue for T3.Y; suspend
      if Column > 40 then -- 18 No more than 40 characters per line
         Column := 1; -- 19 Start the character count over from 1
         Text_IO.New_Line; -- 20        and then start a new line
      else -- 21
         Column := Column + 1; -- 22 Increment the character per line count
      end if; -- 23
      Text_IO.Set_Col(Text_IO.Positive_Count(Column)); -- 24 Note type conversion here
      Ada.Text_IO.Put(Output); -- 25 Print the character on the screen; echo
     end loop ; -- 26
   end T1; -- 27 End of task T1 implementation
   -- 28
   task body  T2 is -- 29 Implement body of task T2
   begin -- 30
     loop -- 31
       select -- 32 Select this alternative or terminate when done
         accept A; -- 33 Rendezvous point; corresponds to entry in
         accept B; -- 34 task specification.  These are sequential here .
       or -- 35 The alternative to selecting  accept A ;
         terminate ;                             -- 36 Taken only when nothing can call this anymore
       end select; -- 37
     end loop  ; -- 38
   end T2; -- 39
   -- 40
   task body T3 is -- 41 Implement task T3 body
     Temp : Character := Latin_1.Nul; -- 42 Local variable
   begin -- 43
    loop -- 44 Choose rendezvous altenative
      select -- 45 Another selective accept statement
        accept X (I : in     Character ) do -- 46 Begins critical region for rendezvous
    Temp := I; -- 47 Calling task is suspended until end statement
        end X; -- 48 Rendezvous complete.  Caller is not suspended
      or -- 49           or this next altenative
        accept Y (I :    out Character ) do -- 50 Critical region begins with do statement
           I := Temp; -- 51 Caller is suspended at this point
           Temp := Latin_1.Nul; -- 52 The non-printing nul character
        end Y; -- 53 Rendezvous complete at this point
      or -- 54 or the terminate alternative which will only
        terminate ; -- 55 be taken if no other task can call this one
     end select ; -- 56 end of scope for the select statement
    end loop ; -- 57
   end T3; -- 58
end Set_Of_Tasks; -- 59
We apologize for the length of this example.  It does serve to show a lot of interesting issues related to
tasking.  You can key it in and it will work.  We also  suggest you expe riment with it by little alterations.
Each task is coded as a loop.   Task T1 simply ge ts a character from the keyboard, sends that character to
T3, gets it back from T3, and prints it to the screen.   T3 does nothing with the character, but it could have
Ada Distilled   by Richard Riehle
Page 89 of 113more logic for examining the character to see if it is OK.   You could modify this program to behave as a
simple data entry application.  We recommend you do this as an exercise.
Here is a simple little test program you can use with this package.
with Set_Of_Tasks;
procedure  Test_Set_Of_Tasks is
begin  null;
end Test_Set_Of_Tasks;
Some tasks will have one or more entry  specifications.   In Ada, an en try is unique because it implies an
entry queue .  That is, a call to an entry simply places an entry into a queue.  An entry call is not a request
for immediate action.  If there are already other entries in that queue, the request for action will have towait for the entries ahead of it to be consumed.  Entr ies disappear from the queue in one of several ways.
The most common is for them to complete the rendezvous request.
Each task body has a begin statement.  Two of the ta sks, T2 and T3, have local variables.   The accept
statements in the bodies of T2 and T3 correspond to the entry statements in their specifications.  A task
body may have more than one accept statement for each entry.  When an accept statement includes a do
part, everything up to the end of  accept statement is called the critical region .   A calling task is suspended
until the critical region is finished for its entry into the task queue.
Now we examine the details of the program example.   Each task in  this package specification is an
anonymous task.  We know this because the word type does not appear in the specification.  Task T1 is not
callable because it has no entries.   Task T2 is callable,  but has no parameters in the entry.  T3 is callable
and includes a parameter list in each entry.   A call to an entry is simply placemes a request for action in an
entry queue.   This is more like message passing than subprogram calling.
The body of this package contains the bodies of the corresponding task specifications.  Task body T1 is
implemented as a loop.   This is not a good model for task design.    In fact, it is a bad design.  However, itdoes give us an introductory point into understanding.   A better design would permit interrupts to occur
and be handled as they occur rather than within the confines of a loop.  We show an example of this kind inthe next example.
Line 14 is an entry call to T3.X.  It includes a parame ter of type Character.   This entry call puts a request
for action in the T3.X queue.  There are, potentially, ot her entries already in that queue.   The default, in
Ada, is that the entries will be consumed in a FIFO order.  This default may be overridden by the designerwhen deemed appropriate.    At Line 14, Task T1 is suspended while waiting for the completion of itsrequest for action.   Task T1 will resume once that request is completed.
Lines 15 and 16 are do nothing  entry calls.  We include them in this example for educational purposes, not
because they add anything to the de sign or performance.   If we were  to reverse Lines 15 and 16, this
program would deadlock.   Each task is a sequential pr ocess.    The two accept st atements in task T2 are
sequential.  Entry B cannot be proce ssed until Entry A is processed.   Th is is an important feature of Ada,
and almost all models for communicating seque ntial processes that operate concurrently.
On line 32 in task T2 and line 45 of task T3, we show the start of a select  statement.   This construct allows
the task to take a choice of accept  alternatives, depending on which entr y is called.   The accept statements
in task T3 are not sequential.  That is, entry X is not dependent on entry Y and entry Y is not dependent on
entry X.  The corresponding accept statements may proceed regardless of which is called first.
Lines 36 and 56 have the terminate  alternative within a select statement.  This alternative will never be
taken unless no other task can call one of the other entries.   The Ada run-time will take the terminate pathfor every task that has reached th e state where it cannot be called, ca nnot call any other task, and has noThe tasks, in package Set_Of_Tasks, will begin
executing as soon as the null statement isexecuted.   It is not n ecessary to call the tasks .
Ada Distilled   by Richard Riehle
Page 90 of 113other tasks currently dependent on it.   This is a graceful  way to for a task to die.   There is no need for a
special shutdown  entry.   Terminate should be used for most service tasks.
If you do not understand the mechan isms associated with an entry queue, you will not understand
communicating tasks.   It is a rule that, when a task puts an entry into the queue of another task, that entryremains in the queue until it is consumed or otherwise is removed from the queue.  The task that puts theentry is suspended until the request for action is completed.   The calling task may request, as part of thecall, that the request remain in the queue for a limited period, after which it is removed from the queue.
Task T3 cannot identify who called which entry.  It cannot purge its own queue.  It can determine how
many entries are in each queue.   That is, we could have a statement that gets  X'Count or Y'Count within
task T3.
Lines 47-48 and 52-53 are the procedural statements w ithin an accept statement.   Every statement between
the word do and the corresponding end is in the critical region , mentioned earlier.   Statement 47 must
occur before statement 48.   Task T1, when it ma kes a call, T3.Input(...), is  suspended until the entire
critical region is finished.   T3.I nput will consume an entry from its ow n queue, process that entry in the
critical region, and finish.  Once it is finished with the statements in the critical region, task T1 is released
from its suspended state and may continue.
In tasks T2 and T3, the loop serves a slightly different purpose than in task T1.    Here the loop is more of a
semantic construct to prevent the task from doing one set of actions and then terminating.   That is, the loopguarantees the task will remain ac tive for as long as it is needed.
14.3 Protecting Shared Data
It has been traditional for a design in which concurre nt threads share access to the same resource to use
some kind of Semaphore.   Semaphores come in many different varieties.  The two most common are thecounting semaphore and the binary semaphore.  The latter is sometimes called a Mutex.   A Semaphore is alow-level mechanism that exposes a program to many  kinds of potential hazards.  Ada uses a different
mechanism, the protected object, which allows the programmer to design encapsulated, self-locking objectswhere the data is secure against multiple concurrent updates.
Protected types are a large topic.   Therefore, we show only one simple version in this book.   The reader is
encouraged to study this in greater depth if they need to develop Ada software using the tasking model.The following example illustrates all of three operators of a protected object.   There a lot of reasons whyyou would not want to design a task-based application in  exactly the way this one is designed.   There are
some inherent inefficiencies in the design but it does illustrate some  fundamental ideas you should know.
with  Ada.Text_IO; --  1
procedure  Protected_Variable_Example is --  2
  package  TIO renames  Ada.Text_IO; --  3
  task T1; --  4
  task T2; --  5
  protected  Variable is --  6 Could have been a type definition
    procedure  Modify(Data : Character); --  7 Object is locked for this operation
    function   Query return  Character ; --  8 Read-only. May not update data
    entry  Display(Data : Character; T : String); --  9 An entry has a queue
  private -- 10
    Shared_Data : Character := '0'; -- 11 All data is declared here
  end Variable; -- 12
 protected  body  Variable is -- 13 No begin end part in protected bodyAlthough this w ill work with
Text_IO, it is not a good idea to useprotected types with  Text_IO in this
way.   We do this only for
pedagogical purposes.
Ada Distilled   by Richard Riehle
Page 91 of 113    entry  Display(Data : Character; T : String) -- 14 A queue and a required barrier that
when  Display'Count > 0 is -- 15      acts like a pre-condition
    begin -- 16
       TIO.Put(T & " "); -- 17        TIO.Put(Data); -- 18        TIO.New_Line; -- 19 
    end Display; -- 20 
    procedure  Modify (Data : Character) is -- 21
    begin -- 22
       Shared_Data := Data; -- 23
    end Modify; -- 24
    function  Query return  Character is -- 25
    begin -- 26
       return  Shared_Data; -- 27
    end Query; -- 28
  end Variable; -- 29
  task body  T1 is -- 30
    Local : Character := 'a'; -- 31    Output : Character; -- 32
  begin -- 33
     loop -- 34
       TIO.Get_Immediate(Local); -- 35 
       exit when  Local not in  '0'..'z'; -- 36
       Variable.Modify(Local); -- 37       Output := Variable.Query; -- 38       Variable.Display(Output, "T1 "); -- 39
     end loop ; -- 40
  end T1; -- 41
  task body  T2 is -- 42
    Local : Character :='a'; -- 43     Output : Character; -- 44
  begin -- 45
     loop -- 46
       TIO.Get_Immediate(Local); -- 47 
exit when  Local not in  '0'..'z'; -- 48
    Variable.Modify(Local); -- 49       Output := Variable.Query; -- 50      Variable.Display(Output, "T2 "); -- 51
     end loop; -- 52
  end T2; -- 53
begin -- 54
    null; -- 55 
end Protected_Variable_Example; -- 56
Every operation in a protected object is performed in mu tual exclusion.    The object is locked for update
only during the modification operations.   It is locked for read only during query operations.   It isimpossible for both update and query to occur at the same time.    A function is read-only.  During functioncalls, the object is locked for read-onl y.   An entry, as with a task, ha s a queue.   Every entry is controlled
by a boolean pre-condition that must be  satisfied before it can be entered.
Think of the difference between a semaphore and a protected type in terms of an airplane lavatory.   If you
were to enter the lavatory and depend on the flight a ttendendant to set the lock when you enter and remove
the lock to let you out, that would be analogous to a semaphore.   In a protected type, once you enter thelavatory, you set the lock yourself.  Once you are finished with your business in the lavatory, you unlock ityourself, and it is now free for someone else to use.   A protected object knows when it is finished with itswork and can unlock itself so another client can enter.When a procedure is executed, the object is locked
for update only.  It is performed in mutual exclusion.No other updates can be performed at the same time.Any other calls to modify must wait for it to be the
protected object to be unlocked.
The object is locked for read-only.  No updates canbe performed.  A functi on is not allowed to update
the encapsulated data.
It does not matter how many tasks are trying toupdate the data.  Only one can do so at any time.This task, and its corresponding task will updatethe protected variable in mutual exclusion.
Ada Distilled   by Richard Riehle
Page  92 of 113A.  Annexes, Appendices and Standard Libraries
Reserved Word List
abort case for new raise tagged
abs constant function not range task
abstract null record terminate
accept declare generic rem then
access delay goto of renames type
aliased delta or requeue
all digits if others return untiland do in out reverse use
array isat else package select when
elsif limited pragma separate while
begin end loop private subtype withbody entry procedure
exit mod protected xor
A.1  Package Standard
package Standard is         -- This package is always visible and n ever needs a with clause or use claus e
pragma Pure(Standard);
type Boolean is (False, True); -- An enumerated type; and ordered set;  False is less than True
-- The predefined relational operators for this type are as follows:
-- function  "="   (Left, Right : Boolean) return Boolean;
-- function  "/="  (Left, Right : Boolean) return Boolean;
-- function  "<"   (Left, Right : Boolean) return Boolean;
-- function  "<="  (Left, Right : Boolean) return Boolean;
-- function  ">"   (Left, Right : Boolean) return Boolean;
-- function  ">="  (Left, Right : Boolean) return Boolean;
-- The predefined logical operato rs and the predefined logical
-- negation operator are as follows :
-- function  "and" (Left, Right : Boolean) return Boolean;
-- function  "or"  (Left, Right : Boolean) return Boolean;
-- function  "xor" (Left, Right : Boolean) return Boolean;
-- function  "not" (Right : Boolean) return Boolean;
-- The integer type root_integer is predefined; The corresponding universal type is universal_integer.
type Integer is range  implementation-defined ;
subtype Natural  is Integer range 0 .. Integer'Last;
subtype Positive  is Integer range 1 .. Integer'Last;
-- The predefined operators for type Integer are as follows :
-- function  "="  (Left, Right : Integer'Base) return Boolean;
-- function  "/=" (Left, Right : Integer'Base) return Boolean;
-- function  "<"  (Left, Right : Integer'Base) return Boolean;
-- function  "<=" (Left, Right : Integer'Base) return Boolean;
-- function  ">"  (Left, Right : Integer'Base) return Boolean;
-- function  ">=" (Left, Right : Integer'Base) return Boolean;
-- function  "+"   (Right : Integer'Base) return Integer'Base;
-- function  "–"   (Right : Integer'Base) return Integer'Base;
-- function  "abs" (Right : Integer'Base) return Integer'Base;
-- function  "+"   (Left, Right : Integer'Base) return Integer'Base;
-- function  "–"   (Left, Right : Integer'Base) return Integer'Base;
-- function  "*"   (Left, Right : Integer'Base) return Integer'Base;
-- function  "/"   (Left, Right : Integer'Base) return Integer'Base;Every language has reserved words,
sometimes called keywords.   Notice that,among Ada’s 69 reserved words, there areno explicit data types.   Instead, pre-definedtypes are declared in package Standard.
Sometimes people will try to evaluate a
language by counting the number ofreserved words.  This is a silly metric andthe intelligent student will select moresubstantive criteria.
Some Ada reserved words are overloaded
with more than one meaning, depending oncontext.  The compiler will not let you makea mistake in the use of a reserved word.
Package Standard is the implied
parent of every other Ada package.
It does not need a with clause or a
use clause.   Every element of
package Standard is always visibleto every part of every Adaprogram.
This package defines the types,
Integer, Boolean, Float, Character,String, Duration. It also definestwo subtypes, Natural and Positive.
All numeric types are
implementation dependent.Therefore, do not use predefinednumeric types in your Adaprogram designs. Instead, defineyour own numeric types withproblem-based constraints.
Note:   Parameter and return types
are Integer'Base rather than Integer.package Standard is always in scope .  Every entity is directly vi sible to every part of an Ada
program.  Think of it as the root parent of ever y other packa ge in an y Ada program.The reserved words in blue are for concurrency and tasking.
Be careful when usin g the words in red.
Ada Distilled   by Richard Riehle
Page 93 of 113-- function  "rem" (Left, Right : Integer'Base) return Integer'Base;
-- function  "mod" (Left, Right : Integer'Base) return Integer'Base;
-- function  "**"  (Left : Integer'Base; Right : Natural) return Integer'Base;
          
-- The floating point type root_real is predefined ; The corresponding universal type is universal_real .
type Float is digits  implementation-defined ;
-- The predefined operators fo r this type are as follows :
-- function  "="   (Left, Right : Float) return Boolean;
-- function  "/="  (Left, Right : Float) return Boolean;
-- function  "<"   (Left, Right : Float) return Boolean;
-- function  "<="  (Left, Right : Float) return Boolean;
-- function  ">"   (Left, Right : Float) return Boolean;
-- function  ">="  (Left, Right : Float) return Boolean;
-- function  "+"   (Right : Float) return Float;
-- function  "–"   (Right : Float) return Float;
-- function  "abs" (Right : Float) return Float;
-- function  "+"   (Left, Right : Float) return Float;
-- function  "–"   (Left, Right : Float) return Float;
-- function  "*"   (Left, Right : Float) return Float;
-- function  "/"   (Left, Right : Float) return Float;
-- function  "**"  (Left : Float; Right : Integer'Base) return Float;
-- In  addition,  the  following operators are predefined for the root numeric types :
function  "*" (Left : root_integer; Right : root_real) return root_real;
function  "*" (Left : root_real;    Right : root_integer) return root_real;
function  "/" (Left : root_real;    Right : root_integer) return root_real;
-- The type universal_fixed is predefined .
-- The only multiplying operators defined  between fixed point types are :
function  "*" (Left : universal_fixed ; Right : universal_fixed )
return universal_fixed ;
function  "/" (Left : universal_fixed ; Right : universal_fixed )
return universal_fixed ;
-- The declaration of type Character is based on the standard ISO 8859-1 character set .
-- There are no character literals correspondi ng to the positions forcontrol characters .
-- They are indicated in italics in  this definition.  See 3.5.2 .
type Character  is
(nul, soh, stx, etx, eot, enq, ack, bel , --  0  (16#00#) ..   7 (16#07#)
 bs,  ht,  lf,  vt,  ff,  cr,  so,  si , --  8 (16#08#) .. 15 (16#0F#)
 dle, dc1, dc2, dc3, dc4, nak, syn, etb , -- 16 (16#10#) .. 23 (16#17#)
 can, em,  sub, esc, fs,  gs,  rs,  us , -- 24 (16#18#) .. 31 (16#1F#)
' ', '!', '"', '#', '$', '%', '&', ''', -- 32 (16#20#) .. 39 (16#27#)
'(', ')', '*', '+', ',' ,'-', '.', '/', -- 40 (16#28#) .. 47 (16#2F#)
'0', '1', '2', '3', '4', '5', '6', '7', -- 48 (16#30#) .. 55 (16#37#)
'8', '9', ':', ';', '<', '=', '>', '?', -- 56 (16#38#) .. 63 (16#3F#)
'@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', -- 64 (16#40#) .. 71 (16#47#)
'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', -- 72 (16#48#) .. 79 (16#4F#)
'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', -- 80 (16#50#) .. 87 (16#57#)
'X', 'Y', 'Z', '[', '\', ']', '^', '_', -- 88 (16#58#) .. 95 (16#5F#)
'`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', -- 96 (16#60#) .. 103 (16#67#)
'h', 'I', 'j', 'k', 'l', 'm', 'n', 'o', -- 104 (16#68#) .. 111 (16#6F#)
'p', 'q', 'r', 's', 't', 'u', 'v', 'w', -- 112 (16#70#) .. 119 (16#77#)
'x', 'y', 'z', '{', '|', '}', '~', del, -- 120 (16#78#) .. 127 (16#7F#)
reserved_128, reserved_129, bph, nbh,  -- 128 (16#80#) .. 131 (16#83#)
reserved_132, nel, ssa, esa,  -- 132 (16#84#) .. 135 (16#87#)
hts, htj, vts, pld, plu, ri, ss2, ss3,  -- 136 (16#88#) .. 143 (16#8F#)
dcs, pu1, pu2, sts, cch, mw, spa, epa,  -- 144 (16#90#) .. 151 (16#97#)
sos, reserved_153, sci, csi,  -- 152 (16#98#) .. 155 (16#9B#)
st, osc, pm, apc,  -- 156 (16#9C#) .. 159 (16#9F#)
' ', '¡', '¢', '£', '¤', '¥', '¦', '§' -- 160 (16#A0#) .. 167 (16#A7#)
'¨', '©', 'ª', '«', '¬', '-', '®', '¯' -- 168 (16#A8#) .. 175 (16#AF#)
'°', '±', '²', '³', '´', 'µ', '¶', '·' -- 176 (16#B0#) .. 183 (16#B7#)
'¸','¹', 'º', '»', '¼', '½', '¾', '¿' -- 184 (16#B8#) .. 191 (16#BF#)Warning:
Do not use predefined Float frompackage Standard in your productionprograms.   This type is useful forstudent programs but is not well-suitedto portable softwa re targeted to some
actual production application.
See also :
package  Ada.Characters
package  Ada.Characters.Latin_1
package  Ada.Characters.HandlingNote :  Fixed point arithmetic on root types
and universal fixed-poi nt types is defined
here.  See also ALRM 4.5.5/16-20
Characters beyondthe normal 7 bitASCII format nowuse 8 bits.  Also seeWide-Character
Ada Distilled   by Richard Riehle
Page 94 of 113'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç' -- 192 (16#C0#) .. 199 (16#C7#)
'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï' -- 200 (16#C8#) .. 207 (16#CF#)
'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×' -- 208 (16#D0#) .. 215 (16#D7#)
'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß' -- 216 (16#D8#) .. 223 (16#DF#)
'à', 'á', 'â', 'ã', 'ä', 'å', 'æ', 'ç' -- 224 (16#E0#) .. 231 (16#E7#)
'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï' -- 232 (16#E8#) .. 239 (16#EF#)
'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷' -- 240 (16#F0#) .. 247 (16#F7#)
'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ' -- 248 (16#F8#) .. 255 (16#FF#)
-- The predefined operators for the type Characte r are the same as for any enumeration type .
-- The declaration of type Wide_Character is based on the standard ISO 10646 BMP character set .
-- The first 256 positions have the same conten ts as type Character.  See 3.5.2 .
type Wide_Character  is (nul, soh  ... FFFE, FFFF);
package ASCII is ... end ASCII;  -- Obsolescent; see J.5
-- Predefined string types :
type String is array (Positive range <>) of Character;
pragma Pack(String);
-- The predefined operators for this type are as follows :
--   function  "="  (Left, Right: String) return Boolean;
--   function  "/=" (Left, Right: String) return Boolean;
--   function  "<"  (Left, Right: String) return Boolean;
--   function  "<=" (Left, Right: String) return Boolean;
--   function  ">"  (Left, Right: String) return Boolean;
--   function  ">=" (Left, Right: String) return Boolean;
--   function  "&" (Left: String;    Right: String)    return String;
--   function  "&" (Left: Character; Right: String)    return String;
--   function  "&" (Left: String;    Right: Character) return String;
--   function  "&" (Left: Character; Right: Character) return String;
type Wide_String is array (Positive range <>) of Wide_Character;
pragma Pack(Wide_String);
-- The predefined operators for Wide_String correspond to those for String
type Duration  is delta implementation-defined range implementation-defined ;
-- The predefined operators for the type Duration are the same as forany fixed point type .
-- The predefined exceptions :
Constraint_Error: exception ;
Program_Error   : exception ;
Storage_Error   : exception ;
Tasking_Error   : exception ;
end Standard;
A.2 The Package Ada
package  Ada is
pragma  Pure(Ada);
end AdaThis is equivalent to Unicode.  Can be used for
internationalization of a lan guage implementation.
Strings of with the same constraint cantake advantage of these operators.
This operator is used to catenatearrays to arrays, arrays tocomponents, etc.   It is defined forany kind of array as well as forpredefined type Strring
Used in delay statements in tasking.  Seedata types in package Calendar, ALRM 9.6
These exceptions are predefin ed in this package.   A designer may define more
exceptions.  Note the absen ce of Numeric_Error, which is now obsolescent in the
current standard.
package Ada is the parent package for many of the library units.  It has no type
definitions and no operations.  It is not hing more than a placeholder packge that
provides a common root (common ancestor) for all of its descendants.  As you learnmore about parent and child packages, you will understand the value for having one
package that is a common root.
The expression, pragma Pure (Ada), is a compiler directive.  Pragmas are compiler
directives.   This directive is of little interest to you at this  stage of your study. It will be
very important when you being developing la rger software systems, especially those
that require the Distributed Systems Annex (Annex E).
Ada Distilled   by Richard Riehle
Page  95 of 113package Numerics
This is the root package for a variety of numerics packages.
package Ada.Numerics is
pragma Pure(Numerics);
Argument_Error : exception ;
Pi : constant  := 3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37511;
e  : constant  := 2.71828_18284_59045_23536_02874_71352_66249_77572_47093_69996;
end Ada.Numerics;
A.5.1 Elementary Functions
Elementary functions are defined as a generic package.   This means it must be instantiated before it can be
used.   Note also that trigonometric functions are in radians.   Also, the function "**" is an operator thatmust be made directly visible before it can be us ed.  We recommend renaming it in the scope where it is
required.     Also, note that the parameters and retu rn type are Float_Type'Base.  This reduces any overflow
problems associated with intermediate results in extended expressions.
generic
type Float_Type is digits  <>;
package Ada.Numerics.Generic_Elementary_Functions is
pragma Pure(Generic_Elementary_Functions);
function  Sqrt    (X           : Float_Type'Base)        return Float_Type'Base;
function  Log     (X           : Float_Type'Base)        return Float_Type'Base;
function  Log     (X, Base     : Float_Type'Base)        return Float_Type'Base;
function  Exp     (X           : Float_Type'Base)        return Float_Type'Base;
function  "**"    (Left, Right : Float_Type'Base)        return Float_Type'Base;
-- Trigonometric functions default in Radians
function  Sin     (X           : Float_Type'Base)        return Float_Type'Base;
function  Sin     (X, Cycle    : Float_Type'Base)        return Float_Type'Base;
function  Cos     (X           : Float_Type'Base)        return Float_Type'Base;
function  Cos     (X, Cycle    : Float_Type'Base)        return Float_Type'Base;
function  Tan     (X           : Float_Type'Base)        return Float_Type'Base;
function  Tan     (X, Cycle    : Float_Type'Base)        return Float_Type'Base;
function  Cot     (X           : Float_Type'Base)        return Float_Type'Base;
function  Cot     (X, Cycle    : Float_Type'Base)        return Float_Type'Base;
function  Arcsin  (X           : Float_Type'Base)        return Float_Type'Base;
function  Arcsin  (X, Cycle    : Float_Type'Base)        return Float_Type'Base;
function  Arccos  (X           : Float_Type'Base)        return Float_Type'Base;
function  Arccos  (X, Cycle    : Float_Type'Base)        return Float_Type'Base;
function  Arctan  (Y           : Float_Type'Base;
                     X           : Float_Type'Base := 1.0) return Float_Type'Base;
function  Arctan  (Y           : Float_Type'Base;
                  X           : Float_Type'Base := 1.0;
                  Cycle       : Float_Type'Base)        return Float_Type'Base;
function  Arccot  (X           : Float_Type'Base;
                  Y           : Float_Type'Base := 1.0) return Float_Type'Base;
function  Arccot  (X           : Float_Type'Base;
                  Y           : Float_Type'Base := 1.0;
                  Cycle       : Float_Type'Base)        return Float_Type'Base;
function  Sinh    (X           : Float_Type'Base)        return Float_Type'Base;
function  Cosh    (X           : Float_Type'Base)        return Float_Type'Base;
function  Tanh    (X           : Float_Type'Base)        return Float_Type'Base;
function  Coth    (X           : Float_Type'Base)        return Float_Type'Base;
function  Arcsinh (X           : Float_Type'Base)        return Float_Type'Base;
function  Arccosh (X           : Float_Type'Base)        return Float_Type'Base;
function  Arctanh (X           : Float_Type'Base)        return Float_Type'Base;
function  Arccoth (X           : Float_Type'Base)        return Float_Type'Base;
end Ada.Numerics.Generic_Elementary_Functions;For the ** function,
you may have avisibility problem.You can solve it byrenaming it locallyafter instantiating thepackage.
If cycle is notsupplied, the defaultis in radians.Log default base isnatural (e).  The basemay be other than e.
Float_Type'Basepermits anunconstrained resultthat will not raise aconstraint errorduring intermediateoperations. Thiseliminates spuriousrange constraintviolations in complexexpressions.
Ada Distilled   by Richard Riehle
Page 96 of 113A.10 Ada.Text_IO  (Annotated)
with Ada.IO_Exceptions; -- Declared in Annex A  of the Ada Language Reference Manual
package Ada.Text_IO is  -- Converts human-readable text to machin e-readable as well as standard input/output
type File_Type is limited private ;                      -- Internal file handle for a program
type File_Mode is (In_File, Out_File, Append_File);     -- Controls direction of data flow
type Count is range 0 .. implementation-defined ;         -- An integer data type;  see Positive_Count
subtype Positive_Count is Count range 1 .. Count'Last;  -- May be used with type Count
Unbounded : constant  Count := 0;                        -- line and page length
subtype Field       is Integer range 0 .. implementation-defined ; -- Varies by platform .
subtype Number_Base is Integer range 2 .. 16;           -- Only use: 2, 8, 10 and 16
type Type_Set is (Lower_Case, Upper_Case);              -- Use this for enumerated types
-- File Management
procedure  Create (File : in out File_Type;              -- Program refers to this parameter
                  Mode : in File_Mode := Out_File;      -- Almost always an output file
                  Name : in String    := "";            -- The external name for the file
                  Form : in String    := "");           -- Usage not defined by the language
procedure  Open   (File : in out File_Type;
                  Mode : in File_Mode;     -- May be opened for input or for append
                  Name : in String;
                  Form : in String := "");  -- Form is rarely used in Ada 95.  Compiler dependent .
procedure  Close  (File : in out File_Type); -- Pretty much what youwould think this would do
procedure  Delete (File : in out File_Type);
procedure  Reset  (File : in out File_Type; Mode : in File_Mode);  -- Resets the mode of the fil e
procedure  Reset  (File : in out File_Type);                       -- Resets the mode of the file
function   Mode   (File : in File_Type) return File_Mode; -- Query the mode of a file
function   Name   (File : in File_Type) return String;    -- Query the external name of a file
function   Form   (File : in File_Type) return String;    -- Varies by compiler implementation
function   Is_Open(File : in File_Type) return Boolean;   -- Query the open status of a file
-- Control of default input and output files
procedure  Set_Input (File : in File_Type); -- Set this file as the default input file; must be open
procedure  Set_Output(File : in File_Type); -- Set this file as the default ouput file; must be open
procedure  Set_Error (File : in File_Type); -- Use this as the standard error file; must be open
function  Standard_Input  return File_Type; -- Standard input is usually a keyboard
function  Standard_Output return File_Type; -- Standard output is usually a video display terminal
function  Standard_Error  return File_Type;
function  Current_Input   return File_Type; -- Usually the same as Standard Input
function  Current_Output  return File_Type;
function  Current_Error   return File_Type;
type File_Access is access constant  File_Type; -- Enable a pointer value to a file handle
function  Standard_Input  return File_Access;
function  Standard_Output return File_Access;
function  Standard_Error  return File_Access;
function  Current_Input   return File_Access;
function  Current_Output  return File_Access;
function  Current_Error   return File_Access;
-- Buffer control
procedure  Flush (File : in out File_Type); -- Flushes any internal buffers
procedure  Flush; -- Flush synchronizes internal file with ext ernal file by Flushing internal buffers
-- Specification of line and page lengths
procedure  Set_Line_Length(File : in File_Type; To : in Count);
procedure  Set_Line_Length(To   : in Count);
procedure  Set_Page_Length(File : in File_Type; To : in Count);
procedure  Set_Page_Length(To   : in Count);
function   Line_Length(File : in File_Type) return Count;
function   Line_Length return Count;
function   Page_Length(File : in File_Type) return Count;
function   Page_Length return Count;
-- Column, Line, and Page ControlText_IO enables machine-readable data to be forma tted as human-readable data and human-readable data to
be conveted to machine-readable.   For character and string types, no conversion from internal to external
format is required.  For all other ty pes, transformations shoul d be done with Text_IO;   Some operations are
overloaded.  Overloading is most common when there are two file destinations for an action: a named file or
default standard file.
Access to File_Type has been added to Ada 95 version
of Text_IO.  This turns out to be quite useful for manysituations.   Since file type is a limited private type,assignment is impossible.  However, assignment ispossible on an access value (value of an access type).
Note :  You may use Count instead of
Positive_Count but be careful of potentialconstraint error.Note  overloading of
subprogram namesfrom this  point on.
Ada Distilled   by Richard Riehle
Page 97 of 113procedure  New_Line   (File    : in File_Type;            -- Carriage return/Line Feed for a File
                      Spacing : in Positive_Count := 1); -- Default to 1 unless otherwise called
procedure  New_Line   (Spacing : in Positive_Count := 1); -- CR/LF on the default output device
procedure  Skip_Line  (File    : in File_Type;            -- Discard characters up to line terminator
                      Spacing : in Positive_Count := 1); -- single line by default
procedure  Skip_Line  (Spacing : in Positive_Count := 1); -- single line by default
function   End_Of_Line(File : in File_Type) return Boolean; -- Are we at the end of a line?
function   End_Of_Line return Boolean;                      -- Are we at the end of a line?
procedure  New_Page   (File : in File_Type); -- Terminate current page with page terminator
procedure  New_Page;
procedure  Skip_Page  (File : in File_Type); -- Discard characters to end of page
procedure  Skip_Page;
function   End_Of_Page(File : in File_Type) return Boolean; -- Is this the end of a page?
function   End_Of_Page return Boolean;
function   End_Of_File(File : in File_Type) return Boolean; -- Is this the end of file?
function   End_Of_File return Boolean;
procedure  Set_Col (File : in File_Type; To : in Positive_Count); -- Cursor to designated col
procedure  Set_Col (To   : in Positive_Count); -- Do not set this to a number less than current Col
procedure  Set_Line(File : in File_Type; To : in Positive_Count); -- Cursor to designated line
procedure  Set_Line(To   : in Positive_Count); -- Must be value greater than current Line
function  Col (File : in File_Type) return Positive_Count; -- What column number in file?
function  Col  return Positive_Count;                      -- What column number?
function  Line(File : in File_Type) return Positive_Count; -- What line number in file?
function  Line return Positive_Count;                      -- What line number?
function  Page(File : in File_Type) return Positive_Count; -- What page number in file?
function  Page return Positive_Count;                      -- What page number?
-- Character Input-Output
procedure  Get(File : in  File_Type; Item : out Character); -- Gets single character from file
procedure  Get(Item : out Character);                       -- Gets single character from keyboard
procedure  Put(File : in  File_Type; Item : in Character);  -- Put single character; no CR/LF
procedure  Put(Item : in  Character);                       -- Put never emits CR/LF
procedure  Look_Ahead (File        : in  File_Type; -- Item set to next character without
                      Item        : out Character; -- consuming it .
                      End_Of_Line : out Boolean);  -- True if End of Line/End of Page/End of File
procedure  Look_Ahead (Item        : out Character; -- What is next character; don't get it yet
                      End_Of_Line : out Boolean);
procedure  Get_Immediate(File      : in  File_Type;  -- Get the next character without CR/LF
                        Item      : out Character); -- Wait until character is available
procedure  Get_Immediate(Item      : out Character); -- Wait until character is available
procedure  Get_Immediate(File      : in  File_Type; -- Only get character if it is available
                        Item      : out Character;
                        Available : out Boolean);  -- False if character is not available
procedure  Get_Immediate(Item      : out Character;
                        Available : out Boolean);  -- False if character is not available
-- String Input-Output
procedure  Get(File : in  File_Type; Item : out String); -- Get fixed sized string
procedure  Get(Item : out String); -- Must enter entire string of size specified
procedure  Put(File : in  File_Type; Item : in String); -- Output string;  no CR/LF
procedure  Put(Item : in  String); -- No carriage return/line feed character
procedure  Get_Line(File : in  File_Type; -- String will vary in size based on value of Last
                   Item : out String;    -- Must be large enough to hold all characters of input
                   Last : out Natural);  -- Number of characters up to line terminator (CR/LF)
procedure  Get_Line(Item : out String; Last : out Natural);
procedure  Put_Line(File : in  File_Type; Item : in String);
procedure  Put_Line(Item : in  String); -- Include carriage return/line feed character
-- Generic packages for Input-Output of any type of signed integerFollowing is a set of generic input/output packages nested within Ada.Text_IO
Ada Distilled   by Richard Riehle
Page 98 of 113-- Consider Ada.Integer_Text_IO  for standard Integer; you can with that pack age and get the same result for type Integer.
generic
type Num is range  <>;   -- Generic formal paramter for sikgned numeric integer type
package Integer_IO is     -- Conversion between human-readable t ext and internal number format .
Default_Width : Field := Num'Width;   -- How big is the number going to be?
Default_Base  : Number_Base := 10;    -- See the options for number base in beginning of Text_IO
procedure  Get(File  : in  File_Type;
              Item  : out Num;        -- Corresponds to generic formal parameter, above
              Width : in Field := 0); -- May specify exact number of input characters .
procedure  Get(Item  : out Num;
              Width : in  Field := 0); -- Should usually leave this as zero
procedure  Put(File  : in File_Type;   -- The file type is the internal handle for the file
              Item  : in Num;         -- Corresponds to generic formal parameter, above
              Width : in Field := Default_Width; -- Ordinarily, don't change this
              Base  : in Number_Base := Default_Base);
procedure  Put(Item  : in Num;
              Width : in Field := Default_Width;
              Base  : in Number_Base := Default_Base);
procedure  Get(From : in  String;      -- 10.2.1 of this book, line 56 for an example of this
              Item : out Num;         -- The actual numeric value of the string
              Last : out Positive);   -- Index value of last character in From
procedure  Put(To   : out String;      -- 10.2.2 of this book, line 41 for an example of this
              Item : in Num;          -- Can raise a data error, or other IO_Error. Check this first.
              Base : in Number_Base := Default_Base); -- Consider output in other than base ten .
end Integer_IO;
generic
type Num is mod <>; -- Generic formal paramter for unsigned numeric type.  See ALRM 3.5.4/10
package Modular_IO is
Default_Width : Field := Num'Width;
Default_Base  : Number_Base := 10;
procedure  Get(File  : in  File_Type;
              Item  : out Num;
              Width : in Field := 0);
procedure  Get(Item  : out Num;  Width : in  Field := 0);
procedure  Put(File  : in File_Type;
              Item  : in Num;
              Width : in Field := Default_Width;
              Base  : in Number_Base := Default_Base);
procedure  Put(Item  : in Num;
              Width : in Field := Default_Width;
              Base  : in Number_Base := Default_Base);
procedure  Get(From : in  String;
              Item : out Num;
              Last : out Positive);
procedure  Put(To   : out String;
              Item : in Num; -- Get a string from an float type; convert float type to string
              Base : in Number_Base := Default_Base);
end Modular_IO;
-- Generic packages for Input -Output of Real Types
generic
type Num is digits  <>;  -- Generic formal paramter for floating point numeric type;  ALRM 3.5.7
package Float_IO is
Default_Fore : Field := 2;             -- Number of  Positions to left of decimal point
Default_Aft  : Field := Num'Digits–1;  -- Number of  Positions to right of decimal point
Default_Exp  : Field := 3;             -- For scientific notation; often zero is OK
procedure  Get(File  : in  File_Type;
              Item  : out Num;
              Width : in  Field := 0); -- May specify exact width; usually don't; leave as zero
procedure  Get(Item  : out Num;
              Width : in  Field := 0);
procedure  Put(File : in File_Type;
              Item : in Num;
              Fore : in Field := Default_Fore; -- Number of  Positions to left of decimal point
              Aft  : in Field := Default_Aft;  -- Number of  Positions to right of decimal pointModular_IO is new to Ada 95 and applies
to a new Modular data type.
A Modular type is unsigned and has
wraparound arithmetic semantics.  It isespecially useful for array indexes insteadof a signed integer type.
Ada Distilled   by Richard Riehle
Page 99 of 113              Exp  : in Field := Default_Exp); -- Set this to zero if you don't want scientific notation
procedure  Put(Item : in Num;
              Fore : in Field := Default_Fore; -- Number of  Positions to left of decimal point
              Aft  : in Field := Default_Aft;  -- Number of  Positions to right of decimal point
              Exp  : in Field := Default_Exp); -- Set this to zero if you don't want scientific notation
-- Use these procedures to convert a floating-point valu e to a string or a string to a floating-point value
procedure  Get(From : in String;   -- Get floating point value from a string value
              Item : out Num;     -- Converts a valid floating point string to a float value
              Last : out Positive);
procedure  Put(To   : out String;  -- Write a floating point value into an internal string
              Item : in Num;      -- Converts a  floating point value to a variable of type String
              Aft  : in Field := Default_Aft;  -- Number of  Positions to right of decimal point
              Exp  : in Field := Default_Exp); -- Set this to zero if you don't want scientific notation
end Float_IO;
generic
type Num is delta  <>;   -- Generic formal paramter for fixed point numeric types
package Fixed_IO is       -- Input/Output of fixed point numeric types
Default_Fore : Field := Num'Fore;
Default_Aft  : Field := Num'Aft; -- Number of  Positions to right of decimal point
Default_Exp  : Field := 0;
procedure  Get(File  : in  File_Type;
              Item  : out Num;
              Width : in  Field := 0);
procedure  Get(Item  : out Num;
              Width : in  Field := 0);
procedure  Put(File : in File_Type;
              Item : in Num;
              Fore : in Field := Default_Fore; -- Number of  Positions to left of decimal point
              Aft  : in Field := Default_Aft;  -- Number of  Positions to right of decimal point
              Exp  : in Field := Default_Exp); -- Set this to zero if you don't want scientific notation
procedure  Put(Item : in Num;
              Fore : in Field := Default_Fore; -- Number of  Positions to left of decimal point
              Aft  : in Field := Default_Aft;  -- Number of  Positions to right of decimal point
              Exp  : in Field := Default_Exp); -- Set this to zero if you don't want scientific notation
-- Use these procedures to convert a fixed-point valu e to a string or a string to a fixed-point value
procedure  Get(From : in  String;
              Item : out Num;
              Last : out Positive);
procedure  Put(To   : out String;
              Item : in Num;
              Aft  : in Field := Default_Aft;  -- Number of  Positions to right of decimal point
              Exp  : in Field := Default_Exp); -- Set this to zero if you don't want scientific notation
end Fixed_IO;
generic
type Num is delta <> digits <>; -- Generic formal paramter for decimal numeric type
package Decimal_IO is             -- Decimal types are used for financial computing .
Default_Fore : Field := Num'Fore;
Default_Aft  : Field := Num'Aft;Default_Exp  : Field := 0;
procedure  Get(File  : in  File_Type;
              Item  : out Num;
              Width : in  Field := 0);
procedure  Get(Item  : out Num;
              Width : in  Field := 0);
procedure  Put(File : in File_Type;
              Item : in Num;
              Fore : in Field := Default_Fore;
              Aft  : in Field := Default_Aft;
              Exp  : in Field := Default_Exp);
procedure  Put(Item : in Num;
              Fore : in Field := Default_Fore;
              Aft  : in Field := Default_Aft;
              Exp  : in Field := Default_Exp);
-- Use these procedures to conver t a decimal value to a string or a string to a decimal valueSee:  ALRM Annex F
         ALRM 3.5.9/4,  ALRM 3.5.9/16
A decimal type is a special kind of fixed-point
type in which the delta must be a power of ten.This is unlike a normal fixed point type wherethe granluarity is a power of two.
Decimal types are more accurate for monetary
applications and others that can be best servedusing power of ten decimal fractions.
Ada Distilled   by Richard Riehle
Page 100 of 113procedure  Get(From : in  String;
              Item : out Num;
              Last : out Positive);
procedure  Put(To   : out String;
              Item : in Num;
              Aft  : in Field := Default_Aft;  -- see type defined above
              Exp  : in Field := Default_Exp); -- see type defined above
end Decimal_IO;
-- Generic package for Input-Out put of Enumeration Types
generic
type Enum is (<>);  -- Actual must be a discrete type
package Enumeration_IO is
Default_Width   : Field := 0;
Default_Setting : Type_Set := Upper_Case;
procedure  Get(File : in  File_Type;
              Item : out Enum);
procedure  Get(Item : out Enum);
procedure  Put(File  : in File_Type;
              Item  : in Enum;
              Width : in Field    := Default_Width;
              Set   : in Type_Set := Default_Setting);
procedure  Put(Item  : in Enum;
              Width : in Field    := Default_Width;
              Set   : in Type_Set := Default_Setting);
-- Use these procedures to convert a enumerated valu e to a string or a string to a enumerated value
procedure  Get(From : in  String;
              Item : out Enum;
              Last : out Positive);
procedure  Put(To   : out String;
              Item : in  Enum;
              Set  : in  Type_Set := Default_Setting); -- see type defined above
end Enumeration_IO;
-- Input-Output Exceptions
Status_Error : exception  renames IO_Exceptions.Status_Error;
Mode_Error   : exception  renames IO_Exceptions.Mode_Error;
Name_Error   : exception  renames IO_Exceptions.Name_Error;
Use_Error    : exception  renames IO_Exceptions.Use_Error;      -- from package IO_Exceptions
Device_Error : exception  renames IO_Exceptions.Device_Error;
End_Error    : exception renames  IO_Exceptions.End_Error;
Data_Error   : exception renames  IO_Exceptions.Data_Error;
Layout_Error : exception renames  IO_Exceptions.Layout_Error;
private
... -- not specified by the language
end Ada.Text_IO;An enumerated type is an ordered set of
values for a named type.  Example:
type Color is (Red, Yellow, Blue);
type Month is (Jan, Feb,.., Dec)
           ... is not legal Ada
type Day is (Monday, Tuesday, ...);
type Priorit y is (Low, Medium , High);
Ada Distilled   by Richard Riehle
Page 101 of 113Ada.Streams.Stream_IO
with Ada.IO_Exceptions;
package Ada.Streams.Stream_IO is
type Stream_Access is access all  Root_Stream_Type'Class;
type File_Type is limited private ;
type File_Mode is (In_File, Out_File, Append_File);
type Count is range  0 .. implementation-defined ;
subtype Positive_Count is Count range 1 .. Count'Last;
-- Index into file, in stream elements .
procedure  Create (File : in out File_Type;
                  Mode : in File_Mode := Out_File;
                  Name : in String    := "";
                  Form : in String    := "");
procedure  Open (File : in out File_Type;
                Mode : in File_Mode;
                Name : in String;
                Form : in String := "");
procedure  Close  (File : in out File_Type);
procedure  Delete (File : in out File_Type);
procedure  Reset  (File : in out File_Type; Mode : in File_Mode);
procedure  Reset  (File : in out File_Type);
function  Mode (File : in File_Type) return File_Mode;
function  Name (File : in File_Type) return String;
function  Form (File : in File_Type) return String;
function  Is_Open     (File : in File_Type) return Boolean;
function  End_Of_File (File : in File_Type) return Boolean;
function  Stream (File : in File_Type) return Stream_Access;
-- Return stream access for use with T’Input and T’Output
-- Read array of stream elements from file
procedure  Read (File : in  File_Type;
                Item : out Stream_Element_Array;
                Last : out Stream_Element_Offset;
                From : in  Positive_Count);
procedure  Read (File : in  File_Type;
                Item : out Stream_Element_Array;
                Last : out Stream_Element_Offset);
-- Write array of stream elements into file
procedure  Write (File : in File_Type;
                 Item : in Stream_Element_Array;
                 To   : in Positive_Count);
procedure  Write (File : in File_Type;
                 Item : in Stream_Element_Array);
-- Operations on position within file
procedure  Set_Index(File : in File_Type; To : in Positive_Count);
function  Index(File : in File_Type) return Positive_Count;
function  Size (File : in File_Type) return Count;
procedure  Set_Mode(File : in out File_Type; Mode : in File_Mode);
procedure  Flush(File : in out File_Type);
-- Exceptions
Status_Error : exception renames  IO_Exceptions.Status_Error;
Mode_Error   : exception renames  IO_Exceptions.Mode_Error;
Name_Error   : exception renames  IO_Exceptions.Name_Error;
Use_Error    : exception renames  IO_Exceptions.Use_Error;
Device_Error : exception renames  IO_Exceptions.Device_Error;
End_Error    : exception renames  IO_Exceptions.End_Error;
Data_Error   : exception renames  IO_Exceptions.Data_Error;
private
... -- not specified by the language
end Ada.Streams.Stream_IO;
Ada.Calendar     -- ALRM 9..6 (also  See ALRM, Annex D. 8 for Ada.Real-Time calendar package)Permits input/ouput of data in terms of System.Storage_Unit.
Use this with attributes: S'Input, S'Output, S'Read, S'Write.This package makes it possible to store a tag of a tagged typealong with the rest of the data in the object.
Note the consistency of this packagewith other input-output packages
Supports direct_IO on
stream items
Ada Distilled   by Richard Riehle
Page 102 of 113package  Ada.Calendar is --  1
type Time is private ; --  2  Encapsulated; use public methods
subtype  Year_Number  is Integer range  1901 ..  2099; --  3 Ada has always been Y2K  compliant
subtype  Month_Number is Integer range  1 ..  12; --  4
subtype  Day_Number   is Integer range  1 ..  31; --  5
subtype  Day_Duration is Duration range  0.0 ..  86_400.0; --  6  Total number of seconds in one day
function  Clock return  Time; --  7  Gets the current clock time
function  Year   (Date : Time) return  Year_Number; --  8
function  Month  (Date : Time) return  Month_Number; --  9
function  Day    (Date : Time) return  Day_Number; -- 10
function  Seconds(Date : Time) return  Day_Duration; -- 11
procedure  Split (Date    : in Time; -- 12
                 Year    : out Year_Number; -- 13
                 Month   : out Month_Number; -- 14
                 Day     : out Day_Number; -- 15
                 Seconds : out Day_Duration); -- 16
    function  Time_Of(Year    : Year_Number; -- 17
                 Month   : Month_Number; -- 18                 Day     : Day_Number; -- 19
                 Seconds : Day_Duration := 0.0) return  Time; -- 20
-- 21
function  "+" (Left : Time;   Right : Duration) return  Time; -- 22
function  "+" (Left : Duration; Right : Time) return  Time; -- 23
function  "–" (Left : Time;   Right : Duration) return  Time; -- 24
function  "–" (Left : Time;   Right : Time) return  Duration; -- 25
      function  "<" (Left, Right : Time) return  Boolean; -- 26
function  "<="(Left, Right : Time) return  Boolean; -- 27
function  ">" (Left, Right : Time) return  Boolean; -- 28
function  ">="(Left, Right : Time) return  Boolean; -- 29
Time_Error : exception ; -- 30
private -- 31
... -- not specified by the language -- 32
end Ada.Calendar; -- 33type Duration is defined in
package Standard
Ada Distilled   by Richard Riehle
Page 103 of 113System Description Package
package  System is --   1 Required for every compiler
pragma  Preelaborate(System); --   2 Elaborate at compile time
type Name is implementation-defined-enumeration-type; --   3 Look this up for your compiler
System_Name : constant  Name := implementation-defined ; --   4
-- System-Dependent Named Numbers : --   5
Min_Int                              : constant  := root_integer'First; --   6 root integer is base type
Max_Int                              : constant  := root_integer'Last; --   7 for all integers in this system
Max_Binary_Modulus       : constant  := implementation-defined ; --   8
Max_Nonbinary_Modulus : constant  := implementation-defined ; --   9
Max_Base_Digits              : constant  := root_real'Digits; -- 10
Max_Digits                        : constant  := implementation-defined ; -- 11
Max_Mantissa                   : constant  := implementation-defined ; -- 12
Fine_Delta                         : constant  := implementation-defined ; -- 13
Tick                                   : constant  := implementation-defined ; -- 14
-- Storage-related Declarations : -- 15
type Address is implementation-defined ; -- 16 Usually a private type
Null_Address : constant  Address; -- 17
Storage_Unit : constant  := implementation-defined ; -- 18
Word_Size    : constant  := implementation-defined  * Storage_Unit; -- 19
Memory_Size  : constant  := implementation-defined ; -- 20
Address Comparison -- 21
function  "<" (Left, Right : Address) return  Boolean; -- 22
function  "<="(Left, Right : Address) return  Boolean; -- 23
function  ">" (Left, Right : Address) return  Boolean; -- 24
function  ">="(Left, Right : Address) return  Boolean; -- 25
function  "=" (Left, Right : Address) return  Boolean; -- 26
--function  "/=" (Left, Right : Address) return  Boolean; -- 27
-- "/=" is implicitly defined -- 28
pragma  Convention(Intrinsic, "<"); -- 29
... -- and so on for all language-defined subprograms in this package -- 30
-- Other System-Dependent Declarations : -- 31
type Bit_Order is (High_Order_First, Low_Order_First);                                            -- 32 Big-endian/Little-endian
Default_Bit_Order : constant  Bit_Order; -- 33
-- Priority-related declarations (see D.1): -- 34
subtype  Any_Priority is Integer range  implementation-defined ; -- 35 Used for tasking
subtype  Priority is Any_Priority range  Any_Priority'First .. implementation-defined ;      -- 36
subtype  Interrupt_Priority is Any_Priority range  Priority'Last+1 .. Any_Priority'Last;     -- 37
Default_Priority : constant  Priority := (Priority'Fir st + Priority'Last)/2; -- 38
private -- 39
... -- not specified by the language -- 40
end System; -- 41Also see:   System.Storage_Elements
                 System.Address_To_Access_Conversion
                 System.Stora ge Pools
Arithmetic operators for type
Address are defined in packageSystem.Storage_Elements
An implementation may add more spec ifications and declarations to this
package to make it conformant w ith the underlying system platform .
Ada Distilled   by Richard Riehle
Page  104 of 113Annex L Pragmas - Language-defined Compiler Directives
Pragmas are Ada compiler directives.  The word pragma has th e same root as the word, pragmatic.  It orginates in a
Greek word which, roughly translated, means “Do this.”  Some  pragmas affect the process of compilation.  Others tell
the compiler about what elements bel ong in the Run-time Environment (RTE), a nd others restrict or expand the role
of of some language feature.
pragma  All_Calls_Remote[(library_unit_name)]; — See E.2.3.
pragma  Asynchronous(local_name); — See E.4.1.
pragma  Atomic(local_name); — See C.6.
pragma  Atomic_Components(array_local_name); — See C.6.
pragma  Attach_Handler(handler_name , expression); — See C.3.1.
pragma  Controlled(first_subtype_local_name); — See 13.11.3.
pragma  Convention([Convention =>]  convention_identifier,[Entity =>] local_name);
— See B.1.
pragma  Discard_Names[([On => ] local_name)]; — See C.5.
pragma  Elaborate(library_unit_name{, library_unit_name}); — See 10.2.1.
pragma  Elaborate_All(library_unit_name{, library_unit_name}); — See 10.2.1.
pragma  Elaborate_Body[(library_unit_name)]; — See 10.2.1.
pragma  Export( [Convention =>]  convention_identifier, [Entity =>] local_na me [, [External_Name  =>] string_expression]
[, [Link_Name =>] string_expression]); — See B.1.
pragma  Import( [Convention =>] conve ntion_identifier, [Entity =>] local_name [, [External_Name =>] string_expression]
[, [Link_Name =>] string_expression]); — See B.1.
pragma  Inline(name {, name}); — See 6.3.2.
pragma  Inspection_Point[(object_name {, object_name})]; — See H.3.2.
pragma  Interrupt_Handler(handler_name); — See C.3.1.
pragma  Interrupt_Priority[(expression)]; — See D.1.
pragma  Linker_Options(string_expression); — See B.1.
pragma  List(identifier); — See 2.8.
pragma  Locking_Policy(policy_identifier); — See D.3.
pragma  Normalize_Scalars; — See H.1.
pragma  Optimize(identifier); — See 2.8.
pragma  Pack(first_subtype_local_name); — See 13.2.
pragma  Page; — See 2.8.
pragma  Preelaborate[(library_unit_name)]; — See 10.2.1.
pragma  Priority(expression); — See D.1.
pragma  Pure[(library_unit_name)]; — See 10.2.1.
pragma  Queuing_Policy(policy_identifier); — See D.4.
pragma Remote_Call_Interface[(libra ry_unit_name)]; — See E.2.3.
pragma  Remote_Types[(library_unit_name)]; — See E.2.2.
pragma  Restrictions(restriction{, restriction}); — See 13.12.
pragma  Reviewable; — See H.3.1.
pragma  Shared_Passive[(library_unit_name)]; — See E.2.1.
pragma  Storage_Size(expression); — See 13.3.
pragma  Suppress(identifier [, [On =>] name]); — See 11.5.
pragma  Task_Dispatching_Policy(policy_identifier ); — See D.2.2.
pragma  Volatile(local_name); — See C.6.
pragma  Volatile_Components(array_local_name); — See C.6.
Ada Distilled   by Richard Riehle
Page  105 of 113Windows 95/98/NT/XP/ME/2000 Programming
NT_Console Package
This package can be used to format a window with colors, place a curs or wherever you wish,
and create character-based graphics on a Microsoft Windows console screen.  Youcan access all of the control characters, and y ou can print the characters defined in Annex A,
package Ada.Characters.Latin_1.   This package is required form implementing the tasking problems
shown in this book.
-----------------------------------------------------------------------
--
--  File:        nt_console.ads--  Description: Win95/NT console support--  Rev:         0.1--  Date:        18-jan-1998--  Author:      Jerry van Dijk    Mail:        jdijk@acm.org
----  Copyright (c) Jerry van Dijk, 1997, 1998--  Billie Holidaystraat 28 2324 LK  LEIDEN THE NETHERLANDS tel int + 31 71 531 43 65----  Permission granted to use for any purpose, provide d this copyright remains attached and unmodified.
----  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,-- WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-- PURPOSE.
-----------------------------------------------------------------------
package NT_Console is
-- TYPE DEFINITIONS  --
   subtype X_Pos is Natural range 0 .. 79;
   subtype Y_Pos is Natural range 0 .. 24;
   type Color_Type is (Black, Blue, Green, Cyan, Red, Magenta, Brown, Gray,
                       Light_Blue, Light_Green, Light_Cyan, Light_Red,
                       Light_Magenta, Yellow, White);
-- CURSOR CONTROL  --
   function  Where_X return X_Pos;
   function  Where_Y return Y_Pos;
   procedure  Goto_XY (X : in X_Pos := X_Pos'First;
                      Y : in Y_Pos := Y_Pos'First);
-- COLOR CONTROL  --
   function  Get_Foreground return Color_Type;
   function  Get_Background return Color_Type;
   procedure  Set_Foreground (Color : in Color_Type := Gray);
   procedure  Set_Background (Color : in Color_Type := Black);
-- SCREEN CONTROL  --
   procedure  Clear_Screen (Color : in Color_Type := Black);
-- SOUND  CONTROL --
   procedure  Bleep;
-- INPUT CONTROL  --Not a part of Ada, but a useful package for many
simple programs where formatting is required.
Ada Distilled   by Richard Riehle
Page 106 of 113   function  Get_Key return Character;
   function  Key_Available return Boolean;
-- EXTENDED PC KEYS  --  Provides access to upper eight bit scan-code  on a PC
                    --  Defined here is a list of special function keys available in
                                     --    Microsoft Operating Systems.  The fu ll list is in the p ackage specification
                                     --   but  we do not include here since they are seldom used .
Console_IO
This package is designed by Jerry Van Dijk and Richard Riehle.  The package body is written by Jerry.  It
is a more extensive and more robust version of NT_C onsole.  It is included with the software provided
with this book.   Console_IO is excellent for doing I/O on predefined types, formatting a screen, using
color, positioning a cursor exactly where you want it,  and accessing low-level scan codes in your program.
CLAW
This is a powerful set of libraries for programming in Microsoft Windows. Available at:
                 http://www.rrsoftware.com
GWindows
 This is a set of freeware windows development libraries created by David Botton. You can get this from:
                                     http://www.adapower.com
JEWL
By far the easiest library for deve loping elementary Windows programs.   This will not take you far in
building industrial strength Windows soft ware, but it will get you started.   This library set is particularly
useful if you are completely new to Windows programming.
GtkAda
A portable GUI development environment.   You can target Windows, Linux, Unix, and many othervariations on Windowing operating systems.   This is not an easy product to use,  but it is powerful enough
that you can do almost anything you might want to do.    However, if you are only targeting Microsoft,consider CLAW or GWindows.Each keypress on a standard PC keyboard generates a scan-code.  The scan-code is contained in an eight bit format that uniquely
identifies the format of th e keystroke.   The scan code is interpreted by th e combination of press and release of a keystroke.  The
PC's ROM-BIOS sees an Interrupt 9 which tr iggers the call of an interrupt handling r outine.  The Interrupt handling routine rea ds
Port 96 (Hex 60) to decide what keyboard action took place.   The interrupt handler returns a 2 byte code to the BIO where a
keyboard service routine examines low-order and high order bytes of  a sixteen bit value.  The scan code is in the high-order by te.
Certain scan code actions are buffered in a FIFO queue for readi ng by some application program.  Others trigger some immediate
action such as reboot instead of inserting them into the queue.
The special keys in this list ar e those that can be queued  rather than those that trigger an immediate operating system action .
Ada Distilled   by Richard Riehle
Page 107 of 113C.  Bibliography
Books Related to Ada
Ada 95 - The Language Reference Manual ANSI/ISO/IEC 8652:1995
Ada 95 Rationale, The Language and Standard Libraries ,  Ada Joint Program O ffice (with Intermetrics)
Beidler, John, Data Structures and Algorithms, An Ob ject-Oriented Approach Using Ada 95 ,
Springer-Verlag 1997,  New York,  ISBN  0-387-94834-1
Barnes, John G. P., Programming in Ada 95 , Addison-Wesley, 1998,  Second Edition
Be sure you get the second edition; m any improvements over the first edition
Ben-Ari, Moti, Understanding Programming Languages , John Wiley & Sons, 1996
Ben-Ari, Moti, Ada for Professional Software Engineers , John Wiley & Sons, 1998
Booch, Grady, Doug Bryan, Charles Petersen,  Software Engineering with Ada , Third Edition
                                 Benjamin/Cummings, 1994  (Ada 83 only)
Booch, Grady,  Object Solutions, Managing the Object-Oriented Project , Addison-Wesley, 1996
Burns, Alan; Wellings, Andy; Concurrency in Ada , Cambridge University Press, 1995
Burns, Alan; Wellings, Andy; Real-Time Systems and Programming Languages , Addison-Wesley, 1997
Bryan, Doulass & Mendal, Geoffrey, Exploring Ada  (2 vols), Prentice-Hall, 1992
Cohen, Norman, Ada As A Second Language , , Second Edition, McGraw-Hill, 1996
Coleman, Derek, et al Object-Oriented Development; The Fusion Method , Prentice-Hall, 1994
Culwin, Fintan, Ada, A Developmental Approach , , Second Edition, 1997, Prentice-Hall
English, John, Ada 95, The Craft of Object-Oriented Programming , Prentice-Hall, 1997
                     ( Now available for FTP download on the World Wide Web )
Fayad, Mohammed;  Schmidt, Douglas;  “O bject-Oriented Appli cation Frameworks”, Communications of the ACM ,
October 1997  (Frameworks theme issue of CACM)
Feldman, Michael, Software Construction and Data  Structures with Ada 95 , Addison-Wesley, 1997
Feldman, M.B, and E.B. Koffman, Ada95: Problem Solving and Program Design , Addison-Wesley, 1996
Finklestein A. and Fuks S. ( 1989) “Multi-party Specification”,  Proceedings of 5th International Workshop on
Software Specification and Design , Pittsburgh, PA ,  pp 185-95
Fowler, Martin and Kendall Scott, UML Distilled , Addison-Wesley Longman, 1997
Gamma, Erich; Helm, Richard; J ohnson, Ralph; Vlissides, John; Design Patterns, Elements of Resuable Object-
Oriented Software , Addison-Wesley, 1995
Gonzalez, Dean , Ada Programmer’s Handbook , Benjamin/Cummings, 1993  (Ada 83 version only)
Jacobson, Ivar,  Object-Oriented Software Engineeri ng: A Use Case Driven Approach , Addison-Wesley, 1994
Ada Distilled   by Richard Riehle
Page 108 of 113Johnston, Simon, Ada 95 for C and C++ Programmers , Addison-Wesley, 1997
Kain, Richard Y., Computer Architecture , Prentice-Hall, 1989 (because software examples are in Ada)
Loftus, Chris (editor), Ada Yearbook - 1994 ,  IOS Press, 1994
Meyer, Bertrand, Object-Oriented Software Construction , 2nd Editon, Prentice-Hall PTR, 1997
                        (Not friendly to Ada, but an excellent  treatment of object-oriented programming)
Naiditch, David, Rendezvous with Ada 95 , John Wiley & Sons, 1995  (0-471-01276-9)
Rosen, Jean Pierre, ……………………….. HOOD …………………..Pressman, Roger, Software Engineering, A Practiti oner’s Approach, Fourth Edition , McGraw-Hill, 1997
Salus, Peter H,  Handbook of Programming Languages, Vol 1,  Object-Oriented Programming Languages ,
                  MacMillan Technical Publishing, 1998 , ISBN   1-57870-009-4
Sigfried, Stefan, Understanding Object-Oriented Software Engineering , IEEE Press, 1995
Skansholm, Jan,  Ada From The Beginning , , Third Edition, Addison-Wesley, 1997
Smith, Michael A., Object-Oriented Software in Ada 95 , Thomson Computer Press, 1996
Sommerville, Ian, Software Engineering, Addis on-Wesley, 1992 (an Ada  friendly book on this topic)
Stroustrop, Bjarne, The C++ Programming Language , 3rd Edition, Addison-Wesley, 1997
Szyperski, Clemens,
                    Component Software: Beyond Object-Oriented Programming , Addison-Wesley, 1998
                                        (N ot an Ada book since it favors Java.  But it is chock full of good ideas about compon ents)
Taylor, David A, Object-Oriented Technology; A Manager's Guide , Addison-Wesley, 1992
Wheeler, David, A, Ada 95, The Lovelace Tutorial , Springer-Verlag, New York, 1997
[ Other Books to be added  ]
Ada Distilled   by Richard Riehle
Page 109 of 113Recommended Periodicals & Other Current Information
Most popular programming pe riodicals are staffed by editors who have little knowledge or interest in
software engineering.  Those who do care about soft ware engineering seem woefully ignorant about Ada.
Some of this ignorance reflects the general ignorance in the software community about Ada.  Some of thefollowing sources are listed for their general interest rather than their attention to serious software issues.
Ada Letters, A Bimonthly Publication of SIGAda, the ACM Special Interest Group on Ada
(ISSN 1094-3641)
A good and reliable source of accurate information regarding Ada
JOOP, Journal of Object-Oriented Programming, SIGS Publications,    ( Now out of business )
Publishes articles and columns with positive perspective on Ada
C++ Report, (especially the Column, Obfuscated C++), SIGS Publications
If you want to be frightened about just how  dangerous C++ really is, go to this source!
Embedded Systems Programming, Miller-Freeman Publications
Good Ada articles from time to time.  Other good articles of interest to Ada practitioners
Dr. Dobbs Journal,  Miller-Freeman
Generally  misinformed about Ada.  Editors, however, ar e open-minded about learning more accurate information
Internet Usenet Forum:   comp.lang.ada
Internet Ada Advocacy List Serve:  team-ada@acm.org
Internet AdaWorks Web Site:   http://www.adaworks.com
Internet Ada Resources Association Web Site:  http://www.adapower.com  and  http://www.adaic.org/
Microsoft Windows Programming in Ada .
       There are several good options.  The easiest to learn is JEWL from                John English.  The FTP is:       ftp://ftp.brighton.ac.uk/pub/je/jewl/.
       A commercial library, for serious Windows developers is CLAW from RR Software.  This has
       a price tag but is worth every penny if you need industrial strength Ada Windows programs.                                         http://www.rrsoftware.com
       The adapower.com site lists other options for those who want to program in Windows
Portable Windows and Graphics Programming
Check out the Gtk+ and OpenGL bindings available free on the Web.    The GtkAda binding is a powerful
set of tools that allows you to bu ild graphical user interfaces (GUI) a nd leverage the power of the portable
graphics development toolset, OpenGL.     With these tools, you can build Ada applications that will besecond to none in usability, efficiency, and portability.Caution:  Do not depend on any information from
www.adahome.com.  It is unreliable and out-of-date.
Ada Distilled   by Richard Riehle
Page  110 of 113Index
A
abs · 7, 131, 132abstract · 19, 78, 79, 87, 89, 131access · 8, 10, 18, 19, 21, 23, 24, 25, 26, 30, 45, 47, 48, 49, 50, 51, 52, 53, 54, 55, 61, 64, 65, 66, 75, 78,
79, 80, 84, 85, 86, 87, 88, 89, 91, 101, 102, 104, 107, 108, 111, 112, 114, 115, 116, 122, 128, 131, 137,143, 148, 152, 154, 155, 156, 157, 158, 161, 164, 165
Ada Core Technologies · 2, 5, 113, 168aliased · 48, 49, 50, 51, 131, 148, 160all · 9, 10, 12, 13, 18, 19, 24, 25, 26, 30, 32, 33, 40,  42, 44, 47, 48, 49, 50, 51, 54, 55, 59, 62, 65, 69, 74,
76, 78, 80, 82, 83, 84, 85, 86, 87, 88, 89, 91, 92, 94, 100, 101, 103, 104, 105, 108, 111, 112, 114, 115,116, 117, 118, 122, 128, 129, 131, 139, 143, 146, 160, 161, 164
and · 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,  17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 32,
33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 46, 47, 49, 50, 51, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
66, 69, 70, 73, 74, 75, 77, 79, 80, 81, 82, 83, 84, 85,  87, 89, 90, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102,
103, 104, 105, 106, 107, 108, 109, 111, 113, 115, 117, 118, 119, 120, 122, 124, 125, 126, 127, 128, 129,130, 131, 132, 135, 136, 137, 139, 143, 146, 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, 160, 162,164, 166, 167, 168
array · 18, 19, 22, 24, 30, 31, 32, 33, 37, 38, 52, 54, 63, 64, 72, 73, 79, 80, 81, 85, 86, 87, 88, 89, 90, 93,
101, 102, 104, 107, 108, 121, 131, 134, 143, 149, 151, 152, 153, 156, 162, 163
at · 2, 5, 13, 14, 15, 16, 17, 18, 26, 32, 34, 36, 40, 43, 44, 48, 49, 51, 54, 55, 59, 60, 62, 63, 70, 71, 72, 80,
81, 86, 90, 94, 95, 100, 105, 106, 107, 109, 118, 124, 126, 130, 131, 138, 146, 149, 151
Bbegin · 5, 9, 10, 14, 15, 16, 18, 20, 28, 29, 31, 32, 33,  36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 48, 49, 50, 51,
52, 53, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 68, 70, 71, 72, 73, 74, 75, 82, 83, 85, 86, 87, 88, 90,
91, 93, 94, 95, 96, 97, 98, 100, 101, 103, 105, 106, 108, 109, 110, 111, 113, 114, 115, 116, 117, 118,119, 120, 121, 125, 126, 127, 129, 130, 131
body · 8, 9, 10, 11, 12, 13, 14, 15, 19, 20, 26, 57,  67, 70, 71, 77, 78, 79, 81, 82, 83, 102, 105, 106, 109,
113, 119, 125, 126, 127, 129, 131, 148, 149, 156
CC++ · 10, 22, 28, 29, 36, 66, 70, 93, 167, 168case · 6, 18, 36, 39, 40, 42, 43, 44, 62, 63, 81, 89, 94, 95, 96, 101, 131, 148Child Library Units · 11, 77, 79COBOL · 93code blocks · 15, 16, 43, 44, 45, 46, 59, 112, 159Compilation Unit · 8, 9, 10, 11, 14, 35, 55, 56, 67, 69, 70, 71, 77, 80, 82, 83, 90, 95, 102, 110, 113, 125,
149, 160, 162
Compilation Units · 9, 10, 11, 14, 67, 69, 70, 83, 95, 149, 160, 162Compiler Publishers · 5constant · 9, 16, 21, 34, 36, 38, 44, 60, 64, 65, 66, 74, 94, 103, 104, 118, 131, 135, 136, 137, 146, 147, 150
Ddeclarations · 8, 9, 12, 14, 15, 16, 20, 24, 27, 29, 31,  44, 45, 51, 54, 57, 58, 64, 67, 69, 70, 73, 78, 105, 146
declare · 7, 13, 14, 15, 16, 24, 44, 45, 46, 49, 50, 51, 54, 66, 69, 70, 71, 72, 86, 93, 100, 109, 115, 118,
120, 121, 131
declare block · 14, 15, 16, 44, 45, 46, 49, 86, 121delay · 18, 131delta · 24, 71, 131, 134, 141, 148, 150
Ada Distilled   by Richard Riehle
Page 111 of 113digits · 24, 27, 29, 53, 71, 75, 103, 131, 132, 135, 140, 141, 148, 150, 153, 154, 158
Dynamic Binding · 87, 89, 90, 113Eelaboration · 14else · 7, 15, 22, 40, 41, 42, 60, 62, 63, 64, 66, 82, 83, 93, 103, 105, 114, 125, 130, 131elsif · 40, 41, 103, 131end · 5, 7, 9, 10, 11, 12, 13, 15, 16, 18, 20, 24, 25, 26, 27, 28, 29, 31, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
43, 44, 45, 46, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
72, 73, 74, 75, 76, 78, 79, 80, 81, 82, 83, 84, 85, 86,  87, 88, 89, 90, 91, 93, 94, 95, 96, 97, 99, 100, 101,
102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123,124, 125, 126, 127, 128, 129, 130, 131, 134, 135, 136, 138, 140, 141, 142, 144, 145, 147
entry · 5, 12, 14, 34, 40, 124, 125, 126, 127, 128, 129, 130, 131, 149, 150exceptions · 8, 18, 22, 44, 80, 100, 101, 102, 103, 104, 134exit · 39, 40, 45, 53, 56, 59, 60, 62, 89, 91, 95, 115, 125, 129, 130, 131Ffor · 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
61, 62, 63, 64, 65, 66, 67, 69, 70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85, 86, 89, 90, 91, 92, 93,
94, 95, 96, 97, 98, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 117, 118, 119, 120,121, 122, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143,144, 146, 147, 148, 149, 151, 153, 154, 155, 157, 158, 159, 160, 161, 164, 166, 167, 168
Fortran · 32function · 8, 9, 11, 12, 14, 18, 19, 21, 22, 25, 27, 28,  29, 34, 41, 42, 43, 44, 45, 47, 50, 51, 52, 53, 54, 55,
56, 58, 59, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 75, 77, 78, 79, 80, 81, 82, 83, 84, 86, 87, 88, 90,
93, 100, 101, 103, 104, 105, 106, 107, 108, 111, 112, 114, 115, 116, 118, 119, 122, 129, 130, 131, 132,133, 134, 135, 136, 137, 138, 143, 144, 145, 146, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,159, 160, 164, 165
Ggeneric · 15, 18, 28, 75, 77, 83, 93, 95, 96, 105,  106, 107, 108, 109, 110, 111, 131, 135, 139, 140, 141, 142
goto · 18, 131GtkAda · 2, 5IImplementation · 8, 9, 10, 11, 14, 35, 55, 56, 67, 69, 70, 71, 77, 80, 82, 83, 90, 102, 110, 113, 125, 126,
127, 129, 130
JJava · 5, 47, 99, 167LLibraries · 3, 5, 7, 15, 16, 17, 18, 22, 24, 27, 28, 29, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 42, 44, 45, 46,
47, 48, 49, 52, 53, 55, 57, 58, 59, 60, 62, 66, 67, 72, 73, 74, 75, 83, 85, 86, 88, 90, 91, 92, 93, 94, 95, 96,
97, 98, 99, 100, 101, 103, 104, 113, 117, 118, 120, 121, 122, 125, 126, 129, 131, 134, 135, 136, 137,139, 142, 146, 147, 148, 149, 158, 166
Library Unit · 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 31, 34, 36, 37,
38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
66, 67, 69, 70, 71, 72, 73, 74, 75, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 93, 94, 95, 96,
98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,122, 127, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 148,149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 164, 165
Library Units · 2, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30, 31, 32,
34, 35, 38, 39, 41, 43, 44, 45, 46, 47, 48, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 62, 64, 65, 66, 67, 69,
70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 113, 117, 118, 119, 120, 122, 124, 125, 127,129, 131, 134, 135, 136, 139, 140, 141, 142, 143, 144, 146, 148, 152, 156, 157, 160, 161, 162, 163, 164,165, 168
Linux Programming · 3, 5, 113, 168
Ada Distilled   by Richard Riehle
Page 112 of 113M
methods · 7, 8, 15, 19, 20, 35, 49, 51, 57, 67, 69, 70, 90, 102, 105, 107, 111, 146mod · 7, 30, 96, 98, 131, 132, 140Nnull · 18, 20, 42, 48, 56, 62, 69, 72, 82, 90, 103,  110, 112, 113, 115, 116, 121, 127, 130, 131, 153, 160, 161
OObject Modeling · 166, 167Object-Oriented Programming · 24, 25, 34, 35, 78, 79, 80, 81, 84, 87, 89, 90, 91, 101, 102, 111, 122, 131,
149, 151, 159
OC Systems · 2, 5Ppackage · 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 22, 23, 24, 25, 26, 27, 28, 31, 32, 34, 35, 39, 44, 46,
47, 48, 49, 53, 54, 55, 56, 59, 62, 64, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
113, 117, 118, 119, 120, 122, 124, 125, 127, 129, 131, 134, 135, 136, 139, 140, 141, 142, 143, 144, 146,160, 164, 165
Package Design · 7, 8, 9, 10, 11, 12, 13, 14, 19, 20, 22, 23, 26, 27, 29, 34, 54, 57, 64, 67, 69, 70, 71, 72,
73, 77, 78, 79, 80, 84, 89, 102, 105, 106, 108, 109, 113, 119, 120, 122, 123, 124, 125, 126, 127, 148,149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 165
Parameters · 9, 10, 21, 22, 25, 30, 33, 38, 39, 47, 50,  51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63, 64, 65,
66, 73, 76, 86, 89, 90, 92, 101, 105, 106, 107, 108, 109, 110, 117, 122, 127, 136, 137, 139, 158
pragma · 14, 15, 31, 34, 35, 131, 134, 135, 146, 162, 163private · 8, 9, 10, 11, 12, 23, 24, 25, 26, 27, 41, 47, 69, 70, 77, 78, 79, 80, 81, 83, 84, 85, 87, 88, 89, 90,
101, 102, 103, 104, 106, 107, 108, 109, 111, 112, 115, 119, 122, 129, 131, 136, 142, 143, 144, 145, 146,147, 149
procedure · 5, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18, 19,  20, 21, 24, 25, 26, 27, 28, 29, 31, 36, 37, 38, 39, 40,
42, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 63, 66, 67, 69, 70, 71, 72, 73, 74, 75,
77, 78, 79, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 94, 95, 96, 98, 100, 101, 102, 103, 104, 106, 107,108, 109, 110, 111, 112, 113, 114, 115, 117, 118, 119, 122, 127, 129, 131, 136, 137, 138, 139, 140, 141,142, 143, 144, 155, 156, 157, 161, 165
protected · 15, 23, 30, 70, 124, 128, 129, 130, 131, 150Rraise · 18, 41, 61, 64, 82, 83, 100, 102, 103, 104, 131, 140rem · 7, 131, 132rename · 17, 117, 118, 120, 121, 122requeue · 131Reserved Words · 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12,  13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108,109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129,130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150,151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168
return · 8, 9, 11, 12, 19, 21, 25, 27, 33, 38, 40, 41, 42, 43, 44, 45, 47, 50, 51, 52, 53, 54, 55, 56, 58, 61, 62,
63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 78, 79, 80, 81, 82, 83, 84, 86, 87, 88, 90, 93, 94, 100, 101, 103,104, 105, 107, 108, 111, 112, 114, 115, 116, 117, 118, 119, 122, 125, 129, 131, 132, 133, 134, 135, 136,137, 138, 139, 143, 144, 145, 146, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 164,165
Reusable components · 15, 18, 28, 75, 77, 83, 93,  95, 96, 105, 106, 107, 108, 109, 110, 111, 131, 135, 139,
140, 141, 142
reverse · 37, 128, 131SScope and Visibility · 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 24, 25, 27, 28, 34, 36, 38, 39, 40, 41,
44, 45, 46, 49, 50, 51, 52, 55, 57, 58, 59, 62, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 78, 79, 80, 89, 92,
94, 95, 96, 102, 113, 117, 118, 119, 123, 124, 125, 126, 135
Ada Distilled   by Richard Riehle
Page 113 of 113select · 18, 126, 128, 131
separate · 11, 14, 61, 67, 80, 115, 131Subprogram · 2, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,  18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 31, 34,
36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 93, 94,
95, 96, 98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,118, 119, 122, 127, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,146, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 164, 165
subprograms · 7, 17, 61, 80, 85, 90, 144subtype · 27, 28, 29, 60, 75, 121, 131, 132, 136, 143, 144, 147, 148, 149, 150, 151, 152, 153, 154, 155,
156, 157, 158, 159, 160, 161, 162, 163, 164
Supported Operating Systems · 2, 3, 5, 164, 165, 168Ttagged · 24, 25, 34, 35, 78, 79, 80, 81, 84, 87,  89, 90, 91, 101, 102, 111, 122, 131, 149, 151, 159
task · 14, 15, 23, 30, 57, 93, 124, 125, 126, 127, 128, 129, 130, 131, 149, 150, 152, 158, 159Tasking · 5, 12, 14, 34, 40, 124, 125, 126, 127, 128, 129, 130, 131, 149, 150terminate · 18, 66, 126, 128, 131then · 7, 39, 40, 41, 42, 45, 58, 60, 61, 62, 63, 64,  66, 70, 82, 83, 93, 95, 98, 103, 105, 106, 114, 119, 125,
128, 131, 149, 152, 156, 157
type · 6, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
37, 38, 41, 42, 47, 48, 49, 50, 51, 52, 53, 54, 55, 58, 59, 60, 61, 62, 63, 64, 65, 66, 69, 70, 71, 72, 73, 74,
75, 78, 79, 80, 81, 84, 85, 87, 88, 89, 90, 91, 92, 93, 96, 98, 101, 102, 103, 104, 105, 106, 107, 108, 109,111, 112, 113, 115, 117, 118, 119, 120, 121, 122, 124, 126, 127, 129, 130, 131, 132, 133, 134, 135, 136,137, 139, 140, 141, 142, 143, 144, 146, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,161, 164
Type definitions · 9, 11, 12, 18, 19, 22, 23, 24, 25, 26,  27, 30, 31, 32, 33, 34, 35, 37, 38, 41, 52, 54, 63, 64,
65, 69, 72, 73, 79, 80, 81, 84, 85, 86, 87, 88, 89, 90, 93, 101, 102, 103, 104, 107, 108, 112, 121, 122,123, 131, 134, 143, 148, 149, 151, 152, 153, 156, 158, 162, 163
type safety · 22Uuntil · 10, 38, 39, 50, 85, 117, 124, 126, 127, 128, 131, 138, 149use · 2, 6, 11, 12, 13, 15, 18, 19, 28, 29, 30, 31, 33, 35, 36, 37, 40, 43, 44, 46, 47, 48, 49, 52, 53, 54, 59, 61,
62, 66, 67, 69, 73, 74, 75, 80, 83, 84, 86, 87, 88, 90, 91, 93, 94, 95, 96, 98, 101, 105, 106, 111, 112, 117,118, 119, 120, 125, 127, 128, 130, 131, 136, 143, 144, 164
VVisibility Rules · 7, 9, 10, 12, 13, 17, 19, 20, 36, 45, 46, 51, 67, 69, 70, 71, 74, 80, 89, 96, 118Wwhen · 2, 6, 15, 16, 22, 28, 29, 31, 37, 39, 40, 42, 43,  44, 45, 46, 48, 49, 50, 52, 53, 54, 56, 59, 62, 64, 65,
77, 82, 89, 90, 91, 95, 100, 101, 103, 111, 115, 122, 124, 125, 126, 127, 128, 129, 130, 131, 149, 150,152, 153, 157, 158, 159
while · 38, 39, 127, 131WinTel  Programming · 3, 5, 164, 168with · 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,  18, 19, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
35, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
67, 69, 70, 72, 73, 74, 75, 76, 77, 78, 82, 83, 84, 85,  86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 98, 100,
101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 117, 118, 119, 120, 122, 124, 125,126, 127, 128, 129, 130, 131, 135, 136, 137, 138, 139, 143, 148, 149, 150, 151, 152, 153, 154, 155, 156,157, 158, 159, 160, 161, 164, 166, 167, 168
Xxor · 7, 31, 131, 132

GNU PROLOG
A Native Prolog Compiler with Constraint Solving over Finite Domains
Edition 1.50, for GNU Prolog version 1.5.0
July 8, 2021
by Daniel Diaz
Copyright (C) 1999-2021 Daniel Diaz
Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice
and this permission notice are preserved on all copies.
Permission is granted to copy and distribute modied versions of this manual under the conditions for
verbatim copying, provided that the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
Permission is granted to copy and distribute translations of this manual into another language, under the
above conditions for modied versions, except that this permission notice may be stated in a translation
approved by the Free Software Foundation, 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
CONTENTS 1
Contents
1 Acknowledgements 9
2 GNU Prolog License Conditions 11
3 Introduction 11
4 Using GNU Prolog 13
4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
4.2 The GNU Prolog interactive interpreter . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
4.2.1 Starting/exiting the interactive interpreter . . . . . . . . . . . . . . . . . . . . . . 13
4.2.2 The interactive interpreter read-execute-write loop . . . . . . . . . . . . . . . . . 15
4.2.3 Consulting a Prolog program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4.2.4 Scripting Prolog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4.2.5 Interrupting a query . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4.2.6 The line editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4.3 Adjusting the size of Prolog data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.4 The GNU Prolog compiler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
4.4.1 Dierent kinds of codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
4.4.2 Compilation scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
4.4.3 Using the compiler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
4.4.4 Running an executable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.4.5 Generating a new interactive interpreter . . . . . . . . . . . . . . . . . . . . . . . 27
4.4.6 The name mangling scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
5 Debugging 31
5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
5.2 The procedure box model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
5.3 Debugging predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
5.3.1 Running and stopping the debugger . . . . . . . . . . . . . . . . . . . . . . . . . 31
5.3.2 Leashing ports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
5.3.3 Spy-points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
5.4 Debugging messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
5.5 Debugger commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
5.6 The WAM debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
6 Format of denitions 37
6.1 General format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
6.2 Types and modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
6.3 Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
6.3.1 General format and error context . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
6.3.2 Instantiation error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
6.3.3 Uninstantiation error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
6.3.4 Type error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
6.3.5 Domain error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
6.3.6 Existence error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
6.3.7 Permission error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
6.3.8 Representation error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
6.3.9 Evaluation error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
6.3.10 Resource error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
6.3.11 Syntax error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
6.3.12 System error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
7 Prolog directives and control constructs 45
2 CONTENTS
7.1 Prolog directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
7.1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
7.1.2 dynamic/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
7.1.3 public/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
7.1.4 multifile/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
7.1.5 discontiguous/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
7.1.6 ensure linked/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
7.1.7 built in/0 ,built in/1 ,built infd/0 ,built infd/1 . . . . . . . . . . . . . . 47
7.1.8 include/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
7.1.9 if/1 ,else/0 ,endif/0 ,elif/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
7.1.10 ensure loaded/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
7.1.11 op/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
7.1.12 char conversion/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
7.1.13 setprolog flag/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
7.1.14 initialization/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
7.1.15 foreign/2 ,foreign/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
7.2 Prolog control constructs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
7.2.1 true/0 ,fail/0 ,!/0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
7.2.2 (',')/2 - conjunction, (;)/2 - disjunction, (->)/2 - if-then, (*->)/2 - soft-cut
(soft if-then) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
7.2.3 call/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
7.2.4 catch/3 ,throw/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
8 Prolog built-in predicates 55
8.1 Type testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
8.1.1 var/1 ,nonvar/1 ,atom/1 ,integer/1 ,float/1 ,number/1 ,atomic/1 ,
compound/1 ,callable/1 ,ground/1 ,islist/1 ,list/1 ,
partial list/1 ,list orpartial list/1 . . . . . . . . . . . . . . . . . . . . . . 55
8.2 Term unication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
8.2.1 (=)/2 - Prolog unication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
8.2.2 unify with occurs check/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
8.2.3 (\=)/2 - not Prolog uniable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
8.3 Term comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
8.3.1 Standard total ordering of terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
8.3.2 (==)/2 - term identical, (\==)/2 - term not identical,
(@<)/2 - term less than, (@=<)/2 - term less than or equal to,
(@>)/2 - term greater than, (@>=)/2 - term greater than or equal to . . . . . . . 57
8.3.3 compare/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
8.4 Term processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
8.4.1 functor/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
8.4.2 arg/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
8.4.3 (=..)/2 - univ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
8.4.4 copy term/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
8.4.5 term variables/2 ,term variables/3 . . . . . . . . . . . . . . . . . . . . . . . . 61
8.4.6 subsumes term/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
8.4.7 acyclic term/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
8.4.8 term hash/4 ,term hash/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
8.4.9 setarg/4 ,setarg/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
8.5 Variable naming/numbering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
8.5.1 name singleton vars/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
8.5.2 name query vars/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
8.5.3 bind variables/2 ,numbervars/3 ,numbervars/1 . . . . . . . . . . . . . . . . . . 64
8.5.4 term ref/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
8.6 Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
CONTENTS 3
8.6.1 Evaluation of an arithmetic expression . . . . . . . . . . . . . . . . . . . . . . . . 66
8.6.2 (is)/2 - evaluate expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
8.6.3 (=:=)/2 - arithmetic equal, (=\=)/2 - arithmetic not equal,
(<)/2 - arithmetic less than, (=<)/2 - arithmetic less than or equal to,
(>)/2 - arithmetic greater than, (>=)/2 - arithmetic greater than or equal to . . 69
8.6.4 succ/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
8.7 Dynamic clause management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
8.7.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
8.7.2 asserta/1 ,assertz/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
8.7.3 retract/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
8.7.4 retractall/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
8.7.5 clause/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
8.7.6 abolish/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
8.8 Predicate information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
8.8.1 current predicate/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
8.8.2 predicate property/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
8.9 All solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
8.9.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
8.9.2 findall/4 ,findall/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
8.9.3 bagof/3 ,setof/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
8.10 Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
8.10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
8.10.2 current input/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
8.10.3 current output/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
8.10.4 setinput/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
8.10.5 setoutput/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
8.10.6 open/4 ,open/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
8.10.7 close/2 ,close/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
8.10.8 flush output/1 ,flush output/0 . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
8.10.9 current stream/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
8.10.10 stream property/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
8.10.11 atendofstream/1 ,atendofstream/0 . . . . . . . . . . . . . . . . . . . . . . 85
8.10.12 stream position/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
8.10.13 setstream position/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
8.10.14 seek/4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
8.10.15 character count/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
8.10.16 line count/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
8.10.17 line position/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
8.10.18 stream line column/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
8.10.19 setstream line column/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
8.10.20 addstream alias/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
8.10.21 current alias/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
8.10.22 addstream mirror/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
8.10.23 remove stream mirror/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
8.10.24 current mirror/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
8.10.25 setstream type/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
8.10.26 setstream eofaction/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
8.10.27 setstream buffering/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
8.11 Constant term streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
8.11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
8.11.2 open input atom stream/2 ,open input chars stream/2 ,
open input codes stream/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
8.11.3 close input atom stream/1 ,close input chars stream/1 ,
close input codes stream/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
4 CONTENTS
8.11.4 open output atom stream/1 ,open output chars stream/1 ,
open output codes stream/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
8.11.5 close output atom stream/2 ,close output chars stream/2 ,
close output codes stream/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
8.12 Character input/output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
8.12.1 getchar/2 ,getchar/1 ,getcode/1 ,getcode/2 . . . . . . . . . . . . . . . . . 97
8.12.2 getkey/2 ,getkey/1 get keynoecho/2 ,getkeynoecho/1 . . . . . . . . . . 98
8.12.3 peek char/2 ,peek char/1 ,peek code/1 ,peek code/2 . . . . . . . . . . . . . . . 99
8.12.4 unget char/2 ,unget char/1 ,unget code/2 ,unget code/1 . . . . . . . . . . . . 100
8.12.5 putchar/2 ,putchar/1 ,putcode/1 ,putcode/2 ,nl/1 ,nl/0 . . . . . . . . . . 100
8.13 Byte input/output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
8.13.1 getbyte/2 ,getbyte/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
8.13.2 peek byte/2 ,peek byte/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
8.13.3 unget byte/2 ,unget byte/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
8.13.4 putbyte/2 ,putbyte/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
8.14 Term input/output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
8.14.1 read term/3 ,read term/2 ,read/2 ,read/1 . . . . . . . . . . . . . . . . . . . . . 104
8.14.2 read atom/2 ,read atom/1 ,read integer/2 ,read integer/1 ,
read number/2 ,read number/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
8.14.3 read token/2 ,read token/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
8.14.4 syntax error info/4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
8.14.5 last read start line column/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
8.14.6 write term/3 ,write term/2 ,write/2 ,write/1 ,writeq/2 ,writeq/1 ,
write canonical/2 ,write canonical/1 ,display/2 ,display/1 ,print/2 ,
print/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
8.14.7 format/3 ,format/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
8.14.8 portray clause/2 ,portray clause/1 . . . . . . . . . . . . . . . . . . . . . . . . 112
8.14.9 getprint stream/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8.14.10 op/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8.14.11 current op/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
8.14.12 char conversion/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
8.14.13 current char conversion/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
8.15 Input/output from/to constant terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
8.15.1 read term from atom/3 ,read from atom/2 ,read token from atom/2 . . . . . . 117
8.15.2 read term from chars/3 ,read from chars/2 ,read token from chars/2 . . . . 117
8.15.3 read term from codes/3 ,read from codes/2 ,read token from codes/2 . . . . 118
8.15.4 write term toatom/3 ,write toatom/2 ,writeq toatom/2 ,
write canonical toatom/2 ,display toatom/2 ,print toatom/2 ,
format toatom/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
8.15.5 write term tochars/3 ,write tochars/2 ,writeq tochars/2 ,
write canonical tochars/2 ,display tochars/2 ,print tochars/2 ,
format tochars/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
8.15.6 write term tocodes/3 ,write tocodes/2 ,writeq tocodes/2 ,
write canonical tocodes/2 ,display tocodes/2 ,print tocodes/2 ,
format tocodes/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
8.16 DEC-10 compatibility input/output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
8.16.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
8.16.2 see/1 ,tell/1 ,append/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
8.16.3 seeing/1 ,telling/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
8.16.4 seen/0 ,told/0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
8.16.5 get0/1 ,get/1 ,skip/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
8.16.6 put/1 ,tab/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
8.17 Term expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
8.17.1 Denite clause grammars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
CONTENTS 5
8.17.2 expand term/2 ,term expansion/2 . . . . . . . . . . . . . . . . . . . . . . . . . . 124
8.17.3 phrase/3 ,phrase/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
8.18 Logic, control and exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
8.18.1 abort/0 ,stop/0 ,toplevel/0 ,break/0 ,halt/1 ,halt/0 . . . . . . . . . . . . . 126
8.18.2 false/0 ,once/1 ,(\+)/1 - not provable, call/2-11 ,call with args/1-11 ,call det/2 ,
forall/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
8.18.3 repeat/0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
8.18.4 between/3 ,for/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
8.19 Atomic term processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
8.19.1 atom length/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
8.19.2 atom concat/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
8.19.3 subatom/5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
8.19.4 char code/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
8.19.5 lower upper/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
8.19.6 atom chars/2 ,atom codes/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
8.19.7 number atom/2 ,number chars/2 ,number codes/2 . . . . . . . . . . . . . . . . . 132
8.19.8 name/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
8.19.9 newatom/2 ,newatom/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
8.19.10 current atom/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
8.19.11 atom property/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
8.20 List processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
8.20.1 append/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
8.20.2 member/2 ,memberchk/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
8.20.3 reverse/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
8.20.4 delete/3 ,select/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
8.20.5 subtract/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
8.20.6 permutation/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
8.20.7 prefix/2 ,suffix/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
8.20.8 sublist/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
8.20.9 last/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
8.20.10 flatten/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
8.20.11 length/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
8.20.12 nth/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
8.20.13 maxlist/2 ,minlist/2 ,sumlist/2 . . . . . . . . . . . . . . . . . . . . . . . . . 139
8.20.14 maplist/2-8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
8.20.15 sort/2 ,msort/2 ,keysort/2 sort/1 ,msort/1 ,keysort/1 . . . . . . . . . . . . . 140
8.21 Global variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
8.21.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
8.21.2 gassign/2 ,gassignb/2 ,glink/2 . . . . . . . . . . . . . . . . . . . . . . . . . 143
8.21.3 gread/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
8.21.4 garray size/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
8.21.5 ginc/3 ,ginc/2 ,ginco/2 ,ginc/1 ,gdec/3 ,gdec/2 ,gdeco/2 ,gdec/1 . . . 144
8.21.6 gsetbit/2 ,greset bit/2 ,gtest setbit/2 ,gtest reset bit/2 . . . . . . 145
8.21.7 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
8.22 Prolog state . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
8.22.1 setprolog flag/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
8.22.2 current prolog flag/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
8.22.3 setbipname/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
8.22.4 current bipname/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
8.22.5 write plstate file/1 ,read plstate file/1 . . . . . . . . . . . . . . . . . . . 152
8.23 Program state . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
8.23.1 consult/1 ,'.'/2 - program consult . . . . . . . . . . . . . . . . . . . . . . . . . 153
8.23.2 load/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
8.23.3 listing/1 ,listing/0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
6 CONTENTS
8.24 System statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
8.24.1 statistics/0 ,statistics/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
8.24.2 user time/1 ,system time/1 ,cputime/1 ,real time/1 . . . . . . . . . . . . . . 155
8.25 Random number generator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
8.25.1 setseed/1 ,randomize/0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
8.25.2 getseed/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
8.25.3 random/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
8.25.4 random/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
8.26 File name processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
8.26.1 absolute file name/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
8.26.2 isabsolute file name/1 ,isrelative file name/1 . . . . . . . . . . . . . . . 158
8.26.3 decompose file name/4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
8.26.4 prolog file name/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
8.27 Operating system interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
8.27.1 argument counter/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
8.27.2 argument value/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
8.27.3 argument list/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
8.27.4 environ/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
8.27.5 make directory/1 ,delete directory/1 ,change directory/1 . . . . . . . . . . 162
8.27.6 working directory/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
8.27.7 directory files/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
8.27.8 rename file/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
8.27.9 delete file/1 ,unlink/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
8.27.10 file permission/2 ,file exists/1 . . . . . . . . . . . . . . . . . . . . . . . . . 164
8.27.11 file property/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
8.27.12 temporary name/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
8.27.13 temporary file/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
8.27.14 date time/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
8.27.15 host name/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
8.27.16 osversion/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
8.27.17 architecture/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
8.27.18 shell/2 ,shell/1 ,shell/0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
8.27.19 system/2 ,system/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
8.27.20 spawn/3 ,spawn/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
8.27.21 popen/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
8.27.22 exec/5 ,exec/4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
8.27.23 fork prolog/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
8.27.24 create pipe/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
8.27.25 wait/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
8.27.26 prolog pid/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
8.27.27 send signal/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
8.27.28 sleep/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
8.27.29 select/5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
8.28 Sockets input/output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
8.28.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
8.28.2 socket/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
8.28.3 socket close/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
8.28.4 socket bind/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
8.28.5 socket connect/4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
8.28.6 socket listen/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
8.28.7 socket accept/4 ,socket accept/3 . . . . . . . . . . . . . . . . . . . . . . . . . 179
8.28.8 hostname address/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
8.29 Linedit management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
8.29.1 getlinedit prompt/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
CONTENTS 7
8.29.2 setlinedit prompt/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
8.29.3 addlinedit completion/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
8.29.4 find linedit completion/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
9 Finite domain solver and built-in predicates 183
9.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
9.1.1 Finite Domain variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
9.2 FD variable parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
9.2.1 fdmaxinteger/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
9.2.2 fdvector max/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
9.2.3 fdsetvector max/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
9.3 Initial value constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
9.3.1 fddomain/3 ,fddomain bool/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
9.3.2 fddomain/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
9.4 Type testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
9.4.1 fdvar/1 ,nonfdvar/1 ,generic var/1 ,nongeneric var/1 . . . . . . . . . . . 187
9.5 FD variable information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
9.5.1 fdmin/2 ,fdmax/2 ,fdsize/2 ,fddom/2 . . . . . . . . . . . . . . . . . . . . . . 187
9.5.2 fdhasextra cstr/1 ,fdhasvector/1 ,fdusevector/1 . . . . . . . . . . . . . 188
9.6 Arithmetic constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
9.6.1 FD arithmetic expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
9.6.2 Partial AC: (#=)/2 - constraint equal, (#\=)/2 - constraint not equal,
(#<)/2 - constraint less than, (#=<)/2 - constraint less than or equal,
(#>)/2 - constraint greater than, (#>=)/2 - constraint greater than or equal . . . 189
9.6.3 Full AC: (#=#)/2 - constraint equal, (#\=#)/2 - constraint not equal,
(#<#)/2 - constraint less than, (#=<#)/2 - constraint less than or equal,
(#>#)/2 - constraint greater than, (#>=#)/2 - constraint greater than or equal . . 190
9.6.4 fdprime/1 ,fdnotprime/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
9.7 Boolean and reied constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
9.7.1 Boolean FD expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
9.7.2 fdreified in/4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
9.7.3 (#\)/1 - constraint NOT, (#<=>)/2 - constraint equivalent,
(#\<=>)/2 - constraint dierent, (##)/2 - constraint XOR,
(#==>)/2 - constraint imply, (#\==>)/2 - constraint not imply,
(#/\)/2 - constraint AND, (#\/\)/2 - constraint NAND,
(#\/)/2 - constraint OR, (#\\/)/2 - constraint NOR . . . . . . . . . . . . . . . . 193
9.7.4 fdcardinality/2 ,fdcardinality/3 ,fdatleast one/1 ,fdatmost one/1 ,
fdonly one/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
9.8 Symbolic constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
9.8.1 fdalldifferent/1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
9.8.2 fdelement/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
9.8.3 fdelement var/3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
9.8.4 fdatmost/3 ,fdatleast/3 ,fdexactly/3 . . . . . . . . . . . . . . . . . . . . . 196
9.8.5 fdrelation/2 ,fdrelationc/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
9.9 Labeling constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
9.9.1 fdlabeling/2 ,fdlabeling/1 ,fdlabelingff/1 . . . . . . . . . . . . . . . . . 198
9.10 Optimization constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
9.10.1 fdminimize/2 ,fdmaximize/2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
10 Interfacing Prolog and C 201
10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
10.2 Including and using gprolog.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
10.3 Calling C from Prolog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
10.3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
10.3.2 foreign/2 directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
8 CONTENTS
10.3.3 The C function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
10.3.4 Input arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
10.3.5 Output arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
10.3.6 Input/output arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
10.3.7 Writing non-deterministic C code . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
10.3.8 Example: input and output arguments . . . . . . . . . . . . . . . . . . . . . . . . 206
10.3.9 Example: non-deterministic code . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
10.3.10 Example: input/output arguments . . . . . . . . . . . . . . . . . . . . . . . . . . 209
10.4 Manipulating Prolog terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
10.4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
10.4.2 Managing Prolog atoms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
10.4.3 Reading Prolog terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
10.4.4 Unifying Prolog terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
10.4.5 Creating Prolog terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
10.4.6 Testing the type of Prolog terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
10.4.7 Comparing Prolog terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
10.4.8 Term processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
10.4.9 Comparing and evaluating arithmetic expressions . . . . . . . . . . . . . . . . . . 216
10.5 Raising Prolog errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
10.5.1 Managing the error context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
10.5.2 Instantiation error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
10.5.3 Uninstantiation error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
10.5.4 Type error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
10.5.5 Domain error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
10.5.6 Existence error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
10.5.7 Permission error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
10.5.8 Representation error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
10.5.9 Evaluation error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
10.5.10 Resource error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
10.5.11 Syntax error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
10.5.12 System error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
10.6 Calling Prolog from C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
10.6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
10.6.2 Example: mycall/1 - acall/1 clone . . . . . . . . . . . . . . . . . . . . . . . . . 221
10.6.3 Example: recovering the list of all operators . . . . . . . . . . . . . . . . . . . . . 223
10.7 Dening a new C main() function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
10.7.1 Example: asking for ancestors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
References 229
Index 231
9
1 Acknowledgements
I am grateful to the members of the Loco project at INRIA Rocquencourt for their encouragement. Their
involvement in this work led to useful feedback and exchange (1995).
Many thanks to all those people at GNU who helped me to nalize the GNU Prolog project (1999).
I would like to thank everybody who tested preliminary releases and helped me to put the nishing
touches to this system (1999).
I would particularly like to thank Jonathan Hodgson for the time and eort he put into the proofreading
of this manual. His suggestions, both regarding ISO technical aspects as well as the language in which it
was expressed, proved invaluable (1999-2017).
Thanks to Richard A. O'Keefe for his advice regarding the implementation of some Prolog built-in
predicates and for suggesting me the in-place installation feature (1999).
The on-line HTML version of this document was created using H EVEA developed by Luc Maranget who
kindly devoted so much of his time extending the capabilities of H EVEA in order to handle such a sizeable
manual (2000).
Jean-Christophe Aude kindly improved the visual aspect of both the illustrations and the GNU Prolog
web pages (2000).
Many thanks to the following contributors:
â€¢Clive Cox1and Edmund Grimley Evans for their port to ix86/SCO (1999).
â€¢Andreas Stolcke for his port to ix86/Solaris (1999).
â€¢Alexander Diemand2for his initial port to alpha/linux (2000).
â€¢Nicolas Ollinger3to for his port to ix86/FreeBSD (2000).
â€¢Brook Milligan4for his port to ix86/NetBSD and for general conguration improvements (2000).
â€¢Lindsey Spratt5for his port to powerpc/Darwin (MacOS X) (2002).
â€¢Gwenol e Beauchesne6for his port to x86 64/Linux (2002).
â€¢Jason Beegan7for his port to sparc/NetBSD and to powerpc/NetBSD (2003).
â€¢Cesar Rabak8for his initial port to ix86/MinGW (2004).
â€¢Scott L. Burson9for his port to x86 64/Solaris (2007).
â€¢David Holland10for his port to x86 64/BSD systems (2008).
â€¢Ozaki Kiichi11for his port to x86 64/Darwin (Mac OS X) (2012).
1clive@laluna.demon.co.uk
2ax@apax.net
3nollinge@ens-lyon.fr
4brook@nmsu.edu
5spratt@alum.mit.edu
6gbeauchesne@mandrakesoft.com
7jtb@netbsd.org
8csrabak@ig.com.br
9Scott@coral8.com
10dholland@netbsd.org
11gclient.gaap@gmail.com
10 1 ACKNOWLEDGEMENTS
â€¢Jasper Taylor12for his port to x86 64/MinGW64 (2011).
â€¢Jasper Taylor13for his ports to arm32/Linux and arm64/Linux (2021).
Many thanks to Paulo Moura for his continuous help (in particular about Darwin ports), for his ISO
Prolog unit tests and for including GNU Prolog in his logtalk system (2000-).
Many thanks to John Collins, the latexmk maintainer, who greatly helped me to simplify the building of
the documentation using latexmk (2021).
12jasper@simulistics.com
13jasper@simulistics.com
11
2 GNU Prolog License Conditions
GNU Prolog is free software. Since version 1.4.0, GNU Prolog distributed under a dual license: LGPL
orGPL. So, you can redistribute it and/or modify it under the terms of either:
{ the GNU Lesser General Public License (LGPL) as published by the Free Software Foundation; either
version 3 of the License, or (at your option) any later version.
or
{ the GNU General Public License (GPL) as published by the Free Software Foundation; either version
2 of the License, or (at your option) any later version.
orboth in parallel (as here).
GNU Prolog is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received copies of the GNU General Public License and the GNU Lesser General Public
License along with this program. If not, see http://www.gnu.org/licenses/.
Remark: versions of GNU Prolog prior to 1.4.0 were entirely released under the GNU General Public
License (GPL).
3 Introduction
GNU Prolog [5] is a free Prolog compiler with constraint solving over nite domains. For recent infor-
mation about GNU Prolog please consult the GNU Prolog page.
GNU Prolog is a Prolog compiler based on the Warren Abstract Machine (WAM) [9, 1]. It rst compiles
a Prolog program to a WAM le which is then translated to a low-level machine independent language
called mini-assembly specically designed for GNU Prolog. The resulting le is then translated to the
assembly language of the target machine (from which an object is obtained). This allows GNU Prolog
to produce a native stand alone executable from a Prolog source (similarly to what does a C compiler
from a C program). The main advantage of this compilation scheme is to produce native code and to be
fast. Another interesting feature is that executables are small. Indeed, the code of most unused built-in
predicates is not included in the executables at link-time.
A lot of work has been devoted to the ISO compatibility. Indeed, GNU Prolog is very close to the ISO
standard for Prolog [6].
GNU Prolog also oers various extensions very useful in practice (global variables, OS interface, sock-
ets,...). In particular, GNU Prolog contains an ecient constraint solver over Finite Domains (FD). This
opens constraint logic programming to the user combining the power of constraint programming to the
declarativity of logic programming. The key feature of the GNU Prolog solver is the use of a single (low-
level) primitive to dene all (high-level) FD constraints. There are many advantages of this approach:
constraints can be compiled, the user can dene his own constraints (in terms of the primitive), the solver
is open and extensible (as opposed to black-box solvers like CHIP),. . . Moreover, the GNU Prolog solver
is rather ecient, often more than commercial solvers.
GNU Prolog is inspired from two systems:
12 3 INTRODUCTION
â€¢wamcc : a Prolog to C compiler [3]. the key point of wamcc was its ability to produce stand alone
executables using an original compilation scheme: the translation of Prolog to C via the WAM.
Its drawback was the time needed by gccto compile the produced sources. GNU Prolog can also
produce stand alone executables but using a faster compilation scheme.
â€¢clp(FD) : a constraint programming language over FD [4]. Its key feature was the use of a single
primitive to dene FD constraints. GNU Prolog is based on the same idea but oers an extended
constraint denition language. In comparison to clp(FD) , GNU Prolog oers new predened con-
straints, new predened heuristics, reied constraints,. . .
Here are some features of GNU Prolog:
â€¢Prolog system:
{conforms to the ISO standard for Prolog (oating point numbers, streams, dynamic code,. . . ).
{a lot of extensions: global variables, denite clause grammars (DCG), sockets interface, oper-
ating system interface,. . .
{more than 300 Prolog built-in predicates.
{Prolog debugger and a low-level WAM debugger.
{line editing facility under the interactive interpreter with completion on atoms.
{powerful bidirectional interface between Prolog and C.
â€¢Compiler:
{native-code compiler producing stand alone executables.
{simple command-line compiler accepting a wide variety of les: Prolog les, C les, WAM
les,. . .
{direct generation of assembly code 15 times faster than wamcc +gcc.
{most of unused built-in predicates are not linked (to reduce the size of the executables).
{compiled predicates (native-code) as fast as wamcc on average.
{consulted predicates (byte-code) 5 times faster than wamcc .
â€¢Constraint solver:
{FD variables well integrated into the Prolog environment (full compatibility with Prolog vari-
ables and integers). No need for explicit FD declarations.
{very ecient FD solver (comparable to commercial solvers).
{high-level constraints can be described in terms of simple primitives.
{a lot of predened constraints: arithmetic constraints, boolean constraints, symbolic con-
straints, reied constraints,. . .
{several predened enumeration heuristics.
{the user can dene his own new constraints.
{more than 50 FD built-in constraints/predicates.
13
4 Using GNU Prolog
4.1 Introduction
GNU Prolog oers two ways to execute a Prolog program:
â€¢interpreting it using the GNU Prolog interactive interpreter.
â€¢compiling it to a (machine-dependent) executable using the GNU Prolog native-code compiler.
Running a program under the interactive interpreter allows the user to list it and to make full use of the
debugger on it (section 5, page 31). Compiling a program to native code makes it possible to obtain a
stand alone executable, with a reduced size and optimized for speed. Running a Prolog program compiled
to native-code is around 3-5 times faster than running it under the interpreter. However, it is not possible
to make full use of the debugger on a program compiled to native-code. Nor is it possible to list the
program. In general, it is preferable to run a program under the interpreter for debugging and then
use the native-code compiler to produce an autonomous executable. It is also possible to combine these
two modes by producing an executable that contains some parts of the program (e.g. already debugged
predicates whose execution-time speed is crucial) and interpreting the other parts under this executable.
In that case, the executable has the same facilities as the GNU Prolog interpreter but also integrates
the native-code predicates. This way to dene a new enriched interpreter is detailed later (section 4.4.5,
page 27).
4.2 The GNU Prolog interactive interpreter
4.2.1 Starting/exiting the interactive interpreter
GNU Prolog oers a classical Prolog interactive interpreter also called top-level . It allows the user to
execute queries, to consult Prolog programs, to list them, to execute them and to debug them. The
top-level can be invoked using the following command:
% gprolog [OPTION ]. . . (the %symbol is the operating system shell prompt)
Options :
--init-goal GOAL execute GOAL before entering the top-level
--consult-file FILE consult FILE inside the top-level
--entry-goal GOAL execute GOAL inside the top-level
--query-goal GOAL execute GOAL as a query for the top-level
--help print a help and exit
--version print version number and exit
-- do not parse the rest of the command-line
The main role of the gprolog command is to execute the top-level itself, i.e. to execute the built-in
predicate toplevel/0 (section 8.18.1, page 126) which will produce something like:
GNU Prolog 1.5.0 (64 bits)
Compiled May 3 2021, 16:36:43 with gcc
Copyright (C) 1999-2021 Daniel Diaz
| ?-
The top-level is ready to execute your queries as explained in the next section.
14 4 USING GNU PROLOG
To quit the top-level type the end-of-le key sequence ( Ctl-D ) or its term representation: endoffile.
It is also possible to use the built-in predicate halt/0 (section 8.18.1, page 126).
However, before entering the top-level itself, the command-line is processed to treat all known options
(those listed above). All unrecognized arguments are collected together to form the argument list which
will be available using argument value/2 (section 8.27.2, page 160) or argument list/1 (section 8.27.3,
page 161). The --option stops the parsing of the command-line, all remainding options are collected
into the argument list.
Several options are provided to execute a goal before entering the interaction with the user:
â€¢The --init-goal option executes the GOAL as soon as it is encountered (while the command-line
is processed). GOAL is thus executed before entering toplevel/0 .
â€¢The --consult-file option consults the FILE at the entry of toplevel/0 just after the banner
is displayed. --consult-file options are handled before --consult-file options.
â€¢The --entry-goal option executes the GOAL at the entry of toplevel/0 just after the banner is
displayed.
â€¢The --query-goal option executes the GOAL as if the user has typed in (under the top-level).
The above order is thus the order in which each kind of goal (init, entry, query) is executed. If there
are several goals of a same kind they are executed in the order of appearance. Thus, all init goals are
executed (in the order of appearance) before all entry goals and all entry goals are executed before all
query goals.
Each GOAL is passed as a shell argument (i.e. one shell string) and should not contain a terminal dot.
Example: --init-goal 'write(hello), nl' under a sh-like. To be executed, a GOAL is transformed
into a term using read term from atom(Goal, Term, [end ofterm(eof)]) . Respecting both the syn-
tax of shell strings and of Prolog can be heavy. For instance, passing a backslash character \can be
dicult since it introduces an escape sequence both in sh and inside Prolog quoted atoms. The use of
back quotes can then be useful since, by default, no escape sequence is processed inside back quotes (this
behavior can be controlled using the back quotes Prolog ag (section 8.22.1, page 148)).
Since the Prolog argument list is created when the whole command-line is parsed, if a --init-goal option
uses argument value/2 orargument list/1 it will obtained the original command-line arguments (i.e.
including all recognized arguments).
Here is an example of using execution goal options:
% gprolog --init-goal 'write(before), nl' --entry-goal 'write(inside), nl'
--query-goal 'append([a,b],[c,d],X)'
will produce the following:
before
GNU Prolog 1.5.0 (64 bits)
Compiled May 3 2021, 16:36:43 with gcc
Copyright (C) 1999-2021 Daniel Diaz
inside
| ?- append([a,b],[c,d],X).
X = [a,b,c,d]
yes
| ?-
4.2 The GNU Prolog interactive interpreter 15
NB: depending on the used shell it may be necessary to use other string delimiters (e.g. use "under
Windows cmd.exe ).
4.2.2 The interactive interpreter read-execute-write loop
The GNU Prolog top-level is built on a classical read-execute-write loop that also allows for re-executions
(when the query is not deterministic) as follows:
â€¢display the prompt, i.e. ' | ?- '.
â€¢read a query (i.e. a goal).
â€¢execute the query.
â€¢in case of success display the values of the variables of the query.
â€¢if there are remaining alternatives (i.e. the query is not deterministic), display a ?and ask the user
who can use one of the following commands: RETURN to stop the execution, ;to compute the next
solution or ato compute all remaining solution.
Here is an example of execution of a query (\nd the lists XandYsuch that the concatenation of Xand
Yis[a,b] "):
| ?- append(X,Y,[a,b,c]).
X = []
Y = [a,b,c] ? ; (here the user presses ;to compute another solution)
X = [a]
Y = [b,c] ? a (here the user presses ato compute all remaining solutions)
X = [a,b]
Y = [c] (here the user is not asked and the next solution is computed)
X = [a,b,c]
Y = [] (here the user is not asked and the next solution is computed)
no (no more solution)
In some cases the top-level can detect that the current solution is the last one (no more alternatives
remaining). In such a case it does not display the ?symbol (and does not ask the user). Example:
| ?- (X=1 ; X=2).
X = 1 ? ; (here the user presses ;to compute another solution)
X = 2 (here the user is not prompted since there are no more alternatives)
yes
The user can stop the execution even if there are more alternatives by typing RETURN .
| ?- (X=1 ; X=2).
X = 1 ? (here the user presses RETURN to stop the execution)
yes
16 4 USING GNU PROLOG
The top-level tries to display the values of the variables of the query in a readable manner. For instance,
when a variable is bound to a query variable, the name of this variable appears. When a variable is a
singleton an underscore symbol is displayed ( is a generic name for a singleton variable, it is also called
an anonymous variable). Other variables are bound to new brand variable names. When a query variable
name Xappears as the value of another query variable Yit is because Xis itself not instantiated otherwise
the value of Xis displayed. In such a case, nothing is output for Xitself (since it is a variable). Example:
| ?- X=f(A,B, ,A), A=k.
A = k (the value of Ais displayed also in f/3forX)
X = f(k,B, ,k) (since Bis a variable which is also a part of X,Bis not displayed)
| ?- functor(T,f,3), arg(1,T,X), arg(3,T,X).
T = f(X, ,X) (the 1stand 3rdargs are equal to X, the 2ndis an anonymous variable)
| ?- read from atom('k(X,Y,X).',T).
T = k(A, ,A) (the 1stand 3rdargs are unied, a new variable name Ais introduced)
The top-level uses variable binding predicates (section 8.5, page 63). To display the value of a variable,
the top-level calls write term/3 with the following option list: [quoted(true),numbervars(false),
namevars(true)] (section 8.14.6, page 108). A term of the form '$VARNAME'(Name) where Name is
an atom is displayed as a variable name while a term of the form '$VAR'(N) where Nis an integer is
displayed as a normal compound term (such a term could be output as a variable name by write term/3 ).
Example:
| ?- X=' $VARNAME'('Y'), Y=' $VAR'(1).
X = Y (the term '$VARNAME'('Y') is displayed as Y)
Y = ' $VAR'(1) (the term '$VAR'(1) is displayed as is)
| ?- X=Y, Y=' $VAR'(1).
X = ' $VAR'(1)
Y = ' $VAR'(1)
In the rst example, Xis explicitly bound to '$VARNAME'('Y') by the query so the top-level displays Y
as the value of X.Yis unied with '$VAR'(1) so the top-level displays it as a normal compound term.
It should be clear that Xis not bound to Y(whereas it is in the second query). This behavior should be
kept in mind when doing variable binding operations.
Finally, the top-level computes the user-time (section 8.24.2, page 155) taken by a query and displays it
when it is signicant. Example:
| ?- retractall(p( )), assertz(p(0)),
repeat,
retract(p(X)),
Y is X + 1,
assertz(p(Y)),
X = 1000, !.
X = 1000
Y = 1001
(180 ms) yes (the query took 180ms of user time)
4.2 The GNU Prolog interactive interpreter 17
4.2.3 Consulting a Prolog program
The top-level allows the user to consult Prolog source les. Consulted predicates can be listed, executed
and debugged (while predicates compiled to native-code cannot). For more information about the dier-
ence between a native-code predicate and a consulted predicate refer to the introduction of this section
(section 4.1, page 13) and to the part devoted to the compiler (section 4.4.1, page 21).
To consult a program use the built-in predicate consult/1 (section 8.23.1, page 153). The argument
of this predicate is a Prolog le name or user to specify the terminal. This allows the user to directly
input the predicates from the terminal. In that case the input shall be terminated by the end-of-le key
sequence ( Ctl-D ) or its term representation: endoffile. A shorthand for consult( FILE )is[FILE ].
Example:
| ?- [user].
{compiling user for byte code...}
even(0).
even(s(s(X))):-
even(X).
(here the user presses Ctl-D to end the input)
{user compiled, 3 lines read - 350 bytes written, 1180 ms}
| ?- even(X).
X = 0 ? ; (here the user presses ;to compute another solution)
X = s(s(0)) ? ; (here the user presses ;to compute another solution)
X = s(s(s(s(0)))) ? (here the user presses RETURN to stop the execution)
yes
| ?- listing.
even(0).
even(s(s(A))) :-
even(A).
When consult/1 (section 8.23.1, page 153) is invoked on a Prolog le it rst runs the GNU Prolog
compiler (section 4.4, page 21) as a child process to generate a temporary WAM le for byte-code. If
the compilation fails a message is displayed and nothing is loaded. If the compilation succeeds, the
produced le is loaded into memory using load/1 (section 8.23.2, page 153). Namely, the byte-code of
each predicate is loaded. When a predicate Pis loaded if there is a previous denition for Pit is removed
(i.e. all clauses dening Pare erased). We say that Pis redened. Note that only consulted predicates
can be redened. If Pis a native-code predicate, trying to redene it will produce an error at load-time:
the predicate redenition will be ignored and the following message displayed:
native code procedure Pcannot be redefined
Finally, an existing predicate will not be removed if it is not re-loaded. This means that if a predicate P
is loaded when consulting the le F, and if later the denition of Pis removed from the le F, consulting
Fagain will not remove the previously loaded denition of Pfrom the memory.
Consulted predicates can be debugged using the Prolog debugger. Use the debugger predicate trace/0
ordebug/0 (section 5.3.1, page 31) to activate the debugger.
18 4 USING GNU PROLOG
4.2.4 Scripting Prolog
Since version 1.4.0 it is possible to use a Prolog source le as a Unix script-le (shebang support). A
PrologScript le should begin as follows:
#!/usr/bin/gprolog --consult-file
GNU Prolog will be invoked as
/usr/bin/gprolog --consult-file FILE
Then FILE will be consulted. In order to correctly deal with the #!rst line, consult/1 treats as a
comment a rst line of a le which begins with #(if you want to use a predicate name starting with a #,
simply skip a line before its denition).
Remark: it is almost never possible to pass additionnal parameters (e.g. query-goal ) this way since in
most systems the shebang implementation deliver all arguments (following #!/usr/bin/gprolog ) as a
single string (which cannot then correctly be recognized by gprolog ).
4.2.5 Interrupting a query
Under the top-level it is possible to interrupt the execution of a query by typing the interruption key
(Ctl-C ). This can be used to abort a query, to stop an innite loop, to activate the debugger,. . . When an
interruption occurs the top-level displays the following message: Prolog interruption (h for help) ?
The user can then type one of the following commands:
Command Name Description
a abort abort the current execution. Same as abort/0 (section 8.18.1, page 126)
e exit quit the current Prolog process. Same as halt/0 (section 8.18.1, page 126)
b break invoke a recursive top-level. Same as break/0 (section 8.18.1, page 126)
c continue resume the execution
t trace start the debugger using trace/0 (section 5.3.1, page 31)
d debug start the debugger using debug/0 (section 5.3.1, page 31)
hor? help display a summary of available commands
4.2.6 The line editor
The line editor ( linedit ) allows the user to build/update the current input line using a variety of
commands. This facility is available if the linedit part of GNU Prolog has been installed. linedit is
implicitly called by any built-in predicate reading from a terminal (e.g. getchar/1 ,read/1 ,. . . ). This
is the case when the top-level reads a query.
Bindings : each command of linedit is activated using a key. For some commands another key is also
available to invoke the command (on some terminals this other key may not work properly while the
primary key always works). Here is the list of available commands:
4.2 The GNU Prolog interactive interpreter 19
Key Alternate key Description
Ctl-B go to the previous character
Ctl-F! go to the next character
Esc-B Ctl- go to the previous word
Esc-F Ctl-! go to the next word
Ctl-A Home go to the beginning of the line
Ctl-E End go to the end of the line
Ctl-H Backspace delete the previous character
Ctl-D Delete delete the current character
Ctl-U Ctl-Home delete from beginning of the line to the current character
Ctl-K Ctl-End delete from the current character to the end of the line
Esc-L lower case the next word
Esc-U upper case the next word
Esc-C capitalize the next word
Ctl-T exchange last two characters
Ctl-V Insert switch on/o the insert/replace mode
Ctl-I Tab complete word (twice displays all possible completions)
Esc-Ctl-I Esc-Tab insert spaces to emulate a tabulation
Ctl-space mark beginning of the selection
Esc-W copy (from the begin selection mark to the current character)
Ctl-W cut (from the begin selection mark to the current character)
Ctl-Y paste
Ctl-P " recall previous history line
Ctl-N # recall next history line
Esc-P recall previous history line beginning with the current prex
Esc-N recall next history line beginning with the current prex
Esc-< Page Up recall rst history line
Esc-> Page Down recall last history line
Ctl-C generate an interrupt signal (section 4.2.5, page 18)
Ctl-D generate an end-of-le character (at the begin of the line)
RETURN validate a line
Esc-? display a summary of available commands
History : when a line is entered (i.e. terminated by RETURN ),linedit records it in an internal list called
history. It is later possible to recall history lines using appropriate commands (e.g. Ctl-P recall the last
entered line) and to modify them as needed. It is also possible to recall a history line beginning with a
given prex. For instance to recall the previous line beginning with write simply type write followed
byEsc-P . Another Esc-P will recall an earlier line beginning with write ,. . .
Completion : another important feature of linedit is its completion facility. Indeed, linedit maintains
a list of known words and uses it to complete the prex of a word. Initially this list contains all predened
atoms and the atoms corresponding to available predicates. This list is dynamically updated when a new
atom appears in the system (whether read at the top-level, created with a built-in predicate, associated
with a new consulted predicate,. . . ). When the completion key ( Tab) is pressed linedit acts as follows:
â€¢use the current word as a prex.
â€¢collect all words of the list that begin with this prex.
â€¢complete the current word with the longest common part of all matching words.
â€¢if more than one word matches emit a beep (a second Tabwill display all possibilities).
Example:
20 4 USING GNU PROLOG
| ?- argu (here the user presses Tabto complete the word)
| ?- argument (linedit completes argu with argument and emits a beep)
(the user presses again Tabto see all possible completions)
argument counter (linedit shows 3 possible completions)
argument list
argument value
| ?- argument (linedit redisplays the input line)
| ?- argument c (to select argument counter the user presses candTab)
| ?- argument counter (linedit completes with argument counter )
Balancing :linedit allows the user to check that (square/curly) brackets are well balanced. For this,
when a close bracket symbol, i.e. ),]or}, is typed, linedit determines the associated open bracket,
i.e.(,[or{, and temporarily repositions the cursor on it to show the match.
Customization : the behavior of linedit can be controlled via an environment variable called LINEDIT .
This variable can contain the following substrings:
no do not activated linedit (should the only value of the variable)
ansi=no do not use ANSI escape sequence (unix only)
out=N use the le descriptor Nfor the output (unix only)
gui=no even if compiled with the GUI console run in text mode (windows)
gui=silent if the GUI console is not found, silently run in text mode (windows)
cp=N use code page N(windows text console)
oemput=no do not use Char!Oem conversion when emitting a char (windows text console)
oemget=no do not use Oem!Char conversion when reading a char (windows text console)
4.3 Adjusting the size of Prolog data
GNU Prolog uses several stacks to execute a Prolog program. Each stack has a static size and cannot be
dynamically increased during the execution. For each stack there is a default size but the user can dene
a new size by setting an environment variable. When a GNU Prolog program is run it rst consults these
variables and if they are not dened uses the default sizes. The following table presents each stack of
GNU Prolog with its default size and the name of its associated environment variable:
Since version 1.4.2, the size of the atom table (the table recording all atoms) is managed similarly to
stacks. It is then included in the following table (even if actually it is not a stack but an hash table). In
this table, the associated name is atoms which is the key used in statistics (section 8.24.1, page 155). The
environment variable name is derived from the corresponding Prolog ag maxatom , see (section 8.22.1,
page 148).
Stack Default Environment Description
name size (Kb) variable
local 16384 LOCALSZ control stack (environments and choice-points)
global 32768 GLOBALSZ heap (compound terms)
trail 16384 TRAILSZ conditional bindings (bindings to undo at backtracking)
cstr 16384 CSTRSZ nite domain constraint stack (FD variables and constraints)
atoms 32768 MAXATOM atom table
In addition, under Windows (since version 1.4.0), registry keys are consulted (key names are the same as
environment names). The keys are stored in HKEY CURRENT USER\Software\GnuProlog\ .
If the size of a stack is too small an overow will occur during the execution. In that case GNU Prolog
4.4 The GNU Prolog compiler 21
emits the following error message before stopping:
Sstack overflow (size: NKb, environment variable used: E)
where Sis the name of the stack, Nis the current stack size in Kb and Ethe name of the associated
environment variable. When such a message occurs it is possible to (re)dene the variable Ewith the
new size. For instance to allocate Kb to the local stack under a Unix shell use:
LOCALSZ=32768; export LOCALSZ (under shorbash )
setenv LOCALSZ 32768 (under cshortcsh )
This method allows the user to adjust the size of Prolog stacks. However, in some cases it is preferable
not to allow the user to modify these sizes. For instance, when providing a stand alone executable whose
behavior should be independent of the environment in which it is run. In that case the program should
not consult environment variables and the programmer should be able to dene new default stack sizes.
The GNU Prolog compiler oers this facilities via several command-line options such as --local-size
or--fixed-sizes (section 4.4.3, page 23).
Finally note that GNU Prolog stacks are virtually allocated (i.e. use virtual memory). This means that
a physical memory page is allocated only when needed (i.e. when an attempt to read/write it occurs).
Thus it is possible to dene very large stacks. At the execution, only the needed amount of space will be
physically allocated.
4.4 The GNU Prolog compiler
4.4.1 Dierent kinds of codes
One of the main advantages of GNU Prolog is its ability to produce stand alone executables. A Prolog
program can be compiled to native code to give rise to a machine-dependent executable using the GNU
Prolog compiler. However native-code predicates cannot be listed nor fully debugged. So there is an
alternative to native-code compilation: byte-code compilation. By default the GNU Prolog compiler
produces native-code but via a command-line option it can produce a le ready for byte-code loading.
This is exactly what consult/1 does as was explained above (section 4.2.3, page 17). GNU Prolog also
manages interpreted code using a Prolog interpreter written in Prolog. Obviously interpreted code is
slower than byte-code but does not require the invocation of the GNU Prolog compiler. This interpreter
is used each time a meta-call is needed as by call/1 (section 7.2.3, page 52). This also the case of
dynamically asserted clauses. The following table summarizes these three kinds of codes:
Type Speed Debug ? For what
interpreted-code slow yes meta-call and dynamically asserted clauses
byte-code medium yes consulted predicates
native-code fast no compiled predicates
4.4.2 Compilation scheme
Native-code compilation : a Prolog source is compiled in several stages to produce an object le that
is linked to the GNU Prolog libraries to produce an executable. The Prolog source is rst compiled to
obtain a WAM [9] le. For a detailed study of the WAM the interested reader can refer to \Warren's
Abstract Machine: A Tutorial Reconstruction" [1]. The WAM le is translated to a machine-independent
language specically designed for GNU Prolog. This language is close to a (universal) assembly language
and is based on a very reduced instruction set. For this reason this language is called mini-assembly
(MA). The mini-assembly le is then mapped to the assembly language of the target machine. This
22 4 USING GNU PROLOG
assembly le is assembled to give rise to an object le which is then linked with the GNU Prolog libraries
to provide an executable. The compiler also takes into account Finite Domain constraint denition les.
It translates them to C and invoke the C compiler to obtain object les. The following gure presents
this compilation scheme:
Obviously all intermediate stages are hidden to the user who simply invokes the compiler on his Prolog
le(s) (plus other les: C,. . . ) and obtains an executable. However, it is also possible to stop the
compiler at any given stage. This can be useful, for instance, to see the WAM code produced (perhaps
when learning the WAM). Finally it is possible to give any kind of le to the compiler which will insert
it in the compilation chain at the stage corresponding to its type. The type of a le is determined using
the sux of its le name. The following table presents all recognized types/suxes:
4.4 The GNU Prolog compiler 23
Sux of the le Type of the le Handled by:
.pl,.pro ,.prolog Prolog source le pl2wam
.wam WAM source le wam2ma
.ma Mini-assembly source le ma2asm
.s Assembly source le the assembler
.c,.C,.CC,.cc,.cxx ,.c++ ,.cpp C or C++ source le the C compiler
.fd Finite Domain constraint source le fd2c
any other sux ( .o,.a,. . . ) any other type (object, library,. . . ) the linker (C linker)
Byte-code compilation : the same compiler can be used to compile a source Prolog le for byte-code.
In that case the Prolog to WAM compiler is invoked using a specic option and produces a WAM for
byte-code source le (suxed .wbc ) that can be later loaded using load/1 (section 8.23.2, page 153).
Note that this is exactly what consult/1 (section 8.23.1, page 153) does as explained above (section 4.2.3,
page 17).
4.4.3 Using the compiler
The GNU Prolog compiler is a command-line compiler similar in spirit to a Unix C compiler like gcc.
To invoke the compiler use the gplc command as follows:
% gplc [OPTION ]. . . FILE . . . (the %symbol is the operating system shell prompt)
The arguments of gplc are le names that are dispatched in the compilation scheme depending on the
type determined from their sux as was explained previously (section 4.4.2, page 21). All object les are
then linked to produce an executable. Note however that GNU Prolog has no module facility (since there
is not yet an ISO reference for Prolog modules) thus a predicate dened in a Prolog le is visible from
any other predicate dened in any other le. GNU Prolog allows the user to split a big Prolog source
into several les but does not oer any way to hide a predicate from others.
The simplest way to obtain an executable from a Prolog source le prog.pl is to use:
% gplc prog.pl
This will produce an native executable called prog which can be executed as follows:
% prog
However, there are several options that can be used to control the compilation:
General options :
-oFILE ,--output FILE useFILE as the name of the output le
-W,--wam-for-native stop after producing WAM le(s)
-w,--wam-for-byte-code stop after producing WAM for byte-code le(s) (force --no-call-c )
-M,--mini-assembly stop after producing mini-assembly le(s)
-S,--assembly stop after producing assembly le(s)
-F,--fd-to-c stop after producing C le(s) from FD constraint denition le(s)
-c,--object stop after producing object le(s)
--temp-dir PATH usePATH as directory for temporary les
--no-del-temp do not delete temporary les
--no-demangling do not decode predicate names (name demangling)
-v,--verbose print executed commands
-h,--help print a help and exit
--version print version number and exit
24 4 USING GNU PROLOG
Prolog to WAM compiler options :
--pl-state FILE read FILE to set the initial Prolog state
--wam-comment COMMENT emit COMMENT as a comment in the WAM le
--no-susp-warn do not show warnings for suspicious predicates
--no-singl-warn do not show warnings for named singleton variables
--no-redef-error do not show errors for built-in predicate redenitions
--foreign-only only compile foreign/1-2 directives
--no-call-c do not allow the use of fdtell ,'$call c',. . .
--no-inline do not inline predicates
--no-reorder do not reorder predicate arguments
--no-reg-opt do not optimize registers
--min-reg-opt minimally optimize registers
--no-opt-last-subterm do not optimize last subterm compilation
--fast-math use fast mathematical mode (assume integer arithmetics)
--keep-void-inst keep void WAM instructions in the output le
--compile-msg print a compile message
--statistics print statistics information
WAM to mini-assembly translator options :
--comment include comments in the output le
Mini-assembly to assembly translator options :
--comment include comments in the output le
--pic produce position independent code (PIC)
C compiler options :
--c-compiler FILE useFILE as C compiler/linker
-COPTION pass OPTION to the C compiler
Assembler options :
-AOPTION pass OPTION to the assembler
Linker options :
4.4 The GNU Prolog compiler 25
--linker FILE useFILE as linker
--local-size N set default local stack size to NKb
--global-size N set default global stack size to NKb
--trail-size N set default trail stack size to NKb
--cstr-size N set default constraint stack size to NKb
--max-atom N set default atom table size to Natoms
--fixed-sizes do not consult environment variables at run-time (use default sizes)
--gui-console link with the GUI console (windows only)
--new-top-level link the top-level main (to recognize top-level command-line options)
--no-top-level do not link the top-level (force --no-debugger )
--no-debugger do not link the Prolog/WAM debugger
--min-pl-bips link only used Prolog built-in predicates
--min-fd-bips link only used FD solver built-in predicates
--min-bips shorthand for: --no-top-level --min-pl-bips --min-fd-bips
--min-size shorthand for: --min-bips --strip
--no-fd-lib do not look for the FD library (maintenance only)
-s,--strip strip the executable
-LOPTION Pass OPTION to the linker
It is possible to only give the prex of an option if there is no ambiguity.
The name of the output le is controlled via the -oFILE option. If present the output le produced will
be named FILE . If not specied, the output le name depends on the last stage reached by the compiler.
If the link is not done the output le name(s) is the input le name(s) with the sux associated with
the last stage. If the link is done, the name of the executable is the name (without sux) of the rst le
name encountered in the command-line. Note that if the link is not done -ohas no sense in the presence
of multiple input le names. For this reason, several meta characters are available for substitution in
FILE :
â€¢%fis substitued by the whole input le name.
â€¢%Fis similar to %fbut the directory part is omitted.
â€¢%pis substitued by the whole prex le name (omitting the sux).
â€¢%Pis similar to %pbut the directory part is omitted.
â€¢%sis substitued by the le sux (including the dot).
â€¢%dis substitued by the directory part (empty if no directory is specied).
â€¢%cis substitued by the value of an internal counter starting from 1 and auto-incremented.
By default the compiler runs in the native-code compilation scheme. To generate a WAM le for byte-code
use the --wam-for-byte-code option. The resulting le can then be loaded using load/1 (section 8.23.2,
page 153).
To execute the Prolog to WAM compiler in a given read environment (operator denitions, character
conversion table,. . . ) use --pl-state FILE . The state le should be produced by write plstate file/1
(section 8.22.5, page 152).
By default the Prolog to WAM compiler inlines calls to some deterministic built-in predicates (e.g. arg/3
andfunctor/3 ). Namely a call to such a predicate will not yield a classical predicate call but a simple
C function call (which is obviously faster). It is possible to avoid this using --no-inline .
Another optimization performed by the Prolog to WAM compiler is unication reordering. The arguments
of a predicate are reordered to optimize unication. This can be deactivated using --no-reorder . The
26 4 USING GNU PROLOG
compiler also optimizes the unication/loading of nested compound terms. More precisely, the compiler
emits optimized instructions when the last subterm of a compound term is itself a compound term (e.g.
lists). This can be deactivated using --no-opt-last-subterm .
By default the Prolog to WAM compiler fully optimizes the allocation of registers to decrease both the
number of instruction produced and the number of used registers. A good allocation will generate many
void instructions that are removed from the produced le except if --keep-void-inst is specied. To
prevent any optimization use --no-reg-opt while --min-reg-opt forces the compiler to only perform
simple register optimizations.
The Prolog to WAM compiler emits an error when a control construct or a built-in predicate is redened.
This can be avoided using --no-redef-error . The compiler also emits warnings for suspicious predicate
denitions like -/2since this often corresponds to an earlier syntax error (e.g. -instead of . This can
be deactivated by specifying --no-susp-warn . Finally, the compiler warns when a singleton variable has
a name (i.e. not the generic anonymous name ). This can be deactivated specifying --no-singl-warn .
Internally, predicate names are encoded to t the syntax of (assembly) identiers. For this GNU Prolog
uses it own name mangling scheme. This is explained in more detail later (section 4.4.6, page 28). By
default the error messages from the linker (e.g. multiple denitions for a given predicate, reference to
an undened predicate,. . . ) are ltered to replace an internal name representation by the real predicate
name (demangling). Specifying the --no-demangling prevents gplc from ltering linker output messages
(internal identiers are then shown).
When producing an executable it is possible to specify default stack sizes (using --STACK NAME -size )
and to prevent it from consulting environment variables (using --fixed-sizes ) as was explained above
(section 4.3, page 20). By default the produced executable will include the top-level, the Prolog/WAM
debugger and all Prolog and FD built-in predicates. It is possible to avoid linking the top-level (sec-
tion 4.2, page 13) by specifying --no-top-level . In this case, at least one initialization/1 directive
(section 7.1.14, page 50) should be dened. The option --no-debugger does not link the debugger. To in-
clude only used built-in predicates that are actually used the options --no-pl-bips and/or --no-fd-bips
can be specied. For the smallest executable all these options should be specied. This can be abbre-
viated by using the shorthand option --min-bips . By default, executables are not stripped , i.e. their
symbol table is not removed. This table is only useful for the C debugger (e.g. when interfacing Prolog
and C). To remove the symbol table (and then to reduce the size of the nal executable) use --strip .
Finally --min-size is a shortcut for --min-bips and--strip , i.e. the produced executable is as small
as possible.
Example: compile and link two Prolog sources prog1.pl and prog2.pl . The resulting executable will
be named prog1 (since -ois not specied):
% gplc prog1.pl prog2.pl
Example: compile the Prolog le prog.pl to study basic WAM code. The resulting le will be named
prog.wam :
% gplc -W --no-inline --no-reorder --keep-void-inst prog.pl
Example: compile the Prolog le prog.pl and its C interface le utils.c to provide an autonomous
executable called mycommand . The executable is not stripped to allow the use of the C debugger:
% gplc -o mycommand prog.pl utils.c
Example: detail all steps to compile the Prolog le prog.pl (the resulting executable is stripped). All
intermediate les are produced ( prog.wam ,prog.ma ,prog.s ,prog.o and the executable prog ):
% gplc -W prog.pl
% gplc -M --comment prog.wam
4.4 The GNU Prolog compiler 27
% gplc -S --comment prog.ma
% gplc -c prog.s
% gplc -o prog -s prog.o
4.4.4 Running an executable
In this section we explain what happens when running an executable produced by the GNU Prolog native-
code compiler. The default main function rst starts the Prolog engine. This function collects all linked
objects (issued from the compilation of Prolog les) and initializes them. The initialization of a Prolog
object le consists in adding to appropriate tables new atoms, new predicates and executing its system
directives. A system directive is generated by the Prolog to WAM compiler to reect a (user) directive
executed at compile-time such as op/3 (section 7.1.11, page 49). Indeed, when the compiler encounters
such a directive it immediately executes it and also generates a system directive to execute it at the
start of the executable. When all system directives have been executed the Prolog engine executes all
initialization directives dened with initialization/1 (section 7.1.14, page 50). If several initialization
directives appear in the same le they are executed in the order of appearance. If several initialization
directives appear in dierent les the order in which they are executed is machine-dependant. However,
on most machines the order will be the reverse order in which the associated les have been linked (this
is not true under native win32). When all initialization directives have been executed the default main
function looks for the GNU Prolog top-level. If present (i.e. it has been linked) it is called otherwise the
program simply ends. Note that if the top-level is not linked and if there is no initialization directive the
program is useless since it simply ends without doing any work. The default main function detects such
a behavior and emits a warning message.
Example: compile an empty le prog.pl without linking the top-level and execute it:
% gplc --no-top-level prog.pl
% prog
Warning: no initial goal executed
use a directive :- initialization(Goal)
or remove the link option --no-top-level (or --min-bips or --min-size)
4.4.5 Generating a new interactive interpreter
In this section we show how to dene a new top-level extending the GNU Prolog interactive interpreter
with new predicate denitions. The obtained top-level can then be considered as an enriched version of
the basic GNU Prolog top-level (section 4.2, page 13). Indeed, each added predicate can be viewed as
a predened predicate just like any other built-in predicate. This can be achieved by compiling these
predicates and including the top-level at link-time.
The real question is: why would we include some predicates in a new top-level instead of simply consulting
them under the GNU Prolog top-level ? There are two reasons for this:
â€¢the predicate cannot be consulted. This is the case of a predicate calling foreign code, like a
predicate interfacing with C (section 10, page 201) or a predicate dening a new FD constraint.
â€¢the performance of the predicate is crucial. Since it is compiled to native-code such a predicate will
be executed very quickly. Consulting will load it as byte-code. The gain is much more noticeable if
the program is run under the debugger. The included version will not be aected by the debugger
while the consulted version will be several times slower. Obviously, a predicate should be included
in a new top-level only when it is itself debugged since it is dicult to debug native-code.
28 4 USING GNU PROLOG
To dene a new top-level simply compile the set of desired predicates and linking them with the GNU
Prolog top-level (this is the default) using gplc (section 4.4.3, page 23).
Example: let us dene a new top-level called mytoplevel including all predicates dened in prog.pl :
% gplc -o my toplevel prog.pl
By the way, note that if prog.pl is an empty Prolog le the previous command will simply create a new
interactive interpreter similar to the GNU Prolog top-level.
Example: as before where some predicates of prog.pl call C functions dened in utils.c :
% gplc -o my toplevel prog.pl utils.c
To obtain a fully extended executable, it is desirable to accept the same set of opions as the original
top-level, see (section 4.2, page 13), e.g. --init-goal . For this it is necessary to link main() function
used by the original top-level. This can be achieved passing the --new-top-level togplc :
% gplc --new-top-level -o my toplevel prog.pl utils.c
In conclusion, dening a particular top-level is nothing else but a particular case of the native-code
compilation. It is simple to do and very useful in practice.
4.4.6 The name mangling scheme
When the GNU Prolog compiler compiles a Prolog source to an object le it has to associate a symbol to
each predicate name. However, the syntax of symbols is restricted to identiers: string containing only
letters, digits or underscore characters. On the other hand, predicate names (i.e. atoms) can contain any
character with quotes if necessary (e.g. 'x+y=z' is a valid predicate name). The compiler may thus have
to encode predicate names respecting the syntax of identiers. In addition, Prolog allows the user to
dene several predicates with the same name and dierent arities, for this GNU Prolog encodes predicate
indicators (predicate name followed by the arity). Finally, to support modules in the future, the module
name is also encoded.
Since version 1.4.0, GNU Prolog adopts the following name mangling scheme. A predicate indicator
of the form [ MODULE :]PRED /N(where the MODULE can be omitted) will give rise to an identier of the
following form: XK[E(MODULE )]E(PRED )aNwhere:
Kis a digit in 0..5storing coding information about MODULE andPRED . Possible values are:
â€¢0: no module present, PRED is not encoded
â€¢1: no module present, PRED is encoded
â€¢2:MODULE is not encoded, PRED is not encoded
â€¢3:MODULE is not encoded, PRED is encoded
â€¢4:MODULE is encoded, PRED is not encoded
â€¢5:MODULE is encoded, PRED is encoded
E(STR)is a function to encode a string STRwhich returns:
â€¢STRitself (not encoded) if STRonly contains letters, digits or but does not contain the sub-
string and does not begin nor end with (i.e. regexp: [a-zA-Z0-9]([-]?[a-zA-Z0-9])* ).
â€¢an hexadecimal representation of each character of the string otherwise. For example: E(x+y=z )
returns 782B793D7A since 78is the hexadecimal representation of the ASCII code of x,2Bof
the code of +, etc.
Examples:
4.4 The GNU Prolog compiler 29
Predicate indicator internal identier
father/2 X0father a2
'x+y=z'/3 X1782B793D7A a3
util:same/2 X2util same a2
util:same 1/3 X3util 73616D655F5F31 a3
So, from the mini-assembly stage, each predicate indicator is handled via its name mangling identier.
The knowledge of this scheme is normally not of interest for the user, i.e. the Prolog programmer. For this
reason the GNU Prolog compiler hides this mangling. When an error occurs on a predicate (undened
predicate, predicate with multiple denitions,. . . ) the compiler has to decode the symbol associated
with the predicate indicator (name demangling). For this gplc lters each message emitted by the
linker to locate and decode eventual predicate indicators. This ltering can be deactivated specifying
--no-demangling when invoking gplc (section 4.4.3, page 23).
This lter is provided as an utility that can be invoked using the hexgplc command as follows:
% hexgplc [OPTION ]. . . FILE . . . (the %symbol is the operating system shell prompt)
Options :
--decode or--demangling decoding mode (this is the default mode)
--encode or--mangling encoding mode
--relax decode also predicate names (not only predicate indicators)
--printf FORMAT pass encoded/decoded string to C printf(3) with FORMAT
--aux-father decode an auxiliary predicate as its father
--aux-father2 decode an auxiliary predicate as its father + auxiliary number
--cmd-line encode/decode each argument of the command-line
-Eor-M same as: --cmd-line --encode --relax
-Por-D same as: --cmd-line --decode --relax --quote
--help print a help and exit
--version print version number and exit
It is possible to give a prex of an option if there is no ambiguity.
Without arguments hexgplc runs in decoding mode reading its standard input and decoding (demangling)
each symbol corresponding to a predicate indicator. To use hexgplc in the encoding (mangling) mode
the--encode option must be specied. By default hexgplc only decodes predicate indicators, this can
be relaxed using --relax to also take into account simple predicate names (the arity can be omitted). It
is possible to format the output of an encoded/decoded string using --printf FORMAT in that case each
string Sis passed to the C printf(3) function as printf( FORMAT ,S).
Auxiliary predicates are generated by the Prolog to WAM compiler when simplifying some control con-
structs like ';'/2 present in the body of a clause. They are of the form '$NAME /ARITY $auxN'where
NAME /ARITY is the predicate indicator of the simplied (i.e. father) predicate and Nis a sequential num-
ber (a predicate can give rise to several auxiliary predicates). It is possible to force hexgplc to decode
an auxiliary predicate as its father predicate indicator using --aux-father or as its father predicate
indicator followed by the sequential number using --aux-father2 .
If no le is specied, hexgplc processes its standard input otherwise each le is treated sequentially.
Specifying the --cmd-line option informs hexgplc that each argument is not a le name but a string
that must be encoded (or decoded). This is useful to encode/decode a particular string. For this reason
the option -E(encode) and -D(decode) are provided as shorthand. Then, to obtain the mangling
representation of a predicate PRED use:
% hexgplc -E PRED
30 4 USING GNU PROLOG
NB: if PRED is a complex atom it is necessary to quote it (the quotes must be passed to hexgplc ). Here
is an example under bash:
% hexgplc -E \'x+y=z\'/3
X1_782B793D7A__a3
Or even more safely (using bash quotes to prevent bash from interpreting special characters):
% hexgplc -E \''x+y=z'\'/3
X1_782B793D7A__a3
31
5 Debugging
5.1 Introduction
The GNU Prolog debugger provides information concerning the control ow of the program. The debugger
can be fully used on consulted predicates (i.e. byte-code). For native compiled code only the calls/exits
are traced, no internal behavior is shown. Under the debugger it is possible to exhaustively trace the
execution or to set spy-points to only debug a specic part of the program. Spy-points allow the user to
indicate on which predicates the debugger has to stop to allow the user to interact with it. The debugger
uses the \procedure box control ow model", also called the Byrd Box model since it is due to Lawrence
Byrd.
5.2 The procedure box model
The procedure box model of Prolog execution provides a simple way to show the control ow. This
model is very popular and has been adopted in many Prolog systems (e.g. SICStus Prolog, Quintus
Prolog,. . . ). A good introduction is the chapter 8 of \Programming in Prolog" of Clocksin & Mellish [2].
The debugger executes a program step by step tracing an invocation to a predicate ( call ) and the
return from this predicate due to either a success ( exit ) or a failure ( fail ). When a failure occurs
the execution backtracks to the last predicate with an alternative clause. The predicate is then re-
invoked ( redo ). Another source of change of the control ow is due to exceptions. When an exception is
raised from a predicate ( exception ) by throw/1 (section 7.2.4, page 53) the control is given back to the
most recent predicate that has dened a handler to recover this exception using catch/3 (section 7.2.4,
page 53). The procedure box model shows these dierent changes in the control ow, as illustrated here:
Each arrow corresponds to a port. An arrow to the box indicates that the control is given to this predicate
while an arrow from the box indicates that the control is given back from the procedure. This model
visualizes the control ow through these ve ports and the connections between the boxes associated with
subgoals. Finally, it should be clear that a box is associated with one invocation of a given predicate. In
particular, a recursive predicate will give raise to a box for each invocation of the predicate with dierent
entries/exits in the control ow. Since this might get confusing for the user, the debugger associates with
each box a unique identier (i.e. the invocation number).
5.3 Debugging predicates
5.3.1 Running and stopping the debugger
trace/0 activates the debugger. The next invocation of a predicate will be traced.
debug/0 activates the debugger. The next invocation of a predicate on which a spy-point has been set
will be traced.
32 5 DEBUGGING
It is important to understand that the information associated with the control ow is only available when
the debugger is on. For eciency reasons, when the debugger is o the information concerning the control
ow (i.e. the boxes) is not retained. So, if the debugger is activated in the middle of a computation (by
a call to debug/0 ortrace/0 in the program or after the interrupt key sequence ( Ctl-C ) by choosing
trace ordebug ), information prior to this point is not available.
debugging/0 : prints onto the terminal information about the current debugging state (whether the
debugger is switched on, what are the leashed ports, spy-points dened,. . . ).
notrace/0 ornodebug/0 switches the debugger o.
wamdebug/0 invokes the sub-debugger devoted to the WAM data structures (section 5.6, page 35). It
can be also invoked using the Wdebugger command (section 5.5, page 33).
5.3.2 Leashing ports
leash(Ports) requests the debugger to prompt the user, as he creeps through the program, for every
port dened in the Ports list. Each element of Ports is an atom in call ,exit ,redo ,fail ,exception .
Ports can also be an atom dening a shorthand:
â€¢full : equivalent to [call, exit, redo, fail, exception]
â€¢half : equivalent to [call, redo]
â€¢loose : equivalent to [call]
â€¢none : equivalent to []
â€¢tight : equivalent to [call, redo, fail, exception]
When an unleashed port is encountered the debugger continues to show the associated goal but does not
stop the execution to prompt the user.
5.3.3 Spy-points
When dealing with big sources it is not very practical to creep through the entire program. It is preferable
to dene a set of spy-points on interesting predicates to be prompted when the debugger reaches one of
these predicates. Spy-points can be added either using spy/1 (orspypoint condition/3 ) or dynamically
when prompted by the debugger using the +(or*) debugger command (section 5.5, page 33). The current
mode of leashing does not aect spy-points in the sense that user interaction is requested on every port.
spy(PredSpec) sets a spy-point on all the predicates given by PredSpec .PredSpec denes one or several
predicates and has one of the following forms:
â€¢[PredSpec1, PredSpec2,...] : set a spy-point for each element of the list.
â€¢Name : set a spy-point for any predicate whose name is Name (whatever the arity).
â€¢Name/Arity : set a spy-point for the predicate whose name is Name and arity is Arity .
â€¢Name/A1-A2 : set a spy-point for the each predicate whose name is Name and arity is between A1
andA2.
5.4 Debugging messages 33
It is not possible to set a spy-point on an undened predicate.
The following predicate is used to remove one or several spy-points:
nospy(PredSpec) removes the spy-points from the specied predicates.
nospyall/0 removes all spy-points:
It is also possible to dene conditional spy-points.
spypoint condition(Goal, Port, Test) sets a conditional spy-point on the predicate for Goal . When
the debugger reaches a conditional spy-point it only shows the associated goal if the following conditions
are veried:
â€¢the actual goal unies with Goal .
â€¢the actual port unies with Port .
â€¢the Prolog goal Test succeeds.
5.4 Debugging messages
We here described which information is displayed by the debugger when it shows a goal. The basic format
is as follows:
S N M Port :Goal ?
Sis a spy-point indicator: if there is a spy-point on the current goal the +symbol is displayed else a space
is displayed. Nis the invocation number. This unique number can be used to correlate the trace messages
for the various ports, since it is unique for every invocation. Mis an index number which represents the
number of direct ancestors of the goal (i.e. the current depth of the goal). Port species the particular
port ( call ,exit ,fail ,redo ,exception ).Goal is the current goal (it is then possible to inspect its
current instantiation) which is displayed using write term/3 with quoted(true) and maxdepth( D)
options (section 8.14.6, page 108). Initially D(the print depth) is set to 10 but can be redened using
the<debugger command (section 5.5, page 33). The ?symbol is displayed when the debugger is waiting
a command from the user. (i.e. Port is a leashed port). If the port is unleashed, this symbol is not
displayed and the debugger continues the execution displaying the next goal.
5.5 Debugger commands
When the debugger reaches a leashed port it shows the current goal followed by the ?symbol. At this
point there are many commands available. Typing RETURN will creep into the program. Continuing to
creep will show all the control ow. The debugger shows every port for every predicate encountered
during the execution. It is possible to select the ports at which the debugger will prompt the user using
the built-in predicate leash/1 (section 5.3.2, page 32). Each command is only one character long:
34 5 DEBUGGING
Command Name Description
RETorc creep single-step to the next port
l leap continue the execution only stopping when a goal with a spy-point
is reached
s skip skip over the entire execution of the current goal. No message will
be shown until control returns
G go to ask for an invocation number and continue the execution until a port
is reached for that invocation number
r retry try to restart the invocation of the current goal by failing until reach-
ing the invocation of the goal. The state of execution is the same
as when the goal was initially invoked (except when using side-eect
predicates)
f fail force the current goal to fail immediately
w write show the current goal using write/2 (section 8.14.6, page 108)
d display show the current goal using display/2 (section 8.14.6, page 108)
p print show the current goal using print/2 (section 8.14.6, page 108)
e exception show the pending exception. Only applicable to an exception port
g ancestors show the list of ancestors of the current goal
A alternatives show the list of ancestors of the current goal combined with choice-
points
u unify ask for a term and unify the current goal with this term. This is
convenient for getting a specic solution. Only available at a call
port
. father le show the Prolog le name and the line number where the current
predicate is dened
n no debug switch the debugger o. Same as nodebug/0 (section 5.3.1, page 31)
= debugging show debugger information. Same as debugging/0 (section 5.3.1,
page 31)
+ spy this set a spy-point on the current goal. Uses spy/1 (section 5.3.3,
page 32)
- nospy this remove a spy-point on the current goal. Uses nospy/1 (section 5.3.3,
page 32)
* spy conditionally ask for a term Goal, Port, Test (terminated by a dot) and
set a conditional spy-point on the current predicate. Goal and
the current goal must have the same predicate indicator. Uses
spypoint condition/3 (section 5.3.3, page 32)
L listing list all the clauses associated with the current predicate. Uses
listing/1 (section 8.23.3, page 154)
a abort abort the current execution. Same as abort/0 (section 8.18.1,
page 126)
b break invoke a recursive top-level. Same as break/0 (section 8.18.1,
page 126)
@ execute goal ask for a goal and execute it
< set print depth ask for an integer and set the print depth to this value ( -1for no
depth limit)
hor? help display a summary of available commands
W WAM debugger invoke the low-level WAM debugger (section 5.6, page 35)
5.6 The WAM debugger 35
5.6 The WAM debugger
In some cases it is interesting to have access to the WAM data structures. This sub-debugger allows
the user to inspect/modify the contents of any stack or register of the WAM. The WAM debugger is
invoked using the built-in predicate wamdebug/0 (section 5.3.1, page 31) or the Wdebugger command
(section 5.5, page 33). The following table presents the specic commands of the WAM debugger:
Command Description
write A[N] write Nterms starting at the address Ausing write/1 (section 8.14.6, page 108)
data A[N] display Nwords starting at the address A
modify A[N] display and modify Nwords starting at the address A
where A display the real address corresponding to A
what RA display what corresponds to the real address RA
deref A display the dereferenced word starting at the address A
envir [SA] display the contents of the environment located at SA(or the current one)
backtrack [SA]display the contents of the choice-point located at SA(or the current one)
backtrack all display all choice-points
quit quit the WAM debugger
help display a summary of available commands
In the above table the following conventions apply:
â€¢elements between [ and ] are optional.
â€¢Nis an optional integer (defaults to 1).
â€¢Ais a WAM address, its syntax is: BANK NAME [[N]], i.e. a bank name possibly followed by an
index (defaults to 0). BANK NAME is either:
{reg: WAM general register (stack pointers, continuation, ...).
{x: WAM X register (temporary variables, i.e. arguments).
{y: WAM Y register (permanent variables).
{ab: WAM X register saved in the current choice-point.
{STACK NAME : WAM stack ( STACK NAME inlocal ,global ,trail ,cstr ).
â€¢SAis a WAM stack address, i.e. STACK NAME [[N]] (special case of WAM addresses).
â€¢RAis a real address, its syntax is the syntax of C integers (in particular the notation 0x... is
recognized).
It is possible to only use the rst letters of a commands and bank names when there is no ambiguity. Also
the square brackets [ ]enclosing the index of a bank name can be omitted. For instance the following
command (showing the contents of 25 consecutive words of the global stack from the index 3): data
global[3] 25 can be abbreviated as: d g 3 25 .
36 5 DEBUGGING
37
6 Format of denitions
6.1 General format
The denition of control constructs, directives and built-in predicates is presented as follows:
Templates
Species the types of the arguments and which of them shall be instantiated (mode). Types and modes
are described later (section 6.2, page 37).
Description
Describes the behavior (in the absence of any error conditions). It is explicitly mentioned when a built-
in predicate is re-executable on backtracking. Predened operators involved in the denition are also
mentioned.
Errors
Details the error conditions. Possible errors are detailed later (section 6.3, page 39). For directives, this
part is omitted.
Portability
Species whether the denition conforms to the ISO standard or is a GNU Prolog extension.
6.2 Types and modes
The templates part denes, for each argument of the concerned built-in predicate, its mode and type.
The mode species whether or not the argument must be instantiated when the built-in predicate is
called. The mode is encoded with a symbol just before the type. Possible modes are:
â€¢+: the argument must be instantiated.
â€¢-: the argument must be a variable (will be instantiated if the built-in predicate succeeds).
â€¢?: the argument can be instantiated or a variable.
The type of an argument is dened by the following table:
38 6 FORMAT OF DEFINITIONS
Type Description
TYPE list a list whose the type of each element is TYPE
TYPE1 orTYPE2 a term whose type is either TYPE1 orTYPE2
atom an atom
atom property an atom property (section 8.19.11, page 134)
boolean the atom true orfalse
byte an integer0 and255
callable term an atom or a compound term
character a single character atom
character code an integer1 and255
clause a clause (fact or rule)
close option a close option (section 8.10.7, page 82)
compound term a compound term
evaluable an arithmetic expression (section 8.6.1, page 66)
fdbool evaluable a boolean FD expression (section 9.7.1, page 191)
fdlabeling option an FD labeling option (section 9.9.1, page 198)
fdevaluable an arithmetic FD expression (section 9.6.1, page 188)
fdvariable an FD variable
flag a Prolog ag (section 8.22.1, page 148)
float a oating point number
head a head of a clause (atom or compound term)
integer an integer
inbyte an integer0 and255 or -1(for the end-of-le)
incharacter a single character atom or the atom endoffile (for the end-of-le)
incharacter code an integer1 and255 or -1(for the end-of-le)
iomode an atom in: read ,write orappend
list the empty list []or a non-empty list [|]
nonvar any term that is not a variable
number an integer or a oating point number
operator specifier an operator specier (section 8.14.10, page 113)
osfile property an operating system le property (section 8.27.11, page 165)
predicate indicator a term Name/Arity where Name is an atom and Arity an integer0. A
callable term can be given if the strict isoProlog ag is switched o
(section 8.22.1, page 148)
predicate property a predicate property (section 8.8.2, page 75)
read option a read option (section 8.14.1, page 104)
socket address a term of the form 'AFUNIX'(A) or'AFINET'(A,N) where Ais an atom
andNan integer
socket domain an atom in: 'AFUNIX' or'AFINET'
source sink an atom identifying a source or a sink
stream a stream-term: a term of the form '$stream'(N) where Nis an integer0
stream option a stream option (section 8.10.6, page 81)
stream oralias a stream-term or an alias (atom)
stream position a stream position: a term '$stream position'(I1, I2, I3, I4) where
I1,I2,I3andI4are integers
stream property a stream property (section 8.10.10, page 84)
stream seek method an atom in: bof,current oreof
term any term
varbinding option a variable binding option (section 8.5.3, page 64)
write option a write option (section 8.14.6, page 108)
6.3 Errors 39
6.3 Errors
6.3.1 General format and error context
When an error occurs an exception of the form: error( ErrorTerm ,Caller )is raised. ErrorTerm is
a term specifying the error (detailed in next sections) and Caller is a term specifying the context of
the error. The context is either the predicate indicator of the last invoked built-in predicate or an atom
giving general context information.
Using exceptions allows the user both to recover an error using catch/3 (section 7.2.4, page 53) and to
raise an error using throw/1 (section 7.2.4, page 53).
To illustrate how to write error cases, let us write a predicate mypred(X) where Xmust be an integer:
my_pred(X) :-
( nonvar(X) ->
true
; throw(error(instantiation_error, my_pred/1)),
),
( integer(X) ->
true
; throw(error(type_error(integer, X), my_pred/1))
),
...
To help the user to write these error cases, a set of system predicates is provided to raise errors. These
predicates are of the form '$plerr...' and they all refer to the implicit error context. The predicates
setbipname/2 (section 8.22.3, page 151) and current bipname/2 (section 8.22.4, page 151) are pro-
vided to set and recover the name and the arity associated with this context (an arity <0 means that
only the atom corresponding to the functor is signicant). Using these system predicates the user could
dene the above predicate as follow:
my_pred(X) :-
set_bip_name(my_pred,1),
( nonvar(X) ->
true
; '$pl_err_instantiation'
),
( integer(X) ->
true
; '$pl_err_type'(integer, X)
),
...
The following sections detail each kind of errors (and associated system predicates).
6.3.2 Instantiation error
An instantiation error occurs when an argument or one of its components is variable while an instantiated
argument was expected. ErrorTerm has the following form: instantiation error .
The system predicate '$plerrinstantiation' raises this error in the current error context (sec-
tion 6.3.1, page 39).
40 6 FORMAT OF DEFINITIONS
6.3.3 Uninstantiation error
An uninstantiation Error when an argument or one of its components is not a variable, and a variable or a
component as variable is required. ErrorTerm has the following form: uninstantiation error( Culprit )
where Culprit is the argument or one of its components which caused the error.
The system predicate '$plerruninstantiation'(Culprit) raises this error in the current error con-
text (section 6.3.1, page 39).
6.3.4 Type error
A type error occurs when the type of an argument or one of its components is not the expected type
(but not a variable). ErrorTerm has the following form: type error( Type ,Culprit )where Type is
the expected type and Culprit the argument which caused the error. Type is one of:
â€¢atom
â€¢atomic
â€¢boolean
â€¢byte
â€¢callable
â€¢character
â€¢compoundâ€¢evaluable
â€¢fdbool evaluable
â€¢fdevaluable
â€¢fdvariable
â€¢float
â€¢inbyte
â€¢incharacterâ€¢integer
â€¢list
â€¢number
â€¢pair
â€¢predicate indicator
The system predicate '$plerrtype'(Type, Culprit) raises this error in the current error context
(section 6.3.1, page 39).
6.3.5 Domain error
A domain error occurs when the type of an argument is correct but its value is outside the expected
domain. ErrorTerm has the following form: domain error( Domain ,Culprit )where Domain is the
expected domain and Culprit the argument which caused the error. Domain is one of:
â€¢atom property
â€¢buffering mode
â€¢character code list
â€¢close option
â€¢date time
â€¢eofaction
â€¢fdlabeling option
â€¢flag value
â€¢format control sequenceâ€¢garray index
â€¢iomode
â€¢nonempty list
â€¢notless than zero
â€¢operator priority
â€¢operator specifier
â€¢order
â€¢osfile permission
â€¢osfile propertyâ€¢ospath
â€¢predicate property
â€¢prolog flag
â€¢read option
â€¢selectable item
â€¢socket address
â€¢socket domain
â€¢source sink
â€¢statistics key
6.3 Errors 41
â€¢statistics value
â€¢stream
â€¢stream option
â€¢stream oraliasâ€¢stream position
â€¢stream property
â€¢stream seek method
â€¢stream typeâ€¢term stream oralias
â€¢varbinding option
â€¢write option
The system predicate '$plerrdomain'(Domain, Culprit) raises this error in the current error context
(section 6.3.1, page 39).
6.3.6 Existence error
an existence error occurs when an object on which an operation is to be performed does not exist.
ErrorTerm has the following form: existence error( Object ,Culprit )where Object is the type of
the object and Culprit the argument which caused the error. Object is one of:
â€¢procedure â€¢source sink â€¢stream
The system predicate '$plerrexistence'(Object, Culprit) raises this error in the current error
context (section 6.3.1, page 39).
6.3.7 Permission error
A permission error occurs when an attempt to perform a prohibited operation is made. ErrorTerm
has the following form: permission error( Operation ,Permission ,Culprit )where Operation is
the operation which caused the error, Permission the type of the tried permission and Culprit the
argument which caused the error. Operation is one of:
â€¢access
â€¢addalias
â€¢closeâ€¢create
â€¢input
â€¢modifyâ€¢open
â€¢output
â€¢reposition
andPermission is one of:
â€¢binary stream
â€¢flag
â€¢operatorâ€¢past endofstream
â€¢private procedure
â€¢source sinkâ€¢static procedure
â€¢stream
â€¢text stream
The system predicate '$plerrpermission'(Operation, Permission, Culprit) raises this error in
the current error context (section 6.3.1, page 39).
6.3.8 Representation error
A representation error occurs when an implementation limit has been breached. ErrorTerm has the
following form: representation error( Limit )where Limit is the name of the reached limit. Limit
is one of:
42 6 FORMAT OF DEFINITIONS
â€¢character
â€¢character code
â€¢incharacter codeâ€¢maxarity
â€¢maxinteger
â€¢minintegerâ€¢integer 32bits
â€¢toomany variables
The errors maxinteger andmininteger are not currently implemented.
The system predicate '$plerrrepresentation'(Limit) raises this error in the current error context
(section 6.3.1, page 39).
6.3.9 Evaluation error
An evaluation error occurs when an arithmetic expression gives rise to an exceptional value. ErrorTerm
has the following form: evaluation error( Error )where Error is the name of the error. Error is one
of:
â€¢float overflow
â€¢intoverflowâ€¢undefined
â€¢underflowâ€¢zero divisor
The errors float overflow ,intoverflow ,undefined andunderflow are not currently implemented.
The system predicate '$plerrevaluation'(Error) raises this error in the current error context (sec-
tion 6.3.1, page 39).
6.3.10 Resource error
A resource error occurs when GNU Prolog does not have enough resources. ErrorTerm has the following
form: resource error( Resource )where Resource is the name of the resource. Resource is one of:
â€¢print object notlinked â€¢toobigfdconstraint
The system predicate '$plerrresource'(Resource) raises this error in the current error context (sec-
tion 6.3.1, page 39).
6.3.11 Syntax error
A syntax error occurs when a sequence of character does not conform to the syntax of terms. ErrorTerm
has the following form: syntax error( Error )where Error is an atom explaining the error.
The system predicate '$plerrsyntax'(Error) raises this error in the current error context (sec-
tion 6.3.1, page 39).
6.3.12 System error
A system error can occur at any stage. A system error is generally associated with an external component
(e.g. operating system). ErrorTerm has the following form: system error( Error )where Error is
6.3 Errors 43
an atom explaining the error. This is an extension to ISO which only denes system error without
arguments.
The system predicate '$plerrsystem'(Error) raises this error in the current error context (sec-
tion 6.3.1, page 39).
44 6 FORMAT OF DEFINITIONS
45
7 Prolog directives and control constructs
7.1 Prolog directives
7.1.1 Introduction
Prolog directives are annotations inserted in Prolog source les for the compiler. A Prolog directive is
used to specify:
â€¢the properties of some procedures dened in the source le.
â€¢the format and the syntax for read-terms in the source le (using changeable Prolog ags).
â€¢included source les.
â€¢a goal to be executed at run-time.
7.1.2 dynamic/1
Templates
dynamic(+predicate indicator)
dynamic(+predicate indicator list)
dynamic(+predicate indicator sequence)
Description
dynamic(Pred) species that the procedure whose predicate indicator is Pred is a dynamic procedure.
This directive makes it possible to alter the denition of Pred by adding or removing clauses. For more
information refer to the section about dynamic clause management (section 8.7.1, page 70).
This directive shall precede the denition of Pred in the source le.
If there is no clause for Pred in the source le, Pred exists however as an empty predicate (this means
that current predicate(Pred) succeeds).
In order to allow multiple denitions, Pred can also be a list of predicate indicators or a sequence of
predicate indicators using ','/2 as separator.
Portability
ISO directive.
7.1.3 public/1
Templates
public(+predicate indicator)
public(+predicate indicator list)
public(+predicate indicator sequence)
46 7 PROLOG DIRECTIVES AND CONTROL CONSTRUCTS
Description
public(Pred) species that the procedure whose predicate indicator is Pred is a public procedure. This
directive makes it possible to inspect the clauses of Pred . For more information refer to the section about
dynamic clause management (section 8.7.1, page 70).
This directive shall precede the denition of Pred in the source le. Since a dynamic procedure is also
public. It is useless (but correct) to dene a public directive for a predicate already declared as dynamic.
In order to allow multiple denitions, Pred can also be a list of predicate indicators or a sequence of
predicate indicators using ','/2 as separator.
Portability
GNU Prolog directive. The ISO reference does not dene any directive to declare a predicate public
but it does distinguish public predicates. It is worth noting that in most Prolog systems the public/1
directive is as a visibility declaration. Indeed, declaring a predicate as public makes it visible from any
predicate dened in any other le (otherwise the predicate is only visible from predicates dened in the
same source le as itself). When a module system is incorporated in GNU Prolog a more general visibility
declaration shall be provided conforming to the ISO reference.
7.1.4 multifile/1
Templates
multifile(+predicate indicator)
multifile(+predicate indicator list)
multifile(+predicate indicator sequence)
Description
multifile(Pred) species that the procedure whose predicate indicator is Pred is a multie procedure
(the clauses of Pred can reside in several source les). This directive is only supported by GNU Prolog
since version 1.4.0.
The native compilation scheme of GNU Prolog requires that each Prolog source le refering to a multile
predicate Pred must include a multifile(Pred) directive even if no clause are dened in this le for
Pred (i.e. Pred is only called by other predicates in this source le).
Portability
ISO directive.
7.1.5 discontiguous/1
Templates
discontiguous(+predicate indicator)
discontiguous(+predicate indicator list)
discontiguous(+predicate indicator sequence)
Description
7.1 Prolog directives 47
discontiguous(Pred) species that the procedure whose predicate indicator is Pred is a discontiguous
procedure. Namely, the clauses dening Pred are not restricted to be consecutive but can appear anywhere
in the source le.
This directive shall precede the denition of Pred in the source le.
In order to allow multiple denitions, Pred can also be a list of predicate indicators or a sequence of
predicate indicators using ','/2 as separator.
A multile predicate (declared with a multifile/1 directive) cannot be directly called from a le where it
is not declared as multile (the native compiler must know the called predicate is multile). Workarounds:
either call it via a meta-call (e.g. using call/1 ) or declare it as multile in the calling source le). A
good habit is to encapsulate a multile predicate in a monole predicate which invokes it (external call
only invoke the monole wrapper predicate).
Portability
ISO directive.
7.1.6 ensure linked/1
Templates
ensure linked(+predicate indicator)
ensure linked(+predicate indicator list)
ensure linked(+predicate indicator sequence)
Description
ensure linked(Pred) species that the procedure whose predicate indicator is Pred must be included
by the linker. This directive is useful when compiling to native code to force the linker to include the code
of a given predicate. Indeed, if the gplc is invoked with an option to reduce the size of the executable
(section 4.4.3, page 23), the linker only includes the code of predicates that are statically referenced.
However, the linker cannot detect dynamically referenced predicates (used as data passed to a meta-call
predicate). The use of this directive prevents it to exclude the code of such predicates.
In order to allow multiple denitions, Pred can also be a list of predicate indicators or a sequence of
predicate indicators using ','/2 as separator.
Portability
GNU Prolog directive.
7.1.7 built in/0,built in/1,built infd/0,built infd/1
Templates
built in
built in(+predicate indicator)
built in(+predicate indicator list)
built in(+predicate indicator sequence)
built infd
48 7 PROLOG DIRECTIVES AND CONTROL CONSTRUCTS
built infd(+predicate indicator)
built infd(+predicate indicator list)
built infd(+predicate indicator sequence)
Description
built inspecies that the procedures dened from now have the built inproperty (section 8.8.2,
page 75).
built in(Pred) is similar to built in/0 but only aects the procedure whose predicate indicator is
Pred .
This directive shall precede the denition of Pred in the source le.
In order to allow multiple denitions, Pred can also be a list of predicate indicators or a sequence of
predicate indicators using ','/2 as separator.
built infd(resp. built infd(Pred) ) is similar to built in(resp. built in(Pred) ) but sets the
built infdpredicate property (section 8.8.2, page 75).
Portability
GNU Prolog directives.
7.1.8 include/1
Templates
include(+atom)
Description
include(File) species that the content of the Prolog source File shall be inserted. The resulting
Prolog text is identical to the Prolog text obtained by replacing the directive by the content of the Prolog
source File .
In case of File is a relative le name, it is searched in the current directory. If it is not found it is then
searched in each directory of parent includers.
Seeabsolute file name/2 for information about the syntax of File (section 8.26.1, page 158).
Portability
ISO directive.
7.1.9 if/1,else/0 ,endif/0 ,elif/1
Templates
if(+callable term)
else
endif
elif(+callable term)
7.1 Prolog directives 49
Description
These directives are for conditional compilation.
if(Goal) compile subsequent code only if Goal succeeds. Goal is rst processed by expand term/2
(section 8.17.2, page 124). If Goal raises an exception it is printed and Goal fails.
else introduces the elsepart.
endif terminates a conditional compilation part.
elif(Goal) is a shorthand for :- else. :- if(Goal). ::::- endif .
Portability
GNU Prolog directive. Also in SWI and YAP.
7.1.10 ensure loaded/1
Templates
ensure loaded(+atom)
Description
ensure loaded(File) is not supported by GNU Prolog. When such a directive is encountered it is
simply ignored.
Portability
ISO directive. Not supported.
7.1.11 op/3
Templates
op(+integer, +operator specifier, +atom oratom list)
Description
op(Priority, OpSpecifier, Operator) alters the operator table. This directive is executed as soon
as it is encountered by calling the built-in predicate op/3 (section 8.14.10, page 113). A system directive
is also generated to reect the eect of this directive at run-time (section 4.4.4, page 27).
Portability
ISO directive.
7.1.12 char conversion/2
Templates
50 7 PROLOG DIRECTIVES AND CONTROL CONSTRUCTS
char conversion(+character, +character)
Description
char conversion(InChar, OutChar) alters the character-conversion mapping. This directive is exe-
cuted as soon as it is encountered by a call to the built-in predicate char conversion/2 (section 8.14.12,
page 116). A system directive is also generated to reect the eect of this directive at run-time (sec-
tion 4.4.4, page 27).
Portability
ISO directive.
7.1.13 setprolog flag/2
Templates
setprolog flag(+flag, +term)
Description
setprolog flag(Flag, Value) sets the value of the Prolog ag Flag toValue . This directive is exe-
cuted as soon as it is encountered by a call to the built-in predicate setprolog flag/2 (section 8.22.1,
page 148). A system directive is also generated to reect the eect of this directive at run-time (sec-
tion 4.4.4, page 27).
Portability
ISO directive.
7.1.14 initialization/1
Templates
initialization(+callable term)
Description
initialization(Goal) adds Goal to the set of goal which shall be executed at run-time. A user directive
is generated to execute Goal at run-time. If several initialization directives appear in the same le they
are executed in the order of appearance (section 4.4.4, page 27).
Portability
ISO directive.
7.1.15 foreign/2 ,foreign/1
Templates
foreign(+callable term, +foreign option list)
foreign(+callable term)
7.2 Prolog control constructs 51
Description
foreign(Template, Options) denes an interface predicate whose prototype is Template according to
the options given by Options . Refer to the foreign code interface for more information (section 10.3,
page 202).
foreign(Template) is equivalent to foreign(Template, []) .
Portability
GNU Prolog directive.
7.2 Prolog control constructs
GNU Prolog follows the ISO notion of control constructs.
7.2.1 true/0 ,fail/0 ,!/0
Templates
true
fail
!
Description
true always succeeds.
fail always fails (enforces backtracking).
!always succeeds and the for side-eect of removing all choice-points created since the invocation of the
predicate activating it.
Errors
None.
Portability
ISO control constructs.
7.2.2 (',')/2 - conjunction, (;)/2 - disjunction, (->)/2 - if-then, (*->)/2 - soft-cut (soft
if-then)
Templates
','(+callable term, +callable term)
;(+callable term, +callable term)
->(+callable term, +callable term)
*->(+callable term, +callable term)
52 7 PROLOG DIRECTIVES AND CONTROL CONSTRUCTS
Description
Goal1 , Goal2 executes Goal1 and, in case of success, executes Goal2 .
Goal1 ; Goal2 rst creates a choice-point and executes Goal1 . On backtracking Goal2 is executed.
Goal1 -> Goal2 rst executes Goal1 and, in case of success, removes all choice-points created by Goal1
and executes Goal2 . This control construct acts like an if-then ( Goal1 is the test part and Goal2 the then
part). Note that if Goal1 fails ->/2 fails also. ->/2 is often combined with ;/2to dene an if-then-else
as follows: Goal1 -> Goal2 ; Goal3 . Note that Goal1 -> Goal2 is the rst argument of the (;)/2
and Goal3 (the else part) is the second argument. Such an if-then-else control construct rst creates
a choice-point for the else-part (intuitively associated with ;/2) and then executes Goal1 . In case of
success, all choice-points created by Goal1 together with the choice-point for the else-part are removed
andGoal2 is executed. If Goal1 fails then Goal3 is executed.
Goal1 *-> Goal2 ; Goal3 implements the so-called soft-cut. It acts as the above if-then-else except that
ifGoal1 succeeds only Goal3 is cut (the alternative solutions of Goal1 are preserved and can be found
by backtracking). Note that Goal1 *-> Goal2 alone (i.e. without an else branch Goal3 ) is equivalent to
(Goal1 , Goal2) .
',',;,->and*->are predened inx operators (section 8.14.10, page 113).
Errors
Goal1 orGoal2 is a variable instantiation error
Goal1 is neither a variable nor a callable term type error(callable, Goal1)
Goal2 is neither a variable nor a callable term type error(callable, Goal2)
The predicate indicator Pred ofGoal1 orGoal2
does not correspond to an existing procedure
and the value of the unknown Prolog ag is
error (section 8.22.1, page 148)existence error(procedure, Pred)
Portability
ISO control constructs except (*->)/2 which is GNU Prolog specic.
7.2.3 call/1
Templates
call(+callable term)
Description
call(Goal) executes Goal .call/1 succeeds if Goal represents a goal which is true. When Goal contains
a cut symbol !(section 7.2.1, page 51) as a subgoal, the eect of !does not extend outside Goal .
Errors
7.2 Prolog control constructs 53
Goal is a variable instantiation error
Goal is neither a variable nor a callable term type error(callable, Goal)
The predicate indicator Pred ofGoal does not
correspond to an existing procedure and the
value of the unknown Prolog ag is error
(section 8.22.1, page 148)existence error(procedure, Pred)
Portability
ISO control construct.
7.2.4 catch/3 ,throw/1
Templates
catch(?callable term, ?term, ?term)
throw(+nonvar)
Description
catch(Goal, Catcher, Recovery) is similar to call(Goal) (section 7.2.3, page 52). If this succeeds or
fails, so does the call to catch/3 . If however, during the execution of Goal , there is a call to throw(Ball) ,
the current ow of control is interrupted, and control returns to a call of catch/3 that is being executed.
This can happen in one of two ways:
â€¢implicitly, when an error condition for a built-in predicate is satised.
â€¢explicitly, when the program executes a call of throw/1 because the program wishes to abandon
the current processing, and instead to take an alternative action.
throw(Ball) causes the normal ow of control to be transferred back to an existing call of catch/3 .
When a call to throw(Ball) happens, Ball is copied and the stack is unwound back to the call to
catch/3 , whereupon the copy of Ball is unied with Catcher . If this unication succeeds, then catch/3
executes the goal Recovery using call/1 (section 7.2.3, page 52) in order to determine the success or
failure of catch/3 . Otherwise, in case the unication fails, the stack keeps unwinding, looking for an
earlier invocation of catch/3 .Ball may be any non-variable term.
Errors
Ball is a variable instantiation error
IfBall does not unify with the Catcher argument of any call of catch/3 , a system error message is
displayed and throw/1 fails.
When catch/3 calls Goal orRecovery it uses call/1 (section 7.2.3, page 52), an instantiation error ,
atype error or an existence error can then occur depending on Goal orRecovery .
Portability
ISO control constructs.
54 7 PROLOG DIRECTIVES AND CONTROL CONSTRUCTS
55
8 Prolog built-in predicates
8.1 Type testing
8.1.1 var/1 ,nonvar/1 ,atom/1 ,integer/1 ,float/1 ,number/1 ,atomic/1 ,
compound/1 ,callable/1 ,ground/1 ,islist/1 ,list/1 ,
partial list/1 ,list orpartial list/1
Templates
var(?term)
nonvar(?term)
atom(?term)
integer(?term)
float(?term)
number(?term)
atomic(?term)compound(?term)
callable(?term)
ground(?term)
islist(?term)
list(?term)
partial list(?term)
list orpartial list(?term)
Description
var(Term) succeeds if Term is currently uninstantiated (which therefore has not been bound to anything,
except possibly another uninstantiated variable).
nonvar(Term) succeeds if Term is currently instantiated (opposite of var/1 ).
atom(Term) succeeds if Term is currently instantiated to an atom.
integer(Term) succeeds if Term is currently instantiated to an integer.
float(Term) succeeds if Term is currently instantiated to a oating point number.
number(Term) succeeds if Term is currently instantiated to an integer or a oating point number.
atomic(Term) succeeds if Term is currently instantiated to an atom, an integer or a oating point number.
compound(Term) succeeds if Term is currently instantiated to a compound term, i.e. a term of arity >0
(a list or a structure).
callable(Term) succeeds if Term is currently instantiated to a callable term, i.e. an atom or a compound
term.
ground(Term) succeeds if Term is a ground term.
list(Term) succeeds if Term is currently instantiated to a list, i.e. the atom [](empty list) or a term
with principal functor '.'/2 and with second argument (the tail) a list.
islist(Term) behaves like list(Term) (for compatibility purpose).
partial list(Term) succeeds if Term is currently instantiated to a partial list, i.e. a variable or a term
whose the main functor is '.'/2 and the second argument (the tail) is a partial list.
list orpartial list(Term) succeeds if Term is currently instantiated to a list or a partial list.
56 8 PROLOG BUILT-IN PREDICATES
Errors
None.
Portability
var/1 ,nonvar/1 ,atom/1 ,integer/1 ,float/1 ,number/1 ,atomic/1 ,compound/1 callable/1 and
ground/1 are ISO predicates.
list/1 ,partial list/1 andlist orpartial list/1 are GNU Prolog predicates.
8.2 Term unication
8.2.1 (=)/2 - Prolog unication
Templates
=(?term, ?term)
Description
Term1 = Term2 unies Term1 andTerm2 . No occurs check is done, i.e. this predicate does not check if a
variable is unied with a compound term containing this variable (this can lead to an innite loop).
=is a predened inx operator (section 8.14.10, page 113).
Errors
None.
Portability
ISO predicate.
8.2.2 unify with occurs check/2
Templates
unify with occurs check(?term, ?term)
Description
unify with occurs check(Term1, Term2) unies Term1 andTerm2 . The occurs check test is done (i.e.
the unication fails if a variable is unied with a compound term containing this variable).
Errors
None.
Portability
ISO predicate.
8.3 Term comparison 57
8.2.3 (\=)/2 - not Prolog uniable
Templates
\=(?term, ?term)
Description
Term1 \= Term2 succeeds if Term1 andTerm2 are not uniable (no occurs check is done).
\=is a predened inx operator (section 8.14.10, page 113).
Errors
None.
Portability
ISO predicate.
8.3 Term comparison
8.3.1 Standard total ordering of terms
The built-in predicates described in this section allows the user to compare Prolog terms. Prolog terms
are totally ordered according to the standard total ordering of terms which is as follows (from the smallest
term to the greatest):
â€¢variables, oldest rst.
â€¢nite domain variables (section 9.1.1, page 183), oldest rst.
â€¢oating point numbers, in numeric order.
â€¢integers, in numeric order.
â€¢atoms, in alphabetical (i.e. character code) order.
â€¢compound terms, ordered rst by arity, then by the name of the principal functor and by the
arguments in left-to-right order.
A list is treated as a compound term (whose principal functor is '.'/2 ).
The portability of the order of variables is not guaranteed (in the ISO reference the order of variables is
system dependent).
8.3.2 (==)/2 - term identical, (\==)/2 - term not identical,
(@<)/2 - term less than, (@=<)/2 - term less than or equal to,
(@>)/2 - term greater than, (@>=)/2 - term greater than or equal to
Templates
58 8 PROLOG BUILT-IN PREDICATES
==(?term, ?term)
\==(?term, ?term)
@<(?term, ?term)@=<(?term, ?term)
@>(?term, ?term)
@>=(?term, ?term)
Description
These predicates compare two terms according to the standard total ordering of terms (section 8.3.1,
page 57).
Term1 == Term2 succeeds if Term1 andTerm2 are equal.
Term1 \== Term2 succeeds if Term1 andTerm2 are dierent.
Term1 @< Term2 succeeds if Term1 is less than Term2 .
Term1 @=< Term2 succeeds if Term1 is less than or equal to Term2 .
Term1 @> Term2 succeeds if Term1 is greater than Term2 .
Term1 @>= Term2 succeeds if Term1 is greater than or equal to Term2 .
==,\==,@<,@=<,@>and@>=are predened inx operators (section 8.14.10, page 113).
Errors
None.
Portability
ISO predicates.
8.3.3 compare/3
Templates
compare(?atom, +term, +term)
Description
compare(Order, Term1, Term2) compares Term1 and Term2 according to the standard (section 8.3.1,
page 57) and unies Order with:
â€¢the atom <ifTerm1 is less than Term2 .
â€¢the atom =ifTerm1 andTerm2 are equal.
â€¢the atom >ifTerm1 is greater than Term2 .
Errors
Order is neither a variable nor an atom type error(atom, Order)
Order is an atom but not <,=or> domain error(order, Order)
Portability
ISO predicate.
8.4 Term processing 59
8.4 Term processing
8.4.1 functor/3
Templates
functor(+nonvar, ?atomic, ?integer)
functor(-nonvar, +atomic, +integer)
Description
functor(Term, Name, Arity) succeeds if the principal functor of Term isName and its arity is Arity .
This predicate can be used in two ways:
â€¢Term is not a variable: extract the name (an atom or a number if Term is a number) and the arity
ofTerm (ifTerm is atomic Arity = 0).
â€¢Term is a variable: unify Term with a general term whose principal functor is given by Name and
arity is given by Arity .
Errors
Term andName are both variables instantiation error
Term andArity are both variables instantiation error
Term is a variable and Name is neither a variable
nor an atomic termtype error(atomic, Name)
Term is a variable and Arity is neither a variable
nor an integertype error(integer, Arity)
Term is a variable, Name is a constant but not an
atom and Arity is an integer >0type error(atom, Name)
Term is a variable and Arity is an integer >
maxarity ag (section 8.22.1, page 148)representation error(max arity)
Term is a variable and Arity is an integer <0 domain error(not less than zero, Arity)
Portability
ISO predicate.
8.4.2 arg/3
Templates
arg(+integer, +compound term, ?term)
Description
arg(N, Term, Arg) succeeds if the Nthargument of Term isArg.
Errors
Nis a variable instantiation error
Term is a variable instantiation error
Nis neither a variable nor an integer type error(integer, N)
Term is neither a variable nor a compound term type error(compound, Term)
Nis an integer <0 domain error(not less than zero, N)
60 8 PROLOG BUILT-IN PREDICATES
Portability
ISO predicate.
8.4.3 (=..)/2 - univ
Templates
=..(+nonvar, ?list)
=..(-nonvar, +list)
Description
Term =.. List succeeds if List is a list whose head is the atom corresponding to the principal functor
ofTerm and whose tail is a list of the arguments of Term .
=..is a predened inx operator (section 8.14.10, page 113).
Errors
Term is a variable and List is a partial list instantiation error
List is neither a partial list nor a list type error(list, List)
Term is a variable and List is a list whose head
is a variableinstantiation error
List is a list whose head His neither an atom nor
a variable and whose tail is not the empty listtype error(atom, H)
List is a list whose head His a compound term
and whose tail is the empty listtype error(atomic, H)
Term is a variable and List is the empty list domain error(non empty list, [])
Term is a variable and the tail of List has a
length>maxarity ag (section 8.22.1,
page 148)representation error(max arity)
Portability
ISO predicate.
8.4.4 copy term/2
Templates
copy term(?term, ?term)
Description
copy term(Term1, Term2) succeeds if Term2 unies with a term Twhich is a renamed copy of Term1 .
Errors
None.
Portability
ISO predicate.
8.4 Term processing 61
8.4.5 term variables/2 ,term variables/3
Templates
term variables(?term, ?list)
term variables(?term, ?list, ?list)
Description
term variables(Term, List) succeeds if List unies with a list of variables (including FD variables),
each sharing with a unique variable of Term . The variables in List are ordered in order of appearance
traversing Term depth-rst and left-to-right.
term variables(Term, List, Tail) is a dierence-list version of the above predicate, i.e. Tail is the
tail of the variable-list List .
Errors
interm variables/2 List is neither a partial
list nor a listtype error(list, List)
Portability
term variables/2 is an ISO Predicate. term variables/3 is a GNU Prolog predicate.
8.4.6 subsumes term/2
Templates
subsumes term(?term, ?term)
Description
subsumes term(General, Specific) succeeds if General can be made equivalent to Specific by bind-
ing variables in General leaving Specific unaected. The current implementation performs the unica-
tion (with occurs check) and ensures that the variable set of Specific is not changed by the unication
(which is then undone). Note that this predicate fails in the presence of FD variables in Specific .
Errors
None.
Portability
ISO predicate.
8.4.7 acyclic term/1
Templates
acyclic term(?term)
62 8 PROLOG BUILT-IN PREDICATES
Description
acyclic term(Term) succeeds if Term does not contain a cyclic (sub-)term. In this case, Term may be
processed safely. If acyclic term(Term) fails, Term contains a cycle and processing Term is not safe,
because GNU Prolog does not support the unication of cyclic terms but permits their creation. Cycles
can be safely undone by failing over their creation. The use of acyclic term/1 shall thus be reserved to
protect critical predicates against cyclic terms.
Errors
None.
Portability
ISO predicate.
8.4.8 term hash/4 ,term hash/2
Templates
term hash(?term, +integer, +integer, ?integer)
term hash(?term, ?integer)
Description
term hash(Term, Depth, Range, Hash) succeeds if Hash is the hash code of Term . IfTerm is not ground
(see ground/1 (section 8.1.1, page 55)), the predicate simply succeeds ( Hash is not unied). Depth is the
depth limit to scan Term (starting from 1 for the top-level term). With Depth = 0 nothing is hashed,
with 1 only atomic terms and the main functors/arity are hashed,... With Depth = -1 the full term is
considered.
The hash code is as follows: 0 Hash<Range . IfRange = 0 then Hash is not restricted (currently it is
<268435456).
term hash(Term, Hash) is equivalent to term hash(Term, -1, 0, Hash) .
NB: the computed hash code is independent of any runtime context (i.e. it is constant across dierent
executions). It is also independent on the underlying machine.
These predicates are useful to implement hash tables or argument indexing.
Errors
Depth is a variable instantiation error
Depth is neither a variable nor an integer type error(integer, Depth)
Range is a variable instantiation error
Range is neither a variable nor an integer type error(integer, Range)
Range is an integer <0 domain error(not less than zero, Range)
Hash is neither a variable nor an integer type error(integer, Hash)
Portability
GNU Prolog predicate.
8.5 Variable naming/numbering 63
8.4.9 setarg/4 ,setarg/3
Templates
setarg(+integer, +compound term, +term, +boolean)
setarg(+integer, +compound term, +term)
Description
setarg(N, Term, NewValue, Undo) replaces destructively the Nthargument of Term with NewValue .
This assignment is undone on backtracking if Undo =true . This should only used if there is no further
use of the old value of the replaced argument. If Undo =false then NewValue must be either an atom
or an integer.
setarg(N, Term, NewValue) is equivalent to setarg(N, Term, NewValue, true) .
Errors
Nis a variable instantiation error
Nis neither a variable nor an integer type error(integer, N)
Nis an integer <0 domain error(not less than zero, N)
Term is a variable instantiation error
Term is neither a variable nor a compound term type error(compound, Term)
NewValue is neither an atom nor an integer and
Undo =falsetype error(atomic, NewValue)
Undo is a variable instantiation error
Undo is neither a variable nor a boolean type error(boolean, Undo)
Portability
GNU Prolog predicate.
8.5 Variable naming/numbering
8.5.1 name singleton vars/1
Templates
name singleton vars(?term)
Description
name singleton vars(Term) binds each singleton variable appearing in Term with a term of the form
'$VARNAME'(' '). Such a term can be output by write term/3 as a variable name (section 8.14.6,
page 108).
Errors
None.
Portability
GNU Prolog predicates.
64 8 PROLOG BUILT-IN PREDICATES
8.5.2 name query vars/2
Templates
name query vars(+list, ?list)
Description
name query vars(List, Rest) for each element of List of the form Name = Var where Name is an
atom and Vara variable, binds Varwith the term '$VARNAME'(Name) . Such a term can be output by
write term/3 as a variable name (section 8.14.6, page 108). Rest is unied with the list of elements
ofList that have not given rise to a binding. This predicate is provided as a way to name the vari-
able lists obtained returned by read term/3 with variable names(List) orsingletons(List) options
(section 8.14.1, page 104).
Errors
List is a partial list instantiation error
List is neither a partial list nor a list type error(list, List)
Rest is neither a partial list nor a list type error(list, Rest)
Portability
GNU Prolog predicate.
8.5.3 bind variables/2 ,numbervars/3 ,numbervars/1
Templates
bind variables(?term, +var binding option list)
numbervars(?term, +integer, ?integer)
numbervars(?term)
Description
bind variables(Term, Options) binds each variable appearing in Term according to the options given
byOptions .
Variable binding options :Options is a list of variable binding options. If this list contains contradic-
tory options, the rightmost option is the one which applies. Possible options are:
â€¢numbervars : species that each variable appearing in Term should be bound to a term of the form
'$VAR'(N) where Nis an integer. Such a term can be output by write term/3 as a variable name
(section 8.14.6, page 108). This is the default.
â€¢namevars : species that each variables appearing in Term shall be bound to a term of the form
'$VARNAME'(Name) where Name is the atom that would be output by write term/3 seeing a term
of the '$VAR'(N) where Nis an integer. Such a term can be output by write term/3 as a variable
name (section 8.14.6, page 108). This is the alternative to numbervars .
â€¢from(From) : the rst integer Nto use for number/name variables of Term isFrom . The default
value is 0.
â€¢next(Next) : when bind variables/2 succeeds, Next is unied with the (last integer N)+1 used to
bind the variables of Term .
8.5 Variable naming/numbering 65
â€¢exclude(List) : collects all variable names appearing in List to avoid a clash when binding a
variable of Term . Precisely a number NFrom will not be used to bind a variable of Term if:
{there is a sub-term of List of the form '$VAR'(N) or'$VARNAME'(Name) where Name is the
constant that would be output by write term/3 seeing a term of the '$VAR'(N) .
{an element of List is of the form Name = Var where Name is an atom that would be output
bywrite term/3 on seeing a term of the from '$VAR'(N) . This case allows for lists returned
byread term/3 (with variable names(List) orsingletons(List) options) (section 8.14.1,
page 104) and by name query vars/2 (section 8.5.2, page 64).
numbervars(Term, From, Next) is equivalent to bind variables(Term, [from(From), next(Next)] ,
i.e. each variable of Term is bound to '$VAR'(N) where FromN<Next .
numbervars(Term) is equivalent to numbervars(Term, 0, ).
See also term variables (section 8.4.5, page 61) which returns the set of variables of a term.
Errors
Options is a partial list or a list with an element
Ewhich is a variableinstantiation error
Options is neither a partial list nor a list type error(list, Options)
an element Eof the Options list is neither a
variable nor a variable binding optiondomain error(var binding option, E)
From is a variable instantiation error
From is neither a variable nor an integer type error(integer, From)
Next is neither a variable nor an integer type error(integer, Next)
List is a partial list instantiation error
List is neither a partial list nor a list type error(list, List)
Portability
GNU Prolog predicates.
8.5.4 term ref/2
Templates
term ref(+term, ?integer)
term ref(?term, +integer)
Description
term ref(Term, Ref) succeeds if the internal reference of Term isRef. This predicate can be used either
to obtain the internal reference of a term or to obtain the term associated with a given reference. Note
that two identical terms can have dierent internal references. A good way to use this predicate is to
rst record the internal reference of a given term and to later re-obtain the term via this reference.
Errors
Term andRefare both variables instantiation error
Refis neither a variable nor an integer type error(integer, Ref)
Refis an integer <0 domain error(not less than zero, Ref)
Portability
66 8 PROLOG BUILT-IN PREDICATES
GNU Prolog predicate.
8.6 Arithmetic
8.6.1 Evaluation of an arithmetic expression
An arithmetic expression is a Prolog term built from numbers, variables, and functors (or operators)
that represent arithmetic functions. When an expression is evaluated each variable must be bound to
a non-variable expression. An expression evaluates to a number, which may be an integer or a oating
point number. The following table details the components of an arithmetic expression, how they are
evaluated, the types expected/returned and if they are ISO or an extension:
8.6 Arithmetic 67
Expression Result = eval(Expression) Signature ISO
a variable bound to an expression E, result is eval(E) IF!IF Y
an integer number this number I Y
a oating point number this number F Y
pi the value of = 3:141592::: F Y
e the value of e= 2:718281::: F N
epsilon dierence between 1.0 and minimum oat >1.0 F N
+ E eval(E) IF!IF Y
- E -eval(E) IF!IF Y
inc(E) eval(E) + 1 IF!IF N
dec(E) eval(E) - 1 IF!IF N
E1 + E2 eval(E1) +eval(E2) IF, IF!IF Y
E1 - E2 eval(E1) -eval(E2) IF, IF!IF Y
E1 * E2 eval(E1) *eval(E2) IF, IF!IF Y
E1 / E2 eval(E1) /eval(E2) IF, IF!F Y
E1 // E2 rnd(eval(E1) /eval(E2)) I, I!I Y
E1 rem E2 eval(E1) - (rnd(eval(E1) /eval(E2)) * eval(E2)) I, I!I Y
E1 div E2 b(eval(E1) -eval(E1)modeval(E2)) / eval(E2)c I, I!I Y
E1 mod E2 eval(E1) - (beval(E1) /eval(E2)c*eval(E2)) I, I!I Y
E1 /\ E2 eval(E1) bitwise and eval(E2) I, I!I Y
E1 \/ E2 eval(E1) bitwise oreval(E2) I, I!I Y
xor(E1,E2) eval(E1) bitwise xoreval(E2) I, I!I Y
\ E bitwise noteval(E) I!I Y
E1 << E2 eval(E1) integer shift lefteval(E2) I, I!I Y
E1 >> E2 eval(E1) integer shift right eval(E2) I, I!I Y
lsb(E) least signicant bit (from 0) of eval(E) or -1 I!I N
msb(E) most signicant bit (from 0) of eval(E) or -1 I!I N
popcount(E) number of 1-bits in eval(E) I!I N
abs(E) absolute value of eval(E) IF!IF Y
sign(E) sign of eval(E) (-1 if<0, 0 if = 0, +1 if >0) IF!IF Y
min(E1,E2) minimal value between eval(E1) and eval(E2) IF, IF!? Y
max(E1,E2) maximal value between eval(E1) and eval(E2) IF, IF!? Y
gcd(E1,E2)greatest common divisor of eval(E1) and
eval(E2)I, I!I N
E1 ^ E2 eval(E1) raised to the power of eval(E2) IF, IF!IF Y
E1 ** E2 eval(E1) raised to the power of eval(E2) IF, IF!F Y
sqrt(E) square root of eval(E) IF!F Y
tan(E) tangent of eval(E) IF!F Y
atan(E) arc tangent of eval(E) IF!F Y
atan2(Y,X)principal value of arc tangent of eval(Y) /
eval(X) using both signs for the quadrantIF!F Y
cos(E) cosine of eval(E) IF!F Y
acos(E) arc cosine of eval(E) IF, IF!F Y
sin(E) sine of eval(E) IF!F Y
asin(E) arc sine of eval(E) IF!F Y
tanh(E) hyperbolic tangent of eval(E) IF!F N
atanh(E) hyperbolic arc tangent of eval(E) IF!F N
cosh(E) hyperbolic cosine of eval(E) IF!F N
acosh(E) hyperbolic arc cosine of eval(E) IF, IF!F N
sinh(E) hyperbolic sine of eval(E) IF!F N
asinh(E) hyperbolic arc sine of eval(E) IF!F N
exp(E) eraised to the power of eval(E) IF!F Y
68 8 PROLOG BUILT-IN PREDICATES
Expression Result = eval(Expression) Signature ISO
log(E) natural logarithm of eval(E) IF!F Y
log10(E) base 10 logarithm of eval(E) IF!F N
log(R, E) base eval(R) logarithm of eval(E) F, IF!F N
float(E) the oating point number equal to eval(E) IF!F Y
ceiling(E) rounds eval(E) upward to the nearest integer F!I Y
floor(E) rounds eval(E) downward to the nearest integer F!I Y
round(E) rounds eval(E) to the nearest integer F!I Y
truncate(E) the integer value of eval(E) F!I Y
float fractional part(E) the oat equal to the fractional part of eval(E) F!F Y
float integer part(E) the oat equal to the integer part of eval(E) F!F Y
The meaning of the signature eld is as follows:
â€¢I!I: unary function, the operand must be an integer and the result is an integer.
â€¢F!F: unary function, the operand must be a oating point number and the result is a oating
point number.
â€¢F!I: unary function, the operand must be a oating point number and the result is an integer.
â€¢IF!F: unary function, the operand can be an integer or a oating point number and the result
is a oating point number.
â€¢IF!IF: unary function, the operand can be an integer or a oating point number and the result
has the same type as the operand.
â€¢I, I!I: binary function: each operand must be an integer and the result is an integer.
â€¢IF, IF!IF: binary function: each operand can be an integer or a oating point number and
the result is a oating point number if at least one operand is a oating point number, an integer
otherwise.
â€¢IF, IF!?: binary function: each operand can be an integer or a oating point number and the
result has the same type as the selected operand. This is used for minandmax. Note that in case
of equality between an integer and a oating point number the result is an integer.
is,+,-,*,/,//,div,rem,mod,/\,\/,<<,>>,**and^are predened inx operators. +,-and\, are
predened prex operators (section 8.14.10, page 113).
Integer division rounding function : the integer division rounding function rnd(X)rounds the oating
point number Xto an integer. There are two possible denitions (depending on the target machine) for
this function which dier on negative numbers:
â€¢rnd(X)= integer part of X, e.g. rnd(-1.5) =-1(round toward 0)
â€¢rnd(X)=bXc, e.g. rnd(-1.5) =-2(round toward 1)
The denition of this function determines the denition of the integer division and remainder ( (//)/2
and(rem)/2 ). It is possible to test the value ( toward zero ordown ) of the integer rounding function
Prolog ag to determine which function being used (section 8.22.1, page 148). Since rounding toward
zero is the most common case, two additional evaluable functors ( (div)/2 and (mod)/2 ) are available
which consider rounding toward  1.
Fast mathematical mode : in order to speed-up integer computations, the GNU Prolog compiler can
generate faster code when invoked with the --fast-math option (section 4.4.3, page 23). In this mode
only integer operations are allowed and a variable in an expression must be bound at evaluation time to
an integer. No type checking is done.
8.6 Arithmetic 69
Errors
a sub-expression Eis a variable instantiation error
a sub-expression Eis neither a number nor an
evaluable functortype error(evaluable, E)
a sub-expression Eis a oating point number
while an integer is expectedtype error(integer, E)
a sub-expression Eis an integer while a oating
point number is expectedtype error(float, E)
a division by zero occurs evaluation error(zero divisor)
Portability
Refer to the above table to determine which evaluable functors are ISO and which are GNU Prolog
extensions. For eciency reasons, GNU Prolog does not detect the following ISO arithmetic errors:
float overflow ,intoverflow, int underflow , and undefined .
8.6.2 (is)/2 - evaluate expression
Templates
is(?term, +evaluable)
Description
Result is Expression succeeds if Result can be unied with eval(Expression ). Refer to the evaluation
of an arithmetic expression for the denition of the eval function (section 8.6.1, page 66).
isis a predened inx operator (section 8.14.10, page 113).
Errors
Refer to the evaluation of an arithmetic expression for possible errors (section 8.6.1, page 66).
Portability
ISO predicate.
8.6.3 (=:=)/2 - arithmetic equal, (=\=)/2 - arithmetic not equal,
(<)/2 - arithmetic less than, (=<)/2 - arithmetic less than or equal to,
(>)/2 - arithmetic greater than, (>=)/2 - arithmetic greater than or equal to
Templates
=:=(+evaluable, +evaluable)
=\=(+evaluable, +evaluable)
<(+evaluable, +evaluable)=<(+evaluable, +evaluable)
>(+evaluable, +evaluable)
>=(+evaluable, +evaluable)
Description
Expr1 =:= Expr2 succeeds if eval(Expr1 ) =eval(Expr2 ).
70 8 PROLOG BUILT-IN PREDICATES
Expr1 =\= Expr2 succeeds if eval(Expr1 )6=eval(Expr2 ).
Expr1 < Expr2 succeeds if eval(Expr1 )<eval(Expr2 ).
Expr1 =< Expr2 succeeds if eval(Expr1 )eval(Expr2 ).
Expr1 > Expr2 succeeds if eval(Expr1 )>eval(Expr2 ).
Expr1 >= Expr2 succeeds if eval(Expr1 )eval(Expr2 ).
Refer to the evaluation of an arithmetic expression for the denition of the eval function (section 8.6.1,
page 66).
=:=,=\=,<,=<,>and>=are predened inx operators (section 8.14.10, page 113).
Errors
Refer to the evaluation of an arithmetic expression for possible errors (section 8.6.1, page 66).
Portability
ISO predicates.
8.6.4 succ/2
Templates
succ(+integer, ?integer)
succ(-integer, +integer)
Description
succ(X, Y) is true i Yis the successor of the non-negative integer X.
Errors
XandYare both variables instantiation error
Xis neither a variable nor an integer type error(integer, X)
Yis neither a variable nor an integer type error(integer, Y)
Xis an integer <0 domain error(not less than zero, X)
Yis an integer <0 domain error(not less than zero, Y)
Portability
GNU Prolog predicate.
8.7 Dynamic clause management
8.7.1 Introduction
Static and dynamic procedures : a procedure is either dynamic or static. All built-in predicates are
static. A user-dened procedure is static by default unless a dynamic/1 directive precedes its denition
8.7 Dynamic clause management 71
(section 7.1.2, page 45). Adding a clause to a non-existent procedure creates a dynamic procedure. The
clauses of a dynamic procedure can be altered (e.g. using asserta/1 ), the clauses of a static procedure
cannot be altered.
Private and public procedures : each procedure is either public or private. A dynamic procedure is
always public. Each built-in predicate is private, and a static user-dened procedure is private by default
unless a public/1 directive precedes its denition (section 7.1.3, page 45). If a dynamic declaration
exists it is unnecessary to add a public declaration since a dynamic procedure is also public. A clause
of a public procedure can be inspected (e.g. using clause/2 ), a clause of a private procedure cannot be
inspected.
A logical database update view : any change in the database that occurs as the result of executing
a goal (e.g. when a sub-goal is a call of assertz/1 orretract/1 ) only aects subsequent activations.
The change does not aect any activation that is currently being executed. Thus the database is frozen
during the execution of a goal, and the list of clauses dening a predication is xed at the moment of its
execution.
8.7.2 asserta/1 ,assertz/1
Templates
asserta(+clause)
assertz(+clause)
Description
asserta(Clause) rst converts the term Clause to a clause and then adds it to the current internal
database. The predicate concerned must be dynamic (section 8.7.1, page 70) or undened and the clause
is inserted before the rst clause of the predicate. If the predicated is undened it is created as a dynamic
procedure.
assertz(Clause) acts like asserta/1 except that the clause is added at the end of all existing clauses
of the concerned predicate.
Converting a term Clause to a clause Clause1 :
â€¢extract the head and the body of Clause : either Clause =(Head :- Body) orClause =Head and
Body =true .
â€¢Head must be a callable term (or else the conversion fails).
â€¢convert Body to a body clause (i.e. a goal) Body1 .
â€¢the converted clause Clause1 =(Head :- Body1) .
Converting a term Tto a goal:
â€¢ifTis a variable it is replaced by the term call(T) .
â€¢ifTis a control construct (',')/2 ,(;)/2 or(->)/2 each argument of the control construct is
recursively converted to a goal.
â€¢ifTis a callable term it remains unchanged.
â€¢otherwise the conversion fails ( Tis neither a variable nor a callable term).
72 8 PROLOG BUILT-IN PREDICATES
Errors
Head is a variable instantiation error
Head is neither a variable nor a callable term type error(callable, Head)
Body cannot be converted to a goal type error(callable, Body)
The predicate indicator Pred ofHead is that of a
static procedurepermission error(modify,
static procedure, Pred)
Portability
ISO predicates.
8.7.3 retract/1
Templates
retract(+clause)
Description
retract(Clause) erases the rst clause of the database that unies with Clause . The concerned pred-
icate must be a dynamic procedure (section 8.7.1, page 70). Removing all clauses of a procedure does
not erase the procedure denition. To achieve this use abolish/1 (section 8.7.6, page 73). retract/1 is
re-executable on backtracking.
Errors
Head is a variable instantiation error
Head is neither a variable nor a callable term type error(callable, Head)
The predicate indicator Pred ofHead is that of a
static procedurepermission error(modify,
static procedure, Pred)
Portability
ISO predicate. In the ISO reference, the operation associated with the permission error isaccess
while it is modify in GNU Prolog. This seems to be an error of the ISO reference since for asserta/1
(which is similar in spirit to retract/1 ) the operation is also modify .
8.7.4 retractall/1
Templates
retractall(+head)
Description
retractall(Head) erases all clauses whose head unies with Head . The concerned predicate must be a
dynamic procedure (section 8.7.1, page 70). The procedure denition is not removed so that it is found
bycurrent predicate/1 (section 8.8.1, page 74). abolish/1 should be used to remove the procedure
(section 8.7.6, page 73).
Errors
8.7 Dynamic clause management 73
Head is a variable instantiation error
Head is not a callable term type error(callable, Head)
The predicate indicator Pred ofHead is that of a
static procedurepermission error(modify,
static procedure, Pred)
Portability
ISO predicate.
8.7.5 clause/2
Templates
clause(+head, ?callable term)
Description
clause(Head, Body) succeeds if there exists a clause in the database that unies with Head :- Body .
The predicate in question must be a public procedure (section 8.7.1, page 70). Clauses are delivered from
the rst to the last. This predicate is re-executable on backtracking.
Errors
Head is a variable instantiation error
Head is neither a variable nor a callable term type error(callable, Head)
The predicate indicator Pred ofHead is that of a
private procedurepermission error(access,
private procedure, Pred)
Body is neither a variable nor a callable term type error(callable, Body)
Portability
ISO predicate.
8.7.6 abolish/1
Templates
abolish(+predicate indicator)
Description
abolish(Pred) removes from the database the procedure whose predicate indicator is Pred . The con-
cerned predicate must be a dynamic procedure (section 8.7.1, page 70).
Errors
74 8 PROLOG BUILT-IN PREDICATES
Pred is a variable instantiation error
Pred is a term Name/Arity and either Name or
Arity is a variableinstantiation error
Pred is neither a variable nor a predicate
indicatortype error(predicate indicator, Pred)
Pred is a term Name/Arity andArity is neither
a variable nor an integertype error(integer, Arity)
Pred is a term Name/Arity andName is neither a
variable nor an atomtype error(atom, Name)
Pred is a term Name/Arity andArity is an
integer<0domain error(not less than zero, Arity)
Pred is a term Name/Arity andArity is an
integer>maxarity ag (section 8.22.1,
page 148)representation error(max arity)
The predicate indicator Pred is that of a static
procedurepermission error(modify,
static procedure, Pred)
Portability
ISO predicate.
8.8 Predicate information
8.8.1 current predicate/1
Templates
current predicate(?predicate indicator)
Description
current predicate(Pred) succeeds if there exists a predicate indicator of a dened procedure that
unies with Pred . All user dened procedures are found, whether static or dynamic. Internal system
procedures whose name begins with '$'are not found. A user-dened procedure is found even when
it has no clauses. A user-dened procedure is not found if it has been abolished. To conform to the
ISO reference, built-in predicates are not found except if the strict isoProlog ag is switched o
(section 8.22.1, page 148). This predicate is re-executable on backtracking.
Errors
Pred is neither a variable nor a predicate
indicatortype error(predicate indicator, Pred)
Pred is a term Name/Arity andArity is neither
a variable nor an integertype error(integer, Arity)
Pred is a term Name/Arity andName is neither a
variable nor an atomtype error(atom, Name)
Pred is a term Name/Arity andArity is an
integer<0domain error(not less than zero, Arity)
Pred is a term Name/Arity andArity is an
integer>maxarity ag (section 8.22.1,
page 148)representation error(max arity)
Portability
8.8 Predicate information 75
ISO predicate.
8.8.2 predicate property/2
Templates
predicate property(?callable, ?predicate property)
Description
predicate property(Head, Property) succeeds if Head refers to a predicate that has a property Property .
All user dened procedures and built-in predicates are found. Internal system procedures whose name
begins with '$'are not found. This predicate is re-executable on backtracking.
Since version 1.4.0, predicate property/2 no longer accepts a predicate indicator. Control constructs
are now returned. Properties built infdandcontrol construct now imply the property built in.
Predicate properties :
â€¢static : if the procedure is static.
â€¢dynamic : if the procedure is dynamic.
â€¢private : if the procedure is private.
â€¢public : if the procedure is public.
â€¢monofile : if the procedure is monole.
â€¢multifile : if the procedure is multile.
â€¢user : if the procedure is a user-dened procedure.
â€¢built in: if the procedure is a built-in predicate or a control construct.
â€¢built infd: if the procedure is an FD built-in predicate.
â€¢control construct : if the procedure is a control construct (section 7.2, page 51).
â€¢native code : if the procedure is compiled in native code.
â€¢prolog file(File) : source le from which the procedure has been read.
â€¢prolog line(Line) : line number of the source le.
â€¢meta predicate(Head) : if the procedure is a meta-predicate unify Head with the head-pattern.
The head-pattern is a compound term with the same name and arity as the predicate where each
argument of the term is a meta argument specier as follows:
integer Nthe argument is a term that is used to reference a predicate with Nmore arguments than
the given argument term (e.g. call(0) ).
:the argument is module sensitive, but does not directly refer to a predicate (e.g. consult(:) ).
-the argument is not module sensitive and unbound on entry.
?the argument is not module sensitive and the mode is unspecied.
+the argument is not module sensitive and bound (i.e., nonvar) on entry.
76 8 PROLOG BUILT-IN PREDICATES
Errors
Head is neither a variable nor a callable term type error(callable, Head)
Property is neither a variable nor a predicate
property termdomain error(predicate property,
Property)
Property =prolog file(File) andFile is
neither a variable nor an atomtype error(atom, File)
Property =prolog line(Line) andLine is
neither a variable nor an integertype error(integer, Line)
Portability
GNU Prolog predicate.
8.9 All solutions
8.9.1 Introduction
It is sometimes useful to collect all solutions for a goal. This can be done by repeatedly backtracking and
gradually building the list of solutions. The following built-in predicates are provided to automate this
process.
The built-in predicates described in this section invoke call/1 (section 7.2.3, page 52) on the argument
Goal . When eciency is crucial and Goal is complex it is better to dene an auxiliary predicate which
can then be compiled, and have Goal call this predicate.
8.9.2 findall/4 ,findall/3
Templates
findall(?term, +callable term, ?list, ?term) findall(?term, +callable term, ?list)
Description
findall(Template, Goal, Instances) succeeds if Instances unies with the list of values to which
a variable Xnot occurring in Template orGoal would be instantiated by successive re-executions of
call(Goal), X = Template after systematic replacement of all variables in Xby new variables. Thus,
the order of the list Instances corresponds to the order in which the proofs are found.
findall(Template, Goal, Instances, Tail) is the dierence list version of findall/3 . The result
is the dierence list Instances -Tail . Thus findall(Template, Goal, Instances) is equivalent to
findall(Template, Goal, Instances, []) .
Errors
8.9 All solutions 77
Goal is a variable instantiation error
Goal is neither a variable nor a callable term type error(callable, Goal)
The predicate indicator Pred ofGoal does not
correspond to an existing procedure and the
value of the unknown Prolog ag is error
(section 8.22.1, page 148)existence error(procedure, Pred)
Instances is neither a partial list nor a list type error(list, Instances)
Tail is neither a partial list nor a list type error(list, Tail)
Portability
findall/3 is an ISO predicate. findall/4 is a GNU Prolog predicate.
8.9.3 bagof/3 ,setof/3
Templates
bagof(?term, +callable term, ?list)
setof(?term, +callable term, ?list)
Description
bagof(Template, Goal, Instances) assembles as a list the set of solutions of Goal for each dierent
instantiation of the free variables in Goal . The elements of each list are in order of solution, but the order
in which each list is found is undened. This predicate is re-executable on backtracking.
Free variable set :bagof/3 groups the solutions of Goal according to the free variables in Goal . This
set corresponds to all variables occurring in Goal but not in Template . It is sometimes useful to exclude
some additional variables of Goal . For that, bagof/3 recognizes a goal of the form T^Goal and exclude all
variables occurring in Tfrom the free variable set. (^)/2 can be viewed as an existential quantier (the
logical reading of X^Goal being \there exists an Xsuch that Goal is true"). The use of this existential
qualier is superuous outside bagof/3 (and setof/3 ) and then is not recognized.
(^)/2 is a predened inx operator (section 8.14.10, page 113).
setof(Template, Goal, Instances) is equivalent to bagof(Template,Goal,I), sort(I,Instances) .
Each list is then a sorted list (duplicate elements are removed).
From the implementation point of view setof/3 is as fast as bagof/3 . Both predicates use an in-place
(i.e. destructive) sort (section 8.20.15, page 140) and require the same amount of memory.
Errors
Goal is a variable instantiation error
Goal is neither a variable nor a callable term type error(callable, Goal)
The predicate indicator Pred ofGoal does not
correspond to an existing procedure and the
value of the unknown Prolog ag is error
(section 8.22.1, page 148)existence error(procedure, Pred)
Instances is neither a partial list nor a list type error(list, Instances)
Portability
ISO predicates.
78 8 PROLOG BUILT-IN PREDICATES
8.10 Streams
8.10.1 Introduction
A stream provides a logical view of a source/sink.
Sources and sinks : a program can output results to a sink or input data from a source. A source/sink
may be a le (regular le, terminal, device,. . . ), a constant term, a pipe, a socket,. . .
Associating a stream to a source/sink : to manipulate a source/sink it must be associated with a
stream. This provides a logical and uniform view of the source/sink whatever its type. Once this asso-
ciation has been established, i.e. a stream has been created, all subsequent references to the source/sink
are made by referring the stream. A stream is unidirectional: it is either an input stream or an out-
put stream. For a classical le, the association is done by opening the le (whose name is specied as
an atom) with the open/4 (section 8.10.6, page 81). GNU Prolog makes it possible to treat a Prolog
constant term as a source/sink and provides built-in predicates to associate a stream to such a term (sec-
tion 8.11, page 94). GNU Prolog provides operating system interface predicates dening pipes between
GNU Prolog and child processes with streams associated with these pipes, e.g. popen/3 (section 8.27.21,
page 170). Similarly, socket interface predicates associate streams to a socket to allow the communication,
e.g.socket connect/4 (section 8.28.5, page 178).
Stream-term : a stream-term identies a stream during a call of an input/output built-in predicate.
It is created as a result of associating a stream to a source/sink (section above). A stream-term is a
compound term of the form '$stream'(I) where Iis an integer.
Stream aliases : any stream may be associated with a stream alias which is an atom which may be
used to refer to that stream. The association can be done at open time or using addstream alias/2
(section 8.10.20, page 90). Such an association automatically ends when the stream is closed. A particular
alias only refers to at most one stream at any one time. However, more than one alias can be associated
with a stream. Most built-in predicates which have a stream-term as an input argument also accept a
stream alias as that argument. However, built-in predicates which return a stream-term do not accept a
stream alias.
Standard streams : three streams are predened and open during the execution of every goal: the
standard input stream which has the alias user input , the standard output stream which has the alias
user output and the standard error stream which has the alias user error . A goal which attempts to
close either standard stream succeeds, but does not close the stream.
Current streams : during execution there is a current input stream and a current output stream. By
default, the current input and output streams are the standard input and output streams, but the built-
in predicates setinput/1 (section 8.10.4, page 80) and setoutput/1 (section 8.10.5, page 80) can be
used to change them. When the current input stream is closed, the standard input stream becomes the
current input stream. When the current output stream is closed, the standard output stream becomes
the current output stream.
Text streams and binary streams : a text stream is a sequence of characters. A text stream is also
regarded as a sequence of lines where each line is a possibly empty sequence of characters followed by
a new line character. GNU Prolog may add or remove space characters at the ends of lines in order
to conform to the conventions for representing text streams in the operating system. A binary stream
is a sequence of bytes. Only a few built-in predicates can deal with binary streams, e.g. getbyte/2
(section 8.13, page 101).
Stream positions : the stream position of a stream identies an absolute position of the source/sink to
8.10 Streams 79
which the stream is connected and denes where in the source/sink the next input or output will take
place. A stream position is a ground term of the form '$stream position'(I1, I2, I3, I4) where
I1,I2,I3and I4are integers. Stream positions are used to reposition a stream (when possible) using
for instance setstream position/2 (section 8.10.13, page 86).
The position end of stream : when all data of a stream Shas been input Shas a stream position
end-of-stream. At this stream position a goal to input more data will return a specic value to indicate
that end of stream has been reached (e.g. -1forgetcode/2 orendoffile forgetchar/2 ,. . . ). When
this terminating value has been input, the stream has a stream position past-end-of-stream.
Buering mode : input/output on a stream can be buered (line-buered or block-buered) or not
buered at all. The buering mode can be specied at open time or using setstream buffering/2
(section 8.10.27, page 93). Line buering is used on output streams, output data are only written to the
sink when a new-line character is output (or at the close time). Block buering is used on input or output.
On input streams, when an input is requested on the source, if the buer is empty, all available characters
are read (within the limits of the size of the buer), subsequent reads will rst use the characters in the
buer. On output streams, output data are stored in the buer and only when the buer is full is it
physically written on the sink. Thus, an output to a buered stream may not be sent immediately to the
sink connected to that stream. When it is necessary to be certain that output has been delivered, the
built-in predicate flush output/1 (section 8.10.8, page 83) should be used. Finally, it is also possible
to use non-buered streams, in that case input/output are directly done on the connected source/sink.
This can be useful for communication purposes (e.g. sockets) or when a precise control is needed, e.g.
select/5 (section 8.27.25, page 173).
Stream mirrors : any stream may be associated with mirror streams specied at open time or using
addstream mirror/2 (section 8.10.22, page 91). Then, all characters/bytes read from/written to the
stream are also written on each mirror stream. The association automatically ends when either the
stream or the mirror stream is closed. It is also possible to explicitly remove a mirror stream using
remove stream mirror/2 (section 8.10.23, page 91).
8.10.2 current input/1
Templates
current input(?stream)
Description
current input(Stream) unies Stream with the stream-term identifying the current input stream.
Errors
Stream is neither a variable nor a stream domain error(stream, Stream)
Portability
ISO predicate.
8.10.3 current output/1
Templates
current output(?stream)
80 8 PROLOG BUILT-IN PREDICATES
Description
current output(Stream) unies Stream with the stream-term identifying the current output stream.
Errors
Stream is neither a variable nor a stream domain error(stream, Stream)
Portability
ISO predicate.
8.10.4 setinput/1
Templates
setinput(+stream oralias)
Description
setinput(SorA) sets the current input stream to be the stream associated with the stream-term or alias
SorA .
Errors
SorA is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
Portability
ISO predicate.
8.10.5 setoutput/1
Templates
setoutput(+stream oralias)
Description
setoutput(SorA) sets the current output stream to be the stream associated with the stream-term or
alias SorA .
Errors
SorA is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an input stream permission error(output, stream, SorA)
8.10 Streams 81
Portability
ISO predicate.
8.10.6 open/4 ,open/3
Templates
open(+source sink, +io mode, -stream, +stream option list)
open(+source sink, +io mode, -stream)
Description
open(SourceSink, Mode, Stream, Options) opens the source/sink SourceSink for input or output
as indicated by Mode and the list of stream-options Options and unies Stream with the stream-term
which is associated with this stream. See absolute file name/2 for information about the syntax of
SourceSink (section 8.26.1, page 158).
Input/output modes :Mode is an atom which denes the input/output operations that may be per-
formed the stream. Possible modes are:
â€¢read : the source/sink is a source and must already exist. Input starts at the beginning of the
source.
â€¢write : the source/sink is a sink. If the sink already exists then it is emptied else an empty sink is
created. Output starts at the beginning of that sink.
â€¢append : the source/sink is a sink. If the sink does not exist it is created. Output starts at the end
of that sink.
Stream options :Options is a list of stream options. If this list contains contradictory options, the
rightmost option is the one which applies. Possible options are:
â€¢type(text /binary) : species whether the stream is a text stream or a binary stream. The default
value is text .
â€¢reposition(true /false) : species whether it is possible to reposition the stream. The default
value is true except if the stream cannot be repositioned (e.g. a terminal).
â€¢eofaction(error /eofcode /reset) : species the eect of attempting to input from a stream
whose stream position is past-end-of-stream:
{error : apermission error is raised signifying that no more input exists in this stream.
{eofcode : the result of input is as if the stream position is end-of-stream.
{reset : the stream position is reset so that it is not past-end-of-stream, and another attempt
is made to input from it (this is useful when inputting from a terminal).The default value is eofcode .
â€¢alias(Alias) : species that the atom Alias is to be an alias for the stream. By default no alias
is attached to the stream. Several aliases can be dened for a same stream.
â€¢mirror(Mirror) : species the stream associated with the stream-term or alias Mirror is a mirror
for the stream. By default no mirror is attached to the stream. Several mirrors can be dened for
a same stream.
â€¢buffering(none /line /block) : species which type of buering is used by input/output operations
on this stream:
{none : no buering.
82 8 PROLOG BUILT-IN PREDICATES
{line : output operations buer data emitted until a new-line occurs
{block : input/output operations buer data until a given number (implementation dependant)
of characters/bytes have been treated.The default value is line for a terminal (TTY), block otherwise.
open(SourceSink, Mode, Stream) is equivalent to open(SourceSink, Mode, Stream, []) .
Errors
SourceSink is a variable instantiation error
Mode is a variable instantiation error
Options is a partial list or a list with an element
Ewhich is a variableinstantiation error
Mode is neither a variable nor an atom type error(atom, Mode)
Options is neither a partial list nor a list type error(list, Options)
Stream is not a variable uninstantiation error(Stream)
SourceSink is neither a variable nor a
source/sinkdomain error(source sink, SourceSink)
Mode is an atom but not an input/output mode domain error(io mode, Mode)
an element Eof the Options list is neither a
variable nor a stream-optiondomain error(stream option, E)
the source/sink specied by SourceSink does
not existexistence error(source sink, SourceSink)
the source/sink specied by SourceSink cannot
be openedpermission error(open, source sink,
SourceSink)
an element Eof the Options list is alias(A) and
Ais already associated with an open streampermission error(open, source sink,
alias(A))
an element Eof the Options list is mirror(M)
andMis not associated with an open streamexistence error(stream, M)
an element Eof the Options list is mirror(M)
andMis an input streampermission error(output, stream, M)
an element Eof the Options list is
reposition(true) and it is not possible to
reposition this streampermission error(open, source sink,
reposition(true))
Portability
ISO predicates. The mirror andbuffering stream options are GNU Prolog extensions.
8.10.7 close/2 ,close/1
Templates
close(+stream oralias, +close option list)
close(+stream oralias)
Description
close(SorA, Options) closes the stream associated with the stream-term or alias SorA . If SorA is
the standard input stream or the standard output stream close/2 simply succeeds else the associated
source/sink is physically closed. If SorA is the current input stream the current input stream becomes
the standard input stream user input . IfSorA is the current output stream the current output stream
becomes the standard output stream user output .
8.10 Streams 83
Close options :Options is a list of close options. For the moment only one option is available:
â€¢force(true /false) : with false , if an error occurs when trying to close the source/sink, the stream
is not closed and an error ( system error orresource error ) is raised (but close/2 succeeds).
With true , if an error occurs it is ignored and the stream is closed. The purpose of force/1 option
is to allow an error handling routine to do its best to reclaim resources. The default value is false .
close(SorA) is equivalent to close(SorA, []) .
Errors
SorA is a variable instantiation error
Options is a partial list or a list with an element
Ewhich is a variableinstantiation error
Options is neither a partial list nor a list type error(list, Options)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
an element Eof the Options list is neither a
variable nor a close-optiondomain error(close option, E)
SorA is not associated with an open stream existence error(stream, SorA)
SorA needs a special close (section 8.11, page 94) system error(needs special close)
Portability
ISO predicates. The system error(needs special close) is a GNU Prolog extension.
8.10.8 flush output/1 ,flush output/0
Templates
flush output(+stream oralias)
flush output
Description
flush output(SorA) sends any buered output characters/bytes to the stream.
flush output/0 applies to the current output stream.
Errors
SorA is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an input stream permission error(output, stream, SorA)
Portability
ISO predicates.
8.10.9 current stream/1
Templates
84 8 PROLOG BUILT-IN PREDICATES
current stream(?stream)
Description
current stream(Stream) succeeds if there exists a stream-term that unies with Stream . This predicate
is re-executable on backtracking.
Errors
Stream is neither a variable nor a stream-term domain error(stream, Stream)
Portability
GNU Prolog predicate.
8.10.10 stream property/2
Templates
stream property(?stream, ?stream property)
Description
stream property(Stream, Property) succeeds if current stream(Stream) succeeds (section 8.10.9,
page 83) and if Property unies with one of the properties of the stream. This predicate is re-executable
on backtracking.
Stream properties :
â€¢file name(F) : the name of the connected source/sink.
â€¢mode(M) :Mis the open mode ( read ,write ,append ).
â€¢input : if it is an input stream.
â€¢output : if it is an output stream.
â€¢alias(A) :Ais an alias of the stream.
â€¢mirror(M) :Mis a mirror stream of the stream.
â€¢type(T) :Tis the type of the stream ( text ,binary ).
â€¢reposition(R) :Ris the reposition boolean ( true ,false ).
â€¢eofaction(A) :Ais the end-of-le action ( error ,eofcode ,reset ).
â€¢buffering(B) :Bis the buering mode ( none ,line ,block ).
â€¢endofstream(E) :Eis the current end-of-stream status ( not,at,past ). If the stream position is
end-of-stream then Eis unied with atelse if the stream position is past-end-of-stream then Eis
unied with past elseEis unied with not.
â€¢position(P) :Pis the stream-position term associated with the current position.
8.10 Streams 85
Errors
Stream is a variable instantiation error
Stream is neither a variable nor a stream-term domain error(stream, Stream)
Property is neither a variable nor a stream
propertydomain error(stream property, Property)
Property =file name(E) ,mode(E) ,alias(E) ,
endofstream(E) ,eofaction(E) ,
reposition(E) ,type(E) orbuffering(E) and
Eis neither a variable nor an atomtype error(atom, E)
Portability
ISO predicate. The buffering/1 property is a GNU Prolog extension.
8.10.11 atendofstream/1 ,atendofstream/0
Templates
atendofstream(+stream oralias)
atendofstream
Description
atendofstream(SorA) succeeds if the stream associated with stream-term or alias SorA has a stream
position end-of-stream or past-end-of-stream. This predicate can be dened using stream property/2
(section 8.10.10, page 84).
atendofstream/0 applies to the current input stream.
Errors
SorA is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
Portability
ISO predicates. The permission error(input, stream, SorA) is a GNU Prolog extension.
8.10.12 stream position/2
Templates
stream position(+stream oralias, ?stream position)
Description
stream position(SorA, Position) succeeds unifying Position with the stream-position term associ-
ated with the current position of the stream-term or alias SorA . This predicate can be dened using
stream property/2 (section 8.10.10, page 84).
86 8 PROLOG BUILT-IN PREDICATES
Errors
SorA is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
Position is neither a variable nor a
stream-position termdomain error(stream position, Position)
SorA is not associated with an open stream existence error(stream, SorA)
Portability
GNU Prolog predicate.
8.10.13 setstream position/2
Templates
setstream position(+stream oralias, +stream position)
Description
setstream position(SorA, Position) sets the position of the stream associated with the stream-
term or alias SorA toPosition .Position should have previously been returned by stream property/2
(section 8.10.10, page 84) or by stream position/2 (section 8.10.12, page 85).
Errors
SorA is a variable instantiation error
Position is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
Position is neither a variable nor a
stream-position termdomain error(stream position, Position)
SorA is not associated with an open stream existence error(stream, SorA)
SorA has stream property reposition(false)permission error(reposition, stream,
SorA)
Portability
ISO predicate.
8.10.14 seek/4
Templates
seek(+stream oralias, +stream seek method, +integer, ?integer)
Description
seek(SorA, Whence, Offset, NewOffset) sets the position of the stream associated with the stream-
term or alias SorA toOffset according to Whence and unies NewOffset with the new oset from the
beginning of the le. seek/4 can only be used on binary streams. Whence is an atom from:
8.10 Streams 87
â€¢bof: the position is set relatively to the begin of the le ( Offset should be0).
â€¢current : the position is set relatively to the current position ( Offset can be0 or0).
â€¢eof: the position is set relatively to the end of the le ( Offset should be0).
This predicate is an interface to the C Unix function lseek(2) .
Errors
SorA is a variable instantiation error
Whence is a variable instantiation error
Offset is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
Whence is neither a variable nor an atom type error(atom, Whence)
Whence is an atom but not a valid stream seek
methoddomain error(stream seek method, Whence)
Offset is neither a variable nor an integer type error(integer, Offset)
NewOffset is neither a variable nor an integer type error(integer, NewOffset)
SorA is not associated with an open stream existence error(stream, SorA)
SorA has stream property reposition(false)permission error(reposition, stream,
SorA)
SorA is associated with a text streampermission error(reposition, text stream,
SorA)
Portability
GNU Prolog predicate.
8.10.15 character count/2
Templates
character count(+stream oralias, ?integer)
Description
character count(SorA, Count) unies Count with the number of characters/bytes read/written on the
stream associated with stream-term or alias SorA .
Errors
SorA is a variable instantiation error
Count is neither a variable nor an integer type error(integer, Count)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
Portability
GNU Prolog predicate.
88 8 PROLOG BUILT-IN PREDICATES
8.10.16 line count/2
Templates
line count(+stream oralias, ?integer)
Description
line count(SorA, Count) unies Count with the number of lines read/written on the stream associated
with the stream-term or alias SorA . This predicate can only be used on text streams.
Errors
SorA is a variable instantiation error
Count is neither a variable nor an integer type error(integer, Count)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is associated with a binary streampermission error(access, binary stream,
SorA)
Portability
GNU Prolog predicate.
8.10.17 line position/2
Templates
line position(+stream oralias, ?integer)
Description
line position(SorA, Count) unies Count with the number of characters read/written on the current
line of the stream associated with the stream-term or alias SorA . This predicate can only be used on text
streams.
Errors
SorA is a variable instantiation error
Count is neither a variable nor an integer type error(integer, Count)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is associated with a binary streampermission error(access, binary stream,
SorA)
Portability
GNU Prolog predicate.
8.10 Streams 89
8.10.18 stream line column/3
Templates
stream line column(+stream oralias, ?integer, ?integer)
Description
stream line column(SorA, Line, Column) unies Line (resp. Column ) with the current line number
(resp. column number) of the stream associated with the stream-term or alias SorA . This predicate can
only be used on text streams. Note that Line corresponds to the value returned by line count/2 + 1
(section 8.10.16, page 88) and Column to the value returned by line position/2 + 1 (section 8.10.17,
page 88).
Errors
SorA is a variable instantiation error
Line is neither a variable nor an integer type error(integer, Line)
Column is neither a variable nor an integer type error(integer, Column)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is associated with a binary streampermission error(access, binary stream,
SorA)
Portability
GNU Prolog predicate.
8.10.19 setstream line column/3
Templates
setstream line column(+stream oralias, +integer, +integer)
Description
setstream line column(SorA, Line, Column) sets the stream position of the stream associated with
the stream-term or alias SorA according to the line number Line and the column number Column . This
predicate can only be used on text streams. It rst repositions the stream to the beginning of the le
and then reads character by character until the required position is reached.
Errors
90 8 PROLOG BUILT-IN PREDICATES
SorA is a variable instantiation error
Line is a variable instantiation error
Column is a variable instantiation error
Line is neither a variable nor an integer type error(integer, Line)
Column is neither a variable nor an integer type error(integer, Column)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is associated with a binary streampermission error(reposition,
binary stream, SorA)
SorA has stream property reposition(false)permission error(reposition, stream,
SorA)
Portability
GNU Prolog predicate.
8.10.20 addstream alias/2
Templates
addstream alias(+stream oralias, +atom)
Description
addstream alias(SorA, Alias) adds Alias as a new alias to the stream associated with the stream-
term or alias SorA .
Errors
SorA is a variable instantiation error
Alias is a variable instantiation error
Alias is neither a variable nor an atom type error(atom, Alias)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
Alias is already associated with an open streampermission error(add alias, source sink,
alias(Alias))
Portability
GNU Prolog predicate.
8.10.21 current alias/2
Templates
current alias(?stream, ?atom)
Description
current alias(Stream, Alias) succeeds if current stream(Stream) succeeds (section 8.10.9, page 83)
8.10 Streams 91
and if Alias unies with one of the aliases of the stream. It can be dened using stream property/2
(section 8.10.10, page 84). This predicate is re-executable on backtracking.
Errors
Stream is neither a variable nor a stream-term domain error(stream, Stream)
Alias is neither a variable nor an atom type error(atom, Alias)
Portability
GNU Prolog predicate.
8.10.22 addstream mirror/2
Templates
addstream mirror(+stream oralias, +stream oralias)
Description
addstream mirror(SorA, Mirror) adds the stream associated with the stream-term or alias Mirror as
a new mirror to the stream associated with the stream-term or alias SorA . After this, all characters (or
bytes) read from (or written to) SorA are also written to Mirror . This mirroring occurs until Mirror is
explicitly removed using remove stream mirror/2 (section 8.10.23, page 91) or implicitly when Mirror
is closed. Several mirror streams can be associated with a same stream. If Mirror represents the same
stream as SorA or if Mirror is already a mirror for SorA , no mirror is added.
Errors
SorA is a variable instantiation error
Mirror is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
Mirror is neither a variable nor a stream-term or
aliasdomain error(stream oralias, Mirror)
SorA is not associated with an open stream existence error(stream, SorA)
Mirror is not associated with an open stream existence error(stream, Mirror)
Mirror is an input stream permission error(output, stream, Mirror)
Portability
GNU Prolog predicate.
8.10.23 remove stream mirror/2
Templates
remove stream mirror(+stream oralias, +stream oralias)
Description
remove stream mirror(SorA, Mirror) removes the stream associated with the stream-term or alias
Mirror from the list of mirrors of the stream associated with the stream-term or alias SorA . This predicate
fails if Mirror is not a mirror stream for SorA .
92 8 PROLOG BUILT-IN PREDICATES
Errors
SorA is a variable instantiation error
Mirror is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
Mirror is neither a variable nor a stream-term or
aliasdomain error(stream oralias, Mirror)
SorA is not associated with an open stream existence error(stream, SorA)
Mirror is not associated with an open stream existence error(stream, Mirror)
Portability
GNU Prolog predicate.
8.10.24 current mirror/2
Templates
current mirror(?stream, ?stream)
Description
current mirror(Stream, M) succeeds if current stream(Stream) succeeds (section 8.10.9, page 83)
and if Munies with one of the mirrors of the stream. It can be dened using stream property/2
(section 8.10.10, page 84). This predicate is re-executable on backtracking.
Errors
Stream is neither a variable nor a stream-term domain error(stream, Stream)
Mis neither a variable nor a stream-term domain error(stream, M)
Portability
GNU Prolog predicate.
8.10.25 setstream type/2
Templates
setstream type(+stream oralias, +atom)
Description
setstream type(SorA, Type) updates the type associated with stream-term or alias SorA . The value
ofType is an atom in text orbinary as for open/4 (section 8.10.6, page 81). The type of a stream can
only be changed before any input/output operation is executed.
Errors
8.10 Streams 93
SorA is a variable instantiation error
Type is a variable instantiation error
Type is neither a variable nor a valid type domain error(stream type, Type)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
An I/O operation has already been executed on
SorApermission error(modify, stream, SorA)
Portability
GNU Prolog predicate.
8.10.26 setstream eofaction/2
Templates
setstream eofaction(+stream oralias, +atom)
Description
setstream eofaction(SorA, Action) updates the eofaction option associated with the stream-
term or alias SorA . The value of Action is one of the atoms error ,eofcode ,reset as for open/4
(section 8.10.6, page 81).
Errors
SorA is a variable instantiation error
Action is a variable instantiation error
Action is neither a variable nor a valid eof action domain error(eof action, Action)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(modify, stream, SorA)
Portability
GNU Prolog predicate.
8.10.27 setstream buffering/2
Templates
setstream buffering(+stream oralias, +atom)
Description
setstream buffering(SorA, Buffering) updates the buering mode associated with the stream-term
or alias SorA . The value of Buffering is one of the atoms none ,line orblock as for open/4 (sec-
tion 8.10.6, page 81). This predicate may only be used after opening a stream and before any other
operations have been performed on it.
Errors
94 8 PROLOG BUILT-IN PREDICATES
SorA is a variable instantiation error
Buffering is a variable instantiation error
Buffering is neither a variable nor a valid
buering modedomain error(buffering mode, Buffering)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
Portability
GNU Prolog predicate.
8.11 Constant term streams
8.11.1 Introduction
Constant term streams allow the user to consider a constant term (atom, character list or character code
list) as a source/sink by associating to them a stream. Reading from a constant term stream will deliver
the characters of the constant term as if they had been read from a standard le. Characters written
on a constant term stream are stored to form the nal constant term when the stream is closed. The
built-in predicates described in this section allow the user to open and close a constant term stream for
input or output. However, very often, a constant term stream is created to be only read or written once
and then closed. To avoid the creation and the destruction of such a stream, GNU Prolog oers several
built-in predicates to perform single input/output from/to constant terms (section 8.15, page 117).
8.11.2 open input atom stream/2 ,open input chars stream/2 ,
open input codes stream/2
Templates
open input atom stream(+atom, -stream)
open input chars stream(+character list, -stream)
open input codes stream(+character code list, -stream)
Description
open input atom stream(Atom, Stream) unies Stream with the stream-term which is associated with
a new input text-stream whose data are the characters of Atom .
open input chars stream(Chars, Stream) is similar to open input atom stream/2 except that data
are the content of the character list Chars .
open input codes stream(Codes, Stream) is similar to open input atom stream/2 except that data
are the content of the character code list Codes .
Errors
8.11 Constant term streams 95
Stream is not a variable uninstantiation error(Stream)
Atom is a variable instantiation error
Chars is a partial list or a list with an element E
which is a variableinstantiation error
Codes is a partial list or a list with an element E
which is a variableinstantiation error
Atom is neither a variable nor a an atom type error(atom, Atom)
Chars is neither a partial list nor a list type error(list, Chars)
Codes is neither a partial list nor a list type error(list, Codes)
an element Eof the Chars list is neither a
variable nor a charactertype error(character, E)
an element Eof the Codes list is neither a
variable nor an integertype error(integer, E)
an element Eof the Codes list is an integer but
not a character coderepresentation error(character code)
Portability
GNU Prolog predicates.
8.11.3 close input atom stream/1 ,close input chars stream/1 ,
close input codes stream/1
Templates
close input atom stream(+stream oralias)
close input chars stream(+stream oralias)
close input codes stream(+stream oralias)
Description
close input atom stream(SorA) closes the constant term stream associated with the stream-term or
alias SorA .SorA must a stream open with open input atom stream/2 (section 8.11.1, page 94).
close input chars stream(SorA) acts similarly for a character list stream.
close input codes stream(SorA) acts similarly for a character code list stream.
Errors
SorA is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(close, stream, SorA)
SorA is a stream-term or alias but does not refer
to a constant term stream.domain error(term stream oralias, SorA)
Portability
GNU Prolog predicates.
96 8 PROLOG BUILT-IN PREDICATES
8.11.4 open output atom stream/1 ,open output chars stream/1 ,
open output codes stream/1
Templates
open output atom stream(-stream)
open output chars stream(-stream)
open output codes stream(-stream)
Description
open output atom stream(Stream) unies Stream with the stream-term which is associated with a new
output text-stream. All characters written to this stream are collected and will be returned as an atom
when the stream is closed by close output atom stream/2 (section 8.11.5, page 96).
open output chars stream(Stream) is similar to open output atom stream/1 except that the result
will be a character list.
open output codes stream(Stream) is similar to open output atom stream/1 except that the result
will be a character code list.
Errors
Stream is not a variable uninstantiation error(Stream)
Portability
GNU Prolog predicates.
8.11.5 close output atom stream/2 ,close output chars stream/2 ,
close output codes stream/2
Templates
close output atom stream(+stream oralias, ?atom)
close output chars stream(+stream oralias, ?character list)
close output codes stream(+stream oralias, ?character code list)
Description
close output atom stream(SorA, Atom) closes the constant term stream associated with the stream-
term or alias SorA .SorA must be associated with a stream open with open output atom stream/1
(section 8.11.4, page 96). Atom is unied with an atom formed with all characters written on the stream.
close output chars stream(SorA, Chars) acts similarly for a character list stream.
close output codes stream(SorA, Codes) acts similarly for a character code list stream.
Errors
8.12 Character input/output 97
SorA is a variable instantiation error
Atom is neither a variable nor an atom type error(atom, Atom)
Chars is neither a partial list nor a list type error(list, Chars)
Codes is neither a partial list nor a list type error(list, Codes)
an element Eof the Chars list is neither a
variable nor a charactertype error(character, E)
an element Eof the Codes list is neither a
variable nor an integertype error(integer, E)
an element Eof the Codes list is an integer but
not a character coderepresentation error(character code)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an input stream permission error(close, stream, SorA)
SorA is a stream-term or alias but does not refer
to a constant term streamdomain error(term stream oralias, SorA)
Portability
GNU Prolog predicates.
8.12 Character input/output
These built-in predicates enable a single character or character code to be input from and output to a
text stream. The atom endoffile is returned as character to indicate the end-of-le. -1is returned as
character code to indicate the end-of-le.
8.12.1 getchar/2 ,getchar/1 ,getcode/1 ,getcode/2
Templates
getchar(+stream oralias, ?in character)
getchar(?in character)
getcode(+stream oralias, ?in character code)
getcode(?in character code)
Description
getchar(SorA, Char) succeeds if Char unies with the next character read from the stream associated
with the stream-term or alias SorA .
getcode/2 is similar to getchar/2 but deals with character codes.
getchar/1 andgetcode/1 apply to the current input stream.
Errors
98 8 PROLOG BUILT-IN PREDICATES
SorA is a variable instantiation error
Char is neither a variable nor an in-character type error(in character, Char)
Code is neither a variable nor an integer type error(integer, Code)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a binary streampermission error(input, binary stream,
SorA)
SorA has stream properties
endofstream(past) andeofaction(error)permission error(input,
past endofstream, SorA)
The entity input from the stream is not a
characterrepresentation error(character)
Code is an integer but not an in-character code representation error(in character code)
Portability
ISO predicates.
8.12.2 getkey/2 ,getkey/1 get keynoecho/2 ,getkeynoecho/1
Templates
getkey(+stream oralias, ?integer)
getkey(?integer)
getkeynoecho(+stream oralias, ?integer)
getkeynoecho(?integer)
Description
getkey(SorA, Code) succeeds if Code unies with the character code of the next key read from the
stream associated with the stream-term or alias SorA . It is intended to read a single key from the keyboard
(thus SorA should refer to current input stream). No buering is performed (a character is read as soon as
available) and function keys can also be read (in that case, Code is an integer >255). The read character
is echoed if it is printable.
This facility is only possible if the linedit facility has been installed (section 4.2.6, page 18) otherwise
getkey/2 behaves similarly to getcode/2 (section 8.12.1, page 97) (the code of the rst character is
returned) but also pumps remaining characters until a character <space (0x20) is read (in particular
RETURN). The same behavior occurs if SorA does not refer to the current input stream or if this stream
is not attached to a terminal.
getkeynoecho/2 behaves similarly to getkey/2 except that the read character is not echoed.
getkey/1 andgetkeynoecho/1 apply to the current input stream.
Errors
8.12 Character input/output 99
SorA is a variable instantiation error
Code is neither a variable nor an integer type error(integer, Code)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a binary streampermission error(input, binary stream,
SorA)
SorA has stream properties
endofstream(past) andeofaction(error)permission error(input,
past endofstream, SorA)
Portability
GNU Prolog predicates.
8.12.3 peek char/2 ,peek char/1 ,peek code/1 ,peek code/2
Templates
peek char(+stream oralias, ?in character)
peek char(?in character)
peek code(+stream oralias, ?in character code)
peek code(?in character code)
Description
peek char(SorA, Char) succeeds if Char unies with the next character that will be read from the
stream associated with the stream-term or alias SorA . The character is not read.
peek code/2 is similar to peek char/2 but deals with character codes.
peek char/1 andpeek code/1 apply to the current input stream.
Errors
SorA is a variable instantiation error
Char is neither a variable nor an in-character type error(in character, Char)
Code is neither a variable nor an integer type error(integer, Code)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a binary streampermission error(input, binary stream,
SorA)
SorA has stream properties
endofstream(past) andeofaction(error)permission error(input,
past endofstream, SorA)
The entity input from the stream is not a
characterrepresentation error(character)
Code is an integer but not an in-character code representation error(in character code)
Portability
ISO predicates.
100 8 PROLOG BUILT-IN PREDICATES
8.12.4 unget char/2 ,unget char/1 ,unget code/2 ,unget code/1
Templates
unget char(+stream oralias, +character)
unget char(+character)
unget code(+stream oralias, +character code)
unget code(+character code)
Description
unget char(SorA, Char) pushes back Char onto the stream associated with the stream-term or alias
SorA .Char will be the next character read by getchar/2 . The maximum number of characters that can
be cumulatively pushed back is given by the maxunget Prolog ag (section 8.22.1, page 148).
unget code/2 is similar to unget char/2 but deals with character codes.
unget char/1 andunget code/1 apply to the current input stream.
Errors
SorA is a variable instantiation error
Char is a variable instantiation error
Code is a variable instantiation error
Char is neither a variable nor a character type error(character, Char)
Code is neither a variable nor an integer type error(integer, Code)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a binary streampermission error(input, binary stream,
SorA)
Code is an integer but not a character code representation error(character code)
Portability
GNU Prolog predicates.
8.12.5 putchar/2 ,putchar/1 ,putcode/1 ,putcode/2 ,nl/1,nl/0
Templates
putchar(+stream oralias, +character)
putchar(+character)
putcode(+stream oralias, +character code)
putcode(+character code)
nl(+stream oralias)
nl
Description
putchar(SorA, Char) writes Char onto the stream associated with the stream-term or alias SorA .
putcode/2 is similar to putchar/2 but deals with character codes.
8.13 Byte input/output 101
nl(SorA) writes a new-line character onto the stream associated with the stream-term or alias SorA .
This is equivalent to putchar(SorA, '\n') .
putchar/1 ,putcode/1 andnl/0 apply to the current output stream.
Errors
SorA is a variable instantiation error
Char is a variable instantiation error
Code is a variable instantiation error
Char is neither a variable nor a character type error(character, Char)
Code is neither a variable nor an integer type error(integer, Code)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an input stream permission error(output, stream, SorA)
SorA is associated with a binary streampermission error(output, binary stream,
SorA)
Code is an integer but not a character code representation error(character code)
Portability
ISO predicates.
8.13 Byte input/output
These built-in predicates enable a single byte to be input from and output to a binary stream. -1is
returned to indicate the end-of-le.
8.13.1 getbyte/2 ,getbyte/1
Templates
getbyte(+stream oralias, ?in byte)
getbyte(?in byte)
Description
getbyte(SorA, Byte) succeeds if Byte unies with the next byte read from the stream associated with
the stream-term or alias SorA .
getbyte/1 applies to the current input stream.
Errors
102 8 PROLOG BUILT-IN PREDICATES
SorA is a variable instantiation error
Byte is neither a variable nor an in-byte type error(in byte, Byte)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a text streampermission error(input, text stream,
SorA)
SorA has stream properties
endofstream(past) andeofaction(error)permission error(input,
past endofstream, SorA)
Portability
ISO predicates.
8.13.2 peek byte/2 ,peek byte/1
Templates
peek byte(+stream oralias, ?in byte)
peek byte(?in byte)
Description
peek byte(SorA, Byte) succeeds if Byte unies with the next byte that will be read from the stream
associated with the stream-term or alias SorA . The byte is not read.
peek byte/1 applies to the current input stream.
Errors
SorA is a variable instantiation error
Byte is neither a variable nor an in-byte type error(in byte, Byte)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a text streampermission error(input, text stream,
SorA)
SorA has stream properties
endofstream(past) andeofaction(error)permission error(input,
past endofstream, SorA)
Portability
ISO predicates.
8.13.3 unget byte/2 ,unget byte/1
Templates
unget byte(+stream oralias, +byte)
unget byte(+byte)
8.13 Byte input/output 103
Description
unget byte(SorA, Byte) pushes back Byte onto the stream associated with the stream-term or alias
SorA .Byte will be the next byte read by getbyte/2 . The maximum number of bytes that can be
successively pushed back is given by the maxunget Prolog ag (section 8.22.1, page 148).
unget byte/1 applies to the current input stream.
Errors
SorA is a variable instantiation error
Byte is a variable instantiation error
Byte is neither a variable nor a byte type error(byte, Byte)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a text streampermission error(input, text stream,
SorA)
Portability
GNU Prolog predicates.
8.13.4 putbyte/2 ,putbyte/1
Templates
putbyte(+stream oralias, +byte)
putbyte(+byte)
Description
putbyte(SorA, Byte) writes Byte onto the stream associated with the stream-term or alias SorA .
putbyte/1 applies to the current output stream.
Errors
SorA is a variable instantiation error
Byte is a variable instantiation error
Byte is neither a variable nor a byte type error(byte, Byte)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(output, stream, SorA)
SorA is associated with a text streampermission error(output, text stream,
SorA)
Portability
GNU Prolog predicates.
104 8 PROLOG BUILT-IN PREDICATES
8.14 Term input/output
These built-in predicates enable a Prolog term to be input from or output to a text stream. The atom
endoffile is returned as term to indicate the end-of-le. The syntax of such terms can also be altered
by changing the operators (section 8.14.10, page 113), and making some characters equivalent to others
(section 8.14.12, page 116) if the char conversion Prolog ag is on(section 8.22.1, page 148). Double
quoted tokens will be returned as an atom or a character list or a character code list depending on the
value of the double quotes Prolog ag (section 8.22.1, page 148). Similarly, back quoted tokens are
returned depending on the value of the back quotes Prolog ag.
8.14.1 read term/3 ,read term/2 ,read/2 ,read/1
Templates
read term(+stream oralias, ?term, +read option list)
read term(?term, +read option list)
read(+stream oralias, ?term)
read(?term)
Description
read term(SorA, Term, Options) is true if Term unies with the next term read from the stream
associated with the stream-term or alias SorA according to the options given by Options .
Read options :Options is a list of read options. If this list contains contradictory options, the rightmost
option is the one which applies. Possible options are:
â€¢variables(VL) :VLis unied with the list of all variables of the input term, in left-to-right traversal
order. Anonymous variables are included in the list VL.
â€¢variable names(VNL) :VNLis unied with the list of pairs Name = Var where Varis a named
variable of the term and Name is the atom associated with the name of Var. Anonymous variables
are not included in the list VNL. The pairs appear in left-to-right traversal order of their Varin the
term.
â€¢singletons(SL) :SLis unied with the list of pairs Name = Var where Varis a named variable which
occurs only once in the term and Name is the atom associated to the name of Var. Anonymous
variables are not included in the list SL.
â€¢syntax error(error /warning /fail) : species the eect of a syntax error:
{error : asyntax error is raised.
{warning : a warning message is displayed and the predicate fails.
{fail : the predicate quietly fails.The default value is the value of the syntax error Prolog ag (section 8.22.1, page 148).
â€¢endofterm(dot /eof) : species the end-of-term delimiter: dotis the classical full-stop delimiter
(a dot followed with a layout character), eofis the end-of-le delimiter. This option is useful for
predicates like read term from atom/3 (section 8.15.1, page 117) to avoid to add a terminal dot at
the end of the atom. The default value is dot.
read(SorA, Term) is equivalent to read term(SorA, Term, []) .
read term/2 andread/1 apply to the current input stream.
Errors
8.14 Term input/output 105
SorA is a variable instantiation error
Options is a partial list or a list with an element
Ewhich is a variableinstantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
Options is neither a partial list nor a list type error(list, Options)
an element Eof the Options list is neither a
variable nor a valid read optiondomain error(read option, E)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a binary streampermission error(input, binary stream,
SorA)
SorA has stream properties
endofstream(past) andeofaction(error)permission error(input,
past endofstream, SorA)
a syntax error occurs and the value of the
syntax error Prolog ag is error
(section 8.22.1, page 148)syntax error( atom explaining the error )
Portability
ISO predicates. The ISO reference raises a representation error(Flag) where Flag ismaxarity ,
maxinteger , or mininteger when the read term breaches an implementation dened limit specied
byFlag . GNU Prolog detects neither mininteger normaxinteger violation and treats a maxarity
violation as a syntax error. The read options syntax error andendofterm are GNU Prolog extensions.
8.14.2 read atom/2 ,read atom/1 ,read integer/2 ,read integer/1 ,
read number/2 ,read number/1
Templates
read atom(+stream oralias, ?atom)
read atom(?atom)
read integer(+stream oralias, ?integer)
read integer(?integer)
read number(+stream oralias, ?number)
read number(?number)
Description
read atom(SorA, Atom) succeeds if Atom unies with the next atom read from the stream associated
with the stream-term or alias SorA .
read integer(SorA, Integer) succeeds if Integer unies with the next integer read from the stream
associated with the stream-term or alias SorA .
read number(SorA, Number) succeeds if Number unies with the next number (integer or oating point
number) read from the stream associated with the stream-term or alias SorA .
read atom/1 ,read integer/1 andread number/1 apply to the current input stream.
Errors
106 8 PROLOG BUILT-IN PREDICATES
SorA is a variable instantiation error
Atom is neither a variable nor an atom type error(atom, Atom)
Integer is neither a variable nor an integer type error(integer, Integer)
Number is neither a variable nor a number type error(number, Number)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a binary streampermission error(input, binary stream,
SorA)
SorA has stream properties
endofstream(past) andeofaction(error)permission error(input,
past endofstream, SorA)
a syntax error occurs and the value of the
syntax error Prolog ag is error
(section 8.22.1, page 148)syntax error( atom explaining the error )
Portability
GNU Prolog predicates.
8.14.3 read token/2 ,read token/1
Templates
read token(+stream oralias, ?nonvar)
read token(?nonvar)
Description
read token(SorA, Token) succeeds if Token unies with the encoding of the next Prolog token read
from the stream associated with stream-term or alias SorA .
Token encoding :
â€¢var(A) : a variable is read whose name is the atom A.
â€¢an atom A: an atom Ais read.
â€¢integer N: an integer Nis read.
â€¢oating point number N: a oating point number Nis read.
â€¢string(A) : a string (double quoted item) is read whose characters forms the atom A.
â€¢punct(P) : a punctuation character Pis read ( Pis a one-character atom in ()[]{|} , the atom
full stop or the atom endoffile ).
â€¢back quotes(A) : a back quoted item is read whose characters forms the atom A.
â€¢extended(A) : an extended character A(an atom) is read.
As for read term/3 , the behavior of read token/2 can be aected by some Prolog flags (section 8.14,
page 104).
read token/1 applies to the current input stream.
Errors
8.14 Term input/output 107
SorA is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an output stream permission error(input, stream, SorA)
SorA is associated with a binary streampermission error(input, binary stream,
SorA)
SorA has stream properties
endofstream(past) andeofaction(error)permission error(input,
past endofstream, SorA)
a syntax error occurs and the value of the
syntax error Prolog ag is error
(section 8.22.1, page 148)syntax error( atom explaining the error )
Portability
GNU Prolog predicates.
8.14.4 syntax error info/4
Templates
syntax error info(?atom, ?integer, ?integer, ?atom)
Description
syntax error info(FileName, Line, Column, Error) returns the information associated with the last
syntax error. Line is the line number of the error, Column is the column number of the error and Error
is an atom explaining the error.
Errors
FileName is neither a variable nor an atom type error(atom, FileName)
Line is neither a variable nor an integer type error(integer, Line)
Column is neither a variable nor an integer type error(integer, Column)
Error is neither a variable nor an atom type error(atom, Error)
Portability
GNU Prolog predicate.
8.14.5 last read start line column/2
Templates
last read start line column(?integer, ?integer)
Description
last read start line column(Line, Column) unies Line and Column with the line number and the
column number associated with the start of the last read predicate. This predicate can be used after calling
one of the following predicates: read term/3 ,read term/2 ,read/2 ,read/1 (section 8.14.1, page 104),
read atom/2 ,read atom/1 ,read integer/2 ,read integer/1 ,read number/2 ,read number/1 (sec-
tion 8.14.2, page 105) or read token/2 ,read token/1 (section 8.14.3, page 106).
108 8 PROLOG BUILT-IN PREDICATES
Errors
Line is neither a variable nor an integer type error(integer, Line)
Column is neither a variable nor an integer type error(integer, Column)
Portability
GNU Prolog predicate.
8.14.6 write term/3 ,write term/2 ,write/2 ,write/1 ,writeq/2 ,writeq/1 ,
write canonical/2 ,write canonical/1 ,display/2 ,display/1 ,print/2 ,
print/1
Templates
write term(+stream oralias, ?term, +write option list)
write term(?term, +write option list)
write(+stream oralias, ?term)
write(?term)
writeq(+stream oralias, ?term)
writeq(?term)
write canonical(+stream oralias, ?term)
write canonical(?term)
display(+stream oralias, ?term)
display(?term)
print(+stream oralias, ?term)
print(?term)
Description
write term(SorA, Term, Options) writes Term to the stream associated with the stream-term or alias
SorA according to the options given by Options .
Write options :Options is a list of write options. If this list contains contradictory options, the
rightmost option is the one which applies. Possible options are:
â€¢quoted(true /false) : iftrue each atom and functor is quoted if this would be necessary for the
term to be input by read term/3 . Iffalse no extra quotes are written. The default value is false .
â€¢ignore ops(true /false) : iftrue each compound term is output in functional notation (neither
operator notation nor list notation is used). If false operator and list notations are used. The
default value is false .
â€¢numbervars(true /false) : iftrue a term of the form '$VAR'(N) , where Nis an integer, is output
as a variable name (see below). If false such a term is output normally (according to the other
options). The default value is false .
â€¢namevars(true /false) : iftrue a term of the form '$VARNAME'(Name) , where Name is an atom
respecting the syntax of variable names, is output as a variable name (see below). If false such a
term is output normally (according to the other options). The default value is false .
â€¢variable names(VNL) :VNLis a list of pairs Name = Var where Varis a variable and Name is the
atom associated with the name of Var. Each variable Varis written as the atom Name (with
quoted(false) ) i a term Name = Var is an element of the list VNL. If several pairs exist for the
same variable name the rst one applies.
8.14 Term input/output 109
â€¢space args(true /false) : iftrue an extra space character is emitted after each comma separating
the arguments of a compound term in functional notation or of a list. If false no extra space is
emitted. The default value is false .
â€¢portrayed(true /false) : iftrue and if there exists a predicate portray/1 ,write term/3 acts
as follows: if Term is a variable it is simply written. If Term is non-variable then it is passed to
portray/1 . If this succeeds then it is assumed that Term has been output. Otherwise write term/3
outputs the principal functor of Term (Term itself if it is atomic) according to other options
and recursively calls portray/1 on the components of Term (if it is a compound term). With
ignore ops(false) a list is rst passed to portray/1 and only if this call fails each element of the
list is passed to portray/1 (thus every sub-list is not passed). The default value is false .
â€¢maxdepth(N) : controls the depth of output for compound terms. Nis an integer specifying the
depth. The output of a term whose depth is greater than Ngives rise to the output of ...(3 dots).
By default there is no depth limit.
â€¢priority(N) : species the starting priority to output the term. This option controls if Term should
be enclosed in brackets. Nis a positive integer 1200. By default N= 1200.
Variable numbering : when the numbervars(true) option is passed to write term/3 any term of the
form '$VAR'(N) where Nis an integer is output as a variable name consisting of a capital letter possibly
followed by an integer. The capital letter is the (I+1) thletter of the alphabet and the integer is J, where
I = N mod 26 andJ = N // 26 . The integer Jis omitted if it is zero. For example:
'$VAR'(0) is written as A
'$VAR'(1) is written as B
...
'$VAR'(25) is written as Z
'$VAR'(26) is written as A1
'$VAR'(27) is written as B1
Variable naming : when the namevars(true) option is passed to write term/3 any term of the form
'$VARNAME'(Name) where Name is an atom is output as a variable name consisting of the characters Name .
For example: '$VARNAME'('A') is written as A(even in the presence of the quoted(true) option).
write(SorA, Term) is equivalent to write term(SorA, Term, [numbervars(true),
namevars(true)]) .
writeq(SorA, Term) is equivalent to write term(SorA, Term, [quoted(true),
numbervars(true), namevars(true)]) .
write canonical(SorA, Term) is equivalent to write term(SorA, Term, [quoted(true),
ignore ops(true), numbervars(false), namevars(false)]) .
display(SorA, Term) is equivalent to write term(SorA, Term, [ignore ops(true),
numbervars(false), namevars(false)]) .
print(SorA, Term) is equivalent to write term(SorA, Term, [numbervars(false),
portrayed(true)]) .
write term/2 ,write/1 ,writeq/1 ,write canonical/1 ,display/1 and print/1 apply to the current
output stream.
Errors
110 8 PROLOG BUILT-IN PREDICATES
SorA is a variable instantiation error
Options is a partial list or a list with an element
Ewhich is a variableinstantiation error
Options is neither a partial list nor a list type error(list, Options)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
an element Eof the Options list is neither a
variable nor a valid write-optiondomain error(write option, E)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an input stream permission error(output, stream, SorA)
SorA is associated with a binary streampermission error(output, binary stream,
SorA)
Portability
ISO predicates except display/1-2 andprint/1-2 that are GNU Prolog predicates. namevars ,variable names
space args ,portrayed ,maxdepth andpriority options are GNU Prolog extensions.
8.14.7 format/3 ,format/2
Templates
format(+stream oralias, +character code list oratom, +list)
format(+character code list oratom, +list)
Description
format(SorA, Format, Arguments) writes the Format string replacing each format control sequence F
by the corresponding element of Arguments (formatted according to F) to the stream associated with the
stream-term or alias SorA .
Format control sequences : the general format of a control sequence is '~NC' . The character Cdeter-
mines the type of the control sequence. Nis an optional numeric argument. An alternative form of Nis
'*'.'*'implies that the next argument ArginArguments should be used as a numeric argument in
the control sequence. The use of C printf() formatting sequence (beginning by the character %) is also
allowed. The following control sequences are available:
8.14 Term input/output 111
Format
sequencetype of the
argumentDescription
~Na atom print the atom without quoting. Nis minimal number of characters
to print using spaces on the right if needed (default: the length of
the atom)
~Nc character code print the character associated with the code. Nis the number of
times to print the character (default: 1)
~Nf
~Ne ~NE
~Ng ~NGoat expression pass the argument Arg and Nto the C printf() function as:
ifNis not specied printf("%f",Arg) else printf("%.Nf",Arg) .
Similarly for ~Ne,~NE,~Ngand~NG
~Nd integer expression print the argument. Nis the number of digits after the decimal point.
IfNis 0 no decimal point is printed (default: 0)
~ND integer expression identical to ~Ndexcept that ','separates groups of three digits to
the left of the decimal point
~Nr integer expression print the argument according to the radix N. 2N36 (default: 8).
The letters a-zdenote digits >9
~NR integer expression identical to ~Nrexcept that the letters A-Zdenote digits >9
~Ns character code list print exactly Ncharacters (default: the length of the list)
~NS character list print exactly Ncharacters (default: the length of the list)
~i term ignore the current argument
~k term pass the argument to write canonical/1 (section 8.14.6, page 108)
~p term pass the argument to print/1 (section 8.14.6, page 108)
~q term pass the argument to writeq/1 (section 8.14.6, page 108)
~w term pass the argument to write/1 (section 8.14.6, page 108)
~~ none print the character '~'
~Nn none print Nnew-line characters (default: 1)
~N none print a new-line character if not at the beginning of a line
~? atom use the argument as a nested format string
%Fatom, integer or
oat expressioninterface to the C function printf(3) for outputting atoms (C
string), integers and oating point numbers. *are also allowed.
format/2 applies to the current output stream.
Errors
112 8 PROLOG BUILT-IN PREDICATES
SorA is a variable instantiation error
Format is a partial list or a list with an element
Ewhich is a variableinstantiation error
Arguments is a partial list instantiation error
Format is neither a partial list nor a list or an
atomtype error(list, Format)
Arguments is neither a partial list nor a list type error(list, Arguments)
an element Eof the Format list is neither a
variable nor a character coderepresentation error(character code, E)
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
an element Eof Format is not a valid format
control sequencedomain error(format control sequence, E)
theArguments list does not contain sucient
elementsdomain error(non empty list, [])
an element Eof the Arguments list is a variable
while a non-variable term was expectedinstantiation error
an element Eof the Arguments list is neither
variable nor an atom while an atom was expectedtype error(atom, E)
an element Eof the Arguments cannot be
evaluated as an arithmetic expression while an
integer or a oating point number was expectedan arithmetic error (section 8.6.1, page 66)
an element Eof the Arguments list is neither
variable nor character code while a character
code was expectedrepresentation error(character code, E)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an input stream permission error(output, stream, SorA)
SorA is associated with a binary streampermission error(output, binary stream,
SorA)
Portability
GNU Prolog predicates.
8.14.8 portray clause/2 ,portray clause/1
Templates
portray clause(+stream oralias, +clause)
portray clause(+clause)
Description
portray clause(SorA, Clause) pretty prints Clause to the stream associated with the stream-term
or alias SorA .portray clause/2 uses the variable binding predicates name singleton vars/1 (sec-
tion 8.5.1, page 63) and numbervars/1 (section 8.5.3, page 64). This predicate is used by listing/1
(section 8.23.3, page 154).
portray clause/1 applies to the current output stream.
Errors
8.14 Term input/output 113
Clause is a variable instantiation error
Clause is neither a variable nor a callable term type error(callable, Clause)
SorA is a variable instantiation error
SorA is neither a variable nor a stream-term or
aliasdomain error(stream oralias, SorA)
SorA is not associated with an open stream existence error(stream, SorA)
SorA is an input stream permission error(output, stream, SorA)
SorA is associated with a binary streampermission error(output, binary stream,
SorA)
Portability
GNU Prolog predicates.
8.14.9 getprint stream/1
Templates
getprint stream(?stream)
Description
getprint stream(Stream) unies Stream with the stream-term associated with the output stream used
byprint/2 (section 8.14.6, page 108). The purpose of this predicate is to allow a user-dened portray/1
predicate to identify the output stream in use.
Errors
Stream is neither a variable nor a stream-term domain error(stream, Stream)
Portability
GNU Prolog predicate.
8.14.10 op/3
Templates
op(+integer, +operator specifier, +atom oratom list)
Description
op(Priority, OpSpecifier, Operator) alters the operator table. Operator is declared as an operator
with properties dened by specier OpSpecifier andPriority .Priority must be an integer 0 and
1200. If Priority is 0 then the operator properties of Operator (if any) are canceled. Operator may
also be a list of atoms in which case all of them are declared to be operators. In general, operators can
be removed from the operator table and their priority or specier can be changed. However, it is an
error to attempt to change the ','operator from its initial status. An atom can have multiple operator
denitions (e.g. prex and inx like +) however an atom cannot have both an inx and a postx operator
denitions.
Operator speciers : the following speciers are available:
114 8 PROLOG BUILT-IN PREDICATES
Specier Type Associativity
fx prex no
fy prex yes
xf postx no
yf postx yes
xfx inx no
yfx inx left
xfy inx right
Prolog predened operators :
Priority Specier Operators
1200 xfx :- -->
1200 fx :-
1105 xfy |
1100 xfy ;
1050 xfy -> *->
1000 xfy ,
900 fy \+
700 xfx= \= =.. == \== @< @=< @> @>= is =:= =\= < =<
> >=
600 xfy :
500 yfx + - /\ \/
400 yfx * / // rem mod div << >>
200 xfx ** ^
200 fy + - \
FD predened operators :
Priority Specier Operators
750 xfy #<=> #\<=>
740 xfy #==> #\==>
730 xfy ## #\/ #\\/
720 yfx #/\ #\/\
710 fy #\
700 xfx #= #\= #< #=< #> #>= #=# #\=# #<# #=<# #># #>=#
500 yfx + -
400 yfx * / // rem
200 xfy **
200 fy + -
Errors
8.14 Term input/output 115
Priority is a variable instantiation error
OpSpecifier is a variable instantiation error
Operator is a partial list or a list with an
element Ewhich is a variableinstantiation error
Priority is neither a variable nor an integer type error(integer, Priority)
OpSpecifier is neither a variable nor an atom type error(atom, OpSpecifier)
Operator is neither a partial list nor a list nor
an atomtype error(list, Operator)
an element Eof the Operator list is neither a
variable nor an atomtype error(atom, E)
Priority is an integer not0 and1200 domain error(operator priority, Priority)
OpSpecifier is not a valid operator specierdomain error(operator specifier,
OpSpecifier)
Operator (or an element of the Operator list) is
','permission error(modify, operator, ',')
OpSpecifier is a specier such that Operator
would have a postx and an inx denition.permission error(create, operator,
Operator)
Operator (or an element of the Operator list) is
|and it would have a prex or a postx
denition or its Priority would be1100.permission error(create, operator, '|')
Operator (or an element of the Operator list) is
[]or{}.permission error(create, operator,
Operator)
Portability
ISO predicate.
The ISO reference implies that if a program calls current op/3 , then modies an operator denition by
calling op/3 and backtracks into the call to current op/3 , then the changes are guaranteed not to aect
that current op/3 goal. This is not guaranteed by GNU Prolog.
8.14.11 current op/3
Templates
current op(?integer, ?operator specifier, ?atom)
Description
current op(Priority, OpSpecifier, Operator) succeeds if Operator is an operator with properties
dened by specier OpSpecifier andPriority . This predicate is re-executable on backtracking.
Errors
Priority is neither a variable nor an operator
prioritydomain error(operator priority, Priority)
OpSpecifier is neither a variable nor an
operator specierdomain error(operator specifier,
OpSpecifier)
Operator is neither a variable nor an atom type error(atom, Operator)
Portability
ISO predicate.
116 8 PROLOG BUILT-IN PREDICATES
8.14.12 char conversion/2
Templates
char conversion(+character, +character)
Description
char conversion(InChar, OutChar) alters the character-conversion mapping. This mapping is used by
the following read predicates: read term/3 (section 8.14.1, page 104), read atom/2 ,read integer/2 ,
read number/2 (section 8.14.2, page 105) and read token/2 (section 8.14.3, page 106) to replace any
occurrence of a character InChar byOutChar . However the conversion mechanism should have been
previously activated by switching on the char conversion Prolog ag (section 8.22.1, page 148). When
InChar andOutChar are the same, the eect is to remove any conversion of a character InChar .
Note that the single character read predicates (e.g. getchar/2 ) never do character conversion. If
such behavior is required, it must be explicitly done using current char conversion/2 (section 8.14.13,
page 116).
Errors
InChar is a variable instantiation error
OutChar is a variable instantiation error
InChar is neither a variable nor a character type error(character, InChar)
OutChar is neither a variable nor a character type error(character, OutChar)
Portability
ISO predicate. The type error(character,...) is a GNU Prolog behavior, the ISO reference instead
denes a representation error(character) in this case. This seems to be an error of the ISO refer-
ence since, for many other built-in predicates accepting a character (e.g. char code/2 ,putchar/2 ), a
type error is raised.
The ISO reference implies that if a program calls current char conversion/2 , then modies the charac-
ter mapping by calling char conversion/2 , and backtracks into the call to current char conversion/2
then the changes are guaranteed not to aect that current char conversion/2 goal. This is not guar-
anteed by GNU Prolog.
8.14.13 current char conversion/2
Templates
current char conversion(?character, ?character)
Description
current char conversion(InChar, OutChar) succeeds if the conversion of InChar isOutChar according
to the character-conversion mapping. In that case, InChar andOutChar are dierent. This predicate is
re-executable on backtracking.
Errors
InChar is neither a variable nor a character type error(character, InChar)
OutChar is neither a variable nor a character type error(character, OutChar)
8.15 Input/output from/to constant terms 117
Portability
ISO predicate. Same remark as for char conversion/2 (section 8.14.12, page 116).
8.15 Input/output from/to constant terms
These built-in predicates enable a Prolog term to be input from or output to a Prolog constant term
(atom, character list or character code list). All these predicates can be dened using constant term
streams (section 8.11, page 94). They are however simpler to use.
8.15.1 read term from atom/3 ,read from atom/2 ,read token from atom/2
Templates
read term from atom(+atom ?term, +read option list)
read from atom(+atom, ?term)
read token from atom(+atom, ?nonvar)
Description
Like read term/3 ,read/2 (section 8.14.1, page 104) and read token/2 (section 8.14.3, page 106) except
that characters are not read from a text-stream but from Atom ; the atom given as rst argument.
Errors
Atom is a variable instantiation error
Atom is neither a variable nor an atom type error(atom, Atom)
see associated predicate errors(section 8.14.1, page 104) and (section 8.14.3,
page 106)
Portability
GNU Prolog predicates.
8.15.2 read term from chars/3 ,read from chars/2 ,read token from chars/2
Templates
read term from chars(+character list ?term, +read option list)
read from chars(+character list, ?term)
read token from chars(+character list, ?nonvar)
Description
Like read term/3 ,read/2 (section 8.14.1, page 104) and read token/2 (section 8.14.3, page 106) except
that characters are not read from a text-stream but from Chars ; the character list given as rst argument.
Errors
118 8 PROLOG BUILT-IN PREDICATES
Chars is a partial list or a list with an element E
which is a variableinstantiation error
Chars is neither a partial list nor a list type error(list, Chars)
an element Eof the Chars list is neither a
variable nor a charactertype error(character, E)
see associated predicate errors(section 8.14.1, page 104) and (section 8.14.3,
page 106)
Portability
GNU Prolog predicates.
8.15.3 read term from codes/3 ,read from codes/2 ,read token from codes/2
Templates
read term from codes(+character code list ?term, +read option list)
read from codes(+character code list, ?term)
read token from codes(+character code list, ?nonvar)
Description
Like read term/3 ,read/2 (section 8.14.1, page 104) and read token/2 (section 8.14.3, page 106) except
that characters are not read from a text-stream but from Codes ; the character code list given as rst
argument.
Errors
Codes is a partial list or a list with an element E
which is a variableinstantiation error
Codes is neither a partial list nor a list type error(list, Codes)
an element Eof the Codes list is neither a
variable nor an integertype error(integer, E)
an element Eof the Codes list is an integer but
not a character coderepresentation error(character code, E)
see associated predicate errors(section 8.14.1, page 104) and (section 8.14.3,
page 106)
Portability
GNU Prolog predicates.
8.15.4 write term toatom/3 ,write toatom/2 ,writeq toatom/2 ,
write canonical toatom/2 ,display toatom/2 ,print toatom/2 ,
format toatom/3
Templates
write term toatom(?atom, ?term, +write option list)
write toatom(?atom, ?term)
writeq toatom(?atom, ?term)
write canonical toatom(?atom, ?term)
8.15 Input/output from/to constant terms 119
display toatom(?atom, ?term)
print toatom(?atom, ?term)
format toatom(?atom, +character code list oratom, +list)
Description
Similar to write term/3 ,write/2 ,writeq/2 ,write canonical/2 ,display/2 ,print/2 (section 8.14.6,
page 108) and format/3 (section 8.14.7, page 110) except that characters are not written onto a text-
stream but are collected as an atom which is then unied with the rst argument Atom .
Errors
Atom is neither a variable nor an atom type error(atom, Atom)
see associated predicate errors(section 8.14.6, page 108) and (section 8.14.7,
page 110)
Portability
GNU Prolog predicates.
8.15.5 write term tochars/3 ,write tochars/2 ,writeq tochars/2 ,
write canonical tochars/2 ,display tochars/2 ,print tochars/2 ,
format tochars/3
Templates
write term tochars(?character list, ?term, +write option list)
write tochars(?character list, ?term)
writeq tochars(?character list, ?term)
write canonical tochars(?character list, ?term)
display tochars(?character list, ?term)
print tochars(?character list, ?term)
format tochars(?character list, +character code list oratom, +list)
Description
Similar to write term/3 ,write/2 ,writeq/2 ,write canonical/2 ,display/2 ,print/2 (section 8.14.6,
page 108) and format/3 (section 8.14.7, page 110) except that characters are not written onto a text-
stream but are collected as a character list which is then unied with the rst argument Chars .
Errors
Chars is neither a partial list nor a list type error(list, Chars)
An element Eof the list Chars is neither a
variable nor a one-char atomtype error(character, E)
see associated predicate errors(section 8.14.6, page 108) and (section 8.14.7,
page 110)
Portability
GNU Prolog predicates.
120 8 PROLOG BUILT-IN PREDICATES
8.15.6 write term tocodes/3 ,write tocodes/2 ,writeq tocodes/2 ,
write canonical tocodes/2 ,display tocodes/2 ,print tocodes/2 ,
format tocodes/3
Templates
write term tocodes(?character code list, ?term, +write option list)
write tocodes(?character code list, ?term)
writeq tocodes(?character code list, ?term)
write canonical tocodes(?character code list, ?term)
display tocodes(?character code list, ?term)
print tocodes(?character code list, ?term)
format tocodes(?character code list, +character code list oratom, +list)
Description
Similar to write term/3 ,write/2 ,writeq/2 ,write canonical/2 ,display/2 ,print/2 (section 8.14.6,
page 108) and format/3 (section 8.14.7, page 110) except that characters are not written onto a text-
stream but are collected as a character code list which is then unied with the rst argument Codes .
Errors
Codes is neither a partial list nor a list type error(list, Codes)
An element Eof the list Codes is neither a
variable nor an integertype error(integer, E)
An element Eof the list Codes is an integer but
not a character coderepresentation error(character code)
see associated predicate errors(section 8.14.6, page 108) and (section 8.14.7,
page 110)
Portability
GNU Prolog predicates.
8.16 DEC-10 compatibility input/output
8.16.1 Introduction
The DEC-10 Prolog I/O predicates manipulate streams implicitly since they only refer to current in-
put/output streams (section 8.10.1, page 78). The current input and output streams are initially set
touser input and user output respectively. The predicate see/1 (resp. tell/1 ,append/1 ) can be
used for setting the current input (resp. output) stream to newly opened streams for particular les.
The predicate seen/0 (resp. told/0 ) close the current input (resp. output) stream, and resets it to the
standard input (resp. output). The predicate seeing/1 (resp. telling/1 ) is used for retrieving the
le name associated with the current input (resp. output) stream. The le name user stands for the
standard input or output, depending on context ( user input and user output can also be used). The
DEC-10 Prolog I/O predicates are only provided for compatibility, they are now obsolete and their use
is discouraged. The predicates for explicit stream manipulation should be used instead (section 8.10,
page 78).
8.16 DEC-10 compatibility input/output 121
8.16.2 see/1 ,tell/1 ,append/1
Templates
see(+source sink)
see(+stream)
tell(+source sink)
tell(+stream)
append(+source sink)
append(+stream)
Description
see(FileName) sets the current input stream to FileName . If there is a stream opened by see/1 associ-
ated with the same FileName already, then it becomes the current input stream. Otherwise, FileName
is opened for reading and becomes the current input stream.
tell(FileName) sets the current output stream to FileName . If there is a stream opened by tell/1
associated with the same FileName already, then it becomes the current output stream. Otherwise,
FileName is opened for writing and becomes the current output stream.
append(FileName) liketell/1 butFileName is opened for writing + append.
A stream-term (obtained with any other built-in predicate) can also be provided as FileName to these
predicates.
Errors
See errors associated with open/4 (section 8.10.6, page 81).
Portability
GNU Prolog predicates. Deprecated.
8.16.3 seeing/1 ,telling/1
Templates
seeing(?source sink)
telling(?source sink)
Description
seeing(FileName) succeeds if FileName unies with the name of the current input le, if it was opened
bysee/1 ; else with the current input stream-term, if this is not user input , otherwise with user .
telling(FileName) succeeds if FileName unies with the name of the current output le, if it was
opened by tell/1 orappend/1 ; else with the current output stream-term, if this is not user output ,
otherwise with user .
Errors
None.
122 8 PROLOG BUILT-IN PREDICATES
Portability
GNU Prolog predicates. Deprecated.
8.16.4 seen/0 ,told/0
Templates
seen
told
Description
seen closes the current input, and resets it to user input .
told closes the current output, and resets it to user output .
Errors
None.
Portability
GNU Prolog predicates. Deprecated.
8.16.5 get0/1 ,get/1 ,skip/1
Templates
get0(?in character code)
get(?in character code)
skip(+character code)
Description
get0(Code) succeeds if Code unies with the next character code read from the current input stream.
Thus it is equivalent to getcode(Code) (section 8.12.1, page 97).
get(Code) succeeds if Code unies with the next character code read from the current input stream that
is not a layout character.
skip(Code) skips just past the next character code Code from the current input stream.
Errors
See errors for getcode/2 (section 8.12.1, page 97).
Portability
GNU Prolog predicates. Deprecated.
8.17 Term expansion 123
8.16.6 put/1 ,tab/1
Templates
put(+character code)
tab(+evaluable)
Description
put(Code) writes the character whose code is Code onto the current output stream. It is equivalent to
putcode(Code) (section 8.12.5, page 100).
tab(N) writes Nspaces onto the current output stream. Nmay be an arithmetic expression.
Errors
See errors for putcode/2 (section 8.12.5, page 100) and for arithmetic expressions (section 8.6.1, page 66).
Portability
GNU Prolog predicates. Deprecated.
8.17 Term expansion
8.17.1 Denite clause grammars
Denite clause grammars are a useful notation to express grammar rules. However the ISO reference does
not include them, so they should be considered as a system dependent feature. Denite clause grammars
are an extension of context-free grammars. A grammar rule is of the form:
head --> body .
-->is a predened inx operator (section 8.14.10, page 113).
Here are some features of denite clause grammars:
â€¢a non-terminal symbol may be any callable term.
â€¢a terminal symbol may be any Prolog term and is written as a list. The empty list represents an
empty sequence of terminals.
â€¢a sequence is expressed using the Prolog conjunction operator ((',')/2).
â€¢the head of a grammar rule consists of a non-terminal optionally followed by a sequence of terminals
(i.e. a Prolog list).
â€¢the body of a grammar rule consists of a sequence of non-terminals, terminals, predicate call,
disjunction (using ;/2), if-then (using (->)/2 ) or cut (using !).
â€¢a predicate call must be enclosed in curly brackets (using {}/1 ). This makes it possible to express
an extra condition.
A grammar rule is nothing but a \syntactic sugar" for a Prolog clause. Each grammar rule accepts as
input a list of terminals (tokens), parses a prex of this list and gives as output the rest of this list
(possibly enlarged). This rest is generally parsed later. So, each a grammar rule is translated into a
Prolog clause that explicitly the manages the list. Two arguments are then added: the input list ( Start )
and the output list ( End). For instance:
124 8 PROLOG BUILT-IN PREDICATES
p --> q.
is translated into:
p(Start, End) :- q(Start, End).
Extra arguments can be provided and the body of the rule can contain several non-terminals. Example:
p(X, Y) -->
q(X),
r(X, Y),
s(Y).
is translated into:
p(X, Y, Start, End) :-
q(X, Start, A),
r(X, Y, A, B),
s(Y, B, End).
Terminals are translated using unication:
assign(X,Y) --> left(X), [:=], right(Y), [;].
is translated into:
assign(X,Y,Start,End) :-
left(X, Start, A),
A=[:=|B],
right(Y, B, C),
C=[;|End].
Terminals appearing on the left-hand side of a rule are connected to the output argument of the head.
It is possible to include a call to a prolog predicate enclosing it in curly brackets (to distinguish them
from non-terminals):
assign(X,Y) --> left(X), [:=], right(Y0), {Y is Y0 }, [;].
is translated into:
assign(X,Y,Start,End) :-
left(X, Start, A),
A=[:=|B],
right(Y0, B, C),
Y is Y0,
C=[;|End].
Cut, disjunction and if-then(-else) are translated literally (and do not need to be enclosed in curly
brackets).
8.17.2 expand term/2 ,term expansion/2
Templates
expand term(?term, ?term)
term expansion(?term, ?term)
8.17 Term expansion 125
Description
expand term(Term1, Term2) succeeds if Term2 is a transformation of Term1 . The transformation steps
are as follows:
â€¢ifTerm1 is a variable, it is unied with Term2
â€¢ifterm expansion(Term1, Term2) succeeds Term2 is assumed to be the transformation of Term1 .
â€¢ifTerm1 is a DCG then Term2 is its translation (section 8.17.1, page 123).
â€¢otherwise Term2 is unied with Term1 .
term expansion(Term1, Term2) is a hook predicate allowing the user to dene a specic transformation.
The GNU Prolog compiler (section 4.4, page 21) automatically calls expand term/2 on each Term1
read in. However, in the current release, only DCG transformation are done by the compiler (i.e.
term expansion/2 cannot be used). To use term expansion/2 , it is necessary to call expand term/2
explicitly.
Errors
None.
Portability
GNU Prolog predicate.
8.17.3 phrase/3 ,phrase/2
Templates
phrase(?term, ?list, ?list)
phrase(?term, ?list)
Description
phrase(Phrase, List, Remainder) succeeds if the list List is in the language dened by the grammar
rule body Phrase .Remainder is what remains of the list after a phrase has been found.
phrase(Phrase, List) is equivalent to phrase(Phrase, List, []) .
Errors
Phrase is a variable instantiation error
Phrase is neither a variable nor a callable term type error(callable, Phrase)
List is neither a list nor a partial list type error(list, List)
Remainder is neither a list nor a partial list type error(list, Remainder)
Portability
GNU Prolog predicates.
126 8 PROLOG BUILT-IN PREDICATES
8.18 Logic, control and exceptions
8.18.1 abort/0 ,stop/0 ,toplevel/0 ,break/0 ,halt/1 ,halt/0
Templates
abort
stop
toplevel
break
halt(+integer)
halt
Description
abort aborts the current execution. If this execution was initiated under a top-level the control is given
back to the top-level and the message {execution aborted} is displayed. Otherwise, e.g. execution
started by a initialization/1 directive (section 7.1.14, page 50), abort/0 is equivalent to halt(1)
(see below).
stop stops the current execution. If this execution was initiated under a top-level the control is given
back to the top-level. Otherwise, stop/0 is equivalent to halt(0) (see below).
toplevel starts a new recursive top-level (including the banner display). To end this new top-level
simply type the end-of-le key sequence ( Ctl-D ) or its term representation: endoffile.
break invokes a recursive top-level (no banner is displayed). To end this new level simply type the
end-of-le key sequence ( Ctl-D ) or its term representation: endoffile.
halt(Status) causes the GNU Prolog process to immediately exit back to the shell with the return code
Status .
halt is equivalent to halt(0) .
Errors
Status is a variable instantiation error
Status is neither a variable nor an integer type error(integer, Status)
Portability
halt/1 and halt/0 are ISO predicates. abort/0 ,stop/0 ,toplevel/0 and break/0 are GNU Prolog
predicates.
8.18.2 false/0 ,once/1 ,(\+)/1 - not provable, call/2-11 ,call with args/1-11 ,call det/2 ,
forall/2
Templates
false
once(+callable term)
\+(+callable term)
call(+callable term, +term,..., +term)
8.18 Logic, control and exceptions 127
call with args(+atom, +term,..., +term)
call det(+callable term, ?boolean)
forall(+callable term, +callable term)
Description
false always fails and enforces backtracking. It is equivalent to the fail/0 control construct (sec-
tion 7.2.1, page 51).
once(Goal) succeeds if call(Goal) succeeds. However once/1 is not re-executable on backtracking since
all alternatives of Goal are cut. once(Goal) is equivalent to call(Goal), ! .
\+ Goal succeeds if call(Goal) fails and fails otherwise. This built-in predicate gives negation by failure.
call(Closure, Arg1,..., ArgN) calls the goal call(Goal) where Goal is constructed by appending
Arg1,..., ArgN (1N10) additional arguments to the arguments (if any) of Closure .
call with args(Functor, Arg1,..., ArgN) calls the goal whose functor is Functor and whose argu-
ments are Arg1 ,. . . , ArgN (0N10).
call det(Goal, Deterministic) succeeds if call(Goal) succeeds and unies Deterministic with
true ifGoal has not created any choice-points, with false otherwise.
forall(Condition, Action) succeeds if for all alternative bindings of Condition ,Action can be proven.
It is equivalent to \+ (Condition, \+ Action) .
\+is a predened prex operator (section 8.14.10, page 113).
Errors
Goal (orCondition orAction ) is a variable instantiation error
Goal (orCondition orAction ) is neither a
variable nor a callable termtype error(callable, Goal)
The predicate indicator Pred ofGoal does not
correspond to an existing procedure and the
value of the unknown Prolog ag is error
(section 8.22.1, page 148)existence error(procedure, Pred)
Functor is a variable instantiation error
Functor is neither a variable nor an atom type error(atom, Functor)
Deterministic is neither a variable nor a
booleantype error(boolean, Deterministic)
forcall/2-11 the resulting arity of Goal (arity
ofClosure +N) is an integer >maxarity ag
(section 8.22.1, page 148)representation error(max arity)
Portability
false/0 ,call/2-8 ,once/1 and(\+)/1 are ISO predicates. call/9-11 ,call with args/1-11 ,call det/2
andforall/2 are GNU Prolog predicates.
8.18.3 repeat/0
Templates
128 8 PROLOG BUILT-IN PREDICATES
repeat
Description
repeat generates an innite sequence of backtracking choices. The purpose is to repeatedly perform some
action on elements which are somehow generated, e.g. by reading them from a stream, until some test
becomes true. Repeat loops cannot contribute to the logic of the program. They are only meaningful
if the action involves side-eects. The only reason for using repeat loops instead of a more natural tail-
recursive formulation is eciency: when the test fails back, the Prolog engine immediately reclaims any
working storage consumed since the call to repeat/0 .
Errors
None.
Portability
ISO predicate.
8.18.4 between/3 ,for/3
Templates
between(+integer, +integer, ?integer)
for(?integer, +integer, +integer)
Description
between(Lower, Upper, Counter) generates an sequence of backtracking choices instantiating Counter
to the values Lower ,Lower+1 ,. . . , Upper .
for(Counter, Lower, Upper) is equivalent to between(Lower, Upper, Counter) . This predicate is
deprecated and new code should use between/3 .
Errors
Counter is neither a variable nor an integer type error(integer, Counter)
Lower is a variable instantiation error
Lower is neither a variable nor an integer type error(integer, Lower)
Upper is a variable instantiation error
Upper is neither a variable nor an integer type error(integer, Upper)
Portability
GNU Prolog predicate.
8.19 Atomic term processing
These built-in predicates enable atomic terms to be processed as a sequence of characters and character
codes. Facilities exist to split and join atoms, to convert a single character to and from the corresponding
character code, and to convert a number to and from a list of characters and character codes.
8.19 Atomic term processing 129
8.19.1 atom length/2
Templates
atom length(+atom, ?integer)
Description
atom length(Atom, Length) succeeds if Length unies with the number of characters of the name of
Atom .
Errors
Atom is a variable instantiation error
Atom is neither a variable nor an atom type error(atom, Atom)
Length is neither a variable nor an integer type error(integer, Length)
Length is an integer <0 domain error(not less than zero, Length)
Portability
ISO predicate.
8.19.2 atom concat/3
Templates
atom concat(+atom, +atom, ?atom)
atom concat(?atom, ?atom, +atom)
Description
atom concat(Atom1, Atom2, Atom12) succeeds if the name of Atom12 is the concatenation of the name
ofAtom1 with the name of Atom1 . This predicate is re-executable on backtracking (e.g. if Atom12 is
instantiated and both Atom1 andAtom2 are variables).
Errors
Atom1 andAtom12 are variables instantiation error
Atom2 andAtom12 are variables instantiation error
Atom1 is neither a variable nor an atom type error(atom, Atom1)
Atom2 is neither a variable nor an atom type error(atom, Atom2)
Atom12 is neither a variable nor an atom type error(atom, Atom12)
Portability
ISO predicate.
8.19.3 subatom/5
Templates
subatom(+atom, ?integer, ?integer, ?integer, ?atom)
130 8 PROLOG BUILT-IN PREDICATES
Description
subatom(Atom, Before, Length, After, SubAtom) succeeds if atom Atom can be split into three
atoms, AtomL ,SubAtom andAtomR such that Before is the number of characters of the name of AtomL ,
Length is the number of characters of the name of SubAtom andAfter is the number of characters of the
name of AtomR . This predicate is re-executable on backtracking.
Errors
Atom is a variable instantiation error
Atom is neither a variable nor an atom type error(atom, Atom)
SubAtom is neither a variable nor an atom type error(atom, SubAtom)
Before is neither a variable nor an integer type error(integer, Before)
Length is neither a variable nor an integer type error(integer, Length)
After is neither a variable nor an integer type error(integer, After)
Before is an integer <0 domain error(not less than zero, Before)
Length is an integer <0 domain error(not less than zero, Length)
After is an integer <0 domain error(not less than zero, After)
Portability
ISO predicate.
8.19.4 char code/2
Templates
char code(+character, ?character code)
char code(-character, +character code)
Description
char code(Char, Code) succeeds if the character code for the one-char atom Char isCode .
Errors
Char andCode are variables instantiation error
Char is neither a variable nor a one-char atom type error(character, Char)
Code is neither a variable nor an integer type error(integer, Code)
Code is an integer but not a character code representation error(character code)
Portability
ISO predicate.
8.19.5 lower upper/2
Templates
lower upper(+character, ?character)
lower upper(-character, +character)
Description
8.19 Atomic term processing 131
lower upper(Char1, Char2) succeeds if Char1 andChar2 are one-char atoms and if Char2 is the upper
conversion of Char1 . IfChar1 (resp. Char2 ) is a character that is not a lower (resp. upper) letter then
Char2 is equal to Char1 .
Errors
Char1 andChar2 are variables instantiation error
Char1 is neither a variable nor a one-char atom type error(character, Char1)
Char2 is neither a variable nor a one-char atom type error(character, Char2)
Portability
GNU Prolog predicate.
8.19.6 atom chars/2 ,atom codes/2
Templates
atom chars(+atom, ?character list)
atom chars(-atom, +character list)
atom codes(+atom, ?character code list)
atom codes(-atom, +character code list)
Description
atom chars(Atom, Chars) succeeds if Chars is the list of one-char atoms whose names are the successive
characters of the name of Atom .
atom codes(Atom, Codes) is similar to atom chars/2 but deals with a list of character codes.
Errors
Atom is a variable and Chars (orCodes ) is a
partial list or a list with an element which is a
variableinstantiation error
Atom is neither a variable nor an atom type error(atom, Atom)
Chars is neither a list nor a partial list type error(list, Chars)
Codes is neither a list nor a partial list type error(list, Codes)
An element Eof the list Chars is neither a
variable nor a one-char atomtype error(character, E)
An element Eof the list Codes is neither a
variable nor an integertype error(integer, E)
An element Eof the list Codes is an integer but
not a character coderepresentation error(character code)
Portability
ISO predicates. The ISO reference only causes a type error(list, Chars) ifAtom is a variable and
Chars is neither a list nor a partial list. GNU Prolog always checks if Chars is a list. Similarly for
Codes . The type error(integer, E) when an element Eof the Codes is not an integer is a GNU Prolog
extension. This seems to be an omission in the ISO reference since this error is detected for many other
built-in predicates accepting a character code (e.g. char code/2 ,putcode/2 ).
132 8 PROLOG BUILT-IN PREDICATES
8.19.7 number atom/2 ,number chars/2 ,number codes/2
Templates
number atom(+number, ?atom)
number atom(-number, +atom)
number chars(+number, ?character list)
number chars(-number, +character list)
number codes(+number, ?character code list)
number codes(-number, +character code list)
Description
number atom(Number, Atom) succeeds if Atom is an atom whose name corresponds to the characters of
Number .
number chars(Number, Chars) is similar to number atom/2 but deals with a list of characters.
number codes(Number, Codes) is similar to number atom/2 but deals with a list of character codes.
Errors
Number andAtom are variables instantiation error
Number is a variable and Chars (orCodes ) is a
partial list or a list with an element which is a
variableinstantiation error
Number is neither a variable nor an number type error(number, Number)
Atom is neither a variable nor an atom type error(atom, Atom)
Chars is neither a list nor a partial list type error(list, Chars)
Codes is neither a list nor a partial list type error(list, Codes)
An element Eof the list Chars is neither a
variable nor a one-char atomtype error(character, E)
An element Eof the list Codes is neither a
variable nor an integertype error(integer, E)
An element Eof the list Codes is an integer but
not a character coderepresentation error(character code)
Number is a variable, Atom (orChars orCodes )
cannot be parsed as a number and the value of
thesyntax error Prolog ag is error
(section 8.22.1, page 148)syntax error( atom explaining the error )
Portability
number atom/2 is a GNU Prolog predicate. number chars/2 andnumber codes/2 are ISO predicates.
GNU Prolog only raises an error about an element Eof the Chars (orCodes ) list when Number is a
variable while the ISO reference always check this. This seems an error since the list itself is only checked
ifNumber is a variable.
The type error(integer, E) when an element Eof the Codes is not an integer is a GNU Prolog
extension. This seems to be an omission in the ISO reference since this error is detected for many other
built-in predicates accepting a character code (e.g. char code/2 ,putcode/2 ).
8.19 Atomic term processing 133
8.19.8 name/2
Templates
name(+atomic, ?character code list)
name(-atomic, +character code list)
Description
name(Constant, Codes) succeeds if Codes is a list whose elements are the character codes corresponding
to the successive characters of Constant (a number or an atom). However, there atoms are for which
name(Constant, Codes) is true, but which will not be constructed if name/2 is called with Constant
uninstantiated, e.g. the atom '1024' . For this reason the use of name/2 is discouraged and should
be limited to compatibility purposes. It is preferable to use atom codes/2 (section 8.19.6, page 131) or
number chars/2 (section 8.19.7, page 132).
Errors
Constant is a variable and Codes is a partial list
or a list with an element which is a variableinstantiation error
Constant is neither a variable nor an atomic
termtype error(atomic, Constant)
Constant is a variable and Codes is neither a list
nor a partial listtype error(list, Codes)
Constant is a variable and an element Eof the
listCodes is neither a variable nor an integertype error(integer, E)
Constant is a variable and an element Eof the
listCodes is an integer but not a character coderepresentation error(character code)
Portability
GNU Prolog predicate.
8.19.9 newatom/2 ,newatom/1
Templates
newatom(+atom, -atom)
newatom(-atom)
Description
newatom(Prefix, Atom) unies Atom with a new atom whose name begins with the characters of the
name of Prefix . This predicate is then a symbol generator. It is guaranteed that Atom does not exist
before the invocation of newatom/3 . The characters appended to Prefix to form Atom are in: A-Z
(capital letter), a-z(small letter) and 0-9(digit).
newatom/1 is similar to newatom(term , Atom) , i.e. the generated atom begins with term .
Errors
Prefix is a variable instantiation error
Prefix is neither a variable nor an atom type error(atom, Prefix)
Atom is not a variable uninstantiation error(Atom)
134 8 PROLOG BUILT-IN PREDICATES
Portability
GNU Prolog predicate.
8.19.10 current atom/1
Templates
current atom(?atom)
Description
current atom(Atom) succeeds if there exists an atom that unies with Atom . All atoms are found except
those beginning with a '$'(system atoms). This predicate is re-executable on backtracking.
Errors
Atom is neither a variable nor an atom type error(atom, Atom)
Portability
GNU Prolog predicate.
8.19.11 atom property/2
Templates
atom property(?atom, ?atom property)
Description
atom property(Atom, Property) succeeds if current atom(Atom) succeeds (section 8.19.10, page 134)
and if Property unies with one of the properties of the atom. This predicate is re-executable on
backtracking.
Atom properties :
â€¢length(Length) :Length is the length of the name of the atom.
â€¢hash(Hash) :Hash is the hash code of the atom, see also term hash/2 (section 8.4.8, page 62).
â€¢prefix op: if there is a prex operator currently dened with this name.
â€¢infix op: if there is an inx operator currently dened with this name.
â€¢postfix op: if there is a postx operator currently dened with this name.
â€¢needs quotes : if the atom must be quoted to be read later.
â€¢needs scan : if the atom must be scanned when output to be read later (e.g. contains special
characters that must be output with a \escape sequence).
Errors
8.20 List processing 135
Atom is neither a variable nor an atom type error(atom, Atom)
Property is neither a variable nor a n atom
property termdomain error(atom property, Property)
Property =length(E) orhash(E) andEis
neither a variable nor an integertype error(integer, E)
Portability
GNU Prolog predicate.
8.20 List processing
These predicates manipulate lists. They are bootstrapped predicates (i.e. written in Prolog) and no
error cases are tested (for the moment). However, since they are written in Prolog using other built-in
predicates, some errors can occur due to those built-in predicates.
8.20.1 append/3
Templates
append(?list, ?list, ?list)
Description
append(List1, List2, List12) succeeds if the concatenation of the list List1 and the list List2 is
the list List12 . This predicate is re-executable on backtracking (e.g. if List12 is instantiated and both
List1 andList2 are variable).
Errors
None.
Portability
GNU Prolog predicate.
8.20.2 member/2 ,memberchk/2
Templates
member(?term, ?list)
memberchk(?term, ?list)
Description
member(Element, List) succeeds if Element belongs to the List . This predicate is re-executable on
backtracking and can be thus used to enumerate the elements of List .
memberchk/2 is similar to member/2 but only succeeds once.
Errors
136 8 PROLOG BUILT-IN PREDICATES
None.
Portability
GNU Prolog predicate.
8.20.3 reverse/2
Templates
reverse(?list, ?list)
Description
reverse(List1, List2) succeeds if List2 unies with the list List1 in reverse order.
Errors
None.
Portability
GNU Prolog predicate.
8.20.4 delete/3 ,select/3
Templates
delete(?list, ?term, ?list)
select(?term, ?list, ?list)
Description
delete(List1, Element, List2) removes all occurrences of Element inList1 to provide List2 . A
strict term equality is required, cf. (==)/2 (section 8.3.2, page 57).
select(Element, List1, List2) removes one occurrence of Element inList1 to provide List2 . This
predicate is re-executable on backtracking.
Errors
None.
Portability
GNU Prolog predicate.
8.20.5 subtract/3
Templates
subtract(+list, +list, ?list)
8.20 List processing 137
Description
subtract(List1, List2, List3) removes all elements in List2 from List1 to provide List3 . Member-
ship is tested using memberchk/2 (section 8.20.2, page 135). The predicate runs in O(jList2jjList1j).
Errors
None.
Portability
GNU Prolog predicate.
8.20.6 permutation/2
Templates
permutation(?list, ?list)
Description
permutation(List1, List2) succeeds if List2 is a permutation of the elements of List1 . This predicate
is re-executable on backtracking.
Errors
None.
Portability
GNU Prolog predicate.
8.20.7 prefix/2 ,suffix/2
Templates
prefix(?list, ?list)
suffix(?list, ?list)
Description
prefix(Prefix, List) succeeds if Prefix is a prex of List . This predicate is re-executable on back-
tracking.
suffix(Suffix, List) succeeds if Suffix is a sux of List . This predicate is re-executable on back-
tracking.
Errors
None.
Portability
GNU Prolog predicate.
138 8 PROLOG BUILT-IN PREDICATES
8.20.8 sublist/2
Templates
sublist(?list, ?list)
Description
sublist(List1, List2) succeeds if all elements of List1 appear in List2 in the same order. This
predicate is re-executable on backtracking.
Errors
None.
Portability
GNU Prolog predicate.
8.20.9 last/2
Templates
last(?list, ?term)
Description
last(List, Element) succeeds if Element is the last element of List .
Errors
None.
Portability
GNU Prolog predicate.
8.20.10 flatten/2
Templates
flatten(?term, ?list)
Description
flat(List1, List2) succeeds if List2 is the atten version of List1 .
Errors
None.
Portability
GNU Prolog predicate.
8.20 List processing 139
8.20.11 length/2
Templates
length(?list, ?integer)
Description
length(List, Length) succeeds if Length is the length of List .
Errors
Length is an integer <0 domain error(not less than zero, Length)
GNU Prolog predicate.
8.20.12 nth/3
Templates
nth(?integer, ?list, ?term)
Description
nth(N, List, Element) succeeds if the Nthargument of List isElement .
Errors
None.
Portability
GNU Prolog predicate.
8.20.13 maxlist/2 ,minlist/2 ,sumlist/2
Templates
minlist(+list, ?number)
maxlist(+list, ?number)
sumlist(+list, ?number)
Description
minlist(List, Min) succeeds if Minis the smallest number in List .
maxlist(List, Max) succeeds if Maxis the largest number in List .
sumlist(List, Sum) succeeds if Sumis the sum of all the elements in List .
List must be a list of arithmetic evaluable terms (section 8.6.1, page 66).
Errors
140 8 PROLOG BUILT-IN PREDICATES
None.
Portability
GNU Prolog predicate.
8.20.14 maplist/2-8
Templates
maplist(+callable term, +list, ..., +list)
Description
maplist(Goal, List) succeeds if Goal can succesfully be applied on all elements of List .
maplist(Goal, List1, List2) succeeds if Goal can succesfully be applied to all pairs of elements of
List1 andList2 .
maplist(Goal, List1, List2, List3) succeeds if Goal can succesfully be applied to all triples of
elements of List1 ..List3 .
maplist(Goal, List1, List2, ..., List N)succeeds if Goal can succesfully be applied to all N-uples
(N8) of elements of List1 ..ListN.
Errors
an error occurs executing a directive seecall/1 errors (section 7.2.3, page 52)
Portability
GNU Prolog predicate.
8.20.15 sort/2 ,msort/2 ,keysort/2 sort/1 ,msort/1 ,keysort/1
Templates
sort(+list, ?list)
msort(+list, ?list)
keysort(+list, ?list)
sort(+list)
msort(+list)
keysort(+list)
Description
sort(List1, List2) succeeds if List2 is the sorted list corresponding to List1 where duplicate elements
are merged.
msort/2 is similar to sort/2 except that duplicate elements are not merged.
keysort(List1, List2) succeeds if List2 is the sorted list of List1 according to the keys. The list
List1 consists of pairs (items of the form Key-Value ). These items are sorted according to the value of
8.21 Global variables 141
Keyyielding the List2 . Duplicate keys are not merged. This predicate is stable, i.e. if K-Aoccurs before
K-Bin the input, then K-Awill occur before K-Bin the output.
sort/1 ,msort/1 and keysort/1 are similar to sort/2 ,msort/2 and keysort/2 but achieve a sort in-
place destructing the original List1 (this in-place assignment is not undone at backtracking). The sorted
list occupies the same memory space as the original list (saving thus memory consumption).
The time complexity of these sorts is O(N log N ),Nbeing the length of the list to sort.
These predicates refer to the standard ordering of terms (section 8.3.1, page 57).
Errors
List1 is a partial list instantiation error
List1 is neither a partial list nor a list type error(list, List1)
List2 is neither a partial list nor a list type error(list, List2)
forkeysort/2 : an element of List1 is a variable instantiation error
forkeysort/2 : an element EofList1 is neither
a variable nor a pairtype error(pair, E)
forkeysort/2 : an element EofList2 is neither
a variable nor a pairtype error(pair, E)
Portability
sort/2 andkeysort/2 are ISO predicates.
sort/1 ,keysort/1 andmsort/1-2 are GNU Prolog predicates.
8.21 Global variables
8.21.1 Introduction
GNU Prolog provides a simple and powerful way to assign and read global variables. A global variable is
associated with each atom, its initial value is the integer 0. A global variable can store 3 kinds of objects:
â€¢a copy of a term (the assignment can be made backtrackable or not).
â€¢a link to a term (the assignment is always backtrackable).
â€¢an array of objects (recursively).
The space necessary for copies and arrays is dynamically allocated and recovered as soon as possible. For
instance, when an atom is associated with a global variable whose current value is an array, the space for
this array is recovered (unless the assignment is to be undone when backtracking occurs).
When a link to a term is associated with a global variable, the reference to this term is stored and thus
the original term is returned when the content of the variable is read.
Global variable naming convention : a global variable is referenced by an atom.
If the variable contains an array, an index (ranging from 0) can be provided using a compound term whose
principal functor is the corresponding atom and the argument is the index. In case of a multi-dimensional
array, each index is given as the arguments of the compound term.
142 8 PROLOG BUILT-IN PREDICATES
If the variable contains a term (link or copy), it is possible to only reference a sub-term by giving its
argument number (also called argument selector). Such a sub-term is specied using a compound term
whose principal functor is -/2and whose rst argument is a global variable name and the second argument
is the argument number (from 1). This can be applied recursively to specify a sub-term of any depth. In
case of a list, a argument number I represents the Ith element of the list. In the rest of this section we
use the operator notation since -is a predened inx operator (section 8.14.10, page 113).
In the following, GVarName represents a reference to a global variable and its syntax is as follows:
GVarName ::= atom whole content of a variable
atom (Integer ,. . .,Integer )element of an array
GVarName -Integer sub-term selection
Integer ::= integer immediate value
GVarName indirect value
When a GVarName is used as an index or an argument number (i.e. indirection), the value of this variable
must be an integer.
Here are some examples of the naming convention:
a the content of variable associated with a(any kind)
t(1) the 2nd element of the array associated with t
t(k) if the value associated with kis I, the Ith element of the array associated with t
a-1-2 if the value associated with aisf(g(a,b,c),2) , the sub-term b
Here are the errors associated with global variable names and common to all predicates.
GVarName is a variable instantiation error
GVarName is neither a variable nor a callable term type error(callable, GVarName)
GVarName contains an invalid argument number
(orGVarName is an array)domain error(g argument selector,
GVarName)
GVarName contains an invalid index (or GVarName
is not an array)domain error(g array index, GVarName)
GVarName is used as an indirect index or
argument selector and is not an integertype error(integer, GVarName)
Arrays : the predicates gassign/2 ,gassignb/2 andglink/2 (section 8.21.2, page 143) can be used
to create an array. They recognize some terms as values. For instance, a compound term with principal
functor garray is used to dene an array of xed size. There are 3 forms for the term garray :
â€¢garray(Size) : if Size is an integer >0 then denes an array of Size elements which are all
initialized with the integer 0.
â€¢garray(Size, Initial) : as above but the elements are initialized with the term Initial instead
of 0. Initial can contain other array denitions allowing thus for multi-dimensional arrays.
â€¢garray(List) : as above if List is a list of length Size except that the elements of the array are
initialized according to the elements of List (which can contain other array denitions).
An array can be extended explicitly using a compound term with principal functor garray extend which
accept the same 3 forms detailed above. In that case, the existing elements of the array are not initialized.
Ifgarray extend is used with an object which is not an array it is similar to garray .
Finally, an array can be automatically expanded when needed. The programmer does not need to
explicitly control the expansion of an automatic array. An array is expanded as soon as an index is
outside the current size of this array. Such an array is dened using a compound term with principal
functor garray auto :
8.21 Global variables 143
â€¢garray auto(Size) : ifSize is an integer >0 then denes an automatic array whose initial size is
Size . All elements are initialized with the integer 0. Elements created during implicit expansions
will be initialized with 0.
â€¢garray auto(Size, Initial) : as above but the elements are initialized with the term Initial
instead of 0. Initial can contain other array denitions allowing thus for multi-dimensional arrays.
Elements created during implicit expansions will be initialized with Initial .
â€¢garray auto(List) : as above if List is a list of length Size except that the elements of the
array are initialized according to the elements of List (which can contain other array denitions).
Elements created during implicit expansions will be initialized with 0.
In any case, when an array is read, a term of the form garray([Elem0,..., ElemSize-1]) is returned.
Some examples using global variables are presented later (section 8.21.7, page 146).
8.21.2 gassign/2 ,gassignb/2 ,glink/2
Templates
gassign(+callable term, ?term)
gassignb(+callable term, ?term)
glink(+callable term, ?term)
Description
gassign(GVarName, Value) assigns a copy of the term Value toGVarName . This assignment is not
undone when backtracking occurs.
gassignb/2 is similar to gassign/2 but the assignment is undone at backtracking.
glink(GVarName, Value) makes a link between GVarName to the term Value . This allows the user to
give a name to any Prolog term (in particular non-ground terms). Such an assignment is always undone
when backtracking occurs (since the term may no longer exist). If Value is an atom or an integer,
glink/2 andgassignb/2 have the same behavior. Since glink/2 only handles links to existing terms
it does not require extra memory space and is not expensive in terms of execution time.
NB: argument selectors can only be used with g assign/2 (i.e. when using an argument selector inside an
assignment, this one must not be backtrackable).
Errors
See common errors detailed in the introduction (section 8.21.1, page 141)
GVarName contains an argument selector and the
assignment is backtrackabledomain error(g argument selector,
GVarName)
Portability
GNU Prolog predicates.
8.21.3 gread/2
Templates
144 8 PROLOG BUILT-IN PREDICATES
gread(+callable term, ?term)
Description
gread(GVarName, Value) unies Value with the term assigned to GVarName .
Errors
See common errors detailed in the introduction (section 8.21.1, page 141)
Portability
GNU Prolog predicate.
8.21.4 garray size/2
Templates
garray size(+callable term, ?integer)
Description
garray size(GVarName, Value) unies Size with the dimension (an integer >0) of the array assigned
toGVarName . Fails if GVarName is not an array.
Errors
See common errors detailed in the introduction (section 8.21.1, page 141)
Size is neither a variable nor an integer type error(integer, Size)
Portability
GNU Prolog predicate.
8.21.5 ginc/3 ,ginc/2 ,ginco/2 ,ginc/1 ,gdec/3 ,gdec/2 ,gdeco/2 ,gdec/1
Templates
ginc(+callable term, ?integer, ?integer)
ginc(+callable term, ?integer)
ginco(+callable term, ?integer)
ginc(+callable term)
gdec(+callable term, ?integer, ?integer)
gdec(+callable term, ?integer)
gdeco(+callable term, ?integer)
gdec(+callable term)
Description
ginc(GVarName, Old, New) unies Oldwith the integer assigned to GVarName , increments GVarName
and then unies Newwith the incremented value.
8.21 Global variables 145
ginc(GVarName, New) is equivalent to ginc(GVarName, , New) .
ginco(GVarName, Old) is equivalent to ginc(GVarName, Old, ).
ginc(GVarName) is equivalent to ginc(GVarName, ,).
Predicates gdecare similar but decrement the content of GVarName instead.
Errors
See common errors detailed in the introduction (section 8.21.1, page 141)
Oldis neither a variable nor an integer type error(integer, Old)
Newis neither a variable nor an integer type error(integer, New)
GVarName stores an array type error(integer, g array)
GVarName stores a term Twhich is not an integer type error(integer, T)
Portability
GNU Prolog predicates.
8.21.6 gsetbit/2 ,greset bit/2 ,gtest setbit/2 ,gtest reset bit/2
Templates
gsetbit(+callable term, +integer)
greset bit(+callable term, +integer)
gtest setbit(+callable term, +integer)
gtest reset bit(+callable term, +integer)
Description
gsetbit(GVarName, Bit) sets to 1 the bit number specied by Bitof the integer assigned to GVarName
to 1. Bit numbers range from 0 to the maximum number allowed for integers (this is architecture
dependent). If Bitis greater than this limit, the modulo with this limit is taken.
greset bit(GVarName, Bit) is similar to gsetbit/2 but sets the specied bit to 0.
gtest setbit/2 succeeds if the specied bit is set to 1.
gtest reset bit/2 succeeds if the specied bit is set to 0.
Errors
See common errors detailed in the introduction (section 8.21.1, page 141)
Bitis a variable instantiation error
Bitis neither a variable nor an integer type error(integer, Bit)
Bitis an integer <0 domain error(not less than zero, Bit)
GVarName stores an array type error(integer, g array)
GVarName stores a term Twhich is not an integer type error(integer, T)
Portability
146 8 PROLOG BUILT-IN PREDICATES
GNU Prolog predicates.
8.21.7 Examples
Simulating ginc/3 : this predicate behaves like: global variable:
my_g_inc(Var, Old, New) :-
g_read(Var, Old),
N is Value + 1,
g_assign(Var, X),
New = N.
The query: myginc(c, X, )will succeed unifying Xwith 0, another call to myginc(a, Y, )will
then unify Ywith 1, and so on.
Dierence between gassign/2 and gassignb/2 :gassign/2 does not undo its assignment when
backtracking occurs whereas gassignb/2 undoes it.
test(Old) :- testb(Old) :-
gassign(x,1), g assign(x,1),
( g read(x, Old), ( g read(x, Old),
gassign (x, 2) gassignb (x, 2)
; g read(x, Old), ; g read(x, Old),
gassign(x, 3) g assign(x, 3)
). ).
The query test(Old) will succeed unifying Oldwith 1and on backtracking with 2(i.e. the assignment
of the value 2has not been undone). The query testb(Old) will succeed unifying Oldwith 1and on
backtracking with 1(i.e. the assignment of the value 2has been undone).
Dierence between gassign/2 and glink/2 :gassign/2 (and gassignb/2 ) creates a copy of
the term whereas glink/2 does not. glink/2 can be used to avoid passing big data structures (e.g.
dictionaries,. . . ) as arguments to predicates.
test(B) :- test(B) :-
gassign (b, f(X)), glink (b, f(X)),
X = 12, X = 12,
gread(b, B). g read(b, B).
The query test(B) will succeed unifying Bwith f()(gassign/2 assigns a copy of the value). The
query test(B) will succeed unifying Bwith f(12) (glink/2 assigns a pointer to the term).
Simple array denition : here are some queries to show how arrays can be handled:
| ?- g_assign(w, g_array(3)), g_read(w, X).
X = g_array([0,0,0])
| ?- g_assign(w(0), 16), g_assign(w(1), 32), g_assign(w(2), 64), g_read(w, X).
X = g_array([16,32,64])
this is equivalent to:
| ?- g_assign(k, g_array([16,32,64])), g_read(k, X).
8.21 Global variables 147
X = g_array([16,32,64])
| ?- g_assign(k, g_array(3,null)), g_read(k, X), g_array_size(k, S).
S = 3
X = g_array([null,null,null])
2-D array denition :
| ?- g_assign(w, g_array(2, g_array(3))), g_read(w, X).
X = g_array([g_array([0,0,0]),g_array([0,0,0])])
| ?- ( for(I,0,1), for(J,0,2), K is I*3+J, g_assign(w(I,J), K),
fail
; g_read(w, X)
).
X = g_array([g_array([0,1,2]),g_array([3,4,5])])
| ?- g_read(w(1),X).
X = g_array([3,4,5])
Hybrid array :
| ?- g_assign(w,g_array([1,2,g_array([a,b,c]), g_array(2,z),5])), g_read(w, X).
X = g_array([1,2,g_array([a,b,c]), g_array([z,z]),5])
| ?- g_read(w(1), X), g_read(w(2,1), Y), g_read(w(3,1), Z).
X = 2
Y = b
Z = z
| ?- g_read(w(1,2),X).
uncaught exception: error(domain_error(g_array_index,w(1,2)),g_read/2)
Array extension :
| ?- g_assign(a, g_array([10,20,30])), g_read(a, X).
X = g_array([10,20,30])
| ?- g_assign(a, g_array_extend(5,null)), g_read(a, X).
X = g_array([10,20,30,null,null])
| ?- g_assign(a, g_array([10,20,30])), g_read(a, X).
X = g_array([10,20,30])
| ?- g_assign(a, g_array_extend([1,2,3,4,5,6])), g_read(a, X).
X = g_array([10,20,30,4,5,6])
Automatic array :
148 8 PROLOG BUILT-IN PREDICATES
| ?- g_assign(t, g_array_auto(3)), g_assign(t(1), foo), g_read(t,X).
X = g_array([0,foo,0])
| ?- g_assign(t(5), bar), g_read(t,X).
X = g_array([0,foo,0,0,0,bar,0,0])
| ?- g_assign(t, g_array_auto(2, g_array(2))), g_assign(t(1,1), foo),
g_read(t,X).
X = g_array([g_array([0,0]),g_array([0,foo])])
| ?- g_assign(t(3,0), bar), g_read(t,X).
X = g_array([g_array([0,0]),g_array([0,foo]),g_array([0,0]),g_array([bar,0])])
| ?- g_assign(t(3,4), bar), g_read(t,X).
uncaught exception: error(domain_error(g_array_index,t(3,4)),g_assign/2)
| ?- g_assign(t, g_array_auto(2, g_array_auto(2))), g_assign(t(1,1), foo),
g_read(t,X).
X = g_array([g_array([0,0]),g_array([0,foo])])
| ?- g_assign(t(3,3), bar), g_read(t,X).
X = g_array([g_array([0,0]),g_array([0,foo]),g_array([0,0]),
g_array([0,0,0,bar])])
| ?- g_assign(t, g_array_auto(2, g_array_auto(2, null))), g_read(t(2,3), U),
g_read(t, X).
U = null
X = g_array([g_array([null,null]),g_array([null,null]),
g_array([null,null,null,null]),g_array([null,null])])
8.22 Prolog state
8.22.1 setprolog flag/2
Templates
setprolog flag(+flag, +term)
Description
setprolog flag(Flag, Value) sets the value of the Prolog ag Flag toValue .
Prolog ags : a Prolog ag is an atom which is associated with a value that is either implementation de-
ned or dened by the user. Each ag has a permitted range of values; any other value is a domain error .
The following two tables present available ags, the possible values, a description and if they are ISO or
an extension. The rst table presents unchangeable ags while the second one the changeable ags. For
8.22 Prolog state 149
ags whose default values is machine independent, this value is underlined .
Unchangeable ags :
Flag Values Description ISO
prolog name an atom name of the Prolog system N
prolog version an atom version number of the Prolog system N
prolog date an atom date of the Prolog system N
prolog copyright an atom copyright message of the Prolog system N
dialect an atom xed to gprolog N
version an integer Major10000 +Minor100 +Patch N
version data a structure gprolog(Major,Minor,Patch,Extra) N
bounded true /false are integers bounded ? Y
maxinteger an integer greatest integer Y
mininteger an integer smallest integer Y
integer rounding functiontoward zero
downrnd(X)= integer part of X
rnd(X)=bXc(section 8.6.1, page 66)Y
maxarity an integer maximum arity for compound terms (255) Y
maxatom an integer maximum number of atoms N
maxunget an integer maximum number of successive ungets N
home an atom GNU Prolog home directory N
host os an atom Operating System identier N
host vendor an atom Operating System vendor N
host cpu an atom processor identier N
host an atom a combination of the OS-vendor-cpu N
arch an atom a combination of the OS-cpu N
address bits an integer address size of the machine (32 or 64) N
unix on/off is the architecture an Unix-like OS ? N
compiled at an atomcompilation date using DATE and
TIME C compiler macrosN
ccc an atomC compiler used to compile GNU Prolog
(gcc,cc,clang ,cl,...)N
cccversion data a structure ccc(Major,Minor,Patch,Extra) N
ccflags an atom CFLAGS used to compile GNU Prolog N
cldflags an atom LDFLAGS used to compile GNU Prolog N
argv a list of atoms list of command-line arguments N
Changeable ags :
150 8 PROLOG BUILT-IN PREDICATES
Flag Values Description ISO
char conversion on/off is character conversion activated ? Y
singleton warning on/off warn about named singleton variables ? N
suspicious warning on/off warn about suspicious predicate ? N
multifile warning on/offwarn about unsupported multile
directive ?N
strict iso on/off strict ISO behavior ? N
debug on/off is the debugger activated ? Y
double quotesatom
chars
codes
atom noescape
chars noescape
codes noescapea double quoted constant is returned as:
an atom
a list of characters
a list of character codes
asatom but ignore escape sequences
aschars but ignore escape sequences
ascode but ignore escape sequencesY
N
back quotesatom
chars
codes
atom noescape
chars noescape
codes noescapea back quoted constant is returned as:
an atom
a list of characters
a list of character codes
asatom but ignore escape sequences
aschars but ignore escape sequences
ascode but ignore escape sequencesN
unknownerror
warning
faila predicate calls an unknown procedure:
anexistence error is raised
a message is displayed then fails
quietly failsY
syntax errorerror
warning
faila predicate causes a syntax error:
asyntax error is raised
a message is displayed then fails
quietly failsN
oserrorerror
warning
faila predicate causes an O.S. error:
asystem error is raised
a message is displayed then fails
quietly failsN
The strict isoag is introduced to allow a compatibility with other Prolog systems. When turned o
the following relaxations apply:
â€¢built-in predicates are found by current predicate/1 (section 8.8.1, page 74).
â€¢the term parser ( read/1 and friends) is more indulgent, e.g. 0''is accepted and returns 39, the
escape sequence \s(space) and \e(escape) are accepted.
â€¢the following arithmetic rounding functions: ceiling ,floor ,round ,truncate also accept integers
(section 8.6.1, page 66).
Errors
Flag is a variable instantiation error
Value is a variable instantiation error
Flag is neither a variable nor an atom type error(atom, Flag)
Flag is an atom but not a valid ag domain error(prolog flag, Flag)
Value is inappropriate for Flag domain error(flag value, Flag+Value)
Value is appropriate for Flag but ag Flag is
not modiablepermission error(modify, flag, Flag)
8.22 Prolog state 151
Portability
ISO predicate. All ISO ags are implemented.
8.22.2 current prolog flag/2
Templates
current prolog flag(?flag, ?term)
Description
current prolog flag(Flag, Value) succeeds if there exists a Prolog ag that unies with Flag and
whose value unies with Value . This predicate is re-executable on backtracking.
Errors
Flag is neither a variable nor an atom type error(atom, Flag)
Flag is an atom but not a valid ag domain error(prolog flag, Flag)
Portability
ISO predicate.
8.22.3 setbipname/2
Templates
setbipname(+atom, +arity)
Description
setbipname(Functor, Arity) initializes the context of the error (section 6.3.1, page 39) with Functor
andArity (ifArity<0 only Functor is signicant).
Errors
Functor is a variable instantiation error
Arity is a variable instantiation error
Functor is neither a variable nor an atom type error(atom, Functor)
Arity is neither a variable nor an integer type error(integer, Arity)
Portability
GNU Prolog predicate.
8.22.4 current bipname/2
Templates
current bipname(?atom, ?arity)
152 8 PROLOG BUILT-IN PREDICATES
Description
current bipname(Functor, Arity) succeeds if Functor and Arity correspond to the context of the
error (section 6.3.1, page 39) (if Arity<0 only Functor is signicant).
Errors
Functor is neither a variable nor an atom type error(atom, Functor)
Arity is neither a variable nor an integer type error(integer, Arity)
Portability
GNU Prolog predicate.
8.22.5 write plstate file/1 ,read plstate file/1
Templates
write plstate file(+source sink)
read plstate file(+source sink)
Description
write plstate file(FileName) writes onto FileName all information that inuences the parsing of a
term (section 8.14, page 104). This allows a sub-process written in Prolog to read this le and then
process any Prolog term as done by the parent process. This le can also be passed as argument of the
--pl-state option when invoking gplc (section 4.4.3, page 23). More precisely the following elements
are saved:
â€¢all operator denitions (section 8.14.10, page 113).
â€¢the character conversion table (section 8.14.12, page 116).
â€¢the value of char conversion ,double quotes ,back quotes ,singleton warning ,suspicious warning
andmultifile warning Prolog ags (section 8.22.1, page 148).
read plstate file(FileName) reads (restores) from FileName all information previously saved by
write plstate file/1.
Errors
FileName is a variable instantiation error
FileName is neither a variable nor an atom type error(atom, FileName)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.23 Program state 153
8.23 Program state
8.23.1 consult/1 ,'.'/2 - program consult
Templates
consult(+atom oratom list)
'.'(+atom, +atom list)
Description
consult(Files) compiles and loads into memory each le of the list Files . Each le is compiled for
byte-code using the GNU Prolog compiler (section 4.4, page 21) then loaded using load/1 (section 8.23.2,
page 153). It is possible to specify user as a le name to directly enter the program from the terminal.
Files can be also a single le name (i.e. an atom). Refer to the section concerning the consult of a
Prolog program for more information (section 4.2.3, page 17).
The nal le name of a le is computed using the predicates prolog file name/2 (section 8.26.4,
page 159) and absolute file name/2 (section 8.26.1, page 158).
[ File | Files ] , i.e. '.'(File, Files) is equivalent to consult([ File | Files ]) .
Since version 1.4.0, with the introduction of shebang support, consult/1 ignores the rst line of a Prolog
source le which directly begins with #. See (section 4.2.4, page 18) for more information about shebang
support and PrologScript.
Errors
Files is a partial list or a list with an element E
which is a variableinstantiation error
Files is neither a partial list nor a list nor an
atomtype error(list, Files)
an element Eof the Files list is neither a
variable nor an atomtype error(atom, E)
an element Eof the Files list is an atom but not
a valid pathnamedomain error(os path, E)
an element Eof the Files list is a valid
pathname but does not correspond to an existing
sourceexistence error(source sink, E)
an error occurs executing a directive seecall/1 errors (section 7.2.3, page 52)
Portability
GNU Prolog predicates.
8.23.2 load/1
Templates
load(+atom oratom list)
Description
154 8 PROLOG BUILT-IN PREDICATES
load(Files) loads into memory each le of the list Files . Each le must have been previously compiled
for byte-code using the GNU Prolog compiler (section 4.4, page 21). Files can be also a single le name
(i.e. an atom).
The nal le name of a le is computed using the predicates absolute file name/2 (section 8.26.1,
page 158). If no sux is given '.wbc' is appended to the le name.
Errors
Files is a partial list or a list with an element E
which is a variableinstantiation error
Files is neither a partial list nor a list nor an
atomtype error(list, Files)
an element Eof the Files list is neither a
variable nor an atomtype error(atom, E)
an element Eof the Files list is an atom but not
a valid pathnamedomain error(os path, E)
an element Eof the Files list is a valid
pathname but does not correspond to an existing
sourceexistence error(source sink, E)
an error occurs executing a directive seecall/1 errors (section 7.2.3, page 52)
Portability
GNU Prolog predicate.
8.23.3 listing/1 ,listing/0
Templates
listing(+predicate indicator)
listing(+atom)
listing
Description
listing(Pred) lists the clauses of the consulted predicate whose predicate indicator is Pred .Pred can
also be a single atom in which case all predicates whose name is Pred are listed (of any arity). This
predicate uses portray clause/2 (section 8.14.8, page 112) to output the clauses.
listing lists all clauses of all consulted predicates.
Errors
Pred is a variable instantiation error
Pred is neither a variable nor predicate indicator
or an atomtype error(predicate indicator, Pred)
Portability
GNU Prolog predicate.
8.24 System statistics 155
8.24 System statistics
8.24.1 statistics/0 ,statistics/2
Templates
statistics
statistics(?atom, ?list)
Description
statistics displays statistics about memory usage and run times.
statistics(Key, Value) unies Value with the current value of the statistics key Key.Value a list of
two elements. Times are in milliseconds, sizes of areas in bytes.
Key Description Value
user time user CPU time [SinceStart, SinceLast]
system time system CPU time [SinceStart, SinceLast]
cputime total CPU time (user + system) [SinceStart, SinceLast]
real time absolute time [SinceStart, SinceLast]
local stack local stack sizes (control, environments, choices) [UsedSize, FreeSize]
global stack global stack sizes (compound terms) [UsedSize, FreeSize]
trail stack trail stack sizes (variable bindings to undo) [UsedSize, FreeSize]
cstr stack constraint trail sizes (nite domain constraints) [UsedSize, FreeSize]
atoms atom table [NumberOfAtoms, FreeNumberOfAtoms]
Note that the key runtime is recognized as user time for compatibility purpose.
Errors
Keyis neither a variable nor a valid key domain error(statistics key, Key)
Value is neither a variable nor a list of two
elementsdomain error(statistics value, Value)
Value is a list of two elements and an element E
is neither a variable nor an integertype error(integer, E)
Portability
GNU Prolog predicates.
8.24.2 user time/1 ,system time/1 ,cputime/1 ,real time/1
Templates
user time(?integer)
system time(?integer)
cputime(?integer)
real time(?integer)
Description
user time(Time) unies Time with the user CPU time elapsed since the start of Prolog.
156 8 PROLOG BUILT-IN PREDICATES
system time(Time) unies Time with the system CPU time elapsed since the start of Prolog.
cputime(Time) unies Time with the CPU time (user + system) elapsed since the start of Prolog.
real time(Time) unies Time with the absolute time elapsed since the start of Prolog.
Errors
Time is neither a variable nor an integer type error(integer, Time)
Portability
GNU Prolog predicates.
8.25 Random number generator
8.25.1 setseed/1 ,randomize/0
Templates
setseed(+integer)
randomize
Description
setseed(Seed) reinitializes the random number generator seed with Seed .
randomize reinitializes the random number generator. This predicates calls setseed/1 with a random
value depending on the absolute time.
Errors
Seed is a variable instantiation error
Seed is neither a variable nor an integer type error(integer, Seed)
Seed is an integer <0 domain error(not less than zero, Seed)
Portability
GNU Prolog predicates.
8.25.2 getseed/1
Templates
getseed(?integer)
Description
getseed(Seed) unies Seed with the current random number generator seed.
Errors
8.25 Random number generator 157
Seed is neither a variable nor an integer type error(integer, Seed)
Seed is an integer <0 domain error(not less than zero, Seed)
Portability
GNU Prolog predicate.
8.25.3 random/1
Templates
random(-float)
Description
random(Number) unies Number with a random oating point number such that 0.0 Number<1.0.
Errors
Number is not a variable uninstantiation error(Number)
Portability
GNU Prolog predicate.
8.25.4 random/3
Templates
random(+number, +number, -number)
Description
random(Base, Max, Number) unies Number with a random number such that BaseNumber<Max.
If both Base and Maxare integers Number will be an integer, otherwise Number will be a oating point
number.
Errors
Base is a variable instantiation error
Base is neither a variable nor a number type error(number, Base)
Maxis a variable instantiation error
Maxis neither a variable nor a number type error(number, Max)
Number is not a variable uninstantiation error(Number)
Portability
GNU Prolog predicate.
158 8 PROLOG BUILT-IN PREDICATES
8.26 File name processing
8.26.1 absolute file name/2
Templates
absolute file name(+atom, atom)
Description
absolute file name(File1, File2) succeeds if File2 is the absolute pathname associated with the rel-
ative le name File1 .File1 can contain $VARNAME sub-strings. When such a sub-string is encountered,
it is expanded with the value of the environment variable whose name is VARNAME if exists (otherwise
no expansion is done). File1 can also begin with a sub-string ~USER NAME /, this is expanded as the
home directory of the user USER NAME . IfUSER NAME does not exist File1 is an invalid pathname. If no
USER NAME is given (i.e. File1 begins with ~/) the ~character is expanded as the value of the environ-
ment variable HOME . If the HOME variable is not dened File1 is an invalid pathname. Relative references
to the current directory ( /./sub-string) and to the parent directory ( /../ sub-strings) are removed and
no longer appear in File2 .File1 is also invalid if it contains too many /../ consecutive sub-strings
(i.e. parent directory relative references). Finally if File1 isuser then File2 is also unied with user
to allow this predicate to be called on Prolog le names (since user in DEC-10 input/output predicates
denotes the current input/output stream).
Under Windows the following applies:
â€¢an alternate recognized form for $VARNAME is%VARNAME %.
â€¢when ~is expanded, if the HOME variable is not dened, ~is expanded using HOMEDIR andHOMEPATH
(ifHOMEPATH is not dened then File1 is an invalid pathname).
Most predicates using a le name implicitly call this predicate to obtain the desired le, e.g. open/4 .
Errors
File1 is a variable instantiation error
File1 is neither a variable nor an atom type error(atom, File1)
File2 is neither a variable nor an atom type error(atom, File2)
File1 is an atom but not a valid pathname domain error(os path, File1)
Portability
GNU Prolog predicate.
8.26.2 isabsolute file name/1 ,isrelative file name/1
Templates
isabsolute file name(+atom)
isrelative file name(+atom)
Description
isabsolute file name(PathName) succeeds if PathName is an absolute le name.
8.26 File name processing 159
Conversely, isrelative file name(PathName) succeeds if PathName is not an absolute le name.
Seeabsolute file name/2 for information about the syntax of PathName (section 8.26.1, page 158).
The current implementation does not check the validity of PathName . IfPathName starts with a /(slash)
it is considered as absolute. Under Windows, PathName can also start with a \(backslash) or a drive
specication.
Errors
PathName is a variable instantiation error
PathName is neither a variable nor an atom type error(atom, PathName)
Portability
GNU Prolog predicates.
8.26.3 decompose file name/4
Templates
decompose file name(+atom, ?atom, ?atom, ?atom)
Description
decompose file name(File, Directory, Prefix, Suffix) decomposes the pathname File and ex-
tracts the Directory part (characters before the last /), the Prefix part (characters after the last /and
before the last .or until the end if there is no sux) and the Suffix part (characters from the last .to
the end of the string).
Errors
File is a variable instantiation error
File is neither a variable nor an atom type error(atom, File)
Directory is neither a variable nor an atom type error(atom, Directory)
Prefix is neither a variable nor an atom type error(atom, Prefix)
Suffix is neither a variable nor an atom type error(atom, Suffix)
Portability
GNU Prolog predicate.
8.26.4 prolog file name/2
Templates
prolog file name(+atom, ?atom)
Description
prolog file name(File1, File2) unies File2 with the Prolog le name associated with File1 . More
precisely File2 is computed as follows:
â€¢ifFile1 has a sux or if it is user then File2 is unied with File1 .
160 8 PROLOG BUILT-IN PREDICATES
â€¢else if the le whose name is File1 +'.pl' exists then File2 is unied with this name.
â€¢else if the le whose name is File1 +'.pro' exists then File2 is unied with this name.
â€¢else if the le whose name is File1 +'.prolog' exists then File2 is unied with this name.
â€¢elseFile2 is unied with the name File1 +'.pl' .
This predicate uses absolute file name/2 to check the existence of a le (section 8.26.1, page 158).
Errors
File1 is a variable instantiation error
File1 is neither a variable nor an atom type error(atom, File1)
File2 is neither a variable nor an atom type error(atom, File2)
File1 is an atom but not a valid pathname domain error(os path, File1)
Portability
GNU Prolog predicate.
8.27 Operating system interface
8.27.1 argument counter/1
Templates
argument counter(?integer)
Description
argument counter(Counter) succeeds if Counter is the number of arguments of the command-line. Since
the rst argument is always the name of the running program, Counter is always1. See (section 4.2,
page 13) for more information about command-line arguments retrieved under the top level.
Errors
Counter is neither a variable nor an integer type error(integer, Counter)
Portability
GNU Prolog predicate.
8.27.2 argument value/2
Templates
argument value(+integer, ?atom)
Description
argument value(N, Arg) succeeds if the Nthargument on the command-line unies with Arg. The rst
argument is always the name of the running program and its number is 0. The number of arguments on
the command-line can be obtained using argument counter/1 (section 8.27.1, page 160).
8.27 Operating system interface 161
Errors
Nis a variable instantiation error
Nis neither a variable nor an integer type error(integer, N)
Nis an integer <0 domain error(not less than zero, N)
Argis neither a variable nor an atom type error(atom, Arg)
Portability
GNU Prolog predicate.
8.27.3 argument list/1
Templates
argument list(?list)
Description
argument list(Args) succeeds if Args unies with the list of atoms associated with each argument on
the command-line other than the rst argument (the name of the running program).
Errors
Args is neither a partial list nor a list type error(list, Args)
Portability
GNU Prolog predicate.
8.27.4 environ/2
Templates
environ(?atom, ?atom)
Description
environ(Name, Value) succeeds if Name is the name of an environment variable whose value is Value .
This predicate is re-executable on backtracking.
Errors
Name is neither a variable nor an atom type error(atom, Name)
Value is neither a variable nor an atom type error(atom, Value)
Portability
GNU Prolog predicate.
162 8 PROLOG BUILT-IN PREDICATES
8.27.5 make directory/1 ,delete directory/1 ,change directory/1
Templates
make directory(+atom)
delete directory(+atom)
change directory(+atom)
Description
make directory(PathName) creates the directory whose pathname is PathName .
delete directory(PathName) removes the directory whose pathname is PathName .
change directory(PathName) sets the current directory to the directory whose pathname is PathName .
Seeabsolute file name/2 for information about the syntax of PathName (section 8.26.1, page 158).
Errors
PathName is a variable instantiation error
PathName is neither a variable nor an atom type error(atom, PathName)
PathName is an atom but not a valid pathname domain error(os path, PathName)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicates.
8.27.6 working directory/1
Templates
working directory(?atom)
Description
working directory(PathName) succeeds if PathName is the pathname of the current directory.
Errors
PathName is neither a variable nor an atom type error(atom, PathName)
Portability
GNU Prolog predicate.
8.27.7 directory files/2
Templates
8.27 Operating system interface 163
directory files(+atom, ?list)
Description
directory files(PathName, Files) succeeds if Files is the list of all entries (les, sub-directories,. . . )
in the directory whose pathname is PathName . See absolute file name/2 for information about the
syntax of PathName (section 8.26.1, page 158).
Errors
PathName is a variable instantiation error
PathName is neither a variable nor an atom type error(atom, PathName)
PathName is an atom but not a valid pathname domain error(os path, PathName)
Files is neither a partial list nor a list type error(list, Files)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.8 rename file/2
Templates
rename file(+atom, +atom)
Description
rename file(PathName1, PathName2) renames the le or directory whose pathname is PathName1 to
PathName2 . See absolute file name/2 for information about the syntax of PathName1 andPathName2
(section 8.26.1, page 158).
Errors
PathName1 is a variable instantiation error
PathName1 is neither a variable nor an atom type error(atom, PathName1)
PathName1 is an atom but not a valid pathname domain error(os path, PathName1)
PathName2 is a variable instantiation error
PathName2 is neither a variable nor an atom type error(atom, PathName2)
PathName2 is an atom but not a valid pathname domain error(os path, PathName2)
an operating system error occurs and value of
theoserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.9 delete file/1 ,unlink/1
Templates
164 8 PROLOG BUILT-IN PREDICATES
delete file(PathName)
unlink(PathName)
Description
delete file(PathName) removes the existing le whose pathname is PathName .
unlink/1 is similar to delete file/1 except that it never causes a system error (e.g. if PathName does
not refer to an existing le).
Seeabsolute file name/2 for information about the syntax of PathName (section 8.26.1, page 158).
Errors
PathName is a variable instantiation error
PathName is neither a variable nor an atom type error(atom, PathName)
PathName is an atom but not a valid pathname domain error(os path, PathName)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicates.
8.27.10 file permission/2 ,file exists/1
Templates
file permission(+atom, +atom)
file permission(+atom, +atom list)
file exists(+atom)
Description
file permission(PathName, Permission) succeeds if PathName is the pathname of an existing le (or
directory) whose permissions include Permission .
File permissions :Permission can be a single permission or a list of permissions. A permission is an
atom among:
â€¢read : the le or directory can be read.
â€¢write : the le or directory can be written.
â€¢execute : the le can be executed.
â€¢search : the directory can be searched.
IfPathName does not exists or if its permissions do not include Permission this predicate fails.
file exists(PathName) is equivalent to file permission(PathName, []) , i.e. it succeeds if PathName
is the pathname of an existing le (or directory).
Seeabsolute file name/2 for information about the syntax of PathName (section 8.26.1, page 158).
8.27 Operating system interface 165
Errors
PathName is a variable instantiation error
PathName is neither a variable nor an atom type error(atom, PathName)
PathName is an atom but not a valid pathname domain error(os path, PathName)
Permission is a partial list or a list with an
element which is a variableinstantiation error
Permission is neither an atom nor partial list or
a listtype error(list, Permission)
an element Eof the Permission list is neither a
variable nor an atomtype error(atom, E)
an element Eof the Permission is an atom but
not a valid permissiondomain error(os file permission,
Permission)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicates.
8.27.11 file property/2
Templates
file property(+atom, ?os file property)
Description
file property(PathName, Property) succeeds if PathName is the pathname of an existing le (or di-
rectory) and if Property unies with one of the properties of the le. This predicate is re-executable on
backtracking.
File properties :
â€¢absolute file name(File) :File is the absolute le name of PathName (section 8.26.1, page 158).
â€¢real file name(File) :File is the real le name of PathName (follows symbolic links).
â€¢type(Type) :Type is the type of PathName . Possible values are: regular ,directory ,fifo ,socket ,
character device ,block device orunknown .
â€¢size(Size) :Size is the size (in bytes) of PathName .
â€¢permission(Permission) :Permission is a permission of PathName (section 8.27.10, page 164).
â€¢last modification(DT) :DTis the last modication date and time (section 8.27.14, page 167).
Seeabsolute file name/2 for information about the syntax of PathName (section 8.26.1, page 158).
Errors
166 8 PROLOG BUILT-IN PREDICATES
PathName is a variable instantiation error
PathName is neither a variable nor an atom type error(atom, PathName)
PathName is an atom but not a valid pathname domain error(os path, PathName)
Property is neither a variable nor a le property
termdomain error(os file property, Property)
Property =absolute file name(E) ,
real file name(E) ,type(E) orpermission(E)
andEis neither a variable nor an atomtype error(atom, E)
Property =last modification(DateTime)
andDateTime is neither a variable nor a
compound termtype error(compound, DateTime)
Property =last modification(DateTime)
andDateTime is a compound term but not a
structure dt/6domain error(date time, DateTime)
Property =size(E) or
last modification(DateTime) andDateTime is
a structure dt/6 but an element Eis neither a
variable nor an integertype error(integer, E)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.12 temporary name/2
Templates
temporary name(+atom, ?atom)
Description
temporary name(Template, PathName) creates a unique le name PathName whose pathname begins by
Template .Template should contain a pathname with six trailing Xs.PathName isTemplate with the six
Xsreplaced with a letter and the process identier. This predicate is an interface to the C Unix function
mktemp(3) .
Seeabsolute file name/2 for information about the syntax of Template (section 8.26.1, page 158).
Errors
Template is a variable instantiation error
Template is neither a variable nor an atom type error(atom, Template)
Template is an atom but not a valid pathname domain error(os path, Template)
PathName is neither a variable nor an atom type error(atom, PathName)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27 Operating system interface 167
8.27.13 temporary file/3
Templates
temporary file(+atom, +atom, ?atom)
Description
temporary file(Directory, Prefix, PathName) creates a unique le name PathName whose pathname
begins by Directory/Prefix . IfDirectory is the empty atom ''a standard temporary directory will
be used (e.g. /tmp ).Prefix can be the empty atom ''. This predicate is an interface to the C Unix
function tempnam(3) .
Seeabsolute file name/2 for information about the syntax of Directory (section 8.26.1, page 158).
Errors
Directory is a variable instantiation error
Directory is neither a variable nor an atom type error(atom, Directory)
Directory is an atom but not a valid pathname domain error(os path, Directory)
Prefix is a variable instantiation error
Prefix is neither a variable nor an atom type error(atom, Prefix)
PathName is neither a variable nor an atom type error(atom, PathName)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.14 date time/1
Templates
date time(?compound)
Description
date time(DateTime) unies DateTime with a compound term containing the current date and time.
DateTime is a structure dt(Year, Month, Day, Hour, Minute, Second) . Each sub-argument of the
term dt/6 is an integer.
Errors
DateTime is neither a variable nor a compound
termtype error(compound, DateTime)
DateTime is a compound term but not a
structure dt/6domain error(date time, DateTime)
DateTime is a structure dt/6 and an element Eis
neither a variable nor an integertype error(integer, E)
Portability
GNU Prolog predicate.
168 8 PROLOG BUILT-IN PREDICATES
8.27.15 host name/1
Templates
host name(?atom)
Description
host name(HostName) unies HostName with the name of the host machine executing the current GNU
Prolog process. If the sockets are available (section 8.28.1, page 176), the name returned will be fully
qualied. In that case, host name/1 will also succeed if HostName is instantiated to the unqualied name
(or an alias) of the machine.
Errors
HostName is neither a variable nor an atom type error(atom, HostName)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.16 osversion/1
Templates
osversion(?atom)
Description
osversion(OSVersion) unies OSVersion with the operating system version of the machine executing
the current GNU Prolog process.
Errors
OSVersion is neither a variable nor an atom type error(atom, OSVersion)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.17 architecture/1
Templates
architecture(?atom)
Description
8.27 Operating system interface 169
architecture(Architecture) unies Architecture with the name of the machine executing the current
GNU Prolog process.
Errors
Architecture is neither a variable nor an atom type error(atom, Architecture)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.18 shell/2 ,shell/1 ,shell/0
Templates
shell(+atom, ?integer)
shell(+atom)
shell
Description
shell(Command, Status) invokes a new shell (named by the SHELL environment variable) passing
Command for execution and unies Status with the result of the execution. If Command is the empty
atom ''a new interactive shell is executed. The control is returned to Prolog upon termination of the
called process.
shell(Command) is equivalent to shell(Command, 0) .
shell is equivalent to shell('', 0) .
Errors
Command is a variable instantiation error
Command is neither a variable nor an atom type error(atom, Command)
Status is neither a variable nor an integer type error(integer, Status)
Portability
GNU Prolog predicates.
8.27.19 system/2 ,system/1
Templates
system(+atom, ?integer)
system(+atom)
Description
system(Command, Status) invokes a new default shell passing Command for execution and unies Status
170 8 PROLOG BUILT-IN PREDICATES
with the result of the execution. The control is returned to Prolog upon termination of the shell process.
This predicate is an interface to the C Unix function system(3) .
system(Command) is equivalent to system(Command, 0) .
Errors
Command is a variable instantiation error
Command is neither a variable nor an atom type error(atom, Command)
Status is neither a variable nor an integer type error(integer, Status)
Portability
GNU Prolog predicates.
8.27.20 spawn/3 ,spawn/2
Templates
spawn(+atom, +atom list, ?integer)
spawn(+atom, +atom list)
Description
spawn(Command, Arguments, Status) executes Command passing as arguments of the command-line each
element of the list Arguments and unies Status with the result of the execution. The control is returned
to Prolog upon termination of the command.
spawn(Command, Arguments) is equivalent to spawn(Command, Arguments, 0) .
Errors
Command is a variable instantiation error
Command is neither a variable nor an atom type error(atom, Command)
Arguments is a partial list or a list with an
element which is a variableinstantiation error
Arguments is neither a partial list nor a list type error(list, Arguments)
an element Eof the Arguments list is neither a
variable nor an atomtype error(atom, E)
Status is neither a variable nor an integer type error(integer, Status)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicates.
8.27.21 popen/3
Templates
popen(+atom, +io mode, -stream)
8.27 Operating system interface 171
Description
popen(Command, Mode, Stream) invokes a new default shell (by creating a pipe) passing Command for
execution and associates a stream either to the standard input or the standard output of the created
process. if Mode isread (resp. write ) an input (resp. output) stream is created and Stream is unied
with the stream-term associated. Writing to the stream writes to the standard input of the command
while reading from the stream reads the command's standard output. The stream must be closed using
close/2 (section 8.10.7, page 82). This predicate is an interface to the C Unix function popen(3) .
Errors
Command is a variable instantiation error
Command is neither a variable nor an atom type error(atom, Command)
Mode is a variable instantiation error
Mode is neither a variable nor an atom type error(atom, Mode)
Mode is an atom but neither read norwrite . domain error(io mode, Mode)
Stream is not a variable uninstantiation error(Stream)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.22 exec/5 ,exec/4
Templates
exec(+atom, -stream, -stream, -stream, -integer)
exec(+atom, -stream, -stream, -stream)
Description
exec(Command, StreamIn, StreamOut, StreamErr, Pid) invokes a new default shell passing Command
for execution and associates streams to standard streams of the created process. StreamIn is unied
with the stream-term associated with the standard input stream of Command (it is an output stream).
StreamOut is unied with the stream-term associated with the standard output stream of Command (it
is an input stream). StreamErr is unied with the stream-term associated with the standard error
stream of Command (it is an input stream). Pidis unied with the process identier of the new process.
This information is only useful if it is necessary to obtain the status of the execution using wait/2
(section 8.27.25, page 173). Until a call to wait/2 is done the process remains in the system processes
table (as a zombie process if terminated). For this reason, if the status is not needed it is preferable to
useexec/4 .
exec/4 is similar to exec/5 but the process is removed from system processes as soon as it is terminated.
Errors
172 8 PROLOG BUILT-IN PREDICATES
Command is a variable instantiation error
Command is neither a variable nor an atom type error(atom, Command)
StreamIn is not a variable uninstantiation error(StreamIn)
StreamOut is not a variable uninstantiation error(StreamOut)
StreamErr is not a variable uninstantiation error(StreamErr)
Pidis not a variable uninstantiation error(Pid)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicates.
8.27.23 fork prolog/1
Templates
fork prolog(-integer)
Description
fork prolog(Pid) creates a child process that diers from the parent process only in its PID. In the
parent process Pidis unied with the PID of the child while in the child process Pidis unied with
0. In the parent process, the status of the child process can be obtained using wait/2 (section 8.27.25,
page 173). Until a call to wait/2 is done the child process remains in the system processes table (as a
zombie process if terminated). This predicate is an interface to the C Unix function fork(2) .
Errors
Pidis not a variable uninstantiation error(Pid)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.24 create pipe/2
Templates
create pipe(-stream, -stream)
Description
create pipe(StreamIn, StreamOut) creates a pair of streams pointing to a pipe inode. StreamIn is
unied with the stream-term associated with the input side of the pipe and StreamOut is unied with the
stream-term associated with output side. This predicate is an interface to the C Unix function pipe(2) .
Errors
8.27 Operating system interface 173
StreamIn is not a variable uninstantiation error(StreamIn)
StreamOut is not a variable uninstantiation error(StreamOut)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.25 wait/2
Templates
wait(+integer, ?integer)
Description
wait(Pid, Status) waits for the child process whose identier is Pidto terminate. Status is then
unied with the exit status. This predicate is an interface to the C Unix function waitpid(2) .
Errors
Pidis a variable instantiation error
Pidis neither a variable nor an integer type error(integer, Pid)
Status is neither a variable nor an integer type error(integer, Status)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.26 prolog pid/1
Templates
prolog pid(?integer)
Description
prolog pid(Pid) unies Pidwith the process identier of the current GNU Prolog process.
Errors
Pidis neither a variable nor an integer type error(integer, Pid)
Portability
GNU Prolog predicate.
174 8 PROLOG BUILT-IN PREDICATES
8.27.27 send signal/2
Templates
send signal(+integer, +integer)
send signal(+integer, +atom)
Description
send signal(Pid, Signal) sends Signal to the process whose identier is Pid. Signal can be specied
directly as an integer or symbolically as an atom. Allowed atoms depend on the machine (e.g. 'SIGINT' ,
'SIGQUIT' ,'SIGKILL' ,'SIGUSR1' ,'SIGUSR2' ,'SIGALRM' ,. . . ). This predicate is an interface to the C
Unix function kill(2) .
Errors
Pidis a variable instantiation error
Pidis neither a variable nor an integer type error(integer, Pid)
Signal is a variable instantiation error
Signal is neither a variable nor an integer or an
atomtype error(integer, Signal)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.27.28 sleep/1
Templates
sleep(+number)
Description
sleep(Seconds) puts the GNU Prolog process to sleep for Second s seconds. Seconds can be an integer
or a oating point number (in which case it can be <1). This predicate is an interface to the C Unix
function usleep(3) .
Errors
Seconds is a variable instantiation error
Seconds is neither a variable nor a number type error(number, Seconds)
Seconds is a number <0 domain error(not less than zero, Seconds)
Portability
GNU Prolog predicate.
8.27 Operating system interface 175
8.27.29 select/5
Templates
select(+list, ?list, +list, ?list, +number)
Description
select(Reads, ReadyReads, Writes, ReadyWrites, TimeOut) waits for a number of streams (or le
descriptors) to change status. ReadyReads is unied with the list of elements listed in Reads that
have characters available for reading. Similarly ReadyWrites is unied with the list of elements of
Writes that are ok for immediate writing. The elements of Reads and Writes are either stream-terms
or aliases or integers considered as le descriptors, e.g. for sockets (section 8.28, page 176). Streams that
must be tested with select/5 should not be buered. This can be done at the opening using open/4
(section 8.10.6, page 81) or later using setstream buffering/2 (section 8.10.27, page 93). TimeOut is
an upper bound on the amount of time (in milliseconds) elapsed before select/5 returns. If TimeOut
0 (no timeout) select/5 waits until something is available (either or reading or for writing) and thus
can block indenitely. This predicate is an interface to the C Unix function select(2) .
Errors
Reads (orWrites ) is a partial list or a list with
an element Ewhich is a variableinstantiation error
Reads is neither a partial list nor a list type error(list, Reads)
Writes is neither a partial list nor a list type error(list, Writes)
ReadyReads is neither a partial list nor a list type error(list, ReadyReads)
ReadyWrites is neither a partial list nor a list type error(list, ReadyWrites)
an element Eof the Reads (orWrites ) list is
neither a stream-term or alias nor an integerdomain error(stream oralias, E)
an element Eof the Reads (orWrites ) list is not
a selectable itemdomain error(selectable item, E)
an element Eof the Reads (orWrites ) list is an
integer<0domain error(not less than zero, E)
an element Eof the Reads (orWrites ) list is a
stream-tern or alias not associated with an open
streamexistence error(stream, E)
an element Eof the Reads list is associated with
an output streampermission error(input, stream, E)
an element Eof the Writes list is associated with
an input streampermission error(output, stream, E)
TimeOut is a variable instantiation error
TimeOut is neither a variable nor a number type error(number, TimeOut)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
176 8 PROLOG BUILT-IN PREDICATES
8.28 Sockets input/output
8.28.1 Introduction
This set of predicates provides a way to manipulate sockets. The predicates are straightforward interfaces
to the corresponding BSD-type socket functions. This facility is available if the sockets part of GNU Prolog
has been installed. A reader familiar with BSD sockets will understand them immediately otherwise a
study of sockets is needed.
The domain is either the atom 'AFINET' or'AFUNIX' corresponding to the same domains in BSD-type
sockets.
An address is either of the form 'AFINET'(HostName, Port) or'AFUNIX'(SocketName) .HostName is
an atom denoting a machine name, Port is a port number and SocketName is an atom denoting a socket.
By default, streams associated with sockets are block buered. The predicate setstream buffering/2
(section 8.10.27, page 93) can be used to change this mode. They are also text streams by default. Use
setstream type/2 (section 8.10.25, page 92) to change the type if binary streams are needed.
8.28.2 socket/2
Templates
socket(+socket domain, -integer)
Description
socket(Domain, Socket) creates a socket whose domain is Domain (section 8.28, page 176) and unies
Socket with the descriptor identifying the socket. This predicate is an interface to the C Unix function
socket(2) .
Errors
Domain is a variable instantiation error
Domain is neither a variable nor an atom type error(atom, Domain)
Domain is an atom but not a valid socket domain domain error(socket domain, Domain)
Socket is not a variable uninstantiation error(Socket)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.28.3 socket close/1
Templates
socket close(+integer)
Description
8.28 Sockets input/output 177
socket close(Socket) closes the socket whose descriptor is Socket . This predicate should not be used
ifSocket has given rise to a stream, e.g. by socket connect/4 (section 8.28.5, page 178). In that case
simply use close/2 (section 8.10.7, page 82) on the associated stream.
Errors
Socket is a variable instantiation error
Socket is neither a variable nor an integer type error(integer, Socket)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.28.4 socket bind/2
Templates
socket bind(+integer, +socket address)
Description
socket bind(Socket, Address) binds the socket whose descriptor is Socket to the address specied
byAddress (section 8.28, page 176). If Address if of the form 'AFINET'(HostName, Port) and if
HostName is uninstantiated then it is unied with the current machine name. If Port is uninstantiated,
it is unied to a port number picked by the operating system. This predicate is an interface to the C
Unix function bind(2) .
Errors
Socket is a variable instantiation error
Socket is neither a variable nor an integer type error(integer, Socket)
Address is a variable instantiation error
Address is neither a variable nor a valid address domain error(socket address, Address)
Address ='AFUNIX'(E) andEis a variable instantiation error
Address ='AFUNIX'(E) or'AFINET'(E, )
andEis neither a variable nor an atomtype error(atom, E)
Address ='AFUNIX'(E) andEis an atom but
not a valid pathnamedomain error(os path, E)
Address ='AFINET'( , E) andEis neither a
variable nor an integertype error(integer, E)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
178 8 PROLOG BUILT-IN PREDICATES
8.28.5 socket connect/4
Templates
socket connect(+integer, +socket address, -stream, -stream)
Description
socket connect(Socket, Address, StreamIn, StreamOut) connects the socket whose descriptor is
Socket to the address specied by Address (section 8.28, page 176). StreamIn is unied with a stream-
term associated with the input of the connection (it is an input stream). Reading from this stream
gets data from the socket. StreamOut is unied with a stream-term associated with the output of
the connection (it is an output stream). Writing to this stream sends data to the socket. The use of
select/5 can be useful (section 8.27.29, page 175). This predicate is an interface to the C Unix function
connect(2) .
Errors
Socket is a variable instantiation error
Socket is neither a variable nor an integer type error(integer, Socket)
Address is a variable instantiation error
Address is neither a variable nor a valid address domain error(socket address, Address)
Address ='AFUNIX'(E) or'AFINET'(E, )or
Address ='AFINET'( , E) andEis a variableinstantiation error
Address ='AFUNIX'(E) or'AFINET'(E, )
andEis neither a variable nor an atomtype error(atom, E)
Address ='AFUNIX'(E) andEis an atom but
not a valid pathnamedomain error(os path, E)
Address ='AFINET'( , E) andEis neither a
variable nor an integertype error(integer, E)
StreamIn is not a variable uninstantiation error(StreamIn)
StreamOut is not a variable uninstantiation error(StreamOut)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.28.6 socket listen/2
Templates
socket listen(+integer, +integer)
Description
socket listen(Socket, Length) denes the socket whose descriptor is Socket to have a maximum
backlog queue of Length pending connections. This predicate is an interface to the C Unix function
listen(2) .
Errors
8.28 Sockets input/output 179
Socket is a variable instantiation error
Socket is neither a variable nor an integer type error(integer, Socket)
Length is a variable instantiation error
Length is neither a variable nor an integer type error(integer, Length)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicate.
8.28.7 socket accept/4 ,socket accept/3
Templates
socket accept(+integer, -atom, -stream, -stream)
socket accept(+integer, -stream, -stream)
Description
socket accept(Socket, Client, StreamIn, StreamOut) extracts the rst connection to the socket
whose descriptor is Socket . If the domain is 'AFINET' ,Client is unied with an atom whose name is
the Internet host address in numbers-and-dots notation of the connecting machine. StreamIn is unied
with a stream-term associated with the input of the connection (it is an input stream). Reading from this
stream gets data from the socket. StreamOut is unied with a stream-term associated with the output
of the connection (it is an output stream). Writing to this stream sends data to the socket. The use of
select/5 can be useful (section 8.27.29, page 175). This predicate is an interface to the C Unix function
accept(2) .
socket accept(Socket, StreamIn, StreamOut) is equivalent to socket accept(Socket, ,
StreamIn, StreamOut) .
Errors
Socket is a variable instantiation error
Socket is neither a variable nor an integer type error(integer, Socket)
Client is not a variable uninstantiation error(Client)
StreamIn is not a variable uninstantiation error(StreamIn)
StreamOut is not a variable uninstantiation error(StreamOut)
an operating system error occurs and the value
of the oserror Prolog ag is error
(section 8.22.1, page 148)system error( atom explaining the error )
Portability
GNU Prolog predicates.
8.28.8 hostname address/2
Templates
180 8 PROLOG BUILT-IN PREDICATES
hostname address(+atom, ?atom)
hostname address(?atom, +atom)
Description
hostname address(HostName, HostAddress) succeeds if the Internet host address in numbers-and-dots
notation of HostName isHostAddress .Hostname can be given as a fully qualied name, or an unqualied
name or an alias of the machine. The predicate will fail if the machine name or address cannot be
resolved.
Errors
HostName andHostAddress are variables instantiation error
HostName is neither a variable nor an atom type error(atom, HostName)
HostAddress is neither a variable nor an atom type error(atom, HostAddress)
Address is neither a variable nor a valid address domain error(socket address, Address)
Portability
GNU Prolog predicate.
8.29 Linedit management
The following predicates are only available if the linedit part of GNU Prolog has been installed.
8.29.1 getlinedit prompt/1
Templates
getlinedit prompt(?atom)
Description
getlinedit prompt(Prompt) succeeds if Prompt is the current linedit prompt, e.g. the top-level
prompt is '| ?-' . By default all other reads have an empty prompt.
Errors
Prompt is neither a variable nor an atom type error(atom, Pred)
Portability
GNU Prolog predicate.
8.29.2 setlinedit prompt/1
Templates
setlinedit prompt(+atom)
Description
8.29 Linedit management 181
setlinedit prompt(Prompt) sets the current linedit prompt to Prompt . This prompt will be displayed
for reads from a terminal (except for top-level reads).
Errors
Prompt is a variable instantiation error
Prompt is neither a variable nor an atom type error(atom, Pred)
Portability
GNU Prolog predicate.
8.29.3 addlinedit completion/1
Templates
addlinedit completion(+atom)
Description
addlinedit completion(Word) adds Word in the list of completion words maintained by linedit (sec-
tion 4.2.6, page 18). Only words containing letters, digits and the underscore character are added (if
Word does not respect this restriction the predicate fails).
Errors
Word is a variable instantiation error
Word is neither a variable nor an atom type error(atom, Word)
Portability
GNU Prolog predicate.
8.29.4 find linedit completion/2
Templates
find linedit completion(+atom, ?atom)
Description
find linedit completion(Prefix, Word) succeeds if Word is a word beginning by Prefix and belongs
to the list of completion words maintained by linedit (section 4.2.6, page 18). This predicate is re-
executable on backtracking.
Errors
Prefix is a variable instantiation error
Prefix is neither a variable nor an atom type error(atom, Prefix)
Word is neither a variable nor an atom type error(atom, Word)
Portability
GNU Prolog predicate.
182 8 PROLOG BUILT-IN PREDICATES
183
9 Finite domain solver and built-in predicates
9.1 Introduction
The nite domain (FD) constraint solver extends Prolog with constraints over FD. This facility is available
if the FD part of GNU Prolog has been installed. The solver is an instance of the Constraint Logic
Programming scheme introduced by Jaar and Lassez in 1987 [7]. Constraints on FD are solved using
propagation techniques, in particular arc-consistency (AC). The interested reader can refer to \Constraint
Satisfaction in Logic Programming" of P. Van Hentenryck (1989) [8]. The solver is based on the clp(FD)
solver [4]. The GNU Prolog FD solver oers arithmetic constraints, boolean constraints, reied constraints
and symbolic constraints on an new kind of variables: Finite Domain variables.
9.1.1 Finite Domain variables
A new type of data is introduced: FD variables which can only take values in their domains. The
initial domain of an FD variable is 0..fd maxinteger where fdmaxinteger represents the greatest
value that any FD variable can take. The predicate fdmaxinteger/1 returns this value which may be
dierent from the maxinteger Prolog ag (section 8.22.1, page 148). The domain of an FD variable
Xis reduced step by step by constraints in a monotonic way: when a value has been removed from the
domain of Xit will never reappear in the domain of X. An FD variable is fully compatible with both
Prolog integers and Prolog variables. Namely, when an FD variable is expected by an FD constraint it is
possible to pass a Prolog integer (considered as an FD variable whose domain is a singleton) or a Prolog
variable (immediately bound to an initial range 0..fd maxinteger ). This avoids the need for specic
type declaration. Although it is not necessary to declare the initial domain of an FD variable (since it
will be bound 0..fd maxinteger when appearing for the st time in a constraint) it is advantageous to
do so and thus reduce as soon as possible the size of its domain: particularly because GNU Prolog, for
eciency reasons, does not check for overows. For instance, without any preliminary domain denitions
forX,Yand Z, the non-linear constraint X*Y#=Z will fail due to an overow when computing the upper
bound of the domain of Z:fdmaxintegerfdmaxinteger . This overow causes a negative result
for the upper bound and the constraint then fails.
There are two internal representations for an FD variable:
â€¢interval representation : only the min and the max of the variable are maintained. In this
representation it is possible to store values included in 0..fd maxinteger .
â€¢sparse representation : an additional bit-vector is used to store the set of possible values for
the variable (i.e. the domain). In this representation it is possible to store values included in
0..vector max. By default vector maxis set to 127. This value can be redened via an en-
vironment variable VECTORMAX or via the built-in predicate fdsetvector max/1 (section 9.2.3,
page 185). The predicate fdvector max/1 returns the current value of vector max(section 9.2.1,
page 184).
The initial representation for an FD variable Xis always an interval representation and is switched to
a sparse representation when a \hole" appears in the domain (e.g. due to an inequality constraint).
Once a variable uses a sparse representation it will not switch back to an interval representation even if
there are no longer holes in its domain. When this switching occurs some values in the domain of Xcan
be lost since vector maxis less than fdmaxinteger . We say that \ Xis extra-constrained" since Xis
constrained by the solver to the domain 0..vector max(via an imaginary constraint X #=< vector max).
Anextra cstr is associated with each FD variable to indicate that values have been lost due to the switch
to a sparse representation. This ag is updated on every operations. The domain of an extra-constrained
FD variable is output followed by the @symbol. When a constraint fails on a extra-constrained variable
184 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
a message Warning: Vector too small - maybe lost solutions (FD Var: N)is displayed ( Nis the
address of the involved variable).
Example 1 ( vector max=127):
Constraint on XDomain of X extra cstr Lost values
X #=< 512 0..512 off none
X #\= 10 0..9:11..127 on 128..512
X #=< 100 0..9:11..100 off none
In this example, when the constraint X #\= 10 is posted some values are lost, the extra cstr is then
switched on. However, posting the constraint X #=< 100 will turn o the ag (no values are lost).
Example 2:
Constraint on XDomain of X extra cstr Lost values
X #=< 512 0..512 off none
X #\= 10 0..9:11..127 on 128..512
X #>= 256 Warning: Vector too small... on 128..512
In this example, the constraint X #>= 256 fails due to the lost of 128..512 so a message is displayed
onto the terminal. The solution would consist in increasing the size of the vector either by setting the
environment variable VECTORMAX (e.g. to 512) or using fdsetvector max(512) .
Finally, bit-vectors are not dynamic, i.e. all vectors have the same size ( 0..vector max). So the use
offdsetvector max/1 is limited to the initial denition of vector sizes and must occur before any
constraint. As seen before, the solver tries to display a message when a failure occurs due to a too short
vector max. Unfortunately, in some cases it cannot detect the lost of values and no message is emitted.
So the user should always take care to this parameter to be sure that it is large to encode any vector.
9.2 FD variable parameters
9.2.1 fdmaxinteger/1
Templates
fdmaxinteger(?integer)
Description
fdmaxinteger(N) succeeds if Nis the current value of fdmaxinteger (section 9.1, page 183).
Errors
Nis neither a variable nor an integer type error(integer, N)
Portability
GNU Prolog predicate.
9.3 Initial value constraints 185
9.2.2 fdvector max/1
Templates
fdvector max(?integer)
Description
fdvector max(N) succeeds if Nis the current value of vector max(section 9.1, page 183).
Errors
Nis neither a variable nor an integer type error(integer, N)
Portability
GNU Prolog predicate.
9.2.3 fdsetvector max/1
Templates
fdsetvector max(+integer)
Description
fdsetvector max(N) initializes vector maxbased on the value N(section 9.1, page 183). More precisely,
on 32 bit machines, vector maxis set to the smallest value of (32*k)- 1 which isN.
Errors
Nis a variable instantiation error
Nis neither a variable nor an integer type error(integer, N)
Nis an integer <0 domain error(not less than zero, N)
Portability
GNU Prolog predicate.
9.3 Initial value constraints
9.3.1 fddomain/3 ,fddomain bool/1
Templates
fddomain(+fd variable list orfdvariable, +integer, +integer)
fddomain(?fd variable, +integer, +integer)
fddomain bool(+fd variable list)
fddomain bool(?fd variable)
Description
186 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
fddomain(Vars, Lower, Upper) constraints each element XofVars to take a value in Lower..Upper .
This predicate is generally used to set the initial domain of variables to an interval. Vars can be also a
single FD variable (or a single Prolog variable).
fddomain bool(Vars) is equivalent to fddomain(Vars, 0, 1) and is used to declare boolean FD
variables.
Errors
Vars is not a variable but is a partial list instantiation error
Vars is neither a variable nor an FD variable nor
an integer nor a listtype error(list, Vars)
an element Eof the Vars list is neither a variable
nor an FD variable nor an integertype error(fd variable, E)
Lower is a variable instantiation error
Lower is neither a variable nor an integer type error(integer, Lower)
Upper is a variable instantiation error
Upper is neither a variable nor an integer type error(integer, Upper)
Portability
GNU Prolog predicate.
9.3.2 fddomain/2
Templates
fddomain(+fd variable list, +integer list)
fddomain(?fd variable, +integer list)
Description
fddomain(Vars, Values) constraints each element Xof the list Vars to take a value in the list Values .
This predicate is generally used to set the initial domain of variables to a set of values. The domain of
each variable of Vars uses a sparse representation. Vars can be also a single FD variable (or a single
Prolog variable).
Errors
Vars is not a variable but is a partial list instantiation error
Vars is neither a variable nor an FD variable nor
an integer nor a listtype error(list, Vars)
an element Eof the Vars list is neither a variable
nor an FD variable nor an integertype error(fd variable, E)
Values is a partial list or a list with an element
Ewhich is a variableinstantiation error
Values is neither a partial list nor a list type error(list, Values)
an element Eof the Values list is neither a
variable nor an integertype error(integer, E)
Portability
GNU Prolog predicate.
9.4 Type testing 187
9.4 Type testing
9.4.1 fdvar/1 ,nonfdvar/1 ,generic var/1 ,nongeneric var/1
Templates
fdvar(?term)
nonfdvar(?term)generic var(?term)
nongeneric var(?term)
Description
fdvar(Term) succeeds if Term is currently an FD variable.
nonfdvar(Term) succeeds if Term is currently not an FD variable (opposite of fdvar/1 ).
generic var(Term) succeeds if Term is either a Prolog variable or an FD variable.
nongeneric var(Term) succeeds if Term is neither a Prolog variable nor an FD variable (opposite of
generic var/1 ).
Errors
None.
Portability
GNU Prolog predicate.
9.5 FD variable information
These predicate allow the user to get some information about FD variables. They are not constraints,
they only return the current state of a variable.
9.5.1 fdmin/2 ,fdmax/2 ,fdsize/2 ,fddom/2
Templates
fdmin(+fd variable, ?integer)
fdmax(+fd variable, ?integer)
fdsize(+fd variable, ?integer)
fddom(+fd variable, ?integer list)
Description
fdmin(X, N) succeeds if Nis the minimal value of the current domain of X.
fdmax(X, N) succeeds if Nis the maximal value of the current domain of X.
fdsize(X, N) succeeds if Nis the number of elements of the current domain of X.
fddom(X, Values) succeeds if Values is the list of values of the current domain of X.
188 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
Errors
Xis a variable instantiation error
Xis neither an FD variable nor an integer type error(fd variable, X)
Nis neither a variable nor an integer type error(integer, N)
an element Eof the Vars list is neither a variable
nor an FD variable nor an integertype error(fd variable, E)
Values is neither a partial list nor a list type error(list, Values)
Portability
GNU Prolog predicate.
9.5.2 fdhasextra cstr/1 ,fdhasvector/1 ,fdusevector/1
Templates
fdhasextra cstr(+fd variable)
fdhasvector(+fd variable)
fdusevector(+fd variable)
Description
fdhasextra cstr(X) succeeds if the extra cstr ofXis currently on (section 9.1, page 183).
fdhasvector(X) succeeds if the current domain of Xuses a sparse representation (section 9.1, page 183).
fdusevector(X) enforces a sparse representation for the domain of X(section 9.1, page 183).
Errors
Xis a variable instantiation error
Xis neither an FD variable nor an integer type error(fd variable, X)
Portability
GNU Prolog predicates.
9.6 Arithmetic constraints
9.6.1 FD arithmetic expressions
An FD arithmetic expression is a Prolog term built from integers, variables (Prolog or FD variables), and
functors (or operators) that represent arithmetic functions. The following table details the components
of an FD arithmetic expression:
9.6 Arithmetic constraints 189
FD Expression Result
Prolog variable domain 0..fd maxinteger
FD variable X domain of X
integer number N domain N..N
+ E same as E
- E opposite of E
E1 + E2 sum of E1andE2
E1 - E2 subtraction of E2from E1
E1 * E2 multiplication of E1byE2
E1 / E2 integer division of E1byE2(only succeeds if the remainder is 0)
E1 ** E2 E1raised to the power of E2(E1orE2must be an integer)
min(E1,E2) minimum of E1andE2
max(E1,E2) maximum of E1andE2
dist(E1,E2) distance, i.e.jE1 - E2j
E1 // E2 quotient of the integer division of E1byE2
E1 rem E2 remainder of the integer division of E1byE2
quot rem(E1,E2,R)quotient of the integer division of E1byE2
(Ris the remainder of the integer division of E1byE2)
FD expressions are not restricted to be linear. However non-linear constraints usually yield less constraint
propagation than linear constraints.
+,-,*,/,//,remand **are predened inx operators. +and -are predened prex operators
(section 8.14.10, page 113).
Errors
a sub-expression is of the form ** E andEis a
variableinstantiation error
a sub-expression Eis neither a variable nor an
integer nor an FD arithmetic functortype error(fd evaluable, E)
an expression is too complex resource error(too bigfdconstraint)
9.6.2 Partial AC: (#=)/2 - constraint equal, (#\=)/2 - constraint not equal,
(#<)/2 - constraint less than, (#=<)/2 - constraint less than or equal,
(#>)/2 - constraint greater than, (#>=)/2 - constraint greater than or equal
Templates
#=(?fd evaluable, ?fd evaluable)
#\=(?fd evaluable, ?fd evaluable)
#<(?fd evaluable, ?fd evaluable)
#=<(?fd evaluable, ?fd evaluable)
#>(?fd evaluable, ?fd evaluable)
#>=(?fd evaluable, ?fd evaluable)
Description
FdExpr1 #= FdExpr2 constrains FdExpr1 to be equal to FdExpr2 .
FdExpr1 #\= FdExpr2 constrains FdExpr1 to be dierent from FdExpr2 .
FdExpr1 #< FdExpr2 constrains FdExpr1 to be less than FdExpr2 .
190 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
FdExpr1 #=< FdExpr2 constrains FdExpr1 to be less than or equal to FdExpr2 .
FdExpr1 #> FdExpr2 constrains FdExpr1 to be greater than FdExpr2 .
FdExpr1 #>= FdExpr2 constrains FdExpr1 to be greater than or equal to FdExpr2 .
FdExpr1 andFdExpr2 are arithmetic FD expressions (section 9.6.1, page 188).
#=,#\=,#<,#=<,#>and#>=are predened inx operators (section 8.14.10, page 113).
These predicates post arithmetic constraints that are managed by the solver using a partial arc-consistency
algorithm to reduce the domain of involved variables. In this scheme only the bounds of the domain of
variables are updated. This leads to less propagation than full arc-consistency techniques (section 9.6.3,
page 190) but is generally more ecient for arithmetic. These arithmetic constraints can be reied
(section 9.7, page 191).
Errors
Refer to the syntax of arithmetic FD expressions for possible errors (section 9.6.1, page 188).
Portability
GNU Prolog predicates.
9.6.3 Full AC: (#=#)/2 - constraint equal, (#\=#)/2 - constraint not equal,
(#<#)/2 - constraint less than, (#=<#)/2 - constraint less than or equal,
(#>#)/2 - constraint greater than, (#>=#)/2 - constraint greater than or equal
Templates
#=#(?fd evaluable, ?fd evaluable)
#\=#(?fd evaluable, ?fd evaluable)
#<#(?fd evaluable, ?fd evaluable)
#=<#(?fd evaluable, ?fd evaluable)
#>#(?fd evaluable, ?fd evaluable)
#>=#(?fd evaluable, ?fd evaluable)
Description
FdExpr1 #=# FdExpr2 constrains FdExpr1 to be equal to FdExpr2 .
FdExpr1 #\=# FdExpr2 constrains FdExpr1 to be dierent from FdExpr2 .
FdExpr1 #<# FdExpr2 constrains FdExpr1 to be less than FdExpr2 .
FdExpr1 #=<# FdExpr2 constrains FdExpr1 to be less than or equal to FdExpr2 .
FdExpr1 #># FdExpr2 constrains FdExpr1 to be greater than FdExpr2 .
FdExpr1 #>=# FdExpr2 constrains FdExpr1 to be greater than or equal to FdExpr2 .
FdExpr1 andFdExpr2 are arithmetic FD expressions (section 9.6.1, page 188).
#=#,#\=# ,#<#,#=<# ,#>#and#>=# are predened inx operators (section 8.14.10, page 113).
9.7 Boolean and reied constraints 191
These predicates post arithmetic constraints that are managed by the solver using a full arc-consistency
algorithm to reduce the domain of involved variables. In this scheme the full domain of variables is
updated. This leads to more propagation than partial arc-consistency techniques (section 9.6.1, page 188)
but is generally less ecient for arithmetic. These arithmetic constraints can be reied (section 9.7.1,
page 191).
Errors
Refer to the syntax of arithmetic FD expressions for possible errors (section 9.6.1, page 188).
Portability
GNU Prolog predicates.
9.6.4 fdprime/1 ,fdnotprime/1
Templates
fdprime(?fd variable)
fdnotprime(?fd variable)
Description
fdprime(X) constraints Xto be a prime number between 0..vector max. This constraint enforces a
sparse representation for the domain of X(section 9.1, page 183).
fdnotprime(X) constraints Xto be a non prime number between 0..vector max. This constraint
enforces a sparse representation for the domain of X(section 9.1, page 183).
Errors
Xis neither an FD variable nor an integer type error(fd variable, X)
Portability
GNU Prolog predicates.
9.7 Boolean and reied constraints
9.7.1 Boolean FD expressions
An boolean FD expression is a Prolog term built from integers (0 for false, 1 for true), variables (Prolog or
FD variables), partial AC arithmetic constraints (section 9.6.2, page 189), full AC arithmetic constraints
(section 9.6.3, page 190) and functors (or operators) that represent boolean functions. When a sub-
expression of a boolean expression is an arithmetic constraint c, it is reied. Namely, as soon as the
solver detects that cis true (i.e. entailed ) the sub-expression has the value 1. Similarly when the solver
detects that cis false (i.e. disentailed ) the sub-expression evaluates as 0. While neither the entailment
nor the disentailment can be detected the sub-expression is evaluated as a domain 0..1 . The following
table details the components of an FD boolean expression:
192 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
FD Expression Result
Prolog variable domain 0..1
FD variable X domain of X,Xis constrained to be in 0..1
0(integer) 0(false)
1(integer) 1(true)
#\ E notE
E1 #<=> E2 E1equivalent to E2
E1 #\<=> E2 E1not equivalent to E2(i.e. E1dierent from E2)
E1 ## E2 E1exclusive OR E2(i.e. E1not equivalent to E2)
E1 #==> E2 E1implies E2
E1 #\==> E2 E1does not imply E2
E1 #/\ E2 E1AND E2
E1 #\/\ E2 E1NAND E2
E1 #\/ E2 E1ORE2
E1 #\\/ E2 E1NOR E2
#<=> ,#\<=> ,##,#==> ,#\==> ,#/\,#\/\ ,#\/and#\\/ are predened inx operators. #\is a predened
prex operator (section 8.14.10, page 113).
Errors
a sub-expression Eis neither a variable nor an
integer (0 or 1) nor an FD boolean functor nor
reied constrainttype error(fd bool evaluable, E)
an expression is too complex resource error(too bigfdconstraint)
a sub-expression is an invalid reied constraintan arithmetic constraint error (section 9.6.1,
page 188)
9.7.2 fdreified in/4
Templates
fdreified in(?fd variable, +integer, +integer, ?fd variable)
Description
fdreified in(X, Lower, Upper, B) captures the truth value of the constraint X2[Lower::Upper ] in
the boolean variable B.
Errors
Xis neither a variable nor an FD variable nor an
integertype error(fd variable, X)
Bis neither a variable nor an FD variable nor an
integertype error(fd variable, B)
Lower is a variable instantiation error
Lower is neither a variable nor an integer type error(integer, Lower)
Upper is a variable instantiation error
Upper is neither a variable nor an integer type error(integer, Upper)
9.7 Boolean and reied constraints 193
9.7.3 (#\)/1 - constraint NOT, (#<=>)/2 - constraint equivalent,
(#\<=>)/2 - constraint dierent, (##)/2 - constraint XOR,
(#==>)/2 - constraint imply, (#\==>)/2 - constraint not imply,
(#/\)/2 - constraint AND, (#\/\)/2 - constraint NAND,
(#\/)/2 - constraint OR, (#\\/)/2 - constraint NOR
Templates
#\(?fd bool evaluable)
#<=>(?fd bool evaluable, ?fd bool evaluable)
#\<=>(?fd bool evaluable, ?fd bool evaluable)
##(?fd bool evaluable, ?fd bool evaluable)
#==>(?fd bool evaluable, ?fd bool evaluable)
#\==>(?fd bool evaluable, ?fd bool evaluable)
#/\(?fd bool evaluable, ?fd bool evaluable)
#\/\(?fd bool evaluable, ?fd bool evaluable)
#\/(?fd bool evaluable, ?fd bool evaluable)
#\\/(?fd bool evaluable, ?fd bool evaluable)
Description
#\ FdBoolExpr1 constraints FdBoolExpr1 to be false.
FdBoolExpr1 #<=> FdBoolExpr2 constrains FdBoolExpr1 to be equivalent to FdBoolExpr2 .
FdBoolExpr1 #\<=> FdBoolExpr2 constrains FdBoolExpr1 to be equivalent to not FdBoolExpr2 .
FdBoolExpr1 ## FdBoolExpr2 constrains FdBoolExpr1 XOR FdBoolExpr2 to be true
FdBoolExpr1 #==> FdBoolExpr2 constrains FdBoolExpr1 to imply FdBoolExpr2 .
FdBoolExpr1 #\==> FdBoolExpr2 constrains FdBoolExpr1 to not imply FdBoolExpr2 .
FdBoolExpr1 #/\ FdBoolExpr2 constrains FdBoolExpr1 AND FdBoolExpr2 to be true.
FdBoolExpr1 #\/\ FdBoolExpr2 constrains FdBoolExpr1 AND FdBoolExpr2 to be false.
FdBoolExpr1 #\/ FdBoolExpr2 constrains FdBoolExpr1 ORFdBoolExpr2 to be true.
FdBoolExpr1 #\\/ FdBoolExpr2 constrains FdBoolExpr1 ORFdBoolExpr2 to be false.
FdBoolExpr1 andFdBoolExpr2 are boolean FD expressions (section 9.7.1, page 191).
Note that #\<=> (not equivalent) and ##(exclusive or) are synonymous.
These predicates post boolean constraints that are managed by the FD solver using a partial arc-
consistency algorithm to reduce the domain of involved variables. The (dis)entailment of reied con-
straints is detected using either the bounds (for partial AC arithmetic constraints) or the full domain
(for full AC arithmetic constraints).
#<=> ,#\<=> ,##,#==> ,#\==> ,#/\,#\/\ ,#\/and#\\/ are predened inx operators. #\is a predened
prex operator (section 8.14.10, page 113).
Errors
194 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
Refer to the syntax of boolean FD expressions for possible errors (section 9.7.1, page 191).
Portability
GNU Prolog predicates.
9.7.4 fdcardinality/2 ,fdcardinality/3 ,fdatleast one/1 ,fdatmost one/1 ,
fdonly one/1
Templates
fdcardinality(+fd bool evaluable list, ?fd variable)
fdcardinality(+integer, ?fd variable, +integer)
fdatleast one(+fd bool evaluable list)
fdatmost one(+fd bool evaluable list)
fdonly one(+fd bool evaluable list)
Description
fdcardinality(List, Count) unies Count with the number of constraints that are true in List .
This is equivalent to post the constraint B1+ B2+ ...+ B n#= Count where each variable Biis a new
variable dened by the constraint Bi#<=> C iwhere Ciis the ithconstraint of List . Each Cimust be a
boolean FD expression (section 9.7.1, page 191).
fdcardinality(Lower, List, Upper) is equivalent to fdcardinality(List, Count), Lower #=<
Count, Count #=< Upper
fdatleast one(List) is equivalent to fdcardinality(List, Count), Count #>= 1 .
fdatmost one(List) is equivalent to fdcardinality(List, Count), Count #=< 1 .
fdonly one(List) is equivalent to fdcardinality(List, 1) .
Errors
List is a partial list instantiation error
List is neither a partial list nor a list type error(list, List)
Count is neither an FD variable nor an integer type error(fd variable, Count)
Lower is a variable instantiation error
Lower is neither a variable nor an integer type error(integer, Lower)
Upper is a variable instantiation error
Upper is neither a variable nor an integer type error(integer, Upper)
an element Eof the List list is an invalid
boolean expressionan FD boolean constraint (section 9.7.1,
page 191)
Portability
GNU Prolog predicates.
9.8 Symbolic constraints 195
9.8 Symbolic constraints
9.8.1 fdalldifferent/1
Templates
fdalldifferent(+fd variable list)
Description
fdalldifferent(List) constrains all variables in List to take distinct values. This is equivalent to
posting an inequality constraint for each pair of variables. This constraint is triggered when a variable
becomes ground, removing its value from the domain of the other variables.
Errors
List is a partial list instantiation error
List is neither a partial list nor a list type error(list, List)
an element Eof the List list is neither a variable
nor an integer nor an FD variabletype error(fd variable, E)
Portability
GNU Prolog predicate.
9.8.2 fdelement/3
Templates
fdelement(?fd variable, +integer list, ?fd variable)
Description
fdelement(I, List, X) constraints Xto be equal to the Ithinteger (from 1) of List .
Errors
Iis neither a variable nor an FD variable nor an
integertype error(fd variable, I)
Xis neither a variable nor an FD variable nor an
integertype error(fd variable, X)
List is a partial list or a list with an element E
which is a variableinstantiation error
List is neither a partial list nor a list type error(list, List)
an element Eof the List list is neither a variable
nor an integertype error(integer, E)
Portability
GNU Prolog predicate.
196 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
9.8.3 fdelement var/3
Templates
fdelement var(?fd variable, +fd variable list, ?fd variable)
Description
fdelement var(I, List, X) constraints Xto be equal to the Ithvariable (from 1) of List . This
constraint is similar to fdelement/3 (section 9.8.2, page 195) but List can also contain FD variables
(rather than just integers).
Errors
Iis neither a variable nor an FD variable nor an
integertype error(fd variable, I)
Xis neither a variable nor an FD variable nor an
integertype error(fd variable, X)
List is a partial list instantiation error
List is neither a partial list nor a list type error(list, List)
an element Eof the List list is neither a variable
nor an integer nor an FD variabletype error(fd variable, E)
Portability
GNU Prolog predicate.
9.8.4 fdatmost/3 ,fdatleast/3 ,fdexactly/3
Templates
fdatmost(+integer, +fd variable list, +integer)
fdatleast(+integer, +fd variable list, +integer)
fdexactly(+integer, +fd variable list, +integer)
Description
fdatmost(N, List, V) posts the constraint that at most Nvariables of List are equal to the value V.
fdatleast(N, List, V) posts the constraint that at least Nvariables of List are equal to the value V.
fdexactly(N, List, V) posts the constraint that at exactly Nvariables of List are equal to the value
V.
These constraints are special cases of fdcardinality/2 (section 9.7.4, page 194) but their implementa-
tion is more ecient.
Errors
9.8 Symbolic constraints 197
Nis a variable instantiation error
Nis neither a variable nor an integer type error(integer, N)
Vis a variable instantiation error
Vis neither a variable nor an integer type error(integer, V)
List is a partial list instantiation error
List is neither a partial list nor a list type error(list, List)
an element Eof the List list is neither a variable
nor an FD variable nor an integertype error(fd variable, E)
Portability
GNU Prolog predicates.
9.8.5 fdrelation/2 ,fdrelationc/2
Templates
fdrelation(+integer list list, ?fd variable list)
fdrelationc(+integer list list, ?fd variable list)
Description
fdrelation(Relation, Vars) constraints the tuple of variables Vars to be equal to one tuple of the
listRelation . A tuple is represented by a list.
Example: denition of the boolean AND relation so that X AND Y ,Z:
and(X,Y,Z):-
fd_relation([[0,0,0],[0,1,0],[1,0,0],[1,1,1]], [X,Y,Z]).
fdrelationc(Columns, Vars) is similar to fdrelation/2 except that the relation is not given as the
list of tuples but as the list of the columns of the relation. A column is represented by a list.
Example:
and(X,Y,Z):-
fd_relationc([[0,0,1,1],[0,1,0,1],[0,0,0,1]], [X,Y,Z]).
Errors
Relation is a partial list or a list with a
sub-term Ewhich is a variableinstantiation error
Relation is neither a partial list nor a list type error(list, Relation)
an element Eof the Relation list is neither a
variable nor an integertype error(integer, E)
Vars is a partial list instantiation error
Vars is neither a partial list nor a list type error(list, Vars)
an element Eof the Vars list is neither a variable
nor an integer nor an FD variabletype error(fd variable, E)
Portability
GNU Prolog predicates.
198 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
9.9 Labeling constraints
9.9.1 fdlabeling/2 ,fdlabeling/1 ,fdlabelingff/1
Templates
fdlabeling(+fd variable list, +fd labeling option list)
fdlabeling(+fd variable, +fd labeling option list)
fdlabeling(+fd variable list)
fdlabeling(+fd variable)
fdlabelingff(+fd variable list)
fdlabelingff(+fd variable)
Description
fdlabeling(Vars, Options) assigns a value to each variable Xof the list Vars according to the list of
labeling options given by Options .Vars can be also a single FD variable. This predicate is re-executable
on backtracking.
FD labeling options :Options is a list of labeling options. If this list contains contradictory options,
the rightmost option is the one which applies. Possible options are:
â€¢variable method(V) : species the heuristics to select the variable to enumerate:
{standard : no heuristics, the leftmost variable is selected.
{first fail (orff): selects the variable with the smallest number of elements in its domain.
If several variables have the same number of elements the leftmost variable is selected.
{most constrained : like first fail but when several variables have the same number of
elements selects the variable that appears in most constraints.
{smallest : selects the variable that has the smallest value in its domain. If there is more than
one such variable selects the variable that appears in most constraints.
{largest : selects the variable that has the greatest value in its domain. If there is more than
one such variable selects the variable that appears in most constraints.
{maxregret : selects the variable that has the greatest dierence between the smallest value
and the next value of its domain. If there is more than one such variable selects the variable
that appears in most constraints.
{random : selects randomly a variable. Each variable is chosen only once.
The default value is standard .
â€¢reorder(true/false) : species if the variable heuristics should dynamically reorder the list of
variable ( true ) or not ( false ). Dynamic reordering is generally more ecient but in some cases a
static ordering is faster. The default value is true .
â€¢value method(V) : species the heuristics to select the value to assign to the chosen variable:
{min: enumerates the values from the smallest to the greatest (default).
{max: enumerates the values from the greatest to the smallest.
{middle : enumerates the values from the middle to the bounds.
{bounds : enumerates the values from the bounds to the middle.
{random : enumerates the values randomly. Each value is tried only once.
{bisect : recursively creates a choice between X #=< M and X #> M , where Mis the midpoint
of the domain of the variable. Values are thus tried from the smallest to the greatest. This is
also known as domain splitting .
9.10 Optimization constraints 199
The default value is min.
â€¢backtracks(B) : unies Bwith the number of backtracks during the enumeration.
fdlabeling(Vars) is equivalent to fdlabeling(Vars, []) .
fdlabelingff(Vars) is equivalent to fdlabeling(Vars, [variable method(ff)]) .
Errors
Vars is a partial list or a list with an element E
which is a variableinstantiation error
Vars is neither a partial list nor a list type error(list, Vars)
an element Eof the Vars list is neither a variable
nor an integer nor an FD variabletype error(fd variable, E)
Options is a partial list or a list with an element
Ewhich is a variableinstantiation error
Options is neither a partial list nor a list type error(list, Options)
an element Eof the Options list is neither a
variable nor a labeling optiondomain error(fd labeling option, E)
Portability
GNU Prolog predicates.
9.10 Optimization constraints
9.10.1 fdminimize/2 ,fdmaximize/2
Templates
fdminimize(+callable term, ?fd variable)
fdmaximize(+callable term, ?fd variable)
Description
fdminimize(Goal, X) repeatedly calls Goal to nd a value that minimizes the variable X.Goal is a
Prolog goal that should instantiate X, a common case being the use of fdlabeling/2 (section 9.9.1,
page 198). This predicate uses a branch-and-bound algorithm with restart: each time call(Goal)
succeeds the computation restarts with a new constraint X #< V where Vis the value of Xat the end of
the last call of Goal . When a failure occurs (either because there are no remaining choice-points for Goal
or because the added constraint is inconsistent with the rest of the store) the last solution is recomputed
since it is optimal.
fdmaximize(Goal, X) is similar to fdminimize/2 butXis maximized .
Errors
200 9 FINITE DOMAIN SOLVER AND BUILT-IN PREDICATES
Goal is a variable instantiation error
Goal is neither a variable nor a callable term type error(callable, Goal)
The predicate indicator Pred ofGoal does not
correspond to an existing procedure and the
value of the unknown Prolog ag is error
(section 8.22.1, page 148)existence error(procedure, Pred)
Xis neither a variable nor an FD variable nor an
integertype error(fd variable, X)
Portability
GNU Prolog predicates.
201
10 Interfacing Prolog and C
10.1 Introduction
The foreign code interface allows the use to link Prolog and C in both directions.
A Prolog predicate can call a C function passing dierent kinds of arguments (input, output or in-
put/output). The interface performs implicit Prolog $C data conversions for simple types (for instance
a Prolog integer is automatically converted into a C integer) and provides a set of API (Application
Programming Interface) functions to convert more complex types (lists or structures). The interface also
performs automatic error detection depending on the actual type of the passed argument. An important
feature is the ability to write non-deterministic code in C.
It is also possible to call (or callback) a Prolog predicate from a C function and to manage Prolog non-
determinism: the C code can ask for next solutions, remove all remaining solutions or terminate and keep
alternatives for the calling Prolog predicate).
10.2 Including and using gprolog.h
The C code should include gprolog.h which provides a set of C denitions (types, macros, prototypes)
associated to the API. Include this les as follows:
#include <gprolog.h>
If the installation has been correctly done nothing else is needed. If the C compiler/preprocessor can-
not locate gprolog.h pass the C compiler option required to specify an additional include directory
(e.g.-Iinclude dir) togplc as follows (section 4.4.3, page 23):
% gplc -C -I include dir ...
The le gprolog.h declares the following C types:
â€¢PlBool as an integer and the constants PLFALSE (i.e. 0) and PLTRUE (i.e. 1).
â€¢PlLong as an integer able to store a pointer (equivalent to intptr t). This type appeared in GNU
Prolog 1.4.0 in replacement of long to support Windows 64 bits (where the long type is only 32
bits). This type is used to handle integer types.
â€¢PlULong same as PlLong but unsigned (same as uintptr t).
â€¢PlTerm same as intptr t. This type is used to store general Prolog terms.
New in GNU Prolog 1.3.1 and backward compatibility issues : in GNU Prolog 1.3.1 the API has
been modied to protect namespace. The name of public functions, macros, variables and types are now
prexed with Pl,PLorpl. All these prexes should be avoided by the foreign C-code to prevent name
clashes. To ensure a backward compatibility, the names used by the old API are available thanks to a
set of #define . However, this deprecated API should not be used by recent code. It is also possible to
prevent the denition of the compatibility macros using:
#define __GPROLOG_FOREIGN_STRICT__
#include <gprolog.h>
In addition, gprolog.h denes a set of macros:
â€¢ GNUPROLOG (as the major version).
202 10 INTERFACING PROLOG AND C
â€¢ GPROLOG ,GPROLOG MINOR and GPROLOG PATCHLEVEL . Their values are the major version,
minor version, and patch level of GNU Prolog, as integer constants. For example, GNU Prolog 1.3.2
will dene GPROLOG to 1, GPROLOG MINOR to 3, and GPROLOG PATCHLEVEL to 2.
If you need to write code which depends on a specic version, you must be more careful. Recall
these macros appeared in GNU Prolog 1.3.1 (undened before), each time the minor version is
increased, the patch level is reset to zero; each time the major version is increased (which happens
rarely), the minor version and patch level are reset.
â€¢GPROLOG VERSION : the version as an integer dened as follows: major10000 +minor100 +
patchlevel . For example: version 1.3.2 will result in the value 10302.
â€¢PLPROLOG DIALECT : a C constant string (generally "gprolog" ). Appeared in 1.3.2.
â€¢PLPROLOG NAME : a C constant string (generally "GNU Prolog" ).
â€¢PLPROLOG VERSION : a C constant string associated to the version (e.g. "1.4.0" ).
â€¢PLPROLOG DATE : a C constant string associated with the date of this version (e.g. "Mar 29 2011" .
â€¢PLPROLOG COPYRIGHT : a C constant string associated with the copyright of this version (e.g.
"Copyright (C) 1999-2021 Daniel Diaz" .
Note the above PLPROLOG ... macros are also accessible via Prolog ags thanks to the built-in predicate
current prolog flag/2 (section 8.22.2, page 151)
10.3 Calling C from Prolog
10.3.1 Introduction
This interface can then be used to write both simple and complex C routines. A simple routine uses
either input or output arguments which type is simple. In that case the user does not need any knowledge
of Prolog data structures since all Prolog $C data conversions are implicitly achieved. To manipulate
complex terms (lists, structures) a set of functions is provided. Finally it is also possible to write non-
deterministic C code.
10.3.2 foreign/2 directive
foreign/2 directive (section 7.1.15, page 50) declares a C function interface. The general form is
foreign(Template, Options) which denes an interface predicate whose prototype is Template ac-
cording to the options given by Options .Template is a callable term specifying the type/mode of each
argument of the associated Prolog predicate.
Foreign options :Options is a list of foreign options. If this list contains contradictory options, the
rightmost option is the one which applies. Possible options are:
â€¢fctname(F) :Fis an atom representing the name of the C function to call. By default the name of
the C function is the same as the principal functor of Template . In any case, the atom associated
with the name of the function must conforms to the syntax of C identiers.
â€¢return(boolean /none /jump) : species the value returned by the C function:
{boolean : the type of the function is PlBool (returns PLTRUE on success, PLFALSE otherwise).
{none : the type of the function is void (no returned value).
{jump : the type of the function is void(*)() (returns the address of a Prolog code to execute).
10.3 Calling C from Prolog 203
The default value is boolean .
â€¢bipname(Name, Arity) : initializes the error context with Name andArity . If an error occurs this
information is used to indicate from which predicate the error occurred (section 6.3.1, page 39). It
is also possible to prevent the initialization of the error context using bipname(none) . By default
Name andArity are set to the functor and arity of Template .
â€¢choice size(N) : this option species that the function implements a non-deterministic code. Nis
an integer specifying the size needed by the non-deterministic C function. This facility is explained
later (section 10.3.7, page 205). By default a foreign function is deterministic.
foreign(Template) is equivalent to foreign(Template, []) .
Foreign modes and types : each argument of Template species the foreign mode and type of the
corresponding argument. This information is used to check the type of eective arguments at run-time
and to perform Prolog $C data conversions. Each argument of Template is formed with a mode symbol
followed by a type name. Possible foreign modes are:
â€¢+: input argument.
â€¢-: output argument.
â€¢?: input/output argument.
Possible foreign types are:
Foreign type Prolog type C type Description of the C type
integer integer PlLong value of the integer
positive positive integer PlLong value of the integer
float oating point number double value of the oating point number
number number double value of the number
atom atom PlLong internal key of the atom
boolean boolean PlLong value of the boolean (0= false , 1=true )
char character PlLong value of (the code of) the character
code character code PlLong value of the character-code
byte byte PlLong value of the byte
inchar in-character PlLong value of the character or -1for end-of-le
incode in-character code PlLong value of the character-code or -1for end-of-le
inbyte in-byte PlLong value of the byte or -1for the end-of-le
string atom char * C string containing the name of the atom
chars character list char * C string containing the characters of the list
codes character-code list char * C string containing the characters of the list
term Prolog term PlTerm generic Prolog term
Simple foreign type : a simple type is any foreign type listed in the above tabled except term . A simple
foreign type is an atomic term (character and character-code lists are in fact lists of constants). Each
simple foreign type is converted to/from a C type to simplify the writing of the C function.
Complex foreign type : type foreign type term refers to any Prolog term (e.g. lists, structures. . . ).
When such an type is specied the argument is passed to the C function as a PlTerm (GNU Prolog C type
equivalent to a PlLong ). Several functions are provided to manipulate PlTerm variables (section 10.4,
page 210). Since the original term is passed to the function it is possible to read its value or to unify it.
So the meaning of the mode symbol is less signicant. For this reason it is possible to omit the mode
symbol. In that case term is equivalent to +term .
204 10 INTERFACING PROLOG AND C
10.3.3 The C function
The type returned by the C function depends on the value of the return foreign option (section 10.3.2,
page 202). If it is boolean then the C function is of type PlBool and shall return PLTRUE in case of
success and PLFALSE otherwise. If the return option is none the C function is of type void . Finally if
it isjump , the function shall return the address of a Prolog predicate and, at the exit of the function, the
control is given to that predicate.
The type of the arguments of the C function depends on the mode and type declaration specied in
Template for the corresponding argument as explained in the following sections.
10.3.4 Input arguments
An input argument is tested at run-time to check if its type conforms to the foreign type and then
it is passed to the C function. The type of the associated C argument is given by the above table
(section 10.3.2, page 202). For instance, the eective argument Argassociated with +positive foreign
declaration is submitted to the following process:
â€¢ifArgis a variable an instantiation error is raised.
â€¢ifArgis neither a variable nor an integer a type error(integer, Arg) is raised.
â€¢ifArgis an integer <0 adomain error(not less than zero, Arg) is raised.
â€¢otherwise the value of Argis passed to the C is passed to the C function as an integer ( PlLong ).
When +string is specied the string passed to the function is the internal string of the corresponding
atom and should not be modied.
When +term is specied the term passed to the function is the original Prolog term. It can be read
and/or unied. It is also the case when term is specied without any mode symbol.
10.3.5 Output arguments
An output argument is tested at run-time to check if its type conforms to the foreign type and it is unied
with the value set by the C function. The type of the associated C argument is a pointer to the type
given by the above table (section 10.3.2, page 202). For instance, the eective argument Argassociated
with -positive foreign declaration is handled as follows:
â€¢ifArgis neither a variable nor an integer a type error(integer, Arg) is raised.
â€¢ifArgis an integer <0 adomain error(not less than zero, Arg) is raised.
â€¢otherwise a pointer to an integer ( PlLong * ) is passed to the C function. If the function returns
PLTRUE the integer stored at this location is unied with Arg.
When -term is specied, the function must construct a term into the its corresponding argument (which
is of type PlTerm * ). At the exit of the function this term will be unied with the actual predicate
argument.
10.3 Calling C from Prolog 205
10.3.6 Input/output arguments
Basically an input/output argument is treated as in input argument if it is not a variable, as an output
argument otherwise. The type of the associated C argument is a pointer to a PlFIOArg (GNU Prolog C
type) dened as follows:
typedef struct
{
PlBool is_var;
PlBool unify;
union
{
PlLong l;
char *s;
double d;
}value;
}PlFIOArg;
The eld isvaris set to PLTRUE if the argument is a variable and PLFALSE otherwise. This value can
be tested by the C function to determine which treatment to perform. The eld unify controls whether
the eective argument must be unied at the exit of the C function. Initially unify is set to the same
value as isvar(i.e. a variable argument will be unied while a non-variable argument will not) but it
can be modied by the C function. The eld value stores the value of the argument. It is declared as a
Cunion since there are several kinds of value types. The eld sis used for C strings, dfor C doubles
and lotherwise ( int,PlLong ,PlTerm ). if isvarisPLFALSE then value contains the input value of
the argument with the same conventions as for input arguments (section 10.3.4, page 204). At the exit
of the function, if unify is PLTRUE value must contain the value to unify with the same conventions as
for output arguments (section 10.3.5, page 204).
For instance, the eective argument Argassociated with ?positive foreign declaration is handled as
follows:
â€¢ifArgis a variable isvarandunify are set to PLTRUE else to PLFALSE and its value is copied in
value.l .
â€¢ifArgis neither a variable nor an integer a type error(integer, Arg) is raised.
â€¢ifArgis an integer <0 adomain error(not less than zero, Arg) is raised.
â€¢otherwise a pointer to the PlFIOArg (PlFIOArg * ) is passed to the C function. If the function
returns PLTRUE and if unify isPLTRUE the value stored in value.l is unied with Arg.
10.3.7 Writing non-deterministic C code
The interface allows the user to write non-deterministic C code. When a C function is non-deterministic,
a choice-point is created for this function. When a failure occurs, if all more recent non-deterministic
code are nished, the function is re-invoked. It is then important to inform Prolog when there is no
more solution (i.e. no more choice) for a non-deterministic code. So, when no more choices remains
the function must remove the choice-point. The interface increments a counter each time the function
is re-invoked. At the rst call this counter is equal to 0. This information allows the function to detect
its rst call. When writing non-deterministic code, it is often useful to record data between consecutive
re-invocations of the function. The interface maintains a buer to record such an information. The size
of this buer is given by choice size(N) when using foreign/2 (section 10.3.2, page 202). This size is
the number of (consecutive) PlLong sneeded by the C function. Inside the function it is possible to call
the following functions/macros:
206 10 INTERFACING PROLOG AND C
int Pl_Get_Choice_Counter(void)
TYPE Pl_Get_Choice_Buffer (TYPE)
void Pl_No_More_Choice (void)
The macro PlGetChoice Counter() returns the value of the invocation counter (0 at the rst call).
The macro PlGetChoice Buffer( TYPE )returns a pointer to the buer (casted to TYPE ).
The function PlNoMore Choice() deletes the choice point associated with the function.
10.3.8 Example: input and output arguments
All examples presented here can be found in the ExamplesC sub-directory of the distribution, in the les
examp.pl (Prolog part) and examp c.c(C part).
Let us dene a predicate first occurrence(A, C, P) which unies Pwith the position (from 0) of the
rst occurrence of the character Cin the atom A. The predicate must fail if Cdoes not appear in A.
In the prolog le examp.pl :
:- foreign(first occurrence(+string, +char, -positive)).
In the C le examp c.c:
#include <string.h>
#include <gprolog.h>
PlBool
first_occurrence(char *str, PlLong c, PlLong *pos)
{
char *p;
p = strchr(str, c);
if (p == NULL) /* C does not appear in A */
return PL_FALSE; /* fail */
*pos = p - str; /* set the output argument */
return PL_TRUE; /* succeed */
}
The compilation produces an executable called examp :
% gplc examp.pl examp c.c
Examples of use:
| ?- first_occurrence(prolog, p, X).
X = 0
| ?- first_occurrence(prolog, k, X).
no
| ?- first_occurrence(prolog, A, X).
{exception: error(instantiation_error,first_occurrence/3)}
10.3 Calling C from Prolog 207
| ?- first_occurrence(prolog, 1 ,X).
{exception: error(type_error(character,1),first_occurrence/3)}
10.3.9 Example: non-deterministic code
We here dene a predicate occurrence(A, C, P) which unies Pwith the position (from 0) of one
occurrence of the character Cin the atom A. The predicate will fail if Cdoes not appear in A. The predicate
is re-executable on backtracking. The information that must be recorded between two invocations of the
function is the next starting position in Ato search for C.
In the prolog le examp.pl :
:- foreign(occurrence(+string, +char, -positive), [choice size(1)]).
In the C le examp c.c:
#include <string.h>
#include <gprolog.h>
PlBool
occurrence(char *str, PlLong c, PlLong *pos)
{
char **info_pos;
char *p;
info_pos = Pl_Get_Choice_Buffer(char **); /* recover the buffer */
if (Pl_Get_Choice_Counter() == 0) /* first invocation ? */
*info_pos = str;
p = strchr(*info_pos, c);
if (p == NULL) /* c does not appear */
{
Pl_No_More_Choice(); /* remove choice-point */
return PL_FALSE; /* fail */
}
*pos = p - str; /* set the output argument */
*info_pos = p + 1; /* update next starting pos */
return PL_TRUE; /* succeed */
}
The compilation produces an executable called examp :
% gplc examp.pl examp c.c
Examples of use:
208 10 INTERFACING PROLOG AND C
| ?- occurrence(prolog, o, X).
X = 2 ? (here the user presses ;to compute another solution)
X = 4 ? (here the user presses ;to compute another solution)
no (no more solution)
| ?- occurrence(prolog, k, X).
no
In the rst example when the second (the last) occurrence is found ( X=4) the choice-point remains and
the failure is detected only when another solution is requested (by pressing ;). It is possible to improve
this behavior by deleting the choice-point when there is no more occurrence. To do this it is necessary to
do one search ahead. The information stored is the position of the next occurrence. Let us dene such a
behavior for the predicate occurrence2/3 .
In the prolog le examp.pl :
:- foreign(occurrence2(+string, +char, -positive), [choice size(1)]).
In the C le examp c.c:
#include <string.h>
#include <gprolog.h>
PlBool
occurrence2(char *str, PlLong c, PlLong *pos)
{
char **info_pos;
char *p;
info_pos = Pl_Get_Choice_Buffer(char **); /* recover the buffer */
if (Pl_Get_Choice_Counter() == 0) /* first invocation ? */
{
p = strchr(str, c);
if (p == NULL) /* C does not appear at all */
{
Pl_No_More_Choice(); /* remove choice-point */
return PL_FALSE; /* fail */
}
*info_pos = p;
}
/* info_pos = an occurrence */
*pos = *info_pos - str; /* set the output argument */
p = strchr(*info_pos + 1, c);
if (p == NULL) /* no more occurrence */
Pl_No_More_Choice(); /* remove choice-point */
else
*info_pos = p; /* else update next solution */
return PL_TRUE; /* succeed */
}
10.3 Calling C from Prolog 209
Examples of use:
| ?- occurrence2(prolog, l, X).
X = 3 (here the user is not prompted since there is no more alternative)
| ?- occurrence2(prolog, o, X).
X = 2 ? (here the user presses ;to compute another solution)
X = 4 (here the user is not prompted since there is no more alternative)
10.3.10 Example: input/output arguments
We here dene a predicate char ascii(Char, Code ) which converts in both directions the character Char
and its character-code Code . This predicate is then similar to char code/2 (section 8.19.4, page 130).
In the prolog le examp.pl :
:- foreign(char ascii(?char, ?code)).
In the C le examp c.c:
#include <gprolog.h>
PlBool
char_ascii(PlFIOArg *c, PlFIOArg *ascii)
{
if (!c->is_var) /* Char is not a variable */
{
ascii->unify = PL_TRUE; /* enforce unif. of Code */
ascii->value.l = c->value.l; /* set Code */
return PL_TRUE; /* succeed */
}
if (ascii->is_var) /* Code is also a variable */
Pl_Err_Instantiation(); /* emit instantiation_error */
c->value.l = ascii->value.l; /* set Char */
return PL_TRUE; /* succeed */
}
IfChar is instantiated it is necessary to enforce the unication of Code since it could be instantiated.
Recall that by default if an input/output argument is instantiated it will not be unied at the exit
of the function (section 10.3.6, page 205). If both Char and Code are variables the function raises an
instantiation error . The way to raise Prolog errors is described later (section 10.5, page 217).
The compilation produces an executable called examp :
% gplc examp.pl examp c.c
Examples of use:
| ?- char_ascii(a, X).
X = 97
210 10 INTERFACING PROLOG AND C
| ?- char_ascii(X, 65).
X = 'A'
| ?- char_ascii(a, 12).
no
| ?- char_ascii(X, X).
{exception: error(instantiation_error,char_ascii/2)}
| ?- char_ascii(1, 12).
{exception: error(type_error(character,1),char_ascii/2)}
10.4 Manipulating Prolog terms
10.4.1 Introduction
In the following we presents a set of functions to manipulate Prolog terms. For simple foreign terms the
functions manipulate simple C types (section 10.3.2, page 202).
Functions managing lists handle an array of 2 elements (of type PlTerm ) containing the terms correspond-
ing to the head and the tail of the list. For the empty list NULL is passed as the array. These functions
require to atten a list in each sub-list. To simplify the management of proper lists (i.e. lists terminated
by[]) a set of functions is provided that handle the number of elements of the list (an integer) and an
array whose elements (of type PlTerm ) are the elements of the list. The caller of these functions must
provide the array.
Functions managing compound terms handle a functor (the principal functor of the term), an arity N
0 and an array of Nelements (of type PlTerm ) containing the sub-terms of the compound term. Since
a list is a special case of compound term (functor = '.'and arity=2) it is possible to use any function
managing compound terms to deal with a list but the error detection is not the same. Indeed many
functions check if the Prolog argument is correct. The name of a read or unify function checking the
Prolog arguments is of the form Name Check() . For each of these functions there is a also check-free
version called Name (). We then only present the name of checking functions.
10.4.2 Managing Prolog atoms
Each atom has a unique internal key (an integer) which corresponds to its index in the GNU Prolog atom
table. It is possible to obtain the information about an atom and to create new atoms using:
char *Pl_Atom_Name (int atom)
int Pl_Atom_Length (int atom)
PlBool Pl_Atom_Needs_Quote (int atom)
PlBool Pl_Atom_Needs_Scan (int atom)
PlBool Pl_Is_Valid_Atom (int atom)
int Pl_Create_Atom (const char *str)
int Pl_Create_Allocate_Atom(const char *str)
int Pl_Find_Atom (const char *str)
int Pl_Atom_Char (char c)
10.4 Manipulating Prolog terms 211
int Pl_Atom_Nil (void)
int Pl_Atom_False (void)
int Pl_Atom_True (void)
int Pl_Atom_End_Of_File (void)
The function PlAtom Name(atom) returns the internal string of atom (this string should not be modied).
The function PlAtom Length(atom) returns the length (of the name) of atom .
The function PlAtom Needs Scan(atom) indicates if the canonical form of atom needs to be quoted as
done by writeq/2 (section 8.14.6, page 108). In that case PlAtom Needs Scan(atom) indicates if this
simply comes down to write quotes around the name of atom or if it necessary to scan each character of
the name because there are some non-printable characters (or included quote characters). The function
PlIsValid Atom(atom) is true only if atom is the internal key of an existing atom.
The function PlCreate Atom(str) adds a new atom whose name is the content of strto the system
and returns its internal key. If the atom already exists its key is simply returned. The string strpassed
to the function should not be modied later. The function PlCreate Allocate Atom(str) is provided
when this condition cannot be ensured. It simply makes a dynamic copy of str(using strdup(3) ).
The function PlFind Atom(str) returns the internal key of the atom whose name is stror-1if it does
not exist.
All atoms corresponding to a single character already exist and their key can be obtained via the function
PlAtom Char . For instance PlAtom Char('.') is the atom associated with '.' (this atom is the
functor of lists). The other functions return the internal key of frequently used atoms: [],false ,true
andendoffile .
10.4.3 Reading Prolog terms
The name of all functions presented here are of the form PlRdName Check() . They all check the validity
of the Prolog term to read emitting appropriate errors if necessary. Each function has a check-free version
called PlRdName ().
Simple foreign types : for each simple foreign type (section 10.3.2, page 202) there is a read function
(used by the interface when an input argument is provided):
PlLong Pl_Rd_Integer_Check (PlTerm term)
PlLong Pl_Rd_Positive_Check (PlTerm term)
int Pl_Rd_C_Int_Check (PlTerm term)
int Pl_Rd_C_Int_Positive_Check(PlTerm term)
double Pl_Rd_Float_Check (PlTerm term)
double Pl_Rd_Number_Check (PlTerm term)
int Pl_Rd_Atom_Check (PlTerm term)
int Pl_Rd_Boolean_Check (PlTerm term)
int Pl_Rd_Char_Check (PlTerm term)
int Pl_Rd_In_Char_Check (PlTerm term)
int Pl_Rd_Code_Check (PlTerm term)
int Pl_Rd_In_Code_Check (PlTerm term)
int Pl_Rd_Byte_Check (PlTerm term)
int Pl_Rd_In_Byte_Check (PlTerm term)
char *Pl_Rd_String_Check (PlTerm term)
char *Pl_Rd_Chars_Check (PlTerm term)
char *Pl_Rd_Codes_Check (PlTerm term)
int Pl_Rd_Chars_Str_Check (PlTerm term, char *str)
212 10 INTERFACING PROLOG AND C
int Pl_Rd_Codes_Str_Check (PlTerm term, char *str)
The function PlRdCIntCheck() is similar to PlRdInteger Check() but returns a C intinstead of
aPlLong . If the Prolog integer does not t into a C int, arepresentation error is raised (this can
occur on 64-bits machine with inton 32-bits). Similarly for PlRdCIntPositive Check() .
All functions returning a C string ( char * ) use a same buer. The function PlRdChars StrCheck()
is similar to PlRdChars Check() but accepts as argument a string to store the result and returns the
length of that string (which is also the length of the Prolog list). Similarly for PlRdCodes StrCheck() .
Complex terms : the following functions return the sub-arguments (terms) of complex terms as an array
ofPlTerm except PlRdProper List Check() which returns the size of the list read (and initializes the
array element ). Refer to the introduction of this section for more information about the arguments of
complex functions (section 10.4.1, page 210).
int Pl_Rd_Proper_List_Check(PlTerm term, PlTerm *arg)
PlTerm *Pl_Rd_List_Check (PlTerm term)
PlTerm *Pl_Rd_Compound_Check (PlTerm term, int *functor, int *arity)
PlTerm *Pl_Rd_Callable_Check (PlTerm term, int *functor, int *arity)
10.4.4 Unifying Prolog terms
The name of all functions presented here are of the form PlUnName Check() . They all check the validity
of the Prolog term to unify emitting appropriate errors if necessary. Each function has a check-free version
called PlUnName ().
Simple foreign types : for each simple foreign type (section 10.3.2, page 202) there is an unify function
(used by the interface when an output argument is provided):
PlBool Pl_Un_Integer_Check (PlLong n, PlTerm term)
PlBool Pl_Un_Positive_Check(PlLong n, PlTerm term)
PlBool Pl_Un_Float_Check (double n, PlTerm term)
PlBool Pl_Un_Number_Check (double n, PlTerm term)
PlBool Pl_Un_Atom_Check (int atom, PlTerm term)
PlBool Pl_Un_Boolean_Check (int b, PlTerm term)
PlBool Pl_Un_Char_Check (int c, PlTerm term)
PlBool Pl_Un_In_Char_Check (int c, PlTerm term)
PlBool Pl_Un_Code_Check (int c, PlTerm term)
PlBool Pl_Un_In_Code_Check (int c, PlTerm term)
PlBool Pl_Un_Byte_Check (int b, PlTerm term)
PlBool Pl_Un_In_Byte_Check (int b, PlTerm term)
PlBool Pl_Un_String_Check (const char *str, PlTerm term)
PlBool Pl_Un_Chars_Check (const char *str, PlTerm term)
PlBool Pl_Un_Codes_Check (const char *str, PlTerm term)
The function PlUnNumber Check(n, term) unies term with an integer if nis an integer, with a oating
point number otherwise. The function PlUnString Check(str, term) creates the atom correspond-
ing to strand then unies term with it (same as PlUnAtom Check(Pl Create Allocate Atom(str),
term) ).
The following functions perform a general unication (between 2 terms). The second one performs a
occurs-check test (while the rst one does not).
PlBool Pl_Unif(PlTerm term1, PlTerm term2)
PlBool Pl_Unif_With_Occurs_Check(PlTerm term1, PlTerm term2)
10.4 Manipulating Prolog terms 213
Complex terms : the following functions accept the sub-arguments (terms) of complex terms as an
array of PlTerm . Refer to the introduction of this section for more information about the arguments of
complex functions (section 10.4.1, page 210).
PlBool Pl_Un_Proper_List_Check(int size, PlTerm *arg, PlTerm term)
PlBool Pl_Un_List_Check (PlTerm *arg, PlTerm term)
PlBool Pl_Un_Compound_Check (int functor, int arity, PlTerm *arg,
PlTerm term)
PlBool Pl_Un_Callable_Check (int functor, int arity, PlTerm *arg,
PlTerm term)
All these functions check the type of the term to unify and return the result of the unication. Generally
if an unication fails the C function returns PLFALSE to enforce a failure. However if there are several
arguments to unify and if an unication fails then the C function returns PLFALSE and the type of other
arguments has not been checked. Normally all error cases are tested before doing any work to be sure
that the predicate fails/succeeds only if no error condition is satised. So a good method is to check the
validity of all arguments to unify and later to do the unication (using check-free functions). Obviously
if there is only one to unify it is more ecient to use a unify function checking the argument. For the
other cases the interface provides a set of functions to check the type of a term.
Simple foreign types : for each simple foreign type (section 10.3.2, page 202) there is check-for-
unication function (used by the interface when an output argument is provided):
void Pl_Check_For_Un_Integer (PlTerm term)
void Pl_Check_For_Un_Positive(PlTerm term)
void Pl_Check_For_Un_Float (PlTerm term)
void Pl_Check_For_Un_Number (PlTerm term)
void Pl_Check_For_Un_Atom (PlTerm term)
void Pl_Check_For_Un_Boolean (PlTerm term)
void Pl_Check_For_Un_Char (PlTerm term)
void Pl_Check_For_Un_In_Char (PlTerm term)
void Pl_Check_For_Un_Code (PlTerm term)
void Pl_Check_For_Un_In_Code (PlTerm term)
void Pl_Check_For_Un_Byte (PlTerm term)
void Pl_Check_For_Un_In_Byte (PlTerm term)
void Pl_Check_For_Un_String (PlTerm term)
void Pl_Check_For_Un_Chars (PlTerm term)
void Pl_Check_For_Un_Codes (PlTerm term)
Complex terms : the following functions check the validity of complex terms:
void Pl_Check_For_Un_List (PlTerm term)
void Pl_Check_For_Un_Compound(PlTerm term)
void Pl_Check_For_Un_Callable(PlTerm term)
void Pl_Check_For_Un_Variable(PlTerm term)
The function PlCheck ForUnList(term) checks if term can be unied with a list. This test is done
for the entire list (not only for the functor/arity of term but also recursively on the tail of the list).
The function PlCheck ForUnVariable(term) ensures that term is not currently instantiated. These
functions can be dened using functions to test the type of a Prolog term (section 10.4.6, page 214) and
functions to raise Prolog errors (section 10.5, page 217). For instance PlCheck ForUnList(term) is
dened as follows:
void Pl_Check_For_Un_List(PlTerm term)
{
if (!Pl_Builtin_List_Or_Partial_List(term))
Pl_Err_Type(type_list, term);
}
214 10 INTERFACING PROLOG AND C
10.4.5 Creating Prolog terms
These functions are provided to creates Prolog terms. Each function returns a PlTerm containing the
created term.
Simple foreign types : for each simple foreign type (section 10.3.2, page 202) there is a creation function:
PlTerm Pl_Mk_Integer (PlLong n)
PlTerm Pl_Mk_Positive(PlLong n)
PlTerm Pl_Mk_Float (double n)
PlTerm Pl_Mk_Number (double n)
PlTerm Pl_Mk_Atom (int atom)
PlTerm Pl_Mk_Boolean (int b)
PlTerm Pl_Mk_Char (int c)
PlTerm Pl_Mk_In_Char (int c)
PlTerm Pl_Mk_Code (int c)
PlTerm Pl_Mk_In_Code (int c)
PlTerm Pl_Mk_Byte (int b)
PlTerm Pl_Mk_In_Byte (int b)
PlTerm Pl_Mk_String (const char *str)
PlTerm Pl_Mk_Chars (const char *str)
PlTerm Pl_Mk_Codes (const char *str)
The function PlMkNumber(n, term) initializes term with an integer if nis an integer, with a oating
point number otherwise. The function PlMkString(str) rst creates an atom corresponding to str
and then returns that Prolog atom (i.e. equivalent to PlMkAtom(Pl Create Allocate Atom(str)) ).
Complex terms : the following functions accept the sub-arguments (terms) of complex terms as an
array of PlTerm . Refer to the introduction of this section for more information about the arguments of
complex functions (section 10.4.1, page 210).
PlTerm Pl_Mk_Proper_List(int size, const PlTerm *arg)
PlTerm Pl_Mk_List (PlTerm *arg)
PlTerm Pl_Mk_Compound (int functor, int arity, const PlTerm *arg)
PlTerm Pl_Mk_Callable (int functor, int arity, const PlTerm *arg)
10.4.6 Testing the type of Prolog terms
The following functions test the type of a Prolog term. Each function corresponds to a type testing
built-in predicate (section 8.1.1, page 55).
PlBool Pl_Builtin_Var (PlTerm term)
PlBool Pl_Builtin_Non_Var (PlTerm term)
PlBool Pl_Builtin_Atom (PlTerm term)
PlBool Pl_Builtin_Integer (PlTerm term)
PlBool Pl_Builtin_Float (PlTerm term)
PlBool Pl_Builtin_Number (PlTerm term)
PlBool Pl_Builtin_Atomic (PlTerm term)
PlBool Pl_Builtin_Compound (PlTerm term)
PlBool Pl_Builtin_Callable (PlTerm term)
PlBool Pl_Builtin_List (PlTerm term)
PlBool Pl_Builtin_Partial_List (PlTerm term)
PlBool Pl_Builtin_List_Or_Partial_List(PlTerm term)
PlBool Pl_Builtin_Fd_Var (PlTerm term)
10.4 Manipulating Prolog terms 215
PlBool Pl_Builtin_Non_Fd_Var (PlTerm term)
PlBool Pl_Builtin_Generic_Var (PlTerm term)
PlBool Pl_Builtin_Non_Generic_Var (PlTerm term)
int Pl_Type_Of_Term (PlTerm term)
PlLong Pl_List_Length (PlTerm list)
The function PlType OfTerm(term) returns the type of term , the following constants can be used to
test this type (e.g. in a switch instruction):
â€¢PLPLV: Prolog variable.
â€¢PLFDV: nite domain variable.
â€¢PLINT: integer.
â€¢PLFLT: oating point number.
â€¢PLATM: atom.
â€¢PLLST: list.
â€¢PLSTC: structure
The tag PLLSTmeans a term whose principal functor is '.'and whose arity is 2 (recall that the empty
list is the atom []). The tag PLSTCmeans any other compound term.
The function PlList Length(list) returns the number of elements of the list (0for the empty list).
If list is not a list this function returns -1.
10.4.7 Comparing Prolog terms
The following functions compares Prolog terms. Each function corresponds to a comparison built-in
predicate (section 8.3.2, page 57).
PlBool Pl_Builtin_Term_Eq (PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Neq(PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Lt (PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Lte(PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Gt (PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Gte(PlTerm term1, PlTerm term2)
All these functions are based on a general comparison function returning a negative integer if term1 is
less than term2 , 0 if they are equal and a positive integer otherwise:
PlLong Term_Compare(PlTerm term1, PlTerm term2)
Finally, the following function gives an access to the compare/3 built-in (section 8.3.3, page 58) unifying
cmpwith the atom <,=or>depending on the result of the comparison of term1 andterm2 .
PlBool Pl_Builtin_Compare(PlTerm cmp, PlTerm term1, PlTerm term2)
10.4.8 Term processing
The following functions give access to the built-in predicates: functor/3 (section 8.4.1, page 59), arg/3
(section 8.4.2, page 59) and (=..)/2 (section 8.4.3, page 60).
216 10 INTERFACING PROLOG AND C
PlBool Pl_Builtin_Functor(PlTerm term, PlTerm functor, PlTerm arity)
PlBool Pl_Builtin_Arg(PlTerm arg_no, PlTerm term, PlTerm sub_term)
PlBool Pl_Builtin_Univ(PlTerm term, PlTerm list)
The following functions make a copy of a Prolog term:
void Pl_Copy_Term (PlTerm *dst_term, const PlTerm *src_term)
void Pl_Copy_Contiguous_Term(PlTerm *dst_term, const PlTerm *src_term)
int Pl_Term_Size (PlTerm term)
The function PlCopy Term(dst term, src term) makes a copy of the term located at srcterm and
stores it from the address given by dstterm . The result is a contiguous term. If it can be ensured that the
source term is a contiguous term (i.e. result of a previous copy) the function PlCopy Contiguous Term()
can be used instead (it is faster). In any case, sucient space should be available for the copy (i.e. from
dstterm ). The function PlTerm Size(term) returns the number of PlTerm needed by term .
The following function is an utility to display a term to the console, similarly to the built-in predicate
write/1 (section 8.14.6, page 108).
void Pl_Write(PlTerm term)
This PlWrite function can be used for debugging purpose. However, it is more exible to receive the
content of the write/1 as a C string. This can be achieved by the following functions (using repectively
write/1 ,writeq/1 ,write canonical/1 and display/1 (section 8.14.6, page 108) to obtain a textual
representation of the term). These functions return a dynamically allocated C string (using malloc(3) )
which can be freed by the user when no longer needed.
char *Pl_Write_To_String(PlTerm term)
char *Pl_Writeq_To_String(PlTerm term)
char *Pl_Write_Canonical_To_String(PlTerm term)
char *Pl_Display_To_String(PlTerm term)
Finally the following function performs the opposite converstion: given a C string it returns the associated
Prolog term. It uses read term/2 (section 8.14.1, page 104) with the option endofterm(eof) (thus the
C string does not need to terminate by a dot).
PlTerm Pl_Read_From_String(const char *str)
10.4.9 Comparing and evaluating arithmetic expressions
The following functions compare arithmetic expressions. Each function corresponds to a comparison
built-in predicate (section 8.6.3, page 69).
PlBool Pl_Builtin_Eq (PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Neq(PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Lt (PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Lte(PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Gt (PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Gte(PlTerm expr1, PlTerm expr2)
The following function evaluates the expression expr and stores its result as a Prolog number (integer or
oating point number) in result :
void Pl_Math_Evaluate(PlTerm expr, PlTerm *result)
This function can be followed by a read function (section 10.4.3, page 211) to obtain the result.
10.5 Raising Prolog errors 217
10.5 Raising Prolog errors
The following functions allows a C function to raise a Prolog error. Refer to the section concerning Prolog
errors for more information about the eect of raising an error (section 6.3, page 39).
10.5.1 Managing the error context
When one of the following error function is invoked it refers to the implicit error context (section 6.3.1,
page 39). This context indicates the name and the arity of the concerned predicate. When using a
foreign/2 declaration this context is set by default to the name and arity of the associated Prolog
predicate. This can be controlled using the bipname option (section 10.3.2, page 202). In any case, the
following functions can also be used to modify this context:
void Pl_Set_C_Bip_Name (const char *functor, int arity)
void Pl_Unset_C_Bip_Name(void)
The function PlSetCBipName(functor, arity) initializes the context of the error with functor and
arity (ifarity<0 only functor is signicant). The function PlUnset CBipName() removes such
an initialization (the context is then reset to the last Functor /Arity set by a call to setbipname/2
(section 8.22.3, page 151). This is useful when writing a C routine to dene a context for errors occurring
in this routine and, before exiting to restore the previous context.
10.5.2 Instantiation error
The following function raises an instantiation error (section 6.3.2, page 39):
void Pl ErrInstantiation(void)
10.5.3 Uninstantiation error
The following function raises an uninstantiation error (section 6.3.3, page 40):
void Pl ErrUninstantiation( PlTerm culprit)
10.5.4 Type error
The following function raises a type error (section 6.3.4, page 40):
void Pl ErrType(int atom type, PlTerm culprit)
atom type is (the internal key of) the atom associated with the expected type. For each type name T
there is a corresponding predened atom stored in a global variable whose name is of the form pltype T.
culprit is the argument which caused the error.
Example :xis an atom while an integer was expected: PlErrType(pl type integer, x) .
10.5.5 Domain error
The following function raises a domain error (section 6.3.5, page 40):
218 10 INTERFACING PROLOG AND C
void Pl ErrDomain(int atom domain, PlTerm culprit)
atom domain is (the internal key of) the atom associated with the expected domain. For each domain
name Dthere is a corresponding predened atom stored in a global variable whose name is of the form
domain D.culprit is the argument which caused the error.
Example :xis<0 but should be0:PlErrDomain(pl domain notless than zero, x) .
10.5.6 Existence error
The following function raises an existence error (section 6.3.6, page 41):
void Pl ErrExistence(int atom object, PlTerm culprit)
atom object is (the internal key of) the atom associated with the type of the object. For each object
name Othere is a corresponding predened atom stored in a global variable whose name is of the form
plexistence O.culprit is the argument which caused the error.
Example :xdoes not refer to an existing source: PlErrExistence(pl existence source sink, x) .
10.5.7 Permission error
The following function raises a permission error (section 6.3.7, page 41):
void Pl ErrPermission(int atom operation, int atom permission, PlTerm culprit)
atom operation is (the internal key of) the atom associated with the operation which caused the error.
For each operation name Othere is a corresponding predened atom stored in a global variable whose
name is of the form plpermission operation O.atom permission is (the internal key of) the atom
associated with the tried permission. For each permission name Pthere is a corresponding predened
atom stored in a global variable whose name is of the form plpermission type P.culprit is the
argument which caused the error.
Example : reading from an output stream x:PlErrPermission(pl permission operation input,
plpermission type stream, x) .
10.5.8 Representation error
The following function raises a representation error (section 6.3.8, page 41):
void Pl ErrRepresentation(int atom limit)
atom limit is (the internal key of) the atom associated with the reached limit. For each limit name
Lthere is a corresponding predened atom stored in a global variable whose name is of the form
plrepresentation L.
Example : an arity too big occurs: PlErrRepresentation(pl representation maxarity) .
10.5.9 Evaluation error
The following function raises an evaluation error (section 6.3.9, page 42):
10.5 Raising Prolog errors 219
void Pl ErrEvaluation(int atom error)
atom error is (the internal key of) the atom associated with the error. For each evaluation error
name Ethere is a corresponding predened atom stored in a global variable whose name is of the form
plevaluation E.
Example : a division by zero occurs: PlErrEvaluation(pl evaluation zero divisor) .
10.5.10 Resource error
The following function raises a resource error (section 6.3.10, page 42):
void Pl ErrResource(int atom resource)
atom resource is (the internal key of) the atom associated with the resource. For each resource error
name Rthere is a corresponding predened atom stored in a global variable whose name is of the form
plresource R.
Example : too many open streams: PlErrResource(pl resource toomany open streams) .
10.5.11 Syntax error
The following function raises a syntax error (section 6.3.11, page 42):
void Pl ErrSyntax(int atom error)
atom error is (the internal key of) the atom associated with the error. There is no predened syntax
error atoms.
Example : a/is expected: PlErrSyntax(Pl Create Atom("/ expected")) .
The following function emits a syntax error according to the value of the syntax error Prolog ag
(section 8.22.1, page 148). This function can then return (if the value of the ag is either warning or
fail ). In that case the calling function should fail (e.g. returning PLFALSE ). This function accepts
a le name (the empty string C ""can be passed), a line and column number and an error message
string. Using this function makes it possible to further call the built-in predicate syntax error info/4
(section 8.14.4, page 107):
void Pl Emit Syntax Error(char *file name, int line, int column, char *message)
Example : a/is expected: PlEmit Syntax Error("data", 10, 30, "/ expected") .
10.5.12 System error
The following function raises a system error (4.3.11, page *):
void Pl ErrSystem(int atom error)
atom error is (the internal key of) the atom associated with the error. There is no predened system
error atoms.
Example : an invalid pathname is given: PlErrSystem(Pl Create Atom("invalid path name")) .
220 10 INTERFACING PROLOG AND C
The following function emits a system error associated with an operating system error according to the
value of the oserror Prolog ag (section 8.22.1, page 148). This function can then return (if the value of
the ag is either warning orfail ). In that case the calling function should fail (e.g. returning PLFALSE ).
The following function uses the value of the errno C library variable (basically it calls PlErrSystem
with the result of strerror(errno) ).
void Pl OsError(void)
Example : if a call to the C Unix function chdir(2) returns -1then call OsError() .
10.6 Calling Prolog from C
10.6.1 Introduction
The following functions allows a C function to call a Prolog predicate:
void Pl_Query_Begin (PlBool recoverable)
int Pl_Query_Call (int functor, int arity, PlTerm *arg)
int Pl_Query_Start (int functor, int arity, PlTerm *arg,
PlBool recoverable)
int Pl_Query_Next_Solution(void)
void Pl_Query_End (int op)
PlTerm Pl_Get_Exception (void)
void Pl_Exec_Continuation (int functor, int arity, PlTerm *arg)
void Pl_Throw (PlTerm ball)
The invocation of a Prolog predicate should be done as follows:
â€¢open a query using PlQuery Begin()
â€¢compute the rst solution using PlQuery Call()
â€¢eventually compute next solutions using PlQuery Next Solution()
â€¢close the query using PlQuery End()
The function PlQuery Begin(recoverable) is used to initialize a query. The argument recoverable
shall be set to PLTRUE if the user wants to recover, at the end of the query, the memory space consumed
by the query (in that case an additional choice-point is created). All terms created in the heap, e.g. using
PlMk...family functions (section 10.4.5, page 214), after the invocation of PlQuery Begin() can be
recovered when calling PlQuery End(PL TRUE) (see below).
The function PlQuery Call(functor, arity, arg) calls a predicate passing arguments. It is then
used to compute the rst solution. The arguments functor ,arity and argare similar to those of the
functions handling complex terms (section 10.4.1, page 210). This function returns:
â€¢PLFAILURE (a constant equal to PLFALSE , i.e. 0) if the query fails.
â€¢PLSUCCESS (a constant equal to PLTRUE , i.e. 1) in case of success. In that case the argument array
argcan be used to obtain the unication performed by the query.
â€¢PLEXCEPTION (a constant equal to 2). In that case function PlGetException() can be used to
obtained the exceptional term raised by throw/1 (section 7.2.4, page 53).
10.6 Calling Prolog from C 221
The function PlQuery Start(functor, arity, arg, recoverable) is a shorthand equivalent to a call
toPlQuery Begin(recoverable) followed by a call to PlQuery Call(functor, arity, arg) .
The function PlQuery Next Solution() is used to compute a new solution. It must be only used if
the result of the previous solution was PLSUCCESS . This functions returns the same kind of values as
PlQuery Call() (see above).
The function PlQuery End(op) is used to nish a query. This function mainly manages the remaining
alternatives of the query. However, even if the query has no alternatives this function must be used to
correctly nish the query. The value of opis:
â€¢PLRECOVER : to recover the memory space consumed by the query. After that the state of Prolog
stacks is exactly the same as before opening the query. To use this option the query must have
been initialized specifying PLTRUE forrecoverable (see above).
â€¢PLCUT: to cut remaining alternatives. The eect of this option is similar to a cut after the query.
â€¢PLKEEP FORPROLOG : to keep the alternatives for Prolog. This is useful when the query was invoked
in a foreign C function. In that case, when the predicate corresponding to the C foreign function
is invoked a query is executed and the remaining alternatives are then available as alternatives of
that predicate.
Note that several queries can be nested since a stack of queries is maintained. For instance, it is possible
to call a query and before terminating it to call another query. In that case the rst execution of
PlQuery End() will nish the second query (i.e. the inner) and the next execution of PlQuery End()
will nish the rst query.
The function PlExec Continuation(functor, arity, arg) replaces the current calculus by the exe-
cution of the specied predicate. The arguments functor ,arity and argare similar to those of the
functions handling complex terms (section 10.4.1, page 210).
Finally the function PlThrow(ball) throws an exception. See the throw/1 control construct for more
information on exceptions (section 7.2.4, page 53). Note that PlThrow(ball) is logically equivalent (but
faster) to PlExec Continuation(Pl Find Atom("throw"), 1, &ball) .
10.6.2 Example: mycall/1 - acall/1 clone
We here dene a predicate mycall(Goal) which acts like call(Goal) except that we do not handle
exceptions (if an exception occurs the goal simply fails):
In the prolog le examp.pl :
:- foreign(my call(term)).
In the C le examp c.c:
#include <string.h>
#include <gprolog.h>
PlBool
my_call(PlTerm goal)
{
PlTerm *arg;
int functor, arity;
222 10 INTERFACING PROLOG AND C
int result;
arg = Pl_Rd_Callable_Check(goal, &functor, &arity);
Pl_Query_Begin(PL_FALSE);
result = Pl_Query_Call(functor, arity, arg);
Pl_Query_End(PL_KEEP_FOR_PROLOG);
return (result == PL_SUCCESS);
}
The compilation produces an executable called examp :
% gplc examp.pl examp c.c
Examples of use:
| ?- my call(write(hello)).
hello
| ?- my call(for(X,1,3)).
X = 1 ? (here the user presses ;to compute another solution)
X = 2 ? (here the user presses ;to compute another solution)
X = 3 (here the user is not prompted since there is no more alternative)
| ?- my call(1).
{exception: error(type error(callable,1),my call/1)}
| ?- my call(call(1)).
no
When mycall(1) is called an error is raised due to the use of PlRdCallable Check() . However the
error raised by mycall(call(1)) is ignored and PLFALSE (i.e. a failure) is returned by the foreign
function.
To really simulate the behavior of call/1 when an exception is recovered it should be re-raised to be
captured by an earlier handler. The idea is then to execute a throw/1 as the continuation. This is what
it is done by the following code:
#include <string.h>
#include <gprolog.h>
PlBool
my_call(PlTerm goal)
{
PlTerm *args;
int functor, arity;
int result;
args = Pl_Rd_Callable_Check(goal, &functor, &arity);
Pl_Query_Begin(PL_FALSE);
result = Pl_Query_Call(functor, arity, args);
Pl_Query_End(PL_KEEP_FOR_PROLOG);
if (result == PL_EXCEPTION)
{
10.6 Calling Prolog from C 223
PlTerm except = Pl_Get_Exception();
Pl_Throw(except);
// equivalent to Pl_Exec_Continuation(Find_Atom("throw"), 1, &except);
}
return result;
}
The following code propagates the error raised by call/1 .
| ?- my call(call(1)).
{exception: error(type error(callable,1),my call/1)}
Finally note that a simpler way to dene mycall/1 is to use PlExec Continuation() as follows:
#include <string.h>
#include <gprolog.h>
PlBool
my_call(PlTerm goal)
{
PlTerm *args;
int functor, arity;
args = Pl_Rd_Callable_Check(goal, &functor, &arity);
Pl_Exec_Continuation(functor, arity, args);
return PL_TRUE;
}
10.6.3 Example: recovering the list of all operators
We here dene a predicate allop(List) which unies List with the list of all currently dened operators
as would be done by: findall(X,current op(,,X),List) .
In the prolog le examp.pl :
:- foreign(all op(term)).
In the C le examp c.c:
#include <string.h>
#include <gprolog.h>
PlBool
all_op(PlTerm list)
{
PlTerm op[1024];
PlTerm args[3];
int n = 0;
int result;
Pl_Query_Begin(PL_TRUE);
args[0] = Pl_Mk_Variable();
args[1] = Pl_Mk_Variable();
args[2] = Pl_Mk_Variable();
result = Pl_Query_Call(Find_Atom("current_op"), 3, args);
224 10 INTERFACING PROLOG AND C
while (result)
{
op[n++] = Pl_Mk_Atom(Pl_Rd_Atom(args[2])); /* arg[2]: the name of the op */
result = Pl_Query_Next_Solution();
}
Pl_Query_End(PL_RECOVER);
return Pl_Un_Proper_List_Check(n, op, list);
}
Note that we know here that there is no source for exception. In that case the result of PlQuery Call
andPlQuery Next Solution can be considered as a boolean.
The compilation produces an executable called examp :
% gplc examp.pl examp c.c
Example of use:
| ?- all_op(L).
L = [:-,:-,\=,=:=,#>=,#<#,@>=,-->,mod,#>=#,**,*,+,+,',',...]
| ?- findall(X,current_op(_,_,X),L).
L = [:-,:-,\=,=:=,#>=,#<#,@>=,-->,mod,#>=#,**,*,+,+,',',...]
10.7 Dening a new C main() function
GNU Prolog allows the user to dene his own main() function. This can be useful to perform several
tasks before starting the Prolog engine. To do this simply dene a classical main(argc, argv) function.
The following functions can then be used:
int Pl_Start_Prolog (int argc, char *argv[])
void Pl_Stop_Prolog (void)
void Pl_Reset_Prolog (void)
PlBool Pl_Try_Execute_Top_Level(void)
The function PlStart Prolog(argc, argv) initializes the Prolog engine ( argc andargv are the command-
line variables). This function collects all linked objects (issued from the compilation of Prolog les) and
initializes them. The initialization of a Prolog object le consists in adding to appropriate tables new
atoms, new predicates and executing its system directives. A system directive is generated by the Prolog
to WAM compiler to reect a (user) directive executed at compile-time such as op/3 (section 7.1.11,
page 49). Indeed, when the compiler encounters such a directive it immediately executes it and also
generates a system directive to execute it at the start of the executable. When all system directives have
been executed the Prolog engine executes all initialization directives dened with initialization/1
(section 7.1.14, page 50). The function returns the number of user directives (i.e. initialization/1 )
executed. This function must be called only once.
The function PlStop Prolog() stops the Prolog engine. This function must be called only once after
all Prolog treatment have been done.
The function PlReset Prolog() reinitializes the Prolog engine (i.e. reset all Prolog stacks).
The function PlTryExecute TopLevel() executes the top-level if linked (section 4.4.3, page 23) and
returns PLTRUE . If the top-level is not present the functions returns PLFALSE .
10.7 Dening a new C main() function 225
Here is the denition of the default GNU Prolog main() function:
static int
Main_Wrapper(int argc, char *argv[])
{
int nb_user_directive;
PlBool top_level;
nb_user_directive = Pl_Start_Prolog(argc, argv);
top_level = Pl_Try_Execute_Top_Level();
Pl_Stop_Prolog();
if (top_level || nb_user_directive)
return 0;
fprintf(stderr,
"Warning: no initial goal executed\n"
" use a directive :- initialization(Goal)\n"
" or remove the link option --no-top-level"
" (or --min-bips or --min-size)\n");
return 1;
}
int
main(int argc, char *argv[])
{
return Main_Wrapper(argc, argv);
}
Note that under some circumstances it is necessary to encapsulate the code of main() inside an intermedi-
ate function called by main() . Indeed, some C compilers (e.g. gcc) treats main() particularly, producing
an incompatible code w.r.t GNU Prolog. So it is a good idea to always use a wrapper function as shown
above.
10.7.1 Example: asking for ancestors
In this example we use the following Prolog code (in a le called newmain.pl ):
parent(bob, mary).
parent(jane, mary).
parent(mary, peter).
parent(paul, peter).
parent(peter, john).
anc(X, Y):-
parent(X, Y).
anc(X, Z) :-
parent(X, Y),
anc(Y, Z).
226 10 INTERFACING PROLOG AND C
The following le (called newmain c.c) denes a main() function read the name of a person and dis-
playing all successors of that person. This is equivalent to the Prolog query: anc(Result, Name) .
static int
Main_Wrapper(int argc, char *argv[])
{
int func;
PlTerm arg[10];
char str[100];
char *sol[100];
int i, nb_sol = 0;
PlBool res;
Pl_Start_Prolog(argc, argv);
func = Pl_Find_Atom("anc");
for (;;)
{
printf("\nEnter a name (or 'end' to finish): ");
fflush(stdout);
scanf("%s", str);
if (strcmp(str, "end") == 0)
break;
Pl_Query_Begin(PL_TRUE);
arg[0] = Pl_Mk_Variable();
arg[1] = Pl_Mk_String(str);
nb_sol = 0;
res = Pl_Query_Call(func, 2, arg);
while (res)
{
sol[nb_sol++] = Pl_Rd_String(arg[0]);
res = Pl_Query_Next_Solution();
}
Pl_Query_End(PL_RECOVER);
for (i = 0; i < nb_sol; i++)
printf(" solution: %s\n", sol[i]);
printf("%d solution(s)\n", nb_sol);
}
Pl_Stop_Prolog();
return 0;
}
int
main(int argc, char *argv[])
{
return Main_Wrapper(argc, argv);
}
The compilation produces an executable called newmain :
% gplc new main.pl new main c.c
10.7 Dening a new C main() function 227
Examples of use:
Enter a name (or 'end' to finish): john
solution: peter
solution: bob
solution: jane
solution: mary
solution: paul
5 solution(s)
Enter a name (or 'end' to finish): mary
solution: bob
solution: jane
2 solution(s)
Enter a name (or 'end' to finish): end
228 10 INTERFACING PROLOG AND C
REFERENCES 229
References
[1] H. A t-Kaci. \Warren's Abstract Machine, A Tutorial Reconstruction".
Logic Programming Series, MIT Press, 1991.
http://web.archive.org/web/20071225092145/www.vanx.org/archive/wam/wam.html
[2] W.F. Clocksin and C.S. Mellish. Programming in Prolog, Springer-Verlag, 1981.
[3] P. Codognet and D. Diaz. \ wamcc : Compiling Prolog to C".
In12th International Conference on Logic Programming , Tokyo, Japan, MIT Press, 1995.
http://cri-dist.univ-paris1.fr/diaz/publications/WAMCC/iclp95.pdf
[4] P. Codognet and D. Diaz. \Compiling Constraint in clp(FD) ".
Journal of Logic Programming , Vol. 27, No. 3, June 1996.
http://cri-dist.univ-paris1.fr/diaz/publications/CLP-FD/jlp96.pdf
[5] D. Diaz and P. Codognet. \Design and Implementation of the GNU Prolog System".
Journal of Functional and Logic Programming , Vol. 2001, No. 6, October 2001.
http://cri-dist.univ-paris1.fr/diaz/publications/GNU-PROLOG/jp01.pdf
[6] Information technology - Programming languages - Prolog - Part 1: General Core.
ISO/IEC 13211-1, 1995.
[7] J. Jaar and J-L. Lassez. \Constraint Logic Programming".
InPrinciples Of Programming Languages , Munich, Germany, January 1987.
[8] P. Van Hentenryck. \Constraint Satisfaction in Logic Programming".
Logic Programming Series, The MIT Press, 1989.
[9] D. H. D. Warren. \An Abstract Prolog Instruction Set".
Technical Report 309, SRI International, Oct. 1983.
230 REFERENCES
INDEX 231
Index
!/0,51, 52
'.'/2 ,153
(',')/2 ,51
(*->)/2 ,51
(-->)/2 ,123
(->)/2 ,51
(;)/2 ,51
(=)/2 ,56
(=..)/2 ,60
(=:=)/2 ,69
(==)/2 ,57, 136
(=<)/2 ,69
(=\=)/2 ,69
(@=<)/2 ,57
(@<)/2 ,57
(@>)/2 ,57
(@>=)/2 ,57
(#/\)/2 (FD), 193
(#=)/2 (FD), 189
(#==>)/2 (FD), 193
(#=#)/2 (FD), 190
(#=<)/2 (FD), 189
(#=<#)/2 (FD), 190
(##)/2 (FD), 193
(#<)/2 (FD), 189
(#<=>)/2 (FD), 193
(#<#)/2 (FD), 190
(#>)/2 (FD), 189
(#>=)/2 (FD), 189
(#>=#)/2 (FD), 190
(#>#)/2 (FD), 190
(#\)/1 (FD), 193
(#\/)/2 (FD), 193
(#\/\)/2 (FD), 193
(#\=)/2 (FD), 189
(#\==>)/2 (FD), 193
(#\=#)/2 (FD), 190
(#\<=>)/2 (FD), 193
(#\\/)/2 (FD), 193
(is)/2 ,69
(<)/2 ,69
(>)/2 ,69
(>=)/2 ,69
(\+)/1 ,126
(\=)/2 ,57
(\==)/2 ,57
--,13
--assembly ,23
--aux-father ,29
--aux-father2 ,29
--c-compiler ,24--cmd-line ,29
--comment ,24, 24
--compile-msg ,24
--consult-file ,13
--cstr-size ,25
--decode ,29
--demangling ,29
--encode ,29
--entry-goal ,13
--fast-math ,24, 68
--fd-to-c ,23
--fixed-sizes , 21,25
--foreign-only ,24
--global-size ,25
--gui-console ,25
--help ,13,23,29
--init-goal ,13, 28
--keep-void-inst ,24
--linker ,25
--local-size , 21,25
--mangling ,29
--max-atom ,25
--min-bips ,25
--min-fd-bips ,25
--min-pl-bips ,25
--min-reg-opt ,24
--min-size ,25
--mini-assembly ,23
--new-top-level ,25, 28
--no-call-c ,24
--no-debugger ,25, 25
--no-del-temp ,23
--no-demangling ,23
--no-fd-lib ,25
--no-inline ,24
--no-opt-last-subterm ,24
--no-redef-error ,24
--no-reg-opt ,24
--no-reorder ,24
--no-singl-warn ,24
--no-susp-warn ,24
--no-top-level ,25
--object ,23
--output ,23
--pic , 24
--pl-state ,24, 152
--printf ,29
--query-goal ,13
--relax ,29
--statistics ,24
--strip ,25
232 INDEX
--temp-dir ,23
--trail-size ,25
--verbose ,23
--version ,13,23,29
--wam-comment ,24
--wam-for-byte-code ,23
--wam-for-native ,23
-A,24
-C,24
-D,29
-E,29
-F,23
-L,25
-M,23,29
-P,29
-S,23
-W,23
-c,23
-h,23
-o,23
-s,25
-v,23
-w,23
abolish/1 ,73
abort/0 , 18, 34, 126
absolute file name (property), 165
absolute file name/2 , 48, 81, 153, 154, 158,
159, 160, 162{167
acyclic term/1 ,61
addlinedit completion/1 ,181
addstream alias/2 , 78,90
addstream mirror/2 , 79,91
address bits (ag), 149
alias (option), 81
alias (property), 84
append (mode), 81
append/1 ,121
append/3 ,135
arch (ag), 149
architecture/1 ,168
arg/3 ,59
argument selector, 142
argument counter/1 ,160
argument list/1 , 14,161
argument value/2 , 14,160
argv (ag), 149
asserta/1 ,71
assertz/1 ,71
atendofstream/0 ,85
atendofstream/1 ,85
atom/1 ,55
atom chars/2 ,131
atom codes/2 ,131atom concat/3 ,129
atom length/2 ,129
atom property/2 ,134
atomic/1 ,55
back quotes (ag), 14, 104, 150, 152
back quotes (token), 106
backtracks (FD option), 199
bagof/3 ,77
between/3 ,128
binary (option), 81, 92
bind variables/2 ,64
bipname (option), 203, 217
bisect (FD option), 198
block (option), 82, 93
block device (permission), 165
bof (whence), 87
boolean (option), 202, 204
bounded (ag), 149
bounds (FD option), 198
break/0 , 18, 34, 126
buffering (option), 81
buffering (property), 84
built in(property), 48, 75
built in/0 (directive), 47
built in/1 (directive), 47
built infd(property), 48, 75
built infd/0 (directive), 47
built infd/1 (directive), 47
ccc(ag), 149
cccversion data (ag), 149
ccflags (ag), 149
cldflags (ag), 149
call/1 ,52
call/2-11 ,126
call det/2 ,126
call with args/1-11 ,126
callable/1 ,55
catch/3 , 31, 39, 53
change directory/1 ,162
char code/2 ,130, 209
char conversion (ag), 104, 116, 150, 152
char conversion/2 (directive), 49
char conversion/2 , 50,116
character count/2 ,87
character device (permission), 165
choice size (option), 203, 205
clause/2 ,73
close/1 ,82
close/2 ,82, 171, 177
close input atom stream/1 ,95
close input chars stream/1 ,95
close input codes stream/1 ,95
close output atom stream/2 ,96
INDEX 233
close output chars stream/2 ,96
close output codes stream/2 ,96
compare/3 ,58
compiled at(ag), 149
completion, 19, 181
compound/1 ,55
consult/1 , 17, 21, 23, 153
control constructs, 51
control construct (property), 75
copy term/2 ,60
cputime/1 ,155
create pipe/2 ,172
current (whence), 87
current alias/2 ,90
current atom/1 ,134
current bipname/2 , 39,151
current char conversion/2 ,116
current input/1 ,79
current mirror/2 ,92
current op/3 ,115
current output/1 ,79
current predicate/1 , 72,74
current prolog flag/2 ,151
current stream/1 ,83
date time/1 ,167
debug (ag), 150
debug/0 (debug), 17, 18, 31
debugging/0 (debug), 31, 34
decompose file name/4 ,159
Denite clause grammars, seeDCG
delete/3 ,136
delete directory/1 ,162
delete file/1 ,163
demangling, 26
dialect (ag), 149
directory (permission), 165
directory files/2 ,162
discontiguous/1 (directive), 46
display/1 ,108
display/2 ,108, 119, 120
display toatom/2 ,118
display tochars/2 ,119
display tocodes/2 ,120
double quotes (ag), 104, 150, 152
dynamic (property), 75
dynamic/1 (directive), 45, 70
elif/1 (directive), 48
else/0 (directive), 48
endofstream (property), 84
endofterm (option), 104
endif/0 (directive), 48
ensure linked/1 (directive), 47
ensure loaded/1 (directive), 49environ/2 ,161
eof (whence), 87
eofaction (option), 81
eofaction (property), 84
eofcode (option), 81, 93
error (option), 81, 93,104
escape sequence, 14, 134, 150, 150
exclude (option), 65
exec/4 ,171
exec/5 ,171
execute (permission), 164
expand term/2 ,124
extended (token), 106
extra-constrained, seeextra cstr
extra cstr (FD), 183, 188
fail (option), 104
fail/0 ,51, 127
false/0 ,126
fctname (option), 202
fdalldifferent/1 (FD), 195
fdatleast one/1 (FD), 194
fdatmost one/1 (FD), 194
fdatleast/3 (FD), 196
fdatmost/3 (FD), 196
fdcardinality/2 (FD), 194, 196
fdcardinality/3 (FD), 194
fddom/2 (FD), 187
fddomain/2 (FD), 186
fddomain/3 (FD), 185
fddomain bool/1 (FD), 185
fdelement/3 (FD), 195
fdelement var/3 (FD), 196
fdexactly/3 (FD), 196
fdhasextra cstr/1 (FD), 188
fdhasvector/1 (FD), 188
fdlabeling/1 (FD), 198
fdlabeling/2 (FD), 198, 199
fdlabelingff/1 (FD), 198
fdmax/2 (FD), 187
fdmaxinteger (FD), 183, 184
fdmaxinteger/1 (FD), 184
fdmaximize/2 (FD), 199
fdmin/2 (FD), 187
fdminimize/2 (FD), 199
fdnotprime/1 (FD), 191
fdonly one/1 (FD), 194
fdprime/1 (FD), 191
fdreified in/4 (FD), 192
fdrelation/2 (FD), 197
fdrelationc/2 (FD), 197
fdsetvector max/1 (FD), 183, 185
fdsize/2 (FD), 187
fdusevector/1 (FD), 188
234 INDEX
fdvar/1 (FD), 187
fdvector max/1 (FD), 183, 185
fifo (permission), 165
file exists/1 ,164
file name (property), 84
file permission/2 ,164
file property/2 ,165
find linedit completion/2 ,181
findall/3 ,76
findall/4 ,76
first fail (FD option), 198
ag, seeProlog ag
flatten/2 ,138
float/1 ,55
flush output/0 ,83
flush output/1 , 79,83
for/3 ,128
forall/2 ,126
force (option), 83
foreign/1 (directive), 50,202
foreign/2 (directive), 50,202
fork prolog/1 ,172
format/2 ,110
format/3 ,110, 119, 120
format toatom/3 ,118
format tochars/3 ,119
format tocodes/3 ,120
from (option), 64
full (debug), 32
functor/3 ,59
garray (global var.), 142
garray auto (global var.), 142
garray extend (global var.), 142
garray size/2 ,144
gassign/2 ,143
gassignb/2 ,143
gdec/1 ,144
gdec/2 ,144
gdec/3 ,144
gdeco/2 ,144
ginc/1 ,144
ginc/2 ,144
ginc/3 ,144
ginco/2 ,144
glink/2 ,143
gread/2 ,143
greset bit/2 ,145
gsetbit/2 ,145
gtest reset bit/2 ,145
gtest setbit/2 ,145
generic var/1 (FD), 187
get/1 ,122
get0/1 ,122getbyte/1 ,101
getbyte/2 , 78,101
getchar/1 ,97
getchar/2 ,97
getcode/1 ,97
getcode/2 ,97, 98
getkey/1 ,98
getkey/2 ,98
getkeynoecho/1 ,98
getkeynoecho/2 ,98
getlinedit prompt/1 ,180
getprint stream/1 ,113
getseed/1 ,156
gplc ,23, 26, 28, 29, 152
ground/1 ,55
GUI console, 20, 25
half (debug), 32
halt/0 , 14, 18, 126
halt/1 ,126
hash (property), 134
hash code, 62, 134
hexgplc ,29
home (ag), 149
host (ag), 149
host cpu (ag), 149
host name/1 ,168
host os(ag), 149
host vendor (ag), 149
hostname address/2 ,179
if/1 (directive), 48
ignore ops (option), 108
include/1 (directive), 48
infix op(property), 134
initialization/1 (directive), 26, 27, 50, 224
input (property), 84
integer/1 ,55
integer rounding function (ag), 68, 149
interpreter, seetop-level
isabsolute file name/1 ,158
islist/1 ,55
isrelative file name/1 ,158
jump (option), 202, 204
keysort/1 ,140
keysort/2 ,140
largest (FD option), 198
last/2 ,138
last modification (property), 165
last read start line column/2 ,107
leash/1 (debug), 32, 33
length (property), 134
INDEX 235
length/2 ,139
line (option), 82, 93
line count/2 ,88, 89
line position/2 ,88
linedit ,18, 98, 180, 181
list/1 ,55
list orpartial list/1 ,55
listing/0 ,154
listing/1 , 34, 112, 154
load/1 , 17, 23, 25, 153
loose (debug), 32
lower upper/2 ,130
MA,21
main() , 28, 224
make directory/1 ,162
maplist/2-8 ,140
max (FD option), 198
maxarity (ag), 149
maxatom (ag), 149
maxdepth (option), 109
maxinteger (ag), 149, 183
maxlist/2 ,139
maxregret (FD option), 198
maxunget (ag), 100, 103, 149
member/2 ,135
memberchk/2 ,135
meta predicate (property), 75
middle (FD option), 198
min (FD option), 198
mininteger (ag), 149
minlist/2 ,139
mini-assembly, 11, 21, 29
mirror (option), 81
mirror (property), 84
mode (property), 84
monofile (property), 75
most constrained (FD option), 198
msort/1 ,140
msort/2 ,140
multifile (property), 75
multifile/1 (directive), 46, 47
multifile warning (ag), 150, 152
name demangling, 29
name mangling, 26, 28
name/2 ,133
name query vars/2 ,64
name singleton vars/1 ,63, 112
namevars (option), 16, 64,108
native code (property), 75
needs quotes (property), 134
needs scan (property), 134
newatom/1 ,133
newatom/2 ,133next (option), 64
nl/0 ,100
nl/1 ,100
nodebug/0 (debug), 31, 34
nonfdvar/1 (FD), 187
nongeneric var/1 (FD), 187
none (debug), 32
none (option), 81, 93,202, 204
nonvar/1 ,55
nospy/1 (debug), 32, 34
nospyall/0 (debug), 32
notrace/0 (debug), 31
nth/3 ,139
number/1 ,55
number atom/2 ,132
number chars/2 ,132
number codes/2 ,132
numbervars (option), 16, 64,108
numbervars/1 ,64, 112
numbervars/3 ,64
once/1 ,126
op/3 (directive), 49
op/3 , 49,113
open/3 ,81
open/4 , 78,81, 92, 93, 175
open input atom stream/2 ,94
open input chars stream/2 ,94
open input codes stream/2 ,94
open output atom stream/1 ,96
open output chars stream/1 ,96
open output codes stream/1 ,96
oserror (ag), 150, 220
osversion/1 ,168
output (property), 84
partial list/1 ,55
peek byte/1 ,102
peek byte/2 ,102
peek char/1 ,99
peek char/2 ,99
peek code/1 ,99
peek code/2 ,99
permission (property), 165
permutation/2 ,137
phrase/2 ,125
phrase/3 ,125
popen/3 , 78,170
portray/1 , 113
portray clause/1 ,112
portray clause/2 ,112, 154
portrayed (option), 109
position (property), 84
postfix op(property), 134
predicate property/2 ,75
236 INDEX
prefix/2 ,137
prefix op(property), 134
print/1 ,108, 111
print/2 ,108, 113, 119, 120
print toatom/2 ,118
print tochars/2 ,119
print tocodes/2 ,120
priority (option), 109
private (property), 75
Prolog ag, 14, 38, 50, 68, 74, 100, 103, 104, 106,
116,148, 151, 152, 183, 219, 220
prolog copyright (ag), 149
prolog date (ag), 149
prolog file (property), 75
prolog file name/2 , 153, 159
prolog line (property), 75
prolog name (ag), 149
prolog pid/1 ,173
prolog version (ag), 149
PrologScript, 18, 153
public (property), 75
public/1 (directive), 45, 71
punct (token), 106
put/1 ,123
putbyte/1 ,103
putbyte/2 ,103
putchar/1 ,100
putchar/2 ,100
putcode/1 ,100
putcode/2 ,100
quoted (option), 16, 108
random (FD option), 198
random/1 ,157
random/3 ,157
randomize/0 ,156
read (mode), 81
read (permission), 164
read/1 ,104, 107
read/2 ,104, 107, 117, 118
read atom/1 ,105, 107
read atom/2 ,105, 107, 116
read from atom/2 ,117
read from chars/2 ,117
read from codes/2 ,118
read integer/1 ,105, 107
read integer/2 ,105, 107, 116
read number/1 ,105, 107
read number/2 ,105, 107, 116
read plstate file/1 ,152
read term/2 ,104, 107
read term/3 ,104, 107, 116{118
read term from atom/3 , 14, 104, 117
read term from chars/3 ,117read term from codes/3 ,118
read token/1 ,106, 107
read token/2 ,106, 107, 116{118
read token from atom/2 ,117
read token from chars/2 ,117
read token from codes/2 ,118
real file name (property), 165
real time/1 ,155
regular (permission), 165
remove stream mirror/2 , 79,91, 91
rename file/2 ,163
reorder (FD option), 198
repeat/0 ,127
reposition (option), 81
reposition (property), 84
reset (option), 81, 93
retract/1 ,72
retractall/1 ,72
return (option), 202, 204
reverse/2 ,136
search (permission), 164
see/1 ,121
seeing/1 ,121
seek/4 ,86
seen/0 ,122
select/3 ,136
select/5 , 79,175, 178, 179
send signal/2 ,174
setbipname/2 , 39,151, 217
setinput/1 , 78,80
setlinedit prompt/1 ,180
setoutput/1 , 78,80
setprolog flag/2 (directive), 50
setprolog flag/2 , 50,148
setseed/1 ,156
setstream buffering/2 , 79,93, 175, 176
setstream eofaction/2 ,93
setstream line column/3 ,89
setstream position/2 , 79,86
setstream type/2 ,92, 176
setarg/3 ,63
setarg/4 ,63
setof/3 ,77
shebang support, 18, 153
shell/0 ,169
shell/1 ,169
shell/2 ,169
singleton warning (ag), 150, 152
singletons (option), 64, 65, 104
size (property), 165
skip/1 ,122
sleep/1 ,174
smallest (FD option), 198
INDEX 237
socket (permission), 165
socket/2 ,176
socket accept/3 ,179
socket accept/4 ,179
socket bind/2 ,177
socket close/1 ,176
socket connect/4 , 78, 177, 178
socket listen/2 ,178
soft-cut, 52
sort/1 ,140
sort/2 ,140
space args (option), 109
spawn/2 ,170
spawn/3 ,170
spy/1 (debug), 32, 34
spypoint condition/3 (debug), 32, 34
standard (FD option), 198
static (property), 75
statistics/0 ,155
statistics/2 ,155
stop/0 ,126
stream line column/3 ,89
stream position/2 ,85, 86
stream property/2 ,84, 85, 86, 91, 92
strict iso (ag), 38, 74, 150
string (token), 106
subatom/5 ,129
sublist/2 ,138
subsumes term/2 ,61
subtract/3 ,136
succ/2 ,70
suffix/2 ,137
sumlist/2 ,139
suspicious warning (ag), 150, 152
syntax error (ag), 104, 150, 219
syntax error (option), 104
syntax error info/4 ,107, 219
system/1 ,169
system/2 ,169
system time/1 ,155
tab/1 ,123
tell/1 ,121
telling/1 ,121
temporary file/3 ,167
temporary name/2 ,166
term expansion/2 ,124
term hash/2 ,62
term hash/4 ,62
term ref/2 ,65
term variables/2 ,61
term variables/3 ,61
text (option), 81, 92
throw/1 , 31, 39, 53, 220, 221tight (debug), 32
told/0 ,122
top-level, 13, 18, 25, 27, 126, 180, 181, 224
toplevel/0 , 13,126
trace/0 (debug), 17, 18, 31
true/0 ,51
type (option), 81
type (property), 84,165
unget byte/1 ,102
unget byte/2 ,102
unget char/1 ,100
unget char/2 ,100
unget code/1 ,100
unget code/2 ,100
unify with occurs check/2 ,56
unix (ag), 149
unknown (ag), 150
unknown (permission), 165
unlink/1 ,163
user (property), 75
user ,120, 121, 153, 158, 159
user error ,78
user input ,78, 82, 120{122
user output ,78, 82, 120{122
user time/1 ,155
value method (FD option), 198
var (token), 106
var/1 ,55
variable method (FD option), 198
variable names (option), 64, 65, 104,108
variables (option), 104
vector max (FD), 183, 185, 191
version (ag), 149
version data (ag), 149
wait/2 ,173
WAM, 11, 21, 22, 35
wamdebug/0 (debug), 31, 35
warning (option), 104
Warren Abstract Machine, seeWAM
working directory/1 ,162
write (mode), 81
write (permission), 164
write/1 ,108, 111
write/2 ,108, 119, 120
write canonical/1 ,108, 111
write canonical/2 ,108, 119, 120
write canonical toatom/2 ,118
write canonical tochars/2 ,119
write canonical tocodes/2 ,120
write plstate file/1 , 25,152
write term/2 ,108
write term/3 , 16, 33, 108, 119, 120
238 INDEX
write term toatom/3 ,118
write term tochars/3 ,119
write term tocodes/3 , 120
write toatom/2 ,118
write tochars/2 ,119
write tocodes/2 ,120
writeq/1 ,108, 111
writeq/2 ,108, 119, 120, 211
writeq toatom/2 ,118
writeq tochars/2 ,119
writeq tocodes/2 ,120

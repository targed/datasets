Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
draft proposed American National Standard for
Information Systems—Programming
Language—Common Lisp
X3J13/94-101R
Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Versions 15.17 (X3J13/94-101) and 15.17R (X3J13/94-101R) are absolutely
identical except for changes to the document number and date on the cover and
in each page's header, addition of this disclaimer on the back of the cover page,
additions to the Edit and Review History on page Credits iv, and changes to the
names and headings in the credits section on pages Credits v-vii. There are NO
technical changes between these versions; from a normative point of view, the
documents X3J13/94-101 and X3J13/94-101R are entirely interchangeable.
Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Figures
Chapter 1 (Introduction)
1{1. Notations for NIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{14
1{2. Deprecated Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{33
1{3. Functions with Deprecated :TEST-NOT Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . 1{33
1{4. Symbols in the COMMON-LISP package (part one of twelve). . . . . . . . . . . . . . . . . . . 1{35
1{5. Symbols in the COMMON-LISP package (part two of twelve). . . . . . . . . . . . . . . . . . . 1{36
1{6. Symbols in the COMMON-LISP package (part three of twelve). . . . . . . . . . . . . . . . . . 1{37
1{7. Symbols in the COMMON-LISP package (part four of twelve). . . . . . . . . . . . . . . . . . . 1{38
1{8. Symbols in the COMMON-LISP package (part ve of twelve). . . . . . . . . . . . . . . . . . . 1{39
1{9. Symbols in the COMMON-LISP package (part six of twelve). . . . . . . . . . . . . . . . . . . . 1{40
1{10. Symbols in the COMMON-LISP package (part seven of twelve). . . . . . . . . . . . . . . . . 1{41
1{11. Symbols in the COMMON-LISP package (part eight of twelve). . . . . . . . . . . . . . . . . 1{42
1{12. Symbols in the COMMON-LISP package (part nine of twelve). . . . . . . . . . . . . . . . . . 1{43
1{13. Symbols in the COMMON-LISP package (part ten of twelve). . . . . . . . . . . . . . . . . . . 1{44
1{14. Symbols in the COMMON-LISP package (part eleven of twelve). . . . . . . . . . . . . . . . . 1{45
1{15. Symbols in the COMMON-LISP package (part twelve of twelve). . . . . . . . . . . . . . . . 1{46
Chapter 2 (Syntax)
2{1. Readtable dened names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{1
2{2. Variables that inuence the Lisp reader. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{2
2{3. Standard Character Subrepertoire (Part 1 of 3: Latin Characters) . . . . . . . . . . . . . . . . . 2{3
2{4. Standard Character Subrepertoire (Part 2 of 3: Numeric Characters) . . . . . . . . . . . . . . 2{3
2{5. Standard Character Subrepertoire (Part 3 of 3: Special Characters) . . . . . . . . . . . . . . . 2{4
2{6. Possible Character Syntax Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{5
2{7. Character Syntax Types in Standard Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{5
2{8. Constituent Traits of Standard Characters and Semi-Standard Characters . . . . . . . . . . . 2{7
2{9. Syntax for Numeric Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{14
2{10. Examples of reserved tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{15
2{11. Examples of symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{15
2{12. Examples of symbols or potential numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{16
2{13. Examples of Ratios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{17
2{14. Examples of Floating-point numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{18
2{15. Examples of the printed representation of symbols (Part 1 of 2) . . . . . . . . . . . . . . . . 2{19
2{16. Examples of the printed representation of symbols (Part 2 of 2) . . . . . . . . . . . . . . . . 2{20
2{17. Valid patterns for tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{21
2{18. Examples of the use of double-quote . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{26
Figuresi
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2{19. Standard # Dispatching Macro Character Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{30
2{20. Radix Indicator Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{34
2{21. Complex Number Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{35
Chapter 3 (Evaluation and Compilation)
3{1. Some Dened Names Applicable to Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{4
3{2. Common Lisp Special Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{6
3{3. Dened names applicable to macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{7
3{4. Some function-related dened names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{8
3{5. Some operators applicable to receiving multiple values . . . . . . . . . . . . . . . . . . . . . . . . 3{13
3{6. Dened names applicable to compiler macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{16
3{7. EVAL-WHEN processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{21
3{8. Dening Macros That Aect the Compile-Time Environment . . . . . . . . . . . . . . . . . . . 3{22
3{9. Common Lisp Declaration Identiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{29
3{10. What Kind of Lambda Lists to Use . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{33
3{11. Dened names applicable to lambda lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{33
3{12. Standardized Operators that use Ordinary Lambda Lists . . . . . . . . . . . . . . . . . . . . . 3{34
3{13. Lambda List Keywords used by Ordinary Lambda Lists . . . . . . . . . . . . . . . . . . . . . . 3{34
3{14. Lambda List Keywords used by Generic Function Lambda Lists . . . . . . . . . . . . . . . . 3{39
3{15. Standardized Operators that use Specialized Lambda Lists . . . . . . . . . . . . . . . . . . . . 3{40
3{16. Lambda List Keywords used by Specialized Lambda Lists . . . . . . . . . . . . . . . . . . . . . 3{40
3{17. Operators that use Macro Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{41
3{18. Lambda List Keywords used by Macro Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . 3{41
3{19. Lambda List Keywords used by Defsetf Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . 3{47
3{20. Lambda List Keywords used by Dene-modify-macro Lambda Lists . . . . . . . . . . . . . . 3{48
3{21. Lambda List Keywords used by Dene-method-combination arguments Lambda Lists 3{48
3{22. Global Declaration Speciers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{81
3{23. Standardized Forms In Which Declarations Can Occur . . . . . . . . . . . . . . . . . . . . . . . 3{83
3{24. Local Declaration Speciers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{83
3{25. Optimize qualities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{96
Chapter 4 (Types and Classes)
4{1. Cross-References to Data Type Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{2
4{2. Standardized Atomic Type Speciers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{4
4{3. Standardized Compound Type Specier Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{5
4{4. Standardized Compound-Only Type Specier Names . . . . . . . . . . . . . . . . . . . . . . . . . . 4{5
4{5. Dened names relating to types and declarations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{6
4{6. Standardized Type Specier Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{7
4{7. Object System Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{8
4{8. Classes that correspond to pre-dened type speciers . . . . . . . . . . . . . . . . . . . . . . . . . 4{18
4{9. Result possibilities for subtypep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{35
Chapter 5 (Data and Control Flow)
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
5{1. Examples of setf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{1
5{2. Operators relating to places and generalized reference. . . . . . . . . . . . . . . . . . . . . . . . . . 5{1
5{3. Sample Setf Expansion of a Variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{4
5{4. Sample Setf Expansion of a CAR Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{4
5{5. Sample Setf Expansion of a SUBSEQ Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{4
5{6. Sample Setf Expansion of a LDB Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{5
5{7. Functions that setf can be used with|1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{6
5{8. Functions that setf can be used with|2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{7
5{9. Read-Modify-Write Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{12
5{10. Macros that have implicit tagbodies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{49
5{11. Operators that always prefer EQ over EQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{58
5{12. Summary and priorities of behavior of equal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{61
5{13. Summary and priorities of behavior of equalp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{63
Chapter 6 (Iteration)
Chapter 7 (Objects)
7{1. Standardized Method-Dening Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{17
7{2. Built-in Method Combination Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{25
Chapter 8 (Structures)
Chapter 9 (Conditions)
9{1. Standardized Condition Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{2
9{2. Operators that dene and create conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{2
9{3. Operators that read condition slots. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{3
9{4. Operators relating to handling conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{7
9{5. Dened names relating to signaling conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{7
9{6. Dened names relating to restarts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{9
9{7. Operators relating to assertions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{10
Chapter 10 (Symbols)
10{1. Property list dened names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10{1
10{2. Symbol creation and inquiry dened names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10{1
Chapter 11 (Packages)
11{1. Some Dened Names related to Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{1
11{2. Standardized Package Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{4
Chapter 12 (Numbers)
12{1. Operators relating to Arithmetic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{1
Figuresiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
12{2. Dened names relating to Exponentials, Logarithms, and Trigonometry. . . . . . . . . . . 12{1
12{3. Operators for numeric comparison and predication. . . . . . . . . . . . . . . . . . . . . . . . . . . 12{1
12{4. Dened names relating to numeric type manipulation and coercion. . . . . . . . . . . . . . . 12{2
12{5. Dened names relating to logical operations on numbers. . . . . . . . . . . . . . . . . . . . . . 12{3
12{6. Dened names relating to byte manipulation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{4
12{7. Dened names relating to implementation-dependent details about numbers. . . . . . . . 12{4
12{8. Functions Aected by Rule of Float Substitutability . . . . . . . . . . . . . . . . . . . . . . . . . 12{6
12{9. Trigonometric Identities for Complex Domain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{9
12{10. Quadrant Numbering for Branch Cuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{9
12{11. Random-state dened names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{10
12{12. Recommended Minimum Floating-Point Precision and Exponent Size . . . . . . . . . . 12{14
12{13. Uses of /=, =, <,>,<=, and >=. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{22
12{14. Mathematical denition of arc sine, arc cosine, and arc tangent . . . . . . . . . . . . . . . 12{29
12{15. Quadrant information for arc tangent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{31
12{16. Mathematical denitions for hyperbolic functions . . . . . . . . . . . . . . . . . . . . . . . . . 12{33
12{17. Bit-Wise Logical Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{68
12{18. Bit-wise Logical Operations on Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{72
Chapter 13 (Characters)
13{1. Character dened names { 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{1
13{2. Character dened names { 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{1
Chapter 14 (Conses)
14{1. Some dened names relating to conses. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{1
14{2. Some dened names relating to trees. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{1
14{3. Some dened names relating to lists. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{2
14{4. Some dened names related to assocation lists. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{2
14{5. Some dened names related to sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{3
14{6. CAR and CDR variants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{11
Chapter 15 (Arrays)
15{1. General Purpose Array-Related Dened Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{2
15{2. Operators that Manipulate Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{3
15{3. Operators that Manipulate Bit Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{4
15{4. Bit-wise Logical Operations on Bit Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{38
Chapter 16 (Strings)
Chapter 17 (Sequences)
17{1. Standardized Sequence Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17{1
17{2. Operators that have Two-Argument Tests to be Satised . . . . . . . . . . . . . . . . . . . . . 17{2
17{3. Operators that have One-Argument Tests to be Satised . . . . . . . . . . . . . . . . . . . . . . 17{3
ivProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Chapter 18 (Hash Tables)
18{1. Hash-table dened names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{1
Chapter 19 (Filenames)
19{1. Pathname Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{2
19{2. Pathname functions using a :CASE argument . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{4
19{3. Special Markers In Directory Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{8
Chapter 20 (Files)
20{1. File and Directory Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20{1
20{2. File Functions that Treat Open and Closed Streams Dierently . . . . . . . . . . . . . . . . . 20{1
20{3. File Functions where Closed Streams Might Work Best . . . . . . . . . . . . . . . . . . . . . . . 20{2
Chapter 21 (Streams)
21{1. Some General-Purpose Stream Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{1
21{2. Operators relating to Input Streams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{1
21{3. Operators relating to Output Streams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{2
21{4. Operators relating to Bidirectional Streams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{2
21{5. Dened Names related to Specialized Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{4
21{6. Standardized Stream Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{4
21{7. Operators that accept either Open or Closed Streams . . . . . . . . . . . . . . . . . . . . . . . . 21{5
21{8. Operators that accept Open Streams only . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{5
Chapter 22 (Printer)
22{1. Standardized Printer Control Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{1
22{2. Additional Inuences on the Lisp printer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{2
22{3. Example of Logical Blocks, Conditional Newlines, and Sections . . . . . . . . . . . . . . . . 22{15
22{4. Dened names related to pretty printing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{15
22{5. Format directives related to Pretty Printing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{15
22{6. Examples of format control strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{23
22{7. Argument correspondences for the WRITE function. . . . . . . . . . . . . . . . . . . . . . . . 22{63
Chapter 23 (Reader)
23{1. Values of standard control variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{18
Chapter 24 (System Construction)
24{1. Features examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24{2
Chapter 25 (Environment)
25{1. Variables maintained by the Read-Eval-Print Loop . . . . . . . . . . . . . . . . . . . . . . . . . . 25{1
25{2. Dened names relating to debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{1
Figuresv
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
25{3. Dened names relating to environment inquiry. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{2
25{4. Dened names involving Time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{2
25{5. Dened names involving time in Decoded Time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{3
25{6. Dened names involving time in Universal Time. . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{4
25{7. Dened names involving time in Internal Time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{4
25{8. Dened names involving time in Seconds. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{4
Chapter 26 (Glossary)
26{1. Exponent Markers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26{22
26{2. Standardized I/O Customization Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26{30
26{3. Standardized Iteration Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26{33
26{4. Standardized Restart Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26{48
Chapter A (Appendix)
viProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Contents
Chapter 1 (Introduction)
1.1 Scope, Purpose, and History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{1
1.1.1 Scope and Purpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{1
1.1.2 History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{1
1.2 Organization of the Document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{4
1.3 Referenced Publications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{5
1.4 Denitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{7
1.4.1 Notational Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{7
1.4.1.1 Font Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{7
1.4.1.2 Modied BNF Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{7
1.4.1.2.1 Splicing in Modied BNF Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{8
1.4.1.2.2 Indirection in Modied BNF Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{9
1.4.1.2.3 Additional Uses for Indirect Denitions in Modied BNF Syntax . . . . . . . . . . . . . . . . . . . . . . 1{9
1.4.1.3 Special Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{10
1.4.1.4 Objects with Multiple Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{12
1.4.1.4.1 Case in Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{12
1.4.1.4.2 Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{13
1.4.1.4.3 Use of the Dot Character . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{13
1.4.1.4.4 NIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{13
1.4.1.5 Designators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{14
1.4.1.6 Nonsense Words . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{15
1.4.2 Error Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{15
1.4.3 Sections Not Formally Part Of This Standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{18
1.4.4 Interpreting Dictionary Entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{19
1.4.4.1 The \Aected By" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{19
1.4.4.2 The \Arguments" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{19
1.4.4.3 The \Arguments and Values" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . 1{19
1.4.4.4 The \Binding Types Aected" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . 1{19
1.4.4.5 The \Class Precedence List" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{19
1.4.4.6 Dictionary Entries for Type Speciers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{20
1.4.4.6.1 The \Compound Type Specier Kind" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . 1{20
1.4.4.6.2 The \Compound Type Specier Syntax" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . 1{20
1.4.4.6.3 The \Compound Type Specier Arguments" Section of a Dictionary Entry . . . . . . . . . . . . . . 1{21
1.4.4.6.4 The \Compound Type Specier Description" Section of a Dictionary Entry . . . . . . . . . . . . . 1{21
1.4.4.7 The \Constant Value" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{21
1.4.4.8 The \Description" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{21
1.4.4.9 The \Examples" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{21
Contents i
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.4.10 The \Exceptional Situations" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . 1{21
1.4.4.11 The \Initial Value" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{21
1.4.4.12 The \Argument Precedence Order" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . 1{22
1.4.4.13 The \Method Signature" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{22
1.4.4.14 The \Name" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{22
1.4.4.15 The \Notes" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{24
1.4.4.16 The \Pronunciation" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{24
1.4.4.17 The \See Also" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{24
1.4.4.18 The \Side Eects" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{24
1.4.4.19 The \Supertypes" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{24
1.4.4.20 The \Syntax" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{24
1.4.4.20.1 Special \Syntax" Notations for Overloaded Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{25
1.4.4.20.2 Naming Conventions for Rest Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{25
1.4.4.20.3 Requiring Non-Null Rest Parameters in the \Syntax" Section . . . . . . . . . . . . . . . . . . . . . . . 1{25
1.4.4.20.4 Return values in the \Syntax" Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{26
1.4.4.20.4.1 No Arguments or Values in the \Syntax" Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{26
1.4.4.20.4.2 Unconditional Transfer of Control in the \Syntax" Section . . . . . . . . . . . . . . . . . . . . . . . . 1{26
1.4.4.21 The \Valid Context" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{26
1.4.4.22 The \Value Type" Section of a Dictionary Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{26
1.5 Conformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{28
1.5.1 Conforming Implementations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{28
1.5.1.1 Required Language Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{28
1.5.1.2 Documentation of Implementation-Dependent Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{28
1.5.1.3 Documentation of Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{28
1.5.1.4 Treatment of Exceptional Situations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{28
1.5.1.4.1 Resolution of Apparent Conicts in Exceptional Situations . . . . . . . . . . . . . . . . . . . . . . . . . 1{28
1.5.1.4.1.1 Examples of Resolution of Apparent Conicts in Exceptional Situations . . . . . . . . . . . . . . . 1{28
1.5.1.5 Conformance Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{29
1.5.2 Conforming Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{29
1.5.2.1 Use of Implementation-Dened Language Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{29
1.5.2.1.1 Use of Read-Time Conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{30
1.5.2.2 Character Set for Portable Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{30
1.6 Language Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{31
1.7 Language Subsets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{32
1.8 Deprecated Language Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{33
1.8.1 Deprecated Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{33
1.8.2 Deprecated Argument Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{33
1.8.3 Deprecated Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{33
1.8.4 Deprecated Reader Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{34
1.9 Symbols in the COMMON-LISP Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1{35
Chapter 2 (Syntax)
2.1 Character Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{1
2.1.1 Readtables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{1
2.1.1.1 The Current Readtable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{1
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.1.1.2 The Standard Readtable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{1
2.1.1.3 The Initial Readtable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{1
2.1.2 Variables that aect the Lisp Reader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{2
2.1.3 Standard Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{2
2.1.4 Character Syntax Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{4
2.1.4.1 Constituent Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{6
2.1.4.2 Constituent Traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{6
2.1.4.3 Invalid Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{8
2.1.4.4 Macro Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{8
2.1.4.5 Multiple Escape Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{8
2.1.4.5.1Examples of Multiple Escape Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{9
2.1.4.6Single Escape Character . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{9
2.1.4.6.1Examples of Single Escape Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{9
2.1.4.7Whitespace Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{9
2.1.4.7.1Examples of Whitespace Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{9
2.2 Reader Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{11
2.3 Interpretation of Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{14
2.3.1 Numbers as Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{14
2.3.1.1 Potential Numbers as Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{14
2.3.1.1.1 Escape Characters and Potential Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{15
2.3.1.1.2 Examples of Potential Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{15
2.3.2 Constructing Numbers from Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{16
2.3.2.1 Syntax of a Rational . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{16
2.3.2.1.1 Syntax of an Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{16
2.3.2.1.2 Syntax of a Ratio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{16
2.3.2.2 Syntax of a Float . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{17
2.3.2.3 Syntax of a Complex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{18
2.3.3 The Consing Dot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{18
2.3.4 Symbols as Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{18
2.3.5 Valid Patterns for Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{20
2.3.6 Package System Consistency Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{22
2.4 Standard Macro Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{23
2.4.1 Left-Parenthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{23
2.4.2 Right-Parenthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{23
2.4.3 Single-Quote . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{23
2.4.3.1 Examples of Single-Quote . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{24
2.4.4 Semicolon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{24
2.4.4.1 Examples of Semicolon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{24
2.4.4.2 Notes about Style for Semicolon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{24
2.4.4.2.1 Use of Single Semicolon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{24
2.4.4.2.2 Use of Double Semicolon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{24
2.4.4.2.3 Use of Triple Semicolon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{25
2.4.4.2.4 Use of Quadruple Semicolon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{25
2.4.4.2.5 Examples of Style for Semicolon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{25
2.4.5 Double-Quote . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{25
Contents iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.6 Backquote . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{26
2.4.6.1 Notes about Backquote . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{28
2.4.7 Comma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{28
2.4.8 Sharpsign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{28
2.4.8.1Sharpsign Backslash . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{31
2.4.8.2Sharpsign Single-Quote . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{31
2.4.8.3Sharpsign Left-Parenthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{31
2.4.8.4 Sharpsign Asterisk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{32
2.4.8.4.1 Examples of Sharpsign Asterisk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{32
2.4.8.5 Sharpsign Colon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{32
2.4.8.6 Sharpsign Dot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{33
2.4.8.7 Sharpsign B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{33
2.4.8.8 Sharpsign O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{33
2.4.8.9 Sharpsign X . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{33
2.4.8.10 Sharpsign R . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{34
2.4.8.11 Sharpsign C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{34
2.4.8.12 Sharpsign A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{35
2.4.8.13 Sharpsign S . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{35
2.4.8.14Sharpsign P . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{36
2.4.8.15Sharpsign Equal-Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{36
2.4.8.16Sharpsign Sharpsign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{36
2.4.8.17 Sharpsign Plus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{37
2.4.8.18 Sharpsign Minus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{37
2.4.8.19 Sharpsign Vertical-Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{37
2.4.8.19.1Examples of Sharpsign Vertical-Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{38
2.4.8.19.2 Notes about Style for Sharpsign Vertical-Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{39
2.4.8.20 Sharpsign Less-Than-Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{39
2.4.8.21 Sharpsign Whitespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{39
2.4.8.22 Sharpsign Right-Parenthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{39
2.4.9 Re-Reading Abbreviated Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2{40
Chapter 3 (Evaluation and Compilation)
3.1 Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{1
3.1.1 Introduction to Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{1
3.1.1.1 The Global Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{1
3.1.1.2 Dynamic Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{1
3.1.1.3 Lexical Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{2
3.1.1.3.1 The Null Lexical Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{2
3.1.1.4 Environment Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{3
3.1.2 The Evaluation Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{3
3.1.2.1 Form Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{3
3.1.2.1.1 Symbols as Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{3
3.1.2.1.1.1 Lexical Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{4
3.1.2.1.1.2 Dynamic Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{4
3.1.2.1.1.3 Constant Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{5
ivProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{5
3.1.2.1.2 Conses as Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{5
3.1.2.1.2.1 Special Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{6
3.1.2.1.2.2 Macro Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{6
3.1.2.1.2.3 Function Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{7
3.1.2.1.2.4Lambda Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{8
3.1.2.1.3Self-Evaluating Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{8
3.1.2.1.3.1Examples of Self-Evaluating Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{8
3.1.3 Lambda Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{9
3.1.4 Closures and Lexical Binding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{9
3.1.5 Shadowing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{11
3.1.6 Extent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{12
3.1.7 Return Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{13
3.2 Compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{14
3.2.1 Compiler Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{14
3.2.2 Compilation Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{15
3.2.2.1 Compiler Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{15
3.2.2.1.1 Purpose of Compiler Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{16
3.2.2.1.2 Naming of Compiler Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{16
3.2.2.1.3 When Compiler Macros Are Used . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{17
3.2.2.1.3.1 Notes about the Implementation of Compiler Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{17
3.2.2.2 Minimal Compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{17
3.2.2.3 Semantic Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{18
3.2.3 File Compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{19
3.2.3.1 Processing of Top Level Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{20
3.2.3.1.1 Processing of Dening Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{22
3.2.3.1.2 Constraints on Macros and Compiler Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{22
3.2.4 Literal Objects in Compiled Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{23
3.2.4.1 Externalizable Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{23
3.2.4.2 Similarity of Literal Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{24
3.2.4.2.1 Similarity of Aggregate Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{24
3.2.4.2.2 Denition of Similarity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{24
3.2.4.3 Extensions to Similarity Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{26
3.2.4.4 Additional Constraints on Externalizable Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{26
3.2.5 Exceptional Situations in the Compiler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{27
3.3 Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{29
3.3.1 Minimal Declaration Processing Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{29
3.3.2 Declaration Speciers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{29
3.3.3 Declaration Identiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{29
3.3.3.1 Shorthand notation for Type Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{30
3.3.4 Declaration Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{30
3.3.4.1 Examples of Declaration Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{30
3.4 Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{33
3.4.1 Ordinary Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{33
3.4.1.1 Speciers for the required parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{34
Contents v
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.4.1.2 Speciers for optional parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{35
3.4.1.3 A specier for a rest parameter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{35
3.4.1.4 Speciers for keyword parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{35
3.4.1.4.1 Suppressing Keyword Argument Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{36
3.4.1.4.1.1Examples of Suppressing Keyword Argument Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{37
3.4.1.5Speciers for &aux variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{37
3.4.1.6Examples of Ordinary Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{37
3.4.2 Generic Function Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{39
3.4.3 Specialized Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{40
3.4.4 Macro Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{41
3.4.4.1 Destructuring by Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{42
3.4.4.1.1 Data-directed Destructuring by Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{43
3.4.4.1.1.1 Examples of Data-directed Destructuring by Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . 3{43
3.4.4.1.2 Lambda-list-directed Destructuring by Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{43
3.4.5 Destructuring Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{45
3.4.6 Boa Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{45
3.4.7 Defsetf Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{47
3.4.8 Deftype Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{47
3.4.9 Dene-modify-macro Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{47
3.4.10 Dene-method-combination Arguments Lambda Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{48
3.4.11 Syntactic Interaction of Documentation Strings and Declarations . . . . . . . . . . . . . . . . . . . . . . . 3{48
3.5 Error Checking in Function Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{49
3.5.1 Argument Mismatch Detection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{49
3.5.1.1 Safe and Unsafe Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{49
3.5.1.1.1 Error Detection Time in Safe Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{50
3.5.1.2 Too Few Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{50
3.5.1.3 Too Many Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{50
3.5.1.4 Unrecognized Keyword Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{50
3.5.1.5 Invalid Keyword Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{50
3.5.1.6 Odd Number of Keyword Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{51
3.5.1.7 Destructuring Mismatch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{51
3.5.1.8 Errors When Calling a Next Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{51
3.6 Traversal Rules and Side Eects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{52
3.7 Destructive Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{53
3.7.1 Modication of Literal Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{53
3.7.2 Transfer of Control during a Destructive Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{54
3.7.2.1 Examples of Transfer of Control during a Destructive Operation . . . . . . . . . . . . . . . . . . . . . . . 3{54
3.8 Evaluation and Compilation Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3{55
Chapter 4 (Types and Classes)
4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{1
4.2 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{2
4.2.1 Data Type Denition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{2
4.2.2 Type Relationships . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{2
4.2.3 Type Speciers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{3
viProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4.3 Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{8
4.3.1 Introduction to Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{8
4.3.1.1 Standard Metaclasses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{9
4.3.2 Dening Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{9
4.3.3 Creating Instances of Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{10
4.3.4 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{11
4.3.4.1 Examples of Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{11
4.3.4.2 Inheritance of Class Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{11
4.3.5 Determining the Class Precedence List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{11
4.3.5.1 Topological Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{12
4.3.5.2 Examples of Class Precedence List Determination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{13
4.3.6 Redening Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{14
4.3.6.1 Modifying the Structure of Instances . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{15
4.3.6.2 Initializing Newly Added Local Slots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{15
4.3.6.3 Customizing Class Redenition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{16
4.3.7 Integrating Types and Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{16
4.4 Types and Classes Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4{19
Chapter 5 (Data and Control Flow)
5.1 Generalized Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{1
5.1.1 Overview of Places and Generalized Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{1
5.1.1.1 Evaluation of Subforms to Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{1
5.1.1.1.1Examples of Evaluation of Subforms to Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{2
5.1.1.2 Setf Expansions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{3
5.1.1.2.1 Examples of Setf Expansions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{4
5.1.2 Kinds of Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{5
5.1.2.1 Variable Names as Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{5
5.1.2.2 Function Call Forms as Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{5
5.1.2.3 VALUES Forms as Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{9
5.1.2.4 THE Forms as Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{9
5.1.2.5 APPLY Forms as Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{9
5.1.2.6 Setf Expansions and Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{10
5.1.2.7 Macro Forms as Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{10
5.1.2.8 Symbol Macros as Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{10
5.1.2.9 Other Compound Forms as Places . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{10
5.1.3 Treatment of Other Macros Based on SETF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{11
5.2 Transfer of Control to an Exit Point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{13
5.3 Data and Control Flow Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5{14
Chapter 6 (Iteration)
6.1The LOOP Facility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{1
6.1.1Overview of the Loop Facility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{1
6.1.1.1Simple vs Extended Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{1
6.1.1.1.1Simple Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{1
Contents vii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.1.1.2Extended Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{1
6.1.1.2Loop Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{1
6.1.1.3Parsing Loop Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{1
6.1.1.4 Expanding Loop Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{2
6.1.1.5 Summary of Loop Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{3
6.1.1.5.1 Summary of Variable Initialization and Stepping Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{3
6.1.1.5.2 Summary of Value Accumulation Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{3
6.1.1.5.3 Summary of Termination Test Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{4
6.1.1.5.4 Summary of Unconditional Execution Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{4
6.1.1.5.5 Summary of Conditional Execution Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{5
6.1.1.5.6 Summary of Miscellaneous Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{5
6.1.1.6 Order of Execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{5
6.1.1.7 Destructuring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{6
6.1.1.8 Restrictions on Side-Eects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{8
6.1.2 Variable Initialization and Stepping Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{8
6.1.2.1 Iteration Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{8
6.1.2.1.1 The for-as-arithmetic subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{9
6.1.2.1.1.1Examples of for-as-arithmetic subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{10
6.1.2.1.2The for-as-in-list subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{11
6.1.2.1.2.1Examples of for-as-in-list subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{11
6.1.2.1.3 The for-as-on-list subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{12
6.1.2.1.3.1 Examples of for-as-on-list subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{12
6.1.2.1.4 The for-as-equals-then subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{12
6.1.2.1.4.1 Examples of for-as-equals-then subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{12
6.1.2.1.5 The for-as-across subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{12
6.1.2.1.5.1 Examples of for-as-across subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{13
6.1.2.1.6 The for-as-hash subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{13
6.1.2.1.7 The for-as-package subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{14
6.1.2.1.7.1 Examples of for-as-package subclause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{15
6.1.2.2 Local Variable Initializations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{15
6.1.2.2.1Examples of WITH clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{16
6.1.3 Value Accumulation Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{17
6.1.3.1Examples of COLLECT clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{19
6.1.3.2Examples of APPEND and NCONC clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{19
6.1.3.3Examples of COUNT clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{20
6.1.3.4Examples of MAXIMIZE and MINIMIZE clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{20
6.1.3.5Examples of SUM clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{20
6.1.4 Termination Test Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{21
6.1.4.1Examples of REPEAT clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{22
6.1.4.2Examples of ALWAYS, NEVER, and THEREIS clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{22
6.1.4.3Examples of WHILE and UNTIL clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{24
6.1.5Unconditional Execution Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{24
6.1.5.1Examples of unconditional execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{24
6.1.6Conditional Execution Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{25
6.1.6.1Examples of WHEN clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{25
viii Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.7 Miscellaneous Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{26
6.1.7.1Control Transfer Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{27
6.1.7.1.1Examples of NAMED clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{27
6.1.7.2Initial and Final Execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{27
6.1.8Examples of Miscellaneous Loop Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{27
6.1.8.1Examples of clause grouping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{28
6.1.9 Notes about Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{30
6.2 Iteration Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6{31
Chapter 7 (Objects)
7.1 Object Creation and Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{1
7.1.1 Initialization Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{2
7.1.2 Declaring the Validity of Initialization Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{2
7.1.3 Defaulting of Initialization Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{3
7.1.4 Rules for Initialization Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{4
7.1.5 Shared-Initialize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{5
7.1.6 Initialize-Instance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{6
7.1.7 Denitions of Make-Instance and Initialize-Instance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{7
7.2 Changing the Class of an Instance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{9
7.2.1 Modifying the Structure of the Instance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{9
7.2.2 Initializing Newly Added Local Slots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{9
7.2.3 Customizing the Change of Class of an Instance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{10
7.3 Reinitializing an Instance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{11
7.3.1 Customizing Reinitialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{11
7.4 Meta-Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{12
7.4.1 Standard Meta-objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{12
7.5 Slots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{13
7.5.1 Introduction to Slots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{13
7.5.2 Accessing Slots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{13
7.5.3 Inheritance of Slots and Slot Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{14
7.6 Generic Functions and Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{16
7.6.1 Introduction to Generic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{16
7.6.2 Introduction to Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{17
7.6.3 Agreement on Parameter Specializers and Qualiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{19
7.6.4 Congruent Lambda-lists for all Methods of a Generic Function . . . . . . . . . . . . . . . . . . . . . . . . . 7{19
7.6.5 Keyword Arguments in Generic Functions and Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{20
7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods . . . . . . . . . . . . . . . . . . . 7{20
7.6.6 Method Selection and Combination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{21
7.6.6.1 Determining the Eective Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{21
7.6.6.1.1 Selecting the Applicable Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{21
7.6.6.1.2 Sorting the Applicable Methods by Precedence Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{22
7.6.6.1.3 Applying method combination to the sorted list of applicable methods . . . . . . . . . . . . . . . . . 7{22
7.6.6.2 Standard Method Combination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{23
7.6.6.3 Declarative Method Combination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{24
7.6.6.4 Built-in Method Combination Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{25
Contents ix
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.6.7 Inheritance of Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{26
7.7 Objects Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7{27
Chapter 8 (Structures)
8.1 Structures Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8{1
Chapter 9 (Conditions)
9.1 Condition System Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{1
9.1.1 Condition Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{2
9.1.1.1 Serious Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{3
9.1.2 Creating Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{3
9.1.2.1 Condition Designators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{3
9.1.3 Printing Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{4
9.1.3.1 Recommended Style in Condition Reporting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{4
9.1.3.1.1Capitalization and Punctuation in Condition Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{5
9.1.3.1.2Leading and Trailing Newlines in Condition Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{5
9.1.3.1.3Embedded Newlines in Condition Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{5
9.1.3.1.4 Note about Tabs in Condition Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{6
9.1.3.1.5 Mentioning Containing Function in Condition Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{6
9.1.4 Signaling and Handling Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{6
9.1.4.1 Signaling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{7
9.1.4.1.1 Resignaling a Condition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{7
9.1.4.2 Restarts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{8
9.1.4.2.1 Interactive Use of Restarts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{9
9.1.4.2.2 Interfaces to Restarts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{9
9.1.4.2.3 Restart Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{9
9.1.4.2.4 Associating a Restart with a Condition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{9
9.1.5 Assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{10
9.1.6 Notes about the Condition System's Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{10
9.2 Conditions Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9{11
Chapter 10 (Symbols)
10.1 Symbol Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10{1
10.2 Symbols Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10{2
Chapter 11 (Packages)
11.1 Package Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{1
11.1.1 Introduction to Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{1
11.1.1.1 Package Names and Nicknames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{1
11.1.1.2 Symbols in a Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{1
11.1.1.2.1 Internal and External Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{1
11.1.1.2.2 Package Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{2
11.1.1.2.3 Accessibility of Symbols in a Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{2
xProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
11.1.1.2.4 Locating a Symbol in a Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{3
11.1.1.2.5 Prevention of Name Conicts in Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{3
11.1.2 Standardized Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{4
11.1.2.1 The COMMON-LISP Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{4
11.1.2.1.1 Constraints on the COMMON-LISP Package for Conforming Implementations . . . . . . . . . . 11{5
11.1.2.1.2 Constraints on the COMMON-LISP Package for Conforming Programs . . . . . . . . . . . . . . . 11{5
11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON-LISP Package for Conforming
Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{6
11.1.2.2 The COMMON-LISP-USER Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{6
11.1.2.3 The KEYWORD Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{7
11.1.2.3.1 Interning a Symbol in the KEYWORD Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{7
11.1.2.3.2 Notes about The KEYWORD Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{7
11.1.2.4 Implementation-Dened Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{7
11.2 Packages Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11{8
Chapter 12 (Numbers)
12.1 Number Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{1
12.1.1 Numeric Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{1
12.1.1.1 Associativity and Commutativity in Numeric Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{2
12.1.1.1.1 Examples of Associativity and Commutativity in Numeric Operations . . . . . . . . . . . . . . . . 12{2
12.1.1.2 Contagion in Numeric Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{3
12.1.1.3 Viewing Integers as Bits and Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{3
12.1.1.3.1 Logical Operations on Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{3
12.1.1.3.2 Byte Operations on Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{3
12.1.2 Implementation-Dependent Numeric Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{4
12.1.3 Rational Computations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{4
12.1.3.1 Rule of Unbounded Rational Precision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{4
12.1.3.2 Rule of Canonical Representation for Rationals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{5
12.1.3.3 Rule of Float Substitutability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{5
12.1.4Floating-point Computations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{6
12.1.4.1Rule of Float and Rational Contagion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{6
12.1.4.1.1Examples of Rule of Float and Rational Contagion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{6
12.1.4.2 Rule of Float Approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{7
12.1.4.3 Rule of Float Underow and Overow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{7
12.1.4.4 Rule of Float Precision Contagion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{7
12.1.5 Complex Computations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{7
12.1.5.1 Rule of Complex Substitutability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{8
12.1.5.2 Rule of Complex Contagion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{8
12.1.5.3 Rule of Canonical Representation for Complex Rationals . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{8
12.1.5.3.1 Examples of Rule of Canonical Representation for Complex Rationals . . . . . . . . . . . . . . . . . 12{8
12.1.5.4 Principal Values and Branch Cuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{8
12.1.6 Interval Designators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{9
12.1.7 Random-State Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{10
12.2 Numbers Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12{11
Contents xi
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Chapter 13 (Characters)
13.1 Character Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{1
13.1.1 Introduction to Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{1
13.1.2 Introduction to Scripts and Repertoires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{1
13.1.2.1 Character Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{1
13.1.2.2 Character Repertoires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{2
13.1.3 Character Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{2
13.1.4 Character Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{2
13.1.4.1 Graphic Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{3
13.1.4.2 Alphabetic Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{3
13.1.4.3 Characters With Case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{3
13.1.4.3.1 Uppercase Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{3
13.1.4.3.2 Lowercase Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{4
13.1.4.3.3 Corresponding Characters in the Other Case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{4
13.1.4.3.4 Case of Implementation-Dened Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{4
13.1.4.4 Numeric Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{4
13.1.4.5 Alphanumeric Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{4
13.1.4.6 Digits in a Radix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{4
13.1.5 Identity of Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{5
13.1.6 Ordering of Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{5
13.1.7 Character Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{5
13.1.8 Treatment of Newline during Input and Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{6
13.1.9 Character Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{7
13.1.10 Documentation of Implementation-Dened Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{7
13.2 Characters Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13{8
Chapter 14 (Conses)
14.1 Cons Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{1
14.1.1 Conses as Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{1
14.1.1.1 General Restrictions on Parameters that must be Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{1
14.1.2 Conses as Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{1
14.1.2.1 Lists as Association Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{2
14.1.2.2 Lists as Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{2
14.1.2.3 General Restrictions on Parameters that must be Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{3
14.2 Conses Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14{4
Chapter 15 (Arrays)
15.1 Array Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{1
15.1.1 Array Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{1
15.1.1.1 Array Indices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{1
15.1.1.2 Array Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{1
15.1.1.2.1 Implementation Limits on Individual Array Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{1
15.1.1.3 Array Rank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{1
15.1.1.3.1 Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{1
xii Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
15.1.1.3.1.1 Fill Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{1
15.1.1.3.2 Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{2
15.1.1.3.2.1 Storage Layout for Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{2
15.1.1.3.2.2 Implementation Limits on Array Rank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{2
15.1.2 Specialized Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{2
15.1.2.1 Array Upgrading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{3
15.1.2.2 Required Kinds of Specialized Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{3
15.2 Arrays Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15{5
Chapter 16 (Strings)
16.1 String Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16{1
16.1.1 Implications of Strings Being Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16{1
16.1.2 Subtypes of STRING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16{1
16.2 Strings Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16{2
Chapter 17 (Sequences)
17.1 Sequence Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17{1
17.1.1 General Restrictions on Parameters that must be Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . 17{1
17.2Rules about Test Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17{2
17.2.1Satisfying a Two-Argument Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17{2
17.2.1.1Examples of Satisfying a Two-Argument Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17{2
17.2.2 Satisfying a One-Argument Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17{3
17.2.2.1 Examples of Satisfying a One-Argument Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17{4
17.3 Sequences Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17{5
Chapter 18 (Hash Tables)
18.1 Hash Table Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{1
18.1.1 Hash-Table Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{1
18.1.2 Modifying Hash Table Keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{1
18.1.2.1 Visible Modication of Objects with respect to EQ and EQL . . . . . . . . . . . . . . . . . . . . . . . . 18{2
18.1.2.2 Visible Modication of Objects with respect to EQUAL . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{2
18.1.2.2.1 Visible Modication of Conses with respect to EQUAL . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{2
18.1.2.2.2 Visible Modication of Bit Vectors and Strings with respect to EQUAL . . . . . . . . . . . . . . . 18{2
18.1.2.3 Visible Modication of Objects with respect to EQUALP . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{2
18.1.2.3.1 Visible Modication of Structures with respect to EQUALP . . . . . . . . . . . . . . . . . . . . . . . . 18{2
18.1.2.3.2 Visible Modication of Arrays with respect to EQUALP . . . . . . . . . . . . . . . . . . . . . . . . . . 18{3
18.1.2.3.3 Visible Modication of Hash Tables with respect to EQUALP . . . . . . . . . . . . . . . . . . . . . . 18{3
18.1.2.4 Visible Modications by Language Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{3
18.2 Hash Tables Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18{4
Chapter 19 (Filenames)
19.1 Overview of Filenames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{1
19.1.1 Namestrings as Filenames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{1
Contents xiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.1.2 Pathnames as Filenames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{1
19.1.3 Parsing Namestrings Into Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{2
19.2 Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.1 Pathname Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.1.1 The Pathname Host Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.1.2 The Pathname Device Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.1.3 The Pathname Directory Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.1.4 The Pathname Name Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.1.5 The Pathname Type Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.1.6 The Pathname Version Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.2 Interpreting Pathname Component Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.2.1 Strings in Component Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{3
19.2.2.1.1 Special Characters in Pathname Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{4
19.2.2.1.2 Case in Pathname Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{4
19.2.2.1.2.1 Local Case in Pathname Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{4
19.2.2.1.2.2 Common Case in Pathname Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{4
19.2.2.2 Special Pathname Component Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{5
19.2.2.2.1 NIL as a Component Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{5
19.2.2.2.2 :WILD as a Component Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{5
19.2.2.2.3 :UNSPECIFIC as a Component Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{5
19.2.2.2.3.1 Relation between component values NIL and :UNSPECIFIC . . . . . . . . . . . . . . . . . . . . . . 19{6
19.2.2.3 Restrictions on Wildcard Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{6
19.2.2.4 Restrictions on Examining Pathname Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{6
19.2.2.4.1 Restrictions on Examining a Pathname Host Component . . . . . . . . . . . . . . . . . . . . . . . . . . 19{7
19.2.2.4.2 Restrictions on Examining a Pathname Device Component . . . . . . . . . . . . . . . . . . . . . . . . 19{7
19.2.2.4.3 Restrictions on Examining a Pathname Directory Component . . . . . . . . . . . . . . . . . . . . . . 19{7
19.2.2.4.3.1 Directory Components in Non-Hierarchical File Systems . . . . . . . . . . . . . . . . . . . . . . . . . 19{8
19.2.2.4.4 Restrictions on Examining a Pathname Name Component . . . . . . . . . . . . . . . . . . . . . . . . . 19{9
19.2.2.4.5 Restrictions on Examining a Pathname Type Component . . . . . . . . . . . . . . . . . . . . . . . . . . 19{9
19.2.2.4.6 Restrictions on Examining a Pathname Version Component . . . . . . . . . . . . . . . . . . . . . . . . 19{9
19.2.2.4.7 Notes about the Pathname Version Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{9
19.2.2.5 Restrictions on Constructing Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{9
19.2.3Merging Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{10
19.2.3.1Examples of Merging Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{10
19.3 Logical Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{12
19.3.1 Syntax of Logical Pathname Namestrings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{12
19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings . . . . . . . . . . . . . . . . . 19{12
19.3.1.1.1 The Host part of a Logical Pathname Namestring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{13
19.3.1.1.2 The Device part of a Logical Pathname Namestring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{13
19.3.1.1.3 The Directory part of a Logical Pathname Namestring . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{13
19.3.1.1.4 The Type part of a Logical Pathname Namestring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{13
19.3.1.1.5 The Version part of a Logical Pathname Namestring . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{13
19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{13
19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{13
19.3.1.1.8 Other Syntax in a Logical Pathname Namestring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{13
xiv Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.3.2 Logical Pathname Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{14
19.3.2.1 Unspecic Components of a Logical Pathname . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{14
19.3.2.2 Null Strings as Components of a Logical Pathname . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{14
19.4 Filenames Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19{15
Chapter 20 (Files)
20.1 File System Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20{1
20.1.1 Coercion of Streams to Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20{1
20.1.2 File Operations on Open and Closed Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20{1
20.1.3 Truenames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20{2
20.1.3.1 Examples of Truenames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20{2
20.2 Files Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20{3
Chapter 21 (Streams)
21.1 Stream Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{1
21.1.1 Introduction to Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{1
21.1.1.1 Abstract Classications of Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{1
21.1.1.1.1 Input, Output, and Bidirectional Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{1
21.1.1.1.2 Open and Closed Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{2
21.1.1.1.3 Interactive Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{2
21.1.1.2 Abstract Classications of Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{3
21.1.1.2.1 File Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{3
21.1.1.3 Other Subclasses of Stream . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{3
21.1.2 Stream Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{4
21.1.3 Stream Arguments to Standardized Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{5
21.1.4 Restrictions on Composite Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{6
21.2 Streams Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21{7
Chapter 22 (Printer)
22.1 The Lisp Printer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{1
22.1.1 Overview of The Lisp Printer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{1
22.1.1.1 Multiple Possible Textual Representations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{1
22.1.1.1.1 Printer Escaping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{2
22.1.2 Printer Dispatching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{2
22.1.3 Default Print-Object Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{2
22.1.3.1 Printing Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{2
22.1.3.1.1 Printing Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{2
22.1.3.1.2 Printing Ratios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{3
22.1.3.1.3 Printing Floats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{3
22.1.3.1.4 Printing Complexes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{3
22.1.3.1.5 Note about Printing Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{3
22.1.3.2 Printing Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{4
22.1.3.3 Printing Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{4
Contents xv
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.1.3.3.1 Package Prexes for Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{4
22.1.3.3.2 Eect of Readtable Case on the Lisp Printer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{5
22.1.3.3.2.1Examples of Eect of Readtable Case on the Lisp Printer . . . . . . . . . . . . . . . . . . . . . . . . . 22{6
22.1.3.4Printing Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{8
22.1.3.5Printing Lists and Conses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{8
22.1.3.6 Printing Bit Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{9
22.1.3.7 Printing Other Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{9
22.1.3.8 Printing Other Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{9
22.1.3.9 Examples of Printing Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{10
22.1.3.10 Printing Random States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{11
22.1.3.11 Printing Pathnames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{11
22.1.3.12 Printing Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{11
22.1.3.13 Printing Other Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{11
22.1.4Examples of Printer Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{12
22.2 The Lisp Pretty Printer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{14
22.2.1 Pretty Printer Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{14
22.2.1.1 Dynamic Control of the Arrangement of Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{14
22.2.1.2 Format Directive Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{15
22.2.1.3Compiling Format Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{16
22.2.1.4Pretty Print Dispatch Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{16
22.2.1.5Pretty Printer Margins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{16
22.2.2Examples of using the Pretty Printer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{16
22.2.3 Notes about the Pretty Printer's Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{22
22.3 Formatted Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{23
22.3.1 FORMAT Basic Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{24
22.3.1.1 Tilde C: Character . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{24
22.3.1.2 Tilde Percent: Newline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{25
22.3.1.3 Tilde Ampersand: Fresh-Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{25
22.3.1.4 Tilde Vertical-Bar: Page . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{25
22.3.1.5 Tilde Tilde: Tilde . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{25
22.3.2 FORMAT Radix Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{25
22.3.2.1 Tilde R: Radix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{25
22.3.2.2 Tilde D: Decimal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{26
22.3.2.3 Tilde B: Binary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{26
22.3.2.4 Tilde O: Octal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{26
22.3.2.5 Tilde X: Hexadecimal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{27
22.3.3 FORMAT Floating-Point Printers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{27
22.3.3.1 Tilde F: Fixed-Format Floating-Point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{27
22.3.3.2 Tilde E: Exponential Floating-Point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{28
22.3.3.3 Tilde G: General Floating-Point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{29
22.3.3.4 Tilde Dollarsign: Monetary Floating-Point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{30
22.3.4 FORMAT Printer Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{31
22.3.4.1 Tilde A: Aesthetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{31
22.3.4.2 Tilde S: Standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{31
22.3.4.3 Tilde W: Write . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{31
xvi Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3.5 FORMAT Pretty Printer Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{31
22.3.5.1 Tilde Underscore: Conditional Newline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{31
22.3.5.2 Tilde Less-Than-Sign: Logical Block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{32
22.3.5.3 Tilde I: Indent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{33
22.3.5.4 Tilde Slash: Call Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{33
22.3.6 FORMAT Layout Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{33
22.3.6.1 Tilde T: Tabulate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{33
22.3.6.2 Tilde Less-Than-Sign: Justication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{34
22.3.6.3 Tilde Greater-Than-Sign: End of Justication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{35
22.3.7 FORMAT Control-Flow Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{35
22.3.7.1 Tilde Asterisk: Go-To . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{35
22.3.7.2Tilde Left-Bracket: Conditional Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{36
22.3.7.3 Tilde Right-Bracket: End of Conditional Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{37
22.3.7.4 Tilde Left-Brace: Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{37
22.3.7.5 Tilde Right-Brace: End of Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{38
22.3.7.6 Tilde Question-Mark: Recursive Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{38
22.3.8 FORMAT Miscellaneous Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{38
22.3.8.1 Tilde Left-Paren: Case Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{39
22.3.8.2 Tilde Right-Paren: End of Case Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{39
22.3.8.3 Tilde P: Plural . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{39
22.3.9 FORMAT Miscellaneous Pseudo-Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{40
22.3.9.1 Tilde Semicolon: Clause Separator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{40
22.3.9.2 Tilde Circumex: Escape Upward . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{40
22.3.9.3 Tilde Newline: Ignored Newline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{41
22.3.10 Additional Information about FORMAT Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{41
22.3.10.1Nesting of FORMAT Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{42
22.3.10.2Missing and Additional FORMAT Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{42
22.3.10.3Additional FORMAT Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{42
22.3.10.4Undened FORMAT Modier Combinations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{42
22.3.11Examples of FORMAT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{42
22.3.12 Notes about FORMAT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{44
22.4Printer Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22{46
Chapter 23 (Reader)
23.1Reader Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{1
23.1.1Dynamic Control of the Lisp Reader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{1
23.1.2Eect of Readtable Case on the Lisp Reader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{1
23.1.2.1Examples of Eect of Readtable Case on the Lisp Reader . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{1
23.1.3 Argument Conventions of Some Reader Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{2
23.1.3.1 The EOF-ERROR-P argument . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{2
23.1.3.2 The RECURSIVE-P argument . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{2
23.2Reader Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23{4
Chapter 24 (System Construction)
Contents xvii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
24.1 System Construction Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24{1
24.1.1 Loading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24{1
24.1.2 Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24{1
24.1.2.1 Feature Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24{1
24.1.2.1.1 Examples of Feature Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24{2
24.2 System Construction Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24{3
Chapter 25 (Environment)
25.1 The External Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{1
25.1.1 Top level loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{1
25.1.2 Debugging Utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{1
25.1.3 Environment Inquiry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{1
25.1.4 Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{2
25.1.4.1 Decoded Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{2
25.1.4.2 Universal Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{3
25.1.4.3 Internal Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{4
25.1.4.4 Seconds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{4
25.2 Environment Dictionary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25{5
Chapter 26 (Glossary)
26.1 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26{1
Chapter A (Appendix)
A.1 Removed Language Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A{1
A.1.1 Requirements for removed and deprecated features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A{1
A.1.2 Removed Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A{1
A.1.3 Removed Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A{1
A.1.4 Removed Argument Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A{1
A.1.5 Removed Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A{1
A.1.6 Removed Reader Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A{1
A.1.7 Packages No Longer Required . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A{1
xviii Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Index
#2{29
&allow-other-keys 3{35
&aux 3{37
&body 3{42
&environment 3{42
&key 3{35
&optional 3{35
&rest 3{35
&whole 3{42
’2{24
(2{23
()1{13, 26{2
(setf class-name) 7{89
(setf documentation) 25{17
)2{23
*12{35, 25{26
**25{26
*** 25{26
*break-on-signals* 9{35
*break-on-warnings* A{1
*compile-ﬁle-pathname* 24{12
*compile-ﬁle-truename* 24{12
*compile-print* 24{13
*compile-verbose* 24{13
*debug-io* 21{57
*debugger-hook* 9{34
*default-pathname-defaults* 19{28
*error-output* 21{57
*features* 1{30, 2{37, 24{10
*gensym-counter* 10{9
*load-pathname* 24{13
*load-print* 24{14
*load-truename* 24{13
*load-verbose* 24{14
*macroexpand-hook* 3{80
*modules* 24{14
*package* 11{40*print-array* 22{66
*print-base* 22{67
*print-case* 22{68
*print-circle* 2{36, 2{37, 22{69
*print-escape* 22{70
*print-gensym* 22{71
*print-length* 22{72
*print-level* 22{72
*print-lines* 22{73
*print-miser-width* 22{74
*print-pprint-dispatch* 22{75
*print-pretty* 22{75
*print-radix* 22{67
*print-readably* 22{76
*print-right-margin* 22{78
*query-io* 21{57
*random-state* 12{53
*read-base* 2{33, 2{34, 23{19
*read-default-ﬂoat-format* 23{19
*read-eval* 2{33, 23{20
*read-suppress* 23{21
*readtable* 23{22
*standard-input* 21{57
*standard-output* 21{57
*terminal-io* 21{59
*trace-output* 21{57
+7{26, 12{36, 25{25
++ 25{25
+++ 25{25
,2{28
 12{36, 25{24
.2{23
..2{40, 22{74
... 2{40, 22{55
/12{37, 25{27
//25{27
/// 25{27
/= 12{20
1+ 12{38
1 12{38
:absolute 19{7
:back 19{8
:common 19{5
:compile-toplevel 3{60
:execute 3{60
Indexi
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
:load-toplevel 3{60
:local 19{4
:relative 19{7
:unspecific 19{6
:up 19{8
:wild 19{5, 19{8
:wild-inferiors 19{5, 19{8
;2{24
<12{20
<=12{20
=12{20
>12{20
>=12{20
A (format directive) 22{31
A (sharpsign reader macro) 2{35
abort 9{65, 9{68
abs 12{39
absolute 26{2
:absolute 19{7
access 26{2
accessibility 26{2
accessible 11{2, 26{2
accessor 26{2
acons 14{43
acos 12{29
acosh 12{33
active 15{2, 26{3
actual adjustability 26{3
actual argument 26{3
actual array element type 15{3, 26{3
actual complex part type 26{3
actual parameter 26{3
actually adjustable 26{3
add-method 7{87
adjoin 14{54
adjust-array 15{14
adjustability 26{3
adjustable 26{3
adjustable-array-p 15{18
after method 26{3
alist 26{3
allocate-instance 7{30
alpha-char-p 13{14
alphabetic 26{3
alphanumeric 26{3alphanumericp 13{15
ampersand 26{4
Ampersand (format directive) 22{25
and 4{28, 5{68, 7{26
anonymous 26{4
apparently uninterned 26{4
append 7{26, 14{30
applicable 26{4
applicable handler 26{4
applicable method 26{4
applicable restart 26{4
apply 26{4
apply 5{14
apropos 25{8
apropos-list 25{8
aref 15{18
argument 26{4
argument evaluation order 26{4
argument precedence order 26{4
arithmetic-error 12{89
arithmetic-error-operands 12{89
arithmetic-error-operation 12{89
around method 26{4
array 26{4
array 2{35, 15{5
array element type 26{5
array total size 26{5
array-dimension 15{19
array-dimension-limit 15{30
array-dimensions 15{20
array-displacement 15{22
array-element-type 15{21
array-has-ﬁll-pointer-p 15{21
array-in-bounds-p 15{23
array-rank 15{24
array-rank-limit 15{30
array-row-major-index 15{25
array-total-size 15{26
array-total-size-limit 15{31
arrayp 15{27
ash 12{64
asin 12{29
asinh 12{33
assert 9{15
assign 26{5
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
assoc 14{43
assoc-if 14{43
assoc-if-not 14{43
association list 14{2, 26{5
asterisk 26{5
Asterisk (format directive) 22{36
Asterisk (sharpsign reader macro) 2{32
at-sign 26{5
atan 12{29
atanh 12{33
atom 26{5
atom 14{5, 14{7
atomic 26{5
atomic type specier 26{5
attribute 26{5
aux variable 26{5
auxiliary method 26{5
B (format directive) 22{26
B (sharpsign reader macro) 2{33
:back 19{8
backquote 26{6
Backquote (reader macro) 2{26
backslash 26{6
Backslash (sharpsign reader macro) 2{31
bar 1{15
base character 26{6
base string 26{6
base-char 13{8
base-string 16{2
baz 1{15
before method 26{6
bidirectional 21{2, 26{6
bignum 12{20
binary 21{1, 26{6
bind 26{6
binding 3{1, 26{6
bit 26{6
bit 12{19, 15{36
bit array 26{6
bit vector 15{3, 26{6
bit-and 15{37
bit-andc1 15{37
bit-andc2 15{37
bit-eqv 15{37
bit-ior 15{37bit-nand 15{37
bit-nor 15{37
bit-not 15{37
bit-orc1 15{37
bit-orc2 15{37
bit-vector 2{32, 15{9
bit-vector-p 15{39
bit-wise logical operation specier 26{6
bit-xor 15{37
block 26{7
block 5{42
block tag 26{7
bnf key 1{8
boa lambda list 3{46, 26{7
body parameter 26{7
boole 12{67
boole-1 12{70
boole-2 12{70
boole-and 12{70
boole-andc1 12{70
boole-andc2 12{70
boole-c1 12{70
boole-c2 12{70
boole-clr 12{70
boole-eqv 12{70
boole-ior 12{70
boole-nand 12{70
boole-nor 12{70
boole-orc1 12{70
boole-orc2 12{70
boole-set 12{70
boole-xor 12{70
boolean 26{7
boolean 4{19
boolean equivalent 26{7
both-case-p 13{20
bound 26{7
bound declaration 3{30, 26{7
bounded 26{7
bounding index 26{7
bounding index designator 26{8
boundp 10{20
break 9{33
break loop 26{8
*break-on-signals* 9{35
Indexiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
broadcast stream 26{8
broadcast-stream 21{7
broadcast-stream-streams 21{47
built-in class 26{8
built-in type 26{8
built-in-class 4{23
butlast 14{33
byte 26{8
byte 12{76
byte specier 26{8
byte-position 12{76
byte-size 12{76
C (format directive) 22{24
C (sharpsign reader macro) 2{34
caaaar 14{9
caaadr 14{9
caaar 14{9
caadar 14{9
caaddr 14{9
caadr 14{9
caar 14{9
cadaar 14{9
cadadr 14{9
cadar 14{9
caddar 14{9
cadddr 14{9
caddr 14{9
cadr 26{8
cadr 14{9
call 26{8
call-arguments-limit 5{29
call-method 7{73
call-next-method 7{74
captured initialization form 26{8
car 26{9
car 14{9
case 26{9
case 5{74
case in symbol names 1{12
case sensitivity mode 26{9
catch 26{9
catch 5{43
catch tag 26{9
ccase 5{74
cdaaar 14{9cdaadr 14{9
cdaar 14{9
cdadar 14{9
cdaddr 14{9
cdadr 14{9
cdar 14{9
cddaar 14{9
cddadr 14{9
cddar 14{9
cdddar 14{9
cddddr 14{9
cdddr 14{9
cddr 26{9
cddr 14{9
cdr 26{9
cdr 14{9
ceiling 12{25
cell 26{9
cell-error 9{13
cell-error-name 9{14
cerror 9{19
change-class 7{38
char 16{5
char-bit A{1
char-bits A{1
char-bits-limit A{1
char-code 13{21
char-code-limit 13{23
char-control-bit A{1
char-downcase 13{19
char-equal 13{10
char-font A{1
char-font-limit A{1
char-greaterp 13{10
char-hyper-bit A{1
char-int 13{22
char-lessp 13{10
char-meta-bit A{1
char-name 13{24
char-not-equal 13{10
char-not-greaterp 13{10
char-not-lessp 13{10
char-super-bit A{1
char-upcase 13{19
char/= 13{10
ivProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
char <13{10
char <=13{10
char= 13{10
char >13{10
char >=13{10
character 13{1, 21{1, 26{9
character 2{31, 13{8, 13{12
character code 26{9
character designator 26{10
characterp 13{13
check-type 9{22
circular 26{10
circular list 14{2, 14{4, 26{10
Circumex (format directive) 22{41
cis 12{55
CLpackage 11{4
CL-USER package 11{7
class 4{8, 26{10
class 4{23
class designator 26{10
class precedence list 4{8, 4{12, 26{10
class-name 7{88
class-of 7{90
clear-input 21{42
clear-output 21{43
close 26{10
close 21{39
closed 21{2, 26{10
closure 26{10
clrhash 18{14
coalesce 3{14, 26{10
code 26{11
code-char A{1, 13{22
coerce 26{11
coerce 4{30
colon 26{11
Colon (sharpsign reader macro) 2{33
comma 26{11
Comma (reader macro) 2{28
comment 2{24, 2{38
:common 19{5
COMMON-LISP package 1{35, 11{4
COMMON-LISP-USER package 11{7
commonp A{1
compilation 26{11compilation environment 3{14, 26{11
compilation unit 26{11
compilation-speed 3{97
compile 26{11
compile 3{18, 3{57, 3{60
compile time 3{15, 26{11
compile-ﬁle 3{18, 24{3
compile-ﬁle-pathname 24{5
*compile-ﬁle-pathname* 24{12
*compile-ﬁle-truename* 24{12
*compile-print* 24{13
compile-time denition 3{15, 26{11
:compile-toplevel 3{60
*compile-verbose* 24{13
compiled code 3{14, 24{1, 26{11
compiled le 24{1, 26{12
compiled function 26{12
compiled-function 4{22
compiled-function-p 5{28
compiler 3{14, 26{12
compiler macro 3{18, 26{12
compiler macro expansion 26{12
compiler macro form 26{12
compiler macro function 26{12
compiler-macro 25{18
compiler-macro-function 3{66
complement 5{65
complex 26{12
complex 2{34, 12{11, 12{56, 22{4
complex oat 26{12
complex part type 26{12
complex rational 26{12
complex single oat 26{13
complexp 12{57
composite stream 26{13
compound form 26{13
compound type specier 4{4, 26{13
compute-applicable-methods 7{76
compute-restarts 9{49
concatenate 17{29
concatenated stream 26{13
concatenated-stream 21{8
concatenated-stream-streams 21{50
cond 5{69
condition 26{13
Indexv
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
condition 9{11
condition designator 9{3, 26{13
condition handler 26{13
condition reporter 9{4, 26{13
conditional newline 26{13
conditional newlines 22{14
conformance 26{13
conforming code 1{29, 26{13
conforming implementation 1{28, 26{13
conforming processor 26{14
conforming program 1{29, 26{14
congruence 7{19
congruent 26{14
conjugate 12{57
cons 14{1, 26{14
cons 2{26, 2{28, 14{5, 14{6
consequences 1{17
consp 14{6
constant 26{14
constant form 26{14
constant object 26{14
constant variable 26{14
constantly 5{66
constantp 3{104
constituent 26{14
constituent trait 26{14
constructed stream 26{15
contagion 26{15
continuable 26{15
continue 9{66, 9{68
control form 26{15
control-error 5{104
copy 26{15
copy-alist 14{45
copy-list 14{19
copy-pprint-dispatch 22{46
copy-readtable 23{4
copy-seq 17{5
copy-structure 8{18
copy-symbol 10{7
copy-tree 14{12
correctable 26{15
cos 12{28
cosh 12{33
count 17{15count-if 17{15
count-if-not 17{15
ctypecase 5{76
current input base 23{19, 26{15
current logical block 26{16
current output base 22{67, 26{16
current package 11{1, 26{16
current pprint dispatch table 22{16, 26{16
current random state 26{16
current readtable 2{1, 26{16
D (format directive) 22{26
data type 26{16
debug 3{97
debug I/O 26{16
*debug-io* 21{57
debugger 26{16
*debugger-hook* 9{34
decf 12{43
declaim 3{83
declaration 3{29, 26{16
declaration 3{29, 3{96
declaration identier 3{29, 26{16
declaration specier 3{29, 26{16
declare 26{17
declare 3{83
decline 26{17
decode-ﬂoat 12{82
decode-universal-time 25{5
decoded time 25{2, 26{17
default method 7{19, 26{17
*default-pathname-defaults* 19{28
defaulted initialization argument list 26{17
defclass 7{60
defconstant 5{31
defgeneric 7{65
deﬁne-compiler-macro 3{67
deﬁne-condition 9{42
deﬁne-method-combination 7{76
dene-method-combination arguments lambda list 3{
48, 26{17
deﬁne-modify-macro 5{92
dene-modify-macro lambda list 3{48, 26{17
deﬁne-setf-expander 5{96
deﬁne-symbol-macro 3{77
dened name 26{17
viProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
dening form 26{17
defmacro 3{70
defmethod 7{69
defpackage 11{29
defparameter 5{32
defsetf 5{93
defsetf lambda list 3{47, 26{17
defstruct 8{1
deftype 4{33
deftype lambda list 3{48, 26{17
defun 5{15
defvar 5{32
delete 17{32
delete-duplicates 17{35
delete-ﬁle 20{9
delete-if 17{32
delete-if-not 17{32
delete-package 11{17
denominator 12{61
denormalized 26{17
deposit-ﬁeld 12{77
derived type 26{18
derived type specier 4{5, 26{18
describe 25{9
describe-object 25{10
designator 1{14, 26{18
destructive 26{18
destructuring lambda list 3{45, 26{18
destructuring-bind 5{35
dierent 26{18
digit 26{18
digit-char A{1, 13{16
digit-char-p 13{16
dimension 15{1, 26{18
direct instance 26{18
direct subclass 4{8, 26{18
direct superclass 4{8, 26{18
directory 20{3
directory-namestring 19{28
disassemble 25{17
disestablish 26{18
disjoint 26{19
dispatching macro character 26{19
displaced array 26{19
distinct 26{19division-by-zero 12{90
do 6{31
do* 6{31
do-all-symbols 11{33
do-external-symbols 11{33
do-symbols 11{33
documentation 25{17
documentation string 26{19
dolist 6{37
Dollarsign (format directive) 22{30
dot 2{23, 22{55, 26{19
Dot (sharpsign reader macro) 2{33
Dot Dot 2{40, 22{74
Dot Dot Dot 2{40, 22{55
dotimes 6{35
dotted list 14{2, 14{4, 26{19
dotted pair 26{19
double oat 26{19
double-ﬂoat 12{14
double-ﬂoat-epsilon 12{88
double-ﬂoat-negative-epsilon 12{88
double-quote 26{19
Double-Quote (reader macro) 2{26
dpb 12{78
dribble 25{23
dynamic binding 26{19
dynamic environment 3{2, 26{19
dynamic extent 26{19
dynamic scope 26{20
dynamic variable 26{20
dynamic-extent 3{86
E (format directive) 22{28
ecase 5{74
echo stream 26{20
echo-stream 21{9
echo-stream-input-stream 21{49
echo-stream-output-stream 21{49
ed25{22
eective method 7{22, 26{20
eighth 14{25
element 26{20
element type 26{20
elt 17{6
em 26{20
empty list 14{4, 26{20
Indexvii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
empty type 26{20
encode-universal-time 25{6
end of le 26{20
end-of-ﬁle 21{61
endp 14{28
enough-namestring 19{28
ensure-directories-exist 20{4
ensure-generic-function 7{29
environment 3{1, 26{21
environment object 3{3, 26{21
environment parameter 26{21
eq5{56
eql 4{30, 5{58
equal 5{59
Equal-Sign (sharpsign reader macro) 2{36
equalp 5{62
error 26{21
error 9{13, 9{17
error output 26{21
error terminology 1{15
*error-output* 21{57
escape 26{21
establish 26{21
etypecase 5{76
eval 2{33, 3{59, 3{60
eval-when 3{20, 3{60
evaluate 26{21
evaluation 3{1, 26{21
evaluation environment 3{14, 26{21
evaluation order 3{63, 5{2, 5{43, 5{83, 6{5, 6{9,
7{4, 9{16, 12{79
evenp 12{40
every 5{67
execute 26{22
:execute 3{60
execution time 26{22
exhaustive partition 26{22
exhaustive union 26{22
exit point 26{22
exp 12{41
explicit return 26{22
explicit use 26{22
exponent marker 26{22
export 26{22
export 11{8exported 26{23
expressed adjustability 26{23
expressed array element type 15{3, 26{23
expressed complex part type 26{23
expression 26{23
expressly adjustable 26{23
expt 12{41
extended character 26{23
extended function designator 26{23
extended lambda list 26{23
extended-char 13{9
extension 26{24
extensions 1{17, 1{18
extent 26{24
external le format 26{24
external le format designator 26{24
external symbol 11{2, 26{24
externalizable object 3{23, 26{24
F (format directive) 22{27
false 26{24
fbound 26{24
fboundp 5{18
fceiling 12{25
fdeﬁnition 5{17
feature 24{1, 26{24
feature expression 24{1, 26{25
features list 24{1, 26{25
*features* 1{30, 2{37, 24{10
ﬄoor 12{25
ﬁfth 14{25
le 20{1, 26{25
le compiler 26{25
le position 26{25
le position designator 26{25
le stream 21{3, 26{25
le system 26{25
ﬁle-author 20{6
ﬁle-error 20{10
ﬁle-error-pathname 20{11
ﬁle-length 21{28
ﬁle-namestring 19{28
ﬁle-position 21{29
ﬁle-stream 21{9
ﬁle-string-length 21{31
ﬁle-write-date 20{7
viii Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
lename 20{1, 26{25
ﬁll 17{7
ll pointer 15{2, 26{25
ﬁll-pointer 15{27
ll-style conditional newline 22{18, 22{54
ﬁnd 17{20
ﬁnd-all-symbols 11{12
ﬁnd-class 7{71
ﬁnd-if 17{20
ﬁnd-if-not 17{20
ﬁnd-method 7{85
ﬁnd-package 11{11
ﬁnd-restart 9{50
ﬁnd-symbol 11{9
ﬁnish-output 21{43
nite 26{25
ﬁrst 14{25
xnum 26{26
ﬁxnum 12{20
ﬂet 5{20
oat 26{26
ﬂoat 12{13, 12{85, 22{3
ﬂoat-digits 12{82
ﬂoat-precision 12{82
ﬂoat-radix 12{82
ﬂoat-sign 12{82
ﬂoating-point-inexact 12{91
ﬂoating-point-invalid-operation 12{90
ﬂoating-point-overﬂow 12{91
ﬂoating-point-underﬂow 12{91
ﬂoatp 12{86
ﬂoor 12{25
fmakunbound 5{19
font key 1{7
foo 1{15
for-value 26{26
force-output 21{43
form 26{26
formal argument 26{26
formal parameter 26{26
format 26{26
format 22{80
format argument 26{26
format control 22{16, 26{26
format directive 26{26format string 26{26
formatter 22{46
fourth 14{25
free declaration 3{30, 26{26
fresh 26{26
fresh-line 21{21
freshline 26{27
fround 12{25
ftruncate 12{25
ftype 3{95
funbound 26{27
funcall 5{24
function 26{27
function 2{31, 4{20, 5{25, 25{18
function block name 26{27
function cell 26{27
function designator 26{27
function form 26{27
function name 26{27
function-keywords 7{28
function-lambda-expression 5{26
functional evaluation 26{27
functional value 26{27
functionp 5{28
further compilation 3{14, 26{28
G (format directive) 22{30
gcd 12{42
general 26{28
generalized boolean 26{28
generalized instance 26{28
generalized reference 5{1, 26{28
generalized synonym stream 26{28
generic function 4{22, 7{17, 26{28
generic function lambda list 3{39, 26{28
generic-function 4{22
gensym 26{28
gensym 10{8
*gensym-counter* 10{9
gentemp 10{10
get 10{17
get-decoded-time 25{6
get-dispatch-macro-character 23{13
get-internal-real-time 25{15
get-internal-run-time 25{16
get-macro-character 23{14
Indexix
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
get-output-stream-string 21{52
get-properties 14{48
get-setf-expansion 5{98
get-universal-time 25{6
getf 14{49
gethash 18{10
global declaration 3{29, 26{29
global environment 3{1, 26{29
global variable 26{29
glyph 26{29
go26{29
go5{44
go point 26{29
go tag 26{29
graphic 13{3, 26{29
graphic-char-p 13{17
Greater-Than-Sign (format directive) 22{36
handle 26{29
handler 26{29
handler-bind 9{37
handler-case 9{38
hash table 26{29
hash-table 18{4
hash-table-count 18{6
hash-table-p 18{5
hash-table-rehash-size 18{7
hash-table-rehash-threshold 18{8
hash-table-size 18{9
hash-table-test 18{9
home package 26{29
host-namestring 19{28
I (format directive) 22{33
I/O customization variable 26{29
identical 26{30
identier 26{30
identity 5{64
if5{70
ignorable 3{85
ignore 3{85
ignore-errors 9{41
imagpart 12{59
immutable 26{30
implementation 26{30
implementation limit 26{30
implementation-dened 26{30implementation-dependent 26{30
implementation-independent 26{30
implicit block 26{30
implicit compilation 3{14, 26{30
implicit progn 26{30
implicit tagbody 26{31
import 26{31
import 11{12
improper list 14{2, 26{31
in-package 11{26
inaccessible 26{31
incf 12{43
indenite extent 26{31
indenite scope 26{31
indicator 26{31
indirect instance 26{31
inherit 26{31
initial pprint dispatch table 26{31
initial readtable 2{2, 26{31
initialization argument list 7{1, 26{31
initialization form 26{31
initialize-instance 7{88
inline 3{93
input 21{1, 26{31
input-stream-p 21{11
inspect 25{23
instance 4{8, 26{31
int-char A{1
integer 26{31
integer 12{17
integer-decode-ﬂoat 12{82
integer-length 12{65
integerp 12{66
interactive stream 21{2, 26{32
interactive-stream-p 21{12
intern 26{32
intern 11{35
internal symbol 11{2, 26{32
internal time 25{4, 26{32
internal time unit 26{32
internal-time-units-per-second 25{15
interned 26{32
interpreted function 26{32
interpreted implementation 26{32
intersection 14{52
xProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
interval designator 26{32
invalid 26{32
invalid-method-error 9{25
invoke-debugger 9{32
invoke-restart 9{52
invoke-restart-interactively 9{53
is signaled 1{16
isqrt 12{49
iteration form 26{32
iteration variable 26{33
key 26{33
keyword 26{33
KEYWORD package 11{7
keyword 10{4
keyword parameter 26{33
keyword/value pair 26{33
keywordp 10{5
labels 5{20
lambda 3{56
lambda combination 26{33
lambda expression 26{33
lambda form 26{33
lambda list 3{33, 26{33
lambda list keyword 26{34
lambda variable 26{34
lambda-list-keywords 5{30
lambda-parameters-limit 5{30
last 14{34
lcm 12{44
ldb 12{79
ldb-test 12{80
ldiﬀ 14{35
leaf 26{34
leap seconds 26{34
least-negative-double-ﬂoat 12{87
least-negative-long-ﬂoat 12{87
least-negative-normalized-double-ﬂoat 12{87
least-negative-normalized-long-ﬂoat 12{87
least-negative-normalized-short-ﬂoat 12{87
least-negative-normalized-single-ﬂoat 12{87
least-negative-short-ﬂoat 12{87
least-negative-single-ﬂoat 12{87
least-positive-double-ﬂoat 12{87
least-positive-long-ﬂoat 12{87
least-positive-normalized-double-ﬂoat 12{87least-positive-normalized-long-ﬂoat 12{87
least-positive-normalized-short-ﬂoat 12{87
least-positive-normalized-single-ﬂoat 12{87
least-positive-short-ﬂoat 12{87
least-positive-single-ﬂoat 12{87
leaves 14{1
Left-Brace (format directive) 22{37
Left-Bracket (format directive) 22{36
Left-Paren (format directive) 22{39
left-parenthesis 26{34
Left-Parenthesis (reader macro) 2{23
Left-Parenthesis (sharpsign reader macro) 2{31
length 26{34
length 17{16
Less-Than-Sign (format directive) 22{32, 22{35
Less-Than-Sign (sharpsign reader macro) 2{39
let 5{36
let* 5{36
lexical binding 26{34
lexical closure 26{34
lexical environment 3{2, 26{34
lexical scope 26{34
lexical variable 26{34
linear-style conditional newline 22{17, 22{54
LISP package A{1
Lisp image 26{34
Lisp printer 26{35
Lisp read-eval-print loop 26{35
Lisp reader 26{35
lisp-implementation-type 25{28
lisp-implementation-version 25{28
list 14{2, 14{4, 26{35
list 2{23, 2{26, 2{28, 7{26, 14{4, 14{20
list designator 26{35
list structure 26{35
list* 14{20
list-all-packages 11{14
list-length 14{21
listen 21{41
listp 14{22
literal 26{35
literal object 3{14
load 26{35
load 3{60, 24{6
load time 26{36
Indexxi
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
load time value 26{36
load-logical-pathname-translations 19{22
*load-pathname* 24{13
*load-print* 24{14
load-time-value 3{18, 3{63
:load-toplevel 3{60
*load-truename* 24{13
*load-verbose* 24{14
loader 26{36
:local 19{4
local declaration 3{29, 26{36
local precedence order 4{9, 4{12, 26{36
local slot 26{36
locally 3{100
log 12{45
logand 12{71
logandc1 12{71
logandc2 12{71
logbitp 12{73
logcount 12{74
logeqv 12{71
logical block 26{36
logical blocks 22{14
logical host 26{36
logical host designator 26{36
logical pathname 26{36
logical-pathname 19{15, 19{27
logical-pathname-translations 19{23
logior 12{71
lognand 12{71
lognor 12{71
lognot 12{71
logorc1 12{71
logorc2 12{71
logtest 12{75
logxor 12{71
long oat 26{36
long-ﬂoat 12{14
long-ﬂoat-epsilon 12{88
long-ﬂoat-negative-epsilon 12{88
long-site-name 25{28
loop 6{38
loop keyword 26{36
loop-ﬁnish 6{42
lower-case-p 13{20lowercase 26{37
machine-instance 25{29
machine-type 25{30
machine-version 25{30
macro 3{18, 26{37
macro character 26{37
macro expansion 26{37
macro form 26{37
macro function 26{37
macro lambda list 3{41, 26{37
macro name 26{37
macro-function 3{73
macroexpand 3{75
macroexpand hook 26{37
macroexpand-1 3{75
*macroexpand-hook* 3{80
macrolet 3{18, 5{20
make-array 15{10
make-broadcast-stream 21{47
make-char A{1
make-concatenated-stream 21{51
make-condition 9{47
make-dispatch-macro-character 23{5
make-echo-stream 21{50
make-hash-table 18{4
make-instance 7{49
make-instances-obsolete 7{50
make-list 14{23
make-load-form 7{51
make-load-form-saving-slots 7{55
make-method 7{73
make-package 11{20
make-pathname 19{17
make-random-state 12{51
make-sequence 17{8
make-string 16{13
make-string-input-stream 21{53
make-string-output-stream 21{53
make-symbol 10{6
make-synonym-stream 21{46
make-two-way-stream 21{48
makunbound 10{21
mandatory-style conditional newline 22{54
map 17{10
map-into 17{12
xii Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
mapc 14{40
mapcan 14{40
mapcar 14{40
mapcon 14{40
maphash 18{12
mapl 14{40
maplist 14{40
mapping 26{37
mask-ﬁeld 12{81
max 7{26, 12{22
member 4{27, 14{39
member-if 14{39
member-if-not 14{39
merge 17{30
merge-pathnames 19{38
metaclass 4{1, 4{9, 26{37
Metaobject Protocol 26{37
method 26{38
method 4{24
method combination 26{38
method-combination 4{26, 25{18
method-combination-error 9{26
method-dening form 26{38
method-dening operator 7{18, 26{38
method-qualiﬁers 7{47
might signal 1{17
min 7{26, 12{22
minimal compilation 3{14, 26{38
Minus (sharpsign reader macro) 2{37
minusp 12{24
miser-style conditional newline 22{17, 22{54
mismatch 17{24
mod 12{19, 12{47
modied lambda list 26{38
*modules* 24{14
most recent 26{38
most-negative-double-ﬂoat 12{87
most-negative-ﬁxnum 12{82
most-negative-long-ﬂoat 12{87
most-negative-short-ﬂoat 12{87
most-negative-single-ﬂoat 12{87
most-positive-double-ﬂoat 12{87
most-positive-ﬁxnum 12{82
most-positive-long-ﬂoat 12{87
most-positive-short-ﬂoat 12{87most-positive-single-ﬂoat 12{87
muﬄe-warning 9{66, 9{68
multiple escape 2{9, 26{38
multiple values 26{38
multiple-value-bind 5{79
multiple-value-call 5{81
multiple-value-list 5{81
multiple-value-prog1 5{82
multiple-value-setq 5{83
multiple-values-limit 5{86
must signal 1{16
name 1{7, 26{39
name-char 13{25
named constant 26{39
namespace 3{1, 26{39
namestring 19{1, 26{39
namestring 19{28
nbutlast 14{33
nconc 7{26, 14{29
newline 26{39
Newline (format directive) 22{42
next method 7{23, 26{39
next-method-p 7{72
nickname 26{39
nil 1{13, 26{39
nil 1{13, 4{19, 5{54
nintersection 14{52
ninth 14{25
no-applicable-method 7{47
no-next-method 7{48
non-atomic 26{39
non-constant variable 26{39
non-correctable 26{40
non-empty 26{40
non-generic function 26{40
non-graphic 13{3, 26{40
non-list 26{40
non-local exit 26{40
non-nil 26{40
non-null lexical environment 26{40
non-simple 26{40
non-terminating 2{8, 26{40
non-top-level form 26{40
normal return 26{40
normalized 26{40
Indexxiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
not 4{27, 5{55
notany 5{67
notation 1{7
notevery 5{67
notinline 3{29, 3{93
nreconc 14{31
nreverse 17{17
nset-diﬀerence 14{56
nset-exclusive-or 14{58
nstring-capitalize 16{7
nstring-downcase 16{7
nstring-upcase 16{7
nsublis 14{13
nsubst 14{15
nsubst-if 14{15
nsubst-if-not 14{15
nsubstitute 17{26
nsubstitute-if 17{26
nsubstitute-if-not 17{26
nth 14{27
nth-value 5{86
nthcdr 14{37
null 13{2, 26{40
null 14{4, 14{28
null lexical environment 3{3, 26{41
number 26{41
number 12{11
numberp 12{54
numerator 12{61
numeric 26{41
nunion 14{61
O (format directive) 22{27
O (sharpsign reader macro) 2{33
object 26{41
object-traversing 26{41
oddp 12{40
open 21{2, 26{41
open 21{32
open-stream-p 21{12
operator 26{41
optimize 3{97
optimize quality 26{41
optional parameter 26{42
or4{28, 5{71, 7{26
order of evaluation 3{63, 5{2, 5{43, 5{83, 6{5,6{9, 7{4, 9{16, 12{79
ordinary function 26{42
ordinary lambda list 3{33, 26{42
otherwise 5{74, 5{77
otherwise inaccessible part 26{42
output 21{1, 26{42
output-stream-p 21{11
P (format directive) 22{40
P (sharpsign reader macro) 2{36
package 11{1, 26{42
package 11{8
package cell 26{42
package designator 26{42
package marker 26{42
package prex 26{42
package registry 26{42
*package* 11{40
package-error 11{41
package-error-package 11{42
package-name 11{36
package-nicknames 11{37
package-shadowing-symbols 11{37
package-use-list 11{38
package-used-by-list 11{39
packagep 11{40
pairlis 14{46
pairwise 26{43
parallel 26{43
parameter 26{43
parameter specializer 26{43
parameter specializer name 26{43
parse-error 9{14
parse-integer 12{66
parse-namestring 19{30
pathname 19{1, 26{43
pathname 2{36, 19{15
pathname designator 26{43
pathname-device 19{20
pathname-directory 19{20
pathname-host 19{20
pathname-match-p 19{34
pathname-name 19{20
pathname-type 19{20
pathname-version 19{20
pathnamep 19{19
xiv Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
peek-char 21{17
Percent (format directive) 22{25
phase 12{58
physical pathname 26{43
pi12{32
place 5{1, 26{43
plist 26{43
Plus (sharpsign reader macro) 2{37
plusp 12{24
pop 14{24
portable 26{43
position 17{21
position-if 17{21
position-if-not 17{21
potential copy 26{44
potential number 26{44
pprint 22{61
pprint dispatch table 22{16, 26{44
pprint-dispatch 22{47
pprint-exit-if-list-exhausted 22{48
pprint-ﬁll 22{49
pprint-indent 22{50
pprint-linear 22{49
pprint-logical-block 22{51
pprint-newline 22{53
pprint-pop 22{55
pprint-tab 22{57
pprint-tabular 22{49
predicate 26{44
prepared to signal 1{16
present 11{2, 24{1, 26{44
pretty print 26{44
pretty printer 22{14, 26{44
pretty printing stream 26{44
primary method 26{44
primary value 26{44
prin1 22{61
prin1-to-string 22{64
princ 22{61
princ-to-string 22{64
principal 26{44
print 22{61
print name 26{45
*print-array* 22{66
*print-base* 22{67*print-case* 22{68
*print-circle* 2{36, 2{37, 22{69
*print-escape* 22{70
*print-gensym* 22{71
*print-length* 22{72
*print-level* 22{72
*print-lines* 22{73
*print-miser-width* 22{74
print-not-readable 22{79
print-not-readable-object 22{79
print-object 22{57
*print-pprint-dispatch* 22{75
*print-pretty* 22{75
*print-radix* 22{67
*print-readably* 22{76
*print-right-margin* 22{78
print-unreadable-object 22{59
printer control variable 22{1, 26{45
printer escaping 22{2, 26{45
printing 26{45
probe-ﬁle 20{3
process 3{14, 26{45
processor 26{45
proclaim 26{45
proclaim 3{81
proclamation 3{29, 26{45
prog 5{87
prog tag 26{45
prog* 5{87
prog1 5{89
prog2 5{89
progn 5{91, 7{26
program 26{45
program-error 5{104
programmer 26{45
programmer code 26{45
progv 5{38
proper list 14{2, 14{4, 26{45
proper name 26{45
proper sequence 26{46
proper subtype 26{46
property 26{46
property indicator 26{46
property list 26{46
property value 26{46
Indexxv
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
provide 24{15
psetf 5{99
psetq 5{40
purports to conform 26{46
push 14{23
pushnew 14{55
qualied method 26{46
qualier 26{46
query I/O 26{46
*query-io* 21{57
Question-Mark (format directive) 22{39
quotation (of forms) 2{24, 2{26, 2{28
quotation (of strings) 2{26
quote 2{24, 2{26, 2{28, 3{65
quoted object 26{46
quux 1{15
R (format directive) 22{25
R (sharpsign reader macro) 2{34
radix 26{47
random 12{52
random state 26{47
random-state 12{50
*random-state* 12{53
random-state-p 12{53
rank 15{1, 26{47
rassoc 14{47
rassoc-if 14{47
rassoc-if-not 14{47
ratio 26{47
ratio 12{16, 22{3
ratio marker 26{47
rational 26{47
rational 12{16, 12{62
rationalize 12{62
rationalp 12{63
read 26{47
read 23{6
*read-base* 2{33, 2{34, 23{19
read-byte 21{15
read-char 21{18
read-char-no-hang 21{19
*read-default-ﬂoat-format* 23{19
read-delimited-list 23{8
*read-eval* 2{33, 23{20
read-from-string 23{10read-line 21{24
read-preserving-whitespace 23{6
read-sequence 21{26
*read-suppress* 23{21
readably 26{47
reader 26{47
reader macro 26{47
reader macro function 2{8, 26{47
reader-error 23{23
readtable 2{1, 26{47
readtable 23{4
readtable case 26{47
readtable designator 26{48
*readtable* 23{22
readtable-case 23{11
readtablep 23{12
real 12{12
realp 12{60
realpart 12{59
recognizable subtype 26{48
redenition 11{5
reduce 17{13
reference 26{48
registered package 26{48
reinitialize-instance 7{31
relative 26{48
:relative 19{7
rem 12{47
remf 14{51
remhash 18{11
remove 17{32
remove-duplicates 17{35
remove-if 17{32
remove-if-not 17{32
remove-method 7{49
remprop 10{19
rename-ﬁle 20{8
rename-package 11{14
repertoire 13{2, 26{48
replace 17{25
report 26{48
report message 9{4, 26{48
require 24{15
required parameter 26{48
rest 14{38
xvi Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
rest list 26{48
rest parameter 26{48
restart 26{48
restart 9{48
restart designator 26{49
restart function 26{49
restart-bind 9{54
restart-case 9{56
restart-name 9{61
return 26{49
return 5{47
return value 26{49
return-from 5{45
revappend 14{31
reverse 17{17
Right-Brace (format directive) 22{39
Right-Bracket (format directive) 22{37
Right-Paren (format directive) 22{40
right-parenthesis 26{49
Right-Parenthesis (reader macro) 2{23
room 25{21
rotatef 5{103
round 12{25
row-major-aref 15{28
rplaca 14{8
rplacd 14{8
run time 3{15, 26{49
run-time compiler 3{15, 26{49
run-time denition 3{15, 26{49
run-time environment 3{15, 26{49
S (format directive) 22{31
S (sharpsign reader macro) 2{36
safe 1{15, 26{49
safe call 3{50, 26{49
safety 3{29, 3{97
same 26{49
satisﬁes 4{26
satisfy the test 17{2, 17{4, 26{50
sbit 15{36
scale-ﬂoat 12{82
schar 16{5
scope 26{50
script 26{50
search 17{23
second 14{25secondary value 26{50
section 26{50
sections 22{14
self-evaluating object 26{50
semi-standard 26{50
semicolon 26{51
Semicolon (format directive) 22{40
Semicolon (reader macro) 2{24
sequence 17{1, 26{51
sequence 17{5
sequence function 17{1, 26{51
sequential 26{51
sequentially 26{51
serious condition 26{51
serious-condition 9{12
session 26{51
set 26{51
set 10{22
set-char-bit A{1
set-diﬀerence 14{56
set-dispatch-macro-character 23{13
set-exclusive-or 14{58
set-macro-character 23{14
set-pprint-dispatch 22{60
set-syntax-from-char 23{16
setf 5{99, 25{18
setf expander 26{51
setf expansion 26{51
setf function 26{51
setf function name 26{51
setq 5{39
seventh 14{25
shadow 3{11, 4{8, 26{51
shadow 11{15
shadowing symbol 11{3, 11{4, 26{51
shadowing symbols list 26{51
shadowing-import 11{16
shared slot 26{52
shared-initialize 7{32
sharpsign 26{52
Sharpsign (reader macro) 2{29
Sharpsign (sharpsign reader macro) 2{37
Sharpsign A (reader macro) 2{35
Sharpsign Asterisk (reader macro) 2{32
Sharpsign B (reader macro) 2{33
Indexxvii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Sharpsign Backslash (reader macro) 2{31
Sharpsign C (reader macro) 2{34
Sharpsign Colon (reader macro) 2{33
Sharpsign Dot (reader macro) 2{33
Sharpsign Equal-Sign (reader macro) 2{36
Sharpsign Left-Parenthesis (reader macro) 2{31
Sharpsign Less-Than-Sign (reader macro) 2{39
Sharpsign Minus (reader macro) 2{37
Sharpsign O (reader macro) 2{33
Sharpsign P (reader macro) 2{36
Sharpsign Plus (reader macro) 2{37
Sharpsign R (reader macro) 2{34
Sharpsign Right-Parenthesis 2{40
Sharpsign S (reader macro) 2{36
Sharpsign Sharpsign (reader macro) 2{37, 22{56
Sharpsign Single-Quote (reader macro) 2{31
Sharpsign Vertical-Bar (reader macro) 2{38
Sharpsign Whitespace 2{39, 2{40
Sharpsign X (reader macro) 2{34
shiftf 5{101
short oat 26{52
short-ﬂoat 12{14
short-ﬂoat-epsilon 12{88
short-ﬂoat-negative-epsilon 12{88
short-site-name 25{28
should signal 1{16
sign 26{52
signal 1{16, 1{17, 26{52
signal 9{27
signature 26{52
signed-byte 12{17
signum 12{48
similar 3{23, 26{52
similarity 26{52
simple 26{52
simple array 26{52
simple bit array 26{52
simple bit vector 26{52
simple condition 26{52
simple general vector 26{52
simple string 26{52
simple vector 26{53
simple-array 15{6
simple-base-string 16{4
simple-bit-vector 2{32, 15{10simple-bit-vector-p 15{40
simple-condition 9{28
simple-condition-format-arguments 9{29
simple-condition-format-control 9{29
simple-error 9{25
simple-string 16{3
simple-string-p 16{4
simple-type-error 4{42
simple-vector 2{31, 15{8
simple-vector-p 15{31
simple-warning 9{31
sin 12{28
single escape 2{9, 26{53
single oat 26{53
single-ﬂoat 12{14
single-ﬂoat-epsilon 12{88
single-ﬂoat-negative-epsilon 12{88
single-quote 26{53
Single-Quote (reader macro) 2{24
Single-Quote (sharpsign reader macro) 2{31
singleton 26{53
sinh 12{33
situation 26{53
sixth 14{25
slash 26{53
Slash (format directive) 22{33
sleep 25{7
slot 26{53
slot specier 4{10, 26{53
slot-boundp 7{40
slot-exists-p 7{41
slot-makunbound 7{42
slot-missing 7{43
slot-unbound 7{44
slot-value 7{45
software-type 25{31
software-version 25{31
some 5{67
sort 17{18
source code 24{1, 26{53
source le 24{1, 26{53
space 26{53
space 3{97
special 3{29, 3{98
special form 26{53
xviii Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
special operator 26{53
special variable 26{53
special-operator-p 3{103
specialize 26{54
specialized 26{54
specialized lambda list 3{40, 26{54
speed 3{97
spreadable argument list designator 26{54
sqrt 12{49
stable-sort 17{18
stack allocate 26{54
stack-allocated 26{54
standard 7{24, 7{26
standard character 2{2, 26{54
standard class 26{54
standard generic function 26{54
standard input 26{54
standard method combination 26{54
standard object 26{54
standard output 26{55
standard pprint dispatch table 26{55
standard readtable 2{1, 26{55
standard syntax 2{1, 26{55
standard-char 13{9
standard-char-p 13{18
standard-class 4{24
standard-generic-function 4{23
*standard-input* 21{57
standard-method 4{25
standard-object 4{25
*standard-output* 21{57
standardized 26{55
startup environment 3{14, 26{55
step 26{55
step 25{13
storage-condition 9{15
store-value 9{67, 9{68
stream 20{1, 21{1, 21{2, 26{55
stream 21{7
stream associated with a le 20{1, 26{55
stream designator 26{56
stream element type 26{56
stream variable 21{4, 26{56
stream variable designator 26{56
stream-element-type 21{13stream-error 21{60
stream-error-stream 21{60
stream-external-format 21{36
streamp 21{14
string 15{3, 26{56
string 2{26, 16{2, 16{6
string designator 26{56
string equal 26{56
string stream 26{56
string-capitalize 16{7
string-char A{1
string-char-p A{1
string-downcase 16{7
string-equal 16{10
string-greaterp 16{10
string-left-trim 16{9
string-lessp 16{10
string-not-equal 16{10
string-not-greaterp 16{10
string-not-lessp 16{10
string-right-trim 16{9
string-stream 21{10
string-trim 16{9
string-upcase 16{7
string/= 16{10
string <16{10
string <=16{10
string= 16{10
string >16{10
string >=16{10
stringp 16{12
structure 26{56
structure 2{36, 25{19
structure class 26{56
structure name 26{56
structure-class 4{24
structure-object 4{25
style warning 26{56
style-warning 9{12
subclass 4{8, 26{56
subexpression 26{57
subform 26{57
sublis 14{13
subrepertoire 26{57
subseq 17{9
Indexxix
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
subsetp 14{59
subst 14{15
subst-if 14{15
subst-if-not 14{15
substitute 17{26
substitute-if 17{26
substitute-if-not 17{26
subtype 26{57
subtypep 4{34
superclass 4{8, 26{57
supertype 26{57
supplied-p parameter 26{57
svref 15{32
sxhash 18{15
symbol 26{57
symbol 2{33, 10{2
symbol macro 3{18, 26{57
symbol-function 10{11
symbol-macrolet 3{18, 3{79
symbol-name 10{13
symbol-package 10{14
symbol-plist 10{15
symbol-value 10{16
symbolp 10{4
synonym stream 26{57
synonym stream symbol 26{57
synonym-stream 21{10
synonym-stream-symbol 21{46
syntax type 2{5, 26{57
SYSTEM package A{1
system class 26{58
system code 26{58
t26{58
t4{26, 5{55, 5{74, 5{77, 25{18, 25{19
T (format directive) 22{34
tag 26{58
tagbody 5{48
tail 26{58
tailp 14{35
tan 12{28
tanh 12{33
target 26{58
tenth 14{25
terminal I/O 26{58
*terminal-io* 21{59terminating 2{8, 26{58
terpri 21{21
tertiary value 26{58
the 3{102
third 14{25
throw 26{58
throw 5{49
tilde 26{58
Tilde (format directive) 22{25
Tilde A (format directive) 22{31
Tilde Ampersand (format directive) 22{25
Tilde Asterisk (format directive) 22{36
Tilde B (format directive) 22{26
Tilde C (format directive) 22{24
Tilde Circumex (format directive) 22{41
Tilde D (format directive) 22{26
Tilde Dollarsign (format directive) 22{30
Tilde E (format directive) 22{28
Tilde F (format directive) 22{27
Tilde G (format directive) 22{30
Tilde Greater-Than-Sign (format directive) 22{
36
Tilde I (format directive) 22{33
Tilde Left-Brace (format directive) 22{37
Tilde Left-Bracket (format directive) 22{36
Tilde Left-Paren (format directive) 22{39
Tilde Less-Than-Sign (format directive) 22{32,
22{35
Tilde Newline (format directive) 22{42
Tilde O (format directive) 22{27
Tilde P (format directive) 22{40
Tilde Percent (format directive) 22{25
Tilde Question-Mark (format directive) 22{39
Tilde R (format directive) 22{25
Tilde Right-Brace (format directive) 22{39
Tilde Right-Bracket (format directive) 22{37
Tilde Right-Paren (format directive) 22{40
Tilde S (format directive) 22{31
Tilde Semicolon (format directive) 22{40
Tilde Slash (format directive) 22{33
Tilde T (format directive) 22{34
Tilde Tilde (format directive) 22{25
Tilde Underscore (format directive) 22{32
Tilde Vertical-Bar (format directive) 22{25
Tilde W (format directive) 22{32
xx Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Tilde X (format directive) 22{27
time 26{58
time 25{14
time zone 26{59
token 2{6, 26{59
top level form 26{59
trace 25{12
trace output 26{59
*trace-output* 21{57
translate-logical-pathname 19{35
translate-pathname 19{36
tree 14{1, 26{59
tree structure 26{59
tree-equal 14{18
true 26{59
truename 20{2, 26{59
truename 20{5
truncate 12{25
two-way stream 26{59
two-way-stream 21{11
two-way-stream-input-stream 21{49
two-way-stream-output-stream 21{49
type 26{59
type 3{90, 25{19
type declaration 26{60
type equivalent 26{60
type expand 26{60
type specier 26{60
type-error 4{41
type-error-datum 4{41
type-error-expected-type 4{41
type-of 4{37
typecase 5{76
typep 4{39
unbound 26{60
unbound variable 26{60
unbound-slot 7{90
unbound-slot-instance 7{91
unbound-variable 10{23
undened consequences 1{17
undened function 26{60
undeﬁned-function 5{104
Underscore (format directive) 22{32
unexport 11{24
unintern 26{60unintern 11{25
uninterned 26{60
union 14{61
universal time 25{3, 26{60
unless 5{72
unqualied method 26{60
unread-char 21{22
unregistered package 26{60
unsafe 1{16, 26{60
unsafe call 3{51, 26{61
unsigned-byte 12{18
:unspecific 19{6
unspecied consequences 1{17
unspecied values 1{17
untrace 25{12
unuse-package 11{27
unwind-protect 5{51
:up 19{8
update-instance-for-diﬀerent-class 7{34
update-instance-for-redeﬁned-class 7{35
upgrade 26{61
upgraded array element type 15{3, 26{61
upgraded complex part type 26{61
upgraded-array-element-type 15{29
upgraded-complex-part-type 12{60
upper-case-p 13{20
uppercase 26{61
use 26{61
use list 26{61
use-package 11{28
use-value 9{68
user 26{61
USER package A{1
user-homedir-pathname 25{32
valid array dimension 26{61
valid array index 26{62
valid array row-major index 26{62
valid ll pointer 26{62
valid logical pathname host 26{62
valid pathname device 26{62
valid pathname directory 26{62
valid pathname host 26{62
valid pathname name 26{62
valid pathname type 26{62
valid pathname version 26{62
Indexxxi
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
valid physical pathname host 26{62
valid sequence index 26{62
value 26{63
value cell 26{63
values 4{29, 5{84
values-list 5{85
variable 26{63
variable 25{19
vector 15{1, 26{63
vector 2{31, 15{7, 15{33
vector-pop 15{33
vector-push 15{34
vector-push-extend 15{34
vectorp 15{36
vertical-bar 26{63
Vertical-Bar (format directive) 22{25
Vertical-Bar (sharpsign reader macro) 2{38
W (format directive) 22{32
warn 9{29
warning 9{11
warning 1{18
when 5{72
whitespace 26{63
wild 26{63
:wild 19{5, 19{8
:wild-inferiors 19{5, 19{8
wild-pathname-p 19{33
with-accessors 7{56
with-compilation-unit 24{8
with-condition-restarts 9{62
with-hash-table-iterator 18{13
with-input-from-string 21{54
with-open-ﬁle 21{37
with-open-stream 21{40
with-output-to-string 21{55
with-package-iterator 11{21
with-simple-restart 9{63
with-slots 7{58
with-standard-io-syntax 23{17
write 26{63
write 22{61
write-byte 21{16
write-char 21{23
write-line 21{25
write-sequence 21{27write-string 21{25
write-to-string 22{64
writer 26{63
X (format directive) 22{27
X (sharpsign reader macro) 2{34
y-or-n-p 21{44
yes-or-no-p 21{44
yield 26{64
zerop 12{25
‘2{26
xxii Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Credits
Principal Technical Editors:
Kent M. Pitman Harlequin, Inc. 1993-present
Symbolics, Inc. 1990-1992
Kathy Chapman Digital Equipment Corporation 1987-1989
Occasional Guest Editors:
Richard P. Gabriel Lucid, Inc.
Sandra Loosemore self
Financial Contributors to the Editing Process:
Digital Equipment Corporation
Harlequin, Ltd. andHarlequin, Inc.
Symbolics, Inc.
Apple, Inc.
Franz, Inc.
Lucid, Inc.
Special thanks to Guy L. Steele Jr. and Digital Press for producing Common Lisp:
The Language , and for relaxing copyright restrictions enough to make it possible
for that document's text to provide an early basis of this work.
Creditsi
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Edit and Review History:
01-Jan-89 Chapman Draft of Chapters 1.1 (scope).
01-Jan-89 Pitman Draft of Chapters 5.1 (conditions).
01-May-89 Chapman Draft of 1.2{1.6.
01-May-89 Gabriel Rewrite of Chapters 1.1 and 5.1.
01-Jun-89 Loosemore Review of Chapter 4.2.
01-Jun-89 Pitman Review of Glossary
15-Jun-89 Gabriel Rewrite of Glossary
16-Jun-89 Margolin Comments on Chapters 2.1{2.4 (types, objects).
23-Jun-89 Gabriel Rewrite of 4.2.
07-Jul-89 Moon Review of Chapters 4.1, 4.3
12-Jul-89 Gabriel Revision of 4.2.
15-Jul-89 Pitman Review of Glossary
18-Jul-89 Gray Comments on 5.1
25-Jul-89 Gabriel Revision of Chapters 1.2{1.6, 2.2
26-Jul-89 Gabriel Rewrite of 5.1
26-Jul-89 Gabriel Rewrite of 4.1.
27-Jul-89 Pitman Revision of 5.1
27-Jul-89 Gabriel Revision of 5.1
28-Jul-89 Chapman Draft of 2.2, 3.2, 3.3, 5.4
28-Jul-89 Gabriel Revision of Glossary.
01-Oct-89 Margolin Review of Dictionary from Jun-89 draft.
20-Jan-91 Pitman Draft 8.81 (for X3J13 review). Document X3J13/91-101.
29-Jan-91 Waters Review of 8.81/Chapter 23 (Printer).
01-Mar-91 Moon Review of 8.81/Chapter 4 (Evaluation and Compilation).
01-Mar-91 Barrett Review of 8.81/Chapter 4 (Evaluation and Compilation).
01-Mar-91 Moon Review of 8.81/Glossary.
13-Mar-90 Wechsler Review of 8.81/Glossary.
21-Mar-91 Kerns Review of 8.81/Chapter 1.
26-Apr-91 Margolin Review of 8.81/Chapters 1{12.
15-May-91 Barrett Review of 8.81/Chapters 5 (Misc), 11 (Conditions).
04-Jun-91 Laddaga Review of 9.60/Chapter 20 (Pathnames).
10-Jun-91 Pitman Draft 9.126 (for X3J13 review). Document X3J13/91-102.
02-Sep-91 Barrett Review of 9.28/Chapter 4 (Evaluation and Compilation).
02-Sep-91 Barrett Review of 9.52/Chapter 4 (Evaluation and Compilation).
15-Sep-91 Barrett Review of 9.126/Chapter 4 (Evaluation and Compilation)
and Chapter 7 (Evaluation/Compilation).
(some comments not yet merged)
18-Sep-91 Wechsler Review of 9.126.
21-Sep-91 Barrett Review of 10.16/Chapter 7 (Evaluation/Compilation).
(some comments not yet merged)
28-Sep-91 Barrett Review of 10.95/Chapter 25 (Printer).
(some comments not yet merged)
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13-Oct-91 Barrett Review (and help editing) of 10.104/Chapter 4
(Evaluation and Compilation)
15-Oct-91 Waters Review of 10.95/Chapter 25 (Printer).
24-Oct-91 Pitman Draft 10.156 (for X3J13 review). Document X3J13/91-103.
04-Nov-91 Moon Review of 10.156/Chapter 5 (Data and Control Flow)
and Chapter 26 (Glossary).
11-Nov-91 Loosemore Review of 10.156/Chapter 2 (Syntax),
Chapter 3 (Evaluation and Compilation),
Chapter 5 (Data and Control Flow), and Chapter 8 (Structures).
02-Dec-91 Barrett Review of 10.156/Chapter 4 (Types and Classes),
and Chapter 10 (Symbols).
02-Dec-91 Barrett Review of 10.156/Chapter 3 (Evaluation and Compilation),
Chapter 6 (Iteration), Chapter 9 (Conditions),
and Chapter 14 (Conses).
(some comments not yet merged)
09-Dec-91 Gabriel Review of 10.156/Chapter 1 (Introduction),
Chapter 2 (Syntax), and Chapter 3 (Evaluation and Compilation).
09-Dec-91 Ida Light review of 10.156/Chapters 1-5.
09-Dec-91 Moon Review of 10.156/Chapter 3 (Evaluation and Compilation).
(some comments not yet merged)
10-Dec-91 Loosemore Review of 10.156/Chapter 10 (Symbols),
Chapter 20 (Files), and Chapter 13 (Characters).
10-Dec-91 Loosemore Review of 10.156/Chapter 14 (Conses).
(some comments not yet merged)
10-Dec-91 Laubsch Review of 10.156/Chapters 1 (Introduction),
Chapter 2 (Syntax), Chapter 3 (Evaluation and Compilation),
Chapter 4 (Types and Classes), Chapter 5 (Data and Control Flow),
Chapter 7 (Objects), Chapter 11 (Packages),
Chapter 19 (Filenames), and Chapter 21 (Streams).
18-Dec-91 Margolin Review of 10.156/Chapter 18 (Hash Tables).
04-Jan-92 White Review of 10.156/Chapter 6 (Iteration),
Chapter 11 (Packages), Chapter 18 (Hash Tables),
and Chapter 23 (Reader).
04-Jan-92 White Review of 10.156/Chapter 26 (Glossary).
(some comments not yet merged)
04-Jan-92 Barrett Review of 10.156/Chapter 18 (Hash Tables) and Chapter 16 (Strings).
04-Jan-92 Barrett Review of 10.156/Chapter 15 (Arrays) and Chapter 21 (Streams).
(some comments not yet merged)
06-Jan-92 Loosemore Review of 10.156/Chapter 16 (Strings),
Chapter 17 (Sequences), and Chapter 25 (Environment).
06-Jan-92 Loosemore Review of 10.156/Chapter 21 (Streams) and Chapter 23 (Reader).
(some comments not yet merged)
06-Jan-92 Margolin Review of 10.156/Chapter 2 (Syntax).
07-Jan-92 Margolin Review of 10.156/Chapter 4 (Types and Classes).
03-Feb-92 Aspinall Review of 10.156/Chapter 12 (Numbers).
Creditsiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
16-Feb-92 Pitman Draft 11.82 (for X3J13 letter ballot). Document X3J13/92-101.
16-Mar-92 Loosemore Review of 11.82/Chapter 1, 3, 4, 5, 7, 8, 9, 10,
11, 12, 18, 22, 23, 24, 25, and 26.
16-Feb-92 Pitman Draft 12.24 (for X3 consideration). Document X3J13/92-102.
09-Sep-92 Samson Public Review Comments (#1). Documents X3J13/92-1001 to 92-1003.
22-Oct-92 Rose, Yen Public Review Comments (#2). Documents X3J13/92-1101 to 92-1103.
23-Oct-92 Staley Public Review Comments (#3). Documents X3J13/92-1201 to 92-1204.
09-Nov-92 Barrett Public Review Comments (#4). Documents X3J13/92-3101 to 92-3110.
11-Nov-92 Moon Public Review Comments (#5). Documents X3J13/92-3201 to 92-3248.
17-Nov-92 Loosemore Public Review Comments (#6). Documents X3J13/92-1301 to 92-1335.
23-Nov-92 Margolin Public Review Comments (#7). Documents X3J13/92-1401 to 92-1419.
23-Nov-92 Withington Public Review Comments (#8a). Documents X3J13/92-1501 to 92-1512.
23-Nov-92 Feinberg Public Review Comments (#8b). Documents X3J13/92-1601 to 92-1603.
23-Nov-92 Wechsler Public Review Comments (#8c). Documents X3J13/92-1701 to 92-1703.
23-Nov-92 Moore Public Review Comments (#9). Documents X3J13/92-1801 to 92-1802.
23-Nov-92 Flanagan Public Review Comments (#10). Documents X3J13/92-1901 to 92-1910.
23-Nov-92 Dalton Public Review Comments (#11). Documents X3J13/92-2001 to 92-2012.
23-Nov-92 Gallagher Public Review Comments (#12). Documents X3J13/92-2101 to 92-2103.
23-Nov-92 Norvig Public Review Comments (#13). Documents X3J13/92-2201 to 92-2208.
24-Nov-92 Robertson Public Review Comments (#14). Document X3J13/92-2301.
23-Nov-92 Kawabe Public Review Comments (#15). Documents X3J13/92-2401 to 92-2403.
23-Nov-92 Barrett Public Review Comments (#16). Documents X3J13/92-2511 to X3J13/92-2531.
23-Nov-92 Wertheimer Public Review Comments (#17). Document X3J13/92-2601.
24-Nov-92 Pitman Public Review Comments (#18). Documents X3J13/92-2701 to 92-2742.
24-Nov-92 Mato Mira Public Review Comments (#19). Documents X3J13/92-2801 to 92-2805.
24-Nov-92 Philpot Public Review Comments (#20). Document X3J13/92-2901.
23-Nov-92 Cerys Public Review Comments (#21). Document X3J13/92-3001.
30-Aug-93 Pitman Draft 13.65 (for X3J13 consideration). Document X3J13/93-101.
04-Oct-93 X3J13 Minor xes to Draft 13.65 before sending to X3.
05-Oct-93 Pitman Draft 14.10 (for X3 consideration). Document X3J13/93-102.
08-Nov-93 Dalton \reply to reply to pr comments". Document X3J13/94-311.
04-Apr-94 Boyer, Kaufmann, Moore
Public Review Comments (#1). Document X3J13/94-305.
05-Apr-94 Pitman Public Review Comments (#2). Document X3J13/94-306.
14-Mar-94 Schulenburg Public Review Comments (#3). Document X3J13/94-307.
04-Apr-94 Shepard Late commentary. Document X3J13/94-309.
05-May-94 X3J13 Editorial-only changes to Draft 14.10 in response to comments.
10-May-94 Pitman Draft 15.17 (for X3 consideration). Document X3J13/94-101.
12-Aug-94 X3J13 Letter ballot to make specic corrections to Credits.
Drafts 15.17 and 15.17R are identical except for:
Changes to document date and version number.
Disclaimer added to back of cover page.
Changes to this Edit and Review History, page Credits iv .
Changes to names and headings, pages Credits v-vii .
12-Aug-94 Pitman Draft 15.17R (for X3 consideration). Document X3J13/94-101R.
ivProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The following lists of information are almost certainly incomplete, but it was
felt that it was better to risk publishing incomplete information than to fail to
acknowledge important contributions by the many people and organizations who
have contributed to this eort.
Mention here of any individual or organization does not imply endorsement of this
document by that individual or organization.
Ad Hoc Group Chairs:
Characters Linden, Thom
Charter Ennis, Susan P.
Compiler Specication Haich, Steven M.
Loosemore, Sandra
Editorial Chapman, Kathy
van Roggen, Walter
Error and Condition System Pitman, Kent M.
Graphics & Windows Douglas Rand
Schoen, Eric
Iteration Facility White, JonL
Language Cleanup Masinter, Larry
Fahlman, Scott
Lisp 1/Lisp 2 Gabriel, Richard P.
Macros Haich, Steven M.
Pitman, Kent M.
Wegman, Mark
Object System Bobrow, Daniel G.
Presentation of Standard Brown, Gary L.
Pretty Printer Waters, Richard C.
Public Review Ida, Masayuki
Types & Declarations Scherlis, William L.
Validation Berman, Richard
Major Administrative Contributions:
Barrett, Kim Mathis, Robert
Brown, Gary L. Pitman, Kent M.
Eiron, Hanoch Steele, Guy L., Jr.
Gabriel, Richard P. Tyson, Mabry
Haich, Steven M. Van Deusen, Mary
Ida, Masayuki White, JonL
Loeer, David D. Whittemore, Susan
Loosemore, Sandra Woodyatt, Anne
Masinter, Larry Zubko, Jan L.
Creditsv
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Major Technical Contributions:
Barrett, Kim A. Keene, Sonya Moon, David A.
Bobrow, Daniel G. Kempf, James Perdue, Crispin
Daniels, Andy Kerns, Robert W. Pitman, Kent M.
DeMichiel, Linda G. Kiczales, Gregor Steele, Guy L., Jr.
Dussud, Patrick H. Loosemore, Sandra Waters, Richard C.
Fahlman, Scott Margolin, Barry Weinreb, Daniel
Gabriel, Richard P. Masinter, Larry White, JonL
Ida, Masayuki Mlynarik, Richard
Participating Companies and Organizations:
AI Architects, Inc. Lucid, Inc.
Amoco Production Co. MCC
Aoyama Gakuin University MIT
Apple Computer MITRE Corporation
Boeing Advanced Technology Center MSC
Carnegie-Mellon University NASA Ames Research Center
Chestnut Software National Bureau of Standards
Computer Sciences Nihon Symbolics
Computer & Business Equipment Manufacturing Association (X3 Secretariat)
CONTEL ParcPlace Systems, Inc.
CSC Prime Computer
DARPA Siemens
Digital Equipment Corporation Southern Illinois University
Encore Sperry
Evans & Sutherland SRI International
Franz, Inc. Sun Microsystems
Gigamos Symbolics
GMD Tektronix
Gold Hill Texas Instruments
Grumman Data Systems Corporation The Aerospace Corporation
Harlequin, Ltd. Thinking Machines Corporation
Hewlett-Packard Unisys
Honeywell University of Bath
IBM University of Edinburgh
Ibuki University of Maryland
Integrated Inference Machines University of Utah
International LISP Associates US Army
Johnson Controls, Inc. USC/ISI
LMI Xerox
viProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Individual Participants:
Adler, Annette Haich, Steven M. Peck, Je
Allen, Stanley Harris, Richard M. Pellegrino, Bob
Antonisse, Jim Hendler, Jim Perdue, Crispin
Arbaugh, Bill Hewitt, Carl Philipp, Christopher
Balzer, Bob Hornig, Charles Pierson, Dan
Barrett, Kim Ida, Masayuki Pitman, Kent M.
Bartley, David H. Kachurik, Catherine A. Posner, Dave
Beckerle, Michael Kahn, Ken Raghavan, B.
Beiser, Paul Keene, Sonya Rand, Douglas
Benson, Eric Keller, Shaun Rininger, Je
Berman, Richard Kempf, James Rosenking, Jerey P.
Bobrow, Daniel G. Kerns, Robert W. Scherlis, William L.
Boelk, Mary P. Kiczales, Gregor Shiota, Eiji
Brittain, Skona Kolb, Dieter Sizer, Andy
Brown, Gary L. Koschmann, Timothy Slater, David
Chailloux, Jerome Kosinski, Paul Sodan, Angela
Chapman, Kathy Larson, Aaron Soley, Richard M.
Clinger, Will Latto, Andy Squires, Stephen L.
Coee, Peter C. Laubsch, Joachim St. Clair, Bill
Cugini, John Layer, Kevin Stanhope, Philip
Curtis, Pavel Linden, Thom Steele, Guy L., Jr.
Dabrowski, Christopher Loeer, David D. Tucker, Paul
Daessler, Klaus Loosemore, Sandra Turba, Thomas
Dalton, Je Magataca, Mituhiro Unietis, Dave
Daniels, Andy Margolin, Barry Van Deusen, Mary
DeMichiel, Linda G. Masinter, Larry van Roggen, Walter
Doi, Takumi Mathis, Robert Waldrum, Ellen
Drescher, Gary Matthews, David C. Waters, Richard C.
Duggan, Jerry McCarthy, John Wechsler, Allan
Dussud, Patrick H. Mikelsons, Martin Wegman, Mark
Ennis, Susan P. Mlynarik, Richard Weinreb, Daniel
Fahlman, Scott Moon, David A. Weyhrauch, Richard
Frayman, Felix Moore, Timothy White, JonL
Gabriel, Richard P. Nicoud, Stephen Wieland, Alexis
Giansiracusa, Bob Nilsson, Jarl Withington, P. Tucker
Goldstein, Brad O'Dell, Jim Wright, Whitman
Gray, David Ohlander, Ron York, Bill
Greenblatt, Richard Padget, Julian Zacharias, Gail
Hadden, George D. Palter, Gary Zubko, Jan L.
Creditsvii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
viii Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
1. Introduction
Introduction ix
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
xProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.1 Scope, Purpose, and History
1.1.1 Scope and Purpose
The specication set forth in this document is designed to promote the portability of Common
Lisp programs among a variety of data processing systems. It is a language specication aimed
at an audience of implementors and knowledgeable programmers. It is neither a tutorial nor an
implementation guide.
1.1.2 History
Lisp is a family of languages with a long history. Early key ideas in Lisp were developed by
John McCarthy during the 1956 Dartmouth Summer Research Project on Articial Intelligence.
McCarthy's motivation was to develop an algebraic list processing language for articial intelligence
work. Implementation eorts for early dialects of Lisp were undertaken on the IBM 704, the
IBM 7090, the Digital Equipment Corporation (DEC) PDP-1, the DEC PDP-6, and the PDP-10.
The primary dialect of Lisp between 1960 and 1965 was Lisp 1.5. By the early 1970's there were
two predominant dialects of Lisp, both arising from these early eorts: MacLisp and Interlisp.
For further information about very early Lisp dialects, see The Anatomy of Lisp orLisp 1.5
Programmer's Manual .
MacLisp improved on the Lisp 1.5 notion of special variables and error handling. MacLisp also
introduced the concept of functions that could take a variable number of arguments, macros,
arrays, non-local dynamic exits, fast arithmetic, the rst good Lisp compiler, and an emphasis
on execution speed. By the end of the 1970's, MacLisp was in use at over 50 sites. For further
information about Maclisp, see Maclisp Reference Manual, Revision 0 orThe Revised Maclisp
Manual .
Interlisp introduced many ideas into Lisp programming environments and methodology. One of the
Interlisp ideas that inuenced Common Lisp was an iteration construct implemented by Warren
Teitelman that inspired the loop macro used both on the Lisp Machines and in MacLisp, and now
in Common Lisp. For further information about Interlisp, see Interlisp Reference Manual .
Although the rst implementations of Lisp were on the IBM 704 and the IBM 7090, later work
focussed on the DEC PDP-6 and, later, PDP-10 computers, the latter being the mainstay of Lisp
and articial intelligence work at such places as Massachusetts Institute of Technology (MIT),
Stanford University, and Carnegie Mellon University (CMU) from the mid-1960's through much
of the 1970's. The PDP-10 computer and its predecessor the PDP-6 computer were, by design,
especially well-suited to Lisp because they had 36-bit words and 18-bit addresses. This architecture
allowed a cons cell to be stored in one word; single instructions could extract the carandcdrparts.
The PDP-6 and PDP-10 had fast, powerful stack instructions that enabled fast function calling.
But the limitations of the PDP-10 were evident by 1973: it supported a small number of researchers
using Lisp, and the small, 18-bit address space ( 218=262,144 words) limited the size of a single
program. One response to the address space problem was the Lisp Machine, a special-purpose
computer designed to run Lisp programs. The other response was to use general-purpose computers
Introduction 1–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with address spaces larger than 18 bits, such as the DEC VAX and the S-1 Mark IIA. For further
information about S-1 Common Lisp, see \S-1 Common Lisp Implementation."
The Lisp machine concept was developed in the late 1960's. In the early 1970's, Peter Deutsch,
working with Daniel Bobrow, implemented a Lisp on the Alto, a single-user minicomputer,
using microcode to interpret a byte-code implementation language. Shortly thereafter, Richard
Greenblatt began work on a dierent hardware and instruction set design at MIT. Although the
Alto was not a total success as a Lisp machine, a dialect of Interlisp known as Interlisp-D became
available on the D-series machines manufactured by Xerox|the Dorado, Dandelion, Dandetiger,
and Dove (or Daybreak). An upward-compatible extension of MacLisp called Lisp Machine Lisp
became available on the early MIT Lisp Machines. Commercial Lisp machines from Xerox, Lisp
Machines (LMI), and Symbolics were on the market by 1981. For further information about Lisp
Machine Lisp, see Lisp Machine Manual .
During the late 1970's, Lisp Machine Lisp began to expand towards a much fuller language.
Sophisticated lambda lists, setf, multiple values, and structures like those in Common Lisp are
the results of early experimentation with programming styles by the Lisp Machine group. Jonl
White and others migrated these features to MacLisp. Around 1980, Scott Fahlman and others at
CMU began work on a Lisp to run on the Scientic Personal Integrated Computing Environment
(SPICE) workstation. One of the goals of the project was to design a simpler dialect than Lisp
Machine Lisp.
The Macsyma group at MIT began a project during the late 1970's called the New Implementation
of Lisp (NIL) for the VAX, which was headed by White. One of the stated goals of the NIL project
was to x many of the historic, but annoying, problems with Lisp while retaining signicant
compatibility with MacLisp. At about the same time, a research group at Stanford University and
Lawrence Livermore National Laboratory headed by Richard P. Gabriel began the design of a Lisp
to run on the S-1 Mark IIA supercomputer. S-1 Lisp, never completely functional, was the test bed
for adapting advanced compiler techniques to Lisp implementation. Eventually the S-1 and NIL
groups collaborated. For further information about the NIL project, see \NIL|A Perspective."
The rst eort towards Lisp standardization was made in 1969, when Anthony Hearn and Martin
Griss at the University of Utah dened Standard Lisp|a subset of Lisp 1.5 and other dialects|to
transport REDUCE, a symbolic algebra system. During the 1970's, the Utah group implemented
rst a retargetable optimizing compiler for Standard Lisp, and then an extended implementation
known as Portable Standard Lisp (PSL). By the mid 1980's, PSL ran on about a dozen kinds of
computers. For further information about Standard Lisp, see \Standard LISP Report."
PSL and Franz Lisp|a MacLisp-like dialect for Unix machines|were the rst examples of widely
available Lisp dialects on multiple hardware platforms.
One of the most important developments in Lisp occurred during the second half of the 1970's:
Scheme. Scheme, designed by Gerald J. Sussman and Guy L. Steele Jr., is a simple dialect of Lisp
whose design brought to Lisp some of the ideas from programming language semantics developed
in the 1960's. Sussman was one of the prime innovators behind many other advances in Lisp
technology from the late 1960's through the 1970's. The major contributions of Scheme were lexical
scoping, lexical closures, rst-class continuations, and simplied syntax (no separation of value cells
1–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
and function cells). Some of these contributions made a large impact on the design of Common
Lisp. For further information about Scheme, see IEEE Standard for the Scheme Programming
Language or \Revised3Report on the Algorithmic Language Scheme."
In the late 1970's object-oriented programming concepts started to make a strong impact on Lisp.
At MIT, certain ideas from Smalltalk made their way into several widely used programming systems.
Flavors, an object-oriented programming system with multiple inheritance, was developed at MIT
for the Lisp machine community by Howard Cannon and others. At Xerox, the experience with
Smalltalk and Knowledge Representation Language (KRL) led to the development of Lisp Object
Oriented Programming System (LOOPS) and later Common LOOPS. For further information on
Smalltalk, see Smalltalk-80: The Language and its Implementation . For further information on
Flavors, see Flavors: A Non-Hierarchical Approach to Object-Oriented Programming .
These systems inuenced the design of the Common Lisp Object System (CLOS). CLOS was
developed specically for this standardization eort, and was separately written up in \Common
Lisp Object System Specication." However, minor details of its design have changed slightly since
that publication, and that paper should not be taken as an authoritative reference to the semantics
of the object system as described in this document.
In 1980 Symbolics and LMI were developing Lisp Machine Lisp; stock-hardware implementation
groups were developing NIL, Franz Lisp, and PSL; Xerox was developing Interlisp; and the SPICE
project at CMU was developing a MacLisp-like dialect of Lisp called SpiceLisp.
In April 1981, after a DARPA-sponsored meeting concerning the splintered Lisp community,
Symbolics, the SPICE project, the NIL project, and the S-1 Lisp project joined together to dene
Common Lisp. Initially spearheaded by White and Gabriel, the driving force behind this grassroots
eort was provided by Fahlman, Daniel Weinreb, David Moon, Steele, and Gabriel. Common Lisp
was designed as a description of a family of languages. The primary inuences on Common Lisp
were Lisp Machine Lisp, MacLisp, NIL, S-1 Lisp, Spice Lisp, and Scheme. Common Lisp: The
Language is a description of that design. Its semantics were intentionally underspecied in places
where it was felt that a tight specication would overly constrain Common Lisp research and use.
In 1986 X3J13 was formed as a technical working group to produce a draft for an ANSI Common
Lisp standard. Because of the acceptance of Common Lisp, the goals of this group diered from
those of the original designers. These new goals included stricter standardization for portability, an
object-oriented programming system, a condition system, iteration facilities, and a way to handle
large character sets. To accommodate those goals, a new language specication, this document,
was developed.
Introduction 1–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.2 Organization of the Document
This is a reference document, not a tutorial document. Where possible and convenient, the order
of presentation has been chosen so that the more primitive topics precede those that build upon
them; however, linear readability has not been a priority.
This document is divided into chapters by topic. Any given chapter might contain conceptual
material, dictionary entries, or both.
Dened names within the dictionary portion of a chapter are grouped in a way that brings related
topics into physical proximity. Many such groupings were possible, and no deep signicance
should be inferred from the particular grouping that was chosen. To see dened names grouped
alphabetically, consult the index. For a complete list of dened names , see Section 1.9 (Symbols in
the COMMON-LISP Package).
In order to compensate for the sometimes-unordered portions of this document, a glossary has been
provided; see Chapter 26 (Glossary). The glossary provides connectivity by providing easy access
to denitions of terms, and in some cases by providing examples or cross references to additional
conceptual material.
For information about notational conventions used in this document, see Section 1.4 (Denitions).
For information about conformance, see Section 1.5 (Conformance).
For information about extensions and subsets, see Section 1.6 (Language Extensions) and Section
1.7 (Language Subsets).
For information about how programs in the language are parsed by the Lisp reader , see Chapter 2
(Syntax).
For information about how programs in the language are compiled and executed , see Chapter 3
(Evaluation and Compilation).
For information about data types, see Chapter 4 (Types and Classes). Not all types and classes
are dened in this chapter; many are dened in chapter corresponding to their topic{for example,
the numeric types are dened in Chapter 12 (Numbers). For a complete list of standardized types ,
see Figure 4{2.
For information about general purpose control and data ow, see Chapter 5 (Data and Control
Flow) or Chapter 6 (Iteration).
1–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.3 Referenced Publications
The Anatomy of Lisp , John Allen, McGraw-Hill, Inc., 1978.
The Art of Computer Programming, Volume 3 , Donald E. Knuth, Addison-Wesley Company
(Reading, MA), 1973.
The Art of the Metaobject Protocol , Kiczales et al., MIT Press (Cambridge, MA), 1991.
\Common Lisp Object System Specication," D. Bobrow, L. DiMichiel, R.P. Gabriel, S. Keene,
G. Kiczales, D. Moon, SIGPLAN Notices V23, September, 1988.
Common Lisp: The Language , Guy L. Steele Jr., Digital Press (Burlington, MA), 1984.
Common Lisp: The Language, Second Edition , Guy L. Steele Jr., Digital Press (Bedford,
MA), 1990.
Exceptional Situations in Lisp , Kent M. Pitman, Proceedings of the First European Conference
on the Practical Application of LISP (EUROPAL '90), Churchill College, Cambridge, England,
March 27-29, 1990.
Flavors: A Non-Hierarchical Approach to Object-Oriented Programming , Howard I. Cannon,
1982.
IEEE Standard for Binary Floating-Point Arithmetic , ANSI/IEEE Std 754-1985, Institute of
Electrical and Electronics Engineers, Inc. (New York), 1985.
IEEE Standard for the Scheme Programming Language , IEEE Std 1178-1990, Institute of
Electrical and Electronic Engineers, Inc. (New York), 1991.
Interlisp Reference Manual , Third Revision, Teitelman, Warren, et al, Xerox Palo Alto
Research Center (Palo Alto, CA), 1978.
ISO 6937/2, Information processing|Coded character sets for text communication|Part 2:
Latin alphabetic and non-alphabetic graphic characters , ISO, 1983.
Lisp 1.5 Programmer's Manual , John McCarthy, MIT Press (Cambridge, MA), August, 1962.
Lisp Machine Manual , D.L. Weinreb and D.A. Moon, Articial Intelligence Laboratory, MIT
(Cambridge, MA), July, 1981.
Maclisp Reference Manual, Revision 0 , David A. Moon, Project MAC (Laboratory for
Computer Science), MIT (Cambridge, MA), March, 1974.
Introduction 1–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
\NIL|A Perspective," JonL White, Macsyma User's Conference , 1979.
Performance and Evaluation of Lisp Programs , Richard P. Gabriel, MIT Press (Cambridge,
MA), 1985.
\Principal Values and Branch Cuts in Complex APL," Paul Peneld Jr., APL 81 Conference
Proceedings , ACM SIGAPL (San Francisco, September 1981), 248-256. Proceedings published
asAPL Quote Quad 12 , 1 (September 1981).
The Revised Maclisp Manual , Kent M. Pitman, Technical Report 295, Laboratory for
Computer Science, MIT (Cambridge, MA), May 1983.
\Revised3Report on the Algorithmic Language Scheme," Jonathan Rees and William Clinger
(editors), SIGPLAN Notices V21, #12, December, 1986.
\S-1 Common Lisp Implementation," R.A. Brooks, R.P. Gabriel, and G.L. Steele, Conference
Record of the 1982 ACM Symposium on Lisp and Functional Programming , 108-113, 1982.
Smalltalk-80: The Language and its Implementation , A. Goldberg and D. Robson, Addison-
Wesley, 1983.
\Standard LISP Report," J.B. Marti, A.C. Hearn, M.L. Griss, and C. Griss, SIGPLAN Notices
V14, #10, October, 1979.
Webster's Third New International Dictionary the English Language, Unabridged , Merriam
Webster (Springeld, MA), 1986.
XP: A Common Lisp Pretty Printing System , R.C. Waters, Memo 1102a, Articial Intelligence
Laboratory, MIT (Cambridge, MA), September 1989.
1–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4 Deﬁnitions
This section contains notational conventions and denitions of terms used in this manual.
1.4.1 Notational Conventions
The following notational conventions are used throughout this document.
1.4.1.1 Font Key
Fonts are used in this document to convey information.
name
Denotes a formal term whose meaning is dened in the Glossary. When this font is used,
the Glossary denition takes precedence over normal English usage.
Sometimes a glossary term appears subscripted, as in \ whitespace 2." Such a notation
selects one particular Glossary denition out of several, in this case the second. The
subscript notation for Glossary terms is generally used where the context might be
insucient to disambiguate among the available denitions.
name
Denotes the introduction of a formal term locally to the current text. There is still a
corresponding glossary entry, and is formally equivalent to a use of \ name ," but the hope
is that making such uses conspicuous will save the reader a trip to the glossary in some
cases.
name
Denotes a symbol in the COMMON-LISP package . For information about case conventions, see
Section 1.4.1.4.1 (Case in Symbols).
name
Denotes a sample name or piece of code that a programmer might write in Common Lisp.
This font is also used for certain standardized names that are not names of external symbols
of theCOMMON-LISP package , such as keywords 1,package names , and loop keywords .
name
Denotes the name of a parameter orvalue .
In some situations the notation \ hhnameii" (i.e., the same font, but with surrounding \angle
brackets") is used instead in order to provide better visual separation from surrounding
characters. These \angle brackets" are metasyntactic, and never actually appear in
program input or output.
Introduction 1–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.1.2 Modiﬁed BNF Syntax
This specication uses an extended Backus Normal Form (BNF) to describe the syntax of Common
Lisp macro forms and special forms . This section discusses the syntax of BNF expressions.
1.4.1.2.1 Splicing in Modiﬁed BNF Syntax
The primary extension used is the following:
[ [O] ]
An expression of this form appears whenever a list of elements is to be spliced into a larger
structure and the elements can appear in any order. The symbol Orepresents a description of the
syntax of some number of syntactic elements to be spliced; that description must be of the form
O1j:::jOl
where each Oican be of the form Sor of the form S* or of the form S1. The expression [ [O] ]
means that a list of the form
(Oi1:::O ij) 1j
is spliced into the enclosing expression, such that if n6=mand1n;mj, then either Oin6=Oim
orOin=Oim=Qk, where for some 1kn,Okis of the form Qk*. Furthermore, for each Oin
that is of the form Qk1, that element is required to appear somewhere in the list to be spliced.
For example, the expression
(x[ [A | B *| C] ]y)
means that at most one A, any number of B's, and at most one Ccan occur in any order. It is a
description of any of these:
(x y)
(x B A C y)
(x A B B B B B C y)
(x C B A B B B y)
but not any of these:
(x B B A A C C y)
(x C B C y)
In the rst case, both AandCappear too often, and in the second case Cappears too often.
The notation [ [O1jO2j:::] ]+adds the additional restriction that at least one item from among
the possible choices must be used. For example:
1–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(x[ [A | B *| C] ]+y)
means that at most one A, any number of B's, and at most one Ccan occur in any order, but that
in any case at least one of these options must be selected. It is a description of any of these:
(x B y)
(x B A C y)
(x A B B B B B C y)
(x C B A B B B y)
but not any of these:
(x y)
(x B B A A C C y)
(x C B C y)
In the rst case, no item was used; in the second case, both AandCappear too often; and in the
third case Cappears too often.
Also, the expression:
(x[ [A1| B1| C] ]y)
can generate exactly these and no others:
(x A B C y)
(x A C B y)
(x A B y)
(x B A C y)
(x B C A y)
(x B A y)
(x C A B y)
(x C B A y)
1.4.1.2.2 Indirection in Modiﬁed BNF Syntax
An indirection extension is introduced in order to make this new syntax more readable:
#O
IfOis a non-terminal symbol, the right-hand side of its denition is substituted for the entire
expression#O. For example, the following BNF is equivalent to the BNF in the previous example:
(x[ [#O] ]y)
O::=AjB*jC
Introduction 1–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.1.2.3 Additional Uses for Indirect Deﬁnitions in Modiﬁed BNF Syntax
In some cases, an auxiliary denition in the BNF might appear to be unused within the BNF, but
might still be useful elsewhere. For example, consider the following denitions:
case keyformf#normal-clauseg* [#otherwise-clause ]!f resultg*
ccase keyplacef#normal-clauseg*!f resultg*
ecase keyformf#normal-clauseg*!f resultg*
normal-clause:: =(keysfformg*)
otherwise-clause:: =(fotherwisejtgfformg*)
clause:: =normal-clausejotherwise-clause
Here the term \ clause " might appear to be \dead" in that it is not used in the BNF. However, the
purpose of the BNF is not just to guide parsing, but also to dene useful terms for reference in the
descriptive text which follows. As such, the term \ clause " might appear in text that follows, as
shorthand for \ normal-clause orotherwise-clause ."
1.4.1.3 Special Symbols
The special symbols described here are used as a notational convenience within this document, and
are part of neither the Common Lisp language nor its environment.
!
This indicates evaluation. For example:
(+ 4 5)!9
This means that the result of evaluating the form(+ 4 5) is9.
If aform returns multiple values , those values might be shown separated by spaces, line
breaks, or commas. For example:
(truncate 7 5)
!1 2
(truncate 7 5)
!1
2
(truncate 7 5)
!1, 2
Each of the above three examples is equivalent, and species that (truncate 7 5) returns
two values, which are 1and2.
1–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Some conforming implementations actually type an arrow (or some other indicator) before
showing return values, while others do not.
or!
The notation \or!" is used to denote one of several possible alternate results. The example
(char-name #\a)
!NILor!"LOWERCASE-a"or!"Small-A"or!"LA01"
indicates that nil,"LOWERCASE-a" ,"Small-A" ,"LA01" are among the possible results of
(char-name #\a) |each with equal preference. Unless explicitly specied otherwise, it
should not be assumed that the set of possible results shown is exhaustive. Formally, the
above example is equivalent to
(char-name #\a) !implementation-dependent
but it is intended to provide additional information to illustrate some of the ways in which
it is permitted for implementations to diverge.
not!
The notation \not!" is used to denote a result which is not possible. This might be used, for
example, in order to emphasize a situation where some anticipated misconception might
lead the reader to falsely believe that the result might be possible. For example,
(function-lambda-expression
(funcall #’(lambda (x) #’(lambda () x)) nil))
!NIL, true, NILor!(LAMBDA () X), true, NIL
not!NIL, false, NIL
not!(LAMBDA () X), false, NIL

This indicates code equivalence. For example:
(gcd x (gcd y z)) (gcd (gcd x y) z)
This means that the results and observable side-eects of evaluating the form
(gcd x (gcd y z)) are always the same as the results and observable side-eects of
(gcd (gcd x y) z) for anyx,y, andz.
.
Introduction 1–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Common Lisp species input and output with respect to a non-interactive stream
model. The specic details of how interactive input and output are mapped onto that
non-interactive model are implementation-dened .
For example, conforming implementations are permitted to dier in issues of how
interactive input is terminated. For example, the function read terminates when the nal
delimiter is typed on a non-interactive stream. In some implementations , an interactive
call toread returns as soon as the nal delimiter is typed, even if that delimiter is not
anewline . In other implementations , a nal newline is always required. In still other
implementations , there might be a command which \activates" a buer full of input
without the command itself being visible on the program's input stream.
In the examples in this document, the notation \ ." precedes lines where interactive input
and output occurs. Within such a scenario, \this notation " notates user input.
For example, the notation
(+ 1 (print (+ (sqrt (read)) (sqrt (read)))))
.9 16
.7
!8
shows an interaction in which \ (+ 1 (print (+ (sqrt (read)) (sqrt (read))))) " is a form
to be evaluated , \9 16 " is interactive input, \ 7" is interactive output, and \ 8" is the value
yielded from the evaluation .
The use of this notation is intended to disguise small dierences in interactive input and
output behavior between implementations .
Sometimes, the non-interactive stream model calls for a newline . How that newline
character is interactively entered is an implementation-dened detail of the user interface,
but in that case, either the notation \ hNewlinei" or \ -" might be used.
(progn (format t "~&Who? ") (read-line))
.Who? Fred, Mary, and Sally  -
!"Fred, Mary, and Sally", false
1.4.1.4 Objects with Multiple Notations
Some objects in Common Lisp can be notated in more than one way. In such situations, the choice
of which notation to use is technically arbitrary, but conventions may exist which convey a \point
of view" or \sense of intent."
1–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.1.4.1 Case in Symbols
While case is signicant in the process of interning asymbol , the Lisp reader , by default, attempts
to canonicalize the case of a symbol prior to interning; see Section 23.1.2 (Eect of Readtable
Case on the Lisp Reader). As such, case in symbols is not, by default, signicant. Throughout
this document, except as explicitly noted otherwise, the case in which a symbol appears is not
signicant; that is, HELLO ,Hello ,hElLo , andhello are all equivalent ways to denote a symbol whose
name is "HELLO" .
The characters backslash and vertical-bar are used to explicitly quote the case and other parsing-
related aspects of characters. As such, the notations |hello| and\h\e\l\l\o are equivalent ways
to refer to a symbol whose name is "hello" , and which is distinct from any symbol whose name is
"HELLO" .
The symbols that correspond to Common Lisp dened names have uppercase names even though
their names generally appear in lowercase in this document.
1.4.1.4.2 Numbers
Although Common Lisp provides a variety of ways for programs to manipulate the input and
output radix for rational numbers, all numbers in this document are in decimal notation unless
explicitly noted otherwise.
1.4.1.4.3 Use of the Dot Character
The dot appearing by itself in an expression such as
(item1 item2 .tail)
means that tailrepresents a listofobjects at the end of a list. For example,
(A B C . (D E F))
is notationally equivalent to:
(A B C D E F)
Although dotis a valid constituent character in a symbol, no standardized symbols contain the
character dot, so a period that follows a reference to a symbol at the end of a sentence in this
document should always be interpreted as a period and never as part of the symbol 'sname . For
example, within this document, a sentence such as \This sample sentence refers to the symbol
car." refers to a symbol whose name is "CAR" (with three letters), and never to a four-letter symbol
"CAR."
Introduction 1–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.1.4.4 NIL
nilhas a variety of meanings. It is a symbol in theCOMMON-LISP package with the name"NIL" , it is
boolean (and generalized boolean )false, it is the empty list , and it is the name of the empty type (a
subtype of all types ).
Within Common Lisp, nilcan be notated interchangeably as either NILor(). By convention, the
choice of notation oers a hint as to which of its many roles it is playing.
For Evaluation? Notation Typically Implied Role
Yes nil use as a boolean .
Yes ’nil use as a symbol .
Yes ’() use as an empty list
No nil use as a symbol orboolean .
No () use as an empty list .
Figure 1–1. Notations for NIL
Within this document only, nilis also sometimes notated as false to emphasize its role as a boolean .
For example:
(print ()) ;avoided
(defun three nil 3) ;avoided
’(nil nil) ;list of two symbols
’(() ()) ;list of empty lists
(defun three () 3) ;Emphasize empty parameter list.
(append ’() ’()) !() ;Emphasize use of empty lists
(not nil)!true ;Emphasize use as Boolean false
(get ’nil ’color) ;Emphasize use as a symbol
Afunction is sometimes said to \be false" or \be true" in some circumstance. Since no function
object can be the same as niland all function objects represent true when viewed as booleans , it
would be meaningless to say that the function was literally false and uninteresting to say that it
was literally true. Instead, these phrases are just traditional alternative ways of saying that the
function \returns false" or \returns true," respectively.
1.4.1.5 Designators
Adesignator is an object that denotes another object .
Where a parameter of an operator is described as a designator , the description of the operator
is written in a way that assumes that the value of the parameter is the denoted object ; that is,
that the parameter is already of the denoted type. (The specic nature of the object denoted by a
\hhtypeiidesignator " or a \ designator for ahhtypeii" can be found in the Glossary entry for \ hhtypeii
designator .")
1–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
For example, \ nil" and \the value of*standard-output* " are operationally indistinguishable
asstream designators . Similarly, the symbolfooand the string"FOO" are operationally
indistinguishable as string designators .
Except as otherwise noted, in a situation where the denoted object might be used multiple times,
it is implementation-dependent whether the object is coerced only once or whether the coercion
occurs each time the object must be used.
For example, mapcar receives a function designator as an argument, and its description is written
as if this were simply a function. In fact, it is implementation-dependent whether the function
designator is coerced right away or whether it is carried around internally in the form that it
was given as an argument and re-coerced each time it is needed. In most cases, conforming
programs cannot detect the distinction, but there are some pathological situations (particularly
those involving self-redening or mutually-redening functions) which do conform and which can
detect this dierence. The following program is a conforming program , but might or might not
have portably correct results, depending on whether its correctness depends on one or the other of
the results:
(defun add-some (x)
(defun add-some (x) (+ x 2))
(+ x 1))!ADD-SOME
(mapcar ’add-some ’(1 2 3 4))
!(2 3 4 5)or!(2 4 5 6)
In a few rare situations, there may be a need in a dictionary entry to refer to the object that was
the original designator for a parameter . Since naming the parameter would refer to the denoted
object , the phrase \the hhparameter-nameiidesignator " can be used to refer to the designator
which was the argument from which the value ofhhparameter-nameiiwas computed.
1.4.1.6 Nonsense Words
When a word having no pre-attached semantics is required ( e.g., in an example), it is common in
the Lisp community to use one of the words \foo," \bar," \baz," and \quux." For example, in
(defun foo (x) (+ x 1))
the use of the name foois just a shorthand way of saying \please substitute your favorite name
here."
These nonsense words have gained such prevalance of usage, that it is commonplace for
newcomers to the community to begin to wonder if there is an attached semantics which they are
overlooking|there is not.
Introduction 1–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.2 Error Terminology
Situations in which errors might, should, or must be signaled are described in the standard. The
wording used to describe such situations is intended to have precise meaning. The following list is
a glossary of those meanings.
Safe code
This is code processed with the safety optimization at its highest setting ( 3).safety is a
lexical property of code. The phrase \the function Fshould signal an error" means that if
Fis invoked from code processed with the highest safety optimization, an error is signaled.
It is implementation-dependent whether For the calling code signals the error.
Unsafe code
This is code processed with lower safety levels.
Unsafe code might do error checking. Implementations are permitted to treat all code as
safe code all the time.
An error is signaled
This means that an error is signaled in both safe and unsafe code. Conforming code
may rely on the fact that the error is signaled in both safe and unsafe code. Every
implementation is required to detect the error in both safe and unsafe code. For example,
\an error is signaled if unexport is given a symbol notaccessible in the current package ."
If an explicit error type is not specied, the default is error .
An error should be signaled
This means that an error is signaled in safe code, and an error might be signaled in unsafe
code. Conforming code may rely on the fact that the error is signaled in safe code. Every
implementation is required to detect the error at least in safe code. When the error is not
signaled, the \consequences are undened" (see below). For example, \ +should signal an
error of typetype-error if any argument is not of typenumber ."
Should be prepared to signal an error
This is similar to \should be signaled" except that it does not imply that `extra eort' has
to be taken on the part of an operator to discover an erroneous situation if the normal
action of that operator can be performed successfully with only `lazy' checking. An
implementation is always permitted to signal an error, but even in safe code , it is only
required to signal the error when failing to signal it might lead to incorrect results. In
unsafe code , the consequences are undened.
For example, dening that \ ﬁnd should be prepared to signal an error of typetype-error
if its second argument is not a proper list " does not imply that an error is always signaled.
1–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The form
(find ’a ’(a b . c))
must either signal an error of typetype-error insafe code , else return A. In unsafe code ,
the consequences are undened. By contrast,
(find ’d ’(a b . c))
must signal an error of typetype-error insafe code . In unsafe code , the consequences are
undened. Also,
(find ’d ’#1=(a b . #1#))
insafe code might return nil(as an implementation-dened extension), might never
return, or might signal an error of typetype-error . In unsafe code , the consequences are
undened.
Typically, the \should be prepared to signal" terminology is used in type checking
situations where there are eciency considerations that make it impractical to detect
errors that are not relevant to the correct operation of the operator .
The consequences are unspeciﬁed
This means that the consequences are unpredictable but harmless. Implementations are
permitted to specify the consequences of this situation. No conforming code may depend
on the results or eects of this situation, and all conforming code is required to treat the
results and eects of this situation as unpredictable but harmless. For example, \if the
second argument to shared-initialize species a name that does not correspond to any
slots accessible in the object , the results are unspecied."
The consequences are undeﬁned
This means that the consequences are unpredictable. The consequences may range from
harmless to fatal. No conforming code may depend on the results or eects. Conforming
code must treat the consequences as unpredictable. In places where the words \must,"
\must not," or \may not" are used, then \the consequences are undened" if the stated
requirement is not met and no specic consequence is explicitly stated. An implementation
is permitted to signal an error in this case.
For example: \Once a name has been declared by defconstant to be constant, any further
assignment or binding of that variable has undened consequences."
An error might be signaled
This means that the situation has undened consequences; however, if an error is signaled,
it is of the specied type. For example, \ open might signal an error of typeﬁle-error ."
The return values are unspeciﬁed
Introduction 1–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
This means that only the number and nature of the return values of a form are not
specied. However, the issue of whether or not any side-eects or transfer of control occurs
is still well-specied.
A program can be well-specied even if it uses a function whose returns values are
unspecied. For example, even if the return values of some function Fare unspecied, an
expression such as (length (list (F))) is still well-specied because it does not rely on
any particular aspect of the value or values returned by F.
Implementations may be extended to cover this situation
This means that the situation has undened consequences; however, a conforming
implementation is free to treat the situation in a more specic way. For example, an
implementation might dene that an error is signaled, or that an error should be signaled,
or even that a certain well-dened non-error behavior occurs.
Noconforming code may depend on the consequences of such a situation ; all conforming
code must treat the consequences of the situation as undened. Implementations are
required to document how the situation is treated.
For example, \implementations may be extended to dene other type speciers to have a
corresponding class ."
Implementations are free to extend the syntax
This means that in this situation implementations are permitted to dene unambiguous
extensions to the syntax of the form being described. No conforming code may depend
on this extension. Implementations are required to document each such extension. All
conforming code is required to treat the syntax as meaningless. The standard might
disallow certain extensions while allowing others. For example, \no implementation is free
to extend the syntax of defclass ."
A warning might be issued
This means that implementations are encouraged to issue a warning if the context is
appropriate ( e.g., when compiling). However, a conforming implementation is not required
to issue a warning.
1.4.3 Sections Not Formally Part Of This Standard
Front matter and back matter, such as the \Table of Contents," \Index," \Figures," \Credits,"
and \Appendix" are not considered formally part of this standard, so that we retain the exibility
needed to update these sections even at the last minute without fear of needing a formal vote to
change those parts of the document. These items are quite short and very useful, however, and it
is not recommended that they be removed even in an abridged version of this document.
1–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Within the concept sections, subsections whose names begin with the words \Note" or \Notes" or
\Example" or \Examples" are provided for illustration purposes only, and are not considered part
of the standard.
An attempt has been made to place these sections last in their parent section, so that they could
be removed without disturbing the contiguous numbering of the surrounding sections in order to
produce a document of smaller size.
Likewise, the \Examples" and \Notes" sections in a dictionary entry are not considered part of the
standard and could be removed if necessary.
Nevertheless, the examples provide important clarications and consistency checks for the rest of
the material, and such abridging is not recommended unless absolutely unavoidable.
1.4.4 Interpreting Dictionary Entries
The dictionary entry for each dened name is partitioned into sections. Except as explicitly
indicated otherwise below, each section is introduced by a label identifying that section. The
omission of a section implies that the section is either not applicable, or would provide no
interesting information.
This section denes the signicance of each potential section in a dictionary entry.
1.4.4.1 The “Aﬀected By” Section of a Dictionary Entry
For an operator , anything that can aect the side eects of or values returned by the operator .
For a variable , anything that can aect the value of the variable including functions that bind or
assign it.
1.4.4.2 The “Arguments” Section of a Dictionary Entry
This information describes the syntax information of entries such as those for declarations and
special expressions which are never evaluated asforms , and so do not return values .
1.4.4.3 The “Arguments and Values” Section of a Dictionary Entry
An English language description of what arguments theoperator accepts and what values it returns,
including information about defaults for parameters corresponding to omittable arguments (such as
optional parameters and keyword parameters ). For special operators and macros , their arguments
are not evaluated unless it is explicitly stated in their descriptions that they are evaluated .
Except as explicitly specied otherwise, the consequences are undened if these type restrictions
are violated.
Introduction 1–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.4.4 The “Binding Types Aﬀected” Section of a Dictionary Entry
This information alerts the reader to the kinds of bindings that might potentially be aected by
a declaration. Whether in fact any particular such binding is actually aected is dependent on
additional factors as well. See the \Description" section of the declaration in question for details.
1.4.4.5 The “Class Precedence List” Section of a Dictionary Entry
This appears in the dictionary entry for a class , and contains an ordered list of the classes dened
by Common Lisp that must be in the class precedence list of this class .
It is permissible for other ( implementation-dened )classes to appear in the implementation 'sclass
precedence list for the class .
It is permissible for either standard-object orstructure-object to appear in the implementation 's
class precedence list ; for details, see Section 4.2.2 (Type Relationships).
Except as explicitly indicated otherwise somewhere in this specication, no additional standardized
classes may appear in the implementation 'sclass precedence list .
By denition of the relationship between classes and types , the classes listed in this section are
also supertypes of the type denoted by the class .
1.4.4.6 Dictionary Entries for Type Speciﬁers
The atomic type speciers are those dened names listed in Figure 4{2. Such dictionary entries
are of kind \Class," \Condition Type," \System Class," or \Type." A description of how to
interpret a symbol naming one of these types orclasses as an atomic type specier is found in the
\Description" section of such dictionary entries.
The compound type speciers are those dened names listed in Figure 4{3. Such dictionary entries
are of kind \Class," \System Class," \Type," or \Type Specier." A description of how to interpret
as a compound type specier alistwhose caris such a symbol is found in the \Compound Type
Specier Kind," \Compound Type Specier Syntax," \Compound Type Specier Arguments," and
\Compound Type Specier Description" sections of such dictionary entries.
1.4.4.6.1 The “Compound Type Speciﬁer Kind” Section of a Dictionary Entry
An \abbreviating" type specier is one that describes a subtype for which it is in principle possible
to enumerate the elements , but for which in practice it is impractical to do so.
A \specializing" type specier is one that describes a subtype by restricting the type of one or more
components of the type, such as element type orcomplex part type .
A \predicating" type specier is one that describes a subtype containing only those objects that
satisfy a given predicate .
A \combining" type specier is one that describes a subtype in a compositional way, using
combining operations (such as \and," \or," and \not") on other types .
1–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.4.6.2 The “Compound Type Speciﬁer Syntax” Section of a Dictionary Entry
This information about a type describes the syntax of a compound type specier for that type.
Whether or not the type is acceptable as an atomic type specier is not represented here; see
Section 1.4.4.6 (Dictionary Entries for Type Speciers).
1.4.4.6.3 The “Compound Type Speciﬁer Arguments” Section of a Dictionary Entry
This information describes type information for the structures dened in the \Compound Type
Specier Syntax" section.
1.4.4.6.4 The “Compound Type Speciﬁer Description” Section of a Dictionary Entry
This information describes the meaning of the structures dened in the \Compound Type Specier
Syntax" section.
1.4.4.7 The “Constant Value” Section of a Dictionary Entry
This information describes the unchanging type and value of a constant variable .
1.4.4.8 The “Description” Section of a Dictionary Entry
A summary of the operator and all intended aspects of the operator , but does not necessarily
include all the elds referenced below it (\Side Eects," \Exceptional Situations," etc.)
1.4.4.9 The “Examples” Section of a Dictionary Entry
Examples of use of the operator . These examples are not considered part of the standard; see
Section 1.4.3 (Sections Not Formally Part Of This Standard).
1.4.4.10 The “Exceptional Situations” Section of a Dictionary Entry
Three kinds of information may appear here:
Situations that are detected by the function and formally signaled.
Situations that are handled by the function .
Situations that may be detected by the function .
This eld does not include conditions that could be signaled by functions passed to and called
by this operator as arguments or through dynamic variables, nor by executing subforms of this
operator if it is a macro orspecial operator .
Introduction 1–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.4.11 The “Initial Value” Section of a Dictionary Entry
This information describes the initial value of adynamic variable . Since this variable might change,
seetype restrictions in the \Value Type" section.
1.4.4.12 The “Argument Precedence Order” Section of a Dictionary Entry
This information describes the argument precedence order . If it is omitted, the argument precedence
order is the default (left to right).
1.4.4.13 The “Method Signature” Section of a Dictionary Entry
The description of a generic function includes descriptions of the methods that are dened on that
generic function by the standard. A method signature is used to describe the parameters and
parameter specializers for each method .Methods dened for the generic function must be of the
form described by the method signature .
F(x class ) (y t)&optional z&key k
This signature indicates that this method on the generic function Fhas two required parameters :
x, which must be a generalized instance of the class class; and y, which can be any object (i.e., a
generalized instance of the classt). In addition, there is an optional parameter zand a keyword
parameter k. This signature also indicates that this method on Fis aprimary method and has no
qualiers .
For each parameter , the argument supplied must be in the intersection of the type specied in the
description of the corresponding generic function and the typegiven in the signature of some method
(including not only those methods dened in this specication, but also implementation-dened or
user-dened methods in situations where the denition of such methods is permitted).
1.4.4.14 The “Name” Section of a Dictionary Entry
This section introduces the dictionary entry. It is not explicitly labeled. It appears preceded and
followed by a horizontal bar.
In large print at left, the dened name appears; if more than one dened name is to be described
by the entry, all such names are shown separated by commas.
In somewhat smaller italic print at right is an indication of what kind of dictionary entry this is.
Possible values are:
Accessor
This is an accessor function .
Class
This is a class .
1–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Condition Type
This is a subtype oftypecondition .
Constant Variable
This is a constant variable .
Declaration
This is a declaration identier .
Function
This is a function .
Local Function
This is a function that is dened only lexically within the scope of some other macro form .
Local Macro
This is a macro that is dened only lexically within the scope of some other macro form .
Macro
This is a macro .
Restart
This is a restart .
Special Operator
This is a special operator .
Standard Generic Function
This is a standard generic function .
Symbol
This is a symbol that is specially recognized in some particular situation, such as the
syntax of a macro .
System Class
This is like class , but it identies a class that is potentially a built-in class . (No class is
actually required to be a built-in class .)
Introduction 1–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Type
This is an atomic type specier , and depending on information for each particular entry,
may subject to form other type speciers .
Type Specier
This is a dened name that is not an atomic type specier , but that can be used in
constructing valid type speciers .
Variable
This is a dynamic variable .
1.4.4.15 The “Notes” Section of a Dictionary Entry
Information not found elsewhere in this description which pertains to this operator . Among
other things, this might include cross reference information, code equivalences, stylistic hints,
implementation hints, typical uses. This information is not considered part of the standard; any
conforming implementation orconforming program is permitted to ignore the presence of this
information.
1.4.4.16 The “Pronunciation” Section of a Dictionary Entry
This oers a suggested pronunciation for dened names so that people not in verbal communication
with the original designers can gure out how to pronounce words that are not in normal English
usage. This information is advisory only, and is not considered part of the standard. For brevity, it
is only provided for entries with names that are specic to Common Lisp and would not be found
inWebster's Third New International Dictionary the English Language, Unabridged .
1.4.4.17 The “See Also” Section of a Dictionary Entry
List of references to other parts of this standard that oer information relevant to this operator .
This list is not part of the standard.
1.4.4.18 The “Side Eﬀects” Section of a Dictionary Entry
Anything that is changed as a result of the evaluation of the form containing this operator .
1.4.4.19 The “Supertypes” Section of a Dictionary Entry
This appears in the dictionary entry for a type, and contains a list of the standardized types that
must be supertypes of this type.
Inimplementations where there is a corresponding class , the order of the classes in the class
precedence list is consistent with the order presented in this section.
1–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.4.20 The “Syntax” Section of a Dictionary Entry
This section describes how to use the dened name in code. The \Syntax" description for a generic
function describes the lambda list of the generic function itself, while the \Method Signatures"
describe the lambda lists of the dened methods . The \Syntax" description for an ordinary
function , amacro , or a special operator describes its parameters .
For example, an operator description might say:
Fx y&optional z&key k
This description indicates that the function Fhas two required parameters, xand y. In addition,
there is an optional parameter zand a keyword parameter k.
Formacros and special operators , syntax is given in modied BNF notation; see Section 1.4.1.2
(Modied BNF Syntax). For functions alambda list is given. In both cases, however, the outermost
parentheses are omitted, and default value information is omitted.
1.4.4.20.1 Special “Syntax” Notations for Overloaded Operators
If two descriptions exist for the same operation but with dierent numbers of arguments, then the
extra arguments are to be treated as optional. For example, this pair of lines:
ﬁle-position stream!position
ﬁle-position stream position-spec !success-p
is operationally equivalent to this line:
ﬁle-position stream&optional position-spec!result
and diers only in that it provides on opportunity to introduce dierent names for parameter and
values for each case. The separated (multi-line) notation is used when an operator is overloaded in
such a way that the parameters are used in dierent ways depending on how many arguments are
supplied ( e.g., for the function /) or the return values are dierent in the two cases ( e.g., for the
functionﬁle-position ).
1.4.4.20.2 Naming Conventions for Rest Parameters
Within this specication, if the name of a rest parameter is chosen to be a plural noun, use of that
name in parameter font refers to the listto which the rest parameter is bound. Use of the singular
form of that name in parameter font refers to an element of that list.
For example, given a syntax description such as:
F&rest arguments
it is appropriate to refer either to the rest parameter named arguments by name, or to one of its
elements by speaking of \an argument ," \some argument ," \each argument "etc.
Introduction 1–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.4.20.3 Requiring Non-Null Rest Parameters in the “Syntax” Section
In some cases it is useful to refer to all arguments equally as a single aggregation using a rest
parameter while at the same time requiring at least one argument. A variety of imperative and
declarative means are available in code for expressing such a restriction, however they generally do
not manifest themselves in a lambda list . For descriptive purposes within this specication,
F&rest arguments+
means the same as
F&rest arguments
but introduces the additional requirement that there be at least one argument .
1.4.4.20.4 Return values in the “Syntax” Section
An evaluation arrow \ !" precedes a list of values to be returned. For example:
Fa b c!x
indicates that Fis an operator that has three required parameters (i.e.,a,b, and c) and that
returns one value (i.e.,x). If more than one value is returned by an operator, the names of the
values are separated by commas, as in:
Fa b c!x, y, z
1.4.4.20.4.1 No Arguments or Values in the “Syntax” Section
If no arguments are permitted, or no values are returned, a special notation is used to make this
more visually apparent. For example,
Fhno argumentsi !h no valuesi
indicates that Fis an operator that accepts no arguments and returns no values .
1.4.4.20.4.2 Unconditional Transfer of Control in the “Syntax” Section
Some operators perform an unconditional transfer of control, and so never have any return values.
Such operators are notated using a notation such as the following:
Fa b c!
1.4.4.21 The “Valid Context” Section of a Dictionary Entry
This information is used by dictionary entries such as \Declarations" in order to restrict the
context in which the declaration may appear.
A given \Declaration" might appear in a declaration (i.e., adeclare expression ), aproclamation
(i.e., adeclaim orproclaim form ), or both.
1–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.4.4.22 The “Value Type” Section of a Dictionary Entry
This information describes any type restrictions on a dynamic variable .
Except as explicitly specied otherwise, the consequences are undened if this type restriction is
violated.
Introduction 1–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.5 Conformance
This standard presents the syntax and semantics to be implemented by a conforming implementation
(and its accompanying documentation). In addition, it imposes requirements on conforming
programs .
1.5.1 Conforming Implementations
Aconforming implementation shall adhere to the requirements outlined in this section.
1.5.1.1 Required Language Features
Aconforming implementation shall accept all features (including deprecated features) of the
language specied in this standard, with the meanings dened in this standard.
Aconforming implementation shall not require the inclusion of substitute or additional language
elements in code in order to accomplish a feature of the language that is specied in this standard.
1.5.1.2 Documentation of Implementation-Dependent Features
Aconforming implementation shall be accompanied by a document that provides a denition of all
implementation-dened aspects of the language dened by this specication.
In addition, a conforming implementation is encouraged (but not required) to document items
in this standard that are identied as implementation-dependent , although in some cases such
documentation might simply identify the item as \undened."
1.5.1.3 Documentation of Extensions
Aconforming implementation shall be accompanied by a document that separately describes any
features accepted by the implementation that are not specied in this standard, but that do not
cause any ambiguity or contradiction when added to the language standard. Such extensions shall
be described as being \extensions to Common Lisp as specied by ANSI hhstandard numberii."
1.5.1.4 Treatment of Exceptional Situations
Aconforming implementation shall treat exceptional situations in a manner consistent with this
specication.
1.5.1.4.1 Resolution of Apparent Conﬂicts in Exceptional Situations
If more than one passage in this specication appears to apply to the same situation but in
conicting ways, the passage that appears to describe the situation in the most specic way
(not necessarily the passage that provides the most constrained kind of error detection) takes
precedence.
1–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.5.1.4.1.1 Examples of Resolution of Apparent Conﬂicts in Exceptional Situations
Suppose that function foois a member of a set Soffunctions that operate on numbers. Suppose
that one passage states that an error must be signaled if any function inSis ever given an
argument of 17. Suppose that an apparently conicting passage states that the consequences are
undened if fooreceives an argument of 17. Then the second passage (the one specically about
foo) would dominate because the description of the situational context is the most specic, and it
would not be required that foosignal an error on an argument of 17even though other functions
in the setSwould be required to do so.
1.5.1.5 Conformance Statement
Aconforming implementation shall produce a conformance statement as a consequence of using
the implementation, or that statement shall be included in the accompanying documentation. If
the implementation conforms in all respects with this standard, the conformance statement shall
be
\hhImplementationiiconforms with the requirements of ANSI hhstandard numberii"
If the implementation conforms with some but not all of the requirements of this standard, then
the conformance statement shall be
\hhImplementationiiconforms with the requirements of ANSI hhstandard numberiiwith the
following exceptions: hhreference to or complete list of the requirements of the standard with
which the implementation does not conform ii."
1.5.2 Conforming Programs
Code conforming with the requirements of this standard shall adhere to the following:
1.Conforming code shall use only those features of the language syntax and semantics that
are either specied in this standard or dened using the extension mechanisms specied in
the standard.
2.Conforming code may use implementation-dependent features and values, but shall not
rely upon any particular interpretation of these features and values other than those that
are discovered by the execution of code.
3.Conforming code shall not depend on the consequences of undened or unspecied
situations.
4.Conforming code does not use any constructions that are prohibited by the standard.
5.Conforming code does not depend on extensions included in an implementation.
Introduction 1–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.5.2.1 Use of Implementation-Deﬁned Language Features
Note that conforming code may rely on particular implementation-dened values or features. Also
note that the requirements for conforming code and conforming implementations do not require
that the results produced by conforming code always be the same when processed by a conforming
implementation . The results may be the same, or they may dier.
Conforming code may run in all conforming implementations, but might have allowable
implementation-dened behavior that makes it non-portable code. For example, the following
are examples of forms that are conforming, but that might return dierent values in dierent
implementations:
(evenp most-positive-fixnum) !implementation-dependent
(random)!implementation-dependent
(> lambda-parameters-limit 93) !implementation-dependent
(char-name #\A) !implementation-dependent
1.5.2.1.1 Use of Read-Time Conditionals
Use of#+and#-does not automatically disqualify a program from being conforming. A program
which uses #+and#-is considered conforming if there is no set of features in which the program
would not be conforming. Of course, conforming programs are not necessarily working programs.
The following program is conforming:
(defun foo ()
#+ACME (acme:initialize-something)
(print ’hello-there))
However, this program might or might not work, depending on whether the presence of the feature
ACME really implies that a function named acme:initialize-something is present in the environment.
In eect, using #+or#-in a conforming program means that the variable *features* becomes just
one more piece of input data to that program. Like any other data coming into a program, the
programmer is responsible for assuring that the program does not make unwarranted assumptions
on the basis of input data.
1.5.2.2 Character Set for Portable Code
Portable code is written using only standard characters .
1–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.6 Language Extensions
A language extension is any documented implementation-dened behavior of a dened name
in this standard that varies from the behavior described in this standard, or a documented
consequence of a situation that the standard species as undened, unspecied, or extendable
by the implementation. For example, if this standard says that \the results are unspecied," an
extension would be to specify the results.
If the correct behavior of a program depends on the results provided by an extension, only
implementations with the same extension will execute the program correctly. Note that such a
program might be non-conforming. Also, if this standard says that \an implementation may be
extended," a conforming, but possibly non-portable, program can be written using an extension.
An implementation can have extensions, provided they do not alter the behavior of conforming
code and provided they are not explicitly prohibited by this standard.
The term \extension" refers only to extensions available upon startup. An implementation is free
to allow or prohibit redenition of an extension.
The following list contains specic guidance to implementations concerning certain types of
extensions.
Extra return values
An implementation must return exactly the number of return values specied by this
standard unless the standard specically indicates otherwise.
Unsolicited messages
No output can be produced by a function other than that specied in the standard or due
to the signaling of conditions detected by the function.
Unsolicited output, such as garbage collection notications and autoload heralds, should
not go directly to the stream that is the value of a stream variable dened in this standard,
but can go indirectly to terminal I/O by using a synonym stream to*terminal-io* .
Progress reports from such functions as load andcompile are considered solicited, and are
not covered by this prohibition.
Implementation of macros and special forms
Macros and special operators dened in this standard must not be functions .
Introduction 1–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.7 Language Subsets
The language described in this standard contains no subsets, though subsets are not forbidden.
For a language to be considered a subset, it must have the property that any valid program in that
language has equivalent semantics and will run directly (with no extralingual pre-processing, and
no special compatibility packages) in any conforming implementation of the full language.
A language that conforms to this requirement shall be described as being a \subset of Common
Lisp as specied by ANSI hhstandard numberii."
1–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.8 Deprecated Language Features
Deprecated language features are not expected to appear in future Common Lisp standards, but
are required to be implemented for conformance with this standard; see Section 1.5.1.1 (Required
Language Features).
Conforming programs can use deprecated features; however, it is considered good programming
style to avoid them. It is permissible for the compiler to produce style warnings about the use of
such features at compile time, but there should be no such warnings at program execution time.
1.8.1 Deprecated Functions
The functions in Figure 1{2 are deprecated.
assoc-if-not nsubst-if-not require
count-if-not nsubstitute-if-not set
delete-if-not position-if-not subst-if-not
ﬁnd-if-not provide substitute-if-not
gentemp rassoc-if-not
member-if-not remove-if-not
Figure 1–2. Deprecated Functions
1.8.2 Deprecated Argument Conventions
The ability to pass a numeric argument togensym has been deprecated.
The:test-not argument to the functions in Figure 1{3 are deprecated.
adjoin nset-diﬀerence search
assoc nset-exclusive-or set-diﬀerence
count nsublis set-exclusive-or
delete nsubst sublis
delete-duplicates nsubstitute subsetp
ﬁnd nunion subst
intersection position substitute
member rassoc tree-equal
mismatch remove union
nintersection remove-duplicates
Figure 1–3. Functions with Deprecated :TEST-NOT Arguments
The use of the situation names compile ,load, andeval ineval-when is deprecated.
Introduction 1–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.8.3 Deprecated Variables
The variable*modules* is deprecated.
1.8.4 Deprecated Reader Syntax
The#Sreader macro forces keyword names into the KEYWORD package ; see Section 2.4.8.13 (Sharpsign
S). This feature is deprecated; in the future, keyword names will be taken in the package they
are read in, so symbols that are actually in the KEYWORD package should be used if that is what is
desired.
1–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
1.9 Symbols in the COMMON-LISP Package
The gures on the next twelve pages contain a complete enumeration of the 978 external symbols
in theCOMMON-LISP package .
&allow-other-keys *print-miser-width*
&aux *print-pprint-dispatch*
&body *print-pretty*
&environment *print-radix*
&key *print-readably*
&optional *print-right-margin*
&rest *query-io*
&whole *random-state*
* *read-base*
** *read-default-ﬂoat-format*
*** *read-eval*
*break-on-signals* *read-suppress*
*compile-ﬁle-pathname* *readtable*
*compile-ﬁle-truename* *standard-input*
*compile-print* *standard-output*
*compile-verbose* *terminal-io*
*debug-io* *trace-output*
*debugger-hook* +
*default-pathname-defaults* ++
*error-output* +++
*features* -
*gensym-counter* /
*load-pathname* //
*load-print* ///
*load-truename* /=
*load-verbose* 1+
*macroexpand-hook* 1-
*modules* <
*package* <=
*print-array* =
*print-base* >
*print-case* >=
*print-circle* abort
*print-escape* abs
*print-gensym* acons
*print-length* acos
*print-level* acosh
*print-lines* add-method
Figure 1–4. Symbols in the COMMON-LISP package (part one of twelve).
Introduction 1–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
adjoin atom boundp
adjust-array base-char break
adjustable-array-p base-string broadcast-stream
allocate-instance bignum broadcast-stream-streams
alpha-char-p bit built-in-class
alphanumericp bit-and butlast
and bit-andc1 byte
append bit-andc2 byte-position
apply bit-eqv byte-size
apropos bit-ior caaaar
apropos-list bit-nand caaadr
aref bit-nor caaar
arithmetic-error bit-not caadar
arithmetic-error-operands bit-orc1 caaddr
arithmetic-error-operation bit-orc2 caadr
array bit-vector caar
array-dimension bit-vector-p cadaar
array-dimension-limit bit-xor cadadr
array-dimensions block cadar
array-displacement boole caddar
array-element-type boole-1 cadddr
array-has-ﬁll-pointer-p boole-2 caddr
array-in-bounds-p boole-and cadr
array-rank boole-andc1 call-arguments-limit
array-rank-limit boole-andc2 call-method
array-row-major-index boole-c1 call-next-method
array-total-size boole-c2 car
array-total-size-limit boole-clr case
arrayp boole-eqv catch
ash boole-ior ccase
asin boole-nand cdaaar
asinh boole-nor cdaadr
assert boole-orc1 cdaar
assoc boole-orc2 cdadar
assoc-if boole-set cdaddr
assoc-if-not boole-xor cdadr
atan boolean cdar
atanh both-case-p cddaar
Figure 1–5. Symbols in the COMMON-LISP package (part two of twelve).
1–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
cddadr clear-input copy-tree
cddar clear-output cos
cdddar close cosh
cddddr clrhash count
cdddr code-char count-if
cddr coerce count-if-not
cdr compilation-speed ctypecase
ceiling compile debug
cell-error compile-ﬁle decf
cell-error-name compile-ﬁle-pathname declaim
cerror compiled-function declaration
change-class compiled-function-p declare
char compiler-macro decode-ﬂoat
char-code compiler-macro-function decode-universal-time
char-code-limit complement defclass
char-downcase complex defconstant
char-equal complexp defgeneric
char-greaterp compute-applicable-methods deﬁne-compiler-macro
char-int compute-restarts deﬁne-condition
char-lessp concatenate deﬁne-method-combination
char-name concatenated-stream deﬁne-modify-macro
char-not-equal concatenated-stream-streams deﬁne-setf-expander
char-not-greaterp cond deﬁne-symbol-macro
char-not-lessp condition defmacro
char-upcase conjugate defmethod
char/= cons defpackage
char < consp defparameter
char <= constantly defsetf
char= constantp defstruct
char > continue deftype
char >= control-error defun
character copy-alist defvar
characterp copy-list delete
check-type copy-pprint-dispatch delete-duplicates
cis copy-readtable delete-ﬁle
class copy-seq delete-if
class-name copy-structure delete-if-not
class-of copy-symbol delete-package
Figure 1–6. Symbols in the COMMON-LISP package (part three of twelve).
Introduction 1–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
denominator eq
deposit-ﬁeld eql
describe equal
describe-object equalp
destructuring-bind error
digit-char etypecase
digit-char-p eval
directory eval-when
directory-namestring evenp
disassemble every
division-by-zero exp
do export
do* expt
do-all-symbols extended-char
do-external-symbols fboundp
do-symbols fceiling
documentation fdeﬁnition
dolist ﬄoor
dotimes ﬁfth
double-ﬂoat ﬁle-author
double-ﬂoat-epsilon ﬁle-error
double-ﬂoat-negative-epsilon ﬁle-error-pathname
dpb ﬁle-length
dribble ﬁle-namestring
dynamic-extent ﬁle-position
ecase ﬁle-stream
echo-stream ﬁle-string-length
echo-stream-input-stream ﬁle-write-date
echo-stream-output-stream ﬁll
ed ﬁll-pointer
eighth ﬁnd
elt ﬁnd-all-symbols
encode-universal-time ﬁnd-class
end-of-ﬁle ﬁnd-if
endp ﬁnd-if-not
enough-namestring ﬁnd-method
ensure-directories-exist ﬁnd-package
ensure-generic-function ﬁnd-restart
Figure 1–7. Symbols in the COMMON-LISP package (part four of twelve).
1–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬁnd-symbol get-internal-run-time
ﬁnish-output get-macro-character
ﬁrst get-output-stream-string
ﬁxnum get-properties
ﬂet get-setf-expansion
ﬂoat get-universal-time
ﬂoat-digits getf
ﬂoat-precision gethash
ﬂoat-radix go
ﬂoat-sign graphic-char-p
ﬂoating-point-inexact handler-bind
ﬂoating-point-invalid-operation handler-case
ﬂoating-point-overﬂow hash-table
ﬂoating-point-underﬂow hash-table-count
ﬂoatp hash-table-p
ﬂoor hash-table-rehash-size
fmakunbound hash-table-rehash-threshold
force-output hash-table-size
format hash-table-test
formatter host-namestring
fourth identity
fresh-line if
fround ignorable
ftruncate ignore
ftype ignore-errors
funcall imagpart
function import
function-keywords in-package
function-lambda-expression incf
functionp initialize-instance
gcd inline
generic-function input-stream-p
gensym inspect
gentemp integer
get integer-decode-ﬂoat
get-decoded-time integer-length
get-dispatch-macro-character integerp
get-internal-real-time interactive-stream-p
Figure 1–8. Symbols in the COMMON-LISP package (part ﬁve of twelve).
Introduction 1–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
intern lisp-implementation-type
internal-time-units-per-second lisp-implementation-version
intersection list
invalid-method-error list*
invoke-debugger list-all-packages
invoke-restart list-length
invoke-restart-interactively listen
isqrt listp
keyword load
keywordp load-logical-pathname-translations
labels load-time-value
lambda locally
lambda-list-keywords log
lambda-parameters-limit logand
last logandc1
lcm logandc2
ldb logbitp
ldb-test logcount
ldiﬀ logeqv
least-negative-double-ﬂoat logical-pathname
least-negative-long-ﬂoat logical-pathname-translations
least-negative-normalized-double-ﬂoat logior
least-negative-normalized-long-ﬂoat lognand
least-negative-normalized-short-ﬂoat lognor
least-negative-normalized-single-ﬂoat lognot
least-negative-short-ﬂoat logorc1
least-negative-single-ﬂoat logorc2
least-positive-double-ﬂoat logtest
least-positive-long-ﬂoat logxor
least-positive-normalized-double-ﬂoat long-ﬂoat
least-positive-normalized-long-ﬂoat long-ﬂoat-epsilon
least-positive-normalized-short-ﬂoat long-ﬂoat-negative-epsilon
least-positive-normalized-single-ﬂoat long-site-name
least-positive-short-ﬂoat loop
least-positive-single-ﬂoat loop-ﬁnish
length lower-case-p
let machine-instance
let* machine-type
Figure 1–9. Symbols in the COMMON-LISP package (part six of twelve).
1–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
machine-version mask-ﬁeld
macro-function max
macroexpand member
macroexpand-1 member-if
macrolet member-if-not
make-array merge
make-broadcast-stream merge-pathnames
make-concatenated-stream method
make-condition method-combination
make-dispatch-macro-character method-combination-error
make-echo-stream method-qualiﬁers
make-hash-table min
make-instance minusp
make-instances-obsolete mismatch
make-list mod
make-load-form most-negative-double-ﬂoat
make-load-form-saving-slots most-negative-ﬁxnum
make-method most-negative-long-ﬂoat
make-package most-negative-short-ﬂoat
make-pathname most-negative-single-ﬂoat
make-random-state most-positive-double-ﬂoat
make-sequence most-positive-ﬁxnum
make-string most-positive-long-ﬂoat
make-string-input-stream most-positive-short-ﬂoat
make-string-output-stream most-positive-single-ﬂoat
make-symbol muﬄe-warning
make-synonym-stream multiple-value-bind
make-two-way-stream multiple-value-call
makunbound multiple-value-list
map multiple-value-prog1
map-into multiple-value-setq
mapc multiple-values-limit
mapcan name-char
mapcar namestring
mapcon nbutlast
maphash nconc
mapl next-method-p
maplist nil
Figure 1–10. Symbols in the COMMON-LISP package (part seven of twelve).
Introduction 1–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
nintersection package-error
ninth package-error-package
no-applicable-method package-name
no-next-method package-nicknames
not package-shadowing-symbols
notany package-use-list
notevery package-used-by-list
notinline packagep
nreconc pairlis
nreverse parse-error
nset-diﬀerence parse-integer
nset-exclusive-or parse-namestring
nstring-capitalize pathname
nstring-downcase pathname-device
nstring-upcase pathname-directory
nsublis pathname-host
nsubst pathname-match-p
nsubst-if pathname-name
nsubst-if-not pathname-type
nsubstitute pathname-version
nsubstitute-if pathnamep
nsubstitute-if-not peek-char
nth phase
nth-value pi
nthcdr plusp
null pop
number position
numberp position-if
numerator position-if-not
nunion pprint
oddp pprint-dispatch
open pprint-exit-if-list-exhausted
open-stream-p pprint-ﬁll
optimize pprint-indent
or pprint-linear
otherwise pprint-logical-block
output-stream-p pprint-newline
package pprint-pop
Figure 1–11. Symbols in the COMMON-LISP package (part eight of twelve).
1–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pprint-tab read-char
pprint-tabular read-char-no-hang
prin1 read-delimited-list
prin1-to-string read-from-string
princ read-line
princ-to-string read-preserving-whitespace
print read-sequence
print-not-readable reader-error
print-not-readable-object readtable
print-object readtable-case
print-unreadable-object readtablep
probe-ﬁle real
proclaim realp
prog realpart
prog* reduce
prog1 reinitialize-instance
prog2 rem
progn remf
program-error remhash
progv remove
provide remove-duplicates
psetf remove-if
psetq remove-if-not
push remove-method
pushnew remprop
quote rename-ﬁle
random rename-package
random-state replace
random-state-p require
rassoc rest
rassoc-if restart
rassoc-if-not restart-bind
ratio restart-case
rational restart-name
rationalize return
rationalp return-from
read revappend
read-byte reverse
Figure 1–12. Symbols in the COMMON-LISP package (part nine of twelve).
Introduction 1–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
room simple-bit-vector
rotatef simple-bit-vector-p
round simple-condition
row-major-aref simple-condition-format-arguments
rplaca simple-condition-format-control
rplacd simple-error
safety simple-string
satisﬁes simple-string-p
sbit simple-type-error
scale-ﬂoat simple-vector
schar simple-vector-p
search simple-warning
second sin
sequence single-ﬂoat
serious-condition single-ﬂoat-epsilon
set single-ﬂoat-negative-epsilon
set-diﬀerence sinh
set-dispatch-macro-character sixth
set-exclusive-or sleep
set-macro-character slot-boundp
set-pprint-dispatch slot-exists-p
set-syntax-from-char slot-makunbound
setf slot-missing
setq slot-unbound
seventh slot-value
shadow software-type
shadowing-import software-version
shared-initialize some
shiftf sort
short-ﬂoat space
short-ﬂoat-epsilon special
short-ﬂoat-negative-epsilon special-operator-p
short-site-name speed
signal sqrt
signed-byte stable-sort
signum standard
simple-array standard-char
simple-base-string standard-char-p
Figure 1–13. Symbols in the COMMON-LISP package (part ten of twelve).
1–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
standard-class sublis
standard-generic-function subseq
standard-method subsetp
standard-object subst
step subst-if
storage-condition subst-if-not
store-value substitute
stream substitute-if
stream-element-type substitute-if-not
stream-error subtypep
stream-error-stream svref
stream-external-format sxhash
streamp symbol
string symbol-function
string-capitalize symbol-macrolet
string-downcase symbol-name
string-equal symbol-package
string-greaterp symbol-plist
string-left-trim symbol-value
string-lessp symbolp
string-not-equal synonym-stream
string-not-greaterp synonym-stream-symbol
string-not-lessp t
string-right-trim tagbody
string-stream tailp
string-trim tan
string-upcase tanh
string/= tenth
string < terpri
string <= the
string= third
string > throw
string >= time
stringp trace
structure translate-logical-pathname
structure-class translate-pathname
structure-object tree-equal
style-warning truename
Figure 1–14. Symbols in the COMMON-LISP package (part eleven of twelve).
Introduction 1–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
truncate values-list
two-way-stream variable
two-way-stream-input-stream vector
two-way-stream-output-stream vector-pop
type vector-push
type-error vector-push-extend
type-error-datum vectorp
type-error-expected-type warn
type-of warning
typecase when
typep wild-pathname-p
unbound-slot with-accessors
unbound-slot-instance with-compilation-unit
unbound-variable with-condition-restarts
undeﬁned-function with-hash-table-iterator
unexport with-input-from-string
unintern with-open-ﬁle
union with-open-stream
unless with-output-to-string
unread-char with-package-iterator
unsigned-byte with-simple-restart
untrace with-slots
unuse-package with-standard-io-syntax
unwind-protect write
update-instance-for-diﬀerent-class write-byte
update-instance-for-redeﬁned-class write-char
upgraded-array-element-type write-line
upgraded-complex-part-type write-sequence
upper-case-p write-string
use-package write-to-string
use-value y-or-n-p
user-homedir-pathname yes-or-no-p
values zerop
Figure 1–15. Symbols in the COMMON-LISP package (part twelve of twelve).
1–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
2. Syntax
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Syntaxiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.1 Character Syntax
The Lisp reader takes characters from a stream , interprets them as a printed representation of an
object , constructs that object , and returns it.
The syntax described by this chapter is called the standard syntax . Operations are provided by
Common Lisp so that various aspects of the syntax information represented by a readtable can be
modied under program control; see Chapter 23 (Reader). Except as explicitly stated otherwise,
the syntax used throughout this document is standard syntax .
2.1.1 Readtables
Syntax information for use by the Lisp reader is embodied in an object called a readtable . Among
other things, the readtable contains the association between characters and syntax types .
Figure 2{1 lists some dened names that are applicable to readtables .
*readtable* readtable-case
copy-readtable readtablep
get-dispatch-macro-character set-dispatch-macro-character
get-macro-character set-macro-character
make-dispatch-macro-character set-syntax-from-char
Figure 2–1. Readtable deﬁned names
2.1.1.1 The Current Readtable
Several readtables describing dierent syntaxes can exist, but at any given time only one, called
thecurrent readtable , aects the way in which expressions 2are parsed into objects by the Lisp
reader . The current readtable in a given dynamic environment is the value of*readtable* in that
environment . To make a dierent readtable become the current readtable ,*readtable* can be
assigned orbound .
2.1.1.2 The Standard Readtable
Thestandard readtable conforms to standard syntax . The consequences are undened if an
attempt is made to modify the standard readtable . To achieve the eect of altering or extending
standard syntax , a copy of the standard readtable can be created; see the functioncopy-readtable .
The readtable case of the standard readtable is:upcase .
Syntax2–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.1.1.3 The Initial Readtable
Theinitial readtable is the readtable that is the current readtable at the time when the Lisp
image starts. At that time, it conforms to standard syntax . The initial readtable isdistinct from
thestandard readtable . It is permissible for a conforming program to modify the initial readtable .
2.1.2 Variables that aﬀect the Lisp Reader
The Lisp reader is inuenced not only by the current readtable , but also by various dynamic
variables . Figure 2{2 lists the variables that inuence the behavior of the Lisp reader .
*package* *read-default-ﬂoat-format* *readtable*
*read-base* *read-suppress*
Figure 2–2. Variables that inﬂuence the Lisp reader.
2.1.3 Standard Characters
Allimplementations must support a character repertoire calledstandard-char ;characters that are
members of that repertoire are called standard characters .
Thestandard-char repertoire consists of the non-graphic character newline , the graphic character
space , and the following additional ninety-four graphic characters or their equivalents:
2–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Graphic ID Glyph Description Graphic ID Glyph Description
LA01 a small a LN01 n small n
LA02 A capital A LN02 N capital N
LB01 b small b LO01 o small o
LB02 B capital B LO02 O capital O
LC01 c small c LP01 p small p
LC02 C capital C LP02 P capital P
LD01 d small d LQ01 q small q
LD02 D capital D LQ02 Q capital Q
LE01 e small e LR01 r small r
LE02 E capital E LR02 R capital R
LF01 f small f LS01 s small s
LF02 F capital F LS02 S capital S
LG01 g small g LT01 t small t
LG02 G capital G LT02 T capital T
LH01 h small h LU01 u small u
LH02 H capital H LU02 U capital U
LI01 i small i LV01 v small v
LI02 I capital I LV02 V capital V
LJ01 j small j LW01 w small w
LJ02 J capital J LW02 W capital W
LK01 k small k LX01 x small x
LK02 K capital K LX02 X capital X
LL01 l small l LY01 y small y
LL02 L capital L LY02 Y capital Y
LM01 m small m LZ01 z small z
LM02 M capital M LZ02 Z capital Z
Figure 2–3. Standard Character Subrepertoire (Part 1 of 3: Latin Characters)
Graphic ID Glyph Description Graphic ID Glyph Description
ND01 1 digit 1 ND06 6 digit 6
ND02 2 digit 2 ND07 7 digit 7
ND03 3 digit 3 ND08 8 digit 8
ND04 4 digit 4 ND09 9 digit 9
ND05 5 digit 5 ND10 0 digit 0
Figure 2–4. Standard Character Subrepertoire (Part 2 of 3: Numeric Characters)
Syntax2–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Graphic ID Glyph Description
SP02 ! exclamation mark
SC03 $ dollar sign
SP04 " quotation mark, or double quote
SP05 ’ apostrophe, or [single] quote
SP06 ( left parenthesis, or open parenthesis
SP07 ) right parenthesis, or close parenthesis
SP08 , comma
SP09 low line, or underscore
SP10 - hyphen, or minus [sign]
SP11 . full stop, period, or dot
SP12 / solidus, or slash
SP13 : colon
SP14 ; semicolon
SP15 ? question mark
SA01 + plus [sign]
SA03 < less-than [sign]
SA04 = equals [sign]
SA05 > greater-than [sign]
SM01 # number sign, or sharp[sign]
SM02 % percent [sign]
SM03 & ampersand
SM04 * asterisk, or star
SM05 @ commercial at, or at-sign
SM06 [ left [square] bracket
SM07 \ reverse solidus, or backslash
SM08 ] right [square] bracket
SM11 { left curly bracket, or left brace
SM13 | vertical bar
SM14 } right curly bracket, or right brace
SD13 ‘ grave accent, or backquote
SD15^ circumex accent
SD19 ~ tilde
Figure 2–5. Standard Character Subrepertoire (Part 3 of 3: Special Characters)
The graphic IDs are not used within Common Lisp, but are provided for cross reference purposes
with ISO 6937/2. Note that the rst letter of the graphic ID categorizes the character as follows:
L|Latin, N|Numeric, S|Special.
2.1.4 Character Syntax Types
The Lisp reader constructs an object from the input text by interpreting each character according
to its syntax type . The Lisp reader cannot accept as input everything that the Lisp printer
2–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
produces, and the Lisp reader has features that are not used by the Lisp printer . The Lisp reader
can be used as a lexical analyzer for a more general user-written parser.
When the Lisp reader is invoked, it reads a single character from the input stream and dispatches
according to the syntax type of that character . Every character that can appear in the input
stream is of one of the syntax types shown in Figure 2{6.
constituent macro character single escape
invalid multiple escape whitespace 2
Figure 2–6. Possible Character Syntax Types
The syntax type of a character in a readtable determines how that character is interpreted by the
Lisp reader while that readtable is the current readtable . At any given time, every character has
exactly one syntax type .
Figure 2{7 lists the syntax type of each character instandard syntax .
character syntax type character syntax type
Backspace constituent 0{9 constituent
Tab whitespace 2 : constituent
Newline whitespace 2 ; terminating macro char
Linefeed whitespace 2 < constituent
Page whitespace 2 = constituent
Return whitespace 2 > constituent
Space whitespace 2 ? constituent *
! constituent * @ constituent
" terminating macro char A{Z constituent
# non-terminating macro char [ constituent *
$ constituent \ single escape
% constituent ] constituent *
& constituent^ constituent
' terminating macro char constituent
( terminating macro char ` terminating macro char
) terminating macro char a{z constituent
* constituent { constituent *
+ constituent | multiple escape
, terminating macro char } constituent *
- constituent ~ constituent
. constituent Rubout constituent
/ constituent
Figure 2–7. Character Syntax Types in Standard Syntax
Syntax2–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The characters marked with an asterisk (*) are initially constituents , but they are not used in any
standard Common Lisp notations. These characters are explicitly reserved to the programmer .~is
not used in Common Lisp, and reserved to implementors. $and%arealphabetic 2characters , but
are not used in the names of any standard Common Lisp dened names .
Whitespace 2characters serve as separators but are otherwise ignored. Constituent and escape
characters are accumulated to make a token , which is then interpreted as a number orsymbol .
Macro characters trigger the invocation of functions (possibly user-supplied) that can perform
arbitrary parsing actions. Macro characters are divided into two kinds, terminating and non-
terminating , depending on whether or not they terminate a token . The following are descriptions
of each kind of syntax type .
2.1.4.1 Constituent Characters
Constituent characters are used in tokens . Atoken is a representation of a number or a symbol .
Examples of constituent characters are letters and digits.
Letters in symbol names are sometimes converted to letters in the opposite case when the name is
read; see Section 23.1.2 (Eect of Readtable Case on the Lisp Reader). Case conversion can be
suppressed by the use of single escape ormultiple escape characters.
2.1.4.2 Constituent Traits
Every character has one or more constituent traits that dene how the character is to be interpreted
by the Lisp reader when the character is a constituent character . These constituent traits are
alphabetic 2, digit, package marker , plus sign, minus sign, dot, decimal point, ratio marker ,exponent
marker , and invalid . Figure 2{8 shows the constituent traits of the standard characters and of
certain semi-standard characters ; no mechanism is provided for changing the constituent trait of a
character . Any character with the alphadigit constituent trait in that gure is a digit if the current
input base is greater than that character's digit value, otherwise the character isalphabetic 2. Any
character quoted by a single escape is treated as an alphabetic 2constituent, regardless of its normal
syntax.
2–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
constituent traits constituent traits
character character
Backspace invalid { alphabetic 2
Tab invalid * } alphabetic 2
Newline invalid * + alphabetic 2, plus sign
Linefeed invalid * - alphabetic 2, minus sign
Page invalid * . alphabetic 2, dot, decimal point
Return invalid * / alphabetic 2,ratio marker
Space invalid * A, a alphadigit
! alphabetic 2 B, b alphadigit
" alphabetic 2* C, c alphadigit
# alphabetic 2* D, d alphadigit, double-oat exponent marker
$ alphabetic 2 E, e alphadigit, oat exponent marker
% alphabetic 2 F, f alphadigit, single-oat exponent marker
& alphabetic 2 G, g alphadigit
' alphabetic 2* H, h alphadigit
( alphabetic 2* I, i alphadigit
) alphabetic 2* J, j alphadigit
* alphabetic 2 K, k alphadigit
, alphabetic 2* L, l alphadigit, long-oat exponent marker
0-9 alphadigit M, m alphadigit
: package marker N, n alphadigit
; alphabetic 2* O, o alphadigit
< alphabetic 2 P, p alphadigit
= alphabetic 2 Q, q alphadigit
> alphabetic 2 R, r alphadigit
? alphabetic 2 S, s alphadigit, short-oat exponent marker
@ alphabetic 2 T, t alphadigit
[ alphabetic 2 U, u alphadigit
\ alphabetic 2* V, v alphadigit
] alphabetic 2 W, w alphadigit
^ alphabetic 2 X, x alphadigit
alphabetic 2 Y, y alphadigit
` alphabetic 2* Z, z alphadigit
| alphabetic 2* Rubout invalid
~ alphabetic 2
Figure 2–8. Constituent Traits of Standard Characters and Semi-Standard Characters
The interpretations in this table apply only to characters whose syntax type isconstituent . Entries
marked with an asterisk (*) are normally shadowed 2because the indicated characters are of syntax
type whitespace 2,macro character ,single escape , ormultiple escape ; these constituent traits apply
to them only if their syntax types are changed to constituent .
Syntax2–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.1.4.3 Invalid Characters
Characters with the constituent trait invalid cannot ever appear in a token except under the
control of a single escape character . If an invalid character is encountered while an object is being
read, an error of typereader-error is signaled. If an invalid character is preceded by a single
escape character , it is treated as an alphabetic 2constituent instead.
2.1.4.4 Macro Characters
When the Lisp reader encounters a macro character on an input stream , special parsing of
subsequent characters on the input stream is performed.
Amacro character has an associated function called a reader macro function that implements
its specialized parsing behavior. An association of this kind can be established or modied
under control of a conforming program by using the functions set-macro-character and
set-dispatch-macro-character .
Upon encountering a macro character , the Lisp reader calls its reader macro function , which
parses one specially formatted object from the input stream . The function either returns the
parsed object , or else it returns no values to indicate that the characters scanned by the function
are being ignored ( e.g., in the case of a comment). Examples of macro characters arebackquote ,
single-quote ,left-parenthesis , and right-parenthesis .
Amacro character is either terminating ornon-terminating . The dierence between terminating
and non-terminating macro characters lies in what happens when such characters occur in the
middle of a token . If a non-terminating macro character occurs in the middle of a token ,
thefunction associated with the non-terminating macro character is not called, and the non-
terminating macro character does not terminate the token 's name; it becomes part of the name
as if the macro character were really a constituent character. A terminating macro character
terminates any token , and its associated reader macro function is called no matter where the
character appears. The only non-terminating macro character instandard syntax issharpsign .
If acharacter is adispatching macro character C1, its reader macro function is afunction supplied
by the implementation . This function reads decimal digit characters until a non- digitC2is
read. If any digits were read, they are converted into a corresponding integer inx parameter P;
otherwise, the inx parameter Pisnil. The terminating non- digitC2is acharacter (sometimes
called a \sub-character" to emphasize its subordinate role in the dispatching) that is looked up
in the dispatch table associated with the dispatching macro character C1. The reader macro
function associated with the sub-character C2is invoked with three arguments: the stream , the
sub-character C2, and the inx parameter P. For more information about dispatch characters, see
thefunctionset-dispatch-macro-character .
For information about the macro characters that are available in standard syntax , see Section 2.4
(Standard Macro Characters).
2–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.1.4.5 Multiple Escape Characters
A pair of multiple escape characters is used to indicate that an enclosed sequence of characters,
including possible macro characters and whitespace 2characters , are to be treated as alphabetic 2
characters with case preserved. Any single escape and multiple escape characters that are to
appear in the sequence must be preceded by a single escape character .
Vertical-bar is amultiple escape character instandard syntax .
2.1.4.5.1 Examples of Multiple Escape Characters
;; The following examples assume the readtable case of *readtable*
;; and *print-case* are both :upcase.
(eq ’abc ’ABC)!true
(eq ’abc ’|ABC|) !true
(eq ’abc ’a|B|c) !true
(eq ’abc ’|abc|) !false
2.1.4.6 Single Escape Character
Asingle escape is used to indicate that the next character is to be treated as an alphabetic 2
character with its case preserved, no matter what the character is or which constituent traits it
has.
Backslash is asingle escape character instandard syntax .
2.1.4.6.1 Examples of Single Escape Characters
;; The following examples assume the readtable case of *readtable*
;; and *print-case* are both :upcase.
(eq ’abc ’\A\B\C) !true
(eq ’abc ’a\Bc) !true
(eq ’abc ’\ABC) !true
(eq ’abc ’\abc) !false
2.1.4.7 Whitespace Characters
Whitespace 2characters are used to separate tokens .
Space and newline arewhitespace 2characters instandard syntax .
Syntax2–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.1.4.7.1 Examples of Whitespace Characters
(length ’(this-that)) !1
(length ’(this - that)) !3
(length ’(a
b))!2
(+ 34)!34
(+ 3 4)!7
2–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.2 Reader Algorithm
This section describes the algorithm used by the Lisp reader to parse objects from an input
character stream , including how the Lisp reader processes macro characters .
When dealing with tokens , the reader's basic function is to distinguish representations of symbols
from those of numbers . When a token is accumulated, it is assumed to represent a number if
it satises the syntax for numbers listed in Figure 2{9. If it does not represent a number , it is
then assumed to be a potential number if it satises the rules governing the syntax for a potential
number . If a valid token is neither a representation of a number nor a potential number , it
represents a symbol .
The algorithm performed by the Lisp reader is as follows:
1. If at end of le, end-of-le processing is performed as specied in read. Otherwise, one
character ,x, is read from the input stream , and dispatched according to the syntax type ofx
to one of steps 2 to 7.
2. If xis an invalid character , an error of typereader-error is signaled.
3. If xis awhitespace 2character , then it is discarded and step 1 is re-entered.
4. If xis a terminating ornon-terminating macro character then its associated reader macro
function is called with two arguments , the input stream and x.
The reader macro function may read characters from the input stream ; if it does, it will see
those characters following the macro character . The Lisp reader may be invoked recursively
from the reader macro function .
The reader macro function must not have any side eects other than on the input stream ;
because of backtracking and restarting of the read operation, front ends to the Lisp reader
(e.g., \editors" and \rubout handlers") may cause the reader macro function to be called
repeatedly during the reading of a single expression in which xonly appears once.
The reader macro function may return zero values or one value. If one value is returned, then
that value is returned as the result of the read operation; the algorithm is done. If zero values
are returned, then step 1 is re-entered.
5. If xis a single escape character then the next character ,y, is read, or an error of type
end-of-ﬁle is signaled if at the end of le. yis treated as if it is a constituent whose only
constituent trait isalphabetic 2.yis used to begin a token , and step 8 is entered.
6. If xis amultiple escape character then a token (initially containing no characters ) is begun
and step 9 is entered.
7. If xis a constituent character , then it begins a token . After the token is read in, it will be
interpreted either as a Lisp object or as being of invalid syntax. If the token represents an
Syntax2–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
object , that object is returned as the result of the read operation. If the token is of invalid
syntax, an error is signaled. If xis a character with case, it might be replaced with the
corresponding character of the opposite case, depending on the readtable case of the current
readtable , as outlined in Section 23.1.2 (Eect of Readtable Case on the Lisp Reader). Xis
used to begin a token , and step 8 is entered.
8. At this point a token is being accumulated, and an even number of multiple escape characters
have been encountered. If at end of le, step 10 is entered. Otherwise, a character ,y, is read,
and one of the following actions is performed according to its syntax type :
Ifyis aconstituent ornon-terminating macro character :
{ If yis a character with case, it might be replaced with the corresponding
character of the opposite case, depending on the readtable case of the current
readtable , as outlined in Section 23.1.2 (Eect of Readtable Case on the Lisp
Reader).
{ Yis appended to the token being built.
{ Step 8 is repeated.
Ifyis asingle escape character , then the next character ,z, is read, or an error of type
end-of-ﬁle is signaled if at end of le. Zis treated as if it is a constituent whose only
constituent trait isalphabetic 2.Zis appended to the token being built, and step 8 is
repeated.
Ifyis amultiple escape character , then step 9 is entered.
Ifyis an invalid character , an error of typereader-error is signaled.
Ifyis aterminating macro character , then it terminates the token . First the character
yis unread (see unread-char ), and then step 10 is entered.
Ifyis awhitespace 2character , then it terminates the token . First the character yis
unread if appropriate (see read-preserving-whitespace ), and then step 10 is entered.
9. At this point a token is being accumulated, and an odd number of multiple escape characters
have been encountered. If at end of le, an error of typeend-of-ﬁle is signaled. Otherwise, a
character ,y, is read, and one of the following actions is performed according to its syntax type :
Ifyis a constituent , macro, or whitespace 2character ,yis treated as a constituent
whose only constituent trait isalphabetic 2.Yis appended to the token being built,
and step 9 is repeated.
Ifyis a single escape character , then the next character ,z, is read, or an error of
typeend-of-ﬁle is signaled if at end of le. Zis treated as a constituent whose only
constituent trait isalphabetic 2.Zis appended to the token being built, and step 9 is
repeated.
2–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Ifyis amultiple escape character , then step 8 is entered.
Ifyis an invalid character , an error of typereader-error is signaled.
10. An entire token has been accumulated. The object represented by the token is returned as the
result of the read operation, or an error of typereader-error is signaled if the token is not of
valid syntax.
Syntax2–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.3 Interpretation of Tokens
2.3.1 Numbers as Tokens
When a token is read, it is interpreted as a number orsymbol . The token is interpreted as a number
if it satises the syntax for numbers specied in Figure 2{9.
numeric-token ::=#integerj#ratioj#oat
integer ::=[sign]fdecimal-digitg+decimal-pointj[sign]fdigitg+
ratio ::=[sign]fdigitg+slashfdigitg+
oat ::=[sign]fdecimal-digitg*decimal-pointfdecimal-digitg+[#exponent ]
j[sign]fdecimal-digitg+[decimal-pointfdecimal-digitg*]#exponent
exponent ::=exponent-marker [sign]fdigitg+
sign|asign.
slash|aslash
decimal-point |adot.
exponent-marker |an exponent marker .
decimal-digit |adigit inradix10.
digit|adigit in the current input radix .
Figure 2–9. Syntax for Numeric Tokens
2.3.1.1 Potential Numbers as Tokens
To allow implementors and future Common Lisp standards to extend the syntax of numbers, a
syntax for potential numbers is dened that is more general than the syntax for numbers. A token
is apotential number if it satises all of the following requirements:
1. The token consists entirely of digits ,signs ,ratio markers , decimal points ( .), extension
characters (^or), and number markers. A number marker is a letter. Whether a letter may
be treated as a number marker depends on context, but no letter that is adjacent to another
letter may ever be treated as a number marker. Exponent markers are number markers.
2. The token contains at least one digit. Letters may be considered to be digits, depending on
thecurrent input base , but only in tokens containing no decimal points.
2–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3. The token begins with a digit,sign, decimal point, or extension character, but not a package
marker . The syntax involving a leading package marker followed by a potential number is not
well-dened. The consequences of the use of notation such as :1,:1/2, and:2^3in a position
where an expression appropriate for read is expected are unspecied.
4. The token does not end with a sign.
If a potential number has number syntax, a number of the appropriate type is constructed and
returned, if the number is representable in an implementation. A number will not be representable
in an implementation if it is outside the boundaries set by the implementation-dependent constants
fornumbers . For example, specifying too large or too small an exponent for a oat may make the
number impossible to represent in the implementation. A ratio with denominator zero (such as
-35/000 ) is not represented in any implementation. When a token with the syntax of a number
cannot be converted to an internal number , an error of typereader-error is signaled. An error
must not be signaled for specifying too many signicant digits for a oat; a truncated or rounded
value should be produced.
If there is an ambiguity as to whether a letter should be treated as a digit or as a number marker,
the letter is treated as a digit.
2.3.1.1.1 Escape Characters and Potential Numbers
Apotential number cannot contain any escape characters . An escape character robs the following
character of all syntactic qualities, forcing it to be strictly alphabetic 2and therefore unsuitable
for use in a potential number . For example, all of the following representations are interpreted as
symbols , not numbers :
\256 25\64 1.0\E6 |100| 3\.14159 |3/4| 3\/4 5||
In each case, removing the escape character (orcharacters ) would cause the token to be a potential
number .
2.3.1.1.2 Examples of Potential Numbers
As examples, the tokens in Figure 2{10 are potential numbers , but they are not actually numbers,
and so are reserved tokens ; aconforming implementation is permitted, but not required, to dene
their meaning.
1b5000 777777q 1.7J -3/4+6.7J 12/25/83
27^19 3^4/5 6//7 3.1.2.6^-43^
3.1415926535897932384 -3.7+2.6i-6.17j+19.6k
Figure 2–10. Examples of reserved tokens
Syntax2–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The tokens in Figure 2{11 are not potential numbers ; they are always treated as symbols :
/ /5 + 1+ 1-
foo+ ab.cd^ ^ /-
Figure 2–11. Examples of symbols
The tokens in Figure 2{12 are potential numbers if the current input base is16, but they are always
treated as symbols if the current input base is10.
bad-face 25-dec-83 a/b fad cafe f^
Figure 2–12. Examples of symbols or potential numbers
2.3.2 Constructing Numbers from Tokens
Arealis constructed directly from a corresponding numeric token ; see Figure 2{9.
Acomplex is notated as a #C(or#c) followed by a listof two reals; see Section 2.4.8.11 (Sharpsign
C).
The reader macros #B,#O,#X, and#Rmay also be useful in controlling the input radix in which
rationals are parsed; see Section 2.4.8.7 (Sharpsign B), Section 2.4.8.8 (Sharpsign O), Section
2.4.8.9 (Sharpsign X), and Section 2.4.8.10 (Sharpsign R).
This section summarizes the full syntax for numbers .
2.3.2.1 Syntax of a Rational
2.3.2.1.1 Syntax of an Integer
Integers can be written as a sequence of digits , optionally preceded by a sign and optionally
followed by a decimal point; see Figure 2{9. When a decimal point is used, the digits are taken
to be in radix10; when no decimal point is used, the digits are taken to be in radix given by the
current input base .
For information on how integers are printed, see Section 22.1.3.1.1 (Printing Integers).
2–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.3.2.1.2 Syntax of a Ratio
Ratios can be written as an optional sign followed by two non-empty sequences of digits separated
by a slash ; see Figure 2{9. The second sequence may not consist entirely of zeros. Examples of
ratios are in Figure 2{13.
2/3 ;This is in canonical form
4/6 ;A non-canonical form for 2/3
-17/23 ;A ratio preceded by a sign
-30517578125/32768 ;This is ( 5=2)15
10/5 ;The canonical form for this is 2
#o-101/75 ;Octal notation for  65=61
#3r120/21 ;Ternary notation for 15=7
#Xbc/ad ;Hexadecimal notation for 188=173
#xFADED/FACADE ;Hexadecimal notation for 1027565=16435934
Figure 2–13. Examples of Ratios
For information on how ratios are printed, see Section 22.1.3.1.2 (Printing Ratios).
2.3.2.2 Syntax of a Float
Floats can be written in either decimal fraction or computerized scientic notation: an optional
sign, then a non-empty sequence of digits with an embedded decimal point, then an optional
decimal exponent specication. If there is no exponent specier, then the decimal point is required,
and there must be digits after it. The exponent specier consists of an exponent marker , an
optional sign, and a non-empty sequence of digits. If no exponent specier is present, or if the
exponent marker e(orE) is used, then the format specied by *read-default-ﬂoat-format* is used.
See Figure 2{9.
An implementation may provide one or more kinds of oat that collectively make up the typeﬂoat.
The letters s,f,d, andl(or their respective uppercase equivalents) explicitly specify the use of the
typesshort-ﬂoat ,single-ﬂoat ,double-ﬂoat , andlong-ﬂoat , respectively.
The internal format used for an external representation depends only on the exponent marker , and
not on the number of decimal digits in the external representation.
Figure 2{14 contains examples of notations for oats :
Syntax2–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
0.0 ;Floating-point zero in default format
0E0 ;As input, this is also oating-point zero in default format.
;As output, this would appear as 0.0.
0e0 ;As input, this is also oating-point zero in default format.
;As output, this would appear as 0.0.
-.0 ;As input, this might be a zero or a minus zero,
; depending on whether the implementation supports
; a distinct minus zero.
;As output, 0.0is zero and -0.0 is minus zero.
0. ;On input, the integer zero| nota oating-point number!
;Whether this appears as 0or0.on output depends
;on the value of*print-radix* .
0.0s0 ;A oating-point zero in short format
0s0 ;As input, this is a oating-point zero in short format.
;As output, such a zero would appear as 0.0s0
; (or as0.0ifshort-ﬂoat was the default format).
6.02E+23 ;Avogadro's number, in default format
602E+21 ;Also Avogadro's number, in default format
Figure 2–14. Examples of Floating-point numbers
For information on how oats are printed, see Section 22.1.3.1.3 (Printing Floats).
2.3.2.3 Syntax of a Complex
Acomplex has a Cartesian structure, with a real part and an imaginary part each of which is a
real. The parts of a complex are not necessarily oats but both parts must be of the same type:
either both are rationals , or both are of the same oat subtype . When constructing a complex , if
the specied parts are not the same type, the parts are converted to be the same type internally
(i.e., the rational part is converted to a oat). An object of type(complex rational) is converted
internally and represented thereafter as a rational if its imaginary part is an integer whose value is
0.
For further information, see Section 2.4.8.11 (Sharpsign C) and Section 22.1.3.1.4 (Printing
Complexes).
2.3.3 The Consing Dot
If atoken consists solely of dots (with no escape characters), then an error of typereader-error
is signaled, except in one circumstance: if the token is a single dotand appears in a situation
where dotted pair notation permits a dot, then it is accepted as part of such syntax and no error is
signaled. See Section 2.4.1 (Left-Parenthesis).
2–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.3.4 Symbols as Tokens
Any token that is not a potential number , does not contain a package marker , and does not consist
entirely of dots will always be interpreted as a symbol . Any token that is a potential number
but does not t the number syntax is a reserved token and has an implementation-dependent
interpretation. In all other cases, the token is construed to be the name of a symbol .
Examples of the printed representation of symbols are in Figure 2{15. For presentational simplicity,
these examples assume that the readtable case of the current readtable is:upcase .
FROBBOZ The symbol whose name isFROBBOZ .
frobboz Another way to notate the same symbol .
fRObBoz Yet another way to notate it.
unwind-protect Asymbol with a hyphen in its name .
+$ The symbol named+$.
1+ The symbol named1+.
+1 This is the integer1, not a symbol .
pascalstyle This symbol has an underscore in its name .
file.rel.43 This symbol has periods in its name .
\( The symbol whose name is(.
\+1 The symbol whose name is+1.
+\1 Also the symbol whose name is+1.
\frobboz The symbol whose name isfROBBOZ .
3.14159265\s0 The symbol whose name is3.14159265s0 .
3.14159265\S0 A dierent symbol , whose name is3.14159265S0 .
3.14159265s0 A possible short oat approximation to .
Figure 2–15. Examples of the printed representation of symbols (Part 1 of 2)
Syntax2–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
APL\\360 The symbol whose name isAPL\360 .
apl\\360 Also the symbol whose name isAPL\360 .
\(b^2\)\ -\ 4*a*c The name is(B^2) - 4*A*C .
Parentheses and two spaces in it.
\(\b^2\)\ -\4*\a*\c The name is(b^2) - 4*a*c .
Letters explicitly lowercase.
|"| The same as writing \".
|(b^2) - 4*a*c| The name is(b^2) - 4*a*c .
|frobboz| The name isfrobboz , notFROBBOZ .
|APL\360| The name isAPL360 .
|APL\\360| The name isAPL\360 .
|apl\\360| The name isapl\360 .
|\|\|| Same as \|\| |the name is||.
|(B^2) - 4*A*C| The name is(B^2) - 4*A*C .
Parentheses and two spaces in it.
|(b^2) - 4*a*c| The name is(b^2) - 4*a*c .
Figure 2–16. Examples of the printed representation of symbols (Part 2 of 2)
In the process of parsing a symbol , it is implementation-dependent which implementation-dened
attributes are removed from the characters forming a token that represents a symbol .
When parsing the syntax for a symbol , the Lisp reader looks up the name of that symbol in the
current package . This lookup may involve looking in other packages whose external symbols are
inherited by the current package . If the name is found, the corresponding symbol is returned. If
the name is not found (that is, there is no symbol of that name accessible in the current package ),
a new symbol is created and is placed in the current package as an internal symbol . The current
package becomes the owner ( home package ) of the symbol , and the symbol becomes interned in
thecurrent package . If the name is later read again while this same package is current, the same
symbol will be found and returned.
2.3.5 Valid Patterns for Tokens
The valid patterns for tokens are summarized in Figure 2{17.
2–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
nnnnn anumber
xxxxx asymbol in the current package
:xxxxx asymbol in the the KEYWORD package
ppppp:xxxxx anexternal symbol in the ppppp package
ppppp::xxxxx a (possibly internal) symbol in the ppppp package
:nnnnn undened
ppppp:nnnnn undened
ppppp::nnnnn undened
::aaaaa undened
aaaaa: undened
aaaaa:aaaaa:aaaaa undened
Figure 2–17. Valid patterns for tokens
Note that nnnnn has number syntax, neither xxxxx norppppp has number syntax, and aaaaa has
any syntax.
A summary of rules concerning package markers follows. In each case, examples are oered to
illustrate the case; for presentational simplicity, the examples assume that the readtable case of the
current readtable is:upcase .
1. If there is a single package marker , and it occurs at the beginning of the token , then the
token is interpreted as a symbol in theKEYWORD package . It also sets the symbol-value of the
newly-created symbol to that same symbol so that the symbol will self-evaluate.
For example, :bar, when read, interns BARas an external symbol in theKEYWORD package .
2. If there is a single package marker not at the beginning or end of the token , then it divides
thetoken into two parts. The rst part species a package ; the second part is the name of an
external symbol available in that package.
For example, foo:bar , when read, looks up BARamong the external symbols of the package
namedFOO.
3. If there are two adjacent package markers not at the beginning or end of the token , then they
divide the token into two parts. The rst part species a package ; the second part is the name
of a symbol within that package (possibly an internal symbol ).
For example, foo::bar , when read, interns BARin the package namedFOO.
4. If the token contains no package markers , and does not have potential number syntax, then
the entire token is the name of the symbol . The symbol is looked up in the current package .
For example, bar, when read, interns BARin the current package .
Syntax2–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
5. The consequences are unspecied if any other pattern of package markers in a token is used.
All other uses of package markers within names of symbols are not dened by this standard
but are reserved for implementation-dependent use.
For example, assuming the readtable case of the current readtable is:upcase ,editor:buffer refers
to the external symbol namedBUFFER present in the package namededitor , regardless of whether
there is a symbol namedBUFFER in the current package . If there is no package namededitor , or if
nosymbol namedBUFFER is present in editor , or ifBUFFER is not exported by editor , the reader
signals a correctable error. If editor::buffer is seen, the eect is exactly the same as reading
buffer with the EDITOR package being the current package .
2.3.6 Package System Consistency Rules
The following rules apply to the package system as long as the value of*package* is not changed:
Read-read consistency
Reading the same symbol name always results in the same symbol .
Print-read consistency
Aninterned symbol always prints as a sequence of characters that, when read back in,
yields the same symbol .
For information about how the Lisp printer treats symbols , see Section 22.1.3.3 (Printing
Symbols).
Print-print consistency
If two interned symbols are not the same , then their printed representations will be
dierent sequences of characters.
These rules are true regardless of any implicit interning. As long as the current package is not
changed, results are reproducible regardless of the order of loading les or the exact history of
what symbols were typed in when. If the value of*package* is changed and then changed back
to the previous value, consistency is maintained. The rules can be violated by changing the value
of*package* , forcing a change to symbols or to packages or to both by continuing from an error,
or calling one of the following functions :unintern ,unexport ,shadow ,shadowing-import , or
unuse-package .
An inconsistency only applies if one of the restrictions is violated between two of the named
symbols .shadow ,unexport ,unintern , andshadowing-import can only aect the consistency of
symbols with the same names (understring= ) as the ones supplied as arguments.
2–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4 Standard Macro Characters
If the reader encounters a macro character , then its associated reader macro function is invoked
and may produce an object to be returned. This function may read the characters following the
macro character in the stream in any syntax and return the object represented by that syntax.
Any character can be made to be a macro character . The macro characters dened initially in a
conforming implementation include the following:
2.4.1 Left-Parenthesis
The left-parenthesis initiates reading of a list.read is called recursively to read successive objects
until a right parenthesis is found in the input stream . Alistof the objects read is returned. Thus
(a b c)
is read as a listof three objects (the symbols a,b, andc). The right parenthesis need not
immediately follow the printed representation of the last object ;whitespace 2characters and
comments may precede it.
If no objects precede the right parenthesis, it reads as a listof zero objects (the empty list ).
If a token that is just a dot not immediately preceded by an escape character is read after
some object then exactly one more object must follow the dot, possibly preceded or followed by
whitespace 2or a comment, followed by the right parenthesis:
(a b c . d)
This means that the cdrof the last cons in the listis notnil, but rather the object whose
representation followed the dot. The above example might have been the result of evaluating
(cons ’a (cons ’b (cons ’c ’d)))
Similarly,
(cons ’this-one ’that-one) !(this-one . that-one)
It is permissible for the object following the dot to be a list:
(a b c d . (e f . (g))) (a b c d e f g)
For information on how the Lisp printer prints lists andconses , see Section 22.1.3.5 (Printing Lists
and Conses).
2.4.2 Right-Parenthesis
The right-parenthesis is invalid except when used in conjunction with the left parenthesis character.
For more information, see Section 2.2 (Reader Algorithm).
Syntax2–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.3 Single-Quote
Syntax: ’hhexpii
Asingle-quote introduces an expression to be \quoted." Single-quote followed by an expression
expis treated by the Lisp reader as an abbreviation for and is parsed identically to the expression
(quote exp). See the special operator quote .
2.4.3.1 Examples of Single-Quote
’foo!FOO
”foo!(QUOTE FOO)
(car ”foo)!QUOTE
2.4.4 Semicolon
Syntax: ;hhtextii
Asemicolon introduces characters that are to be ignored, such as comments. The semicolon and
allcharacters up to and including the next newline or end of le are ignored.
2.4.4.1 Examples of Semicolon
(+ 3 ; three
4)
!7
2.4.4.2 Notes about Style for Semicolon
Some text editors make assumptions about desired indentation based on the number of semicolons
that begin a comment. The following style conventions are common, although not by any means
universal.
2.4.4.2.1 Use of Single Semicolon
Comments that begin with a single semicolon are all aligned to the same column at the right
(sometimes called the \comment column"). The text of such a comment generally applies only to
the line on which it appears. Occasionally two or three contain a single sentence together; this is
sometimes indicated by indenting all but the rst with an additional space (after the semicolon ).
2–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.4.2.2 Use of Double Semicolon
Comments that begin with a double semicolon are all aligned to the same level of indentation as a
form would be at that same position in the code. The text of such a comment usually describes the
state of the program at the point where the comment occurs, the code which follows the comment,
or both.
2.4.4.2.3 Use of Triple Semicolon
Comments that begin with a triple semicolon are all aligned to the left margin. Usually they are
used prior to a denition or set of denitions, rather than within a denition.
2.4.4.2.4 Use of Quadruple Semicolon
Comments that begin with a quadruple semicolon are all aligned to the left margin, and generally
contain only a short piece of text that serve as a title for the code which follows, and might be used
in the header or footer of a program that prepares code for presentation as a hardcopy document.
2.4.4.2.5 Examples of Style for Semicolon
;;;; Math Utilities
;;; FIB computes the the Fibonacci function in the traditional
;;; recursive way.
(defun fib (n)
(check-type n integer)
;; At this point we’re sure we have an integer argument.
;; Now we can get down to some serious computation.
(cond ((< n 0)
;; Hey, this is just supposed to be a simple example.
;; Did you really expect me to handle the general case?
(error "FIB got ~D as an argument." n))
((< n 2) n) ;fib[0]=0 and fib[1]=1
;; The cheap cases didn’t work.
;; Nothing more to do but recurse.
(t (+ (fib (- n 1)) ;The traditional formula
(fib (- n 2)))))) ; is fib[n-1]+fib[n-2].
Syntax2–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.5 Double-Quote
Syntax: "hhtextii"
The double-quote is used to begin and end a string . When a double-quote is encountered, characters
are read from the input stream and accumulated until another double-quote is encountered. If
asingle escape character is seen, the single escape character is discarded, the next character is
accumulated, and accumulation continues. The accumulated characters up to but not including the
matching double-quote are made into a simple string and returned. It is implementation-dependent
which attributes of the accumulated characters are removed in this process.
Examples of the use of the double-quote character are in Figure 2{18.
"Foo" ;A string with three characters in it
"" ;An empty string
"\"APL\\360?\" he cried." ;A string with twenty characters
"|x| = |-x|" ;A ten-character string
Figure 2–18. Examples of the use of double-quote
Note that to place a single escape character or a double-quote into a string, such a character must
be preceded by a single escape character. Note, too, that a multiple escape character need not be
quoted by a single escape character within a string.
For information on how the Lisp printer prints strings , see Section 22.1.3.4 (Printing Strings).
2.4.6 Backquote
The backquote introduces a template of a data structure to be built. For example, writing
‘(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))
is roughly equivalent to writing
(list ’cond
(cons (list ’numberp x) y)
(list* ’t (list ’print x) y))
Where a comma occurs in the template, the expression following the comma is to be evaluated
to produce an object to be inserted at that point. Assume bhas the value 3, for example, then
evaluating the form denoted by ‘(a b ,b ,(+ b 1) b) produces the result (a b 3 4 b) .
If a comma is immediately followed by an at-sign , then the form following the at-sign is evaluated
to produce a listofobjects . These objects are then \spliced" into place in the template. For
example, if xhas the value (a b c) , then
‘(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))
!(x (a b c) a b c foo b bar (b c) baz b c)
2–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The backquote syntax can be summarized formally as follows.
‘basic is the same as ’basic , that is, (quote basic), for any expression basic that is not a
listor a general vector .
‘,form is the same as form, for any form, provided that the representation of form does not
begin with at-sign ordot. (A similar caveat holds for all occurrences of a form after a
comma .)
‘,@form has undened consequences.
‘(x1 x2 x3 ... xn . atom) may be interpreted to mean
(append [x1] [x2] [x3]...[xn](quote atom))
where the brackets are used to indicate a transformation of an xjas follows:
{[form]is interpreted as (list ‘ form), which contains a backquoted form that
must then be further interpreted.
{[,form]is interpreted as (list form).
{[,@form]is interpreted as form.
‘(x1 x2 x3 ... xn) may be interpreted to mean the same as the backquoted form
‘(x1 x2 x3 ... xn . nil), thereby reducing it to the previous case.
‘(x1 x2 x3 ... xn . ,form) may be interpreted to mean
(append [x1] [x2] [x3]...[xn]form)
where the brackets indicate a transformation of an xjas described above.
‘(x1 x2 x3 ... xn . ,@form) has undened consequences.
‘#(x1 x2 x3 ... xn) may be interpreted to mean (apply #’vector ‘(x1 x2 x3 ... xn)) .
Anywhere \ ,@" may be used, the syntax \ ,." may be used instead to indicate that it is permissible
to operate destructively on the list structure produced by the form following the \ ,." (in eect, to
usenconc instead of append ).
If the backquote syntax is nested, the innermost backquoted form should be expanded rst. This
means that if several commas occur in a row, the leftmost one belongs to the innermost backquote .
Animplementation is free to interpret a backquoted formF1as any formF2that, when evaluated,
will produce a result that is the same underequal as the result implied by the above denition,
provided that the side-eect behavior of the substitute formF2is also consistent with the
Syntax2–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
description given above. The constructed copy of the template might or might not share list
structure with the template itself. As an example, the above denition implies that
‘((,a b) ,c ,@d)
will be interpreted as if it were
(append (list (append (list a) (list ’b) ’ nil)) (list c) d ’ nil)
but it could also be legitimately interpreted to mean any of the following:
(append (list (append (list a) (list ’b))) (list c) d)
(append (list (append (list a) ’(b))) (list c) d)
(list* (cons a ’(b)) c d)
(list* (cons a (list ’b)) c d)
(append (list (cons a ’(b))) (list c) d)
(list* (cons a ’(b)) c (copy-list d))
2.4.6.1 Notes about Backquote
Since the exact manner in which the Lisp reader will parse an expression involving the backquote
reader macro is not specied, an implementation is free to choose any representation that preserves
the semantics described.
Often an implementation will choose a representation that facilitates pretty printing of the
expression, so that (pprint ‘(a ,b)) will display ‘(a ,b) and not, for example, (list ’a b) .
However, this is not a requirement.
Implementors who have no particular reason to make one choice or another might wish to refer
toIEEE Standard for the Scheme Programming Language , which identies a popular choice of
representation for such expressions that might provide useful to be useful compatibility for some
user communities. There is no requirement, however, that any conforming implementation use this
particular representation. This information is provided merely for cross-reference purposes.
2.4.7 Comma
The comma is part of the backquote syntax; see Section 2.4.6 (Backquote). Comma is invalid if
used other than inside the body of a backquote expression as described above.
2–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.8 Sharpsign
Sharpsign is a non-terminating dispatching macro character . It reads an optional sequence of
digits and then one more character, and uses that character to select a function to run as a reader
macro function .
The standard syntax includes constructs introduced by the #character. The syntax of these
constructs is as follows: a character that identies the type of construct is followed by arguments
in some form. If the character is a letter, its case is not important; #Oand#oare considered to be
equivalent, for example.
Certain #constructs allow an unsigned decimal number to appear between the #and the character.
The reader macros associated with the dispatching macro character #are described later in this
section and summarized in Figure 2{19.
Syntax2–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
dispatch char purpose dispatch char purpose
Backspace signals error { undened*
Tab signals error } undened*
Newline signals error + read-time conditional
Linefeed signals error - read-time conditional
Page signals error . read-time evaluation
Return signals error / undened
Space signals error A, a array
! undened* B, b binary rational
" undened C, c complex number
# reference to = label D, d undened
$ undened E, e undened
% undened F, f undened
& undened G, g undened
' function abbreviation H, h undened
( simple vector I, i undened
) signals error J, j undened
* bit vector K, k undened
, undened L, l undened
: uninterned symbol M, m undened
; undened N, n undened
< signals error O, o octal rational
= labels following object P, p pathname
> undened Q, q undened
? undened* R, r radix- nrational
@ undened S, s structure
[ undened* T, t undened
\ character object U, u undened
] undened* V, v undened
^ undened W, w undened
undened X, x hexadecimal rational
` undened Y, y undened
| balanced comment Z, z undened
~ undened Rubout undened
Figure 2–19. Standard # Dispatching Macro Character Syntax
The combinations marked by an asterisk (*) are explicitly reserved to the user. No conforming
implementation denes them.
Note also that digits do not appear in the preceding table. This is because the notations #0,#1, ...,
#9are reserved for another purpose which occupies the same syntactic space. When a digit follows
asharpsign , it is not treated as a dispatch character. Instead, an unsigned integer argument is
2–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
accumulated and passed as an argument to the reader macro for the character that follows the
digits. For example, #2A((1 2) (3 4)) is a use of #Awith an argument of 2.
2.4.8.1 Sharpsign Backslash
Syntax: #\hhxii
When the token xis a single character long, this parses as the literal character char.Uppercase
andlowercase letters are distinguished after #\;#\Aand#\adenote dierent character objects . Any
single character works after #\, even those that are normally special to read, such as left-parenthesis
and right-parenthesis .
In the single character case, the xmust be followed by a non-constituent character . After#\is
read, the reader backs up over the slash and then reads a token , treating the initial slash as a
single escape character (whether it really is or not in the current readtable ).
When the token xis more than one character long, the xmust have the syntax of a symbol with no
embedded package markers . In this case, the sharpsign backslash notation parses as the character
whose name is(string-upcase x); see Section 13.1.7 (Character Names).
For information about how the Lisp printer prints character objects , see Section 22.1.3.2 (Printing
Characters).
2.4.8.2 Sharpsign Single-Quote
Any expression preceded by #’(sharpsign followed by single-quote ), as in #’expression , is
treated by the Lisp reader as an abbreviation for and parsed identically to the expression
(function expression ). Seefunction . For example,
(apply #’+ l)(apply (function +) l)
2.4.8.3 Sharpsign Left-Parenthesis
#(and)are used to notate a simple vector .
If an unsigned decimal integer appears between the #and(, it species explicitly the length of
thevector . The consequences are undened if the number of objects specied before the closing )
exceeds the unsigned decimal integer. If the number of objects supplied before the closing )is less
than the unsigned decimal integer but greater than zero, the last object is used to ll all remaining
elements of the vector . The consequences are undened if the unsigned decimal integer is non-zero
and number of objects supplied before the closing )is zero. For example,
#(a b c c c c)
#6(a b c c c c)
#6(a b c)
#6(a b c c)
Syntax2–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
all mean the same thing: a vector of length 6with elements a,b, and four occurrences of c. Other
examples follow:
#(a b c) ;A vector of length 3
#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)
;A vector containing the primes below 50
#() ;An empty vector
The notation #()denotes an empty vector , as does #0().
For information on how the Lisp printer prints vectors , see Section 22.1.3.4 (Printing Strings),
Section 22.1.3.6 (Printing Bit Vectors), or Section 22.1.3.7 (Printing Other Vectors).
2.4.8.4 Sharpsign Asterisk
Syntax: #*hhbitsii
Asimple bit vector is constructed containing the indicated bits(0's and1's), where the leftmost bit
has index zero and the subsequent bitshave increasing indices.
Syntax: #hhnii*hhbitsii
With an argument n, the vector to be created is of length n. If the number of bitsis less than n
but greater than zero, the last bit is used to ll all remaining bits of the bit vector .
The notations #*and#0*each denote an empty bit vector .
Regardless of whether the optional numeric argument nis provided, the token that follows the
asterisk is delimited by a normal token delimiter. However, (unless the value of*read-suppress*
istrue) an error of typereader-error is signaled if that token is not composed entirely of 0's and
1's, or if nwas supplied and the token is composed of more than n bits , or if nis greater than one,
but no bitswere specied. Neither a single escape nor a multiple escape is permitted in this token .
For information on how the Lisp printer prints bit vectors , see Section 22.1.3.6 (Printing Bit
Vectors).
2.4.8.4.1 Examples of Sharpsign Asterisk
For example, #*101111
#6*101111
#6*101
#6*1011
all mean the same thing: a vector of length 6with elements 1,0,1,1,1, and1.
For example:
#* ;An empty bit-vector
2–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.8.5 Sharpsign Colon
Syntax: #:hhsymbol-nameii
#:introduces an uninterned symbol whose name issymbol-name . Every time this syntax is
encountered, a distinct uninterned symbol is created. The symbol-name must have the syntax of a
symbol with no package prex .
For information on how the Lisp reader prints uninterned symbols , see Section 22.1.3.3 (Printing
Symbols).
2.4.8.6 Sharpsign Dot
#.foois read as the object resulting from the evaluation of the object represented by foo. The
evaluation is done during the read process, when the #.notation is encountered. The #.syntax
therefore performs a read-time evaluation of foo.
The normal eect of #.is inhibited when the value of*read-eval* isfalse. In that situation, an
error of typereader-error is signaled.
For an object that does not have a convenient printed representation, a form that computes the
object can be given using the #.notation.
2.4.8.7 Sharpsign B
#Brational reads rational in binary (radix 2). For example,
#B110113 ;1101 2
#b101/115/3
The consequences are undened if the token immediately following the #Bdoes not have the syntax
of a binary ( i.e., radix 2) rational .
2.4.8.8 Sharpsign O
#Orational reads rational in octal (radix 8). For example,
#o37/1531/13
#o777511
#o10569 ;105 8
The consequences are undened if the token immediately following the #Odoes not have the syntax
of an octal ( i.e., radix 8) rational .
Syntax2–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.8.9 Sharpsign X
#Xrational reads rational in hexadecimal (radix 16). The digits above 9are the letters Athrough F
(the lowercase letters athrough fare also acceptable). For example,
#xF003840
#x105261 ;105 16
The consequences are undened if the token immediately following the #Xdoes not have the syntax
of a hexadecimal ( i.e., radix 16) rational .
2.4.8.10 Sharpsign R
#nR
#radixRrational reads rational in radix radix .radix must consist of only digits that are interpreted
as an integer in decimal radix; its value must be between 2 and 36 (inclusive). Only valid digits for
the specied radix may be used.
For example, #3r102 is another way of writing 11(decimal), and #11R32 is another way of writing
35(decimal). For radices larger than 10, letters of the alphabet are used in order for the digits
after9. No alternate #notation exists for the decimal radix since a decimal point suces.
Figure 2{20 contains examples of the use of #B,#O,#X, and#R.
#2r11010101 ;Another way of writing 213decimal
#b11010101 ;Ditto
#b+11010101 ;Ditto
#o325 ;Ditto, in octal radix
#xD5 ;Ditto, in hexadecimal radix
#16r+D5 ;Ditto
#o-300 ;Decimal -192, written in base 8
#3r-21010 ;Same thing in base 3
#25R-7H ;Same thing in base 25
#xACCEDED ;181202413 , in hexadecimal radix
Figure 2–20. Radix Indicator Example
The consequences are undened if the token immediately following the #nRdoes not have the
syntax of a rational in radix n.
2.4.8.11 Sharpsign C
#Creads a following object , which must be a listof length two whose elements are both reals.
These reals denote, respectively, the real and imaginary parts of a complex number. If the two
parts as notated are not of the same data type, then they are converted according to the rules of
oating-point contagion described in Section 12.1.1.2 (Contagion in Numeric Operations).
2–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
#C(real imag )is equivalent to #.(complex (quote real) (quote imag)), except that #Cis not
aected by *read-eval* . See the functioncomplex .
Figure 2{21 contains examples of the use of #C.
#C(3.0s1 2.0s-1) ;Acomplex with small oat parts.
#C(5 -3) ;A \Gaussian integer"
#C(5/3 7.0) ;Will be converted internally to #C(1.66666 7.0)
#C(0 1) ;The imaginary unit; that is, i.
Figure 2–21. Complex Number Example
For further information, see Section 22.1.3.1.4 (Printing Complexes) and Section 2.3.2.3 (Syntax of
a Complex).
2.4.8.12 Sharpsign A
#nA
#nAobject constructs an n-dimensional array , using object as the value of the :initial-contents
argument to make-array .
For example, #2A((0 1 5) (foo 2 (hot dog))) represents a 2-by-3 matrix:
0 1 5
foo 2 (hot dog)
In contrast, #1A((0 1 5) (foo 2 (hot dog))) represents a vector oflength2whose elements are
lists:
(0 1 5) (foo 2 (hot dog))
#0A((0 1 5) (foo 2 (hot dog))) represents a zero-dimensional array whose sole element is a list:
((0 1 5) (foo 2 (hot dog)))
#0A foo represents a zero-dimensional array whose sole element is the symbolfoo. The notation
#1A foo is not valid because foois not a sequence .
If some dimension of the array whose representation is being parsed is found to be 0, alldimensions
to the right ( i.e., the higher numbered dimensions ) are also considered to be 0.
For information on how the Lisp printer prints arrays , see Section 22.1.3.4 (Printing Strings),
Section 22.1.3.6 (Printing Bit Vectors), Section 22.1.3.7 (Printing Other Vectors), or Section
22.1.3.8 (Printing Other Arrays).
Syntax2–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.8.13 Sharpsign S
#s(name slot1 value1 slot2 value2 ...) denotes a structure . This is valid only if name is the
name of a structure type already dened by defstruct and if the structure type has a standard
constructor function. Let cmstand for the name of this constructor function; then this syntax is
equivalent to
#.(cm keyword1 ’value1 keyword2 ’value2 ...)
where each keywordj is the result of computing
(intern (string slotj) (find-package ’keyword))
The net eect is that the constructor function is called with the specied slots having the specied
values. (This coercion feature is deprecated; in the future, keyword names will be taken in the
package they are read in, so symbols that are actually in the KEYWORD package should be used if that
is what is desired.)
Whatever object the constructor function returns is returned by the #Ssyntax.
For information on how the Lisp printer prints structures , see Section 22.1.3.12 (Printing
Structures).
2.4.8.14 Sharpsign P
#Preads a following object , which must be a string .
#Phhexpressioniiis equivalent to #.(parse-namestring ’ hhexpressionii), except that #Pis not aected
by*read-eval* .
For information on how the Lisp printer prints pathnames , see Section 22.1.3.11 (Printing
Pathnames).
2.4.8.15 Sharpsign Equal-Sign
#n=
#n=object reads as whatever object has object as its printed representation. However, that object
is labeled by n, a required unsigned decimal integer, for possible reference by the syntax #n#. The
scope of the label is the expression being read by the outermost call to read; within this expression ,
the same label may not appear twice.
2–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.8.16 Sharpsign Sharpsign
#n#
#n#, where nis a required unsigned decimal integer , provides a reference to some object labeled
by#n=; that is, #n#represents a pointer to the same ( eq)object labeled by #n=. For example, a
structure created in the variable yby this code:
(setq x (list ’p ’q))
(setq y (list (list ’a ’b) x ’foo x))
(rplacd (last y) (cdr y))
could be represented in this way:
((a b) . #1=(#2=(p q) foo #2# . #1#))
Without this notation, but with *print-length* set to10and*print-circle* set tonil, the
structure would print in this way:
((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...)
A reference #n#may only occur after a label #n=; forward references are not permitted. The
reference may not appear as the labeled object itself (that is, #n=#n#) may not be written because
theobject labeled by #n=is not well dened in this case.
2.4.8.17 Sharpsign Plus
#+provides a read-time conditionalization facility; the syntax is #+test expression . If the
feature expression testsucceeds, then this textual notation represents an object whose printed
representation is expression . If the feature expression testfails, then this textual notation is treated
aswhitespace 2; that is, it is as if the \ #+test expression " did not appear and only a space appeared
in its place.
For a detailed description of success and failure in feature expressions , see Section 24.1.2.1 (Feature
Expressions).
#+operates by rst reading the feature expression and then skipping over the form if the feature
expression fails. While reading the test, the current package is theKEYWORD package . Skipping over
theform is accomplished by binding*read-suppress* totrue and then calling read.
For examples, see Section 24.1.2.1.1 (Examples of Feature Expressions).
2.4.8.18 Sharpsign Minus
#-is like#+except that it skips the expression if the testsucceeds; that is,
#-test expression#+(not test)expression
For examples, see Section 24.1.2.1.1 (Examples of Feature Expressions).
Syntax2–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.8.19 Sharpsign Vertical-Bar
#|...|# is treated as a comment by the reader. It must be balanced with respect to other
occurrences of #|and|#, but otherwise may contain any characters whatsoever.
2.4.8.19.1 Examples of Sharpsign Vertical-Bar
The following are some examples that exploit the #|...|# notation:
;;; In this example, some debugging code is commented out with #|...|#
;;; Note that this kind of comment can occur in the middle of a line
;;; (because a delimiter marks where the end of the comment occurs)
;;; where a semicolon comment can only occur at the end of a line
;;; (because it comments out the rest of the line).
(defun add3 (n) #|(format t "~&Adding 3 to ~D." n)|# (+ n 3))
;;; The examples that follow show issues related to #| ... |# nesting.
;;; In this first example, #| and |# always occur properly paired,
;;; so nesting works naturally.
(defun mention-fun-fact-1a ()
(format t "CL uses ; and #|...|# in comments."))
!MENTION-FUN-FACT-1A
(mention-fun-fact-1a)
.CL uses ; and #|...|# in comments.
!NIL
#| (defun mention-fun-fact-1b ()
(format t "CL uses ; and #|...|# in comments.")) |#
(fboundp ’mention-fun-fact-1b) !NIL
;;; In this example, vertical-bar followed by sharpsign needed to appear
;;; in a string without any matching sharpsign followed by vertical-bar
;;; having preceded this. To compensate, the programmer has included a
;;; slash separating the two characters. In case 2a, the slash is
;;; unnecessary but harmless, but in case 2b, the slash is critical to
;;; allowing the outer #| ... |# pair match. If the slash were not present,
;;; the outer comment would terminate prematurely.
(defun mention-fun-fact-2a ()
(format t "Don’t use |\# unmatched or you’ll get in trouble!"))
!MENTION-FUN-FACT-2A
(mention-fun-fact-2a)
.Don’t use |# unmatched or you’ll get in trouble!
!NIL
#| (defun mention-fun-fact-2b ()
2–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(format t "Don’t use |\# unmatched or you’ll get in trouble!") |#
(fboundp ’mention-fun-fact-2b) !NIL
;;; In this example, the programmer attacks the mismatch problem in a
;;; different way. The sharpsign vertical bar in the comment is not needed
;;; for the correct parsing of the program normally (as in case 3a), but
;;; becomes important to avoid premature termination of a comment when such
;;; a program is commented out (as in case 3b).
(defun mention-fun-fact-3a () ; #|
(format t "Don’t use |# unmatched or you’ll get in trouble!"))
!MENTION-FUN-FACT-3A
(mention-fun-fact-3a)
.Don’t use |# unmatched or you’ll get in trouble!
!NIL
#|
(defun mention-fun-fact-3b () ; #|
(format t "Don’t use |# unmatched or you’ll get in trouble!"))
|#
(fboundp ’mention-fun-fact-3b) !NIL
2.4.8.19.2 Notes about Style for Sharpsign Vertical-Bar
Some text editors that purport to understand Lisp syntax treat any |...| as balanced pairs
that cannot nest (as if they were just balanced pairs of the multiple escapes used in notating
certain symbols). To compensate for this deciency, some programmers use the notation
#||...#||...||#...||# instead of #|...#|...|#...|# . Note that this alternate usage is not a
dierent reader macro ; it merely exploits the fact that the additional vertical-bars occur within the
comment in a way that tricks certain text editor into better supporting nested comments. As such,
one might sometimes see code like:
#|| (+ #|| 3 ||# 4 5) ||#
Such code is equivalent to:
#| (+ #| 3 |# 4 5) |#
2.4.8.20 Sharpsign Less-Than-Sign
#<is not valid reader syntax. The Lisp reader will signal an error of typereader-error on
encountering #<. This syntax is typically used in the printed representation of objects that cannot
be read back in.
Syntax2–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
2.4.8.21 Sharpsign Whitespace
#followed immediately by whitespace 1is not valid reader syntax. The Lisp reader will signal an
error of typereader-error if it encounters the reader macro notation #hNewlineior#hSpacei.
2.4.8.22 Sharpsign Right-Parenthesis
This is not valid reader syntax.
The Lisp reader will signal an error of typereader-error upon encountering #).
2.4.9 Re-Reading Abbreviated Expressions
Note that the Lisp reader will generally signal an error of typereader-error when reading
anexpression 2that has been abbreviated because of length or level limits (see *print-level* ,
*print-length* , and*print-lines* ) due to restrictions on \ ..", \...", \#" followed by whitespace 1,
and \#)".
2–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
3. Evaluation and Compilation
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Evaluation and Compilation iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.1 Evaluation
Execution ofcode can be accomplished by a variety of means ranging from direct interpretation of
aform representing a program to invocation of compiled code produced by a compiler .
Evaluation is the process by which a program isexecuted in Common Lisp. The mechanism of
evaluation is manifested both implicitly through the eect of the Lisp read-eval-print loop , and
explicitly through the presence of the functions eval,compile ,compile-ﬁle , andload. Any of
these facilities might share the same execution strategy, or each might use a dierent one.
The behavior of a conforming program processed by eval and bycompile-ﬁle might dier; see
Section 3.2.2.3 (Semantic Constraints).
Evaluation can be understood in terms of a model in which an interpreter recursively traverses
aform performing each step of the computation as it goes. This model, which describes the
semantics of Common Lisp programs , is described in Section 3.1.2 (The Evaluation Model).
3.1.1 Introduction to Environments
Abinding is an association between a name and that which the name denotes. Bindings are
established in a lexical environment or a dynamic environment by particular special operators .
Anenvironment is a set of bindings and other information used during evaluation ( e.g., to
associate meanings with names).
Bindings in an environment are partitioned into namespaces . A single name can simultaneously
have more than one associated binding perenvironment , but can have only one associated binding
pernamespace .
3.1.1.1 The Global Environment
Theglobal environment is that part of an environment that contains bindings with both
indenite scope and indenite extent . The global environment contains, among other things, the
following:
bindings ofdynamic variables and constant variables .
bindings offunctions ,macros , and special operators .
bindings ofcompiler macros .
bindings oftype and class names
information about proclamations .
Evaluation and Compilation 3–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.1.1.2 Dynamic Environments
Adynamic environment forevaluation is that part of an environment that contains bindings
whose duration is bounded by points of establishment and disestablishment within the execution of
theform that established the binding . Adynamic environment contains, among other things, the
following:
bindings fordynamic variables .
information about active catch tags .
information about exit points established by unwind-protect .
information about active handlers and restarts .
The dynamic environment that is active at any given point in the execution of aprogram is referred
to by denite reference as \the current dynamic environment ," or sometimes as just \the dynamic
environment ."
Within a given namespace , aname is said to be bound in a dynamic environment if there is
abinding associated with its name in the dynamic environment or, if not, there is a binding
associated with its name in the global environment .
3.1.1.3 Lexical Environments
Alexical environment forevaluation at some position in a program is that part of the
environment that contains information having lexical scope within the forms containing that
position. A lexical environment contains, among other things, the following:
bindings oflexical variables and symbol macros .
bindings offunctions and macros . (Implicit in this is information about those compiler macros
that are locally disabled.)
bindings ofblock tags .
bindings ofgo tags .
information about declarations .
The lexical environment that is active at any given position in a program being semantically
processed is referred to by denite reference as \the current lexical environment ," or sometimes as
just \the lexical environment ."
Within a given namespace , aname is said to be bound in a lexical environment if there is a binding
associated with its name in the lexical environment or, if not, there is a binding associated with its
name in the global environment .
3–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.1.1.3.1 The Null Lexical Environment
Thenull lexical environment is equivalent to the global environment .
Although in general the representation of an environment object isimplementation-dependent ,nil
can be used in any situation where an environment object is called for in order to denote the null
lexical environment .
3.1.1.4 Environment Objects
Some operators make use of an object , called an environment object , that represents the set of
lexical bindings needed to perform semantic analysis on a form in a given lexical environment . The
set of bindings in an environment object may be a subset of the bindings that would be needed to
actually perform an evaluation ; for example, values associated with variable names and function
names in the corresponding lexical environment might not be available in an environment object .
The type and nature of an environment object isimplementation-dependent . The values of
environment parameters tomacro functions are examples of environment objects .
The objectnilwhen used as an environment object denotes the null lexical environment ; see
Section 3.1.1.3.1 (The Null Lexical Environment).
3.1.2 The Evaluation Model
A Common Lisp system evaluates forms with respect to lexical, dynamic, and global environments .
The following sections describe the components of the Common Lisp evaluation model.
3.1.2.1 Form Evaluation
Forms fall into three categories: symbols ,conses , and self-evaluating objects . The following sections
explain these categories.
3.1.2.1.1 Symbols as Forms
If aform is asymbol , then it is either a symbol macro or a variable .
The symbol names a symbol macro if there is a binding of the symbol as a symbol macro in the
current lexical environment (seedeﬁne-symbol-macro andsymbol-macrolet ). If the symbol is
asymbol macro , its expansion function is obtained. The expansion function is a function of two
arguments, and is invoked by calling the macroexpand hook with the expansion function as its
rst argument, the symbol as its second argument, and an environment object (corresponding to
the current lexical environment ) as its third argument. The macroexpand hook , in turn, calls the
expansion function with the form as its rst argument and the environment as its second argument.
The value of the expansion function, which is passed through by the macroexpand hook , is a form .
This resulting form is processed in place of the original symbol .
If aform is asymbol that is not a symbol macro , then it is the name of a variable , and the value of
that variable is returned. There are three kinds of variables: lexical variables ,dynamic variables ,
Evaluation and Compilation 3–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
and constant variables . Avariable can store one object . The main operations on a variable are to
read 1and to write 1itsvalue .
An error of typeunbound-variable should be signaled if an unbound variable is referenced.
Non-constant variables can be assigned by usingsetq orbound 3by usinglet. Figure 3{1 lists some
dened names that are applicable to assigning, binding, and dening variables .
boundp let progv
defconstant let* psetq
defparameter makunbound set
defvar multiple-value-bind setq
lambda multiple-value-setq symbol-value
Figure 3–1. Some Deﬁned Names Applicable to Variables
The following is a description of each kind of variable.
3.1.2.1.1.1 Lexical Variables
Alexical variable is avariable that can be referenced only within the lexical scope of the form that
establishes that variable ;lexical variables have lexical scope . Each time a form creates a lexical
binding of a variable , afresh binding isestablished .
Within the scope of a binding for a lexical variable name , uses of that name as a variable are
considered to be references to that binding except where the variable isshadowed 2by a form that
establishes afresh binding for that variable name , or by a form that locally declares thename
special .
Alexical variable always has a value . There is no operator that introduces a binding for a lexical
variable without giving it an initial value , nor is there any operator that can make a lexical variable
beunbound .
Bindings oflexical variables are found in the lexical environment .
3.1.2.1.1.2 Dynamic Variables
Avariable is adynamic variable if one of the following conditions hold:
It is locally declared or globally proclaimed special .
It occurs textually within a form that creates a dynamic binding for a variable of the same
name , and the binding is not shadowed 2by a form that creates a lexical binding of the same
variable name .
Adynamic variable can be referenced at any time in any program ; there is no textual limitation on
references to dynamic variables . At any given time, all dynamic variables with a given name refer
to exactly one binding , either in the dynamic environment or in the global environment .
3–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The value part of the binding for a dynamic variable might be empty; in this case, the dynamic
variable is said to have no value , or to be unbound . Adynamic variable can be made unbound by
usingmakunbound .
The eect of binding adynamic variable is to create a new binding to which all references to that
dynamic variable in any program refer for the duration of the evaluation of the form that creates
thedynamic binding .
Adynamic variable can be referenced outside the dynamic extent of a form that binds it. Such
avariable is sometimes called a \global variable" but is still in all respects just a dynamic
variable whose binding happens to exist in the global environment rather than in some dynamic
environment .
Adynamic variable isunbound unless and until explicitly assigned a value, except for those
variables whose initial value is dened in this specication or by an implementation .
3.1.2.1.1.3 Constant Variables
Certain variables, called constant variables , are reserved as \named constants." The consequences
are undened if an attempt is made to assign a value to, or create a binding for a constant variable ,
except that a `compatible' redenition of a constant variable usingdefconstant is permitted; see
themacrodefconstant .
Keywords ,symbols dened by Common Lisp or the implementation as constant (such as nil,t, and
pi), and symbols declared as constant using defconstant areconstant variables .
3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables
The same symbol can name both a lexical variable and a dynamic variable , but never in the same
lexical environment .
In the following example, the symbolxis used, at dierent times, as the name of a lexical variable
and as the name of a dynamic variable .
(let ((x 1)) ;Binds a special variable X
(declare (special x))
(let ((x 2)) ;Binds a lexical variable X
(+ x ;Reads a lexical variable X
(locally (declare (special x))
x)))) ;Reads a special variable X
!3
3.1.2.1.2 Conses as Forms
Acons that is used as a form is called a compound form .
If the carof that compound form is a symbol , that symbol is the name of an operator , and the
form is either a special form , amacro form , or a function form , depending on the function binding
of the operator in the current lexical environment . If the operator is neither a special operator
Evaluation and Compilation 3–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
nor a macro name , it is assumed to be a function name (even if there is no denition for such a
function ).
If the carof the compound form is not a symbol , then that carmust be a lambda expression , in
which case the compound form is alambda form .
How a compound form is processed depends on whether it is classied as a special form , amacro
form , afunction form , or a lambda form .
3.1.2.1.2.1 Special Forms
Aspecial form is aform with special syntax, special evaluation rules, or both, possibly manipulating
the evaluation environment, control ow, or both. A special operator has access to the current
lexical environment and the current dynamic environment . Each special operator denes the
manner in which its subexpressions are treated|which are forms , which are special syntax, etc.
Some special operators create new lexical or dynamic environments for use during the evaluation
ofsubforms of the special form . For example, block creates a new lexical environment that is the
same as the one in force at the point of evaluation of the block form with the addition of a binding
of theblock name to an exit point from the block .
The set of special operator names is xed in Common Lisp; no way is provided for the user to
dene a special operator . Figure 3{2 lists all of the Common Lisp symbols that have denitions as
special operators .
block let* return-from
catch load-time-value setq
eval-when locally symbol-macrolet
ﬂet macrolet tagbody
function multiple-value-call the
go multiple-value-prog1 throw
if progn unwind-protect
labels progv
let quote
Figure 3–2. Common Lisp Special Operators
3.1.2.1.2.2 Macro Forms
If the operator names a macro , its associated macro function is applied to the entire form and the
result of that application is used in place of the original form .
Specically, a symbol names a macro in a given lexical environment ifmacro-function istrue
of the symbol and that environment . The function returned by macro-function is afunction of
two arguments, called the expansion function. The expansion function is invoked by calling the
macroexpand hook with the expansion function as its rst argument, the entire macro form as its
3–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
second argument, and an environment object (corresponding to the current lexical environment ) as
its third argument. The macroexpand hook , in turn, calls the expansion function with the form
as its rst argument and the environment as its second argument. The value of the expansion
function, which is passed through by the macroexpand hook , is a form . The returned form is
evaluated in place of the original form .
The consequences are undened if a macro function destructively modies any part of its form
argument.
Amacro name is not a function designator , and cannot be used as the function argument to
functions such asapply ,funcall , ormap.
Animplementation is free to implement a Common Lisp special operator as a macro . An
implementation is free to implement any macro operator as a special operator , but only if an
equivalent denition of the macro is also provided.
Figure 3{3 lists some dened names that are applicable to macros .
*macroexpand-hook* macro-function macroexpand-1
defmacro macroexpand macrolet
Figure 3–3. Deﬁned names applicable to macros
3.1.2.1.2.3 Function Forms
If the operator is asymbol naming a function , the form represents a function form , and the cdrof
the list contains the forms which when evaluated will supply the arguments passed to the function .
When a function name is not dened, an error of typeundeﬁned-function should be signaled at
run time; see Section 3.2.2.3 (Semantic Constraints).
Afunction form is evaluated as follows:
The subforms in the cdrof the original form are evaluated in left-to-right order in the current
lexical and dynamic environments . The primary value of each such evaluation becomes an
argument to the named function ; any additional values returned by the subforms are discarded.
The functional value of the operator is retrieved from the lexical environment , and that function is
invoked with the indicated arguments.
Although the order of evaluation of the argument subforms themselves is strictly left-to-right, it
is not specied whether the denition of the operator in a function form is looked up before the
evaluation of the argument subforms , after the evaluation of the argument subforms , or between
theevaluation of any two argument subforms if there is more than one such argument subform .
For example, the following might return 23 or 24.
(defun foo (x) (+ x 3))
Evaluation and Compilation 3–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defun bar () (setf (symbol-function ’foo) #’(lambda (x) (+ x 4))))
(foo (progn (bar) 20))
Abinding for a function name can be established in one of several ways. A bind-
ingfor a function name in the global environment can be established bydefun ,setf of
fdeﬁnition ,setf ofsymbol-function ,ensure-generic-function ,defmethod (implicitly, due to
ensure-generic-function ), ordefgeneric . Abinding for a function name in the lexical environment
can be established byﬂetorlabels .
Figure 3{4 lists some dened names that are applicable to functions .
apply fdeﬁnition mapcan
call-arguments-limit ﬂet mapcar
complement fmakunbound mapcon
constantly funcall mapl
defgeneric function maplist
defmethod functionp multiple-value-call
defun labels reduce
fboundp map symbol-function
Figure 3–4. Some function-related deﬁned names
3.1.2.1.2.4 Lambda Forms
Alambda form is similar to a function form , except that the function name is replaced by a lambda
expression .
Alambda form is equivalent to using funcall of a lexical closure of the lambda expression on the
given arguments . (In practice, some compilers are more likely to produce inline code for a lambda
form than for an arbitrary named function that has been declared inline ; however, such a dierence
is not semantic.)
For further information, see Section 3.1.3 (Lambda Expressions).
3.1.2.1.3 Self-Evaluating Objects
Aform that is neither a symbol nor a cons is dened to be a self-evaluating object .Evaluating
such an object yields thesame object as a result.
Certain specic symbols and conses might also happen to be \self-evaluating" but only as a special
case of a more general set of rules for the evaluation ofsymbols and conses ; such objects are not
considered to be self-evaluating objects .
The consequences are undened if literal objects (including self-evaluating objects ) are destructively
modied.
3–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.1.2.1.3.1 Examples of Self-Evaluating Objects
Numbers ,pathnames , and arrays are examples of self-evaluating objects .
3!3
#c(2/3 5/8)!#C(2/3 5/8)
#p"S:[BILL]OTHELLO.TXT" !#P"S:[BILL]OTHELLO.TXT"
#(a b c)!#(A B C)
"fred smith"!"fred smith"
3.1.3 Lambda Expressions
In a lambda expression , the body is evaluated in a lexical environment that is formed by adding
thebinding of each parameter in the lambda list with the corresponding value from the arguments
to the current lexical environment .
For further discussion of how bindings areestablished based on the lambda list , see Section 3.4
(Lambda Lists).
The body of a lambda expression is an implicit progn ; the values it returns are returned by the
lambda expression .
3.1.4 Closures and Lexical Binding
Alexical closure is afunction that can refer to and alter the values of lexical bindings established
bybinding forms that textually include the function denition.
Consider this code, where xis not declared special :
(defun two-funs (x)
(list (function (lambda () x))
(function (lambda (y) (setq x y)))))
(setq funs (two-funs 6))
(funcall (car funs)) !6
(funcall (cadr funs) 43) !43
(funcall (car funs)) !43
Thefunction special form coerces a lambda expression into a closure in which the lexical
environment in eect when the special form is evaluated is captured along with the lambda
expression .
The function two-funs returns a listof two functions , each of which refers to the binding of the
variable xcreated on entry to the function two-funs when it was called. This variable has the
value6initially, but setq can alter this binding . The lexical closure created for the rst lambda
expression does not \snapshot" the value6forxwhen the closure is created; rather it captures the
binding ofx. The second function can be used to alter the value in the same (captured) binding
Evaluation and Compilation 3–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(to43, in the example), and this altered variable binding then aects the value returned by the
rst function .
In situations where a closure of alambda expression over the same set of bindings may be produced
more than once, the various resulting closures may or may not be identical , at the discretion of the
implementation . That is, two functions that are behaviorally indistinguishable might or might not
beidentical . Two functions that are behaviorally distinguishable are distinct . For example:
(let ((x 5) (funs ’()))
(dotimes (j 10)
(push #’(lambda (z)
(if (null z) (setq x 0) (+ x z)))
funs))
funs)
The result of the above form is alistof ten closures . Each requires only the binding ofx. It is the
same binding in each case, but the ten closure objects might or might not be identical . On the
other hand, the result of the form
(let ((funs ’()))
(dotimes (j 10)
(let ((x 5))
(push (function (lambda (z)
(if (null z) (setq x 0) (+ x z))))
funs)))
funs)
is also a listof ten closures . However, in this case no two of the closure objects can be identical
because each closure is closed over a distinct binding ofx, and these bindings can be behaviorally
distinguished because of the use of setq.
The result of the form
(let ((funs ’()))
(dotimes (j 10)
(let ((x 5))
(push (function (lambda (z) (+ x z)))
funs)))
funs)
is a listof ten closure objects that might or might not be identical . A dierent binding ofx
is involved for each closure , but the bindings cannot be distinguished because their values are
thesame and immutable (there being no occurrence of setq onx). A compiler could internally
transform the form to
(let ((funs ’()))
(dotimes (j 10)
(push (function (lambda (z) (+ 5 z)))
3–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
funs))
funs)
where the closures may be identical .
It is possible that a closure does not close over any variable bindings. In the code fragment
(mapcar (function (lambda (x) (+ x 2))) y)
the function (lambda (x) (+ x 2)) contains no references to any outside object. In this case, the
same closure might be returned for all evaluations of the function form .
3.1.5 Shadowing
If two forms that establish lexical bindings with the same nameNare textually nested, then
references to Nwithin the inner form refer to the binding established by the inner form ; the inner
binding forNshadows the outer binding forN. Outside the inner form but inside the outer one,
references to Nrefer to the binding established by the outer form . For example:
(defun test (x z)
(let ((z (* x 2)))
(print z))
z)
The binding of the variable zbyletshadows the parameter binding for the function test. The
reference to the variable zin theprint form refers to the letbinding. The reference to zat the end
of the function test refers to the parameter namedz.
Constructs that are lexically scoped act as if new names were generated for each object on each
execution. Therefore, dynamic shadowing cannot occur. For example:
(defun contorted-example (f g x)
(if (= x 0)
(funcall f)
(block here
(+ 5 (contorted-example g
#’(lambda () (return-from here 4))
(- x 1))))))
Consider the call (contorted-example nil nil 2) . This produces 4. During the course of execution,
there are three calls to contorted-example , interleaved with two blocks:
(contorted-example nil nil 2)
(block here 1...)
(contorted-example nil #’(lambda () (return-from here 14)) 1)
(block here 2...)
(contorted-example #’(lambda () (return-from here 14))
#’(lambda () (return-from here 24))
Evaluation and Compilation 3–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
0)
(funcall f)
where f!#’(lambda () (return-from here 14))
(return-from here 14)
At the time the funcall is executed there are two block exit points outstanding, each apparently
namedhere. Thereturn-from form executed as a result of the funcall operation refers to the
outer outstanding exit point (here 1), not the inner one (here 2). It refers to that exit point textually
visible at the point of execution of function (here abbreviated by the #’syntax) that resulted in
creation of the function object actually invoked by funcall .
If, in this example, one were to change the (funcall f) to(funcall g) , then the value of the call
(contorted-example nil nil 2) would be 9. The value would change because funcall would cause
the execution of (return-from here 24), thereby causing a return from the inner exit point (here 2).
When that occurs, the value 4is returned from the middle invocation of contorted-example ,5is
added to that to get 9, and that value is returned from the outer block and the outermost call to
contorted-example . The point is that the choice of exit point returned from has nothing to do with
its being innermost or outermost; rather, it depends on the lexical environment that is packaged
up with a lambda expression whenfunction is executed.
3.1.6 Extent
Contorted-example works only because the function named by fis invoked during the extent of
theexit point . Once the ow of execution has left the block, the exit point isdisestablished . For
example:
(defun invalid-example ()
(let ((y (block here #’(lambda (z) (return-from here z)))))
(if (numberp y) y (funcall y 5))))
One might expect the call (invalid-example) to produce 5by the following incorrect reasoning:
letbindsyto the value of block ; this value is a function resulting from the lambda expression .
Because yis not a number, it is invoked on the value 5. Thereturn-from should then return this
value from the exit point namedhere, thereby exiting from the block again and giving ythe value
5which, being a number, is then returned as the value of the call to invalid-example .
The argument fails only because exit points have dynamic extent . The argument is correct up
to the execution of return-from . The execution of return-from should signal an error of type
control-error , however, not because it cannot refer to the exit point , but because it does correctly
refer to an exit point and that exit point has been disestablished .
A reference by name to a dynamic exit point binding such as a catch tag refers to the most recently
established binding of that name that has not been disestablished . For example:
(defun fun1 (x)
(catch ’trap (+ 3 (fun2 x))))
(defun fun2 (y)
3–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(catch ’trap (* 5 (fun3 y))))
(defun fun3 (z)
(throw ’trap z))
Consider the call (fun1 7) . The result is 10. At the time the throw is executed, there are two
outstanding catchers with the name trap: one established within procedure fun1, and the other
within procedure fun2. The latter is the more recent, and so the value 7is returned from catch in
fun2. Viewed from within fun3, thecatch infun2 shadows the one in fun1. Hadfun2 been dened
as
(defun fun2 (y)
(catch ’snare (* 5 (fun3 y))))
then the two exit points would have dierent names , and therefore the one in fun1 would not be
shadowed. The result would then have been 7.
3.1.7 Return Values
Ordinarily the result of calling a function is a single object . Sometimes, however, it is convenient
for a function to compute several objects and return them.
In order to receive other than exactly one value from a form , one of several special forms ormacros
must be used to request those values. If a form produces multiple values which were not requested
in this way, then the rst value is given to the caller and all others are discarded; if the form
produces zero values, then the caller receives nilas a value.
Figure 3{5 lists some operators for receiving multiple values 2. These operators can be used to
specify one or more forms toevaluate and where to put the values returned by those forms .
multiple-value-bind multiple-value-prog1 return-from
multiple-value-call multiple-value-setq throw
multiple-value-list return
Figure 3–5. Some operators applicable to receiving multiple values
The function values can produce multiple values 2.(values) returns zero values; (values form)
returns the primary value returned by form;(values form1 form2 )returns two values, the primary
value ofform1 and the primary value ofform2 ; and so on.
Seemultiple-values-limit andvalues-list .
Evaluation and Compilation 3–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.2 Compilation
3.2.1 Compiler Terminology
The following terminology is used in this section.
Thecompiler is a utility that translates code into an implementation-dependent form that might
be represented or executed eciently. The term compiler refers to both of the functions compile
andcompile-ﬁle .
The term compiled code refers to objects representing compiled programs, such as objects
constructed by compile or byload when loading acompiled le .
The term implicit compilation refers to compilation performed during evaluation .
The term literal object refers to a quoted object or a self-evaluating object or an object that is a
substructure of such an object . Aconstant variable is not itself a literal object .
The term coalesce is dened as follows. Suppose AandBare two literal constants in the source
code, and that A’andB’are the corresponding objects in the compiled code . IfA’andB’areeql
butAandBare noteql, then it is said that AandBhave been coalesced by the compiler.
The term minimal compilation refers to actions the compiler must take at compile time . These
actions are specied in Section 3.2.2 (Compilation Semantics).
The verb process refers to performing minimal compilation , determining the time of evaluation
for a form , and possibly evaluating that form (if required).
The term further compilation refers to implementation-dependent compilation beyond minimal
compilation . That is, processing does not imply complete compilation. Block compilation
and generation of machine-specic instructions are examples of further compilation. Further
compilation is permitted to take place at run time .
Four dierent environments relevant to compilation are distinguished: the startup environment ,
thecompilation environment , the evaluation environment , and the run-time environment .
Thestartup environment is the environment of the Lisp image from which the compiler was
invoked.
Thecompilation environment is maintained by the compiler and is used to hold denitions and
declarations to be used internally by the compiler. Only those parts of a denition needed for
correct compilation are saved. The compilation environment is used as the environment argument
to macro expanders called by the compiler. It is unspecied whether a denition available in the
compilation environment can be used in an evaluation initiated in the startup environment or
evaluation environment .
Theevaluation environment is a run-time environment in which macro expanders and code
specied by eval-when to be evaluated are evaluated. All evaluations initiated by the compiler
3–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
take place in the evaluation environment .
Therun-time environment is the environment in which the program being compiled will be
executed.
The compilation environment inherits from the evaluation environment , and the compilation
environment and evaluation environment might be identical . The evaluation environment inherits
from the startup environment , and the startup environment and evaluation environment might be
identical .
The term compile time refers to the duration of time that the compiler is processing source code .
Atcompile time , only the compilation environment and the evaluation environment are available.
The term compile-time denition refers to a denition in the compilation environment . For
example, when compiling a le, the denition of a function might be retained in the compilation
environment if it is declared inline . This denition might not be available in the evaluation
environment .
The term run time refers to the duration of time that the loader is loading compiled code or
compiled code is being executed. At run time, only the run-time environment is available.
The term run-time denition refers to a denition in the run-time environment .
The term run-time compiler refers to the function compile orimplicit compilation , for which
the compilation and run-time environments are maintained in the same Lisp image . Note that
when the run-time compiler is used, the run-time environment and startup environment are the
same.
3.2.2 Compilation Semantics
Conceptually, compilation is a process that traverses code, performs certain kinds of syntactic and
semantic analyses using information (such as proclamations and macro denitions) present in the
compilation environment , and produces equivalent, possibly more ecient code.
3.2.2.1 Compiler Macros
Acompiler macro can be dened for a name that also names a function ormacro . That is, it is
possible for a function name to name both a function and a compiler macro .
Afunction name names a compiler macro ifcompiler-macro-function istrue of the function name
in the lexical environment in which it appears. Creating a lexical binding for the function name
not only creates a new local function ormacro denition, but also shadows 2thecompiler macro .
The function returned by compiler-macro-function is a function of two arguments, called the
expansion function. To expand a compiler macro , the expansion function is invoked by calling the
macroexpand hook with the expansion function as its rst argument, the entire compiler macro
form as its second argument, and the current compilation environment (or with the current lexical
environment , if the form is being processed by something other than compile-ﬁle ) as its third
Evaluation and Compilation 3–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
argument. The macroexpand hook , in turn, calls the expansion function with the form as its rst
argument and the environment as its second argument. The return value from the expansion
function, which is passed through by the macroexpand hook , might either be the same form , or else
a form that can, at the discretion of the code doing the expansion, be used in place of the original
form .
*macroexpand-hook* compiler-macro-function deﬁne-compiler-macro
Figure 3–6. Deﬁned names applicable to compiler macros
3.2.2.1.1 Purpose of Compiler Macros
The purpose of the compiler macro facility is to permit selective source code transformations
as optimization advice to the compiler . When a compound form is being processed (as by the
compiler), if the operator names a compiler macro then the compiler macro function may be
invoked on the form, and the resulting expansion recursively processed in preference to performing
the usual processing on the original form according to its normal interpretation as a function form
ormacro form .
Acompiler macro function , like a macro function , is a function of two arguments : the entire call
form and the environment . Unlike an ordinary macro function , acompiler macro function can
decline to provide an expansion merely by returning a value that is the same as the original form .
The consequences are undened if a compiler macro function destructively modies any part of its
form argument.
The form passed to the compiler macro function can either be a listwhose caris the function
name, or a listwhose carisfuncall and whose cadr is a list(function name); note that this aects
destructuring of the form argument by the compiler macro function .deﬁne-compiler-macro
arranges for destructuring of arguments to be performed correctly for both possible formats.
Whencompile-ﬁle chooses to expand a top level form that is a compiler macro form , the expansion
is also treated as a top level form for the purposes of eval-when processing; see Section 3.2.3.1
(Processing of Top Level Forms).
3.2.2.1.2 Naming of Compiler Macros
Compiler macros may be dened for function names that name macros as well as functions .
Compiler macro denitions are strictly global. There is no provision for dening local compiler
macros in the way that macrolet denes local macros . Lexical bindings of a function name shadow
any compiler macro denition associated with the name as well as its global function ormacro
denition.
Note that the presence of a compiler macro denition does not aect the values returned by
functions that access function denitions ( e.g.,fboundp ) ormacro denitions ( e.g.,macroexpand ).
3–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compiler macros are global, and the function compiler-macro-function is sucient to resolve
their interaction with other lexical and global denitions.
3.2.2.1.3 When Compiler Macros Are Used
The presence of a compiler macro denition for a function ormacro indicates that it is desirable
for the compiler to use the expansion of the compiler macro instead of the original function form
ormacro form . However, no language processor (compiler, evaluator, or other code walker) is ever
required to actually invoke compiler macro functions , or to make use of the resulting expansion if
it does invoke a compiler macro function .
When the compiler encounters a form during processing that represents a call to a compiler macro
name (that is not declared notinline ), the compiler might expand the compiler macro , and might
use the expansion in place of the original form .
Wheneval encounters a form during processing that represents a call to a compiler macro name
(that is not declared notinline ),eval might expand the compiler macro , and might use the
expansion in place of the original form .
There are two situations in which a compiler macro denition must not be applied by any language
processor:
The global function name binding associated with the compiler macro is shadowed by a
lexical binding of the function name.
The function name has been declared or proclaimed notinline and the call form appears
within the scope of the declaration.
It is unspecied whether compiler macros are expanded or used in any other situations.
3.2.2.1.3.1 Notes about the Implementation of Compiler Macros
Although it is technically permissible, as described above, for eval to treat compiler macros
in the same situations as compiler might, this is not necessarily a good idea in interpreted
implementations .
Compiler macros exist for the purpose of trading compile-time speed for run-time speed.
Programmers who write compiler macros tend to assume that the compiler macros can take more
time than normal functions and macros in order to produce code which is especially optimal for
use at run time. Since eval in an interpreted implementation might perform semantic analysis of
the same form multiple times, it might be inecient in general for the implementation to choose
to call compiler macros on every such evaluation .
Nevertheless, the decision about what to do in these situations is left to each implementation .
Evaluation and Compilation 3–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.2.2.2 Minimal Compilation
Minimal compilation is dened as follows:
Allcompiler macro calls appearing in the source code being compiled are expanded, if at
all, at compile time; they will not be expanded at run time.
Allmacro and symbol macro calls appearing in the source code being compiled are
expanded at compile time in such a way that they will not be expanded again at run time.
macrolet andsymbol-macrolet are eectively replaced by forms corresponding to their
bodies in which calls to macros are replaced by their expansions.
The rst argument in aload-time-value form insource code processed by compile is
evaluated atcompile time ; insource code processed by compile-ﬁle , the compiler arranges
for it to be evaluated atload time . In either case, the result of the evaluation is remembered
and used later as the value of the load-time-value form atexecution time .
3.2.2.3 Semantic Constraints
Allconforming programs must obey the following constraints, which are designed to minimize the
observable dierences between compiled and interpreted programs:
Denitions of any referenced macros must be present in the compilation environment . Any
form that is a listbeginning with a symbol that does not name a special operator or a
macro dened in the compilation environment is treated by the compiler as a function call.
Special proclamations for dynamic variables must be made in the compilation environment .
Any binding for which there is no special declaration or proclamation in the compilation
environment is treated by the compiler as a lexical binding .
The denition of a function that is dened and declared inline in the compilation
environment must be the same at run time.
Within a function namedF, the compiler may (but is not required to) assume that an
apparent recursive call to a function namedFrefers to the same denition of F, unless that
function has been declared notinline . The consequences of redening such a recursively
dened functionFwhile it is executing are undened.
A call within a le to a named function that is dened in the same le refers to that
function, unless that function has been declared notinline . The consequences are
unspecied if functions are redened individually at run time or multiply dened in the
same le.
The argument syntax and number of return values for all functions whose ftype is declared
at compile time must remain the same at run time.
3–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Constant variables dened in the compilation environment must have a similar value at
run time. A reference to a constant variable insource code is equivalent to a reference to a
literal object that is the value of the constant variable .
Type denitions made with deftype ordefstruct in the compilation environment must
retain the same denition at run time. Classes dened by defclass in the compilation
environment must be dened at run time to have the same superclasses and same
metaclass .
This implies that subtype /supertype relationships of type speciers must not change
between compile time and run time .
Type declarations present in the compilation environment must accurately describe
the corresponding values at run time; otherwise, the consequences are undened. It is
permissible for an unknown type to appear in a declaration at compile time, though a
warning might be signaled in such a case.
Except in the situations explicitly listed above, a function dened in the evaluation
environment is permitted to have a dierent denition or a dierent signature at run time,
and the run-time denition prevails.
Conforming programs should not be written using any additional assumptions about consistency
between the run-time environment and the startup, evaluation, and compilation environments .
Except where noted, when a compile-time and a run-time denition are dierent, one of the
following occurs at run time:
an error of typeerror is signaled
the compile-time denition prevails
the run-time denition prevails
If the compiler processes a function form whose operator is not dened at compile time, no error
is signaled at compile time.
3.2.3 File Compilation
The function compile-ﬁle performs compilation of forms in a le following the rules specied in
Section 3.2.2 (Compilation Semantics), and produces an output le that can be loaded by using
load.
Normally, the top level forms appearing in a le compiled with compile-ﬁle are evaluated only
when the resulting compiled le is loaded, and not when the le is compiled. However, it is typically
the case that some forms in the le need to be evaluated at compile time so the remainder of the
le can be read and compiled correctly.
Evaluation and Compilation 3–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Theeval-when special form can be used to control whether a top level form is evaluated at
compile time, load time, or both. It is possible to specify any of three situations with eval-when ,
denoted by the symbols :compile-toplevel ,:load-toplevel , and:execute . For top level eval-when
forms,:compile-toplevel species that the compiler must evaluate the body at compile time, and
:load-toplevel species that the compiler must arrange to evaluate the body at load time. For
non-top level eval-when forms,:execute species that the body must be executed in the run-time
environment .
The behavior of this form can be more precisely understood in terms of a model of how compile-ﬁle
processes forms in a le to be compiled. There are two processing modes, called \not-compile-time"
and \compile-time-too".
Successive forms are read from the le by compile-ﬁle and processed in not-compile-time mode; in
this mode, compile-ﬁle arranges for forms to be evaluated only at load time and not at compile
time. When compile-ﬁle is in compile-time-too mode, forms are evaluated both at compile time
and load time.
3.2.3.1 Processing of Top Level Forms
Processing of top level forms in the le compiler is dened as follows:
1. If the form is a compiler macro form (not disabled by a notinline declaration ), the
implementation might or might not choose to compute the compiler macro expansion of
theform and, having performed the expansion, might or might not choose to process the
result as a top level form in the same processing mode (compile-time-too or not-compile-
time). If it declines to obtain or use the expansion, it must process the original form .
2. If the form is a macro form , its macro expansion is computed and processed as a top level
form in the same processing mode (compile-time-too or not-compile-time).
3. If the form is a progn form, each of its body forms is sequentially processed as a top level
form in the same processing mode.
4. If the form is a locally ,macrolet , orsymbol-macrolet ,compile-ﬁle establishes the
appropriate bindings and processes the body forms as top level forms with those bindings
in eect in the same processing mode. (Note that this implies that the lexical environment
in which top level forms are processed is not necessarily the null lexical environment .)
5. If the form is an eval-when form, it is handled according to Figure 3{7.
3–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
CT LT E Mode Action New Mode
Yes Yes | | Process compile-time-too
No Yes Yes CTT Process compile-time-too
No Yes Yes NCT Process not-compile-time
No Yes No | Process not-compile-time
Yes No | | Evaluate |
No No Yes CTT Evaluate |
No No Yes NCT Discard |
No No No | Discard |
Figure 3–7. EVAL-WHEN processing
ColumnCTindicates whether :compile-toplevel is specied. Column LTindicates
whether :load-toplevel is specied. Column Eindicates whether :execute is specied.
ColumnMode indicates the processing mode; a dash (|) indicates that the processing
mode is not relevant.
TheAction column species one of three actions:
Process: process the body as top level forms in the specied mode.
Evaluate: evaluate the body in the dynamic execution context of the compiler, using
theevaluation environment as the global environment and the lexical environment in
which the eval-when appears.
Discard: ignore the form .
TheNew Mode column indicates the new processing mode. A dash (|) indicates the
compiler remains in its current mode.
6. Otherwise, the form is a top level form that is not one of the special cases. In compile-
time-too mode, the compiler rst evaluates the form in the evaluation environment and
then minimally compiles it. In not-compile-time mode, the form is simply minimally
compiled. All subforms are treated as non-top-level forms .
Note that top level forms are processed in the order in which they textually appear in the
le and that each top level form read by the compiler is processed before the next is read.
However, the order of processing (including macro expansion) of subforms that are not top
level forms and the order of further compilation is unspecied as long as Common Lisp
semantics are preserved.
eval-when forms cause compile-time evaluation only at top level. Both :compile-toplevel and
:load-toplevel situation specications are ignored for non-top-level forms . For non-top-level
Evaluation and Compilation 3–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
forms , aneval-when specifying the :execute situation is treated as an implicit progn including the
forms in the body of the eval-when form ; otherwise, the forms in the body are ignored.
3.2.3.1.1 Processing of Deﬁning Macros
Dening macros (such as defmacro ordefvar ) appearing within a le being processed by
compile-ﬁle normally have compile-time side eects which aect how subsequent forms in the
same leare compiled. A convenient model for explaining how these side eects happen is that
the dening macro expands into one or more eval-when forms , and that the calls which cause the
compile-time side eects to happen appear in the body of an (eval-when (:compile-toplevel) ...)
form .
The compile-time side eects may cause information about the denition to be stored dierently
than if the dening macro had been processed in the `normal' way (either interpretively or by
loading the compiled le).
In particular, the information stored by the dening macros at compile time might or might not
be available to the interpreter (either during or after compilation), or during subsequent calls to
thecompiler . For example, the following code is nonportable because it assumes that the compiler
stores the macro denition of foowhere it is available to the interpreter:
(defmacro foo (x) ‘(car ,x))
(eval-when (:execute :compile-toplevel :load-toplevel)
(print (foo ’(a b c))))
A portable way to do the same thing would be to include the macro denition inside the eval-when
form , as in:
(eval-when (:execute :compile-toplevel :load-toplevel)
(defmacro foo (x) ‘(car ,x))
(print (foo ’(a b c))))
Figure 3{8 lists macros that make denitions available both in the compilation and run-time
environments . It is not specied whether denitions made available in the compilation environment
are available in the evaluation environment , nor is it specied whether they are available in
subsequent compilation units or subsequent invocations of the compiler. As with eval-when , these
compile-time side eects happen only when the dening macros appear at top level.
declaim deﬁne-modify-macro defsetf
defclass deﬁne-setf-expander defstruct
defconstant defmacro deftype
deﬁne-compiler-macro defpackage defvar
deﬁne-condition defparameter
Figure 3–8. Deﬁning Macros That Aﬀect the Compile-Time Environment
3–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.2.3.1.2 Constraints on Macros and Compiler Macros
Except where explicitly stated otherwise, no macro dened in the Common Lisp standard produces
an expansion that could cause any of the subforms of the macro form to be treated as top level
forms . If an implementation also provides a special operator denition of a Common Lisp macro ,
thespecial operator denition must be semantically equivalent in this respect.
Compiler macro expansions must also have the same top level evaluation semantics as the form
which they replace. This is of concern both to conforming implementations and to conforming
programs .
3.2.4 Literal Objects in Compiled Files
The functions eval andcompile are required to ensure that literal objects referenced within the
resulting interpreted or compiled code objects are the same as the corresponding objects in the
source code .compile-ﬁle , on the other hand, must produce a compiled le that, when loaded with
load, constructs the objects dened by the source code and produces references to them.
In the case of compile-ﬁle ,objects constructed by load of the compiled le cannot be spoken of as
being the same as the objects constructed at compile time, because the compiled le may be loaded
into a dierent Lisp image than the one in which it was compiled. This section denes the concept
ofsimilarity which relates objects in the evaluation environment to the corresponding objects in
therun-time environment .
The constraints on literal objects described in this section apply only to compile-ﬁle ;eval and
compile do not copy or coalesce constants.
3.2.4.1 Externalizable Objects
The fact that the le compiler represents literal objects externally in a compiled le and must
later reconstruct suitable equivalents of those objects when that leis loaded imposes a need for
constraints on the nature of the objects that can be used as literal objects incode to be processed
by the le compiler .
Anobject that can be used as a literal object incode to be processed by the le compiler is called
anexternalizable object .
We dene that two objects aresimilar if they satisfy a two-place conceptual equivalence predicate
(dened below), which is independent of the Lisp image so that the two objects in dierent Lisp
images can be understood to be equivalent under this predicate. Further, by inspecting the
denition of this conceptual predicate, the programmer can anticipate what aspects of an object
are reliably preserved by le compilation .
The le compiler must cooperate with the loader in order to assure that in each case where an
externalizable object is processed as a literal object , the loader will construct a similar object .
The set of objects that are externalizable objects are those for which the new conceptual term
\similar " is dened, such that when a compiled le isloaded , an object can be constructed which
Evaluation and Compilation 3–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
can be shown to be similar to the original object which existed at the time the le compiler was
operating.
3.2.4.2 Similarity of Literal Objects
3.2.4.2.1 Similarity of Aggregate Objects
Of the types over which similarity is dened, some are treated as aggregate objects. For these
types, similarity is dened recursively. We say that an object of these types has certain \basic
qualities" and to satisfy the similarity relationship, the values of the corresponding qualities of the
twoobjects must also be similar.
3.2.4.2.2 Deﬁnition of Similarity
Two objectsS(insource code ) andC(incompiled code ) are dened to be similar if and only if
they are both of one of the types listed here (or dened by the implementation ) and they both
satisfy all additional requirements of similarity indicated for that type.
number
Two numbersSandCaresimilar if they are of the same type and represent the same
mathematical value.
character
Two simple characters SandCaresimilar if they have similar code attributes .
Implementations providing additional, implementation-dened attributes must dene
whether and how non-simple characters can be regarded as similar .
symbol
Two apparently uninterned symbols SandCaresimilar if their names aresimilar .
Two interned symbolsSandCaresimilar if their names aresimilar , and if either Sis
accessible in the current package at compile time and Cis accessible in the current package
at load time, or Cis accessible in the package that is similar to the home package ofS.
(Note that similarity ofsymbols is dependent on neither the current readtable nor how the
functionread would parse the characters in the name of the symbol .)
package
Two packagesSandCaresimilar if their names aresimilar .
Note that although a package object is an externalizable object , the programmer is
responsible for ensuring that the corresponding package is already in existence when code
3–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
referencing it as a literal object isloaded . The loader nds the corresponding package
object as if by calling ﬁnd-package with that name as an argument . An error is signaled
by the loader if no package exists at load time.
random-state
Two random states SandCaresimilar ifSwould always produce the same sequence of
pseudo-random numbers as a copy 5ofCwhen given as the random-state argument to the
functionrandom , assuming equivalent limit arguments in each case.
(Note that since Chas been processed by the le compiler , it cannot be used directly as
anargument torandom becauserandom would perform a side eect.)
cons
Two conses ,SandC, are similar if the car2ofSissimilar to the car2ofC, and the cdr2
ofSissimilar to the cdr2ofC.
array
Two one-dimensional arrays ,SandC, are similar if the length ofSissimilar to the length
ofC, the actual array element type ofSissimilar to the actual array element type ofC,
and each active element ofSissimilar to the corresponding element ofC.
Two arrays ofrank other than one, SandC, are similar if the rank ofSissimilar to
therank ofC, each dimension 1ofSissimilar to the corresponding dimension 1ofC, the
actual array element type ofSissimilar to the actual array element type ofC, and each
element ofSissimilar to the corresponding element ofC.
In addition, if Sis asimple array , thenCmust also be a simple array . IfSis adisplaced
array , has a ll pointer , or is actually adjustable ,Cis permitted to lack any or all of these
qualities.
hash-table
Two hash tables SandCaresimilar if they meet the following three requirements:
1. They both have the same test ( e.g., they are both eqlhash tables ).
2. There is a unique one-to-one correspondence between the keys of the two hash tables ,
such that the corresponding keys are similar .
3. For all keys, the values associated with two corresponding keys are similar .
If there is more than one possible one-to-one correspondence between the keys of SandC,
the consequences are unspecied. A conforming program cannot use a table such as Sas
anexternalizable constant .
Evaluation and Compilation 3–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pathname
Two pathnames SandCaresimilar if all corresponding pathname components aresimilar .
function
Functions are not externalizable objects .
structure-object andstandard-object
A general-purpose concept of similarity does not exist for structures and standard objects .
However, a conforming program is permitted to dene a make-load-form method for
any classKdened by that program that is a subclass of either structure-object or
standard-object . The eect of such a method is to dene that an objectSoftypeKin
source code issimilar to an objectCoftypeKincompiled code ifCwas constructed from
code produced by calling make-load-form onS.
3.2.4.3 Extensions to Similarity Rules
Some objects , such as streams ,readtables , andmethods are not externalizable objects under the
denition of similarity given above. That is, such objects may not portably appear as literal objects
incode to be processed by the le compiler .
Animplementation is permitted to extend the rules of similarity, so that other kinds of objects are
externalizable objects for that implementation .
If for some kind of object ,similarity is neither dened by this specication nor by the
implementation , then the le compiler must signal an error upon encountering such an object as a
literal constant .
3.2.4.4 Additional Constraints on Externalizable Objects
If two literal objects appearing in the source code for a single le processed with the le compiler
are the identical , the corresponding objects in the compiled code must also be the identical . With
the exception of symbols and packages , any two literal objects incode being processed by the le
compiler may be coalesced if and only if they are similar ; if they are either both symbols or both
packages , they may only be coalesced if and only if they are identical .
Objects containing circular references can be externalizable objects . The le compiler is required to
preserveeqlness of substructures within a le. Preserving eqlness means that subobjects that are
thesame in the source code must be the same in the corresponding compiled code .
In addition, the following are constraints on the handling of literal objects by the le compiler :
3–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
array: If an array in the source code is a simple array , then the corresponding array in the
compiled code will also be a simple array . If an array in the source code is displaced, has a ll
pointer , or is actually adjustable , the corresponding array in the compiled code might lack any
or all of these qualities. If an array in the source code has a ll pointer, then the corresponding
array in the compiled code might be only the size implied by the ll pointer.
packages: The loader is required to nd the corresponding package object as if by calling
ﬁnd-package with the package name as an argument. An error of typepackage-error is
signaled if no package of that name exists at load time.
random-state: A constant random state object cannot be used as the state argument to the
functionrandom becauserandom modies this data structure.
structure, standard-object: Objects oftypestructure-object andstandard-object may
appear in compiled constants if there is an appropriate make-load-form method dened for
that type.
The le compiler callsmake-load-form on any object that is referenced as a literal object if
theobject is ageneralized instance ofstandard-object ,structure-object ,condition , or any of
a (possibly empty) implementation-dependent set of other classes . The le compiler only calls
make-load-form once for any given object within a single le.
symbol: In order to guarantee that compiled les can be loaded correctly, users must ensure
that the packages referenced in those les are dened consistently at compile time and load
time. Conforming programs must satisfy the following requirements:
1. The current package when a top level form in the leis processed by compile-ﬁle
must be the same as the current package when the code corresponding to that top level
form in the compiled le is executed by load. In particular:
a. Any top level form in a lethat alters the current package must change it to
apackage of the same name both at compile time and at load time.
b. If the rst non-atomic top level form in the leis not an in-package form ,
then the current package at the time load is called must be a package with
the same name as the package that was the current package at the time
compile-ﬁle was called.
2. For all symbols appearing lexically within a top level form that were accessible in
thepackage that was the current package during processing of that top level form at
compile time, but whose home package was another package , at load time there must
be a symbol with the same name that is accessible in both the load-time current
package and in the package with the same name as the compile-time home package .
Evaluation and Compilation 3–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3. For all symbols represented in the compiled le that were external symbols in their
home package at compile time, there must be a symbol with the same name that is an
external symbol in the package with the same name at load time.
If any of these conditions do not hold, the package in which the loader looks for the aected
symbols is unspecied. Implementations are permitted to signal an error or to dene this
behavior.
3.2.5 Exceptional Situations in the Compiler
compile andcompile-ﬁle are permitted to signal errors and warnings, including errors due to
compile-time processing of (eval-when (:compile-toplevel) ...) forms, macro expansion, and
conditions signaled by the compiler itself.
Conditions oftypeerror might be signaled by the compiler in situations where the compilation
cannot proceed without intervention.
In addition to situations for which the standard species that conditions oftypewarning must
or might be signaled, warnings might be signaled in situations where the compiler can determine
that the consequences are undened or that a run-time error will be signaled. Examples of this
situation are as follows: violating type declarations, altering or assigning the value of a constant
dened with defconstant , calling built-in Lisp functions with a wrong number of arguments or
malformed keyword argument lists, and using unrecognized declaration speciers.
The compiler is permitted to issue warnings about matters of programming style as conditions
oftypestyle-warning . Examples of this situation are as follows: redening a function using a
dierent argument list, calling a function with a wrong number of arguments, not declaring ignore
of a local variable that is not referenced, and referencing a variable declared ignore .
Bothcompile andcompile-ﬁle are permitted (but not required) to establish ahandler for
conditions oftypeerror . For example, they might signal a warning, and restart compilation from
some implementation-dependent point in order to let the compilation proceed without manual
intervention.
Bothcompile andcompile-ﬁle return three values, the second two indicating whether the source
code being compiled contained errors and whether style warnings were issued.
Some warnings might be deferred until the end of compilation. See with-compilation-unit .
3–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.3 Declarations
Declarations provide a way of specifying information for use by program processors, such as the
evaluator or the compiler.
Local declarations can be embedded in executable code using declare .Global declarations ,
orproclamations , are established by proclaim ordeclaim .
Thethespecial form provides a shorthand notation for making a local declaration about the type
of the value of a given form .
The consequences are undened if a program violates a declaration or a proclamation .
3.3.1 Minimal Declaration Processing Requirements
In general, an implementation is free to ignore declaration speciers except for the declaration ,
notinline ,safety , andspecial declaration speciers .
Adeclaration declaration must suppress warnings about unrecognized declarations of the kind
that it declares. If an implementation does not produce warnings about unrecognized declarations,
it may safely ignore this declaration .
Anotinline declaration must be recognized by any implementation that supports inline functions
orcompiler macros in order to disable those facilities. An implementation that does not use inline
functions or compiler macros may safely ignore this declaration .
Asafety declaration that increases the current safety level must always be recognized. An
implementation that always processes code as if safety were high may safely ignore this declaration .
Aspecial declaration must be processed by all implementations .
3.3.2 Declaration Speciﬁers
Adeclaration specier is an expression that can appear at top level of a declare expression or
adeclaim form, or as the argument to proclaim . It is a listwhose caris adeclaration identier ,
and whose cdris data interpreted according to rules specic to the declaration identier .
3.3.3 Declaration Identiﬁers
Figure 3{9 shows a list of all declaration identiers dened by this standard.
declaration ignore special
dynamic-extent inline type
ftype notinline
ignorable optimize
Figure 3–9. Common Lisp Declaration Identiﬁers
Evaluation and Compilation 3–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
An implementation is free to support other ( implementation-dened )declaration identiers as
well. A warning might be issued if a declaration identier is not among those dened above, is not
dened by the implementation , is not a type name , and has not been declared in a declaration
proclamation .
3.3.3.1 Shorthand notation for Type Declarations
Atype specier can be used as a declaration identier .(type-specierfvarg*)is taken as
shorthand for (type type-specierfvarg*).
3.3.4 Declaration Scope
Declarations can be divided into two kinds: those that apply to the bindings ofvariables or
functions ; and those that do not apply to bindings .
Adeclaration that appears at the head of a binding form and applies to a variable orfunction
binding made by that form is called a bound declaration ; such a declaration aects both the
binding and any references within the scope of the declaration .
Declarations that are not bound declarations are called free declarations .
Afree declaration in a formF1that applies to a binding for a nameNestablished by some form
F2of whichF1is asubform aects only references to NwithinF1; it does not to apply to other
references to Noutside ofF1, nor does it aect the manner in which the binding ofNbyF2is
established .
Declarations that do not apply to bindings can only appear as free declarations .
The scope of a bound declaration is the same as the lexical scope of the binding to which it applies;
forspecial variables , this means the scope that the binding would have had had it been a lexical
binding .
Unless explicitly stated otherwise, the scope of a free declaration includes only the body subforms
of the form at whose head it appears, and no other subforms . The scope offree declarations
specically does not include initialization forms forbindings established by the form containing
thedeclarations .
Some iteration forms include step, end-test, or result subforms that are also included in the scope
ofdeclarations that appear in the iteration form . Specically, the iteration forms and subforms
involved are:
do,do*:step-forms ,end-test-form , and result-forms .
dolist ,dotimes :result-form
do-all-symbols ,do-external-symbols ,do-symbols :result-form
3–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.3.4.1 Examples of Declaration Scope
Here is an example illustrating the scope ofbound declarations .
(let ((x 1)) ;[1] 1st occurrence of x
(declare (special x)) ;[2] 2nd occurrence of x
(let ((x 2)) ;[3] 3rd occurrence of x
(let ((old-x x) ;[4] 4th occurrence of x
(x 3)) ;[5] 5th occurrence of x
(declare (special x)) ;[6] 6th occurrence of x
(list old-x x)))) ;[7] 7th occurrence of x
!(2 3)
The rst occurrence of xestablishes adynamic binding ofxbecause of the special declaration forx
in the second line. The third occurrence of xestablishes alexical binding ofx(because there is no
special declaration in the corresponding letform ). The fourth occurrence of xxis a reference to
thelexical binding ofxestablished in the third line. The fth occurrence of xestablishes adynamic
binding ofxfor the body of the letform that begins on that line because of the special declaration
forxin the sixth line. The reference to xin the fourth line is not aected by the special declaration
in the sixth line because that reference is not within the \would-be lexical scope " of the variable x
in the fth line. The reference to xin the seventh line is a reference to the dynamic binding ofx
established in the fth line.
Here is another example, to illustrate the scope of a free declaration . In the following:
(lambda (&optional (x (foo 1))) ;[1]
(declare (notinline foo)) ;[2]
(foo x)) ;[3]
thecalltofooin the rst line might be compiled inline even though the calltofooin the third
line must not be. This is because the notinline declaration forfooin the second line applies only
to the body on the third line. In order to suppress inlining for both calls, one might write:
(locally (declare (notinline foo)) ;[1]
(lambda (&optional (x (foo 1))) ;[2]
(foo x))) ;[3]
or, alternatively:
(lambda (&optional ;[1]
(x (locally (declare (notinline foo)) ;[2]
(foo 1)))) ;[3]
(declare (notinline foo)) ;[4]
(foo x)) ;[5]
Finally, here is an example that shows the scope ofdeclarations in an iteration form .
(let ((x 1)) ;[1]
(declare (special x)) ;[2]
Evaluation and Compilation 3–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(let ((x 2)) ;[3]
(dotimes (i x x) ;[4]
(declare (special x))))) ;[5]
!1
In this example, the rst reference to xon the fourth line is to the lexical binding ofxestablished
on the third line. However, the second occurrence of xon the fourth line lies within the scope of
thefree declaration on the fth line (because this is the result-form of thedotimes ) and therefore
refers to the dynamic binding ofx.
3–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.4 Lambda Lists
Alambda list is alistthat species a set of parameters (sometimes called lambda variables ) and
a protocol for receiving values for those parameters .
There are several kinds of lambda lists .
Context Kind of Lambda List
defun form ordinary lambda list
defmacro form macro lambda list
lambda expression ordinary lambda list
ﬂetlocal function denition ordinary lambda list
labels local function denition ordinary lambda list
handler-case clause specication ordinary lambda list
restart-case clause specication ordinary lambda list
macrolet local macro denition macro lambda list
deﬁne-method-combination ordinary lambda list
deﬁne-method-combination :arguments option dene-method-combination arguments lambda list
defstruct :constructor option boa lambda list
defgeneric form generic function lambda list
defgeneric method clause specialized lambda list
defmethod form specialized lambda list
defsetf form defsetf lambda list
deﬁne-setf-expander form macro lambda list
deftype form deftype lambda list
destructuring-bind form destructuring lambda list
deﬁne-compiler-macro form macro lambda list
deﬁne-modify-macro form dene-modify-macro lambda list
Figure 3–10. What Kind of Lambda Lists to Use
Figure 3{11 lists some dened names that are applicable to lambda lists .
lambda-list-keywords lambda-parameters-limit
Figure 3–11. Deﬁned names applicable to lambda lists
3.4.1 Ordinary Lambda Lists
Anordinary lambda list is used to describe how a set of arguments is received by an ordinary
function . The dened names in Figure 3{12 are those which use ordinary lambda lists :
Evaluation and Compilation 3–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination handler-case restart-case
defun labels
ﬂet lambda
Figure 3–12. Standardized Operators that use Ordinary Lambda Lists
Anordinary lambda list can contain the lambda list keywords shown in Figure 3{13.
&allow-other-keys &key &rest
&aux &optional
Figure 3–13. Lambda List Keywords used by Ordinary Lambda Lists
Each element of a lambda list is either a parameter specier or a lambda list keyword .
Implementations are free to provide additional lambda list keywords . For a list of all lambda list
keywords used by the implementation, see lambda-list-keywords .
The syntax for ordinary lambda lists is as follows:
lambda-list:: =(fvarg*
[&optionalfvarj(var[init-form [supplied-p-parameter ]])g*]
[&rest var]
[&keyfvarj(fvarj(keyword-name var )g[init-form [supplied-p-parameter ]])g*
[&allow-other-keys ]]
[&auxfvarj(var[init-form ])g*])
Avarorsupplied-p-parameter must be a symbol that is not the name of a constant variable .
Aninit-form can be any form . Whenever any init-form is evaluated for any parameter specier, that
form may refer to any parameter variable to the left of the specier in which the init-form appears,
including any supplied-p-parameter variables, and may rely on the fact that no other parameter
variable has yet been bound (including its own parameter variable).
Akeyword-name can be any symbol , but by convention is normally a keyword 1; all standardized
functions follow that convention.
Anordinary lambda list has ve parts, any or all of which may be empty. For information about
the treatment of argument mismatches, see Section 3.5 (Error Checking in Function Calls).
3–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.4.1.1 Speciﬁers for the required parameters
These are all the parameter speciers up to the rst lambda list keyword ; if there are no lambda list
keywords , then all the speciers are for required parameters. Each required parameter is specied
by a parameter variable var.varis bound as a lexical variable unless it is declared special .
If there are nrequired parameters ( nmay be zero), there must be at least npassed arguments, and
the required parameters are bound to the rst npassed arguments; see Section 3.5 (Error Checking
in Function Calls). The other parameters are then processed using any remaining arguments.
3.4.1.2 Speciﬁers for optional parameters
If&optional is present, the optional parameter speciers are those following &optional up to
the next lambda list keyword or the end of the list. If optional parameters are specied, then
each one is processed as follows. If any unprocessed arguments remain, then the parameter
variable varis bound to the next remaining argument, just as for a required parameter. If no
arguments remain, however, then init-form is evaluated, and the parameter variable is bound to
the resulting value (or to nilif no init-form appears in the parameter specier). If another variable
name supplied-p-parameter appears in the specier, it is bound to true if an argument had been
available, and to false if no argument remained (and therefore init-form had to be evaluated).
Supplied-p-parameter is bound not to an argument but to a value indicating whether or not an
argument had been supplied for the corresponding var.
3.4.1.3 A speciﬁer for a rest parameter
&rest , if present, must be followed by a single rest parameter specier, which in turn must be
followed by another lambda list keyword or the end of the lambda list . After all optional parameter
speciers have been processed, then there may or may not be a rest parameter . If there is a rest
parameter , it is bound to a listof all as-yet-unprocessed arguments. If no unprocessed arguments
remain, the rest parameter is bound to the empty list . If there is no rest parameter and there are
nokeyword parameters , then an error should be signaled if any unprocessed arguments remain; see
Section 3.5 (Error Checking in Function Calls). The value of a rest parameter is permitted, but
not required, to share structure with the last argument to apply .
3.4.1.4 Speciﬁers for keyword parameters
If&key is present, all speciers up to the next lambda list keyword or the end of the listare
keyword parameter speciers. When keyword parameters are processed, the same arguments are
processed that would be made into a listfor a rest parameter . It is permitted to specify both
&rest and&key . In this case the remaining arguments are used for both purposes; that is, all
remaining arguments are made into a listfor the rest parameter , and are also processed for the
&key parameters. If &key is specied, there must remain an even number of arguments; see
Section 3.5.1.6 (Odd Number of Keyword Arguments). These arguments are considered as pairs,
the rst argument in each pair being interpreted as a name and the second as the corresponding
value. The rst object of each pair must be a symbol ; see Section 3.5.1.5 (Invalid Keyword
Evaluation and Compilation 3–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments). The keyword parameter speciers may optionally be followed by the lambda list
keyword&allow-other-keys .
In each keyword parameter specier must be a name varfor the parameter variable. If the
varappears alone or in a (var init-form )combination, the keyword name used when matching
arguments toparameters is a symbol in theKEYWORD package whose name is the same (under
string= ) as var's. If the notation ((keyword-name var )init-form )is used, then the keyword name
used to match arguments toparameters iskeyword-name , which may be a symbol in any package .
(Of course, if it is not a symbol in theKEYWORD package , it does not necessarily self-evaluate, so
care must be taken when calling the function to make sure that normal evaluation still yields the
keyword name.) Thus
(defun foo (&key radix (type ’integer)) ...)
means exactly the same as
(defun foo (&key ((:radix radix)) ((:type type) ’integer)) ...)
The keyword parameter speciers are, like all parameter speciers, eectively processed from left
to right. For each keyword parameter specier, if there is an argument pair whose name matches
that specier's name (that is, the names are eq), then the parameter variable for that specier is
bound to the second item (the value) of that argument pair. If more than one such argument pair
matches, the leftmost argument pair is used. If no such argument pair exists, then the init-form
for that specier is evaluated and the parameter variable is bound to that value (or to nilif no
init-form was specied). supplied-p-parameter is treated as for &optional parameters: it is bound
totrue if there was a matching argument pair, and to false otherwise.
Unless keyword argument checking is suppressed, an argument pair must a name matched by a
parameter specier; see Section 3.5.1.4 (Unrecognized Keyword Arguments).
If keyword argument checking is suppressed, then it is permitted for an argument pair to match
no parameter specier, and the argument pair is ignored, but such an argument pair is accessible
through the rest parameter if one was supplied. The purpose of these mechanisms is to allow
sharing of argument lists among several lambda expressions and to allow either the caller or the
called lambda expression to specify that such sharing may be taking place.
Note that if &key is present, a keyword argument of :allow-other-keys is always permitted|
regardless of whether the associated value is true orfalse. However, if the value is false, other
non-matching keywords are not tolerated (unless &allow-other-keys was used).
Furthermore, if the receiving argument list species a regular argument which would be agged
by:allow-other-keys , then:allow-other-keys has both its special-cased meaning (identifying
whether additional keywords are permitted) and its normal meaning (data ow into the function
in question).
3.4.1.4.1 Suppressing Keyword Argument Checking
If&allow-other-keys was specied in the lambda list of a function ,keyword 2argument checking is
suppressed in calls to that function .
3–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If the:allow-other-keys argument istrue in a call to a function ,keyword 2argument checking is
suppressed in that call.
The:allow-other-keys argument is permissible in all situations involving keyword 2arguments ,
even when its associated value isfalse.
3.4.1.4.1.1 Examples of Suppressing Keyword Argument Checking
;;; The caller can supply :ALLOW-OTHER-KEYS T to suppress checking.
((lambda (&key x) x) :x 1 :y 2 :allow-other-keys t) !1
;;; The callee can use &ALLOW-OTHER-KEYS to suppress checking.
((lambda (&key x &allow-other-keys) x) :x 1 :y 2) !1
;;; :ALLOW-OTHER-KEYS NIL is always permitted.
((lambda (&key) t) :allow-other-keys nil) !T
;;; As with other keyword arguments, only the left-most pair
;;; named :ALLOW-OTHER-KEYS has any effect.
((lambda (&key x) x)
:x 1 :y 2 :allow-other-keys t :allow-other-keys nil)
!1
;;; Only the left-most pair named :ALLOW-OTHER-KEYS has any effect,
;;; so in safe code this signals a PROGRAM-ERROR (and might enter the
;;; debugger). In unsafe code, the consequences are undefined.
((lambda (&key x) x) ;This call is not valid
:x 1 :y 2 :allow-other-keys nil :allow-other-keys t)
3.4.1.5 Speciﬁers for &auxvariables
These are not really parameters. If the lambda list keyword &aux is present, all speciers after it
are auxiliary variable speciers. After all parameter speciers have been processed, the auxiliary
variable speciers (those following &aux) are processed from left to right. For each one, init-form is
evaluated and varis bound to that value (or to nilif no init-form was specied). &aux variable
processing is analogous to let*processing.
(lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))
(lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))
3.4.1.6 Examples of Ordinary Lambda Lists
Here are some examples involving optional parameters and rest parameters :
((lambda (a b) (+ a (* b 3))) 4 5) !19
((lambda (a &optional (b 2)) (+ a (* b 3))) 4 5) !19
((lambda (a &optional (b 2)) (+ a (* b 3))) 4) !10
Evaluation and Compilation 3–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)))
!(2 NIL 3 NIL NIL)
((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6)
!(6 T 3 NIL NIL)
((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3)
!(6 T 3 T NIL)
((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3 8)
!(6 T 3 T (8))
((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))
6 3 8 9 10 11)
!(6 t 3 t (8 9 10 11))
Here are some examples involving keyword parameters :
((lambda (a b &key c d) (list a b c d)) 1 2) !(1 2 NIL NIL)
((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) !(1 2 6 NIL)
((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) !(1 2 NIL 8)
((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) !(1 2 6 8)
((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) !(1 2 6 8)
((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) !(:a 1 6 8)
((lambda (a b &key c d) (list a b c d)) :a :b :c :d) !(:a :b :d NIL)
((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) !(1 2 6 NIL)
((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 ’c 6) !(1 2 6 NIL)
Here are some examples involving optional parameters ,rest parameters , and keyword parameters
together:
((lambda (a &optional (b 3) &rest x &key c (d a))
(list a b c d x)) 1)
!(1 3 NIL 1 ())
((lambda (a &optional (b 3) &rest x &key c (d a))
(list a b c d x)) 1 2)
!(1 2 NIL 1 ())
((lambda (a &optional (b 3) &rest x &key c (d a))
(list a b c d x)) :c 7)
!(:c 7 NIL :c ())
((lambda (a &optional (b 3) &rest x &key c (d a))
(list a b c d x)) 1 6 :c 7)
!(1 6 7 1 (:c 7))
((lambda (a &optional (b 3) &rest x &key c (d a))
(list a b c d x)) 1 6 :d 8)
!(1 6 NIL 8 (:d 8))
((lambda (a &optional (b 3) &rest x &key c (d a))
(list a b c d x)) 1 6 :d 8 :c 9 :d 10)
!(1 6 9 8 (:d 8 :c 9 :d 10))
As an example of the use of &allow-other-keys and:allow-other-keys , consider a function that
3–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
takes two named arguments of its own and also accepts additional named arguments to be passed
tomake-array :
(defun array-of-strings (str dims &rest named-pairs
&key (start 0) end &allow-other-keys)
(apply #’make-array dims
:initial-element (subseq str start end)
:allow-other-keys t
named-pairs))
This function takes a string and dimensioning information and returns an array of the specied
dimensions, each of whose elements is the specied string . However, :start and:end named
arguments may be used to specify that a substring of the given string should be used. In
addition, the presence of &allow-other-keys in the lambda list indicates that the caller may
supply additional named arguments; the rest parameter provides access to them. These additional
named arguments are passed to make-array . The function make-array normally does not allow
the named arguments :start and:end to be used, and an error should be signaled if such named
arguments are supplied to make-array . However, the presence in the call to make-array of the
named argument :allow-other-keys with a true value causes any extraneous named arguments,
including :start and:end, to be acceptable and ignored.
3.4.2 Generic Function Lambda Lists
Ageneric function lambda list is used to describe the overall shape of the argument list to be
accepted by a generic function . Individual method signatures might contribute additional keyword
parameters to the lambda list of the eective method .
Ageneric function lambda list is used by defgeneric .
Ageneric function lambda list has the following syntax:
lambda-list:: =(fvarg*
[&optionalfvarj(var)g*]
[&rest var]
[&keyfvarj(fvarj(keyword-name var )g)g*
[&allow-other-keys ]])
Ageneric function lambda list can contain the lambda list keywords shown in Figure 3{14.
&allow-other-keys &optional
&key &rest
Figure 3–14. Lambda List Keywords used by Generic Function Lambda Lists
Evaluation and Compilation 3–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Ageneric function lambda list diers from an ordinary lambda list in the following ways:
Required arguments
Zero or more required parameters must be specied.
Optional and keyword arguments
Optional parameters and keyword parameters may not have default initial value forms nor
use supplied-p parameters.
Use of&aux
The use of &aux is not allowed.
3.4.3 Specialized Lambda Lists
Aspecialized lambda list is used to specialize amethod for a particular signature and to describe
how arguments matching that signature are received by the method . The dened names in Figure
3{15 use specialized lambda lists in some way; see the dictionary entry for each for information
about how.
defmethod defgeneric
Figure 3–15. Standardized Operators that use Specialized Lambda Lists
Aspecialized lambda list can contain the lambda list keywords shown in Figure 3{16.
&allow-other-keys &key &rest
&aux &optional
Figure 3–16. Lambda List Keywords used by Specialized Lambda Lists
Aspecialized lambda list is syntactically the same as an ordinary lambda list except that each
required parameter may optionally be associated with a class orobject for which that parameter is
specialized .
lambda-list:: =(fvarj(var[specializer ])g*
[&optionalfvarj(var[init-form [supplied-p-parameter ]])g*]
[&rest var]
[&keyfvarj(fvarj(keyword-name var )g[init-form [supplied-p-parameter ]])g* [&allow-other-keys ]]
[&auxfvarj(var[init-form ])g*])
3–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.4.4 Macro Lambda Lists
Amacro lambda list is used in describing macros dened by the operators in Figure 3{17.
deﬁne-compiler-macro defmacro macrolet
deﬁne-setf-expander
Figure 3–17. Operators that use Macro Lambda Lists
With the additional restriction that an environment parameter may appear only once (at any of
the positions indicated), a macro lambda list has the following syntax:
reqvars:: =fvarj#patterng*
optvars:: =[&optionalfvarj(fvarj#patterng[init-form [supplied-p-parameter ]])g*]
restvar:: =[f&restj&bodygfvarj#patterng]
keyvars:: =[&keyfvarj(fvarj(keyword-namefvarj#patterng)g[init-form [supplied-p-parameter ]])g*
[&allow-other-keys ]]
auxvars:: =[&auxfvarj(var[init-form ])g*]
envvar:: =[&environment var]
wholevar:: =[&whole var]
lambda-list:: =(#wholevar#envvar#reqvars#envvar#optvars#envvar
#restvar#envvar#keyvars#envvar#auxvars#envvar )j
(#wholevar#envvar#reqvars#envvar#optvars#envvar.var)
pattern:: =(#wholevar#reqvars#optvars#restvar#keyvars#auxvars )j
(#wholevar#reqvars#optvars.var)
Amacro lambda list can contain the lambda list keywords shown in Figure 3{18.
&allow-other-keys &environment &rest
&aux &key &whole
&body &optional
Figure 3–18. Lambda List Keywords used by Macro Lambda Lists
Evaluation and Compilation 3–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Optional parameters (introduced by &optional ) and keyword parameters (introduced by &key )
can be supplied in a macro lambda list , just as in an ordinary lambda list . Both may contain
default initialization forms and supplied-p parameters .
&body is identical in function to &rest , but it can be used to inform certain output-formatting
and editing functions that the remainder of the form is treated as a body, and should be indented
accordingly. Only one of &body or&rest can be used at any particular level; see Section 3.4.4.1
(Destructuring by Lambda Lists). &body can appear at any level of a macro lambda list ; for
details, see Section 3.4.4.1 (Destructuring by Lambda Lists).
&whole is followed by a single variable that is bound to the entire macro-call form; this is the value
that the macro function receives as its rst argument. If &whole and a following variable appear,
they must appear rst in lambda-list , before any other parameter or lambda list keyword .&whole
can appear at any level of a macro lambda list . At inner levels, the &whole variable is bound to
the corresponding part of the argument, as with &rest , but unlike &rest , other arguments are also
allowed. The use of &whole does not aect the pattern of arguments specied.
&environment is followed by a single variable that is bound to an environment representing the
lexical environment in which the macro call is to be interpreted. This environment should be
used with macro-function ,get-setf-expansion ,compiler-macro-function , andmacroexpand
(for example) in computing the expansion of the macro, to ensure that any lexical bindings or
denitions established in the compilation environment are taken into account. &environment can
only appear at the top level of a macro lambda list , and can only appear once, but can appear
anywhere in that list; the &environment parameter isbound along with &whole before any other
variables in the lambda list , regardless of where &environment appears in the lambda list . The
object that is bound to the environment parameter hasdynamic extent .
Destructuring allows a macro lambda list to express the structure of a macro call syntax. If no
lambda list keywords appear, then the macro lambda list is atreecontaining parameter names at
the leaves. The pattern and the macro form must have compatible tree structure ; that is, their
tree structure must be equivalent, or it must dier only in that some leaves of the pattern match
non-atomic objects of the macro form . For information about error detection in this situation , see
Section 3.5.1.7 (Destructuring Mismatch).
A destructuring lambda list (whether at top level or embedded) can be dotted, ending in a
parameter name. This situation is treated exactly as if the parameter name that ends the listhad
appeared preceded by &rest .
It is permissible for a macro form (or a subexpression of a macro form ) to be a dotted list only
when(... &rest var) or(... . var) is used to match it. It is the responsibility of the macro
to recognize and deal with such situations.
3.4.4.1 Destructuring by Lambda Lists
Anywhere in a macro lambda list where a parameter name can appear, and where ordinary lambda
listsyntax (as described in Section 3.4.1 (Ordinary Lambda Lists)) does not otherwise allow a list,
adestructuring lambda list can appear in place of the parameter name. When this is done, then
3–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
the argument that would match the parameter is treated as a (possibly dotted) list, to be used
as an argument list for satisfying the parameters in the embedded lambda list . This is known as
destructuring.
Destructuring is the process of decomposing a compound object into its component parts, using
an abbreviated, declarative syntax, rather than writing it out by hand using the primitive
component-accessing functions. Each component part is bound to a variable.
A destructuring operation requires an object to be decomposed, a pattern that species what
components are to be extracted, and the names of the variables whose values are to be the
components.
3.4.4.1.1 Data-directed Destructuring by Lambda Lists
In data-directed destructuring, the pattern is a sample object of the type to be decomposed.
Wherever a component is to be extracted, a symbol appears in the pattern; this symbol is the name
of the variable whose value will be that component.
3.4.4.1.1.1 Examples of Data-directed Destructuring by Lambda Lists
An example pattern is
(a b c)
which destructures a list of three elements. The variable ais assigned to the rst element, bto the
second, etc. A more complex example is
((first . rest) . more)
The important features of data-directed destructuring are its syntactic simplicity and the ability
to extend it to lambda-list-directed destructuring.
3.4.4.1.2 Lambda-list-directed Destructuring by Lambda Lists
An extension of data-directed destructuring of trees is lambda-list-directed destructuring. This
derives from the analogy between the three-element destructuring pattern
(first second third)
and the three-argument lambda list
(first second third)
Lambda-list-directed destructuring is identical to data-directed destructuring if no lambda list
keywords appear in the pattern. Any list in the pattern (whether a sub-list or the whole pattern
itself) that contains a lambda list keyword is interpreted specially. Elements of the list to the left
of the rst lambda list keyword are treated as destructuring patterns, as usual, but the remaining
elements of the list are treated like a function's lambda list except that where a variable would
normally be required, an arbitrary destructuring pattern is allowed. Note that in case of ambiguity,
Evaluation and Compilation 3–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
lambda list syntax is preferred over destructuring syntax. Thus, after &optional a list of elements
is a list of a destructuring pattern and a default value form.
The detailed behavior of each lambda list keyword in a lambda-list-directed destructuring pattern
is as follows:
&optional
Each following element is a variable or a list of a destructuring pattern, a default value
form, and a supplied-p variable. The default value and the supplied-p variable can be
omitted. If the list being destructured ends early, so that it does not have an element
to match against this destructuring (sub)-pattern, the default form is evaluated and
destructured instead. The supplied-p variable receives the value nilif the default form is
used,totherwise.
&rest ,&body
The next element is a destructuring pattern that matches the rest of the list. &body is
identical to &rest but declares that what is being matched is a list of forms that constitutes
the body of form . This next element must be the last unless a lambda list keyword follows
it.
&aux
The remaining elements are not destructuring patterns at all, but are auxiliary variable
bindings.
&whole
The next element is a destructuring pattern that matches the entire form in a macro, or
the entire subexpression at inner levels.
&key
Each following element is one of
avariable ,
or a list of a variable, an optional initialization form, and an optional supplied-p
variable.
or a list of a list of a keyword and a destructuring pattern, an optional initialization
form, and an optional supplied-p variable.
The rest of the list being destructured is taken to be alternating keywords and values and
is taken apart appropriately.
3–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
&allow-other-keys
Stands by itself.
3.4.5 Destructuring Lambda Lists
Adestructuring lambda list is used by destructuring-bind .
Destructuring lambda lists are closely related to macro lambda lists ; see Section 3.4.4 (Macro
Lambda Lists). A destructuring lambda list can contain all of the lambda list keywords listed for
macro lambda lists except for &environment , and supports destructuring in the same way. Inner
lambda lists nested within a macro lambda list have the syntax of destructuring lambda lists .
Adestructuring lambda list has the following syntax:
reqvars:: =fvarj#lambda-listg*
optvars:: =[&optionalfvarj(fvarj#lambda-listg[init-form [supplied-p-parameter ]])g*]
restvar:: =[f&restj&bodygfvarj#lambda-listg]
keyvars:: =[&keyfvarj(fvarj(keyword-namefvarj#lambda-listg)g[init-form [supplied-p-parameter ]])g*
[&allow-other-keys ]]
auxvars:: =[&auxfvarj(var[init-form ])g*]
envvar:: =[&environment var]
wholevar:: =[&whole var]
lambda-list:: =(#wholevar#reqvars#optvars#restvar#keyvars#auxvars )j
(#wholevar#reqvars#optvars.var)
3.4.6 Boa Lambda Lists
Aboa lambda list is alambda list that is syntactically like an ordinary lambda list , but that is
processed in \ byorder ofargument" style.
Aboa lambda list is used only in a defstruct form , when explicitly specifying the lambda list of a
constructor function (sometimes called a \boa constructor").
The&optional ,&rest ,&aux ,&key , and&allow-other-keys lambda list keywords are recognized
in a boa lambda list . The way these lambda list keywords dier from their use in an ordinary
lambda list follows.
Evaluation and Compilation 3–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Consider this example, which describes how destruct processes its :constructor option.
(:constructor create-foo
(a &optional b (c ’sea) &rest d &aux e (f ’eff)))
This denes create-foo to be a constructor of one or more arguments. The rst argument is used
to initialize the aslot. The second argument is used to initialize the bslot. If there isn't any second
argument, then the default value given in the body of the defstruct (if given) is used instead. The
third argument is used to initialize the cslot. If there isn't any third argument, then the symbol
seais used instead. Any arguments following the third argument are collected into a listand used
to initialize the dslot. If there are three or fewer arguments, then nilis placed in the dslot. The
eslot is not initialized; its initial value is implementation-dened . Finally, the fslot is initialized
to contain the symbol eff.&key and&allow-other-keys arguments default in a manner similar
to that of &optional arguments: if no default is supplied in the lambda list then the default value
given in the body of the defstruct (if given) is used instead. For example:
(defstruct (foo (:constructor CREATE-FOO (a &optional b (c ’sea)
&key (d 2)
&aux e (f ’eff))))
(a 1) (b 2) (c 3) (d 4) (e 5) (f 6))
(create-foo 10) !#S(FOO A 10 B 2 C SEA D 2 E implemention-dependent F EFF)
(create-foo 10 ’bee ’see :d ’dee)
!#S(FOO A 10 B BEE C SEE D DEE E implemention-dependent F EFF)
If keyword arguments of the form ((key var)[default [svar]])are specied, the slot name is
matched with var(not key).
The actions taken in the bandecases were carefully chosen to allow the user to specify all possible
behaviors. The &aux variables can be used to completely override the default initializations given
in the body.
If no default value is supplied for an aux variable variable, the consequences are undened if an
attempt is later made to read the corresponding slot's value before a value is explicitly assigned.
If such a slothas a:type option specied, this suppressed initialization does not imply a type
mismatch situation; the declared type is only required to apply when the slotis nally assigned.
With this denition, the following can be written:
(create-foo 1 2)
instead of
(make-foo :a 1 :b 2)
andcreate-foo provides defaulting dierent from that of make-foo .
Additional arguments that do not correspond to slot names but are merely present to supply values
used in subsequent initialization computations are allowed. For example, in the denition
3–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defstruct (frob (:constructor create-frob
(a &key (b 3 have-b) (c-token ’c)
(c (list c-token (if have-b 7 2))))))
a b c)
thec-token argument is used merely to supply a value used in the initialization of the cslot. The
supplied-p parameters associated with optional parameters and keyword parameters might also be
used this way.
3.4.7 Defsetf Lambda Lists
Adefsetf lambda list is used by defsetf .
Adefsetf lambda list has the following syntax:
lambda-list:: =(fvarg*
[&optionalfvarj(var[init-form [supplied-p-parameter ]])g*]
[&rest var]
[&keyfvarj(fvarj(keyword-name var )g[init-form [supplied-p-parameter ]])g*
[&allow-other-keys ]]
[&environment var]
Adefsetf lambda list can contain the lambda list keywords shown in Figure 3{19.
&allow-other-keys &key &rest
&environment &optional
Figure 3–19. Lambda List Keywords used by Defsetf Lambda Lists
Adefsetf lambda list diers from an ordinary lambda list only in that it does not permit the use of
&aux , and that it permits use of &environment , which introduces an environment parameter .
3.4.8 Deftype Lambda Lists
Adeftype lambda list is used by deftype .
Adeftype lambda list has the same syntax as a macro lambda list , and can therefore contain the
lambda list keywords as a macro lambda list .
Adeftype lambda list diers from a macro lambda list only in that if no init-form is supplied for an
optional parameter orkeyword parameter in the lambda-list , the default value for that parameter
is the symbol*(rather than nil).
Evaluation and Compilation 3–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.4.9 Deﬁne-modify-macro Lambda Lists
Adene-modify-macro lambda list is used by deﬁne-modify-macro .
Adene-modify-macro lambda list can contain the lambda list keywords shown in Figure 3{20.
&optional &rest
Figure 3–20. Lambda List Keywords used by Deﬁne-modify-macro Lambda Lists
Dene-modify-macro lambda lists are similar to ordinary lambda lists , but do not support keyword
arguments. deﬁne-modify-macro has no need match keyword arguments, and a rest parameter is
sucient. Aux variables are also not supported, since deﬁne-modify-macro has no body forms
which could refer to such bindings . See the macrodeﬁne-modify-macro .
3.4.10 Deﬁne-method-combination Arguments Lambda Lists
Adene-method-combination arguments lambda list is used by the :arguments option to
deﬁne-method-combination .
Adene-method-combination arguments lambda list can contain the lambda list keywords shown in
Figure 3{21.
&allow-other-keys &key &rest
&aux &optional &whole
Figure 3–21. Lambda List Keywords used by Deﬁne-method-combination arguments Lambda Lists
Dene-method-combination arguments lambda lists are similar to ordinary lambda lists , but also
permit the use of &whole .
3.4.11 Syntactic Interaction of Documentation Strings and
Declarations
In a number of situations, a documentation string can appear amidst a series of declare expressions
prior to a series of forms .
In that case, if a stringSappears where a documentation string is permissible and is not followed
by either a declare expression or a form thenSis taken to be a form ; otherwise, Sis taken as
adocumentation string . The consequences are unspecied if more than one such documentation
string is present.
3–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.5 Error Checking in Function Calls
3.5.1 Argument Mismatch Detection
3.5.1.1 Safe and Unsafe Calls
Acallis asafe call if each of the following is either safe code orsystem code (other than system
code that results from macro expansion ofprogrammer code ):
thecall.
the denition of the function being called .
the point of functional evaluation
The following special cases require some elaboration:
If the function being called is a generic function , it is considered safeif all of the following
aresafe code orsystem code :
{ its denition (if it was dened explicitly).
{ the method denitions for all applicable methods .
{ the denition of its method combination .
For the form (coerce x’function) , where xis a lambda expression , the value of the
optimize quality safety in the global environment at the time the coerce isexecuted applies
to the resulting function .
For a call to the functionensure-generic-function , the value of the optimize quality safety
in the environment object passed as the :environment argument applies to the resulting
generic function .
For a call to compile with a lambda expression as the argument , the value of the optimize
qualitysafety in the global environment at the time compile iscalled applies to the
resulting compiled function .
For a call to compile with only one argument, if the original denition of the function was
safe, then the resulting compiled function must also be safe.
Acallto a method bycall-next-method must be considered safe if each of the following
issafe code orsystem code :
{ the denition of the generic function (if it was dened explicitly).
Evaluation and Compilation 3–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
{ the method denitions for all applicable methods .
{ the denition of the method combination .
{ the point of entry into the body of the method dening form , where the binding of
call-next-method is established.
{ the point of functional evaluation of the name call-next-method .
Anunsafe call is acallthat is not a safe call .
The informal intent is that the programmer can rely on a callto be safe, even when system code is
involved, if all reasonable steps have been taken to ensure that the callissafe. For example, if a
programmer callsmapcar from safe code and supplies a function that was compiled assafe, the
implementation is required to ensure that mapcar makes a safe call as well.
3.5.1.1.1 Error Detection Time in Safe Calls
If an error is signaled in a safe call , the exact point of the signal isimplementation-dependent .
In particular, it might be signaled at compile time or at run time, and if signaled at run time, it
might be prior to, during, or after executing thecall. However, it is always prior to the execution
of the body of the function being called .
3.5.1.2 Too Few Arguments
It is not permitted to supply too few arguments to a function . Too few arguments means fewer
arguments than the number of required parameters for the function .
If this situation occurs in a safe call , an error of typeprogram-error must be signaled; and in an
unsafe call thesituation has undened consequences.
3.5.1.3 Too Many Arguments
It is not permitted to supply too many arguments to a function . Too many arguments means
more arguments than the number of required parameters plus the number of optional parameters ;
however, if the function uses&rest or&key , it is not possible for it to receive too many arguments.
If this situation occurs in a safe call , an error of typeprogram-error must be signaled; and in an
unsafe call thesituation has undened consequences.
3.5.1.4 Unrecognized Keyword Arguments
It is not permitted to supply a keyword argument to a function using a name that is not recognized
by that function unless keyword argument checking is suppressed as described in Section 3.4.1.4.1
(Suppressing Keyword Argument Checking).
If this situation occurs in a safe call , an error of typeprogram-error must be signaled; and in an
unsafe call thesituation has undened consequences.
3–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.5.1.5 Invalid Keyword Arguments
It is not permitted to supply a keyword argument to a function using a name that is not a symbol .
If this situation occurs in a safe call , an error of typeprogram-error must be signaled unless
keyword argument checking is suppressed as described in Section 3.4.1.4.1 (Suppressing Keyword
Argument Checking); and in an unsafe call thesituation has undened consequences.
3.5.1.6 Odd Number of Keyword Arguments
An odd number of arguments must not be supplied for the keyword parameters .
If this situation occurs in a safe call , an error of typeprogram-error must be signaled unless
keyword argument checking is suppressed as described in Section 3.4.1.4.1 (Suppressing Keyword
Argument Checking); and in an unsafe call thesituation has undened consequences.
3.5.1.7 Destructuring Mismatch
When matching a destructuring lambda list against a form , the pattern and the form must have
compatible tree structure , as described in Section 3.4.4 (Macro Lambda Lists).
Otherwise, in a safe call , an error of typeprogram-error must be signaled; and in an unsafe call
thesituation has undened consequences.
3.5.1.8 Errors When Calling a Next Method
Ifcall-next-method is called with arguments , the ordered set of applicable methods for the changed
set of arguments forcall-next-method must be the same as the ordered set of applicable methods
for the original arguments to the generic function , or else an error should be signaled.
The comparison between the set of methods applicable to the new arguments and the set applicable
to the original arguments is insensitive to order dierences among methods with the same
specializers.
Ifcall-next-method is called with arguments that specify a dierent ordered set of applicable
methods and there is no next method available, the test for dierent methods and the associated
error signaling (when present) takes precedence over calling no-next-method .
Evaluation and Compilation 3–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.6 Traversal Rules and Side Eﬀects
The consequences are undened when code executed during an object-traversing operation
destructively modies the object in a way that might aect the ongoing traversal operation. In
particular, the following rules apply.
List traversal
Forlisttraversal operations, the cdrchain of the listis not allowed to be destructively
modied.
Array traversal
Forarray traversal operations, the array is not allowed to be adjusted and its ll pointer ,
if any, is not allowed to be changed.
Hash-table traversal
Forhash table traversal operations, new elements may not be added or deleted except that
the element corresponding to the current hash key may be changed or removed.
Package traversal
Forpackage traversal operations ( e.g.,do-symbols ), new symbols may not be interned in
oruninterned from the package being traversed or any package that it uses except that the
current symbol may be uninterned from the package being traversed.
3–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
3.7 Destructive Operations
3.7.1 Modiﬁcation of Literal Objects
The consequences are undened if literal objects are destructively modied. For this purpose, the
following operations are considered destructive :
random-state
Using it as an argument to the functionrandom .
cons
Changing the car1orcdr1of the cons, or performing a destructive operation on an object
which is either the car2or the cdr2of the cons.
array
Storing a new value into some element of the array , or performing a destructive operation
on an object that is already such an element .
Changing the ll pointer ,dimensions , or displacement of the array (regardless of whether
thearray isactually adjustable ).
Performing a destructive operation on another array that is displaced to the array or that
otherwise shares its contents with the array .
hash-table
Performing a destructive operation on any key.
Storing a new value 4for any key, or performing a destructive operation on any object that
is such a value .
Adding or removing entries from the hash table .
structure-object
Storing a new value into any slot, or performing a destructive operation on an object that
is the value of some slot.
standard-object
Storing a new value into any slot, or performing a destructive operation on an object that
is the value of some slot.
Changing the class of the object (e.g., using the functionchange-class ).
Evaluation and Compilation 3–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
readtable
Altering the readtable case .
Altering the syntax type of any character in this readtable.
Altering the reader macro function associated with any character in the readtable , or
altering the reader macro functions associated with characters dened as dispatching
macro characters in the readtable .
stream
Performing I/O operations on the stream , orclosing thestream .
All other standardized types
[This category includes, for example, character ,condition ,function ,
method-combination ,method ,number ,package ,pathname ,restart , andsymbol .]
There are no standardized destructive operations dened on objects of these types .
3.7.2 Transfer of Control during a Destructive Operation
Should a transfer of control out of a destructive operation occur ( e.g., due to an error) the state of
theobject being modied is implementation-dependent .
3.7.2.1 Examples of Transfer of Control during a Destructive Operation
The following examples illustrate some of the many ways in which the implementation-dependent
nature of the modication can manifest itself.
(let ((a (list 2 1 4 3 7 6 ’five)))
(ignore-errors (sort a #’<))
a)
!(1 2 3 4 6 7 FIVE)or!(2 1 4 3 7 6 FIVE)or!(2)
(prog foo ((a (list 1 2 3 4 5 6 7 8 9 10)))
(sort a #’(lambda (x y) (if (zerop (random 5)) (return-from foo a) (> x y)))))
!(1 2 3 4 5 6 7 8 9 10)or!(3 4 5 6 2 7 8 9 10 1)or!(1 2 4 3)
3–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
lambda Symbol
Syntax:
lambda lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*
Arguments:
lambda-list |an ordinary lambda list .
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
form|aform .
Description:
Alambda expression is alistthat can be used in place of a function name in certain contexts to
denote a function by directly describing its behavior rather than indirectly by referring to the
name of an established function .
Documentation is attached to the denoted function (if any is actually created) as a documentation
string .
See Also:
function ,documentation , Section 3.1.3 (Lambda Expressions), Section 3.1.2.1.2.4 (Lambda
Forms), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)
Notes:
The lambda form
((lambda lambda-list .body) . arguments )
is semantically equivalent to the function form
(funcall #’(lambda lambda-list .body) . arguments )
lambda Macro
Syntax:
lambda lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*!function
Arguments and Values:
lambda-list |an ordinary lambda list .
Evaluation and Compilation 3–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
form|aform .
function |afunction .
Description:
Provides a shorthand notation for a function special form involving a lambda expression such that:
(lambda lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*)
(function (lambda lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*))
#’(lambda lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*)
Examples:
(funcall (lambda (x) (+ x 3)) 4) !7
See Also:
lambda (symbol)
Notes:
This macro could be implemented by:
(defmacro lambda (&whole form &rest bvl-decls-and-body)
(declare (ignore bvl-decls-and-body))
‘#’,form)
compile Function
Syntax:
compile name&optional denition!function, warnings-p, failure-p
Arguments and Values:
name |afunction name , ornil.
denition |alambda expression or a function . The default is the function denition of name if
it names a function , or the macro function ofname if it names a macro . The consequences are
undened if no denition is supplied when the name isnil.
function |the function-name , or a compiled function .
warnings-p |ageneralized boolean .
3–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
compile
failure-p |ageneralized boolean .
Description:
Compiles an interpreted function .
compile produces a compiled function from denition . If the denition is alambda expression , it is
coerced to a function . If the denition is already a compiled function ,compile either produces that
function itself ( i.e., is an identity operation) or an equivalent function.
If the name isnil, the resulting compiled function is returned directly as the primary value . If a
non-nil name is given, then the resulting compiled function replaces the existing function denition
ofname and the name is returned as the primary value ; ifname is asymbol that names a macro ,
itsmacro function is updated and the name is returned as the primary value .
Literal objects appearing in code processed by the compile function are neither copied nor
coalesced . The code resulting from the execution of compile references objects that areeqlto the
corresponding objects in the source code.
compile is permitted, but not required, to establish ahandler forconditions oftypeerror . For
example, the handler might issue a warning and restart compilation from some implementation-
dependent point in order to let the compilation proceed without manual intervention.
The secondary value ,warnings-p , isfalse if no conditions oftypeerror orwarning were detected
by the compiler, and true otherwise.
The tertiary value ,failure-p , isfalse if no conditions oftypeerror orwarning (other than
style-warning ) were detected by the compiler, and true otherwise.
Examples:
(defun foo () "bar") !FOO
(compiled-function-p #’foo) !implementation-dependent
(compile ’foo)!FOO
(compiled-function-p #’foo) !true
(setf (symbol-function ’foo)
(compile nil ’(lambda () "replaced"))) !#<Compiled-Function>
(foo)!"replaced"
Aﬀected By:
*error-output* ,*macroexpand-hook* .
The presence of macro denitions and proclamations.
Exceptional Situations:
The consequences are undened if the lexical environment surrounding the function to be compiled
contains any bindings other than those for macros ,symbol macros , ordeclarations .
For information about errors detected during the compilation process, see Section 3.2.5 (Exceptional
Evaluation and Compilation 3–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Situations in the Compiler).
See Also:
compile-ﬁle
eval Function
Syntax:
eval form!f resultg*
Arguments and Values:
form|aform .
results |the values yielded by the evaluation ofform.
Description:
Evaluates form in the current dynamic environment and the null lexical environment .
eval is a user interface to the evaluator.
The evaluator expands macro calls as if through the use of macroexpand-1 .
Constants appearing in code processed by eval are not copied nor coalesced. The code resulting
from the execution of eval references objects that areeqlto the corresponding objects in the source
code.
Examples:
(setq form ’(1+ a) a 999) !999
(eval form)!1000
(eval ’form)!(1+ A)
(let ((a ’(this would break if eval used local value))) (eval form))
!1000
See Also:
macroexpand-1 , Section 3.1.2 (The Evaluation Model)
Notes:
To obtain the current dynamic value of a symbol , use ofsymbol-value is equivalent (and usually
preferable) to use of eval.
Note that an eval form involves two levels of evaluation for its argument . First, form isevaluated
by the normal argument evaluation mechanism as would occur with any call. The object that
3–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
results from this normal argument evaluation becomes the value of the form parameter , and is then
evaluated as part of the eval form . For example:
(eval (list ’cdr (car ’((quote (a . b)) c)))) !b
The argument form (list ’cdr (car ’((quote (a . b)) c))) is evaluated in the usual
way to produce the argument (cdr (quote (a . b))) ;eval then evaluates its argument ,
(cdr (quote (a . b))) , to produce b. Since a single evaluation already occurs for any argument
form in any function form ,eval is sometimes said to perform \an extra level of evaluation."
eval-when Special Operator
Syntax:
eval-when (fsituationg*)fformg*!f resultg*
Arguments and Values:
situation |One of the symbols :compile-toplevel ,:load-toplevel ,:execute ,compile ,load, oreval.
The use of eval,compile , andload is deprecated.
forms |an implicit progn .
results |the values of the forms if they are executed, or nilif they are not.
Description:
The body of an eval-when form is processed as an implicit progn , but only in the situations listed.
The use of the situations :compile-toplevel (orcompile ) and:load-toplevel (orload) controls
whether and when evaluation occurs when eval-when appears as a top level form in code processed
bycompile-ﬁle . See Section 3.2.3 (File Compilation).
The use of the situation :execute (oreval) controls whether evaluation occurs for other eval-when
forms ; that is, those that are not top level forms , or those in code processed by eval orcompile . If
the:execute situation is specied in such a form , then the body forms are processed as an implicit
progn ; otherwise, the eval-when form returnsnil.
eval-when normally appears as a top level form , but it is meaningful for it to appear as a
non-top-level form . However, the compile-time side eects described in Section 3.2 (Compilation)
only take place when eval-when appears as a top level form .
Examples:
One example of the use of eval-when is that for the compiler to be able to read a le properly
when it uses user-dened reader macros , it is necessary to write
(eval-when (:compile-toplevel :load-toplevel :execute)
Evaluation and Compilation 3–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
eval-when
(set-macro-character #\$ #’(lambda (stream char)
(declare (ignore char))
(list ’dollar (read stream))))) !T
This causes the call to set-macro-character to be executed in the compiler's execution environment,
thereby modifying its reader syntax table.
;;; The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE
;;; keyword is considered. At compile time, this has no effect.
;;; At load time (if the LET is at toplevel), or at execution time
;;; (if the LET is embedded in some other form which does not execute
;;; until later) this sets (SYMBOL-FUNCTION ’FOO1) to a function which
;;; returns 1.
(let ((x 1))
(eval-when (:execute :load-toplevel :compile-toplevel)
(setf (symbol-function ’foo1) #’(lambda () x))))
;;; If this expression occurs at the toplevel of a file to be compiled,
;;; it has BOTH a compile time AND a load-time effect of setting
;;; (SYMBOL-FUNCTION ’FOO2) to a function which returns 2.
(eval-when (:execute :load-toplevel :compile-toplevel)
(let ((x 2))
(eval-when (:execute :load-toplevel :compile-toplevel)
(setf (symbol-function ’foo2) #’(lambda () x)))))
;;; If this expression occurs at the toplevel of a file to be compiled,
;;; it has BOTH a compile time AND a load-time effect of setting the
;;; function cell of FOO3 to a function which returns 3.
(eval-when (:execute :load-toplevel :compile-toplevel)
(setf (symbol-function ’foo3) #’(lambda () 3)))
;;; #4: This always does nothing. It simply returns NIL.
(eval-when (:compile-toplevel)
(eval-when (:compile-toplevel)
(print ’foo4)))
;;; If this form occurs at toplevel of a file to be compiled, FOO5 is
;;; printed at compile time. If this form occurs in a non-top-level
;;; position, nothing is printed at compile time. Regardless of context,
;;; nothing is ever printed at load time or execution time.
(eval-when (:compile-toplevel)
(eval-when (:execute)
(print ’foo5)))
;;; If this form occurs at toplevel of a file to be compiled, FOO6 is
;;; printed at compile time. If this form occurs in a non-top-level
3–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
eval-when
;;; position, nothing is printed at compile time. Regardless of context,
;;; nothing is ever printed at load time or execution time.
(eval-when (:execute :load-toplevel)
(eval-when (:compile-toplevel)
(print ’foo6)))
See Also:
compile-ﬁle , Section 3.2 (Compilation)
Notes:
The following eects are logical consequences of the denition of eval-when :
Execution of a single eval-when expression executes the body code at most once.
Macros intended for use in top level forms should be written so that side-eects are
done by the forms in the macro expansion. The macro-expander itself should not do the
side-eects.
For example:
Wrong:
(defmacro foo ()
(really-foo)
‘(really-foo))
Right:
(defmacro foo ()
‘(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))
Adherence to this convention means that such macros behave intuitively when appearing
asnon-top-level forms .
Placing a variable binding around an eval-when reliably captures the binding because the
compile-time-too mode cannot occur ( i.e., introducing a variable binding means that the
eval-when is not a top level form ). For example,
(let ((x 3))
(eval-when (:execute :load-toplevel :compile-toplevel) (print x)))
prints3at execution ( i.e., load) time, and does not print anything at compile time. This is
important so that expansions of defun anddefmacro can be done in terms of eval-when
and can correctly capture the lexical environment .
(defun bar (x) (defun foo () (+ x 3)))
might expand into
Evaluation and Compilation 3–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defun bar (x)
(progn (eval-when (:compile-toplevel)
(compiler::notice-function-definition ’foo ’(x)))
(eval-when (:execute :load-toplevel)
(setf (symbol-function ’foo) #’(lambda () (+ x 3))))))
which would be treated by the above rules the same as
(defun bar (x)
(setf (symbol-function ’foo) #’(lambda () (+ x 3))))
when the denition of baris not a top level form .
load-time-value Special Operator
Syntax:
load-time-value form&optional read-only-p!object
Arguments and Values:
form|aform ; evaluated as described below.
read-only-p |aboolean ; not evaluated.
object |the primary value resulting from evaluating form.
Description:
load-time-value provides a mechanism for delaying evaluation of form until the expression is in the
run-time environment; see Section 3.2 (Compilation).
Read-only-p designates whether the result can be considered a constant object . Ift, the result is a
read-only quantity that can, if appropriate to the implementation , be copied into read-only space
and/or coalesced with similar constant objects from other programs . Ifnil(the default), the result
must be neither copied nor coalesced; it must be considered to be potentially modiable data.
If aload-time-value expression is processed by compile-ﬁle , the compiler performs its normal
semantic processing (such as macro expansion and translation into machine code) on form, but
arranges for the execution of form to occur at load time in a null lexical environment , with the
result of this evaluation then being treated as a literal object at run time. It is guaranteed that
the evaluation of form will take place only once when the leisloaded , but the order of evaluation
with respect to the evaluation of top level forms in the le is implementation-dependent .
If aload-time-value expression appears within a function compiled with compile , the form is
evaluated at compile time in a null lexical environment . The result of this compile-time evaluation
is treated as a literal object in the compiled code.
3–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
load-time-value
If aload-time-value expression is processed by eval,form is evaluated in a null lexical environment ,
and one value is returned. Implementations that implicitly compile (or partially compile) expressions
processed by eval might evaluate form only once, at the time this compilation is performed.
If the same list (load-time-value form)is evaluated or compiled more than once, it is
implementation-dependent whether form is evaluated only once or is evaluated more than once.
This can happen both when an expression being evaluated or compiled shares substructure, and
when the same form is processed by eval orcompile multiple times. Since a load-time-value
expression can be referenced in more than one place and can be evaluated multiple times by eval,
it is implementation-dependent whether each execution returns a fresh object or returns the same
object as some other execution. Users must use caution when destructively modifying the resulting
object .
If two lists (load-time-value form)that are the same underequal but are not identical are
evaluated or compiled, their values always come from distinct evaluations of form. Their values
may not be coalesced unless read-only-p ist.
Examples:
;;; The function INCR1 always returns the same value, even in different images.
;;; The function INCR2 always returns the same value in a given image,
;;; but the value it returns might vary from image to image.
(defun incr1 (x) (+ x #.(random 17)))
(defun incr2 (x) (+ x (load-time-value (random 17))))
;;; The function FOO1-REF references the nth element of the first of
;;; the *FOO-ARRAYS* that is available at load time. It is permissible for
;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the
;;; updated values.
(defvar *foo-arrays* (list (make-array 7) (make-array 8)))
(defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))
(defun set-foo1-ref (n val)
(setf (aref (load-time-value (first *my-arrays*) nil) n) val))
;;; The function BAR1-REF references the nth element of the first of
;;; the *BAR-ARRAYS* that is available at load time. The programmer has
;;; promised that the array will be treated as read-only, so the system
;;; can copy or coalesce the array.
(defvar *bar-arrays* (list (make-array 7) (make-array 8)))
(defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))
;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
;;; even though NIL was specified, because the object was already read-only
;;; when it was written as a literal vector rather than created by a constructor.
;;; User programs must treat the vector v as read-only.
(defun baz-ref (n)
Evaluation and Compilation 3–63
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(let ((v (load-time-value #(A B C) nil)))
(values (svref v n) v)))
;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
;;; even though NIL was specified in the outer situation because T was specified
;;; in the inner situation. User programs must treat the vector v as read-only.
(defun baz-ref (n)
(let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))
(values (svref v n) v)))
See Also:
compile-ﬁle ,compile ,eval, Section 3.2.2.2 (Minimal Compilation), Section 3.2 (Compilation)
Notes:
load-time-value must appear outside of quoted structure in a \for evaluation " position. In
situations which would appear to call for use of load-time-value within a quoted structure, the
backquote reader macro is probably called for; see Section 2.4.6 (Backquote).
Specifying nilforread-only-p is not a way to force an object to become modiable if it has already
been made read-only. It is only a way to say that, for an object that is modiable, this operation
is not intended to make that object read-only.
quote Special Operator
Syntax:
quote object!object
Arguments and Values:
object |an object ; not evaluated.
Description:
Thequote special operator just returns object .
The consequences are undened if literal objects (including quoted objects ) are destructively
modied.
Examples:
(setq a 1)!1
(quote (setq a 3)) !(SETQ A 3)
a!1
’a!A
”a!(QUOTE A)
3–64 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
”’a!(QUOTE (QUOTE A))
(setq a 43)!43
(list a (cons a 3)) !(43 (43 . 3))
(list (quote a) (quote (cons a 3))) !(A (CONS A 3))
1!1
’1!1
"foo"!"foo"
’"foo"!"foo"
(car ’(a b))!A
’(car ’(a b))!(CAR (QUOTE (A B)))
#(car ’(a b))!#(CAR (QUOTE (A B)))
’#(car ’(a b))!#(CAR (QUOTE (A B)))
See Also:
Section 3.1 (Evaluation), Section 2.4.3 (Single-Quote), Section 3.2.1 (Compiler Terminology)
Notes:
The textual notation ’object is equivalent to (quote object); see Section 3.2.1 (Compiler
Terminology).
Some objects , called self-evaluating objects , do not require quotation by quote . However, symbols
and lists are used to represent parts of programs, and so would not be useable as constant data
in a program without quote . Sincequote suppresses the evaluation of these objects , they become
data rather than program.
compiler-macro-function Accessor
Syntax:
compiler-macro-function name&optional environment!function
(setf (compiler-macro-function name&optional environment )new-function )
Arguments and Values:
name |afunction name .
environment |an environment object .
function ,new-function |acompiler macro function , ornil.
Description:
Accesses thecompiler macro function named name , if any, in the environment .
Evaluation and Compilation 3–65
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
A value of nildenotes the absence of a compiler macro function named name .
Exceptional Situations:
The consequences are undened if environment isnon-nil in a use of setf of
compiler-macro-function .
See Also:
deﬁne-compiler-macro , Section 3.2.2.1 (Compiler Macros)
deﬁne-compiler-macro Macro
Syntax:
deﬁne-compiler-macro name lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*
!name
Arguments and Values:
name |afunction name .
lambda-list |amacro lambda list .
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
form|aform .
Description:
This is the normal mechanism for dening a compiler macro function . Its manner of denition is
the same as for defmacro ; the only dierences are:
The name can be a function name naming any function ormacro .
The expander function is installed as a compiler macro function for the name , rather than
as a macro function .
The&whole argument is bound to the form argument that is passed to the compiler macro
function . The remaining lambda-list parameters are specied as if this form contained the
function name in the carand the actual arguments in the cdr, but if the carof the actual
form is the symbol funcall , then the destructuring of the arguments is actually performed
using its cddr instead.
 Documentation is attached as a documentation string toname (as kindcompiler-macro )
and to the compiler macro function .
3–66 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-compiler-macro
Unlike an ordinary macro , acompiler macro can decline to provide an expansion merely
by returning a form that is the same as the original (which can be obtained by using
&whole ).
Examples:
(defun square (x) (expt x 2)) !SQUARE
(define-compiler-macro square (&whole form arg)
(if (atom arg)
‘(expt ,arg 2)
(case (car arg)
(square (if (= (length arg) 2)
‘(expt ,(nth 1 arg) 4)
form))
(expt (if (= (length arg) 3)
(if (numberp (nth 2 arg))
‘(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))
‘(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))
form))
(otherwise ‘(expt ,arg 2))))) !SQUARE
(square (square 3)) !81
(macroexpand ’(square x)) !(SQUARE X), false
(funcall (compiler-macro-function ’square) ’(square x) nil)
!(EXPT X 2)
(funcall (compiler-macro-function ’square) ’(square (square x)) nil)
!(EXPT X 4)
(funcall (compiler-macro-function ’square) ’(funcall #’square x) nil)
!(EXPT X 2)
(defun distance-positional (x1 y1 x2 y2)
(sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))
!DISTANCE-POSITIONAL
(defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))
(distance-positional x1 y1 x2 y2))
!DISTANCE
(define-compiler-macro distance (&whole form
&rest key-value-pairs
&key (x1 0 x1-p)
(y1 0 y1-p)
(x2 x1 x2-p)
(y2 y1 y2-p)
&allow-other-keys
&environment env)
(flet ((key (n) (nth (* n 2) key-value-pairs))
(arg (n) (nth (1+ (* n 2)) key-value-pairs))
(simplep (x)
Evaluation and Compilation 3–67
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-compiler-macro
(let ((expanded-x (macroexpand x env)))
(or (constantp expanded-x env)
(symbolp expanded-x)))))
(let ((n (/ (length key-value-pairs) 2)))
(multiple-value-bind (x1s y1s x2s y2s others)
(loop for (key) on key-value-pairs by #’cddr
count (eq key ’:x1) into x1s
count (eq key ’:y1) into y1s
count (eq key ’:x2) into x2s
count (eq key ’:y1) into y2s
count (not (member key ’(:x1 :x2 :y1 :y2)))
into others
finally (return (values x1s y1s x2s y2s others)))
(cond ((and (= n 4)
(eq (key 0) :x1)
(eq (key 1) :y1)
(eq (key 2) :x2)
(eq (key 3) :y2))
‘(distance-positional ,x1 ,y1 ,x2 ,y2))
((and (if x1-p (and (= x1s 1) (simplep x1)) t)
(if y1-p (and (= y1s 1) (simplep y1)) t)
(if x2-p (and (= x2s 1) (simplep x2)) t)
(if y2-p (and (= y2s 1) (simplep y2)) t)
(zerop others))
‘(distance-positional ,x1 ,y1 ,x2 ,y2))
((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)
(zerop others))
(let ((temps (loop repeat n collect (gensym))))
‘(let ,(loop for i below n
collect (list (nth i temps) (arg i)))
(distance
,@(loop for i below n
append (list (key i) (nth i temps)))))))
(t form))))))
!DISTANCE
(dolist (form
’((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))
(distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))
(distance :x1 (setq x 7) :y1 (incf x))
(distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))
(distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)
(distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)
(distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))
(print (funcall (compiler-macro-function ’distance) form nil)))
.(LET ((#:G6558 (SETQ X 7))
3–68 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
. (#:G6559 (DECF X))
. (#:G6560 (DECF X))
. (#:G6561 (DECF X)))
.(DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561))
.(DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X))
.(LET ((#:G6567 (SETQ X 7))
. (#:G6568 (INCF X)))
.(DISTANCE :X1 #:G6567 :Y1 #:G6568))
.(DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X))
.(DISTANCE-POSITIONAL A1 B1 A2 B2)
.(DISTANCE-POSITIONAL A1 B1 A2 B2)
.(DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2)
!NIL
See Also:
compiler-macro-function ,defmacro ,documentation , Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations)
Notes:
The consequences of writing a compiler macro denition for a function in the COMMON-LISP package
are undened; it is quite possible that in some implementations such an attempt would override
an equivalent or equally important denition. In general, it is recommended that a programmer
only write compiler macro denitions for functions he or she personally maintains{writing a
compiler macro denition for a function maintained elsewhere is normally considered a violation of
traditional rules of modularity and data abstraction.
defmacro Macro
Syntax:
defmacro name lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*
!name
Arguments and Values:
name |asymbol .
lambda-list |amacro lambda list .
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
form|aform .
Evaluation and Compilation 3–69
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defmacro
Description:
Denes name as a macro by associating a macro function with that name in the global environment.
The macro function is dened in the same lexical environment in which the defmacro form appears.
The parameter variables in lambda-list are bound to destructured portions of the macro call.
The expansion function accepts two arguments, a form and an environment . The expansion
function returns a form . The body of the expansion function is specied by forms .Forms are
executed in order. The value of the last form executed is returned as the expansion of the macro .
The body forms of the expansion function (but not the lambda-list ) are implicitly enclosed in a
block whose name is name .
The lambda-list conforms to the requirements described in Section 3.4.4 (Macro Lambda Lists).
Documentation is attached as a documentation string toname (as kindfunction ) and to the macro
function .
defmacro can be used to redene a macro or to replace a function denition with a macro
denition.
Recursive expansion of the form returned must terminate, including the expansion of other macros
which are subforms of other forms returned.
The consequences are undened if the result of fully macroexpanding a form contains any circular
list structure except in literal objects .
If adefmacro form appears as a top level form , the compiler must store the macro denition at
compile time, so that occurrences of the macro later on in the le can be expanded correctly. Users
must ensure that the body of the macro can be evaluated at compile time if it is referenced within
thelebeing compiled .
Examples:
(defmacro mac1 (a b) "Mac1 multiplies and adds"
‘(+ ,a (* ,b 3))) !MAC1
(mac1 4 5)!19
(documentation ’mac1 ’function) !"Mac1 multiplies and adds"
(defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) ‘’(,a ,b ,c ,d ,x)) !MAC2
(mac2 6)!(6 T 3 NIL NIL)
(mac2 6 3 8)!(6 T 3 T (8))
(defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))
‘’(,r ,a ,b ,c ,d ,x)) !MAC3
(mac3 1 6 :d 8 :c 9 :d 10) !((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10))
The stipulation that an embedded destructuring lambda list is permitted only where ordinary
lambda list syntax would permit a parameter name but not a listis made to prevent ambiguity.
For example, the following is not valid:
3–70 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defmacro
(defmacro loser (x &optional (a b &rest c) &rest z)
...)
because ordinary lambda list syntax does permit a listfollowing &optional ; the list (a b &rest c)
would be interpreted as describing an optional parameter named awhose default value is that of
the form b, with a supplied-p parameter named &rest (not valid), and an extraneous symbol cin
the list (also not valid). An almost correct way to express this is
(defmacro loser (x &optional ((a b &rest c)) &rest z)
...)
The extra set of parentheses removes the ambiguity. However, the denition is now incorrect
because a macro call such as (loser (car pool)) would not provide any argument form for the
lambda list (a b &rest c) , and so the default value against which to match the lambda list would
benilbecause no explicit default value was specied. The consequences of this are unspecied
since the empty list, nil, does not have forms to satisfy the parameters aandb. The fully correct
denition would be either
(defmacro loser (x &optional ((a b &rest c) ’(nil nil)) &rest z)
...)
or
(defmacro loser (x &optional ((&optional a b &rest c)) &rest z)
...)
These dier slightly: the rst requires that if the macro call species aexplicitly then it must also
specifybexplicitly, whereas the second does not have this requirement. For example,
(loser (car pool) ((+ x 1)))
would be a valid call for the second denition but not for the rst.
(defmacro dm1a (&whole x) ‘’,x)
(macroexpand ’(dm1a)) !(QUOTE (DM1A))
(macroexpand ’(dm1a a)) is an error.
(defmacro dm1b (&whole x a &optional b) ‘’(,x ,a ,b))
(macroexpand ’(dm1b)) is an error.
(macroexpand ’(dm1b q)) !(QUOTE ((DM1B Q) Q NIL))
(macroexpand ’(dm1b q r)) !(QUOTE ((DM1B Q R) Q R))
(macroexpand ’(dm1b q r s)) is an error.
(defmacro dm2a (&whole form a b) ‘’(form ,form a ,a b ,b))
(macroexpand ’(dm2a x y)) !(QUOTE (FORM (DM2A X Y) A X B Y))
(dm2a x y)!(FORM (DM2A X Y) A X B Y)
(defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5))
&body f &environment env)
Evaluation and Compilation 3–71
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
“(,’,form „a ,’,b ,’,(macroexpand c env) ,’,d ,’,e ,’,f))
;Note that because backquote is involved, implementations may differ
;slightly in the nature (though not the functionality) of the expansion.
(macroexpand ’(dm2b x1 (((incf x2) x3 x4)) x5 x6))
!(LIST* ’(DM2B X1 (((INCF X2) X3 X4))
X5 X6)
X1
’((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),
T
(let ((x1 5))
(macrolet ((segundo (x) ‘(cadr ,x)))
(dm2b x1 (((segundo x2) x3 x4)) x5 x6)))
!((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)
5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))
See Also:
deﬁne-compiler-macro ,destructuring-bind ,documentation ,macroexpand ,
*macroexpand-hook* ,macrolet ,macro-function , Section 3.1 (Evaluation), Section 3.2
(Compilation), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)
macro-function Accessor
Syntax:
macro-function symbol&optional environment!function
(setf (macro-function symbol&optional environment )new-function )
Arguments and Values:
symbol |asymbol .
environment |an environment object .
function |amacro function ornil.
new-function |amacro function .
Description:
Determines whether symbol has a function denition as a macro in the specied environment .
3–72 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If so, the macro expansion function, a function of two arguments, is returned. If symbol has
no function denition in the lexical environment environment , or its denition is not a macro ,
macro-function returnsnil.
It is possible for both macro-function andspecial-operator-p to return true ofsymbol . The macro
denition must be available for use by programs that understand only the standard Common Lisp
special forms .
Examples:
(defmacro macfun (x) ’(macro-function ’macfun)) !MACFUN
(not (macro-function ’macfun)) !false
(macrolet ((foo (&environment env)
(if (macro-function ’bar env)
”yes
”no)))
(list (foo)
(macrolet ((bar () :beep))
(foo))))
!(NO YES)
Aﬀected By:
(setf macro-function) ,defmacro , andmacrolet .
Exceptional Situations:
The consequences are undened if environment isnon-nil in a use of setf ofmacro-function .
See Also:
defmacro , Section 3.1 (Evaluation)
Notes:
setf can be used with macro-function to install a macro as a symbol's global function denition:
(setf (macro-function symbol) fn)
The value installed must be a function that accepts two arguments, the entire macro call and an
environment , and computes the expansion for that call. Performing this operation causes symbol
to have only that macro denition as its global function denition; any previous denition, whether
as a macro or as a function , is lost.
Evaluation and Compilation 3–73
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
macroexpand, macroexpand-1
macroexpand,macroexpand-1 Function
Syntax:
macroexpand form&optional env!expansion, expanded-p
macroexpand-1 form&optional env!expansion, expanded-p
Arguments and Values:
form|aform .
env|an environment object . The default is nil.
expansion |aform .
expanded-p |ageneralized boolean .
Description:
macroexpand andmacroexpand-1 expand macros .
Ifform is amacro form , thenmacroexpand-1 expands the macro form call once.
macroexpand repeatedly expands form until it is no longer a macro form . In eect, macroexpand
callsmacroexpand-1 repeatedly until the secondary value it returns is nil.
Ifform is amacro form , then the expansion is amacro expansion and expanded-p istrue. Otherwise,
theexpansion is the given form and expanded-p isfalse.
Macro expansion is carried out as follows. Once macroexpand-1 has determined that the form is
amacro form , it obtains an appropriate expansion function for the macro orsymbol macro . The
value of*macroexpand-hook* is coerced to a function and then called as a function of three
arguments: the expansion function , the form, and the env. The value returned from this call is
taken to be the expansion of the form.
In addition to macro denitions in the global environment, any local macro denitions established
within envbymacrolet orsymbol-macrolet are considered. If only form is supplied as an
argument, then the environment is eectively null, and only global macro denitions as established
bydefmacro are considered. Macro denitions are shadowed by local function denitions.
Examples:
(defmacro alpha (x y) ‘(beta ,x ,y)) !ALPHA
(defmacro beta (x y) ‘(gamma ,x ,y)) !BETA
(defmacro delta (x y) ‘(gamma ,x ,y)) !EPSILON
(defmacro expand (form &environment env)
(multiple-value-bind (expansion expanded-p)
(macroexpand form env)
‘(values ’,expansion ’,expanded-p))) !EXPAND
3–74 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
macroexpand, macroexpand-1
(defmacro expand-1 (form &environment env)
(multiple-value-bind (expansion expanded-p)
(macroexpand-1 form env)
‘(values ’,expansion ’,expanded-p))) !EXPAND-1
;; Simple examples involving just the global environment
(macroexpand-1 ’(alpha a b)) !(BETA A B), true
(expand-1 (alpha a b)) !(BETA A B), true
(macroexpand ’(alpha a b)) !(GAMMA A B), true
(expand (alpha a b)) !(GAMMA A B), true
(macroexpand-1 ’not-a-macro) !NOT-A-MACRO, false
(expand-1 not-a-macro) !NOT-A-MACRO, false
(macroexpand ’(not-a-macro a b)) !(NOT-A-MACRO A B), false
(expand (not-a-macro a b)) !(NOT-A-MACRO A B), false
;; Examples involving lexical environments
(macrolet ((alpha (x y) ‘(delta ,x ,y)))
(macroexpand-1 ’(alpha a b))) !(BETA A B), true
(macrolet ((alpha (x y) ‘(delta ,x ,y)))
(expand-1 (alpha a b))) !(DELTA A B), true
(macrolet ((alpha (x y) ‘(delta ,x ,y)))
(macroexpand ’(alpha a b))) !(GAMMA A B), true
(macrolet ((alpha (x y) ‘(delta ,x ,y)))
(expand (alpha a b))) !(GAMMA A B), true
(macrolet ((beta (x y) ‘(epsilon ,x ,y)))
(expand (alpha a b))) !(EPSILON A B), true
(let ((x (list 1 2 3)))
(symbol-macrolet ((a (first x)))
(expand a)))!(FIRST X), true
(let ((x (list 1 2 3)))
(symbol-macrolet ((a (first x)))
(macroexpand ’a))) !A,false
(symbol-macrolet ((b (alpha x y)))
(expand-1 b))!(ALPHA X Y), true
(symbol-macrolet ((b (alpha x y)))
(expand b))!(GAMMA X Y), true
(symbol-macrolet ((b (alpha x y))
(a b))
(expand-1 a))!B,true
(symbol-macrolet ((b (alpha x y))
(a b))
(expand a))!(GAMMA X Y), true
Evaluation and Compilation 3–75
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;; Examples of shadowing behavior
(flet ((beta (x y) (+ x y)))
(expand (alpha a b))) !(BETA A B), true
(macrolet ((alpha (x y) ‘(delta ,x ,y)))
(flet ((alpha (x y) (+ x y)))
(expand (alpha a b)))) !(ALPHA A B), false
(let ((x (list 1 2 3)))
(symbol-macrolet ((a (first x)))
(let ((a x))
(expand a))))!A,false
Aﬀected By:
defmacro ,setf ofmacro-function ,macrolet ,symbol-macrolet
See Also:
*macroexpand-hook* ,defmacro ,setf ofmacro-function ,macrolet ,symbol-macrolet , Section
3.1 (Evaluation)
Notes:
Neithermacroexpand normacroexpand-1 makes any explicit attempt to expand macro forms
that are either subforms of the form orsubforms of the expansion . Such expansion might occur
implicitly, however, due to the semantics or implementation of the macro function .
deﬁne-symbol-macro Macro
Syntax:
deﬁne-symbol-macro symbol expansion
!symbol
Arguments and Values:
symbol |asymbol .
expansion |aform .
Description:
Provides a mechanism for globally aecting the macro expansion of the indicated symbol .
Globally establishes an expansion function for the symbol macro named by symbol . The only
guaranteed property of an expansion function for a symbol macro is that when it is applied to the
form and the environment it returns the correct expansion. (In particular, it is implementation-
dependent whether the expansion is conceptually stored in the expansion function, the environment ,
or both.)
3–76 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Each global reference to symbol (i.e., not shadowed 2by a binding for a variable orsymbol macro
named by the same symbol ) is expanded by the normal macro expansion process; see Section
3.1.2.1.1 (Symbols as Forms). The expansion of a symbol macro is subject to further macro
expansion in the same lexical environment as the symbol macro reference, exactly analogous to
normal macros .
The consequences are unspecied if a special declaration is made for symbol while in the scope of
this denition ( i.e., when it is not shadowed 2by a binding for a variable orsymbol macro named
by the same symbol ).
Any use of setq to set the value of the symbol while in the scope of this denition is treated as if it
were asetf.psetq ofsymbol is treated as if it were a psetf , andmultiple-value-setq is treated as
if it were a setf ofvalues .
Abinding for a symbol macro can be shadowed 2byletorsymbol-macrolet .
Examples:
(defvar *things* (list ’alpha ’beta ’gamma)) !*THINGS*
(define-symbol-macro thing1 (first *things*)) !THING1
(define-symbol-macro thing2 (second *things*)) !THING2
(define-symbol-macro thing3 (third *things*)) !THING3
thing1!ALPHA
(setq thing1 ’ONE) !ONE
*things*!(ONE BETA GAMMA)
(multiple-value-setq (thing2 thing3) (values ’two ’three)) !TWO
thing3!THREE
*things*!(ONE TWO THREE)
(list thing2 (let ((thing2 2)) thing2)) !(TWO 2)
Exceptional Situations:
Ifsymbol is already dened as a global variable , an error of typeprogram-error is signaled.
See Also:
symbol-macrolet ,macroexpand
Evaluation and Compilation 3–77
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
symbol-macrolet
symbol-macrolet Special Operator
Syntax:
symbol-macrolet (f(symbol expansion )g*)fdeclarationg*fformg*
!f resultg*
Arguments and Values:
symbol |asymbol .
expansion |aform .
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values returned by the forms .
Description:
symbol-macrolet provides a mechanism for aecting the macro expansion environment for symbols .
symbol-macrolet lexically establishes expansion functions for each of the symbol macros named by
symbols . The only guaranteed property of an expansion function for a symbol macro is that when
it is applied to the form and the environment it returns the correct expansion. (In particular, it is
implementation-dependent whether the expansion is conceptually stored in the expansion function,
theenvironment , or both.)
Each reference to symbol as a variable within the lexical scope ofsymbol-macrolet is expanded by
the normal macro expansion process; see Section 3.1.2.1.1 (Symbols as Forms). The expansion of a
symbol macro is subject to further macro expansion in the same lexical environment as the symbol
macro invocation, exactly analogous to normal macros .
Exactly the same declarations are allowed as for letwith one exception: symbol-macrolet signals
an error if a special declaration names one of the symbols being dened by symbol-macrolet .
When the forms of thesymbol-macrolet form are expanded, any use of setq to set the value of
one of the specied variables is treated as if it were a setf.psetq of a symbol dened as a symbol
macro is treated as if it were a psetf , andmultiple-value-setq is treated as if it were a setf of
values .
The use of symbol-macrolet can be shadowed by let. In other words, symbol-macrolet only
substitutes for occurrences of symbol that would be in the scope of a lexical binding of symbol
surrounding the forms .
Examples:
;;; The following is equivalent to
;;; (list ’foo (let ((x ’bar)) x)),
3–78 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;;; not
;;; (list ’foo (let ((’foo ’bar)) ’foo))
(symbol-macrolet ((x ’foo))
(list x (let ((x ’bar)) x)))
!(foo bar)
not!(foo foo)
(symbol-macrolet ((x ’(foo x)))
(list x))
!((FOO X))
Exceptional Situations:
If an attempt is made to bind a symbol that is dened as a global variable , an error of type
program-error is signaled.
Ifdeclaration contains a special declaration that names one of the symbols being bound by
symbol-macrolet , an error of typeprogram-error is signaled.
See Also:
with-slots ,macroexpand
Notes:
The special form symbol-macrolet is the basic mechanism that is used to implement with-slots .
If asymbol-macrolet form is atop level form , the forms are also processed as top level forms . See
Section 3.2.3 (File Compilation).
macroexpand-hook  Variable
Value Type:
adesignator for a function of three arguments : a macro function , amacro form , and an
environment object .
Initial Value:
adesignator for a function that is equivalent to the functionfuncall , but that might have additional
implementation-dependent side-eects.
Description:
Used as the expansion interface hook by macroexpand-1 to control the macro expansion process.
When a macro form is to be expanded, this function is called with three arguments: the macro
function , the macro form , and the environment in which the macro form is to be expanded. The
environment object hasdynamic extent ; the consequences are undened if the environment object
is referred to outside the dynamic extent of the macro expansion function.
Evaluation and Compilation 3–79
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(defun hook (expander form env)
(format t "Now expanding: ~S~%" form)
(funcall expander form env)) !HOOK
(defmacro machook (x y) ‘(/ (+ ,x ,y) 2)) !MACHOOK
(macroexpand ’(machook 1 2)) !(/ (+ 1 2) 2), true
(let ((*macroexpand-hook* #’hook)) (macroexpand ’(machook 1 2)))
.Now expanding (MACHOOK 1 2)
!(/ (+ 1 2) 2), true
See Also:
macroexpand ,macroexpand-1 ,funcall , Section 3.1 (Evaluation)
Notes:
The net eect of the chosen initial value is to just invoke the macro function , giving it the macro
form and environment as its two arguments.
Users or user programs can assign this variable to customize or trace the macro expansion
mechanism. Note, however, that this variable is a global resource, potentially shared by multiple
programs ; as such, if any two programs depend for their correctness on the setting of this variable ,
those programs may not be able to run in the same Lisp image . For this reason, it is frequently
best to conne its uses to debugging situations.
Users who put their own function into *macroexpand-hook* should consider saving the previous
value of the hook, and calling that value from their own.
proclaim Function
Syntax:
proclaim declaration-specier !implementation-dependent
Arguments and Values:
declaration-specier |adeclaration specier .
Description:
Establishes thedeclaration specied by declaration-specier in the global environment .
Such a declaration , sometimes called a global declaration or a proclamation , is always in force
unless locally shadowed .
Names ofvariables and functions within declaration-specier refer to dynamic variables and global
function denitions, respectively.
3–80 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Figure 3{22 shows a list of declaration identiers that can be used with proclaim .
declaration inline optimize type
ftype notinline special
Figure 3–22. Global Declaration Speciﬁers
An implementation is free to support other ( implementation-dened )declaration identiers as well.
Examples:
(defun declare-variable-types-globally (type vars)
(proclaim ‘(type ,type ,@vars))
type)
;; Once this form is executed, the dynamic variable *TOLERANCE*
;; must always contain a float.
(declare-variable-types-globally ’float ’(*tolerance*))
!FLOAT
See Also:
declaim ,declare , Section 3.2 (Compilation)
Notes:
Although the execution of aproclaim form has eects that might aect compilation, the compiler
does not make any attempt to recognize and specially process proclaim forms . A proclamation
such as the following, even if a top level form , does not have any eect until it is executed:
(proclaim ’(special *x*))
If compile time side eects are desired, eval-when may be useful. For example:
(eval-when (:execute :compile-toplevel :load-toplevel)
(proclaim ’(special *x*)))
In most such cases, however, it is preferrable to use declaim for this purpose.
Sinceproclaim forms are ordinary function forms ,macro forms can expand into them.
declaim Macro
Syntax:
declaimfdeclaration-specier g*!implementation-dependent
Evaluation and Compilation 3–81
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments and Values:
declaration-specier |adeclaration specier ; not evaluated.
Description:
Establishes the declarations specied by the declaration-speciers .
If a use of this macro appears as a top level form in a lebeing processed by the le compiler ,
the proclamations are also made at compile-time. As with other dening macros, it is unspecied
whether or not the compile-time side-eects of a declaim persist after the lehas been compiled .
Examples:
See Also:
declare ,proclaim
declare Symbol
Syntax:
declarefdeclaration-specier g*
Arguments:
declaration-specier |adeclaration specier ; not evaluated.
Description:
Adeclare expression , sometimes called a declaration , can occur only at the beginning of the
bodies of certain forms ; that is, it may be preceded only by other declare expressions , or by a
documentation string if the context permits.
Adeclare expression can occur in a lambda expression or in any of the forms listed in Figure 3{23.
3–82 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
declare
defgeneric do-external-symbols prog
deﬁne-compiler-macro do-symbols prog*
deﬁne-method-combination dolist restart-case
deﬁne-setf-expander dotimes symbol-macrolet
defmacro ﬂet with-accessors
defmethod handler-case with-hash-table-iterator
defsetf labels with-input-from-string
deftype let with-open-ﬁle
defun let* with-open-stream
destructuring-bind locally with-output-to-string
do macrolet with-package-iterator
do* multiple-value-bind with-slots
do-all-symbols pprint-logical-block
Figure 3–23. Standardized Forms In Which Declarations Can Occur
Adeclare expression can only occur where specied by the syntax of these forms . The consequences
of attempting to evaluate a declare expression are undened. In situations where such expressions
can appear, explicit checks are made for their presence and they are never actually evaluated; it is
for this reason that they are called \ declare expressions " rather than \ declare forms ."
Macro forms cannot expand into declarations; declare expressions must appear as actual
subexpressions of the form to which they refer.
Figure 3{24 shows a list of declaration identiers that can be used with declare .
dynamic-extent ignore optimize
ftype inline special
ignorable notinline type
Figure 3–24. Local Declaration Speciﬁers
An implementation is free to support other ( implementation-dened )declaration identiers as well.
Examples:
(defun nonsense (k x z)
(foo z x) ;First call to foo
(let ((j (foo k x)) ;Second call to foo
(x (* k k)))
(declare (inline foo) (special x z))
(foo x j z))) ;Third call to foo
In this example, the inline declaration applies only to the third call to foo, but not to the rst
or second ones. The special declaration of xcausesletto make a dynamic binding forx, and
Evaluation and Compilation 3–83
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
causes the reference to xin the body of letto be a dynamic reference. The reference to xin the
second call to foois a local reference to the second parameter of nonsense . The reference to xin
the rst call to foois a local reference, not a special one. The special declaration of zcauses the
reference to zin the third call to footo be a dynamic reference; it does not refer to the parameter
tononsense namedz, because that parameter binding has not been declared to be special . (The
special declaration of zdoes not appear in the body of defun , but in an inner form , and therefore
does not aect the binding of the parameter .)
Exceptional Situations:
The consequences of trying to use a declare expression as a form to be evaluated are undened.
See Also:
proclaim , Section 4.2.3 (Type Speciers), declaration ,dynamic-extent ,ftype ,ignorable ,ignore ,
inline ,notinline ,optimize ,type
ignore,ignorable Declaration
Syntax:
(ignorefvar|(function fn)g*)
(ignorablefvar|(function fn)g*)
Arguments:
var|avariable name .
fn|afunction name .
Valid Context:
declaration
Binding Types Aﬀected:
variable ,function
Description:
Theignore andignorable declarations refer to for-value references tovariable bindings for the
varsand to function bindings for the fns.
Anignore declaration species that for-value references to the indicated bindings will not occur
within the scope of the declaration . Within the scope of such a declaration , it is desirable for a
compiler to issue a warning about the presence of either a for-value reference to any varorfn, or a
special declaration for any var.
3–84 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Anignorable declaration species that for-value references to the indicated bindings might or
might not occur within the scope of the declaration . Within the scope of such a declaration , it is
not desirable for a compiler to issue a warning about the presence or absence of either a for-value
reference to any varorfn, or aspecial declaration for any var.
When not within the scope of aignore orignorable declaration , it is desirable for a compiler
to issue a warning about any varfor which there is neither a for-value reference nor aspecial
declaration , or about any fnfor which there is no for-value reference .
Any warning about a \used" or \unused" binding must be of typestyle-warning , and may not
aect program semantics.
The stream variables established by with-open-ﬁle ,with-open-stream ,with-input-from-string ,
andwith-output-to-string , and all iteration variables are, by denition, always \used". Using
(declare (ignore v)), for such a variable vhas unspecied consequences.
See Also:
declare
dynamic-extent Declaration
Syntax:
(dynamic-extent [ [fvarg*|(function fn)*] ])
Arguments:
var|avariable name .
fn|afunction name .
Valid Context:
declaration
Binding Types Aﬀected:
variable ,function
Description:
In some containing form ,F, this declaration asserts for each vari(which need not be bound by F),
and for each value vijthat varitakes on, and for each object xijkthat is an otherwise inaccessible
part ofvijat any time when vijbecomes the value of vari, that just after the execution of F
terminates, xijkis either inaccessible (ifFestablished a binding forvari) or still an otherwise
inaccessible part of the current value of vari(ifFdid not establish a binding forvari). The same
relation holds for each fni, except that the bindings are in the function namespace .
Evaluation and Compilation 3–85
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
dynamic-extent
The compiler is permitted to use this information in any way that is appropriate to the
implementation and that does not conict with the semantics of Common Lisp.
dynamic-extent declarations can be free declarations orbound declarations .
The varsand fnsnamed in a dynamic-extent declaration must not refer to symbol macro ormacro
bindings.
Examples:
Since stack allocation of the initial value entails knowing at the object 's creation time that the
object can be stack-allocated , it is not generally useful to make a dynamic-extent declaration for
variables which have no lexically apparent initial value. For example, it is probably useful to write:
(defun f ()
(let ((x (list 1 2 3)))
(declare (dynamic-extent x))
...))
This would permit those compilers that wish to do so to stack allocate the list held by the local
variable x. It is permissible, but in practice probably not as useful, to write:
(defun g (x) (declare (dynamic-extent x)) ...)
(defun f () (g (list 1 2 3)))
Most compilers would probably not stack allocate theargument toginfbecause it would
be a modularity violation for the compiler to assume facts about gfrom within f. Only an
implementation that was willing to be responsible for recompiling fif the denition of gchanged
incompatibly could legitimately stack allocate thelistargument to ginf.
Here is another example:
(declaim (inline g))
(defun g (x) (declare (dynamic-extent x)) ...)
(defun f () (g (list 1 2 3)))
(defun f ()
(flet ((g (x) (declare (dynamic-extent x)) ...))
(g (list 1 2 3))))
In the previous example, some compilers might determine that optimization was possible and
others might not.
A variant of this is the so-called \stack allocated rest list" that can be achieved (in implementations
supporting the optimization) by:
(defun f (&rest x)
(declare (dynamic-extent x))
3–86 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
dynamic-extent
...)
Note that although the initial value of xis not explicit, the ffunction is responsible for assembling
the list xfrom the passed arguments, so the ffunction can be optimized by the compiler to
construct a stack-allocated list instead of a heap-allocated list in implementations that support
such.
In the following example,
(let ((x (list ’a1 ’b1 ’c1))
(y (cons ’a2 (cons ’b2 (cons ’c2 nil)))))
(declare (dynamic-extent x y))
...)
The otherwise inaccessible parts ofxare three conses , and the otherwise inaccessible parts ofyare
three other conses . None of the symbols a1,b1,c1,a2,b2,c2, ornilis an otherwise inaccessible
part ofxorybecause each is interned and hence accessible by the package (orpackages ) in which
it is interned . However, if a freshly allocated uninterned symbol had been used, it would have been
anotherwise inaccessible part of the listwhich contained it.
;; In this example, the implementation is permitted to stack allocate
;; the list that is bound to X.
(let ((x (list 1 2 3)))
(declare (dynamic-extent x))
(print x)
:done)
.(1 2 3)
!:DONE
;; In this example, the list to be bound to L can be stack-allocated .
(defun zap (x y z)
(do ((l (list x y z) (cdr l)))
((null l))
(declare (dynamic-extent l))
(prin1 (car l)))) !ZAP
(zap 1 2 3)
.123
!NIL
;; Some implementations might open-code LIST-ALL-PACKAGES in a way
;; that permits using stack allocation of the list to be bound to L.
(do ((l (list-all-packages) (cdr l)))
((null l))
(declare (dynamic-extent l))
(let ((name (package-name (car l))))
(when (string-search "COMMON-LISP" name) (print name))))
."COMMON-LISP"
Evaluation and Compilation 3–87
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
."COMMON-LISP-USER"
!NIL
;; Some implementations might have the ability to stack allocate
;; rest lists. A declaration such as the following should be a cue
;; to such implementations that stack-allocation of the rest list
;; would be desirable.
(defun add (&rest x)
(declare (dynamic-extent x))
(apply #’+ x))!ADD
(add 1 2 3)!6
(defun zap (n m)
;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).
;; It may be slow, but with a good compiler at least it
;; doesn’t waste much heap storage. :-}
(let ((a (make-array n)))
(declare (dynamic-extent a))
(dotimes (i n)
(declare (dynamic-extent i))
(setf (aref a i) (random (+ i 1))))
(aref a m)))!ZAP
(< (zap 5 3) 3) !true
The following are in error, since the value of xis used outside of its extent :
(length (list (let ((x (list 1 2 3))) ; Invalid
(declare (dynamic-extent x))
x)))
(progn (let ((x (list 1 2 3))) ; Invalid
(declare (dynamic-extent x))
x)
nil)
See Also:
declare
Notes:
The most common optimization is to stack allocate the initial value of the objects named by the
vars.
It is permissible for an implementation to simply ignore this declaration.
3–88 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
type
type Declaration
Syntax:
(type typespecfvarg*)
(typespecfvarg*)
Arguments:
typespec |atype specier .
var|avariable name .
Valid Context:
declaration orproclamation
Binding Types Aﬀected:
variable
Description:
Aects only variable bindings and species that the vars take on values only of the specied
typespec . In particular, values assigned to the variables by setq, as well as the initial values of the
vars must be of the specied typespec .type declarations never apply to function bindings (see
ftype ).
A type declaration of a symbol dened by symbol-macrolet is equivalent to wrapping a the
expression around the expansion of that symbol , although the symbol 'smacro expansion is not
actually aected.
The meaning of a type declaration is equivalent to changing each reference to a variable ( var)
within the scope of the declaration to (the typespec var ), changing each expression assigned to
the variable ( new-value ) within the scope of the declaration to (the typespec new-value ), and
executing (the typespec var )at the moment the scope of the declaration is entered.
Atype declaration is valid in all declarations. The interpretation of a type declaration is as follows:
1. During the execution of any reference to the declared variable within the scope of the
declaration, the consequences are undened if the value of the declared variable is not of
the declared type.
2. During the execution of any setq of the declared variable within the scope of the
declaration, the consequences are undened if the newly assigned value of the declared
variable is not of the declared type.
3. At the moment the scope of the declaration is entered, the consequences are undened if
the value of the declared variable is not of the declared type.
Evaluation and Compilation 3–89
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
type
Atype declaration aects only variable references within its scope.
If nested type declarations refer to the same variable, then the value of the variable must be a
member of the intersection of the declared types .
If there is a local type declaration for a dynamic variable, and there is also a global type
proclamation for that same variable, then the value of the variable within the scope of the local
declaration must be a member of the intersection of the two declared types .
type declarations can be free declarations orbound declarations .
Asymbol cannot be both the name of a type and the name of a declaration. Dening a symbol
as the name of a class ,structure ,condition , or type, when the symbol has been declared as a
declaration name, or vice versa, signals an error.
Within the lexical scope of anarray type declaration, all references to array elements are assumed
to satisfy the expressed array element type (as opposed to the upgraded array element type ). A
compiler can treat the code within the scope of the array type declaration as if each access of an
array element were surrounded by an appropriate theform.
Examples:
(defun f (x y)
(declare (type fixnum x y))
(let ((z (+ x y)))
(declare (type fixnum z))
z))!F
(f 1 2)!3
;; The previous definition of F is equivalent to
(defun f (x y)
;; This declaration is a shorthand form of the TYPE declaration
(declare (fixnum x y))
;; To declare the type of a return value, it’s not necessary to
;; create a named variable. A THE special form can be used instead.
(the fixnum (+ x y))) !F
(f 1 2)!3
(defvar *one-array* (make-array 10 :element-type ’(signed-byte 5)))
(defvar *another-array* (make-array 10 :element-type ’(signed-byte 8)))
(defun frob (an-array)
(declare (type (array (signed-byte 5) 1) an-array))
(setf (aref an-array 1) 31)
(setf (aref an-array 2) 127)
(setf (aref an-array 3) (* 2 (aref an-array 3)))
(let ((foo 0))
3–90 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
type
(declare (type (signed-byte 5) foo))
(setf foo (aref an-array 0))))
(frob *one-array*)
(frob *another-array*)
The above denition of frob is equivalent to:
(defun frob (an-array)
(setf (the (signed-byte 5) (aref an-array 1)) 31)
(setf (the (signed-byte 5) (aref an-array 2)) 127)
(setf (the (signed-byte 5) (aref an-array 3))
(* 2 (the (signed-byte 5) (aref an-array 3))))
(let ((foo 0))
(declare (type (signed-byte 5) foo))
(setf foo (the (signed-byte 5) (aref an-array 0)))))
Given an implementation in which xnums are 29 bits but ﬁxnum arrays are upgraded to signed
32-bit arrays , the following could be compiled with all xnum arithmetic:
(defun bump-counters (counters)
(declare (type (array fixnum *) bump-counters))
(dotimes (i (length counters))
(incf (aref counters i))))
See Also:
declare ,declaim ,proclaim
Notes:
(typespecfvarg*)is an abbreviation for (type typespecfvarg*).
Atype declaration for the arguments to a function does not necessarily imply anything
about the type of the result. The following function is not permitted to be compiled using
implementation-dependent xnum -only arithmetic:
(defun f (x y) (declare (fixnum x y)) (+ x y))
To see why, consider (f most-positive-fixnum 1) . Common Lisp denes that Fmust return a
bignum here, rather than signal an error or produce a mathematically incorrect result. If you have
special knowledge such \ xnum overow" cases will not come up, you can declare the result value
to be in the xnum range, enabling some compilers to use more ecient arithmetic:
(defun f (x y)
(declare (fixnum x y))
(the fixnum (+ x y)))
Note, however, that in the three-argument case, because of the possibility of an implicit
Evaluation and Compilation 3–91
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
intermediate value growing too large, the following will not cause implementation-dependent
xnum -only arithmetic to be used:
(defun f (x y)
(declare (fixnum x y z))
(the fixnum (+ x y z)))
To see why, consider (f most-positive-fixnum 1 -1). Although the arguments and the result are
allxnums , an intermediate value is not a xnum . If it is important that implementation-dependent
xnum -only arithmetic be selected in implementations that provide it, consider writing something
like this instead:
(defun f (x y)
(declare (fixnum x y z))
(the fixnum (+ (the fixnum (+ x y)) z)))
inline,notinline Declaration
Syntax:
(inlineffunction-nameg*)
(notinlineffunction-nameg*)
Arguments:
function-name |afunction name .
Valid Context:
declaration orproclamation
Binding Types Aﬀected:
function
Description:
inline species that it is desirable for the compiler to produce inline calls to the functions named
byfunction-names ; that is, the code for a specied function-name should be integrated into the
calling routine, appearing \in line" in place of a procedure call. A compiler is free to ignore this
declaration. inline declarations never apply to variable bindings .
If one of the functions mentioned has a lexically apparent local denition (as made by ﬂet
orlabels ), then the declaration applies to that local denition and not to the global function
denition.
3–92 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
inline, notinline
While no conforming implementation is required to perform inline expansion of user-dened
functions, those implementations that do attempt to recognize the following paradigm:
To dene a function fthat is not inline by default but for which (declare (inline f)) will make f
be locally inlined, the proper denition sequence is:
(declaim (inline f))
(defun f ...)
(declaim (notinline f))
Theinline proclamation preceding the defun form ensures that the compiler has the opportunity
save the information necessary for inline expansion, and the notinline proclamation following the
defun form prevents ffrom being expanded inline everywhere.
notinline species that it is undesirable to compile the functions named by function-names
in-line. A compiler is not free to ignore this declaration; calls to the specied functions must be
implemented as out-of-line subroutine calls.
If one of the functions mentioned has a lexically apparent local denition (as made by ﬂet
orlabels ), then the declaration applies to that local denition and not to the global function
denition.
In the presence of a compiler macro denition for function-name , anotinline declaration prevents
that compiler macro from being used. An inline declaration may be used to encourage use of
compiler macro denitions. inline andnotinline declarations otherwise have no eect when the
lexically visible denition of function-name is amacro denition.
inline andnotinline declarations can be free declarations orbound declarations .inline and
notinline declarations of functions that appear before the body of a ﬂetorlabels form that denes
that function are bound declarations . Such declarations in other contexts are free declarations .
Examples:
;; The globally defined function DISPATCH should be open-coded,
;; if the implementation supports inlining, unless a NOTINLINE
;; declaration overrides this effect.
(declaim (inline dispatch))
(defun dispatch (x) (funcall (get (car x) ’dispatch) x))
;; Here is an example where inlining would be encouraged.
(defun top-level-1 () (dispatch (read-command)))
;; Here is an example where inlining would be prohibited.
(defun top-level-2 ()
(declare (notinline dispatch))
(dispatch (read-command)))
;; Here is an example where inlining would be prohibited.
(declaim (notinline dispatch))
(defun top-level-3 () (dispatch (read-command)))
;; Here is an example where inlining would be encouraged.
Evaluation and Compilation 3–93
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defun top-level-4 ()
(declare (inline dispatch))
(dispatch (read-command)))
See Also:
declare ,declaim ,proclaim
ftype Declaration
Syntax:
(ftype typeffunction-nameg*)
Arguments:
function-name |afunction name .
type|atype specier .
Valid Context:
declaration orproclamation
Binding Types Aﬀected:
function
Description:
Species that the functions named by function-names are of the functional type type. For example:
(declare (ftype (function (integer list) t) ith)
(ftype (function (number) float) sine cosine))
If one of the functions mentioned has a lexically apparent local denition (as made by ﬂet
orlabels ), then the declaration applies to that local denition and not to the global function
denition. ftype declarations never apply to variable bindings (seetype).
The lexically apparent bindings of function-names must not be macro denitions. (This is because
ftype declares the functional denition of each function name to be of a particular subtype of
function , and macros do not denote functions .)
ftype declarations can be free declarations orbound declarations .ftype declarations of functions
that appear before the body of a ﬂetorlabels form that denes that function are bound
declarations . Such declarations in other contexts are free declarations .
See Also:
declare ,declaim ,proclaim
3–94 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
declaration Declaration
Syntax:
(declarationfnameg*)
Arguments:
name |asymbol .
Valid Context:
proclamation only
Description:
Advises the compiler that each name is a valid but potentially non-standard declaration name.
The purpose of this is to tell one compiler not to issue warnings for declarations meant for another
compiler or other program processor.
Examples:
(declaim (declaration author target-language target-machine))
(declaim (target-language ada))
(declaim (target-machine IBM-650))
(defun strangep (x)
(declare (author "Harry Tweeker"))
(member x ’(strange weird odd peculiar)))
See Also:
declaim ,proclaim
optimize Declaration
Syntax:
(optimizefquality| (quality value )g*)
Arguments:
quality |an optimize quality .
value |one of the integers 0,1,2, or3.
Evaluation and Compilation 3–95
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
optimize
Valid Context:
declaration orproclamation
Description:
Advises the compiler that each quality should be given attention according to the specied
corresponding value . Each quality must be a symbol naming an optimize quality ; the names and
meanings of the standard optimize qualities are shown in Figure 3{25.
Name Meaning
compilation-speed speed of the compilation process
debug ease of debugging
safety run-time error checking
space both code size and run-time space
speed speed of the object code
Figure 3–25. Optimize qualities
There may be other, implementation-dened optimize qualities .
Avalue0means that the corresponding quality is totally unimportant, and 3that the quality is
extremely important; 1and2are intermediate values, with 1the neutral value. (quality3)can be
abbreviated to quality .
Note that code which has the optimization (safety 3) , or justsafety , is called safe code .
The consequences are unspecied if a quality appears more than once with dierent values .
Examples:
(defun often-used-subroutine (x y)
(declare (optimize (safety 2)))
(error-check x y)
(hairy-setup x)
(do ((i 0 (+ i 1))
(z x (cdr z)))
((null z))
;; This inner loop really needs to burn.
(declare (optimize speed))
(declare (fixnum i))
))
See Also:
declare ,declaim ,proclaim , Section 3.3.4 (Declaration Scope)
Notes:
Anoptimize declaration never applies to either a variable or a function binding . Anoptimize
3–96 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
declaration can only be a free declaration . For more information, see Section 3.3.4 (Declaration
Scope).
special Declaration
Syntax:
(specialfvarg*)
Arguments:
var|asymbol .
Valid Context:
declaration orproclamation
Binding Types Aﬀected:
variable
Description:
Species that all of the varsnamed are dynamic. This specier aects variable bindings and aects
references. All variable bindings aected are made to be dynamic bindings , and aected variable
references refer to the current dynamic binding . For example:
(defun hack (thing *mod*) ;The binding of the parameter
(declare (special *mod*)) ; *mod* is visible to hack1,
(hack1 (car thing))) ; but not that of thing.
(defun hack1 (arg)
(declare (special *mod*)) ;Declare references to *mod*
;within hack1 to be special.
(if (atom arg) *mod*
(cons (hack1 (car arg)) (hack1 (cdr arg)))))
Aspecial declaration does not aect inner bindings of a var; the inner bindings implicitly shadow
aspecial declaration and must be explicitly re-declared to be special .special declarations never
apply to function bindings .
special declarations can be either bound declarations , aecting both a binding and references, or
free declarations , aecting only references, depending on whether the declaration is attached to a
variable binding.
When used in a proclamation , aspecial declaration specier applies to all bindings as well as to all
references of the mentioned variables. For example, after
(declaim (special x))
Evaluation and Compilation 3–97
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
special
then in a function denition such as
(defun example (x) ...)
the parameter xis bound as a dynamic variable rather than as a lexical variable.
Examples:
(defun declare-eg (y) ;this y is special
(declare (special y))
(let ((y t)) ;this y is lexical
(list y
(locally (declare (special y)) y)))) ;this y refers to the
;special binding of y
!DECLARE-EG
(declare-eg nil) !(T NIL)
(setf (symbol-value ’x) 6)
(defun foo (x) ;a lexical binding of x
(print x)
(let ((x (1+ x))) ;a special binding of x
(declare (special x)) ;and a lexical reference
(bar))
(1+ x))
(defun bar ()
(print (locally (declare (special x))
x)))
(foo 10)
.10
.11
!11
(setf (symbol-value ’x) 6)
(defun bar (x y) ;[1] 1st occurrence of x
(let ((old-x x) ;[2] 2nd occurrence of x – same as 1st occurrence
(x y)) ;[3] 3rd occurrence of x
(declare (special x))
(list old-x x)))
(bar ’first ’second) !(FIRST SECOND)
(defun few (x &optional (y *foo*))
(declare (special *foo*))
...)
The reference to *foo* in the rst line of this example is not special even though there is a special
declaration in the second line.
(declaim (special prosp)) !implementation-dependent
3–98 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setq prosp 1 reg 1) !1
(let ((prosp 2) (reg 2)) ;the binding of prosp is special
(set ’prosp 3) (set ’reg 3) ;due to the preceding proclamation,
(list prosp reg)) ;whereas the variable reg is lexical
!(3 2)
(list prosp reg) !(1 3)
(declaim (special x)) ;x is always special.
(defun example (x y)
(declare (special y))
(let ((y 3) (x (* x 2)))
(print (+ y (locally (declare (special y)) y)))
(let ((y 4)) (declare (special y)) (foo x)))) !EXAMPLE
In the contorted code above, the outermost and innermost bindings ofyare dynamic, but the
middle binding is lexical. The two arguments to +are dierent, one being the value, which is 3, of
the lexical variable y, and the other being the value of the dynamic variable named y(abinding of
which happens, coincidentally, to lexically surround it at an outer level). All the bindings ofxand
references to xare dynamic, however, because of the proclamation that xis always special .
See Also:
defparameter ,defvar
locally Special Operator
Syntax:
locallyfdeclarationg*fformg*!f resultg*
Arguments and Values:
Declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values of the forms .
Description:
Sequentially evaluates a body of forms in a lexical environment where the given declarations have
eect.
Examples:
(defun sample-function (y) ;this y is regarded as special
(declare (special y))
Evaluation and Compilation 3–99
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(let ((y t)) ;this y is regarded as lexical
(list y
(locally (declare (special y))
;; this next y is regarded as special
y))))
!SAMPLE-FUNCTION
(sample-function nil) !(T NIL)
(setq x ’(1 2 3) y ’(4 . 5)) !(4 . 5)
;;; The following declarations are not notably useful in specific.
;;; They just offer a sample of valid declaration syntax using LOCALLY.
(locally (declare (inline floor) (notinline car cdr))
(declare (optimize space))
(floor (car x) (cdr y))) !0, 1
;;; This example shows a definition of a function that has a particular set
;;; of OPTIMIZE settings made locally to that definition.
(locally (declare (optimize (safety 3) (space 3) (speed 0)))
(defun frob (w x y &optional (z (foo x y)))
(mumble x y z w)))
!FROB
;;; This is like the previous example, except that the optimize settings
;;; remain in effect for subsequent definitions in the same compilation unit.
(declaim (optimize (safety 3) (space 3) (speed 0)))
(defun frob (w x y &optional (z (foo x y)))
(mumble x y z w))
!FROB
See Also:
declare
Notes:
Thespecial declaration may be used with locally to aect references to, rather than bindings of,
variables .
If alocally form is a top level form , the body forms are also processed as top level forms . See
Section 3.2.3 (File Compilation).
3–100 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
the
the Special Operator
Syntax:
the value-type form !f resultg*
Arguments and Values:
value-type |atype specier ; not evaluated.
form|aform ; evaluated.
results |the values resulting from the evaluation ofform. These values must conform to the type
supplied by value-type ; see below.
Description:
thespecies that the values 1areturned by form are of the types specied by value-type . The
consequences are undened if any result is not of the declared type.
It is permissible for form toyield a dierent number of values than are specied by value-type ,
provided that the values for which types are declared are indeed of those types . Missing values are
treated as nilfor the purposes of checking their types .
Regardless of number of values declared by value-type , the number of values returned by the the
special form is the same as the number of values returned by form.
Examples:
(the symbol (car (list (gensym)))) !#:G9876
(the fixnum (+ 5 7)) !12
(the (values) (truncate 3.2 2)) !1, 1.2
(the integer (truncate 3.2 2)) !1, 1.2
(the (values integer) (truncate 3.2 2)) !1, 1.2
(the (values integer float) (truncate 3.2 2)) !1, 1.2
(the (values integer float symbol) (truncate 3.2 2)) !1, 1.2
(the (values integer float symbol t null list)
(truncate 3.2 2)) !1, 1.2
(let ((i 100))
(declare (fixnum i))
(the fixnum (1+ i))) !101
(let* ((x (list ’a ’b ’c))
(y 5))
(setf (the fixnum (car x)) y)
x)!(5 B C)
Evaluation and Compilation 3–101
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
The consequences are undened if the values yielded by the form are not of the type specied by
value-type .
See Also:
values
Notes:
Thevalues type specier can be used to indicate the types of multiple values :
(the (values integer integer) (floor x y))
(the (values string t)
(gethash the-key the-string-table))
setf can be used with thetype declarations. In this case the declaration is transferred to the form
that species the new value. The resulting setf form is then analyzed.
special-operator-p Function
Syntax:
special-operator-p symbol!generalized-boolean
Arguments and Values:
symbol |asymbol .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifsymbol is aspecial operator ; otherwise, returns false.
Examples:
(special-operator-p ’if) !true
(special-operator-p ’car) !false
(special-operator-p ’one) !false
Exceptional Situations:
Should signal type-error if its argument is not a symbol .
Notes:
Historically, this function was called special-form-p . The name was nally declared a misnomer
and changed, since it returned true for special operators , not special forms .
3–102 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
constantp
constantp Function
Syntax:
constantp form&optional environment!generalized-boolean
Arguments and Values:
form|aform .
environment |an environment object . The default is nil.
generalized-boolean |ageneralized boolean .
Description:
Returns true ifform can be determined by the implementation to be a constant form in the
indicated environment ; otherwise, it returns false indicating either that the form is not a constant
form or that it cannot be determined whether or not form is aconstant form .
The following kinds of forms are considered constant forms :
Self-evaluating objects (such as numbers ,characters , and the various kinds of arrays ) are
always considered constant forms and must be recognized as such by constantp .
Constant variables , such as keywords , symbols dened by Common Lisp as constant (such
asnil,t, andpi), and symbols declared as constant by the user in the indicated environment
usingdefconstant are always considered constant forms and must be recognized as such
byconstantp .
quote forms are always considered constant forms and must be recognized as such by
constantp .
Animplementation is permitted, but not required, to detect additional constant forms .
If it does, it is also permitted, but not required, to make use of information in the
environment . Examples of constant forms for which constantp might or might not return
true are:(sqrt pi) ,(+ 3 2) ,(length ’(a b c)) , and(let ((x 7)) (zerop x)) .
If an implementation chooses to make use of the environment information, such actions as expanding
macros or performing function inlining are permitted to be used, but not required; however,
expanding compiler macros is not permitted.
Examples:
(constantp 1)!true
(constantp ’temp) !false
(constantp ”temp)) !true
(defconstant this-is-a-constant ’never-changing) !THIS-IS-A-CONSTANT
Evaluation and Compilation 3–103
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
constantp
(constantp ’this-is-a-constant) !true
(constantp "temp") !true
(setq a 6)!6
(constantp a)!true
(constantp ’(sin pi)) !implementation-dependent
(constantp ’(car ’(x))) !implementation-dependent
(constantp ’(eql x x)) !implementation-dependent
(constantp ’(typep x ’nil)) !implementation-dependent
(constantp ’(typep x ’t)) !implementation-dependent
(constantp ’(values this-is-a-constant)) !implementation-dependent
(constantp ’(values ’x ’y)) !implementation-dependent
(constantp ’(let ((a ’(a b c))) (+ (length a) 6))) !implementation-dependent
Aﬀected By:
The state of the global environment ( e.g., which symbols have been declared to be the names of
constant variables ).
See Also:
defconstant
3–104 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
4. Types and Classes
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Types and Classes iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4.1 Introduction
Atype is a (possibly innite) set of objects . An object can belong to more than one type.Types are
never explicitly represented as objects by Common Lisp. Instead, they are referred to indirectly by
the use of type speciers , which are objects that denote types .
New types can be dened using deftype ,defstruct ,defclass , anddeﬁne-condition .
The function typep , a set membership test, is used to determine whether a given object is of a
given type. The function subtypep , a subset test, is used to determine whether a given type is a
subtype of another given type. The function type-of returns a particular type to which a given
object belongs, even though that object must belong to one or more other types as well. (For
example, every object is of typet, buttype-of always returns a type specier for a type more
specic than t.)
Objects , not variables , have types . Normally, any variable can have any object as its value . It is
possible to declare that a variable takes on only values of a given type by making an explicit type
declaration .Types are arranged in a directed acyclic graph, except for the presence of equivalences.
Declarations can be made about types usingdeclare ,proclaim ,declaim , orthe. For more
information about declarations , see Section 3.3 (Declarations).
Among the fundamental objects of the object system are classes . Aclass determines the structure
and behavior of a set of other objects , which are called its instances . Every object is a direct
instance of a class . The class of an object determines the set of operations that can be performed
on the object . For more information, see Section 4.3 (Classes).
It is possible to write functions that have behavior specialized to the class of the objects which are
their arguments . For more information, see Section 7.6 (Generic Functions and Methods).
The class of the class of an object is called its metaclass . For more information about metaclasses ,
see Section 7.4 (Meta-Objects).
Types and Classes 4–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4.2 Types
4.2.1 Data Type Deﬁnition
Information about type usage is located in the sections specied in Figure 4{1. Figure 4{7 lists
some classes that are particularly relevant to the object system. Figure 9{1 lists the dened
condition types .
Section Data Type
Section 4.3 (Classes) Object System types
Section 7.5 (Slots) Object System types
Chapter 7 (Objects) Object System types
Section 7.6 (Generic Functions and Methods) Object System types
Section 9.1 (Condition System Concepts) Condition System types
Chapter 4 (Types and Classes) Miscellaneous types
Chapter 2 (Syntax) All types|read and print syntax
Section 22.1 (The Lisp Printer) All types|print syntax
Section 3.2 (Compilation) All types|compilation issues
Figure 4–1. Cross-References to Data Type Information
4.2.2 Type Relationships
The typescons,symbol ,array ,number ,character ,hash-table ,function ,readtable ,
package ,pathname ,stream ,random-state ,condition ,restart , and any single other type
created by defstruct ,deﬁne-condition , ordefclass arepairwise disjoint , except for type
relations explicitly established by specifying superclasses indefclass ordeﬁne-condition
or the:include option of destruct .
Any two types created by defstruct aredisjoint unless one is a supertype of the other by
virtue of the defstruct :include option.
Any two distinct classes created by defclass ordeﬁne-condition aredisjoint unless they
have a common subclass or one class is asubclass of the other.
An implementation may be extended to add other subtype relationships between the
specied types , as long as they do not violate the type relationships and disjointness
requirements specied here. An implementation may dene additional types that are
subtypes orsupertypes of any specied types , as long as each additional type is asubtype of
typetand a supertype oftypeniland the disjointness requirements are not violated.
4–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
At the discretion of the implementation, either standard-object orstructure-object might
appear in any class precedence list for a system class that does not already specify either
standard-object orstructure-object . If it does, it must precede the classtand follow all
other standardized classes .
4.2.3 Type Speciﬁers
Type speciers can be symbols ,classes , or lists. Figure 4{2 lists symbols that are standardized
atomic type speciers , and Figure 4{3 lists standardized compound type specier names . For
syntax information, see the dictionary entry for the corresponding type specier . It is possible to
dene new type speciers usingdefclass ,deﬁne-condition ,defstruct , ordeftype .
Types and Classes 4–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
arithmetic-error function simple-condition
array generic-function simple-error
atom hash-table simple-string
base-char integer simple-type-error
base-string keyword simple-vector
bignum list simple-warning
bit logical-pathname single-ﬂoat
bit-vector long-ﬂoat standard-char
broadcast-stream method standard-class
built-in-class method-combination standard-generic-function
cell-error nil standard-method
character null standard-object
class number storage-condition
compiled-function package stream
complex package-error stream-error
concatenated-stream parse-error string
condition pathname string-stream
cons print-not-readable structure-class
control-error program-error structure-object
division-by-zero random-state style-warning
double-ﬂoat ratio symbol
echo-stream rational synonym-stream
end-of-ﬁle reader-error t
error readtable two-way-stream
extended-char real type-error
ﬁle-error restart unbound-slot
ﬁle-stream sequence unbound-variable
ﬁxnum serious-condition undeﬁned-function
ﬂoat short-ﬂoat unsigned-byte
ﬂoating-point-inexact signed-byte vector
ﬂoating-point-invalid-operation simple-array warning
ﬂoating-point-overﬂow simple-base-string
ﬂoating-point-underﬂow simple-bit-vector
Figure 4–2. Standardized Atomic Type Speciﬁers
If atype specier is alist, the carof the listis asymbol , and the rest of the listis subsidiary type
information. Such a type specier is called a compound type specier . Except as explicitly
stated otherwise, the subsidiary items can be unspecied. The unspecied subsidiary items are
indicated by writing *. For example, to completely specify a vector , the type of the elements and
the length of the vector must be present.
(vector double-float 100)
The following leaves the length unspecied:
4–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(vector double-float *)
The following leaves the element type unspecied:
(vector * 100)
Suppose that two type speciers are the same except that the rst has a *where the second has a
more explicit specication. Then the second denotes a subtype of the type denoted by the rst.
If alisthas one or more unspecied items at the end, those items can be dropped. If dropping all
occurrences of *results in a singleton list , then the parentheses can be dropped as well (the list can
be replaced by the symbol in its car). For example, (vector double-float *) can be abbreviated
to(vector double-float) , and(vector * *) can be abbreviated to (vector) and then to vector .
and long-ﬂoat simple-base-string
array member simple-bit-vector
base-string mod simple-string
bit-vector not simple-vector
complex or single-ﬂoat
cons rational string
double-ﬂoat real unsigned-byte
eql satisﬁes values
ﬂoat short-ﬂoat vector
function signed-byte
integer simple-array
Figure 4–3. Standardized Compound Type Speciﬁer Names
Figure 4{4 show the dened names that can be used as compound type specier names but that
cannot be used as atomic type speciers .
and mod satisﬁes
eql not values
member or
Figure 4–4. Standardized Compound-Only Type Speciﬁer Names
New type speciers can come into existence in two ways.
Dening a structure by using defstruct without using the :type specier or dening a class
by using defclass ordeﬁne-condition automatically causes the name of the structure or
class to be a new type specier symbol .
deftype can be used to dene derived type speciers , which act as `abbreviations' for
other type speciers .
Aclass object can be used as a type specier . When used this way, it denotes the set of all members
Types and Classes 4–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
of that class .
Figure 4{5 shows some dened names relating to types and declarations .
coerce defstruct subtypep
declaim deftype the
declare ftype type
defclass locally type-of
deﬁne-condition proclaim typep
Figure 4–5. Deﬁned names relating to types and declarations.
Figure 4{6 shows all dened names that are type specier names , whether for atomic type speciers
orcompound type speciers ; this list is the union of the lists in Figure 4{2 and Figure 4{3.
4–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
and function simple-array
arithmetic-error generic-function simple-base-string
array hash-table simple-bit-vector
atom integer simple-condition
base-char keyword simple-error
base-string list simple-string
bignum logical-pathname simple-type-error
bit long-ﬂoat simple-vector
bit-vector member simple-warning
broadcast-stream method single-ﬂoat
built-in-class method-combination standard-char
cell-error mod standard-class
character nil standard-generic-function
class not standard-method
compiled-function null standard-object
complex number storage-condition
concatenated-stream or stream
condition package stream-error
cons package-error string
control-error parse-error string-stream
division-by-zero pathname structure-class
double-ﬂoat print-not-readable structure-object
echo-stream program-error style-warning
end-of-ﬁle random-state symbol
eql ratio synonym-stream
error rational t
extended-char reader-error two-way-stream
ﬁle-error readtable type-error
ﬁle-stream real unbound-slot
ﬁxnum restart unbound-variable
ﬂoat satisﬁes undeﬁned-function
ﬂoating-point-inexact sequence unsigned-byte
ﬂoating-point-invalid-operation serious-condition values
ﬂoating-point-overﬂow short-ﬂoat vector
ﬂoating-point-underﬂow signed-byte warning
Figure 4–6. Standardized Type Speciﬁer Names
Types and Classes 4–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4.3 Classes
While the object system is general enough to describe all standardized classes (including, for
example, number ,hash-table , andsymbol ), Figure 4{7 contains a list of classes that are especially
relevant to understanding the object system.
built-in-class method-combination standard-object
class standard-class structure-class
generic-function standard-generic-function structure-object
method standard-method
Figure 4–7. Object System Classes
4.3.1 Introduction to Classes
Aclass is an object that determines the structure and behavior of a set of other objects , which are
called its instances .
Aclass can inherit structure and behavior from other classes . A class whose denition refers
to other classes for the purpose of inheriting from them is said to be a subclass of each of those
classes . The classes that are designated for purposes of inheritance are said to be superclasses of
the inheriting class .
Aclass can have a name . The functionclass-name takes a class object and returns its name . The
name of an anonymous class isnil. Asymbol canname aclass . The function ﬁnd-class takes a
symbol and returns the class that the symbol names. A class has a proper name if the name is a
symbol and if the name of the class names that class . That is, a classChas the proper name S
ifS=(class-name C)andC=(find-class S). Notice that it is possible for (find-class S1)=
(find-class S2)andS16=S2. IfC=(find-class S), we say that Cis the class named S.
AclassC1is adirect superclass of a classC2ifC2explicitly designates C1as a superclass in its
denition. In this case C2is adirect subclass ofC1. AclassCnis asuperclass of a classC1if
there exists a series of classesC2;:::;C n 1such thatCi+1is adirect superclass ofCifor1i<n.
In this case, C1is asubclass ofCn. Aclass is considered neither a superclass nor a subclass of
itself. That is, if C1is asuperclass ofC2, thenC16=C2. The set of classes consisting of some given
classCalong with all of its superclasses is called \Cand its superclasses."
Each class has a class precedence list , which is a total ordering on the set of the given class and
itssuperclasses . The total ordering is expressed as a list ordered from most specic to least specic.
The class precedence list is used in several ways. In general, more specic classes canshadow 1
features that would otherwise be inherited from less specic classes . The method selection and
combination process uses the class precedence list to order methods from most specic to least
specic.
When a class is dened, the order in which its direct superclasses are mentioned in the dening
4–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
form is important. Each class has a local precedence order , which is a listconsisting of the
class followed by its direct superclasses in the order mentioned in the dening form .
Aclass precedence list is always consistent with the local precedence order of each class in the
list. The classes in each local precedence order appear within the class precedence list in the same
order. If the local precedence orders are inconsistent with each other, no class precedence list can
be constructed, and an error is signaled. The class precedence list and its computation is discussed
in Section 4.3.5 (Determining the Class Precedence List).
classes are organized into a directed acyclic graph. There are two distinguished classes , named
tandstandard-object . The class namedthas no superclasses . It is a superclass of every class
except itself. The class namedstandard-object is an instance of the classstandard-class and is a
superclass of every class that is an instance of the classstandard-class except itself.
There is a mapping from the object system class space into the type space. Many of the standard
types specied in this document have a corresponding class that has the same name as the type.
Some types do not have a corresponding class . The integration of the type and class systems is
discussed in Section 4.3.7 (Integrating Types and Classes).
Classes are represented by objects that are themselves instances ofclasses . The class of the class
of an object is termed the metaclass of that object . When no misinterpretation is possible, the
term metaclass is used to refer to a class that has instances that are themselves classes . The
metaclass determines the form of inheritance used by the classes that are its instances and the
representation of the instances of those classes . The object system provides a default metaclass ,
standard-class , that is appropriate for most programs.
Except where otherwise specied, all classes mentioned in this standard are instances of the class
standard-class , all generic functions areinstances of the classstandard-generic-function , and all
methods areinstances of the classstandard-method .
4.3.1.1 Standard Metaclasses
The object system provides a number of predened metaclasses . These include the classes
standard-class ,built-in-class , andstructure-class :
The classstandard-class is the default class ofclasses dened by defclass .
The classbuilt-in-class is the class whose instances areclasses that have special
implementations with restricted capabilities. Any class that corresponds to a standard type
might be an instance ofbuilt-in-class . The predened type speciers that are required
to have corresponding classes are listed in Figure 4{8. It is implementation-dependent
whether each of these classes is implemented as a built-in class .
Allclasses dened by means of defstruct areinstances of the classstructure-class .
Types and Classes 4–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4.3.2 Deﬁning Classes
The macro defclass is used to dene a new named class .
The denition of a class includes:
The name of the new class . For newly-dened classes this name is aproper name .
The list of the direct superclasses of the new class .
A set of slot speciers . Each slot specier includes the name of the slotand zero or more
slotoptions. A slotoption pertains only to a single slot. If a class denition contains two
slot speciers with the same name , an error is signaled.
A set of class options. Each class option pertains to the class as a whole.
The slotoptions and class options of the defclass form provide mechanisms for the following:
Supplying a default initial value form for a given slot.
Requesting that methods forgeneric functions be automatically generated for reading or
writing slots.
Controlling whether a given slotis shared by all instances of the class or whether each
instance of the class has its own slot.
Supplying a set of initialization arguments and initialization argument defaults to be used
ininstance creation.
Indicating that the metaclass is to be other than the default. The :metaclass option is
reserved for future use; an implementation can be extended to make use of the :metaclass
option.
Indicating the expected type for the value stored in the slot.
Indicating the documentation string for the slot.
4–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4.3.3 Creating Instances of Classes
The generic function make-instance creates and returns a new instance of a class . The object
system provides several mechanisms for specifying how a new instance is to be initialized. For
example, it is possible to specify the initial values for slots in newly created instances either by
giving arguments to make-instance or by providing default initial values. Further initialization
activities can be performed by methods written for generic functions that are part of the
initialization protocol. The complete initialization protocol is described in Section 7.1 (Object
Creation and Initialization).
4.3.4 Inheritance
Aclass can inherit methods ,slots, and some defclass options from its superclasses . Other sections
describe the inheritance of methods , the inheritance of slots and slotoptions, and the inheritance
ofclass options.
4.3.4.1 Examples of Inheritance
(defclass C1 ()
((S1 :initform 5.4 :type number)
(S2 :allocation :class)))
(defclass C2 (C1)
((S1 :initform 5 :type integer)
(S2 :allocation :instance)
(S3 :accessor C2-S3)))
Instances of the class C1have a local slot namedS1, whose default initial value is 5.4 and whose
value should always be a number . The class C1also has a shared slot namedS2.
There is a local slot namedS1ininstances ofC2. The default initial value of S1is 5. The value of
S1should always be of type (and integer number) . There are also local slots namedS2andS3in
instances ofC2. The class C2has a method forC2-S3 for reading the value of slot S3; there is also a
method for(setf C2-S3) that writes the value of S3.
4.3.4.2 Inheritance of Class Options
The:default-initargs class option is inherited. The set of defaulted initialization arguments for
aclass is the union of the sets of initialization arguments supplied in the :default-initargs class
options of the class and its superclasses . When more than one default initial value form is supplied
for a given initialization argument, the default initial value form that is used is the one supplied
by the class that is most specic according to the class precedence list .
If a given :default-initargs class option species an initialization argument of the same name
more than once, an error of typeprogram-error is signaled.
Types and Classes 4–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4.3.5 Determining the Class Precedence List
Thedefclass form for a class provides a total ordering on that class and its direct superclasses .
This ordering is called the local precedence order . It is an ordered list of the class and its direct
superclasses . The class precedence list for a classCis a total ordering on Cand its superclasses
that is consistent with the local precedence orders for each of Cand its superclasses .
Aclass precedes its direct superclasses , and a direct superclass precedes all other direct superclasses
specied to its right in the superclasses list of the defclass form. For every class C, dene
RC=f(C;C 1);(C1;C2);:::; (Cn 1;Cn)g
whereC1;:::;C nare the direct superclasses ofCin the order in which they are mentioned in
thedefclass form. These ordered pairs generate the total ordering on the class Cand its direct
superclasses .
LetSCbe the set of Cand its superclasses . LetRbe
R=[
c2SCRc
.
The setRmight or might not generate a partial ordering, depending on whether the Rc,c2SC,
are consistent; it is assumed that they are consistent and that Rgenerates a partial ordering.
When theRcare not consistent, it is said that Ris inconsistent.
To compute the class precedence list forC, topologically sort the elements of SCwith respect to
the partial ordering generated by R. When the topological sort must select a class from a set of two
or more classes , none of which are preceded by other classes with respect to R, the class selected
is chosen deterministically, as described below.
IfRis inconsistent, an error is signaled.
4.3.5.1 Topological Sorting
Topological sorting proceeds by nding a class CinSCsuch that no other class precedes that
element according to the elements in R. The class Cis placed rst in the result. Remove Cfrom
SC, and remove all pairs of the form (C;D),D2SC, fromR. Repeat the process, adding classes
with no predecessors to the end of the result. Stop when no element can be found that has no
predecessor.
IfSCis not empty and the process has stopped, the set Ris inconsistent. If every class in the
nite set of classes is preceded by another, then Rcontains a loop. That is, there is a chain of
classesC1;:::;C nsuch thatCiprecedesCi+1,1i<n, andCnprecedesC1.
Sometimes there are several classes fromSCwith no predecessors. In this case select the one that
has a direct subclass rightmost in the class precedence list computed so far. (If there is no such
candidate class ,Rdoes not generate a partial ordering|the Rc,c2SC, are inconsistent.)
4–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
In more precise terms, let fN1;:::;N mg,m2, be the classes fromSCwith no predecessors. Let
(C1:::C n),n1, be the class precedence list constructed so far. C1is the most specic class ,
andCnis the least specic. Let 1jnbe the largest number such that there exists an iwhere
1imandNiis a direct superclass ofCj;Niis placed next.
The eect of this rule for selecting from a set of classes with no predecessors is that the classes
in a simple superclass chain are adjacent in the class precedence list and that classes in each
relatively separated subgraph are adjacent in the class precedence list . For example, let T1and
T2be subgraphs whose only element in common is the class J. Suppose that no superclass of J
appears in either T1orT2, and that Jis in the superclass chain of every class in both T1and
T2. LetC1be the bottom of T1; and letC2be the bottom of T2. SupposeCis a class whose
direct superclasses areC1andC2in that order, then the class precedence list forCstarts with C
and is followed by all classes inT1exceptJ. All the classes ofT2are next. The classJand its
superclasses appear last.
4.3.5.2 Examples of Class Precedence List Determination
This example determines a class precedence list for the class pie. The following classes are dened:
(defclass pie (apple cinnamon) ())
(defclass apple (fruit) ())
(defclass cinnamon (spice) ())
(defclass fruit (food) ())
(defclass spice (food) ())
(defclass food () ())
The setSpie=fpie, apple, cinnamon, fruit, spice, food, standard-object, t g. The setR=
f(pie, apple), (apple, cinnamon), (apple, fruit), (cinnamon, spice),
(fruit, food), (spice, food), (food, standard-object), (standard-object, t) g.
The class pieis not preceded by anything, so it comes rst; the result so far is (pie) . Remove
piefromSand pairs mentioning piefromRto getS=fapple, cinnamon, fruit, spice, food,
standard-object, t gandR=f(apple, cinnamon), (apple, fruit), (cinnamon, spice),
(fruit, food), (spice, food), (food, standard-object), (standard-object, t) g.
The class apple is not preceded by anything, so it is next; the result is (pie apple) . Removing
apple and the relevant pairs results in S=fcinnamon, fruit, spice, food, standard-object, t g
andR=f(cinnamon, spice), (fruit, food), (spice, food), (food, standard-object),
(standard-object, t) g.
The classes cinnamon andfruit are not preceded by anything, so the one with a direct subclass
rightmost in the class precedence list computed so far goes next. The class apple is a direct subclass
Types and Classes 4–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
offruit , and the class pieis a direct subclass ofcinnamon . Because apple appears to the right of
piein the class precedence list ,fruit goes next, and the result so far is (pie apple fruit) .S=
fcinnamon, spice, food, standard-object, t g;R=f(cinnamon, spice), (spice, food),
(food, standard-object), (standard-object, t) g.
The class cinnamon is next, giving the result so far as (pie apple fruit cinnamon) . At this
pointS=fspice, food, standard-object, t g;R=f(spice, food), (food, standard-object),
(standard-object, t) g.
The classes spice ,food,standard-object , andtare added in that order, and the class precedence
listis(pie apple fruit cinnamon spice food standard-object t) .
It is possible to write a set of class denitions that cannot be ordered. For example:
(defclass new-class (fruit apple) ())
(defclass apple (fruit) ())
The class fruit must precede apple because the local ordering of superclasses must be preserved.
The class apple must precede fruit because a class always precedes its own superclasses . When
this situation occurs, an error is signaled, as happens here when the system tries to compute the
class precedence list ofnew-class .
The following might appear to be a conicting set of denitions:
(defclass pie (apple cinnamon) ())
(defclass pastry (cinnamon apple) ())
(defclass apple () ())
(defclass cinnamon () ())
The class precedence list forpieis(pie apple cinnamon standard-object t) .
The class precedence list forpastry is(pastry cinnamon apple standard-object t) .
It is not a problem for apple to precede cinnamon in the ordering of the superclasses ofpiebut not
in the ordering for pastry . However, it is not possible to build a new class that has both pieand
pastry assuperclasses .
4.3.6 Redeﬁning Classes
Aclass that is a direct instance ofstandard-class can be redened if the new class is also a direct
instance ofstandard-class . Redening a class modies the existing class object to reect the new
class denition; it does not create a new class object for the class . Any method object created
by a:reader ,:writer , or:accessor option specied by the old defclass form is removed from the
corresponding generic function .Methods specied by the new defclass form are added.
4–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
When the class Cis redened, changes are propagated to its instances and to instances of any of
itssubclasses . Updating such an instance occurs at an implementation-dependent time, but no
later than the next time a slotof that instance is read or written. Updating an instance does not
change its identity as dened by the function eq. The updating process may change the slots of
that particular instance , but it does not create a new instance . Whether updating an instance
consumes storage is implementation-dependent .
Note that redening a class may cause slots to be added or deleted. If a class is redened in a
way that changes the set of local slots accessible ininstances , the instances are updated. It is
implementation-dependent whether instances are updated if a class is redened in a way that does
not change the set of local slots accessible ininstances .
The value of a slotthat is specied as shared both in the old class and in the new class is retained.
If such a shared slot was unbound in the old class , it is unbound in the new class .Slots that were
local in the old class and that are shared in the new class are initialized. Newly added shared slots
are initialized.
Each newly added shared slot is set to the result of evaluating the captured initialization form for
theslotthat was specied in the defclass form for the new class . If there was no initialization
form , the slotis unbound.
If a class is redened in such a way that the set of local slots accessible in an instance of the
class is changed, a two-step process of updating the instances of the class takes place. The
process may be explicitly started by invoking the generic function make-instances-obsolete . This
two-step process can happen in other circumstances in some implementations. For example, in
some implementations this two-step process is triggered if the order of slots in storage is changed.
The rst step modies the structure of the instance by adding new local slots and discarding
local slots that are not dened in the new version of the class . The second step initializes the
newly-added local slots and performs any other user-dened actions. These two steps are further
specied in the next two sections.
4.3.6.1 Modifying the Structure of Instances
The rst step modies the structure of instances of the redened class to conform to its new class
denition. Local slots specied by the new class denition that are not specied as either local or
shared by the old class are added, and slots not specied as either local or shared by the new class
denition that are specied as local by the old class are discarded. The names of these added and
discarded slots are passed as arguments to update-instance-for-redeﬁned-class as described in
the next section.
The values of local slots specied by both the new and old classes are retained. If such a local slot
was unbound, it remains unbound.
The value of a slotthat is specied as shared in the old class and as local in the new class is
retained. If such a shared slot was unbound, the local slot is unbound.
Types and Classes 4–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4.3.6.2 Initializing Newly Added Local Slots
The second step initializes the newly added local slots and performs any other user-dened actions.
This step is implemented by the generic function update-instance-for-redeﬁned-class , which is
called after completion of the rst step of modifying the structure of the instance .
The generic function update-instance-for-redeﬁned-class takes four required arguments: the
instance being updated after it has undergone the rst step, a list of the names of local slots that
were added, a list of the names of local slots that were discarded, and a property list containing the
slotnames and values of slots that were discarded and had values. Included among the discarded
slots areslots that were local in the old class and that are shared in the new class .
The generic function update-instance-for-redeﬁned-class also takes any number of initialization
arguments. When it is called by the system to update an instance whose class has been redened,
no initialization arguments are provided.
There is a system-supplied primary method forupdate-instance-for-redeﬁned-class whose
parameter specializer for its instance argument is the classstandard-object . First this method
checks the validity of initialization arguments and signals an error if an initialization argument
is supplied that is not declared as valid. (For more information, see Section 7.1.2 (Declaring the
Validity of Initialization Arguments).) Then it calls the generic function shared-initialize with the
following arguments: the instance , the list of names of the newly added slots, and the initialization
arguments it received.
4.3.6.3 Customizing Class Redeﬁnition
Methods forupdate-instance-for-redeﬁned-class may be dened to specify actions to be taken
when an instance is updated. If only after methods forupdate-instance-for-redeﬁned-class
are dened, they will be run after the system-supplied primary method for initialization and
therefore will not interfere with the default behavior of update-instance-for-redeﬁned-class .
Because no initialization arguments are passed to update-instance-for-redeﬁned-class when it
is called by the system, the initialization forms forslots that are lled by before methods for
update-instance-for-redeﬁned-class will not be evaluated by shared-initialize .
Methods forshared-initialize may be dened to customize class redenition. For more information,
see Section 7.1.5 (Shared-Initialize).
4.3.7 Integrating Types and Classes
The object system maps the space of classes into the space of types . Every class that has a proper
name has a corresponding type with the same name .
The proper name of every class is a valid type specier . In addition, every class object is a valid
type specier . Thus the expression (typep object class )evaluates to true if the class ofobject
isclass itself or a subclass ofclass . The evaluation of the expression (subtypep class1 class2)
returns the values true and true ifclass1 is a subclass of class2 or if they are the same class ;
otherwise it returns the values false and true. IfIis an instance of some classCnamedSandC
4–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
is an instance ofstandard-class , the evaluation of the expression (type-ofI)returnsSifSis the
proper name ofC; otherwise, it returns C.
Because the names of classes and class objects aretype speciers , they may be used in the special
formtheand in type declarations.
Many but not all of the predened type speciers have a corresponding class with the same proper
name as the type. These type speciers are listed in Figure 4{8. For example, the typearray has
a corresponding class namedarray . No type specier that is a list, such as (vector double-float
100), has a corresponding class . The operator deftype does not create any classes .
Each class that corresponds to a predened type specier can be implemented in one of three ways,
at the discretion of each implementation. It can be a standard class , astructure class , or a system
class .
Abuilt-in class is one whose generalized instances have restricted capabilities or special
representations. Attempting to use defclass to dene subclasses of abuilt-in-class signals an error.
Callingmake-instance to create a generalized instance of a built-in class signals an error. Calling
slot-value on a generalized instance of a built-in class signals an error. Redening a built-in class
or usingchange-class to change the class of an object to or from a built-in class signals an error.
However, built-in classes can be used as parameter specializers inmethods .
It is possible to determine whether a class is a built-in class by checking the metaclass . A
standard class is an instance of the classstandard-class , abuilt-in class is an instance of the class
built-in-class , and a structure class is an instance of the classstructure-class .
Each structure type created by defstruct without using the :type option has a corresponding class .
This class is ageneralized instance of the classstructure-class . The:include option of defstruct
creates a direct subclass of the class that corresponds to the included structure type .
It is implementation-dependent whether slots are involved in the operation of functions dened
in this specication on instances ofclasses dened in this specication, except when slots are
explicitly dened by this specication.
If in a particular implementation aclass dened in this specication has slots that are not dened
by this speccation, the names of these slots must not be external symbols ofpackages dened in
this specication nor otherwise accessible in theCL-USER package .
The purpose of specifying that many of the standard type speciers have a corresponding class is
to enable users to write methods that discriminate on these types .Method selection requires that a
class precedence list can be determined for each class .
The hierarchical relationships among the type speciers are mirrored by relationships among the
classes corresponding to those types .
Figure 4{8 lists the set of classes that correspond to predened type speciers .
Types and Classes 4–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
arithmetic-error generic-function simple-error
array hash-table simple-type-error
bit-vector integer simple-warning
broadcast-stream list standard-class
built-in-class logical-pathname standard-generic-function
cell-error method standard-method
character method-combination standard-object
class null storage-condition
complex number stream
concatenated-stream package stream-error
condition package-error string
cons parse-error string-stream
control-error pathname structure-class
division-by-zero print-not-readable structure-object
echo-stream program-error style-warning
end-of-ﬁle random-state symbol
error ratio synonym-stream
ﬁle-error rational t
ﬁle-stream reader-error two-way-stream
ﬂoat readtable type-error
ﬂoating-point-inexact real unbound-slot
ﬂoating-point-invalid-operation restart unbound-variable
ﬂoating-point-overﬂow sequence undeﬁned-function
ﬂoating-point-underﬂow serious-condition vector
function simple-condition warning
Figure 4–8. Classes that correspond to pre-deﬁned type speciﬁers
The class precedence list information specied in the entries for each of these classes are those that
are required by the object system.
Individual implementations may be extended to dene other type speciers to have a corresponding
class . Individual implementations may be extended to add other subclass relationships and to add
other elements to the class precedence lists as long as they do not violate the type relationships
and disjointness requirements specied by this standard. A standard class dened with no direct
superclasses is guaranteed to be disjoint from all of the classes in the table, except for the class
namedt.
4–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
nil Type
Supertypes:
alltypes
Description:
The typenilcontains no objects and so is also called the empty type . The typenilis asubtype of
every type. No object is of typenil.
Notes:
The type containing the objectnilis the typenull, not the typenil.
boolean Type
Supertypes:
boolean ,symbol ,t
Description:
The typeboolean contains the symbolstandnil, which represent true and false, respectively.
See Also:
t(constant variable ),nil(constant variable ),if,not,complement
Notes:
Conditional operations, such as if, permit the use of generalized booleans , not just booleans ;
any non-nil value, not just t, counts as true for a generalized boolean . However, as a matter of
convention, the symboltis considered the canonical value to use even for a generalized boolean
when no better choice presents itself.
Types and Classes 4–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
function
function System Class
Class Precedence List:
function ,t
Description:
Afunction is an object that represents code to be executed when an appropriate number of
arguments is supplied. A function is produced by the function special form , the function coerce ,
or the function compile . Afunction can be directly invoked by using it as the rst argument to
funcall ,apply , ormultiple-value-call .
Compound Type Speciﬁer Kind:
Specializing.
Compound Type Speciﬁer Syntax:
(function [ arg-typespec [value-typespec ]])
arg-typespec:: =(ftypespecg*
[&optionalftypespecg*]
[&rest typespec ]
[&keyf(keyword typespec )g*])
Compound Type Speciﬁer Arguments:
typespec |atype specier .
value-typespec |atype specier .
Compound Type Speciﬁer Description:
The list form of the function type-specier can be used only for declaration and not for
discrimination. Every element of this type is a function that accepts arguments of the types
specied by the argj-types and returns values that are members of the types specied by value-type .
The&optional ,&rest ,&key , and&allow-other-keys markers can appear in the list of argument
types. The type specier provided with &rest is the type of each actual argument, not the type of
the corresponding variable.
The&key parameters should be supplied as lists of the form (keyword type ). The keyword must
be a valid keyword-name symbol as must be supplied in the actual arguments of a call. This is
usually a symbol in theKEYWORD package but can be any symbol . When&key is given in a function
type specier lambda list , the keyword parameters given are exhaustive unless &allow-other-keys
is also present. &allow-other-keys is an indication that other keyword arguments might actually
be supplied and, if supplied, can be used. For example, the type of the functionmake-list could be
declared as follows:
4–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(function ((integer 0) &key (:initial-element t)) list)
The value-type can be a values type specier in order to indicate the types ofmultiple values .
Consider a declaration of the following form:
(ftype (function (arg0-type arg1-type ...) val-type) f))
Any form(f arg0 arg1 ...) within the scope of that declaration is equivalent to the following:
(the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))
That is, the consequences are undened if any of the arguments are not of the specied types or
the result is not of the specied type. In particular, if any argument is not of the correct type, the
result is not guaranteed to be of the specied type.
Thus, an ftype declaration for a function describes calls to the function , not the actual denition
of the function .
Consider a declaration of the following form:
(type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)
This declaration has the interpretation that, within the scope of the declaration, the consequences
are unspecied if the value of fn-valued-variable is called with arguments not of the specied
types ; the value resulting from a valid call will be of type val-type .
As with variable type declarations, nested declarations imply intersections of types , as follows:
Consider the following two declarations of ftype :
(ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))
and
(ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))
If both these declarations are in eect, then within the shared scope of the declarations,
calls tofcan be treated as if fwere declared as follows:
(ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)
(and val-type1 val-type2))
f))
It is permitted to ignore one or all of the ftype declarations in force.
If two (or more) type declarations are in eect for a variable, and they are both function
declarations, the declarations combine similarly.
Types and Classes 4–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
compiled-function Type
Supertypes:
compiled-function ,function ,t
Description:
Any function may be considered by an implementation to be a a compiled function if it contains no
references to macros that must be expanded at run time, and it contains no unresolved references
toload time values . See Section 3.2.2 (Compilation Semantics).
Functions whose denitions appear lexically within a lethat has been compiled withcompile-ﬁle
and then loaded withload are of typecompiled-function .Functions produced by the compile
function are of typecompiled-function . Other functions might also be of typecompiled-function .
generic-function System Class
Class Precedence List:
generic-function ,function ,t
Description:
Ageneric function is a function whose behavior depends on the classes or identities of the
arguments supplied to it. A generic function object contains a set of methods , alambda list , a
method combination type , and other information. The methods dene the class-specic behavior
and operations of the generic function ; amethod is said to specialize ageneric function . When
invoked, a generic function executes a subset of its methods based on the classes or identities of its
arguments .
Ageneric function can be used in the same ways that an ordinary function can be used; specically,
ageneric function can be used as an argument to funcall andapply , and can be given a global or
a local name.
4–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
standard-generic-function System Class
Class Precedence List:
standard-generic-function ,generic-function ,function ,t
Description:
The classstandard-generic-function is the default class ofgeneric functions established by
defmethod ,ensure-generic-function ,defgeneric , anddefclass forms .
class System Class
Class Precedence List:
class ,standard-object ,t
Description:
The typeclass represents objects that determine the structure and behavior of their instances .
Associated with an object oftypeclass is information describing its place in the directed acyclic
graph of classes , its slots, and its options.
built-in-class System Class
Class Precedence List:
built-in-class ,class ,standard-object ,t
Description:
Abuilt-in class is aclass whose instances have restricted capabilities or special representations.
Attempting to use defclass to dene subclasses of a built-in class signals an error of typeerror .
Callingmake-instance to create an instance of a built-in class signals an error of typeerror .
Callingslot-value on an instance of a built-in class signals an error of typeerror . Redening a
built-in class or usingchange-class to change the class of an instance to or from a built-in class
signals an error of typeerror . However, built-in classes can be used as parameter specializers in
methods .
Types and Classes 4–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
structure-class System Class
Class Precedence List:
structure-class ,class ,standard-object ,t
Description:
Allclasses dened by means of defstruct areinstances of the classstructure-class .
standard-class System Class
Class Precedence List:
standard-class ,class ,standard-object ,t
Description:
The classstandard-class is the default class ofclasses dened by defclass .
method System Class
Class Precedence List:
method ,t
Description:
Amethod is an object that represents a modular part of the behavior of a generic function .
Amethod contains code to implement the method 's behavior, a sequence of parameter specializers
that specify when the given method is applicable, and a sequence of qualiers that is used by
the method combination facility to distinguish among methods . Each required parameter of each
method has an associated parameter specializer , and the method will be invoked only on arguments
that satisfy its parameter specializers .
The method combination facility controls the selection of methods , the order in which they are
run, and the values that are returned by the generic function. The object system oers a default
method combination type and provides a facility for declaring new types of method combination.
See Also:
Section 7.6 (Generic Functions and Methods)
4–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
standard-method System Class
Class Precedence List:
standard-method ,method ,standard-object ,t
Description:
The classstandard-method is the default class ofmethods dened by the defmethod and
defgeneric forms .
structure-object Class
Class Precedence List:
structure-object ,t
Description:
The classstructure-object is an instance ofstructure-class and is a superclass of every class that
is an instance ofstructure-class except itself, and is a superclass of every class that is dened by
defstruct .
See Also:
defstruct , Section 2.4.8.13 (Sharpsign S), Section 22.1.3.12 (Printing Structures)
standard-object Class
Class Precedence List:
standard-object ,t
Description:
The classstandard-object is an instance ofstandard-class and is a superclass of every class that
is an instance ofstandard-class except itself.
Types and Classes 4–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
method-combination System Class
Class Precedence List:
method-combination ,t
Description:
Every method combination object is an indirect instance of the classmethod-combination . A
method combination object represents the information about the method combination being used
by a generic function . Amethod combination object contains information about both the type of
method combination and the arguments being used with that type.
t System Class
Class Precedence List:
t
Description:
The set of all objects . The typetis asupertype of every type, including itself. Every object is of
typet.
satisﬁes Type Specier
Compound Type Speciﬁer Kind:
Predicating.
Compound Type Speciﬁer Syntax:
(satisfies predicate-name )
Compound Type Speciﬁer Arguments:
predicate-name |asymbol .
Compound Type Speciﬁer Description:
This denotes the set of all objects that satisfy the predicate predicate-name , which must be a
symbol whose global function denition is a one-argument predicate. A name is required for
predicate-name ;lambda expressions are not allowed. For example, the type specier (and integer
(satisfies evenp)) denotes the set of all even integers. The form (typep x’(satisfies p))is
equivalent to (if ( p x) t nil) .
4–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The argument is required. The symbol*can be the argument, but it denotes itself (the symbol*),
and does not represent an unspecied value.
The symbol satisﬁes is not valid as a type specier .
member Type Specier
Compound Type Speciﬁer Kind:
Combining.
Compound Type Speciﬁer Syntax:
(memberfobjectg*)
Compound Type Speciﬁer Arguments:
object |an object .
Compound Type Speciﬁer Description:
This denotes the set containing the named objects . An object is of this type if and only if it is eql
to one of the specied objects .
The type speciers (member) andnilare equivalent. *can be among the objects , but if so it denotes
itself (the symbol *) and does not represent an unspecied value. The symbol member is not valid
as a type specier ; and, specically, it is not an abbreviation for either (member) or(member *) .
See Also:
thetypeeql
not Type Specier
Compound Type Speciﬁer Kind:
Combining.
Compound Type Speciﬁer Syntax:
(not typespec )
Compound Type Speciﬁer Arguments:
typespec |atype specier .
Types and Classes 4–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compound Type Speciﬁer Description:
This denotes the set of all objects that are not of the type typespec .
The argument is required, and cannot be *.
The symbol notis not valid as a type specier .
and Type Specier
Compound Type Speciﬁer Kind:
Combining.
Compound Type Speciﬁer Syntax:
(andftypespecg*)
Compound Type Speciﬁer Arguments:
typespec |atype specier .
Compound Type Speciﬁer Description:
This denotes the set of all objects of the type determined by the intersection of the typespecs .
*is not permitted as an argument.
The type speciers (and) andtare equivalent. The symbol andis not valid as a type specier , and,
specically, it is not an abbreviation for (and) .
or Type Specier
Compound Type Speciﬁer Kind:
Combining.
Compound Type Speciﬁer Syntax:
(orftypespecg*)
Compound Type Speciﬁer Arguments:
typespec |atype specier .
4–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compound Type Speciﬁer Description:
This denotes the set of all objects of the type determined by the union of the typespecs . For
example, the typelistby denition is the same as (or null cons) . Also, the value returned by
position is an object oftype(or null (integer 0 *)) ;i.e., eithernilor a non-negative integer .
*is not permitted as an argument.
The type speciers (or) andnilare equivalent. The symbol oris not valid as a type specier ; and,
specically, it is not an abbreviation for (or).
values Type Specier
Compound Type Speciﬁer Kind:
Specializing.
Compound Type Speciﬁer Syntax:
(values#value-typespec )
value-typespec:: =ftypespecg*[&optionalftypespecg*] [&rest typespec ] [&allow-other-keys ]
Compound Type Speciﬁer Arguments:
typespec |atype specier .
Compound Type Speciﬁer Description:
This type specier can be used only as the value-type in afunction type specier or athespecial
form . It is used to specify individual types when multiple values are involved. The &optional and
&rest markers can appear in the value-type list; they indicate the parameter list of a function that,
when given to multiple-value-call along with the values, would correctly receive those values.
The symbol *may not be among the value-types .
The symbol values is not valid as a type specier ; and, specically, it is not an abbreviation for
(values) .
Types and Classes 4–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
eql Type Specier
Compound Type Speciﬁer Kind:
Combining.
Compound Type Speciﬁer Syntax:
(eql object)
Compound Type Speciﬁer Arguments:
object |an object .
Compound Type Speciﬁer Description:
Represents the type of all xfor which (eql object x )is true.
The argument object is required. The object can be*, but if so it denotes itself (the symbol *) and
does not represent an unspecied value. The symboleqlis not valid as an atomic type specier .
coerce Function
Syntax:
coerce object result-type !result
Arguments and Values:
object |an object .
result-type |atype specier .
result |an object , oftype result-type except in situations described in Section 12.1.5.3 (Rule of
Canonical Representation for Complex Rationals).
Description:
Coerces theobject totype result-type .
Ifobject is already of type result-type , the object itself is returned, regardless of whether it would
have been possible in general to coerce an object of some other type toresult-type .
Otherwise, the object iscoerced totype result-type according to the following rules:
4–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
coerce
sequence
If the result-type is a recognizable subtype oflist, and the object is a sequence , then the
result is alistthat has the same elements asobject .
If the result-type is arecognizable subtype ofvector , and the object is asequence , then the
result is avector that has the same elements asobject . Ifresult-type is a specialized type,
theresult has an actual array element type that is the result of upgrading the element type
part of that specialized type . If no element type is specied, the element type defaults to t.
If the implementation cannot determine the element type, an error is signaled.
character
If the result-type ischaracter and the object is a character designator , the result is the
character it denotes.
complex
If the result-type iscomplex and the object is a real, then the result is obtained by
constructing a complex whose real part is the object and whose imaginary part is the result
ofcoercing aninteger zero to the type of the object (usingcoerce ). (If the real part is a
rational , however, then the result must be represented as a rational rather than a complex ;
see Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals). So, for
example, (coerce 3 ’complex) is permissible, but will return 3, which is not a complex .)
ﬂoat
If the result-type is any of ﬂoat,short-ﬂoat ,single-ﬂoat ,double-ﬂoat ,long-ﬂoat , and
theobject is areal, then the result is aoat oftype result-type which is equal in sign and
magnitude to the object to whatever degree of representational precision is permitted by
that oat representation. (If the result-type isﬂoat and object is not already a oat, then
theresult is asingle oat .)
function
If the result-type isfunction , and object is any function name that is fbound but that is
globally dened neither as a macro name nor as a special operator , then the result is the
functional value ofobject .
If the result-type isfunction , and object is alambda expression , then the result is aclosure
ofobject in the null lexical environment .
t
Any object can be coerced to an object oftypet. In this case, the object is simply returned.
Examples:
(coerce ’(a b c) ’vector) !#(A B C)
Types and Classes 4–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(coerce ’a ’character) !#\A
(coerce 4.56 ’complex) !#C(4.56 0.0)
(coerce 4.5s0 ’complex) !#C(4.5s0 0.0s0)
(coerce 7/2 ’complex) !7/2
(coerce 0 ’short-float) !0.0s0
(coerce 3.5L0 ’float) !3.5L0
(coerce 7/2 ’float) !3.5
(coerce (cons 1 2) t) !(1 . 2)
All the following forms should signal an error:
(coerce ’(a b c) ’(vector * 4))
(coerce #(a b c) ’(vector * 4))
(coerce ’(a b c) ’(vector * 2))
(coerce #(a b c) ’(vector * 2))
(coerce "foo" ’(string 2))
(coerce #(#\a #\b #\c) ’(string 2))
(coerce ’(0 1) ’(simple-bit-vector 3))
Exceptional Situations:
If a coercion is not possible, an error of typetype-error is signaled.
(coerce x ’nil) always signals an error of typetype-error .
An error of typeerror is signaled if the result-type isfunction but object is asymbol that is not
fbound or if the symbol names a macro or a special operator .
An error of typetype-error should be signaled if result-type species the number of elements and
object is of a dierent length.
See Also:
rational ,ﬂoor ,char-code ,char-int
Notes:
Coercions from oats torationals and from ratios tointegers are not provided because of rounding
problems.
(coerce x ’t)(identity x)x
4–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deftype
deftype Macro
Syntax:
deftype name lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*!name
Arguments and Values:
name |asymbol .
lambda-list |adeftype lambda list .
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
form|aform .
Description:
deftype denes a derived type specier named name .
The meaning of the new type specier is given in terms of a function which expands the type
specier into another type specier , which itself will be expanded if it contains references to another
derived type specier .
The newly dened type specier may be referenced as a list of the form (name arg 1arg2...).
The number of arguments must be appropriate to the lambda-list . If the new type specier takes
no arguments, or if all of its arguments are optional, the type specier may be used as an atomic
type specier .
The argument expressions to the type specier ,arg1:::argn, are not evaluated . Instead, these
literal objects become the objects to which corresponding parameters become bound .
The body of the deftype form (but not the lambda-list ) is implicitly enclosed in a block named
name , and is evaluated as an implicit progn , returning a new type specier .
The lexical environment of the body is the one which was current at the time the deftype form
was evaluated, augmented by the variables in the lambda-list .
Recursive expansion of the type specier returned as the expansion must terminate, including the
expansion of type speciers which are nested within the expansion.
The consequences are undened if the result of fully expanding a type specier contains any circular
structure, except within the objects referred to by member andeqltype speciers .
Documentation is attached to name as a documentation string of kindtype.
If adeftype form appears as a top level form , the compiler must ensure that the name is recognized
in subsequent type declarations. The programmer must ensure that the body of a deftype form
can be evaluated at compile time if the name is referenced in subsequent type declarations. If the
Types and Classes 4–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
expansion of a type specier is not dened fully at compile time (perhaps because it expands into
an unknown type specier or asatisﬁes of a named function that isn't dened in the compile-time
environment), an implementation may ignore any references to this type in declarations and/or
signal a warning.
Examples:
(defun equidimensional (a)
(or (< (array-rank a) 2)
(apply #’= (array-dimensions a)))) !EQUIDIMENSIONAL
(deftype square-matrix (&optional type size)
‘(and (array ,type (,size ,size))
(satisfies equidimensional))) !SQUARE-MATRIX
See Also:
declare ,defmacro ,documentation , Section 4.2.3 (Type Speciers), Section 3.4.11 (Syntactic
Interaction of Documentation Strings and Declarations)
subtypep Function
Syntax:
subtypep type-1 type-2 &optional environment!subtype-p, valid-p
Arguments and Values:
type-1 |atype specier .
type-2 |atype specier .
environment |an environment object . The default is nil, denoting the null lexical environment and
the current global environment .
subtype-p |ageneralized boolean .
valid-p |ageneralized boolean .
Description:
Iftype-1 is a recognizable subtype oftype-2 , the rst value istrue. Otherwise, the rst value is
false, indicating that either type-1 is not a subtype oftype-2 , or else type-1 is asubtype oftype-2
but is not a recognizable subtype .
A second value is also returned indicating the `certainty' of the rst value . If this value is true,
then the rst value is an accurate indication of the subtype relationship. (The second value is
always true when the rst value istrue.)
4–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
subtypep
Figure 4{9 summarizes the possible combinations of values that might result.
Value 1 Value 2 Meaning
true true type-1 is denitely a subtype oftype-2 .
false true type-1 is denitely not a subtype oftype-2 .
false false subtypep could not determine the relationship,
sotype-1 might or might not be a subtype oftype-2 .
Figure 4–9. Result possibilities for subtypep
subtypep is permitted to return the values false and false only when at least one argument
involves one of these type speciers :and,eql, the list form of function ,member ,not,or,satisﬁes ,
orvalues . (A type specier `involves' such a symbol if, after being type expanded , it contains
that symbol in a position that would call for its meaning as a type specier to be used.) One
consequence of this is that if neither type-1 nor type-2 involves any of these type speciers , then
subtypep is obliged to determine the relationship accurately. In particular, subtypep returns the
values true and true if the arguments are equal and do not involve any of these type speciers .
subtypep never returns a second value of nilwhen both type-1 and type-2 involve only the names
in Figure 4{2, or names of types dened by defstruct ,deﬁne-condition , ordefclass , or derived
types that expand into only those names. While type speciers listed in Figure 4{2 and names of
defclass anddefstruct can in some cases be implemented as derived types ,subtypep regards them
as primitive.
The relationships between types reected by subtypep are those specic to the particular
implementation. For example, if an implementation supports only a single type of oating-point
numbers, in that implementation (subtypep ’float ’long-float) returns the values true and true
(since the two types are identical).
For all T1and T2other than *,(array T1)and(array T2)are two dierent type spec-
iers that always refer to the same sets of things if and only if they refer to arrays of
exactly the same specialized representation, i.e., if(upgraded-array-element-type ’ T1)and
(upgraded-array-element-type ’ T2)return two dierent type speciers that always refer to
the same sets of objects . This is another way of saying that ‘(array type-specier )and
‘(array ,(upgraded-array-element-type ’ type-specier ))refer to the same set of specialized array
representations. For all T1and T2other than *, the intersection of (array T1)and(array T2)is
the empty set if and only if they refer to arrays of dierent, distinct specialized representations.
Therefore,
(subtypep ’(array T1) ’(array T2)) !true
if and only if
(upgraded-array-element-type ’T1) and
(upgraded-array-element-type ’T2)
Types and Classes 4–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
subtypep
return two dierent type speciers that always refer to the same sets of objects .
For all type-speciers T1and T2other than *,
(subtypep ’(complex T1) ’(complex T2)) !true,true
if:
1.T1is asubtype ofT2, or
2.(upgraded-complex-part-type ’ T1)and(upgraded-complex-part-type ’ T2)return two
dierent type speciers that always refer to the same sets of objects ; in this case,
(complex T1)and(complex T2)both refer to the same specialized representation.
The values arefalse and true otherwise.
The form
(subtypep ’(complex single-float) ’(complex float))
must return true in all implementations, but
(subtypep ’(array single-float) ’(array float))
returns true only in implementations that do not have a specialized array representation for single
oats distinct from that for other oats .
Examples:
(subtypep ’compiled-function ’function) !true,true
(subtypep ’null ’list) !true,true
(subtypep ’null ’symbol) !true,true
(subtypep ’integer ’string) !false,true
(subtypep ’(satisfies dummy) nil) !false,implementation-dependent
(subtypep ’(integer 1 3) ’(integer 1 4)) !true,true
(subtypep ’(integer (0) (0)) ’nil) !true,true
(subtypep ’nil ’(integer (0) (0))) !true,true
(subtypep ’(integer (0) (0)) ’(member)) !true,true;orfalse,false
(subtypep ’(member) ’nil) !true,true;orfalse,false
(subtypep ’nil ’(member)) !true,true;orfalse,false
Let<aet-x> and<aet-y> be two distinct type speciers that do not always refer to the same sets
ofobjects in a given implementation, but for which make-array , will return an object of the same
array type .
Thus, in each case,
(subtypep (array-element-type (make-array 0 :element-type ’<aet-x>))
(array-element-type (make-array 0 :element-type ’<aet-y>)))
!true,true
4–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(subtypep (array-element-type (make-array 0 :element-type ’<aet-y>))
(array-element-type (make-array 0 :element-type ’<aet-x>)))
!true,true
If(array <aet-x>) and(array <aet-y>) are dierent names for exactly the same set of objects ,
these names should always refer to the same sets of objects . That implies that the following set of
tests are also true:
(subtypep ’(array <aet-x>) ’(array <aet-y>)) !true,true
(subtypep ’(array <aet-y>) ’(array <aet-x>)) !true,true
See Also:
Section 4.2 (Types)
Notes:
The small dierences between the subtypep specication for the array andcomplex types are
necessary because there is no creation function for complexes which allows the specication of the
resultant part type independently of the actual types of the parts. Thus in the case of the type
complex , the actual type of the parts is referred to, although a number can be a member of more
than one type. For example, 17is of type(mod 18) as well as type(mod 256) and typeinteger ; and
2.3f5 is of typesingle-ﬂoat as well as typeﬂoat.
type-of Function
Syntax:
type-of object!typespec
Arguments and Values:
object |an object .
typespec |atype specier .
Description:
Returns a type specier ,typespec , for a type that has the object as an element . The typespec
satises the following:
1. For any object that is an element of some built-in type :
a. the type returned is a recognizable subtype of that built-in type .
b. the type returned does not involve and,eql,member ,not,or,satisfies , orvalues .
Types and Classes 4–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
type-of
2. For all objects ,(typep object(type-of object))returns true. Implicit in this is that type
speciers which are not valid for use with typep , such as the listform of the function type
specier , are never returned by type-of .
3. The type returned by type-of is always a recognizable subtype of the class returned by
class-of . That is,
(subtypep (type-of object) (class-of object))!true,true
4. For objects of metaclass structure-class orstandard-class , and for conditions ,type-of
returns the proper name of the class returned by class-of if it has a proper name , and
otherwise returns the class itself. In particular, for objects created by the constructor
function of a structure dened with defstruct without a :type option,type-of returns the
structure name; and for objects created by make-condition , the typespec is the name of
thecondition type .
5. For each of the typesshort-ﬂoat ,single-ﬂoat ,double-ﬂoat , orlong-ﬂoat of which the
object is an element , the typespec is arecognizable subtype of that type.
Examples:
(type-of ’a)!SYMBOL
(type-of ’(1 . 2))
!CONSor!(CONS FIXNUM FIXNUM)
(type-of #c(0 1))
!COMPLEXor!(COMPLEX INTEGER)
(defstruct temp-struct x y z) !TEMP-STRUCT
(type-of (make-temp-struct)) !TEMP-STRUCT
(type-of "abc")
!STRINGor!(STRING 3)
(subtypep (type-of "abc") ’string) !true,true
(type-of (expt 2 40))
!BIGNUMor!INTEGERor!(INTEGER 1099511627776 1099511627776)or!SYSTEM::TWO-WORD-BIGNUMor!FIXNUM
(subtypep (type-of 112312) ’integer) !true,true
(defvar *foo* (make-array 5 :element-type t)) !*FOO*
(class-name (class-of *foo*)) !VECTOR
4–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(type-of *foo*)
!VECTORor!(VECTOR T 5)
See Also:
array-element-type ,class-of ,defstruct ,typecase ,typep , Section 4.2 (Types)
Notes:
Implementors are encouraged to arrange for type-of to return a portable value.
typep Function
Syntax:
typep object type-specier &optional environment!generalized-boolean
Arguments and Values:
object |an object .
type-specier |any type specier exceptvalues , or a type specier list whose rst element is either
function orvalues .
environment |an environment object . The default is nil, denoting the null lexical environment and
the and current global environment .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of the type specied by type-specier ; otherwise, returns false.
Atype-specier of the form (satisfies fn) is handled by applying the function fntoobject .
(typep object’(array type-specier )), where type-specier is not*, returns trueif and only if object
is an array that could be the result of supplying type-specier as the:element-type argument to
make-array .(array *) refers to all arrays regardless of element type, while (array type-specier )
refers only to those arrays that can result from giving type-specier as the:element-type
argument to make-array . A similar interpretation applies to (simple-array type-specier )and
(vector type-specier ). See Section 15.1.2.1 (Array Upgrading).
(typep object’(complex type-specier ))returns true for all complex numbers that can result from
giving numbers of type type-specier to the function complex , plus all other complex numbers of
the same specialized representation. Both the real and the imaginary parts of any such complex
number must satisfy:
Types and Classes 4–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
typep
(typep realpart ’type-specifier)
(typep imagpart ’type-specifier)
See the functionupgraded-complex-part-type .
Examples:
(typep 12 ’integer) !true
(typep (1+ most-positive-fixnum) ’fixnum) !false
(typep nil t)!true
(typep nil nil) !false
(typep 1 ’(mod 2)) !true
(typep #c(1 1) ’(complex (eql 1))) !true
;; To understand this next example, you might need to refer to
;; Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals).
(typep #c(0 0) ’(complex (eql 0))) !false
LetAxandAybe two type speciers that denote dierent types , but for which
(upgraded-array-element-type ’A x)
and
(upgraded-array-element-type ’A y)
denote the same type. Notice that
(typep (make-array 0 :element-type ’A x) ’(array A x))!true
(typep (make-array 0 :element-type ’A y) ’(array A y))!true
(typep (make-array 0 :element-type ’A x) ’(array A y))!true
(typep (make-array 0 :element-type ’A y) ’(array A x))!true
Exceptional Situations:
An error of typeerror is signaled if type-specier isvalues , or a type specier list whose rst
element is either function orvalues .
The consequences are undened if the type-specier is not a type specier .
See Also:
type-of ,upgraded-array-element-type ,upgraded-complex-part-type , Section 4.2.3 (Type
Speciers)
Notes:
Implementations are encouraged to recognize and optimize the case of (typep x(the class y)),
since it does not involve any need for expansion of deftype information at runtime.
4–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
type-error Condition Type
Class Precedence List:
type-error ,error ,serious-condition ,condition ,t
Description:
The typetype-error represents a situation in which an object is not of the expected type. The
\oending datum" and \expected type" are initialized by the initialization arguments named :datum
and:expected-type tomake-condition , and are accessed by the functions type-error-datum and
type-error-expected-type .
See Also:
type-error-datum ,type-error-expected-type
type-error-datum,type-error-expected-type Function
Syntax:
type-error-datum condition!datum
type-error-expected-type condition!expected-type
Arguments and Values:
condition |acondition oftypetype-error .
datum |an object .
expected-type |atype specier .
Description:
type-error-datum returns the oending datum in the situation represented by the condition .
type-error-expected-type returns the expected type of the oending datum in the situation
represented by the condition .
Examples:
(defun fix-digits (condition)
(check-type condition type-error)
(let* ((digits ’(zero one two three four
five six seven eight nine))
Types and Classes 4–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(val (position (type-error-datum condition) digits)))
(if (and val (subtypep ’fixnum (type-error-expected-type condition)))
(store-value 7))))
(defun foo (x)
(handler-bind ((type-error #’fix-digits))
(check-type x number)
(+ x 3)))
(foo ’seven)
!10
See Also:
type-error , Chapter 9 (Conditions)
simple-type-error Condition Type
Class Precedence List:
simple-type-error ,simple-condition ,type-error ,error ,serious-condition ,condition ,t
Description:
Conditions oftypesimple-type-error are like conditions oftypetype-error , except that they
provide an alternate mechanism for specifying how the condition is to be reported ; see the type
simple-condition .
See Also:
simple-condition ,simple-condition-format-control ,simple-condition-format-arguments ,
type-error-datum ,type-error-expected-type
4–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
5. Data and Control Flow
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Data and Control Flow iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
5.1 Generalized Reference
5.1.1 Overview of Places and Generalized Reference
Ageneralized reference is the use of a form , sometimes called a place , as if it were a variable
that could be read and written. The value of aplace is the object to which the place form evaluates.
The value of a place can be changed by using setf. The concept of binding a place is not dened
in Common Lisp, but an implementation is permitted to extend the language by dening this
concept.
Figure 5{1 contains examples of the use of setf. Note that the values returned by evaluating the
forms in column two are not necessarily the same as those obtained by evaluating the forms in
column three. In general, the exact macro expansion of asetf form is not guaranteed and can even
beimplementation-dependent ; all that is guaranteed is that the expansion is an update form that
works for that particular implementation , that the left-to-right evaluation of subforms is preserved,
and that the ultimate result of evaluating setf is the value or values being stored.
Access function Update Function Update using setf
x (setq x datum) (setf x datum)
(car x) (rplaca x datum) (setf (car x) datum)
(symbol-value x) (set x datum) (setf (symbol-value x) datum)
Figure 5–1. Examples of setf
Figure 5{2 shows operators relating to places and generalized reference .
assert defsetf push
ccase get-setf-expansion remf
ctypecase getf rotatef
decf incf setf
deﬁne-modify-macro pop shiftf
deﬁne-setf-expander psetf
Figure 5–2. Operators relating to places and generalized reference.
Some of the operators above manipulate places and some manipulate setf expanders . A setf
expansion can be derived from any place . New setf expanders can be dened by using defsetf and
deﬁne-setf-expander .
Data and Control Flow 5–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
5.1.1.1 Evaluation of Subforms to Places
The following rules apply to the evaluation ofsubforms in a place :
1. The evaluation ordering of subforms within a place is determined by the order specied
by the second value returned by get-setf-expansion . For all places dened by this
specication ( e.g.,getf,ldb,:::), this order of evaluation is left-to-right. When a place is
derived from a macro expansion, this rule is applied after the macro is expanded to nd
the appropriate place .
Places dened by using defmacro ordeﬁne-setf-expander use the evaluation order dened
by those denitions. For example, consider the following:
(defmacro wrong-order (x y) ‘(getf ,y ,x))
This following form evaluates place2 rst and then place1 because that is the order they
are evaluated in the macro expansion:
(push value (wrong-order place1 place2))
2. For the macros that manipulate places (push ,pushnew ,remf ,incf,decf,shiftf ,rotatef ,
psetf ,setf,pop, and those dened by deﬁne-modify-macro ) the subforms of the macro
call are evaluated exactly once in left-to-right order, with the subforms of the places
evaluated in the order specied in (1).
push ,pushnew ,remf ,incf,decf,shiftf ,rotatef ,psetf ,popevaluate all subforms before
modifying any of the place locations. setf (in the case when setf has more than two
arguments) performs its operation on each pair in sequence. For example, in
(setf place1 value1 place2 value2 ...)
thesubforms ofplace1 andvalue1 are evaluated, the location specied by place1 is
modied to contain the value returned by value1 , and then the rest of the setf form is
processed in a like manner.
3. Forcheck-type ,ctypecase , andccase ,subforms of the place are evaluated once as in (1),
but might be evaluated again if the type check fails in the case of check-type or none of
the cases hold in ctypecase andccase .
4. Forassert , the order of evaluation of the generalized references is not specied.
Rules 2, 3 and 4 cover all standardized macros that manipulate places .
5.1.1.1.1 Examples of Evaluation of Subforms to Places
(let ((ref2 (list ’())))
(push (progn (princ "1") ’ref-1)
5–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(car (progn (princ "2") ref2))))
.12
!(REF1)
(let (x)
(push (setq x (list ’a))
(car (setq x (list ’b))))
x)
!(((A) . B))
push rst evaluates (setq x (list ’a)) !(a), then evaluates (setq x (list ’b)) !(b), then
modies the carof this latest value to be ((a) . b) .
5.1.1.2 Setf Expansions
Sometimes it is possible to avoid evaluating subforms of a place multiple times or in the wrong
order. A setf expansion for a given access form can be expressed as an ordered collection of ve
objects :
List of temporary variables
a list of symbols naming temporary variables to be bound sequentially, as if by let*, to
values resulting from value forms.
List of value forms
a list of forms (typically, subforms of the place ) which when evaluated yield the values to
which the corresponding temporary variables should be bound.
List of store variables
a list of symbols naming temporary store variables which are to hold the new values that
will be assigned to the place .
Storing form
a form which can reference both the temporary and the store variables, and which changes
thevalue of the place and guarantees to return as its values the values of the store
variables, which are the correct values for setf to return.
Accessing form
aform which can reference the temporary variables, and which returns the value of the
place .
The value returned by the accessing form is aected by execution of the storing form, but either of
these forms might be evaluated any number of times.
Data and Control Flow 5–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
It is possible to do more than one setf in parallel via psetf ,shiftf , androtatef . Because of this,
thesetf expander must produce new temporary and store variable names every time. For examples
of how to do this, see gensym .
For each standardized accessor function F, unless it is explicitly documented otherwise, it is
implementation-dependent whether the ability to use an Fform as asetf place is implemented by
asetf expander or a setf function . Also, it follows from this that it is implementation-dependent
whether the name (setf F)isfbound .
5.1.1.2.1 Examples of Setf Expansions
Examples of the contents of the constituents of setf expansions follow.
For a variable x:
() ;list of temporary variables
() ;list of value forms
(g0001) ;list of store variables
(setq xg0001) ;storing form
x ;accessing form
Figure 5–3. Sample Setf Expansion of a Variable
For(car exp):
(g0002) ;list of temporary variables
(exp) ;list of value forms
(g0003) ;list of store variables
(progn (rplaca g0002 g0003) g0003) ;storing form
(car g0002) ;accessing form
Figure 5–4. Sample Setf Expansion of a CAR Form
For(subseq seq s e):
(g0004 g0005 g0006) ;list of temporary variables
(seq s e) ;list of value forms
(g0007) ;list of store variables
(progn (replace g0004 g0007 :start1 g0005 :end1 g0006) g0007)
;storing form
(subseq g0004 g0005 g0006) ; accessing form
Figure 5–5. Sample Setf Expansion of a SUBSEQ Form
5–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
In some cases, if a subform of a place is itself a place , it is necessary to expand the subform in
order to compute some of the values in the expansion of the outer place . For(ldb bs(car exp)):
(g0001 g0002) ;list of temporary variables
(bs exp) ;list of value forms
(g0003) ;list of store variables
(progn (rplaca g0002 (dpb g0003 g0001 (car g0002))) g0003)
;storing form
(ldb g0001 (car g0002)) ; accessing form
Figure 5–6. Sample Setf Expansion of a LDB Form
5.1.2 Kinds of Places
Several kinds of places are dened by Common Lisp; this section enumerates them. This set can
be extended by implementations and by programmer code .
5.1.2.1 Variable Names as Places
The name of a lexical variable ordynamic variable can be used as a place .
5.1.2.2 Function Call Forms as Places
Afunction form can be used as a place if it falls into one of the following categories:
A function call form whose rst element is the name of any one of the functions in Figure
5{7.
Data and Control Flow 5–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
aref cdadr get
bit cdar gethash
caaaar cddaar logical-pathname-translations
caaadr cddadr macro-function
caaar cddar ninth
caadar cdddar nth
caaddr cddddr readtable-case
caadr cdddr rest
caar cddr row-major-aref
cadaar cdr sbit
cadadr char schar
cadar class-name second
caddar compiler-macro-function seventh
cadddr documentation sixth
caddr eighth slot-value
cadr elt subseq
car fdeﬁnition svref
cdaaar ﬁfth symbol-function
cdaadr ﬁll-pointer symbol-plist
cdaar ﬁnd-class symbol-value
cdadar ﬁrst tenth
cdaddr fourth third
Figure 5–7. Functions that setf can be used with—1
In the case of subseq , the replacement value must be a sequence whose elements might
be contained by the sequence argument to subseq , but does not have to be a sequence of
the same type as the sequence of which the subsequence is specied. If the length of the
replacement value does not equal the length of the subsequence to be replaced, then the
shorter length determines the number of elements to be stored, as for replace .
A function call form whose rst element is the name of a selector function constructed by
defstruct . The function name must refer to the global function denition, rather than a
locally dened function .
A function call form whose rst element is the name of any one of the functions in Figure
5{8, provided that the supplied argument to that function is in turn a place form; in this
case the new place has stored back into it the result of applying the supplied \update"
function.
5–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Function name Argument that is a placeUpdate function used
ldb second dpb
mask-ﬁeld second deposit-ﬁeld
getf rst implementation-dependent
Figure 5–8. Functions that setf can be used with—2
During the setf expansion of these forms , it is necessary to call get-setf-expansion in
order to gure out how the inner, nested generalized variable must be treated.
The information from get-setf-expansion is used as follows.
ldb
In a form such as:
(setf (ldb byte-spec place-form )value-form )
the place referred to by the place-form must always be both read and written ; note
that the update is to the generalized variable specied by place-form , not to any
object of typeinteger .
Thus this setf should generate code to do the following:
1. Evaluate byte-spec (and bind it into a temporary variable).
2. Bind the temporary variables for place-form .
3. Evaluate value-form (and bind its value or values into the store variable).
4. Do the read from place-form .
5. Do the write into place-form with the given bits of the integer fetched in
step 4 replaced with the value from step 3.
If the evaluation of value-form in step 3 alters what is found in place-form , such as
setting dierent bits of integer , then the change of the bits denoted by byte-spec
is to that altered integer , because step 4 is done after the value-form evaluation.
Nevertheless, the evaluations required for binding the temporary variables are
done in steps 1 and 2, and thus the expected left-to-right evaluation order is seen.
For example:
(setq integer #x69) !#x69
(rotatef (ldb (byte 4 4) integer)
(ldb (byte 4 0) integer))
integer!#x96
;;; This example is trying to swap two independent bit fields
;;; in an integer. Note that the generalized variable of
;;; interest here is just the (possibly local) program variable
Data and Control Flow 5–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;;; integer.
mask-ﬁeld
This case is the same as ldbin all essential aspects.
getf
In a form such as:
(setf (getf place-form ind-form )value-form )
the place referred to by place-form must always be both read andwritten ; note that
the update is to the generalized variable specied by place-form , not necessarily to
the particular listthat is the property list in question.
Thus this setf should generate code to do the following:
1. Bind the temporary variables for place-form .
2. Evaluate ind-form (and bind it into a temporary variable).
3. Evaluate value-form (and bind its value or values into the store variable).
4. Do the read from place-form .
5. Do the write into place-form with a possibly-new property list obtained
by combining the values from steps 2, 3, and 4. (Note that the phrase
\possibly-new property list" can mean that the former property list is
somehow destructively re-used, or it can mean partial or full copying of
it. Since either copying or destructive re-use can occur, the treatment
of the resultant value for the possibly-new property list must proceed as
if it were a dierent copy needing to be stored back into the generalized
variable.)
If the evaluation of value-form in step 3 alters what is found in place-form , such
as setting a dierent named property in the list, then the change of the property
denoted by ind-form is to that altered list, because step 4 is done after the
value-form evaluation. Nevertheless, the evaluations required for binding the
temporary variables are done in steps 1 and 2, and thus the expected left-to-right
evaluation order is seen.
For example:
(setq s (setq r (list (list ’a 1 ’b 2 ’c 3)))) !((a 1 b 2 c 3))
(setf (getf (car r) ’b)
(progn (setq r nil) 6)) !6
r!NIL
s!((A 1 B 6 C 3))
;;; Note that the (setq r nil) does not affect the actions of
5–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;;; the SETF because the value of R had already been saved in
;;; a temporary variable as part of the step 1. Only the CAR
;;; of this value will be retrieved, and subsequently modified
;;; after the value computation.
5.1.2.3 VALUES Forms as Places
Avalues form can be used as a place , provided that each of its subforms is also a place form.
A form such as
(setf (values place-1:::place-n)values-form )
does the following:
1. The subforms of each nested place are evaluated in left-to-right order.
2. The values-form is evaluated, and the rst store variable from each place is bound to its
return values as if by multiple-value-bind .
3. If the setf expansion for any place involves more than one store variable, then the additional
store variables are bound to nil.
4. The storing forms for each place are evaluated in left-to-right order.
The storing form in the setf expansion ofvalues returns as multiple values 2the values of the store
variables in step 2. That is, the number of values returned is the same as the number of place
forms. This may be more or fewer values than are produced by the values-form .
5.1.2.4 THE Forms as Places
Atheform can be used as a place , in which case the declaration is transferred to the newvalue
form, and the resulting setf is analyzed. For example,
(setf (the integer (cadr x)) (+ y 3))
is processed as if it were
(setf (cadr x) (the integer (+ y 3)))
Data and Control Flow 5–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
5.1.2.5 APPLY Forms as Places
The following situations involving setf ofapply must be supported:
(setf (apply #’aref arrayfsubscriptg*more-subscripts )new-element )
(setf (apply #’bit arrayfsubscriptg*more-subscripts )new-element )
(setf (apply #’sbit arrayfsubscriptg*more-subscripts )new-element )
In all three cases, the element ofarray designated by the concatenation of subscripts and
more-subscripts (i.e., the same element which would be read by the call to apply if it were not part
of asetf form ) is changed to have the value given by new-element . For these usages, the function
name (aref,bit, orsbit) must refer to the global function denition, rather than a locally dened
function .
No other standardized function is required to be supported, but an implementation may dene
such support. An implementation may also dene support for implementation-dened operators .
If a user-dened function is used in this context, the following equivalence is true, except that care
is taken to preserve proper left-to-right evaluation of argument subforms :
(setf (apply #’ namefargg*)val)
(apply #’(setf name)valfargg*)
5.1.2.6 Setf Expansions and Places
Any compound form for which the operator has a setf expander dened can be used as a place .
The operator must refer to the global function denition, rather than a locally dened function or
macro .
5.1.2.7 Macro Forms as Places
Amacro form can be used as a place , in which case Common Lisp expands the macro form as if
bymacroexpand-1 and then uses the macro expansion in place of the original place . Such macro
expansion is attempted only after exhausting all other possibilities other than expanding into a call
to a function named (setf reader).
5.1.2.8 Symbol Macros as Places
A reference to a symbol that has been established as a symbol macro can be used as a place . In
this case, setf expands the reference and then analyzes the resulting form .
5–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
5.1.2.9 Other Compound Forms as Places
For any other compound form for which the operator is asymbol f, thesetf form expands into a
call to the function named(setf f). The rst argument in the newly constructed function form is
newvalue and the remaining arguments are the remaining elements ofplace . This expansion occurs
regardless of whether for(setf f)is dened as a function locally, globally, or not at all. For
example,
(setf ( f arg1 arg2 ...) new-value )
expands into a form with the same eect and value as
(let ((#:temp-1 arg1) ;force correct order of evaluation
(#:temp-2 arg2)
...
(#:temp-0 new-value ))
(funcall (function (setf f)) #:temp-0 #:temp-1 #:temp-2...))
Afunction named(setf f)must return its rst argument as its only value in order to preserve the
semantics of setf.
5.1.3 Treatment of Other Macros Based on SETF
For each of the \read-modify-write" operators in Figure 5{9, and for any additional macros dened
by the programmer usingdeﬁne-modify-macro , an exception is made to the normal rule of
left-to-right evaluation of arguments. Evaluation of argument forms occurs in left-to-right order,
with the exception that for the place argument , the actual read of the \old value" from that place
happens after all of the argument form evaluations , and just before a \new value" is computed
and written back into the place .
Specically, each of these operators can be viewed as involving a form with the following general
syntax:
(operatorfpreceding-formg*placeffollowing-formg*)
The evaluation of each such form proceeds like this:
1.Evaluate each of the preceding-forms , in left-to-right order.
2.Evaluate thesubforms of the place , in the order specied by the second value of the setf
expansion for that place .
3.Evaluate each of the following-forms , in left-to-right order.
4.Read the old value from place .
5. Compute the new value.
6. Store the new value into place .
Data and Control Flow 5–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
decf pop pushnew
incf push remf
Figure 5–9. Read-Modify-Write Macros
5–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
5.2 Transfer of Control to an Exit Point
When a transfer of control is initiated by go,return-from , orthrow the following events occur in
order to accomplish the transfer of control. Note that for go, the exit point is the form within the
tagbody that is being executed at the time the gois performed; for return-from , the exit point is
the corresponding block form ; and for throw , the exit point is the corresponding catch form .
1. Intervening exit points are \abandoned" ( i.e., their extent ends and it is no longer valid to
attempt to transfer control through them).
2. The cleanup clauses of any intervening unwind-protect clauses are evaluated.
3. Intervening dynamic bindings ofspecial variables, catch tags ,condition handlers , and
restarts are undone.
4. The extent of the exit point being invoked ends, and control is passed to the target.
The extent of an exit being \abandoned" because it is being passed over ends as soon as the
transfer of control is initiated. That is, event 1 occurs at the beginning of the initiation of the
transfer of control. The consequences are undened if an attempt is made to transfer control to an
exit point whose dynamic extent has ended.
Events 2 and 3 are actually performed interleaved, in the order corresponding to the reverse order
in which they were established. The eect of this is that the cleanup clauses of an unwind-protect
see the same dynamic bindings of variables and catch tags as were visible when the unwind-protect
was entered.
Event 4 occurs at the end of the transfer of control.
Data and Control Flow 5–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
apply Function
Syntax:
apply function &rest args+!f resultg*
Arguments and Values:
function |afunction designator .
args|aspreadable argument list designator .
results |the values returned by function .
Description:
Applies thefunction to the args.
When the function receives its arguments via &rest , it is permissible (but not required) for
theimplementation tobind therest parameter to an object that shares structure with the last
argument to apply . Because a function can neither detect whether it was called via apply nor
whether (if so) the last argument to apply was a constant ,conforming programs must neither rely
on the liststructure of a rest list to be freshly consed, nor modify that liststructure.
setfcan be used with apply in certain circumstances; see Section 5.1.2.5 (APPLY Forms as Places).
Examples:
(setq f ’+)!+
(apply f ’(1 2)) !3
(setq f #’-)!#<FUNCTION ->
(apply f ’(1 2)) !-1
(apply #’max 3 5 ’(2 7 3)) !7
(apply ’cons ’((+ 2 3) 4)) !((+ 2 3) . 4)
(apply #’+ ’()) !0
(defparameter *some-list* ’(a b c))
(defun strange-test (&rest x) (eq x *some-list*))
(apply #’strange-test *some-list*) !implementation-dependent
(defun bad-boy (&rest x) (rplacd x ’y))
(bad-boy ’a ’b ’c) has undefined consequences.
(apply #’bad-boy *some-list*) has undefined consequences.
(defun foo (size &rest keys &key double &allow-other-keys)
(let ((v (apply #’make-array size :allow-other-keys t keys)))
(if double (concatenate (type-of v) v v) v)))
(foo 4 :initial-contents ’(a b c d) :double t)
5–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
!#(A B C D A B C D)
See Also:
funcall ,fdeﬁnition ,function , Section 3.1 (Evaluation), Section 5.1.2.5 (APPLY Forms as Places)
defun Macro
Syntax:
defun function-name lambda-list [ [fdeclarationg*jdocumentation ] ]fformg*
!function-name
Arguments and Values:
function-name |afunction name .
lambda-list |an ordinary lambda list .
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
forms |an implicit progn .
block-name |the function block name of the function-name .
Description:
Denes a new function named function-name in the global environment . The body of the function
dened by defun consists of forms ; they are executed as an implicit progn when the function is
called.defun can be used to dene a new function , to install a corrected version of an incorrect
denition, to redene an already-dened function , or to redene a macro as a function .
defun implicitly puts a block named block-name around the body forms (but not the forms in the
lambda-list ) of the function dened.
Documentation is attached as a documentation string toname (as kind function ) and to the
function object .
Evaluating defun causes function-name to be a global name for the function specied by the lambda
expression
(lambda lambda-list
[ [fdeclarationg*jdocumentation ] ]
(block block-namefformg*))
processed in the lexical environment in which defun was executed.
Data and Control Flow 5–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defun
(None of the arguments are evaluated at macro expansion time.)
defun is not required to perform any compile-time side eects. In particular, defun does not
make the function denition available at compile time. An implementation may choose to store
information about the function for the purposes of compile-time error-checking (such as checking
the number of arguments on calls), or to enable the function to be expanded inline.
Examples:
(defun recur (x)
(when (> x 0)
(recur (1- x)))) !RECUR
(defun ex (a b &optional c (d 66) &rest keys &key test (start 0))
(list a b c d keys test start)) !EX
(ex 1 2)!(1 2 NIL 66 NIL NIL 0)
(ex 1 2 3 4 :test ’equal :start 50)
!(1 2 3 4 (:TEST EQUAL :START 50) EQUAL 50)
(ex :test 1 :start 2) !(:TEST 1 :START 2 NIL NIL 0)
;; This function assumes its callers have checked the types of the
;; arguments, and authorizes the compiler to build in that assumption.
(defun discriminant (a b c)
(declare (number a b c))
"Compute the discriminant for a quadratic equation."
(- (* b b) (* 4 a c))) !DISCRIMINANT
(discriminant 1 2/3 -2) !76/9
;; This function assumes its callers have not checked the types of the
;; arguments, and performs explicit type checks before making any assumptions.
(defun careful-discriminant (a b c)
"Compute the discriminant for a quadratic equation."
(check-type a number)
(check-type b number)
(check-type c number)
(locally (declare (number a b c))
(- (* b b) (* 4 a c)))) !CAREFUL-DISCRIMINANT
(careful-discriminant 1 2/3 -2) !76/9
See Also:
ﬂet,labels ,block ,return-from ,declare ,documentation , Section 3.1 (Evaluation), Section 3.4.1
(Ordinary Lambda Lists), Section 3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations)
Notes:
return-from can be used to return prematurely from a function dened by defun .
5–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Additional side eects might take place when additional information (typically debugging
information) about the function denition is recorded.
fdeﬁnition Accessor
Syntax:
fdeﬁnition function-name!denition
(setf (fdeﬁnition function-name )new-denition )
Arguments and Values:
function-name |afunction name . In the non- setf case, the name must be fbound in the global
environment .
denition |Current global function denition named by function-name .
new-denition |afunction .
Description:
fdeﬁnition accesses the current global function denition named by function-name . The denition
may be a function or may be an object representing a special form ormacro . The value returned
byfdeﬁnition whenfboundp returns true but the function-name denotes a macro orspecial form
is not well-dened, but fdeﬁnition does not signal an error.
Exceptional Situations:
Should signal an error of typetype-error iffunction-name is not a function name .
An error of typeundeﬁned-function is signaled in the non- setfcase if function-name is not fbound .
See Also:
fboundp ,fmakunbound ,macro-function ,special-operator-p ,symbol-function
Notes:
fdeﬁnition cannot access the value of a lexical function name produced by ﬂetorlabels ; it can
access only the global function value.
setf can be used with fdeﬁnition to replace a global function denition when the function-name 's
function denition does not represent a special form .setf offdeﬁnition requires a function as the
new value. It is an error to set the fdeﬁnition of a function-name to a symbol , alist, or the value
returned by fdeﬁnition on the name of a macro orspecial form .
Data and Control Flow 5–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
fboundp
fboundp Function
Syntax:
fboundp name!generalized-boolean
Pronunciation:
[efba_undp—e]
Arguments and Values:
name |afunction name .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifname isfbound ; otherwise, returns false.
Examples:
(fboundp ’car)!true
(fboundp ’nth-value) !false
(fboundp ’with-open-file) !true
(fboundp ’unwind-protect) !true
(defun my-function (x) x) !MY-FUNCTION
(fboundp ’my-function) !true
(let ((saved-definition (symbol-function ’my-function)))
(unwind-protect (progn (fmakunbound ’my-function)
(fboundp ’my-function))
(setf (symbol-function ’my-function) saved-definition)))
!false
(fboundp ’my-function) !true
(defmacro my-macro (x) ‘’,x) !MY-MACRO
(fboundp ’my-macro) !true
(fmakunbound ’my-function) !MY-FUNCTION
(fboundp ’my-function) !false
(flet ((my-function (x) x))
(fboundp ’my-function)) !false
Exceptional Situations:
Should signal an error of typetype-error ifname is not a function name .
See Also:
symbol-function ,fmakunbound ,fdeﬁnition
5–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
It is permissible to call symbol-function on any symbol that is fbound .
fboundp is sometimes used to \guard" an access to the function cell , as in: (if (fboundp x)
(symbol-function x))
Dening a setf expander Fdoes not cause the setf function (setf F)to become dened.
fmakunbound Function
Syntax:
fmakunbound name!name
Pronunciation:
[efmaknba_und]or[efm—aknba_und]
Arguments and Values:
name |afunction name .
Description:
Removes the function ormacro denition, if any, of name in the global environment .
Examples:
(defun add-some (x) (+ x 19)) !ADD-SOME
(fboundp ’add-some) !true
(flet ((add-some (x) (+ x 37)))
(fmakunbound ’add-some)
(add-some 1))!38
(fboundp ’add-some) !false
Exceptional Situations:
Should signal an error of typetype-error ifname is not a function name .
The consequences are undened if name is aspecial operator .
See Also:
fboundp ,makunbound
Data and Control Flow 5–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬂet, labels, macrolet
ﬂet,labels,macrolet Special Operator
Syntax:
ﬂet(f(function-name lambda-list [ [flocal-declarationg*jlocal-documentation ] ]flocal-formg*)g*)
fdeclarationg*fformg*
!f resultg*
labels (f(function-name lambda-list [ [flocal-declarationg*jlocal-documentation ] ]flocal-formg*)g*)
fdeclarationg*fformg*
!f resultg*
macrolet (f(name lambda-list [ [flocal-declarationg*jlocal-documentation ] ]flocal-formg*)g*)
fdeclarationg*fformg*
!f resultg*
Arguments and Values:
function-name |afunction name .
name |asymbol .
lambda-list |alambda list ; forﬂetandlabels , it is an ordinary lambda list ; formacrolet , it is a
macro lambda list .
local-declaration |adeclare expression ; not evaluated.
declaration |adeclare expression ; not evaluated.
local-documentation |astring ; not evaluated.
local-forms ,forms |an implicit progn .
results |the values of the forms .
Description:
ﬂet,labels , andmacrolet dene local functions and macros , and execute forms using the local
denitions. Forms are executed in order of occurrence.
The body forms (but not the lambda list ) of each function created by ﬂetandlabels and each
macro created by macrolet are enclosed in an implicit block whose name is the function block
name of the function-name orname , as appropriate.
The scope of the declarations between the list of local function/macro denitions and the body
forms inﬂetandlabels does not include the bodies of the locally dened functions , except that
5–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬂet, labels, macrolet
forlabels , anyinline ,notinline , orftype declarations that refer to the locally dened functions do
apply to the local function bodies. That is, their scope is the same as the function name that they
aect. The scope of these declarations does not include the bodies of the macro expander functions
dened by macrolet .
ﬂet
ﬂetdenes locally named functions and executes a series of forms with these denition
bindings . Any number of such local functions can be dened.
The scope of the name binding encompasses only the body. Within the body of ﬂet,
function-names matching those dened by ﬂetrefer to the locally dened functions rather
than to the global function denitions of the same name. Also, within the scope of ﬂet,
global setf expander denitions of the function-name dened by ﬂetdo not apply. Note
that this applies to (defsetf f...), not(defmethod (setf f) ...) .
The names of functions dened by ﬂetare in the lexical environment ; they retain their
local denitions only within the body of ﬂet. The function denition bindings are visible
only in the body of ﬂet, not the denitions themselves. Within the function denitions,
local function names that match those being dened refer to functions ormacros dened
outside the ﬂet.ﬂetcan locally shadow a global function name, and the new denition
can refer to the global denition.
Any local-documentation is attached to the corresponding local function (if one is actually
created) as a documentation string .
labels
labels is equivalent to ﬂetexcept that the scope of the dened function names for labels
encompasses the function denitions themselves as well as the body.
macrolet
macrolet establishes local macro denitions, using the same format used by defmacro .
Within the body of macrolet , global setf expander denitions of the names dened by the
macrolet do not apply; rather, setf expands the macro form and recursively process the
resulting form .
The macro-expansion functions dened by macrolet are dened in the lexical environment
in which the macrolet form appears. Declarations and macrolet andsymbol-macrolet
denitions aect the local macro denitions in a macrolet , but the consequences are
undened if the local macro denitions reference any local variable orfunction bindings
that are visible in that lexical environment .
Any local-documentation is attached to the corresponding local macro function as a
documentation string .
Data and Control Flow 5–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬂet, labels, macrolet
Examples:
(defun foo (x flag)
(macrolet ((fudge (z)
;The parameters x and flag are not accessible
; at this point; a reference to flag would be to
; the global variable of that name.
‘(if flag (* ,z ,z) ,z)))
;The parameters x and flag are accessible here.
(+ x
(fudge x)
(fudge (+ x 1)))))

(defun foo (x flag)
(+ x
(if flag (* x x) x)
(if flag (* (+ x 1) (+ x 1)) (+ x 1))))
after macro expansion. The occurrences of xandflag legitimately refer to the parameters of the
function foobecause those parameters are visible at the site of the macro call which produced the
expansion.
(flet ((flet1 (n) (+ n n)))
(flet ((flet1 (n) (+ 2 (flet1 n))))
(flet1 2)))!6
(defun dummy-function () ’top-level) !DUMMY-FUNCTION
(funcall #’dummy-function) !TOP-LEVEL
(flet ((dummy-function () ’shadow))
(funcall #’dummy-function)) !SHADOW
(eq (funcall #’dummy-function) (funcall ’dummy-function))
!true
(flet ((dummy-function () ’shadow))
(eq (funcall #’dummy-function)
(funcall ’dummy-function)))
!false
(defun recursive-times (k n)
(labels ((temp (n)
(if (zerop n) 0 (+ k (temp (1- n))))))
(temp n)))!RECURSIVE-TIMES
(recursive-times 2 3) !6
(defmacro mlets (x &environment env)
(let ((form ‘(babbit ,x)))
(macroexpand form env))) !MLETS
5–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬂet, labels, macrolet
(macrolet ((babbit (z) ‘(+ ,z ,z))) (mlets 5)) !10
(flet ((safesqrt (x) (sqrt (abs x))))
;; The safesqrt function is used in two places.
(safesqrt (apply #’+ (map ’list #’safesqrt ’(1 2 3 4 5 6)))))
!3.291173
(defun integer-power (n k)
(declare (integer n))
(declare (type (integer 0 *) k))
(labels ((expt0 (x k a)
(declare (integer x a) (type (integer 0 *) k))
(cond ((zerop k) a)
((evenp k) (expt1 (* x x) (floor k 2) a))
(t (expt0 (* x x) (floor k 2) (* x a)))))
(expt1 (x k a)
(declare (integer x a) (type (integer 0 *) k))
(cond ((evenp k) (expt1 (* x x) (floor k 2) a))
(t (expt0 (* x x) (floor k 2) (* x a))))))
(expt0 n k 1))) !INTEGER-POWER
(defun example (y l)
(flet ((attach (x)
(setq l (append l (list x)))))
(declare (inline attach))
(dolist (x y)
(unless (null (cdr x))
(attach x)))
l))
(example ’((a apple apricot) (b banana) (c cherry) (d) (e))
’((1) (2) (3) (4 2) (5) (6 3 2)))
!((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY))
See Also:
declare ,defmacro ,defun ,documentation ,let, Section 3.1 (Evaluation), Section 3.4.11 (Syntactic
Interaction of Documentation Strings and Declarations)
Notes:
It is not possible to dene recursive functions withﬂet.labels can be used to dene mutually
recursive functions .
If amacrolet form is atop level form , the body forms are also processed as top level forms . See
Section 3.2.3 (File Compilation).
Data and Control Flow 5–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
funcall Function
Syntax:
funcall function &rest args!f resultg*
Arguments and Values:
function |afunction designator .
args|arguments to the function .
results |the values returned by the function .
Description:
funcall applies function toargs. Iffunction is asymbol , it is coerced to a function as if by nding
itsfunctional value in the global environment .
Examples:
(funcall #’+ 1 2 3) !6
(funcall ’car ’(1 2 3)) !1
(funcall ’position 1 ’(1 2 3 2 1) :start 1) !4
(cons 1 2)!(1 . 2)
(flet ((cons (x y) ‘(kons ,x ,y)))
(let ((cons (symbol-function ’+)))
(funcall #’cons
(funcall ’cons 1 2)
(funcall cons 1 2))))
!(KONS (1 . 2) 3)
Exceptional Situations:
An error of typeundeﬁned-function should be signaled if function is asymbol that does not have
a global denition as a function or that has a global denition as a macro or a special operator .
See Also:
apply ,function , Section 3.1 (Evaluation)
Notes:
(funcall function arg1 arg2 ...)
(apply function arg1 arg2 ... nil)
(apply function (list arg1 arg2 ...))
The dierence between funcall and an ordinary function call is that in the former case the function
5–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
is obtained by ordinary evaluation of a form , and in the latter case it is obtained by the special
interpretation of the function position that normally occurs.
function Special Operator
Syntax:
function name!function
Arguments and Values:
name |afunction name orlambda expression .
function |afunction object .
Description:
The value offunction is the functional value ofname in the current lexical environment .
Ifname is a function name , the functional denition of that name is that established by the
innermost lexically enclosing ﬂet,labels , ormacrolet form , if there is one. Otherwise the global
functional denition of the function name is returned.
Ifname is a lambda expression , then a lexical closure is returned. In situations where a closure
over the same set of bindings might be produced more than once, the various resulting closures
might or might not be eq.
It is an error to use function on a function name that does not denote a function in the lexical
environment in which the function form appears. Specically, it is an error to use function on a
symbol that denotes a macro orspecial form . An implementation may choose not to signal this
error for performance reasons, but implementations are forbidden from dening the failure to signal
an error as a useful behavior.
Examples:
(defun adder (x) (function (lambda (y) (+ x y))))
The result of (adder 3) is a function that adds 3to its argument:
(setq add3 (adder 3))
(funcall add3 5) !8
This works because function creates a closure of the lambda expression that is able to refer to the
value3of the variable xeven after control has returned from the function adder .
See Also:
defun ,fdeﬁnition ,ﬂet,labels ,symbol-function , Section 3.1.2.1.1 (Symbols as Forms), Section
2.4.8.2 (Sharpsign Single-Quote), Section 22.1.3.13 (Printing Other Objects)
Data and Control Flow 5–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
The notation #’name may be used as an abbreviation for (function name).
function-lambda-expression Function
Syntax:
function-lambda-expression function
!lambda-expression, closure-p, name
Arguments and Values:
function |afunction .
lambda-expression |alambda expression ornil.
closure-p |ageneralized boolean .
name |an object .
Description:
Returns information about function as follows:
The primary value ,lambda-expression , is function 's dening lambda expression , ornilif the
information is not available. The lambda expression may have been pre-processed in some ways,
but it should remain a suitable argument to compile orfunction . Any implementation may
legitimately return nilas the lambda-expression of any function .
The secondary value ,closure-p , isniliffunction 's denition was enclosed in the null lexical
environment or something non-nil iffunction 's denition might have been enclosed in some
non-null lexical environment . Any implementation may legitimately return true as the closure-p of
any function .
The tertiary value ,name , is the \name" of function . The name is intended for debugging only and
is not necessarily one that would be valid for use as a name in defun orfunction , for example. By
convention, nilis used to mean that function has no name. Any implementation may legitimately
returnnilas the name of any function .
Examples:
The following examples illustrate some possible return values, but are not intended to be exhaustive:
(function-lambda-expression #’(lambda (x) x))
!NIL, false, NIL
or!NIL, true, NILor!(LAMBDA (X) X), true, NILor!(LAMBDA (X) X), false, NIL
5–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(function-lambda-expression
(funcall #’(lambda () #’(lambda (x) x))))
!NIL, false, NIL
or!NIL, true, NILor!(LAMBDA (X) X), true, NILor!(LAMBDA (X) X), false, NIL
(function-lambda-expression
(funcall #’(lambda (x) #’(lambda () x)) nil))
!NIL, true, NILor!(LAMBDA () X), true, NIL
not!NIL, false, NIL
not!(LAMBDA () X), false, NIL
(flet ((foo (x) x))
(setf (symbol-function ’bar) #’foo)
(function-lambda-expression #’bar))
!NIL, false, NIL
or!NIL, true, NILor!(LAMBDA (X) (BLOCK FOO X)), true, NILor!(LAMBDA (X) (BLOCK FOO X)), false, FOO
or!(SI::BLOCK-LAMBDA FOO (X) X), false, FOO
(defun foo ()
(flet ((bar (x) x))
#’bar))
(function-lambda-expression (foo))
!NIL, false, NIL
or!NIL, true, NILor!(LAMBDA (X) (BLOCK BAR X)), true, NILor!(LAMBDA (X) (BLOCK BAR X)), true, (:INTERNAL FOO 0 BAR)or!(LAMBDA (X) (BLOCK BAR X)), false, "BAR in FOO"
Notes:
Although implementations are free to return \ nil,true,nil" in all cases, they are encouraged to
return a lambda expression as the primary value in the case where the argument was created by a
call tocompile oreval (as opposed to being created by loading acompiled le ).
Data and Control Flow 5–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
functionp Function
Syntax:
functionp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typefunction ; otherwise, returns false.
Examples:
(functionp ’append) !false
(functionp #’append) !true
(functionp (symbol-function ’append)) !true
(flet ((f () 1)) (functionp #’f)) !true
(functionp (compile nil ’(lambda () 259))) !true
(functionp nil) !false
(functionp 12)!false
(functionp ’(lambda (x) (* x x))) !false
(functionp #’(lambda (x) (* x x))) !true
Notes:
(functionp object)(typep object’function)
compiled-function-p Function
Syntax:
compiled-function-p object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typecompiled-function ; otherwise, returns false.
5–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(defun f (x) x) !F
(compiled-function-p #’f)
!false
or!true
(compiled-function-p ’f) !false
(compile ’f)!F
(compiled-function-p #’f) !true
(compiled-function-p ’f) !false
(compiled-function-p (compile nil ’(lambda (x) x)))
!true
(compiled-function-p #’(lambda (x) x))
!false
or!true
(compiled-function-p ’(lambda (x) x)) !false
See Also:
compile ,compile-ﬁle ,compiled-function
Notes:
(compiled-function-p object)(typep object’compiled-function)
call-arguments-limit Constant Variable
Constant Value:
An integer not smaller than 50and at least as great as the value oflambda-parameters-limit , the
exact magnitude of which is implementation-dependent .
Description:
The upper exclusive bound on the number of arguments that may be passed to a function .
See Also:
lambda-parameters-limit ,multiple-values-limit
Data and Control Flow 5–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
lambda-list-keywords Constant Variable
Constant Value:
alist, the elements of which are implementation-dependent , but which must contain at least
thesymbols&allow-other-keys ,&aux ,&body ,&environment ,&key ,&optional ,&rest , and
&whole .
Description:
Alistof all the lambda list keywords used in the implementation , including the additional ones
used only by macro denition forms .
See Also:
defun ,ﬂet,defmacro ,macrolet , Section 3.1.2 (The Evaluation Model)
lambda-parameters-limit Constant Variable
Constant Value:
implementation-dependent , but not smaller than 50.
Description:
A positive integer that is the upper exclusive bound on the number of parameter names that can
appear in a single lambda list .
See Also:
call-arguments-limit
Notes:
Implementors are encouraged to make the value oflambda-parameters-limit as large as possible.
5–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defconstant
defconstant Macro
Syntax:
defconstant name initial-value [documentation ]!name
Arguments and Values:
name |asymbol ; not evaluated.
initial-value |aform ; evaluated.
documentation |astring ; not evaluated.
Description:
defconstant causes the global variable named by name to be given a value that is the result of
evaluating initial-value .
A constant dened by defconstant can be redened with defconstant . However, the consequences
are undened if an attempt is made to assign a value to the symbol using another operator, or to
assign it to a dierent value using a subsequent defconstant .
Ifdocumentation is supplied, it is attached to name as a documentation string of kindvariable .
defconstant normally appears as a top level form , but it is meaningful for it to appear as a
non-top-level form . However, the compile-time side eects described below only take place when
defconstant appears as a top level form .
The consequences are undened if there are any bindings of the variable named by name at the
timedefconstant is executed or if the value is not eqlto the value of initial-value .
The consequences are undened when constant symbols are rebound as either lexical or dynamic
variables. In other words, a reference to a symbol declared with defconstant always refers to its
global value.
The side eects of the execution of defconstant must be equivalent to at least the side eects of
the execution of the following code:
(setf (symbol-value ’ name)initial-value )
(setf (documentation ’ name’variable) ’ documentation )
If adefconstant form appears as a top level form , the compiler must recognize that name names a
constant variable . An implementation may choose to evaluate the value-form at compile time, load
time, or both. Therefore, users must ensure that the initial-value can be evaluated at compile time
(regardless of whether or not references to name appear in the le) and that it always evaluates to
the same value.
Data and Control Flow 5–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(defconstant this-is-a-constant ’never-changing "for a test") !THIS-IS-A-CONSTANT
this-is-a-constant !NEVER-CHANGING
(documentation ’this-is-a-constant ’variable) !"for a test"
(constantp ’this-is-a-constant) !true
See Also:
declaim ,defparameter ,defvar ,documentation ,proclaim , Section 3.1.2.1.1.3 (Constant
Variables), Section 3.2 (Compilation)
defparameter,defvar Macro
Syntax:
defparameter name initial-value [documentation ]!name
defvar name[initial-value [documentation ]]!name
Arguments and Values:
name |asymbol ; not evaluated.
initial-value |aform ; fordefparameter , it is always evaluated , but fordefvar it is evaluated only if
name is not already bound .
documentation |a string ; not evaluated.
Description:
defparameter anddefvar establish name as a dynamic variable .
defparameter unconditionally assigns the initial-value to the dynamic variable named name .
defvar , by contrast, assigns initial-value (if supplied) to the dynamic variable named name only if
name is not already bound .
If no initial-value is supplied, defvar leaves the value cell of the dynamic variable named name
undisturbed; if name was previously bound , its old value persists, and if it was previously unbound ,
it remains unbound .
Ifdocumentation is supplied, it is attached to name as a documentation string of kindvariable .
defparameter anddefvar normally appear as a top level form , but it is meaningful for them to
appear as non-top-level forms . However, the compile-time side eects described below only take
place when they appear as top level forms .
5–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defparameter, defvar
Examples:
(defparameter *p* 1) !*P*
*p*!1
(constantp ’*p*) !false
(setq *p* 2)!2
(defparameter *p* 3) !*P*
*p*!3
(defvar *v* 1)!*V*
*v*!1
(constantp ’*v*) !false
(setq *v* 2)!2
(defvar *v* 3)!*V*
*v*!2
(defun foo ()
(let ((*p* ’p) (*v* ’v))
(bar)))!FOO
(defun bar () (list *p* *v*)) !BAR
(foo)!(P V)
The principal operational distinction between defparameter anddefvar is thatdefparameter
makes an unconditional assignment to name , whiledefvar makes a conditional one. In practice,
this means that defparameter is useful in situations where loading or reloading the denition
would want to pick up a new value of the variable, while defvar is used in situations where the old
value would want to be retained if the le were loaded or reloaded. For example, one might create
a le which contained:
(defvar *the-interesting-numbers* ’())
(defmacro define-interesting-number (name n)
‘(progn (defvar ,name ,n)
(pushnew ,name *the-interesting-numbers*)
’,name))
(define-interesting-number *my-height* 168) ;cm
(define-interesting-number *my-weight* 13) ;stones
Here the initial value, (), for the variable *the-interesting-numbers* is just a seed that we are
never likely to want to reset to something else once something has been grown from it. As such, we
have used defvar to avoid having the *interesting-numbers* information reset if the le is loaded a
second time. It is true that the two calls to deﬁne-interesting-number here would be reprocessed,
but if there were additional calls in another le, they would not be and that information would be
lost. On the other hand, consider the following code:
(defparameter *default-beep-count* 3)
(defun beep (&optional (n *default-beep-count*))
(dotimes (i n) (si:%beep 1000. 100000.) (sleep 0.1)))
Data and Control Flow 5–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defparameter, defvar
Here we could easily imagine editing the code to change the initial value of *default-beep-count* ,
and then reloading the le to pick up the new value. In order to make value updating easy, we
have used defparameter .
On the other hand, there is potential value to using defvar in this situation. For example, suppose
that someone had predened an alternate value for *default-beep-count* , or had loaded the le and
then manually changed the value. In both cases, if we had used defvar instead of defparameter ,
those user preferences would not be overridden by (re)loading the le.
The choice of whether to use defparameter ordefvar has visible consequences to programs, but is
nevertheless often made for subjective reasons.
Side Eﬀects:
If adefvar ordefparameter form appears as a top level form , the compiler must recognize that
thename has been proclaimed special . However, it must neither evaluate theinitial-value form nor
assign thedynamic variable named name at compile time.
There may be additional ( implementation-dened ) compile-time or run-time side eects, as long as
such eects do not interfere with the correct operation of conforming programs .
Aﬀected By:
defvar is aected by whether name is already bound .
See Also:
declaim ,defconstant ,documentation , Section 3.2 (Compilation)
Notes:
It is customary to name dynamic variables with an asterisk at the beginning and end of the name.
e.g.,*foo* is a good name for a dynamic variable , but not for a lexical variable ;foois a good
name for a lexical variable , but not for a dynamic variable . This naming convention is observed
for all dened names in Common Lisp; however, neither conforming programs norconforming
implementations are obliged to adhere to this convention.
The intent of the permission for additional side eects is to allow implementations to do normal
\bookkeeping" that accompanies denitions. For example, the macro expansion of adefvar or
defparameter form might include code that arranges to record the name of the source le in which
the denition occurs.
defparameter anddefvar might be dened as follows:
(defmacro defparameter (name initial-value
&optional (documentation nil documentation-p))
‘(progn (declaim (special ,name))
(setf (symbol-value ’,name) ,initial-value)
,(when documentation-p
‘(setf (documentation ’,name ’variable) ’,documentation))
’,name))
5–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defmacro defvar (name &optional
(initial-value nil initial-value-p)
(documentation nil documentation-p))
‘(progn (declaim (special ,name))
,(when initial-value-p
‘(unless (boundp ’,name)
(setf (symbol-value ’,name) ,initial-value)))
,(when documentation-p
‘(setf (documentation ’,name ’variable) ’,documentation))
’,name))
destructuring-bind Macro
Syntax:
destructuring-bind lambda-list expression fdeclarationg*fformg*
!f resultg*
Arguments and Values:
lambda-list |adestructuring lambda list .
expression |aform .
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values returned by the forms .
Description:
destructuring-bind binds the variables specied in lambda-list to the corresponding values in the
tree structure resulting from the evaluation of expression ; thendestructuring-bind evaluates forms .
The lambda-list supports destructuring as described in Section 3.4.5 (Destructuring Lambda Lists).
Examples:
(defun iota (n) (loop for i from 1 to n collect i)) ;helper
(destructuring-bind ((a &optional (b ’bee)) one two three)
‘((alpha) ,@(iota 3))
(list a b three two one)) !(ALPHA BEE 3 2 1)
Data and Control Flow 5–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
If the result of evaluating the expression does not match the destructuring pattern, an error of type
error should be signaled.
See Also:
macrolet ,defmacro
let,let Special Operator
Syntax:
let(fvarj(var[init-form ])g*)fdeclarationg*fformg*!f resultg*
let* (fvarj(var[init-form ])g*)fdeclarationg*fformg*!f resultg*
Arguments and Values:
var|asymbol .
init-form |aform .
declaration |adeclare expression ; not evaluated.
form|aform .
results |the values returned by the forms .
Description:
letandlet*create new variable bindings and execute a series of forms that use these bindings .let
performs the bindings in parallel and let*does them sequentially.
The form
(let (( var1 init-form-1 )
(var2 init-form-2 )
...
(varm init-form-m ))
declaration1
declaration2
...
declarationp
form1
form2
...
formn)
5–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
let, let
rst evaluates the expressions init-form-1 ,init-form-2 , and so on, in that order, saving the resulting
values. Then all of the variables varjare bound to the corresponding values; each binding is lexical
unless there is a special declaration to the contrary. The expressions formk are then evaluated in
order; the values of all but the last are discarded (that is, the body of a letis an implicit progn ).
let* is similar to let, but the bindings of variables are performed sequentially rather than in
parallel. The expression for the init-form of a varcan refer to varspreviously bound in the let*.
The form
(let* (( var1 init-form-1 )
(var2 init-form-2 )
...
(varm init-form-m ))
declaration1
declaration2
...
declarationp
form1
form2
...
formn)
rst evaluates the expression init-form-1 , then binds the variable var1 to that value; then it
evaluates init-form-2 and binds var2, and so on. The expressions formj are then evaluated in order;
the values of all but the last are discarded (that is, the body of let*is an implicit progn ).
For both letandlet*, if there is not an init-form associated with a var,varis initialized to nil.
The special form lethas the property that the scope of the name binding does not include any
initial value form. For let*, a variable's scope also includes the remaining initial value forms for
subsequent variable bindings.
Examples:
(setq a ’top)!TOP
(defun dummy-function () a) !DUMMY-FUNCTION
(let ((a ’inside) (b a))
(format nil "~S ~S ~S" a b (dummy-function))) !"INSIDE TOP TOP"
(let* ((a ’inside) (b a))
(format nil "~S ~S ~S" a b (dummy-function))) !"INSIDE INSIDE TOP"
(let ((a ’inside) (b a))
(declare (special a))
(format nil "~S ~S ~S" a b (dummy-function))) !"INSIDE TOP INSIDE"
The code
(let (x)
Data and Control Flow 5–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(declare (integer x))
(setq x (gcd y z))
...)
is incorrect; although xis indeed set before it is used, and is set to a value of the declared type
integer , nevertheless xinitially takes on the value nilin violation of the type declaration.
See Also:
progv
progv Special Operator
Syntax:
progv symbols valuesfformg*!f resultg*
Arguments and Values:
symbols |alistofsymbols ; evaluated.
values |alistofobjects ; evaluated.
forms |an implicit progn .
results |the values returned by the forms .
Description:
progv creates new dynamic variable bindings and executes each form using those bindings . Each
form is evaluated in order.
progv allows binding one or more dynamic variables whose names may be determined at run time.
Each form is evaluated in order with the dynamic variables whose names are in symbols bound to
corresponding values . If too few values are supplied, the remaining symbols are bound and then
made to have no value. If too many values are supplied, the excess values are ignored. The bindings
of the dynamic variables are undone on exit from progv .
Examples:
(setq *x* 1)!1
(progv ’(*x*) ’(2) *x*) !2
*x*!1
Assuming *x* is not globally special,
(let ((*x* 3))
(progv ’(*x*) ’(4)
(list *x* (symbol-value ’*x*)))) !(3 4)
5–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
let, Section 3.1 (Evaluation)
Notes:
Among other things, progv is useful when writing interpreters for languages embedded in Lisp; it
provides a handle on the mechanism for binding dynamic variables .
setq Special Form
Syntax:
setqf#pairg*!result
pair:: =var form
Pronunciation:
[setky/hyphen.altu]
Arguments and Values:
var|asymbol naming a variable other than a constant variable .
form|aform .
result |the primary value of the last form, ornilif no pairs were supplied.
Description:
Assigns values to variables .
(setq var1 form1 var2 form2 ...) is the simple variable assignment statement of Lisp. First
form1 is evaluated and the result is stored in the variable var1, then form2 is evaluated and the
result stored in var2, and so forth. setq may be used for assignment of both lexical and dynamic
variables.
If any varrefers to a binding made by symbol-macrolet , then that varis treated as if setf (not
setq) had been used.
Examples:
;; A simple use of SETQ to establish values for variables.
(setq a 1 b 2 c 3) !3
a!1
b!2
c!3
;; Use of SETQ to update values by sequential assignment.
Data and Control Flow 5–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setq a (1+ b) b (1+ a) c (+ a b)) !7
a!3
b!4
c!7
;; This illustrates the use of SETQ on a symbol macro.
(let ((x (list 10 20 30)))
(symbol-macrolet ((y (car x)) (z (cadr x)))
(setq y (1+ z) z (1+ y))
(list x y z)))
!((21 22 30) 21 22)
Side Eﬀects:
The primary value of each form is assigned to the corresponding var.
See Also:
psetq ,set,setf
psetq Macro
Syntax:
psetqf#pairg*!nil
pair:: =var form
Pronunciation:
psetq :[p—esetky/hyphen.altu]
Arguments and Values:
var|asymbol naming a variable other than a constant variable .
form|aform .
Description:
Assigns values to variables .
This is just like setq, except that the assignments happen \in parallel." That is, rst all of the
forms are evaluated, and only then are the variables set to the resulting values. In this way, the
assignment to one variable does not aect the value computation of another in the way that would
occur with setq's sequential assignment.
If any varrefers to a binding made by symbol-macrolet , then that varis treated as if psetf (not
psetq ) had been used.
5–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
;; A simple use of PSETQ to establish values for variables.
;; As a matter of style, many programmers would prefer SETQ
;; in a simple situation like this where parallel assignment
;; is not needed, but the two have equivalent effect.
(psetq a 1 b 2 c 3) !NIL
a!1
b!2
c!3
;; Use of PSETQ to update values by parallel assignment.
;; The effect here is very different than if SETQ had been used.
(psetq a (1+ b) b (1+ a) c (+ a b)) !NIL
a!3
b!2
c!3
;; Use of PSETQ on a symbol macro.
(let ((x (list 10 20 30)))
(symbol-macrolet ((y (car x)) (z (cadr x)))
(psetq y (1+ z) z (1+ y))
(list x y z)))
!((21 11 30) 21 11)
;; Use of parallel assignment to swap values of A and B.
(let ((a 1) (b 2))
(psetq a b b a)
(values a b))
!2, 1
Side Eﬀects:
The values of forms are assigned to vars.
See Also:
psetf ,setq
block Special Operator
Syntax:
block name form *!f resultg*
Data and Control Flow 5–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments and Values:
name |asymbol .
form|aform .
results |the values of the forms if anormal return occurs, or else, if an explicit return occurs, the
values that were transferred.
Description:
block establishes ablock named name and then evaluates forms as an implicit progn .
The special operators block andreturn-from work together to provide a structured, lexical,
non-local exit facility. At any point lexically contained within forms ,return-from can be used
with the given name to return control and values from the block form , except when an intervening
block with the same name has been established , in which case the outer block is shadowed by the
inner one.
The block named name haslexical scope and dynamic extent .
Once established, a block may only be exited once, whether by normal return orexplicit return .
Examples:
(block empty)!NIL
(block whocares (values 1 2) (values 3 4)) !3, 4
(let ((x 1))
(block stop (setq x 2) (return-from stop) (setq x 3))
x)!2
(block early (return-from early (values 1 2)) (values 3 4)) !1, 2
(block outer (block inner (return-from outer 1)) 2) !1
(block twin (block twin (return-from twin 1)) 2) !2
;; Contrast behavior of this example with corresponding example of CATCH.
(block b
(flet ((b1 () (return-from b 1)))
(block b (b1) (print ’unreachable))
2))!1
See Also:
return ,return-from , Section 3.1 (Evaluation)
Notes:
5–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
catch
catch Special Operator
Syntax:
catch tagfformg*!f resultg*
Arguments and Values:
tag|acatch tag ; evaluated.
forms |an implicit progn .
results |if the forms exit normally, the values returned by the forms ; if a throw occurs to the tag,
thevalues that are thrown.
Description:
catch is used as the destination of a non-local control transfer by throw .Tags are used to nd the
catch to which a throw is transferring control. (catch ’foo form)catches a (throw ’foo form)
but not a (throw ’bar form).
The order of execution of catch follows:
1. Tagis evaluated. It serves as the name of the catch .
2. Forms are then evaluated as an implicit progn , and the results of the last form are returned
unless athrow occurs.
3. If athrow occurs during the execution of one of the forms , control is transferred to the
catch form whose tagiseqto the tag argument of the throw and which is the most
recently established catch with that tag. No further evaluation of forms occurs.
4. The tagestablished bycatch isdisestablished just before the results are returned.
If during the execution of one of the forms , athrow is executed whose tag is eqto thecatch tag,
then the values specied by the throw are returned as the result of the dynamically most recently
established catch form with that tag.
The mechanism for catch andthrow works even if throw is not within the lexical scope of catch .
throw must occur within the dynamic extent of the evaluation of the body of a catch with a
corresponding tag.
Examples:
(catch ’dummy-tag 1 2 (throw ’dummy-tag 3) 4) !3
(catch ’dummy-tag 1 2 3 4) !4
(defun throw-back (tag) (throw tag t)) !THROW-BACK
(catch ’dummy-tag (throw-back ’dummy-tag) 2) !T
Data and Control Flow 5–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;; Contrast behavior of this example with corresponding example of BLOCK.
(catch ’c
(flet ((c1 () (throw ’c 1)))
(catch ’c (c1) (print ’unreachable))
2))!2
Exceptional Situations:
An error of typecontrol-error is signaled if throw is done when there is no suitable catch tag.
See Also:
throw , Section 3.1 (Evaluation)
Notes:
It is customary for symbols to be used as tags, but any object is permitted. However, numbers
should not be used because the comparison is done using eq.
catch diers from block in thatcatch tags have dynamic scope whileblock names have lexical
scope .
go Special Operator
Syntax:
gotag!
Arguments and Values:
tag|ago tag .
Description:
gotransfers control to the point in the body of an enclosing tagbody form labeled by a tag eqlto
tag. If there is no such tagin the body, the bodies of lexically containing tagbody forms (if any)
are examined as well. If several tags are eqltotag, control is transferred to whichever matching tag
is contained in the innermost tagbody form that contains the go. The consequences are undened
if there is no matching taglexically visible to the point of the go.
The transfer of control initiated by gois performed as described in Section 5.2 (Transfer of Control
to an Exit Point).
Examples:
(tagbody
(setq val 2)
(go lp)
(incf val 3)
lp (incf val 4)) !NIL
5–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
val!6
The following is in error because there is a normal exit of the tagbody before the gois executed.
(let ((a nil))
(tagbody t (setq a #’(lambda () (go t))))
(funcall a))
The following is in error because the tagbody is passed over before the goform is executed.
(funcall (block nil
(tagbody a (return #’(lambda () (go a))))))
See Also:
tagbody
return-from Special Operator
Syntax:
return-from name [result ]!
Arguments and Values:
name |ablock tag ; not evaluated.
result |aform ; evaluated. The default is nil.
Description:
Returns control and multiple values 2from a lexically enclosing block .
Ablock form named name must lexically enclose the occurrence of return-from ; any values yielded
by the evaluation ofresult are immediately returned from the innermost such lexically enclosing
block .
The transfer of control initiated by return-from is performed as described in Section 5.2 (Transfer
of Control to an Exit Point).
Examples:
(block alpha (return-from alpha) 1) !NIL
(block alpha (return-from alpha 1) 2) !1
(block alpha (return-from alpha (values 1 2)) 3) !1, 2
(let ((a 0))
(dotimes (i 10) (incf a) (when (oddp i) (return)))
a)!2
Data and Control Flow 5–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
return-from
(defun temp (x)
(if x (return-from temp ’dummy))
44)!TEMP
(temp nil)!44
(temp t)!DUMMY
(block out
(flet ((exit (n) (return-from out n)))
(block out (exit 1)))
2)!1
(block nil
(unwind-protect (return-from nil 1)
(return-from nil 2)))
!2
(dolist (flag ’(nil t))
(block nil
(let ((x 5))
(declare (special x))
(unwind-protect (return-from nil)
(print x))))
(print ’here))
.5
.HERE
.5
.HERE
!NIL
(dolist (flag ’(nil t))
(block nil
(let ((x 5))
(declare (special x))
(unwind-protect
(if flag (return-from nil))
(print x))))
(print ’here))
.5
.HERE
.5
.HERE
!NIL
The following has undened consequences because the block form exits normally before the
return-from form is attempted.
(funcall (block nil #’(lambda () (return-from nil)))) is an error.
5–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
block ,return , Section 3.1 (Evaluation)
return Macro
Syntax:
return [result ]!
Arguments and Values:
result |aform ; evaluated. The default is nil.
Description:
Returns, as if by return-from , from the block namednil.
Examples:
(block nil (return) 1) !NIL
(block nil (return 1) 2) !1
(block nil (return (values 1 2)) 3) !1, 2
(block nil (block alpha (return 1) 2)) !1
(block alpha (block nil (return 1)) 2) !2
(block nil (block nil (return 1) 2)) !1
See Also:
block ,return-from , Section 3.1 (Evaluation)
Notes:
(return)(return-from nil)
(return form)(return-from nil form)
The implicit blocks established bymacros such asdoare often named nil, so that return can be
used to exit from such forms .
Data and Control Flow 5–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
tagbody
tagbody Special Operator
Syntax:
tagbodyftagjstatementg*!nil
Arguments and Values:
tag|ago tag ; not evaluated.
statement |acompound form ; evaluated as described below.
Description:
Executes zero or more statements in a lexical environment that provides for control transfers to
labels indicated by the tags.
The statements in atagbody areevaluated in order from left to right, and their values are
discarded. If at any time there are no remaining statements ,tagbody returnsnil. However, if
(go tag)isevaluated , control jumps to the part of the body labeled with the tag. (Tags are
compared with eql.)
Atagestablished by tagbody haslexical scope and has dynamic extent . Oncetagbody has been
exited, it is no longer valid to goto a tagin its body. It is permissible for goto jump to a tagbody
that is not the innermost tagbody containing that go; the tags established by a tagbody only
shadow other tags of like name.
The determination of which elements of the body are tags and which are statements is made prior
to any macro expansion of that element. If a statement is amacro form and its macro expansion
is an atom , that atom is treated as a statement , not a tag.
Examples:
(let (val)
(tagbody
(setq val 1)
(go point-a)
(incf val 16)
point-c
(incf val 04)
(go point-b)
(incf val 32)
point-a
(incf val 02)
(go point-c)
(incf val 64)
point-b
(incf val 08))
5–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
val)
!15
(defun f1 (flag)
(let ((n 1))
(tagbody
(setq n (f2 flag #’(lambda () (go out))))
out
(prin1 n))))
!F1
(defun f2 (flag escape)
(if flag (funcall escape) 2))
!F2
(f1 nil)
.2
!NIL
(f1 t)
.1
!NIL
See Also:
go
Notes:
The macros in Figure 5{10 have implicit tagbodies .
do do-external-symbols dotimes
do* do-symbols prog
do-all-symbols dolist prog*
Figure 5–10. Macros that have implicit tagbodies.
throw Special Operator
Syntax:
throw tag result-form!
Arguments and Values:
tag|acatch tag ; evaluated.
result-form |aform ; evaluated as described below.
Data and Control Flow 5–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
throw
Description:
throw causes a non-local control transfer to a catch whose tag is eqtotag.
Tagis evaluated rst to produce an object called the throw tag; then result-form is evaluated, and
its results are saved. If the result-form produces multiple values, then all the values are saved. The
most recent outstanding catch whose tagiseqto the throw tag is exited; the saved results are
returned as the value or values of catch .
The transfer of control initiated by throw is performed as described in Section 5.2 (Transfer of
Control to an Exit Point).
Examples:
(catch ’result
(setq i 0 j 0)
(loop (incf j 3) (incf i)
(if (= i 3) (throw ’result (values i j))))) !3, 9
(catch nil
(unwind-protect (throw nil 1)
(throw nil 2))) !2
The consequences of the following are undened because the catch ofbis passed over by the rst
throw , hence portable programs must assume that its dynamic extent is terminated. The binding
of the catch tag is not yet disestablished and therefore it is the target of the second throw .
(catch ’a
(catch ’b
(unwind-protect (throw ’a 1)
(throw ’b 2))))
The following prints \ The inner catch returns :SECOND-THROW " and then returns :outer-catch .
(catch ’foo
(format t "The inner catch returns ~s.~%"
(catch ’foo
(unwind-protect (throw ’foo :first-throw)
(throw ’foo :second-throw))))
:outer-catch)
.The inner catch returns :SECOND-THROW
!:OUTER-CATCH
Exceptional Situations:
If there is no outstanding catch tag that matches the throw tag, no unwinding of the stack is
5–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
performed, and an error of typecontrol-error is signaled. When the error is signaled, the dynamic
environment is that which was in force at the point of the throw .
See Also:
block ,catch ,return-from ,unwind-protect , Section 3.1 (Evaluation)
Notes:
catch andthrow are normally used when the exit point must have dynamic scope (e.g., thethrow
is not lexically enclosed by the catch ), whileblock andreturn are used when lexical scope is
sucient.
unwind-protect Special Operator
Syntax:
unwind-protect protected-formfcleanup-formg*!f resultg*
Arguments and Values:
protected-form |aform .
cleanup-form |aform .
results |the values of the protected-form .
Description:
unwind-protect evaluates protected-form and guarantees that cleanup-forms are executed before
unwind-protect exits, whether it terminates normally or is aborted by a control transfer of some
kind.unwind-protect is intended to be used to make sure that certain side eects take place after
the evaluation of protected-form .
If a non-local exit occurs during execution of cleanup-forms , no special action is taken. The
cleanup-forms ofunwind-protect are not protected by that unwind-protect .
unwind-protect protects against all attempts to exit from protected-form , including go,
handler-case ,ignore-errors ,restart-case ,return-from ,throw , andwith-simple-restart .
Undoing of handler and restart bindings during an exit happens in parallel with the undoing of the
bindings of dynamic variables andcatch tags, in the reverse order in which they were established.
The eect of this is that cleanup-form sees the same handler and restart bindings , as well as
dynamic variable bindings andcatch tags, as were visible when the unwind-protect was entered.
Examples:
(tagbody
(let ((x 3))
Data and Control Flow 5–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
unwind-protect
(unwind-protect
(if (numberp x) (go out))
(print x)))
out
...)
Whengois executed, the call to print is executed rst, and then the transfer of control to the tag
outis completed.
(defun dummy-function (x)
(setq state ’running)
(unless (numberp x) (throw ’abort ’not-a-number))
(setq state (1+ x))) !DUMMY-FUNCTION
(catch ’abort (dummy-function 1)) !2
state!2
(catch ’abort (dummy-function ’trash)) !NOT-A-NUMBER
state!RUNNING
(catch ’abort (unwind-protect (dummy-function ’trash)
(setq state ’aborted))) !NOT-A-NUMBER
state!ABORTED
The following code is not correct:
(unwind-protect
(progn (incf *access-count*)
(perform-access))
(decf *access-count*))
If an exit occurs before completion of incf, thedecf form is executed anyway, resulting in an
incorrect value for *access-count* . The correct way to code this is as follows:
(let ((old-count *access-count*))
(unwind-protect
(progn (incf *access-count*)
(perform-access))
(setq *access-count* old-count)))
;;; The following returns 2.
(block nil
(unwind-protect (return 1)
(return 2)))
;;; The following has undefined consequences.
(block a
(block b
(unwind-protect (return-from a 1)
5–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
unwind-protect
(return-from b 2))))
;;; The following returns 2.
(catch nil
(unwind-protect (throw nil 1)
(throw nil 2)))
;;; The following has undefined consequences because the catch of B is
;;; passed over by the first THROW, hence portable programs must assume
;;; its dynamic extent is terminated. The binding of the catch tag is not
;;; yet disestablished and therefore it is the target of the second throw.
(catch ’a
(catch ’b
(unwind-protect (throw ’a 1)
(throw ’b 2))))
;;; The following prints "The inner catch returns :SECOND-THROW"
;;; and then returns :OUTER-CATCH.
(catch ’foo
(format t "The inner catch returns ~s.~%"
(catch ’foo
(unwind-protect (throw ’foo :first-throw)
(throw ’foo :second-throw))))
:outer-catch)
;;; The following returns 10. The inner CATCH of A is passed over, but
;;; because that CATCH is disestablished before the THROW to A is executed,
;;; it isn’t seen.
(catch ’a
(catch ’b
(unwind-protect (1+ (catch ’a (throw ’b 1)))
(throw ’a 10))))
;;; The following has undefined consequences because the extent of
;;; the (CATCH ’BAR ...) exit ends when the (THROW ’FOO ...)
;;; commences.
(catch ’foo
(catch ’bar
(unwind-protect (throw ’foo 3)
(throw ’bar 4)
(print ’xxx))))
Data and Control Flow 5–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;;; The following returns 4; XXX is not printed.
;;; The (THROW ’FOO ...) has no effect on the scope of the BAR
;;; catch tag or the extent of the (CATCH ’BAR ...) exit.
(catch ’bar
(catch ’foo
(unwind-protect (throw ’foo 3)
(throw ’bar 4)
(print ’xxx))))
;;; The following prints 5.
(block nil
(let ((x 5))
(declare (special x))
(unwind-protect (return)
(print x))))
See Also:
catch ,go,handler-case ,restart-case ,return ,return-from ,throw , Section 3.1 (Evaluation)
nil Constant Variable
Constant Value:
nil.
Description:
nilrepresents both boolean (and generalized boolean )false and the empty list .
Examples:
nil!NIL
See Also:
t
5–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
not Function
Syntax:
not x!boolean
Arguments and Values:
x|ageneralized boolean (i.e., any object ).
boolean |aboolean .
Description:
Returnstifxisfalse; otherwise, returns nil.
Examples:
(not nil)!T
(not ’())!T
(not (integerp ’sss)) !T
(not (integerp 1)) !NIL
(not 3.7)!NIL
(not ’apple)!NIL
See Also:
null
Notes:
notis intended to be used to invert the `truth value' of a boolean (orgeneralized boolean ) whereas
null is intended to be used to test for the empty list . Operationally, notandnull compute the
same result; which to use is a matter of style.
t Constant Variable
Constant Value:
t.
Description:
The boolean representing true, and the canonical generalized boolean representing true. Although
anyobject other than nilis considered true,tis generally used when there is no special reason to
prefer one such object over another.
Data and Control Flow 5–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The symboltis also sometimes used for other purposes as well. For example, as the name of a
class , as a designator (e.g., astream designator ) or as a special symbol for some syntactic reason
(e.g., incase andtypecase to label the otherwise-clause ).
Examples:
t!T
(eq t ’t)!true
(find-class ’t) !#<CLASS T 610703333>
(case ’a (a 1) (t 2)) !1
(case ’b (a 1) (t 2)) !2
(prin1 ’hello t)
.HELLO
!HELLO
See Also:
nil
eq Function
Syntax:
eqx y!generalized-boolean
Arguments and Values:
x|an object .
y|an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true if its arguments are the same, identical object ; otherwise, returns false.
Examples:
(eq ’a ’b)!false
(eq ’a ’a)!true
(eq 3 3)
!trueor!false
(eq 3 3.0)!false
(eq 3.0 3.0)
!trueor!false
5–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
eq
(eq #c(3 -4) #c(3 -4))
!trueor!false
(eq #c(3 -4.0) #c(3 -4)) !false
(eq (cons ’a ’b) (cons ’a ’c)) !false
(eq (cons ’a ’b) (cons ’a ’b)) !false
(eq ’(a . b) ’(a . b))
!trueor!false
(progn (setq x (cons ’a ’b)) (eq x x)) !true
(progn (setq x ’(a . b)) (eq x x)) !true
(eq #\A #\A)
!trueor!false
(let ((x "Foo")) (eq x x)) !true
(eq "Foo" "Foo")
!trueor!false
(eq "Foo" (copy-seq "Foo")) !false
(eq "FOO" "foo") !false
(eq "string-seq" (copy-seq "string-seq")) !false
(let ((x 5)) (eq x x))
!trueor!false
See Also:
eql,equal ,equalp ,=, Section 3.2 (Compilation)
Notes:
Objects that appear the same when printed are not necessarily eqto each other. Symbols that
print the same usually are eqto each other because of the use of the intern function. However,
numbers with the same value need not be eq, and two similar lists are usually not identical .
An implementation is permitted to make \copies" of characters and numbers at any time. The
eect is that Common Lisp makes no guarantee that eqis true even when both its arguments are
\the same thing" if that thing is a character ornumber .
Most Common Lisp operators useeqlrather than eqto compare objects, or else they default to
eqland only use eqif specically requested to do so. However, the following operators are dened
to useeqrather than eqlin a way that cannot be overridden by the code which employs them:
Data and Control Flow 5–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
catch getf throw
get remf
get-properties remprop
Figure 5–11. Operators that always prefer EQ over EQL
eql Function
Syntax:
eqlx y!generalized-boolean
Arguments and Values:
x|an object .
y|an object .
generalized-boolean |ageneralized boolean .
Description:
The value of eqlistrue of two objects, xand y, in the folowing cases:
1. If xand yareeq.
2. If xand yare both numbers of the same type and the same value.
3. If they are both characters that represent the same character.
Otherwise the value of eqlisfalse.
If an implementation supports positive and negative zeros as distinct values, then (eql 0.0 -0.0)
returns false. Otherwise, when the syntax -0.0 is read it is interpreted as the value 0.0, and so
(eql 0.0 -0.0) returns true.
Examples:
(eql ’a ’b)!false
(eql ’a ’a)!true
(eql 3 3)!true
(eql 3 3.0)!false
(eql 3.0 3.0)!true
(eql #c(3 -4) #c(3 -4)) !true
(eql #c(3 -4.0) #c(3 -4)) !false
(eql (cons ’a ’b) (cons ’a ’c)) !false
5–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(eql (cons ’a ’b) (cons ’a ’b)) !false
(eql ’(a . b) ’(a . b))
!trueor!false
(progn (setq x (cons ’a ’b)) (eql x x)) !true
(progn (setq x ’(a . b)) (eql x x)) !true
(eql #\A #\A)!true
(eql "Foo" "Foo")
!trueor!false
(eql "Foo" (copy-seq "Foo")) !false
(eql "FOO" "foo") !false
Normally (eql 1.0s0 1.0d0) is false, under the assumption that 1.0s0 and1.0d0 are of distinct
data types. However, implementations that do not provide four distinct oating-point formats
are permitted to \collapse" the four formats into some smaller number of them; in such an
implementation (eql 1.0s0 1.0d0) might be true.
See Also:
eq,equal ,equalp ,=,char=
Notes:
eqlis the same as eq, except that if the arguments are characters ornumbers of the same type
then their values are compared. Thus eqltells whether two objects are conceptually the same,
whereaseqtells whether two objects are implementationally identical. It is for this reason that
eql, noteq, is the default comparison predicate for operators that take sequences as arguments.
eqlmay not be true of two oats even when they represent the same value. =is used to compare
mathematical values.
Two complex numbers are considered to be eqlif their real parts are eqland their imaginary
parts are eql. For example, (eql #C(4 5) #C(4 5)) istrue and(eql #C(4 5) #C(4.0 5.0)) is
false. Note that while (eql #C(5.0 0.0) 5.0) isfalse,(eql #C(5 0) 5) istrue. In the case of
(eql #C(5.0 0.0) 5.0) the two arguments are of dierent types, and so cannot satisfy eql. In the
case of(eql #C(5 0) 5) ,#C(5 0) is not a complex number, but is automatically reduced to the
integer5.
equal Function
Syntax:
equal x y!generalized-boolean
Data and Control Flow 5–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
equal
Arguments and Values:
x|an object .
y|an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifxand yare structurally similar (isomorphic) objects .Objects are treated as follows
byequal .
Symbols ,Numbers , and Characters
equal istrue of two objects if they are symbols that areeq, if they are numbers that are
eql, or if they are characters that areeql.
Conses
Forconses ,equal is dened recursively as the two cars beingequal and the two cdrs being
equal .
Arrays
Two arrays areequal only if they are eq, with one exception: strings and bit vectors are
compared element-by-element (using eql). If either xoryhas a ll pointer , the ll pointer
limits the number of elements examined by equal . Uppercase and lowercase letters in
strings are considered by equal to be dierent.
Pathnames
Two pathnames areequal if and only if all the corresponding components (host, device,
and so on) are equivalent. Whether or not uppercase and lowercase letters are considered
equivalent in strings appearing in components is implementation-dependent .pathnames
that areequal should be functionally equivalent.
Other (Structures, hash-tables, instances, :::)
Two other objects areequal only if they are eq.
equal does not descend any objects other than the ones explicitly specied above. Figure 5{12
summarizes the information given in the previous list. In addition, the gure species the priority
of the behavior of equal , with upper entries taking priority over lower ones.
5–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
equal
Type Behavior
number useseql
character useseql
cons descends
bit vector descends
string descends
pathname \functionally equivalent"
structure useseq
Other array useseq
hash table useseq
Other object useseq
Figure 5–12. Summary and priorities of behavior of equal
Any two objects that areeqlare alsoequal .
equal may fail to terminate if xoryis circular.
Examples:
(equal ’a ’b)!false
(equal ’a ’a)!true
(equal 3 3)!true
(equal 3 3.0)!false
(equal 3.0 3.0) !true
(equal #c(3 -4) #c(3 -4)) !true
(equal #c(3 -4.0) #c(3 -4)) !false
(equal (cons ’a ’b) (cons ’a ’c)) !false
(equal (cons ’a ’b) (cons ’a ’b)) !true
(equal #\A #\A) !true
(equal #\A #\a) !false
(equal "Foo" "Foo") !true
(equal "Foo" (copy-seq "Foo")) !true
(equal "FOO" "foo") !false
(equal "This-string" "This-string") !true
(equal "This-string" "this-string") !false
See Also:
eq,eql,equalp ,=,string= ,string-equal ,char= ,char-equal ,tree-equal
Notes:
Object equality is not a concept for which there is a uniquely determined correct algorithm. The
appropriateness of an equality predicate can be judged only in the context of the needs of some
particular program. Although these functions take any type of argument and their names sound
Data and Control Flow 5–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
very generic, equal andequalp are not appropriate for every application.
A rough rule of thumb is that two objects areequal if and only if their printed representations are
the same.
equalp Function
Syntax:
equalp x y!generalized-boolean
Arguments and Values:
x|an object .
y|an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifxand yareequal , or if they have components that are of the same type as each
other and if those components are equalp ; specically, equalp returns true in the following cases:
Characters
If two characters arechar-equal .
Numbers
If two numbers are the same under=.
Conses
If the two cars in the conses areequalp and the two cdrs in the conses areequalp .
Arrays
If two arrays have the same number of dimensions, the dimensions match, and the
corresponding active elements areequalp . The types for which the arrays arespecialized
need not match; for example, a string and a general array that happens to contain the
same characters areequalp . Because equalp performs element -by-element comparisons
ofstrings and ignores the case ofcharacters ,case distinctions are ignored when equalp
compares strings .
5–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
equalp
Structures
If two structuresS1andS2have the same class and the value of each slotinS1is the
same underequalp as the value of the corresponding slotinS2.
Hash Tables
equalp descends hash-tables by rst comparing the count of entries and the :test function;
if those are the same, it compares the keys of the tables using the :test function and then
the values of the matching keys using equalp recursively.
equalp does not descend any objects other than the ones explicitly specied above. Figure 5{13
summarizes the information given in the previous list. In addition, the gure species the priority
of the behavior of equalp , with upper entries taking priority over lower ones.
Type Behavior
number uses=
character useschar-equal
cons descends
bit vector descends
string descends
pathname same asequal
structure descends, as described above
Other array descends
hash table descends, as described above
Other object useseq
Figure 5–13. Summary and priorities of behavior of equalp
Examples:
(equalp ’a ’b)!false
(equalp ’a ’a)!true
(equalp 3 3)!true
(equalp 3 3.0)!true
(equalp 3.0 3.0) !true
(equalp #c(3 -4) #c(3 -4)) !true
(equalp #c(3 -4.0) #c(3 -4)) !true
(equalp (cons ’a ’b) (cons ’a ’c)) !false
(equalp (cons ’a ’b) (cons ’a ’b)) !true
(equalp #\A #\A) !true
(equalp #\A #\a) !true
(equalp "Foo" "Foo") !true
(equalp "Foo" (copy-seq "Foo")) !true
Data and Control Flow 5–63
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(equalp "FOO" "foo") !true
(setq array1 (make-array 6 :element-type ’integer
:initial-contents ’(1 1 1 3 5 7)))
!#(1 1 1 3 5 7)
(setq array2 (make-array 8 :element-type ’integer
:initial-contents ’(1 1 1 3 5 7 2 6)
:fill-pointer 6))
!#(1 1 1 3 5 7)
(equalp array1 array2) !true
(setq vector1 (vector 1 1 1 3 5 7)) !#(1 1 1 3 5 7)
(equalp array1 vector1) !true
See Also:
eq,eql,equal ,=,string= ,string-equal ,char= ,char-equal
Notes:
Object equality is not a concept for which there is a uniquely determined correct algorithm. The
appropriateness of an equality predicate can be judged only in the context of the needs of some
particular program. Although these functions take any type of argument and their names sound
very generic, equal andequalp are not appropriate for every application.
identity Function
Syntax:
identity object!object
Arguments and Values:
object |an object .
Description:
Returns its argument object .
Examples:
(identity 101)!101
(mapcan #’identity (list (list 1 2 3) ’(4 5 6))) !(1 2 3 4 5 6)
Notes:
identity is intended for use with functions that require a function as an argument.
(eql x (identity x)) returns true for all possible values of x, but(eq x (identity x)) might
return false when xis anumber orcharacter .
5–64 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
identity could be dened by
(defun identity (x) x)
complement Function
Syntax:
complement function!complement-function
Arguments and Values:
function |afunction .
complement-function |afunction .
Description:
Returns a function that takes the same arguments asfunction , and has the same side-eect
behavior as function , but returns only a single value: a generalized boolean with the opposite truth
value of that which would be returned as the primary value offunction . That is, when the function
would have returned true as its primary value thecomplement-function returns false, and when the
function would have returned false as its primary value thecomplement-function returns true.
Examples:
(funcall (complement #’zerop) 1) !true
(funcall (complement #’characterp) #\A) !false
(funcall (complement #’member) ’a ’(a b c)) !false
(funcall (complement #’member) ’d ’(a b c)) !true
See Also:
not
Notes:
(complement x)#’(lambda (&rest arguments) (not (apply xarguments)))
In Common Lisp, functions with names like \ xxx-if-not " are related to functions with names like
\xxx-if" in that
(xxx-if-not f.arguments )(xxx-if (complement f) .arguments )
For example,
(find-if-not #’zerop ’(0 0 3)) 
(find-if (complement #’zerop) ’(0 0 3)) !3
Data and Control Flow 5–65
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Note that since the \ xxx-if-not "functions and the :test-not arguments have been deprecated,
uses of \ xxx-if"functions or:test arguments with complement are preferred.
constantly Function
Syntax:
constantly value!function
Arguments and Values:
value |an object .
function |afunction .
Description:
constantly returns a function that accepts any number of arguments, that has no side-eects, and
that always returns value .
Examples:
(mapcar (constantly 3) ’(a b c d)) !(3 3 3 3)
(defmacro with-vars (vars &body forms)
‘((lambda ,vars ,@forms) ,@(mapcar (constantly nil) vars)))
!WITH-VARS
(macroexpand ’(with-vars (a b) (setq a 3 b (* a a)) (list a b)))
!((LAMBDA (A B) (SETQ A 3 B (* A A)) (LIST A B)) NIL NIL), true
See Also:
identity
Notes:
constantly could be dened by:
(defun constantly (object)
#’(lambda (&rest arguments) object))
5–66 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
every, some, notevery, notany
every,some,notevery,notany Function
Syntax:
every predicate &rest sequences+!generalized-boolean
some predicate &rest sequences+!result
notevery predicate &rest sequences+!generalized-boolean
notany predicate &rest sequences+!generalized-boolean
Arguments and Values:
predicate |adesignator for a function of as many arguments as there are sequences .
sequence |asequence .
result |an object .
generalized-boolean |ageneralized boolean .
Description:
every ,some ,notevery , andnotany test elements ofsequences for satisfaction of a given predicate .
The rst argument to predicate is an element of the rst sequence ; each succeeding argument is an
element of a succeeding sequence .
Predicate is rst applied to the elements with index 0in each of the sequences , and possibly then to
the elements with index 1, and so on, until a termination criterion is met or the end of the shortest
of the sequences is reached.
every returns false as soon as any invocation of predicate returns false. If the end of a sequence is
reached,every returns true. Thus,every returns true if and only if every invocation of predicate
returns true.
some returns the rst non-nil value which is returned by an invocation of predicate . If the end of
asequence is reached without any invocation of the predicate returning true,some returns false.
Thus,some returns true if and only if some invocation of predicate returns true.
notany returns false as soon as any invocation of predicate returns true. If the end of a sequence is
reached,notany returns true. Thus,notany returns true if and only if it is not the case that any
invocation of predicate returns true.
notevery returns true as soon as any invocation of predicate returns false. If the end of a sequence
is reached, notevery returns false. Thus,notevery returns true if and only if it is not the case
that every invocation of predicate returns true.
Data and Control Flow 5–67
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(every #’characterp "abc") !true
(some #’= ’(1 2 3 4 5) ’(5 4 3 2 1)) !true
(notevery #’< ’(1 2 3 4) ’(5 6 7 8) ’(9 10 11 12)) !false
(notany #’> ’(1 2 3 4) ’(5 6 7 8) ’(9 10 11 12)) !true
Exceptional Situations:
Should signal type-error if its rst argument is neither a symbol nor a function or if any subsequent
argument is not a proper sequence .
Other exceptional situations are possible, depending on the nature of the predicate .
See Also:
and,or, Section 3.6 (Traversal Rules and Side Eects)
Notes:
(notany predicatefsequenceg*)(not (some predicatefsequenceg*))
(notevery predicatefsequenceg*)(not (every predicatefsequenceg*))
and Macro
Syntax:
andfformg*!f resultg*
Arguments and Values:
form|aform .
results |the values resulting from the evaluation of the last form, or the symbols nilort.
Description:
The macro andevaluates each form one at a time from left to right. As soon as any form evaluates
tonil,andreturnsnilwithout evaluating the remaining forms . If all forms but the last evaluate to
true values,andreturns the results produced by evaluating the last form.
If no forms are supplied, (and) returnst.
andpasses back multiple values from the last subform but not from subforms other than the last.
Examples:
(if (and (>= n 0)
5–68 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(< n (length a-simple-vector))
(eq (elt a-simple-vector n) ’foo))
(princ "Foo!"))
The above expression prints Foo! if element nofa-simple-vector is the symbol foo, provided also
thatnis indeed a valid index for a-simple-vector . Because andguarantees left-to-right testing of
its parts, eltis not called if nis out of range.
(setq temp1 1 temp2 1 temp3 1) !1
(and (incf temp1) (incf temp2) (incf temp3)) !2
(and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) !true
(decf temp3)!1
(and (decf temp1) (decf temp2) (eq temp3 ’nil) (decf temp3)) !NIL
(and (eql temp1 temp2) (eql temp2 temp3)) !true
(and)!T
See Also:
cond ,every ,if,or,when
Notes:
(and form)(let () form)
(and form1 form2 ...)(when form1(and form2...))
cond Macro
Syntax:
condf#clauseg*!f resultg*
clause:: =(test-formfformg*)
Arguments and Values:
test-form |aform .
forms |an implicit progn .
results |the values of the forms in the rst clause whose test-form yields true , or the primary value
of the test-form if there are no forms in that clause , or elsenilif no test-form yields true .
Description:
cond allows the execution of forms to be dependent on test-form .
Data and Control Flow 5–69
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Test-forms are evaluated one at a time in the order in which they are given in the argument list
until a test-form is found that evaluates to true.
If there are no forms in that clause, the primary value of the test-form is returned by the cond
form . Otherwise, the forms associated with this test-form are evaluated in order, left to right, as
animplicit progn , and the values returned by the last form are returned by the cond form .
Once one test-form hasyielded true , no additional test-forms areevaluated . If no test-form yields
true,nilis returned.
Examples:
(defun select-options ()
(cond ((= a 1) (setq a 2))
((= a 2) (setq a 3))
((and (= a 3) (floor a 2)))
(t (floor a 3)))) !SELECT-OPTIONS
(setq a 1)!1
(select-options) !2
a!2
(select-options) !3
a!3
(select-options) !1
(setq a 5)!5
(select-options) !1, 2
See Also:
if,case.
if Special Operator
Syntax:
iftest-form then-form [else-form ]!f resultg*
Arguments and Values:
Test-form |aform .
Then-form |aform .
Else-form |aform . The default is nil.
results |if the test-form yielded true , the values returned by the then-form ; otherwise, the values
returned by the else-form .
5–70 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
ifallows the execution of a form to be dependent on a single test-form .
First test-form is evaluated. If the result is true, then then-form is selected; otherwise else-form is
selected. Whichever form is selected is then evaluated.
Examples:
(if t 1)!1
(if nil 1 2)!2
(defun test ()
(dolist (truth-value ’(t nil 1 (a b c)))
(if truth-value (print ’true) (print ’false))
(prin1 truth-value))) !TEST
(test)
.TRUE T
.FALSE NIL
.TRUE 1
.TRUE (A B C)
!NIL
See Also:
cond ,unless ,when
Notes:
(if test-form then-form else-form )
(cond ( test-form then-form ) (t else-form ))
or Macro
Syntax:
orfformg*!f resultsg*
Arguments and Values:
form|aform .
results |the values orprimary value (see below) resulting from the evaluation of the last form
executed or nil.
Description:
orevaluates each form, one at a time, from left to right. The evaluation of all forms terminates
when a form evaluates to true (i.e., something other than nil).
Data and Control Flow 5–71
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If the evaluation of any form other than the last returns a primary value that is true,orimmediately
returns that value (but no additional values ) without evaluating the remaining forms . If every form
but the last returns false as its primary value ,orreturns all values returned by the last form. If
noforms are supplied, orreturnsnil.
Examples:
(or)!NIL
(setq temp0 nil temp1 10 temp2 20 temp3 30) !30
(or temp0 temp1 (setq temp2 37)) !10
temp2!20
(or (incf temp1) (incf temp2) (incf temp3)) !11
temp1!11
temp2!20
temp3!30
(or (values) temp1) !11
(or (values temp1 temp2) temp3) !11
(or temp0 (values temp1 temp2)) !11, 20
(or (values temp0 temp1) (values temp2 temp3)) !20, 30
See Also:
and,some ,unless
when,unless Macro
Syntax:
when test-formfformg*!f resultg*
unless test-formfformg*!f resultg*
Arguments and Values:
test-form |aform .
forms |an implicit progn .
results |the values of the forms in awhen form if the test-form yields true or in anunless form if
thetest-form yields false ; otherwise nil.
Description:
when andunless allow the execution of forms to be dependent on a single test-form .
In awhen form , if the test-form yields true , the forms areevaluated in order from left to right and
thevalues returned by the forms are returned from the when form . Otherwise, if the test-form
yields false , the forms are not evaluated , and the when form returnsnil.
5–72 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
when, unless
In anunless form , if the test-form yields false , the forms areevaluated in order from left to right
and the values returned by the forms are returned from the unless form . Otherwise, if the test-form
yields false , the forms are not evaluated , and the unless form returnsnil.
Examples:
(when t ’hello) !HELLO
(unless t ’hello) !NIL
(when nil ’hello) !NIL
(unless nil ’hello) !HELLO
(when t)!NIL
(unless nil)!NIL
(when t (prin1 1) (prin1 2) (prin1 3))
.123
!3
(unless t (prin1 1) (prin1 2) (prin1 3)) !NIL
(when nil (prin1 1) (prin1 2) (prin1 3)) !NIL
(unless nil (prin1 1) (prin1 2) (prin1 3))
.123
!3
(let ((x 3))
(list (when (oddp x) (incf x) (list x))
(when (oddp x) (incf x) (list x))
(unless (oddp x) (incf x) (list x))
(unless (oddp x) (incf x) (list x))
(if (oddp x) (incf x) (list x))
(if (oddp x) (incf x) (list x))
(if (not (oddp x)) (incf x) (list x))
(if (not (oddp x)) (incf x) (list x))))
!((4) NIL (5) NIL 6 (6) 7 (7))
See Also:
and,cond ,if,or
Notes:
(when testfformg+)(and test(prognfformg+))
(when testfformg+)(cond ( testfformg+))
(when testfformg+)(if test(prognfformg+) nil)
(when testfformg+)(unless (not test)fformg+)
(unless testfformg+)(cond ((not test)fformg+))
(unless testfformg+)(if testnil (prognfformg+))
(unless testfformg+)(when (not test)fformg+)
Data and Control Flow 5–73
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
case,ccase,ecase Macro
Syntax:
case keyformf#normal-clauseg* [#otherwise-clause ]!f resultg*
ccase keyplacef#normal-clauseg*!f resultg*
ecase keyformf#normal-clauseg*!f resultg*
normal-clause:: =(keysfformg*)
otherwise-clause:: =(fotherwisejtgfformg*)
clause:: =normal-clausejotherwise-clause
Arguments and Values:
keyform |aform ; evaluated to produce a test-key .
keyplace |aform ; evaluated initially to produce a test-key . Possibly also used later as a place if no
keys match.
test-key |an object produced by evaluating keyform orkeyplace .
keys|adesignator for a listofobjects . In the case of case, the symbolstandotherwise may not
be used as the keys designator . To refer to these symbols by themselves as keys, the designators
(t)and(otherwise) , respectively, must be used instead.
forms |an implicit progn .
results |the values returned by the forms in the matching clause .
Description:
These macros allow the conditional execution of a body of forms in a clause that is selected by
matching the test-key on the basis of its identity.
The keyform orkeyplace isevaluated to produce the test-key .
Each of the normal-clauses is then considered in turn. If the test-key is the same as any keyfor
that clause , the forms in that clause areevaluated as an implicit progn , and the values it returns
are returned as the value of the case,ccase , orecase form .
These macros dier only in their behavior when no normal-clause matches; specically:
case
If no normal-clause matches, and there is an otherwise-clause , then that otherwise-clause
5–74 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
case, ccase, ecase
automatically matches; the forms in that clause areevaluated as an implicit progn , and the
values it returns are returned as the value of the case.
If there is no otherwise-clause ,case returnsnil.
ccase
If no normal-clause matches, a correctable error oftypetype-error is signaled. The oending
datum is the test-key and the expected type is type equivalent to(member key1 key2 ...).
Thestore-value restart can be used to correct the error.
If thestore-value restart is invoked, its argument becomes the new test-key , and is stored
inkeyplace as if by (setf keyplace test-key ). Thenccase starts over, considering each
clause anew.
The subforms of keyplace might be evaluated again if none of the cases holds.
ecase
If no normal-clause matches, a non-correctable error oftypetype-error is signaled.
The oending datum is the test-key and the expected type is type equivalent to
(member key1 key2 ...).
Note that in contrast with ccase , the caller of ecase may rely on the fact that ecase does
not return if a normal-clause does not match.
Examples:
(dolist (k ’(1 2 3 :four #\v () t ’other))
(format t "~S "
(case k ((1 2) ’clause1)
(3 ’clause2)
(nil ’no-keys-so-never-seen)
((nil) ’nilslot)
((:four #\v) ’clause4)
((t) ’tslot)
(otherwise ’others))))
.CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS
!NIL
(defun add-em (x) (apply #’+ (mapcar #’decode x)))
!ADD-EM
(defun decode (x)
(ccase x
((i uno) 1)
((ii dos) 2)
((iii tres) 3)
((iv cuatro) 4)))
!DECODE
Data and Control Flow 5–75
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(add-em ’(uno iii)) !4
(add-em ’(uno iiii))
.Error: The value of X, IIII, is not I, UNO, II, DOS, III,
. TRES, IV, or CUATRO.
.1: Supply a value to use instead.
.2: Return to Lisp Toplevel.
.Debug> :CONTINUE 1
.Value to evaluate and use for X: ’IV
!5
Side Eﬀects:
The debugger might be entered. If the store-value restart is invoked, the value ofkeyplace might
be changed.
Aﬀected By:
ccase andecase , since they might signal an error, are potentially aected by existing handlers and
*debug-io* .
Exceptional Situations:
ccase andecase signal an error of typetype-error if no normal-clause matches.
See Also:
cond ,typecase ,setf, Section 5.1 (Generalized Reference)
Notes:
(case test-key
f((fkeyg*)fformg*)g*)

(let ((#1=#:g0001 test-key))
(condf((member #1# ’(fkeyg*))fformg*)g*))
The specic error message used by ecase andccase can vary between implementations. In
situations where control of the specic wording of the error message is important, it is better to
usecase with an otherwise-clause that explicitly signals an error with an appropriate message.
typecase,ctypecase,etypecase Macro
Syntax:
typecase keyformf#normal-clauseg* [#otherwise-clause ]!f resultg*
ctypecase keyplacef#normal-clauseg*!f resultg*
5–76 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
typecase, ctypecase, etypecase
etypecase keyformf#normal-clauseg*!f resultg*
normal-clause:: =(typefformg*)
otherwise-clause:: =(fotherwisejtgfformg*)
clause:: =normal-clausejotherwise-clause
Arguments and Values:
keyform |aform ; evaluated to produce a test-key .
keyplace |aform ; evaluated initially to produce a test-key . Possibly also used later as a place if no
types match.
test-key |an object produced by evaluating keyform orkeyplace .
type|atype specier .
forms |an implicit progn .
results |the values returned by the forms in the matching clause .
Description:
These macros allow the conditional execution of a body of forms in a clause that is selected by
matching the test-key on the basis of its type.
The keyform orkeyplace isevaluated to produce the test-key .
Each of the normal-clauses is then considered in turn. If the test-key is of the type given by the
clauses 'stype, the forms in that clause areevaluated as an implicit progn , and the values it returns
are returned as the value of the typecase ,ctypecase , oretypecase form .
These macros dier only in their behavior when no normal-clause matches; specically:
typecase
If no normal-clause matches, and there is an otherwise-clause , then that otherwise-clause
automatically matches; the forms in that clause areevaluated as an implicit progn , and the
values it returns are returned as the value of the typecase .
If there is no otherwise-clause ,typecase returnsnil.
ctypecase
If no normal-clause matches, a correctable error oftypetype-error is signaled. The oending
datum is the test-key and the expected type is type equivalent to(or type1 type2 ...).
Thestore-value restart can be used to correct the error.
If thestore-value restart is invoked, its argument becomes the new test-key , and is stored
Data and Control Flow 5–77
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
typecase, ctypecase, etypecase
inkeyplace as if by(setf keyplace test-key ). Thenctypecase starts over, considering each
clause anew.
If thestore-value restart is invoked interactively, the user is prompted for a new test-key
to use.
The subforms of keyplace might be evaluated again if none of the cases holds.
etypecase
If no normal-clause matches, a non-correctable error oftypetype-error is signaled.
The oending datum is the test-key and the expected type is type equivalent to
(or type1 type2 ...).
Note that in contrast with ctypecase , the caller of etypecase may rely on the fact that
etypecase does not return if a normal-clause does not match.
In all three cases, is permissible for more than one clause to specify a matching type, particularly if
one is a subtype of another; the earliest applicable clause is chosen.
Examples:
;;; (Note that the parts of this example which use TYPE-OF
;;; are implementation-dependent.)
(defun what-is-it (x)
(format t "~&~S is ~A.~%"
x (typecase x
(float "a float")
(null "a symbol, boolean false, or the empty list")
(list "a list")
(t (format nil "a(n) ~(~A~)" (type-of x))))))
!WHAT-IS-IT
(map ’nil #’what-is-it ’(nil (a b) 7.0 7 box))
.NIL is a symbol, boolean false, or the empty list.
.(A B) is a list.
.7.0 is a float.
.7 is a(n) integer.
.BOX is a(n) symbol.
!NIL
(setq x 1/3)
!1/3
(ctypecase x
(integer (* x 4))
(symbol (symbol-value x)))
.Error: The value of X, 1/3, is neither an integer nor a symbol.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a value to use instead.
5–78 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.2: Return to Lisp Toplevel.
.Debug> :CONTINUE 1
.Use value: 3.7
.Error: The value of X, 3.7, is neither an integer nor a symbol.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a value to use instead.
.2: Return to Lisp Toplevel.
.Debug> :CONTINUE 1
.Use value: 12
!48
x!12
Aﬀected By:
ctypecase andetypecase , since they might signal an error, are potentially aected by existing
handlers and*debug-io* .
Exceptional Situations:
ctypecase andetypecase signal an error of typetype-error if no normal-clause matches.
The compiler may choose to issue a warning of typestyle-warning if aclause will never be selected
because it is completely shadowed by earlier clauses.
See Also:
case,cond ,setf, Section 5.1 (Generalized Reference)
Notes:
(typecase test-key
f(typefformg*)g*)

(let ((#1=#:g0001 test-key))
(condf((typep #1# ’ type)fformg*)g*))
The specic error message used by etypecase andctypecase can vary between implementations.
In situations where control of the specic wording of the error message is important, it is better to
usetypecase with an otherwise-clause that explicitly signals an error with an appropriate message.
multiple-value-bind Macro
Syntax:
multiple-value-bind (fvarg*)values-formfdeclarationg*fformg*
!f resultg*
Data and Control Flow 5–79
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments and Values:
var|asymbol naming a variable; not evaluated.
values-form |aform ; evaluated.
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values returned by the forms .
Description:
Creates new variable bindings for the varsand executes a series of forms that use these bindings .
The variable bindings created are lexical unless special declarations are specied.
Values-form is evaluated, and each of the vars is bound to the respective value returned by that
form . If there are more varsthan values returned, extra values of nilare given to the remaining
vars. If there are more values than vars, the excess values are discarded. The varsare bound to the
values over the execution of the forms , which make up an implicit progn . The consequences are
unspecied if a type declaration is specied for a var, but the value to which that varis bound is
not consistent with the type declaration .
The scopes of the name binding and declarations do not include the values-form .
Examples:
(multiple-value-bind (f r)
(floor 130 11)
(list f r))!(11 9)
See Also:
let,multiple-value-call
Notes:
(multiple-value-bind ( fvarg*)values-formfformg*)
(multiple-value-call #’(lambda (&optional fvarg*&rest #1=#:ignore)
(declare (ignore #1#))
fformg*)
values-form )
5–80 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
multiple-value-call Special Operator
Syntax:
multiple-value-call function-form form *!f resultg*
Arguments and Values:
function-form |aform ; evaluated to produce function .
function |afunction designator resulting from the evaluation of function-form .
form|aform .
results |the values returned by the function .
Description:
Applies function to a listof the objects collected from groups of multiple values 2.
multiple-value-call rst evaluates the function-form to obtain function , and then evaluates each
form. All the values of each form are gathered together (not just one value from each) and given as
arguments to the function .
Examples:
(multiple-value-call #’list 1 ’/ (values 2 3) ’/ (values) ’/ (floor 2.5))
!(1 / 2 3 / / 2 0.5)
(+ (floor 5 3) (floor 19 4)) (+ 1 4)
!5
(multiple-value-call #’+ (floor 5 3) (floor 19 4)) (+ 1 2 4 3)
!10
See Also:
multiple-value-list ,multiple-value-bind
multiple-value-list Macro
Syntax:
multiple-value-list form!list
Arguments and Values:
form|aform ; evaluated as described below.
list|alistof the values returned by form.
Data and Control Flow 5–81
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
multiple-value-list evaluates form and creates a listof the multiple values 2it returns.
Examples:
(multiple-value-list (floor -3 4)) !(-1 1)
See Also:
values-list ,multiple-value-call
Notes:
multiple-value-list andvalues-list are inverses of each other.
(multiple-value-list form) (multiple-value-call #’list form)
multiple-value-prog1 Special Operator
Syntax:
multiple-value-prog1 rst-formfformg*!rst-form-results
Arguments and Values:
rst-form |aform ; evaluated as described below.
form|aform ; evaluated as described below.
rst-form-results |the values resulting from the evaluation ofrst-form .
Description:
multiple-value-prog1 evaluates rst-form and saves all the values produced by that form . It then
evaluates each form from left to right, discarding their values.
Examples:
(setq temp ’(1 2 3)) !(1 2 3)
(multiple-value-prog1
(values-list temp)
(setq temp nil)
(values-list temp)) !1, 2, 3
See Also:
prog1
5–82 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
multiple-value-setq
multiple-value-setq Macro
Syntax:
multiple-value-setq vars form!result
Arguments and Values:
vars|alistofsymbols that are either variable names ornames ofsymbol macros .
form|aform .
result |The primary value returned by the form.
Description:
multiple-value-setq assigns values to vars.
The form is evaluated, and each varisassigned to the corresponding value returned by that form .
If there are more vars than values returned, nilisassigned to the extra vars. If there are more
values than vars, the extra values are discarded.
If any varis the name of a symbol macro , then it is assigned as if bysetf. Specically,
(multiple-value-setq ( symbol 1...symbol n)value-producing-form )
is dened to always behave in the same way as
(values (setf (values symbol 1...symbol n)value-producing-form ))
in order that the rules for order of evaluation and side-eects be consistent with those used by
setf. See Section 5.1.2.3 (VALUES Forms as Places).
Examples:
(multiple-value-setq (quotient remainder) (truncate 3.2 2)) !1
quotient!1
remainder!1.2
(multiple-value-setq (a b c) (values 1 2)) !1
a!1
b!2
c!NIL
(multiple-value-setq (a b) (values 4 5 6)) !4
a!4
b!5
See Also:
setq,symbol-macrolet
Data and Control Flow 5–83
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
values Accessor
Syntax:
values&rest object!f objectg*
(setf (values &rest place)new-values )
Arguments and Values:
object |an object .
place |aplace .
new-value |an object .
Description:
values returns the objects asmultiple values 2.
setf ofvalues is used to store the multiple values 2new-values into the places . See Section 5.1.2.3
(VALUES Forms as Places).
Examples:
(values)!hno valuesi
(values 1)!1
(values 1 2)!1, 2
(values 1 2 3)!1, 2, 3
(values (values 1 2 3) 4 5) !1, 4, 5
(defun polar (x y)
(values (sqrt (+ (* x x) (* y y))) (atan y x))) !POLAR
(multiple-value-bind (r theta) (polar 3.0 4.0)
(vector r theta))
!#(5.0 0.927295)
Sometimes it is desirable to indicate explicitly that a function returns exactly one value. For
example, the function
(defun foo (x y)
(floor (+ x y) y)) !FOO
returns two values because ﬂoor returns two values. It may be that the second value makes no
sense, or that for eciency reasons it is desired not to compute the second value. values is the
standard idiom for indicating that only one value is to be returned:
5–84 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defun foo (x y)
(values (floor (+ x y) y))) !FOO
This works because values returns exactly one value for each of args; as for any function call, if
any of args produces more than one value, all but the rst are discarded.
See Also:
values-list ,multiple-value-bind ,multiple-values-limit , Section 3.1 (Evaluation)
Notes:
Sincevalues is afunction , not a macro orspecial form , it receives as arguments only the primary
values of its argument forms .
values-list Function
Syntax:
values-list list!f elementg*
Arguments and Values:
list|alist.
elements |the elements of the list.
Description:
Returns the elements of the listasmultiple values 2.
Examples:
(values-list nil) !hno valuesi
(values-list ’(1)) !1
(values-list ’(1 2)) !1, 2
(values-list ’(1 2 3)) !1, 2, 3
Exceptional Situations:
Should signal type-error if its argument is not a proper list .
See Also:
multiple-value-bind ,multiple-value-list ,multiple-values-limit ,values
Notes:
(values-list list)(apply #’values list)
(equal x(multiple-value-list (values-list x)))returns true for all lists x.
Data and Control Flow 5–85
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
multiple-values-limit Constant Variable
Constant Value:
Aninteger not smaller than 20, the exact magnitude of which is implementation-dependent .
Description:
The upper exclusive bound on the number of values that may be returned from a function , bound
or assigned by multiple-value-bind ormultiple-value-setq , or passed as a rst argument to
nth-value . (If these individual limits might dier, the minimum value is used.)
See Also:
lambda-parameters-limit ,call-arguments-limit
Notes:
Implementors are encouraged to make this limit as large as possible.
nth-value Macro
Syntax:
nth-value n form!object
Arguments and Values:
n|a non-negative integer ; evaluated.
form|aform ; evaluated as described below.
object |an object .
Description:
Evaluates nand then form, returning as its only value the nth value yielded byform, ornilifn
is greater than or equal to the number of values returned by form. (The rst returned value is
numbered 0.)
Examples:
(nth-value 0 (values ’a ’b)) !A
(nth-value 1 (values ’a ’b)) !B
(nth-value 2 (values ’a ’b)) !NIL
(let* ((x 83927472397238947423879243432432432)
(y 32423489732)
5–86 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(a (nth-value 1 (floor x y)))
(b (mod x y)))
(values a b (= a b)))
!3332987528, 3332987528, true
See Also:
multiple-value-list ,nth
Notes:
Operationally, the following relationship is true, although nth-value might be more ecient in
some implementations because, for example, some consing might be avoided.
(nth-value n form)(nth n(multiple-value-list form))
prog,prog Macro
Syntax:
prog (fvarj(var[init-form ])g*)fdeclarationg*ftagjstatementg*
!f resultg*
prog* (fvarj(var[init-form ])g*)fdeclarationg*ftagjstatementg*
!f resultg*
Arguments and Values:
var|variable name.
init-form |aform .
declaration |adeclare expression ; not evaluated.
tag|ago tag ; not evaluated.
statement |acompound form ; evaluated as described below.
results |nilif anormal return occurs, or else, if an explicit return occurs, the values that were
transferred.
Description:
Three distinct operations are performed by prog andprog* : they bind local variables, they permit
use of the return statement, and they permit use of the gostatement. A typical prog looks like
this:
(prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))
fdeclarationg*
Data and Control Flow 5–87
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
prog, prog
statement1
tag1
statement2
statement3
statement4
tag2
statement5
...
)
Forprog ,init-forms are evaluated rst, in the order in which they are supplied. The varsare then
bound to the corresponding values in parallel. If no init-form is supplied for a given var, that varis
bound to nil.
The body of prog is executed as if it were a tagbody form ; thegostatement can be used to
transfer control to a tag.Tags label statements .
prog implicitly establishes a block namednilaround the entire prog form , so that return can be
used at any time to exit from the prog form .
The dierence between prog* andprog is that in prog* thebinding and initialization of the vars
is done sequentially , so that the init-form for each one can use the values of previous ones.
Examples:
(prog* ((y z) (x (car y)))
(return x))
returns the carof the value of z.
(setq a 1)!1
(prog ((a 2) (b a)) (return (if (= a b) ’= ’/=))) !/=
(prog* ((a 2) (b a)) (return (if (= a b) ’= ’/=))) !=
(prog () ’no-return-value) !NIL
(defun king-of-confusion (w)
"Take a cons of two lists and make a list of conses.
Think of this function as being like a zipper."
(prog (x y z) ;Initialize x, y, z to NIL
(setq y (car w) z (cdr w))
loop
(cond ((null y) (return x))
((null z) (go err)))
rejoin
(setq x (cons (cons (car y) (car z)) x))
(setq y (cdr y) z (cdr z))
(go loop)
err
5–88 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(cerror "Will self-pair extraneous items"
"Mismatch - gleep! ~S" y)
(setq z y)
(go rejoin)))!KING-OF-CONFUSION
This can be accomplished more perspicuously as follows:
(defun prince-of-clarity (w)
"Take a cons of two lists and make a list of conses.
Think of this function as being like a zipper."
(do ((y (car w) (cdr y))
(z (cdr w) (cdr z))
(x ’() (cons (cons (car y) (car z)) x)))
((null y) x)
(when (null z)
(cerror "Will self-pair extraneous items"
"Mismatch - gleep! ~S" y)
(setq z y))))!PRINCE-OF-CLARITY
See Also:
block ,let,tagbody ,go,return , Section 3.1 (Evaluation)
Notes:
prog can be explained in terms of block ,let, andtagbody as follows:
(prog variable-list declaration .body)
(block nil (let variable-list declaration (tagbody . body)))
prog1,prog2 Macro
Syntax:
prog1 rst-formfformg*!result-1
prog2 rst-form second-form fformg*!result-2
Arguments and Values:
rst-form |aform ; evaluated as described below.
second-form |aform ; evaluated as described below.
forms |an implicit progn ; evaluated as described below.
result-1 |the primary value resulting from the evaluation ofrst-form .
Data and Control Flow 5–89
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
prog1, prog2
result-2 |the primary value resulting from the evaluation ofsecond-form .
Description:
prog1 evaluates rst-form and then forms ,yielding as its only value theprimary value yielded by
rst-form .
prog2 evaluates rst-form , then second-form , and then forms ,yielding as its only value theprimary
value yielded byrst-form .
Examples:
(setq temp 1)!1
(prog1 temp (print temp) (incf temp) (print temp))
.1
.2
!1
(prog1 temp (setq temp nil)) !2
temp!NIL
(prog1 (values 1 2 3) 4) !1
(setq temp (list ’a ’b ’c))
(prog1 (car temp) (setf (car temp) ’alpha)) !A
temp!(ALPHA B C)
(flet ((swap-symbol-values (x y)
(setf (symbol-value x)
(prog1 (symbol-value y)
(setf (symbol-value y) (symbol-value x))))))
(let ((*foo* 1) (*bar* 2))
(declare (special *foo* *bar*))
(swap-symbol-values ’*foo* ’*bar*)
(values *foo* *bar*)))
!2, 1
(setq temp 1)!1
(prog2 (incf temp) (incf temp) (incf temp)) !3
temp!4
(prog2 1 (values 2 3 4) 5) !2
See Also:
multiple-value-prog1 ,progn
Notes:
prog1 andprog2 are typically used to evaluate one or more forms with side eects and return a
value that must be computed before some or all of the side eects happen.
(prog1fformg*)(values (multiple-value-prog1 fformg*))
(prog2 form1fformg*)(let () form1(prog1fformg*))
5–90 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
progn Special Operator
Syntax:
prognfformg*!f resultg*
Arguments and Values:
forms |an implicit progn .
results |the values of the forms .
Description:
progn evaluates forms , in the order in which they are given.
The values of each form but the last are discarded.
Ifprogn appears as a top level form , then all forms within that progn are considered by the
compiler to be top level forms .
Examples:
(progn)!NIL
(progn 1 2 3)!3
(progn (values 1 2 3)) !1, 2, 3
(setq a 1)!1
(if a
(progn (setq a nil) ’here)
(progn (setq a t) ’there)) !HERE
a!NIL
See Also:
prog1 ,prog2 , Section 3.1 (Evaluation)
Notes:
Many places in Common Lisp involve syntax that uses implicit progns . That is, part of their syntax
allows many forms to be written that are to be evaluated sequentially, discarding the results of
allforms but the last and returning the results of the last form . Such places include, but are
not limited to, the following: the body of a lambda expression ; the bodies of various control and
conditional forms (e.g.,case,catch ,progn , andwhen ).
Data and Control Flow 5–91
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-modify-macro
deﬁne-modify-macro Macro
Syntax:
deﬁne-modify-macro name lambda-list function [documentation ]!name
Arguments and Values:
name |asymbol .
lambda-list |adene-modify-macro lambda list
function |asymbol .
documentation |astring ; not evaluated.
Description:
deﬁne-modify-macro denes a macro named name toread and write aplace .
The arguments to the new macro are a place , followed by the arguments that are supplied in
lambda-list .Macros dened with deﬁne-modify-macro correctly pass the environment parameter
toget-setf-expansion .
When the macro is invoked, function is applied to the old contents of the place and the lambda-list
arguments to obtain the new value, and the place is updated to contain the result.
Except for the issue of avoiding multiple evaluation (see below), the expansion of a
deﬁne-modify-macro is equivalent to the following:
(defmacro name(reference . lambda-list )
documentation
‘(setf ,reference
(function ,reference , arg1,arg2...)))
where arg1,arg2, ..., are the parameters appearing in lambda-list ; appropriate provision is made for
arest parameter .
The subforms of the macro calls dened by deﬁne-modify-macro are evaluated as specied in
Section 5.1.1.1 (Evaluation of Subforms to Places).
Documentation is attached as a documentation string toname (as kindfunction ) and to the macro
function .
If adeﬁne-modify-macro form appears as a top level form , the compiler must store the macro
denition at compile time, so that occurrences of the macro later on in the le can be expanded
correctly.
5–92 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(define-modify-macro appendf (&rest args)
append "Append onto list") !APPENDF
(setq x ’(a b c) y x) !(A B C)
(appendf x ’(d e f) ’(1 2 3)) !(A B C D E F 1 2 3)
x!(A B C D E F 1 2 3)
y!(A B C)
(define-modify-macro new-incf (&optional (delta 1)) +)
(define-modify-macro unionf (other-set &rest keywords) union)
Side Eﬀects:
A macro denition is assigned to name .
See Also:
defsetf ,deﬁne-setf-expander ,documentation , Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations)
defsetf Macro
Syntax:
The \short form":
defsetf access-fn update-fn [documentation ]
!access-fn
The \long form":
defsetf access-fn lambda-list (fstore-variableg*)[ [fdeclarationg*jdocumentation ] ]fformg*
!access-fn
Arguments and Values:
access-fn |asymbol which names a function or a macro .
update-fn |asymbol naming a function ormacro .
lambda-list |adefsetf lambda list .
store-variable |asymbol (avariable name ).
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
form|aform .
Data and Control Flow 5–93
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defsetf
Description:
defsetf denes how to setf aplace of the form (access-fn ...) for relatively simple cases. (See
deﬁne-setf-expander for more general access to this facility.) It must be the case that the function
ormacro named by access-fn evaluates all of its arguments.
defsetf may take one of two forms, called the \short form" and the \long form," which are
distinguished by the type of the second argument .
When the short form is used, update-fn must name a function (ormacro ) that takes one more
argument than access-fn takes. When setf is given a place that is a call on access-fn , it expands
into a call on update-fn that is given all the arguments to access-fn and also, as its last argument,
the new value (which must be returned by update-fn as its value).
The long form defsetf resembles defmacro . The lambda-list describes the arguments of access-fn .
The store-variables describe the value or values to be stored into the place . The body must compute
the expansion of a setf of a call on access-fn . The expansion function is dened in the same lexical
environment in which the defsetf form appears.
During the evaluation of the forms , the variables in the lambda-list and the store-variables are
bound to names of temporary variables, generated as if by gensym orgentemp , that will be bound
by the expansion of setf to the values of those subforms . This binding permits the forms to be
written without regard for order-of-evaluation issues. defsetf arranges for the temporary variables
to be optimized out of the nal result in cases where that is possible.
The body code in defsetf is implicitly enclosed in a block whose name is access-fn
defsetf ensures that subforms of the place are evaluated exactly once.
Documentation is attached to access-fn as a documentation string of kindsetf.
If adefsetf form appears as a top level form , the compiler must make the setf expander available
so that it may be used to expand calls to setflater on in the le. Users must ensure that the forms ,
if any, can be evaluated at compile time if the access-fn is used in a place later in the same le.
The compiler must make these setf expanders available to compile-time calls to get-setf-expansion
when its environment argument is a value received as the environment parameter of a macro .
Examples:
The eect of
(defsetf symbol-value set)
is built into the Common Lisp system. This causes the form (setf (symbol-value foo) fu) to
expand into (set foo fu) .
Note that
(defsetf car rplaca)
would be incorrect because rplaca does not return its last argument.
5–94 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defsetf
(defun middleguy (x) (nth (truncate (1- (list-length x)) 2) x)) !MIDDLEGUY
(defun set-middleguy (x v)
(unless (null x)
(rplaca (nthcdr (truncate (1- (list-length x)) 2) x) v))
v)!SET-MIDDLEGUY
(defsetf middleguy set-middleguy) !MIDDLEGUY
(setq a (list ’a ’b ’c ’d)
b (list ’x)
c (list 1 2 3 (list 4 5 6) 7 8 9)) !(1 2 3 (4 5 6) 7 8 9)
(setf (middleguy a) 3) !3
(setf (middleguy b) 7) !7
(setf (middleguy (middleguy c)) ’middleguy-symbol) !MIDDLEGUY-SYMBOL
a!(A 3 C D)
b!(7)
c!(1 2 3 (4 MIDDLEGUY-SYMBOL 6) 7 8 9)
An example of the use of the long form of defsetf :
(defsetf subseq (sequence start &optional end) (new-sequence)
‘(progn (replace ,sequence ,new-sequence
:start1 ,start :end1 ,end)
,new-sequence)) !SUBSEQ
(defvar *xy* (make-array ’(10 10)))
(defun xy (&key ((x x) 0) ((y y) 0)) (aref *xy* x y)) !XY
(defun set-xy (new-value &key ((x x) 0) ((y y) 0))
(setf (aref *xy* x y) new-value)) !SET-XY
(defsetf xy (&key ((x x) 0) ((y y) 0)) (store)
‘(set-xy ,store ’x ,x ’y ,y)) !XY
(get-setf-expansion ’(xy a b))
!(#:t0 #:t1),
(a b),
(#:store),
((lambda (&key ((x #:x)) ((y #:y)))
(set-xy #:store ’x #:x ’y #:y))
#:t0 #:t1),
(xy #:t0 #:t1)
(xy ’x 1)!NIL
(setf (xy ’x 1) 1) !1
(xy ’x 1)!1
(let ((a ’x) (b ’y))
(setf (xy a 1 b 2) 3)
(setf (xy b 5 a 9) 14))
!14
(xy ’y 0 ’x 1)!1
(xy ’x 1 ’y 2)!3
Data and Control Flow 5–95
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
documentation ,setf,deﬁne-setf-expander ,get-setf-expansion , Section 5.1 (Generalized
Reference), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)
Notes:
forms must include provision for returning the correct value (the value or values of store-variable ).
This is handled by forms rather than by defsetf because in many cases this value can be returned
at no extra cost, by calling a function that simultaneously stores into the place and returns the
correct value.
Asetf of a call on access-fn also evaluates all of access-fn 's arguments; it cannot treat any of them
specially. This means that defsetf cannot be used to describe how to store into a generalized
reference to a byte, such as (ldb field reference) .deﬁne-setf-expander is used to handle
situations that do not t the restrictions imposed by defsetf and gives the user additional control.
deﬁne-setf-expander Macro
Syntax:
deﬁne-setf-expander access-fn lambda-list
[ [fdeclarationg*jdocumentation ] ]fformg*
!access-fn
Arguments and Values:
access-fn |asymbol that names afunction ormacro .
lambda-list {macro lambda list .
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
forms |an implicit progn .
Description:
deﬁne-setf-expander species the means by which setf updates a place that is referenced by
access-fn .
Whensetfis given a place that is specied in terms of access-fn and a new value for the place , it is
expanded into a form that performs the appropriate update.
The lambda-list supports destructuring. See Section 3.4.4 (Macro Lambda Lists).
Documentation is attached to access-fn as a documentation string of kindsetf.
5–96 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-setf-expander
Forms constitute the body of the setf expander denition and must compute the setf expansion for
a call on setfthat references the place by means of the given access-fn . The setf expander function
is dened in the same lexical environment in which the deﬁne-setf-expander form appears. While
forms are being executed, the variables in lambda-list are bound to parts of the place form . The
body forms (but not the lambda-list ) in adeﬁne-setf-expander form are implicitly enclosed in a
block whose name is access-fn .
The evaluation of forms must result in the ve values described in Section 5.1.1.2 (Setf Expansions).
If adeﬁne-setf-expander form appears as a top level form , the compiler must make the setf
expander available so that it may be used to expand calls to setflater on in the le.Programmers
must ensure that the forms can be evaluated at compile time if the access-fn is used in a place
later in the same le. The compiler must make these setf expanders available to compile-time
calls toget-setf-expansion when its environment argument is a value received as the environment
parameter of a macro .
Examples:
(defun lastguy (x) (car (last x))) !LASTGUY
(define-setf-expander lastguy (x &environment env)
"Set the last element in a list to the given value."
(multiple-value-bind (dummies vals newval setter getter)
(get-setf-expansion x env)
(let ((store (gensym)))
(values dummies
vals
‘(,store)
‘(progn (rplaca (last ,getter) ,store) ,store)
‘(lastguy ,getter))))) !LASTGUY
(setq a (list ’a ’b ’c ’d)
b (list ’x)
c (list 1 2 3 (list 4 5 6))) !(1 2 3 (4 5 6))
(setf (lastguy a) 3) !3
(setf (lastguy b) 7) !7
(setf (lastguy (lastguy c)) ’lastguy-symbol) !LASTGUY-SYMBOL
a!(A B C 3)
b!(7)
c!(1 2 3 (4 5 LASTGUY-SYMBOL))
;;; Setf expander for the form (LDB bytespec int).
;;; Recall that the int form must itself be suitable for SETF.
(define-setf-expander ldb (bytespec int &environment env)
(multiple-value-bind (temps vals stores
store-form access-form)
(get-setf-expansion int env);Get setf expansion for int.
Data and Control Flow 5–97
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(let ((btemp (gensym)) ;Temp var for byte specifier.
(store (gensym)) ;Temp var for byte to store.
(stemp (first stores))) ;Temp var for int to store.
(if (cdr stores) (error "Can’t expand this."))
;;; Return the setf expansion for LDB as five values.
(values (cons btemp temps) ;Temporary variables.
(cons bytespec vals) ;Value forms.
(list store) ;Store variables.
‘(let ((,stemp (dpb ,store ,btemp ,access-form)))
,store-form
,store) ;Storing form.
‘(ldb ,btemp ,access-form) ;Accessing form.
))))
See Also:
setf,defsetf ,documentation ,get-setf-expansion , Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations)
Notes:
deﬁne-setf-expander diers from the long form of defsetf in that while the body is being executed
thevariables inlambda-list are bound to parts of the place form , not to temporary variables that
will be bound to the values of such parts. In addition, deﬁne-setf-expander does not have defsetf 's
restriction that access-fn must be a function or a function-like macro ; an arbitrary defmacro
destructuring pattern is permitted in lambda-list .
get-setf-expansion Function
Syntax:
get-setf-expansion place&optional environment
!vars, vals, store-vars, writer-form, reader-form
Arguments and Values:
place |aplace .
environment |an environment object .
vars, vals, store-vars, writer-form, reader-form |asetf expansion .
Description:
Determines ve values constituting the setf expansion forplace inenvironment ; see Section 5.1.1.2
(Setf Expansions).
5–98 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Ifenvironment is not supplied or nil, the environment is the null lexical environment .
Examples:
(get-setf-expansion ’x)
!NIL, NIL, (#:G0001), (SETQ X #:G0001), X
;;; This macro is like POP
(defmacro xpop (place &environment env)
(multiple-value-bind (dummies vals new setter getter)
(get-setf-expansion place env)
‘(let* (,@(mapcar #’list dummies vals) (,(car new) ,getter))
(if (cdr new) (error "Can’t expand this."))
(prog1 (car ,(car new))
(setq ,(car new) (cdr ,(car new)))
,setter))))
(defsetf frob (x) (value)
‘(setf (car ,x) ,value)) !FROB
;;; The following is an error; an error might be signaled at macro expansion time
(flet ((frob (x) (cdr x))) ;Invalid
(xpop (frob z)))
See Also:
defsetf ,deﬁne-setf-expander ,setf
Notes:
Any compound form is a valid place , since any compound form whose operator fhas no setf
expander are expanded into a call to (setf f).
setf,psetf Macro
Syntax:
setff#pairg*!f resultg*
psetff#pairg*!nil
pair:: =place newvalue
Data and Control Flow 5–99
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
setf, psetf
Arguments and Values:
place |aplace .
newvalue |aform .
results |the multiple values 2returned by the storing form for the last place , ornilif there are no
pairs.
Description:
setf changes the value ofplace to be newvalue .
(setf place newvalue) expands into an update form that stores the result of evaluating newvalue
into the location referred to by place . Some place forms involve uses of accessors that take optional
arguments. Whether those optional arguments are permitted by setf, or what their use is, is up
to thesetf expander function and is not under the control of setf. The documentation for any
function that accepts &optional ,&rest , or&key arguments and that claims to be usable with setf
must specify how those arguments are treated.
If more than one pairis supplied, the pairs are processed sequentially; that is,
(setf place-1 newvalue-1
place-2 newvalue-2
...
place-N newvalue-N)
is precisely equivalent to
(progn (setf place-1 newvalue-1)
(setf place-2 newvalue-2)
...
(setf place-N newvalue-N))
Forpsetf , if more than one pairis supplied then the assignments of new values to places are done
in parallel. More precisely, all subforms (in both the place and newvalue forms ) that are to be
evaluated are evaluated from left to right; after all evaluations have been performed, all of the
assignments are performed in an unpredictable order.
For detailed treatment of the expansion of setf andpsetf , see Section 5.1.2 (Kinds of Places).
Examples:
(setq x (cons ’a ’b) y (list 1 2 3)) !(1 2 3)
(setf (car x) ’x (cadr y) (car x) (cdr x) y) !(1 X 3)
x!(X 1 X 3)
y!(1 X 3)
(setq x (cons ’a ’b) y (list 1 2 3)) !(1 2 3)
(psetf (car x) ’x (cadr y) (car x) (cdr x) y) !NIL
x!(X 1 A 3)
5–100 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
y!(1 A 3)
Aﬀected By:
deﬁne-setf-expander ,defsetf ,*macroexpand-hook*
See Also:
deﬁne-setf-expander ,defsetf ,macroexpand-1 ,rotatef ,shiftf , Section 5.1 (Generalized
Reference)
shiftf Macro
Syntax:
shiftffplaceg+newvalue!old-value-1
Arguments and Values:
place |aplace .
newvalue |aform ; evaluated.
old-value-1 |an object (the old value of the rst place ).
Description:
shiftf modies the values of each place by storing newvalue into the last place , and shifting the
values of the second through the last place into the remaining places .
Ifnewvalue produces more values than there are store variables, the extra values are ignored. If
newvalue produces fewer values than there are store variables, the missing values are set to nil.
In the form (shiftf place1 place2 ... placen newvalue ), the values in place1 through placen
areread and saved, and newvalue is evaluated, for a total of n+1 values in all. Values 2 through
n+1 are then stored into place1 through placen , respectively. It is as if all the places form a shift
register; the newvalue is shifted in from the right, all values shift over to the left one place, and the
value shifted out of place1 is returned.
For information about the evaluation ofsubforms ofplaces , see Section 5.1.1.1 (Evaluation of
Subforms to Places).
Examples:
(setq x (list 1 2 3) y ’trash) !TRASH
(shiftf y x (cdr x) ’(hi there)) !TRASH
x!(2 3)
y!(1 HI THERE)
Data and Control Flow 5–101
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setq x (list ’a ’b ’c)) !(A B C)
(shiftf (cadr x) ’z) !B
x!(A Z C)
(shiftf (cadr x) (cddr x) ’q) !Z
x!(A (C) . Q)
(setq n 0)!0
(setq x (list ’a ’b ’c ’d)) !(A B C D)
(shiftf (nth (setq n (+ n 1)) x) ’z) !B
x!(A Z C D)
Aﬀected By:
deﬁne-setf-expander ,defsetf ,*macroexpand-hook*
See Also:
setf,rotatef , Section 5.1 (Generalized Reference)
Notes:
The eect of (shiftf place1 place2 ... placen newvalue )is roughly equivalent to
(let ((var1 place1)
(var2 place2)
...
(varn placen)
(var0 newvalue ))
(setf place1var2)
(setf place2var3)
...
(setf placenvar0)
var1)
except that the latter would evaluate any subforms of eachplace twice, whereas shiftf evaluates
them once. For example,
(setq n 0)!0
(setq x (list ’a ’b ’c ’d)) !(A B C D)
(prog1 (nth (setq n (+ n 1)) x)
(setf (nth (setq n (+ n 1)) x) ’z)) !B
x!(A B Z D)
5–102 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
rotatef
rotatef Macro
Syntax:
rotateffplaceg*!nil
Arguments and Values:
place |aplace .
Description:
rotatef modies the values of each place by rotating values from one place into another.
If a place produces more values than there are store variables, the extra values are ignored. If a
place produces fewer values than there are store variables, the missing values are set to nil.
In the form (rotatef place1 place2 ... placen), the values in place1 through placen areread and
written . Values 2 through nand value 1 are then stored into place1 through placen . It is as if all
the places form an end-around shift register that is rotated one place to the left, with the value of
place1 being shifted around the end to placen .
For information about the evaluation ofsubforms ofplaces , see Section 5.1.1.1 (Evaluation of
Subforms to Places).
Examples:
(let ((n 0)
(x (list ’a ’b ’c ’d ’e ’f ’g)))
(rotatef (nth (incf n) x)
(nth (incf n) x)
(nth (incf n) x))
x)!(A C D B E F G)
See Also:
deﬁne-setf-expander ,defsetf ,setf,shiftf ,*macroexpand-hook* , Section 5.1 (Generalized
Reference)
Notes:
The eect of (rotatef place1 place2 ... placen)is roughly equivalent to
(psetf place1 place2
place2 place3
...
placen place1 )
except that the latter would evaluate any subforms of eachplace twice, whereas rotatef evaluates
them once.
Data and Control Flow 5–103
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
control-error Condition Type
Class Precedence List:
control-error ,error ,serious-condition ,condition ,t
Description:
The typecontrol-error consists of error conditions that result from invalid dynamic transfers of
control in a program. The errors that result from giving throw a tag that is not active or from
givinggoorreturn-from a tag that is no longer dynamically available are of typecontrol-error .
program-error Condition Type
Class Precedence List:
program-error ,error ,serious-condition ,condition ,t
Description:
The typeprogram-error consists of error conditions related to incorrect program syntax. The
errors that result from naming a go tag or a block tag that is not lexically apparent are of type
program-error .
undeﬁned-function Condition Type
Class Precedence List:
undeﬁned-function ,cell-error ,error ,serious-condition ,condition ,t
Description:
The typeundeﬁned-function consists of error conditions that represent attempts to read the
denition of an undened function .
The name of the cell (see cell-error ) is the function name which was funbound .
See Also:
cell-error-name
5–104 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
6. Iteration
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Iteration iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1 The LOOP Facility
6.1.1 Overview of the Loop Facility
Theloop macro performs iteration.
6.1.1.1 Simple vs Extended Loop
loop forms are partitioned into two categories: simple loop forms and extended loop forms .
6.1.1.1.1 Simple Loop
A simple loop form is one that has a body containing only compound forms . Each form isevaluated
in turn from left to right. When the last form has been evaluated , then the rst form is evaluated
again, and so on, in a never-ending cycle. A simple loop form establishes an implicit block named
nil. The execution of a simple loop can be terminated by explicitly transfering control to the
implicit block (usingreturn orreturn-from ) or to some exit point outside of the block (e.g., using
throw ,go, orreturn-from ).
6.1.1.1.2 Extended Loop
An extended loop form is one that has a body containing atomic expressions . When the loop
macro processes such a form , it invokes a facility that is commonly called \the Loop Facility."
The Loop Facility provides standardized access to mechanisms commonly used in iterations through
Loop schemas, which are introduced by loop keywords .
The body of an extended loop form is divided into loop clauses, each which is in turn made up of
loop keywords and forms .
6.1.1.2 Loop Keywords
Loop keywords are not true keywords 1; they are special symbols , recognized by name rather than
object identity, that are meaningful only to the loop facility. A loop keyword is a symbol but is
recognized by its name (not its identity), regardless of the packages in which it is accessible .
In general, loop keywords are not external symbols of theCOMMON-LISP package , except in the
coincidental situation that a symbol with the same name as a loop keyword was needed for some
other purpose in Common Lisp. For example, there is a symbol in theCOMMON-LISP package whose
name is"UNLESS" but not one whose name is"UNTIL" .
If no loop keywords are supplied in a loop form , the Loop Facility executes the loop body
repeatedly; see Section 6.1.1.1.1 (Simple Loop).
Iteration 6–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.1.3 Parsing Loop Clauses
The syntactic parts of an extended loop form are called clauses; the rules for parsing are determined
by that clause's keyword. The following example shows a loop form with six clauses:
(loop for i from 1 to (compute-top-value) ; first clause
while (not (unacceptable i)) ; second clause
collect (square i) ; third clause
do (format t "Working on ~D now" i) ; fourth clause
when (evenp i) ; fifth clause
do (format t "~D is a non-odd number" i)
finally (format t "About to exit!")) ; sixth clause
Each loop keyword introduces either a compound loop clause or a simple loop clause that can
consist of a loop keyword followed by a single form . The number of forms in a clause is determined
by the loop keyword that begins the clause and by the auxiliary keywords in the clause. The
keywords do,doing ,initially , andfinally are the only loop keywords that can take any number
offorms and group them as an implicit progn .
Loop clauses can contain auxiliary keywords, which are sometimes called prepositions. For example,
the rst clause in the code above includes the prepositions from andto, which mark the value from
which stepping begins and the value at which stepping ends.
For detailed information about loop syntax, see the macroloop.
6.1.1.4 Expanding Loop Forms
Aloop macro form expands into a form containing one or more binding forms (that establish
bindings of loop variables) and a block and atagbody (that express a looping control structure).
The variables established in loop are bound as if by letorlambda .
Implementations can interleave the setting of initial values with the bindings . However, the
assignment of the initial values is always calculated in the order specied by the user. A variable
is thus sometimes bound to a meaningless value of the correct type, and then later in the prologue
it is set to the true initial value by using setq. One implication of this interleaving is that it
isimplementation-dependent whether the lexical environment in which the initial value forms
(variously called the form1 ,form2 ,form3 ,step-fun ,vector ,hash-table , and package ) in any
for-as-subclause , except for-as-equals-then , are evaluated includes only the loop variables preceding
that form or includes more or all of the loop variables; the form1 and form2 in a for-as-equals-then
form includes the lexical environment of all the loop variables.
After the form is expanded, it consists of three basic parts in the tagbody : the loop prologue, the
loop body, and the loop epilogue.
Loop prologue
The loop prologue contains forms that are executed before iteration begins, such as
any automatic variable initializations prescribed by the variable clauses, along with any
6–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
initially clauses in the order they appear in the source.
Loop body
The loop body contains those forms that are executed during iteration, including
application-specic calculations, termination tests, and variable stepping 1.
Loop epilogue
The loop epilogue contains forms that are executed after iteration terminates, such as
finally clauses, if any, along with any implicit return value from an accumulation clause
or an termination-test clause.
Some clauses from the source form contribute code only to the loop prologue; these clauses must
come before other clauses that are in the main body of the loop form. Others contribute code only
to the loop epilogue. All other clauses contribute to the nal translated form in the same order
given in the original source form of theloop.
Expansion of the loop macro produces an implicit block namednilunlessnamed is supplied. Thus,
return-from (and sometimes return ) can be used to return values from loop or to exit loop.
6.1.1.5 Summary of Loop Clauses
Loop clauses fall into one of the following categories:
6.1.1.5.1 Summary of Variable Initialization and Stepping Clauses
Theforandasconstructs provide iteration control clauses that establish a variable to be initialized.
forandasclauses can be combined with the loop keyword andto get parallel initialization and
stepping 1. Otherwise, the initialization and stepping 1aresequential .
Thewith construct is similar to a single letclause.with clauses can be combined using the loop
keyword andto get parallel initialization.
For more information, see Section 6.1.2 (Variable Initialization and Stepping Clauses).
6.1.1.5.2 Summary of Value Accumulation Clauses
Thecollect (orcollecting ) construct takes one form in its clause and adds the value of that form
to the end of a listof values. By default, the listof values is returned when the loop nishes.
Theappend (orappending ) construct takes one form in its clause and appends the value of that
form to the end of a listof values. By default, the listof values is returned when the loop nishes.
Thenconc (ornconcing ) construct is similar to the append construct, but its listvalues are
concatenated as if by the function nconc . By default, the listof values is returned when the loop
nishes.
Iteration 6–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Thesum(orsumming ) construct takes one form in its clause that must evaluate to a number and
accumulates the sum of all these numbers . By default, the cumulative sum is returned when the
loop nishes.
Thecount (orcounting ) construct takes one form in its clause and counts the number of times that
theform evaluates to true. By default, the count is returned when the loop nishes.
Theminimize (orminimizing ) construct takes one form in its clause and determines the minimum
value obtained by evaluating that form . By default, the minimum value is returned when the loop
nishes.
Themaximize (ormaximizing ) construct takes one form in its clause and determines the maximum
value obtained by evaluating that form . By default, the maximum value is returned when the loop
nishes.
For more information, see Section 6.1.3 (Value Accumulation Clauses).
6.1.1.5.3 Summary of Termination Test Clauses
Theforandasconstructs provide a termination test that is determined by the iteration control
clause.
Therepeat construct causes termination after a specied number of iterations. (It uses an internal
variable to keep track of the number of iterations.)
Thewhile construct takes one form , atest, and terminates the iteration if the testevaluates to
false. Awhile clause is equivalent to the expression (if (not test) (loop-finish)) .
Theuntil construct is the inverse of while ; it terminates the iteration if the testevaluates to any
non-nil value. An until clause is equivalent to the expression (if test(loop-finish)) .
Thealways construct takes one form and terminates the loop if the form ever evaluates to false;
in this case, the loop form returnsnil. Otherwise, it provides a default return value of t.
Thenever construct takes one form and terminates the loop if the form ever evaluates to true; in
this case, the loop form returnsnil. Otherwise, it provides a default return value of t.
Thethereis construct takes one form and terminates the loop if the form ever evaluates to a
non-nil object ; in this case, the loop form returns that object . Otherwise, it provides a default
return value of nil.
If multiple termination test clauses are specied, the loop form terminates if any are satised.
For more information, see Section 6.1.4 (Termination Test Clauses).
6–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.1.5.4 Summary of Unconditional Execution Clauses
Thedo(ordoing ) construct evaluates all forms in its clause.
Thereturn construct takes one form . Any values returned by the form are immediately returned by
theloop form. It is equivalent to the clause do (return-from block-name value ), where block-name
is the name specied in a named clause, or nilif there is no named clause.
For more information, see Section 6.1.5 (Unconditional Execution Clauses).
6.1.1.5.5 Summary of Conditional Execution Clauses
Theifandwhen constructs take one form as a test and a clause that is executed when the test
yields true . The clause can be a value accumulation, unconditional, or another conditional clause;
it can also be any combination of such clauses connected by the loopandkeyword.
Theloopunless construct is similar to the loopwhen construct except that it complements the
test result.
Theloopelse construct provides an optional component of if,when, andunless clauses that is
executed when an iforwhen test yields false or when an unless test yields true . The component
is one of the clauses described under if.
Theloopendconstruct provides an optional component to mark the end of a conditional clause.
For more information, see Section 6.1.6 (Conditional Execution Clauses).
6.1.1.5.6 Summary of Miscellaneous Clauses
Theloopnamed construct gives a name for the block of the loop.
Theloopinitially construct causes its forms to be evaluated in the loop prologue, which precedes
allloop code except for initial settings supplied by the constructs with,for, oras.
Theloopfinally construct causes its forms to be evaluated in the loop epilogue after normal
iteration terminates.
For more information, see Section 6.1.7 (Miscellaneous Clauses).
6.1.1.6 Order of Execution
With the exceptions listed below, clauses are executed in the loop body in the order in which they
appear in the source. Execution is repeated until a clause terminates the loop or until a return ,go,
orthrow form is encountered which transfers control to a point outside of the loop. The following
actions are exceptions to the linear order of execution:
All variables are initialized rst, regardless of where the establishing clauses appear in the
source. The order of initialization follows the order of these clauses.
Iteration 6–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The code for any initially clauses is collected into one progn in the order in which the
clauses appear in the source. The collected code is executed once in the loop prologue after
any implicit variable initializations.
The code for any finally clauses is collected into one progn in the order in which the
clauses appear in the source. The collected code is executed once in the loop epilogue
before any implicit values from the accumulation clauses are returned. Explicit returns
anywhere in the source, however, will exit the loop without executing the epilogue code.
Awith clause introduces a variable binding and an optional initial value. The initial values
are calculated in the order in which the with clauses occur.
Iteration control clauses implicitly perform the following actions:
{ initialize variables;
{step variables, generally between each execution of the loop body;
{ perform termination tests, generally just before the execution of the loop body.
6.1.1.7 Destructuring
The d-type-spec argument is used for destructuring. If the d-type-spec argument consists solely of
thetypeﬁxnum ,ﬂoat,t, ornil, theof-type keyword is optional. The of-type construct is optional
in these cases to provide backwards compatibility; thus, the following two expressions are the same:
;;; This expression uses the old syntax for type specifiers.
(loop for i fixnum upfrom 3 ...)
;;; This expression uses the new syntax for type specifiers.
(loop for i of-type fixnum upfrom 3 ...)
;; Declare X and Y to be of type VECTOR and FIXNUM respectively.
(loop for (x y) of-type (vector fixnum)
in l do ...)
Atype specier for a destructuring pattern is a treeoftype speciers with the same shape as the
treeofvariable names , with the following exceptions:
When aligning the trees, an atom in the treeoftype speciers that matches a cons in the
variable tree declares the same type for each variable in the subtree rooted at the cons.
Acons in the treeoftype speciers that matches an atom in the treeofvariable names is
acompound type specifer .
6–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Destructuring allows binding of a set of variables to a corresponding set of values anywhere that
a value can normally be bound to a single variable. During loop expansion, each variable in the
variable list is matched with the values in the values list. If there are more variables in the variable
list than there are values in the values list, the remaining variables are given a value of nil. If there
are more values than variables listed, the extra values are discarded.
To assign values from a list to the variables a,b, andc, theforclause could be used to bind the
variable numlist to the carof the supplied form, and then another forclause could be used to bind
the variables a,b, andcsequentially .
;; Collect values by using FOR constructs.
(loop for numlist in ’((1 2 4.0) (5 6 8.3) (8 9 10.4))
for a of-type integer = (first numlist)
and b of-type integer = (second numlist)
and c of-type float = (third numlist)
collect (list c b a))
!((4.0 2 1) (8.3 6 5) (10.4 9 8))
Destructuring makes this process easier by allowing the variables to be bound in each loop iteration.
Types can be declared by using a list of type-spec arguments. If all the types are the same, a
shorthand destructuring syntax can be used, as the second example illustrates.
;; Destructuring simplifies the process.
(loop for (a b c) of-type (integer integer float) in
’((1 2 4.0) (5 6 8.3) (8 9 10.4))
collect (list c b a))
!((4.0 2 1) (8.3 6 5) (10.4 9 8))
;; If all the types are the same, this way is even simpler.
(loop for (a b c) of-type float in
’((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))
collect (list c b a))
!((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))
If destructuring is used to declare or initialize a number of groups of variables into types , the loop
keyword andcan be used to simplify the process further. ;; Initialize and declare variables
in parallel by using the AND construct.
(loop with (a b) of-type float = ’(1.0 2.0)
and (c d) of-type integer = ’(3 4)
and (e f)
return (list a b c d e f))
!(1.0 2.0 3 4 NIL NIL)
Ifnilis used in a destructuring list, no variable is provided for its place.
(loop for (a nil b) = ’(1 2 3)
Iteration 6–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
do (return (list a b)))
!(1 3)
Note that dotted lists can specify destructuring.
(loop for (x . y) = ’(1 . 2)
do (return y))
!2
(loop for ((a . b) (c . d)) of-type ((float . float) (integer . integer)) in
’(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6)))
collect (list a b c d))
!((1.2 2.4 3 4) (3.4 4.6 5 6))
An error of typeprogram-error is signaled (at macro expansion time) if the same variable is
bound twice in any variable-binding clause of a single loop expression. Such variables include local
variables, iteration control variables, and variables found by destructuring.
6.1.1.8 Restrictions on Side-Eﬀects
See Section 3.6 (Traversal Rules and Side Eects).
6.1.2 Variable Initialization and Stepping Clauses
6.1.2.1 Iteration Control
Iteration control clauses allow direction of loop iteration. The loop keywords forandasdesignate
iteration control clauses. Iteration control clauses dier with respect to the specication of
termination tests and to the initialization and stepping 1of loop variables. Iteration clauses by
themselves do not cause the Loop Facility to return values, but they can be used in conjunction
with value-accumulation clauses to return values.
All variables are initialized in the loop prologue. A variable binding haslexical scope unless it is
proclaimed special ; thus, by default, the variable can be accessed only by forms that lie textually
within the loop. Stepping assignments are made in the loop body before any other forms are
evaluated in the body.
The variable argument in iteration control clauses can be a destructuring list. A destructuring list
is atreewhose non-nil atoms arevariable names . See Section 6.1.1.7 (Destructuring).
The iteration control clauses for,as, andrepeat must precede any other loop clauses, except
initially ,with, andnamed , since they establish variable bindings . When iteration control clauses
are used in a loop, the corresponding termination tests in the loop body are evaluated before any
other loop body code is executed.
If multiple iteration clauses are used to control iteration, variable initialization and stepping 1occur
sequentially by default. The andconstruct can be used to connect two or more iteration clauses
6–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
when sequential binding and stepping 1are not necessary. The iteration behavior of clauses joined
byandis analogous to the behavior of the macro dowith respect to do*.
Theforandasclauses iterate by using one or more local loop variables that are initialized to
some value and that can be modied or stepped 1after each iteration. For these clauses, iteration
terminates when a local variable reaches some supplied value or when some other loop clause
terminates iteration. At each iteration, variables can be stepped 1by an increment or a decrement
or can be assigned a new value by the evaluation of a form ). Destructuring can be used to assign
values to variables during iteration.
Theforandaskeywords are synonyms; they can be used interchangeably. There are seven
syntactic formats for these constructs. In each syntactic format, the type ofvarcan be supplied by
the optional type-spec argument. If varis a destructuring list, the type supplied by the type-spec
argument must appropriately match the elements of the list. By convention, forintroduces new
iterations and asintroduces iterations that depend on a previous iteration specication.
6.1.2.1.1 The for-as-arithmetic subclause
In the for-as-arithmetic subclause, the fororasconstruct iterates from the value supplied by form1
to the value supplied by form2 in increments or decrements denoted by form3 . Each expression
is evaluated only once and must evaluate to a number . The variable varis bound to the value of
form1 in the rst iteration and is stepped 1by the value of form3 in each succeeding iteration, or
by 1 if form3 is not provided. The following loop keywords serve as valid prepositions within this
syntax. At least one of the prepositions must be used; and at most one from each line may be used
in a single subclause.
from | downfrom | upfrom
to | downto | upto | below | above
by
The prepositional phrases in each subclause may appear in any order. For example, either
\from x by y " or \by y from x " is permitted. However, because left-to-right order of evaluation is
preserved, the eects will be dierent in the case of side eects. Consider:
(let ((x 1)) (loop for i from x by (incf x) to 10 collect i))
!(1 3 5 7 9)
(let ((x 1)) (loop for i by (incf x) from x to 10 collect i))
!(2 4 6 8 10)
The descriptions of the prepositions follow:
from
The loop keyword from species the value from which stepping 1begins, as supplied by
form1 .Stepping 1is incremental by default. If decremental stepping 1is desired, the
preposition downto orabove must be used with form2 . For incremental stepping 1, the
defaultfrom value is 0.
Iteration 6–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
downfrom, upfrom
The loop keyword downfrom indicates that the variable varis decreased in decrements
supplied by form3 ; the loop keyword upfrom indicates that varis increased in increments
supplied by form3 .
to
The loop keyword tomarks the end value for stepping 1supplied in form2 .Stepping 1is
incremental by default. If decremental stepping 1is desired, the preposition downfrom must
be used with form1 , or else the preposition downto orabove should be used instead of to
with form2 .
downto, upto
The loop keyword downto species decremental stepping ; the loop keyword upto species
incremental stepping . In both cases, the amount of change on each step is specied by
form3 , and the loop terminates when the variable varpasses the value of form2 . Since
there is no default for form1 in decremental stepping 1, aform1 value must be supplied
(usingfrom ordownfrom ) whendownto is supplied.
below, above
The loop keywords below andabove are analogous to upto anddownto respectively. These
keywords stop iteration just before the value of the variable varreaches the value supplied
byform2 ; the end value of form2 is not included. Since there is no default for form1 in
decremental stepping 1, aform1 value must be supplied (using from ordownfrom ) when
above is supplied.
by
The loop keyword bymarks the increment or decrement supplied by form3 . The value of
form3 can be any positive number . The default value is 1.
In an iteration control clause, the fororasconstruct causes termination when the supplied limit
is reached. That is, iteration continues until the value varis stepped to the exclusive or inclusive
limit supplied by form2 . The range is exclusive if form3 increases or decreases varto the value of
form2 without reaching that value; the loop keywords below andabove provide exclusive limits. An
inclusive limit allows varto attain the value of form2 ;to,downto , andupto provide inclusive limits.
6.1.2.1.1.1 Examples of for-as-arithmetic subclause
;; Print some numbers.
(loop for i from 1 to 3
do (print i))
.1
.2
6–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.3
!NIL
;; Print every third number.
(loop for i from 10 downto 1 by 3
do (print i))
.10
.7
.4
.1
!NIL
;; Step incrementally from the default starting value.
(loop for i below 3
do (print i))
.0
.1
.2
!NIL
6.1.2.1.2 The for-as-in-list subclause
In the for-as-in-list subclause, the fororasconstruct iterates over the contents of a list. It checks
for the end of the listas if by using endp . The variable varis bound to the successive elements
of the listinform1 before each iteration. At the end of each iteration, the function step-fun is
applied to the list; the default value for step-fun iscdr. The loop keywords inandbyserve as valid
prepositions in this syntax. The fororasconstruct causes termination when the end of the listis
reached.
6.1.2.1.2.1 Examples of for-as-in-list subclause
;; Print every item in a list.
(loop for item in ’(1 2 3) do (print item))
.1
.2
.3
!NIL
;; Print every other item in a list.
(loop for item in ’(1 2 3 4 5) by #’cddr
do (print item))
.1
.3
.5
!NIL
Iteration 6–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;; Destructure a list, and sum the x values using fixnum arithmetic.
(loop for (item . x) of-type (t . fixnum) in ’((A . 1) (B . 2) (C . 3))
unless (eq item ’B) sum x)
!4
6.1.2.1.3 The for-as-on-list subclause
In the for-as-on-list subclause, the fororasconstruct iterates over a list. It checks for the end
of the listas if by using atom . The variable varis bound to the successive tails of the listin
form1 . At the end of each iteration, the function step-fun is applied to the list; the default value
forstep-fun iscdr. The loop keywords onandbyserve as valid prepositions in this syntax. The for
orasconstruct causes termination when the end of the listis reached.
6.1.2.1.3.1 Examples of for-as-on-list subclause
;; Collect successive tails of a list.
(loop for sublist on ’(a b c d)
collect sublist)
!((A B C D) (B C D) (C D) (D))
;; Print a list by using destructuring with the loop keyword ON.
(loop for (item) on ’(1 2 3)
do (print item))
.1
.2
.3
!NIL
6.1.2.1.4 The for-as-equals-then subclause
In the for-as-equals-then subclause the fororasconstruct initializes the variable varby setting it
to the result of evaluating form1 on the rst iteration, then setting it to the result of evaluating
form2 on the second and subsequent iterations. If form2 is omitted, the construct uses form1 on
the second and subsequent iterations. The loop keywords =andthen serve as valid prepositions in
this syntax. This construct does not provide any termination tests.
6.1.2.1.4.1 Examples of for-as-equals-then subclause
;; Collect some numbers.
(loop for item = 1 then (+ item 10)
for iteration from 1 to 5
collect item)
!(1 11 21 31 41)
6–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.2.1.5 The for-as-across subclause
In the for-as-across subclause the fororasconstruct binds the variable varto the value of each
element in the array vector . The loop keyword across marks the array vector ;across is used as a
preposition in this syntax. Iteration stops when there are no more elements in the supplied array
that can be referenced. Some implementations might recognize a thespecial form in the vector
form to produce more ecient code.
6.1.2.1.5.1 Examples of for-as-across subclause
(loop for char across (the simple-string (find-message channel))
do (write-char char stream))
6.1.2.1.6 The for-as-hash subclause
In the for-as-hash subclause the fororasconstruct iterates over the elements, keys, and values of
ahash-table . In this syntax, a compound preposition is used to designate access to a hash table .
The variable vartakes on the value of each hash key or hash value in the supplied hash-table . The
following loop keywords serve as valid prepositions within this syntax:
being
The keyword being introduces either the Loop schema hash-key orhash-value .
each,the
The loop keyword each follows the loop keyword being whenhash-key orhash-value is used.
The loop keyword theis used with hash-keys andhash-values only for ease of reading.
This agreement isn't required.
hash-key ,hash-keys
These loop keywords access each key entry of the hash table . If the name hash-value is
supplied in a using construct with one of these Loop schemas, the iteration can optionally
access the keyed value. The order in which the keys are accessed is undened; empty slots
in the hash table are ignored.
hash-value ,hash-values
These loop keywords access each value entry of a hash table . If the name hash-key is
supplied in a using construct with one of these Loop schemas, the iteration can optionally
access the key that corresponds to the value. The order in which the keys are accessed is
undened; empty slots in the hash table are ignored.
using
The loop keyword using introduces the optional key or the keyed value to be accessed. It
allows access to the hash key if iteration is over the hash values, and the hash value if
iteration is over the hash keys.
Iteration 6–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
in,of
These loop prepositions introduce hash-table .
In eect
beingfeachjthegfhash-valuejhash-valuesjhash-keyjhash-keysgfinjofg
is a compound preposition.
Iteration stops when there are no more hash keys or hash values to be referenced in the supplied
hash-table .
6.1.2.1.7 The for-as-package subclause
In the for-as-package subclause the fororasconstruct iterates over the symbols in a package . In
this syntax, a compound preposition is used to designate access to a package . The variable var
takes on the value of each symbol in the supplied package . The following loop keywords serve as
valid prepositions within this syntax:
being
The keyword being introduces either the Loop schema symbol ,present-symbol , or
external-symbol .
each,the
The loop keyword each follows the loop keyword being whensymbol ,present-symbol , or
external-symbol is used. The loop keyword theis used with symbols ,present-symbols , and
external-symbols only for ease of reading. This agreement isn't required.
present-symbol ,present-symbols
These Loop schemas iterate over the symbols that are present in a package . The package
to be iterated over is supplied in the same way that package arguments to ﬁnd-package
are supplied. If the package for the iteration is not supplied, the current package is used.
If a package that does not exist is supplied, an error of typepackage-error is signaled.
symbol ,symbols
These Loop schemas iterate over symbols that are accessible in a given package . The
package to be iterated over is supplied in the same way that package arguments to
ﬁnd-package are supplied. If the package for the iteration is not supplied, the current
package is used. If a package that does not exist is supplied, an error of typepackage-error
is signaled.
external-symbol ,external-symbols
These Loop schemas iterate over the external symbols of a package . The package to be
iterated over is supplied in the same way that package arguments to ﬁnd-package are
6–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
supplied. If the package for the iteration is not supplied, the current package is used. If a
package that does not exist is supplied, an error of typepackage-error is signaled.
in,of
These loop prepositions introduce package .
In eect
beingfeachjthegfsymboljsymbolsjpresent-symboljpresent-symbols jexternal-symbol j
external-symbols gfinjofg
is a compound preposition.
Iteration stops when there are no more symbols to be referenced in the supplied package .
6.1.2.1.7.1 Examples of for-as-package subclause
(let ((*package* (make-package "TEST-PACKAGE-1")))
;; For effect, intern some symbols
(read-from-string "(THIS IS A TEST)")
(export (intern "THIS"))
(loop for x being each present-symbol of *package*
do (print x)))
.A
.TEST
.THIS
.IS
!NIL
6.1.2.2 Local Variable Initializations
When aloop form is executed, the local variables are bound and are initialized to some value.
These local variables exist until loop iteration terminates, at which point they cease to exist.
Implicit variables are also established by iteration control clauses and the into preposition of
accumulation clauses.
Thewith construct initializes variables that are local to a loop. The variables are initialized one
time only. If the optional type-spec argument is supplied for the variable var, but there is no
related expression to be evaluated, varis initialized to an appropriate default value for its type.
For example, for the types t,number , andﬂoat, the default values are nil,0, and0.0respectively.
The consequences are undened if a type-spec argument is supplied for varif the related expression
returns a value that is not of the supplied type. By default, the with construct initializes variables
sequentially ; that is, one variable is assigned a value before the next expression is evaluated.
However, by using the loop keyword andto join several with clauses, initializations can be forced to
Iteration 6–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
occur in parallel ; that is, all of the supplied forms are evaluated, and the results are bound to the
respective variables simultaneously.
Sequential binding is used when it is desireable for the initialization of some variables to depend
on the values of previously bound variables. For example, suppose the variables a,b, andcare to
be bound in sequence:
(loop with a = 1
with b = (+ a 2)
with c = (+ b 3)
return (list a b c))
!(1 3 6)
The execution of the above loop is equivalent to the execution of the following code:
(block nil
(let* ((a 1)
(b (+ a 2))
(c (+ b 3)))
(tagbody
(next-loop (return (list a b c))
(go next-loop)
end-loop))))
If the values of previously bound variables are not needed for the initialization of other local
variables, an andclause can be used to specify that the bindings are to occur in parallel :
(loop with a = 1
and b = 2
and c = 3
return (list a b c))
!(1 2 3)
The execution of the above loop is equivalent to the execution of the following code:
(block nil
(let ((a 1)
(b 2)
(c 3))
(tagbody
(next-loop (return (list a b c))
(go next-loop)
end-loop))))
6.1.2.2.1 Examples of WITH clause
;; These bindings occur in sequence.
6–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(loop with a = 1
with b = (+ a 2)
with c = (+ b 3)
return (list a b c))
!(1 3 6)
;; These bindings occur in parallel.
(setq a 5 b 10)
!10
(loop with a = 1
and b = (+ a 2)
and c = (+ b 3)
return (list a b c))
!(1 7 13)
;; This example shows a shorthand way to declare local variables
;; that are of different types.
(loop with (a b c) of-type (float integer float)
return (format nil "~A ~A ~A" a b c))
!"0.0 0 0.0"
;; This example shows a shorthand way to declare local variables
;; that are the same type.
(loop with (a b c) of-type float
return (format nil "~A ~A ~A" a b c))
!"0.0 0.0 0.0"
6.1.3 Value Accumulation Clauses
The constructs collect ,collecting ,append ,appending ,nconc ,nconcing ,count ,counting ,maximize ,
maximizing ,minimize ,minimizing ,sum, andsumming , allow values to be accumulated in a loop.
The constructs collect ,collecting ,append ,appending ,nconc , andnconcing , designate clauses that
accumulate values in lists and return them. The constructs count ,counting ,maximize ,maximizing ,
minimize ,minimizing ,sum, andsumming designate clauses that accumulate and return numerical
values.
During each iteration, the constructs collect andcollecting collect the value of the supplied form
into a list. When iteration terminates, the listis returned. The argument varis set to the list
of collected values; if varis supplied, the loop does not return the nal listautomatically. If var
is not supplied, it is equivalent to supplying an internal name for varand returning its value in a
finally clause. The varargument is bound as if by the construct with. No mechanism is provided
for declaring the type ofvar; it must be of typelist.
The constructs append ,appending ,nconc , andnconcing are similar to collect except that the values
Iteration 6–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
of the supplied form must be lists.
Theappend keyword causes its listvalues to be concatenated into a single list, as if they
were arguments to the functionappend .
Thenconc keyword causes its listvalues to be concatenated into a single list, as if they
were arguments to the functionnconc .
The argument varis set to the listof concatenated values; if varis supplied, loop does not return
the nal listautomatically. The varargument is bound as if by the construct with. Atype cannot
be supplied for var; it must be of typelist. The construct nconc destructively modies its argument
lists.
Thecount construct counts the number of times that the supplied form returns true. The argument
varaccumulates the number of occurrences; if varis supplied, loop does not return the nal
count automatically. The varargument is bound as if by the construct with to a zero of the
appropriate type. Subsequent values (including any necessary coercions) are computed as if by
the function 1+. Ifinto varis used, a type can be supplied for varwith the type-spec argument;
the consequences are unspecied if a nonnumeric type is supplied. If there is no into variable, the
optional type-spec argument applies to the internal variable that is keeping the count. The default
type isimplementation-dependent ; but it must be a supertype oftypeﬁxnum .
Themaximize andminimize constructs compare the value of the supplied form obtained during
the rst iteration with values obtained in successive iterations. The maximum (for maximize ) or
minimum (for minimize ) value encountered is determined (as if by the function max formaximize
and as if by the functionminforminimize ) and returned. If the maximize orminimize clause is never
executed, the accumulated value is unspecied. The argument varaccumulates the maximum or
minimum value; if varis supplied, loop does not return the maximum or minimum automatically.
The varargument is bound as if by the construct with. Ifinto varis used, a type can be supplied for
varwith the type-spec argument; the consequences are unspecied if a nonnumeric type is supplied.
If there is no into variable, the optional type-spec argument applies to the internal variable that
is keeping the maximum or minimum value. The default type isimplementation-dependent ; but it
must be a supertype oftypereal.
Thesumconstruct forms a cumulative sum of the successive primary values of the supplied form at
each iteration. The argument varis used to accumulate the sum; if varis supplied, loop does not
return the nal sum automatically. The varargument is bound as if by the construct with to a zero
of the appropriate type. Subsequent values (including any necessary coercions) are computed as if
by the function+. Ifinto varis used, a type can be supplied for varwith the type-spec argument;
the consequences are unspecied if a nonnumeric type is supplied. If there is no into variable, the
optional type-spec argument applies to the internal variable that is keeping the sum. The default
type isimplementation-dependent ; but it must be a supertype oftypenumber .
Ifinto is used, the construct does not provide a default return value; however, the variable is
available for use in any finally clause.
Certain kinds of accumulation clauses can be combined in a loop if their destination is the
6–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
same (the result of loop or aninto var) because they are considered to accumulate conceptually
compatible quantities. In particular, any elements of following sets of accumulation clauses can be
mixed with other elements of the same set for the same destination in a loop form :
collect ,append ,nconc
sum,count
maximize ,minimize
;; Collect every name and the kids in one list by using
;; COLLECT and APPEND.
(loop for name in ’(fred sue alice joe june)
for kids in ’((bob ken) () () (kris sunshine) ())
collect name
append kids)
!(FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)
Any two clauses that do not accumulate the same type ofobject can coexist in a loop only if each
clause accumulates its values into a dierent variable .
6.1.3.1 Examples of COLLECT clause
;; Collect all the symbols in a list.
(loop for i in ’(bird 3 4 turtle (1 . 4) horse cat)
when (symbolp i) collect i)
!(BIRD TURTLE HORSE CAT)
;; Collect and return odd numbers.
(loop for i from 1 to 10
if (oddp i) collect i)
!(1 3 5 7 9)
;; Collect items into local variable, but don’t return them.
(loop for i in ’(a b c d) by #’cddr
collect i into my-list
finally (print my-list))
.(A C)
!NIL
Iteration 6–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.3.2 Examples of APPEND and NCONC clauses
;; Use APPEND to concatenate some sublists.
(loop for x in ’((a) (b) ((c)))
append x)
!(A B (C))
;; NCONC some sublists together. Note that only lists made by the
;; call to LIST are modified.
(loop for i upfrom 0
as x in ’(a b (c))
nconc (if (evenp i) (list x) nil))
!(A (C))
6.1.3.3 Examples of COUNT clause
(loop for i in ’(a b nil c nil d e)
count i)
!5
6.1.3.4 Examples of MAXIMIZE and MINIMIZE clauses
(loop for i in ’(2 1 5 3 4)
maximize i)
!5
(loop for i in ’(2 1 5 3 4)
minimize i)
!1
;; In this example, FIXNUM applies to the internal variable that holds
;; the maximum value.
(setq series ’(1.2 4.3 5.7))
!(1.2 4.3 5.7)
(loop for v in series
maximize (round v) of-type fixnum)
!6
;; In this example, FIXNUM applies to the variable RESULT.
(loop for v of-type float in series
minimize (round v) into result of-type fixnum
6–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
finally (return result))
!1
6.1.3.5 Examples of SUM clause
(loop for i of-type fixnum in ’(1 2 3 4 5)
sum i)
!15
(setq series ’(1.2 4.3 5.7))
!(1.2 4.3 5.7)
(loop for v in series
sum (* 2.0 v))
!22.4
6.1.4 Termination Test Clauses
Therepeat construct causes iteration to terminate after a specied number of times. The loop
body executes ntimes, where nis the value of the expression form. The form argument is evaluated
one time in the loop prologue. If the expression evaluates to 0 or to a negative number , the loop
body is not evaluated.
The constructs always ,never ,thereis ,while ,until , and the macro loop-ﬁnish allow conditional
termination of iteration within a loop.
The constructs always ,never , andthereis provide specic values to be returned when a loop
terminates. Using always ,never , orthereis in a loop with value accumulation clauses that are not
into causes an error of typeprogram-error to be signaled (at macro expansion time). Since always ,
never , andthereis use thereturn-from special operator to terminate iteration, any finally clause
that is supplied is not evaluated when exit occurs due to any of these constructs. In all other
respects these constructs behave like the while anduntil constructs.
Thealways construct takes one form and terminates the loop if the form ever evaluates to nil;
in this case, it returns nil. Otherwise, it provides a default return value of t. If the value of the
supplied form is nevernil, some other construct can terminate the iteration.
Thenever construct terminates iteration the rst time that the value of the supplied form is
non-nil ; theloop returnsnil. If the value of the supplied form is always nil, some other construct
can terminate the iteration. Unless some other clause contributes a return value, the default value
returned is t.
Thethereis construct terminates iteration the rst time that the value of the supplied form is
non-nil ; theloop returns the value of the supplied form. If the value of the supplied form is always
nil, some other construct can terminate the iteration. Unless some other clause contributes a
return value, the default value returned is nil.
Iteration 6–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
There are two dierences between the thereis anduntil constructs:
Theuntil construct does not return a value or nilbased on the value of the supplied form.
Theuntil construct executes any finally clause. Since thereis uses thereturn-from
special operator to terminate iteration, any finally clause that is supplied is not evaluated
when exit occurs due to thereis .
Thewhile construct allows iteration to continue until the supplied form evaluates to false. The
supplied form is reevaluated at the location of the while clause.
Theuntil construct is equivalent to while (not form):::. If the value of the supplied form is
non-nil , iteration terminates.
Termination-test control constructs can be used anywhere within the loop body. The termination
tests are used in the order in which they appear. If an until orwhile clause causes termination,
any clauses that precede it in the source are still evaluated. If the until andwhile constructs cause
termination, control is passed to the loop epilogue, where any finally clauses will be executed.
There are two dierences between the never anduntil constructs:
Theuntil construct does not return tornilbased on the value of the supplied form.
Theuntil construct does not bypass any finally clauses. Since never uses thereturn-from
special operator to terminate iteration, any finally clause that is supplied is not evaluated
when exit occurs due to never .
In most cases it is not necessary to use loop-ﬁnish because other loop control clauses terminate
theloop. The macro loop-ﬁnish is used to provide a normal exit from a nested conditional inside
aloop. Sinceloop-ﬁnish transfers control to the loop epilogue, using loop-ﬁnish within a finally
expression can cause innite looping.
6.1.4.1 Examples of REPEAT clause
(loop repeat 3
do (format t "~&What I say three times is true.~%"))
.What I say three times is true.
.What I say three times is true.
.What I say three times is true.
!NIL
(loop repeat -15
do (format t "What you see is what you expect~%"))
!NIL
6–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.4.2 Examples of ALWAYS, NEVER, and THEREIS clauses
;; Make sure I is always less than 11 (two ways).
;; The FOR construct terminates these loops.
(loop for i from 0 to 10
always (< i 11))
!T
(loop for i from 0 to 10
never (> i 11))
!T
;; If I exceeds 10 return I; otherwise, return NIL.
;; The THEREIS construct terminates this loop.
(loop for i from 0
thereis (when (> i 10) i) )
!11
;;; The FINALLY clause is not evaluated in these examples.
(loop for i from 0 to 10
always (< i 9)
finally (print "you won’t see this"))
!NIL
(loop never t
finally (print "you won’t see this"))
!NIL
(loop thereis "Here is my value"
finally (print "you won’t see this"))
!"Here is my value"
;; The FOR construct terminates this loop, so the FINALLY clause
;; is evaluated.
(loop for i from 1 to 10
thereis (> i 11)
finally (prin1 ’got-here))
.GOT-HERE
!NIL
;; If this code could be used to find a counterexample to Fermat’s
;; last theorem, it would still not return the value of the
;; counterexample because all of the THEREIS clauses in this example
;; only return T. But if Fermat is right, that won’t matter
;; because this won’t terminate.
(loop for z upfrom 2
Iteration 6–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
thereis
(loop for n upfrom 3 below (log z 2)
thereis
(loop for x below z
thereis
(loop for y below z
thereis (= (+ (expt x n) (expt y n))
(expt z n))))))
6.1.4.3 Examples of WHILE and UNTIL clauses
(loop while (hungry-p) do (eat))
;; UNTIL NOT is equivalent to WHILE.
(loop until (not (hungry-p)) do (eat))
;; Collect the length and the items of STACK.
(let ((stack ’(a b c d e f)))
(loop for item = (length stack) then (pop stack)
collect item
while stack))
!(6 A B C D E F)
;; Use WHILE to terminate a loop that otherwise wouldn’t terminate.
;; Note that WHILE occurs after the WHEN.
(loop for i fixnum from 3
when (oddp i) collect i
while (< i 5))
!(3 5)
6.1.5 Unconditional Execution Clauses
Thedoanddoing constructs evaluate the supplied forms wherever they occur in the expanded form
ofloop. The form argument can be any compound form . Each form is evaluated in every iteration.
Because every loop clause must begin with a loop keyword , the keyword dois used when no control
action other than execution is required.
Thereturn construct takes one form . Any values returned by the form are immediately returned by
theloop form. It is equivalent to the clause do (return-from block-name value ), where block-name
is the name specied in a named clause, or nilif there is no named clause.
6–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.5.1 Examples of unconditional execution
;; Print numbers and their squares.
;; The DO construct applies to multiple forms.
(loop for i from 1 to 3
do (print i)
(print (* i i)))
.1
.1
.2
.4
.3
.9
!NIL
6.1.6 Conditional Execution Clauses
Theif,when, andunless constructs establish conditional control in a loop. If the test passes, the
succeeding loop clause is executed. If the test does not pass, the succeeding clause is skipped, and
program control moves to the clause that follows the loop keyword else. If the test does not pass
and noelse clause is supplied, control is transferred to the clause or construct following the entire
conditional clause.
If conditional clauses are nested, each else is paired with the closest preceding conditional clause
that has no associated else orend.
In theifandwhen clauses, which are synonymous, the test passes if the value of form istrue.
In theunless clause, the test passes if the value of form isfalse.
Clauses that follow the test expression can be grouped by using the loop keyword andto produce a
conditional block consisting of a compound clause.
The loop keyword itcan be used to refer to the result of the test expression in a clause. Use the
loop keyword itin place of the form in a return clause or an accumulation clause that is inside a
conditional execution clause. If multiple clauses are connected with and, theitconstruct must be
in the rst clause in the block.
The optional loop keyword endmarks the end of the clause. If this keyword is not supplied, the
next loop keyword marks the end. The construct endcan be used to distinguish the scoping of
compound clauses.
Iteration 6–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.6.1 Examples of WHEN clause
;; Signal an exceptional condition.
(loop for item in ’(1 2 3 a 4 5)
when (not (numberp item))
return (cerror "enter new value" "non-numeric value: ~s" item))
Error: non-numeric value: A
;; The previous example is equivalent to the following one.
(loop for item in ’(1 2 3 a 4 5)
when (not (numberp item))
do (return
(cerror "Enter new value" "non-numeric value: ~s" item)))
Error: non-numeric value: A
;; This example parses a simple printed string representation from
;; BUFFER (which is itself a string) and returns the index of the
;; closing double-quote character.
(let ((buffer "\"a\" \"b\""))
(loop initially (unless (char= (char buffer 0) #\")
(loop-finish))
for i of-type fixnum from 1 below (length (the string buffer))
when (char= (char buffer i) #\")
return i))
!2
;; The collected value is returned.
(loop for i from 1 to 10
when (> i 5)
collect i
finally (prin1 ’got-here))
.GOT-HERE
!(6 7 8 9 10)
;; Return both the count of collected numbers and the numbers.
(loop for i from 1 to 10
when (> i 5)
collect i into number-list
and count i into number-count
finally (return (values number-count number-list)))
!5, (6 7 8 9 10)
6–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.7 Miscellaneous Clauses
6.1.7.1 Control Transfer Clauses
Thenamed construct establishes a name for an implicit block surrounding the entire loop so that
thereturn-from special operator can be used to return values from or to exit loop. Only one name
perloop form can be assigned. If used, the named construct must be the rst clause in the loop
expression.
Thereturn construct takes one form . Any values returned by the form are immediately returned
by theloop form. This construct is similar to the return-from special operator and thereturn
macro . Thereturn construct does not execute any finally clause that the loop form is given.
6.1.7.1.1 Examples of NAMED clause
;; Just name and return.
(loop named max
for i from 1 to 10
do (print i)
do (return-from max ’done))
.1
!DONE
6.1.7.2 Initial and Final Execution
Theinitially andfinally constructs evaluate forms that occur before and after the loop body.
Theinitially construct causes the supplied compound-forms to be evaluated in the loop prologue,
which precedes all loop code except for initial settings supplied by constructs with,for, oras. The
code for any initially clauses is executed in the order in which the clauses appeared in the loop.
Thefinally construct causes the supplied compound-forms to be evaluated in the loop epilogue
after normal iteration terminates. The code for any finally clauses is executed in the order in
which the clauses appeared in the loop. The collected code is executed once in the loop epilogue
before any implicit values are returned from the accumulation clauses. An explicit transfer of
control ( e.g., byreturn ,go, orthrow ) from the loop body, however, will exit the loop without
executing the epilogue code.
Clauses such as return ,always ,never , andthereis can bypass the finally clause.return (or
return-from , if thenamed option was supplied) can be used after finally to return values from
aloop. Such an explicit return inside the finally clause takes precedence over returning the
accumulation from clauses supplied by such keywords as collect ,nconc ,append ,sum,count ,
maximize , andminimize ; the accumulation values for these preempted clauses are not returned by
loop ifreturn orreturn-from is used.
Iteration 6–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6.1.8 Examples of Miscellaneous Loop Features
(let ((i 0)) ; no loop keywords are used
(loop (incf i) (if (= i 3) (return i)))) !3
(let ((i 0)(j 0))
(tagbody
(loop (incf j 3) (incf i) (if (= i 3) (go exit)))
exit)
j)!9
In the following example, the variable xis stepped before yis stepped; thus, the value of yreects
the updated value of x:
(loop for x from 1 to 10
for y = nil then x
collect (list x y))
!((1 NIL) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9) (10 10))
In this example, xandyare stepped in parallel :
(loop for x from 1 to 10
and y = nil then x
collect (list x y))
!((1 NIL) (2 1) (3 2) (4 3) (5 4) (6 5) (7 6) (8 7) (9 8) (10 9))
6.1.8.1 Examples of clause grouping
;; Group conditional clauses.
(loop for i in ’(1 324 2345 323 2 4 235 252)
when (oddp i)
do (print i)
and collect i into odd-numbers
and do (terpri)
else ; I is even.
collect i into even-numbers
finally
(return (values odd-numbers even-numbers)))
.1
.
.2345
.
.323
.
6–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.235
!(1 2345 323 235), (324 2 4 252)
;; Collect numbers larger than 3.
(loop for i in ’(1 2 3 4 5 6)
when (and (> i 3) i)
collect it) ; IT refers to (and (> i 3) i).
!(4 5 6)
;; Find a number in a list.
(loop for i in ’(1 2 3 4 5 6)
when (and (> i 3) i)
return it)
!4
;; The above example is similar to the following one.
(loop for i in ’(1 2 3 4 5 6)
thereis (and (> i 3) i))
!4
;; Nest conditional clauses.
(let ((list ’(0 3.0 apple 4 5 9.8 orange banana)))
(loop for i in list
when (numberp i)
when (floatp i)
collect i into float-numbers
else ; Not (floatp i)
collect i into other-numbers
else ; Not (numberp i)
when (symbolp i)
collect i into symbol-list
else ; Not (symbolp i)
do (error "found a funny value in list ~S, value ~S~%" list i)
finally (return (values float-numbers other-numbers symbol-list))))
!(3.0 9.8), (0 4 5), (APPLE ORANGE BANANA)
;; Without the END preposition, the last AND would apply to the
;; inner IF rather than the outer one.
(loop for x from 0 to 3
do (print x)
if (zerop (mod x 2))
do (princ " a")
and if (zerop (floor x 2))
Iteration 6–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
do (princ " b")
end
and do (princ " c"))
.0 a b c
.1
.2 a c
.3
!NIL
6.1.9 Notes about Loop
Types can be supplied for loop variables. It is not necessary to supply a type for any variable, but
supplying the type can ensure that the variable has a correctly typed initial value, and it can also
enable compiler optimizations (depending on the implementation ).
The clause repeat n... is roughly equivalent to a clause such as
(loop for internal-variable downfrom (- n1) to 0 ...)
but in some implementations , therepeat construct might be more ecient.
Within the executable parts of the loop clauses and around the entire loop form, variables can be
bound by using let.
Use caution when using a variable named IT(in any package ) in connection with loop, sinceitis
aloop keyword that can be used in place of a form in certain contexts.
There is no standardized mechanism for users to add extensions to loop.
6–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
do,do Macro
Syntax:
do(fvarj(var[init-form [step-form ]])g*)
(end-test-formfresult-formg*)
fdeclarationg*ftagjstatementg*
!f resultg*
do*(fvarj(var[init-form [step-form ]])g*)
(end-test-formfresult-formg*)
fdeclarationg*ftagjstatementg*
!f resultg*
Arguments and Values:
var|asymbol .
init-form |aform .
step-form |aform .
end-test-form |aform .
result-forms |an implicit progn .
declaration |adeclare expression ; not evaluated.
tag|ago tag ; not evaluated.
statement |acompound form ; evaluated as described below.
results |if areturn orreturn-from form is executed, the values passed from that form ; otherwise,
thevalues returned by the result-forms .
Description:
doiterates over a group of statements while a test condition holds. doaccepts an arbitrary number
of iteration varswhich are bound within the iteration and stepped in parallel. An initial value may
be supplied for each iteration variable by use of an init-form .Step-forms may be used to specify
how the varsshould be updated on succeeding iterations through the loop. Step-forms may be used
both to generate successive values or to accumulate results. If the end-test-form condition is met
prior to an execution of the body, the iteration terminates. Tags label statements .
do*is exactly like doexcept that the bindings and steppings of the varsare performed sequentially
rather than in parallel.
Iteration 6–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
do, do
Before the rst iteration, all the init-forms are evaluated, and each varis bound to the value of its
respective init-form , if supplied. This is a binding , not an assignment; when the loop terminates,
the old values of those variables will be restored. For do, all of the init-forms are evaluated before
any varis bound. The init-forms can refer to the bindings of the vars visible before beginning
execution of do. Fordo*, the rst init-form is evaluated, then the rst varis bound to that value,
then the second init-form is evaluated, then the second varis bound, and so on; in general, the kth
init-form can refer to the new binding of the jthvarifj<k, and otherwise to the old binding of the
jthvar.
At the beginning of each iteration, after processing the variables, the end-test-form is evaluated. If
the result is false, execution proceeds with the body of the do(ordo*) form. If the result is true,
theresult-forms are evaluated in order as an implicit progn , and then doordo*returns.
At the beginning of each iteration other than the rst, vars are updated as follows. All the
step-forms , if supplied, are evaluated, from left to right, and the resulting values are assigned to
the respective vars. Any varthat has no associated step-form is not assigned to. For do, all the
step-forms are evaluated before any varis updated; the assignment of values to vars is done in
parallel, as if by psetq . Because all of the step-forms are evaluated before any of the vars are
altered, a step-form when evaluated always has access to the old values of all the vars, even if other
step-forms precede it. For do*, the rst step-form is evaluated, then the value is assigned to the
rst var, then the second step-form is evaluated, then the value is assigned to the second var, and
so on; the assignment of values to variables is done sequentially, as if by setq. For either door
do*, after the varshave been updated, the end-test-form is evaluated as described above, and the
iteration continues.
The remainder of the do(ordo*) form constitutes an implicit tagbody .Tags may appear within
the body of a doloop for use by gostatements appearing in the body (but such gostatements
may not appear in the variable speciers, the end-test-form , or the result-forms ). When the end of
adobody is reached, the next iteration cycle (beginning with the evaluation of step-forms ) occurs.
Animplicit block namednilsurrounds the entire do(ordo*) form. A return statement may be
used at any point to exit the loop immediately.
Init-form is an initial value for the varwith which it is associated. If init-form is omitted, the initial
value of varisnil. If a declaration is supplied for a var,init-form must be consistent with the
declaration .
Declarations can appear at the beginning of a do(ordo*) body. They apply to code in the do(or
do*) body, to the bindings of thedo(ordo*)vars, to the step-forms , to the end-test-form , and to
theresult-forms .
Examples:
(do ((temp-one 1 (1+ temp-one))
(temp-two 0 (1- temp-two)))
((> (- temp-one temp-two) 5) temp-one)) !4
6–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
do, do
(do ((temp-one 1 (1+ temp-one))
(temp-two 0 (1+ temp-one)))
((= 3 temp-two) temp-one)) !3
(do* ((temp-one 1 (1+ temp-one))
(temp-two 0 (1+ temp-one)))
((= 3 temp-two) temp-one)) !2
(do ((j 0 (+ j 1)))
(nil) ;Do forever.
(format t "~%Input ~D:" j)
(let ((item (read)))
(if (null item) (return) ;Process items until NIL seen.
(format t "~&Output ~D: ~S" j item))))
.Input 0: banana
.Output 0: BANANA
.Input 1: (57 boxes)
.Output 1: (57 BOXES)
.Input 2: NIL
!NIL
(setq a-vector (vector 1 nil 3 nil))
(do ((i 0 (+ i 1)) ;Sets every null element of a-vector to zero.
(n (array-dimension a-vector 0)))
((= i n))
(when (null (aref a-vector i))
(setf (aref a-vector i) 0))) !NIL
a-vector!#(1 0 3 0)
(do ((x e (cdr x))
(oldx x x))
((null x))
body)
is an example of parallel assignment to index variables. On the rst iteration, the value of oldx is
whatever value xhad before the dowas entered. On succeeding iterations, oldx contains the value
thatxhad on the previous iteration.
(do ((x foo (cdr x))
(y bar (cdr y))
(z ’() (cons (f (car x) (car y)) z)))
((or (null x) (null y))
(nreverse z)))
does the same thing as (mapcar #’f foo bar) . The step computation for zis an example of the
fact that variables are stepped in parallel. Also, the body of the loop is empty.
Iteration 6–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
do, do
(defun list-reverse (list)
(do ((x list (cdr x))
(y ’() (cons (car x) y)))
((endp x) y)))
As an example of nested iterations, consider a data structure that is a listofconses . The car
of each cons is a listofsymbols , and the cdrof each cons is a listof equal length containing
corresponding values. Such a data structure is similar to an association list, but is divided into
\frames"; the overall structure resembles a rib-cage. A lookup function on such a data structure
might be:
(defun ribcage-lookup (sym ribcage)
(do ((r ribcage (cdr r)))
((null r) nil)
(do ((s (caar r) (cdr s))
(v (cdar r) (cdr v)))
((null s))
(when (eq (car s) sym)
(return-from ribcage-lookup (car v)))))) !RIBCAGE-LOOKUP
See Also:
other iteration functions ( dolist ,dotimes , andloop) and more primitive functionality ( tagbody ,
go,block ,return ,let, andsetq)
Notes:
Ifend-test-form isnil, the test will never succeed. This provides an idiom for \do forever": the
body of the doordo*is executed repeatedly. The innite loop can be terminated by the use of
return ,return-from ,goto an outer level, or throw .
Adoform may be explained in terms of the more primitive formsblock ,return ,let,loop,
tagbody , andpsetq as follows:
(block nil
(let ((var1 init1)
(var2 init2)
...
(varn initn))
declarations
(loop (when end-test (return (progn . result)))
(tagbody . tagbody)
(psetq var1 step1
var2 step2
...
varn stepn))))
do*is similar, except that let*andsetq replace the letandpsetq , respectively.
6–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
dotimes Macro
Syntax:
dotimes (var count-form [result-form ])fdeclarationg*ftagjstatementg*
!f resultg*
Arguments and Values:
var|asymbol .
count-form |aform .
result-form |aform .
declaration |adeclare expression ; not evaluated.
tag|ago tag ; not evaluated.
statement |acompound form ; evaluated as described below.
results |if areturn orreturn-from form is executed, the values passed from that form ; otherwise,
thevalues returned by the result-form ornilif there is no result-form .
Description:
dotimes iterates over a series of integers .
dotimes evaluates count-form , which should produce an integer . Ifcount-form is zero or negative,
the body is not executed. dotimes then executes the body once for each integer from 0 up to but
not including the value of count-form , in the order in which the tags and statements occur, with var
bound to each integer . Then result-form is evaluated. At the time result-form is processed, varis
bound to the number of times the body was executed. Tags label statements .
Animplicit block namednilsurrounds dotimes .return may be used to terminate the loop
immediately without performing any further iterations, returning zero or more values .
The body of the loop is an implicit tagbody ; it may contain tags to serve as the targets of go
statements. Declarations may appear before the body of the loop.
The scope of the binding of vardoes not include the count-form , but the result-form is included.
It is implementation-dependent whetherdotimes establishes a new binding ofvaron each iteration
or whether it establishes a binding for varonce at the beginning and then assigns it on any
subsequent iterations.
Iteration 6–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(dotimes (temp-one 10 temp-one)) !10
(setq temp-two 0) !0
(dotimes (temp-one 10 t) (incf temp-two)) !T
temp-two!10
Here is an example of the use of dotimes in processing strings:
;;; True if the specified subsequence of the string is a
;;; palindrome (reads the same forwards and backwards).
(defun palindromep (string &optional
(start 0)
(end (length string)))
(dotimes (k (floor (- end start) 2) t)
(unless (char-equal (char string (+ start k))
(char string (- end k 1)))
(return nil))))
(palindromep "Able was I ere I saw Elba") !T
(palindromep "A man, a plan, a canal–Panama!") !NIL
(remove-if-not #’alpha-char-p ;Remove punctuation.
"A man, a plan, a canal–Panama!")
!"AmanaplanacanalPanama"
(palindromep
(remove-if-not #’alpha-char-p
"A man, a plan, a canal–Panama!")) !T
(palindromep
(remove-if-not
#’alpha-char-p
"Unremarkable was I ere I saw Elba Kramer, nu?")) !T
(palindromep
(remove-if-not
#’alpha-char-p
"A man, a plan, a cat, a ham, a yak,
a yam, a hat, a canal–Panama!")) !T
See Also:
do,dolist ,tagbody
Notes:
gomay be used within the body of dotimes to transfer control to a statement labeled by a tag.
6–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
dolist
dolist Macro
Syntax:
dolist (var list-form [result-form ])fdeclarationg*ftagjstatementg*
!f resultg*
Arguments and Values:
var|asymbol .
list-form |aform .
result-form |aform .
declaration |adeclare expression ; not evaluated.
tag|ago tag ; not evaluated.
statement |acompound form ; evaluated as described below.
results |if areturn orreturn-from form is executed, the values passed from that form ; otherwise,
thevalues returned by the result-form ornilif there is no result-form .
Description:
dolist iterates over the elements of a list. The body of dolist is like atagbody . It consists of a
series of tags and statements .
dolist evaluates list-form , which should produce a list. It then executes the body once for each
element in the list, in the order in which the tags and statements occur, with varbound to the
element. Then result-form is evaluated. tags label statements .
At the time result-form is processed, varis bound to nil.
Animplicit block namednilsurrounds dolist .return may be used to terminate the loop
immediately without performing any further iterations, returning zero or more values .
The scope of the binding of vardoes not include the list-form , but the result-form is included.
It is implementation-dependent whetherdolist establishes a new binding ofvaron each iteration or
whether it establishes a binding for varonce at the beginning and then assigns it on any subsequent
iterations.
Examples:
(setq temp-two ’()) !NIL
(dolist (temp-one ’(1 2 3 4) temp-two) (push temp-one temp-two)) !(4 3 2 1)
(setq temp-two 0) !0
Iteration 6–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(dolist (temp-one ’(1 2 3 4)) (incf temp-two)) !NIL
temp-two!4
(dolist (x ’(a b c d)) (prin1 x) (princ " "))
.A B C D
!NIL
See Also:
do,dotimes ,tagbody , Section 3.6 (Traversal Rules and Side Eects)
Notes:
gomay be used within the body of dolist to transfer control to a statement labeled by a tag.
loop Macro
Syntax:
The \simple" loop form :
loopfcompound-formg*!f resultg*
The \extended" loop form :
loop [#name-clause ]f#variable-clauseg*f#main-clauseg*!f resultg*
name-clause:: =named name
variable-clause:: =#with-clausej#initial-nalj#for-as-clause
with-clause:: =with var1 [type-spec ] [=form1 ]fandvar2 [type-spec ] [=form2 ]g*
main-clause:: =#unconditionalj#accumulationj#conditionalj#termination-testj#initial-nal
initial-nal:: =initiallyfcompound-formg+jfinallyfcompound-formg+
unconditional:: =fdojdoinggfcompound-formg+jreturnfformjitg
accumulation:: =#list-accumulationj#numeric-accumulation
list-accumulation:: =fcollectjcollectingjappendjappendingjnconcjnconcinggfformjitg
[into simple-var ]
6–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
loop
numeric-accumulation:: =fcountjcountingjsumjsummingj
maximizejmaximizingjminimizejminimizinggfformjitg
[into simple-var ] [type-spec ]
conditional:: =fifjwhenjunlessgform#selectable-clausefand#selectable-clauseg*
[else#selectable-clausefand#selectable-clauseg*]
[end]
selectable-clause:: =#unconditionalj#accumulationj#conditional
termination-test:: =while formjuntil formjrepeat formjalways formjnever formjthereis form
for-as-clause:: =fforjasg#for-as-subclausefand#for-as-subclauseg*
for-as-subclause:: =#for-as-arithmeticj#for-as-in-listj#for-as-on-listj#for-as-equals-then j
#for-as-acrossj#for-as-hashj#for-as-package
for-as-arithmetic:: =var[type-spec ]#for-as-arithmetic-subclause
for-as-arithmetic-subclause:: =#arithmetic-upj#arithmetic-downto j#arithmetic-downfrom
arithmetic-up:: =[ [ffromjupfromgform1j ftojuptojbelowgform2jbyform3 ] ]+
arithmetic-downto:: =[ [ffrom form1g1j ffdowntojabovegform2g1jbyform3 ] ]
arithmetic-downfrom:: =[ [fdownfrom form1g1j ftojdowntojabovegform2jbyform3 ] ]
for-as-in-list:: =var[type-spec ]inform1 [bystep-fun ]
for-as-on-list:: =var[type-spec ]onform1 [bystep-fun ]
for-as-equals-then:: =var[type-spec ]=form1 [then form2 ]
for-as-across:: =var[type-spec ]across vector
for-as-hash:: =var[type-spec ]beingfeachjtheg
ffhash-keyjhash-keysgfinjofghash-table
[using (hash-value other-var )]j
fhash-valuejhash-valuesgfinjofghash-table
[using (hash-key other-var )]g
Iteration 6–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
loop
for-as-package:: =var[type-spec ]beingfeachjtheg
fsymboljsymbolsj
present-symboljpresent-symbolsj
external-symboljexternal-symbols g
[finjofgpackage ]
type-spec:: =#simple-type-specj#destructured-type-spec
simple-type-spec:: =ﬁxnumjﬂoatjtjnil
destructured-type-spec:: =of-type d-type-spec
d-type-spec:: =type-specierj(d-type-spec .d-type-spec )
var::=#d-var-spec
var1:: =#d-var-spec
var2:: =#d-var-spec
other-var:: =#d-var-spec
d-var-spec:: =simple-varjnilj(#d-var-spec .#d-var-spec )
Arguments and Values:
compound-form |acompound form .
name |asymbol .
simple-var |asymbol (avariable name).
form,form1 ,form2 ,form3 |aform .
step-fun |aform that evaluates to a function of one argument .
vector |aform that evaluates to a vector .
hash-table |aform that evaluates to a hash table .
package |aform that evaluates to a package designator .
type-specier |a type specier . This might be either an atomic type specier or a compound
type specier , which introduces some additional complications to proper parsing in the face of
destructuring; for further information, see Section 6.1.1.7 (Destructuring).
result |an object .
6–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
loop
Description:
For details, see Section 6.1 (The LOOP Facility).
Examples:
;; An example of the simple form of LOOP.
(defun sqrt-advisor ()
(loop (format t "~&Number: ")
(let ((n (parse-integer (read-line) :junk-allowed t)))
(when (not n) (return))
(format t "~&The square root of ~D is ~D.~%" n (sqrt n)))))
!SQRT-ADVISOR
(sqrt-advisor)
.Number: 5 -
.The square root of 5 is 2.236068.
.Number: 4 -
.The square root of 4 is 2.
.Number: done -
!NIL
;; An example of the extended form of LOOP.
(defun square-advisor ()
(loop as n = (progn (format t "~&Number: ")
(parse-integer (read-line) :junk-allowed t))
while n
do (format t "~&The square of ~D is ~D.~%" n (* n n))))
!SQUARE-ADVISOR
(square-advisor)
.Number: 4 -
.The square of 4 is 16.
.Number: 23 -
.The square of 23 is 529.
.Number: done -
!NIL
;; Another example of the extended form of LOOP.
(loop for n from 1 to 10
when (oddp n)
collect n)
!(1 3 5 7 9)
See Also:
do,dolist ,dotimes ,return ,go,throw , Section 6.1.1.7 (Destructuring)
Iteration 6–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
Except that loop-ﬁnish cannot be used within a simple loop form , a simple loop form is related
to an extended loop form in the following way:
(loopfcompound-formg*)(loop dofcompound-formg*)
loop-ﬁnish Local Macro
Syntax:
loop-ﬁnishhno argumentsi !
Description:
Theloop-ﬁnish macro can be used lexically within an extended loop form to terminate that
form \normally." That is, it transfers control to the loop epilogue of the lexically innermost
extended loop form . This permits execution of any ﬁnally clause (for eect) and the return of any
accumulated result.
Examples:
;; Terminate the loop, but return the accumulated count.
(loop for i in ’(1 2 3 stop-here 4 5 6)
when (symbolp i) do (loop-finish)
count i)
!3
;; The preceding loop is equivalent to:
(loop for i in ’(1 2 3 stop-here 4 5 6)
until (symbolp i)
count i)
!3
;; While LOOP-FINISH can be used can be used in a variety of
;; situations it is really most needed in a situation where a need
;; to exit is detected at other than the loop’s ‘top level’
;; (where UNTIL or WHEN often work just as well), or where some
;; computation must occur between the point where a need to exit is
;; detected and the point where the exit actually occurs. For example:
(defun tokenize-sentence (string)
(macrolet ((add-word (wvar svar)
‘(when ,wvar
(push (coerce (nreverse ,wvar) ’string) ,svar)
(setq ,wvar nil))))
6–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
loop-ﬁnish
(loop with word = ’() and sentence = ’() and endpos = nil
for i below (length string)
do (let ((char (aref string i)))
(case char
(#\Space (add-word word sentence))
(#\. (setq endpos (1+ i)) (loop-finish))
(otherwise (push char word))))
finally (add-word word sentence)
(return (values (nreverse sentence) endpos)))))
!TOKENIZE-SENTENCE
(tokenize-sentence "this is a sentence. this is another sentence.")
!("this" "is" "a" "sentence"), 19
(tokenize-sentence "this is a sentence")
!("this" "is" "a" "sentence"), NIL
Side Eﬀects:
Transfers control.
Exceptional Situations:
Whether or not loop-ﬁnish isfbound in the global environment isimplementation-dependent ;
however, the restrictions on redenition and shadowing ofloop-ﬁnish are the same as for symbols
in theCOMMON-LISP package which are fbound in the global environment . The consequences of
attempting to use loop-ﬁnish outside of loop are undened.
See Also:
loop, Section 6.1 (The LOOP Facility)
Notes:
Iteration 6–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
6–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
7. Objects
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Objects iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.1 Object Creation and Initialization
The generic function make-instance creates and returns a new instance of a class . The rst
argument is a class or the name of a class , and the remaining arguments form an initialization
argument list .
The initialization of a new instance consists of several distinct steps, including the following:
combining the explicitly supplied initialization arguments with default values for the unsupplied
initialization arguments, checking the validity of the initialization arguments, allocating storage for
theinstance , lling slots with values, and executing user-supplied methods that perform additional
initialization. Each step of make-instance is implemented by a generic function to provide a
mechanism for customizing that step. In addition, make-instance is itself a generic function and
thus also can be customized.
The object system species system-supplied primary methods for each step and thus species a
well-dened standard behavior for the entire initialization process. The standard behavior provides
four simple mechanisms for controlling initialization:
Declaring a symbol to be an initialization argument for a slot. An initialization argument
is declared by using the :initarg slot option to defclass . This provides a mechanism for
supplying a value for a slotin a call to make-instance .
Supplying a default value form for an initialization argument. Default value forms for
initialization arguments are dened by using the :default-initargs class option to defclass .
If an initialization argument is not explicitly provided as an argument to make-instance ,
the default value form is evaluated in the lexical environment of the defclass form that
dened it, and the resulting value is used as the value of the initialization argument.
Supplying a default initial value form for a slot. A default initial value form for a slot
is dened by using the :initform slot option to defclass . If no initialization argument
associated with that slotis given as an argument to make-instance or is defaulted by
:default-initargs , this default initial value form is evaluated in the lexical environment
of thedefclass form that dened it, and the resulting value is stored in the slot. The
:initform form for a local slot may be used when creating an instance , when updating
aninstance to conform to a redened class , or when updating an instance to conform to
the denition of a dierent class . The:initform form for a shared slot may be used when
dening or re-dening the class .
Dening methods forinitialize-instance andshared-initialize . The slot-lling behavior
described above is implemented by a system-supplied primary method forinitialize-instance
which invokes shared-initialize . The generic function shared-initialize implements the
parts of initialization shared by these four situations: when making an instance , when
re-initializing an instance , when updating an instance to conform to a redened class ,
and when updating an instance to conform to the denition of a dierent class . The
system-supplied primary method forshared-initialize directly implements the slot-lling
behavior described above, and initialize-instance simply invokes shared-initialize .
Objects 7–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.1.1 Initialization Arguments
An initialization argument controls object creation and initialization. It is often convenient to use
keyword symbols to name initialization arguments, but the name of an initialization argument can
be any symbol , including nil. An initialization argument can be used in two ways: to ll a slotwith
a value or to provide an argument for an initialization method . A single initialization argument
can be used for both purposes.
Aninitialization argument list is aproperty list of initialization argument names and values. Its
structure is identical to a property list and also to the portion of an argument list processed for
&key parameters. As in those lists, if an initialization argument name appears more than once
in an initialization argument list, the leftmost occurrence supplies the value and the remaining
occurrences are ignored. The arguments to make-instance (after the rst argument) form an
initialization argument list .
An initialization argument can be associated with a slot. If the initialization argument has a
value in the initialization argument list , the value is stored into the slotof the newly created
object , overriding any :initform form associated with the slot. A single initialization argument
can initialize more than one slot. An initialization argument that initializes a shared slot stores its
value into the shared slot , replacing any previous value.
An initialization argument can be associated with a method . When an object is created
and a particular initialization argument is supplied, the generic functions initialize-instance ,
shared-initialize , andallocate-instance are called with that initialization argument's name and
value as a keyword argument pair. If a value for the initialization argument is not supplied in the
initialization argument list , the method 'slambda list supplies a default value.
Initialization arguments are used in four situations: when making an instance , when re-initializing
aninstance , when updating an instance to conform to a redened class , and when updating an
instance to conform to the denition of a dierent class .
Because initialization arguments are used to control the creation and initialization of an instance
of some particular class , we say that an initialization argument is \an initialization argument for"
that class .
7.1.2 Declaring the Validity of Initialization Arguments
Initialization arguments are checked for validity in each of the four situations that use them.
An initialization argument may be valid in one situation and not another. For example, the
system-supplied primary method formake-instance dened for the classstandard-class checks the
validity of its initialization arguments and signals an error if an initialization argument is supplied
that is not declared as valid in that situation.
There are two means for declaring initialization arguments valid.
Initialization arguments that ll slots are declared as valid by the :initarg slot option to
defclass . The:initarg slot option is inherited from superclasses . Thus the set of valid
7–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
initialization arguments that ll slots for a class is the union of the initialization arguments
that ll slots declared as valid by that class and its superclasses . Initialization arguments
that ll slots are valid in all four contexts.
Initialization arguments that supply arguments to methods are declared as valid by dening
those methods . The keyword name of each keyword parameter specied in the method 's
lambda list becomes an initialization argument for all classes for which the method is
applicable. The presence of &allow-other-keys in the lambda list of an applicable method
disables validity checking of initialization arguments. Thus method inheritance controls
the set of valid initialization arguments that supply arguments to methods . The generic
functions for which method denitions serve to declare initialization arguments valid are
as follows:
{ Making an instance of a class :allocate-instance ,initialize-instance , and
shared-initialize . Initialization arguments declared as valid by these methods are
valid when making an instance of a class .
{ Re-initializing an instance :reinitialize-instance andshared-initialize . Initializa-
tion arguments declared as valid by these methods are valid when re-initializing an
instance .
{ Updating an instance to conform to a redened class :
update-instance-for-redeﬁned-class andshared-initialize . Initialization ar-
guments declared as valid by these methods are valid when updating an instance
to conform to a redened class .
{ Updating an instance to conform to the denition of a dierent class :
update-instance-for-diﬀerent-class andshared-initialize . Initialization
arguments declared as valid by these methods are valid when updating an instance
to conform to the denition of a dierent class .
The set of valid initialization arguments for a class is the set of valid initialization arguments
that either ll slots or supply arguments to methods , along with the predened initialization
argument :allow-other-keys . The default value for :allow-other-keys isnil. Validity checking of
initialization arguments is disabled if the value of the initialization argument :allow-other-keys is
true.
7.1.3 Defaulting of Initialization Arguments
A default value form can be supplied for an initialization argument by using the :default-initargs
class option. If an initialization argument is declared valid by some particular class , its default
value form might be specied by a dierent class . In this case :default-initargs is used to supply
a default value for an inherited initialization argument.
Objects 7–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The:default-initargs option is used only to provide default values for initialization arguments;
it does not declare a symbol as a valid initialization argument name. Furthermore, the
:default-initargs option is used only to provide default values for initialization arguments when
making an instance .
The argument to the :default-initargs class option is a list of alternating initialization argument
names and forms . Each form is the default value form for the corresponding initialization
argument. The default value form of an initialization argument is used and evaluated only if that
initialization argument does not appear in the arguments to make-instance and is not defaulted
by a more specic class . The default value form is evaluated in the lexical environment of the
defclass form that supplied it; the resulting value is used as the initialization argument's value.
The initialization arguments supplied to make-instance are combined with defaulted initialization
arguments to produce a defaulted initialization argument list . Adefaulted initialization argument
listis a list of alternating initialization argument names and values in which unsupplied initialization
arguments are defaulted and in which the explicitly supplied initialization arguments appear earlier
in the list than the defaulted initialization arguments. Defaulted initialization arguments are
ordered according to the order in the class precedence list of the classes that supplied the default
values.
There is a distinction between the purposes of the :default-initargs and the :initform options
with respect to the initialization of slots. The:default-initargs class option provides a mechanism
for the user to give a default value form for an initialization argument without knowing whether
the initialization argument initializes a slotor is passed to a method . If that initialization argument
is not explicitly supplied in a call to make-instance , the default value form is used, just as if it had
been supplied in the call. In contrast, the :initform slot option provides a mechanism for the user
to give a default initial value form for a slot. An:initform form is used to initialize a slotonly if
no initialization argument associated with that slotis given as an argument to make-instance or
is defaulted by :default-initargs .
The order of evaluation of default value forms for initialization arguments and the order of evaluation
of:initform forms are undened. If the order of evaluation is important, initialize-instance or
shared-initialize methods should be used instead.
7.1.4 Rules for Initialization Arguments
The:initarg slot option may be specied more than once for a given slot.
The following rules specify when initialization arguments may be multiply dened:
A given initialization argument can be used to initialize more than one slotif the same
initialization argument name appears in more than one :initarg slot option.
A given initialization argument name can appear in the lambda list of more than one
initialization method .
7–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
A given initialization argument name can appear both in an :initarg slot option and in
thelambda list of an initialization method .
If two or more initialization arguments that initialize the same slotare given in the arguments to
make-instance , the leftmost of these initialization arguments in the initialization argument list
supplies the value, even if the initialization arguments have dierent names.
If two or more dierent initialization arguments that initialize the same slothave default values
and none is given explicitly in the arguments to make-instance , the initialization argument that
appears in a :default-initargs class option in the most specic of the classes supplies the value. If
a single :default-initargs class option species two or more initialization arguments that initialize
the same slotand none is given explicitly in the arguments to make-instance , the leftmost in the
:default-initargs class option supplies the value, and the values of the remaining default value
forms are ignored.
Initialization arguments given explicitly in the arguments to make-instance appear to the left
of defaulted initialization arguments. Suppose that the classes C1andC2supply the values of
defaulted initialization arguments for dierent slots, and suppose that C1is more specic than
C2; then the defaulted initialization argument whose value is supplied by C1is to the left of
the defaulted initialization argument whose value is supplied by C2in the defaulted initialization
argument list . If a single :default-initargs class option supplies the values of initialization
arguments for two dierent slots, the initialization argument whose value is specied farther to the
left in the :default-initargs class option appears farther to the left in the defaulted initialization
argument list .
If aslothas both an :initform form and an :initarg slot option, and the initialization argument is
defaulted using :default-initargs or is supplied to make-instance , the captured :initform form
is neither used nor evaluated.
The following is an example of the above rules:
(defclass q () ((x :initarg a)))
(defclass r (q) ((x :initarg b))
(:default-initargs a 1 b 2))
Defaulted
Form Initialization Argument List Contents of Slot X
(make-instance ’r) (a 1 b 2) 1
(make-instance ’r ’a 3) (a 3 b 2) 3
(make-instance ’r ’b 4) (b 4 a 1) 4
(make-instance ’r ’a 1 ’a 2) (a 1 a 2 b 2) 1
Objects 7–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.1.5 Shared-Initialize
The generic function shared-initialize is used to ll the slots of an instance using initialization
arguments and :initform forms when an instance is created, when an instance is re-initialized,
when an instance is updated to conform to a redened class , and when an instance is updated
to conform to a dierent class . It uses standard method combination. It takes the following
arguments: the instance to be initialized, a specication of a set of names ofslots accessible in
that instance , and any number of initialization arguments. The arguments after the rst two must
form an initialization argument list .
The second argument to shared-initialize may be one of the following:
It can be a (possibly empty) listofslotnames, which species the set of those slotnames.
It can be the symbol t, which species the set of all of the slots.
There is a system-supplied primary method forshared-initialize whose rst parameter specializer
is the classstandard-object . This method behaves as follows on each slot, whether shared or local:
If an initialization argument in the initialization argument list species a value for that
slot, that value is stored into the slot, even if a value has already been stored in the slot
before the method is run. The aected slots are independent of which slots are indicated
by the second argument to shared-initialize .
Any slots indicated by the second argument that are still unbound at this point are
initialized according to their :initform forms. For any such slotthat has an :initform
form, that form is evaluated in the lexical environment of its dening defclass form and
the result is stored into the slot. For example, if a before method stores a value in the slot,
the:initform form will not be used to supply a value for the slot. If the second argument
species a name that does not correspond to any slots accessible in the instance , the
results are unspecied.
The rules mentioned in Section 7.1.4 (Rules for Initialization Arguments) are obeyed.
The generic function shared-initialize is called by the system-supplied primary methods for
reinitialize-instance ,update-instance-for-diﬀerent-class ,update-instance-for-redeﬁned-class ,
andinitialize-instance . Thus, methods can be written for shared-initialize to specify actions that
should be taken in all of these contexts.
7.1.6 Initialize-Instance
The generic function initialize-instance is called by make-instance to initialize a newly created
instance . It uses standard method combination .Methods forinitialize-instance can be dened in
order to perform any initialization that cannot be achieved simply by supplying initial values for
slots.
During initialization, initialize-instance is invoked after the following actions have been taken:
7–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The defaulted initialization argument list has been computed by combining the supplied
initialization argument list with any default initialization arguments for the class .
The validity of the defaulted initialization argument list has been checked. If any of the
initialization arguments has not been declared as valid, an error is signaled.
A new instance whose slots are unbound has been created.
The generic function initialize-instance is called with the new instance and the defaulted
initialization arguments. There is a system-supplied primary method forinitialize-instance
whose parameter specializer is the classstandard-object . This method calls the generic function
shared-initialize to ll in the slots according to the initialization arguments and the :initform
forms for the slots; the generic function shared-initialize is called with the following arguments:
theinstance ,t, and the defaulted initialization arguments.
Note that initialize-instance provides the defaulted initialization argument list in its call to
shared-initialize , so the rst step performed by the system-supplied primary method for
shared-initialize takes into account both the initialization arguments provided in the call to
make-instance and the defaulted initialization argument list .
Methods forinitialize-instance can be dened to specify actions to be taken when an instance
is initialized. If only after methods forinitialize-instance are dened, they will be run after the
system-supplied primary method for initialization and therefore will not interfere with the default
behavior of initialize-instance .
The object system provides two functions that are useful in the bodies of initialize-instance
methods. The function slot-boundp returns a generic boolean value that indicates whether a
specied slothas a value; this provides a mechanism for writing after methods forinitialize-instance
that initialize slots only if they have not already been initialized. The functionslot-makunbound
causes the slotto have no value.
7.1.7 Deﬁnitions of Make-Instance and Initialize-Instance
The generic function make-instance behaves as if it were dened as follows, except that certain
optimizations are permitted:
(defmethod make-instance ((class standard-class) &rest initargs)
...
(let ((instance (apply #’allocate-instance class initargs)))
(apply #’initialize-instance instance initargs)
instance))
(defmethod make-instance ((class-name symbol) &rest initargs)
(apply #’make-instance (find-class class-name) initargs))
The elided code in the denition of make-instance augments the initargs with any defaulted
initialization arguments and checks the resulting initialization arguments to determine whether
Objects 7–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
an initialization argument was supplied that neither lled a slotnor supplied an argument to an
applicable method .
The generic function initialize-instance behaves as if it were dened as follows, except that certain
optimizations are permitted:
(defmethod initialize-instance ((instance standard-object) &rest initargs)
(apply #’shared-initialize instance t initargs)))
These procedures can be customized.
Customizing at the Programmer Interface level includes using the :initform ,:initarg ,
and:default-initargs options to defclass , as well as dening methods formake-instance ,
allocate-instance , andinitialize-instance . It is also possible to dene methods for
shared-initialize , which would be invoked by the generic functions reinitialize-instance ,
update-instance-for-redeﬁned-class ,update-instance-for-diﬀerent-class , andinitialize-instance .
The meta-object level supports additional customization.
Implementations are permitted to make certain optimizations to initialize-instance and
shared-initialize . The description of shared-initialize in Chapter 7 mentions the possible
optimizations.
7–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.2 Changing the Class of an Instance
The function change-class can be used to change the class of an instance from its current class,
Cfrom, to a dierent class, Cto; it changes the structure of the instance to conform to the denition
of the class Cto.
Note that changing the class of an instance may cause slots to be added or deleted. Changing the
class of an instance does not change its identity as dened by the eqfunction.
Whenchange-class is invoked on an instance , a two-step updating process takes place. The rst
step modies the structure of the instance by adding new local slots and discarding local slots that
are not specied in the new version of the instance . The second step initializes the newly added
local slots and performs any other user-dened actions. These two steps are further described in
the two following sections.
7.2.1 Modifying the Structure of the Instance
In order to make the instance conform to the class Cto,local slots specied by the class Ctothat
are not specied by the class Cfromare added, and local slots not specied by the class Ctothat are
specied by the class Cfromare discarded.
The values of local slots specied by both the class Ctoand the class Cfromare retained. If such a
local slot was unbound, it remains unbound.
The values of slots specied as shared in the class Cfromand as local in the class Ctoare retained.
This rst step of the update does not aect the values of any shared slots .
7.2.2 Initializing Newly Added Local Slots
The second step of the update initializes the newly added slots and performs any other user-dened
actions. This step is implemented by the generic function update-instance-for-diﬀerent-class .
The generic function update-instance-for-diﬀerent-class is invoked by change-class after the rst
step of the update has been completed.
The generic function update-instance-for-diﬀerent-class is invoked on arguments computed by
change-class . The rst argument passed is a copy of the instance being updated and is an instance
of the class Cfrom; this copy has dynamic extent within the generic function change-class . The
second argument is the instance as updated so far by change-class and is an instance of the class
Cto. The remaining arguments are an initialization argument list .
There is a system-supplied primary method forupdate-instance-for-diﬀerent-class that has two
parameter specializers, each of which is the classstandard-object . First this method checks the
validity of initialization arguments and signals an error if an initialization argument is supplied
that is not declared as valid. (For more information, see Section 7.1.2 (Declaring the Validity of
Initialization Arguments).) Then it calls the generic function shared-initialize with the following
arguments: the new instance , a list of names of the newly added slots, and the initialization
arguments it received.
Objects 7–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.2.3 Customizing the Change of Class of an Instance
Methods forupdate-instance-for-diﬀerent-class may be dened to specify actions to be taken
when an instance is updated. If only after methods forupdate-instance-for-diﬀerent-class are
dened, they will be run after the system-supplied primary method for initialization and will not
interfere with the default behavior of update-instance-for-diﬀerent-class .
Methods forshared-initialize may be dened to customize class redenition. For more information,
see Section 7.1.5 (Shared-Initialize).
7–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.3 Reinitializing an Instance
The generic function reinitialize-instance may be used to change the values of slots according to
initialization arguments.
The process of reinitialization changes the values of some slots and performs any user-dened
actions. It does not modify the structure of an instance to add or delete slots, and it does not use
any:initform forms to initialize slots.
The generic function reinitialize-instance may be called directly. It takes one required argument,
theinstance . It also takes any number of initialization arguments to be used by methods for
reinitialize-instance or forshared-initialize . The arguments after the required instance must
form an initialization argument list .
There is a system-supplied primary method forreinitialize-instance whose parameter specializer
is the classstandard-object . First this method checks the validity of initialization arguments and
signals an error if an initialization argument is supplied that is not declared as valid. (For more
information, see Section 7.1.2 (Declaring the Validity of Initialization Arguments).) Then it calls
the generic function shared-initialize with the following arguments: the instance ,nil, and the
initialization arguments it received.
7.3.1 Customizing Reinitialization
Methods forreinitialize-instance may be dened to specify actions to be taken when an instance
is updated. If only after methods forreinitialize-instance are dened, they will be run after the
system-supplied primary method for initialization and therefore will not interfere with the default
behavior of reinitialize-instance .
Methods forshared-initialize may be dened to customize class redenition. For more information,
see Section 7.1.5 (Shared-Initialize).
Objects 7–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.4 Meta-Objects
The implementation of the object system manipulates classes ,methods , and generic functions .
The object system contains a set of generic functions dened by methods onclasses ; the behavior
of those generic functions denes the behavior of the object system. The instances of the classes
on which those methods are dened are called meta-objects.
7.4.1 Standard Meta-objects
The object system supplies a set of meta-objects, called standard meta-objects. These include the
classstandard-object and instances of the classes standard-method ,standard-generic-function ,
andmethod-combination .
The classstandard-method is the default class ofmethods dened by the defmethod and
defgeneric forms .
The classstandard-generic-function is the default class ofgeneric functions dened by
the forms defmethod ,defgeneric , anddefclass .
The class namedstandard-object is an instance of the classstandard-class and is
asuperclass of every class that is an instance ofstandard-class except itself and
structure-class .
Every method combination object is an instance of asubclass ofclassmethod-combination .
7–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.5 Slots
7.5.1 Introduction to Slots
Anobject ofmetaclass standard-class has zero or more named slots. The slots of an object are
determined by the class of the object . Each slotcan hold one value. The name of a slotis asymbol
that is syntactically valid for use as a variable name.
When a slotdoes not have a value, the slotis said to be unbound . When an unbound slotis
read, the generic function slot-unbound is invoked. The system-supplied primary method for
slot-unbound onclasstsignals an error. If slot-unbound returns, its primary value is used that
time as the value of the slot.
The default initial value form for a slotis dened by the :initform slot option. When the :initform
form is used to supply a value, it is evaluated in the lexical environment in which the defclass
form was evaluated. The :initform along with the lexical environment in which the defclass form
was evaluated is called a captured initialization form . For more details, see Section 7.1 (Object
Creation and Initialization).
Alocal slot is dened to be a slotthat is accessible to exactly one instance , namely the one in
which the slotis allocated. A shared slot is dened to be a slotthat is visible to more than one
instance of a given class and its subclasses .
Aclass is said to dene a slotwith a given name when the defclass form for that class contains a
slot specier with that name . Dening a local slot does not immediately create a slot; it causes a
slotto be created each time an instance of the class is created. Dening a shared slot immediately
creates a slot.
The:allocation slot option to defclass controls the kind of slotthat is dened. If the value of the
:allocation slot option is :instance , alocal slot is created. If the value of :allocation is:class , a
shared slot is created.
Aslotis said to be accessible in an instance of a class if the slotis dened by the class of the
instance or is inherited from a superclass of that class . At most one slotof a given name can be
accessible in an instance . Ashared slot dened by a class isaccessible in all instances of that class .
A detailed explanation of the inheritance of slots is given in Section 7.5.3 (Inheritance of Slots and
Slot Options).
7.5.2 Accessing Slots
Slots can be accessed in two ways: by use of the primitive function slot-value and by use of generic
functions generated by the defclass form.
The function slot-value can be used with any of the slotnames specied in the defclass form to
access a specic slot accessible in an instance of the given class .
Objects 7–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The macro defclass provides syntax for generating methods to read and write slots. If a reader
method is requested, a method is automatically generated for reading the value of the slot, but
nomethod for storing a value into it is generated. If a writer method is requested, a method is
automatically generated for storing a value into the slot, but no method for reading its value is
generated. If an accessor method is requested, a method for reading the value of the slotand a
method for storing a value into the slotare automatically generated. Reader and writer methods
are implemented using slot-value .
When a reader or writer method is specied for a slot, the name of the generic function to which
the generated method belongs is directly specied. If the name specied for the writer method is
the symbol name, the name of the generic function for writing the slotis the symbol name, and the
generic function takes two arguments: the new value and the instance , in that order. If the name
specied for the accessor method is the symbol name, the name of the generic function for reading
theslotis the symbol name, and the name of the generic function for writing the slotis the list
(setf name) .
Ageneric function created or modied by supplying :reader ,:writer , or:accessor slotoptions
can be treated exactly as an ordinary generic function .
Note that slot-value can be used to read or write the value of a slotwhether or not reader or writer
methods exist for that slot. Whenslot-value is used, no reader or writer methods are invoked.
The macro with-slots can be used to establish a lexical environment in which specied slots are
lexically available as if they were variables. The macro with-slots invokes the function slot-value
toaccess the specied slots.
The macro with-accessors can be used to establish a lexical environment in which specied slots
are lexically available through their accessors as if they were variables. The macro with-accessors
invokes the appropriate accessors to access the specied slots.
7.5.3 Inheritance of Slots and Slot Options
The set of the names of all slots accessible in an instance of a classCis the union of the sets of
names ofslots dened byCand its superclasses . The structure of an instance is the set of names
oflocal slots in that instance .
In the simplest case, only one class amongCand its superclasses denes a slotwith a given slot
name. If a slotis dened by a superclass ofC, the slotis said to be inherited. The characteristics
of the slotare determined by the slot specier of the dening class . Consider the dening class for
a slotS. If the value of the :allocation slot option is :instance , thenSis alocal slot and each
instance ofChas its own slotnamedSthat stores its own value. If the value of the :allocation
slot option is :class , thenSis a shared slot , the class that dened Sstores the value, and all
instances ofCcanaccess that single slot. If the :allocation slot option is omitted, :instance is
used.
In general, more than one class amongCand its superclasses can dene a slotwith a given
name . In such cases, only one slotwith the given name is accessible in an instance ofC, and the
characteristics of that slotare a combination of the several slotspeciers, computed as follows:
7–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
All the slot speciers for a given slotname are ordered from most specic to least specic,
according to the order in C'sclass precedence list of the classes that dene them. All
references to the specicity of slot speciers immediately below refers to this ordering.
The allocation of a slotis controlled by the most specic slot specier . If the most specic
slot specier does not contain an :allocation slot option, :instance is used. Less specic
slot speciers do not aect the allocation.
The default initial value form for a slotis the value of the :initform slot option in the
most specic slot specier that contains one. If no slot specier contains an :initform slot
option, the slothas no default initial value form.
The contents of a slotwill always be of type (andT1::: T n)whereT1:::T nare the values
of the:type slot options contained in all of the slot speciers . If no slot specier contains
the:type slot option, the contents of the slotwill always be of typet. The consequences of
attempting to store in a slota value that does not satisfy the type of the slotare undened.
The set of initialization arguments that initialize a given slotis the union of the
initialization arguments declared in the :initarg slot options in all the slot speciers .
The documentation string for a slotis the value of the :documentation slot option in the
most specic slotspecier that contains one. If no slot specier contains a :documentation
slot option, the slothas no documentation string .
A consequence of the allocation rule is that a shared slot can be shadowed . For example, if a
classC1denes a slotnamedSwhose value for the :allocation slot option is :class , that slotis
accessible ininstances ofC1and all of its subclasses . However, if C2is asubclass ofC1and also
denes a slotnamedS,C1'sslotis not shared by instances ofC2and its subclasses . When a class
C1denes a shared slot , any subclass C2ofC1will share this single slotunless the defclass form
forC2species a slotof the same name or there is a superclass ofC2that precedes C1in the class
precedence list ofC2that denes a slotof the same name.
A consequence of the type rule is that the value of a slotsatises the type constraint of each slot
specier that contributes to that slot. Because the result of attempting to store in a slota value
that does not satisfy the type constraint for the slotis undened, the value in a slotmight fail to
satisfy its type constraint.
The:reader ,:writer , and:accessor slot options create methods rather than dene the
characteristics of a slot. Reader and writer methods are inherited in the sense described in Section
7.6.7 (Inheritance of Methods).
Methods that access slots use only the name of the slotand the type of the slot's value. Suppose a
superclass provides a method that expects to access ashared slot of a given name , and a subclass
denes a local slot with the same name . If the method provided by the superclass is used on an
instance of the subclass , the method accesses thelocal slot .
Objects 7–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.6 Generic Functions and Methods
7.6.1 Introduction to Generic Functions
Ageneric function is a function whose behavior depends on the classes or identities of the
arguments supplied to it. A generic function object is associated with a set of methods , alambda
list, amethod combination 2, and other information.
Like an ordinary function , ageneric function takes arguments , performs a series of operations,
and perhaps returns useful values . An ordinary function has a single body of code that is always
executed when the function is called. A generic function has a set of bodies of code of which a
subset is selected for execution . The selected bodies of code and the manner of their combination
are determined by the classes or identities of one or more of the arguments to the generic function
and by its method combination .
Ordinary functions and generic functions are called with identical syntax.
Generic functions are true functions that can be passed as arguments and used as the rst
argument tofuncall andapply .
Abinding of a function name to a generic function can be established in one of several ways. It
can be established in the global environment byensure-generic-function ,defmethod (implicitly,
due toensure-generic-function ) ordefgeneric (also implicitly, due to ensure-generic-function ).
Nostandardized mechanism is provided for establishing abinding of a function name to a generic
function in the lexical environment .
When adefgeneric form is evaluated, one of three actions is taken (due to ensure-generic-function ):
If a generic function of the given name already exists, the existing generic function object
is modied. Methods specied by the current defgeneric form are added, and any methods
in the existing generic function that were dened by a previous defgeneric form are
removed. Methods added by the current defgeneric form might replace methods dened
bydefmethod ,defclass ,deﬁne-condition , ordefstruct . No other methods in the generic
function are aected or replaced.
If the given name names an ordinary function , amacro , or a special operator , an error is
signaled.
Otherwise a generic function is created with the methods specied by the method
denitions in the defgeneric form.
Some operators permit specication of the options of a generic function , such as the type of
method combination it uses or its argument precedence order . These operators will be referred to as
\operators that specify generic function options." The only standardized operator in this category
isdefgeneric .
7–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Some operators dene methods for a generic function . These operators will be referred to as
method-dening operators ; their associated forms are called method-dening forms . The
standardized method-dening operators are listed in Figure 7{1.
defgeneric defmethod defclass
deﬁne-condition defstruct
Figure 7–1. Standardized Method-Deﬁning Operators
Note that of the standardized method-dening operators onlydefgeneric can specify generic
function options.defgeneric and any implementation-dened operators that can specify generic
function options are also referred to as \operators that specify generic function options."
7.6.2 Introduction to Methods
Methods dene the class-specic or identity-specic behavior and operations of a generic function .
Amethod object is associated with code that implements the method's behavior, a sequence of
parameter specializers that specify when the given method is applicable, a lambda list , and a
sequence of qualiers that are used by the method combination facility to distinguish among
methods .
A method object is not a function and cannot be invoked as a function. Various mechanisms in the
object system take a method object and invoke its method function, as is the case when a generic
function is invoked. When this occurs it is said that the method is invoked or called.
A method-dening form contains the code that is to be run when the arguments to the generic
function cause the method that it denes to be invoked. When a method-dening form is evaluated,
a method object is created and one of four actions is taken:
If a generic function of the given name already exists and if a method object already
exists that agrees with the new one on parameter specializers and qualiers , the new
method object replaces the old one. For a denition of one method agreeing with another
onparameter specializers and qualiers , see Section 7.6.3 (Agreement on Parameter
Specializers and Qualiers).
If a generic function of the given name already exists and if there is no method object
that agrees with the new one on parameter specializers and qualiers , the existing generic
function object is modied to contain the new method object .
If the given name names an ordinary function , amacro , or a special operator , an error is
signaled.
Otherwise a generic function is created with the method specied by the method-dening
form .
Objects 7–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If the lambda list of a new method is not congruent with the lambda list of the generic function , an
error is signaled. If a method-dening operator that cannot specify generic function options creates
a new generic function , alambda list for that generic function is derived from the lambda list of
themethod in the method-dening form in such a way as to be congruent with it. For a discussion
ofcongruence , see Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function).
Each method has a specialized lambda list , which determines when that method can be applied.
Aspecialized lambda list is like an ordinary lambda list except that a specialized parameter
may occur instead of the name of a required parameter. A specialized parameter is a list
(variable-name parameter-specializer-name ), where parameter-specializer-name is one of the
following:
asymbol
denotes a parameter specializer which is the class named by that symbol .
aclass
denotes a parameter specializer which is the class itself.
(eql form)
denotes a parameter specializer which satises the type specier (eql object), where object
is the result of evaluating form. The form form is evaluated in the lexical environment in
which the method-dening form is evaluated. Note that form is evaluated only once, at
the time the method is dened, not each time the generic function is called.
Parameter specializer names are used in macros intended as the user-level interface ( defmethod ),
while parameter specializers are used in the functional interface.
Only required parameters may be specialized, and there must be a parameter specializer for each
required parameter. For notational simplicity, if some required parameter in a specialized lambda
listin a method-dening form is simply a variable name, its parameter specializer defaults to the
classt.
Given a generic function and a set of arguments, an applicable method is a method for that
generic function whose parameter specializers are satised by their corresponding arguments. The
following denition species what it means for a method to be applicable and for an argument to
satisfy a parameter specializer .
LethA1;:::;A nibe the required arguments to a generic function in order. Let hP1;:::;P nibe the
parameter specializers corresponding to the required parameters of the method Min order. The
methodMis applicable when each Aiis of the type specied by the type specier Pi. Because
every valid parameter specializer is also a valid type specier , the function typep can be used
during method selection to determine whether an argument satises a parameter specializer .
A method all of whose parameter specializers are the classtis called a default method ; it is
always applicable but may be shadowed by a more specic method.
7–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Methods can have qualiers , which give the method combination procedure a way to distinguish
among methods. A method that has one or more qualiers is called a qualied method . A method
with no qualiers is called an unqualied method . Aqualier is any non-list . The qualiers dened
by the standardized method combination types are symbols .
In this specication, the terms \ primary method " and \ auxiliary method " are used to partition
methods within a method combination type according to their intended use. In standard method
combination, primary methods areunqualied methods and auxiliary methods are methods with a
single qualier that is one of :around ,:before , or:after .Methods with these qualiers are called
around methods ,before methods , and after methods , respectively. When a method combination
type is dened using the short form of deﬁne-method-combination ,primary methods are methods
qualied with the name of the type of method combination, and auxiliary methods have the
qualier :around . Thus the terms \ primary method " and \ auxiliary method " have only a relative
denition within a given method combination type.
7.6.3 Agreement on Parameter Specializers and Qualiﬁers
Two methods are said to agree with each other on parameter specializers and qualiers if the
following conditions hold:
1. Both methods have the same number of required parameters. Suppose the parameter
specializers of the two methods are P1;1:::P 1;nandP2;1:::P 2;n.
2. For each 1in,P1;iagrees with P2;i. The parameter specializer P1;iagrees with P2;iif
P1;iandP2;iare the same class or if P1;i=(eql object1),P2;i=(eql object2), and(eql
object1object2). Otherwise P1;iandP2;ido not agree.
3. The two lists ofqualiers are the same underequal .
7.6.4 Congruent Lambda-lists for all Methods of a Generic
Function
These rules dene the congruence of a set of lambda lists , including the lambda list of each method
for a given generic function and the lambda list specied for the generic function itself, if given.
1. Each lambda list must have the same number of required parameters.
2. Each lambda list must have the same number of optional parameters. Each method can
supply its own default for an optional parameter.
3. If any lambda list mentions &rest or&key , each lambda list must mention one or both of
them.
Objects 7–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
4. If the generic function lambda list mentions &key , each method must accept all of the
keyword names mentioned after &key , either by accepting them explicitly, by specifying
&allow-other-keys , or by specifying &rest but not&key . Each method can accept
additional keyword arguments of its own. The checking of the validity of keyword names is
done in the generic function, not in each method. A method is invoked as if the keyword
argument pair whose name is :allow-other-keys and whose value is true were supplied,
though no such argument pair will be passed.
5. The use of &allow-other-keys need not be consistent across lambda lists . If
&allow-other-keys is mentioned in the lambda list of any applicable method or of
thegeneric function , any keyword arguments may be mentioned in the call to the generic
function .
6. The use of &aux need not be consistent across methods.
If amethod-dening operator that cannot specify generic function options creates a generic
function , and if the lambda list for the method mentions keyword arguments, the lambda
listof the generic function will mention &key (but no keyword arguments).
7.6.5 Keyword Arguments in Generic Functions and Methods
When a generic function or any of its methods mentions &key in a lambda list , the specic set of
keyword arguments accepted by the generic function varies according to the applicable methods.
The set of keyword arguments accepted by the generic function for a particular call is the union of
the keyword arguments accepted by all applicable methods and the keyword arguments mentioned
after&key in the generic function denition, if any. A method that has &rest but not&key does
not aect the set of acceptable keyword arguments. If the lambda list of any applicable method or
of the generic function denition contains &allow-other-keys , all keyword arguments are accepted
by the generic function.
The lambda list congruence rules require that each method accept all of the keyword arguments
mentioned after &key in the generic function denition, by accepting them explicitly, by specifying
&allow-other-keys , or by specifying &rest but not&key . Each method can accept additional
keyword arguments of its own, in addition to the keyword arguments mentioned in the generic
function denition.
If ageneric function is passed a keyword argument that no applicable method accepts, an error
should be signaled; see Section 3.5 (Error Checking in Function Calls).
7–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods
For example, suppose there are two methods dened for width as follows:
(defmethod width ((c character-class) &key font) ...)
(defmethod width ((p picture-class) &key pixel-size) ...)
Assume that there are no other methods and no generic function denition for width . The
evaluation of the following form should signal an error because the keyword argument :pixel-size
is not accepted by the applicable method.
(width (make-instance ‘character-class :char #\Q)
:font ’baskerville :pixel-size 10)
The evaluation of the following form should signal an error.
(width (make-instance ‘picture-class :glyph (glyph #\Q))
:font ’baskerville :pixel-size 10)
The evaluation of the following form will not signal an error if the class named character-picture-
class is a subclass of both picture-class andcharacter-class .
(width (make-instance ‘character-picture-class :char #\Q)
:font ’baskerville :pixel-size 10)
7.6.6 Method Selection and Combination
When a generic function is called with particular arguments, it must determine the code to
execute. This code is called the eective method for those arguments . The eective method is a
combination of the applicable methods in the generic function that calls some or all of the methods .
If a generic function is called and no methods areapplicable , the generic function
no-applicable-method is invoked, with the results from that call being used as the results
of the call to the original generic function . Calling no-applicable-method takes precedence over
checking for acceptable keyword arguments; see Section 7.6.5 (Keyword Arguments in Generic
Functions and Methods).
When the eective method has been determined, it is invoked with the same arguments as were
passed to the generic function . Whatever values it returns are returned as the values of the generic
function .
Objects 7–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.6.6.1 Determining the Eﬀective Method
The eective method is determined by the following three-step procedure:
1. Select the applicable methods.
2. Sort the applicable methods by precedence order, putting the most specic method rst.
3. Apply method combination to the sorted list of applicable methods, producing the eective
method.
7.6.6.1.1 Selecting the Applicable Methods
This step is described in Section 7.6.2 (Introduction to Methods).
7.6.6.1.2 Sorting the Applicable Methods by Precedence Order
To compare the precedence of two methods, their parameter specializers are examined in order.
The default examination order is from left to right, but an alternative order may be specied by
the:argument-precedence-order option to defgeneric or to any of the other operators that specify
generic function options.
The corresponding parameter specializers from each method are compared. When a pair of
parameter specializers agree, the next pair are compared for agreement. If all corresponding
parameter specializers agree, the two methods must have dierent qualiers ; in this case, either
method can be selected to precede the other. For information about agreement, see Section 7.6.3
(Agreement on Parameter Specializers and Qualiers).
If some corresponding parameter specializers do not agree, the rst pair of parameter specializers
that do not agree determines the precedence. If both parameter specializers are classes, the more
specic of the two methods is the method whose parameter specializer appears earlier in the class
precedence list of the corresponding argument. Because of the way in which the set of applicable
methods is chosen, the parameter specializers are guaranteed to be present in the class precedence
list of the class of the argument.
If just one of a pair of corresponding parameter specializers is(eql object), the method with that
parameter specializer precedes the other method . If both parameter specializers areeqlexpressions ,
the specializers must agree (otherwise the two methods would not both have been applicable to
this argument).
The resulting list of applicable methods has the most specic method rst and the least specic
method last.
7–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.6.6.1.3 Applying method combination to the sorted list of applicable methods
In the simple case|if standard method combination is used and all applicable methods are primary
methods|the eective method is the most specic method. That method can call the next most
specic method by using the function call-next-method . The method that call-next-method
will call is referred to as the next method . The predicate next-method-p tests whether a next
method exists. If call-next-method is called and there is no next most specic method, the generic
functionno-next-method is invoked.
In general, the eective method is some combination of the applicable methods. It is described by
aform that contains calls to some or all of the applicable methods, returns the value or values that
will be returned as the value or values of the generic function, and optionally makes some of the
methods accessible by means of call-next-method .
The role of each method in the eective method is determined by its qualiers and the specicity
of the method. A qualier serves to mark a method, and the meaning of a qualier is determined
by the way that these marks are used by this step of the procedure. If an applicable method has an
unrecognized qualier , this step signals an error and does not include that method in the eective
method.
When standard method combination is used together with qualied methods, the eective method
is produced as described in Section 7.6.6.2 (Standard Method Combination).
Another type of method combination can be specied by using the :method-combination option of
defgeneric or of any of the other operators that specify generic function options. In this way this
step of the procedure can be customized.
New types of method combination can be dened by using the deﬁne-method-combination macro .
7.6.6.2 Standard Method Combination
Standard method combination is supported by the classstandard-generic-function . It is used
if no other type of method combination is specied or if the built-in method combination type
standard is specied.
Primary methods dene the main action of the eective method, while auxiliary methods modify
that action in one of three ways. A primary method has no method qualiers .
An auxiliary method is a method whose qualier is:before ,:after , or:around . Standard method
combination allows no more than one qualier per method; if a method denition species more
than one qualier per method, an error is signaled.
Abefore method has the keyword :before as its only qualier . Abefore method species
code that is to be run before any primary methods .
Anafter method has the keyword :after as its only qualier . An after method species
code that is to be run after primary methods .
Objects 7–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Anaround method has the keyword :around as its only qualier . An around method
species code that is to be run instead of other applicable methods , but which might
contain explicit code which calls some of those shadowed methods (viacall-next-method ).
The semantics of standard method combination is as follows:
If there are any around methods , the most specic around method is called. It supplies the
value or values of the generic function.
Inside the body of an around method ,call-next-method can be used to call the next
method . When the next method returns, the around method can execute more code,
perhaps based on the returned value or values. The generic function no-next-method is
invoked if call-next-method is used and there is no applicable method to call. The function
next-method-p may be used to determine whether a next method exists.
If an around method invokescall-next-method , the next most specic around method is
called, if one is applicable. If there are no around methods or ifcall-next-method is called
by the least specic around method , the other methods are called as follows:
{ All the before methods are called, in most-specic-rst order. Their values are
ignored. An error is signaled if call-next-method is used in a before method .
{ The most specic primary method is called. Inside the body of a primary
method,call-next-method may be used to call the next most specic primary
method. When that method returns, the previous primary method can execute
more code, perhaps based on the returned value or values. The generic function
no-next-method is invoked if call-next-method is used and there are no more
applicable primary methods. The function next-method-p may be used to
determine whether a next method exists. If call-next-method is not used, only
the most specic primary method is called.
{ All the after methods are called in most-specic-last order. Their values are
ignored. An error is signaled if call-next-method is used in an after method .
If no around methods were invoked, the most specic primary method supplies the value
or values returned by the generic function. The value or values returned by the invocation
ofcall-next-method in the least specic around method are those returned by the most
specic primary method.
In standard method combination, if there is an applicable method but no applicable primary
method, an error is signaled.
The before methods are run in most-specic-rst order while the after methods are run in
least-specic-rst order. The design rationale for this dierence can be illustrated with an example.
Suppose class C1modies the behavior of its superclass, C2, by adding before methods and after
methods . Whether the behavior of the class C2is dened directly by methods on C2or is inherited
7–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
from its superclasses does not aect the relative order of invocation of methods on instances of the
classC1. ClassC1'sbefore method runs before all of class C2's methods. Class C1'safter method
runs after all of class C2's methods.
By contrast, all around methods run before any other methods run. Thus a less specic around
method runs before a more specic primary method.
If only primary methods are used and if call-next-method is not used, only the most specic
method is invoked; that is, more specic methods shadow more general ones.
7.6.6.3 Declarative Method Combination
The macro deﬁne-method-combination denes new forms of method combination. It provides
a mechanism for customizing the production of the eective method. The default procedure for
producing an eective method is described in Section 7.6.6.1 (Determining the Eective Method).
There are two forms of deﬁne-method-combination . The short form is a simple facility while the
long form is more powerful and more verbose. The long form resembles defmacro in that the body
is an expression that computes a Lisp form; it provides mechanisms for implementing arbitrary
control structures within method combination and for arbitrary processing of method qualiers .
7.6.6.4 Built-in Method Combination Types
The object system provides a set of built-in method combination types. To specify that a
generic function is to use one of these method combination types, the name of the method
combination type is given as the argument to the :method-combination option to defgeneric or to
the:method-combination option to any of the other operators that specify generic function options.
The names of the built-in method combination types are listed in Figure 7{2.
+ append max nconc progn
and list min or standard
Figure 7–2. Built-in Method Combination Types
The semantics of the standard built-in method combination type is described in Section 7.6.6.2
(Standard Method Combination). The other built-in method combination types are called simple
built-in method combination types.
The simple built-in method combination types act as though they were dened by the short form
ofdeﬁne-method-combination . They recognize two roles for methods :
Anaround method has the keyword symbol :around as its sole qualier . The meaning of
:around methods is the same as in standard method combination. Use of the functions
call-next-method andnext-method-p is supported in around methods .
Objects 7–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
A primary method has the name of the method combination type as its sole qualier .
For example, the built-in method combination type andrecognizes methods whose sole
qualier isand; these are primary methods. Use of the functions call-next-method and
next-method-p is not supported in primary methods .
The semantics of the simple built-in method combination types is as follows:
If there are any around methods , the most specic around method is called. It supplies the
value or values of the generic function .
Inside the body of an around method , the function call-next-method can be used to call
thenext method . The generic function no-next-method is invoked if call-next-method is
used and there is no applicable method to call. The functionnext-method-p may be used
to determine whether a next method exists. When the next method returns, the around
method can execute more code, perhaps based on the returned value or values.
If an around method invokescall-next-method , the next most specic around method is
called, if one is applicable. If there are no around methods or ifcall-next-method is called
by the least specic around method , a Lisp form derived from the name of the built-in
method combination type and from the list of applicable primary methods is evaluated to
produce the value of the generic function. Suppose the name of the method combination
type is operator and the call to the generic function is of the form
(generic-function a1:::a n)
LetM1;:::;M kbe the applicable primary methods in order; then the derived Lisp form is
(operatorhM1a1:::a ni:::hMka1:::a ni)
If the expression hMia1:::a niis evaluated, the method Miwill be applied to the
arguments a1:::a n. For example, if operator isor, the expressionhMia1:::a niis
evaluated only if hMja1:::a ni,1j<i, returned nil.
The default order for the primary methods is :most-specific-first . However, the
order can be reversed by supplying :most-specific-last as the second argument to the
:method-combination option.
The simple built-in method combination types require exactly one qualier per method. An error is
signaled if there are applicable methods with no qualiers or with qualiers that are not supported
by the method combination type. An error is signaled if there are applicable around methods and
no applicable primary methods.
7–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
7.6.7 Inheritance of Methods
A subclass inherits methods in the sense that any method applicable to all instances of a class is
also applicable to all instances of any subclass of that class.
The inheritance of methods acts the same way regardless of which of the method-dening operators
created the methods.
The inheritance of methods is described in detail in Section 7.6.6 (Method Selection and
Combination).
Objects 7–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
function-keywords Standard Generic Function
Syntax:
function-keywords method!keys, allow-other-keys-p
Method Signatures:
function-keywords (methodstandard-method )
Arguments and Values:
method |amethod .
keys|alist.
allow-other-keys-p |ageneralized boolean .
Description:
Returns the keyword parameter speciers for a method .
Two values are returned: a listof the explicitly named keywords and a generalized boolean that
states whether &allow-other-keys had been specied in the method denition.
Examples:
(defmethod gf1 ((a integer) &optional (b 2)
&key (c 3) ((:dee d) 4) e ((eff f)))
(list a b c d e f))
!#<STANDARD-METHOD GF1 (INTEGER) 36324653>
(find-method #’gf1 ’() (list (find-class ’integer)))
!#<STANDARD-METHOD GF1 (INTEGER) 36324653>
(function-keywords *)
!(:C :DEE :E EFF), false
(defmethod gf2 ((a integer))
(list a b c d e f))
!#<STANDARD-METHOD GF2 (INTEGER) 42701775>
(function-keywords (find-method #’gf1 ’() (list (find-class ’integer))))
!(),false
(defmethod gf3 ((a integer) &key b c d &allow-other-keys)
(list a b c d e f))
(function-keywords *)
!(:B :C :D), true
Aﬀected By:
defmethod
7–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
defmethod
ensure-generic-function Function
Syntax:
ensure-generic-function function-name &key argument-precedence-order declare
documentation environment
generic-function-class lambda-list
method-class method-combination
!generic-function
Arguments and Values:
function-name |afunction name .
The keyword arguments correspond to the option arguments of defgeneric , except that the
:method-class and:generic-function-class arguments can be class object s as well as names.
Method-combination { method combination object.
Environment { the same as the &environment argument to macro expansion functions and is used
to distinguish between compile-time and run-time environments.
generic-function |ageneric function object .
Description:
The functionensure-generic-function is used to dene a globally named generic function with no
methods or to specify or modify options and declarations that pertain to a globally named generic
function as a whole.
Iffunction-name is not fbound in the global environment , a new generic function is created. If
(fdefinition function-name )is an ordinary function , amacro , or a special operator , an error is
signaled.
Iffunction-name is a list, it must be of the form (setf symbol). If function-name species
ageneric function that has a dierent value for any of the following arguments, the generic
function is modied to have the new value: :argument-precedence-order ,:declare ,:documentation ,
:method-combination .
Iffunction-name species a generic function that has a dierent value for the :lambda-list
argument, and the new value is congruent with the lambda lists of all existing methods or there are
nomethods , the value is changed; otherwise an error is signaled.
Objects 7–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Iffunction-name species a generic function that has a dierent value for the
:generic-function-class argument and if the new generic function class is compatible with
the old,change-class is called to change the class of the generic function ; otherwise an error is
signaled.
Iffunction-name species a generic function that has a dierent value for the :method-class
argument, the value is changed, but any existing methods are not changed.
Aﬀected By:
Existing function binding of function-name .
Exceptional Situations:
If(fdefinition function-name )is an ordinary function , amacro , or a special operator , an error of
typeerror is signaled.
Iffunction-name species a generic function that has a dierent value for the :lambda-list
argument, and the new value is not congruent with the lambda list of any existing method , an error
oftypeerror is signaled.
Iffunction-name species a generic function that has a dierent value for the
:generic-function-class argument and if the new generic function class not is compatible
with the old, an error of typeerror is signaled.
See Also:
defgeneric
allocate-instance Standard Generic Function
Syntax:
allocate-instance class&rest initargs&key &allow-other-keys !new-instance
Method Signatures:
allocate-instance (classstandard-class )&rest initargs
allocate-instance (classstructure-class )&rest initargs
Arguments and Values:
class|aclass .
initargs |alistofkeyword/value pairs (initialization argument names and values ).
new-instance |an object whose class isclass.
7–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
The generic function allocate-instance creates and returns a new instance of the class, without
initializing it. When the class is astandard class , this means that the slots areunbound ; when the
class is astructure class , this means the slots'values are unspecied.
The caller of allocate-instance is expected to have already checked the initialization arguments.
The generic function allocate-instance is called by make-instance , as described in Section 7.1
(Object Creation and Initialization).
See Also:
defclass ,make-instance ,class-of , Section 7.1 (Object Creation and Initialization)
Notes:
The consequences of adding methods toallocate-instance is unspecied. This capability might be
added by the Metaobject Protocol .
reinitialize-instance Standard Generic Function
Syntax:
reinitialize-instance instance &rest initargs&key &allow-other-keys !instance
Method Signatures:
reinitialize-instance (instancestandard-object )&rest initargs
Arguments and Values:
instance |an object .
initargs |an initialization argument list .
Description:
The generic function reinitialize-instance can be used to change the values of local slots of an
instance according to initargs . This generic function can be called by users.
The system-supplied primary method forreinitialize-instance checks the validity of initargs and
signals an error if an initarg is supplied that is not declared as valid. The method then calls the
generic function shared-initialize with the following arguments: the instance ,nil(which means no
slots should be initialized according to their initforms), and the initargs it received.
Side Eﬀects:
The generic function reinitialize-instance changes the values of local slots .
Objects 7–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
The system-supplied primary method forreinitialize-instance signals an error if an initarg is
supplied that is not declared as valid.
See Also:
initialize-instance ,shared-initialize ,update-instance-for-redeﬁned-class ,
update-instance-for-diﬀerent-class ,slot-boundp ,slot-makunbound , Section 7.3 (Reinitial-
izing an Instance), Section 7.1.4 (Rules for Initialization Arguments), Section 7.1.2 (Declaring the
Validity of Initialization Arguments)
Notes:
Initargs are declared as valid by using the :initarg option to defclass , or by dening methods for
reinitialize-instance orshared-initialize . The keyword name of each keyword parameter specier
in the lambda list of any method dened on reinitialize-instance orshared-initialize is declared
as a valid initialization argument name for all classes for which that method is applicable.
shared-initialize Standard Generic Function
Syntax:
shared-initialize instance slot-names &rest initargs&key &allow-other-keys !instance
Method Signatures:
shared-initialize (instancestandard-object )slot-names &rest initargs
Arguments and Values:
instance |an object .
slot-names |alistort.
initargs |alistofkeyword/value pairs (of initialization argument names and values ).
Description:
The generic function shared-initialize is used to ll the slots of an instance using initargs and
:initform forms. It is called when an instance is created, when an instance is re-initialized, when
an instance is updated to conform to a redened class , and when an instance is updated to conform
to a dierent class . The generic function shared-initialize is called by the system-supplied primary
method forinitialize-instance ,reinitialize-instance ,update-instance-for-redeﬁned-class , and
update-instance-for-diﬀerent-class .
The generic function shared-initialize takes the following arguments: the instance to be initialized,
a specication of a set of slot-names accessible in that instance , and any number of initargs . The
arguments after the rst two must form an initialization argument list . The system-supplied
7–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
shared-initialize
primary method onshared-initialize initializes the slots with values according to the initargs and
supplied :initform forms. Slot-names indicates which slots should be initialized according to their
:initform forms if no initargs are provided for those slots.
The system-supplied primary method behaves as follows, regardless of whether the slots are local
or shared:
If an initarg in the initialization argument list species a value for that slot, that value is
stored into the slot, even if a value has already been stored in the slotbefore the method
is run.
Any slots indicated by slot-names that are still unbound at this point are initialized
according to their :initform forms. For any such slotthat has an :initform form, that
form is evaluated in the lexical environment of its dening defclass form and the result
is stored into the slot. For example, if a before method stores a value in the slot, the
:initform form will not be used to supply a value for the slot.
The rules mentioned in Section 7.1.4 (Rules for Initialization Arguments) are obeyed.
The slots-names argument species the slots that are to be initialized according to their :initform
forms if no initialization arguments apply. It can be a listof slot names , which species the set of
those slot names ; or it can be the symbolt, which species the set of all of the slots.
See Also:
initialize-instance ,reinitialize-instance ,update-instance-for-redeﬁned-class ,
update-instance-for-diﬀerent-class ,slot-boundp ,slot-makunbound , Section 7.1 (Object
Creation and Initialization), Section 7.1.4 (Rules for Initialization Arguments), Section 7.1.2
(Declaring the Validity of Initialization Arguments)
Notes:
Initargs are declared as valid by using the :initarg option to defclass , or by dening methods for
shared-initialize . The keyword name of each keyword parameter specier in the lambda list of
anymethod dened on shared-initialize is declared as a valid initarg name for all classes for which
that method is applicable.
Implementations are permitted to optimize :initform forms that neither produce nor depend
on side eects, by evaluating these forms and storing them into slots before running any
initialize-instance methods, rather than by handling them in the primary initialize-instance
method. (This optimization might be implemented by having the allocate-instance method copy
a prototype instance.)
Implementations are permitted to optimize default initial value forms for initargs associated with
slots by not actually creating the complete initialization argument listwhen the only method that
would receive the complete listis the method onstandard-object . In this case default initial value
forms can be treated like :initform forms. This optimization has no visible eects other than a
performance improvement.
Objects 7–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
update-instance-for-diﬀerent-class Standard Generic
Function
Syntax:
update-instance-for-diﬀerent-class previous current &rest initargs&key &allow-other-keys
!implementation-dependent
Method Signatures:
update-instance-for-diﬀerent-class (previousstandard-object )
(currentstandard-object )
&rest initargs
Arguments and Values:
previous |a copy of the original instance .
current |the original instance (altered).
initargs |an initialization argument list .
Description:
The generic function update-instance-for-diﬀerent-class is not intended to be called by program-
mers. Programmers may write methods for it. The functionupdate-instance-for-diﬀerent-class is
called only by the functionchange-class .
The system-supplied primary method onupdate-instance-for-diﬀerent-class checks the validity
ofinitargs and signals an error if an initarg is supplied that is not declared as valid. This method
then initializes slots with values according to the initargs , and initializes the newly added slots
with values according to their :initform forms. It does this by calling the generic function
shared-initialize with the following arguments: the instance ( current ), a list of names of the newly
added slots, and the initargs it received. Newly added slots are those local slots for which no slot
of the same name exists in the previous class.
Methods forupdate-instance-for-diﬀerent-class can be dened to specify actions to be taken
when an instance is updated. If only after methods forupdate-instance-for-diﬀerent-class are
dened, they will be run after the system-supplied primary method for initialization and therefore
will not interfere with the default behavior of update-instance-for-diﬀerent-class .
Methods onupdate-instance-for-diﬀerent-class can be dened to initialize slots dierently from
change-class . The default behavior of change-class is described in Section 7.2 (Changing the Class
of an Instance).
7–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The arguments to update-instance-for-diﬀerent-class are computed by change-class . When
change-class is invoked on an instance , a copy of that instance is made; change-class then de-
structively alters the original instance . The rst argument to update-instance-for-diﬀerent-class ,
previous , is that copy; it holds the old slotvalues temporarily. This argument has dynamic
extent within change-class ; if it is referenced in any way once update-instance-for-diﬀerent-class
returns, the results are undened. The second argument to update-instance-for-diﬀerent-class ,
current , is the altered original instance . The intended use of previous is to extract old slotvalues
by usingslot-value orwith-slots or by invoking a reader generic function, or to run other methods
that were applicable to instances of the original class .
Examples:
See the example for the functionchange-class .
Exceptional Situations:
The system-supplied primary method onupdate-instance-for-diﬀerent-class signals an error if an
initialization argument is supplied that is not declared as valid.
See Also:
change-class ,shared-initialize , Section 7.2 (Changing the Class of an Instance), Section 7.1.4
(Rules for Initialization Arguments), Section 7.1.2 (Declaring the Validity of Initialization
Arguments)
Notes:
Initargs are declared as valid by using the :initarg option to defclass , or by dening methods
forupdate-instance-for-diﬀerent-class orshared-initialize . The keyword name of each keyword
parameter specier in the lambda list of any method dened on update-instance-for-diﬀerent-class
orshared-initialize is declared as a valid initarg name for all classes for which that method is
applicable.
The value returned by update-instance-for-diﬀerent-class is ignored by change-class .
update-instance-for-redeﬁned-class Standard Generic
Function
Syntax:
update-instance-for-redeﬁned-class instance
added-slots discarded-slots
property-list
&rest initargs&key &allow-other-keys
!f resultg*
Objects 7–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
update-instance-for-redeﬁned-class
Method Signatures:
update-instance-for-redeﬁned-class (instancestandard-object )
added-slots discarded-slots
property-list
&rest initargs
Arguments and Values:
instance |an object .
added-slots |alist.
discarded-slots |alist.
property-list |alist.
initargs |an initialization argument list .
result |an object .
Description:
The generic function update-instance-for-redeﬁned-class is not intended to be called
by programmers. Programmers may write methods for it. The generic func-
tionupdate-instance-for-redeﬁned-class is called by the mechanism activated by
make-instances-obsolete .
The system-supplied primary method onupdate-instance-for-redeﬁned-class checks the validity of
initargs and signals an error if an initarg is supplied that is not declared as valid. This method then
initializes slots with values according to the initargs , and initializes the newly added-slots with values
according to their :initform forms. It does this by calling the generic function shared-initialize
with the following arguments: the instance , a list of names of the newly added-slots toinstance ,
and the initargs it received. Newly added-slots are those local slots for which no slotof the same
name exists in the old version of the class .
Whenmake-instances-obsolete is invoked or when a class has been redened and an instance is
being updated, a property-list is created that captures the slot names and values of all the discarded-
slots with values in the original instance . The structure of the instance is transformed so that it
conforms to the current class denition. The arguments to update-instance-for-redeﬁned-class
are this transformed instance , a list of added-slots to the instance , a list discarded-slots from the
instance , and the property-list containing the slot names and values for slots that were discarded
and had values. Included in this list of discarded slots areslots that were local in the old class and
are shared in the new class .
The value returned by update-instance-for-redeﬁned-class is ignored.
Examples:
7–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
update-instance-for-redeﬁned-class
(defclass position () ())
(defclass x-y-position (position)
((x :initform 0 :accessor position-x)
(y :initform 0 :accessor position-y)))
;;; It turns out polar coordinates are used more than Cartesian
;;; coordinates, so the representation is altered and some new
;;; accessor methods are added.
(defmethod update-instance-for-redefined-class :before
((pos x-y-position) added deleted plist &key)
;; Transform the x-y coordinates to polar coordinates
;; and store into the new slots.
(let ((x (getf plist ’x))
(y (getf plist ’y)))
(setf (position-rho pos) (sqrt (+ (* x x) (* y y)))
(position-theta pos) (atan y x))))
(defclass x-y-position (position)
((rho :initform 0 :accessor position-rho)
(theta :initform 0 :accessor position-theta)))
;;; All instances of the old x-y-position class will be updated
;;; automatically.
;;; The new representation is given the look and feel of the old one.
(defmethod position-x ((pos x-y-position))
(with-slots (rho theta) pos (* rho (cos theta))))
(defmethod (setf position-x) (new-x (pos x-y-position))
(with-slots (rho theta) pos
(let ((y (position-y pos)))
(setq rho (sqrt (+ (* new-x new-x) (* y y)))
theta (atan y new-x))
new-x)))
(defmethod position-y ((pos x-y-position))
(with-slots (rho theta) pos (* rho (sin theta))))
(defmethod (setf position-y) (new-y (pos x-y-position))
(with-slots (rho theta) pos
(let ((x (position-x pos)))
(setq rho (sqrt (+ (* x x) (* new-y new-y)))
Objects 7–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
theta (atan new-y x))
new-y)))
Exceptional Situations:
The system-supplied primary method onupdate-instance-for-redeﬁned-class signals an error if
aninitarg is supplied that is not declared as valid.
See Also:
make-instances-obsolete ,shared-initialize , Section 4.3.6 (Redening Classes), Section 7.1.4 (Rules
for Initialization Arguments), Section 7.1.2 (Declaring the Validity of Initialization Arguments)
Notes:
Initargs are declared as valid by using the :initarg option to defclass , or by dening methods for
update-instance-for-redeﬁned-class orshared-initialize . The keyword name of each keyword
parameter specier in the lambda list of any method dened on update-instance-for-redeﬁned-class
orshared-initialize is declared as a valid initarg name for all classes for which that method is
applicable.
change-class Standard Generic Function
Syntax:
change-class instance new-class &key &allow-other-keys !instance
Method Signatures:
change-class (instancestandard-object ) (new-class standard-class )&rest initargs
change-class (instancet) (new-class symbol )&rest initargs
Arguments and Values:
instance |an object .
new-class |aclass designator .
initargs |an initialization argument list .
Description:
The generic function change-class changes the class of an instance tonew-class . It destructively
modies and returns the instance .
7–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
change-class
If in the old class there is any slotof the same name as a local slotin the new-class , the value of
that slotis retained. This means that if the slothas a value, the value returned by slot-value after
change-class is invoked is eqlto the value returned by slot-value beforechange-class is invoked.
Similarly, if the slotwas unbound, it remains unbound. The other slots are initialized as described
in Section 7.2 (Changing the Class of an Instance).
After completing all other actions, change-class invokesupdate-instance-for-diﬀerent-class . The
generic function update-instance-for-diﬀerent-class can be used to assign values to slots in the
transformed instance. See Section 7.2.2 (Initializing Newly Added Local Slots).
If the second of the above methods is selected, that method invokeschange-class oninstance ,
(find-class new-class ), and the initargs .
Examples:
(defclass position () ())
(defclass x-y-position (position)
((x :initform 0 :initarg :x)
(y :initform 0 :initarg :y)))
(defclass rho-theta-position (position)
((rho :initform 0)
(theta :initform 0)))
(defmethod update-instance-for-different-class :before ((old x-y-position)
(new rho-theta-position)
&key)
;; Copy the position information from old to new to make new
;; be a rho-theta-position at the same position as old.
(let ((x (slot-value old ’x))
(y (slot-value old ’y)))
(setf (slot-value new ’rho) (sqrt (+ (* x x) (* y y)))
(slot-value new ’theta) (atan y x))))
;;; At this point an instance of the class x-y-position can be
;;; changed to be an instance of the class rho-theta-position using
;;; change-class:
(setq p1 (make-instance ’x-y-position :x 2 :y 0))
(change-class p1 ’rho-theta-position)
;;; The result is that the instance bound to p1 is now an instance of
;;; the class rho-theta-position. The update-instance-for-different-class
;;; method performed the initialization of the rho and theta slots based
Objects 7–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;;; on the value of the x and y slots, which were maintained by
;;; the old instance.
See Also:
update-instance-for-diﬀerent-class , Section 7.2 (Changing the Class of an Instance)
Notes:
The generic function change-class has several semantic diculties. First, it performs a destructive
operation that can be invoked within a method on an instance that was used to select that method .
When multiple methods are involved because methods are being combined, the methods currently
executing or about to be executed may no longer be applicable. Second, some implementations
might use compiler optimizations of slot access , and when the class of an instance is changed the
assumptions the compiler made might be violated. This implies that a programmer must not use
change-class inside a method if any methods for that generic function access any slots, or the
results are undened.
slot-boundp Function
Syntax:
slot-boundp instance slot-name !generalized-boolean
Arguments and Values:
instance |an object .
slot-name |asymbol naming a slotofinstance .
generalized-boolean |ageneralized boolean .
Description:
Returns true if the slotnamed slot-name ininstance is bound; otherwise, returns false.
Exceptional Situations:
If no slotof the name slot-name exists in the instance ,slot-missing is called as follows:
(slot-missing (class-of instance )
instance
slot-name
’slot-boundp)
(Ifslot-missing is invoked and returns a value, a boolean equivalent to its primary value is returned
byslot-boundp .)
7–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The specic behavior depends on instance 'smetaclass . An error is never signaled if instance has
metaclass standard-class . An error is always signaled if instance hasmetaclass built-in-class . The
consequences are undened if instance has any other metaclass {an error might or might not be
signaled in this situation. Note in particular that the behavior for conditions and structures is not
specied.
See Also:
slot-makunbound ,slot-missing
Notes:
The function slot-boundp allows for writing after methods oninitialize-instance in order to
initialize only those slots that have not already been bound.
Although no implementation is required to do so, implementors are strongly encouraged to
implement the functionslot-boundp using the function slot-boundp-using-class described in the
Metaobject Protocol .
slot-exists-p Function
Syntax:
slot-exists-p object slot-name !generalized-boolean
Arguments and Values:
object |an object .
slot-name |asymbol .
generalized-boolean |ageneralized boolean .
Description:
Returns true if the object has a slotnamed slot-name .
Aﬀected By:
defclass ,defstruct
See Also:
defclass ,slot-missing
Notes:
Although no implementation is required to do so, implementors are strongly encouraged to
implement the function slot-exists-p using the function slot-exists-p-using-class described in
theMetaobject Protocol .
Objects 7–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
slot-makunbound Function
Syntax:
slot-makunbound instance slot-name !instance
Arguments and Values:
instance { instance.
Slot-name |asymbol .
Description:
The functionslot-makunbound restores a slotof the name slot-name in an instance to the unbound
state.
Exceptional Situations:
If no slotof the name slot-name exists in the instance ,slot-missing is called as follows:
(slot-missing (class-of instance )
instance
slot-name
’slot-makunbound)
(Any values returned by slot-missing in this case are ignored by slot-makunbound .)
The specic behavior depends on instance 'smetaclass . An error is never signaled if instance has
metaclass standard-class . An error is always signaled if instance hasmetaclass built-in-class . The
consequences are undened if instance has any other metaclass {an error might or might not be
signaled in this situation. Note in particular that the behavior for conditions and structures is not
specied.
See Also:
slot-boundp ,slot-missing
Notes:
Although no implementation is required to do so, implementors are strongly encouraged to
implement the function slot-makunbound using the function slot-makunbound-using-class
described in the Metaobject Protocol .
7–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
slot-missing
slot-missing Standard Generic Function
Syntax:
slot-missing class object slot-name operation &optional new-value!f resultg*
Method Signatures:
slot-missing (classt)object slot-name
operation &optional new-value
Arguments and Values:
class|the class ofobject .
object |an object .
slot-name |asymbol (the name of a would-be slot).
operation |one of the symbolssetf,slot-boundp ,slot-makunbound , orslot-value .
new-value |an object .
result |an object .
Description:
The generic function slot-missing is invoked when an attempt is made to access aslotin an object
whose metaclass isstandard-class and the slotof the name slot-name is not a name of a slotin
that class . The default method signals an error.
The generic function slot-missing is not intended to be called by programmers. Programmers may
write methods for it.
The generic function slot-missing may be called during evaluation of slot-value ,(setf slot-value) ,
slot-boundp , andslot-makunbound . For each of these operations the corresponding symbol for
theoperation argument is slot-value ,setf,slot-boundp , andslot-makunbound respectively.
The optional new-value argument to slot-missing is used when the operation is attempting to set
the value of the slot.
Ifslot-missing returns, its values will be treated as follows:
If the operation issetf orslot-makunbound , any values will be ignored by the caller.
If the operation isslot-value , only the primary value will be used by the caller, and all other
values will be ignored.
If the operation isslot-boundp , any boolean equivalent of the primary value of the method
might be is used, and all other values will be ignored.
Objects 7–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
The default method onslot-missing signals an error of typeerror .
See Also:
defclass ,slot-exists-p ,slot-value
Notes:
The set of arguments (including the class of the instance) facilitates dening methods on the
metaclass for slot-missing .
slot-unbound Standard Generic Function
Syntax:
slot-unbound class instance slot-name !f resultg*
Method Signatures:
slot-unbound (classt)instance slot-name
Arguments and Values:
class|the class of the instance .
instance |the instance in which an attempt was made to read theunbound slot .
slot-name |the name of the unbound slot .
result |an object .
Description:
The generic function slot-unbound is called when an unbound slotis read in an instance whose
metaclass is standard-class . The default method signals an error of typeunbound-slot . The name
slot of the unbound-slot condition is initialized to the name of the oending variable, and the
instance slot of the unbound-slot condition is initialized to the oending instance.
The generic function slot-unbound is not intended to be called by programmers. Programmers
may write methods for it. The functionslot-unbound is called only indirectly by slot-value .
Ifslot-unbound returns, only the primary value will be used by the caller, and all other values will
be ignored.
Exceptional Situations:
The default method onslot-unbound signals an error of typeunbound-slot .
See Also:
slot-makunbound
7–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
An unbound slotmay occur if no :initform form was specied for the slotand the slotvalue has
not been set, or if slot-makunbound has been called on the slot.
slot-value Function
Syntax:
slot-value object slot-name !value
Arguments and Values:
object |an object .
name |asymbol .
value |an object .
Description:
The function slot-value returns the value of the slotnamed slot-name in the object . If there is no
slotnamed slot-name ,slot-missing is called. If the slotis unbound, slot-unbound is called.
The macro setf can be used with slot-value to change the value of a slot.
Examples:
(defclass foo ()
((a :accessor foo-a :initarg :a :initform 1)
(b :accessor foo-b :initarg :b)
(c :accessor foo-c :initform 3)))
!#<STANDARD-CLASS FOO 244020371>
(setq foo1 (make-instance ’foo :a ’one :b ’two))
!#<FOO 36325624>
(slot-value foo1 ’a) !ONE
(slot-value foo1 ’b) !TWO
(slot-value foo1 ’c) !3
(setf (slot-value foo1 ’a) ’uno) !UNO
(slot-value foo1 ’a) !UNO
(defmethod foo-method ((x foo))
(slot-value x ’a))
!#<STANDARD-METHOD FOO-METHOD (FOO) 42720573>
(foo-method foo1) !UNO
Objects 7–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
If an attempt is made to read a slotand no slotof the name slot-name exists in the object ,
slot-missing is called as follows:
(slot-missing (class-of instance )
instance
slot-name
’slot-value)
(Ifslot-missing is invoked, its primary value is returned by slot-value .)
If an attempt is made to write a slotand no slotof the name slot-name exists in the object ,
slot-missing is called as follows:
(slot-missing (class-of instance )
instance
slot-name
’setf
new-value )
(Ifslot-missing returns in this case, any values are ignored.)
The specic behavior depends on object 'smetaclass . An error is never signaled if object has
metaclass standard-class . An error is always signaled if object hasmetaclass built-in-class . The
consequences are unspecied if object has any other metaclass {an error might or might not be
signaled in this situation. Note in particular that the behavior for conditions and structures is not
specied.
See Also:
slot-missing ,slot-unbound ,with-slots
Notes:
Although no implementation is required to do so, implementors are strongly encouraged to
implement the function slot-value using the function slot-value-using-class described in the
Metaobject Protocol .
Implementations may optimize slot-value by compiling it inline.
method-qualiﬁers Standard Generic Function
Syntax:
method-qualiﬁers method!qualiers
7–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Method Signatures:
method-qualiﬁers (methodstandard-method )
Arguments and Values:
method |amethod .
qualiers |aproper list .
Description:
Returns a listof the qualiers of the method .
Examples:
(defmethod some-gf :before ((a integer)) a)
!#<STANDARD-METHOD SOME-GF (:BEFORE) (INTEGER) 42736540>
(method-qualifiers *) !(:BEFORE)
See Also:
deﬁne-method-combination
no-applicable-method Standard Generic Function
Syntax:
no-applicable-method generic-function &rest function-arguments !f resultg*
Method Signatures:
no-applicable-method (generic-function t)
&rest function-arguments
Arguments and Values:
generic-function |ageneric function on which no applicable method was found.
function-arguments |arguments to the generic-function .
result |an object .
Description:
The generic function no-applicable-method is called when a generic function is invoked and no
method on that generic function is applicable. The default method signals an error.
The generic function no-applicable-method is not intended to be called by programmers.
Programmers may write methods for it.
Objects 7–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
The default method signals an error of typeerror .
See Also:
no-next-method Standard Generic Function
Syntax:
no-next-method generic-function method &rest args!f resultg*
Method Signatures:
no-next-method (generic-function standard-generic-function )
(methodstandard-method )
&rest args
Arguments and Values:
generic-function {generic function to which method belongs.
method {method that contained the call to call-next-method for which there is no next method .
args { arguments to call-next-method .
result |an object .
Description:
The generic function no-next-method is called by call-next-method when there is no next
method .
The generic function no-next-method is not intended to be called by programmers. Programmers
may write methods for it.
Exceptional Situations:
The system-supplied method onno-next-method signals an error of typeerror .
See Also:
call-next-method
7–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
remove-method Standard Generic Function
Syntax:
remove-method generic-function method !generic-function
Method Signatures:
remove-method (generic-function standard-generic-function )
method
Arguments and Values:
generic-function |ageneric function .
method |amethod .
Description:
The generic function remove-method removes a method from generic-function by modifying the
generic-function (if necessary).
remove-method must not signal an error if the method is not one of the methods on the
generic-function .
See Also:
ﬁnd-method
make-instance Standard Generic Function
Syntax:
make-instance class&rest initargs&key &allow-other-keys !instance
Method Signatures:
make-instance (classstandard-class )&rest initargs
make-instance (classsymbol )&rest initargs
Arguments and Values:
class|aclass , or a symbol that names a class .
initargs |an initialization argument list .
instance |afresh instance ofclass class.
Objects 7–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
The generic function make-instance creates and returns a new instance of the given class.
If the second of the above methods is selected, that method invokesmake-instance on the
arguments (find-class class)and initargs .
The initialization arguments are checked within make-instance .
The generic function make-instance may be used as described in Section 7.1 (Object Creation and
Initialization).
Exceptional Situations:
If any of the initialization arguments has not been declared as valid, an error of typeerror is
signaled.
See Also:
defclass ,class-of ,allocate-instance ,initialize-instance , Section 7.1 (Object Creation and
Initialization)
make-instances-obsolete Standard Generic Function
Syntax:
make-instances-obsolete class!class
Method Signatures:
make-instances-obsolete (classstandard-class )
make-instances-obsolete (classsymbol )
Arguments and Values:
class|aclass designator .
Description:
The function make-instances-obsolete has the eect of initiating the process of updating the
instances of the class . During updating, the generic function update-instance-for-redeﬁned-class
will be invoked.
The generic function make-instances-obsolete is invoked automatically by the system when
defclass has been used to redene an existing standard class and the set of local slots accessible in
an instance is changed or the order of slots in storage is changed. It can also be explicitly invoked
by the user.
If the second of the above methods is selected, that method invokesmake-instances-obsolete on
(find-class class).
7–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
See Also:
update-instance-for-redeﬁned-class , Section 4.3.6 (Redening Classes)
make-load-form Standard Generic Function
Syntax:
make-load-form object&optional environment!creation-form [, initialization-form ]
Method Signatures:
make-load-form (objectstandard-object )&optional environment
make-load-form (objectstructure-object )&optional environment
make-load-form (objectcondition )&optional environment
make-load-form (objectclass )&optional environment
Arguments and Values:
object |an object .
environment |an environment object .
creation-form |aform .
initialization-form |aform .
Description:
The generic function make-load-form creates and returns one or two forms , acreation-form and an
initialization-form , that enable load to construct an object equivalent to object .Environment is an
environment object corresponding to the lexical environment in which the forms will be processed.
The le compiler callsmake-load-form to process certain classes ofliteral objects ; see Section
3.2.4.4 (Additional Constraints on Externalizable Objects).
Conforming programs may call make-load-form directly, providing object is ageneralized instance
ofstandard-object ,structure-object , orcondition .
The creation form is a form that, when evaluated at load time, should return an object that is
equivalent to object . The exact meaning of equivalent depends on the type ofobject and is up to
the programmer who denes a method formake-load-form ; see Section 3.2.4 (Literal Objects in
Compiled Files).
Objects 7–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-load-form
The initialization form is a form that, when evaluated at load time, should perform further
initialization of the object . The value returned by the initialization form is ignored. If
make-load-form returns only one value, the initialization form is nil, which has no eect. If object
appears as a constant in the initialization form, at load time it will be replaced by the equivalent
object constructed by the creation form; this is how the further initialization gains access to the
object .
Both the creation-form and the initialization-form may contain references to any externalizable
object . However, there must not be any circular dependencies in creation forms. An example of a
circular dependency is when the creation form for the object Xcontains a reference to the object Y,
and the creation form for the object Ycontains a reference to the object X. Initialization forms are
not subject to any restriction against circular dependencies, which is the reason that initialization
forms exist; see the example of circular data structures below.
The creation form for an object is always evaluated before the initialization form for that object .
When either the creation form or the initialization form references other objects that have not been
referenced earlier in the lebeing compiled , the compiler ensures that all of the referenced objects
have been created before evaluating the referencing form . When the referenced object is of a type
which the le compiler processes using make-load-form , this involves evaluating the creation form
returned for it. (This is the reason for the prohibition against circular references among creation
forms).
Each initialization form is evaluated as soon as possible after its associated creation form, as
determined by data ow. If the initialization form for an object does not reference any other objects
not referenced earlier in the leand processed by the le compiler usingmake-load-form , the
initialization form is evaluated immediately after the creation form. If a creation or initialization
formFdoes contain references to such objects , the creation forms for those other objects are
evaluated before F, and the initialization forms for those other objects are also evaluated before F
whenever they do not depend on the object created or initialized by F. Where these rules do not
uniquely determine an order of evaluation between two creation/initialization forms, the order of
evaluation is unspecied.
While these creation and initialization forms are being evaluated, the objects are possibly in an
uninitialized state, analogous to the state of an object between the time it has been created by
allocate-instance and it has been processed fully by initialize-instance . Programmers writing
methods formake-load-form must take care in manipulating objects not to depend on slots that
have not yet been initialized.
It is implementation-dependent whetherload callseval on the forms or does some other operation
that has an equivalent eect. For example, the forms might be translated into dierent but
equivalent forms and then evaluated, they might be compiled and the resulting functions called by
load, or they might be interpreted by a special-purpose function dierent from eval. All that is
required is that the eect be equivalent to evaluating the forms .
The method specialized onclass returns a creation form using the name of the class if the class
has a proper name inenvironment , signaling an error of typeerror if it does not have a proper
name .Evaluation of the creation form uses the name to nd the class with that name , as if by
7–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-load-form
callingﬁnd-class . If a class with that name has not been dened, then a class may be computed
in an implementation-dened manner. If a class cannot be returned as the result of evaluating the
creation form , then an error of typeerror is signaled.
Both conforming implementations and conforming programs may further specialize
make-load-form .
Examples:
(defclass obj ()
((x :initarg :x :reader obj-x)
(y :initarg :y :reader obj-y)
(dist :accessor obj-dist)))
!#<STANDARD-CLASS OBJ 250020030>
(defmethod shared-initialize :after ((self obj) slot-names &rest keys)
(declare (ignore slot-names keys))
(unless (slot-boundp self ’dist)
(setf (obj-dist self)
(sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))
!#<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714>
(defmethod make-load-form ((self obj) &optional environment)
(declare (ignore environment))
;; Note that this definition only works because X and Y do not
;; contain information which refers back to the object itself.
;; For a more general solution to this problem, see revised example below.
‘(make-instance ’,(class-of self)
:x ’,(obj-x self) :y ’,(obj-y self)))
!#<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>
(setq obj1 (make-instance ’obj :x 3.0 :y 4.0)) !#<OBJ 26274136>
(obj-dist obj1) !5.0
(make-load-form obj1) !(MAKE-INSTANCE ’OBJ :X ’3.0 :Y ’4.0)
In the above example, an equivalent instance ofobjis reconstructed by using the values of two of
itsslots. The value of the third slotis derived from those two values.
Another way to write the make-load-form method in that example is to use
make-load-form-saving-slots . The code it generates might yield a slightly dierent result
from the make-load-form method shown above, but the operational eect will be the same. For
example:
;; Redefine method defined above.
(defmethod make-load-form ((self obj) &optional environment)
(make-load-form-saving-slots self
:slot-names ’(x y)
:environment environment))
!#<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>
Objects 7–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-load-form
;; Try MAKE-LOAD-FORM on object created above.
(make-load-form obj1)
!(ALLOCATE-INSTANCE ’#<STANDARD-CLASS OBJ 250020030>),
(PROGN
(SETF (SLOT-VALUE ’#<OBJ 26274136> ’X) ’3.0)
(SETF (SLOT-VALUE ’#<OBJ 26274136> ’Y) ’4.0)
(INITIALIZE-INSTANCE ’#<OBJ 26274136>))
In the following example, instances ofmy-frob are \interned" in some way. An equivalent instance
is reconstructed by using the value of the name slot as a key for searching existing objects . In this
case the programmer has chosen to create a new object if no existing object is found; alternatively
an error could have been signaled in that case.
(defclass my-frob ()
((name :initarg :name :reader my-name)))
(defmethod make-load-form ((self my-frob) &optional environment)
(declare (ignore environment))
‘(find-my-frob ’,(my-name self) :if-does-not-exist :create))
In the following example, the data structure to be dumped is circular, because each parent has a
list of its children and each child has a reference back to its parent. If make-load-form is called
on one object in such a structure, the creation form creates an equivalent object and lls in the
children slot, which forces creation of equivalent objects for all of its children, grandchildren, etc.
At this point none of the parent slots have been lled in. The initialization form lls in the parent
slot, which forces creation of an equivalent object for the parent if it was not already created. Thus
the entire tree is recreated at load time. At compile time, make-load-form is called once for each
object in the tree. All of the creation forms are evaluated, in implementation-dependent order, and
then all of the initialization forms are evaluated, also in implementation-dependent order.
(defclass tree-with-parent () ((parent :accessor tree-parent)
(children :initarg :children)))
(defmethod make-load-form ((x tree-with-parent) &optional environment)
(declare (ignore environment))
(values
;; creation form
‘(make-instance ’,(class-of x) :children ’,(slot-value x ’children))
;; initialization form
‘(setf (tree-parent ’,x) ’,(slot-value x ’parent))))
In the following example, the data structure to be dumped has no special properties and an
equivalent structure can be reconstructed simply by reconstructing the slots' contents.
(defstruct my-struct a b c)
(defmethod make-load-form ((s my-struct) &optional environment)
(make-load-form-saving-slots s :environment environment))
7–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
The methods specialized onstandard-object ,structure-object , andcondition all signal an error
oftypeerror .
It is implementation-dependent whether callingmake-load-form on a generalized instance of a
system class signals an error or returns creation and initialization forms .
See Also:
compile-ﬁle ,make-load-form-saving-slots , Section 3.2.4.4 (Additional Constraints on Externaliz-
able Objects) Section 3.1 (Evaluation), Section 3.2 (Compilation)
Notes:
The le compiler callsmake-load-form in specic circumstances detailed in Section 3.2.4.4
(Additional Constraints on Externalizable Objects).
Some implementations may provide facilities for dening new subclasses ofclasses which are
specied as system classes . (Some likely candidates include generic-function ,method , and
stream ). Such implementations should document how the le compiler processes instances of
such classes when encountered as literal objects , and should document any relevant methods for
make-load-form .
make-load-form-saving-slots Function
Syntax:
make-load-form-saving-slots object&key slot-names environment
!creation-form, initialization-form
Arguments and Values:
object |an object .
slot-names |alist.
environment |an environment object .
creation-form |aform .
initialization-form |aform .
Description:
Returns forms that, when evaluated , will construct an object equivalent to object , without
executing initialization forms . The slots in the new object that correspond to initialized slots in
object are initialized using the values from object . Uninitialized slots inobject are not initialized
in the new object .make-load-form-saving-slots works for any instance ofstandard-object or
structure-object .
Objects 7–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Slot-names is alistof the names of the slots to preserve. If slot-names is not supplied, its value is
all of the local slots .
make-load-form-saving-slots returns two values, thus it can deal with circular structures. Whether
the result is useful in an application depends on whether the object 'stype and slot contents fully
capture the application's idea of the object 's state.
Environment is the environment in which the forms will be processed.
See Also:
make-load-form ,make-instance ,setf,slot-value ,slot-makunbound
Notes:
make-load-form-saving-slots can be useful in user-written make-load-form methods.
When the object is an instance ofstandard-object ,make-load-form-saving-slots could return a
creation form that callsallocate-instance and an initialization form that contains calls tosetf of
slot-value andslot-makunbound , though other functions of similar eect might actually be used.
with-accessors Macro
Syntax:
with-accessors (fslot-entryg*)instance-formfdeclarationg*fformg*
!f resultg*
slot-entry:: =(variable-name accessor-name )
Arguments and Values:
variable-name |avariable name ; not evaluated.
accessor-name |afunction name ; not evaluated.
instance-form |aform ; evaluated.
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values returned by the forms .
Description:
Creates a lexical environment in which the slots specied by slot-entry are lexically available
through their accessors as if they were variables. The macro with-accessors invokes the appropriate
accessors to access theslots specied by slot-entry . Bothsetfandsetq can be used to set the value
of the slot.
7–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-accessors
Examples:
(defclass thing ()
((x :initarg :x :accessor thing-x)
(y :initarg :y :accessor thing-y)))
!#<STANDARD-CLASS THING 250020173>
(defmethod (setf thing-x) :before (new-x (thing thing))
(format t "~&Changing X from ~D to ~D in ~S.~%"
(thing-x thing) new-x thing))
(setq thing1 (make-instance ’thing :x 1 :y 2)) !#<THING 43135676>
(setq thing2 (make-instance ’thing :x 7 :y 8)) !#<THING 43147374>
(with-accessors ((x1 thing-x) (y1 thing-y))
thing1
(with-accessors ((x2 thing-x) (y2 thing-y))
thing2
(list (list x1 (thing-x thing1) y1 (thing-y thing1)
x2 (thing-x thing2) y2 (thing-y thing2))
(setq x1 (+ y1 x2))
(list x1 (thing-x thing1) y1 (thing-y thing1)
x2 (thing-x thing2) y2 (thing-y thing2))
(setf (thing-x thing2) (list x1))
(list x1 (thing-x thing1) y1 (thing-y thing1)
x2 (thing-x thing2) y2 (thing-y thing2)))))
.Changing X from 1 to 9 in #<THING 43135676>.
.Changing X from 7 to (9) in #<THING 43147374>.
!((1 1 2 2 7 7 8 8)
9
(9 9 2 2 7 7 8 8)
(9)
(9 9 2 2 (9) (9) 8 8))
Aﬀected By:
defclass
Exceptional Situations:
The consequences are undened if any accessor-name is not the name of an accessor for the instance .
See Also:
with-slots ,symbol-macrolet
Notes:
Awith-accessors expression of the form:
(with-accessors (slot-entry1:::slot-entryn)instance-form form1:::formk)
Objects 7–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
expands into the equivalent of
(let ((ininstance-form ))
(symbol-macrolet ( Q1:::Qn)form1:::formk))
where Qiis
(variable-name i()(accessor-name iin))
with-slots Macro
Syntax:
with-slots (fslot-entryg*)instance-formfdeclarationg*fformg*
!f resultg*
slot-entry:: =slot-namej(variable-name slot-name )
Arguments and Values:
slot-name |aslot name ; not evaluated.
variable-name |avariable name ; not evaluated.
instance-form |aform ; evaluted to produce instance .
instance |an object .
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values returned by the forms .
Description:
The macro with-slots establishes alexical environment for referring to the slots in the instance
named by the given slot-names as though they were variables . Within such a context the value of
theslotcan be specied by using its slot name, as if it were a lexically bound variable. Both setf
andsetq can be used to set the value of the slot.
The macro with-slots translates an appearance of the slot name as a variable into a call to
slot-value .
Examples:
(defclass thing ()
7–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-slots
((x :initarg :x :accessor thing-x)
(y :initarg :y :accessor thing-y)))
!#<STANDARD-CLASS THING 250020173>
(defmethod (setf thing-x) :before (new-x (thing thing))
(format t "~&Changing X from ~D to ~D in ~S.~%"
(thing-x thing) new-x thing))
(setq thing (make-instance ’thing :x 0 :y 1)) !#<THING 62310540>
(with-slots (x y) thing (incf x) (incf y)) !2
(values (thing-x thing) (thing-y thing)) !1, 2
(setq thing1 (make-instance ’thing :x 1 :y 2)) !#<THING 43135676>
(setq thing2 (make-instance ’thing :x 7 :y 8)) !#<THING 43147374>
(with-slots ((x1 x) (y1 y))
thing1
(with-slots ((x2 x) (y2 y))
thing2
(list (list x1 (thing-x thing1) y1 (thing-y thing1)
x2 (thing-x thing2) y2 (thing-y thing2))
(setq x1 (+ y1 x2))
(list x1 (thing-x thing1) y1 (thing-y thing1)
x2 (thing-x thing2) y2 (thing-y thing2))
(setf (thing-x thing2) (list x1))
(list x1 (thing-x thing1) y1 (thing-y thing1)
x2 (thing-x thing2) y2 (thing-y thing2)))))
.Changing X from 7 to (9) in #<THING 43147374>.
!((1 1 2 2 7 7 8 8)
9
(9 9 2 2 7 7 8 8)
(9)
(9 9 2 2 (9) (9) 8 8))
Aﬀected By:
defclass
Exceptional Situations:
The consequences are undened if any slot-name is not the name of a slotin the instance .
See Also:
with-accessors ,slot-value ,symbol-macrolet
Notes:
Awith-slots expression of the form:
(with-slots (slot-entry1:::slot-entryn)instance-form form1:::formk)
expands into the equivalent of
Objects 7–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(let ((ininstance-form ))
(symbol-macrolet ( Q1:::Qn)form1:::formk))
where Qiis
(slot-entryi()(slot-value in'slot-entryi))
ifslot-entryiis asymbol and is
(variable-name i()(slot-value in'slot-name i))
ifslot-entryiis of the form
(variable-name islot-name i)
defclass Macro
Syntax:
defclass class-name (fsuperclass-nameg*) (fslot-specierg*)[ [#class-option ] ]
!new-class
slot-specier ::=slot-namej(slot-name [ [#slot-option ] ])
slot-name ::=symbol
slot-option ::=f:reader reader-function-name g*j
f:writer writer-function-name g*j
f:accessor reader-function-name g*j
f:allocation allocation-typegj
f:initarg initarg-nameg*j
f:initform formgj
f:type type-speciergj
f:documentation stringg
function-name ::=fsymbolj(setf symbol)g
class-option ::=(:default-initargs . initarg-list )j
(:documentation string )j
(:metaclass class-name )
7–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defclass
Arguments and Values:
Class-name |anon-nil symbol .
Superclass-name {anon-nil symbol .
Slot-name {asymbol . The slot-name argument is a symbol that is syntactically valid for use as a
variable name.
Reader-function-name |anon-nil symbol .:reader can be supplied more than once for a given slot.
Writer-function-name |ageneric function name.:writer can be supplied more than once for a
given slot.
Reader-function-name |anon-nil symbol .:accessor can be supplied more than once for a given
slot.
Allocation-type |(member :instance :class ).:allocation can be supplied once at most for a given
slot.
Initarg-name |asymbol .:initarg can be supplied more than once for a given slot.
Form |aform .:init-form can be supplied once at most for a given slot.
Type-specier |atype specier .:type can be supplied once at most for a given slot.
Class-option | refers to the class as a whole or to all class slots.
Initarg-list |alistof alternating initialization argument names and default initial value forms .
:default-initargs can be supplied at most once.
Class-name |anon-nil symbol .:metaclass can be supplied once at most.
new-class |the new class object .
Description:
The macro defclass denes a new named class . It returns the new class object as its result.
The syntax of defclass provides options for specifying initialization arguments for slots, for
specifying default initialization values for slots, and for requesting that methods on specied
generic functions be automatically generated for reading and writing the values of slots. No reader
or writer functions are dened by default; their generation must be explicitly requested. However,
slots can always be accessed usingslot-value .
Dening a new class also causes a type of the same name to be dened. The predicate
(typep object class-name )returns true if the class of the given object is the class named by
class-name itself or a subclass of the class class-name . Aclass object can be used as a type specier .
Thus(typep object class )returns true if the class of the object isclass itself or a subclass of class.
The class-name argument species the proper name of the new class . If a class with the same
Objects 7–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defclass
proper name already exists and that class is an instance ofstandard-class , and if the defclass
form for the denition of the new class species a class ofclassstandard-class , the existing class
is redened, and instances of it (and its subclasses ) are updated to the new denition at the time
that they are next accessed . For details, see Section 4.3.6 (Redening Classes).
Each superclass-name argument species a direct superclass of the new class . If the superclass list
is empty, then the superclass defaults depending on the metaclass , withstandard-object being the
default for standard-class .
The new class will inherit slots and methods from each of its direct superclasses , from their direct
superclasses , and so on. For a discussion of how slots and methods are inherited, see Section 4.3.4
(Inheritance).
The following slot options are available:
The:reader slot option species that an unqualied method is to be dened on the generic
function named reader-function-name to read the value of the given slot.
The:writer slot option species that an unqualied method is to be dened on the generic
function named writer-function-name to write the value of the slot.
The:accessor slot option species that an unqualied method is to be dened on
the generic function named reader-function-name to read the value of the given slot
and that an unqualied method is to be dened on the generic function named
(setf reader-function-name )to be used with setf to modify the value of the slot.
The:allocation slot option is used to specify where storage is to be allocated for the given
slot. Storage for a slotcan be located in each instance or in the class object itself. The
value of the allocation-type argument can be either the keyword :instance or the keyword
:class . If the:allocation slot option is not specied, the eect is the same as specifying
:allocation :instance .
{ If allocation-type is:instance , alocal slot of the name slot-name is allocated in
each instance of the class .
{ If allocation-type is:class , a shared slotof the given name is allocated in the
class object created by this defclass form. The value of the slotis shared by all
instances of the class . If a class C1denes such a shared slot , any subclass C2of
C1will share this single slotunless the defclass form forC2species a slotof the
same name or there is a superclass of C2that precedes C1in the class precedence
list ofC2and that denes a slotof the same name .
The:initform slot option is used to provide a default initial value form to be used in the
initialization of the slot. This form is evaluated every time it is used to initialize the slot.
The lexical environment in which this form is evaluated is the lexical environment in which
thedefclass form was evaluated. Note that the lexical environment refers both to variables
7–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defclass
and to functions. For local slots , the dynamic environment is the dynamic environment in
whichmake-instance is called; for shared slots, the dynamic environment is the dynamic
environment in which the defclass form was evaluated. See Section 7.1 (Object Creation
and Initialization).
No implementation is permitted to extend the syntax of defclass to allow (slot-name form )
as an abbreviation for (slot-name :initform form).
The:initarg slot option declares an initialization argument named initarg-name and
species that this initialization argument initializes the given slot. If the initialization
argument has a value in the call to initialize-instance , the value will be stored into
the given slot, and the slot's :initform slot option, if any, is not evaluated. If none of
the initialization arguments specied for a given slothas a value, the slotis initialized
according to the :initform slot option, if specied.
The:type slot option species that the contents of the slotwill always be of the specied
data type. It eectively declares the result type of the reader generic function when
applied to an object of this class . The consequences of attempting to store in a slota value
that does not satisfy the type of the slotare undened. The :type slot option is further
discussed in Section 7.5.3 (Inheritance of Slots and Slot Options).
The:documentation slot option provides a documentation string for the slot.:documentation
can be supplied once at most for a given slot.
Each class option is an option that refers to the class as a whole. The following class options are
available:
The:default-initargs class option is followed by a list of alternating initialization
argument names and default initial value forms. If any of these initialization arguments
does not appear in the initialization argument list supplied to make-instance , the
corresponding default initial value form is evaluated, and the initialization argument name
and the form 's value are added to the end of the initialization argument list before the
instance is created; see Section 7.1 (Object Creation and Initialization). The default initial
value form is evaluated each time it is used. The lexical environment in which this form
is evaluated is the lexical environment in which the defclass form was evaluated. The
dynamic environment is the dynamic environment in which make-instance was called.
If an initialization argument name appears more than once in a :default-initargs class
option, an error is signaled.
The:documentation class option causes a documentation string to be attached with the
class object , and attached with kind type to the class-name .:documentation can be
supplied once at most.
The:metaclass class option is used to specify that instances of the class being dened
are to have a dierent metaclass than the default provided by the system (the class
standard-class ).
Objects 7–63
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defclass
Note the following rules of defclass forstandard classes :
It is not required that the superclasses of a class be dened before the defclass form for
that class is evaluated.
All the superclasses of aclass must be dened before an instance of the class can be made.
Aclass must be dened before it can be used as a parameter specializer in a defmethod
form.
The object system can be extended to cover situations where these rules are not obeyed.
Some slot options are inherited by a class from its superclasses , and some can be shadowed
or altered by providing a local slot description. No class options except :default-initargs are
inherited. For a detailed description of how slots and slot options are inherited, see Section 7.5.3
(Inheritance of Slots and Slot Options).
The options to defclass can be extended. It is required that all implementations signal an error if
they observe a class option or a slot option that is not implemented locally.
It is valid to specify more than one reader, writer, accessor, or initialization argument for a slot.
No other slot option can appear more than once in a single slot description, or an error is signaled.
If no reader, writer, or accessor is specied for a slot, the slotcan only be accessed by the function
slot-value .
If adefclass form appears as a top level form , the compiler must make the class name be
recognized as a valid type name in subsequent declarations (as for deftype ) and be recognized as
a valid class name fordefmethod parameter specializers and for use as the :metaclass option of
a subsequent defclass . The compiler must make the class denition available to be returned by
ﬁnd-class when its environment argument is a value received as the environment parameter of a
macro .
Exceptional Situations:
If there are any duplicate slot names, an error of typeprogram-error is signaled.
If an initialization argument name appears more than once in :default-initargs class option, an
error of typeprogram-error is signaled.
If any of the following slot options appears more than once in a single slot description, an error of
typeprogram-error is signaled: :allocation ,:initform ,:type ,:documentation .
It is required that all implementations signal an error of typeprogram-error if they observe a class
option or a slot option that is not implemented locally.
See Also:
documentation ,initialize-instance ,make-instance ,slot-value , Section 4.3 (Classes), Section 4.3.4
(Inheritance), Section 4.3.6 (Redening Classes), Section 4.3.5 (Determining the Class Precedence
7–64 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
List), Section 7.1 (Object Creation and Initialization)
defgeneric Macro
Syntax:
defgeneric function-name gf-lambda-list [ [#optionjf#method-description g*] ]
!new-generic
option:: =(:argument-precedence-order fparameter-nameg+)j
(declarefgf-declarationg+)j
(:documentation gf-documentation )j
(:method-combination method-combination fmethod-combination-argument g*)j
(:generic-function-class generic-function-class )j
(:method-class method-class )
method-description:: =(:methodfmethod-qualierg*specialized-lambda-list
[ [fdeclarationg*jdocumentation ] ]fformg*)Arguments and Values:
function-name |afunction name .
generic-function-class |anon-nil symbol naming a class .
gf-declaration |anoptimize declaration specier ; other declaration speciers are not permitted.
gf-documentation |astring ; not evaluated.
gf-lambda-list |ageneric function lambda list .
method-class |anon-nil symbol naming a class .
method-combination-argument |an object.
method-combination-name |asymbol naming a method combination type .
method-qualiers ,specialized-lambda-list ,declarations ,documentation ,forms |as perdefmethod .
new-generic |the generic function object .
parameter-name |a symbol that names a required parameter in the lambda-list . (If the
:argument-precedence-order option is specied, each required parameter in the lambda-list must be
used exactly once as a parameter-name .)
Objects 7–65
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defgeneric
Description:
The macro defgeneric is used to dene a generic function or to specify options and declarations
that pertain to a generic function as a whole.
Iffunction-name is a listit must be of the form (setf symbol). If(fboundp function-name )is
false, a new generic function is created. If (fdefinition function-name )is ageneric function , that
generic function is modied. If function-name names an ordinary function , amacro , or a special
operator , an error is signaled.
The eect of the defgeneric macro is as if the following three steps were performed: rst, methods
dened by previous defgeneric forms are removed; second, ensure-generic-function is called; and
nally, methods specied by the current defgeneric form are added to the generic function .
Each method-description denes a method on the generic function . The lambda list of each method
must be congruent with the lambda list specied by the gf-lambda-list option. If no method
descriptions are specied and a generic function of the same name does not already exist, a generic
function with no methods is created.
The gf-lambda-list argument of defgeneric species the shape of lambda lists for the methods on
this generic function . All methods on the resulting generic function must have lambda lists that
are congruent with this shape. If a defgeneric form is evaluated and some methods for that generic
function have lambda lists that are not congruent with that given in the defgeneric form, an error
is signaled. For further details on method congruence, see Section 7.6.4 (Congruent Lambda-lists
for all Methods of a Generic Function).
The generic function passes to the method all the argument values passed to it, and only those;
default values are not supported. Note that optional and keyword arguments in method denitions,
however, can have default initial value forms and can use supplied-p parameters.
The following options are provided. Except as otherwise noted, a given option may occur only
once.
The:argument-precedence-order option is used to specify the order in which the required
arguments in a call to the generic function are tested for specicity when selecting a
particular method . Each required argument, as specied in the gf-lambda-list argument,
must be included exactly once as a parameter-name so that the full and unambiguous
precedence order is supplied. If this condition is not met, an error is signaled.
Thedeclare option is used to specify declarations that pertain to the generic function .
Anoptimize declaration specier is allowed. It species whether method selection should
be optimized for speed or space, but it has no eect on methods . To control how a method
is optimized, an optimize declaration must be placed directly in the defmethod form or
method description. The optimization qualities speed andspace are the only qualities
this standard requires, but an implementation can extend the object system to recognize
other qualities. A simple implementation that has only one method selection technique
and ignores optimize declaration speciers is valid.
7–66 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defgeneric
Thespecial ,ftype ,function ,inline ,notinline , anddeclaration declarations are not
permitted. Individual implementations can extend the declare option to support additional
declarations. If an implementation notices a declaration specier that it does not support
and that has not been proclaimed as a non-standard declaration identier name in a
declaration proclamation , it should issue a warning.
Thedeclare option may be specied more than once. The eect is the same as if the lists
ofdeclaration speciers had been appended together into a single list and specied as a
singledeclare option.
The:documentation argument is a documentation string to be attached to the generic
function object , and to be attached with kind function to the function-name .
The:generic-function-class option may be used to specify that the generic function
is to have a dierent class than the default provided by the system (the class
standard-generic-function ). The class-name argument is the name of a class that can
be the class of a generic function . If function-name species an existing generic function
that has a dierent value for the :generic-function-class argument and the new generic
function class is compatible with the old, change-class is called to change the class of the
generic function ; otherwise an error is signaled.
The:method-class option is used to specify that all methods on this generic function are to
have a dierent class from the default provided by the system (the classstandard-method ).
The class-name argument is the name of a class that is capable of being the class of a
method .
The:method-combination option is followed by a symbol that names a type of method
combination. The arguments (if any) that follow that symbol depend on the type of
method combination. Note that the standard method combination type does not support
any arguments. However, all types of method combination dened by the short form of
deﬁne-method-combination accept an optional argument named order , defaulting to
:most-specific-first , where a value of :most-specific-last reverses the order of the
primary methods without aecting the order of the auxiliary methods .
The method-description arguments dene methods that will be associated with the generic function .
The method-qualier and specialized-lambda-list arguments in a method description are the same as
fordefmethod .
The form arguments specify the method body. The body of the method is enclosed in an implicit
block . If function-name is a symbol , this block bears the same name as the generic function . If
function-name is alistof the form (setf symbol), the name of the block is symbol .
Implementations can extend defgeneric to include other options. It is required that an
implementation signal an error if it observes an option that is not implemented locally.
defgeneric is not required to perform any compile-time side eects. In particular, the methods
are not installed for invocation during compilation. An implementation may choose to store
Objects 7–67
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
information about the generic function for the purposes of compile-time error-checking (such as
checking the number of arguments on calls, or noting that a denition for the function name has
been seen).
Examples:
Exceptional Situations:
Iffunction-name names an ordinary function , amacro , or a special operator , an error of type
program-error is signaled.
Each required argument, as specied in the gf-lambda-list argument, must be included exactly once
as a parameter-name , or an error of typeprogram-error is signaled.
The lambda list of each method specied by a method-description must be congruent with the
lambda list specied by the gf-lambda-list option, or an error of typeerror is signaled.
If adefgeneric form is evaluated and some methods for that generic function have lambda lists
that are not congruent with that given in the defgeneric form, an error of typeerror is signaled.
A given option may occur only once, or an error of typeprogram-error is signaled.
Iffunction-name species an existing generic function that has a dierent value for the
:generic-function-class argument and the new generic function class is compatible with the old,
change-class is called to change the class of the generic function ; otherwise an error of typeerror
is signaled.
Implementations can extend defgeneric to include other options. It is required that an
implementation signal an error of typeprogram-error if it observes an option that is not
implemented locally.
See Also:
defmethod ,documentation ,ensure-generic-function ,generic-function , Section 7.6.4 (Congruent
Lambda-lists for all Methods of a Generic Function)
defmethod Macro
Syntax:
defmethod function-namefmethod-qualierg*specialized-lambda-list
[ [fdeclarationg*jdocumentation ] ]fformg*
!new-method
function-name ::=fsymbolj(setf symbol)g
7–68 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defmethod
method-qualier ::=non-list
specialized-lambda-list ::=(fvarj(varparameter-specializer-name )g*
[&optionalfvarj(var[initform [supplied-p-parameter ]])g*]
[&rest var]
[&keyfvarj(fvarj(keyword var)g[initform [supplied-p-parameter ]])g*
[&allow-other-keys ]]
[&auxfvarj(var[initform ] )g*])
parameter-specializer-name ::=symbolj(eqleql-specializer-form )
Arguments and Values:
declaration |adeclare expression ; not evaluated.
documentation |astring ; not evaluated.
var|avariable name .
eql-specializer-form |aform .
Form |aform .
Initform |aform .
Supplied-p-parameter |variable name.
new-method |the new method object .
Description:
The macro defmethod denes a method on a generic function .
If(fboundp function-name )isnil, ageneric function is created with default values for the argument
precedence order (each argument is more specic than the arguments to its right in the argument
list), for the generic function class (the classstandard-generic-function ), for the method class (the
classstandard-method ), and for the method combination type (the standard method combination
type). The lambda list of the generic function is congruent with the lambda list of the method
being dened; if the defmethod form mentions keyword arguments, the lambda list of the generic
function will mention &key (but no keyword arguments). If function-name names an ordinary
function , amacro , or a special operator , an error is signaled.
If ageneric function is currently named by function-name , the lambda list of the method must be
congruent with the lambda list of the generic function . If this condition does not hold, an error is
signaled. For a denition of congruence in this context, see Section 7.6.4 (Congruent Lambda-lists
for all Methods of a Generic Function).
Each method-qualier argument is an object that is used by method combination to identify the
given method . The method combination type might further restrict what a method qualier can
be. The standard method combination type allows for unqualied methods and methods whose sole
Objects 7–69
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defmethod
qualier is one of the keywords :before ,:after , or:around .
The specialized-lambda-list argument is like an ordinary lambda list except that the names of
required parameters can be replaced by specialized parameters. A specialized parameter is a
list of the form (varparameter-specializer-name ). Only required parameters can be specialized.
Ifparameter-specializer-name is a symbol it names a class ; if it is a list, it is of the form
(eql eql-specializer-form ). The parameter specializer name (eql eql-specializer-form )indicates that
the corresponding argument must be eqlto the object that is the value of eql-specializer-form for
themethod to be applicable. The eql-specializer-form is evaluated at the time that the expansion
of thedefmethod macro is evaluated. If no parameter specializer name is specied for a given
required parameter, the parameter specializer defaults to the classt. For further discussion, see
Section 7.6.2 (Introduction to Methods).
The form arguments specify the method body. The body of the method is enclosed in an implicit
block . Iffunction-name is asymbol , this block bears the same name as the generic function . If
function-name is alistof the form (setf symbol), the name of the block is symbol .
The class of the method object that is created is that given by the method class option of the
generic function on which the method is dened.
If the generic function already has a method that agrees with the method being dened on
parameter specializers and qualiers ,defmethod replaces the existing method with the one now
being dened. For a denition of agreement in this context. see Section 7.6.3 (Agreement on
Parameter Specializers and Qualiers).
The parameter specializers are derived from the parameter specializer names as described in
Section 7.6.2 (Introduction to Methods).
The expansion of the defmethod macro \refers to" each specialized parameter (see the description
ofignore within the description of declare ). This includes parameters that have an explicit
parameter specializer name oft. This means that a compiler warning does not occur if the body
of the method does not refer to a specialized parameter, while a warning might occur if the body
of the method does not refer to an unspecialized parameter. For this reason, a parameter that
specializes on tis not quite synonymous with an unspecialized parameter in this context.
Declarations at the head of the method body that apply to the method's lambda variables are
treated as bound declarations whose scope is the same as the corresponding bindings .
Declarations at the head of the method body that apply to the functional bindings of
call-next-method ornext-method-p apply to references to those functions within the method
body forms . Any outer bindings of the function names call-next-method andnext-method-p ,
and declarations associated with such bindings areshadowed 2within the method body forms .
The scope offree declarations at the head of the method body is the entire method body, which
includes any implicit local function denitions but excludes initialization forms for the lambda
variables .
defmethod is not required to perform any compile-time side eects. In particular, the methods
7–70 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
are not installed for invocation during compilation. An implementation may choose to store
information about the generic function for the purposes of compile-time error-checking (such as
checking the number of arguments on calls, or noting that a denition for the function name has
been seen).
Documentation is attached as a documentation string to the method object .
Aﬀected By:
The denition of the referenced generic function .
Exceptional Situations:
Iffunction-name names an ordinary function , amacro , or a special operator , an error of typeerror
is signaled.
If ageneric function is currently named by function-name , the lambda list of the method must be
congruent with the lambda list of the generic function , or an error of typeerror is signaled.
See Also:
defgeneric ,documentation , Section 7.6.2 (Introduction to Methods), Section 7.6.4 (Congruent
Lambda-lists for all Methods of a Generic Function), Section 7.6.3 (Agreement on Parameter
Specializers and Qualiers), Section 3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations)
ﬁnd-class Accessor
Syntax:
ﬁnd-class symbol&optional errorp environment !class
(setf (ﬁnd-class symbol&optional errorp environment )new-class)
Arguments and Values:
symbol |asymbol .
errorp |ageneralized boolean . The default is true.
environment { same as the &environment argument to macro expansion functions and is used
to distinguish between compile-time and run-time environments. The &environment argument
hasdynamic extent ; the consequences are undened if the &environment argument is referred to
outside the dynamic extent of the macro expansion function.
class|aclass object , ornil.
Objects 7–71
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returns the class object named by the symbol in the environment . If there is no such class ,nilis
returned if errorp isfalse; otherwise, if errorp istrue, an error is signaled.
The class associated with a particular symbol can be changed by using setf withﬁnd-class ; or, if
the new class given tosetfisnil, the class association is removed (but the class object itself is not
aected). The results are undened if the user attempts to change or remove the class associated
with a symbol that is dened as a type specier in this standard. See Section 4.3.7 (Integrating
Types and Classes).
When using setfofﬁnd-class , any errorp argument is evaluated for eect, but any values it returns
are ignored; the errorp parameter is permitted primarily so that the environment parameter can be
used.
The environment might be used to distinguish between a compile-time and a run-time environment.
Exceptional Situations:
If there is no such class and errorp istrue,ﬁnd-class signals an error of typeerror .
See Also:
defmacro , Section 4.3.7 (Integrating Types and Classes)
next-method-p Local Function
Syntax:
next-method-phno argumentsi ! generalized-boolean
Arguments and Values:
generalized-boolean |ageneralized boolean .
Description:
The locally dened function next-method-p can be used within the body forms (but not the
lambda list ) dened by a method-dening form to determine whether a next method exists.
The functionnext-method-p haslexical scope and indenite extent .
Whether or not next-method-p isfbound in the global environment isimplementation-dependent ;
however, the restrictions on redenition and shadowing ofnext-method-p are the same as for
symbols in theCOMMON-LISP package which are fbound in the global environment . The consequences
of attempting to use next-method-p outside of a method-dening form are undened.
See Also:
call-next-method ,defmethod ,call-method
7–72 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
call-method,make-method Local Macro
Syntax:
call-method method&optional next-method-list !f resultg*
make-method form!method-object
Arguments and Values:
method |amethod object , or a list(see below); not evaluated.
method-object |amethod object .
next-method-list |alistofmethod objects ; not evaluated.
results |the values returned by the method invocation.
Description:
The macro call-method is used in method combination. It hides the implementation-dependent
details of how methods are called. The macro call-method haslexical scope and can only be used
within an eective method form .
Whether or not call-method isfbound in the global environment isimplementation-dependent ;
however, the restrictions on redenition and shadowing ofcall-method are the same as for symbols
in theCOMMON-LISP package which are fbound in the global environment . The consequences of
attempting to use call-method outside of an eective method form are undened.
The macro call-method invokes the specied method , supplying it with arguments and with
denitions for call-next-method and fornext-method-p . If the invocation of call-method is
lexically inside of a make-method , the arguments are those that were supplied to that method.
Otherwise the arguments are those that were supplied to the generic function. The denitions of
call-next-method andnext-method-p rely on the specied next-method-list .
Ifmethod is alist, the rst element of the listmust be the symbol make-method and the second
element must be a form . Such a listspecies a method object whose method function has a body
that is the given form .
Next-method-list can contain method objects orlists, the rst element of which must be the symbol
make-method and the second element of which must be a form .
Those are the only two places where make-method can be used. The form used with make-method
is evaluated in the null lexical environment augmented with a local macro denition for call-method
and with bindings named by symbols not accessible from the COMMON-LISP-USER package .
Thecall-next-method function available to method will call the rst method innext-method-list .
Objects 7–73
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Thecall-next-method function available in that method , in turn, will call the second method in
next-method-list , and so on, until the list of next methods is exhausted.
Ifnext-method-list is not supplied, the call-next-method function available to method signals an
error of typecontrol-error and thenext-method-p function available to method returnsnil.
Examples:
See Also:
call-next-method ,deﬁne-method-combination ,next-method-p
call-next-method Local Function
Syntax:
call-next-method &rest args!f resultg*
Arguments and Values:
arg|an object .
results |the values returned by the method it calls.
Description:
The function call-next-method can be used within the body forms (but not the lambda list ) of a
method dened by a method-dening form to call the next method .
If there is no next method , the generic function no-next-method is called.
The type of method combination used determines which methods can invoke call-next-method .
The standard method combination type allows call-next-method to be used within primary
methods andaround methods . For generic functions using a type of method combination dened by
the short form of deﬁne-method-combination ,call-next-method can be used in around methods
only.
Whencall-next-method is called with no arguments, it passes the current method 's original
arguments to the next method . Neither argument defaulting, nor using setq, nor rebinding
variables with the same names as parameters of the method aects the values call-next-method
passes to the method it calls.
Whencall-next-method is called with arguments, the next method is called with those arguments.
Ifcall-next-method is called with arguments but omits optional arguments, the next method called
defaults those arguments.
The functioncall-next-method returns any values that are returned by the next method .
7–74 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The functioncall-next-method haslexical scope and indenite extent and can only be used within
the body of a method dened by a method-dening form .
Whether or not call-next-method isfbound in the global environment isimplementation-dependent ;
however, the restrictions on redenition and shadowing ofcall-next-method are the same as for
symbols in theCOMMON-LISP package which are fbound in the global environment . The consequences
of attempting to use call-next-method outside of a method-dening form are undened.
Aﬀected By:
defmethod ,call-method ,deﬁne-method-combination .
Exceptional Situations:
When providing arguments to call-next-method , the following rule must be satised or an error of
typeerror should be signaled: the ordered set of applicable methods for a changed set of arguments
forcall-next-method must be the same as the ordered set of applicable methods for the original
arguments to the generic function . Optimizations of the error checking are possible, but they must
not change the semantics of call-next-method .
See Also:
deﬁne-method-combination ,defmethod ,next-method-p ,no-next-method ,call-method ,
Section 7.6.6 (Method Selection and Combination), Section 7.6.6.2 (Standard Method Combination),
Section 7.6.6.4 (Built-in Method Combination Types)
compute-applicable-methods Standard Generic Function
Syntax:
compute-applicable-methods generic-function function-arguments !methods
Method Signatures:
compute-applicable-methods (generic-function standard-generic-function )
Arguments and Values:
generic-function |ageneric function .
function-arguments |alistof arguments for the generic-function .
methods |alistofmethod objects .
Description:
Given a generic-function and a set of function-arguments , the function compute-applicable-methods
returns the set of methods that are applicable for those arguments sorted according to precedence
order. See Section 7.6.6 (Method Selection and Combination).
Objects 7–75
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Aﬀected By:
defmethod
See Also:
Section 7.6.6 (Method Selection and Combination)
deﬁne-method-combination Macro
Syntax:
deﬁne-method-combination name [ [#short-form-option ] ]
!name
deﬁne-method-combination name lambda-list
(fmethod-group-specier g*)
[(:arguments . args-lambda-list )]
[(:generic-function generic-function-symbol )]
[ [fdeclarationg*jdocumentation ] ]
fformg*
!name
short-form-option:: =:documentation documentationj
:identity-with-one-argument identity-with-one-argument j
:operator operator
method-group-specier:: =(nameffqualier-patterng+jpredicateg[ [#long-form-option ] ])
long-form-option:: =:description descriptionj
:order orderj
:required required-p
Arguments and Values:
args-lambda-list |adene-method-combination arguments lambda list .
declaration |adeclare expression ; not evaluated.
description |aformat control .
documentation |astring ; not evaluated.
forms |an implicit progn that must compute and return the form that species how the methods
are combined, that is, the eective method .
7–76 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination
generic-function-symbol |asymbol .
identity-with-one-argument |ageneralized boolean .
lambda-list |ordinary lambda list .
name |asymbol . Non- keyword ,non-nil symbols are usually used.
operator |an operator .Name and operator are often the same symbol . This is the default, but it
is not required.
order |:most-specific-first or:most-specific-last ; evaluated.
predicate |asymbol that names a function of one argument that returns a generalized boolean .
qualier-pattern |alist, or the symbol*.
required-p |ageneralized boolean .
Description:
The macro deﬁne-method-combination is used to dene new types of method combination.
There are two forms of deﬁne-method-combination . The short form is a simple facility for the
cases that are expected to be most commonly needed. The long form is more powerful but more
verbose. It resembles defmacro in that the body is an expression, usually using backquote, that
computes a form . Thus arbitrary control structures can be implemented. The long form also allows
arbitrary processing of method qualiers .
Short Form
The short form syntax of deﬁne-method-combination is recognized when the sec-
ond subform is a non-nil symbol or is not present. When the short form is
used, name is dened as a type of method combination that produces a Lisp form
(operator method-call method-call :::). The operator is asymbol that can be the name of
afunction ,macro , orspecial operator . The operator can be supplied by a keyword option;
it defaults to name .
Keyword options for the short form are the following:
The:documentation option is used to document the method-combination type; see
description of long form below.
The:identity-with-one-argument option enables an optimization when its value
istrue (the default is false). If there is exactly one applicable method and it is a
primary method, that method serves as the eective method and operator is not
called. This optimization avoids the need to create a new eective method and
avoids the overhead of a function call. This option is designed to be used with
operators such as progn ,and,+, andmax.
Objects 7–77
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination
The:operator option species the name of the operator. The operator argument
is asymbol that can be the name of a function ,macro , orspecial form .
These types of method combination require exactly one qualier per method. An error is
signaled if there are applicable methods with no qualiers or with qualiers that are not
supported by the method combination type.
A method combination procedure dened in this way recognizes two roles for methods.
A method whose one qualier is the symbol naming this type of method combination is
dened to be a primary method. At least one primary method must be applicable or an
error is signaled. A method with :around as its one qualier is an auxiliary method that
behaves the same as an around method in standard method combination. The function
call-next-method can only be used in around methods ; it cannot be used in primary
methods dened by the short form of the deﬁne-method-combination macro.
A method combination procedure dened in this way accepts an optional argument named
order , which defaults to :most-specific-first . A value of :most-specific-last reverses
the order of the primary methods without aecting the order of the auxiliary methods.
The short form automatically includes error checking and support for around methods .
For a discussion of built-in method combination types, see Section 7.6.6.4 (Built-in Method
Combination Types).
Long Form
The long form syntax of deﬁne-method-combination is recognized when the second
subform is a list.
The lambda-list receives any arguments provided after the name of the method combination
type in the :method-combination option to defgeneric .
A list of method group speciers follows. Each specier selects a subset of the applicable
methods to play a particular role, either by matching their qualiers against some patterns
or by testing their qualiers with a predicate . These method group speciers dene all
method qualiers that can be used with this type of method combination.
The carof each method-group-specier is asymbol which names avariable . During the
execution of the forms in the body of deﬁne-method-combination , this variable is bound
to a list of the methods in the method group. The methods in this list occur in the order
specied by the :order option.
Ifqualier-pattern is a symbol it must be *. A method matches a qualier-pattern if the
method's list of qualiers isequal to the qualier-pattern (except that the symbol *in a
qualier-pattern matches anything). Thus a qualier-pattern can be one of the following: the
empty list , which matches unqualied methods ; the symbol *, which matches all methods;
a true list, which matches methods with the same number of qualiers as the length of the
list when each qualier matches the corresponding list element; or a dotted list that ends
7–78 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination
in the symbol *(the*matches any number of additional qualiers ).
Each applicable method is tested against the qualier-patterns and predicates in left-to-right
order. As soon as a qualier-pattern matches or a predicate returns true, the method
becomes a member of the corresponding method group and no further tests are made.
Thus if a method could be a member of more than one method group, it joins only the
rst such group. If a method group has more than one qualier-pattern , a method need
only satisfy one of the qualier-patterns to be a member of the group.
The name of a predicate function can appear instead of qualier-patterns in a method group
specier. The predicate is called for each method that has not been assigned to an earlier
method group; it is called with one argument, the method's qualier list . The predicate
should return true if the method is to be a member of the method group. A predicate can
be distinguished from a qualier-pattern because it is a symbol other than nilor*.
If there is an applicable method that does not fall into any method group, the function
invalid-method-error is called.
Method group speciers can have keyword options following the qualier patterns or
predicate. Keyword options can be distinguished from additional qualier patterns because
they are neither lists nor the symbol *. The keyword options are as follows:
The:description option is used to provide a description of the role of methods in
the method group. Programming environment tools use (apply #’format stream
format-control (method-qualifiers method))to print this description, which is
expected to be concise. This keyword option allows the description of a method
qualier to be dened in the same module that denes the meaning of the method
qualier . In most cases, format-control will not contain any format directives,
but they are available for generality. If :description is not supplied, a default
description is generated based on the variable name and the qualier patterns and
on whether this method group includes the unqualied methods .
The:order option species the order of methods. The order argument is a form
that evaluates to :most-specific-first or:most-specific-last . If it evaluates
to any other value, an error is signaled. If :order is not supplied, it defaults to
:most-specific-first .
The:required option species whether at least one method in this method group
is required. If its value is true and the method group is empty (that is, no
applicable methods match the qualier patterns or satisfy the predicate), an error
is signaled. If :required is not supplied, it defaults to nil.
The use of method group speciers provides a convenient syntax to select methods, to
divide them among the possible roles, and to perform the necessary error checking. It
is possible to perform further ltering of methods in the body forms by using normal
list-processing operations and the functions method-qualiﬁers andinvalid-method-error .
It is permissible to use setq on the variables named in the method group speciers and
Objects 7–79
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination
to bind additional variables. It is also possible to bypass the method group specier
mechanism and do everything in the body forms . This is accomplished by writing a single
method group with *as its only qualier-pattern ; the variable is then bound to a listof all
of the applicable methods , in most-specic-rst order.
The body forms compute and return the form that species how the methods are
combined, that is, the eective method. The eective method is evaluated in the null
lexical environment augmented with a local macro denition for call-method and with
bindings named by symbols not accessible from the COMMON-LISP-USER package . Given
a method object in one of the lists produced by the method group speciers and a list
of next methods, call-method will invoke the method such that call-next-method has
available the next methods.
When an eective method has no eect other than to call a single method, some
implementations employ an optimization that uses the single method directly as the
eective method, thus avoiding the need to create a new eective method. This
optimization is active when the eective method form consists entirely of an invocation
of thecall-method macro whose rst subform is a method object and whose second
subform isnilor unsupplied. Each deﬁne-method-combination body is responsible for
stripping o redundant invocations of progn ,and,multiple-value-prog1 , and the like, if
this optimization is desired.
The list (:arguments . lambda-list )can appear before any declarations or documentation
string . This form is useful when the method combination type performs some specic
behavior as part of the combined method and that behavior needs access to the arguments
to the generic function . Each parameter variable dened by lambda-list is bound to a
form that can be inserted into the eective method. When this form is evaluated during
execution of the eective method, its value is the corresponding argument to the generic
function ; the consequences of using such a form as the place in asetf form are undened.
Argument correspondence is computed by dividing the :arguments lambda-list and the
generic function lambda-list into three sections: the required parameters , the optional
parameters , and the keyword and rest parameters . The arguments supplied to the generic
function for a particular callare also divided into three sections; the required arguments
section contains as many arguments as the generic function hasrequired parameters ,
the optional arguments section contains as many arguments as the generic function has
optional parameters , and the keyword/rest arguments section contains the remaining
arguments. Each parameter in the required and optional sections of the :arguments
lambda-list accesses the argument at the same position in the corresponding section of the
arguments . If the section of the :arguments lambda-list is shorter, extra arguments are
ignored. If the section of the :arguments lambda-list is longer, excess required parameters
are bound to forms that evaluate to niland excess optional parameters arebound to their
initforms. The keyword parameters and rest parameters in the:arguments lambda-list
access the keyword/rest section of the arguments . If the :arguments lambda-list contains
&key , it behaves as if it also contained &allow-other-keys .
In addition, &whole varcan be placed rst in the :arguments lambda-list . It causes varto
7–80 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination
bebound to a form that evaluates to a listof all of the arguments supplied to the generic
function . This is dierent from &rest because it accesses all of the arguments, not just the
keyword/rest arguments .
Erroneous conditions detected by the body should be reported with
method-combination-error orinvalid-method-error ; these functions add any nec-
essary contextual information to the error message and will signal the appropriate
error.
The body forms are evaluated inside of the bindings created by the lambda list and method
group speciers. Declarations at the head of the body are positioned directly inside of
bindings created by the lambda list and outside of the bindings of the method group
variables. Thus method group variables cannot be declared in this way. locally may be
used around the body, however.
Within the body forms ,generic-function-symbol is bound to the generic function object .
Documentation is attached as a documentation string toname (as kind
method-combination ) and to the method combination object .
Note that two methods with identical specializers, but with dierent qualiers , are not
ordered by the algorithm described in Step 2 of the method selection and combination
process described in Section 7.6.6 (Method Selection and Combination). Normally the two
methods play dierent roles in the eective method because they have dierent qualiers ,
and no matter how they are ordered in the result of Step 2, the eective method is the
same. If the two methods play the same role and their order matters, an error is signaled.
This happens as part of the qualier pattern matching in deﬁne-method-combination .
If adeﬁne-method-combination form appears as a top level form , the compiler must make
themethod combination name be recognized as a valid method combination name in subsequent
defgeneric forms . However, the method combination is executed no earlier than when the
deﬁne-method-combination form is executed, and possibly as late as the time that generic
functions that use the method combination are executed.
Examples:
Most examples of the long form of deﬁne-method-combination also illustrate the use of the
related functions that are provided as part of the declarative method combination facility.
;;; Examples of the short form of define-method-combination
(define-method-combination and :identity-with-one-argument t)
(defmethod func and ((x class1) y) ...)
;;; The equivalent of this example in the long form is:
(define-method-combination and
Objects 7–81
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination
(&optional (order :most-specific-first))
((around (:around))
(primary (and) :order order :required t))
(let ((form (if (rest primary)
‘(and ,@(mapcar #’(lambda (method)
‘(call-method ,method))
primary))
‘(call-method ,(first primary)))))
(if around
‘(call-method ,(first around)
(,@(rest around)
(make-method ,form)))
form)))
;;; Examples of the long form of define-method-combination
;The default method-combination technique
(define-method-combination standard ()
((around (:around))
(before (:before))
(primary () :required t)
(after (:after)))
(flet ((call-methods (methods)
(mapcar #’(lambda (method)
‘(call-method ,method))
methods)))
(let ((form (if (or before after (rest primary))
‘(multiple-value-prog1
(progn ,@(call-methods before)
(call-method ,(first primary)
,(rest primary)))
,@(call-methods (reverse after)))
‘(call-method ,(first primary)))))
(if around
‘(call-method ,(first around)
(,@(rest around)
(make-method ,form)))
form))))
;A simple way to try several methods until one returns non-nil
(define-method-combination or ()
((methods (or)))
‘(or ,@(mapcar #’(lambda (method)
‘(call-method ,method))
methods)))
7–82 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination
;A more complete version of the preceding
(define-method-combination or
(&optional (order ’:most-specific-first))
((around (:around))
(primary (or)))
;; Process the order argument
(case order
(:most-specific-first)
(:most-specific-last (setq primary (reverse primary)))
(otherwise (method-combination-error "~S is an invalid order.~@
:most-specific-first and :most-specific-last are the possible values."
order)))
;; Must have a primary method
(unless primary
(method-combination-error "A primary method is required."))
;; Construct the form that calls the primary methods
(let ((form (if (rest primary)
‘(or ,@(mapcar #’(lambda (method)
‘(call-method ,method))
primary))
‘(call-method ,(first primary)))))
;; Wrap the around methods around that form
(if around
‘(call-method ,(first around)
(,@(rest around)
(make-method ,form)))
form)))
;The same thing, using the :order and :required keyword options
(define-method-combination or
(&optional (order ’:most-specific-first))
((around (:around))
(primary (or) :order order :required t))
(let ((form (if (rest primary)
‘(or ,@(mapcar #’(lambda (method)
‘(call-method ,method))
primary))
‘(call-method ,(first primary)))))
(if around
‘(call-method ,(first around)
(,@(rest around)
(make-method ,form)))
form)))
Objects 7–83
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-method-combination
;This short-form call is behaviorally identical to the preceding
(define-method-combination or :identity-with-one-argument t)
;Order methods by positive integer qualifiers
;:around methods are disallowed to keep the example small
(define-method-combination example-method-combination ()
((methods positive-integer-qualifier-p))
‘(progn ,@(mapcar #’(lambda (method)
‘(call-method ,method))
(stable-sort methods #’<
:key #’(lambda (method)
(first (method-qualifiers method)))))))
(defun positive-integer-qualifier-p (method-qualifiers)
(and (= (length method-qualifiers) 1)
(typep (first method-qualifiers) ’(integer 0 *))))
;;; Example of the use of :arguments
(define-method-combination progn-with-lock ()
((methods ()))
(:arguments object)
‘(unwind-protect
(progn (lock (object-lock ,object))
,@(mapcar #’(lambda (method)
‘(call-method ,method))
methods))
(unlock (object-lock ,object))))
Side Eﬀects:
The compiler is not required to perform any compile-time side-eects.
Exceptional Situations:
Method combination types dened with the short form require exactly one qualier per method.
An error of typeerror is signaled if there are applicable methods with no qualiers or with
qualiers that are not supported by the method combination type. At least one primary method
must be applicable or an error of typeerror is signaled.
If an applicable method does not fall into any method group, the system signals an error of type
error indicating that the method is invalid for the kind of method combination in use.
If the value of the :required option is true and the method group is empty (that is, no applicable
methods match the qualier patterns or satisfy the predicate), an error of typeerror is signaled.
If the:order option evaluates to a value other than :most-specific-first or:most-specific-last ,
an error of typeerror is signaled.
7–84 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
call-method ,call-next-method ,documentation ,method-qualiﬁers ,method-combination-error ,
invalid-method-error ,defgeneric , Section 7.6.6 (Method Selection and Combination), Sec-
tion 7.6.6.4 (Built-in Method Combination Types), Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations)
Notes:
The:method-combination option of defgeneric is used to specify that a generic function should use
a particular method combination type. The rst argument to the :method-combination option is
thename of a method combination type and the remaining arguments are options for that type.
ﬁnd-method Standard Generic Function
Syntax:
ﬁnd-method generic-function method-qualiers specializers &optional errorp
!method
Method Signatures:
ﬁnd-method (generic-function standard-generic-function )
method-qualiers specializers &optional errorp
Arguments and Values:
generic-function |ageneric function .
method-qualiers |alist.
specializers |alist.
errorp |ageneralized boolean . The default is true.
method |amethod object , ornil.
Description:
The generic function ﬁnd-method takes a generic function and returns the method object that
agrees on qualiers andparameter specializers with the method-qualiers and specializers arguments
ofﬁnd-method .Method-qualiers contains the method qualiers for the method . The order of
the method qualiers is signicant. For a denition of agreement in this context, see Section 7.6.3
(Agreement on Parameter Specializers and Qualiers).
The specializers argument contains the parameter specializers for the method . It must correspond
in length to the number of required arguments of the generic function , or an error is signaled. This
means that to obtain the default method on a given generic-function , alistwhose elements are the
classtmust be given.
Objects 7–85
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If there is no such method and errorp istrue,ﬁnd-method signals an error. If there is no such
method and errorp isfalse,ﬁnd-method returnsnil.
Examples:
(defmethod some-operation ((a integer) (b float)) (list a b))
!#<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
(find-method #’some-operation ’() (mapcar #’find-class ’(integer float)))
!#<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
(find-method #’some-operation ’() (mapcar #’find-class ’(integer integer)))
.Error: No matching method
(find-method #’some-operation ’() (mapcar #’find-class ’(integer integer)) nil)
!NIL
Aﬀected By:
add-method ,defclass ,defgeneric ,defmethod
Exceptional Situations:
If the specializers argument does not correspond in length to the number of required arguments of
thegeneric-function , an an error of typeerror is signaled.
If there is no such method and errorp istrue,ﬁnd-method signals an error of typeerror .
See Also:
Section 7.6.3 (Agreement on Parameter Specializers and Qualiers)
add-method Standard Generic Function
Syntax:
add-method generic-function method !generic-function
Method Signatures:
add-method (generic-function standard-generic-function )
(methodmethod )
Arguments and Values:
generic-function |ageneric function object .
method |amethod object .
Description:
The generic function add-method adds a method to a generic function .
7–86 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Ifmethod agrees with an existing method ofgeneric-function onparameter specializers and
qualiers , the existing method is replaced.
Exceptional Situations:
The lambda list of the method function of method must be congruent with the lambda list of
generic-function , or an error of typeerror is signaled.
Ifmethod is amethod object of another generic function , an error of typeerror is signaled.
See Also:
defmethod ,defgeneric ,ﬁnd-method ,remove-method , Section 7.6.3 (Agreement on Parameter
Specializers and Qualiers)
initialize-instance Standard Generic Function
Syntax:
initialize-instance instance &rest initargs&key &allow-other-keys !instance
Method Signatures:
initialize-instance (instancestandard-object )&rest initargs
Arguments and Values:
instance |an object .
initargs |adefaulted initialization argument list .
Description:
Called by make-instance to initialize a newly created instance . The generic function is called with
the new instance and the defaulted initialization argument list .
The system-supplied primary method oninitialize-instance initializes the slots of the instance with
values according to the initargs and the :initform forms of the slots. It does this by calling the
generic function shared-initialize with the following arguments: the instance ,t(this indicates that
allslots for which no initialization arguments are provided should be initialized according to their
:initform forms), and the initargs .
Programmers can dene methods forinitialize-instance to specify actions to be taken when an
instance is initialized. If only after methods are dened, they will be run after the system-supplied
primary method for initialization and therefore will not interfere with the default behavior of
initialize-instance .
Objects 7–87
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
shared-initialize ,make-instance ,slot-boundp ,slot-makunbound , Section 7.1 (Object Creation
and Initialization), Section 7.1.4 (Rules for Initialization Arguments), Section 7.1.2 (Declaring the
Validity of Initialization Arguments)
class-name Standard Generic Function
Syntax:
class-name class!name
Method Signatures:
class-name (classclass )
Arguments and Values:
class|aclass object .
name |asymbol .
Description:
Returns the name of the given class.
See Also:
ﬁnd-class , Section 4.3 (Classes)
Notes:
IfSis asymbol such thatS=(class-name C)andC=(find-class S), thenSis the proper name
ofC. For further discussion, see Section 4.3 (Classes).
The name of an anonymous class isnil.
7–88 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setfclass-name) Standard Generic Function
Syntax:
(setf class-name) new-value class!new-value
Method Signatures:
(setf class-name) new-value (classclass )
Arguments and Values:
new-value |asymbol .
class|aclass .
Description:
The generic function (setf class-name) sets the name of a class object.
See Also:
ﬁnd-class ,proper name , Section 4.3 (Classes)
class-of Function
Syntax:
class-of object!class
Arguments and Values:
object |an object .
class|aclass object .
Description:
Returns the class of which the object is adirect instance .
Examples:
(class-of ’fred) !#<BUILT-IN-CLASS SYMBOL 610327300>
(class-of 2/3)!#<BUILT-IN-CLASS RATIO 610326642>
(defclass book () ()) !#<STANDARD-CLASS BOOK 33424745>
(class-of (make-instance ’book)) !#<STANDARD-CLASS BOOK 33424745>
(defclass novel (book) ()) !#<STANDARD-CLASS NOVEL 33424764>
(class-of (make-instance ’novel)) !#<STANDARD-CLASS NOVEL 33424764>
Objects 7–89
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defstruct kons kar kdr) !KONS
(class-of (make-kons :kar 3 :kdr 4)) !#<STRUCTURE-CLASS KONS 250020317>
See Also:
make-instance ,type-of
unbound-slot Condition Type
Class Precedence List:
unbound-slot ,cell-error ,error ,serious-condition ,condition ,t
Description:
The object having the unbound slot is initialized by the :instance initialization argument to
make-condition , and is accessed by the functionunbound-slot-instance .
The name of the cell (see cell-error ) is the name of the slot.
See Also:
cell-error-name ,unbound-slot-object , Section 9.1 (Condition System Concepts)
unbound-slot-instance Function
Syntax:
unbound-slot-instance condition!instance
Arguments and Values:
condition |acondition oftypeunbound-slot .
instance |an object .
Description:
Returns the instance which had the unbound slot in the situation represented by the condition .
See Also:
cell-error-name ,unbound-slot , Section 9.1 (Condition System Concepts)
7–90 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
8. Structures
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Structures iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct Macro
Syntax:
defstruct name-and-options [documentation ]f#slot-descriptiong*
!structure-name
name-and-options:: =structure-namej(structure-name [ [#options ] ])
options:: =#conc-name-option j
f#constructor-option g*j
#copier-optionj
#include-optionj
#initial-oset-option j
#named-optionj
#predicate-optionj
#printer-optionj
#type-option
conc-name-option:: =:conc-namej(:conc-name )j(:conc-name conc-name )
constructor-option:: =:constructorj
(:constructor )j
(:constructor constructor-name )j
(:constructor constructor-name constructor-arglist )
copier-option:: =:copierj(:copier )j(:copier copier-name )
predicate-option:: =:predicatej(:predicate )j(:predicate predicate-name )
include-option:: =(:include included-structure-name f#slot-descriptiong*)
printer-option:: =#print-object-option j#print-function-option
print-object-option:: =(:print-object printer-name )j(:print-object )
print-function-option:: =(:print-function printer-name )j(:print-function )
type-option:: =(:type type)
named-option:: =:named
initial-oset-option:: =(:initial-offset initial-oset )
Structures 8–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
slot-description:: =slot-namej
(slot-name [slot-initform [ [#slot-option ] ]])
slot-option:: =:type slot-typej
:read-only slot-read-only-p
Arguments and Values:
conc-name |astring designator .
constructor-arglist |aboa lambda list .
constructor-name |asymbol .
copier-name |asymbol .
included-structure-name |an already-dened structure name . Note that a derived type is not
permissible, even if it would expand into a structure name .
initial-oset |a non-negative integer .
predicate-name |asymbol .
printer-name |afunction name or a lambda expression .
slot-name |asymbol .
slot-initform |aform .
slot-read-only-p |ageneralized boolean .
structure-name |asymbol .
type|one of the type speciers list,vector , or(vector size), or some other type specier dened
by the implementation to be appropriate.
documentation |astring ; not evaluated.
Description:
defstruct denes a structured type, named structure-type , with named slots as specied by the
slot-options .
defstruct denes readers for the slots and arranges for setf to work properly on such reader
functions. Also, unless overridden, it denes a predicate named name-p, denes a constructor
function named make- constructor-name , and denes a copier function named copy- constructor-name .
All names of automatically created functions might automatically be declared inline (at the
discretion of the implementation ).
Ifdocumentation is supplied, it is attached to structure-name as a documentation string of kind
structure , and unless :type is used, the documentation is also attached to structure-name as a
8–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
documentation string of kindtype and as a documentation string to the class object for the class
named structure-name .
defstruct denes a constructor function that is used to create instances of the structure created by
defstruct . The default name is make- structure-name . A dierent name can be supplied by giving
the name as the argument to the constructor option.nilindicates that no constructor function will
be created.
After a new structure type has been dened, instances of that type normally can be created by
using the constructor function for the type. A call to a constructor function is of the following
form:
(constructor-function-name
slot-keyword-1 form-1
slot-keyword-2 form-2
:::)
The arguments to the constructor function are all keyword arguments. Each slot keyword argument
must be a keyword whose name corresponds to the name of a structure slot. All the keywords and
forms are evaluated. If a slot is not initialized in this way, it is initialized by evaluating slot-initform
in the slot description at the time the constructor function is called. If no slot-initform is supplied,
the consequences are undened if an attempt is later made to read the slot's value before a value
is explicitly assigned.
Each slot-initform supplied for a defstruct component, when used by the constructor function for
an otherwise unsupplied component, is re-evaluated on every call to the constructor function. The
slot-initform is not evaluated unless it is needed in the creation of a particular structure instance.
If it is never needed, there can be no type-mismatch error, even if the type of the slot is specied;
no warning should be issued in this case. For example, in the following sequence, only the last call
is an error.
(defstruct person (name 007 :type string))
(make-person :name "James")
(make-person)
It is as if the slot-initforms were used as initialization forms for the keyword parameters of the
constructor function.
The symbols which name the slots must not be used by the implementation as the names for the
lambda variables in the constructor function, since one or more of those symbols might have been
proclaimed special or might be dened as the name of a constant variable . The slot default init
forms are evaluated in the lexical environment in which the defstruct form itself appears and in
thedynamic environment in which the call to the constructor function appears.
For example, if the form (gensym) were used as an initialization form, either in the constructor-
function call or as the default initialization form in defstruct , then every call to the constructor
function would call gensym once to generate a new symbol .
Structures 8–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
Each slot-description indefstruct can specify zero or more slot-options . A slot-option consists of
a pair of a keyword and a value (which is not a form to be evaluated, but the value itself). For
example:
(defstruct ship
(x-position 0.0 :type short-float)
(y-position 0.0 :type short-float)
(x-velocity 0.0 :type short-float)
(y-velocity 0.0 :type short-float)
(mass *default-ship-mass* :type short-float :read-only t))
This species that each slot always contains a short oat , and that the last slot cannot be altered
once a ship is constructed.
The available slot-options are:
:type type
This species that the contents of the slot is always of type type. This is entirely analogous
to the declaration of a variable or function; it eectively declares the result type of
thereader function. It is implementation-dependent whether the type is checked when
initializing a slot or when assigning to it. Type is not evaluated; it must be a valid type
specier .
:read-only x
When xistrue, this species that this slot cannot be altered; it will always contain the
value supplied at construction time. setf will not accept the reader function for this slot.
Ifxisfalse, this slot-option has no eect. Xis not evaluated.
When this option is false or unsupplied, it is implementation-dependent whether the ability
towrite the slot is implemented by a setf function or a setf expander .
The following keyword options are available for use with defstruct . Adefstruct option can be
either a keyword or a listof a keyword and arguments for that keyword; specifying the keyword by
itself is equivalent to specifying a list consisting of the keyword and no arguments. The syntax for
defstruct options diers from the pair syntax used for slot-options. No part of any of these options
is evaluated.
:conc-name
This provides for automatic prexing of names of reader (oraccess ) functions. The default
behavior is to begin the names of all the reader functions of a structure with the name of
the structure followed by a hyphen.
:conc-name supplies an alternate prex to be used. If a hyphen is to be used as a separator,
it must be supplied as part of the prex. If :conc-name isnilor no argument is supplied,
then no prex is used; then the names of the reader functions are the same as the slot
names. If a non-nil prex is given, the name of the reader function for each slot is
8–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
constructed by concatenating that prex and the name of the slot, and interning the
resulting symbol in the package that is current at the time the defstruct form is expanded.
Note that no matter what is supplied for :conc-name , slot keywords that match the slot
names with no prex attached are used with a constructor function. The reader function
name is used in conjunction with setf. Here is an example:
(defstruct (door (:conc-name dr-)) knob-color width material) !DOOR
(setq my-door (make-door :knob-color ’red :width 5.0))
!#S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)
(dr-width my-door) !5.0
(setf (dr-width my-door) 43.7) !43.7
(dr-width my-door) !43.7
Whether or not the :conc-name option is explicitly supplied, the following rule governs
name conicts of generated reader (oraccessor ) names: For any structure type S1having
areader function named Rfor a slot named X1that is inherited by another structure
typeS2that would have a reader function with the same name Rfor a slot named X2,
no denition for Ris generated by the denition of S2; instead, the denition of Ris
inherited from the denition of S1. (In such a case, if X1andX2are dierent slots, the
implementation might signal a style warning.)
:constructor
This option takes zero, one, or two arguments. If at least one argument is supplied and
the rst argument is not nil, then that argument is a symbol which species the name of
the constructor function. If the argument is not supplied (or if the option itself is not
supplied), the name of the constructor is produced by concatenating the string "MAKE-"
and the name of the structure, interning the name in whatever package is current at the
timedefstruct is expanded. If the argument is provided and is nil, no constructor function
is dened.
If:constructor is given as (:constructor name arglist ), then instead of making a keyword
driven constructor function, defstruct denes a \positional" constructor function, taking
arguments whose meaning is determined by the argument's position and possibly by
keywords. Arglist is used to describe what the arguments to the constructor will be. In
the simplest case something like (:constructor make-foo (a b c)) denesmake-foo to be
a three-argument constructor function whose arguments are used to initialize the slots
nameda,b, andc.
Because a constructor of this type operates \By Order of Arguments," it is sometimes
known as a \boa constructor."
For information on how the arglist for a \boa constructor" is processed, see Section 3.4.6
(Boa Lambda Lists).
It is permissible to use the :constructor option more than once, so that you can dene
several dierent constructor functions, each taking dierent parameters.
Structures 8–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
defstruct creates the default-named keyword constructor function only if no explicit
:constructor options are specied, or if the :constructor option is specied without a
name argument.
(:constructor nil) is meaningful only when there are no other :constructor options
specied. It prevents defstruct from generating any constructors at all.
Otherwise, defstruct creates a constructor function corresponding to each supplied
:constructor option. It is permissible to specify multiple keyword constructor functions as
well as multiple \boa constructors".
:copier
This option takes one argument, a symbol , which species the name of the copier function.
If the argument is not provided or if the option itself is not provided, the name of the
copier is produced by concatenating the string "COPY-" and the name of the structure,
interning the name in whatever package is current at the time defstruct is expanded. If
the argument is provided and is nil, no copier function is dened.
The automatically dened copier function is a function of one argument , which must be of
the structure type being dened. The copier function creates a fresh structure that has
the same type as its argument , and that has the same component values as the original
structure; that is, the component values are not copied recursively. If the defstruct :type
option was not used, the following equivalence applies:
(copier-name x) = (copy-structure (the structure-name x))
:include
This option is used for building a new structure denition as an extension of another
structure denition. For example:
(defstruct person name age sex)
To make a new structure to represent an astronaut that has the attributes of name,
age, and sex, and functions that operate on person structures, astronaut is dened with
:include as follows:
(defstruct (astronaut (:include person)
(:conc-name astro-))
helmet-size
(favorite-beverage ’tang))
:include causes the structure being dened to have the same slots as the included structure.
This is done in such a way that the reader functions for the included structure also work
on the structure being dened. In this example, an astronaut therefore has ve slots:
the three dened in person and the two dened in astronaut itself. The reader functions
dened by the person structure can be applied to instances of the astronaut structure, and
they work correctly. Moreover, astronaut has its own reader functions for components
8–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
dened by the person structure. The following examples illustrate the use of astronaut
structures:
(setq x (make-astronaut :name ’buzz
:age 45.
:sex t
:helmet-size 17.5))
(person-name x) !BUZZ
(astro-name x)!BUZZ
(astro-favorite-beverage x) !TANG
(reduce #’+ astros :key #’person-age) ; obtains the total of the ages
; of the possibly empty
; sequence of astros
The dierence between the reader functions person-name andastro-name is thatperson-name
can be correctly applied to any person , including an astronaut , whileastro-name can be
correctly applied only to an astronaut . An implementation might check for incorrect use
ofreader functions.
At most one :include can be supplied in a single defstruct . The argument to :include
is required and must be the name of some previously dened structure. If the structure
being dened has no :type option, then the included structure must also have had no :type
option supplied for it. If the structure being dened has a :type option, then the included
structure must have been declared with a :type option specifying the same representation
type.
If no:type option is involved, then the structure name of the including structure denition
becomes the name of a data type , and therefore a valid type specier recognizable by
typep ; it becomes a subtype of the included structure. In the above example, astronaut is
asubtype ofperson ; hence
(typep (make-astronaut) ’person) !true
indicating that all operations on persons also work on astronauts.
The structure using :include can specify default values or slot-options for the included
slots dierent from those the included structure species, by giving the :include option as:
(:include included-structure-name fslot-descriptiong*)
Each slot-description must have a slot-name that is the same as that of some slot in the
included structure. If a slot-description has no slot-initform , then in the new structure the
slot has no initial value. Otherwise its initial value form is replaced by the slot-initform in
theslot-description . A normally writable slot can be made read-only. If a slot is read-only
in the included structure, then it must also be so in the including structure. If a type is
supplied for a slot, it must be a subtype of the type specied in the included structure.
Structures 8–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
For example, if the default age for an astronaut is 45, then
(defstruct (astronaut (:include person (age 45)))
helmet-size
(favorite-beverage ’tang))
If:include is used with the :type option, then the eect is rst to skip over as many
representation elements as needed to represent the included structure, then to skip over any
additional elements supplied by the :initial-offset option, and then to begin allocation
of elements from that point. For example:
(defstruct (binop (:type list) :named (:initial-offset 2))
(operator ’? :type symbol)
operand-1
operand-2)!BINOP
(defstruct (annotated-binop (:type list)
(:initial-offset 3)
(:include binop))
commutative associative identity) !ANNOTATED-BINOP
(make-annotated-binop :operator ’*
:operand-1 ’x
:operand-2 5
:commutative t
:associative t
:identity 1)
!(NIL NIL BINOP * X 5 NIL NIL NIL T T 1)
The rst two nilelements stem from the :initial-offset of2in the denition of binop .
The next four elements contain the structure name and three slots for binop . The next
threenilelements stem from the :initial-offset of3in the denition of annotated-binop .
The last three list elements contain the additional slots for an annotated-binop .
:initial-offset
:initial-offset instructs defstruct to skip over a certain number of slots before it starts
allocating the slots described in the body. This option's argument is the number of slots
defstruct should skip. :initial-offset can be used only if :type is also supplied.
:initial-offset allows slots to be allocated beginning at a representational element other
than the rst. For example, the form
(defstruct (binop (:type list) (:initial-offset 2))
(operator ’? :type symbol)
operand-1
operand-2)!BINOP
would result in the following behavior for make-binop :
8–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
(make-binop :operator ’+ :operand-1 ’x :operand-2 5)
!(NIL NIL + X 5)
(make-binop :operand-2 4 :operator ’*)
!(NIL NIL * NIL 4)
The selector functions binop-operator ,binop-operand-1 , andbinop-operand-2 would be
essentially equivalent to third ,fourth , andﬁfth, respectively. Similarly, the form
(defstruct (binop (:type list) :named (:initial-offset 2))
(operator ’? :type symbol)
operand-1
operand-2)!BINOP
would result in the following behavior for make-binop :
(make-binop :operator ’+ :operand-1 ’x :operand-2 5) !(NIL NIL BINOP + X 5)
(make-binop :operand-2 4 :operator ’*) !(NIL NIL BINOP * NIL 4)
The rst two nilelements stem from the :initial-offset of2in the denition of binop .
The next four elements contain the structure name and three slots for binop .
:named
:named species that the structure is named. If no :type is supplied, then the structure is
always named.
For example:
(defstruct (binop (:type list))
(operator ’? :type symbol)
operand-1
operand-2)!BINOP
This denes a constructor function make-binop and three selector functions, namely
binop-operator ,binop-operand-1 , andbinop-operand-2 . (It does not, however, dene a
predicate binop-p , for reasons explained below.)
The eect of make-binop is simply to construct a list of length three:
(make-binop :operator ’+ :operand-1 ’x :operand-2 5) !(+ X 5)
(make-binop :operand-2 4 :operator ’*) !(* NIL 4)
It is just like the function list except that it takes keyword arguments and performs slot
defaulting appropriate to the binop conceptual data type. Similarly, the selector functions
binop-operator ,binop-operand-1 , andbinop-operand-2 are essentially equivalent to car,
cadr, andcaddr , respectively. They might not be completely equivalent because, for
example, an implementation would be justied in adding error-checking code to ensure
that the argument to each selector function is a length-3 list.
Structures 8–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
binop is a conceptual data type in that it is not made a part of the Common Lisp type
system.typep does not recognize binop as a type specier , andtype-of returnslist when
given abinop structure. There is no way to distinguish a data structure constructed by
make-binop from any other listthat happens to have the correct structure.
There is not any way to recover the structure name binop from a structure created by
make-binop . This can only be done if the structure is named. A named structure has the
property that, given an instance of the structure, the structure name (that names the
type) can be reliably recovered. For structures dened with no :type option, the structure
name actually becomes part of the Common Lisp data-type system. type-of , when applied
to such a structure, returns the structure name as the type of the object ;typep recognizes
the structure name as a valid type specier .
For structures dened with a :type option,type-of returns a type specier such as list
or(vector t) , depending on the type supplied to the :type option. The structure name
does not become a valid type specier . However, if the :named option is also supplied,
then the rst component of the structure (as created by a defstruct constructor function)
always contains the structure name. This allows the structure name to be recovered from
an instance of the structure and allows a reasonable predicate for the conceptual type to
be dened: the automatically dened name-p predicate for the structure operates by rst
checking that its argument is of the proper type ( list,(vector t) , or whatever) and then
checking whether the rst component contains the appropriate type name.
Consider the binop example shown above, modied only to include the :named option:
(defstruct (binop (:type list) :named)
(operator ’? :type symbol)
operand-1
operand-2)!BINOP
As before, this denes a constructor function make-binop and three selector functions
binop-operator ,binop-operand-1 , andbinop-operand-2 . It also denes a predicate binop-p .
The eect of make-binop is now to construct a list of length four:
(make-binop :operator ’+ :operand-1 ’x :operand-2 5) !(BINOP + X 5)
(make-binop :operand-2 4 :operator ’*) !(BINOP * NIL 4)
The structure has the same layout as before except that the structure name binop is
included as the rst list element. The selector functions binop-operator ,binop-operand-1 ,
andbinop-operand-2 are essentially equivalent to cadr,caddr , andcadddr , respectively.
The predicate binop-p is more or less equivalent to this denition:
(defun binop-p (x)
(and (consp x) (eq (car x) ’binop))) !BINOP-P
The name binop is still not a valid type specier recognizable to typep , but at least there
is a way of distinguishing binop structures from other similarly dened structures.
8–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
:predicate
This option takes one argument, which species the name of the type predicate. If the
argument is not supplied or if the option itself is not supplied, the name of the predicate is
made by concatenating the name of the structure to the string "-P", interning the name in
whatever package is current at the time defstruct is expanded. If the argument is provided
and isnil, no predicate is dened. A predicate can be dened only if the structure is
named; if :type is supplied and :named is not supplied, then :predicate must either be
unsupplied or have the value nil.
:print-function ,:print-object
The:print-function and:print-object options specify that a print-object method for
structures of type structure-name should be generated. These options are not synonyms, but
do perform a similar service; the choice of which option ( :print-function or:print-object )
is used aects how the function named printer-name is called. Only one of these options
may be used, and these options may be used only if :type is not supplied.
If the:print-function option is used, then when a structure of type structure-name is to
be printed, the designated printer function is called on three arguments :
{ the structure to be printed (a generalized instance ofstructure-name ).
{ a stream to print to.
{ an integer indicating the current depth. The magnitude of this integer may
vary between implementations ; however, it can reliably be compared against
*print-level* to determine whether depth abbreviation is appropriate.
Specifying (:print-function printer-name )is approximately equivalent to specifying:
(defmethod print-object ((object structure-name ) stream)
(funcall (function printer-name ) object stream hhcurrent-print-depth ii))
where thehhcurrent-print-depth iirepresents the printer's belief of how deep it is currently
printing. It is implementation-dependent whetherhhcurrent-print-depth iiis always 0 and
*print-level* , ifnon-nil , is re-bound to successively smaller values as printing descends
recursively, or whether current-print-depth varies in value as printing descends recursively
and *print-level* remains constant during the same traversal.
If the:print-object option is used, then when a structure of type structure-name is to be
printed, the designated printer function is called on two arguments:
{ the structure to be printed.
{ the stream to print to.
Specifying (:print-object printer-name )is equivalent to specifying:
Structures 8–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
(defmethod print-object ((object structure-name ) stream)
(funcall (function printer-name ) object stream))
If no:type option is supplied, and if either a :print-function or a:print-object option
is supplied, and if no printer-name is supplied, then a print-object method specialized for
structure-name is generated that calls a function that implements the default printing
behavior for structures using #Snotation; see Section 22.1.3.12 (Printing Structures).
If neither a :print-function nor a:print-object option is supplied, then defstruct
does not generate a print-object method specialized forstructure-name and some default
behavior is inherited either from a structure named in an :include option or from the
default behavior for printing structures; see the functionprint-object and Section 22.1.3.12
(Printing Structures).
When*print-circle* istrue, a user-dened print function can print objects to the supplied
stream usingwrite ,prin1 ,princ , orformat and expect circularities to be detected and
printed using the #n#syntax. This applies to methods onprint-object in addition to
:print-function options. If a user-dened print function prints to a stream other than
the one that was supplied, then circularity detection starts over for that stream . See the
variable*print-circle* .
:type
:type explicitly species the representation to be used for the structure. Its argument must
be one of these types :
vector
This produces the same result as specifying (vector t) . The structure is
represented as a general vector , storing components as vector elements. The rst
component is vector element 1 if the structure is :named , and element 0 otherwise.
(vector element-type )
The structure is represented as a (possibly specialized) vector , storing components
as vector elements. Every component must be of a type that can be stored in
avector of the type specied. The rst component is vector element 1 if the
structure is :named , and element 0 otherwise. The structure can be :named only if
thetypesymbol is asubtype of the supplied element-type .
list
The structure is represented as a list. The rst component is the cadr if the
structure is :named , and the carif it is not :named .
Specifying this option has the eect of forcing a specic representation and of forcing the
components to be stored in the order specied in defstruct in corresponding successive
elements of the specied representation. It also prevents the structure name from becoming
8–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
a valid type specier recognizable by typep .
For example:
(defstruct (quux (:type list) :named) x y)
should make a constructor that builds a listexactly like the one that listproduces, with
quux as its car.
If this type is dened:
(deftype quux () ’(satisfies quux-p))
then this form
(typep (make-quux) ’quux)
should return precisely what this one does
(typep (list ’quux nil nil) ’quux)
If:type is not supplied, the structure is represented as an object oftypestructure-object .
defstruct without a :type option denes a class with the structure name as its name. The
metaclass of structure instances isstructure-class .
The consequences of redening a defstruct structure are undened.
In the case where no defstruct options have been supplied, the following functions are automatically
dened to operate on instances of the new structure:
Predicate
A predicate with the name structure-name -pis dened to test membership in the structure
type. The predicate (structure-name -pobject)istrue if an object is of this type; otherwise
it is false.typep can also be used with the name of the new type to test whether an object
belongs to the type. Such a function call has the form (typep object’structure-name ).
Component reader functions
Reader functions are dened to read the components of the structure. For each slot name,
there is a corresponding reader function with the name structure-name -slot-name . This
function reads the contents of that slot. Each reader function takes one argument, which
is an instance of the structure type. setfcan be used with any of these reader functions to
alter the slot contents.
Constructor function
A constructor function with the name make- structure-name is dened. This function creates
and returns new instances of the structure type.
Structures 8–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
Copier function
A copier function with the name copy- structure-name is dened. The copier function takes
an object of the structure type and creates a new object of the same type that is a copy of
the rst. The copier function creates a new structure with the same component entries as
the original. Corresponding components of the two structure instances are eql.
If adefstruct form appears as a top level form , the compiler must make the structure type name
recognized as a valid type name in subsequent declarations (as for deftype ) and make the structure
slot readers known to setf. In addition, the compiler must save enough information about the
structure type so that further defstruct denitions can use :include in a subsequent deftype in
the same leto refer to the structure type name. The functions which defstruct generates are
not dened in the compile time environment, although the compiler may save enough information
about the functions to code subsequent calls inline. The #Sreader macro might or might not
recognize the newly dened structure type name at compile time.
Examples:
An example of a structure denition follows:
(defstruct ship
x-position
y-position
x-velocity
y-velocity
mass)
This declares that every ship is an object with ve named components. The evaluation of this form
does the following:
1. It denes ship-x-position to be a function of one argument, a ship, that returns the
x-position of the ship; ship-y-position and the other components are given similar
function denitions. These functions are called the access functions, as they are used to
access elements of the structure.
2.ship becomes the name of a type of which instances of ships are elements. ship becomes
acceptable to typep , for example; (typep x ’ship) istrue ifxis a ship and false if xis any
object other than a ship.
3. A function named ship-p of one argument is dened; it is a predicate that is true if its
argument is a ship and is false otherwise.
4. A function called make-ship is dened that, when invoked, creates a data structure with
ve components, suitable for use with the access functions. Thus executing
(setq ship2 (make-ship))
setsship2 to a newly created ship object . One can supply the initial values of any desired
8–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
component in the call to make-ship by using keyword arguments in this way:
(setq ship2 (make-ship :mass *default-ship-mass*
:x-position 0
:y-position 0))
This constructs a new ship and initializes three of its components. This function is called
the \constructor function" because it constructs a new structure.
5. A function called copy-ship of one argument is dened that, when given a ship object ,
creates a new ship object that is a copy of the given one. This function is called the \copier
function."
setf can be used to alter the components of a ship:
(setf (ship-x-position ship2) 100)
This alters the x-position ofship2 to be100. This works because defstruct behaves as if it
generates an appropriate defsetf for each access function.
;;;
;;; Example 1
;;; define town structure type
;;; area, watertowers, firetrucks, population, elevation are its components
;;;
(defstruct town
area
watertowers
(firetrucks 1 :type fixnum) ;an initialized slot
population
(elevation 5128 :read-only t)) ;a slot that can’t be changed
!TOWN
;create a town instance
(setq town1 (make-town :area 0 :watertowers 0)) !#S(TOWN...)
;town’s predicate recognizes the new instance
(town-p town1)!true
;new town’s area is as specified by make-town
(town-area town1) !0
;new town’s elevation has initial value
(town-elevation town1) !5128
;setf recognizes reader function
(setf (town-population town1) 99) !99
(town-population town1) !99
;copier function makes a copy of town1
(setq town2 (copy-town town1)) !#S(TOWN...)
(= (town-population town1) (town-population town2)) !true
;since elevation is a read-only slot, its value can be set only
Structures 8–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defstruct
;when the structure is created
(setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))
!#S(TOWN...)
;;;
;;; Example 2
;;; define clown structure type
;;; this structure uses a nonstandard prefix
;;;
(defstruct (clown (:conc-name bozo-))
(nose-color ’red)
frizzy-hair-p polkadots) !CLOWN
(setq funny-clown (make-clown)) !#S(CLOWN)
;use non-default reader name
(bozo-nose-color funny-clown) !RED
(defstruct (klown (:constructor make-up-klown) ;similar def using other
(:copier clone-klown) ;customizing keywords
(:predicate is-a-bozo-p))
nose-color frizzy-hair-p polkadots) !klown
;custom constructor now exists
(fboundp ’make-up-klown) !true
;;;
;;; Example 3
;;; define a vehicle structure type
;;; then define a truck structure type that includes
;;; the vehicle structure
;;;
(defstruct vehicle name year (diesel t :read-only t)) !VEHICLE
(defstruct (truck (:include vehicle (year 79)))
load-limit
(axles 6))!TRUCK
(setq x (make-truck :name ’mac :diesel t :load-limit 17))
!#S(TRUCK...)
;vehicle readers work on trucks
(vehicle-name x)
!MAC
;default taken from :include clause
(vehicle-year x)
!79
(defstruct (pickup (:include truck)) ;pickup type includes truck
camper long-bed four-wheel-drive) !PICKUP
(setq x (make-pickup :name ’king :long-bed t)) !#S(PICKUP...)
;:include default inherited
(pickup-year x) !79
;;;
;;; Example 4
8–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;;; use of BOA constructors
;;;
(defstruct (dfs-boa ;BOA constructors
(:constructor make-dfs-boa (a b c))
(:constructor create-dfs-boa
(a &optional b (c ’cc) &rest d &aux e (f ’ff))))
a b c d e f)!DFS-BOA
;a, b, and c set by position, and the rest are uninitialized
(setq x (make-dfs-boa 1 2 3)) !#(DFS-BOA...)
(dfs-boa-a x)!1
;a and b set, c and f defaulted
(setq x (create-dfs-boa 1 2)) !#(DFS-BOA...)
(dfs-boa-b x)!2
(eq (dfs-boa-c x) ’cc) !true
;a, b, and c set, and the rest are collected into d
(setq x (create-dfs-boa 1 2 3 4 5 6)) !#(DFS-BOA...)
(dfs-boa-d x)!(4 5 6)
Exceptional Situations:
If any two slot names (whether present directly or inherited by the :include option) are the same
understring= ,defstruct should signal an error of typeprogram-error .
The consequences are undened if the included-structure-name does not name a structure type .
See Also:
documentation ,print-object ,setf,subtypep ,type-of ,typep , Section 3.2 (Compilation)
Notes:
The printer-name should observe the values of such printer-control variables as *print-escape* .
The restriction against issuing a warning for type mismatches between a slot-initform and the
corresponding slot's :type option is necessary because a slot-initform must be specied in order to
specify slot options; in some cases, no suitable default may exist.
The mechanism by which defstruct arranges for slot accessors to be usable with setf is
implementation-dependent ; for example, it may use setf functions ,setf expanders , or some other
implementation-dependent mechanism known to that implementation 'scode forsetf.
copy-structure Function
Syntax:
copy-structure structure!copy
Structures 8–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
copy-structure
Arguments and Values:
structure |astructure .
copy|a copy of the structure .
Description:
Returns a copy 6of the structure .
Only the structure itself is copied; not the values of the slots.
See Also:
the:copier option to defstruct
Notes:
The copy is the same as the given structure underequalp , but not under equal .
8–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
9. Conditions
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Conditions iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
9.1 Condition System Concepts
Common Lisp constructs are described not only in terms of their behavior in situations during
which they are intended to be used (see the \Description" part of each operator specication), but
in all other situations (see the \Exceptional Situations" part of each operator specication).
A situation is the evaluation of an expression in a specic context. A condition is an object that
represents a specic situation that has been detected. Conditions aregeneralized instances of the
classcondition . A hierarchy of condition classes is dened in Common Lisp. A condition hasslots
that contain data relevant to the situation that the condition represents.
An error is a situation in which normal program execution cannot continue correctly without
some form of intervention (either interactively by the user or under program control). Not all
errors are detected. When an error goes undetected, the eects can be implementation-dependent ,
implementation-dened , unspecied, or undened. See Section 1.4 (Denitions). All detected
errors can be represented by conditions , but not all conditions represent errors.
Signaling is the process by which a condition can alter the ow of control in a program by raising
thecondition which can then be handled . The functions error ,cerror ,signal , andwarn are used
to signal conditions .
The process of signaling involves the selection and invocation of a handler from a set of active
handlers . A handler is a function of one argument (the condition ) that is invoked to handle a
condition . Each handler is associated with a condition type , and a handler will be invoked only on
acondition of the handler 's associated type.
Active handlers areestablished dynamically (see handler-bind orhandler-case ).Handlers are
invoked in a dynamic environment equivalent to that of the signaler, except that the set of active
handlers is bound in such a way as to include only those that were active at the time the handler
being invoked was established . Signaling a condition has no side-eect on the condition , and there
is no dynamic state contained in a condition .
If ahandler is invoked, it can address the situation in one of three ways:
Decline
It can decline to handle thecondition . It does this by simply returning rather than
transferring control. When this happens, any values returned by the handler are ignored
and the next most recently established handler is invoked. If there is no such handler
and the signaling function is error orcerror , the debugger is entered in the dynamic
environment of the signaler. If there is no such handler and the signaling function is either
signal orwarn , the signaling function simply returns nil.
Handle
It can handle thecondition by performing a non-local transfer of control. This can be done
either primitively by using go,return ,throw or more abstractly by using a function such
asabort orinvoke-restart .
Conditions 9–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Defer
It can put o a decision about whether to handle ordecline , by any of a number of actions,
but most commonly by signaling another condition, resignaling the same condition, or
forcing entry into the debugger.
9.1.1 Condition Types
Figure 9{1 lists the standardized condition types . Additional condition types can be dened by
usingdeﬁne-condition .
arithmetic-error ﬂoating-point-overﬂow simple-type-error
cell-error ﬂoating-point-underﬂow simple-warning
condition package-error storage-condition
control-error parse-error stream-error
division-by-zero print-not-readable style-warning
end-of-ﬁle program-error type-error
error reader-error unbound-slot
ﬁle-error serious-condition unbound-variable
ﬂoating-point-inexact simple-condition undeﬁned-function
ﬂoating-point-invalid-operation simple-error warning
Figure 9–1. Standardized Condition Types
Allcondition types are subtypes oftypecondition . That is,
(typep c’condition)!true
if and only if cis acondition .
Implementations must dene all specied subtype relationships. Except where noted, all subtype
relationships indicated in this document are not mutually exclusive. A condition inherits the
structure of its supertypes .
The metaclass of the classcondition is not specied. Names ofcondition types may be used to
specify supertype relationships in deﬁne-condition , but the consequences are not specied if an
attempt is made to use a condition type as a superclass in adefclass form .
Figure 9{2 shows operators that dene condition types and creating conditions .
deﬁne-condition make-condition
Figure 9–2. Operators that deﬁne and create conditions.
9–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Figure 9{3 shows operators that read thevalue ofcondition slots .
arithmetic-error-operands simple-condition-format-arguments
arithmetic-error-operation simple-condition-format-control
cell-error-name stream-error-stream
ﬁle-error-pathname type-error-datum
package-error-package type-error-expected-type
print-not-readable-object unbound-slot-instance
Figure 9–3. Operators that read condition slots.
9.1.1.1 Serious Conditions
Aserious condition is acondition serious enough to require interactive intervention if not handled.
Serious conditions are typically signaled with error orcerror ; non-serious conditions are typically
signaled with signal orwarn .
9.1.2 Creating Conditions
The function make-condition can be used to construct a condition object explicitly. Functions
such aserror ,cerror ,signal , andwarn operate on conditions and might create condition objects
implicitly. Macros such as ccase ,ctypecase ,ecase ,etypecase ,check-type , andassert might also
implicitly create (and signal )conditions .
9.1.2.1 Condition Designators
A number of the functions in the condition system take arguments which are identied as
condition designators . By convention, those arguments are notated as
datum&rest arguments
Taken together, the datum and the arguments are \ designators for a condition of default type
default-type ." How the denoted condition is computed depends on the type of the datum :
If the datum is asymbol naming a condition type :::
The denoted condition is the result of
(apply #’make-condition datum arguments )
Conditions 9–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If the datum is aformat control :::
The denoted condition is the result of
(make-condition defaulted-type
:format-control datum
:format-arguments arguments )
where the defaulted-type is asubtype ofdefault-type .
If the datum is acondition:::
The denoted condition is the datum itself. In this case, unless otherwise specied by the
description of the operator in question, the arguments must be null; that is, the consequences
are undened if any arguments were supplied.
Note that the default-type gets used only in the case where the datum string is supplied. In the
other situations, the resulting condition is not necessarily of type default-type .
Here are some illustrations of how dierent condition designators can denote equivalent condition
objects :
(let ((c (make-condition ’arithmetic-error :operator ’/ :operands ’(7 0))))
(error c))
(error ’arithmetic-error :operator ’/ :operands ’(7 0))
(error "Bad luck.")
(error ’simple-error :format-control "Bad luck." :format-arguments ’())
9.1.3 Printing Conditions
If the:report argument to deﬁne-condition is used, a print function is dened that is called
whenever the dened condition is printed while the value of*print-escape* isfalse. This function
is called the condition reporter ; the text which it outputs is called a report message .
When a condition is printed and *print-escape* isfalse, the condition reporter for the condition
is invoked. Conditions are printed automatically by functions such as invoke-debugger ,break ,
andwarn .
When*print-escape* istrue, the object should print in an abbreviated fashion according to the
style of the implementation ( e.g., byprint-unreadable-object ). It is not required that a condition
can be recreated by reading its printed representation.
Nofunction is provided for directly accessing or invoking condition reporters .
9–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
9.1.3.1 Recommended Style in Condition Reporting
In order to ensure a properly aesthetic result when presenting report messages to the user, certain
stylistic conventions are recommended.
There are stylistic recommendations for the content of the messages output by condition reporters ,
but there are no formal requirements on those programs . If a program violates the recommendations
for some message, the display of that message might be less aesthetic than if the guideline had
been observed, but the program is still considered a conforming program .
The requirements on a program orimplementation which invokes a condition reporter are somewhat
stronger. A conforming program must be permitted to assume that if these style guidelines are
followed, proper aesthetics will be maintained. Where appropriate, any specic requirements on
such routines are explicitly mentioned below.
9.1.3.1.1 Capitalization and Punctuation in Condition Reports
It is recommended that a report message be a complete sentences, in the proper case and correctly
punctuated. In English, for example, this means the rst letter should be uppercase, and there
should be a trailing period.
(error "This is a message") ; Not recommended
(error "this is a message.") ; Not recommended
(error "This is a message.") ; Recommended instead
9.1.3.1.2 Leading and Trailing Newlines in Condition Reports
It is recommended that a report message not begin with any introductory text, such as \ Error: "
or \Warning: " or even just freshline ornewline . Such text is added, if appropriate to the context,
by the routine invoking the condition reporter .
It is recommended that a report message not be followed by a trailing freshline ornewline . Such
text is added, if appropriate to the context, by the routine invoking the condition reporter .
(error "This is a message.~%") ; Not recommended
(error "~&This is a message.") ; Not recommended
(error "~&This is a message.~%") ; Not recommended
(error "This is a message.") ; Recommended instead
9.1.3.1.3 Embedded Newlines in Condition Reports
Especially if it is long, it is permissible and appropriate for a report message to contain one or
more embedded newlines .
If the calling routine conventionally inserts some additional prex (such as \ Error: " or
\;; Error: ") on the rst line of the message, it must also assure that an appropriate prex will
Conditions 9–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
be added to each subsequent line of the output, so that the left edge of the message output by the
condition reporter will still be properly aligned.
(defun test ()
(error "This is an error message.~%It has two lines."))
;; Implementation A
(test)
This is an error message.
It has two lines.
;; Implementation B
(test)
;; Error: This is an error message.
;; It has two lines.
;; Implementation C
(test)
» Error: This is an error message.
It has two lines.
9.1.3.1.4 Note about Tabs in Condition Reports
Because the indentation of a report message might be shifted to the right or left by an
arbitrary amount, special care should be taken with the semi-standard characterhTabi(in those
implementations that support such a character ). Unless the implementation specically denes its
behavior in this context, its use should be avoided.
9.1.3.1.5 Mentioning Containing Function in Condition Reports
The name of the containing function should generally not be mentioned in report messages . It is
assumed that the debugger will make this information accessible in situations where it is necessary
and appropriate.
9.1.4 Signaling and Handling Conditions
The operation of the condition system depends on the ordering of active applicable handlers from
most recent to least recent.
Each handler is associated with a type specier that must designate a subtype oftypecondition .
Ahandler is said to be applicable to a condition if that condition is of the type designated by the
associated type specier .
Active handlers areestablished by using handler-bind (or an abstraction based on handler-bind ,
such ashandler-case orignore-errors ).
Active handlers can be established within the dynamic scope of other active handlers . At any point
during program execution, there is a set of active handlers . When a condition is signaled, the most
9–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
recent active applicable handler for that condition is selected from this set. Given a condition , the
order of recentness of active applicable handlers is dened by the following two rules:
1. Each handler in a set of active handlers H1is more recent than every handler in a set H2
if the handlers in H2were active when the handlers in H1were established.
2. Leth1andh2be two applicable active handlers established by the same form . Thenh1is
more recent than h2ifh1was dened to the left of h2in the form that established them.
Once a handler in a handler binding form (such as handler-bind orhandler-case ) has been
selected, all handlers in that form become inactive for the remainder of the signaling process.
While the selected handler runs, no other handler established by that form is active. That is, if
thehandler declines, no other handler established by that form will be considered for possible
invocation.
Figure 9{4 shows operators relating to the handling ofconditions .
handler-bind handler-case ignore-errors
Figure 9–4. Operators relating to handling conditions.
9.1.4.1 Signaling
When a condition is signaled, the most recent applicable active handler is invoked. Sometimes a
handler will decline by simply returning without a transfer of control. In such cases, the next most
recent applicable active handler is invoked.
If there are no applicable handlers for a condition that has been signaled, or if all applicable
handlers decline, the condition is unhandled.
The functions cerror anderror invoke the interactive condition handler (the debugger) rather
than return if the condition being signaled, regardless of its type, is unhandled. In contrast, signal
returnsnilif the condition being signaled, regardless of its type, is unhandled.
The variable*break-on-signals* can be used to cause the debugger to be entered before the
signaling process begins.
Figure 9{5 shows dened names relating to the signaling ofconditions .
*break-on-signals* error warn
cerror signal
Figure 9–5. Deﬁned names relating to signaling conditions.
Conditions 9–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
9.1.4.1.1 Resignaling a Condition
During the dynamic extent of the signaling process for a particular condition object ,signaling the
same condition object again is permitted if and only if the situation represented in both cases are
the same.
For example, a handler might legitimately signal thecondition object that is its argument in order
to allow outer handlers rst opportunity to handle the condition. (Such a handlers is sometimes
called a \default handler.") This action is permitted because the situation which the second
signaling process is addressing is really the same situation .
On the other hand, in an implementation that implemented asynchronous keyboard events by
interrupting the user process with a call to signal , it would not be permissible for two distinct
asynchronous keyboard events to signal identical condition objects at the same time for dierent
situations.
9.1.4.2 Restarts
The interactive condition handler returns only through non-local transfer of control to specially
dened restarts that can be set up either by the system or by user code. Transferring control to a
restart is called \invoking" the restart. Like handlers, active restarts areestablished dynamically,
and only active restarts can be invoked. An active restart can be invoked by the user from the
debugger or by a program by using invoke-restart .
Arestart contains a function to be called when the restart is invoked, an optional name that
can be used to nd or invoke the restart , and an optional set of interaction information for the
debugger to use to enable the user to manually invoke a restart .
The name of a restart is used by invoke-restart .Restarts that can be invoked only within the
debugger do not need names.
Restarts can be established by using restart-bind ,restart-case , andwith-simple-restart . A
restart function can itself invoke any other restart that was active at the time of establishment of
therestart of which the function is part.
The restarts established by arestart-bind form , arestart-case form , or awith-simple-restart
form have dynamic extent which extends for the duration of that form 's execution.
Restarts of the same name can be ordered from least recent to most recent according to the
following two rules:
1. Each restart in a set of active restarts R1is more recent than every restart in a setR2if
therestarts inR2were active when the restarts inR1were established.
2. Letr1andr2be two active restarts with the same name established by the same form .
Thenr1is more recent than r2ifr1was dened to the left of r2in the form that established
them.
9–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If a restart is invoked but does not transfer control, the values resulting from the restart
function are returned by the function that invoked the restart, either invoke-restart or
invoke-restart-interactively .
9.1.4.2.1 Interactive Use of Restarts
For interactive handling, two pieces of information are needed from a restart : a report function
and an interactive function.
The report function is used by a program such as the debugger to present a description of the action
therestart will take. The report function is specied and established by the :report-function
keyword to restart-bind or the:report keyword to restart-case .
The interactive function, which can be specied using the :interactive-function keyword to
restart-bind or:interactive keyword to restart-case , is used when the restart is invoked
interactively, such as from the debugger, to produce a suitable list of arguments.
invoke-restart invokes the most recently established restart whose name is the same as the rst
argument to invoke-restart . If a restart is invoked interactively by the debugger and does not
transfer control but rather returns values, the precise action of the debugger on those values is
implementation-dened .
9.1.4.2.2 Interfaces to Restarts
Some restarts have functional interfaces, such as abort ,continue ,muﬄe-warning ,store-value ,
anduse-value . They are ordinary functions that use ﬁnd-restart andinvoke-restart internally,
that have the same name as the restarts they manipulate, and that are provided simply for
notational convenience.
Figure 9{6 shows dened names relating to restarts .
abort invoke-restart-interactively store-value
compute-restarts muﬄe-warning use-value
continue restart-bind with-simple-restart
ﬁnd-restart restart-case
invoke-restart restart-name
Figure 9–6. Deﬁned names relating to restarts.
9.1.4.2.3 Restart Tests
Each restart has an associated test, which is a function of one argument (a condition ornil) which
returns true if the restart should be visible in the current situation . This test is created by the
:test-function option to restart-bind or the:test option to restart-case .
Conditions 9–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
9.1.4.2.4 Associating a Restart with a Condition
Arestart can be \associated with" a condition explicitly by with-condition-restarts , or implicitly
byrestart-case . Such an assocation has dynamic extent .
A single restart may be associated with several conditions at the same time. A single condition
may have several associated restarts at the same time.
Active restarts associated with a particular condition can be detected by calling afunction such
asﬁnd-restart , supplying that condition as the condition argument . Active restarts can also be
detected without regard to any associated condition by calling such a function without a condition
argument , or by supplying a value of nilfor such an argument .
9.1.5 Assertions
Conditional signaling of conditions based on such things as key match, form evaluation, and type
are handled by assertion operators . Figure 9{7 shows operators relating to assertions.
assert check-type ecase
ccase ctypecase etypecase
Figure 9–7. Operators relating to assertions.
9.1.6 Notes about the Condition System’s Background
For a background reference to the abstract concepts detailed in this section, see Exceptional
Situations in Lisp . The details of that paper are not binding on this document, but may be helpful
in establishing a conceptual basis for understanding this material.
9–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
condition Condition Type
Class Precedence List:
condition ,t
Description:
All types of conditions , whether error or non-error, must inherit from this type.
No additional subtype relationships among the specied subtypes oftypecondition are allowed,
except when explicitly mentioned in the text; however implementations are permitted to introduce
additional types and one of these types can be a subtype of any number of the subtypes oftype
condition .
Whether a user-dened condition type hasslots that are accessible by with-slots isimplementation-
dependent . Furthermore, even in an implementation in which user-dened condition types would
have slots, it is implementation-dependent whether any condition types dened in this document
have such slots or, if they do, what their names might be; only the reader functions documented
by this specication may be relied upon by portable code.
Conforming code must observe the following restrictions related to conditions :
deﬁne-condition , notdefclass , must be used to dene new condition types .
make-condition , notmake-instance , must be used to create condition objects explicitly.
The:report option of deﬁne-condition , notdefmethod forprint-object , must be used to
dene a condition reporter.
slot-value ,slot-boundp ,slot-makunbound , andwith-slots must not be used on condition
objects . Instead, the appropriate accessor functions (dened by deﬁne-condition ) should
be used.
warning Condition Type
Class Precedence List:
warning ,condition ,t
Description:
The typewarning consists of all types of warnings.
Conditions 9–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
style-warning
style-warning Condition Type
Class Precedence List:
style-warning ,warning ,condition ,t
Description:
The typestyle-warning includes those conditions that represent situations involving code that is
conforming code but that is nevertheless considered to be faulty or substandard.
See Also:
muﬄe-warning
Notes:
Animplementation might signal such a condition if it encounters code that uses deprecated features
or that appears unaesthetic or inecient.
An `unused variable' warning must be of typestyle-warning .
In general, the question of whether code is faulty or substandard is a subjective decision to be
made by the facility processing that code. The intent is that whenever such a facility wishes to
complain about code on such subjective grounds, it should use this condition type so that any
clients who wish to redirect or mue superuous warnings can do so without risking that they will
be redirecting or muing other, more serious warnings.
serious-condition Condition Type
Class Precedence List:
serious-condition ,condition ,t
Description:
Allconditions serious enough to require interactive intervention if not handled should inherit from
thetypeserious-condition . This condition type is provided primarily so that it may be included
as a superclass of other condition types ; it is not intended to be signaled directly.
Notes:
Signaling a serious condition does not itself force entry into the debugger. However, except in the
unusual situation where the programmer can assure that no harm will come from failing to handle
9–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
aserious condition , such a condition is usually signaled with error rather than signal in order to
assure that the program does not continue without handling thecondition . (And conversely, it is
conventional to use signal rather than error to signal conditions which are not serious conditions ,
since normally the failure to handle a non-serious condition is not reason enough for the debugger
to be entered.)
error Condition Type
Class Precedence List:
error ,serious-condition ,condition ,t
Description:
The typeerror consists of all conditions that represent errors .
cell-error Condition Type
Class Precedence List:
cell-error ,error ,serious-condition ,condition ,t
Description:
The typecell-error consists of error conditions that occur during a location access . The name
of the oending cell is initialized by the :name initialization argument to make-condition , and is
accessed by the functioncell-error-name .
See Also:
cell-error-name
Conditions 9–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
cell-error-name Function
Syntax:
cell-error-name condition!name
Arguments and Values:
condition |acondition oftypecell-error .
name |an object .
Description:
Returns the name of the oending cell involved in the situation represented by condition .
The nature of the result depends on the specic type ofcondition . For example, if the condition is of
typeunbound-variable , the result is the name of the unbound variable which was being accessed ,
if the condition is of typeundeﬁned-function , this is the name of the undened function which was
being accessed , and if the condition is of typeunbound-slot , this is the name of the slotwhich was
being accessed .
See Also:
cell-error ,unbound-slot ,unbound-variable ,undeﬁned-function , Section 9.1 (Condition System
Concepts)
parse-error Condition Type
Class Precedence List:
parse-error ,error ,serious-condition ,condition ,t
Description:
The typeparse-error consists of error conditions that are related to parsing.
See Also:
parse-namestring ,reader-error
9–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
storage-condition Condition Type
Class Precedence List:
storage-condition ,serious-condition ,condition ,t
Description:
The typestorage-condition consists of serious conditions that relate to problems with memory
management that are potentially due to implementation-dependent limits rather than semantic
errors in conforming programs , and that typically warrant entry to the debugger if not handled.
Depending on the details of the implementation , these might include such problems as stack
overow, memory region overow, and storage exhausted.
Notes:
While some Common Lisp operations might signal storage-condition because they are dened to
create objects , it is unspecied whether operations that are not dened to create objects create
them anyway and so might also signal storage-condition . Likewise, the evaluator itself might
create objects and so might signal storage-condition . (The natural assumption might be that such
object creation is naturally inecient, but even that is implementation-dependent .) In general,
the entire question of how storage allocation is done is implementation-dependent , and so any
operation might signal storage-condition at any time. Because such a condition is indicative of a
limitation of the implementation or of the image rather than an error in a program ,objects oftype
storage-condition are not of typeerror .
assert Macro
Syntax:
assert test-form [(fplaceg*) [datum-formfargument-formg*]]
!nil
Arguments and Values:
test-form |aform ; always evaluated.
place |aplace ; evaluated if an error is signaled.
datum-form |aform that evaluates to a datum . Evaluated each time an error is to be signaled, or
not at all if no error is to be signaled.
argument-form |aform that evaluates to an argument . Evaluated each time an error is to be
signaled, or not at all if no error is to be signaled.
datum ,arguments |designators for a condition of default type error . (These designators are the
result of evaluating datum-form and each of the argument-forms .)
Conditions 9–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
assert
Description:
assert assures that test-form evaluates to true. If test-form evaluates to false,assert signals a
correctable error (denoted by datum and arguments ). Continuing from this error using the continue
restart makes it possible for the user to alter the values of the places beforeassert evaluates
test-form again. If the value of test-form isnon-nil ,assert returnsnil.
The places aregeneralized references to data upon which test-form depends, whose values can be
changed by the user in attempting to correct the error. Subforms of each place are only evaluated if
an error is signaled, and might be re-evaluated if the error is re-signaled (after continuing without
actually xing the problem). The order of evaluation of the places is not specied; see Section
5.1.1.1 (Evaluation of Subforms to Places). If a place form is supplied that produces more values
than there are store variables, the extra values are ignored. If the supplied form produces fewer
values than there are store variables, the missing values are set to nil.
Examples:
(setq x (make-array ’(3 5) :initial-element 3))
!#2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))
(setq y (make-array ’(3 5) :initial-element 7))
!#2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))
(defun matrix-multiply (a b)
(let ((*print-array* nil))
(assert (and (= (array-rank a) (array-rank b) 2)
(= (array-dimension a 1) (array-dimension b 0)))
(a b)
"Cannot multiply ~S by ~S." a b)
(really-matrix-multiply a b))) !MATRIX-MULTIPLY
(matrix-multiply x y)
.Correctable error in MATRIX-MULTIPLY:
.Cannot multiply #<ARRAY ...> by #<ARRAY ...>.
.Restart options:
.1: You will be prompted for one or more new values.
.2: Top level.
.Debug> :continue 1
.Value for A: x
.Value for B: (make-array ’(5 3) :initial-element 6)
!#2A((54 54 54 54 54)
(54 54 54 54 54)
(54 54 54 54 54)
(54 54 54 54 54)
(54 54 54 54 54))
(defun double-safely (x) (assert (numberp x) (x)) (+ x x))
(double-safely 4)
!8
9–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(double-safely t)
.Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.
.Restart options:
.1: You will be prompted for one or more new values.
.2: Top level.
.Debug> :continue 1
.Value for X: 7
!14
Aﬀected By:
*break-on-signals*
The set of active condition handlers .
See Also:
check-type ,error , Section 5.1 (Generalized Reference)
Notes:
The debugger need not include the test-form in the error message, and the places should not be
included in the message, but they should be made available for the user's perusal. If the user gives
the \continue" command, the values of any of the references can be altered. The details of this
depend on the implementation's style of user interface.
error Function
Syntax:
error datum&rest arguments!
Arguments and Values:
datum ,arguments |designators for a condition of default type simple-error .
Description:
error eectively invokes signal on the denoted condition .
If the condition is not handled, (invoke-debugger condition )is done. As a consequence of calling
invoke-debugger ,error cannot directly return; the only exit from error can come by non-local
transfer of control in a handler or by use of an interactive debugging command.
Examples:
(defun factorial (x)
(cond ((or (not (typep x ’integer)) (minusp x))
(error "~S is not a valid argument to FACTORIAL." x))
((zerop x) 1)
Conditions 9–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
error
(t (* x (factorial (- x 1))))))
!FACTORIAL
(factorial 20)
!2432902008176640000
(factorial -1)
.Error: -1 is not a valid argument to FACTORIAL.
.To continue, type :CONTINUE followed by an option number:
.1: Return to Lisp Toplevel.
.Debug>
(setq a ’fred)
!FRED
(if (numberp a) (1+ a) (error "~S is not a number." A))
.Error: FRED is not a number.
.To continue, type :CONTINUE followed by an option number:
.1: Return to Lisp Toplevel.
.Debug> :Continue 1
.Return to Lisp Toplevel.
(define-condition not-a-number (error)
((argument :reader not-a-number-argument :initarg :argument))
(:report (lambda (condition stream)
(format stream "~S is not a number."
(not-a-number-argument condition)))))
!NOT-A-NUMBER
(if (numberp a) (1+ a) (error ’not-a-number :argument a))
.Error: FRED is not a number.
.To continue, type :CONTINUE followed by an option number:
.1: Return to Lisp Toplevel.
.Debug> :Continue 1
.Return to Lisp Toplevel.
Side Eﬀects:
Handlers for the specied condition, if any, are invoked and might have side eects. Program
execution might stop, and the debugger might be entered.
Aﬀected By:
Existing handler bindings.
*break-on-signals*
Signals an error of typetype-error ifdatum and arguments are not designators for a condition .
See Also:
cerror ,signal ,format ,ignore-errors ,*break-on-signals* ,handler-bind , Section 9.1 (Condition
9–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
System Concepts)
Notes:
Some implementations may provide debugger commands for interactively returning from individual
stack frames. However, it should be possible for the programmer to feel condent about writing
code like:
(defun wargames:no-win-scenario ()
(if (error "pushing the button would be stupid."))
(push-the-button))
In this scenario, there should be no chance that error will return and the button will get pushed.
While the meaning of this program is clear and it might be proven `safe' by a formal theorem
prover, such a proof is no guarantee that the program is safe to execute. Compilers have been
known to have bugs, computers to have signal glitches, and human beings to manually intervene
in ways that are not always possible to predict. Those kinds of errors, while beyond the scope of
the condition system to formally model, are not beyond the scope of things that should seriously
be considered when writing code that could have the kinds of sweeping eects hinted at by this
example.
cerror Function
Syntax:
cerror continue-format-control datum &rest arguments!nil
Arguments and Values:
Continue-format-control |aformat control .
datum ,arguments |designators for a condition of default type simple-error .
Description:
cerror eectively invokes error on the condition named by datum . As with any function that
implicitly calls error , if the condition is not handled, (invoke-debugger condition )is executed.
While signaling is going on, and while in the debugger if it is reached, it is possible to continue
code execution ( i.e., to return from cerror ) using the continue restart .
Ifdatum is a condition ,arguments can be supplied, but are used only in conjunction with the
continue-format-control .
Examples:
(defun real-sqrt (n)
(when (minusp n)
(setq n (- n))
Conditions 9–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
cerror
(cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
(sqrt n))
(real-sqrt 4)
!2.0
(real-sqrt -9)
.Correctable error in REAL-SQRT: Tried to take sqrt(-9).
.Restart options:
.1: Return sqrt(9) instead.
.2: Top level.
.Debug> :continue 1
!3.0
(define-condition not-a-number (error)
((argument :reader not-a-number-argument :initarg :argument))
(:report (lambda (condition stream)
(format stream "~S is not a number."
(not-a-number-argument condition)))))
(defun assure-number (n)
(loop (when (numberp n) (return n))
(cerror "Enter a number."
’not-a-number :argument n)
(format t "~&Type a number: ")
(setq n (read))
(fresh-line)))
(assure-number ’a)
.Correctable error in ASSURE-NUMBER: A is not a number.
.Restart options:
.1: Enter a number.
.2: Top level.
.Debug> :continue 1
.Type a number: 1/2
!1/2
(defun assure-large-number (n)
(loop (when (and (numberp n) (> n 73)) (return n))
(cerror "Enter a number~:[~; a bit larger than ~D~]."
"~*~A is not a large number."
(numberp n) n)
(format t "~&Type a large number: ")
(setq n (read))
(fresh-line)))
9–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
cerror
(assure-large-number 10000)
!10000
(assure-large-number ’a)
.Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
.Restart options:
.1: Enter a number.
.2: Top level.
.Debug> :continue 1
.Type a large number: 88
!88
(assure-large-number 37)
.Correctable error in ASSURE-LARGE-NUMBER: 37 is not a large number.
.Restart options:
.1: Enter a number a bit larger than 37.
.2: Top level.
.Debug> :continue 1
.Type a large number: 259
!259
(define-condition not-a-large-number (error)
((argument :reader not-a-large-number-argument :initarg :argument))
(:report (lambda (condition stream)
(format stream "~S is not a large number."
(not-a-large-number-argument condition)))))
(defun assure-large-number (n)
(loop (when (and (numberp n) (> n 73)) (return n))
(cerror "Enter a number~3*~:[~; a bit larger than ~*~D~]."
’not-a-large-number
:argument n
:ignore (numberp n)
:ignore n
:allow-other-keys t)
(format t "~&Type a large number: ")
(setq n (read))
(fresh-line)))
(assure-large-number ’a)
.Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
.Restart options:
.1: Enter a number.
Conditions 9–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.2: Top level.
.Debug> :continue 1
.Type a large number: 88
!88
(assure-large-number 37)
.Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
.Restart options:
.1: Enter a number a bit larger than 37.
.2: Top level.
.Debug> :continue 1
.Type a large number: 259
!259
Aﬀected By:
*break-on-signals* .
Existing handler bindings.
See Also:
error ,format ,handler-bind ,*break-on-signals* ,simple-type-error
Notes:
Ifdatum is acondition type rather than a string , theformat directive ~*may be especially useful
in the continue-format-control in order to ignore the keywords in the initialization argument list .
For example:
(cerror "enter a new value to replace ~*~s"
’not-a-number
:argument a)
check-type Macro
Syntax:
check-type place typespec [string ]!nil
Arguments and Values:
place |aplace .
typespec |atype specier .
string |astring ; evaluated.
9–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
check-type
Description:
check-type signals a correctable error oftypetype-error if the contents of place are not of the
type typespec .
check-type can return only if the store-value restart is invoked, either explicitly from a handler
or implicitly as one of the options oered by the debugger. If the store-value restart is invoked,
check-type stores the new value that is the argument to the restart invocation (or that is prompted
for interactively by the debugger) in place and starts over, checking the type of the new value and
signaling another error if it is still not of the desired type.
The rst time place isevaluated , it is evaluated by normal evaluation rules. It is later evaluated as
aplace if the type check fails and the store-value restart is used; see Section 5.1.1.1 (Evaluation of
Subforms to Places).
string should be an English description of the type, starting with an indenite article (\a" or
\an"). If string is not supplied, it is computed automatically from typespec . The automatically
generated message mentions place , its contents, and the desired type. An implementation may
choose to generate a somewhat dierently worded error message if it recognizes that place is of a
particular form, such as one of the arguments to the function that called check-type .string is
allowed because some applications of check-type may require a more specic description of what
is wanted than can be generated automatically from typespec .
Examples:
(setq aardvarks ’(sam harry fred))
!(SAM HARRY FRED)
(check-type aardvarks (array * (3)))
.Error: The value of AARDVARKS, (SAM HARRY FRED),
. is not a 3-long array.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a value to use instead.
.2: Return to Lisp Toplevel.
.Debug> :CONTINUE 1
.Use Value: #(SAM FRED HARRY)
!NIL
aardvarks
!#<ARRAY-T-3 13571>
(map ’list #’identity aardvarks)
!(SAM FRED HARRY)
(setq aardvark-count ’foo)
!FOO
(check-type aardvark-count (integer 0 *) "A positive integer")
.Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a value to use instead.
.2: Top level.
Conditions 9–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
check-type
.Debug> :CONTINUE 2
(defmacro define-adder (name amount)
(check-type name (and symbol (not null)) "a name for an adder function")
(check-type amount integer)
‘(defun ,name (x) (+ x ,amount)))
(macroexpand ’(define-adder add3 3))
!(defun add3 (x) (+ x 3))
(macroexpand ’(define-adder 7 7))
.Error: The value of NAME, 7, is not a name for an adder function.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a value to use instead.
.2: Top level.
.Debug> :Continue 1
.Specify a value to use instead.
.Type a form to be evaluated and used instead: ’ADD7
!(defun add7 (x) (+ x 7))
(macroexpand ’(define-adder add5 something))
.Error: The value of AMOUNT, SOMETHING, is not an integer.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a value to use instead.
.2: Top level.
.Debug> :Continue 1
.Type a form to be evaluated and used instead: 5
!(defun add5 (x) (+ x 5))
Control is transferred to a handler.
Side Eﬀects:
The debugger might be entered.
Aﬀected By:
*break-on-signals*
The implementation.
See Also:
Section 9.1 (Condition System Concepts)
Notes:
(check-type place typespec )
9–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(assert (typep place’typespec ) (place)
’type-error :datum place:expected-type ’ typespec )
simple-error Condition Type
Class Precedence List:
simple-error ,simple-condition ,error ,serious-condition ,condition ,t
Description:
The typesimple-error consists of conditions that are signaled by error orcerror when a format
control is supplied as the function's rst argument.
invalid-method-error Function
Syntax:
invalid-method-error method format-control &rest args!implementation-dependent
Arguments and Values:
method |amethod .
format-control |aformat control .
args|format arguments for the format-control .
Description:
The function invalid-method-error is used to signal an error of typeerror when there is an
applicable method whose qualiers are not valid for the method combination type. The error
message is constructed by using the format-control suitable for format and any args to it. Because
an implementation may need to add additional contextual information to the error message,
invalid-method-error should be called only within the dynamic extent of a method combination
function.
The function invalid-method-error is called automatically when a method fails to satisfy every
qualier pattern and predicate in a deﬁne-method-combination form . A method combination
function that imposes additional restrictions should call invalid-method-error explicitly if it
encounters a method it cannot accept.
Whether invalid-method-error returns to its caller or exits via throw isimplementation-dependent .
Conditions 9–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Side Eﬀects:
The debugger might be entered.
Aﬀected By:
*break-on-signals*
See Also:
deﬁne-method-combination
method-combination-error Function
Syntax:
method-combination-error format-control &rest args!implementation-dependent
Arguments and Values:
format-control |aformat control .
args|format arguments forformat-control .
Description:
The functionmethod-combination-error is used to signal an error in method combination.
The error message is constructed by using a format-control suitable for format and any args to
it. Because an implementation may need to add additional contextual information to the error
message, method-combination-error should be called only within the dynamic extent of a method
combination function.
Whether method-combination-error returns to its caller or exits via throw isimplementation-
dependent .
Side Eﬀects:
The debugger might be entered.
Aﬀected By:
*break-on-signals*
See Also:
deﬁne-method-combination
9–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
signal
signal Function
Syntax:
signal datum&rest arguments!nil
Arguments and Values:
datum ,arguments |designators for a condition of default type simple-condition .
Description:
Signals thecondition denoted by the given datum and arguments . If the condition is not handled,
signal returnsnil.
Examples:
(defun handle-division-conditions (condition)
(format t "Considering condition for division condition handling~%")
(when (and (typep condition ’arithmetic-error)
(eq ’/ (arithmetic-error-operation condition)))
(invoke-debugger condition)))
HANDLE-DIVISION-CONDITIONS
(defun handle-other-arithmetic-errors (condition)
(format t "Considering condition for arithmetic condition handling~%")
(when (typep condition ’arithmetic-error)
(abort)))
HANDLE-OTHER-ARITHMETIC-ERRORS
(define-condition a-condition-with-no-handler (condition) ())
A-CONDITION-WITH-NO-HANDLER
(signal ’a-condition-with-no-handler)
NIL
(handler-bind ((condition #’handle-division-conditions)
(condition #’handle-other-arithmetic-errors))
(signal ’a-condition-with-no-handler))
Considering condition for division condition handling
Considering condition for arithmetic condition handling
NIL
(handler-bind ((arithmetic-error #’handle-division-conditions)
(arithmetic-error #’handle-other-arithmetic-errors))
(signal ’arithmetic-error :operation ’* :operands ’(1.2 b)))
Considering condition for division condition handling
Considering condition for arithmetic condition handling
Back to Lisp Toplevel
Side Eﬀects:
The debugger might be entered due to *break-on-signals* .
Conditions 9–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Handlers for the condition being signaled might transfer control.
Aﬀected By:
Existing handler bindings.
*break-on-signals*
See Also:
*break-on-signals* ,error ,simple-condition , Section 9.1.4 (Signaling and Handling Conditions)
Notes:
If(typep datum*break-on-signals*) yields true , the debugger is entered prior to beginning the
signaling process. The continue restart can be used to continue with the signaling process. This is
also true for all other functions and macros that should, might, or must signal conditions .
simple-condition Condition Type
Class Precedence List:
simple-condition ,condition ,t
Description:
The typesimple-condition represents conditions that are signaled by signal whenever a format-
control is supplied as the function's rst argument. The format control and format arguments
are initialized with the initialization arguments named :format-control and:format-arguments
tomake-condition , and are accessed by the functions simple-condition-format-control and
simple-condition-format-arguments . If format arguments are not supplied to make-condition ,
nilis used as a default.
See Also:
simple-condition-format-control ,simple-condition-format-arguments
9–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
simple-condition-format-control,simple-
condition-format-arguments Function
Syntax:
simple-condition-format-control condition!format-control
simple-condition-format-arguments condition!format-arguments
Arguments and Values:
condition |acondition oftypesimple-condition .
format-control |aformat control .
format-arguments |alist.
Description:
simple-condition-format-control returns the format control needed to process the condition 's
format arguments .
simple-condition-format-arguments returns a listofformat arguments needed to process the
condition 'sformat control .
Examples:
(setq foo (make-condition ’simple-condition
:format-control "Hi ~S"
:format-arguments ’(ho)))
!#<SIMPLE-CONDITION 26223553>
(apply #’format nil (simple-condition-format-control foo)
(simple-condition-format-arguments foo))
!"Hi HO"
See Also:
simple-condition , Section 9.1 (Condition System Concepts)
warn Function
Syntax:
warn datum&rest arguments!nil
Arguments and Values:
datum ,arguments |designators for a condition of default type simple-warning .
Conditions 9–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
warn
Description:
Signals acondition oftypewarning . If the condition is not handled , reports the condition toerror
output .
The precise mechanism for warning is as follows:
The warning condition is signaled
While the warning condition is being signaled, the muﬄe-warning restart is established
for use by a handler . If invoked, this restart bypasses further action by warn , which in
turn causes warn to immediately return nil.
If no handler for the warning condition is found
If no handlers for the warning condition are found, or if all such handlers decline, then the
condition is reported to error output bywarn in an implementation-dependent format.
nilis returned
The value returned by warn if it returns is nil.
Examples:
(defun foo (x)
(let ((result (* x 2)))
(if (not (typep result ’fixnum))
(warn "You’re using very big numbers."))
result))
!FOO
(foo 3)
!6
(foo most-positive-fixnum)
.Warning: You’re using very big numbers.
!4294967294
(setq *break-on-signals* t)
!T
(foo most-positive-fixnum)
.Break: Caveat emptor.
.To continue, type :CONTINUE followed by an option number.
.1: Return from Break.
.2: Abort to Lisp Toplevel.
.Debug> :continue 1
9–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.Warning: You’re using very big numbers.
!4294967294
Side Eﬀects:
A warning is issued. The debugger might be entered.
Aﬀected By:
Existing handler bindings.
*break-on-signals* ,*error-output* .
Exceptional Situations:
Ifdatum is a condition and if the condition is not of typewarning , or arguments isnon-nil , an
error of typetype-error is signaled.
Ifdatum is a condition type, the result of (apply #’make-condition datum arguments) must be of
typewarning or an error of typetype-error is signaled.
See Also:
*break-on-signals* ,muﬄe-warning ,signal
simple-warning Condition Type
Class Precedence List:
simple-warning ,simple-condition ,warning ,condition ,t
Description:
The typesimple-warning represents conditions that are signaled by warn whenever a format
control is supplied as the function's rst argument.
Conditions 9–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
invoke-debugger Function
Syntax:
invoke-debugger condition!
Arguments and Values:
condition |acondition object .
Description:
invoke-debugger attempts to enter the debugger with condition .
If*debugger-hook* is notnil, it should be a function (or the name of a function ) to be called
prior to entry to the standard debugger. The function is called with *debugger-hook* bound to
nil, and the function must accept two arguments: the condition and the value of*debugger-hook*
prior to binding it to nil. If the function returns normally, the standard debugger is entered.
The standard debugger never directly returns. Return can occur only by a non-local transfer of
control, such as the use of a restart function.
Examples:
(ignore-errors ;Normally, this would suppress debugger entry
(handler-bind ((error #’invoke-debugger)) ;But this forces debugger entry
(error "Foo.")))
Debug: Foo.
To continue, type :CONTINUE followed by an option number:
1: Return to Lisp Toplevel.
Debug>
Side Eﬀects:
*debugger-hook* is bound to nil, program execution is discontinued, and the debugger is entered.
Aﬀected By:
*debug-io* and*debugger-hook* .
See Also:
error ,break
9–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
break
break Function
Syntax:
break&optional format-control &rest format-arguments !nil
Arguments and Values:
format-control |aformat control . The default is implementation-dependent .
format-arguments |format arguments for the format-control .
Description:
break formats format-control and format-arguments and then goes directly into the debugger
without allowing any possibility of interception by programmed error-handling facilities.
If thecontinue restart is used while in the debugger, break immediately returns nilwithout taking
any unusual recovery action.
break binds*debugger-hook* tonilbefore attempting to enter the debugger.
Examples:
(break "You got here with arguments: ~:S." ’(FOO 37 A))
.BREAK: You got here with these arguments: FOO, 37, A.
.To continue, type :CONTINUE followed by an option number:
.1: Return from BREAK.
.2: Top level.
.Debug> :CONTINUE 1
.Return from BREAK.
!NIL
Side Eﬀects:
The debugger is entered.
Aﬀected By:
*debug-io* .
See Also:
error ,invoke-debugger .
Notes:
break is used as a way of inserting temporary debugging \breakpoints" in a program, not as a way
of signaling errors. For this reason, break does not take the continue-format-control argument that
cerror takes. This and the lack of any possibility of interception by condition handling are the
only program-visible dierences between break andcerror .
Conditions 9–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The user interface aspects of break andcerror are permitted to vary more widely, in order to
accomodate the interface needs of the implementation . For example, it is permissible for a Lisp
read-eval-print loop to be entered by break rather than the conventional debugger.
break could be dened by:
(defun break (&optional (format-control "Break") &rest format-arguments)
(with-simple-restart (continue "Return from BREAK.")
(let ((*debugger-hook* nil))
(invoke-debugger
(make-condition ’simple-condition
:format-control format-control
:format-arguments format-arguments))))
nil)
debugger-hook Variable
Value Type:
adesignator for a function of two arguments (acondition and the value of*debugger-hook* at
the time the debugger was entered), or nil.
Initial Value:
nil.
Description:
When the value of*debugger-hook* isnon-nil , it is called prior to normal entry into the debugger,
either due to a call to invoke-debugger or due to automatic entry into the debugger from a
call toerror orcerror with a condition that is not handled. The function may either handle
thecondition (transfer control) or return normally (allowing the standard debugger to run). To
minimize recursive errors while debugging, *debugger-hook* is bound to nilbyinvoke-debugger
prior to calling the function .
Examples:
(defun one-of (choices &optional (prompt "Choice"))
(let ((n (length choices)) (i))
(do ((c choices (cdr c)) (i 1 (+ i 1)))
((null c))
(format t "~&[~D] ~A~%" i (car c)))
(do () ((typep i ‘(integer 1 ,n)))
(format t "~&~A: " prompt)
(setq i (read))
9–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(fresh-line))
(nth (- i 1) choices)))
(defun my-debugger (condition me-or-my-encapsulation)
(format t "~&Fooey: ~A" condition)
(let ((restart (one-of (compute-restarts))))
(if (not restart) (error "My debugger got an error."))
(let ((*debugger-hook* me-or-my-encapsulation))
(invoke-restart-interactively restart))))
(let ((*debugger-hook* #’my-debugger))
(+ 3 ’a))
.Fooey: The argument to +, A, is not a number.
.[1] Supply a replacement for A.
.[2] Return to Cloe Toplevel.
.Choice: 1
.Form to evaluate and use: (+ 5 ’b)
.Fooey: The argument to +, B, is not a number.
.[1] Supply a replacement for B.
.[2] Supply a replacement for A.
.[3] Return to Cloe Toplevel.
.Choice: 1
.Form to evaluate and use: 1
!9
Aﬀected By:
invoke-debugger
Notes:
When evaluating code typed in by the user interactively, it is sometimes useful to have the hook
function bind *debugger-hook* to the function that was its second argument so that recursive
errors can be handled using the same interactive facility.
break-on-signals  Variable
Value Type:
atype specier .
Initial Value:
nil.
Conditions 9–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
break-on-signals 
Description:
When(typep condition *break-on-signals*) returns true, calls to signal , and to other operators
such aserror that implicitly call signal , enter the debugger prior to signaling thecondition .
Thecontinue restart can be used to continue with the normal signaling process when a break
occurs process due to *break-on-signals* .
Examples:
*break-on-signals* !NIL
(ignore-errors (error ’simple-error :format-control "Fooey!"))
!NIL, #<SIMPLE-ERROR 32207172>
(let ((*break-on-signals* ’error))
(ignore-errors (error ’simple-error :format-control "Fooey!")))
.Break: Fooey!
.BREAK entered because of *BREAK-ON-SIGNALS*.
.To continue, type :CONTINUE followed by an option number:
.1: Continue to signal.
.2: Top level.
.Debug> :CONTINUE 1
.Continue to signal.
!NIL, #<SIMPLE-ERROR 32212257>
(let ((*break-on-signals* ’error))
(error ’simple-error :format-control "Fooey!"))
.Break: Fooey!
.BREAK entered because of *BREAK-ON-SIGNALS*.
.To continue, type :CONTINUE followed by an option number:
.1: Continue to signal.
.2: Top level.
.Debug> :CONTINUE 1
.Continue to signal.
.Error: Fooey!
.To continue, type :CONTINUE followed by an option number:
.1: Top level.
.Debug> :CONTINUE 1
.Top level.
See Also:
break ,signal ,warn ,error ,typep , Section 9.1 (Condition System Concepts)
Notes:
*break-on-signals* is intended primarily for use in debugging code that does signaling. When
setting*break-on-signals* , the user is encouraged to choose the most restrictive specication
9–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
that suces. Setting *break-on-signals* eectively violates the modular handling of condition
signaling. In practice, the complete eect of setting *break-on-signals* might be unpredictable in
some cases since the user might not be aware of the variety or number of calls to signal that are
used in code called only incidentally.
*break-on-signals* enables an early entry to the debugger but such an entry does not preclude an
additional entry to the debugger in the case of operations such as error andcerror .
handler-bind Macro
Syntax:
handler-bind (f#bindingg*)fformg*!f resultg*
binding:: =(type handler )
Arguments and Values:
type|atype specier .
handler |aform ; evaluated to produce a handler-function .
handler-function |adesignator for a function of one argument .
forms |an implicit progn .
results |the values returned by the forms .
Description:
Executes forms in a dynamic environment where the indicated handler bindings are in eect.
Each handler should evaluate to a handler-function , which is used to handle conditions of the given
type during execution of the forms . This function should take a single argument, the condition
being signaled.
If more than one handler binding is supplied, the handler bindings are searched sequentially from
top to bottom in search of a match (by visual analogy with typecase ). If an appropriate type
is found, the associated handler is run in a dynamic environment where none of these handler
bindings are visible (to avoid recursive errors). If the handler declines , the search continues for
another handler .
If no appropriate handler is found, other handlers are sought from dynamically enclosing contours.
If no handler is found outside, then signal returns or error enters the debugger.
Examples:
In the following code, if an unbound variable error is signaled in the body (and not handled by an
intervening handler), the rst function is called.
Conditions 9–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(handler-bind ((unbound-variable #’(lambda ...))
(error #’(lambda ...)))
...)
If any other kind of error is signaled, the second function is called. In either case, neither handler
is active while executing the code in the associated function.
(defun trap-error-handler (condition)
(format *error-output* "~&~A~&" condition)
(throw ’trap-errors nil))
(defmacro trap-errors (&rest forms)
‘(catch ’trap-errors
(handler-bind ((error #’trap-error-handler))
,@forms)))
(list (trap-errors (signal "Foo.") 1)
(trap-errors (error "Bar.") 2)
(+ 1 2))
.Bar.
!(1 NIL 3)
Note that \Foo." is not printed because the condition made by signal is asimple condition , which
is not of typeerror , so it doesn't trigger the handler for error set up by trap-errors .
See Also:
handler-case
handler-case Macro
Syntax:
handler-case expression [ [f#error-clauseg*j#no-error-clause ] ]!f resultg*
clause:: =#error-clausej#no-error-clause
error-clause:: =(typespec ([var])fdeclarationg*fformg*)
no-error-clause:: =(:no-error lambda-listfdeclarationg*fformg*)
Arguments and Values:
expression |aform .
typespec |atype specier .
9–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
handler-case
var|avariable name .
lambda-list |an ordinary lambda list .
declaration |adeclare expression ; not evaluated.
form|aform .
results |In the normal situation, the values returned are those that result from the evaluation of
expression ; in the exceptional situation when control is transferred to a clause , the value of the last
form in that clause is returned.
Description:
handler-case executes expression in adynamic environment where various handlers are active. Each
error-clause species how to handle a condition matching the indicated typespec . Ano-error-clause
allows the specication of a particular action if control returns normally.
If a condition is signaled for which there is an appropriate error-clause during the execution
ofexpression (i.e., one for which (typep condition ’typespec )returns true) and if there is no
intervening handler for a condition of that type, then control is transferred to the body of the
relevant error-clause . In this case, the dynamic state is unwound appropriately (so that the
handlers established around the expression are no longer active), and varis bound to the condition
that had been signaled. If more than one case is provided, those cases are made accessible in
parallel. That is, in
(handler-case form
(typespec1 (var1)form1)
(typespec2 (var2)form2))
if the rst clause (containing form1 ) has been selected, the handler for the second is no longer
visible (or vice versa).
The clauses are searched sequentially from top to bottom. If there is type overlap between
typespecs , the earlier of the clauses is selected.
Ifvaris not needed, it can be omitted. That is, a clause such as:
(typespec (var) (declare (ignore var))form)
can be written (typespec ()form).
If there are no forms in a selected clause , the case, and therefore handler-case , returns nil.
If execution of expression returns normally and no no-error-clause exists, the values returned
byexpression are returned by handler-case . If execution of expression returns normally and a
no-error-clause does exist, the values returned are used as arguments to the function described
by constructing (lambda lambda-listfformg*)from the no-error-clause , and the values of that
function call are returned by handler-case . The handlers which were established around the
expression are no longer active at the time of this call.
Conditions 9–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
handler-case
Examples:
(defun assess-condition (condition)
(handler-case (signal condition)
(warning () "Lots of smoke, but no fire.")
((or arithmetic-error control-error cell-error stream-error)
(condition)
(format nil "~S looks especially bad." condition))
(serious-condition (condition)
(format nil "~S looks serious." condition))
(condition () "Hardly worth mentioning.")))
!ASSESS-CONDITION
(assess-condition (make-condition ’stream-error :stream *terminal-io*))
!"#<STREAM-ERROR 12352256> looks especially bad."
(define-condition random-condition (condition) ()
(:report (lambda (condition stream)
(declare (ignore condition))
(princ "Yow" stream))))
!RANDOM-CONDITION
(assess-condition (make-condition ’random-condition))
!"Hardly worth mentioning."
See Also:
handler-bind ,ignore-errors , Section 9.1 (Condition System Concepts)
Notes:
(handler-case form
(type1(var1) .body1)
(type2(var2) .body2) ...)
is approximately equivalent to:
(block #1=#:g0001
(let ((#2=#:g0002 nil))
(tagbody
(handler-bind (( type1#’(lambda (temp)
(setq #1# temp)
(go #3=#:g0003)))
(type2#’(lambda (temp)
(setq #2# temp)
(go #4=#:g0004))) ...)
(return-from #1# form))
#3# (return-from #1# (let (( var1#2#)) . body1))
#4# (return-from #1# (let (( var2#2#)) . body2)) ...)))
(handler-case form
9–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(type1 (var1) .body1)
...
(:no-error ( varN-1 varN-2 ...) . bodyN))
is approximately equivalent to:
(block #1=#:error-return
(multiple-value-call #’(lambda ( varN-1 varN-2 ...) . bodyN)
(block #2=#:normal-return
(return-from #1#
(handler-case (return-from #2# form)
(type1(var1) .body1) ...)))))
ignore-errors Macro
Syntax:
ignore-errorsfformg*!f resultg*
Arguments and Values:
forms |an implicit progn .
results |In the normal situation, the values of the forms are returned; in the exceptional situation,
two values are returned: niland the condition .
Description:
ignore-errors is used to prevent conditions oftypeerror from causing entry into the debugger.
Specically, ignore-errors executes forms in adynamic environment where a handler forconditions
oftypeerror has been established; if invoked, it handles such conditions by returning two values ,
niland the condition that was signaled , from the ignore-errors form .
If anormal return from the forms occurs, any values returned are returned by ignore-errors .
Examples:
(defun load-init-file (program)
(let ((win nil))
(ignore-errors ;if this fails, don’t enter debugger
(load (merge-pathnames (make-pathname :name program :type :lisp)
(user-homedir-pathname)))
(setq win t))
(unless win (format t "~&Init file failed to load.~%"))
win))
Conditions 9–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(load-init-file "no-such-program")
.Init file failed to load.
NIL
See Also:
handler-case , Section 9.1 (Condition System Concepts)
Notes:
(ignore-errors . forms)
is equivalent to:
(handler-case (progn . forms)
(error (condition) (values nil condition)))
Because the second return value is a condition in the exceptional case, it is common (but not
required) to arrange for the second return value in the normal case to be missing or nilso that the
two situations can be distinguished.
deﬁne-condition Macro
Syntax:
deﬁne-condition name (fparent-typeg*) (f#slot-specg*)foptiong*
!name
slot-spec:: =slot-namej(slot-name#slot-option )
slot-option:: =[ [f:reader symbolg*j
f:writer#function-nameg*j
f:accessor symbolg*j
f:allocation#allocation-typegj
f:initarg symbolg*j
f:initform formgj
f:type type-specierg] ]
option:: =[ [(:default-initargs . initarg-list )j
(:documentation string )j
(:report report-name )] ]
9–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-condition
function-name:: =fsymbolj(setf symbol)g
allocation-type:: =:instancej:class
report-name:: =stringjsymboljlambda expression
Arguments and Values:
name |asymbol .
parent-type |asymbol naming a condition type . If no parent-types are supplied, the parent-types
default to (condition) .
default-initargs |alistofkeyword/value pairs .
Slot-spec { the name of a slotor a listconsisting of the slot-name followed by zero or more
slot-options .
Slot-name { a slot name (a symbol ), the listof a slot name, or the listof slot name/slot form pairs.
Option { Any of the following:
:reader
:reader can be supplied more than once for a given slotand cannot be nil.
:writer
:writer can be supplied more than once for a given slotand must name a generic function .
:accessor
:accessor can be supplied more than once for a given slotand cannot be nil.
:allocation
:allocation can be supplied once at most for a given slot. The default if :allocation is
not supplied is :instance .
:initarg
:initarg can be supplied more than once for a given slot.
:initform
:initform can be supplied once at most for a given slot.
:type
:type can be supplied once at most for a given slot.
Conditions 9–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-condition
:documentation
:documentation can be supplied once at most for a given slot.
:report
:report can be supplied once at most.
Description:
deﬁne-condition denes a new condition type called name , which is a subtype of the type ortypes
named by parent-type . Each parent-type argument species a direct supertype of the new condition .
The new condition inherits slots and methods from each of its direct supertypes , and so on.
If a slot name/slot form pair is supplied, the slot form is a form that can be evaluated by
make-condition to produce a default value when an explicit value is not provided. If no slot form
is supplied, the contents of the slotis initialized in an implementation-dependent way.
If the type being dened and some other type from which it inherits have a slot by the same name,
only one slot is allocated in the condition , but the supplied slot form overrides any slot form that
might otherwise have been inherited from a parent-type . If no slot form is supplied, the inherited
slot form (if any) is still visible.
Accessors are created according to the same rules as used by defclass .
A description of slot-options follows:
:reader
The:reader slot option species that an unqualied method is to be dened on the generic
function named by the argument to :reader to read the value of the given slot.
The:initform slot option is used to provide a default initial value form to be used in
the initialization of the slot. This form is evaluated every time it is used to initialize the
slot. The lexical environment in which this form is evaluated is the lexical environment
in which the deﬁne-condition form was evaluated. Note that the lexical environment
refers both to variables and to functions . For local slots , the dynamic environment is
the dynamic environment in which make-condition was called; for shared slots , the
dynamic environment is the dynamic environment in which the deﬁne-condition form was
evaluated.
No implementation is permitted to extend the syntax of deﬁne-condition to allow
(slot-name form )as an abbreviation for (slot-name :initform form).
:initarg
The:initarg slot option declares an initialization argument named by its symbol argument
and species that this initialization argument initializes the given slot. If the initialization
9–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-condition
argument has a value in the call to initialize-instance , the value is stored into the given
slot, and the slot's :initform slot option, if any, is not evaluated. If none of the initialization
arguments specied for a given slothas a value, the slotis initialized according to the
:initform slot option, if specied.
:type
The:type slot option species that the contents of the slotis always of the specied type.
It eectively declares the result type of the reader generic function when applied to an
object of this condition type. The consequences of attempting to store in a slota value
that does not satisfy the type of the slotis undened.
:default-initargs
This option is treated the same as it would be defclass .
:documentation
The:documentation slot option provides a documentation string for the slot.
:report
Condition reporting is mediated through the print-object method for the condition type
in question, with *print-escape* always being nil. Specifying (:report report-name )in
the denition of a condition type Cis equivalent to:
(defmethod print-object ((x c) stream)
(if *print-escape* (call-next-method) ( report-name x stream)))
If the value supplied by the argument to :report (report-name ) is a symbol or a lambda
expression , it must be acceptable to function .(function report-name )is evaluated in the
current lexical environment . It should return a function of two arguments, a condition and
astream , that prints on the stream a description of the condition . This function is called
whenever the condition is printed while *print-escape* isnil.
Ifreport-name is astring , it is a shorthand for
(lambda (condition stream)
(declare (ignore condition))
(write-string report-name stream))
This option is processed after the new condition type has been dened, so use of the
slotaccessors within the :report function is permitted. If this option is not supplied,
information about how to report this type of condition is inherited from the parent-type .
The consequences are unspecifed if an attempt is made to read aslotthat has not been explicitly
initialized and that has not been given a default value.
The consequences are unspecied if an attempt is made to assign the slots by using setf.
Conditions 9–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deﬁne-condition
If adeﬁne-condition form appears as a top level form , the compiler must make name recognizable
as a valid type name, and it must be possible to reference the condition type as the parent-type of
another condition type in a subsequent deﬁne-condition form in the lebeing compiled.
Examples:
The following form denes a condition of typepeg/hole-mismatch which inherits from a condition
type called blocks-world-error :
(define-condition peg/hole-mismatch
(blocks-world-error)
((peg-shape :initarg :peg-shape
:reader peg/hole-mismatch-peg-shape)
(hole-shape :initarg :hole-shape
:reader peg/hole-mismatch-hole-shape))
(:report (lambda (condition stream)
(format stream "A ~A peg cannot go in a ~A hole."
(peg/hole-mismatch-peg-shape condition)
(peg/hole-mismatch-hole-shape condition)))))
The new type has slots peg-shape andhole-shape , somake-condition accepts
:peg-shape and:hole-shape keywords. The readers peg/hole-mismatch-peg-shape and
peg/hole-mismatch-hole-shape apply to objects of this type, as illustrated in the :report
information.
The following form denes a condition type namedmachine-error which inherits from error :
(define-condition machine-error
(error)
((machine-name :initarg :machine-name
:reader machine-error-machine-name))
(:report (lambda (condition stream)
(format stream "There is a problem with ~A."
(machine-error-machine-name condition)))))
Building on this denition, a new error condition can be dened which is a subtype of machine-error
for use when machines are not available:
(define-condition machine-not-available-error (machine-error) ()
(:report (lambda (condition stream)
(format stream "The machine ~A is not available."
(machine-error-machine-name condition)))))
This denes a still more specic condition, built upon machine-not-available-error , which provides
a slot initialization form for machine-name but which does not provide any new slots or report
information. It just gives the machine-name slot a default initialization:
(define-condition my-favorite-machine-not-available-error
(machine-not-available-error)
9–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
((machine-name :initform "mc.lcs.mit.edu")))
Note that since no :report clause was given, the information inherited from
machine-not-available-error is used to report this type of condition.
(define-condition ate-too-much (error)
((person :initarg :person :reader ate-too-much-person)
(weight :initarg :weight :reader ate-too-much-weight)
(kind-of-food :initarg :kind-of-food
:reader :ate-too-much-kind-of-food)))
!ATE-TOO-MUCH
(define-condition ate-too-much-ice-cream (ate-too-much)
((kind-of-food :initform ’ice-cream)
(flavor :initarg :flavor
:reader ate-too-much-ice-cream-flavor
:initform ’vanilla ))
(:report (lambda (condition stream)
(format stream "~A ate too much ~A ice-cream"
(ate-too-much-person condition)
(ate-too-much-ice-cream-flavor condition)))))
!ATE-TOO-MUCH-ICE-CREAM
(make-condition ’ate-too-much-ice-cream
:person ’fred
:weight 300
:flavor ’chocolate)
!#<ATE-TOO-MUCH-ICE-CREAM 32236101>
(format t "~A" *)
.FRED ate too much CHOCOLATE ice-cream
!NIL
See Also:
make-condition ,defclass , Section 9.1 (Condition System Concepts)
make-condition Function
Syntax:
make-condition type&rest slot-initializations !condition
Arguments and Values:
type|atype specier (for a subtype ofcondition ).
slot-initializations |an initialization argument list .
condition |acondition .
Conditions 9–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Constructs and returns a condition of type type using slot-initializations for the initial values of the
slots. The newly created condition is returned.
Examples:
(defvar *oops-count* 0)
(setq a (make-condition ’simple-error
:format-control "This is your ~:R error."
:format-arguments (list (incf *oops-count*))))
!#<SIMPLE-ERROR 32245104>
(format t "~&~A~%" a)
.This is your first error.
!NIL
(error a)
.Error: This is your first error.
.To continue, type :CONTINUE followed by an option number:
.1: Return to Lisp Toplevel.
.Debug>
Aﬀected By:
The set of dened condition types .
See Also:
deﬁne-condition , Section 9.1 (Condition System Concepts)
restart System Class
Class Precedence List:
restart ,t
Description:
Anobject oftyperestart represents a function that can be called to perform some form of recovery
action, usually a transfer of control to an outer point in the running program.
Animplementation is free to implement a restart in whatever manner is most convenient; a restart
has only dynamic extent relative to the scope of the binding form which establishes it.
9–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
compute-restarts
compute-restarts Function
Syntax:
compute-restarts &optional condition!restarts
Arguments and Values:
condition |acondition object , ornil.
restarts |alistofrestarts .
Description:
compute-restarts uses the dynamic state of the program to compute a listof the restarts which
are currently active.
The resulting listis ordered so that the innermost (more-recently established) restarts are nearer
the head of the list.
When condition isnon-nil , only those restarts are considered that are either explicitly associated
with that condition , or not associated with any condition ; that is, the excluded restarts are those
that are associated with a non-empty set of conditions of which the given condition is not an
element . Ifcondition isnil, all restarts are considered.
compute-restarts returns all applicable restarts , including anonymous ones, even if some of them
have the same name as others and would therefore not be found by ﬁnd-restart when given a
symbol argument.
Implementations are permitted, but not required, to return distinct lists from repeated calls to
compute-restarts while in the same dynamic environment. The consequences are undened if the
listreturned by compute-restarts is every modied.
Examples:
;; One possible way in which an interactive debugger might present
;; restarts to the user.
(defun invoke-a-restart ()
(let ((restarts (compute-restarts)))
(do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r))
(format t "~&~D: ~A~%" i (car r)))
(let ((n nil) (k (length restarts)))
(loop (when (and (typep n ’integer) (>= n 0) (< n k))
(return t))
(format t "~&Option: ")
(setq n (read))
(fresh-line))
(invoke-restart-interactively (nth n restarts)))))
Conditions 9–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(restart-case (invoke-a-restart)
(one () 1)
(two () 2)
(nil () :report "Who knows?" ’anonymous)
(one () ’I)
(two () ’II))
.0: ONE
.1: TWO
.2: Who knows?
.3: ONE
.4: TWO
.5: Return to Lisp Toplevel.
.Option: 4
!II
;; Note that in addition to user-defined restart points, COMPUTE-RESTARTS
;; also returns information about any system-supplied restarts, such as
;; the "Return to Lisp Toplevel" restart offered above.
Aﬀected By:
Existing restarts.
See Also:
ﬁnd-restart ,invoke-restart ,restart-bind
ﬁnd-restart Function
Syntax:
ﬁnd-restart identier &optional condition
restart
Arguments and Values:
identier |anon-nil symbol , or a restart .
condition |acondition object , ornil.
restart |arestart ornil.
Description:
ﬁnd-restart searches for a particular restart in the current dynamic environment .
9–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
When condition isnon-nil , only those restarts are considered that are either explicitly associated
with that condition , or not associated with any condition ; that is, the excluded restarts are those
that are associated with a non-empty set of conditions of which the given condition is not an
element . Ifcondition isnil, all restarts are considered.
Ifidentier is asymbol , then the innermost (most recently established) applicable restart with that
name is returned. nilis returned if no such restart is found.
Ifidentier is a currently active restart, then it is returned. Otherwise, nilis returned.
Examples:
(restart-case
(let ((r (find-restart ’my-restart)))
(format t "~S is named ~S" r (restart-name r)))
(my-restart () nil))
.#<RESTART 32307325> is named MY-RESTART
!NIL
(find-restart ’my-restart)
!NIL
Aﬀected By:
Existing restarts.
restart-case ,restart-bind ,with-condition-restarts .
See Also:
compute-restarts
Notes:
(find-restart identier )
(find identier (compute-restarts) :key :restart-name)
Although anonymous restarts have a name of nil, the consequences are unspecied if nilis given
as an identier . Occasionally, programmers lament that nilis not permissible as an identier
argument. In most such cases, compute-restarts can probably be used to simulate the desired
eect.
invoke-restart Function
Syntax:
invoke-restart restart&rest arguments!f resultg*
Conditions 9–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments and Values:
restart |arestart designator .
argument |an object .
results |the values returned by the function associated with restart , if that function returns.
Description:
Calls the function associated with restart , passing arguments to it. Restart must be valid in the
current dynamic environment .
Examples:
(defun add3 (x) (check-type x number) (+ x 3))
(foo ’seven)
.Error: The value SEVEN was not of type NUMBER.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a different value to use.
.2: Return to Lisp Toplevel.
.Debug> (invoke-restart ’store-value 7)
!10
Side Eﬀects:
A non-local transfer of control might be done by the restart.
Aﬀected By:
Existing restarts.
Exceptional Situations:
Ifrestart is not valid, an error of typecontrol-error is signaled.
See Also:
ﬁnd-restart ,restart-bind ,restart-case ,invoke-restart-interactively
Notes:
The most common use for invoke-restart is in a handler . It might be used explicitly, or implicitly
throughinvoke-restart-interactively or a restart function .
Restart functions callinvoke-restart , not vice versa. That is, invoke-restart provides primitive
functionality, and restart functions are non-essential \syntactic sugar."
9–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
invoke-restart-interactively
invoke-restart-interactively Function
Syntax:
invoke-restart-interactively restart!f resultg*
Arguments and Values:
restart |arestart designator .
results |the values returned by the function associated with restart , if that function returns.
Description:
invoke-restart-interactively calls the function associated with restart , prompting for any necessary
arguments. If restart is a name, it must be valid in the current dynamic environment .
invoke-restart-interactively prompts for arguments by executing the code provided in the
:interactive keyword to restart-case or:interactive-function keyword to restart-bind .
If no such options have been supplied in the corresponding restart-bind orrestart-case , then the
consequences are undened if the restart takes required arguments. If the arguments are optional,
an argument list of nilis used.
Once the arguments have been determined, invoke-restart-interactively executes the following:
(apply #’invoke-restart restart arguments )
Examples:
(defun add3 (x) (check-type x number) (+ x 3))
(add3 ’seven)
.Error: The value SEVEN was not of type NUMBER.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a different value to use.
.2: Return to Lisp Toplevel.
.Debug> (invoke-restart-interactively ’store-value)
.Type a form to evaluate and use: 7
!10
Side Eﬀects:
If prompting for arguments is necesary, some typeout may occur (on query I/O ).
A non-local transfer of control might be done by the restart.
Aﬀected By:
*query-io* , active restarts
Conditions 9–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Ifrestart is not valid, an error of typecontrol-error is signaled.
See Also:
ﬁnd-restart ,invoke-restart ,restart-case ,restart-bind
Notes:
invoke-restart-interactively is used internally by the debugger and may also be useful in
implementing other portable, interactive debugging tools.
restart-bind Macro
Syntax:
restart-bind (f(name functionf#key-val-pairg*)g)fformg*
!f resultg*
key-val-pair:: =:interactive-function interactive-function j
:report-function report-functionj
:test-function test-function
Arguments and Values:
name |asymbol ; not evaluated.
function |aform ; evaluated.
forms |an implicit progn .
interactive-function |aform ; evaluated.
report-function |aform ; evaluated.
test-function |aform ; evaluated.
results |the values returned by the forms .
Description:
restart-bind executes the body of forms in a dynamic environment where restarts with the given
names are in eect.
If a name isnil, it indicates an anonymous restart; if a name is anon-nil symbol , it indicates a
named restart.
9–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
restart-bind
The function ,interactive-function , and report-function are unconditionally evaluated in the current
lexical and dynamic environment prior to evaluation of the body. Each of these forms must
evaluate to a function .
Ifinvoke-restart is done on that restart, the function which resulted from evaluating function
is called, in the dynamic environment of theinvoke-restart , with the arguments given to
invoke-restart . The function may either perform a non-local transfer of control or may return
normally.
If the restart is invoked interactively from the debugger (using invoke-restart-interactively ), the
arguments are defaulted by calling the function which resulted from evaluating interactive-function .
That function may optionally prompt interactively on query I/O , and should return a listof
arguments to be used by invoke-restart-interactively when invoking the restart.
If a restart is invoked interactively but no interactive-function is used, then an argument list of nil
is used. In that case, the function must be compatible with an empty argument list.
If the restart is presented interactively ( e.g., by the debugger), the presentation is done by calling
thefunction which resulted from evaluating report-function . This function must be a function of
one argument, a stream . It is expected to print a description of the action that the restart takes to
that stream . This function is called any time the restart is printed while *print-escape* isnil.
In the case of interactive invocation, the result is dependent on the value of :interactive-function
as follows.
:interactive-function
Value is evaluated in the current lexical environment and should return a function of no
arguments which constructs a listof arguments to be used by invoke-restart-interactively
when invoking this restart. The function may prompt interactively using query I/O if
necessary.
:report-function
Value is evaluated in the current lexical environment and should return a function of
one argument, a stream , which prints on the stream a summary of the action that this
restart takes. This function is called whenever the restart is reported (printed while
*print-escape* isnil). If no:report-function option is provided, the manner in which the
restart is reported is implementation-dependent .
:test-function
Value is evaluated in the current lexical environment and should return a function of one
argument, a condition , which returns true if the restart is to be considered visible.
Aﬀected By:
*query-io* .
Conditions 9–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
restart-case ,with-simple-restart
Notes:
restart-bind is primarily intended to be used to implement restart-case and might be useful in
implementing other macros. Programmers who are uncertain about whether to use restart-case
orrestart-bind should prefer restart-case for the cases where it is powerful enough, using
restart-bind only in cases where its full generality is really needed.
restart-case Macro
Syntax:
restart-case restartable-formf#clauseg !f resultg*
clause:: =(case-name lambda-list
[ [:interactive interactive-expression j:report report-expressionj:test test-expression ] ]
fdeclarationg*fformg*)
Arguments and Values:
restartable-form |aform .
case-name |asymbol ornil.
lambda-list |an ordinary lambda list .
interactive-expression |asymbol or a lambda expression .
report-expression |astring , asymbol , or a lambda expression .
test-expression |asymbol or a lambda expression .
declaration |adeclare expression ; not evaluated.
form|aform .
results |the values resulting from the evaluation ofrestartable-form , or the values returned by the
last form executed in a chosen clause , ornil.
Description:
restart-case evaluates restartable-form in a dynamic environment where the clauses have special
meanings as points to which control may be transferred. If restartable-form nishes executing and
returns any values, all values returned are returned by restart-case and processing has completed.
While restartable-form is executing, any code may transfer control to one of the clauses (see
9–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
restart-case
invoke-restart ). If a transfer occurs, the forms in the body of that clause is evaluated and any
values returned by the last such form are returned by restart-case . In this case, the dynamic state
is unwound appropriately (so that the restarts established around the restartable-form are no longer
active) prior to execution of the clause.
If there are no forms in a selected clause, restart-case returnsnil.
Ifcase-name is asymbol , it names this restart.
It is possible to have more than one clause use the same case-name . In this case, the rst clause
with that name is found by ﬁnd-restart . The other clauses are accessible using compute-restarts .
Each arglist is an ordinary lambda list to be bound during the execution of its corresponding forms .
These parameters are used by the restart-case clause to receive any necessary data from a call to
invoke-restart .
By default, invoke-restart-interactively passes no arguments and all arguments must be optional
in order to accomodate interactive restarting. However, the arguments need not be optional if the
:interactive keyword has been used to inform invoke-restart-interactively about how to compute
a proper argument list.
Keyword options have the following meaning.
:interactive
The value supplied by :interactive value must be a suitable argument to function .
(function value)is evaluated in the current lexical environment. It should return a function
of no arguments which returns arguments to be used by invoke-restart-interactively when
it is invoked. invoke-restart-interactively is called in the dynamic environment available
prior to any restart attempt, and uses query I/O for user interaction.
If a restart is invoked interactively but no :interactive option was supplied, the argument
list used in the invocation is the empty list.
:report
If the value supplied by :report value is a lambda expression or a symbol , it must be
acceptable to function .(function value)is evaluated in the current lexical environment.
It should return a function of one argument, a stream , which prints on the stream a
description of the restart. This function is called whenever the restart is printed while
*print-escape* isnil.
Ifvalue is astring , it is a shorthand for
(lambda (stream) (write-string value stream))
If a named restart is asked to report but no report information has been supplied, the
name of the restart is used in generating default report text.
Conditions 9–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
restart-case
When*print-escape* isnil, the printer uses the report information for a restart. For
example, a debugger might announce the action of typing a \continue" command by:
(format t "~&~S – ~A~%" ’:continue some-restart)
which might then display as something like:
:CONTINUE – Return to command level
The consequences are unspecied if an unnamed restart is specied but no :report option
is provided.
:test
The value supplied by :test value must be a suitable argument to function .
(function value)is evaluated in the current lexical environment. It should return a
function of one argument , the condition , that returns true if the restart is to be considered
visible.
The default for this option is equivalent to (lambda (c) (declare (ignore c)) t) .
If the restartable-form is alistwhose caris any of the symbolssignal ,error ,cerror , orwarn (or is a
macro form which macroexpands into such a list), thenwith-condition-restarts is used implicitly
to associate the indicated restarts with the condition to be signaled.
Examples:
(restart-case
(handler-bind ((error #’(lambda (c)
(declare (ignore condition))
(invoke-restart ’my-restart 7))))
(error "Foo."))
(my-restart (&optional v) v))
!7
(define-condition food-error (error) ())
!FOOD-ERROR
(define-condition bad-tasting-sundae (food-error)
((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)
(sauce :initarg :sauce :reader bad-tasting-sundae-sauce)
(topping :initarg :topping :reader bad-tasting-sundae-topping))
(:report (lambda (condition stream)
(format stream "Bad tasting sundae with ~S, ~S, and ~S"
(bad-tasting-sundae-ice-cream condition)
(bad-tasting-sundae-sauce condition)
(bad-tasting-sundae-topping condition)))))
!BAD-TASTING-SUNDAE
(defun all-start-with-same-letter (symbol1 symbol2 symbol3)
9–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
restart-case
(let ((first-letter (char (symbol-name symbol1) 0)))
(and (eql first-letter (char (symbol-name symbol2) 0))
(eql first-letter (char (symbol-name symbol3) 0)))))
!ALL-START-WITH-SAME-LETTER
(defun read-new-value ()
(format t "Enter a new value: ")
(multiple-value-list (eval (read))))
!READ-NEW-VALUE
Conditions 9–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
restart-case
(defun verify-or-fix-perfect-sundae (ice-cream sauce topping)
(do ()
((all-start-with-same-letter ice-cream sauce topping))
(restart-case
(error ’bad-tasting-sundae
:ice-cream ice-cream
:sauce sauce
:topping topping)
(use-new-ice-cream (new-ice-cream)
:report "Use a new ice cream."
:interactive read-new-value
(setq ice-cream new-ice-cream))
(use-new-sauce (new-sauce)
:report "Use a new sauce."
:interactive read-new-value
(setq sauce new-sauce))
(use-new-topping (new-topping)
:report "Use a new topping."
:interactive read-new-value
(setq topping new-topping))))
(values ice-cream sauce topping))
!VERIFY-OR-FIX-PERFECT-SUNDAE
(verify-or-fix-perfect-sundae ’vanilla ’caramel ’cherry)
.Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.
.To continue, type :CONTINUE followed by an option number:
.1: Use a new ice cream.
.2: Use a new sauce.
.3: Use a new topping.
.4: Return to Lisp Toplevel.
.Debug> :continue 1
.Use a new ice cream.
.Enter a new ice cream: ’chocolate
!CHOCOLATE, CARAMEL, CHERRY
See Also:
restart-bind ,with-simple-restart .
Notes:
(restart-case expression
(name1 arglist1 ...options1 ... . body1)
(name2 arglist2 ...options2 ... . body2))
is essentially equivalent to
9–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(block #1=#:g0001
(let ((#2=#:g0002 nil))
(tagbody
(restart-bind ((name1 #’(lambda (&rest temp)
(setq #2# temp)
(go #3=#:g0003))
...slightly-transformed-options1 ...)
(name2 #’(lambda (&rest temp)
(setq #2# temp)
(go #4=#:g0004))
...slightly-transformed-options2 ...))
(return-from #1# expression ))
#3# (return-from #1#
(apply #’(lambda arglist1 .body1) #2#))
#4# (return-from #1#
(apply #’(lambda arglist2 .body2) #2#)))))
Unnamed restarts are generally only useful interactively and an interactive option which has no
description is of little value. Implementations are encouraged to warn if an unnamed restart is
used and no report information is provided at compilation time. At runtime, this error might be
noticed when entering the debugger. Since signaling an error would probably cause recursive entry
into the debugger (causing yet another recursive error, etc.) it is suggested that the debugger print
some indication of such problems when they occur but not actually signal errors.
(restart-case (signal fred)
(a ...)
(b ...))

(restart-case
(with-condition-restarts fred
(list (find-restart ’a)
(find-restart ’b))
(signal fred))
(a ...)
(b ...))
restart-name Function
Syntax:
restart-name restart!name
Conditions 9–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments and Values:
restart |arestart .
name |asymbol .
Description:
Returns the name of the restart , ornilif the restart is not named.
Examples:
(restart-case
(loop for restart in (compute-restarts)
collect (restart-name restart))
(case1 () :report "Return 1." 1)
(nil () :report "Return 2." 2)
(case3 () :report "Return 3." 3)
(case1 () :report "Return 4." 4))
!(CASE1 NIL CASE3 CASE1 ABORT)
;; In the example above the restart named ABORT was not created
;; explicitly, but was implicitly supplied by the system.
See Also:
compute-restarts ﬁnd-restart
with-condition-restarts Macro
Syntax:
with-condition-restarts condition-form restarts-form fformg*
!f resultg*
Arguments and Values:
condition-form |aform ;evaluated to produce a condition .
condition |acondition object resulting from the evaluation ofcondition-form .
restart-form |aform ;evaluated to produce a restart-list .
restart-list |alistofrestart objects resulting from the evaluation ofrestart-form .
forms |an implicit progn ; evaluated.
results |the values returned by forms .
9–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
First, the condition-form and restarts-form areevaluated in normal left-to-right order; the primary
values yielded by these evaluations are respectively called the condition and the restart-list .
Next, the forms areevaluated in a dynamic environment in which each restart inrestart-list is
associated with the condition . See Section 9.1.4.2.4 (Associating a Restart with a Condition).
See Also:
restart-case
Notes:
Usually this macro is not used explicitly in code, since restart-case handles most of the common
cases in a way that is syntactically more concise.
with-simple-restart Macro
Syntax:
with-simple-restart (name format-control fformat-argumentg*)fformg*
!f resultg*
Arguments and Values:
name |asymbol .
format-control |aformat control .
format-argument |an object (i.e., aformat argument ).
forms |an implicit progn .
results |in the normal situation, the values returned by the forms ; in the exceptional situation
where the restart named name is invoked, two values| nilandt.
Description:
with-simple-restart establishes a restart.
If the restart designated by name is not invoked while executing forms , all values returned by the
last of forms are returned. If the restart designated by name is invoked, control is transferred to
with-simple-restart , which returns two values, nilandt.
Ifname isnil, an anonymous restart is established.
The format-control and format-arguments are used report the restart .
Conditions 9–63
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-simple-restart
Examples:
(defun read-eval-print-loop (level)
(with-simple-restart (abort "Exit command level ~D." level)
(loop
(with-simple-restart (abort "Return to command level ~D." level)
(let ((form (prog2 (fresh-line) (read) (fresh-line))))
(prin1 (eval form)))))))
!READ-EVAL-PRINT-LOOP
(read-eval-print-loop 1)
(+ ’a 3)
.Error: The argument, A, to the function + was of the wrong type.
. The function expected a number.
.To continue, type :CONTINUE followed by an option number:
.1: Specify a value to use this time.
.2: Return to command level 1.
.3: Exit command level 1.
.4: Return to Lisp Toplevel.
(defun compute-fixnum-power-of-2 (x)
(with-simple-restart (nil "Give up on computing 2^~D." x)
(let ((result 1))
(dotimes (i x result)
(setq result (* 2 result))
(unless (fixnump result)
(error "Power of 2 is too large."))))))
COMPUTE-FIXNUM-POWER-OF-2
(defun compute-power-of-2 (x)
(or (compute-fixnum-power-of-2 x) ’something big))
COMPUTE-POWER-OF-2
(compute-power-of-2 10)
1024
(compute-power-of-2 10000)
.Error: Power of 2 is too large.
.To continue, type :CONTINUE followed by an option number.
.1: Give up on computing 2^10000.
.2: Return to Lisp Toplevel
.Debug> :continue 1
!SOMETHING-BIG
See Also:
restart-case
Notes:
with-simple-restart is shorthand for one of the most common uses of restart-case .
9–64 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-simple-restart could be dened by:
(defmacro with-simple-restart ((restart-name format-control
&rest format-arguments)
&body forms)
‘(restart-case (progn ,@forms)
(,restart-name ()
:report (lambda (stream)
(format stream ,format-control ,@format-arguments))
(values nil t))))
Because the second return value is tin the exceptional case, it is common (but not required)
to arrange for the second return value in the normal case to be missing or nilso that the two
situations can be distinguished.
abort Restart
Data Arguments Required:
None.
Description:
The intent of the abort restart is to allow return to the innermost \command level." Implementors
are encouraged to make sure that there is always a restart named abort around any user code so
that user code can call abort at any time and expect something reasonable to happen; exactly what
the reasonable thing is may vary somewhat. Typically, in an interactive listener, the invocation of
abort returns to the Lisp reader phase of the Lisp read-eval-print loop , though in some batch or
multi-processing situations there may be situations in which having it kill the running process is
more appropriate.
See Also:
Section 9.1.4.2 (Restarts), Section 9.1.4.2.2 (Interfaces to Restarts), invoke-restart ,abort
(function )
Conditions 9–65
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
continue Restart
Data Arguments Required:
None.
Description:
Thecontinue restart is generally part of protocols where there is a single \obvious" way to
continue, such as in break andcerror . Some user-dened protocols may also wish to incorporate it
for similar reasons. In general, however, it is more reliable to design a special purpose restart with
a name that more directly suits the particular application.
Examples:
(let ((x 3))
(handler-bind ((error #’(lambda (c)
(let ((r (find-restart ’continue c)))
(when r (invoke-restart r))))))
(cond ((not (floatp x))
(cerror "Try floating it." "~D is not a float." x)
(float x))
(t x))))!3.0
See Also:
Section 9.1.4.2 (Restarts), Section 9.1.4.2.2 (Interfaces to Restarts), invoke-restart ,continue
(function ),assert ,cerror
muﬄe-warning Restart
Data Arguments Required:
None.
Description:
This restart is established by warn so that handlers ofwarning conditions have a way to tell warn
that a warning has already been dealt with and that no further action is warranted.
Examples:
(defvar *all-quiet* nil) !*ALL-QUIET*
(defvar *saved-warnings* ’()) !*SAVED-WARNINGS*
(defun quiet-warning-handler (c)
(when *all-quiet*
(let ((r (find-restart ’muffle-warning c)))
9–66 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(when r
(push c *saved-warnings*)
(invoke-restart r)))))
!CUSTOM-WARNING-HANDLER
(defmacro with-quiet-warnings (&body forms)
‘(let ((*all-quiet* t)
(*saved-warnings* ’()))
(handler-bind ((warning #’quiet-warning-handler))
,@forms
*saved-warnings*)))
!WITH-QUIET-WARNINGS
(setq saved
(with-quiet-warnings
(warn "Situation #1.")
(let ((*all-quiet* nil))
(warn "Situation #2."))
(warn "Situation #3.")))
.Warning: Situation #2.
!(#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)
(dolist (s saved) (format t "~&~A~%" s))
.Situation #3.
.Situation #1.
!NIL
See Also:
Section 9.1.4.2 (Restarts), Section 9.1.4.2.2 (Interfaces to Restarts), invoke-restart ,muﬄe-warning
(function ),warn
store-value Restart
Data Arguments Required:
a value to use instead (on an ongoing basis).
Description:
Thestore-value restart is generally used by handlers trying to recover from errors of types such as
cell-error ortype-error , which may wish to supply a replacement datum to be stored permanently.
Examples:
(defun type-error-auto-coerce (c)
(when (typep c ’type-error)
(let ((r (find-restart ’store-value c)))
(handler-case (let ((v (coerce (type-error-datum c)
Conditions 9–67
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(type-error-expected-type c))))
(invoke-restart r v))
(error ())))))!TYPE-ERROR-AUTO-COERCE
(let ((x 3))
(handler-bind ((type-error #’type-error-auto-coerce))
(check-type x float)
x))!3.0
See Also:
Section 9.1.4.2 (Restarts), Section 9.1.4.2.2 (Interfaces to Restarts), invoke-restart ,store-value
(function ),ccase ,check-type ,ctypecase ,use-value (function and restart )
use-value Restart
Data Arguments Required:
a value to use instead (once).
Description:
Theuse-value restart is generally used by handlers trying to recover from errors of types such as
cell-error , where the handler may wish to supply a replacement datum for one-time use.
See Also:
Section 9.1.4.2 (Restarts), Section 9.1.4.2.2 (Interfaces to Restarts), invoke-restart ,use-value
(function ),store-value (function and restart )
abort,continue,muﬄe-warning,store-value,use-
value Function
Syntax:
abort&optional condition!
continue &optional condition!nil
muﬄe-warning &optional condition!
store-value value&optional condition!nil
use-value value&optional condition!nil
9–68 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
abort, continue, muﬄe-warning, store-value, use-value
Arguments and Values:
value |an object .
condition |acondition object , ornil.
Description:
Transfers control to the most recently established applicable restart having the same name as
the function. That is, the function abort searches for an applicable abort restart , the function
continue searches for an applicable continue restart , and so on.
If no such restart exists, the functions continue ,store-value , anduse-value returnnil, and the
functions abort andmuﬄe-warning signal an error of typecontrol-error .
When condition isnon-nil , only those restarts are considered that are either explicitly associated
with that condition , or not associated with any condition ; that is, the excluded restarts are those
that are associated with a non-empty set of conditions of which the given condition is not an
element . Ifcondition isnil, all restarts are considered.
Examples:
;;; Example of the ABORT retart
(defmacro abort-on-error (&body forms)
‘(handler-bind ((error #’abort))
,@forms))!ABORT-ON-ERROR
(abort-on-error (+ 3 5)) !8
(abort-on-error (error "You lose."))
.Returned to Lisp Top Level.
;;; Example of the CONTINUE restart
(defun real-sqrt (n)
(when (minusp n)
(setq n (- n))
(cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
(sqrt n))
(real-sqrt 4)!2
(real-sqrt -9)
.Error: Tried to take sqrt(-9).
.To continue, type :CONTINUE followed by an option number:
.1: Return sqrt(9) instead.
.2: Return to Lisp Toplevel.
.Debug> (continue)
.Return sqrt(9) instead.
!3
Conditions 9–69
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
abort, continue, muﬄe-warning, store-value, use-value
(handler-bind ((error #’(lambda (c) (continue))))
(real-sqrt -9)) !3
;;; Example of the MUFFLE-WARNING restart
(defun count-down (x)
(do ((counter x (1- counter)))
((= counter 0) ’done)
(when (= counter 1)
(warn "Almost done"))
(format t "~&~D~%" counter)))
!COUNT-DOWN
(count-down 3)
.3
.2
.Warning: Almost done
.1
!DONE
(defun ignore-warnings-while-counting (x)
(handler-bind ((warning #’ignore-warning))
(count-down x)))
!IGNORE-WARNINGS-WHILE-COUNTING
(defun ignore-warning (condition)
(declare (ignore condition))
(muffle-warning))
!IGNORE-WARNING
(ignore-warnings-while-counting 3)
.3
.2
.1
!DONE
;;; Example of the STORE-VALUE and USE-VALUE restarts
(defun careful-symbol-value (symbol)
(check-type symbol symbol)
(restart-case (if (boundp symbol)
(return-from careful-symbol-value
(symbol-value symbol))
(error ’unbound-variable
:name symbol))
(use-value (value)
:report "Specify a value to use this time."
value)
9–70 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
abort, continue, muﬄe-warning, store-value, use-value
(store-value (value)
:report "Specify a value to store and use in the future."
(setf (symbol-value symbol) value))))
(setq a 1234)!1234
(careful-symbol-value ’a) !1234
(makunbound ’a) !A
(careful-symbol-value ’a)
.Error: A is not bound.
.To continue, type :CONTINUE followed by an option number.
.1: Specify a value to use this time.
.2: Specify a value to store and use in the future.
.3: Return to Lisp Toplevel.
.Debug> (use-value 12)
!12
(careful-symbol-value ’a)
.Error: A is not bound.
.To continue, type :CONTINUE followed by an option number.
.1: Specify a value to use this time.
.2: Specify a value to store and use in the future.
.3: Return to Lisp Toplevel.
.Debug> (store-value 24)
!24
(careful-symbol-value ’a)
!24
;;; Example of the USE-VALUE restart
(defun add-symbols-with-default (default &rest symbols)
(handler-bind ((sys:unbound-symbol
#’(lambda (c)
(declare (ignore c))
(use-value default))))
(apply #’+ (mapcar #’careful-symbol-value symbols))))
!ADD-SYMBOLS-WITH-DEFAULT
(setq x 1 y 2)!2
(add-symbols-with-default 3 ’x ’y ’z) !6
Side Eﬀects:
A transfer of control may occur if an appropriate restart is available, or (in the case of the function
abort or the functionmuﬄe-warning ) execution may be stopped.
Aﬀected By:
Each of these functions can be aected by the presence of a restart having the same name.
Conditions 9–71
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
abort, continue, muﬄe-warning, store-value, use-value
Exceptional Situations:
If an appropriate abort restart is not available for the function abort , or an appropriate
muﬄe-warning restart is not available for the function muﬄe-warning , an error of type
control-error is signaled.
See Also:
invoke-restart , Section 9.1.4.2 (Restarts), Section 9.1.4.2.2 (Interfaces to Restarts), assert ,ccase ,
cerror ,check-type ,ctypecase ,use-value ,warn
Notes:
(abort condition) (invoke-restart ’abort)
(muffle-warning) (invoke-restart ’muffle-warning)
(continue) (let ((r (find-restart ’continue))) (if r (invoke-restart r)))
(use-value x)(let ((r (find-restart ’use-value))) (if r (invoke-restart r x)))
(store-value x) (let ((r (find-restart ’store-value))) (if r (invoke-restart r x)))
No functions dened in this specication are required to provide a use-value restart .
9–72 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
10. Symbols
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Symbols iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
10.1 Symbol Concepts
Figure 10{1 lists some dened names that are applicable to the property lists ofsymbols .
get remprop symbol-plist
Figure 10–1. Property list deﬁned names
Figure 10{2 lists some dened names that are applicable to the creation of and inquiry about
symbols .
copy-symbol keywordp symbol-package
gensym make-symbol symbol-value
gentemp symbol-name
Figure 10–2. Symbol creation and inquiry deﬁned names
Symbols 10–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
symbol System Class
Class Precedence List:
symbol ,t
Description:
Symbols are used for their object identity to name various entities in Common Lisp, including (but
not limited to) linguistic entities such as variables and functions .
Symbols can be collected together into packages . A symbol is said to be interned in a package if
it is accessible in that package ; the same symbol can be interned in more than one package . If a
symbol is not interned in any package , it is called uninterned .
Aninterned symbol is uniquely identiable by its name from any package in which it is accessible .
Symbols have the following attributes. For historical reasons, these are sometimes referred
to as cells, although the actual internal representation of symbols and their attributes is
implementation-dependent .
Name
The name of a symbol is astring used to identify the symbol . Every symbol has a name ,
and the consequences are undened if that name is altered. The name is used as part of
the external, printed representation of the symbol ; see Section 2.1 (Character Syntax).
The function symbol-name returns the name of a given symbol . Asymbol may have any
character in its name .
Package
The object in this cellis called the home package of the symbol . If the home package is
nil, the symbol is sometimes said to have no home package .
When a symbol is rst created, it has no home package . When it is rst interned , the
package in which it is initially interned becomes its home package . The home package of a
symbol can be accessed by using the functionsymbol-package .
If asymbol isuninterned from the package which is its home package , its home package is
set tonil. Depending on whether there is another package in which the symbol isinterned ,
the symbol might or might not really be an uninterned symbol . Asymbol with no home
package is therefore called apparently uninterned .
The consequences are undened if an attempt is made to alter the home package of a
symbol external in the COMMON-LISP package or theKEYWORD package .
Property list
The property list of a symbol provides a mechanism for associating named attributes
10–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with that symbol . The operations for adding and removing entries are destructive to the
property list . Common Lisp provides operators both for direct manipulation of property
list objects (e.g., seegetf,remf , andsymbol-plist ) and for implicit manipulation of a
symbol 'sproperty list by reference to the symbol (e.g., seegetandremprop ). The property
listassociated with a fresh symbol is initially null.
Value
If a symbol has a value attribute, it is said to be bound , and that fact can be detected
by the function boundp . The object contained in the value cell of a bound symbol is the
value of the global variable named by that symbol , and can be accessed by the function
symbol-value . Asymbol can be made to be unbound by the functionmakunbound .
The consequences are undened if an attempt is made to change the value of a symbol
that names a constant variable , or to make such a symbol beunbound .
Function
If a symbol has a function attribute, it is said to be fbound , and that fact can be
detected by the function fboundp . If the symbol is the name of a function in the global
environment , the function cell contains the function , and can be accessed by the function
symbol-function . If the symbol is the name of either a macro in the global environment
(seemacro-function ) or a special operator (seespecial-operator-p ), the symbol isfbound ,
and can be accessed by the function symbol-function , but the object which the function
cellcontains is of implementation-dependent type and purpose. A symbol can be made to
befunbound by the functionfmakunbound .
The consequences are undened if an attempt is made to change the functional value of a
symbol that names a special form .
Operations on a symbol 'svalue cell and function cell are sometimes described in terms of their
eect on the symbol itself, but the user should keep in mind that there is an intimate relationship
between the contents of those cells and the global variable or global function denition, respectively.
Symbols are used as identiers for lexical variables and lexical function denitions, but in that role,
only their object identity is signicant. Common Lisp provides no operation on a symbol that can
have any eect on a lexical variable or on a lexical function denition.
See Also:
Section 2.3.4 (Symbols as Tokens), Section 2.3.1.1 (Potential Numbers as Tokens), Section 22.1.3.3
(Printing Symbols)
Symbols 10–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
keyword Type
Supertypes:
keyword ,symbol ,t
Description:
The typekeyword includes all symbols interned theKEYWORD package .
Interning asymbol in theKEYWORD package has three automatic eects:
1. It causes the symbol to become bound to itself.
2. It causes the symbol to become an external symbol of theKEYWORD package .
3. It causes the symbol to become a constant variable .
See Also:
keywordp
symbolp Function
Syntax:
symbolp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typesymbol ; otherwise, returns false.
Examples:
(symbolp ’elephant) !true
(symbolp 12)!false
(symbolp nil)!true
(symbolp ’())!true
(symbolp :test) !true
(symbolp "hello") !false
See Also:
keywordp ,symbol ,typep
10–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(symbolp object)(typep object’symbol)
keywordp Function
Syntax:
keywordp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is akeyword 1; otherwise, returns false.
Examples:
(keywordp ’elephant) !false
(keywordp 12)!false
(keywordp :test) !true
(keywordp ’:test) !true
(keywordp nil)!false
(keywordp :nil) !true
(keywordp ’(:test)) !false
(keywordp "hello") !false
(keywordp ":hello") !false
(keywordp ’&optional) !false
See Also:
constantp ,keyword ,symbolp ,symbol-package
Symbols 10–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-symbol Function
Syntax:
make-symbol name!new-symbol
Arguments and Values:
name |astring .
new-symbol |afresh ,uninterned symbol .
Description:
make-symbol creates and returns a fresh ,uninterned symbol whose name is the given name . The
new-symbol is neither bound norfbound and has a null property list .
It is implementation-dependent whether the string that becomes the new-symbol 'sname is the
given name or a copy of it. Once a string has been given as the name argument tomake-symbol ,
the consequences are undened if a subsequent attempt is made to alter that string .
Examples:
(setq temp-string "temp") !"temp"
(setq temp-symbol (make-symbol temp-string)) !#:|temp|
(symbol-name temp-symbol) !"temp"
(eq (symbol-name temp-symbol) temp-string) !implementation-dependent
(find-symbol "temp") !NIL, NIL
(eq (make-symbol temp-string) (make-symbol temp-string)) !false
Exceptional Situations:
Should signal an error of typetype-error ifname is not a string .
See Also:
copy-symbol
Notes:
No attempt is made by make-symbol to convert the case of the name to uppercase. The only case
conversion which ever occurs for symbols is done by the Lisp reader . The program interface to
symbol creation retains case, and the program interface to interning symbols is case-sensitive.
10–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
copy-symbol
copy-symbol Function
Syntax:
copy-symbol symbol&optional copy-properties!new-symbol
Arguments and Values:
symbol |asymbol .
copy-properties |ageneralized boolean . The default is false.
new-symbol |afresh ,uninterned symbol .
Description:
copy-symbol returns a fresh ,uninterned symbol , the name of which is string= to and possibly the
same as the name of the given symbol .
Ifcopy-properties isfalse, the new-symbol is neither bound norfbound and has a null property
list. If copy-properties istrue, then the initial value ofnew-symbol is the value ofsymbol , the
initial function denition of new-symbol is the functional value ofsymbol , and the property list of
new-symbol is acopy 2of the property list ofsymbol .
Examples:
(setq fred ’fred-smith) !FRED-SMITH
(setf (symbol-value fred) 3) !3
(setq fred-clone-1a (copy-symbol fred nil)) !#:FRED-SMITH
(setq fred-clone-1b (copy-symbol fred nil)) !#:FRED-SMITH
(setq fred-clone-2a (copy-symbol fred t)) !#:FRED-SMITH
(setq fred-clone-2b (copy-symbol fred t)) !#:FRED-SMITH
(eq fred fred-clone-1a) !false
(eq fred-clone-1a fred-clone-1b) !false
(eq fred-clone-2a fred-clone-2b) !false
(eq fred-clone-1a fred-clone-2a) !false
(symbol-value fred) !3
(boundp fred-clone-1a) !false
(symbol-value fred-clone-2a) !3
(setf (symbol-value fred-clone-2a) 4) !4
(symbol-value fred) !3
(symbol-value fred-clone-2a) !4
(symbol-value fred-clone-2b) !3
(boundp fred-clone-1a) !false
(setf (symbol-function fred) #’(lambda (x) x)) !#<FUNCTION anonymous>
(fboundp fred)!true
(fboundp fred-clone-1a) !false
(fboundp fred-clone-2a) !false
Symbols 10–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
See Also:
make-symbol
Notes:
Implementors are encouraged not to copy the string which is the symbol 'sname unnecessarily.
Unless there is a good reason to do so, the normal implementation strategy is for the new-symbol 's
name to be identical to the given symbol 'sname .
gensym Function
Syntax:
gensym &optional x!new-symbol
Arguments and Values:
x|astring or a non-negative integer . Complicated defaulting behavior; see below.
new-symbol |afresh ,uninterned symbol .
Description:
Creates and returns a fresh ,uninterned symbol , as if by calling make-symbol . (The only dierence
betweengensym andmake-symbol is in how the new-symbol 'sname is determined.)
The name of the new-symbol is the concatenation of a prex, which defaults to "G", and a sux,
which is the decimal representation of a number that defaults to the value of*gensym-counter* .
Ifxis supplied, and is a string , then that string is used as a prex instead of "G"for this call to
gensym only.
Ifxis supplied, and is an integer , then that integer , instead of the value of*gensym-counter* , is
used as the sux for this call to gensym only.
If and only if no explicit sux is supplied, *gensym-counter* is incremented after it is used.
Examples:
(setq sym1 (gensym)) !#:G3142
(symbol-package sym1) !NIL
(setq sym2 (gensym 100)) !#:G100
(setq sym3 (gensym 100)) !#:G100
(eq sym2 sym3)!false
(find-symbol "G100") !NIL, NIL
10–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(gensym "T")!#:T3143
(gensym)!#:G3144
Side Eﬀects:
Might increment *gensym-counter* .
Aﬀected By:
*gensym-counter*
Exceptional Situations:
Should signal an error of typetype-error ifxis not a string or a non-negative integer .
See Also:
gentemp ,*gensym-counter*
Notes:
The ability to pass a numeric argument to gensym has been deprecated; explicitly binding
*gensym-counter* is now stylistically preferred. (The somewhat baroque conventions for the
optional argument are historical in nature, and supported primarily for compatibility with older
dialects of Lisp. In modern code, it is recommended that the only kind of argument used be a
string prex. In general, though, to obtain more exible control of the new-symbol 'sname , consider
usingmake-symbol instead.)
gensym-counter  Variable
Value Type:
a non-negative integer .
Initial Value:
implementation-dependent .
Description:
A number which will be used in constructing the name of the next symbol generated by the
functiongensym .
*gensym-counter* can be either assigned orbound at any time, but its value must always be a
non-negative integer .
Aﬀected By:
gensym .
See Also:
gensym
Symbols 10–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
The ability to pass a numeric argument to gensym has been deprecated; explicitly binding
*gensym-counter* is now stylistically preferred.
gentemp Function
Syntax:
gentemp &optional prex package!new-symbol
Arguments and Values:
prex |astring . The default is "T".
package |apackage designator . The default is the current package .
new-symbol |afresh ,interned symbol .
Description:
gentemp creates and returns a fresh symbol ,interned in the indicated package . The symbol is
guaranteed to be one that was not previously accessible inpackage . It is neither bound norfbound ,
and has a null property list .
The name of the new-symbol is the concatenation of the prex and a sux, which is taken from an
internal counter used only by gentemp . (If a symbol by that name is already accessible inpackage ,
the counter is incremented as many times as is necessary to produce a name that is not already
thename of a symbol accessible inpackage .)
Examples:
(gentemp)!T1298
(gentemp "FOO") !FOO1299
(find-symbol "FOO1300") !NIL, NIL
(gentemp "FOO") !FOO1300
(find-symbol "FOO1300") !FOO1300, :INTERNAL
(intern "FOO1301") !FOO1301, :INTERNAL
(gentemp "FOO") !FOO1302
(gentemp)!T1303
Side Eﬀects:
Its internal counter is incremented one or more times.
Interns thenew-symbol inpackage .
Aﬀected By:
The current state of its internal counter, and the current state of the package .
10–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Should signal an error of typetype-error ifprex is not a string . Should signal an error of type
type-error ifpackage is not a package designator .
See Also:
gensym
Notes:
The function gentemp is deprecated.
Ifpackage is theKEYWORD package , the result is an external symbol ofpackage . Otherwise, the result
is an internal symbol ofpackage .
Thegentemp internal counter is independent of *gensym-counter* , the counter used by gensym .
There is no provision for accessing the gentemp internal counter.
Just because gentemp creates a symbol which did not previously exist does not mean that such
asymbol might not be seen in the future ( e.g., in a data le|perhaps even created by the same
program in another session). As such, this symbol is not truly unique in the same sense as a
gensym would be. In particular, programs which do automatic code generation should be careful
not to attach global attributes to such generated symbols (e.g.,special declarations ) and then
write them into a le because such global attributes might, in a dierent session, end up applying
to other symbols that were automatically generated on another day for some other purpose.
symbol-function Accessor
Syntax:
symbol-function symbol!contents
(setf (symbol-function symbol)new-contents )
Arguments and Values:
symbol |asymbol .
contents | If the symbol is globally dened as a macro or a special operator , an object of
implementation-dependent nature and identity is returned. If the symbol is not globally dened as
either a macro or a special operator , and if the symbol isfbound , afunction object is returned.
new-contents |afunction .
Description:
Accesses thesymbol 'sfunction cell .
Symbols 10–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
symbol-function
Examples:
(symbol-function ’car) !#<FUNCTION CAR>
(symbol-function ’twice) is an error ;because TWICE isn’t defined.
(defun twice (n) (* n 2)) !TWICE
(symbol-function ’twice) !#<FUNCTION TWICE>
(list (twice 3)
(funcall (function twice) 3)
(funcall (symbol-function ’twice) 3))
!(6 6 6)
(flet ((twice (x) (list x x)))
(list (twice 3)
(funcall (function twice) 3)
(funcall (symbol-function ’twice) 3)))
!((3 3) (3 3) 6)
(setf (symbol-function ’twice) #’(lambda (x) (list x x)))
!#<FUNCTION anonymous>
(list (twice 3)
(funcall (function twice) 3)
(funcall (symbol-function ’twice) 3))
!((3 3) (3 3) (3 3))
(fboundp ’defun) !true
(symbol-function ’defun)
!implementation-dependent
(functionp (symbol-function ’defun))
!implementation-dependent
(defun symbol-function-or-nil (symbol)
(if (and (fboundp symbol)
(not (macro-function symbol))
(not (special-operator-p symbol)))
(symbol-function symbol)
nil))!SYMBOL-FUNCTION-OR-NIL
(symbol-function-or-nil ’car) !#<FUNCTION CAR>
(symbol-function-or-nil ’defun) !NIL
Aﬀected By:
defun
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
Should signal undeﬁned-function ifsymbol is not fbound and an attempt is made to read its
denition. (No such error is signaled on an attempt to write its denition.)
See Also:
fboundp ,fmakunbound ,macro-function ,special-operator-p
10–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
symbol-function cannot access the value of a lexical function name produced by ﬂetorlabels ; it
canaccess only the global function value.
setf may be used with symbol-function to replace a global function denition when the symbol 's
function denition does not represent a special operator .
(symbol-function symbol)(fdefinition symbol)
However, fdeﬁnition accepts arguments other than just symbols .
symbol-name Function
Syntax:
symbol-name symbol!name
Arguments and Values:
symbol |asymbol .
name |astring .
Description:
symbol-name returns the name ofsymbol . The consequences are undened if name is ever
modied.
Examples:
(symbol-name ’temp) !"TEMP"
(symbol-name :start) !"START"
(symbol-name (gensym)) !"G1234" ;for example
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
Symbols 10–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
symbol-package
symbol-package Function
Syntax:
symbol-package symbol!contents
Arguments and Values:
symbol |asymbol .
contents |apackage object ornil.
Description:
Returns the home package ofsymbol .
Examples:
(in-package "CL-USER") !#<PACKAGE "COMMON-LISP-USER">
(symbol-package ’car) !#<PACKAGE "COMMON-LISP">
(symbol-package ’bus) !#<PACKAGE "COMMON-LISP-USER">
(symbol-package :optional) !#<PACKAGE "KEYWORD">
;; Gensyms are uninterned, so have no home package.
(symbol-package (gensym)) !NIL
(make-package ’pk1) !#<PACKAGE "PK1">
(intern "SAMPLE1" "PK1") !PK1::SAMPLE1, NIL
(export (find-symbol "SAMPLE1" "PK1") "PK1") !T
(make-package ’pk2 :use ’(pk1)) !#<PACKAGE "PK2">
(find-symbol "SAMPLE1" "PK2") !PK1:SAMPLE1, :INHERITED
(symbol-package ’pk1::sample1) !#<PACKAGE "PK1">
(symbol-package ’pk2::sample1) !#<PACKAGE "PK1">
(symbol-package ’pk1::sample2) !#<PACKAGE "PK1">
(symbol-package ’pk2::sample2) !#<PACKAGE "PK2">
;; The next several forms create a scenario in which a symbol
;; is not really uninterned, but is "apparently uninterned",
;; and so SYMBOL-PACKAGE still returns NIL.
(setq s3 ’pk1::sample3) !PK1::SAMPLE3
(import s3 ’pk2) !T
(unintern s3 ’pk1) !T
(symbol-package s3) !NIL
(eq s3 ’pk2::sample3) !T
Aﬀected By:
import ,intern ,unintern
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
10–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
intern
symbol-plist Accessor
Syntax:
symbol-plist symbol!plist
(setf (symbol-plist symbol)new-plist)
Arguments and Values:
symbol |asymbol .
plist,new-plist |aproperty list .
Description:
Accesses theproperty list ofsymbol .
Examples:
(setq sym (gensym)) !#:G9723
(symbol-plist sym) !()
(setf (get sym ’prop1) ’val1) !VAL1
(symbol-plist sym) !(PROP1 VAL1)
(setf (get sym ’prop2) ’val2) !VAL2
(symbol-plist sym) !(PROP2 VAL2 PROP1 VAL1)
(setf (symbol-plist sym) (list ’prop3 ’val3)) !(PROP3 VAL3)
(symbol-plist sym) !(PROP3 VAL3)
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
See Also:
get,remprop
Notes:
The use of setf should be avoided, since a symbol 'sproperty list is a global resource that can
contain information established and depended upon by unrelated programs in the same Lisp image .
Symbols 10–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
symbol-value
symbol-value Accessor
Syntax:
symbol-value symbol!value
(setf (symbol-value symbol)new-value )
Arguments and Values:
symbol |asymbol that must have a value .
value ,new-value |an object .
Description:
Accesses thesymbol 'svalue cell .
Examples:
(setf (symbol-value ’a) 1) !1
(symbol-value ’a) !1
;; SYMBOL-VALUE cannot see lexical variables.
(let ((a 2)) (symbol-value ’a)) !1
(let ((a 2)) (setq a 3) (symbol-value ’a)) !1
;; SYMBOL-VALUE can see dynamic variables.
(let ((a 2))
(declare (special a))
(symbol-value ’a)) !2
(let ((a 2))
(declare (special a))
(setq a 3)
(symbol-value ’a)) !3
(let ((a 2))
(setf (symbol-value ’a) 3)
a)!2
a!3
(symbol-value ’a) !3
(let ((a 4))
(declare (special a))
(let ((b (symbol-value ’a)))
(setf (symbol-value ’a) 5)
(values a b)))!5, 4
a!3
(symbol-value :any-keyword) !:ANY-KEYWORD
(symbol-value ’nil) !NIL
(symbol-value ’()) !NIL
10–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;; The precision of this next one is implementation-dependent .
(symbol-value ’pi) !3.141592653589793d0
Aﬀected By:
makunbound ,set,setq
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
Should signal unbound-variable ifsymbol isunbound and an attempt is made to read itsvalue .
(No such error is signaled on an attempt to write itsvalue .)
See Also:
boundp ,makunbound ,set,setq
Notes:
symbol-value can be used to get the value of a constant variable .symbol-value cannot access the
value of a lexical variable .
get Accessor
Syntax:
getsymbol indicator &optional default!value
(setf (get symbol indicator &optional default)new-value )
Arguments and Values:
symbol |asymbol .
indicator |an object .
default |an object . The default is nil.
value |if the indicated property exists, the object that is its value ; otherwise, the specied default .
new-value |an object .
Description:
getnds a property on the property list 2ofsymbol whose property indicator isidentical to
indicator , and returns its corresponding property value . If there are multiple properties 1with that
property indicator ,getuses the rst such property . If there is no property with that property
indicator ,default is returned.
Symbols 10–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
get
setfofgetmay be used to associate a new object with an existing indicator already on the symbol 's
property list , or to create a new assocation if none exists. If there are multiple properties 1with
that property indicator ,setf ofgetassociates the new-value with the rst such property . When a
getform is used as a setf place , any default which is supplied is evaluated according to normal
left-to-right evaluation rules, but its value is ignored.
Examples:
(defun make-person (first-name last-name)
(let ((person (gensym "PERSON")))
(setf (get person ’first-name) first-name)
(setf (get person ’last-name) last-name)
person))!MAKE-PERSON
(defvar *john* (make-person "John" "Dow")) !*JOHN*
*john*!#:PERSON4603
(defvar *sally* (make-person "Sally" "Jones")) !*SALLY*
(get *john* ’first-name) !"John"
(get *sally* ’last-name) !"Jones"
(defun marry (man woman married-name)
(setf (get man ’wife) woman)
(setf (get woman ’husband) man)
(setf (get man ’last-name) married-name)
(setf (get woman ’last-name) married-name)
married-name)!MARRY
(marry *john* *sally* "Dow-Jones") !"Dow-Jones"
(get *john* ’last-name) !"Dow-Jones"
(get (get *john* ’wife) ’first-name) !"Sally"
(symbol-plist *john*)
!(WIFE #:PERSON4604 LAST-NAME "Dow-Jones" FIRST-NAME "John")
(defmacro age (person &optional (default ”thirty-something))
‘(get ,person ’age ,default)) !AGE
(age *john*)!THIRTY-SOMETHING
(age *john* 20) !20
(setf (age *john*) 25) !25
(age *john*)!25
(age *john* 20) !25
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
See Also:
getf,symbol-plist ,remprop
Notes:
(get x y)(getf (symbol-plist x) y)
10–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Numbers and characters are not recommended for use as indicators in portable code since
gettests with eqrather than eql, and consequently the eect of using such indicators is
implementation-dependent .
There is no way using getto distinguish an absent property from one whose value is default .
However, see get-properties .
remprop Function
Syntax:
remprop symbol indicator !generalized-boolean
Arguments and Values:
symbol |asymbol .
indicator |an object .
generalized-boolean |ageneralized boolean .
Description:
remprop removes from the property list 2ofsymbol aproperty 1with a property indicator identical
toindicator . If there are multiple properties 1with the identical key,remprop only removes the
rst such property .remprop returns false if no such property was found, or true if a property was
found.
The property indicator and the corresponding property value are removed in an undened order by
destructively splicing the property list. The permissible side-eects correspond to those permitted
forremf , such that:
(remprop x y)(remf (symbol-plist x)y)
Examples:
(setq test (make-symbol "PSEUDO-PI")) !#:PSEUDO-PI
(symbol-plist test) !()
(setf (get test ’constant) t) !T
(setf (get test ’approximation) 3.14) !3.14
(setf (get test ’error-range) ’noticeable) !NOTICEABLE
(symbol-plist test)
!(ERROR-RANGE NOTICEABLE APPROXIMATION 3.14 CONSTANT T)
(setf (get test ’approximation) nil) !NIL
(symbol-plist test)
!(ERROR-RANGE NOTICEABLE APPROXIMATION NIL CONSTANT T)
(get test ’approximation) !NIL
Symbols 10–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(remprop test ’approximation) !true
(get test ’approximation) !NIL
(symbol-plist test)
!(ERROR-RANGE NOTICEABLE CONSTANT T)
(remprop test ’approximation) !NIL
(symbol-plist test)
!(ERROR-RANGE NOTICEABLE CONSTANT T)
(remprop test ’error-range) !true
(setf (get test ’approximation) 3) !3
(symbol-plist test)
!(APPROXIMATION 3 CONSTANT T)
Side Eﬀects:
The property list ofsymbol is modied.
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
See Also:
remf ,symbol-plist
Notes:
Numbers and characters are not recommended for use as indicators in portable code since
remprop tests with eqrather than eql, and consequently the eect of using such indicators is
implementation-dependent . Of course, if you've gotten as far as needing to remove such a property ,
you don't have much choice|the time to have been thinking about this was when you used setfof
getto establish the property .
boundp Function
Syntax:
boundp symbol!generalized-boolean
Arguments and Values:
symbol |asymbol .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifsymbol isbound ; otherwise, returns false.
10–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(setq x 1)!1
(boundp ’x)!true
(makunbound ’x) !X
(boundp ’x)!false
(let ((x 2)) (boundp ’x)) !false
(let ((x 2)) (declare (special x)) (boundp ’x)) !true
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
See Also:
set,setq,symbol-value ,makunbound
Notes:
The functionbound determines only whether a symbol has a value in the global environment ; any
lexical bindings are ignored.
makunbound Function
Syntax:
makunbound symbol!symbol
Arguments and Values:
symbol |asymbol
Description:
Makes the symbol beunbound , regardless of whether it was previously bound .
Examples:
(setf (symbol-value ’a) 1)
(boundp ’a)!true
a!1
(makunbound ’a) !A
(boundp ’a)!false
Side Eﬀects:
The value cell ofsymbol is modied.
Exceptional Situations:
Should signal an error of typetype-error ifsymbol is not a symbol .
Symbols 10–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
boundp ,fmakunbound
set Function
Syntax:
setsymbol value!value
Arguments and Values:
symbol |asymbol .
value |an object .
Description:
setchanges the contents of the value cell ofsymbol to the given value .
(set symbol value )(setf (symbol-value symbol)value)
Examples:
(setf (symbol-value ’n) 1) !1
(set ’n 2)!2
(symbol-value ’n) !2
(let ((n 3))
(declare (special n))
(setq n (+ n 1))
(setf (symbol-value ’n) (* n 10))
(set ’n (+ (symbol-value ’n) n))
n)!80
n!2
(let ((n 3))
(setq n (+ n 1))
(setf (symbol-value ’n) (* n 10))
(set ’n (+ (symbol-value ’n) n))
n)!4
n!44
(defvar *n* 2)
(let ((*n* 3))
(setq *n* (+ *n* 1))
(setf (symbol-value ’*n*) (* *n* 10))
(set ’*n* (+ (symbol-value ’*n*) *n*))
*n*)!80
*n*!2
10–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defvar *even-count* 0) !*EVEN-COUNT*
(defvar *odd-count* 0) !*ODD-COUNT*
(defun tally-list (list)
(dolist (element list)
(set (if (evenp element) ’*even-count* ’*odd-count*)
(+ element (if (evenp element) *even-count* *odd-count*)))))
(tally-list ’(1 9 4 3 2 7)) !NIL
*even-count*!6
*odd-count*!20
Side Eﬀects:
The value ofsymbol is changed.
See Also:
setq,progv ,symbol-value
Notes:
The function setis deprecated.
setcannot change the value of a lexical variable .
unbound-variable Condition Type
Class Precedence List:
unbound-variable ,cell-error ,error ,serious-condition ,condition ,t
Description:
The typeunbound-variable consists of error conditions that represent attempts to read thevalue
of an unbound variable .
The name of the cell (see cell-error ) is the name of the variable that was unbound .
See Also:
cell-error-name
Symbols 10–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
10–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
11. Packages
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Packages iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
11.1 Package Concepts
11.1.1 Introduction to Packages
Apackage establishes a mapping from names to symbols . At any given time, one package is
current. The current package is the one that is the value of*package* . When using the Lisp
reader , it is possible to refer to symbols inpackages other than the current one through the use of
package prexes in the printed representation of the symbol .
Figure 11{1 lists some dened names that are applicable to packages . Where an operator takes an
argument that is either a symbol or a listofsymbols , an argument of nilis treated as an empty list
ofsymbols . Any package argument may be either a string , asymbol , or a package . If a symbol is
supplied, its name will be used as the package name.
*modules* import provide
*package* in-package rename-package
defpackage intern require
do-all-symbols list-all-packages shadow
do-external-symbols make-package shadowing-import
do-symbols package-name unexport
export package-nicknames unintern
ﬁnd-all-symbols package-shadowing-symbols unuse-package
ﬁnd-package package-use-list use-package
ﬁnd-symbol package-used-by-list
Figure 11–1. Some Deﬁned Names related to Packages
11.1.1.1 Package Names and Nicknames
Each package has a name (astring ) and perhaps some nicknames (also strings ). These are assigned
when the package is created and can be changed later.
There is a single namespace for packages . The functionﬁnd-package translates a package name or
nickname into the associated package . The functionpackage-name returns the name of apackage .
The function package-nicknames returns a listof all nicknames for a package .rename-package
removes a package 's current name and nicknames and replaces them with new ones specied by
the caller.
11.1.1.2 Symbols in a Package
Packages 11–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
11.1.1.2.1 Internal and External Symbols
The mappings in a package are divided into two classes, external and internal. The symbols
targeted by these dierent mappings are called external symbols and internal symbols of the
package . Within a package , a name refers to one symbol or to none; if it does refer to a symbol ,
then it is either external or internal in that package , but not both. External symbols are part
of the package's public interface to other packages .Symbols become external symbols of a given
package if they have been exported from that package .
Asymbol has the same name no matter what package it is present in, but it might be an external
symbol of some packages and an internal symbol of others.
11.1.1.2.2 Package Inheritance
Packages can be built up in layers. From one point of view, a package is a single collection
of mappings from strings into internal symbols and external symbols . However, some of these
mappings might be established within the package itself, while other mappings are inherited from
other packages viause-package . Asymbol is said to be present in a package if the mapping is in
thepackage itself and is not inherited from somewhere else.
There is no way to inherit the internal symbols of another package ; to refer to an internal symbol
using the Lisp reader , apackage containing the symbol must be made to be the current package , a
package prex must be used, or the symbol must be imported into the current package .
11.1.1.2.3 Accessibility of Symbols in a Package
Asymbol becomes accessible in a package if that is its home package when it is created, or if it is
imported into that package , or by inheritance via use-package .
If a symbol isaccessible in a package , it can be referred to when using the Lisp reader without
apackage prex when that package is the current package , regardless of whether it is present or
inherited.
Symbols from one package can be made accessible in another package in two ways.
{ Any individual symbol can be added to a package by use of import . After the call to
import thesymbol ispresent in the importing package . The status of the symbol in
thepackage it came from (if any) is unchanged, and the home package for this symbol
is unchanged. Once imported , asymbol ispresent in the importing package and can be
removed only by calling unintern .
Asymbol isshadowed 3by another symbol in some package if the rst symbol would
beaccessible by inheritance if not for the presence of the second symbol . See
shadowing-import .
{ The second mechanism for making symbols from one package accessible in another is
provided by use-package . All of the external symbols of the used package are inherited
11–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
by the using package . The function unuse-package undoes the eects of a previous
use-package .
11.1.1.2.4 Locating a Symbol in a Package
When a symbol is to be located in a given package the following occurs:
{ The external symbols and internal symbols of the package are searched for the symbol .
{ The external symbols of the used packages are searched in some unspecied order. The
order does not matter; see the rules for handling name conicts listed below.
11.1.1.2.5 Prevention of Name Conﬂicts in Packages
Within one package , any particular name can refer to at most one symbol . A name conict is said
to occur when there would be more than one candidate symbol . Any time a name conict is about
to occur, a correctable error is signaled.
The following rules apply to name conicts:
{ Name conicts are detected when they become possible, that is, when the package structure
is altered. Name conicts are not checked during every name lookup.
{ If the same symbol isaccessible to a package through more than one path, there is no
name conict. A symbol cannot conict with itself. Name conicts occur only between
distinct symbols with the same name (under string= ).
{ Every package has a list of shadowing symbols . A shadowing symbol takes precedence over
any other symbol of the same name that would otherwise be accessible in the package . A
name conict involving a shadowing symbol is always resolved in favor of the shadowing
symbol , without signaling an error (except for one exception involving import ). See
shadow andshadowing-import .
{ The functions use-package ,import , andexport check for name conicts.
{shadow andshadowing-import never signal a name-conict error.
{unuse-package andunexport do not need to do any name-conict checking. unintern
does name-conict checking only when a symbol being uninterned is ashadowing symbol .
{ Giving a shadowing symbol to unintern can uncover a name conict that had previously
been resolved by the shadowing.
{ Package functions signal name-conict errors of typepackage-error before making any
change to the package structure. When multiple changes are to be made, it is permissible
for the implementation to process each change separately. For example, when export is
Packages 11–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
given a listofsymbols , aborting from a name conict caused by the second symbol in the
listmight still export the rst symbol in the list. However, a name-conict error caused by
export of a single symbol will be signaled before that symbol 'saccessibility in any package
is changed.
{ Continuing from a name-conict error must oer the user a chance to resolve the name
conict in favor of either of the candidates. The package structure should be altered to
reect the resolution of the name conict, via shadowing-import ,unintern , orunexport .
{ A name conict in use-package between a symbol present in the using package and an
external symbol of the used package is resolved in favor of the rst symbol by making it a
shadowing symbol , or in favor of the second symbol by uninterning the rst symbol from
the using package .
{ A name conict in export orunintern due to a package 's inheriting two distinct symbols
with the same name (understring= ) from two other packages can be resolved in favor of
either symbol by importing it into the using package and making it a shadowing symbol ,
just as with use-package .
11.1.2 Standardized Packages
This section describes the packages that are available in every conforming implementation . A
summary of the names and nicknames of those standardized packages is given in Figure 11{2.
Name Nicknames
COMMON-LISP CL
COMMON-LISP-USER CL-USER
KEYWORD none
Figure 11–2. Standardized Package Names
11.1.2.1 The COMMON-LISP Package
TheCOMMON-LISP package contains the primitives of the Common Lisp system as dened by this
specication. Its external symbols include all of the dened names (except for dened names in
theKEYWORD package ) that are present in the Common Lisp system, such as car,cdr,*package* ,
etc. The COMMON-LISP package has the nickname CL.
TheCOMMON-LISP package has as external symbols those symbols enumerated in the gures in
Section 1.9 (Symbols in the COMMON-LISP Package), and no others. These external symbols are
present in theCOMMON-LISP package but their home package need not be the COMMON-LISP package .
For example, the symbol HELP cannot be an external symbol of theCOMMON-LISP package because it
is not mentioned in Section 1.9 (Symbols in the COMMON-LISP Package). In contrast, the symbol
11–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
variable must be an external symbol of theCOMMON-LISP package even though it has no denition
because it is listed in that section (to support its use as a valid second argument to the function
documentation ).
TheCOMMON-LISP package can have additional internal symbols .
11.1.2.1.1 Constraints on the COMMON-LISP Package for Conforming
Implementations
In a conforming implementation , an external symbol of theCOMMON-LISP package can have a
function ,macro , or special operator denition, a global variable denition (or other status as a
dynamic variable due to a special proclamation ), or a type denition only if explicitly permitted
in this standard. For example, fboundp yields false for any external symbol of theCOMMON-LISP
package that is not the name of a standardized function ,macro orspecial operator , andboundp
returns false for any external symbol of theCOMMON-LISP package that is not the name of a
standardized global variable . It also follows that conforming programs can use external symbols
of theCOMMON-LISP package as the names of local lexical variables with condence that those
names have not been proclaimed special by the implementation unless those symbols arenames of
standardized global variables .
Aconforming implementation must not place any property on an external symbol of theCOMMON-LISP
package using a property indicator that is either an external symbol of any standardized package or
asymbol that is otherwise accessible in theCOMMON-LISP-USER package .
11.1.2.1.2 Constraints on the COMMON-LISP Package for Conforming Programs
Except where explicitly allowed, the consequences are undened if any of the following actions are
performed on an external symbol of theCOMMON-LISP package :
1.Binding or altering its value (lexically or dynamically). (Some exceptions are noted below.)
2. Dening, undening, or binding it as a function . (Some exceptions are noted below.)
3. Dening, undening, or binding it as a macro orcompiler macro . (Some exceptions are
noted below.)
4. Dening it as a type specier (viadefstruct ,defclass ,deftype ,deﬁne-condition ).
5. Dening it as a structure (via defstruct ).
6. Dening it as a declaration with adeclaration proclamation .
7. Dening it as a symbol macro .
8. Altering its home package .
Packages 11–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
9. Tracing it (via trace ).
10. Declaring or proclaiming it special (viadeclare ,declaim , orproclaim ).
11. Declaring or proclaiming its type orftype (viadeclare ,declaim , orproclaim ). (Some
exceptions are noted below.)
12. Removing it from the COMMON-LISP package .
13. Dening a setf expander for it (via defsetf ordeﬁne-setf-method ).
14. Dening, undening, or binding its setf function name .
15. Dening it as a method combination type (via deﬁne-method-combination ).
16. Using it as the class-name argument to setf ofﬁnd-class .
17. Binding it as a catch tag .
18. Binding it as a restart name .
19. Dening a method for a standardized generic function which is applicable when all of the
arguments aredirect instances ofstandardized classes .
11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON-LISP Package for Conforming
Programs
If an external symbol of theCOMMON-LISP package is not globally dened as a standardized dynamic
variable orconstant variable , it is allowed to lexically bind it and to declare the type of that
binding , and it is allowed to locally establish it as a symbol macro (e.g., withsymbol-macrolet ).
Unless explicitly specied otherwise, if an external symbol of theCOMMON-LISP package is globally
dened as a standardized dynamic variable , it is permitted to bind orassign that dynamic variable
provided that the \Value Type" constraints on the dynamic variable are maintained, and that the
new value of the variable is consistent with the stated purpose of the variable .
If an external symbol of theCOMMON-LISP package is not dened as a standardized function ,macro ,
orspecial operator , it is allowed to lexically bind it as a function (e.g., withﬂet), to declare the
ftype of that binding , and (in implementations which provide the ability to do so) to trace that
binding .
If an external symbol of theCOMMON-LISP package is not dened as a standardized function ,macro ,
orspecial operator , it is allowed to lexically bind it as a macro (e.g., withmacrolet ).
If an external symbol of theCOMMON-LISP package is not dened as a standardized function ,macro ,
orspecial operator , it is allowed to lexically bind itssetf function name as a function , and to
declare the ftype of that binding .
11–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
11.1.2.2 The COMMON-LISP-USER Package
TheCOMMON-LISP-USER package is the current package when a Common Lisp system starts up. This
package uses theCOMMON-LISP package . TheCOMMON-LISP-USER package has the nickname CL-USER .
TheCOMMON-LISP-USER package can have additional symbols interned within it; it can useother
implementation-dened packages .
11.1.2.3 The KEYWORD Package
TheKEYWORD package contains symbols , called keywords 1, that are typically used as special markers
inprograms and their associated data expressions 1.
Symbol tokens that start with a package marker are parsed by the Lisp reader assymbols in the
KEYWORD package ; see Section 2.3.4 (Symbols as Tokens). This makes it notationally convenient
to use keywords when communicating between programs in dierent packages . For example, the
mechanism for passing keyword parameters in a calluses keywords 1to name the corresponding
arguments ; see Section 3.4.1 (Ordinary Lambda Lists).
Symbols in theKEYWORD package are, by denition, of typekeyword .
11.1.2.3.1 Interning a Symbol in the KEYWORD Package
TheKEYWORD package is treated dierently than other packages in that special actions are taken
when a symbol isinterned in it. In particular, when a symbol isinterned in theKEYWORD package ,
it is automatically made to be an external symbol and is automatically made to be a constant
variable with itself as a value .
11.1.2.3.2 Notes about The KEYWORD Package
It is generally best to conne the use of keywords to situations in which there are a nitely
enumerable set of names to be selected between. For example, if there were two states of a light
switch, they might be called :onand:off.
In situations where the set of names is not nitely enumerable ( i.e., where name conicts might
arise) it is frequently best to use symbols in some package other than KEYWORD so that conicts will
be naturally avoided. For example, it is generally not wise for a program to use a keyword 1as a
property indicator , since if there were ever another program that did the same thing, each would
clobber the other's data.
11.1.2.4 Implementation-Deﬁned Packages
Other, implementation-dened packages might be present in the initial Common Lisp environment.
It is recommended, but not required, that the documentation for a conforming implementation
contain a full list of all package names initially present in that implementation but not specied in
this specication. (See also the functionlist-all-packages .)
Packages 11–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
package System Class
Class Precedence List:
package ,t
Description:
Apackage is anamespace that maps symbol names tosymbols ; see Section 11.1 (Package Concepts).
See Also:
Section 11.1 (Package Concepts), Section 22.1.3.13 (Printing Other Objects), Section 2.3.4
(Symbols as Tokens)
export Function
Syntax:
export symbols &optional package!t
Arguments and Values:
symbols |adesignator for a listofsymbols .
package |apackage designator . The default is the current package .
Description:
export makes one or more symbols that are accessible inpackage (whether directly or by
inheritance) be external symbols of that package .
If any of the symbols is already accessible as an external symbol ofpackage ,export has no eect
on that symbol . If the symbol ispresent inpackage as an internal symbol, it is simply changed
to external status. If it is accessible as an internal symbol viause-package , it is rst imported
into package , then exported . (The symbol is then present in the package whether or not package
continues to use the package through which the symbol was originally inherited.)
export makes each symbol accessible to all the packages that use package . All of these packages
are checked for name conicts: (export s p)does(find-symbol (symbol-name s)q)for each
package qin(package-used-by-list p). Note that in the usual case of an export during the initial
denition of a package , the result of package-used-by-list isniland the name-conict checking
takes negligible time. When multiple changes are to be made, for example when export is given a
listofsymbols , it is permissible for the implementation to process each change separately, so that
aborting from a name conict caused by any but the rst symbol in the listdoes not unexport the
rst symbol in the list. However, aborting from a name-conict error caused by export of one of
symbols does not leave that symbol accessible to some packages and inaccessible to others; with
respect to each of symbols processed, export behaves as if it were as an atomic operation.
11–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
A name conict in export between one of symbols being exported and a symbol already present in
apackage that would inherit the newly-exported symbol may be resolved in favor of the exported
symbol by uninterning the other one, or in favor of the already-present symbol by making it a
shadowing symbol.
Examples:
(make-package ’temp :use nil) !#<PACKAGE "TEMP">
(use-package ’temp) !T
(intern "TEMP-SYM" ’temp) !TEMP::TEMP-SYM, NIL
(find-symbol "TEMP-SYM") !NIL, NIL
(export (find-symbol "TEMP-SYM" ’temp) ’temp) !T
(find-symbol "TEMP-SYM") !TEMP-SYM, :INHERITED
Side Eﬀects:
The package system is modied.
Aﬀected By:
Accessible symbols .
Exceptional Situations:
If any of the symbols is not accessible at all in package , an error of typepackage-error is signaled
that is correctable by permitting the user to interactively specify whether that symbol should be
imported .
See Also:
import ,unexport , Section 11.1 (Package Concepts)
ﬁnd-symbol Function
Syntax:
ﬁnd-symbol string&optional package!symbol, status
Arguments and Values:
string |astring .
package |apackage designator . The default is the current package .
symbol |asymbol accessible in the package , ornil.
status |one of :inherited ,:external ,:internal , ornil.
Packages 11–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬁnd-symbol
Description:
ﬁnd-symbol locates a symbol whose name isstring in a package . If a symbol named string is found
inpackage , directly or by inheritance, the symbol found is returned as the rst value; the second
value is as follows:
:internal
If the symbol ispresent inpackage as an internal symbol .
:external
If the symbol ispresent inpackage as an external symbol .
:inherited
If the symbol is inherited by package throughuse-package , but is not present inpackage .
If no such symbol isaccessible inpackage , both values are nil.
Examples:
(find-symbol "NEVER-BEFORE-USED") !NIL, NIL
(find-symbol "NEVER-BEFORE-USED") !NIL, NIL
(intern "NEVER-BEFORE-USED") !NEVER-BEFORE-USED, NIL
(intern "NEVER-BEFORE-USED") !NEVER-BEFORE-USED, :INTERNAL
(find-symbol "NEVER-BEFORE-USED") !NEVER-BEFORE-USED, :INTERNAL
(find-symbol "never-before-used") !NIL, NIL
(find-symbol "CAR" ’common-lisp-user) !CAR, :INHERITED
(find-symbol "CAR" ’common-lisp) !CAR, :EXTERNAL
(find-symbol "NIL" ’common-lisp-user) !NIL, :INHERITED
(find-symbol "NIL" ’common-lisp) !NIL, :EXTERNAL
(find-symbol "NIL" (prog1 (make-package "JUST-TESTING" :use ’())
(intern "NIL" "JUST-TESTING")))
!JUST-TESTING::NIL, :INTERNAL
(export ’just-testing::nil ’just-testing)
(find-symbol "NIL" ’just-testing) !JUST-TESTING:NIL, :EXTERNAL
(find-symbol "NIL" "KEYWORD")
!NIL, NILor!:NIL, :EXTERNAL
(find-symbol (symbol-name :nil) "KEYWORD") !:NIL, :EXTERNAL
Aﬀected By:
intern ,import ,export ,use-package ,unintern ,unexport ,unuse-package
See Also:
intern ,ﬁnd-all-symbols
11–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
ﬁnd-symbol is operationally equivalent to intern , except that it never creates a new symbol .
ﬁnd-package Function
Syntax:
ﬁnd-package name!package
Arguments and Values:
name |astring designator or a package object .
package |apackage object ornil.
Description:
Ifname is a string designator ,ﬁnd-package locates and returns the package whose name or
nickname is name . This search is case sensitive. If there is no such package ,ﬁnd-package returns
nil.
Ifname is apackage object , that package object is returned.
Examples:
(find-package ’common-lisp) !#<PACKAGE "COMMON-LISP">
(find-package "COMMON-LISP-USER") !#<PACKAGE "COMMON-LISP-USER">
(find-package ’not-there) !NIL
Aﬀected By:
The set of packages created by the implementation .
defpackage ,delete-package ,make-package ,rename-package
See Also:
make-package
Packages 11–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬁnd-all-symbols Function
Syntax:
ﬁnd-all-symbols string!symbols
Arguments and Values:
string |astring designator .
symbols |alistofsymbols .
Description:
ﬁnd-all-symbols searches every registered package forsymbols that have a name that is the same
(understring= ) as string . Alistof all such symbols is returned. Whether or how the listis ordered
isimplementation-dependent .
Examples:
(find-all-symbols ’car)
!(CAR)or!(CAR VEHICLES:CAR)or!(VEHICLES:CAR CAR)
(intern "CAR" (make-package ’temp :use nil)) !TEMP::CAR, NIL
(find-all-symbols ’car)
!(TEMP::CAR CAR)or!(CAR TEMP::CAR)or!(TEMP::CAR CAR VEHICLES:CAR)or!(CAR TEMP::CAR VEHICLES:CAR)
See Also:
ﬁnd-symbol
import Function
Syntax:
import symbols &optional package!t
Arguments and Values:
symbols |adesignator for a listofsymbols .
package |apackage designator . The default is the current package .
11–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
import adds symbol orsymbols to the internals of package , checking for name conicts with
existing symbols either present inpackage oraccessible to it. Once the symbols have been imported ,
they may be referenced in the importing package without the use of a package prex when using
theLisp reader .
A name conict in import between the symbol being imported and a symbol inherited from some
other package can be resolved in favor of the symbol being imported by making it a shadowing
symbol, or in favor of the symbol already accessible by not doing the import . A name conict in
import with a symbol already present in the package may be resolved by uninterning that symbol ,
or by not doing the import .
The imported symbol is not automatically exported from the current package , but if it is already
present and external, then the fact that it is external is not changed. If any symbol to be imported
has no home package ( i.e.,(symbol-package symbol)!nil),import sets the home package of the
symbol topackage .
If the symbol is already present in the importing package ,import has no eect.
Examples:
(import ’common-lisp::car (make-package ’temp :use nil)) !T
(find-symbol "CAR" ’temp) !CAR, :INTERNAL
(find-symbol "CDR" ’temp) !NIL, NIL
The form (import ’editor:buffer) takes the external symbol named buffer in theEDITOR package
(this symbol was located when the form was read by the Lisp reader ) and adds it to the current
package as an internal symbol . The symbol buffer is then present in the current package .
Side Eﬀects:
The package system is modied.
Aﬀected By:
Current state of the package system.
Exceptional Situations:
import signals a correctable error of typepackage-error if any of the symbols to be imported has
thesame name (understring= ) as some distinct symbol (undereql) already accessible in the
package , even if the conict is with a shadowing symbol of the package .
See Also:
shadow ,export
Packages 11–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
list-all-packages Function
Syntax:
list-all-packages hno argumentsi ! packages
Arguments and Values:
packages |alistofpackage objects .
Description:
list-all-packages returns a fresh list of all registered packages .
Examples:
(let ((before (list-all-packages)))
(make-package ’temp)
(set-difference (list-all-packages) before)) !(#<PACKAGE "TEMP">)
Aﬀected By:
defpackage ,delete-package ,make-package
rename-package Function
Syntax:
rename-package package new-name &optional new-nicknames!package-object
Arguments and Values:
package |apackage designator .
new-name |apackage designator .
new-nicknames |alistofstring designators . The default is the empty list .
package-object |the renamed package object .
Description:
Replaces the name and nicknames of package . The old name and all of the old nicknames of
package are eliminated and are replaced by new-name and new-nicknames .
The consequences are undened if new-name or any new-nickname conicts with any existing
package names.
11–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(make-package ’temporary :nicknames ’("TEMP")) !#<PACKAGE "TEMPORARY">
(rename-package ’temp ’ephemeral) !#<PACKAGE "EPHEMERAL">
(package-nicknames (find-package ’ephemeral)) !()
(find-package ’temporary) !NIL
(rename-package ’ephemeral ’temporary ’(temp fleeting))
!#<PACKAGE "TEMPORARY">
(package-nicknames (find-package ’temp)) !("TEMP" "FLEETING")
See Also:
make-package
shadow Function
Syntax:
shadow symbol-names &optional package!t
Arguments and Values:
symbol-names |adesignator for a listofstring designators .
package |apackage designator . The default is the current package .
Description:
shadow assures that symbols with names given by symbol-names arepresent in the package .
Specically, package is searched for symbols with the names supplied by symbol-names . For each
such name , if a corresponding symbol is not present inpackage (directly, not by inheritance), then
a corresponding symbol is created with that name , and inserted into package as an internal symbol .
The corresponding symbol , whether pre-existing or newly created, is then added, if not already
present, to the shadowing symbols list ofpackage .
Examples:
(package-shadowing-symbols (make-package ’temp)) !NIL
(find-symbol ’car ’temp) !CAR, :INHERITED
(shadow ’car ’temp) !T
(find-symbol ’car ’temp) !TEMP::CAR, :INTERNAL
(package-shadowing-symbols ’temp) !(TEMP::CAR)
(make-package ’test-1) !#<PACKAGE "TEST-1">
(intern "TEST" (find-package ’test-1)) !TEST-1::TEST, NIL
(shadow ’test-1::test (find-package ’test-1)) !T
Packages 11–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(shadow ’TEST (find-package ’test-1)) !T
(assert (not (null (member ’test-1::test (package-shadowing-symbols
(find-package ’test-1))))))
(make-package ’test-2) !#<PACKAGE "TEST-2">
(intern "TEST" (find-package ’test-2)) !TEST-2::TEST, NIL
(export ’test-2::test (find-package ’test-2)) !T
(use-package ’test-2 (find-package ’test-1)) ;should not error
Side Eﬀects:
shadow changes the state of the package system in such a way that the package consistency rules
do not hold across the change.
Aﬀected By:
Current state of the package system.
See Also:
package-shadowing-symbols , Section 11.1 (Package Concepts)
Notes:
If a symbol with a name in symbol-names already exists in package , but by inheritance, the
inherited symbol becomes shadowed 3by a newly created internal symbol .
shadowing-import Function
Syntax:
shadowing-import symbols &optional package!t
Arguments and Values:
symbols |adesignator for a listofsymbols .
package |apackage designator . The default is the current package .
Description:
shadowing-import is likeimport , but it does not signal an error even if the importation of a
symbol would shadow some symbol already accessible inpackage .
shadowing-import inserts each of symbols into package as an internal symbol, regardless of
whether another symbol of the same name is shadowed by this action. If a dierent symbol of the
same name is already present inpackage , that symbol is rst uninterned from package . The new
symbol is added to package 's shadowing-symbols list.
11–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
shadowing-import does name-conict checking to the extent that it checks whether a distinct
existing symbol with the same name is accessible ; if so, it is shadowed by the new symbol , which
implies that it must be uninterned if it was present inpackage .
Examples:
(in-package "COMMON-LISP-USER") !#<PACKAGE "COMMON-LISP-USER">
(setq sym (intern "CONFLICT")) !CONFLICT
(intern "CONFLICT" (make-package ’temp)) !TEMP::CONFLICT, NIL
(package-shadowing-symbols ’temp) !NIL
(shadowing-import sym ’temp) !T
(package-shadowing-symbols ’temp) !(CONFLICT)
Side Eﬀects:
shadowing-import changes the state of the package system in such a way that the consistency
rules do not hold across the change.
package 's shadowing-symbols list is modied.
Aﬀected By:
Current state of the package system.
See Also:
import ,unintern ,package-shadowing-symbols
delete-package Function
Syntax:
delete-package package!generalized-boolean
Arguments and Values:
package |apackage designator .
generalized-boolean |ageneralized boolean .
Description:
delete-package deletes package from all package system data structures. If the operation is
successful, delete-package returns true, otherwise nil. The eect of delete-package is that the
name and nicknames of package cease to be recognized package names. The package object is still a
package (i.e.,packagep istrue of it) but package-name returnsnil. The consequences of deleting
theCOMMON-LISP package or theKEYWORD package are undened. The consequences of invoking any
other package operation on package once it has been deleted are unspecied. In particular, the
consequences of invoking ﬁnd-symbol ,intern and other functions that look for a symbol name in
Packages 11–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
delete-package
apackage are unspecied if they are called with *package* bound to the deleted package or with
the deleted package as an argument.
Ifpackage is apackage object that has already been deleted, delete-package immediately returns
nil.
After this operation completes, the home package of any symbol whose home package had previously
been package isimplementation-dependent . Except for this, symbols accessible inpackage are not
modied in any other way; symbols whose home package is not package remain unchanged.
Examples:
(setq *foo-package* (make-package "FOO" :use nil))
(setq *foo-symbol* (intern "FOO" *foo-package*))
(export *foo-symbol* *foo-package*)
(setq *bar-package* (make-package "BAR" :use ’("FOO")))
(setq *bar-symbol* (intern "BAR" *bar-package*))
(export *foo-symbol* *bar-package*)
(export *bar-symbol* *bar-package*)
(setq *baz-package* (make-package "BAZ" :use ’("BAR")))
(symbol-package *foo-symbol*) !#<PACKAGE "FOO">
(symbol-package *bar-symbol*) !#<PACKAGE "BAR">
(prin1-to-string *foo-symbol*) !"FOO:FOO"
(prin1-to-string *bar-symbol*) !"BAR:BAR"
(find-symbol "FOO" *bar-package*) !FOO:FOO, :EXTERNAL
(find-symbol "FOO" *baz-package*) !FOO:FOO, :INHERITED
(find-symbol "BAR" *baz-package*) !BAR:BAR, :INHERITED
(packagep *foo-package*) !true
(packagep *bar-package*) !true
(packagep *baz-package*) !true
(package-name *foo-package*) !"FOO"
(package-name *bar-package*) !"BAR"
(package-name *baz-package*) !"BAZ"
(package-use-list *foo-package*) !()
(package-use-list *bar-package*) !(#<PACKAGE "FOO">)
(package-use-list *baz-package*) !(#<PACKAGE "BAR">)
11–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
delete-package
(package-used-by-list *foo-package*) !(#<PACKAGE "BAR">)
(package-used-by-list *bar-package*) !(#<PACKAGE "BAZ">)
(package-used-by-list *baz-package*) !()
(delete-package *bar-package*)
.Error: Package BAZ uses package BAR.
.If continued, BAZ will be made to unuse-package BAR,
.and then BAR will be deleted.
.Type :CONTINUE to continue.
.Debug> :CONTINUE
!T
(symbol-package *foo-symbol*) !#<PACKAGE "FOO">
(symbol-package *bar-symbol*) is unspecified
(prin1-to-string *foo-symbol*) !"FOO:FOO"
(prin1-to-string *bar-symbol*) is unspecified
(find-symbol "FOO" *bar-package*) is unspecified
(find-symbol "FOO" *baz-package*) !NIL, NIL
(find-symbol "BAR" *baz-package*) !NIL, NIL
(packagep *foo-package*) !T
(packagep *bar-package*) !T
(packagep *baz-package*) !T
(package-name *foo-package*) !"FOO"
(package-name *bar-package*) !NIL
(package-name *baz-package*) !"BAZ"
(package-use-list *foo-package*) !()
(package-use-list *bar-package*) is unspecified
(package-use-list *baz-package*) !()
(package-used-by-list *foo-package*) !()
(package-used-by-list *bar-package*) is unspecified
(package-used-by-list *baz-package*) !()
Exceptional Situations:
If the package designator is aname that does not currently name a package , acorrectable error of
typepackage-error is signaled. If correction is attempted, no deletion action is attempted; instead,
delete-package immediately returns nil.
Ifpackage is used by other packages , acorrectable error of typepackage-error is signaled.
Packages 11–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If correction is attempted, unuse-package is eectively called to remove any dependencies,
causing package 'sexternal symbols to cease being accessible to those packages that use package .
delete-package then deletes package just as it would have had there been no packages that used it.
See Also:
unuse-package
make-package Function
Syntax:
make-package package-name &key nicknames use!package
Arguments and Values:
package-name |astring designator .
nicknames |alistofstring designators . The default is the empty list .
use|alistofpackage designators . The default is implementation-dened .
package |apackage .
Description:
Creates a new package with the name package-name .
Nicknames are additional names which may be used to refer to the new package .
usespecies zero or more packages theexternal symbols of which are to be inherited by the new
package . See the functionuse-package .
Examples:
(make-package ’temporary :nicknames ’("TEMP" "temp")) !#<PACKAGE "TEMPORARY">
(make-package "OWNER" :use ’("temp")) !#<PACKAGE "OWNER">
(package-used-by-list ’temp) !(#<PACKAGE "OWNER">)
(package-use-list ’owner) !(#<PACKAGE "TEMPORARY">)
Aﬀected By:
The existence of other packages in the system.
Exceptional Situations:
The consequences are unspecied if packages denoted by usedo not exist.
Acorrectable error is signaled if the package-name or any of the nicknames is already the name or
nickname of an existing package .
11–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
defpackage ,use-package
Notes:
In situations where the packages to be used contain symbols which would conict, it is necessary
to rst create the package with :use ’() , then to use shadow orshadowing-import to address the
conicts, and then after that to use use-package once the conicts have been addressed.
When packages are being created as part of the static denition of a program rather than
dynamically by the program, it is generally considered more stylistically appropriate to use
defpackage rather than make-package .
with-package-iterator Macro
Syntax:
with-package-iterator (name package-list-form &rest symbol-types )fdeclarationg*fformg*
!f resultg*
Arguments and Values:
name |asymbol .
package-list-form |aform ; evaluated once to produce a package-list .
package-list |adesignator for a list of package designators .
symbol-type |one of the symbols :internal ,:external , or:inherited .
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values of the forms .
Description:
Within the lexical scope of the body forms , the name is dened via macrolet such that successive
invocations of (name)will return the symbols , one by one, from the packages inpackage-list .
It is unspecied whether symbols inherited from multiple packages are returned more than once.
The order of symbols returned does not necessarily reect the order of packages inpackage-list .
When package-list has more than one element, it is unspecied whether duplicate symbols are
returned once or more than once.
Symbol-types controls which symbols that are accessible in a package are returned as follows:
Packages 11–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-package-iterator
:internal
The symbols that are present in the package , but that are not exported .
:external
The symbols that are present in the package and are exported .
:inherited
The symbols that are exported by used packages and that are not shadowed .
When more than one argument is supplied for symbol-types , asymbol is returned if its accessibility
matches any one of the symbol-types supplied. Implementations may extend this syntax by
recognizing additional symbol accessibility types.
An invocation of (name)returns four values as follows:
1. A ag that indicates whether a symbol is returned (true means that a symbol is returned).
2. A symbol that is accessible in one the indicated packages .
3. The accessibility type for that symbol ;i.e., one of the symbols :internal ,:external , or
:inherited .
4. The package from which the symbol was obtained. The package is one of the packages
present or named in package-list .
After all symbols have been returned by successive invocations of (name), then only one value is
returned, namely nil.
The meaning of the second, third, and fourth values is that the returned symbol isaccessible in the
returned package in the way indicated by the second return value as follows:
:internal
Means present and not exported .
:external
Means present and exported .
:inherited
Means not present (thus not shadowed ) but inherited from some used package .
It is unspecied what happens if any of the implicit interior state of an iteration is returned outside
the dynamic extent of the with-package-iterator form such as by returning some closure over the
invocation form .
Any number of invocations of with-package-iterator can be nested, and the body of the innermost
one can invoke all of the locally established macros , provided all those macros have distinct names.
11–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-package-iterator
Examples:
The following function should return ton any package , and signal an error if the usage of
with-package-iterator does not agree with the corresponding usage of do-symbols .
(defun test-package-iterator (package)
(unless (packagep package)
(setq package (find-package package)))
(let ((all-entries ’())
(generated-entries ’()))
(do-symbols (x package)
(multiple-value-bind (symbol accessibility)
(find-symbol (symbol-name x) package)
(push (list symbol accessibility) all-entries)))
(with-package-iterator (generator-fn package
:internal :external :inherited)
(loop
(multiple-value-bind (more? symbol accessibility pkg)
(generator-fn)
(unless more? (return))
(let ((l (multiple-value-list (find-symbol (symbol-name symbol)
package))))
(unless (equal l (list symbol accessibility))
(error "Symbol ~S not found as ~S in package ~A [~S]"
symbol accessibility (package-name package) l))
(push l generated-entries)))))
(unless (and (subsetp all-entries generated-entries :test #’equal)
(subsetp generated-entries all-entries :test #’equal))
(error "Generated entries and Do-Symbols entries don’t correspond"))
t))
The following function prints out every present symbol (possibly more than once):
(defun print-all-symbols ()
(with-package-iterator (next-symbol (list-all-packages)
:internal :external)
(loop
(multiple-value-bind (more? symbol) (next-symbol)
(if more?
(print symbol)
(return))))))
Exceptional Situations:
with-package-iterator signals an error of typeprogram-error if no symbol-types are supplied or if
asymbol-type is not recognized by the implementation is supplied.
The consequences are undened if the local function named name established by
Packages 11–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-package-iterator is called after it has returned false as its primary value .
See Also:
Section 3.6 (Traversal Rules and Side Eects)
unexport Function
Syntax:
unexport symbols &optional package!t
Arguments and Values:
symbols |adesignator for a listofsymbols .
package |apackage designator . The default is the current package .
Description:
unexport reverts external symbols inpackage to internal status; it undoes the eect of export .
unexport works only on symbols present inpackage , switching them back to internal status. If
unexport is given a symbol that is already accessible as an internal symbol inpackage , it does
nothing.
Examples:
(in-package "COMMON-LISP-USER") !#<PACKAGE "COMMON-LISP-USER">
(export (intern "CONTRABAND" (make-package ’temp)) ’temp) !T
(find-symbol "CONTRABAND") !NIL, NIL
(use-package ’temp) !T
(find-symbol "CONTRABAND") !CONTRABAND, :INHERITED
(unexport ’contraband ’temp) !T
(find-symbol "CONTRABAND") !NIL, NIL
Side Eﬀects:
Package system is modied.
Aﬀected By:
Current state of the package system.
Exceptional Situations:
Ifunexport is given a symbol notaccessible inpackage at all, an error of typepackage-error is
signaled.
The consequences are undened if package is theKEYWORD package or theCOMMON-LISP package .
11–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
export , Section 11.1 (Package Concepts)
unintern Function
Syntax:
unintern symbol&optional package!generalized-boolean
Arguments and Values:
symbol |asymbol .
package |apackage designator . The default is the current package .
generalized-boolean |ageneralized boolean .
Description:
unintern removes symbol from package . Ifsymbol ispresent inpackage , it is removed from package
and also from package 'sshadowing symbols list if it is present there. If package is the home package
forsymbol ,symbol is made to have no home package .Symbol may continue to be accessible in
package by inheritance.
Use ofunintern can result in a symbol that has no recorded home package , but that in fact is
accessible in some package . Common Lisp does not check for this pathological case, and such
symbols are always printed preceded by #:.
unintern returns true if it removes symbol , andnilotherwise.
Examples:
(in-package "COMMON-LISP-USER") !#<PACKAGE "COMMON-LISP-USER">
(setq temps-unpack (intern "UNPACK" (make-package ’temp))) !TEMP::UNPACK
(unintern temps-unpack ’temp) !T
(find-symbol "UNPACK" ’temp) !NIL, NIL
temps-unpack!#:UNPACK
Side Eﬀects:
unintern changes the state of the package system in such a way that the consistency rules do not
hold across the change.
Aﬀected By:
Current state of the package system.
Packages 11–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Giving a shadowing symbol to unintern can uncover a name conict that had previously been
resolved by the shadowing. If package A uses packages B and C, A contains a shadowing symbol x,
and B and C each contain external symbols named x, then removing the shadowing symbol xfrom
A will reveal a name conict between b:xandc:xif those two symbols are distinct. In this case
unintern will signal an error.
See Also:
Section 11.1 (Package Concepts)
in-package Macro
Syntax:
in-package name!package
Arguments and Values:
name |astring designator ; not evaluated.
package |the package named by name .
Description:
Causes the the package named by name to become the current package |that is, the value of
*package* . If no such package already exists, an error of typepackage-error is signaled.
Everything in-package does is also performed at compile time if the call appears as a top level
form .
Side Eﬀects:
The variable*package* is assigned. If the in-package form is atop level form , this assignment
also occurs at compile time.
Exceptional Situations:
An error of typepackage-error is signaled if the specied package does not exist.
See Also:
*package*
11–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
unuse-package Function
Syntax:
unuse-package packages-to-unuse &optional package!t
Arguments and Values:
packages-to-unuse |adesignator for a listofpackage designators .
package |apackage designator . The default is the current package .
Description:
unuse-package causes package to cease inheriting all the external symbols ofpackages-to-unuse ;
unuse-package undoes the eects of use-package . The packages-to-unuse are removed from the
use list ofpackage .
Any symbols that have been imported into package continue to be present inpackage .
Examples:
(in-package "COMMON-LISP-USER") !#<PACKAGE "COMMON-LISP-USER">
(export (intern "SHOES" (make-package ’temp)) ’temp) !T
(find-symbol "SHOES") !NIL, NIL
(use-package ’temp) !T
(find-symbol "SHOES") !SHOES, :INHERITED
(find (find-package ’temp) (package-use-list ’common-lisp-user)) !#<PACKAGE "TEMP">
(unuse-package ’temp) !T
(find-symbol "SHOES") !NIL, NIL
Side Eﬀects:
The use list ofpackage is modied.
Aﬀected By:
Current state of the package system.
See Also:
use-package ,package-use-list
Packages 11–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
use-package Function
Syntax:
use-package packages-to-use &optional package!t
Arguments and Values:
packages-to-use |adesignator for a listofpackage designators . TheKEYWORD package may not be
supplied.
package |apackage designator . The default is the current package . The package cannot be the
KEYWORD package .
Description:
use-package causes package to inherit all the external symbols ofpackages-to-use . The inherited
symbols become accessible asinternal symbols ofpackage .
Packages-to-use are added to the use list ofpackage if they are not there already. All external
symbols inpackages-to-use become accessible inpackage asinternal symbols .use-package does not
cause any new symbols to be present inpackage but only makes them accessible by inheritance.
use-package checks for name conicts between the newly imported symbols and those already
accessible inpackage . A name conict in use-package between two external symbols inherited by
package from packages-to-use may be resolved in favor of either symbol byimporting one of them
into package and making it a shadowing symbol.
Examples:
(export (intern "LAND-FILL" (make-package ’trash)) ’trash) !T
(find-symbol "LAND-FILL" (make-package ’temp)) !NIL, NIL
(package-use-list ’temp) !(#<PACKAGE "TEMP">)
(use-package ’trash ’temp) !T
(package-use-list ’temp) !(#<PACKAGE "TEMP"> #<PACKAGE "TRASH">)
(find-symbol "LAND-FILL" ’temp) !TRASH:LAND-FILL, :INHERITED
Side Eﬀects:
The use list ofpackage may be modied.
See Also:
unuse-package ,package-use-list , Section 11.1 (Package Concepts)
Notes:
It is permissible for a packageP1touseapackageP2even ifP2already uses P1. The using of
packages is not transitive, so no problem results from the apparent circularity.
11–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defpackage
defpackage Macro
Syntax:
defpackage dened-package-name [ [#option ] ]!package
option:: =f(:nicknamesfnicknameg*)g*j
(:documentation string )j
f(:usefpackage-nameg*)g*j
f(:shadowf#symbol-nameg*)g*j
f(:shadowing-import-from package-namef#symbol-nameg*)g*j
f(:import-from package-namef#symbol-nameg*)g*j
f(:exportf#symbol-nameg*)g*j
f(:internf#symbol-nameg*)g*j
(:size integer )
Arguments and Values:
dened-package-name |astring designator .
package-name |apackage designator .
nickname |astring designator .
symbol-name |astring designator .
package |the package named package-name .
Description:
defpackage creates a package as specied and returns the package .
Ifdened-package-name already refers to an existing package , the name-to-package mapping for
that name is not changed. If the new denition is at variance with the current state of that
package , the consequences are undened; an implementation might choose to modify the existing
package to reect the new denition. If dened-package-name is asymbol , its name is used.
The standard options are described below.
:nicknames
The arguments to :nicknames set the package 's nicknames to the supplied names.
:documentation
The argument to :documentation species a documentation string ; it is attached as a
Packages 11–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defpackage
documentation string to the package . At most one :documentation option can appear in a
singledefpackage form .
:use
The arguments to :use set the packages that the package named by package-name will
inherit from. If :use is not supplied, it defaults to the same implementation-dependent
value as the :use argument tomake-package .
:shadow
The arguments to :shadow ,symbol-names , name symbols that are to be created in the
package being dened. These symbols are added to the list of shadowing symbols eectively
as if byshadow .
:shadowing-import-from
The symbols named by the argument symbol-names are found (involving a lookup as
if byﬁnd-symbol ) in the specied package-name . The resulting symbols areimported
into the package being dened, and placed on the shadowing symbols list as if by
shadowing-import . In no case are symbols created in any package other than the one
being dened.
:import-from
The symbols named by the argument symbol-names are found in the package named by
package-name and they are imported into the package being dened. In no case are symbols
created in any package other than the one being dened.
:export
The symbols named by the argument symbol-names are found or created in the package
being dened and exported . The:export option interacts with the :use option, since
inherited symbols can be used rather than new ones created. The :export option interacts
with the :import-from and:shadowing-import-from options, since imported symbols can be
used rather than new ones created. If an argument to the :export option is accessible as
an (inherited) internal symbol viause-package , that the symbol named by symbol-name is
rst imported into the package being dened, and is then exported from that package .
:intern
The symbols named by the argument symbol-names are found or created in the package
being dened. The :intern option interacts with the :use option, since inherited symbols
can be used rather than new ones created.
:size
The argument to the :size option declares the approximate number of symbols expected
in the package . This is an eciency hint only and might be ignored by an implementation.
11–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defpackage
The order in which the options appear in a defpackage form is irrelevant. The order in which they
are executed is as follows:
1.:shadow and:shadowing-import-from .
2.:use.
3.:import-from and:intern .
4.:export .
Shadows are established rst, since they might be necessary to block spurious name conicts when
the:use option is processed. The :use option is executed next so that :intern and:export options
can refer to normally inherited symbols . The:export option is executed last so that it can refer
tosymbols created by any of the other options; in particular, shadowing symbols and imported
symbols can be made external.
If a defpackage form appears as a top level form , all of the actions normally performed by this
macro at load time must also be performed at compile time.
Examples:
(defpackage "MY-PACKAGE"
(:nicknames "MYPKG" "MY-PKG")
(:use "COMMON-LISP")
(:shadow "CAR" "CDR")
(:shadowing-import-from "VENDOR-COMMON-LISP" "CONS")
(:import-from "VENDOR-COMMON-LISP" "GC")
(:export "EQ" "CONS" "FROBOLA")
)
(defpackage my-package
(:nicknames mypkg :MY-PKG) ; remember Common Lisp conventions for case
(:use common-lisp) ; conversion on symbols
(:shadow CAR :cdr #:cons)
(:export "CONS") ; this is the shadowed one.
)
Aﬀected By:
Existing packages .
Exceptional Situations:
If one of the supplied :nicknames already refers to an existing package , an error of type
package-error is signaled.
An error of typeprogram-error should be signaled if :size or:documentation appears more than
once.
Packages 11–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
defpackage
Since implementations might allow extended options an error of typeprogram-error should be
signaled if an option is present that is not actually supported in the host implementation .
The collection of symbol-name arguments given to the options :shadow ,:intern ,:import-from ,
and:shadowing-import-from must all be disjoint; additionally, the symbol-name arguments given
to:export and:intern must be disjoint. Disjoint in this context is dened as no two of the
symbol-names beingstring= with each other. If either condition is violated, an error of type
program-error should be signaled.
For the:shadowing-import-from and:import-from options, a correctable error oftypepackage-error
is signaled if no symbol isaccessible in the package named by package-name for one of the argument
symbol-names .
Name conict errors are handled by the underlying calls to make-package ,use-package ,import ,
andexport . See Section 11.1 (Package Concepts).
See Also:
documentation , Section 11.1 (Package Concepts), Section 3.2 (Compilation)
Notes:
The:intern option is useful if an :import-from or a:shadowing-import-from option in a subsequent
call todefpackage (for some other package ) expects to nd these symbols accessible but not
necessarily external.
It is recommended that the entire package denition is put in a single place, and that all the package
denitions of a program are in a single le. This le can be loaded before loading or compiling
anything else that depends on those packages . Such a le can be read in the COMMON-LISP-USER
package , avoiding any initial state issues.
defpackage cannot be used to create two \mutually recursive" packages, such as:
(defpackage my-package
(:use common-lisp your-package) ;requires your-package to exist first
(:export "MY-FUN"))
(defpackage your-package
(:use common-lisp)
(:import-from my-package "MY-FUN") ;requires my-package to exist first
(:export "MY-FUN"))
However, nothing prevents the user from using the package -aecting functions such as use-package ,
import , andexport to establish such links after a more standard use of defpackage .
The macroexpansion of defpackage could usefully canonicalize the names into strings , so that even
if a source le has random symbols in thedefpackage form, the compiled le would only contain
strings .
Frequently additional implementation-dependent options take the form of a keyword standing by
itself as an abbreviation for a list (keyword T) ; this syntax should be properly reported as an
11–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
unrecognized option in implementations that do not support it.
do-symbols,do-external-symbols,do-all-symbols
Macro
Syntax:
do-symbols (var[package [result-form ]])
fdeclarationg*ftagjstatementg*
!f resultg*
do-external-symbols (var[package [result-form ]])
fdeclarationg*ftagjstatementg*
!f resultg*
do-all-symbols (var[result-form ])
fdeclarationg*ftagjstatementg*
!f resultg*
Arguments and Values:
var|avariable name ; not evaluated.
package |apackage designator ; evaluated. The default in do-symbols anddo-external-symbols
is the current package .
result-form |aform ; evaluated as described below. The default is nil.
declaration |adeclare expression ; not evaluated.
tag|ago tag ; not evaluated.
statement |acompound form ; evaluated as described below.
results |the values returned by the result-form if anormal return occurs, or else, if an explicit
return occurs, the values that were transferred.
Description:
do-symbols ,do-external-symbols , anddo-all-symbols iterate over the symbols ofpackages . For
each symbol in the set of packages chosen, the varis bound to the symbol , and the statements in
the body are executed. When all the symbols have been processed, result-form is evaluated and
returned as the value of the macro.
Packages 11–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
do-symbols, do-external-symbols, do-all-symbols
do-symbols iterates over the symbols accessible inpackage .Statements may execute more than
once for symbols that are inherited from multiple packages .
do-all-symbols iterates on every registered package .do-all-symbols will not process every symbol
whatsoever, because a symbol notaccessible in any registered package will not be processed.
do-all-symbols may cause a symbol that is present in several packages to be processed more than
once.
do-external-symbols iterates on the external symbols of package .
When result-form is evaluated, varis bound and has the value nil.
Animplicit block namednilsurrounds the entire do-symbols ,do-external-symbols , or
do-all-symbols form .return orreturn-from may be used to terminate the iteration prematurely.
If execution of the body aects which symbols are contained in the set of packages over which
iteration is occurring, other than to remove the symbol currently the value of varby usingunintern ,
the consequences are undened.
For each of these macros, the scope of the name binding does not include any initial value form,
but the optional result forms are included.
Any tagin the body is treated as with tagbody .
Examples:
(make-package ’temp :use nil) !#<PACKAGE "TEMP">
(intern "SHY" ’temp) !TEMP::SHY, NIL ;SHY will be an internal symbol
;in the package TEMP
(export (intern "BOLD" ’temp) ’temp) !T ;BOLD will be external
(let ((lst ()))
(do-symbols (s (find-package ’temp)) (push s lst))
lst)
!(TEMP::SHY TEMP:BOLD)or!(TEMP:BOLD TEMP::SHY)
(let ((lst ()))
(do-external-symbols (s (find-package ’temp) lst) (push s lst))
lst)
!(TEMP:BOLD)
(let ((lst ()))
(do-all-symbols (s lst)
(when (eq (find-package ’temp) (symbol-package s)) (push s lst)))
lst)
!(TEMP::SHY TEMP:BOLD)or!(TEMP:BOLD TEMP::SHY)
11–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
intern ,export , Section 3.6 (Traversal Rules and Side Eects)
intern Function
Syntax:
intern string&optional package!symbol, status
Arguments and Values:
string |astring .
package |apackage designator . The default is the current package .
symbol |asymbol .
status |one of :inherited ,:external ,:internal , ornil.
Description:
intern enters a symbol named string into package . If a symbol whose name is the same as string
is already accessible inpackage , it is returned. If no such symbol isaccessible inpackage , a new
symbol with the given name is created and entered into package as an internal symbol , or as an
external symbol if the package is theKEYWORD package ;package becomes the home package of the
created symbol .
The rst value returned by intern ,symbol , is the symbol that was found or created. The meaning
of the secondary value ,status , is as follows:
:internal
The symbol was found and is present inpackage as an internal symbol .
:external
The symbol was found and is present as an external symbol .
:inherited
The symbol was found and is inherited via use-package (which implies that the symbol is
internal).
nil
No pre-existing symbol was found, so one was created.
Packages 11–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
It is implementation-dependent whether the string that becomes the new symbol 'sname
is the given string or a copy of it. Once a string has been given as the string argument to
intern in this situation where a new symbol is created, the consequences are undened if a
subsequent attempt is made to alter that string .
Examples:
(in-package "COMMON-LISP-USER") !#<PACKAGE "COMMON-LISP-USER">
(intern "Never-Before") !|Never-Before|, NIL
(intern "Never-Before") !|Never-Before|, :INTERNAL
(intern "NEVER-BEFORE" "KEYWORD") !:NEVER-BEFORE, NIL
(intern "NEVER-BEFORE" "KEYWORD") !:NEVER-BEFORE, :EXTERNAL
See Also:
ﬁnd-symbol ,read,symbol ,unintern , Section 2.3.4 (Symbols as Tokens)
Notes:
intern does not need to do any name conict checking because it never creates a new symbol if
there is already an accessible symbol with the name given.
package-name Function
Syntax:
package-name package!name
Arguments and Values:
package |apackage designator .
name |astring ornil.
Description:
package-name returns the string that names package , ornilif the package designator is apackage
object that has no name (see the functiondelete-package ).
Examples:
(in-package "COMMON-LISP-USER") !#<PACKAGE "COMMON-LISP-USER">
(package-name *package*) !"COMMON-LISP-USER"
(package-name (symbol-package :test)) !"KEYWORD"
(package-name (find-package ’common-lisp)) !"COMMON-LISP"
(defvar *foo-package* (make-package "FOO"))
11–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(rename-package "FOO" "FOO0")
(package-name *foo-package*) !"FOO0"
Exceptional Situations:
Should signal an error of typetype-error ifpackage is not a package designator .
package-nicknames Function
Syntax:
package-nicknames package!nicknames
Arguments and Values:
package |apackage designator .
nicknames |alistofstrings .
Description:
Returns the listof nickname strings forpackage , not including the name of package .
Examples:
(package-nicknames (make-package ’temporary
:nicknames ’("TEMP" "temp")))
!("temp" "TEMP")
Exceptional Situations:
Should signal an error of typetype-error ifpackage is not a package designator .
Packages 11–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
package-shadowing-symbols Function
Syntax:
package-shadowing-symbols package!symbols
Arguments and Values:
package |apackage designator .
symbols |alistofsymbols .
Description:
Returns a listofsymbols that have been declared as shadowing symbols inpackage byshadow or
shadowing-import (or the equivalent defpackage options). All symbols on this listarepresent in
package .
Examples:
(package-shadowing-symbols (make-package ’temp)) !()
(shadow ’cdr ’temp) !T
(package-shadowing-symbols ’temp) !(TEMP::CDR)
(intern "PILL" ’temp) !TEMP::PILL, NIL
(shadowing-import ’pill ’temp) !T
(package-shadowing-symbols ’temp) !(PILL TEMP::CDR)
Exceptional Situations:
Should signal an error of typetype-error ifpackage is not a package designator .
See Also:
shadow ,shadowing-import
Notes:
Whether the list of symbols isfresh isimplementation-dependent .
package-use-list Function
Syntax:
package-use-list package!use-list
Arguments and Values:
package |apackage designator .
use-list |alistofpackage objects .
11–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returns a listof other packages used by package .
Examples:
(package-use-list (make-package ’temp)) !(#<PACKAGE "COMMON-LISP">)
(use-package ’common-lisp-user ’temp) !T
(package-use-list ’temp) !(#<PACKAGE "COMMON-LISP"> #<PACKAGE "COMMON-LISP-USER">)
Exceptional Situations:
Should signal an error of typetype-error ifpackage is not a package designator .
See Also:
use-package ,unuse-package
package-used-by-list Function
Syntax:
package-used-by-list package!used-by-list
Arguments and Values:
package |apackage designator .
used-by-list |alistofpackage objects .
Description:
package-used-by-list returns a listof other packages that use package .
Examples:
(package-used-by-list (make-package ’temp)) !()
(make-package ’trash :use ’(temp)) !#<PACKAGE "TRASH">
(package-used-by-list ’temp) !(#<PACKAGE "TRASH">)
Exceptional Situations:
Should signal an error of typetype-error ifpackage is not a package .
See Also:
use-package ,unuse-package
Packages 11–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
packagep Function
Syntax:
packagep object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typepackage ; otherwise, returns false.
Examples:
(packagep *package*) !true
(packagep ’common-lisp) !false
(packagep (find-package ’common-lisp)) !true
Notes:
(packagep object)(typep object’package)
package Variable
Value Type:
apackage object .
Initial Value:
theCOMMON-LISP-USER package .
Description:
Whatever package object is currently the value of*package* is referred to as the current package .
Examples:
(in-package "COMMON-LISP-USER") !#<PACKAGE "COMMON-LISP-USER">
*package*!#<PACKAGE "COMMON-LISP-USER">
(make-package "SAMPLE-PACKAGE" :use ’("COMMON-LISP"))
!#<PACKAGE "SAMPLE-PACKAGE">
(list
11–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(symbol-package
(let ((*package* (find-package ’sample-package)))
(setq *some-symbol* (read-from-string "just-testing"))))
*package*)
!(#<PACKAGE "SAMPLE-PACKAGE"> #<PACKAGE "COMMON-LISP-USER">)
(list (symbol-package (read-from-string "just-testing"))
*package*)
!(#<PACKAGE "COMMON-LISP-USER"> #<PACKAGE "COMMON-LISP-USER">)
(eq ’foo (intern "FOO")) !true
(eq ’foo (let ((*package* (find-package ’sample-package)))
(intern "FOO")))
!false
Aﬀected By:
load,compile-ﬁle ,in-package
See Also:
compile-ﬁle ,in-package ,load,package
package-error Condition Type
Class Precedence List:
package-error ,error ,serious-condition ,condition ,t
Description:
The typepackage-error consists of error conditions related to operations on packages . The
oending package (orpackage name ) is initialized by the :package initialization argument to
make-condition , and is accessed by the functionpackage-error-package .
See Also:
package-error-package , Chapter 9 (Conditions)
Packages 11–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
package-error-package
package-error-package Function
Syntax:
package-error-package condition!package
Arguments and Values:
condition |acondition oftypepackage-error .
package |apackage designator .
Description:
Returns a designator for the oending package in the situation represented by the condition .
Examples:
(package-error-package
(make-condition ’package-error
:package (find-package "COMMON-LISP")))
!#<Package "COMMON-LISP">
See Also:
package-error
11–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
12. Numbers
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Numbers iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
12.1 Number Concepts
12.1.1 Numeric Operations
Common Lisp provides a large variety of operations related to numbers . This section provides
an overview of those operations by grouping them into categories that emphasize some of the
relationships among them.
Figure 12{1 shows operators relating to arithmetic operations.
* 1+ gcd
+ 1- incf
- conjugate lcm
/ decf
Figure 12–1. Operators relating to Arithmetic.
Figure 12{2 shows dened names relating to exponential, logarithmic, and trigonometric operations.
abs cos signum
acos cosh sin
acosh exp sinh
asin expt sqrt
asinh isqrt tan
atan log tanh
atanh phase
cis pi
Figure 12–2. Deﬁned names relating to Exponentials, Logarithms, and Trigonometry.
Figure 12{3 shows operators relating to numeric comparison and predication.
/= >= oddp
< evenp plusp
<= max zerop
= min
> minusp
Figure 12–3. Operators for numeric comparison and predication.
Numbers 12–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Figure 12{4 shows dened names relating to numeric type manipulation and coercion.
ceiling ﬂoat-radix rational
complex ﬂoat-sign rationalize
decode-ﬂoat ﬂoor realpart
denominator fround rem
fceiling ftruncate round
ﬄoor imagpart scale-ﬂoat
ﬂoat integer-decode-ﬂoat truncate
ﬂoat-digits mod
ﬂoat-precision numerator
Figure 12–4. Deﬁned names relating to numeric type manipulation and coercion.
12.1.1.1 Associativity and Commutativity in Numeric Operations
For functions that are mathematically associative (and possibly commutative), a conforming
implementation may process the arguments in any manner consistent with associative (and
possibly commutative) rearrangement. This does not aect the order in which the argument
forms areevaluated ; for a discussion of evaluation order, see Section 3.1.2.1.2.3 (Function Forms).
What is unspecied is only the order in which the parameter values are processed. This implies
that implementations may dier in which automatic coercions are applied; see Section 12.1.1.2
(Contagion in Numeric Operations).
Aconforming program can control the order of processing explicitly by separating the operations
into separate (possibly nested) function forms , or by writing explicit calls to functions that perform
coercions.
12.1.1.1.1 Examples of Associativity and Commutativity in Numeric Operations
Consider the following expression, in which we assume that 1.0and1.0e-15 both denote single
oats :
(+ 1/3 2/3 1.0d0 1.0 1.0e-15)
One conforming implementation might process the arguments from left to right, rst adding
1/3and2/3to get1, then converting that to a double oat for combination with 1.0d0 , then
successively converting and adding 1.0and1.0e-15 .
Another conforming implementation might process the arguments from right to left, rst performing
asingle oat addition of 1.0and1.0e-15 (perhaps losing accuracy in the process), then converting
the sum to a double oat and adding 1.0d0 , then converting 2/3to a double oat and adding it,
and then converting 1/3and adding that.
A third conforming implementation might rst scan all the arguments , process all the rationals
rst to keep that part of the computation exact, then nd an argument of the largest oating-point
12–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
format among all the arguments and add that, and then add in all other arguments , converting
each in turn (all in a perhaps misguided attempt to make the computation as accurate as possible).
In any case, all three strategies are legitimate.
Aconforming program could control the order by writing, for example,
(+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0)
12.1.1.2 Contagion in Numeric Operations
For information about the contagion rules for implicit coercions of arguments in numeric operations,
see Section 12.1.4.4 (Rule of Float Precision Contagion), Section 12.1.4.1 (Rule of Float and
Rational Contagion), and Section 12.1.5.2 (Rule of Complex Contagion).
12.1.1.3 Viewing Integers as Bits and Bytes
12.1.1.3.1 Logical Operations on Integers
Logical operations require integers as arguments; an error of typetype-error should be signaled if
an argument is supplied that is not an integer .Integer arguments to logical operations are treated
as if they were represented in two's-complement notation.
Figure 12{5 shows dened names relating to logical operations on numbers.
ash boole-ior logbitp
boole boole-nand logcount
boole-1 boole-nor logeqv
boole-2 boole-orc1 logior
boole-and boole-orc2 lognand
boole-andc1 boole-set lognor
boole-andc2 boole-xor lognot
boole-c1 integer-length logorc1
boole-c2 logand logorc2
boole-clr logandc1 logtest
boole-eqv logandc2 logxor
Figure 12–5. Deﬁned names relating to logical operations on numbers.
Numbers 12–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
12.1.1.3.2 Byte Operations on Integers
The byte-manipulation functions useobjects called byte speciers to designate the size and position
of a specic byte within an integer . The representation of a byte specier isimplementation-
dependent ; it might or might not be a number . The function byte will construct a byte specier ,
which various other byte-manipulation functions will accept.
Figure 12{6 shows dened names relating to manipulating bytes ofnumbers .
byte deposit-ﬁeld ldb-test
byte-position dpb mask-ﬁeld
byte-size ldb
Figure 12–6. Deﬁned names relating to byte manipulation.
12.1.2 Implementation-Dependent Numeric Constants
Figure 12{7 shows dened names relating to implementation-dependent details about numbers .
double-ﬂoat-epsilon most-negative-ﬁxnum
double-ﬂoat-negative-epsilon most-negative-long-ﬂoat
least-negative-double-ﬂoat most-negative-short-ﬂoat
least-negative-long-ﬂoat most-negative-single-ﬂoat
least-negative-short-ﬂoat most-positive-double-ﬂoat
least-negative-single-ﬂoat most-positive-ﬁxnum
least-positive-double-ﬂoat most-positive-long-ﬂoat
least-positive-long-ﬂoat most-positive-short-ﬂoat
least-positive-short-ﬂoat most-positive-single-ﬂoat
least-positive-single-ﬂoat short-ﬂoat-epsilon
long-ﬂoat-epsilon short-ﬂoat-negative-epsilon
long-ﬂoat-negative-epsilon single-ﬂoat-epsilon
most-negative-double-ﬂoat single-ﬂoat-negative-epsilon
Figure 12–7. Deﬁned names relating to implementation-dependent details about numbers.
12.1.3 Rational Computations
The rules in this section apply to rational computations.
12–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
12.1.3.1 Rule of Unbounded Rational Precision
Rational computations cannot overow in the usual sense (though there may not be enough storage
to represent a result), since integers and ratios may in principle be of any magnitude.
12.1.3.2 Rule of Canonical Representation for Rationals
If any computation produces a result that is a mathematical ratio of two integers such that the
denominator evenly divides the numerator, then the result is converted to the equivalent integer .
If the denominator does not evenly divide the numerator, the canonical representation of a rational
number is as the ratio that numerator and that denominator, where the greatest common divisor
of the numerator and denominator is one, and where the denominator is positive and greater than
one.
When used as input (in the default syntax), the notation -0always denotes the integer0. A
conforming implementation must not have a representation of \minus zero" for integers that is
distinct from its representation of zero for integers . However, such a distinction is possible for
oats ; see the typeﬂoat.
12.1.3.3 Rule of Float Substitutability
When the arguments to an irrational mathematical function are all rational and the true mathe-
matical result is also (mathematically) rational, then unless otherwise noted an implementation is
free to return either an accurate rational result or a single oat approximation. If the arguments
are all rational but the result cannot be expressed as a rational number, then a single oat
approximation is always returned.
If the arguments to an irrational mathematical function are all of type
(or rational (complex rational)) and the true mathematical result is (mathematically) a
complex number with rational real and imaginary parts, then unless otherwise noted an imple-
mentation is free to return either an accurate result of type (or rational (complex rational)) or
asingle oat (permissible only if the imaginary part of the true mathematical result is zero) or
(complex single-float) . If the arguments are all of type (or rational (complex rational)) but
the result cannot be expressed as a rational orcomplex rational , then the returned value will be of
typesingle-ﬂoat (permissible only if the imaginary part of the true mathematical result is zero) or
(complex single-float) .
Float substitutability applies neither to the rational functions +,-,*, and/nor to the related
operators 1+,1-,incf,decf, andconjugate . For rational functions , if all arguments are rational ,
then the result is rational ; if all arguments are of type (or rational (complex rational)) , then the
result is of type (or rational (complex rational)) .
Numbers 12–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Function Sample Results
abs (abs #c(3 4))!5or5.0
acos (acos 1)!0or0.0
acosh (acosh 1)!0or0.0
asin (asin 0)!0or0.0
asinh (asinh 0)!0or0.0
atan (atan 0)!0or0.0
atanh (atanh 0)!0or0.0
cis (cis 0)!1or#c(1.0 0.0)
cos (cos 0)!1or1.0
cosh (cosh 0)!1or1.0
exp (exp 0)!1or1.0
expt (expt 8 1/3)!2or2.0
log (log 1)!0or0.0
(log 8 2)!3or3.0
phase (phase 7)!0or0.0
signum (signum #c(3 4)) !#c(3/5 4/5) or#c(0.6 0.8)
sin (sin 0)!0or0.0
sinh (sinh 0)!0or0.0
sqrt (sqrt 4)!2or2.0
(sqrt 9/16)!3/4or0.75
tan (tan 0)!0or0.0
tanh (tanh 0)!0or0.0
Figure 12–8. Functions Aﬀected by Rule of Float Substitutability
12.1.4 Floating-point Computations
The following rules apply to oating point computations.
12.1.4.1 Rule of Float and Rational Contagion
When rationals and oats are combined by a numerical function, the rational is rst converted
to a oat of the same format. For functions such as+that take more than two arguments, it is
permitted that part of the operation be carried out exactly using rationals and the rest be done
using oating-point arithmetic.
When rationals andoats are compared by a numerical function, the functionrational is eectively
called to convert the oat to a rational and then an exact comparison is performed. In the case of
complex numbers, the real and imaginary parts are eectively handled individually.
12–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
12.1.4.1.1 Examples of Rule of Float and Rational Contagion
;;;; Combining rationals with floats.
;;; This example assumes an implementation in which
;;; (float-radix 0.5) is 2 (as in IEEE) or 16 (as in IBM/360),
;;; or else some other implementation in which 1/2 has an exact
;;; representation in floating point.
(+ 1/2 0.5)!1.0
(- 1/2 0.5d0)!0.0d0
(+ 0.5 -0.5 1/2) !0.5
;;;; Comparing rationals with floats.
;;; This example assumes an implementation in which the default float
;;; format is IEEE single-float, IEEE double-float, or some other format
;;; in which 5/7 is rounded upwards by FLOAT.
(< 5/7 (float 5/7)) !true
(< 5/7 (rational (float 5/7))) !true
(< (float 5/7) (float 5/7)) !false
12.1.4.2 Rule of Float Approximation
Computations with oats are only approximate, although they are described as if the results
were mathematically accurate. Two mathematically identical expressions may be computationally
dierent because of errors inherent in the oating-point approximation process. The precision
of a oat is not necessarily correlated with the accuracy of that number. For instance,
3.142857142857142857 is a more precise approximation to than 3.14159, but the latter is more
accurate. The precision refers to the number of bits retained in the representation. When an
operation combines a short oat with a long oat , the result will be a long oat . Common Lisp
functions assume that the accuracy of arguments to them does not exceed their precision. Therefore
when two small oats are combined, the result is a small oat . Common Lisp functions never
convert automatically from a larger size to a smaller one.
12.1.4.3 Rule of Float Underﬂow and Overﬂow
An error of typeﬂoating-point-overﬂow orﬂoating-point-underﬂow should be signaled if a
oating-point computation causes exponent overow or underow, respectively.
12.1.4.4 Rule of Float Precision Contagion
The result of a numerical function is a oat of the largest format among all the oating-point
arguments to the function .
Numbers 12–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
12.1.5 Complex Computations
The following rules apply to complex computations:
12.1.5.1 Rule of Complex Substitutability
Except during the execution of irrational and transcendental functions , no numerical function ever
yields acomplex unless one or more of its arguments is acomplex .
12.1.5.2 Rule of Complex Contagion
When a realand a complex are both part of a computation, the realis rst converted to a complex
by providing an imaginary part of 0.
12.1.5.3 Rule of Canonical Representation for Complex Rationals
If the result of any computation would be a complex number whose real part is of typerational
and whose imaginary part is zero, the result is converted to the rational which is the real part.
This rule does not apply to complex numbers whose parts are oats . For example, #C(5 0) and5
are not dierent objects in Common Lisp(they are always the same undereql);#C(5.0 0.0) and
5.0are always dierent objects in Common Lisp (they are never the same undereql, although
they are the same underequalp and=).
12.1.5.3.1 Examples of Rule of Canonical Representation for Complex Rationals
#c(1.0 1.0)!#C(1.0 1.0)
#c(0.0 0.0)!#C(0.0 0.0)
#c(1.0 1)!#C(1.0 1.0)
#c(0.0 0)!#C(0.0 0.0)
#c(1 1)!#C(1 1)
#c(0 0)!0
(typep #c(1 1) ’(complex (eql 1))) !true
(typep #c(0 0) ’(complex (eql 0))) !false
12–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
12.1.5.4 Principal Values and Branch Cuts
Many of the irrational and transcendental functions are multiply dened in the complex domain;
for example, there are in general an innite number of complex values for the logarithm function.
In each such case, a principal value must be chosen for the function to return. In general, such
values cannot be chosen so as to make the range continuous; lines in the domain called branch
cuts must be dened, which in turn dene the discontinuities in the range. Common Lisp denes
the branch cuts, principal values , and boundary conditions for the complex functions following
\Principal Values and Branch Cuts in Complex APL." The branch cut rules that apply to each
function are located with the description of that function.
Figure 12{9 lists the identities that are obeyed throughout the applicable portion of the complex
domain, even on the branch cuts:
sin i z = i sinh z sinh i z = i sin z arctan i z = i arctanh z
cos i z = cosh z cosh i z = cos z arcsinh i z = i arcsin z
tan i z = i tanh z arcsin i z = i arcsinh z arctanh i z = i arctan z
Figure 12–9. Trigonometric Identities for Complex Domain
The quadrant numbers referred to in the discussions of branch cuts are as illustrated in Figure
12{10.
Positive
Imaginary Axis
...
II...I
Negative Real Axis  Positive Real Axis
III...IV
...
Negative
Imaginary Axis
Figure 12–10. Quadrant Numbering for Branch Cuts
12.1.6 Interval Designators
The compound type specier form of the numeric type speciers permit the user to specify an
interval on the real number line which describe a subtype of the type which would be described by
Numbers 12–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
the corresponding atomic type specier . A subtype of some type Tis specied using an ordered
pair of objects called interval designators fortype T.
The rst of the two interval designators fortype Tcan be any of the following:
a number Noftype T
This denotes a lower inclusive bound of N. That is, elements of the subtype ofTwill be
greater than or equal to N.
asingleton list whose element is a number Moftype T
This denotes a lower exclusive bound of M. That is, elements of the subtype ofTwill be
greater than M.
the symbol *
This denotes the absence of a lower bound on the interval.
The second of the two interval designators fortype Tcan be any of the following:
a number Noftype T
This denotes an upper inclusive bound of N. That is, elements of the subtype ofTwill be
less than or equal to N.
asingleton list whose element is a number Moftype T
This denotes an upper exclusive bound of M. That is, elements of the subtype ofTwill be
less than M.
the symbol *
This denotes the absence of an upper bound on the interval.
12.1.7 Random-State Operations
Figure 12{11 lists some dened names that are applicable to random states .
*random-state* random
make-random-state random-state-p
Figure 12–11. Random-state deﬁned names
12–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
number System Class
Class Precedence List:
number ,t
Description:
The typenumber contains objects which represent mathematical numbers. The typesreal and
complex aredisjoint subtypes ofnumber .
The function =tests for numerical equality. The function eql, when its arguments are both
numbers , tests that they have both the same type and numerical value. Two numbers that are the
same undereqlor=are not necessarily the same undereq.
Notes:
Common Lisp diers from mathematics on some naming issues. In mathematics, the set of
real numbers is traditionally described as a subset of the complex numbers, but in Common
Lisp, the typereal and the typecomplex are disjoint. The Common Lisp type which includes
all mathematical complex numbers is called number . The reasons for these dierences include
historical precedent, compatibility with most other popular computer languages, and various issues
of time and space eciency.
complex System Class
Class Precedence List:
complex ,number ,t
Description:
The typecomplex includes all mathematical complex numbers other than those included in the
typerational .Complexes are expressed in Cartesian form with a real part and an imaginary part,
each of which is a real. The real part and imaginary part are either both rational or both of the
same oat type . The imaginary part can be a oat zero, but can never be a rational zero, for such
a number is always represented by Common Lisp as a rational rather than a complex .
Compound Type Speciﬁer Kind:
Specializing.
Compound Type Speciﬁer Syntax:
(complex [ typespecj*])
Numbers 12–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compound Type Speciﬁer Arguments:
typespec |atype specier that denotes a subtype oftypereal.
Compound Type Speciﬁer Description:
Every element of this type is a complex whose real part and imaginary part are each of type
(upgraded-complex-part-type typespec ). This type encompasses those complexes that can result
by giving numbers of type typespec tocomplex .
(complex type-specier )refers to all complexes that can result from giving numbers oftype type-
specier to the functioncomplex , plus all other complexes of the same specialized representation.
See Also:
Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals), Section 2.3.2
(Constructing Numbers from Tokens), Section 22.1.3.1.4 (Printing Complexes)
Notes:
The input syntax for a complex with real part rand imaginary part iis#C(r i). For further
details, see Section 2.4 (Standard Macro Characters).
For every oat,n, there is a complex which represents the same mathematical number and which
can be obtained by (COERCEn’COMPLEX) .
real System Class
Class Precedence List:
real,number ,t
Description:
The typereal includes all numbers that represent mathematical real numbers, though there are
mathematical real numbers ( e.g., irrational numbers) that do not have an exact representation in
Common Lisp. Only reals can be ordered using the <,>,<=, and >=functions.
The typesrational andﬂoat aredisjoint subtypes oftypereal.
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(real [ lower-limit [upper-limit ]])
12–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compound Type Speciﬁer Arguments:
lower-limit ,upper-limit |interval designators fortypereal. The defaults for each of lower-limit and
upper-limit is the symbol*.
Compound Type Speciﬁer Description:
This denotes the reals on the interval described by lower-limit and upper-limit .
ﬂoat System Class
Class Precedence List:
ﬂoat,real,number ,t
Description:
Aoat is a mathematical rational (but nota Common Lisp rational ) of the form sfbe p, where
sis+1or 1, the sign;bis an integer greater than 1, the base orradix of the representation; pis
a positive integer , the precision (in base-bdigits) of the oat;fis a positive integer betweenbp 1
andbp 1(inclusive), the signicand; and eis an integer , the exponent. The value of pand the
range ofedepends on the implementation and on the type of oat within that implementation.
In addition, there is a oating-point zero; depending on the implementation, there can also be
a \minus zero". If there is no minus zero, then 0:0and 0:0are both interpreted as simply a
oating-point zero. (= 0.0 -0.0) is always true. If there is a minus zero, (eql -0.0 0.0) isfalse,
otherwise it is true.
The typesshort-ﬂoat ,single-ﬂoat ,double-ﬂoat , andlong-ﬂoat aresubtypes oftypeﬂoat. Any
two of them must be either disjoint types or the same type ; if the same type , then any other
types between them in the above ordering must also be the same type . For example, if the type
single-ﬂoat and the typelong-ﬂoat are the same type , then the typedouble-ﬂoat must be the
same type also.
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(float [ lower-limit [upper-limit ]])
Compound Type Speciﬁer Arguments:
lower-limit ,upper-limit |interval designators fortypeﬂoat. The defaults for each of lower-limit and
upper-limit is the symbol*.
Compound Type Speciﬁer Description:
This denotes the oats on the interval described by lower-limit and upper-limit .
Numbers 12–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
Figure 2{9, Section 2.3.2 (Constructing Numbers from Tokens), Section 22.1.3.1.3 (Printing Floats)
Notes:
Note that all mathematical integers are representable not only as Common Lisp reals, but also as
complex oats . For example, possible representations of the mathematical number 1include the
integer1, the oat1.0, or the complex #C(1.0 0.0) .
short-ﬂoat,single-ﬂoat,double-ﬂoat,long-ﬂoat Type
Supertypes:
short-ﬂoat :short-ﬂoat ,ﬂoat,real,number ,t
single-ﬂoat :single-ﬂoat ,ﬂoat,real,number ,t
double-ﬂoat :double-ﬂoat ,ﬂoat,real,number ,t
long-ﬂoat :long-ﬂoat ,ﬂoat,real,number ,t
Description:
For the four dened subtypes oftypeﬂoat, it is true that intermediate between the typeshort-ﬂoat
and the typelong-ﬂoat are the typesingle-ﬂoat and the typedouble-ﬂoat . The precise denition
of these categories is implementation-dened . The precision (measured in \bits", computed as
plog2b) and the exponent size (also measured in \bits," computed as log2(n+ 1), wherenis the
maximum exponent value) is recommended to be at least as great as the values in Figure 12{12.
Each of the dened subtypes oftypeﬂoat might or might not have a minus zero.
Format Minimum Precision Minimum Exponent Size
Short 13 bits 5 bits
Single 24 bits 8 bits
Double 50 bits 8 bits
Long 50 bits 8 bits
Figure 12–12. Recommended Minimum Floating-Point Precision and Exponent Size
There can be fewer than four internal representations for oats . If there are fewer distinct
representations, the following rules apply:
{ If there is only one, it is the typesingle-ﬂoat . In this representation, an object is
simultaneously of typessingle-ﬂoat ,double-ﬂoat ,short-ﬂoat , andlong-ﬂoat .
{ Two internal representations can be arranged in either of the following ways:
12–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Two types are provided: single-ﬂoat andshort-ﬂoat . An object is simultaneously
oftypessingle-ﬂoat ,double-ﬂoat , andlong-ﬂoat .
Two types are provided: single-ﬂoat anddouble-ﬂoat . An object is simultaneously
oftypessingle-ﬂoat andshort-ﬂoat , ordouble-ﬂoat andlong-ﬂoat .
{ Three internal representations can be arranged in either of the following ways:
Three types are provided: short-ﬂoat ,single-ﬂoat , anddouble-ﬂoat . An object
can simultaneously be of typedouble-ﬂoat andlong-ﬂoat .
Three types are provided: single-ﬂoat ,double-ﬂoat , andlong-ﬂoat . An object
can simultaneously be of typessingle-ﬂoat andshort-ﬂoat .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(short-float [ short-lower-limit [short-upper-limit ]])
(single-float [ single-lower-limit [single-upper-limit ]])
(double-float [ double-lower-limit [double-upper-limit ]])
(long-float [ long-lower-limit [long-upper-limit ]])
Compound Type Speciﬁer Arguments:
short-lower-limit ,short-upper-limit |interval designators fortypeshort-ﬂoat . The defaults for each
oflower-limit and upper-limit is the symbol*.
single-lower-limit ,single-upper-limit |interval designators fortypesingle-ﬂoat . The defaults for
each of lower-limit and upper-limit is the symbol*.
double-lower-limit ,double-upper-limit |interval designators fortypedouble-ﬂoat . The defaults for
each of lower-limit and upper-limit is the symbol*.
long-lower-limit ,long-upper-limit |interval designators fortypelong-ﬂoat . The defaults for each of
lower-limit and upper-limit is the symbol*.
Compound Type Speciﬁer Description:
Each of these denotes the set of oats of the indicated type that are on the interval specied by the
interval designators .
Numbers 12–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
rational System Class
Class Precedence List:
rational ,real,number ,t
Description:
The canonical representation of a rational is as an integer if its value is integral, and otherwise as
aratio .
The typesinteger andratio aredisjoint subtypes oftyperational .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(rational [ lower-limit [upper-limit ]])
Compound Type Speciﬁer Arguments:
lower-limit ,upper-limit |interval designators fortyperational . The defaults for each of lower-limit
and upper-limit is the symbol*.
Compound Type Speciﬁer Description:
This denotes the rationals on the interval described by lower-limit and upper-limit .
ratio System Class
Class Precedence List:
ratio ,rational ,real,number ,t
Description:
Aratio is anumber representing the mathematical ratio of two non-zero integers, the numerator
and denominator, whose greatest common divisor is one, and of which the denominator is positive
and greater than one.
See Also:
Figure 2{9, Section 2.3.2 (Constructing Numbers from Tokens), Section 22.1.3.1.2 (Printing Ratios)
12–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
integer System Class
Class Precedence List:
integer ,rational ,real,number ,t
Description:
Aninteger is a mathematical integer. There is no limit on the magnitude of an integer .
The typesﬁxnum andbignum form an exhaustive partition oftypeinteger .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(integer [ lower-limit [upper-limit ]])
Compound Type Speciﬁer Arguments:
lower-limit ,upper-limit |interval designators fortypeinteger . The defaults for each of lower-limit
and upper-limit is the symbol*.
Compound Type Speciﬁer Description:
This denotes the integers on the interval described by lower-limit and upper-limit .
See Also:
Figure 2{9, Section 2.3.2 (Constructing Numbers from Tokens), Section 22.1.3.1.1 (Printing
Integers)
Notes:
The type(integer lower upper ), where lower and upper aremost-negative-ﬁxnum and
most-positive-ﬁxnum , respectively, is also called ﬁxnum .
The type(integer 0 1) is also called bit. The type(integer 0 *) is also called unsigned-byte .
signed-byte Type
Supertypes:
signed-byte ,integer ,rational ,real,number ,t
Description:
The atomic type specier signed-byte denotes the same type as is denoted by the type specier
integer ; however, the list forms of these two type speciers have dierent semantics.
Numbers 12–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(signed-byte [ sj*])
Compound Type Speciﬁer Arguments:
s|a positive integer .
Compound Type Speciﬁer Description:
This denotes the set of integers that can be represented in two's-complement form in a byte
ofsbits. This is equivalent to (integer 2s 12s 1 1). The type signed-byte or the type
(signed-byte *) is the same as the typeinteger .
unsigned-byte Type
Supertypes:
unsigned-byte ,signed-byte ,integer ,rational ,real,number ,t
Description:
The atomic type specier unsigned-byte denotes the same type as is denoted by the type specier
(integer 0 *) .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(unsigned-byte [ sj*])
Compound Type Speciﬁer Arguments:
s|a positive integer .
Compound Type Speciﬁer Description:
This denotes the set of non-negative integers that can be represented in a byte of size s(bits). This
is equivalent to (mod m)form= 2s, or to(integer 0 n)forn= 2s 1. The typeunsigned-byte or
the type (unsigned-byte *) is the same as the type (integer 0 *) , the set of non-negative integers .
Notes:
The type(unsigned-byte 1) is also called bit.
12–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
mod Type Specier
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(mod n)
Compound Type Speciﬁer Arguments:
n|a positive integer .
Compound Type Speciﬁer Description:
This denotes the set of non-negative integers less than n. This is equivalent to (integer 0 ( n))or
to(integer 0 m), where m=n 1.
The argument is required, and cannot be *.
The symbol mod is not valid as a type specier .
bit Type
Supertypes:
bit,unsigned-byte ,signed-byte ,integer ,rational ,real,number ,t
Description:
The typebitis equivalent to the type(integer 0 1) and(unsigned-byte 1) .
ﬁxnum Type
Supertypes:
ﬁxnum ,integer ,rational ,real,number ,t
Description:
Axnum is an integer whose value is between most-negative-ﬁxnum andmost-positive-ﬁxnum
inclusive. Exactly which integers arexnums isimplementation-dened . The typeﬁxnum is
required to be a supertype of (signed-byte 16) .
Numbers 12–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
bignum Type
Supertypes:
bignum ,integer ,rational ,real,number ,t
Description:
The typebignum is dened to be exactly (and integer (not fixnum)) .
=,/=,<,>,<=,>= Function
Syntax:
=&rest numbers+!generalized-boolean
/=&rest numbers+!generalized-boolean
<&rest numbers+!generalized-boolean
>&rest numbers+!generalized-boolean
<=&rest numbers+!generalized-boolean
>=&rest numbers+!generalized-boolean
Arguments and Values:
number |for <,>,<=,>=: areal; for=,/=: anumber .
generalized-boolean |ageneralized boolean .
Description:
=,/=,<,>,<=, and >=perform arithmetic comparisons on their arguments as follows:
=
The value of =istrue if all numbers are the same in value; otherwise it is false. Two
complexes are considered equal by =if their real and imaginary parts are equal according
to=.
/=
The value of /=istrue if no two numbers are the same in value; otherwise it is false.
12–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
=, /=,<,>,<=,>=
<
The value of <istrue if the numbers are in monotonically increasing order; otherwise it is
false.
>
The value of >istrue if the numbers are in monotonically decreasing order; otherwise it is
false.
<=
The value of <=istrue if the numbers are in monotonically nondecreasing order; otherwise
it is false.
>=
The value of >=istrue if the numbers are in monotonically nonincreasing order; otherwise
it is false.
=,/=,<,>,<=, and >=perform necessary type conversions.
Examples:
The uses of these functions are illustrated in Figure 12{13.
Numbers 12–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(= 3 3) istrue. (/= 3 3) isfalse.
(= 3 5) isfalse. (/= 3 5) istrue.
(= 3 3 3 3) istrue. (/= 3 3 3 3) isfalse.
(= 3 3 5 3) isfalse. (/= 3 3 5 3) isfalse.
(= 3 6 5 2) isfalse. (/= 3 6 5 2) istrue.
(= 3 2 3) isfalse. (/= 3 2 3) isfalse.
(< 3 5) istrue. (<= 3 5) istrue.
(< 3 -5) isfalse. (<= 3 -5) isfalse.
(< 3 3) isfalse. (<= 3 3) istrue.
(< 0 3 4 6 7) istrue. (<= 0 3 4 6 7) istrue.
(< 0 3 4 4 6) isfalse. (<= 0 3 4 4 6) istrue.
(> 4 3) istrue. (>= 4 3) istrue.
(> 4 3 2 1 0) istrue. (>= 4 3 2 1 0) istrue.
(> 4 3 3 2 0) isfalse. (>= 4 3 3 2 0) istrue.
(> 4 3 1 2 0) isfalse. (>= 4 3 1 2 0) isfalse.
(= 3) istrue. (/= 3) istrue.
(< 3) istrue. (<= 3) istrue.
(= 3.0 #c(3.0 0.0)) istrue. (/= 3.0 #c(3.0 1.0)) istrue.
(= 3 3.0) istrue. (= 3.0s0 3.0d0) istrue.
(= 0.0 -0.0) istrue. (= 5/2 2.5) istrue.
(> 0.0 -0.0) isfalse. (= 0 -0.0) istrue.
(<= 0 x 9) istrue ifxis between 0and9, inclusive
(< 0.0 x 1.0) istrue ifxis between 0.0and1.0, exclusive
(< -1 j (length v)) istrue ifjis avalid array index for a vectorv
Figure 12–13. Uses of /=, =, <,>,<=, and >=
Exceptional Situations:
Might signal type-error if some argument is not a real. Might signal arithmetic-error if otherwise
unable to fulll its contract.
Notes:
=diers from eqlin that(= 0.0 -0.0) is always true, because =compares the mathematical
values of its operands, whereas eqlcompares the representational values, so to speak.
max,min Function
Syntax:
max&rest reals+!max-real
12–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
max, min
min&rest reals+!min-real
Arguments and Values:
real|areal.
max-real ,min-real |areal.
Description:
max returns the realthat is greatest (closest to positive innity). min returns the realthat is least
(closest to negative innity).
Formax, the implementation has the choice of returning the largest argument as is or applying
the rules of oating-point contagion , taking all the arguments into consideration for contagion
purposes. Also, if one or more of the arguments are =, then any one of them may be chosen as
the value to return. For example, if the reals are a mixture of rationals and oats , and the largest
argument is a rational , then the implementation is free to produce either that rational or its oat
approximation; if the largest argument is a oat of a smaller format than the largest format of
anyoat argument, then the implementation is free to return the argument in its given format or
expanded to the larger format. Similar remarks apply to min (replacing \largest argument" by
\smallest argument").
Examples:
(max 3)!3
(min 3)!3
(max 6 12)!12
(min 6 12)!6
(max -6 -12)!-6
(min -6 -12)!-12
(max 1 3 2 -7)!3
(min 1 3 2 -7)!-7
(max -2 3 0 7)!7
(min -2 3 0 7)!-2
(max 5.0 2)!5.0
(min 5.0 2)
!2or!2.0
(max 3.0 7 1)
!7or!7.0
(min 3.0 7 1)
!1or!1.0
(max 1.0s0 7.0d0) !7.0d0
Numbers 12–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(min 1.0s0 7.0d0)
!1.0s0or!1.0d0
(max 3 1 1.0s0 1.0d0)
!3or!3.0d0
(min 3 1 1.0s0 1.0d0)
!1or!1.0s0or!1.0d0
Exceptional Situations:
Should signal an error of typetype-error if any number is not a real.
minusp,plusp Function
Syntax:
minusp real!generalized-boolean
plusp real!generalized-boolean
Arguments and Values:
real|areal.
generalized-boolean |ageneralized boolean .
Description:
minusp returns true ifrealis less than zero; otherwise, returns false.
plusp returns true ifrealis greater than zero; otherwise, returns false.
Regardless of whether an implementation provides distinct representations for positive and negative
oat zeros,(minusp -0.0) always returns false.
Examples:
(minusp -1)!true
(plusp 0)!false
(plusp least-positive-single-float) !true
Exceptional Situations:
Should signal an error of typetype-error ifrealis not a real.
12–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
zerop Function
Syntax:
zerop number!generalized-boolean
Pronunciation:
[z—e()r—o()p—e]
Arguments and Values:
number |anumber .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifnumber is zero ( integer ,oat, orcomplex ); otherwise, returns false.
Regardless of whether an implementation provides distinct representations for positive and negative
oating-point zeros, (zerop -0.0) always returns true.
Examples:
(zerop 0)!true
(zerop 1)!false
(zerop -0.0)!true
(zerop 0/100)!true
(zerop #c(0 0.0)) !true
Exceptional Situations:
Should signal an error of typetype-error ifnumber is not a number .
Notes:
(zerop number)(=number 0)
ﬂoor,ﬄoor,ceiling,fceiling,truncate,ftruncate,
round,fround Function
Syntax:
ﬂoor number&optional divisor!quotient, remainder
ﬄoor number&optional divisor!quotient, remainder
ceiling number&optional divisor!quotient, remainder
Numbers 12–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬂoor, ﬄoor, ceiling, fceiling, truncate, ftruncate, :::
fceiling number&optional divisor!quotient, remainder
truncate number&optional divisor!quotient, remainder
ftruncate number&optional divisor!quotient, remainder
round number&optional divisor!quotient, remainder
fround number&optional divisor!quotient, remainder
Arguments and Values:
number |areal.
divisor |a non-zero real. The default is the integer1.
quotient |forﬂoor ,ceiling ,truncate , andround : an integer ; forﬄoor ,fceiling ,ftruncate , and
fround : aoat.
remainder |areal.
Description:
These functions divide number bydivisor , returning a quotient and remainder , such that
quotientdivisor +remainder =number
The quotient always represents a mathematical integer. When more than one mathematical integer
might be possible ( i.e., when the remainder is not zero), the kind of rounding or truncation depends
on the operator :
ﬂoor ,ﬄoor
ﬂoor andﬄoor produce a quotient that has been truncated toward negative innity; that
is, the quotient represents the largest mathematical integer that is not larger than the
mathematical quotient.
ceiling ,fceiling
ceiling andfceiling produce a quotient that has been truncated toward positive innity;
that is, the quotient represents the smallest mathematical integer that is not smaller than
the mathematical result.
truncate ,ftruncate
truncate andftruncate produce a quotient that has been truncated towards zero; that
is, the quotient represents the mathematical integer of the same sign as the mathematical
quotient, and that has the greatest integral magnitude not greater than that of the
mathematical quotient.
round ,fround
round andfround produce a quotient that has been rounded to the nearest mathematical
integer; if the mathematical quotient is exactly halfway between two integers, (that is, it
12–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬂoor, ﬄoor, ceiling, fceiling, truncate, ftruncate, :::
has the form integer +1
2), then the quotient has been rounded to the even (divisible by two)
integer.
All of these functions perform type conversion operations on numbers .
The remainder is an integer if bothxandyareintegers , is a rational if bothxandyarerationals ,
and is a oat if either xoryis aoat.
ﬄoor ,fceiling ,ftruncate , andfround handle arguments of dierent types in the following way: If
number is aoat, and divisor is not a oat of longer format, then the rst result is a oat of the
same type asnumber . Otherwise, the rst result is of the type determined by contagion rules; see
Section 12.1.1.2 (Contagion in Numeric Operations).
Examples:
(floor 3/2)!1, 1/2
(ceiling 3 2)!2, -1
(ffloor 3 2)!1.0, 1
(ffloor -4.7)!-5.0, 0.3
(ffloor 3.5d0)!3.0d0, 0.5d0
(fceiling 3/2)!2.0, -1/2
(truncate 1)!1, 0
(truncate .5)!0, 0.5
(round .5)!0, 0.5
(ftruncate -7 2) !-3.0, -1
(fround -7 2)!-4.0, 1
(dolist (n ’(2.6 2.5 2.4 0.7 0.3 -0.3 -0.7 -2.4 -2.5 -2.6))
(format t "~&~4,1@F ~2,’ D ~2,’ D ~2,’ D ~2,’ D"
n (floor n) (ceiling n) (truncate n) (round n)))
.+2.6 2 3 2 3
.+2.5 2 3 2 2
.+2.4 2 3 2 2
.+0.7 0 1 0 1
.+0.3 0 1 0 0
.-0.3 -1 0 0 0
.-0.7 -1 0 0 -1
.-2.4 -3 -2 -2 -2
.-2.5 -3 -2 -2 -2
.-2.6 -3 -2 -2 -3
!NIL
Notes:
When only number is given, the two results are exact; the mathematical sum of the two results is
always equal to the mathematical value of number .
(function number divisor )and(function (/number divisor ))(where function is any of one of
ﬂoor ,ceiling ,ﬄoor ,fceiling ,truncate ,round ,ftruncate , andfround ) return the same rst value,
Numbers 12–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
but they return dierent remainders as the second value. For example:
(floor 5 2)!2, 1
(floor (/ 5 2)) !2, 1/2
If an eect is desired that is similar to round , but that always rounds up or down (rather
than toward the nearest even integer) if the mathematical quotient is exactly halfway between
two integers, the programmer should consider a construction such as (floor (+ x 1/2)) or
(ceiling (- x 1/2)) .
sin,cos,tan Function
Syntax:
sinradians!number
cosradians!number
tan radians!number
Arguments and Values:
radians |anumber given in radians.
number |anumber .
Description:
sin,cos, andtanreturn the sine, cosine, and tangent, respectively, of radians .
Examples:
(sin 0)!0.0
(cos 0.7853982) !0.707107
(tan #c(0 1))!#C(0.0 0.761594)
Exceptional Situations:
Should signal an error of typetype-error ifradians is not a number . Might signal arithmetic-error .
See Also:
asin,acos,atan, Section 12.1.3.3 (Rule of Float Substitutability)
12–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
asin, acos, atan
asin,acos,atan Function
Syntax:
asin number!radians
acos number!radians
atan number1 &optional number2!radians
Arguments and Values:
number |anumber .
number1 |anumber ifnumber2 is not supplied, or a realifnumber2 is supplied.
number2 |areal.
radians |anumber (of radians).
Description:
asin,acos, andatan compute the arc sine, arc cosine, and arc tangent respectively.
The arc sine, arc cosine, and arc tangent (with only number1 supplied) functions can be dened
mathematically for number ornumber1 specied as xas in Figure 12{14.
Function Deﬁnition
Arc sine  ilog 
ix+p
1 x2
Arc cosine (=2) arcsinx
Arc tangent  ilog 
(1 +ix)p
1=(1 +x2)
Figure 12–14. Mathematical deﬁnition of arc sine, arc cosine, and arc tangent
These formulae are mathematically correct, assuming completely accurate computation. They are
not necessarily the simplest ones for real-valued computations.
If both number1 and number2 are supplied for atan, the result is the arc tangent of
number1 /number2 . The value of atan is always between  (exclusive) and (inclusive)
when minus zero is not supported. The range of the two-argument arc tangent when minus zero is
supported includes  .
For a real number1 , the result is a realand lies between  =2and=2(both exclusive). number1
can be a complex ifnumber2 is not supplied. If both are supplied, number2 can be zero provided
number1 is not zero.
The following denition for arc sine determines the range and branch cuts:
Numbers 12–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
asin, acos, atan
arcsinz= ilog
iz+p
1 z2
The branch cut for the arc sine function is in two pieces: one along the negative real axis to the left
of 1(inclusive), continuous with quadrant II, and one along the positive real axis to the right of 1
(inclusive), continuous with quadrant IV. The range is that strip of the complex plane containing
numbers whose real part is between  =2and=2. A number with real part equal to  =2is in
the range if and only if its imaginary part is non-negative; a number with real part equal to =2is
in the range if and only if its imaginary part is non-positive.
The following denition for arc cosine determines the range and branch cuts:
arccosz=
2 arcsinz
or, which are equivalent,
arccosz= ilog
z+ip
1 z2
arccosz=2log p
(1 +z)=2 +ip
(1 z)=2
i
The branch cut for the arc cosine function is in two pieces: one along the negative real axis to the
left of 1(inclusive), continuous with quadrant II, and one along the positive real axis to the right
of1(inclusive), continuous with quadrant IV. This is the same branch cut as for arc sine. The
range is that strip of the complex plane containing numbers whose real part is between 0 and . A
number with real part equal to 0 is in the range if and only if its imaginary part is non-negative; a
number with real part equal to is in the range if and only if its imaginary part is non-positive.
The following denition for (one-argument) arc tangent determines the range and branch cuts:
arctanz=log(1 +iz) log(1 iz)
2i
Beware of simplifying this formula; \obvious" simplications are likely to alter the branch cuts
or the values on the branch cuts incorrectly. The branch cut for the arc tangent function is in
two pieces: one along the positive imaginary axis above i(exclusive), continuous with quadrant
II, and one along the negative imaginary axis below  i(exclusive), continuous with quadrant IV.
The points iand iare excluded from the domain. The range is that strip of the complex plane
containing numbers whose real part is between  =2and=2. A number with real part equal to
 =2is in the range if and only if its imaginary part is strictly positive; a number with real part
equal to=2is in the range if and only if its imaginary part is strictly negative. Thus the range of
arc tangent is identical to that of arc sine with the points  =2and=2excluded.
12–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
asin, acos, atan
Foratan, the signs of number1 (indicated as x) and number2 (indicated as y) are used to derive
quadrant information. Figure 12{15 details various special cases. The asterisk (*) indicates that
the entry in the gure applies to implementations that support minus zero.
yCondition xCondition Cartesian locus Range of result
y= 0 x>0 Positive x-axis 0
*y= +0 x>0 Positive x-axis +0
*y= 0x>0 Positive x-axis  0
y>0 x>0 Quadrant I 0<result <=2
y>0 x= 0 Positive y-axis =2
y>0 x<0 Quadrant II =2<result <
y= 0 x<0 Negative x-axis 
*y= +0 x<0 Negative x-axis +
*y= 0x<0 Negative x-axis  
y<0 x<0 Quadrant III  <result < =2
y<0 x= 0 Negative y-axis  =2
y<0 x>0 Quadrant IV  =2<result <0
y= 0 x= 0 Origin undened consequences
*y= +0 x= +0 Origin +0
*y= 0x= +0 Origin  0
*y= +0 x= 0 Origin +
*y= 0x= 0 Origin  
Figure 12–15. Quadrant information for arc tangent
Examples:
(asin 0)!0.0
(acos #c(0 1)) !#C(1.5707963267948966 -0.8813735870195432)
(/ (atan 1 (sqrt 3)) 6) !0.087266
(atan #c(0 2))!#C(-1.5707964 0.54930615)
Exceptional Situations:
acos andasin should signal an error of typetype-error ifnumber is not a number .atan should
signaltype-error if one argument is supplied and that argument is not a number , or if two
arguments are supplied and both of those arguments are not reals.
acos,asin, andatan might signal arithmetic-error .
See Also:
log,sqrt, Section 12.1.3.3 (Rule of Float Substitutability)
Numbers 12–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
The result of either asin oracos can be a complex even if number is not a complex ; this occurs
when the absolute value of number is greater than one.
pi Constant Variable
Value:
animplementation-dependent long oat .
Description:
The best long oat approximation to the mathematical constant .
Examples:
;; In each of the following computations, the precision depends
;; on the implementation. Also, if ‘long float’ is treated by
;; the implementation as equivalent to some other float format
;; (e.g., ‘double float’) the exponent marker might be the marker
;; for that equivalent (e.g., ‘D’ instead of ‘L’).
pi!3.141592653589793L0
(cos pi)!-1.0L0
(defun sin-of-degrees (degrees)
(let ((x (if (floatp degrees) degrees (float degrees pi))))
(sin (* x (/ (float pi x) 180)))))
Notes:
An approximation to in some other precision can be obtained by writing (float pi x) , wherex
is aoat of the desired precision, or by writing (coerce pi type), where type is the desired type,
such asshort-ﬂoat .
12–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
sinh, cosh, tanh, asinh, acosh, atanh
sinh,cosh,tanh,asinh,acosh,atanh Function
Syntax:
sinh number!result
cosh number!result
tanh number!result
asinh number!result
acosh number!result
atanh number!result
Arguments and Values:
number |anumber .
result |anumber .
Description:
These functions compute the hyperbolic sine, cosine, tangent, arc sine, arc cosine, and arc tangent
functions, which are mathematically dened for an argument xas given in Figure 12{16.
Function Deﬁnition
Hyperbolic sine (ex e x)=2
Hyperbolic cosine (ex+e x)=2
Hyperbolic tangent (ex e x)=(ex+e x)
Hyperbolic arc sine log(x+p
1 +x2)
Hyperbolic arc cosine 2log(p
(x+ 1)=2 +p
(x 1)=2)
Hyperbolic arc tangent (log(1 +x) log(1 x))=2
Figure 12–16. Mathematical deﬁnitions for hyperbolic functions
The following denition for the inverse hyperbolic cosine determines the range and branch cuts:
arccoshz= 2logp
(z+ 1)=2 +p
(z 1)=2
:
The branch cut for the inverse hyperbolic cosine function lies along the real axis to the left of 1
(inclusive), extending indenitely along the negative real axis, continuous with quadrant II and
(between 0and1) with quadrant I. The range is that half-strip of the complex plane containing
numbers whose real part is non-negative and whose imaginary part is between  (exclusive)
and(inclusive). A number with real part zero is in the range if its imaginary part is between
zero (inclusive) and (inclusive).
Numbers 12–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
sinh, cosh, tanh, asinh, acosh, atanh
The following denition for the inverse hyperbolic sine determines the range and branch cuts:
arcsinhz=log
z+p
1 +z2
:
The branch cut for the inverse hyperbolic sine function is in two pieces: one along the positive
imaginary axis above i(inclusive), continuous with quadrant I, and one along the negative
imaginary axis below  i(inclusive), continuous with quadrant III. The range is that strip of the
complex plane containing numbers whose imaginary part is between  =2and=2. A number with
imaginary part equal to  =2is in the range if and only if its real part is non-positive; a number
with imaginary part equal to =2is in the range if and only if its imaginary part is non-negative.
The following denition for the inverse hyperbolic tangent determines the range and branch cuts:
arctanhz=log(1 +z) log(1 z)
2:
Note that:
iarctanz=arctanhiz:
The branch cut for the inverse hyperbolic tangent function is in two pieces: one along the negative
real axis to the left of  1(inclusive), continuous with quadrant III, and one along the positive real
axis to the right of 1(inclusive), continuous with quadrant I. The points  1and1are excluded
from the domain. The range is that strip of the complex plane containing numbers whose imaginary
part is between =2and=2. A number with imaginary part equal to  =2is in the range if
and only if its real part is strictly negative; a number with imaginary part equal to =2is in the
range if and only if its imaginary part is strictly positive. Thus the range of the inverse hyperbolic
tangent function is identical to that of the inverse hyperbolic sine function with the points  i=2
andi=2excluded.
Examples:
(sinh 0)!0.0
(cosh (complex 0 -1)) !#C(0.540302 -0.0)
Exceptional Situations:
Should signal an error of typetype-error ifnumber is not a number . Might signal arithmetic-error .
See Also:
log,sqrt, Section 12.1.3.3 (Rule of Float Substitutability)
Notes:
The result of acosh may be a complex even if number is not a complex ; this occurs when number
is less than one. Also, the result of atanh may be a complex even if number is not a complex ; this
occurs when the absolute value of number is greater than one.
12–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The branch cut formulae are mathematically correct, assuming completely accurate computation.
Implementors should consult a good text on numerical analysis. The formulae given above are not
necessarily the simplest ones for real-valued computations; they are chosen to dene the branch
cuts in desirable ways for the complex case.
 Function
Syntax:
*&rest numbers!product
Arguments and Values:
number |anumber .
product |anumber .
Description:
Returns the product of numbers , performing any necessary type conversions in the process. If no
numbers are supplied, 1is returned.
Examples:
(*)!1
(* 3 5)!15
(* 1.0 #c(22 33) 55/98) !#C(12.346938775510203 18.520408163265305)
Exceptional Situations:
Might signal type-error if some argument is not a number . Might signal arithmetic-error .
See Also:
Section 12.1.1 (Numeric Operations), Section 12.1.3 (Rational Computations), Section 12.1.4
(Floating-point Computations), Section 12.1.5 (Complex Computations)
Numbers 12–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
+ Function
Syntax:
+&rest numbers!sum
Arguments and Values:
number |anumber .
sum|anumber .
Description:
Returns the sum of numbers , performing any necessary type conversions in the process. If no
numbers are supplied, 0is returned.
Examples:
(+)!0
(+ 1)!1
(+ 31/100 69/100) !1
(+ 1/5 0.8)!1.0
Exceptional Situations:
Might signal type-error if some argument is not a number . Might signal arithmetic-error .
See Also:
Section 12.1.1 (Numeric Operations), Section 12.1.3 (Rational Computations), Section 12.1.4
(Floating-point Computations), Section 12.1.5 (Complex Computations)
  Function
Syntax:
 number!negation
 minuend &rest subtrahends+!dierence
Arguments and Values:
number ,minuend ,subtrahend |anumber .
negation ,dierence |anumber .
Description:
The function-performs arithmetic subtraction and negation.
12–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If only one number is supplied, the negation of that number is returned.
If more than one argument is given, it subtracts all of the subtrahends from the minuend and
returns the result.
The function-performs necessary type conversions.
Examples:
(- 55.55)!-55.55
(- #c(3 -5))!#C(-3 5)
(- 0)!0
(eql (- 0.0) -0.0) !true
(- #c(100 45) #c(0 45)) !100
(- 10 1 2 3 4)!0
Exceptional Situations:
Might signal type-error if some argument is not a number . Might signal arithmetic-error .
See Also:
Section 12.1.1 (Numeric Operations), Section 12.1.3 (Rational Computations), Section 12.1.4
(Floating-point Computations), Section 12.1.5 (Complex Computations)
/ Function
Syntax:
/number!reciprocal
/numerator &rest denominators+!quotient
Arguments and Values:
number ,denominator |a non-zero number .
numerator ,quotient ,reciprocal |anumber .
Description:
The function/performs division or reciprocation.
If no denominators are supplied, the function/returns the reciprocal of number .
If at least one denominator is supplied, the function /divides the numerator by all of the
denominators and returns the resulting quotient .
If each argument is either an integer or a ratio , and the result is not an integer , then it is a ratio .
Numbers 12–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The function/performs necessary type conversions.
If any argument is a oat then the rules of oating-point contagion apply; see Section 12.1.4
(Floating-point Computations).
Examples:
(/ 12 4)!3
(/ 13 4)!13/4
(/ -8)!-1/8
(/ 3 4 5)!3/20
(/ 0.5)!2.0
(/ 20 5)!4
(/ 5 20)!1/4
(/ 60 -2 3 5.0) !-2.0
(/ 2 #c(2 2))!#C(1/2 -1/2)
Exceptional Situations:
The consequences are unspecied if any argument other than the rst is zero. If there is only one
argument , the consequences are unspecied if it is zero.
Might signal type-error if some argument is not a number . Might signal division-by-zero if
division by zero is attempted. Might signal arithmetic-error .
See Also:
ﬂoor ,ceiling ,truncate ,round
1+,1  Function
Syntax:
1+number!successor
1 number!predecessor
Arguments and Values:
number |anumber .
successor ,predecessor |anumber .
Description:
1+returns a number that is one more than its argument number .1-returns a number that is one
less than its argument number .
12–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(1+ 99)!100
(1- 100)!99
(1+ (complex 0.0)) !#C(1.0 0.0)
(1- 5/3)!2/3
Exceptional Situations:
Might signal type-error if its argument is not a number . Might signal arithmetic-error .
See Also:
incf,decf
Notes:
(1+ number)(+number 1)
(1- number)(-number 1)
Implementors are encouraged to make the performance of both the previous expressions be the
same.
abs Function
Syntax:
abs number!absolute-value
Arguments and Values:
number |anumber .
absolute-value |a non-negative real.
Description:
absreturns the absolute value of number .
Ifnumber is areal, the result is of the same type asnumber .
Ifnumber is a complex , the result is a positive realwith the same magnitude as number . The
result can be a oat even if number 's components are rationals and an exact rational result would
have been possible. Thus the result of (abs #c(3 4)) can be either 5or5.0, depending on the
implementation.
Examples:
(abs 0)!0
Numbers 12–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(abs 12/13)!12/13
(abs -1.09)!1.09
(abs #c(5.0 -5.0)) !7.071068
(abs #c(5 5))!7.071068
(abs #c(3/5 4/5)) !1 or approximately 1.0
(eql (abs -0.0) -0.0) !true
See Also:
Section 12.1.3.3 (Rule of Float Substitutability)
Notes:
Ifnumber is acomplex , the result is equivalent to the following:
(sqrt (+ (expt (realpart number) 2) (expt (imagpart number) 2)))
An implementation should not use this formula directly for all complexes but should handle very
large or very small components specially to avoid intermediate overow or underow.
evenp,oddp Function
Syntax:
evenp integer!generalized-boolean
oddp integer!generalized-boolean
Arguments and Values:
integer |an integer .
generalized-boolean |ageneralized boolean .
Description:
evenp returns true ifinteger is even (divisible by two); otherwise, returns false.
oddp returns true ifinteger is odd (not divisible by two); otherwise, returns false.
Examples:
(evenp 0)!true
(oddp 10000000000000000000000) !false
(oddp -1)!true
Exceptional Situations:
Should signal an error of typetype-error ifinteger is not an integer .
12–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(evenp integer)(not (oddp integer))
(oddp integer)(not (evenp integer))
exp,expt Function
Syntax:
exp number!result
expt base-number power-number !result
Arguments and Values:
number |anumber .
base-number |anumber .
power-number |anumber .
result |anumber .
Description:
expandexpt perform exponentiation.
expreturns eraised to the power number , where eis the base of the natural logarithms. exphas
no branch cut.
expt returns base-number raised to the power power-number . If the base-number is a rational
and power-number is an integer , the calculation is exact and the result will be of typerational ;
otherwise a oating-point approximation might result. For expt of a complex rational to an integer
power, the calculation must be exact and the result is of type (or rational (complex rational)) .
The result of expt can be a complex , even when neither argument is a complex , ifbase-number is
negative and power-number is not an integer . The result is always the principal complex value .
For example, (expt -8 1/3) is not permitted to return -2, even though -2is one of the cube roots
of-8. The principal cube root is a complex approximately equal to #C(1.0 1.73205) , not-2.
expt is dened as bx=exlogb. This denes the principal values precisely. The range of expt is the
entire complex plane. Regarded as a function of x, with bxed, there is no branch cut. Regarded
as a function of b, with xxed, there is in general a branch cut along the negative real axis,
continuous with quadrant II. The domain excludes the origin. By denition, 00=1. If b=0 and the
real part of xis strictly positive, then bx=0. For all other values of x,0xis an error.
Numbers 12–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
When power-number is an integer0, then the result is always the value one in the type of
base-number , even if the base-number is zero (of any type). That is:
(expt x 0)(coerce 1 (type-of x))
Ifpower-number is a zero of any other type, then the result is also the value one, in the type of the
arguments after the application of the contagion rules in Section 12.1.1.2 (Contagion in Numeric
Operations), with one exception: the consequences are undened if base-number is zero when
power-number is zero and not of typeinteger .
Examples:
(exp 0)!1.0
(exp 1)!2.718282
(exp (log 5))!5.0
(expt 2 8)!256
(expt 4 .5)!2.0
(expt #c(0 1) 2) !-1
(expt #c(2 2) 3) !#C(-16 16)
(expt #c(2 2) 4) !-64
See Also:
log, Section 12.1.3.3 (Rule of Float Substitutability)
Notes:
Implementations of expt are permitted to use dierent algorithms for the cases of a power-number
oftyperational and a power-number oftypeﬂoat.
Note that by the following logic, (sqrt (expt x3))is not equivalent to (expt x3/2).
(setq x (exp (/ (* 2 pi #c(0 1)) 3))) ;exp(2.pi.i/3)
(expt x 3)!1 ;except for round-off error
(sqrt (expt x 3)) !1 ;except for round-off error
(expt x 3/2)!-1 ;except for round-off error
gcd Function
Syntax:
gcd&rest integers!greatest-common-denominator
Arguments and Values:
integer |an integer .
12–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
greatest-common-denominator |a non-negative integer .
Description:
Returns the greatest common divisor of integers . If only one integer is supplied, its absolute value
is returned. If no integers are given, gcdreturns0, which is an identity for this operation.
Examples:
(gcd)!0
(gcd 60 42)!6
(gcd 3333 -33 101) !1
(gcd 3333 -33 1002001) !11
(gcd 91 -49)!7
(gcd 63 -42 35) !7
(gcd 5)!5
(gcd -4)!4
Exceptional Situations:
Should signal an error of typetype-error if any integer is not an integer .
See Also:
lcm
Notes:
For three or more arguments,
(gcd b c ... z) (gcd (gcd a b) c ... z)
incf,decf Macro
Syntax:
incf place [delta-form ]!new-value
decf place [delta-form ]!new-value
Arguments and Values:
place |aplace .
delta-form |aform ; evaluated to produce a delta. The default is 1.
delta|anumber .
new-value |anumber .
Numbers 12–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
incf anddecf are used for incrementing and decrementing the value ofplace , respectively.
The delta is added to (in the case of incf) or subtracted from (in the case of decf) the number in
place and the result is stored in place .
Any necessary type conversions are performed automatically.
For information about the evaluation ofsubforms ofplaces , see Section 5.1.1.1 (Evaluation of
Subforms to Places).
Examples:
(setq n 0)
(incf n)!1
n!1
(decf n 3)!-2
n!-2
(decf n -5)!3
(decf n)!2
(incf n 0.5)!2.5
(decf n)!1.5
n!1.5
Side Eﬀects:
Place is modied.
See Also:
+,-,1+,1-,setf
lcm Function
Syntax:
lcm&rest integers!least-common-multiple
Arguments and Values:
integer |an integer .
least-common-multiple |a non-negative integer .
Description:
lcmreturns the least common multiple of the integers .
If no integer is supplied, the integer1is returned.
12–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If only one integer is supplied, the absolute value of that integer is returned.
For two arguments that are not both zero,
(lcm a b)(/ (abs (* a b)) (gcd a b))
If one or both arguments are zero,
(lcm a 0)(lcm 0 a)0
For three or more arguments,
(lcm a b c ... z) (lcm (lcm a b) c ... z)
Examples:
(lcm 10)!10
(lcm 25 30)!150
(lcm -24 18 10) !360
(lcm 14 35)!70
(lcm 0 5)!0
(lcm 1 2 3 4 5 6) !60
Exceptional Situations:
Should signal type-error if any argument is not an integer .
See Also:
gcd
log Function
Syntax:
lognumber&optional base!logarithm
Arguments and Values:
number |a non-zero number .
base|anumber .
logarithm |anumber .
Description:
logreturns the logarithm of number in base base. Ifbase is not supplied its value is e, the base of
the natural logarithms.
Numbers 12–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
log
logmay return a complex when given a realnegative number .
(log -1.0)(complex 0.0 (float pi 0.0))
Ifbase is zero,logreturns zero.
The result of (log 8 2) may be either 3or3.0, depending on the implementation. An
implementation can use oating-point calculations even if an exact integer result is possible.
The branch cut for the logarithm function of one argument (natural logarithm) lies along the
negative real axis, continuous with quadrant II. The domain excludes the origin.
The mathematical denition of a complex logarithm is as follows, whether or not minus zero is
supported by the implementation:
(log x)(complex (log (abs x)) (phase x))
Therefore the range of the one-argument logarithm function is that strip of the complex plane
containing numbers with imaginary parts between  (exclusive) and (inclusive) if minus zero is
not supported, or  (inclusive) and (inclusive) if minus zero is supported.
The two-argument logarithm function is dened as
(log base number )
(/ (log number) (log base))
This denes the principal values precisely. The range of the two-argument logarithm function is
the entire complex plane.
Examples:
(log 100 10)
!2.0
!2
(log 100.0 10)!2.0
(log #c(0 1) #c(0 -1))
!#C(-1.0 0.0)or!#C(-1 0)
(log 8.0 2)!3.0
(log #c(-16 16) #c(2 2)) !3 or approximately #c(3.0 0.0)
or approximately 3.0 (unlikely)
Aﬀected By:
The implementation.
12–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
exp,expt, Section 12.1.3.3 (Rule of Float Substitutability)
mod,rem Function
Syntax:
mod number divisor!modulus
rem number divisor!remainder
Arguments and Values:
number |areal.
divisor |areal.
modulus ,remainder |areal.
Description:
mod andrem are generalizations of the modulus and remainder functions respectively.
mod performs the operation ﬂoor onnumber and divisor and returns the remainder of the ﬂoor
operation.
rem performs the operation truncate onnumber and divisor and returns the remainder of the
truncate operation.
mod andrem are the modulus and remainder functions when number and divisor areintegers .
Examples:
(rem -1 5)!-1
(mod -1 5)!4
(mod 13 4)!1
(rem 13 4)!1
(mod -13 4)!3
(rem -13 4)!-1
(mod 13 -4)!-3
(rem 13 -4)!1
(mod -13 -4)!-1
(rem -13 -4)!-1
(mod 13.4 1)!0.4
(rem 13.4 1)!0.4
(mod -13.4 1)!0.6
(rem -13.4 1)!-0.4
Numbers 12–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
ﬂoor ,truncate
Notes:
The result of mod is either zero or a realwith the same sign as divisor .
signum Function
Syntax:
signum number!signed-prototype
Arguments and Values:
number |anumber .
signed-prototype |anumber .
Description:
signum determines a numerical value that indicates whether number is negative, zero, or positive.
For a rational ,signum returns one of -1,0, or1according to whether number is negative, zero, or
positive. For a oat, the result is a oat of the same format whose value is minus one, zero, or
one. For a complex number z,(signum z)is a complex number of the same phase but with unit
magnitude, unless zis a complex zero, in which case the result is z.
Forrational arguments ,signum is a rational function, but it may be irrational for complex
arguments .
Ifnumber is aoat, the result is a oat. Ifnumber is arational , the result is a rational . Ifnumber
is a complex oat , the result is a complex oat . If number is a complex rational , the result is a
complex , but it is implementation-dependent whether that result is a complex rational or a complex
oat.
Examples:
(signum 0)!0
(signum 99)!1
(signum 4/5)!1
(signum -99/100) !-1
(signum 0.0)!0.0
(signum #c(0 33)) !#C(0.0 1.0)
(signum #c(7.5 10.0)) !#C(0.6 0.8)
(signum #c(0.0 -14.7)) !#C(0.0 -1.0)
(eql (signum -0.0) -0.0) !true
12–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
Section 12.1.3.3 (Rule of Float Substitutability)
Notes:
(signum x)(if (zerop x) x (/ x (abs x)))
sqrt,isqrt Function
Syntax:
sqrt number!root
isqrt natural!natural-root
Arguments and Values:
number ,root|anumber .
natural ,natural-root |a non-negative integer .
Description:
sqrt andisqrt compute square roots.
sqrt returns the principal square root of number . If the number is not a complex but is negative,
then the result is a complex .
isqrt returns the greatest integer less than or equal to the exact positive square root of natural .
Ifnumber is a positive rational , it is implementation-dependent whether root is a rational or a
oat. If number is a negative rational , it is implementation-dependent whether root is acomplex
rational or a complex oat .
The mathematical denition of complex square root (whether or not minus zero is supported)
follows:
(sqrt x) = (exp (/ (log x) 2))
The branch cut for square root lies along the negative real axis, continuous with quadrant II. The
range consists of the right half-plane, including the non-negative imaginary axis and excluding the
negative imaginary axis.
Examples:
(sqrt 9.0)!3.0
(sqrt -9.0)!#C(0.0 3.0)
Numbers 12–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(isqrt 9)!3
(sqrt 12)!3.4641016
(isqrt 12)!3
(isqrt 300)!17
(isqrt 325)!18
(sqrt 25)
!5or!5.0
(isqrt 25)!5
(sqrt -1)!#C(0.0 1.0)
(sqrt #c(0 2))!#C(1.0 1.0)
Exceptional Situations:
The functionsqrt should signal type-error if its argument is not a number .
The functionisqrt should signal type-error if its argument is not a non-negative integer .
The functions sqrt andisqrt might signal arithmetic-error .
See Also:
exp,log, Section 12.1.3.3 (Rule of Float Substitutability)
Notes:
(isqrt x)(values (floor (sqrt x)))
but it is potentially more ecient.
random-state System Class
Class Precedence List:
random-state ,t
Description:
Arandom state object contains state information used by the pseudo-random number generator.
The nature of a random state object isimplementation-dependent . It can be printed out and
successfully read back in by the same implementation , but might not function correctly as a
random state in another implementation .
Implementations are required to provide a read syntax for objects oftyperandom-state , but the
specic nature of that syntax is implementation-dependent .
See Also:
*random-state* ,random , Section 22.1.3.10 (Printing Random States)
12–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-random-state Function
Syntax:
make-random-state &optional state!new-state
Arguments and Values:
state |arandom state , ornil, ort. The default is nil.
new-state |arandom state object .
Description:
Creates a fresh object oftyperandom-state suitable for use as the value of*random-state* .
Ifstate is arandom state object , the new-state is acopy 5of that object . Ifstate isnil, the new-state
is acopy 5of the current random state . If state ist, the new-state is afresh random state object
that has been randomly initialized by some means.
Examples:
(let* ((rs1 (make-random-state nil))
(rs2 (make-random-state t))
(rs3 (make-random-state rs2))
(rs4 nil))
(list (loop for i from 1 to 10
collect (random 100)
when (= i 5)
do (setq rs4 (make-random-state)))
(loop for i from 1 to 10 collect (random 100 rs1))
(loop for i from 1 to 10 collect (random 100 rs2))
(loop for i from 1 to 10 collect (random 100 rs3))
(loop for i from 1 to 10 collect (random 100 rs4))))
!((29 25 72 57 55 68 24 35 54 65)
(29 25 72 57 55 68 24 35 54 65)
(93 85 53 99 58 62 2 23 23 59)
(93 85 53 99 58 62 2 23 23 59)
(68 24 35 54 65 54 55 50 59 49))
Exceptional Situations:
Should signal an error of typetype-error ifstate is not a random state , ornil, ort.
See Also:
random ,*random-state*
Numbers 12–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
One important use of make-random-state is to allow the same series of pseudo-random numbers
to be generated many times within a single program.
random Function
Syntax:
random limit&optional random-state!random-number
Arguments and Values:
limit|a positive integer , or a positive oat.
random-state |arandom state . The default is the current random state .
random-number |a non-negative number less than limit and of the same type aslimit.
Description:
Returns a pseudo-random number that is a non-negative number less than limit and of the same
type aslimit.
The random-state , which is modied by this function, encodes the internal state maintained by the
random number generator.
An approximately uniform choice distribution is used. If limit is an integer , each of the possible
results occurs with (approximate) probability 1/ limit.
Examples:
(<= 0 (random 1000) 1000) !true
(let ((state1 (make-random-state))
(state2 (make-random-state)))
(= (random 1000 state1) (random 1000 state2))) !true
Side Eﬀects:
The random-state is modied.
Exceptional Situations:
Should signal an error of typetype-error iflimit is not a positive integer or a positive real.
See Also:
make-random-state ,*random-state*
Notes:
SeeCommon Lisp: The Language for information about generating random numbers.
12–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
random-state-p Function
Syntax:
random-state-p object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typerandom-state ; otherwise, returns false.
Examples:
(random-state-p *random-state*) !true
(random-state-p (make-random-state)) !true
(random-state-p ’test-function) !false
See Also:
make-random-state ,*random-state*
Notes:
(random-state-p object)(typep object’random-state)
random-state Variable
Value Type:
arandom state .
Initial Value:
implementation-dependent .
Description:
The current random state , which is used, for example, by the function random when a random
state is not explicitly supplied.
Numbers 12–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(random-state-p *random-state*) !true
(setq snap-shot (make-random-state))
;; The series from any given point is random,
;; but if you backtrack to that point, you get the same series.
(list (loop for i from 1 to 10 collect (random))
(let ((*random-state* snap-shot))
(loop for i from 1 to 10 collect (random)))
(loop for i from 1 to 10 collect (random))
(let ((*random-state* snap-shot))
(loop for i from 1 to 10 collect (random))))
!((19 16 44 19 96 15 76 96 13 61)
(19 16 44 19 96 15 76 96 13 61)
(16 67 0 43 70 79 58 5 63 50)
(16 67 0 43 70 79 58 5 63 50))
Aﬀected By:
The implementation .
random .
See Also:
make-random-state ,random ,random-state
Notes:
Binding*random-state* to a dierent random state object correctly saves and restores the old
random state object .
numberp Function
Syntax:
numberp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typenumber ; otherwise, returns false.
12–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(numberp 12)!true
(numberp (expt 2 130)) !true
(numberp #c(5/3 7.2)) !true
(numberp nil)!false
(numberp (cons 1 2)) !false
Notes:
(numberp object)(typep object’number)
cis Function
Syntax:
cisradians!number
Arguments and Values:
radians |areal.
number |acomplex .
Description:
cisreturns the value of eiradians, which is a complex in which the real part is equal to the cosine
ofradians , and the imaginary part is equal to the sine of radians .
Examples:
(cis 0)!#C(1.0 0.0)
See Also:
Section 12.1.3.3 (Rule of Float Substitutability)
Numbers 12–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
complex Function
Syntax:
complex realpart&optional imagpart!complex
Arguments and Values:
realpart |areal.
imagpart |areal.
complex |arational or a complex .
Description:
complex returns a number whose real part is realpart and whose imaginary part is imagpart .
Ifrealpart is arational and imagpart is the rational number zero, the result of complex isrealpart ,
arational . Otherwise, the result is a complex .
If either realpart orimagpart is aoat, the non- oat is converted to a oat before the complex is
created. If imagpart is not supplied, the imaginary part is a zero of the same type asrealpart ;i.e.,
(coerce 0 (type-of realpart))is eectively used.
Type upgrading implies a movement upwards in the type hierarchy lattice. In the case of
complexes , the type-specier must be a subtype of (upgraded-complex-part-type type-specier ).
Iftype-specier1 is a subtype of type-specier2 , then(upgraded-complex-element-type ’ type-
specier1 )must also be a subtype of (upgraded-complex-element-type ’ type-specier2 ). Two
disjoint types can be upgraded into the same thing.
Examples:
(complex 0)!0
(complex 0.0)!#C(0.0 0.0)
(complex 1 1/2) !#C(1 1/2)
(complex 1 .99) !#C(1.0 0.99)
(complex 3/2 0.0) !#C(1.5 0.0)
See Also:
realpart ,imagpart , Section 2.4.8.11 (Sharpsign C)
12–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
complexp Function
Syntax:
complexp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typecomplex ; otherwise, returns false.
Examples:
(complexp 1.2d2) !false
(complexp #c(5/3 7.2)) !true
See Also:
complex (function and type),typep
Notes:
(complexp object)(typep object’complex)
conjugate Function
Syntax:
conjugate number!conjugate
Arguments and Values:
number |anumber .
conjugate |anumber .
Description:
Returns the complex conjugate of number . The conjugate of a realnumber is itself.
Numbers 12–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(conjugate #c(0 -1)) !#C(0 1)
(conjugate #c(1 1)) !#C(1 -1)
(conjugate 1.5) !1.5
(conjugate #C(3/5 4/5)) !#C(3/5 -4/5)
(conjugate #C(0.0D0 -1.0D0)) !#C(0.0D0 1.0D0)
(conjugate 3.7) !3.7
Notes:
For a complex number z,
(conjugate z)(complex (realpart z) (- (imagpart z)))
phase Function
Syntax:
phase number!phase
Arguments and Values:
number |anumber .
phase |anumber .
Description:
phase returns the phase of number (the angle part of its polar representation) in radians, in the
range (exclusive) if minus zero is not supported, or  (inclusive) if minus zero is supported,
to(inclusive). The phase of a positive realnumber is zero; that of a negative realnumber is.
The phase of zero is dened to be zero.
Ifnumber is acomplex oat , the result is a oat of the same type as the components of number .
Ifnumber is a oat, the result is a oat of the same type. If number is a rational or a complex
rational , the result is a single oat .
The branch cut for phase lies along the negative real axis, continuous with quadrant II. The range
consists of that portion of the real axis between  (exclusive) and (inclusive).
The mathematical denition of phase is as follows:
(phase x) = (atan (imagpart x) (realpart x))
Examples:
(phase 1)!0.0s0
12–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(phase 0)!0.0s0
(phase (cis 30)) !-1.4159266
(phase #c(0 1)) !1.5707964
Exceptional Situations:
Should signal type-error if its argument is not a number . Might signal arithmetic-error .
See Also:
Section 12.1.3.3 (Rule of Float Substitutability)
realpart,imagpart Function
Syntax:
realpart number!real
imagpart number!real
Arguments and Values:
number |anumber .
real|areal.
Description:
realpart andimagpart return the real and imaginary parts of number respectively. If number is
real, thenrealpart returns number andimagpart returns(* 0 number), which has the eect that
the imaginary part of a rational is0and that of a oat is a oating-point zero of the same format.
Examples:
(realpart #c(23 41)) !23
(imagpart #c(23 41.0)) !41.0
(realpart #c(23 41.0)) !23.0
(imagpart 23.0) !0.0
Exceptional Situations:
Should signal an error of typetype-error ifnumber is not a number .
See Also:
complex
Numbers 12–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
upgraded-complex-part-type Function
Syntax:
upgraded-complex-part-type typespec &optional environment!upgraded-typespec
Arguments and Values:
typespec |atype specier .
environment |an environment object . The default is nil, denoting the null lexical environment and
the and current global environment .
upgraded-typespec |atype specier .
Description:
upgraded-complex-part-type returns the part type of the most specialized complex number
representation that can hold parts of type typespec .
The typespec is asubtype of (and possibly type equivalent to) the upgraded-typespec .
The purpose of upgraded-complex-part-type is to reveal how an implementation does its
upgrading .
See Also:
complex (function and type)
Notes:
realp Function
Syntax:
realp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typereal; otherwise, returns false.
Examples:
(realp 12)!true
12–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(realp #c(5/3 7.2)) !false
(realp nil)!false
(realp (cons 1 2)) !false
Notes:
(realp object)(typep object’real)
numerator,denominator Function
Syntax:
numerator rational!numerator
denominator rational!denominator
Arguments and Values:
rational |arational .
numerator |an integer .
denominator |a positive integer .
Description:
numerator anddenominator reduce rational to canonical form and compute the numerator or
denominator of that number.
numerator anddenominator return the numerator or denominator of the canonical form of
rational .
Ifrational is an integer ,numerator returns rational anddenominator returns 1.
Examples:
(numerator 1/2) !1
(denominator 12/36) !3
(numerator -1)!-1
(denominator (/ -33)) !33
(numerator (/ 8 -6)) !-4
(denominator (/ 8 -6)) !3
See Also:
/
Numbers 12–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(gcd (numerator x) (denominator x)) !1
rational,rationalize Function
Syntax:
rational number!rational
rationalize number!rational
Arguments and Values:
number |areal.
rational |arational .
Description:
rational andrationalize convert reals torationals .
Ifnumber is already rational , it is returned.
Ifnumber is a oat,rational returns a rational that is mathematically equal in value to the
oat.rationalize returns a rational that approximates the oat to the accuracy of the underlying
oating-point representation.
rational assumes that the oat is completely accurate.
rationalize assumes that the oat is accurate only to the precision of the oating-point
representation.
Examples:
(rational 0)!0
(rationalize -11/100) !-11/100
(rational .1)!13421773/134217728 ;implementation-dependent
(rationalize .1) !1/10
Aﬀected By:
The implementation .
Exceptional Situations:
Should signal an error of typetype-error ifnumber is not a real. Might signal arithmetic-error .
12–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
It is always the case that
(float (rational x) x) x
and
(float (rationalize x) x) x
That is, rationalizing a oat by either method and then converting it back to a oat of the same
format produces the original number .
rationalp Function
Syntax:
rationalp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typerational ; otherwise, returns false.
Examples:
(rationalp 12)!true
(rationalp 6/5) !true
(rationalp 1.212) !false
See Also:
rational
Notes:
(rationalp object)(typep object’rational)
Numbers 12–63
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ash Function
Syntax:
ash integer count!shifted-integer
Arguments and Values:
integer |an integer .
count |an integer .
shifted-integer |an integer .
Description:
ashperforms the arithmetic shift operation on the binary representation of integer , which is treated
as if it were binary.
ashshifts integer arithmetically left by count bit positions if count is positive, or right count bit
positions if count is negative. The shifted value of the same sign as integer is returned.
Mathematically speaking, ashperforms the computation floor (integer2count). Logically, ash
moves all of the bits in integer to the left, adding zero-bits at the right, or moves them to the right,
discarding bits.
ashis dened to behave as if integer were represented in two's complement form, regardless of how
integers are represented internally.
Examples:
(ash 16 1)!32
(ash 16 0)!16
(ash 16 -1)!8
(ash -100000000000000000000000000000000 -100) !-79
Exceptional Situations:
Should signal an error of typetype-error ifinteger is not an integer . Should signal an error of type
type-error ifcount is not an integer . Might signal arithmetic-error .
Notes:
(logbitp j(ash n k))
(and (>= j k) (logbitp (- j k)n))
12–64 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
integer-length
integer-length Function
Syntax:
integer-length integer!number-of-bits
Arguments and Values:
integer |an integer .
number-of-bits |a non-negative integer .
Description:
Returns the number of bits needed to represent integer in binary two's-complement format.
Examples:
(integer-length 0) !0
(integer-length 1) !1
(integer-length 3) !2
(integer-length 4) !3
(integer-length 7) !3
(integer-length -1) !0
(integer-length -4) !2
(integer-length -7) !3
(integer-length -8) !3
(integer-length (expt 2 9)) !10
(integer-length (1- (expt 2 9))) !9
(integer-length (- (expt 2 9))) !9
(integer-length (- (1+ (expt 2 9)))) !10
Exceptional Situations:
Should signal an error of typetype-error ifinteger is not an integer .
Notes:
This function could have been dened by:
(defun integer-length (integer)
(ceiling (log (if (minusp integer)
(- integer)
(1+ integer))
2)))
Ifinteger is non-negative, then its value can be represented in unsigned binary form in a eld
whose width in bits is no smaller than (integer-length integer). Regardless of the sign of integer ,
its value can be represented in signed binary two's-complement form in a eld whose width in bits
is no smaller than (+ (integer-length integer) 1).
Numbers 12–65
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
integerp Function
Syntax:
integerp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typeinteger ; otherwise, returns false.
Examples:
(integerp 1)!true
(integerp (expt 2 130)) !true
(integerp 6/5)!false
(integerp nil)!false
Notes:
(integerp object)(typep object’integer)
parse-integer Function
Syntax:
parse-integer string&key start end radix junk-allowed !integer, pos
Arguments and Values:
string |astring .
start,end|bounding index designators ofstring . The defaults for start and endare0andnil,
respectively.
radix |aradix . The default is 10.
junk-allowed |ageneralized boolean . The default is false.
12–66 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
integer |an integer orfalse.
pos|abounding index ofstring .
Description:
parse-integer parses an integer in the specied radix from the substring of string delimited by start
and end.
parse-integer expects an optional sign ( +or-) followed by a a non-empty sequence of digits to be
interpreted in the specied radix . Optional leading and trailing whitespace 1is ignored.
parse-integer does not recognize the syntactic radix-specier prexes #O,#B,#X, and#nR, nor does
it recognize a trailing decimal point.
Ifjunk-allowed isfalse, an error of typeparse-error is signaled if substring does not consist
entirely of the representation of a signed integer , possibly surrounded on either side by whitespace 1
characters .
The rst value returned is either the integer that was parsed, or else nilif no syntactically correct
integer was seen but junk-allowed was true.
The second value is either the index into the string of the delimiter that terminated the parse, or
the upper bounding index of the substring if the parse terminated at the end of the substring (as is
always the case if junk-allowed isfalse).
Examples:
(parse-integer "123") !123, 3
(parse-integer "123" :start 1 :radix 5) !13, 3
(parse-integer "no-integer" :junk-allowed t) !NIL, 0
Exceptional Situations:
Ifjunk-allowed isfalse, an error is signaled if substring does not consist entirely of the representation
of an integer , possibly surrounded on either side by whitespace 1characters.
boole Function
Syntax:
boole op integer-1 integer-2 !result-integer
Arguments and Values:
Op|abit-wise logical operation specier .
integer-1 |an integer .
Numbers 12–67
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
boole
integer-2 |an integer .
result-integer |an integer .
Description:
boole performs bit-wise logical operations on integer-1 and integer-2 , which are treated as if they
were binary and in two's complement representation.
The operation to be performed and the return value are determined by op.
boole returns the values specied for any opin Figure 12{17.
Op Result
boole-1 integer-1
boole-2 integer-2
boole-andc1 and complement of integer-1 with integer-2
boole-andc2 and integer-1 with complement of integer-2
boole-and and
boole-c1 complement of integer-1
boole-c2 complement of integer-2
boole-clr always 0 (all zero bits)
boole-eqv equivalence (exclusive nor)
boole-ior inclusive or
boole-nand not-and
boole-nor not-or
boole-orc1 or complement of integer-1 with integer-2
boole-orc2 orinteger-1 with complement of integer-2
boole-set always -1 (all one bits)
boole-xor exclusive or
Figure 12–17. Bit-Wise Logical Operations
Examples:
(boole boole-ior 1 16) !17
(boole boole-and -2 5) !4
(boole boole-eqv 17 15) !-31
;;; These examples illustrate the result of applying BOOLE and each
;;; of the possible values of OP to each possible combination of bits.
(progn
(format t "~&Results of (BOOLE <op> #b0011 #b0101) ...~
~%–-Op–––-Decimal––-Binary––Bits–-~%")
(dolist (symbol ’(boole-1 boole-2 boole-and boole-andc1
boole-andc2 boole-c1 boole-c2 boole-clr
boole-eqv boole-ior boole-nand boole-nor
12–68 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
boole
boole-orc1 boole-orc2 boole-set boole-xor))
(let ((result (boole (symbol-value symbol) #b0011 #b0101)))
(format t "~& ~A~13T~3,’ D~23T~:*~5,’ B~31T ...~4,’0B~%"
symbol result (logand result #b1111)))))
.Results of (BOOLE <op> #b0011 #b0101) ...
.–-Op–––-Decimal––-Binary––Bits–-
.BOOLE-1 3 11 ...0011
.BOOLE-2 5 101 ...0101
.BOOLE-AND 1 1 ...0001
.BOOLE-ANDC1 4 100 ...0100
.BOOLE-ANDC2 2 10 ...0010
.BOOLE-C1 -4 -100 ...1100
.BOOLE-C2 -6 -110 ...1010
.BOOLE-CLR 0 0 ...0000
.BOOLE-EQV -7 -111 ...1001
.BOOLE-IOR 7 111 ...0111
.BOOLE-NAND -2 -10 ...1110
.BOOLE-NOR -8 -1000 ...1000
.BOOLE-ORC1 -3 -11 ...1101
.BOOLE-ORC2 -5 -101 ...1011
.BOOLE-SET -1 -1 ...1111
.BOOLE-XOR 6 110 ...0110
!NIL
Exceptional Situations:
Should signal type-error if its rst argument is not a bit-wise logical operation specier or if any
subsequent argument is not an integer .
See Also:
logand
Notes:
In general,
(boole boole-and x y) (logand x y)
Programmers who would prefer to use numeric indices rather than bit-wise logical operation
speciers can get an equivalent eect by a technique such as the following:
;; The order of the values in this ‘table’ are such that
;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n
(defconstant boole-n-vector
(vector boole-clr boole-and boole-andc1 boole-2
boole-andc2 boole-1 boole-xor boole-ior
boole-nor boole-eqv boole-c1 boole-orc1
Numbers 12–69
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
boole-c2 boole-orc2 boole-nand boole-set))
!BOOLE-N-VECTOR
(proclaim ’(inline boole-n))
!implementation-dependent
(defun boole-n (n integer &rest more-integers)
(apply #’boole (elt boole-n-vector n) integer more-integers))
!BOOLE-N
(boole-n #b0111 5 3) !7
(boole-n #b0001 5 3) !1
(boole-n #b1101 5 3) !-3
(loop for n from #b0000 to #b1111 collect (boole-n n 5 3))
!(0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)
boole-1,boole-2,boole-and,boole-andc1,boole-
andc2,boole-c1,boole-c2,boole-clr,boole-eqv,
boole-ior,boole-nand,boole-nor,boole-orc1,
boole-orc2,boole-set,boole-xor Constant Variable
Constant Value:
The identity and nature of the values of each of these variables isimplementation-dependent ,
except that it must be distinct from each of the values of the others, and it must be a valid rst
argument to the functionboole .
Description:
Each of these constants has a value which is one of the sixteen possible bit-wise logical operation
speciers .
Examples:
(boole boole-ior 1 16) !17
(boole boole-and -2 5) !4
(boole boole-eqv 17 15) !-31
See Also:
boole
12–70 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
logand, logandc1, logandc2, logeqv, logior, lognand, :::
logand,logandc1,logandc2,logeqv,logior,lognand,
lognor,lognot,logorc1,logorc2,logxor Function
Syntax:
logand&rest integers!result-integer
logandc1 integer-1 integer-2 !result-integer
logandc2 integer-1 integer-2 !result-integer
logeqv&rest integers!result-integer
logior&rest integers!result-integer
lognand integer-1 integer-2 !result-integer
lognor integer-1 integer-2 !result-integer
lognot integer!result-integer
logorc1 integer-1 integer-2 !result-integer
logorc2 integer-1 integer-2 !result-integer
logxor&rest integers!result-integer
Arguments and Values:
integers |integers .
integer |an integer .
integer-1 |an integer .
integer-2 |an integer .
result-integer |an integer .
Description:
The functions logandc1 ,logandc2 ,logand ,logeqv ,logior ,lognand ,lognor ,lognot ,logorc1 ,
logorc2 , andlogxor perform bit-wise logical operations on their arguments , that are treated as if
they were binary.
Figure 12{18 lists the meaning of each of the functions . Where an `identity' is shown, it indicates
thevalue yielded by the function when no arguments are supplied.
Numbers 12–71
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
logand, logandc1, logandc2, logeqv, logior, lognand, :::
Function Identity Operation performed
logandc1 | and complement of integer-1 with integer-2
logandc2 | and integer-1 with complement of integer-2
logand -1 and
logeqv -1 equivalence (exclusive nor)
logior 0 inclusive or
lognand | complement of integer-1 and integer-2
lognor | complement of integer-1 orinteger-2
lognot | complement
logorc1 | or complement of integer-1 with integer-2
logorc2 | or integer-1 with complement of integer-2
logxor 0 exclusive or
Figure 12–18. Bit-wise Logical Operations on Integers
Negative integers are treated as if they were in two's-complement notation.
Examples:
(logior 1 2 4 8) !15
(logxor 1 3 7 15) !10
(logeqv)!-1
(logand 16 31)!16
(lognot 0)!-1
(lognot 1)!-2
(lognot -1)!0
(lognot (1+ (lognot 1000))) !999
;;; In the following example, m is a mask. For each bit in
;;; the mask that is a 1, the corresponding bits in x and y are
;;; exchanged. For each bit in the mask that is a 0, the
;;; corresponding bits of x and y are left unchanged.
(flet ((show (m x y)
(format t "~%m = #o~6,’0O~%x = #o~6,’0O~%y = #o~6,’0O~%"
m x y)))
(let ((m #o007750)
(x #o452576)
(y #o317407))
(show m x y)
(let ((z (logand (logxor x y) m)))
(setq x (logxor z x))
(setq y (logxor z y))
(show m x y))))
.m = #o007750
12–72 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.x = #o452576
.y = #o317407
.
.m = #o007750
.x = #o457426
.y = #o312557
!NIL
Exceptional Situations:
Should signal type-error if any argument is not an integer .
See Also:
boole
Notes:
(logbitp k-1)returns true for all values of k.
Because the following functions are not associative, they take exactly two arguments rather than
any number of arguments.
(lognand n1 n2)(lognot (logand n1 n2))
(lognor n1 n2)(lognot (logior n1 n2))
(logandc1 n1 n2)(logand (lognot n1)n2)
(logandc2 n1 n2)(logand n1(lognot n2))
(logiorc1 n1 n2)(logior (lognot n1)n2)
(logiorc2 n1 n2)(logior n1(lognot n2))
(logbitp j(lognot x))(not (logbitp j x))
logbitp Function
Syntax:
logbitp index integer!generalized-boolean
Arguments and Values:
index |a non-negative integer .
integer |an integer .
generalized-boolean |ageneralized boolean .
Numbers 12–73
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
logbitp is used to test the value of a particular bit in integer , that is treated as if it were binary.
The value of logbitp istrue if the bit in integer whose index is index (that is, its weight is 2index)
is a one-bit; otherwise it is false.
Negative integers are treated as if they were in two's-complement notation.
Examples:
(logbitp 1 1)!false
(logbitp 0 1)!true
(logbitp 3 10)!true
(logbitp 1000000 -1) !true
(logbitp 2 6)!true
(logbitp 0 6)!false
Exceptional Situations:
Should signal an error of typetype-error ifindex is not a non-negative integer . Should signal an
error of typetype-error ifinteger is not an integer .
Notes:
(logbitp k n)(ldb-test (byte 1 k)n)
logcount Function
Syntax:
logcount integer!number-of-on-bits
Arguments and Values:
integer |an integer .
number-of-on-bits |a non-negative integer .
Description:
Computes and returns the number of bits in the two's-complement binary representation of integer
that are `on' or `set'. If integer is negative, the 0bits are counted; otherwise, the 1bits are counted.
Examples:
(logcount 0)!0
(logcount -1)!0
(logcount 7)!3
12–74 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(logcount 13)!3 ;Two’s-complement binary: ...0001101
(logcount -13)!2 ;Two’s-complement binary: ...1110011
(logcount 30)!4 ;Two’s-complement binary: ...0011110
(logcount -30)!4 ;Two’s-complement binary: ...1100010
(logcount (expt 2 100)) !1
(logcount (- (expt 2 100))) !100
(logcount (- (1+ (expt 2 100)))) !1
Exceptional Situations:
Should signal type-error if its argument is not an integer .
Notes:
Even if the implementation does not represent integers internally in two's complement binary,
logcount behaves as if it did.
The following identity always holds:
(logcount x)
(logcount (- (+ x1)))
(logcount (lognot x))
logtest Function
Syntax:
logtest integer-1 integer-2 !generalized-boolean
Arguments and Values:
integer-1 |an integer .
integer-2 |an integer .
generalized-boolean |ageneralized boolean .
Description:
Returns true if any of the bits designated by the 1's in integer-1 is 1 in integer-2 ; otherwise it is
false.integer-1 and integer-2 are treated as if they were binary.
Negative integer-1 and integer-2 are treated as if they were represented in two's-complement binary.
Examples:
(logtest 1 7)!true
(logtest 1 2)!false
Numbers 12–75
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(logtest -2 -1) !true
(logtest 0 -1)!false
Exceptional Situations:
Should signal an error of typetype-error ifinteger-1 is not an integer . Should signal an error of
typetype-error ifinteger-2 is not an integer .
Notes:
(logtest x y)(not (zerop (logand x y)))
byte,byte-size,byte-position Function
Syntax:
byte size position!bytespec
byte-size bytespec!size
byte-position bytespec!position
Arguments and Values:
size,position |a non-negative integer .
bytespec |abyte specier .
Description:
byte returns a byte specier that indicates a byte of width sizeand whose bits have weights
2position +size 1through 2position, and whose representation is implementation-dependent .
byte-size returns the number of bits specied by bytespec .
byte-position returns the position specied by bytespec .
Examples:
(setq b (byte 100 200)) !#<BYTE-SPECIFIER size 100 position 200>
(byte-size b)!100
(byte-position b) !200
See Also:
ldb,dpb
12–76 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(byte-size (byte j k))j
(byte-position (byte j k))k
Abyte ofsizeof0is permissible; it refers to a byte of width zero. For example,
(ldb (byte 0 3) #o7777) !0
(dpb #o7777 (byte 0 3) 0) !0
deposit-ﬁeld Function
Syntax:
deposit-ﬁeld newbyte bytespec integer !result-integer
Arguments and Values:
newbyte |an integer .
bytespec |abyte specier .
integer |an integer .
result-integer |an integer .
Description:
Replaces a eld of bits within integer ; specically, returns an integer that contains the bits of
newbyte within the byte specied by bytespec , and elsewhere contains the bits of integer .
Examples:
(deposit-field 7 (byte 2 1) 0) !6
(deposit-field -1 (byte 4 0) 0) !15
(deposit-field 0 (byte 2 1) -3) !-7
See Also:
byte,dpb
Notes:
(logbitp j(deposit-field m(byte s p)n))
(if (and (>= j p) (< j(+p s)))
(logbitp j m)
(logbitp j n))
Numbers 12–77
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deposit-ﬁeld is tomask-ﬁeld asdpb is toldb.
dpb Function
Syntax:
dpb newbyte bytespec integer !result-integer
Pronunciation:
[dpib]or[dpb]or[d—ep—eb—e]
Arguments and Values:
newbyte |an integer .
bytespec |abyte specier .
integer |an integer .
result-integer |an integer .
Description:
dpb (deposit byte) is used to replace a eld of bits within integer .dpb returns an integer that is
the same as integer except in the bits specied by bytespec .
Letsbe the size specied by bytespec ; then the low sbits of newbyte appear in the result in the
byte specied by bytespec .Newbyte is interpreted as being right-justied, as if it were the result of
ldb.
Examples:
(dpb 1 (byte 1 10) 0) !1024
(dpb -2 (byte 2 10) 0) !2048
(dpb 1 (byte 2 10) 2048) !1024
See Also:
byte,deposit-ﬁeld ,ldb
Notes:
(logbitp j(dpb m(byte s p)n))
(if (and (>= j p) (< j(+p s)))
(logbitp (- j p)m)
(logbitp j n))
In general,
12–78 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(dpb x(byte 0 y)z)!z
for all valid values of x,y, and z.
Historically, the name \dpb" comes from a DEC PDP-10 assembly language instruction meaning
\deposit byte."
ldb Accessor
Syntax:
ldb bytespec integer !byte
(setf (ldb bytespec place )new-byte)
Pronunciation:
[lidib ]or[lidb]or[eld—eb—e]
Arguments and Values:
bytespec |abyte specier .
integer |an integer .
byte,new-byte |a non-negative integer .
Description:
ldbextracts and returns the byte ofinteger specied by bytespec .
ldbreturns an integer in which the bits with weights 2(s 1)through 20are the same as those in
integer with weights 2(p+s 1)through 2p, and all other bits zero; sis(byte-size bytespec )and p
is(byte-position bytespec ).
setf may be used with ldbto modify a byte within the integer that is stored in a given place . The
order of evaluation, when an ldbform is supplied to setf, is exactly left-to-right. The eect is to
perform a dpb operation and then store the result back into the place .
Examples:
(ldb (byte 2 1) 10) !1
(setq a (list 8)) !(8)
(setf (ldb (byte 2 1) (car a)) 1) !1
a!(10)
See Also:
byte,byte-position ,byte-size ,dpb
Numbers 12–79
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(logbitp j(ldb (byte s p)n))
(and (< j s) (logbitp (+ j p)n))
In general,
(ldb (byte 0 x)y)!0
for all valid values of xand y.
Historically, the name \ldb" comes from a DEC PDP-10 assembly language instruction meaning
\load byte."
ldb-test Function
Syntax:
ldb-test bytespec integer !generalized-boolean
Arguments and Values:
bytespec |abyte specier .
integer |an integer .
generalized-boolean |ageneralized boolean .
Description:
Returns true if any of the bits of the byte in integer specied by bytespec is non-zero; otherwise
returns false.
Examples:
(ldb-test (byte 4 1) 16) !true
(ldb-test (byte 3 1) 16) !false
(ldb-test (byte 3 2) 16) !true
See Also:
byte,ldb,zerop
Notes:
(ldb-test bytespec n) 
(not (zerop (ldb bytespec n))) 
(logtest (ldb bytespec -1) n)
12–80 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
mask-ﬁeld Accessor
Syntax:
mask-ﬁeld bytespec integer !masked-integer
(setf (mask-ﬁeld bytespec place )new-masked-integer )
Arguments and Values:
bytespec |abyte specier .
integer |an integer .
masked-integer ,new-masked-integer |a non-negative integer .
Description:
mask-ﬁeld performs a \mask" operation on integer . It returns an integer that has the same bits
asinteger in the byte specied by bytespec , but that has zero-bits everywhere else.
setf may be used with mask-ﬁeld to modify a byte within the integer that is stored in a given
place . The eect is to perform a deposit-ﬁeld operation and then store the result back into the
place .
Examples:
(mask-field (byte 1 5) -1) !32
(setq a 15)!15
(mask-field (byte 2 0) a) !3
a!15
(setf (mask-field (byte 2 0) a) 1) !1
a!13
See Also:
byte,ldb
Notes:
(ldb bs(mask-field bs n))(ldb bs n)
(logbitp j(mask-field (byte s p)n))
(and (>= j p) (< j s) (logbitp j n))
(mask-field bs n)(logand n(dpb -1 bs0))
Numbers 12–81
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
most-positive-ﬁxnum,most-negative-ﬁxnum Constant
Variable
Constant Value:
implementation-dependent .
Description:
most-positive-ﬁxnum is that xnum closest in value to positive innity provided by the
implementation, and greater than or equal to both 215- 1 andarray-dimension-limit .
most-negative-ﬁxnum is that xnum closest in value to negative innity provided by the
implementation, and less than or equal to  215.
decode-ﬂoat,scale-ﬂoat,ﬂoat-radix,ﬂoat-sign,
ﬂoat-digits,ﬂoat-precision,integer-decode-ﬂoat
Function
Syntax:
decode-ﬂoat oat!signicand, exponent, sign
scale-ﬂoat oat integer!scaled-oat
ﬂoat-radix oat!oat-radix
ﬂoat-sign oat-1&optional oat-2!signed-oat
ﬂoat-digits oat!digits1
ﬂoat-precision oat!digits2
integer-decode-ﬂoat oat!signicand, exponent, integer-sign
Arguments and Values:
digits1 |a non-negative integer .
digits2 |a non-negative integer .
exponent |an integer .
oat|aoat.
oat-1 |aoat.
oat-2 |aoat.
12–82 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
decode-ﬂoat, scale-ﬂoat, ﬂoat-radix, ﬂoat-sign, :::
oat-radix |an integer .
integer |a non-negative integer .
integer-sign |the integer-1, or the integer1.
scaled-oat |aoat.
sign|A oat of the same type asoat but numerically equal to 1.0or-1.0.
signed-oat |aoat.
signicand |aoat.
Description:
decode-ﬂoat computes three values that characterize oat. The rst value is of the same type as
oat and represents the signicand. The second value represents the exponent to which the radix
(notated in this description by b) must be raised to obtain the value that, when multiplied with the
rst result, produces the absolute value of oat. Ifoat is zero, any integer value may be returned,
provided that the identity shown for scale-ﬂoat holds. The third value is of the same type asoat
and is 1.0 if oat is greater than or equal to zero or -1.0 otherwise.
decode-ﬂoat divides oat by an integral power of bso as to bring its value between 1=b(inclusive)
and1(exclusive), and returns the quotient as the rst value. If oat is zero, however, the result
equals the absolute value of oat (that is, if there is a negative zero, its signicand is considered to
be a positive zero).
scale-ﬂoat returns(*oat(expt (float boat)integer)), where bis the radix of the oating-
point representation. oat is not necessarily between 1=band1.
ﬂoat-radix returns the radix of oat.
ﬂoat-sign returns a number zsuch that zand oat-1 have the same sign and also such that z
and oat-2 have the same absolute value. If oat-2 is not supplied, its value is (float 1 oat-1).
If an implementation has distinct representations for negative zero and positive zero, then
(float-sign -0.0) !-1.0.
ﬂoat-digits returns the number of radix bdigits used in the representation of oat (including any
implicit digits, such as a \hidden bit").
ﬂoat-precision returns the number of signicant radix bdigits present in oat; ifoat is aoat
zero, then the result is an integer zero.
Fornormalized oats , the results of ﬂoat-digits andﬂoat-precision are the same, but the precision
is less than the number of representation digits for a denormalized or zero number.
integer-decode-ﬂoat computes three values that characterize oat - the signicand scaled so as
to be an integer , and the same last two values that are returned by decode-ﬂoat . Ifoat is zero,
integer-decode-ﬂoat returns zero as the rst value. The second value bears the same relationship
Numbers 12–83
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
decode-ﬂoat, scale-ﬂoat, ﬂoat-radix, ﬂoat-sign, :::
to the rst value as for decode-ﬂoat :
(multiple-value-bind (signif expon sign)
(integer-decode-float f)
(scale-float (float signif f) expon)) (abs f)
Examples:
;; Note that since the purpose of this functionality is to expose
;; details of the implementation, all of these examples are necessarily
;; very implementation-dependent. Results may vary widely.
;; Values shown here are chosen consistently from one particular implementation.
(decode-float .5) !0.5, 0, 1.0
(decode-float 1.0) !0.5, 1, 1.0
(scale-float 1.0 1) !2.0
(scale-float 10.01 -2) !2.5025
(scale-float 23.0 0) !23.0
(float-radix 1.0) !2
(float-sign 5.0) !1.0
(float-sign -5.0) !-1.0
(float-sign 0.0) !1.0
(float-sign 1.0 0.0) !0.0
(float-sign 1.0 -10.0) !10.0
(float-sign -1.0 10.0) !-10.0
(float-digits 1.0) !24
(float-precision 1.0) !24
(float-precision least-positive-single-float) !1
(integer-decode-float 1.0) !8388608, -23, 1
Aﬀected By:
The implementation's representation for oats .
Exceptional Situations:
The functions decode-ﬂoat ,ﬂoat-radix ,ﬂoat-digits ,ﬂoat-precision , andinteger-decode-ﬂoat
should signal an error if their only argument is not a oat.
The function scale-ﬂoat should signal an error if its rst argument is not a oat or if its second
argument is not an integer .
The function ﬂoat-sign should signal an error if its rst argument is not a oat or if its second
argument is supplied but is not a oat.
Notes:
The product of the rst result of decode-ﬂoat orinteger-decode-ﬂoat , of the radix raised to the
power of the second result, and of the third result is exactly equal to the value of oat.
(multiple-value-bind (signif expon sign)
12–84 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(decode-float f)
(scale-float signif expon))
(abs f)
and
(multiple-value-bind (signif expon sign)
(decode-float f)
(* (scale-float signif expon) sign))
f
ﬂoat Function
Syntax:
ﬂoat number&optional prototype!oat
Arguments and Values:
number |areal.
prototype |aoat.
oat|aoat.
Description:
ﬂoat converts a realnumber to a oat.
If a prototype is supplied, a oat is returned that is mathematically equal to number but has the
same format as prototype .
Ifprototype is not supplied, then if the number is already a oat, it is returned; otherwise, a oat
is returned that is mathematically equal to number but is a single oat .
Examples:
(float 0)!0.0
(float 1 .5)!1.0
(float 1.0)!1.0
(float 1/2)!0.5
!1.0d0or!1.0
(eql (float 1.0 1.0d0) 1.0d0) !true
Numbers 12–85
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
coerce
ﬂoatp Function
Syntax:
ﬂoatp object
generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typeﬂoat; otherwise, returns false.
Examples:
(floatp 1.2d2)!true
(floatp 1.212)!true
(floatp 1.2s2)!true
(floatp (expt 2 130)) !false
Notes:
(floatp object)(typep object’float)
12–86 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
most-positive-short-ﬂoat, least-positive-short-ﬂoat, :::
most-positive-short-ﬂoat,least-positive-short-
ﬂoat,least-positive-normalized-short-ﬂoat,most-
positive-double-ﬂoat,least-positive-double-ﬂoat,
least-positive-normalized-double-ﬂoat,most-
positive-long-ﬂoat,least-positive-long-ﬂoat,least-
positive-normalized-long-ﬂoat,most-positive-
single-ﬂoat,least-positive-single-ﬂoat,least-
positive-normalized-single-ﬂoat,most-negative-
short-ﬂoat,least-negative-short-ﬂoat,least-
negative-normalized-short-ﬂoat,most-negative-
single-ﬂoat,least-negative-single-ﬂoat,least-
negative-normalized-single-ﬂoat,most-negative-
double-ﬂoat,least-negative-double-ﬂoat,least-
negative-normalized-double-ﬂoat,most-negative-
long-ﬂoat,least-negative-long-ﬂoat,least-negative-
normalized-long-ﬂoat Constant
Variable
Constant Value:
implementation-dependent .
Description:
These constant variables provide a way for programs to examine the implementation-dened limits
for the various oat formats.
Of these variables , each which has \ -normalized " in its name must have a value which is a
normalized oat , and each which does not have \ -normalized " in its name may have a value which
is either a normalized oat or a denormalized oat , as appropriate.
Of these variables , each which has \ short-float " in its name must have a value which is a short
oat, each which has \ single-float " in its name must have a value which is a single oat , each
which has \ double-float " in its name must have a value which is a double oat , and each which
has \long-float " in its name must have a value which is a long oat .
most-positive-short-ﬂoat ,most-positive-single-ﬂoat ,
most-positive-double-ﬂoat ,most-positive-long-ﬂoat
Each of these constant variables has as its value the positive oat of the largest magnitude
Numbers 12–87
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(closest in value to, but not equal to, positive innity) for the oat format implied by its
name.
least-positive-short-ﬂoat ,least-positive-normalized-short-ﬂoat ,
least-positive-single-ﬂoat ,least-positive-normalized-single-ﬂoat ,
least-positive-double-ﬂoat ,least-positive-normalized-double-ﬂoat ,
least-positive-long-ﬂoat ,least-positive-normalized-long-ﬂoat
Each of these constant variables has as its value the smallest positive (nonzero) oat for
the oat format implied by its name.
least-negative-short-ﬂoat ,least-negative-normalized-short-ﬂoat ,
least-negative-single-ﬂoat ,least-negative-normalized-single-ﬂoat ,
least-negative-double-ﬂoat ,least-negative-normalized-double-ﬂoat ,
least-negative-long-ﬂoat ,least-negative-normalized-long-ﬂoat
Each of these constant variables has as its value the negative (nonzero) oat of the smallest
magnitude for the oat format implied by its name. (If an implementation supports minus
zero as a dierent object from positive zero, this value must not be minus zero.)
most-negative-short-ﬂoat ,most-negative-single-ﬂoat ,
most-negative-double-ﬂoat ,most-negative-long-ﬂoat
Each of these constant variables has as its value the negative oat of the largest magnitude
(closest in value to, but not equal to, negative innity) for the oat format implied by its
name.
Notes:
short-ﬂoat-epsilon,short-ﬂoat-negative-epsilon,
single-ﬂoat-epsilon,single-ﬂoat-negative-epsilon,
double-ﬂoat-epsilon,double-ﬂoat-negative-epsilon,
long-ﬂoat-epsilon,long-ﬂoat-negative-epsilon Con-
stant Variable
Constant Value:
implementation-dependent .
Description:
The value of each of the constants short-ﬂoat-epsilon ,single-ﬂoat-epsilon ,double-ﬂoat-epsilon ,
andlong-ﬂoat-epsilon is the smallest positive oatof the given format, such that the following
expression is true when evaluated:
12–88 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(not (= (float 1 ) (+ (float 1 ))))
The value of each of the constants short-ﬂoat-negative-epsilon ,single-ﬂoat-negative-epsilon ,
double-ﬂoat-negative-epsilon , andlong-ﬂoat-negative-epsilon is the smallest positive oatof
the given format, such that the following expression is true when evaluated:
(not (= (float 1 ) (- (float 1 ))))
arithmetic-error Condition Type
Class Precedence List:
arithmetic-error ,error ,serious-condition ,condition ,t
Description:
The typearithmetic-error consists of error conditions that occur during arithmetic operations.
The operation and operands are initialized with the initialization arguments named :operation
and:operands tomake-condition , and are accessed by the functions arithmetic-error-operation
andarithmetic-error-operands .
See Also:
arithmetic-error-operation ,arithmetic-error-operands
arithmetic-error-operands,arithmetic-error-
operation Function
Syntax:
arithmetic-error-operands condition!operands
arithmetic-error-operation condition!operation
Arguments and Values:
condition |acondition oftypearithmetic-error .
operands |alist.
operation |afunction designator .
Description:
arithmetic-error-operands returns a listof the operands which were used in the oending call to
the operation that signaled the condition .
Numbers 12–89
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
arithmetic-error-operation returns a listof the oending operation in the oending call that
signaled the condition .
See Also:
arithmetic-error , Chapter 9 (Conditions)
Notes:
division-by-zero Condition Type
Class Precedence List:
division-by-zero ,arithmetic-error ,error ,serious-condition ,condition ,t
Description:
The typedivision-by-zero consists of error conditions that occur because of division by zero.
ﬂoating-point-invalid-operation Condition Type
Class Precedence List:
ﬂoating-point-invalid-operation ,arithmetic-error ,error ,serious-condition ,condition ,t
Description:
The typeﬂoating-point-invalid-operation consists of error conditions that occur because of certain
oating point traps.
It is implementation-dependent whether oating point traps occur, and whether or how they may
be enabled or disabled. Therefore, conforming code may establish handlers for this condition, but
must not depend on its being signaled .
12–90 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬂoating-point-inexact Condition Type
Class Precedence List:
ﬂoating-point-inexact ,arithmetic-error ,error ,serious-condition ,condition ,t
Description:
The typeﬂoating-point-inexact consists of error conditions that occur because of certain oating
point traps.
It is implementation-dependent whether oating point traps occur, and whether or how they may
be enabled or disabled. Therefore, conforming code may establish handlers for this condition, but
must not depend on its being signaled .
ﬂoating-point-overﬂow Condition Type
Class Precedence List:
ﬂoating-point-overﬂow ,arithmetic-error ,error ,serious-condition ,condition ,t
Description:
The typeﬂoating-point-overﬂow consists of error conditions that occur because of oating-point
overow.
ﬂoating-point-underﬂow Condition Type
Class Precedence List:
ﬂoating-point-underﬂow ,arithmetic-error ,error ,serious-condition ,condition ,t
Description:
The typeﬂoating-point-underﬂow consists of error conditions that occur because of oating-point
underow.
Numbers 12–91
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
12–92 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
13. Characters
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Characters iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13.1 Character Concepts
13.1.1 Introduction to Characters
Acharacter is an object that represents a unitary token ( e.g., a letter, a special symbol, or a
\control character") in an aggregate quantity of text ( e.g., astring or a text stream ).
Common Lisp allows an implementation to provide support for international language characters
as well as characters used in specialized arenas ( e.g., mathematics).
The following gures contain lists of dened names applicable to characters .
Figure 13{1 lists some dened names relating to character attributes and character predicates .
alpha-char-p char-not-equal char >
alphanumericp char-not-greaterp char >=
both-case-p char-not-lessp digit-char-p
char-code-limit char/= graphic-char-p
char-equal char < lower-case-p
char-greaterp char <= standard-char-p
char-lessp char= upper-case-p
Figure 13–1. Character deﬁned names – 1
Figure 13{2 lists some character construction and conversion dened names .
char-code char-name code-char
char-downcase char-upcase digit-char
char-int character name-char
Figure 13–2. Character deﬁned names – 2
13.1.2 Introduction to Scripts and Repertoires
Characters 13–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13.1.2.1 Character Scripts
Ascript is one of possibly several sets that form an exhaustive partition of the type character .
The number of such sets and boundaries between them is implementation-dened . Common Lisp
does not require these sets to be types , but an implementation is permitted to dene such types
as an extension. Since no character from one script can ever be a member of another script , it is
generally more useful to speak about character repertoires .
Although the term \ script " is chosen for denitional compatibility with ISO terminology, no
conforming implementation is required to use any particular scripts standardized by ISO or by any
other standards organization.
Whether and how the script orscripts used by any given implementation are named is
implementation-dependent .
13.1.2.2 Character Repertoires
Arepertoire is atype specier for a subtype oftypecharacter . This term is generally used when
describing a collection of characters independent of their coding. Characters inrepertoires are only
identied by name, by glyph , or by character description.
Arepertoire can contain characters from several scripts , and a character can appear in more than
onerepertoire .
For some examples of repertoires , see the coded character standards ISO 8859/1, ISO 8859/2,
and ISO 6937/2. Note, however, that although the term \ repertoire " is chosen for denitional
compatibility with ISO terminology, no conforming implementation is required to use repertoires
standardized by ISO or any other standards organization.
13.1.3 Character Attributes
Characters have only one standardized attribute : acode. A character 'scode is a non-negative
integer . This code is composed from a character script and a character label in an implementation-
dependent way. See the functions char-code andcode-char .
Additional, implementation-dened attributes ofcharacters are also permitted so that, for example,
twocharacters with the same code may dier in some other, implementation-dened way.
For any implementation-dened attribute there is a distinguished value called the null value for
that attribute . Acharacter for which each implementation-dened attribute has the null value for
that attribute is called a simple character . If the implementation has no implementation-dened
attributes , then all characters aresimple characters .
13–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13.1.4 Character Categories
There are several (overlapping) categories of characters that have no formally associated type but
that are nevertheless useful to name. They include graphic characters ,alphabetic 1characters ,
characters with case (uppercase and lowercase characters ),numeric characters ,alphanumeric
characters , and digits (in a given radix ).
For each implementation-dened attribute of a character , the documentation for that implementa-
tion must specify whether characters that dier only in that attribute are permitted to dier in
whether are not they are members of one of the aforementioned categories.
Note that these terms are dened independently of any special syntax which might have been
enabled in the current readtable .
13.1.4.1 Graphic Characters
Characters that are classied as graphic , or displayable, are each associated with a glyph, a visual
representation of the character .
Agraphic character is one that has a standard textual representation as a single glyph , such as A
or*or=.Space , which eectively has a blank glyph , is dened to be a graphic .
Of the standard characters ,newline isnon-graphic and all others are graphic ; see Section 2.1.3
(Standard Characters).
Characters that are not graphic are called non-graphic .Non-graphic characters are sometimes
informally called \formatting characters" or \control characters."
#\Backspace ,#\Tab ,#\Rubout ,#\Linefeed ,#\Return , and#\Page , if they are supported by the
implementation , are non-graphic .
13.1.4.2 Alphabetic Characters
The alphabetic 1characters are a subset of the graphic characters . Of the standard characters , only
these are the alphabetic 1characters :
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
a b c d e f g h i j k l m n o p q r s t u v w x y z
Any implementation-dened character that has case must be alphabetic 1. For each implementation-
dened graphic character that has no case, it is implementation-dened whether that character is
alphabetic 1.
13.1.4.3 Characters With Case
The characters with case are a subset of the alphabetic 1characters . A character with case has
the property of being either uppercase orlowercase . Every character with case is in one-to-one
correspondence with some other character with the opposite case.
Characters 13–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13.1.4.3.1 Uppercase Characters
An uppercase character is one that has a corresponding lowercase character that is dierent (and
can be obtained using char-downcase ).
Of the standard characters , only these are uppercase characters :
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
13.1.4.3.2 Lowercase Characters
A lowercase character is one that has a corresponding uppercase character that is dierent (and
can be obtained using char-upcase ).
Of the standard characters , only these are lowercase characters :
a b c d e f g h i j k l m n o p q r s t u v w x y z
13.1.4.3.3 Corresponding Characters in the Other Case
The uppercase standard characters Athrough Zmentioned above respectively correspond to the
lowercase standard characters athrough zmentioned above. For example, the uppercase character
Ecorresponds to the lowercase character e, and vice versa.
13.1.4.3.4 Case of Implementation-Deﬁned Characters
Animplementation may dene that other implementation-dened graphic characters have
case. Such denitions must always be done in pairs|one uppercase character in one-to-one
correspondence with one lowercase character .
13.1.4.4 Numeric Characters
The numeric characters are a subset of the graphic characters . Of the standard characters , only
these are numeric characters :
0 1 2 3 4 5 6 7 8 9
For each implementation-dened graphic character that has no case, the implementation must
dene whether or not it is a numeric character .
13.1.4.5 Alphanumeric Characters
The set of alphanumeric characters is the union of the set of alphabetic 1characters and the set of
numeric characters .
13–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13.1.4.6 Digits in a Radix
What qualies as a digit depends on the radix (aninteger between 2and36, inclusive). The
potential digits are:
0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
Their respective weights are 0,1,2,:::35. In any given radix n, only the rst npotential digits
are considered to be digits . For example, the digits in radix 2are0and1, the digits in radix 10are
0through 9, and the digits in radix 16are0through F.
Case is not signicant in digits ; for example, in radix 16, bothFandfaredigits with weight 15.
13.1.5 Identity of Characters
Two characters that areeql,char= , orchar-equal are not necessarily eq.
13.1.6 Ordering of Characters
The total ordering on characters is guaranteed to have the following properties:
If two characters have the same implementation-dened attributes , then their ordering by
char <is consistent with the numerical ordering by the predicate <on their code attributes .
If two characters dier in any attribute , then they are not char= .
The total ordering is not necessarily the same as the total ordering on the integers
produced by applying char-int to the characters .
While alphabetic 1standard characters of a given case must obey a partial ordering, they
need not be contiguous; it is permissible for uppercase and lowercase characters to be
interleaved. Thus (char<= #\a x #\z) is not a valid way of determining whether or not x
is alowercase character .
Of the standard characters , those which are alphanumeric obey the following partial ordering:
A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z
a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z
0<1<2<3<4<5<6<7<8<9
either 9<A or Z<0
either 9<a or z<0
This implies that, for standard characters ,alphabetic 1ordering holds within each case (uppercase
and lowercase ), and that the numeric characters as a group are not interleaved with alphabetic
characters . However, the ordering or possible interleaving of uppercase characters and lowercase
characters isimplementation-dened .
Characters 13–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13.1.7 Character Names
The following character names must be present in all conforming implementations :
Newline
The character that represents the division between lines. An implementation must
translate between #\Newline , a single-character representation, and whatever external
representation(s) may be used.
Space
The space or blank character.
The following names are semi-standard ; if an implementation supports them, they should be used
for the described characters and no others.
Rubout
The rubout or delete character.
Page
The form-feed or page-separator character.
Tab
The tabulate character.
Backspace
The backspace character.
Return
The carriage return character.
Linefeed
The line-feed character.
In some implementations , one or more of these character names might denote a standard character ;
for example, #\Linefeed and#\Newline might be the same character in some implementations .
13–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13.1.8 Treatment of Newline during Input and Output
When the character #\Newline is written to an output le, the implementation must take the
appropriate action to produce a line division. This might involve writing out a record or translating
#\Newline to a CR/LF sequence. When reading, a corresponding reverse transformation must take
place.
13.1.9 Character Encodings
Acharacter is sometimes represented merely by its code, and sometimes by another integer value
which is composed from the code and all implementation-dened attributes (in an implementation-
dened way that might vary between Lisp images even in the same implementation ). This integer ,
returned by the function char-int , is called the character's \encoding." There is no corresponding
function from a character's encoding back to the character , since its primary intended uses include
things like hashing where an inverse operation is not really called for.
13.1.10 Documentation of Implementation-Deﬁned Scripts
Animplementation must document the character scripts it supports. For each character script
supported, the documentation must describe at least the following:
Character labels, glyphs, and descriptions. Character labels must be uniquely named using
only Latin capital letters A{Z, hyphen (-), and digits 0{9.
Reader canonicalization. Any mechanisms by which read treats dierent characters as
equivalent must be documented.
The impact on char-upcase ,char-downcase , and the case-sensitive format directives . In
particular, for each character with case, whether it is uppercase orlowercase , and which
character is its equivalent in the opposite case.
The behavior of the case-insensitive functions char-equal ,char-not-equal ,char-lessp ,
char-greaterp ,char-not-greaterp , andchar-not-lessp .
The behavior of any character predicates ; in particular, the eects of alpha-char-p ,
lower-case-p ,upper-case-p ,both-case-p ,graphic-char-p , andalphanumericp .
The interaction with le I/O, in particular, the supported coded character sets (for
example, ISO8859/1-1987) and external encoding schemes supported are documented.
Characters 13–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
character System Class
Class Precedence List:
character ,t
Description:
Acharacter is an object that represents a unitary token in an aggregate quantity of text; see
Section 13.1 (Character Concepts).
The typesbase-char andextended-char form an exhaustive partition of the typecharacter .
See Also:
Section 13.1 (Character Concepts), Section 2.4.8.1 (Sharpsign Backslash), Section 22.1.3.2 (Printing
Characters)
base-char Type
Supertypes:
base-char ,character ,t
Description:
The typebase-char is dened as the upgraded array element type ofstandard-char . An
implementation can support additional subtypes oftypecharacter (besides the ones listed in this
standard) that might or might not be supertypes oftypebase-char . In addition, an implementation
can dene base-char to be the same type ascharacter .
Base characters are distinguished in the following respects:
1. The typestandard-char is asubrepertoire of the typebase-char .
2. The selection of base characters that are not standard characters is implementation
dened.
3. Only objects of the typebase-char can be elements of a base string .
4. No upper bound is specied for the number of characters in the base-char repertoire ; the
size of that repertoire isimplementation-dened . The lower bound is 96, the number of
standard characters .
Whether a character is a base character depends on the way that an implementation represents
strings , and not any other properties of the implementation or the host operating system. For
example, one implementation might encode all strings as characters having 16-bit encodings,
and another might have two kinds of strings : those with characters having 8-bit encodings and
those with characters having 16-bit encodings. In the rst implementation , the typebase-char is
13–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
equivalent to the typecharacter : there is only one kind of string . In the second implementation ,
thebase characters might be those characters that could be stored in a string ofcharacters having
8-bit encodings. In such an implementation, the typebase-char is a proper subtype of the type
character .
The typestandard-char is asubtype oftypebase-char .
standard-char Type
Supertypes:
standard-char ,base-char ,character ,t
Description:
A xed set of 96 characters required to be present in all conforming implementations .Standard
characters are dened in Section 2.1.3 (Standard Characters).
Any character that is not simple is not a standard character .
See Also:
Section 2.1.3 (Standard Characters)
extended-char Type
Supertypes:
extended-char ,character ,t
Description:
The typeextended-char is equivalent to the type(and character (not base-char)) .
Notes:
The typeextended-char might have no elements 4inimplementations in which all characters are
oftypebase-char .
Characters 13–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
char=, char/=, char <, char>, char<=, char>=,:::
char=,char/=,char <,char>,char<=,char>=,
char-equal,char-not-equal,char-lessp,char-
greaterp,char-not-greaterp,char-not-lessp Function
Syntax:
char=&rest characters+!generalized-boolean
char==&rest characters+!generalized-boolean
char <&rest characters+!generalized-boolean
char >&rest characters+!generalized-boolean
char <=&rest characters+!generalized-boolean
char >=&rest characters+!generalized-boolean
char-equal &rest characters+!generalized-boolean
char-not-equal &rest characters+!generalized-boolean
char-lessp &rest characters+!generalized-boolean
char-greaterp &rest characters+!generalized-boolean
char-not-greaterp &rest characters+!generalized-boolean
char-not-lessp &rest characters+!generalized-boolean
Arguments and Values:
character |acharacter .
generalized-boolean |ageneralized boolean .
Description:
These predicates compare characters .
char= returns true if all characters are the same ; otherwise, it returns false. If two characters dier
in any implementation-dened attributes , then they are not char= .
char/= returns true if all characters are dierent; otherwise, it returns false.
char <returns true if the characters are monotonically increasing; otherwise, it returns false. If
two characters have identical implementation-dened attributes , then their ordering by char <is
consistent with the numerical ordering by the predicate <on their codes .
char >returns true if the characters are monotonically decreasing; otherwise, it returns false. If
two characters have identical implementation-dened attributes , then their ordering by char >is
consistent with the numerical ordering by the predicate >on their codes .
char <=returns true if the characters are monotonically nondecreasing; otherwise, it returns false.
If two characters have identical implementation-dened attributes , then their ordering by char <=
is consistent with the numerical ordering by the predicate <=on their codes .
char >=returns true if the characters are monotonically nonincreasing; otherwise, it returns false.
13–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
char=, char/=, char <, char>, char<=, char>=,:::
If two characters have identical implementation-dened attributes , then their ordering by char >=
is consistent with the numerical ordering by the predicate >=on their codes .
char-equal ,char-not-equal ,char-lessp ,char-greaterp ,char-not-greaterp , andchar-not-lessp
are similar to char= ,char/= ,char <,char >,char <=,char >=, respectively, except that they
ignore dierences in case and might have an implementation-dened behavior for non-simple
characters . For example, an implementation might dene that char-equal ,etc. ignore certain
implementation-dened attributes . The eect, if any, of each implementation-dened attribute
upon these functions must be specied as part of the denition of that attribute .
Examples:
(char= #\d #\d) !true
(char= #\A #\a) !false
(char= #\d #\x) !false
(char= #\d #\D) !false
(char/= #\d #\d) !false
(char/= #\d #\x) !true
(char/= #\d #\D) !true
(char= #\d #\d #\d #\d) !true
(char/= #\d #\d #\d #\d) !false
(char= #\d #\d #\x #\d) !false
(char/= #\d #\d #\x #\d) !false
(char= #\d #\y #\x #\c) !false
(char/= #\d #\y #\x #\c) !true
(char= #\d #\c #\d) !false
(char/= #\d #\c #\d) !false
(char< #\d #\x) !true
(char<= #\d #\x) !true
(char< #\d #\d) !false
(char<= #\d #\d) !true
(char< #\a #\e #\y #\z) !true
(char<= #\a #\e #\y #\z) !true
(char< #\a #\e #\e #\y) !false
(char<= #\a #\e #\e #\y) !true
(char> #\e #\d) !true
(char>= #\e #\d) !true
(char> #\d #\c #\b #\a) !true
(char>= #\d #\c #\b #\a) !true
(char> #\d #\d #\c #\a) !false
(char>= #\d #\d #\c #\a) !true
(char> #\e #\d #\b #\c #\a) !false
(char>= #\e #\d #\b #\c #\a) !false
(char> #\z #\A) !implementation-dependent
(char> #\Z #\a) !implementation-dependent
(char-equal #\A #\a) !true
Characters 13–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(stable-sort (list #\b #\A #\B #\a #\c #\C) #’char-lessp)
!(#\A #\a #\b #\B #\c #\C)
(stable-sort (list #\b #\A #\B #\a #\c #\C) #’char<)
!(#\A #\B #\C #\a #\b #\c) ;Implementation A
!(#\a #\b #\c #\A #\B #\C) ;Implementation B
!(#\a #\A #\b #\B #\c #\C) ;Implementation C
!(#\A #\a #\B #\b #\C #\c) ;Implementation D
!(#\A #\B #\a #\b #\C #\c) ;Implementation E
Exceptional Situations:
Should signal an error of typeprogram-error if at least one character is not supplied.
See Also:
Section 2.1 (Character Syntax), Section 13.1.10 (Documentation of Implementation-Dened
Scripts)
Notes:
If characters dier in their code attribute or any implementation-dened attribute , they are
considered to be dierent by char= .
There is no requirement that (eq c1 c2) be true merely because (char= c1 c2) istrue. Whileeq
can distinguish two characters thatchar= does not, it is distinguishing them not as characters ,
but in some sense on the basis of a lower level implementation characteristic. If (eq c1 c2) istrue,
then(char= c1 c2) is also true. eqlandequal compare characters in the same way that char=
does.
The manner in which case is used by char-equal ,char-not-equal ,char-lessp ,char-greaterp ,
char-not-greaterp , andchar-not-lessp implies an ordering for standard characters such that A=a,
B=b, and so on, up to Z=z, and furthermore either 9<AorZ<0.
character Function
Syntax:
character character!denoted-character
Arguments and Values:
character |acharacter designator .
denoted-character |acharacter .
Description:
Returns the character denoted by the character designator .
13–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(character #\a) !#\a
(character "a") !#\a
(character ’a)!#\A
(character ’\a) !#\a
(character 65.) is an error.
(character ’apple) is an error.
Exceptional Situations:
Should signal an error of typetype-error ifobject is not a character designator .
See Also:
coerce
Notes:
(character object)(coerce object’character)
characterp Function
Syntax:
characterp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typecharacter ; otherwise, returns false.
Examples:
(characterp #\a) !true
(characterp ’a) !false
(characterp "a") !false
(characterp 65.) !false
(characterp #\Newline) !true
;; This next example presupposes an implementation
;; in which #\Rubout is an implementation-defined character.
(characterp #\Rubout) !true
Characters 13–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
character (type and function ),typep
Notes:
(characterp object)(typep object’character)
alpha-char-p Function
Syntax:
alpha-char-p character!generalized-boolean
Arguments and Values:
character |acharacter .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifcharacter is an alphabetic 1character ; otherwise, returns false.
Examples:
(alpha-char-p #\a) !true
(alpha-char-p #\5) !false
(alpha-char-p #\Newline) !false
;; This next example presupposes an implementation
;; in which #\ is a defined character.
(alpha-char-p #\ )!implementation-dependent
Aﬀected By:
None. (In particular, the results of this predicate are independent of any special syntax which
might have been enabled in the current readtable .)
Exceptional Situations:
Should signal an error of typetype-error ifcharacter is not a character .
See Also:
alphanumericp , Section 13.1.10 (Documentation of Implementation-Dened Scripts)
13–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
alphanumericp Function
Syntax:
alphanumericp character!generalized-boolean
Arguments and Values:
character |acharacter .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifcharacter is an alphabetic 1character or a numeric character ; otherwise, returns
false.
Examples:
(alphanumericp #\Z) !true
(alphanumericp #\9) !true
(alphanumericp #\Newline) !false
(alphanumericp #\#) !false
Aﬀected By:
None. (In particular, the results of this predicate are independent of any special syntax which
might have been enabled in the current readtable .)
Exceptional Situations:
Should signal an error of typetype-error ifcharacter is not a character .
See Also:
alpha-char-p ,graphic-char-p ,digit-char-p
Notes:
Alphanumeric characters are graphic as dened by graphic-char-p . The alphanumeric characters
are a subset of the graphic characters. The standard characters Athrough Z,athrough z, and0
through 9are alphanumeric characters.
(alphanumericp x)
(or (alpha-char-p x) (not (null (digit-char-p x))))
Characters 13–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
digit-char Function
Syntax:
digit-char weight&optional radix!char
Arguments and Values:
weight |a non-negative integer .
radix |aradix . The default is 10.
char|acharacter orfalse.
Description:
Ifweight is less than radix ,digit-char returns a character which has that weight when considered
as a digit in the specied radix. If the resulting character is to be an alphabetic 1character , it will
be an uppercase character .
Ifweight is greater than or equal to radix ,digit-char returns false.
Examples:
(digit-char 0)!#\0
(digit-char 10 11) !#\A
(digit-char 10 10) !false
(digit-char 7)!#\7
(digit-char 12) !false
(digit-char 12 16) !#\C ;not #\c
(digit-char 6 2) !false
(digit-char 1 2) !#\1
See Also:
digit-char-p ,graphic-char-p , Section 2.1 (Character Syntax)
Notes:
digit-char-p Function
Syntax:
digit-char-p char&optional radix!weight
Arguments and Values:
char|acharacter .
13–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
radix |aradix . The default is 10.
weight |either a non-negative integer less than radix , orfalse.
Description:
Tests whether char is a digit in the specied radix (i.e., with a weight less than radix ). If it is a
digit in that radix , its weight is returned as an integer ; otherwise nilis returned.
Examples:
(digit-char-p #\5) !5
(digit-char-p #\5 2) !false
(digit-char-p #\A) !false
(digit-char-p #\a) !false
(digit-char-p #\A 11) !10
(digit-char-p #\a 11) !10
(mapcar #’(lambda (radix)
(map ’list #’(lambda (x) (digit-char-p x radix))
"059AaFGZ"))
’(2 8 10 16 36))
!((0 NIL NIL NIL NIL NIL NIL NIL)
(0 5 NIL NIL NIL NIL NIL NIL)
(0 5 9 NIL NIL NIL NIL NIL)
(0 5 9 10 10 15 NIL NIL)
(0 5 9 10 10 15 16 35))
Aﬀected By:
None. (In particular, the results of this predicate are independent of any special syntax which
might have been enabled in the current readtable .)
See Also:
alphanumericp
Notes:
Digits are graphic characters .
graphic-char-p Function
Syntax:
graphic-char-p char!generalized-boolean
Arguments and Values:
char|acharacter .
Characters 13–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
generalized-boolean |ageneralized boolean .
Description:
Returns true ifcharacter is agraphic character ; otherwise, returns false.
Examples:
(graphic-char-p #\G) !true
(graphic-char-p #\#) !true
(graphic-char-p #\Space) !true
(graphic-char-p #\Newline) !false
Exceptional Situations:
Should signal an error of typetype-error ifcharacter is not a character .
See Also:
read, Section 2.1 (Character Syntax), Section 13.1.10 (Documentation of Implementation-Dened
Scripts)
standard-char-p Function
Syntax:
standard-char-p character!generalized-boolean
Arguments and Values:
character |acharacter .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifcharacter is of typestandard-char ; otherwise, returns false.
Examples:
(standard-char-p #\Space) !true
(standard-char-p #\~) !true
;; This next example presupposes an implementation
;; in which #\Bell is a defined character.
(standard-char-p #\Bell) !false
Exceptional Situations:
Should signal an error of typetype-error ifcharacter is not a character .
13–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
char-upcase, char-downcase
char-upcase,char-downcase Function
Syntax:
char-upcase character!corresponding-character
char-downcase character!corresponding-character
Arguments and Values:
character ,corresponding-character |acharacter .
Description:
Ifcharacter is alowercase character ,char-upcase returns the corresponding uppercase character .
Otherwise, char-upcase just returns the given character .
Ifcharacter is an uppercase character ,char-downcase returns the corresponding lowercase
character . Otherwise, char-downcase just returns the given character .
The result only ever diers from character in its code attribute ; allimplementation-dened attributes
are preserved.
Examples:
(char-upcase #\a) !#\A
(char-upcase #\A) !#\A
(char-downcase #\a) !#\a
(char-downcase #\A) !#\a
(char-upcase #\9) !#\9
(char-downcase #\9) !#\9
(char-upcase #\@) !#\@
(char-downcase #\@) !#\@
;; Note that this next example might run for a very long time in
;; some implementations if CHAR-CODE-LIMIT happens to be very large
;; for that implementation.
(dotimes (code char-code-limit)
(let ((char (code-char code)))
(when char
(unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))
((lower-case-p char) (char= (char-downcase (char-upcase char)) char))
(t (and (char= (char-upcase (char-downcase char)) char)
(char= (char-downcase (char-upcase char)) char))))
(return char)))))
!NIL
Exceptional Situations:
Should signal an error of typetype-error ifcharacter is not a character .
Characters 13–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
upper-case-p ,alpha-char-p , Section 13.1.4.3 (Characters With Case), Section 13.1.10 (Documen-
tation of Implementation-Dened Scripts)
Notes:
If the corresponding-char isdierent than character , then both the character and the corresponding-
char have case.
Sincechar-equal ignores the case of the characters it compares, the corresponding-character is
always the same ascharacter underchar-equal .
upper-case-p,lower-case-p,both-case-p Function
Syntax:
upper-case-p character!generalized-boolean
lower-case-p character!generalized-boolean
both-case-p character!generalized-boolean
Arguments and Values:
character |acharacter .
generalized-boolean |ageneralized boolean .
Description:
These functions test the case of a given character .
upper-case-p returns true ifcharacter is an uppercase character ; otherwise, returns false.
lower-case-p returns true ifcharacter is alowercase character ; otherwise, returns false.
both-case-p returns true ifcharacter is acharacter with case; otherwise, returns false.
Examples:
(upper-case-p #\A) !true
(upper-case-p #\a) !false
(both-case-p #\a) !true
(both-case-p #\5) !false
(lower-case-p #\5) !false
(upper-case-p #\5) !false
;; This next example presupposes an implementation
;; in which #\Bell is an implementation-defined character.
(lower-case-p #\Bell) !false
13–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Should signal an error of typetype-error ifcharacter is not a character .
See Also:
char-upcase ,char-downcase , Section 13.1.4.3 (Characters With Case), Section 13.1.10
(Documentation of Implementation-Dened Scripts)
char-code Function
Syntax:
char-code character!code
Arguments and Values:
character |acharacter .
code|acharacter code .
Description:
char-code returns the code attribute ofcharacter .
Examples:
;; An implementation using ASCII character encoding
;; might return these values:
(char-code #\$) !36
(char-code #\a) !97
Exceptional Situations:
Should signal an error of typetype-error ifcharacter is not a character .
See Also:
char-code-limit
Characters 13–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
char-int Function
Syntax:
char-int character!integer
Arguments and Values:
character |acharacter .
integer |a non-negative integer .
Description:
Returns a non-negative integer encoding the character object. The manner in which the integer is
computed is implementation-dependent . In contrast to sxhash , the result is not guaranteed to be
independent of the particular Lisp image .
Ifcharacter has no implementation-dened attributes , the results of char-int andchar-code are
the same.
(char= c1 c2)(= (char-int c1) (char-int c2))
for characters c1and c2.
Examples:
(char-int #\A)!65 ; implementation A
(char-int #\A)!577 ; implementation B
(char-int #\A)!262145 ; implementation C
See Also:
char-code
code-char Function
Syntax:
code-char code!char-p
Arguments and Values:
code|acharacter code .
char-p |acharacter ornil.
13–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returns a character with the code attribute given by code. If no such character exists and one
cannot be created, nilis returned.
Examples:
(code-char 65.) !#\A ;in an implementation using ASCII codes
(code-char (char-code #\Space)) !#\Space ;in any implementation
Aﬀected By:
The implementation 's character encoding.
See Also:
char-code
Notes:
char-code-limit Constant Variable
Constant Value:
A non-negative integer , the exact magnitude of which is implementation-dependent , but which is
not less than 96(the number of standard characters ).
Description:
The upper exclusive bound on the value returned by the functionchar-code .
See Also:
char-code
Notes:
The value ofchar-code-limit might be larger than the actual number of characters supported by
theimplementation .
Characters 13–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
char-name
char-name Function
Syntax:
char-name character!name
Arguments and Values:
character |acharacter .
name |astring ornil.
Description:
Returns a string that is the name of the character , ornilif the character has no name .
Allnon-graphic characters are required to have names unless they have some implementation-dened
attribute which is not null. Whether or not other characters have names isimplementation-
dependent .
The standard characters hNewlineiandhSpaceihave the respective names "Newline" and"Space" .
The semi-standard characters hTabi,hPagei,hRubouti,hLinefeedi,hReturni, andhBackspacei(if
they are supported by the implementation ) have the respective names "Tab" ,"Page" ,"Rubout" ,
"Linefeed" ,"Return" , and"Backspace" (in the indicated case, even though name lookup by \ #\"
and by the functionname-char is not case sensitive).
Examples:
(char-name #\ ) !"Space"
(char-name #\Space) !"Space"
(char-name #\Page) !"Page"
(char-name #\a)
!NILor!"LOWERCASE-a"or!"Small-A"or!"LA01"
(char-name #\A)
!NILor!"UPPERCASE-A"or!"Capital-A"
or!"LA02"
;; Even though its CHAR-NAME can vary, #\A prints as #\A
(prin1-to-string (read-from-string (format nil "#\\~A" (or (char-name #\A) "A"))))
!"#\\A"
13–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Should signal an error of typetype-error ifcharacter is not a character .
See Also:
name-char , Section 22.1.3.2 (Printing Characters)
Notes:
Non-graphic characters having names are written by the Lisp printer as \#\" followed by the their
name ; see Section 22.1.3.2 (Printing Characters).
name-char Function
Syntax:
name-char name!char-p
Arguments and Values:
name |astring designator .
char-p |acharacter ornil.
Description:
Returns the character object whose name isname (as determined by string-equal |i.e., lookup is
not case sensitive). If such a character does not exist, nilis returned.
Examples:
(name-char ’space) !#\Space
(name-char "space") !#\Space
(name-char "Space") !#\Space
(let ((x (char-name #\a)))
(or (not x) (eql (name-char x) #\a))) !true
Exceptional Situations:
Should signal an error of typetype-error ifname is not a string designator .
See Also:
char-name
Characters 13–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
13–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
14. Conses
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Consesiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
14.1 Cons Concepts
Acons is a compound data object having two components called the carand the cdr.
car cons rplacd
cdr rplaca
Figure 14–1. Some deﬁned names relating to conses.
Depending on context, a group of connected conses can be viewed in a variety of dierent ways. A
variety of operations is provided to support each of these various views.
14.1.1 Conses as Trees
Atree is a binary recursive data structure made up of conses and atoms : the conses are
themselves also trees (sometimes called \subtrees" or \branches"), and the atoms are terminal
nodes (sometimes called leaves ). Typically, the leaves represent data while the branches establish
some relationship among that data.
caaaar caddar cdar nsubst
caaadr cadddr cddaar nsubst-if
caaar caddr cddadr nsubst-if-not
caadar cadr cddar nthcdr
caaddr cdaaar cdddar sublis
caadr cdaadr cddddr subst
caar cdaar cdddr subst-if
cadaar cdadar cddr subst-if-not
cadadr cdaddr copy-tree tree-equal
cadar cdadr nsublis
Figure 14–2. Some deﬁned names relating to trees.
14.1.1.1 General Restrictions on Parameters that must be Trees
Except as explicitly stated otherwise, for any standardized function that takes a parameter that is
required to be a tree, the consequences are undened if that treeis circular.
Conses14–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
14.1.2 Conses as Lists
Alistis a chain of conses in which the carof each cons is an element of the list, and the cdrof
each cons is either the next link in the chain or a terminating atom .
Aproper list is alistterminated by the empty list . The empty list is aproper list , but is not a
cons.
Animproper list is alistthat is not a proper list ; that is, it is a circular list or a dotted list .
Adotted list is alistthat has a terminating atom that is not the empty list . Anon-nil atom by
itself is not considered to be a listof any kind|not even a dotted list .
Acircular list is a chain of conses that has no termination because some cons in the chain is the
cdrof a later cons.
append last nbutlast rest
butlast ldiﬀ nconc revappend
copy-alist list ninth second
copy-list list* nreconc seventh
eighth list-length nth sixth
endp make-list nthcdr tailp
ﬁfth member pop tenth
ﬁrst member-if push third
fourth member-if-not pushnew
Figure 14–3. Some deﬁned names relating to lists.
14.1.2.1 Lists as Association Lists
Anassociation list is alistofconses representing an association of keys with values , where the
carof each cons is the keyand the cdris the value associated with that key.
acons assoc-if pairlis rassoc-if
assoc assoc-if-not rassoc rassoc-if-not
Figure 14–4. Some deﬁned names related to assocation lists.
14–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
14.1.2.2 Lists as Sets
Lists are sometimes viewed as sets by considering their elements unordered and by assuming there
is no duplication of elements.
adjoin nset-diﬀerence set-diﬀerence union
intersection nset-exclusive-or set-exclusive-or
nintersection nunion subsetp
Figure 14–5. Some deﬁned names related to sets.
14.1.2.3 General Restrictions on Parameters that must be Lists
Except as explicitly specied otherwise, any standardized function that takes a parameter that is
required to be a listshould be prepared to signal an error of typetype-error if the value received
is adotted list .
Except as explicitly specied otherwise, for any standardized function that takes a parameter that
is required to be a list, the consequences are undened if that listiscircular .
Conses14–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
list System Class
Class Precedence List:
list,sequence ,t
Description:
Alistis a chain of conses in which the carof each cons is an element of the list, and the cdrof
each cons is either the next link in the chain or a terminating atom .
Aproper list is a chain of conses terminated by the empty list ,(), which is itself a proper list .
Adotted list is alistwhich has a terminating atom that is not the empty list . Acircular list is
a chain of conses that has no termination because some cons in the chain is the cdrof a later cons.
Dotted lists and circular lists are also lists, but usually the unqualied term \list" within this
specication means proper list . Nevertheless, the typelistunambiguously includes dotted lists and
circular lists .
For each element of a listthere is a cons. The empty list has no elements and is not a cons.
The typescons andnullform an exhaustive partition of the typelist.
See Also:
Section 2.4.1 (Left-Parenthesis), Section 22.1.3.5 (Printing Lists and Conses)
null System Class
Class Precedence List:
null,symbol ,list,sequence ,t
Description:
The only object oftypenullisnil, which represents the empty list and can also be notated ().
See Also:
Section 2.3.4 (Symbols as Tokens), Section 2.4.1 (Left-Parenthesis), Section 22.1.3.3 (Printing
Symbols)
14–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
cons System Class
Class Precedence List:
cons,list,sequence ,t
Description:
Acons is a compound object having two components, called the carand cdr. These form a dotted
pair. Each component can be any object .
Compound Type Speciﬁer Kind:
Specializing.
Compound Type Speciﬁer Syntax:
(cons [ car-typespec [cdr-typespec ]])
Compound Type Speciﬁer Arguments:
car-typespec |atype specier , or the symbol*. The default is the symbol*.
cdr-typespec |atype specier , or the symbol*. The default is the symbol*.
Compound Type Speciﬁer Description:
This denotes the set of conses whose caris constrained to be of type car-typespec and whose cdr
is constrained to be of type cdr-typespec . (If either car-typespec orcdr-typespec is*, it is as if the
typethad been denoted.)
See Also:
Section 2.4.1 (Left-Parenthesis), Section 22.1.3.5 (Printing Lists and Conses)
atom Type
Supertypes:
atom ,t
Description:
It is equivalent to (not cons) .
Conses14–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
cons Function
Syntax:
cons object-1 object-2 !cons
Arguments and Values:
object-1 |an object .
object-2 |an object .
cons|acons.
Description:
Creates a fresh cons , the carof which is object-1 and the cdrof which is object-2 .
Examples:
(cons 1 2)!(1 . 2)
(cons 1 nil)!(1)
(cons nil 2)!(NIL . 2)
(cons nil nil)!(NIL)
(cons 1 (cons 2 (cons 3 (cons 4 nil)))) !(1 2 3 4)
(cons ’a ’b)!(A . B)
(cons ’a (cons ’b (cons ’c ’()))) !(A B C)
(cons ’a ’(b c d)) !(A B C D)
See Also:
list
Notes:
Ifobject-2 is alist,cons can be thought of as producing a new listwhich is like it but has object-1
prepended.
consp Function
Syntax:
consp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
14–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returns true ifobject is of typecons; otherwise, returns false.
Examples:
(consp nil)!false
(consp (cons 1 2)) !true
The empty list is not a cons, so
(consp ’())(consp ’nil)!false
See Also:
listp
Notes:
(consp object)(typep object’cons)(not (typep object’atom))(typep object’(not
atom))
atom Function
Syntax:
atom object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typeatom ; otherwise, returns false.
Examples:
(atom ’sss)!true
(atom (cons 1 2)) !false
(atom nil)!true
(atom ’())!true
(atom 3)!true
Conses14–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(atom object)(typep object’atom)(not (consp object))
(not (typep object’cons))(typep object’(not cons))
rplaca,rplacd Function
Syntax:
rplaca cons object!cons
rplacd cons object!cons
Pronunciation:
rplaca :[r—eplak]or[rplak]
rplacd :[r—eplakd]or[rplakd]or[r—eplakd—e]or[rplakd—e]
Arguments and Values:
cons|acons.
object |an object .
Description:
rplaca replaces the carof the cons with object .
rplacd replaces the cdrof the cons with object .
Examples:
(defparameter *some-list* (list* ’one ’two ’three ’four)) !*some-list*
*some-list*!(ONE TWO THREE . FOUR)
(rplaca *some-list* ’uno) !(UNO TWO THREE . FOUR)
*some-list*!(UNO TWO THREE . FOUR)
(rplacd (last *some-list*) (list ’IV)) !(THREE IV)
*some-list*!(UNO TWO THREE IV)
Side Eﬀects:
The cons is modied.
Should signal an error of typetype-error ifcons is not a cons.
14–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
car, cdr, caar, cadr, cdar, cddr, caaar, caadr, cadar, :::
car,cdr,caar,cadr,cdar,cddr,caaar,caadr,cadar,
caddr,cdaar,cdadr,cddar,cdddr,caaaar,caaadr,
caadar,caaddr,cadaar,cadadr,caddar,cadddr,
cdaaar,cdaadr,cdadar,cdaddr,cddaar,cddadr,
cdddar,cddddr Accessor
Syntax:
carx!object
cdr x!object
caar x!object
cadr x!object
cdar x!object
cddr x!object
caaar x!object
caadr x!object
cadar x!object
caddr x!object
cdaar x!object
cdadr x!object
cddar x!object
cdddr x!object
caaaar x!object
caaadr x!object
caadar x!object
caaddr x!object
cadaar x!object
cadadr x!object
caddar x!object
cadddr x!object
cdaaar x!object
cdaadr x!object
cdadar x!object
cdaddr x!object
cddaar x!object
cddadr x!object
cdddar x!object
cddddr x!object(setf (car x)new-object )
(setf (cdr x)new-object )
(setf (caar x)new-object )
(setf (cadr x)new-object )
(setf (cdar x)new-object )
(setf (cddr x)new-object )
(setf (caaar x)new-object )
(setf (caadr x)new-object )
(setf (cadar x)new-object )
(setf (caddr x)new-object )
(setf (cdaar x)new-object )
(setf (cdadr x)new-object )
(setf (cddar x)new-object )
(setf (cdddr x)new-object )
(setf (caaaar x)new-object )
(setf (caaadr x)new-object )
(setf (caadar x)new-object )
(setf (caaddr x)new-object )
(setf (cadaar x)new-object )
(setf (cadadr x)new-object )
(setf (caddar x)new-object )
(setf (cadddr x)new-object )
(setf (cdaaar x)new-object )
(setf (cdaadr x)new-object )
(setf (cdadar x)new-object )
(setf (cdaddr x)new-object )
(setf (cddaar x)new-object )
(setf (cddadr x)new-object )
(setf (cdddar x)new-object )
(setf (cddddr x)new-object )
Pronunciation:
cadr:[kadr]
Conses14–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
car, cdr, caar, cadr, cdar, cddr, caaar, caadr, cadar, :::
caddr :[kaddr]or[kad_udr]
cdr:[k_udr]
cddr :[k_uddr]or[kd_udr]
Arguments and Values:
x|alist.
object |an object .
new-object |an object .
Description:
Ifxis acons,carreturns the carof that cons. Ifxisnil,carreturnsnil.
Ifxis acons,cdrreturns the cdrof that cons. Ifxisnil,cdrreturnsnil.
Functions are provided which perform compositions of up to four carandcdroperations. Their
names consist of a C, followed by two, three, or four occurrences of AorD, and nally an R. The
series of A's andD's in each function 'sname is chosen to identify the series of carandcdroperations
that is performed by the function. The order in which the A's andD's appear is the inverse of the
order in which the corresponding operations are performed. Figure 14{6 denes the relationships
precisely.
14–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
car, cdr, caar, cadr, cdar, cddr, caaar, caadr, cadar, :::
This place::: Is equivalent to this place:::
(caar x) (car (car x))
(cadr x) (car (cdr x))
(cdar x) (cdr (car x))
(cddr x) (cdr (cdr x))
(caaar x) (car (car (car x)))
(caadr x) (car (car (cdr x)))
(cadar x) (car (cdr (car x)))
(caddr x) (car (cdr (cdr x)))
(cdaar x) (cdr (car (car x)))
(cdadr x) (cdr (car (cdr x)))
(cddar x) (cdr (cdr (car x)))
(cdddr x) (cdr (cdr (cdr x)))
(caaaar x) (car (car (car (car x))))
(caaadr x) (car (car (car (cdr x))))
(caadar x) (car (car (cdr (car x))))
(caaddr x) (car (car (cdr (cdr x))))
(cadaar x) (car (cdr (car (car x))))
(cadadr x) (car (cdr (car (cdr x))))
(caddar x) (car (cdr (cdr (car x))))
(cadddr x) (car (cdr (cdr (cdr x))))
(cdaaar x) (cdr (car (car (car x))))
(cdaadr x) (cdr (car (car (cdr x))))
(cdadar x) (cdr (car (cdr (car x))))
(cdaddr x) (cdr (car (cdr (cdr x))))
(cddaar x) (cdr (cdr (car (car x))))
(cddadr x) (cdr (cdr (car (cdr x))))
(cdddar x) (cdr (cdr (cdr (car x))))
(cddddr x) (cdr (cdr (cdr (cdr x))))
Figure 14–6. CAR and CDR variants
setf can also be used with any of these functions to change an existing component of x, butsetf
will not make new components. So, for example, the carof a cons can be assigned with setf of
car, but the carofnilcannot be assigned with setf ofcar. Similarly, the carof the carof a cons
whose caris acons can be assigned with setf ofcaar, but neither nilnor a cons whose car is nil
can be assigned with setf ofcaar.
The argument xis permitted to be a dotted list or a circular list .
Examples:
(car nil)!NIL
(cdr ’(1 . 2))!2
(cdr ’(1 2))!(2)
Conses14–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(cadr ’(1 2))!2
(car ’(a b c))!A
(cdr ’(a b c))!(B C)
Exceptional Situations:
The functions carandcdrshould signal type-error if they receive an argument which is not a list.
The other functions ( caar,cadr,:::cddddr ) should behave for the purpose of error checking as if
dened by appropriate calls to carandcdr.
See Also:
rplaca ,ﬁrst,rest
Notes:
The carof a cons can also be altered by using rplaca , and the cdrof a cons can be altered by
usingrplacd .
(car x)(first x)
(cadr x)(second x)(car (cdr x))
(caddr x)(third x)(car (cdr (cdr x)))
(cadddr x)(fourth x)(car (cdr (cdr (cdr x))))
copy-tree Function
Syntax:
copy-tree tree!new-tree
Arguments and Values:
tree|atree.
new-tree |atree.
Description:
Creates a copy of a treeofconses .
Iftreeis not a cons, it is returned; otherwise, the result is a new cons of the results of calling
copy-tree on the carand cdroftree. In other words, all conses in the treerepresented by treeare
copied recursively, stopping only when non- conses are encountered.
copy-tree does not preserve circularities and the sharing of substructure.
Examples:
(setq object (list (cons 1 "one")
14–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(cons 2 (list ’a ’b ’c))))
!((1 . "one") (2 A B C))
(setq object-too object) !((1 . "one") (2 A B C))
(setq copy-as-list (copy-list object))
(setq copy-as-alist (copy-alist object))
(setq copy-as-tree (copy-tree object))
(eq object object-too) !true
(eq copy-as-tree object) !false
(eql copy-as-tree object) !false
(equal copy-as-tree object) !true
(setf (first (cdr (second object))) "a"
(car (second object)) "two"
(car object) ’(one . 1)) !(ONE . 1)
object!((ONE . 1) ("two" "a" B C))
object-too!((ONE . 1) ("two" "a" B C))
copy-as-list!((1 . "one") ("two" "a" B C))
copy-as-alist!((1 . "one") (2 "a" B C))
copy-as-tree!((1 . "one") (2 A B C))
See Also:
tree-equal
sublis,nsublis Function
Syntax:
sublis alist tree &key key test test-not !new-tree
nsublis alist tree &key key test test-not !new-tree
Arguments and Values:
alist|an association list .
tree|atree.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
new-tree |atree.
Conses14–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
sublis, nsublis
Description:
sublis makes substitutions for objects intree(a structure of conses ).nsublis is likesublis but
destructively modies the relevant parts of the tree.
sublis looks at all subtrees and leaves of tree; if a subtree or leaf appears as a key in alist (that
is, the key and the subtree or leaf satisfy the test ), it is replaced by the object with which that
key is associated. This operation is non-destructive. In eect, sublis can perform several subst
operations simultaneously.
Ifsublis succeeds, a new copy of treeis returned in which each occurrence of such a subtree or leaf
is replaced by the object with which it is associated. If no changes are made, the original tree is
returned. The original treeis left unchanged, but the result tree may share cells with it.
nsublis is permitted to modify treebut otherwise returns the same values as sublis .
Examples:
(sublis ’((x . 100) (z . zprime))
’(plus x (minus g z x p) 4 . x))
!(PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)
(sublis ’(((+ x y) . (- x y)) ((- x y) . (+ x y)))
’(* (/ (+ x y) (+ x p)) (- x y))
:test #’equal)
!(* (/ (- X Y) (+ X P)) (+ X Y))
(setq tree1 ’(1 (1 2) ((1 2 3)) (((1 2 3 4)))))
!(1 (1 2) ((1 2 3)) (((1 2 3 4))))
(sublis ’((3 . "three")) tree1)
!(1 (1 2) ((1 2 "three")) (((1 2 "three" 4))))
(sublis ’((t . "string"))
(sublis ’((1 . "") (4 . 44)) tree1)
:key #’stringp)
!("string" ("string" 2) (("string" 2 3)) ((("string" 2 3 44))))
tree1!(1 (1 2) ((1 2 3)) (((1 2 3 4))))
(setq tree2 ’("one" ("one" "two") (("one" "Two" "three"))))
!("one" ("one" "two") (("one" "Two" "three")))
(sublis ’(("two" . 2)) tree2)
!("one" ("one" "two") (("one" "Two" "three")))
tree2!("one" ("one" "two") (("one" "Two" "three")))
(sublis ’(("two" . 2)) tree2 :test ’equal)
!("one" ("one" 2) (("one" "Two" "three")))
(nsublis ’((t . ’temp))
tree1
:key #’(lambda (x) (or (atom x) (< (list-length x) 3))))
!((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP)
14–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Side Eﬀects:
nsublis modies tree.
See Also:
subst , Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
Because the side-eecting variants ( e.g.,nsublis ) potentially change the path that is being
traversed, their eects in the presence of shared or circular structure structure may vary in
surprising ways when compared to their non-side-eecting alternatives. To see this, consider the
following side-eect behavior, which might be exhibited by some implementations:
(defun test-it (fn)
(let* ((shared-piece (list ’a ’b))
(data (list shared-piece shared-piece)))
(funcall fn ’((a . b) (b . a)) data)))
(test-it #’sublis) !((B A) (B A))
(test-it #’nsublis) !((A B) (A B))
subst,subst-if,subst-if-not,nsubst,nsubst-if,
nsubst-if-not Function
Syntax:
subst new old tree &key key test test-not !new-tree
subst-if new predicate tree &key key!new-tree
subst-if-not new predicate tree &key key!new-tree
nsubst new old tree &key key test test-not !new-tree
nsubst-if new predicate tree &key key!new-tree
nsubst-if-not new predicate tree &key key!new-tree
Arguments and Values:
new|an object .
old|an object .
Conses14–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
subst, subst-if, subst-if-not, nsubst, nsubst-if, :::
predicate |asymbol that names a function , or a function of one argument that returns a generalized
boolean value.
tree|atree.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
new-tree |atree.
Description:
subst ,subst-if , andsubst-if-not perform substitution operations on tree. Each function searches
treefor occurrences of a particular olditem of an element or subexpression that satises the test .
nsubst ,nsubst-if , andnsubst-if-not are likesubst ,subst-if , andsubst-if-not respectively, except
that the original treeis modied.
subst makes a copy of tree, substituting new for every subtree or leaf of tree(whether the subtree
or leaf is a caror a cdrof its parent) such that oldand the subtree or leaf satisfy the test .
nsubst is a destructive version of subst . The list structure of treeis altered by destructively
replacing with new each leaf of the treesuch that oldand the leaf satisfy the test .
Forsubst ,subst-if , andsubst-if-not , if the functions succeed, a new copy of the tree is returned
in which each occurrence of such an element is replaced by the new element or subexpression. If
no changes are made, the original treemay be returned. The original treeis left unchanged, but
the result tree may share storage with it.
Fornsubst ,nsubst-if , andnsubst-if-not the original treeis modied and returned as the function
result, but the result may not be eqtotree.
Examples:
(setq tree1 ’(1 (1 2) (1 2 3) (1 2 3 4))) !(1 (1 2) (1 2 3) (1 2 3 4))
(subst "two" 2 tree1) !(1 (1 "two") (1 "two" 3) (1 "two" 3 4))
(subst "five" 5 tree1) !(1 (1 2) (1 2 3) (1 2 3 4))
(eq tree1 (subst "five" 5 tree1)) !implementation-dependent
(subst ’tempest ’hurricane
’(shakespeare wrote (the hurricane)))
!(SHAKESPEARE WROTE (THE TEMPEST))
(subst ’foo ’nil ’(shakespeare wrote (twelfth night)))
!(SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)
(subst ’(a . cons) ’(old . pair)
’((old . spice) ((old . shoes) old . pair) (old . pair))
14–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
:test #’equal)
!((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))
(subst-if 5 #’listp tree1) !5
(subst-if-not ’(x) #’consp tree1)
!(1 X)
tree1!(1 (1 2) (1 2 3) (1 2 3 4))
(nsubst ’x 3 tree1 :key #’(lambda (y) (and (listp y) (third y))))
!(1 (1 2) X X)
tree1!(1 (1 2) X X)
Side Eﬀects:
nsubst ,nsubst-if , andnsubst-if-not might alter the tree structure oftree.
See Also:
substitute ,nsubstitute , Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and
Side Eects)
Notes:
The:test-not parameter is deprecated.
The functions subst-if-not andnsubst-if-not are deprecated.
One possible denition of subst :
(defun subst (old new tree &rest x &key test test-not key)
(cond ((satisfies-the-test old tree :test test
:test-not test-not :key key)
new)
((atom tree) tree)
(t (let ((a (apply #’subst old new (car tree) x))
(d (apply #’subst old new (cdr tree) x)))
(if (and (eql a (car tree))
(eql d (cdr tree)))
tree
(cons a d))))))
Conses14–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
tree-equal
tree-equal Function
Syntax:
tree-equal tree-1 tree-2 &key test test-not!generalized-boolean
Arguments and Values:
tree-1 |atree.
tree-2 |atree.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
generalized-boolean |ageneralized boolean .
Description:
tree-equal tests whether two trees are of the same shape and have the same leaves. tree-equal
returns true iftree-1 and tree-2 are both atoms and satisfy the test , or if they are both conses and
thecaroftree-1 istree-equal to the caroftree-2 and the cdroftree-1 istree-equal to the cdrof
tree-2 . Otherwise, tree-equal returns false.
tree-equal recursively compares conses but not any other objects that have components.
The rst argument to the :test or:test-not function is tree-1 or a carorcdroftree-1 ; the second
argument is tree-2 or a carorcdroftree-2 .
Examples:
(setq tree1 ’(1 (1 2))
tree2 ’(1 (1 2))) !(1 (1 2))
(tree-equal tree1 tree2) !true
(eql tree1 tree2) !false
(setq tree1 ’(’a (’b ’c))
tree2 ’(’a (’b ’c))) !(’a (’b ’c))
!((QUOTE A) ((QUOTE B) (QUOTE C)))
(tree-equal tree1 tree2 :test ’eq) !true
Exceptional Situations:
The consequences are undened if both tree-1 and tree-2 are circular.
See Also:
equal , Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
14–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
copy-list Function
Syntax:
copy-list list!copy
Arguments and Values:
list|aproper list or a dotted list .
copy|alist.
Description:
Returns a copy oflist. Iflistis adotted list , the resulting listwill also be a dotted list .
Only the list structure oflistis copied; the elements of the resulting list are the same as the
corresponding elements of the given list.
Examples:
(setq lst (list 1 (list 2 3))) !(1 (2 3))
(setq slst lst) !(1 (2 3))
(setq clst (copy-list lst)) !(1 (2 3))
(eq slst lst)!true
(eq clst lst)!false
(equal clst lst) !true
(rplaca lst "one") !("one" (2 3))
slst!("one" (2 3))
clst!(1 (2 3))
(setf (caadr lst) "two") !"two"
lst!("one" ("two" 3))
slst!("one" ("two" 3))
clst!(1 ("two" 3))
Exceptional Situations:
The consequences are undened if listis acircular list .
See Also:
copy-alist ,copy-seq ,copy-tree
Notes:
The copy created is equal tolist, but not eq.
Conses14–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
list, list
list,list Function
Syntax:
list&rest objects!list
list*&rest objects+!result
Arguments and Values:
object |an object .
list|alist.
result |an object .
Description:
listreturns a listcontaining the supplied objects .
list* is likelistexcept that the last argument tolistbecomes the carof the last cons constructed,
while the last argument tolist* becomes the cdrof the last cons constructed. Hence, any given call
tolist* always produces one fewer conses than a call to listwith the same number of arguments.
If the last argument tolist* is alist, the eect is to construct a new listwhich is similar, but which
has additional elements added to the front corresponding to the preceding arguments oflist*.
Iflist* receives only one object , that object is returned, regardless of whether or not it is a list.
Examples:
(list 1)!(1)
(list* 1)!1
(setq a 1)!1
(list a 2)!(1 2)
’(a 2)!(A 2)
(list ’a 2)!(A 2)
(list* a 2)!(1 . 2)
(list)!NIL ; i.e., ()
(setq a ’(1 2)) !(1 2)
(eq a (list* a)) !true
(list 3 4 ’a (car ’(b . c)) (+ 6 -2)) !(3 4 A B 4)
(list* ’a ’b ’c ’d) (cons ’a (cons ’b (cons ’c ’d))) !(A B C . D)
(list* ’a ’b ’c ’(d e f)) !(A B C D E F)
See Also:
cons
14–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(list* x)x
list-length Function
Syntax:
list-length list!length
Arguments and Values:
list|aproper list or a circular list .
length |a non-negative integer , ornil.
Description:
Returns the length oflistiflistis aproper list . Returns niliflistis acircular list .
Examples:
(list-length ’(a b c d)) !4
(list-length ’(a (b c) d)) !3
(list-length ’()) !0
(list-length nil) !0
(defun circular-list (&rest elements)
(let ((cycle (copy-list elements)))
(nconc cycle cycle)))
(list-length (circular-list ’a ’b)) !NIL
(list-length (circular-list ’a)) !NIL
(list-length (circular-list)) !0
Exceptional Situations:
Should signal an error of typetype-error iflistis not a proper list or a circular list .
See Also:
length
Notes:
list-length could be implemented as follows:
(defun list-length (x)
(do ((n 0 (+ n 2)) ;Counter.
(fast x (cddr fast)) ;Fast pointer: leaps by 2.
Conses14–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(slow x (cdr slow))) ;Slow pointer: leaps by 1.
(nil)
;; If fast pointer hits the end, return the count.
(when (endp fast) (return n))
(when (endp (cdr fast)) (return (+ n 1)))
;; If fast pointer eventually equals slow pointer,
;; then we must be stuck in a circular list.
;; (A deeper property is the converse: if we are
;; stuck in a circular list, then eventually the
;; fast pointer will equal the slow pointer.
;; That fact justifies this implementation.)
(when (and (eq fast slow) (> n 0)) (return nil))))
listp Function
Syntax:
listp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typelist; otherwise, returns false.
Examples:
(listp nil)!true
(listp (cons 1 2)) !true
(listp (make-array 6)) !false
(listp t)!false
See Also:
consp
Notes:
Ifobject is acons,listp does not check whether object is aproper list ; it returns true for any kind
oflist.
(listp object)(typep object’list)(typep object’(or cons null))
14–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-list Function
Syntax:
make-list size&key initial-element!list
Arguments and Values:
size|a non-negative integer .
initial-element |an object . The default is nil.
list|alist.
Description:
Returns a listoflength given by size, each of the elements of which is initial-element .
Examples:
(make-list 5)!(NIL NIL NIL NIL NIL)
(make-list 3 :initial-element ’rah) !(RAH RAH RAH)
(make-list 2 :initial-element ’(1 2 3)) !((1 2 3) (1 2 3))
(make-list 0)!NIL ; i.e., ()
(make-list 0 :initial-element ’new-element) !NIL
Exceptional Situations:
Should signal an error of typetype-error ifsizeis not a non-negative integer .
See Also:
cons,list
push Macro
Syntax:
push item place!new-place-value
Arguments and Values:
item|an object .
place |aplace , the value of which may be any object .
new-place-value |alist(the new value ofplace ).
Conses14–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
push prepends item to the listthat is stored in place , stores the resulting listinplace , and returns
thelist.
For information about the evaluation ofsubforms ofplace , see Section 5.1.1.1 (Evaluation of
Subforms to Places).
Examples:
(setq llst ’(nil)) !(NIL)
(push 1 (car llst)) !(1)
llst!((1))
(push 1 (car llst)) !(1 1)
llst!((1 1))
(setq x ’(a (b c) d)) !(A (B C) D)
(push 5 (cadr x)) !(5 B C)
x!(A (5 B C) D)
Side Eﬀects:
The contents of place are modied.
See Also:
pop,pushnew , Section 5.1 (Generalized Reference)
Notes:
The eect of (push item place )is equivalent to
(setf place (cons item place ))
except that the subforms ofplace are evaluated only once, and item is evaluated before place .
pop Macro
Syntax:
pop place!element
Arguments and Values:
place |aplace , the value of which is a list(possibly, but necessarily, a dotted list orcircular list ).
element |an object (the carof the contents of place ).
Description:
pop reads thevalue ofplace , remembers the carof the listwhich was retrieved, writes thecdrof
thelistback into the place , and nally yields thecarof the originally retrieved list.
14–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
For information about the evaluation ofsubforms ofplace , see Section 5.1.1.1 (Evaluation of
Subforms to Places).
Examples:
(setq stack ’(a b c)) !(A B C)
(pop stack)!A
stack!(B C)
(setq llst ’((1 2 3 4))) !((1 2 3 4))
(pop (car llst)) !1
llst!((2 3 4))
Side Eﬀects:
The contents of place are modied.
See Also:
push ,pushnew , Section 5.1 (Generalized Reference)
Notes:
The eect of (pop place)is roughly equivalent to
(prog1 (car place) (setf place(cdr place)))
except that the latter would evaluate any subforms ofplace three times, while popevaluates them
only once.
ﬁrst,second,third,fourth,ﬁfth,sixth,seventh,
eighth,ninth,tenth Accessor
Syntax:
ﬁrst list!object
second list!object
third list!object
fourth list!object
ﬁfth list!object
sixth list!object
seventh list!object
eighth list!object
ninth list!object
tenth list!object(setf (ﬁrst list)new-object )
(setf (second list)new-object )
(setf (third list)new-object )
(setf (fourth list)new-object )
(setf (ﬁfth list)new-object )
(setf (sixth list)new-object )
(setf (seventh list)new-object )
(setf (eighth list)new-object )
(setf (ninth list)new-object )
(setf (tenth list)new-object )
Arguments and Values:
list|alist, which might be a dotted list or a circular list .
Conses14–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬁrst, second, third, fourth, ﬁfth, sixth, seventh, :::
object ,new-object |an object .
Description:
The functions ﬁrst,second ,third ,fourth ,ﬁfth,sixth ,seventh ,eighth ,ninth , andtenth access
the rst, second, third, fourth, fth, sixth, seventh, eighth, ninth, and tenth elements oflist,
respectively. Specically,
(first list)(car list)
(second list)(car (cdr list))
(third list)(car (cddr list))
(fourth list)(car (cdddr list))
(fifth list)(car (cddddr list))
(sixth list)(car (cdr (cddddr list)))
(seventh list)(car (cddr (cddddr list)))
(eighth list)(car (cdddr (cddddr list)))
(ninth list)(car (cddddr (cddddr list)))
(tenth list)(car (cdr (cddddr (cddddr list))))
setf can also be used with any of these functions to change an existing component. The same
equivalences apply. For example:
(setf (fifth list)new-object )(setf (car (cddddr list))new-object )
Examples:
(setq lst ’(1 2 3 (4 5 6) ((V)) vi 7 8 9 10))
!(1 2 3 (4 5 6) ((V)) VI 7 8 9 10)
(first lst)!1
(tenth lst)!10
(fifth lst)!((V))
(second (fourth lst)) !5
(sixth ’(1 2 3)) !NIL
(setf (fourth lst) "four") !"four"
lst!(1 2 3 "four" ((V)) VI 7 8 9 10)
See Also:
car,nth
Notes:
ﬁrst is functionally equivalent to car,second is functionally equivalent to cadr,third is functionally
equivalent to caddr , andfourth is functionally equivalent to cadddr .
The ordinal numbering used here is one-origin, as opposed to the zero-origin numbering used by
nth:
(fifth x)(nth 4 x)
14–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
nth Accessor
Syntax:
nth n list!object
(setf (nth n list)new-object )
Arguments and Values:
n|a non-negative integer .
list|alist, which might be a dotted list or a circular list .
object |an object .
new-object |an object .
Description:
nthlocates the nth element of list, where the carof the listis the \zeroth" element. Specically,
(nth n list)(car (nthcdr n list))
nthmay be used to specify a place tosetf. Specically,
(setf (nth n list)new-object )(setf (car (nthcdr n list))new-object )
Examples:
(nth 0 ’(foo bar baz)) !FOO
(nth 1 ’(foo bar baz)) !BAR
(nth 3 ’(foo bar baz)) !NIL
(setq 0-to-3 (list 0 1 2 3)) !(0 1 2 3)
(setf (nth 2 0-to-3) "two") !"two"
0-to-3!(0 1 "two" 3)
See Also:
elt,ﬁrst,nthcdr
Conses14–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
endp Function
Syntax:
endp list!generalized-boolean
Arguments and Values:
list|alist, which might be a dotted list or a circular list .
generalized-boolean |ageneralized boolean .
Description:
Returns true iflistis the empty list . Returns false iflistis acons.
Examples:
(endp nil)!true
(endp ’(1 2))!false
(endp (cddr ’(1 2))) !true
Exceptional Situations:
Should signal an error of typetype-error iflistis not a list.
Notes:
The purpose of endp is to test for the end of proper list . Sinceendp does not descend into a
cons, it is well-dened to pass it a dotted list . However, if shorter \lists" are iteratively produced
by calling cdron such a dotted list and those \lists" are tested with endp , a situation that has
undened consequences will eventually result when the non-nil atom (which is not in fact a list)
nally becomes the argument to endp . Since this is the usual way in which endp is used, it is
conservative programming style and consistent with the intent of endp to treatendp as simply a
function on proper lists which happens not to enforce an argument type of proper list except when
the argument is atomic .
null Function
Syntax:
null object!boolean
Arguments and Values:
object |an object .
boolean |aboolean .
14–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returnstifobject is the empty list ; otherwise, returns nil.
Examples:
(null ’())!T
(null nil)!T
(null t)!NIL
(null 1)!NIL
See Also:
not
Notes:
null is intended to be used to test for the empty list whereasnotis intended to be used to invert
aboolean (orgeneralized boolean ). Operationally, null andnotcompute the same result; which to
use is a matter of style.
(null object)(typep object’null)(eq object’())
nconc Function
Syntax:
nconc&rest lists!concatenated-list
Arguments and Values:
list|each but the last must be a list(which might be a dotted list but must not be a circular list );
the last listmay be any object .
concatenated-list |alist.
Description:
Returns a listthat is the concatenation of lists. If no listsare supplied, (nconc) returnsnil.nconc
is dened using the following recursive relationship:
(nconc)!()
(nconc nil . lists)(nconc . lists)
(nconc list)!list
(nconc list-1 list-2 )(progn (rplacd (last list-1)list-2)list-1)
(nconc list-1 list-2 .lists)(nconc (nconc list-1 list-2 ) . lists)
Conses14–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(nconc)!NIL
(setq x ’(a b c)) !(A B C)
(setq y ’(d e f)) !(D E F)
(nconc x y)!(A B C D E F)
x!(A B C D E F)
Note, in the example, that the value of xis now dierent, since its last cons has been rplacd 'd
to the value of y. If(nconc x y) were evaluated again, it would yield a piece of a circular list ,
whose printed representation would be (A B C D E F D E F D E F ...) , repeating forever; if the
*print-circle* switch were non-nil , it would be printed as (A B C . #1=(D E F . #1#)) .
(setq foo (list ’a ’b ’c ’d ’e)
bar (list ’f ’g ’h ’i ’j)
baz (list ’k ’l ’m)) !(K L M)
(setq foo (nconc foo bar baz)) !(A B C D E F G H I J K L M)
foo!(A B C D E F G H I J K L M)
bar!(F G H I J K L M)
baz!(K L M)
(setq foo (list ’a ’b ’c ’d ’e)
bar (list ’f ’g ’h ’i ’j)
baz (list ’k ’l ’m)) !(K L M)
(setq foo (nconc nil foo bar nil baz)) !(A B C D E F G H I J K L M)
foo!(A B C D E F G H I J K L M)
bar!(F G H I J K L M)
baz!(K L M)
Side Eﬀects:
The listsare modied rather than copied.
See Also:
append ,concatenate
append Function
Syntax:
append &rest lists!result
Arguments and Values:
list|each must be a proper list except the last, which may be any object .
14–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
result |an object . This will be a listunless the last listwas not a listand all preceding listswere
null.
Description:
append returns a new listthat is the concatenation of the copies. listsare left unchanged; the list
structure of each of listsexcept the last is copied. The last argument is not copied; it becomes the
cdrof the nal dotted pair of the concatenation of the preceding lists, or is returned directly if
there are no preceding non-empty lists.
Examples:
(append ’(a b c) ’(d e f) ’() ’(g)) !(A B C D E F G)
(append ’(a b c) ’d) !(A B C . D)
(setq lst ’(a b c)) !(A B C)
(append lst ’(d)) !(A B C D)
lst!(A B C)
(append)!NIL
(append ’a)!A
See Also:
nconc ,concatenate
revappend,nreconc Function
Syntax:
revappend list tail!result-list
nreconc list tail!result-list
Arguments and Values:
list|aproper list .
tail|an object .
result-list |an object .
Description:
revappend constructs a copy 2oflist, but with the elements in reverse order. It then appends (as
if bynconc ) the tailto that reversed list and returns the result.
nreconc reverses the order of elements inlist(as if bynreverse ). It then appends (as if by nconc )
thetailto that reversed list and returns the result.
The resulting listshares list structure with tail.
Conses14–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
revappend, nreconc
Examples:
(let ((list-1 (list 1 2 3))
(list-2 (list ’a ’b ’c)))
(print (revappend list-1 list-2))
(print (equal list-1 ’(1 2 3)))
(print (equal list-2 ’(a b c))))
.(3 2 1 A B C)
.T
.T
!T
(revappend ’(1 2 3) ’()) !(3 2 1)
(revappend ’(1 2 3) ’(a . b)) !(3 2 1 A . B)
(revappend ’() ’(a b c)) !(A B C)
(revappend ’(1 2 3) ’a) !(3 2 1 . A)
(revappend ’() ’a) !A ;degenerate case
(let ((list-1 ’(1 2 3))
(list-2 ’(a b c)))
(print (nreconc list-1 list-2))
(print (equal list-1 ’(1 2 3)))
(print (equal list-2 ’(a b c))))
.(3 2 1 A B C)
.NIL
.T
!T
Side Eﬀects:
revappend does not modify either of its arguments .nreconc is permitted to modify listbut not
tail.
Although it might be implemented dierently, nreconc is constrained to have side-eect behavior
equivalent to:
(nconc (nreverse list)tail)
See Also:
reverse ,nreverse ,nconc
Notes:
The following functional equivalences are true, although good implementations will typically use a
faster algorithm for achieving the same eect:
14–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(revappend list tail)(nconc (reverse list)tail)
(nreconc list tail)(nconc (nreverse list)tail)
butlast,nbutlast Function
Syntax:
butlast list&optional n!result-list
nbutlast list&optional n!result-list
Arguments and Values:
list|alist, which might be a dotted list but must not be a circular list .
n|a non-negative integer .
result-list |alist.
Description:
butlast returns a copy of listfrom which the last nconses have been omitted. If nis not supplied,
its value is 1. If there are fewer than nconses in list,nilis returned and, in the case of nbutlast ,
listis not modied.
nbutlast is likebutlast , butnbutlast may modify list. It changes the cdrof the cons n+1 from
the end of the listtonil.
Examples:
(setq lst ’(1 2 3 4 5 6 7 8 9)) !(1 2 3 4 5 6 7 8 9)
(butlast lst)!(1 2 3 4 5 6 7 8)
(butlast lst 5) !(1 2 3 4)
(butlast lst (+ 5 5)) !NIL
lst!(1 2 3 4 5 6 7 8 9)
(nbutlast lst 3) !(1 2 3 4 5 6)
lst!(1 2 3 4 5 6)
(nbutlast lst 99) !NIL
lst!(1 2 3 4 5 6)
(butlast ’(a b c d)) !(A B C)
(butlast ’((a b) (c d))) !((A B))
(butlast ’(a))!NIL
(butlast nil)!NIL
(setq foo (list ’a ’b ’c ’d)) !(A B C D)
(nbutlast foo)!(A B C)
foo!(A B C)
Conses14–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(nbutlast (list ’a)) !NIL
(nbutlast ’())!NIL
Exceptional Situations:
Should signal an error of typetype-error iflistis not a proper list or a dotted list . Should signal
an error of typetype-error ifnis not a non-negative integer .
Notes:
(butlast list n)(ldiff list(last list n))
last Function
Syntax:
last list&optional n!tail
Arguments and Values:
list|alist, which might be a dotted list but must not be a circular list .
n|a non-negative integer . The default is 1.
tail|an object .
Description:
lastreturns the last nconses (not the last nelements) of list). If listis(),lastreturns().
Ifnis zero, the atom that terminates listis returned. If nis greater than or equal to the number
ofcons cells in list, the result is list.
Examples:
(last nil)!NIL
(last ’(1 2 3)) !(3)
(last ’(1 2 . 3)) !(2 . 3)
(setq x (list ’a ’b ’c ’d)) !(A B C D)
(last x)!(D)
(rplacd (last x) (list ’e ’f)) x !(A B C D E F)
(last x)!(F)
(last ’(a b c)) !(C)
(last ’(a b c) 0) !()
(last ’(a b c) 1) !(C)
14–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(last ’(a b c) 2) !(B C)
(last ’(a b c) 3) !(A B C)
(last ’(a b c) 4) !(A B C)
(last ’(a . b) 0) !B
(last ’(a . b) 1) !(A . B)
(last ’(a . b) 2) !(A . B)
Exceptional Situations:
The consequences are undened if listis acircular list . Should signal an error of typetype-error if
nis not a non-negative integer .
See Also:
butlast ,nth
Notes:
The following code could be used to dene last.
(defun last (list &optional (n 1))
(check-type n (integer 0))
(do ((l list (cdr l))
(r list)
(i 0 (+ i 1)))
((atom l) r)
(if (>= i n) (pop r))))
ldiﬀ,tailp Function
Syntax:
ldiﬀ list object!result-list
tailp object list!generalized-boolean
Arguments and Values:
list|alist, which might be a dotted list .
object |an object .
result-list |alist.
generalized-boolean |ageneralized boolean .
Conses14–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ldiﬀ, tailp
Description:
Ifobject is the same as some tailoflist,tailp returns true; otherwise, it returns false.
Ifobject is the same as some tailoflist,ldiﬀ returns a fresh list of the elements oflistthat precede
object in the list structure oflist; otherwise, it returns a copy 2oflist.
Examples:
(let ((lists ’#((a b c) (a b c . d))))
(dotimes (i (length lists)) ()
(let ((list (aref lists i)))
(format t "~2&list=~S ~21T(tailp object list)~
~44T(ldiff list object)~%" list)
(let ((objects (vector list (cddr list) (copy-list (cddr list))
’(f g h) ’() ’d ’x)))
(dotimes (j (length objects)) ()
(let ((object (aref objects j)))
(format t "~& object=~S ~21T~S ~44T~S"
object (tailp object list) (ldiff list object))))))))
.
.list=(A B C) (tailp object list) (ldiff list object)
.object=(A B C) T NIL
.object=(C) T (A B)
.object=(C) NIL (A B C)
.object=(F G H) NIL (A B C)
.object=NIL T (A B C)
.object=D NIL (A B C)
.object=X NIL (A B C)
.
.list=(A B C . D) (tailp object list) (ldiff list object)
.object=(A B C . D) T NIL
.object=(C . D) T (A B)
.object=(C . D) NIL (A B C . D)
.object=(F G H) NIL (A B C . D)
.object=NIL NIL (A B C . D)
.object=D T (A B C)
.object=X NIL (A B C . D)
!NIL
Side Eﬀects:
Neitherldiﬀ nortailp modies either of its arguments .
Exceptional Situations:
Should be prepared to signal an error of typetype-error iflistis not a proper list or a dotted list .
14–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
set-diﬀerence
Notes:
If the listis acircular list ,tailp will reliably yield avalue only if the given object is in fact a tail
oflist. Otherwise, the consequences are unspecied: a given implementation which detects the
circularity must return false, but since an implementation is not obliged to detect such a situation ,
tailp might just loop indenitely without returning in that case.
tailp could be dened as follows:
(defun tailp (object list)
(do ((list list (cdr list)))
((atom list) (eql list object))
(if (eql object list)
(return t))))
andldiﬀ could be dened by:
(defun ldiff (list object)
(do ((list list (cdr list))
(r ’() (cons (car list) r)))
((atom list)
(if (eql list object) (nreverse r) (nreconc r list)))
(when (eql object list)
(return (nreverse r)))))
nthcdr Function
Syntax:
nthcdr n list!tail
Arguments and Values:
n|a non-negative integer .
list|alist, which might be a dotted list or a circular list .
tail|an object .
Description:
Returns the tailoflistthat would be obtained by calling cdr ntimes in succession.
Conses14–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(nthcdr 0 ’())!NIL
(nthcdr 3 ’())!NIL
(nthcdr 0 ’(a b c)) !(A B C)
(nthcdr 2 ’(a b c)) !(C)
(nthcdr 4 ’(a b c)) !()
(nthcdr 1 ’(0 . 1)) !1
(locally (declare (optimize (safety 3)))
(nthcdr 3 ’(0 . 1)))
Error: Attempted to take CDR of 1.
Exceptional Situations:
Should signal an error of typetype-error ifnis not a non-negative integer .
Fornbeing an integer greater than 1, the error checking done by (nthcdr n list)is the same as for
(nthcdr (- n1) (cdr list)); see the functioncdr.
See Also:
cdr,nth,rest
rest Accessor
Syntax:
rest list!tail
(setf (rest list)new-tail)
Arguments and Values:
list|alist, which might be a dotted list or a circular list .
tail|an object .
Description:
rest performs the same operation as cdr, but mnemonically complements ﬁrst. Specically,
(rest list)(cdr list)
(setf (rest list)new-tail)(setf (cdr list)new-tail)
Examples:
(rest ’(1 2))!(2)
14–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(rest ’(1 . 2)) !2
(rest ’(1))!NIL
(setq *cons* ’(1 . 2)) !(1 . 2)
(setf (rest *cons*) "two") !"two"
*cons*!(1 . "two")
See Also:
cdr,nthcdr
Notes:
rest is often preferred stylistically over cdrwhen the argument is to being subjectively viewed as a
listrather than as a cons.
member,member-if,member-if-not Function
Syntax:
member item list &key key test test-not !tail
member-if predicate list &key key!tail
member-if-not predicate list &key key!tail
Arguments and Values:
item|an object .
list|aproper list .
predicate |adesignator for a function of one argument that returns a generalized boolean .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
tail|alist.
Description:
member ,member-if , andmember-if-not each search listforitem or for a top-level element that
satises the test . The argument to the predicate function is an element of list.
If some element satises the test , the tail of listbeginning with this element is returned; otherwise
nilis returned.
listis searched on the top level only.
Conses14–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(member 2 ’(1 2 3)) !(2 3)
(member 2 ’((1 . 2) (3 . 4)) :test-not #’= :key #’cdr) !((3 . 4))
(member ’e ’(a b c d)) !NIL
(member-if #’listp ’(a b nil c d)) !(NIL C D)
(member-if #’numberp ’(a #\Space 5/3 foo)) !(5/3 FOO)
(member-if-not #’zerop
’(3 6 9 11 . 12)
:key #’(lambda (x) (mod x 3))) !(11 . 12)
Exceptional Situations:
Should be prepared to signal an error of typetype-error iflistis not a proper list .
See Also:
ﬁnd,position , Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
The functionmember-if-not is deprecated.
In the following
(member ’a ’(g (a y) c a d e a f)) !(A D E A F)
the value returned by member isidentical to the portion of the listbeginning with a. Thusrplaca
on the result of member can be used to alter the part of the listwhereawas found (assuming a
check has been made that member did not return nil).
mapc,mapcar,mapcan,mapl,maplist,mapcon
Function
Syntax:
mapc function &rest lists+!list-1
mapcar function &rest lists+!result-list
mapcan function &rest lists+!concatenated-results
mapl function &rest lists+!list-1
maplist function &rest lists+!result-list
14–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
mapc, mapcar, mapcan, mapl, maplist, mapcon
mapcon function &rest lists+!concatenated-results
Arguments and Values:
function |adesignator for a function that must take as many arguments as there are lists.
list|aproper list .
list-1 |the rst list(which must be a proper list ).
result-list |alist.
concatenated-results |alist.
Description:
The mapping operation involves applying function to successive sets of arguments in which one
argument is obtained from each sequence . Except for mapc andmapl , the result contains the
results returned by function . In the cases of mapc andmapl , the resulting sequence islist.
function is called rst on all the elements with index 0, then on all those with index 1, and so on.
result-type species the type of the resulting sequence . If function is asymbol , it iscoerce d to a
function as if bysymbol-function .
mapcar operates on successive elements of the lists.function is applied to the rst element of each
list, then to the second element of each list, and so on. The iteration terminates when the shortest
listruns out, and excess elements in other lists are ignored. The value returned by mapcar is alist
of the results of successive calls to function .
mapc is likemapcar except that the results of applying function are not accumulated. The list
argument is returned.
maplist is likemapcar except that function is applied to successive sublists of the lists.function is
rst applied to the liststhemselves, and then to the cdrof each list, and then to the cdrof the cdr
of each list, and so on.
mapl is likemaplist except that the results of applying function are not accumulated; list-1 is
returned.
mapcan andmapcon are likemapcar andmaplist respectively, except that the results of applying
function are combined into a listby the use of nconc rather than list. That is,
(mapcon f x1 ... xn)
(apply #’nconc (maplist f x1 ... xn))
and similarly for the relationship between mapcan andmapcar .
Examples:
(mapcar #’car ’((1 a) (2 b) (3 c))) !(1 2 3)
(mapcar #’abs ’(3 -4 2 -5 -6)) !(3 4 2 5 6)
Conses14–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(mapcar #’cons ’(a b c) ’(1 2 3)) !((A . 1) (B . 2) (C . 3))
(maplist #’append ’(1 2 3 4) ’(1 2) ’(1 2 3))
!((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3))
(maplist #’(lambda (x) (cons ’foo x)) ’(a b c d))
!((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))
(maplist #’(lambda (x) (if (member (car x) (cdr x)) 0 1)) ’(a b a c d b c))
!(0 0 1 0 1 1 1)
;An entry is 1 if the corresponding element of the input
; list was the last instance of that element in the input list.
(setq dummy nil) !NIL
(mapc #’(lambda (&rest x) (setq dummy (append dummy x)))
’(1 2 3 4)
’(a b c d e)
’(x y z))!(1 2 3 4)
dummy!(1 A X 2 B Y 3 C Z)
(setq dummy nil) !NIL
(mapl #’(lambda (x) (push x dummy)) ’(1 2 3 4)) !(1 2 3 4)
dummy!((4) (3 4) (2 3 4) (1 2 3 4))
(mapcan #’(lambda (x y) (if (null x) nil (list x y)))
’(nil nil nil d e)
’(1 2 3 4 5 6)) !(D 4 E 5)
(mapcan #’(lambda (x) (and (numberp x) (list x)))
’(a 1 b c 3 4 d 5))
!(1 3 4 5)
In this case the function serves as a lter; this is a standard Lisp idiom using mapcan .
(mapcon #’list ’(1 2 3 4)) !((1 2 3 4) (2 3 4) (3 4) (4))
Exceptional Situations:
Should be prepared to signal an error of typetype-error if any listis not a proper list .
See Also:
dolist ,map, Section 3.6 (Traversal Rules and Side Eects)
14–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
acons Function
Syntax:
acons key datum alist!new-alist
Arguments and Values:
key|an object .
datum |an object .
alist|an association list .
new-alist |an association list .
Description:
Creates a fresh cons , the cdrof which is alist and the carof which is another fresh cons , the car
of which is keyand the cdrof which is datum .
Examples:
(setq alist ’()) !NIL
(acons 1 "one" alist) !((1 . "one"))
alist!NIL
(setq alist (acons 1 "one" (acons 2 "two" alist))) !((1 . "one") (2 . "two"))
(assoc 1 alist) !(1 . "one")
(setq alist (acons 1 "uno" alist)) !((1 . "uno") (1 . "one") (2 . "two"))
(assoc 1 alist) !(1 . "uno")
See Also:
assoc ,pairlis
Notes:
(acons key datum alist )(cons (cons key datum )alist)
assoc,assoc-if,assoc-if-not Function
Syntax:
assoc item alist &key key test test-not !entry
assoc-if predicate alist &key key!entry
Conses14–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
assoc, assoc-if, assoc-if-not
assoc-if-not predicate alist &key key!entry
Arguments and Values:
item|an object .
alist|an association list .
predicate |adesignator for a function of one argument that returns a generalized boolean .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
entry |acons that is an element ofalist, ornil.
Description:
assoc ,assoc-if , andassoc-if-not return the rst cons inalist whose car satises the test , ornilif
no such cons is found.
Forassoc ,assoc-if , andassoc-if-not , ifnilappears in alist in place of a pair, it is ignored.
Examples:
(setq values ’((x . 100) (y . 200) (z . 50))) !((X . 100) (Y . 200) (Z . 50))
(assoc ’y values) !(Y . 200)
(rplacd (assoc ’y values) 201) !(Y . 201)
(assoc ’y values) !(Y . 201)
(setq alist ’((1 . "one")(2 . "two")(3 . "three")))
!((1 . "one") (2 . "two") (3 . "three"))
(assoc 2 alist) !(2 . "two")
(assoc-if #’evenp alist) !(2 . "two")
(assoc-if-not #’(lambda(x) (< x 3)) alist) !(3 . "three")
(setq alist ’(("one" . 1)("two" . 2))) !(("one" . 1) ("two" . 2))
(assoc "one" alist) !NIL
(assoc "one" alist :test #’equalp) !("one" . 1)
(assoc "two" alist :key #’(lambda(x) (char x 2))) !NIL
(assoc #\o alist :key #’(lambda(x) (char x 2))) !("two" . 2)
(assoc ’r ’((a . b) (c . d) (r . x) (s . y) (r . z))) !(R . X)
(assoc ’goo ’((foo . bar) (zoo . goo))) !NIL
(assoc ’2 ’((1 a b c) (2 b c d) (-7 x y z))) !(2 B C D)
(setq alist ’(("one" . 1) ("2" . 2) ("three" . 3)))
!(("one" . 1) ("2" . 2) ("three" . 3))
(assoc-if-not #’alpha-char-p alist
:key #’(lambda (x) (char x 0))) !("2" . 2)
14–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifalist is not an association list .
See Also:
rassoc ,ﬁnd,member ,position , Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
The functionassoc-if-not is deprecated.
It is possible to rplacd the result of assoc , provided that it is not nil, in order to \update" alist.
The two expressions
(assoc item list :test fn)
and
(find item list :test fn :key #’car)
are equivalent in meaning with one exception: if nilappears in alist in place of a pair, and item
isnil,ﬁnd will compute the carof thenilinalist, nd that it is equal to item, and return nil,
whereasassoc will ignore the nilinalist and continue to search for an actual cons whose carisnil.
copy-alist Function
Syntax:
copy-alist alist!new-alist
Arguments and Values:
alist|an association list .
new-alist |an association list .
Description:
copy-alist returns a copy ofalist.
The list structure ofalist is copied, and the elements ofalist which are conses are also copied (as
conses only). Any other objects which are referred to, whether directly or indirectly, by the alist
continue to be shared.
Examples:
(defparameter *alist* (acons 1 "one" (acons 2 "two" ’())))
Conses14–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
*alist*!((1 . "one") (2 . "two"))
(defparameter *list-copy* (copy-list *alist*))
*list-copy*!((1 . "one") (2 . "two"))
(defparameter *alist-copy* (copy-alist *alist*))
*alist-copy*!((1 . "one") (2 . "two"))
(setf (cdr (assoc 2 *alist-copy*)) "deux") !"deux"
*alist-copy*!((1 . "one") (2 . "deux"))
*alist*!((1 . "one") (2 . "two"))
(setf (cdr (assoc 1 *list-copy*)) "uno") !"uno"
*list-copy*!((1 . "uno") (2 . "two"))
*alist*!((1 . "uno") (2 . "two"))
See Also:
copy-list
pairlis Function
Syntax:
pairlis keys data &optional alist!new-alist
Arguments and Values:
keys|aproper list .
data|aproper list .
alist|an association list . The default is the empty list .
new-alist |an association list .
Description:
Returns an association list that associates elements of keys to corresponding elements of data. The
consequences are undened if keys and data are not of the same length .
Ifalist is supplied, pairlis returns a modied alist with the new pairs prepended to it. The new
pairs may appear in the resulting association list in either forward or backward order. The result
of
(pairlis ’(one two) ’(1 2) ’((three . 3) (four . 19)))
might be
((one . 1) (two . 2) (three . 3) (four . 19))
or
14–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
((two . 2) (one . 1) (three . 3) (four . 19))
Examples:
(setq keys ’(1 2 3)
data ’("one" "two" "three")
alist ’((4 . "four"))) !((4 . "four"))
(pairlis keys data) !((3 . "three") (2 . "two") (1 . "one"))
(pairlis keys data alist)
!((3 . "three") (2 . "two") (1 . "one") (4 . "four"))
alist!((4 . "four"))
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifkeys and data are not proper lists .
See Also:
acons
rassoc,rassoc-if,rassoc-if-not Function
Syntax:
rassoc item alist &key key test test-not !entry
rassoc-if predicate alist &key key!entry
rassoc-if-not predicate alist &key key!entry
Arguments and Values:
item|an object .
alist|an association list .
predicate |adesignator for a function of one argument that returns a generalized boolean .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
entry |acons that is an element of the alist, ornil.
Conses14–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
rassoc ,rassoc-if , andrassoc-if-not return the rst cons whose cdr satises the test . If no such
cons is found, nilis returned.
Ifnilappears in alist in place of a pair, it is ignored.
Examples:
(setq alist ’((1 . "one") (2 . "two") (3 . 3)))
!((1 . "one") (2 . "two") (3 . 3))
(rassoc 3 alist) !(3 . 3)
(rassoc "two" alist) !NIL
(rassoc "two" alist :test ’equal) !(2 . "two")
(rassoc 1 alist :key #’(lambda (x) (if (numberp x) (/ x 3)))) !(3 . 3)
(rassoc ’a ’((a . b) (b . c) (c . a) (z . a))) !(C . A)
(rassoc-if #’stringp alist) !(1 . "one")
(rassoc-if-not #’vectorp alist) !(3 . 3)
See Also:
assoc , Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
The functionrassoc-if-not is deprecated.
It is possible to rplaca the result of rassoc , provided that it is not nil, in order to \update" alist.
The expressions
(rassoc item list :test fn)
and
(find item list :test fn :key #’cdr)
are equivalent in meaning, except when the item isnilandnilappears in place of a pair in the
alist. See the functionassoc .
get-properties Function
Syntax:
get-properties plist indicator-list !indicator, value, tail
Arguments and Values:
14–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
plist|aproperty list .
indicator-list |aproper list (ofindicators ).
indicator |an object that is an element ofindicator-list .
value |an object .
tail|alist.
Description:
get-properties is used to look up any of several property list entries all at once.
It searches the plist for the rst entry whose indicator isidentical to one of the objects in
indicator-list . If such an entry is found, the indicator and value returned are the property indicator
and its associated property value , and the tailreturned is the tailof the plist that begins with the
found entry ( i.e., whose caris the indicator ). If no such entry is found, the indicator ,value , and tail
are allnil.
Examples:
(setq x ’())!NIL
(setq *indicator-list* ’(prop1 prop2)) !(PROP1 PROP2)
(getf x ’prop1) !NIL
(setf (getf x ’prop1) ’val1) !VAL1
(eq (getf x ’prop1) ’val1) !true
(get-properties x *indicator-list*) !PROP1, VAL1, (PROP1 VAL1)
x!(PROP1 VAL1)
See Also:
get,getf
getf Accessor
Syntax:
getf plist indicator &optional default!value
(setf (getf place indicator &optional default)new-value )
Arguments and Values:
plist|aproperty list .
place |aplace , the value of which is a property list .
Conses14–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
getf
indicator |an object .
default |an object . The default is nil.
value |an object .
new-value |an object .
Description:
getf nds a property on the plist whose property indicator isidentical toindicator , and returns its
corresponding property value . If there are multiple properties 1with that property indicator ,getf
uses the rst such property . If there is no property with that property indicator ,default is returned.
setf ofgetf may be used to associate a new object with an existing indicator in the property list
held by place , or to create a new assocation if none exists. If there are multiple properties 1with
that property indicator ,setf ofgetf associates the new-value with the rst such property . When a
getf form is used as a setf place , any default which is supplied is evaluated according to normal
left-to-right evaluation rules, but its value is ignored.
setf ofgetf is permitted to either write thevalue ofplace itself, or modify of any part, carorcdr,
of the list structure held by place .
Examples:
(setq x ’())!NIL
(getf x ’prop1) !NIL
(getf x ’prop1 7) !7
(getf x ’prop1) !NIL
(setf (getf x ’prop1) ’val1) !VAL1
(eq (getf x ’prop1) ’val1) !true
(getf x ’prop1) !VAL1
(getf x ’prop1 7) !VAL1
x!(PROP1 VAL1)
;; Examples of implementation variation permitted.
(setq foo (list ’a ’b ’c ’d ’e ’f)) !(A B C D E F)
(setq bar (cddr foo)) !(C D E F)
(remf foo ’c)!true
foo!(A B E F)
bar
!(C D E F)or!(C)or!(NIL)or!(C NIL)or!(C D)
14–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
get,get-properties ,setf, Section 5.1.2.2 (Function Call Forms as Places)
Notes:
There is no way (using getf) to distinguish an absent property from one whose value is default ; but
seeget-properties .
Note that while supplying a default argument to getf in asetf situation is sometimes not very
interesting, it is still important because some macros, such as push andincf, require a place
argument which data is both read from and written to. In such a context, if a default argument is
to be supplied for the read situation, it must be syntactically valid for the write situation as well.
For example,
(let ((plist ’()))
(incf (getf plist ’count 0))
plist)!(COUNT 1)
remf Macro
Syntax:
remf place indicator!generalized-boolean
Arguments and Values:
place |aplace .
indicator |an object .
generalized-boolean |ageneralized boolean .
Description:
remf removes from the property list stored in place aproperty 1with a property indicator identical
toindicator . If there are multiple properties 1with the identical key,remf only removes the rst
such property .remf returns false if no such property was found, or true if a property was found.
The property indicator and the corresponding property value are removed in an undened order by
destructively splicing the property list. remf is permitted to either setf place or tosetf any part,
carorcdr, of the list structure held by that place .
For information about the evaluation ofsubforms ofplace , see Section 5.1.1.1 (Evaluation of
Subforms to Places).
Conses14–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(setq x (cons () ())) !(NIL)
(setf (getf (car x) ’prop1) ’val1) !VAL1
(remf (car x) ’prop1) !true
(remf (car x) ’prop1) !false
Side Eﬀects:
The property list stored in place is modied.
See Also:
remprop ,getf
intersection,nintersection Function
Syntax:
intersection list-1 list-2 &key key test test-not !result-list
nintersection list-1 list-2 &key key test test-not !result-list
Arguments and Values:
list-1 |aproper list .
list-2 |aproper list .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
result-list |alist.
Description:
intersection andnintersection return a listthat contains every element that occurs in both list-1
and list-2 .
nintersection is the destructive version of intersection . It performs the same operation, but may
destroy list-1 using its cells to construct the result. list-2 is not destroyed.
The intersection operation is described as follows. For all possible ordered pairs consisting of one
element from list-1 and one element from list-2 ,:test or:test-not are used to determine whether
they satisfy the test . The rst argument to the :test or:test-not function is an element of list-1 ;
the second argument is an element of list-2 . If:test or:test-not is not supplied, eqlis used. It is
an error if :test and:test-not are supplied in the same function call.
14–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
intersection, nintersection
If:key is supplied (and not nil), it is used to extract the part to be tested from the listelement.
The argument to the :key function is an element of either list-1 orlist-2 ; the:key function typically
returns part of the supplied element. If :key is not supplied or nil, the list-1 and list-2 elements are
used.
For every pair that saties the test , exactly one of the two elements of the pair will be put in the
result. No element from either listappears in the result that does not satisfy the test for an element
from the other list. If one of the lists contains duplicate elements, there may be duplication in the
result.
There is no guarantee that the order of elements in the result will reect the ordering of the
arguments in any particular way. The result listmay share cells with, or be eqto, either list-1 or
list-2 if appropriate.
Examples:
(setq list1 (list 1 1 2 3 4 a b c "A" "B" "C" "d")
list2 (list 1 4 5 b c d "a" "B" "c" "D"))
!(1 4 5 B C D "a" "B" "c" "D")
(intersection list1 list2) !(C B 4 1 1)
(intersection list1 list2 :test ’equal) !("B" C B 4 1 1)
(intersection list1 list2 :test #’equalp) !("d" "C" "B" "A" C B 4 1 1)
(nintersection list1 list2) !(1 1 4 B C)
list1!implementation-dependent ;e.g., (1 1 4 B C)
list2!implementation-dependent ;e.g., (1 4 5 B C D "a" "B" "c" "D")
(setq list1 (copy-list ’((1 . 2) (2 . 3) (3 . 4) (4 . 5))))
!((1 . 2) (2 . 3) (3 . 4) (4 . 5))
(setq list2 (copy-list ’((1 . 3) (2 . 4) (3 . 6) (4 . 8))))
!((1 . 3) (2 . 4) (3 . 6) (4 . 8))
(nintersection list1 list2 :key #’cdr) !((2 . 3) (3 . 4))
list1!implementation-dependent ;e.g., ((1 . 2) (2 . 3) (3 . 4))
list2!implementation-dependent ;e.g., ((1 . 3) (2 . 4) (3 . 6) (4 . 8))
Side Eﬀects:
nintersection can modify list-1 , but not list-2 .
Exceptional Situations:
Should be prepared to signal an error of typetype-error iflist-1 and list-2 are not proper lists .
See Also:
union , Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
Since the nintersection side eect is not required, it should not be used in for-eect-only positions
Conses14–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
in portable code.
adjoin Function
Syntax:
adjoin item list &key key test test-not !new-list
Arguments and Values:
item|an object .
list|aproper list .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
new-list |alist.
Description:
Tests whether item is the same as an existing element of list. If the item is not an existing element,
adjoin adds it to list(as if bycons) and returns the resulting list; otherwise, nothing is added and
the original listis returned.
The test,test-not , and keyaect how it is determined whether item is the same as an element of
list. For details, see Section 17.2.1 (Satisfying a Two-Argument Test).
Examples:
(setq slist ’()) !NIL
(adjoin ’a slist) !(A)
slist!NIL
(setq slist (adjoin ’(test-item 1) slist)) !((TEST-ITEM 1))
(adjoin ’(test-item 1) slist) !((TEST-ITEM 1) (TEST-ITEM 1))
(adjoin ’(test-item 1) slist :test ’equal) !((TEST-ITEM 1))
(adjoin ’(new-test-item 1) slist :key #’cadr) !((TEST-ITEM 1))
(adjoin ’(new-test-item 1) slist) !((NEW-TEST-ITEM 1) (TEST-ITEM 1))
Exceptional Situations:
Should be prepared to signal an error of typetype-error iflistis not a proper list .
See Also:
pushnew , Section 3.6 (Traversal Rules and Side Eects)
14–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
The:test-not parameter is deprecated.
(adjoin item list :key fn)
(if (member (fn item) list :key fn) list (cons item list))
pushnew Macro
Syntax:
pushnew item place &key key test test-not
!new-place-value
Arguments and Values:
item|an object .
place |aplace , the value of which is a proper list .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
new-place-value |alist(the new value ofplace ).
Description:
pushnew tests whether item is the same as any existing element of the liststored in place . Ifitem
is not, it is prepended to the list, and the new listis stored in place .
pushnew returns the new listthat is stored in place .
Whether or not item is already a member of the listthat is in place is determined by comparisons
using:test or:test-not . The rst argument to the :test or:test-not function is item; the second
argument is an element of the listinplace as returned by the :key function (if supplied).
If:key is supplied, it is used to extract the part to be tested from both item and the listelement,
as foradjoin .
The argument to the :key function is an element of the liststored in place . The:key function
typically returns part part of the element of the list. If:key is not supplied or nil, the listelement
is used.
For information about the evaluation ofsubforms ofplace , see Section 5.1.1.1 (Evaluation of
Subforms to Places).
Conses14–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
It is implementation-dependent whether or not pushnew actually executes the storing form for its
place in the situation where the item is already a member of the listheld by place .
Examples:
(setq x ’(a (b c) d)) !(A (B C) D)
(pushnew 5 (cadr x)) !(5 B C)
x!(A (5 B C) D)
(pushnew ’b (cadr x)) !(5 B C)
x!(A (5 B C) D)
(setq lst ’((1) (1 2) (1 2 3))) !((1) (1 2) (1 2 3))
(pushnew ’(2) lst) !((2) (1) (1 2) (1 2 3))
(pushnew ’(1) lst) !((1) (2) (1) (1 2) (1 2 3))
(pushnew ’(1) lst :test ’equal) !((1) (2) (1) (1 2) (1 2 3))
(pushnew ’(1) lst :key #’car) !((1) (2) (1) (1 2) (1 2 3))
Side Eﬀects:
The contents of place may be modied.
See Also:
push ,adjoin , Section 5.1 (Generalized Reference)
Notes:
The eect of (pushnew item place :test p)
is roughly equivalent to (setf place (adjoin item place :test p))
except that the subforms ofplace are evaluated only once, and item is evaluated before place .
set-diﬀerence,nset-diﬀerence Function
Syntax:
set-diﬀerence list-1 list-2 &key key test test-not !result-list
nset-diﬀerence list-1 list-2 &key key test test-not !result-list
Arguments and Values:
list-1 |aproper list .
list-2 |aproper list .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
14–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
set-diﬀerence, nset-diﬀerence
key|adesignator for a function of one argument, or nil.
result-list |alist.
Description:
set-diﬀerence returns a listof elements of list-1 that do not appear in list-2 .
nset-diﬀerence is the destructive version of set-diﬀerence . It may destroy list-1 .
For all possible ordered pairs consisting of one element from list-1 and one element from list-2 , the
:test or:test-not function is used to determine whether they satisfy the test . The rst argument
to the:test or:test-not function is the part of an element of list-1 that is returned by the :key
function (if supplied); the second argument is the part of an element of list-2 that is returned by
the:key function (if supplied).
If:key is supplied, its argument is a list-1 orlist-2 element. The :key function typically returns
part of the supplied element. If :key is not supplied, the list-1 orlist-2 element is used.
An element of list-1 appears in the result if and only if it does not match any element of list-2 .
There is no guarantee that the order of elements in the result will reect the ordering of the
arguments in any particular way. The result listmay share cells with, or be eqto, either of list-1
orlist-2 , if appropriate.
Examples:
(setq lst1 (list "A" "b" "C" "d")
lst2 (list "a" "B" "C" "d")) !("a" "B" "C" "d")
(set-difference lst1 lst2) !("d" "C" "b" "A")
(set-difference lst1 lst2 :test ’equal) !("b" "A")
(set-difference lst1 lst2 :test #’equalp) !NIL
(nset-difference lst1 lst2 :test #’string=) !("A" "b")
(setq lst1 ’(("a" . "b") ("c" . "d") ("e" . "f")))
!(("a" . "b") ("c" . "d") ("e" . "f"))
(setq lst2 ’(("c" . "a") ("e" . "b") ("d" . "a")))
!(("c" . "a") ("e" . "b") ("d" . "a"))
(nset-difference lst1 lst2 :test #’string= :key #’cdr)
!(("c" . "d") ("e" . "f"))
lst1!(("a" . "b") ("c" . "d") ("e" . "f"))
lst2!(("c" . "a") ("e" . "b") ("d" . "a"))
;; Remove all flavor names that contain "c" or "w".
(set-difference ’("strawberry" "chocolate" "banana"
"lemon" "pistachio" "rhubarb")
’(#\c #\w)
:test #’(lambda (s c) (find c s)))
!("banana" "rhubarb" "lemon") ;One possible ordering.
Conses14–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Side Eﬀects:
nset-diﬀerence may destroy list-1 .
Exceptional Situations:
Should be prepared to signal an error of typetype-error iflist-1 and list-2 are not proper lists .
See Also:
Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
set-exclusive-or,nset-exclusive-or Function
Syntax:
set-exclusive-or list-1 list-2 &key key test test-not !result-list
nset-exclusive-or list-1 list-2 &key key test test-not !result-list
Arguments and Values:
list-1 |aproper list .
list-2 |aproper list .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
result-list |alist.
Description:
set-exclusive-or returns a listof elements that appear in exactly one of list-1 and list-2 .
nset-exclusive-or is the destructive version of set-exclusive-or .
For all possible ordered pairs consisting of one element from list-1 and one element from list-2 , the
:test or:test-not function is used to determine whether they satisfy the test .
If:key is supplied, it is used to extract the part to be tested from the list-1 orlist-2 element. The
rst argument to the :test or:test-not function is the part of an element of list-1 extracted by
the:key function (if supplied); the second argument is the part of an element of list-2 extracted by
the:key function (if supplied). If :key is not supplied or nil, the list-1 orlist-2 element is used.
14–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The result contains precisely those elements of list-1 and list-2 that appear in no matching pair.
The result listofset-exclusive-or might share storage with one of list-1 orlist-2 .
Examples:
(setq lst1 (list 1 "a" "b")
lst2 (list 1 "A" "b")) !(1 "A" "b")
(set-exclusive-or lst1 lst2) !("b" "A" "b" "a")
(set-exclusive-or lst1 lst2 :test #’equal) !("A" "a")
(set-exclusive-or lst1 lst2 :test ’equalp) !NIL
(nset-exclusive-or lst1 lst2) !("a" "b" "A" "b")
(setq lst1 (list (("a" . "b") ("c" . "d") ("e" . "f"))))
!(("a" . "b") ("c" . "d") ("e" . "f"))
(setq lst2 (list (("c" . "a") ("e" . "b") ("d" . "a"))))
!(("c" . "a") ("e" . "b") ("d" . "a"))
(nset-exclusive-or lst1 lst2 :test #’string= :key #’cdr)
!(("c" . "d") ("e" . "f") ("c" . "a") ("d" . "a"))
lst1!(("a" . "b") ("c" . "d") ("e" . "f"))
lst2!(("c" . "a") ("d" . "a"))
Side Eﬀects:
nset-exclusive-or is permitted to modify any part, carorcdr, of the list structure oflist-1 orlist-2 .
Exceptional Situations:
Should be prepared to signal an error of typetype-error iflist-1 and list-2 are not proper lists .
See Also:
Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
Since the nset-exclusive-or side eect is not required, it should not be used in for-eect-only
positions in portable code.
subsetp Function
Syntax:
subsetp list-1 list-2 &key key test test-not !generalized-boolean
Conses14–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments and Values:
list-1 |aproper list .
list-2 |aproper list .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
generalized-boolean |ageneralized boolean .
Description:
subsetp returns true if every element of list-1 matches some element of list-2 , and false otherwise.
Whether a list element is the same as another list element is determined by the functions specied
by the keyword arguments. The rst argument to the :test or:test-not function is typically part
of an element of list-1 extracted by the :key function; the second argument is typically part of an
element of list-2 extracted by the :key function.
The argument to the :key function is an element of either list-1 orlist-2 ; the return value is part of
the element of the supplied list element. If :key is not supplied or nil, the list-1 orlist-2 element
itself is supplied to the :test or:test-not function.
Examples:
(setq cosmos ’(1 "a" (1 2))) !(1 "a" (1 2))
(subsetp ’(1) cosmos) !true
(subsetp ’((1 2)) cosmos) !false
(subsetp ’((1 2)) cosmos :test ’equal) !true
(subsetp ’(1 "A") cosmos :test #’equalp) !true
(subsetp ’((1) (2)) ’((1) (2))) !false
(subsetp ’((1) (2)) ’((1) (2)) :key #’car) !true
Exceptional Situations:
Should be prepared to signal an error of typetype-error iflist-1 and list-2 are not proper lists .
See Also:
Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
14–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
union, nunion
union,nunion Function
Syntax:
union list-1 list-2 &key key test test-not !result-list
nunion list-1 list-2 &key key test test-not !result-list
Arguments and Values:
list-1 |aproper list .
list-2 |aproper list .
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
result-list |alist.
Description:
union andnunion return a listthat contains every element that occurs in either list-1 orlist-2 .
For all possible ordered pairs consisting of one element from list-1 and one element from list-2 ,
:test or:test-not is used to determine whether they satisfy the test . The rst argument to the
:test or:test-not function is the part of the element of list-1 extracted by the :key function (if
supplied); the second argument is the part of the element of list-2 extracted by the :key function
(if supplied).
The argument to the :key function is an element of list-1 orlist-2 ; the return value is part of the
supplied element. If :key is not supplied or nil, the element of list-1 orlist-2 itself is supplied to
the:test or:test-not function.
For every matching pair, one of the two elements of the pair will be in the result. Any element
from either list-1 orlist-2 that matches no element of the other will appear in the result.
If there is a duplication between list-1 and list-2 , only one of the duplicate instances will be in the
result. If either list-1 orlist-2 has duplicate entries within it, the redundant entries might or might
not appear in the result.
The order of elements in the result do not have to reect the ordering of list-1 orlist-2 in any way.
The result listmay beeqto either list-1 orlist-2 if appropriate.
Conses14–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
union, nunion
Examples:
(union ’(a b c) ’(f a d))
!(A B C F D)or!(B C F A D)or!(D F A B C)
(union ’((x 5) (y 6)) ’((z 2) (x 4)) :key #’car)
!((X 5) (Y 6) (Z 2))or!((X 4) (Y 6) (Z 2))
(setq lst1 (list 1 2 ’(1 2) "a" "b")
lst2 (list 2 3 ’(2 3) "B" "C"))
!(2 3 (2 3) "B" "C")
(nunion lst1 lst2)
!(1 (1 2) "a" "b" 2 3 (2 3) "B" "C")or!(1 2 (1 2) "a" "b" "C" "B" (2 3) 3)
Side Eﬀects:
nunion is permitted to modify any part, carorcdr, of the list structure oflist-1 orlist-2 .
Exceptional Situations:
Should be prepared to signal an error of typetype-error iflist-1 and list-2 are not proper lists .
See Also:
intersection , Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not parameter is deprecated.
Since the nunion side eect is not required, it should not be used in for-eect-only positions in
portable code.
14–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
15. Arrays
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arraysiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
15.1 Array Concepts
15.1.1 Array Elements
Anarray contains a set of objects called elements that can be referenced individually according to
a rectilinear coordinate system.
15.1.1.1 Array Indices
Anarray element is referred to by a (possibly empty) series of indices. The length of the series
must equal the rank of the array . Each index must be a non-negative xnum less than the
corresponding array dimension .Array indexing is zero-origin.
15.1.1.2 Array Dimensions
An axis of an array is called a dimension .
Each dimension is a non-negative xnum ; if any dimension of an array is zero, the array has no
elements. It is permissible for a dimension to be zero, in which case the array has no elements,
and any attempt to access anelement is an error. However, other properties of the array , such as
thedimensions themselves, may be used.
15.1.1.2.1 Implementation Limits on Individual Array Dimensions
Animplementation may impose a limit on dimensions of an array , but there is a minimum
requirement on that limit. See the variablearray-dimension-limit .
15.1.1.3 Array Rank
Anarray can have any number of dimensions (including zero). The number of dimensions is called
therank .
If the rank of an array is zero then the array is said to have no dimensions , and the product of the
dimensions (see array-total-size ) is then 1; a zero-rank array therefore has a single element.
15.1.1.3.1 Vectors
Anarray ofrank one ( i.e., a one-dimensional array ) is called a vector .
Arrays15–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
15.1.1.3.1.1 Fill Pointers
All pointer is a non-negative integer no larger than the total number of elements in a vector .
Not all vectors have ll pointers . See the functions make-array andadjust-array .
Anelement of a vector is said to be active if it has an index that is greater than or equal to
zero, but less than the ll pointer (if any). For an array that has no ll pointer , all elements are
considered active .
Only vectors may have ll pointers ; multidimensional arrays may not. A multidimensional array
that is displaced to a vector that has a ll pointer can be created.
15.1.1.3.2 Multidimensional Arrays
15.1.1.3.2.1 Storage Layout for Multidimensional Arrays
Multidimensional arrays store their components in row-major order; that is, internally a
multidimensional array is stored as a one-dimensional array , with the multidimensional index sets
ordered lexicographically, last index varying fastest.
15.1.1.3.2.2 Implementation Limits on Array Rank
Animplementation may impose a limit on the rank of an array , but there is a minimum requirement
on that limit. See the variablearray-rank-limit .
15.1.2 Specialized Arrays
Anarray can be a general array , meaning each element may be any object , or it may be a
specialized array , meaning that each element must be of a restricted type.
The phrasing \an array specialized totypehhtypeii" is sometimes used to emphasize the element
type of an array . This phrasing is tolerated even when the hhtypeiiist, even though an array
specialized totype t is ageneral array , not a specialized array .
Figure 15{1 lists some dened names that are applicable to array creation, access , and information
operations.
adjust-array array-has-ﬁll-pointer-p make-array
adjustable-array-p array-in-bounds-p svref
aref array-rank upgraded-array-element-type
array-dimension array-rank-limit upgraded-complex-part-type
array-dimension-limit array-row-major-index vector
array-dimensions array-total-size vector-pop
array-displacement array-total-size-limit vector-push
array-element-type ﬁll-pointer vector-push-extend
Figure 15–1. General Purpose Array-Related Deﬁned Names
15–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
15.1.2.1 Array Upgrading
Theupgraded array element type of a typeT1is atypeT2that is a supertype ofT1and that
is used instead of T1wheneverT1is used as an array element type for object creation or type
discrimination.
During creation of an array , the element type that was requested is called the expressed array
element type . The upgraded array element type of the expressed array element type becomes the
actual array element type of the array that is created.
Type upgrading implies a movement upwards in the type hierarchy lattice. A type is always a
subtype of its upgraded array element type . Also, if a typeTxis asubtype of another typeTy, then
theupgraded array element type ofTxmust be a subtype of the upgraded array element type ofTy.
Two disjoint types can be upgraded to the same type.
The upgraded array element type T2of a typeT1is a function only of T1itself; that is, it
is independent of any other property of the array for whichT2will be used, such as rank,
adjustability ,ll pointers , or displacement. The function upgraded-array-element-type can be
used by conforming programs to predict how the implementation willupgrade a given type.
15.1.2.2 Required Kinds of Specialized Arrays
Vectors whose elements are restricted to typecharacter or a subtype ofcharacter are called
strings .Strings are of typestring . Figure 15{2 lists some dened names related to strings .
Strings arespecialized arrays and might logically have been included in this chapter. However, for
purposes of readability most information about strings does not appear in this chapter; see instead
Chapter 16 (Strings).
char string-equal string-upcase
make-string string-greaterp string /=
nstring-capitalize string-left-trim string <
nstring-downcase string-lessp string <=
nstring-upcase string-not-equal string =
schar string-not-greaterp string >
string string-not-lessp string >=
string-capitalize string-right-trim
string-downcase string-trim
Figure 15–2. Operators that Manipulate Strings
Vectors whose elements are restricted to typebitare called bit vectors .Bit vectors are of type
bit-vector . Figure 15{3 lists some dened names for operations on bit arrays .
Arrays15–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
bit bit-ior bit-orc2
bit-and bit-nand bit-xor
bit-andc1 bit-nor sbit
bit-andc2 bit-not
bit-eqv bit-orc1
Figure 15–3. Operators that Manipulate Bit Arrays
15–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
array System Class
Class Precedence List:
array ,t
Description:
Anarray contains objects arranged according to a Cartesian coordinate system. An array provides
mappings from a set of xnumsfi0;i1;:::;i r 1gto corresponding elements of the array , where
0ij<dj,ris the rank of the array, and djis the size of dimensionjof the array.
When an array is created, the program requesting its creation may declare that all elements are
of a particular type, called the expressed array element type . The implementation is permitted to
upgrade this type in order to produce the actual array element type , which is the element type for
thearray is actually specialized . See the functionupgraded-array-element-type .
Compound Type Speciﬁer Kind:
Specializing.
Compound Type Speciﬁer Syntax:
(array [felement-typej*g[dimension-spec ]])
dimension-spec:: =rankj*j(fdimensionj*g*)
Compound Type Speciﬁer Arguments:
dimension |avalid array dimension .
element-type |atype specier .
rank|a non-negative xnum .
Compound Type Speciﬁer Description:
This denotes the set of arrays whose element type ,rank, and dimensions match any given
element-type ,rank, and dimensions . Specically:
Ifelement-type is the symbol*,arrays are not excluded on the basis of their element type .
Otherwise, only those arrays are included whose actual array element type is the result of upgrading
element-type ; see Section 15.1.2.1 (Array Upgrading).
If the dimension-spec is a rank, the set includes only those arrays having that rank. If the
dimension-spec is alistofdimensions , the set includes only those arrays having a rank given by the
length of the dimensions , and having the indicated dimensions ; in this case, *matches any value for
the corresponding dimension . If the dimension-spec is the symbol*, the set is not restricted on the
basis of rank ordimension .
Arrays15–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
*print-array* ,aref,make-array ,vector , Section 2.4.8.12 (Sharpsign A), Section 22.1.3.8 (Printing
Other Arrays)
Notes:
Note that the type (array t) is a proper subtype of the type (array *) . The reason is that the
type(array t) is the set of arrays that can hold any object (the elements are of typet, which
includes all objects ). On the other hand, the type (array *) is the set of all arrays whatsoever,
including for example arrays that can hold only characters . The type (array character) is not a
subtype of the type (array t) ; the two sets are disjoint because the type (array character) is not
the set of all arrays that can hold characters , but rather the set of arrays that are specialized to
hold precisely characters and no other objects .
simple-array Type
Supertypes:
simple-array ,array ,t
Description:
The type of an array that is not displaced to another array , has no ll pointer , and is not expressly
adjustable is a subtype oftypesimple-array . The concept of a simple array exists to allow the
implementation to use a specialized representation and to allow the user to declare that certain
values will always be simple arrays .
The typessimple-vector ,simple-string , andsimple-bit-vector aredisjoint subtypes of
typesimple-array , for they respectively mean (simple-array t (*)) , the union of all
(simple-array c(*)) for any cbeing a subtype oftypecharacter , and(simple-array bit (*)) .
Compound Type Speciﬁer Kind:
Specializing.
Compound Type Speciﬁer Syntax:
(simple-array [felement-typej*g[dimension-spec ]])
dimension-spec:: =rankj*j(fdimensionj*g*)
Compound Type Speciﬁer Arguments:
dimension |avalid array dimension .
element-type |atype specier .
rank|a non-negative xnum .
15–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compound Type Speciﬁer Description:
This compound type specier is treated exactly as the corresponding compound type specier for
typearray would be treated, except that the set is further constrained to include only simple
arrays .
Notes:
It is implementation-dependent whether displaced arrays ,vectors with ll pointers , or arrays that
areactually adjustable aresimple arrays .
(simple-array *) refers to all simple arrays regardless of element type, (simple-array type-
specier)refers only to those simple arrays that can result from giving type-specier as the
:element-type argument to make-array .
vector System Class
Class Precedence List:
vector ,array ,sequence ,t
Description:
Any one-dimensional array is avector .
The typevector is asubtype oftypearray ; for all typesx,(vector x) is the same as (array x (*)) .
The type(vector t) , the typestring , and the typebit-vector aredisjoint subtypes oftypevector .
Compound Type Speciﬁer Kind:
Specializing.
Compound Type Speciﬁer Syntax:
(vector [felement-typej*g[fsizej*g]])
Compound Type Speciﬁer Arguments:
size|a non-negative xnum .
element-type |atype specier .
Compound Type Speciﬁer Description:
This denotes the set of specialized vectors whose element type and dimension match the specied
values. Specically:
Ifelement-type is the symbol*,vectors are not excluded on the basis of their element type .
Otherwise, only those vectors are included whose actual array element type is the result of
upgrading element-type ; see Section 15.1.2.1 (Array Upgrading).
Arrays15–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If a sizeis specied, the set includes only those vectors whose only dimension issize. If the symbol
*is specied instead of a size, the set is not restricted on the basis of dimension .
See Also:
Section 15.1.2.2 (Required Kinds of Specialized Arrays), Section 2.4.8.3 (Sharpsign Left-
Parenthesis), Section 22.1.3.7 (Printing Other Vectors), Section 2.4.8.12 (Sharpsign A)
Notes:
The type(vector e s)is equivalent to the type(array e(s)).
The type (vector bit) has the name bit-vector .
The union of all types(vectorC), whereCis any subtype ofcharacter , has the name string .
(vector *) refers to all vectors regardless of element type, (vector type-specier )refers only
to those vectors that can result from giving type-specier as the:element-type argument to
make-array .
simple-vector Type
Supertypes:
simple-vector ,vector ,simple-array ,array ,sequence ,t
Description:
The type of a vector that is not displaced to another array , has no ll pointer , is not expressly
adjustable and is able to hold elements of any type is asubtype oftypesimple-vector .
The typesimple-vector is asubtype oftypevector , and is a subtype oftype(vector t) .
Compound Type Speciﬁer Kind:
Specializing.
Compound Type Speciﬁer Syntax:
(simple-vector [ size])
Compound Type Speciﬁer Arguments:
size|a non-negative xnum , or the symbol*. The default is the symbol*.
Compound Type Speciﬁer Description:
This is the same as (simple-array t ( size)).
15–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
bit-vector System Class
Class Precedence List:
bit-vector ,vector ,array ,sequence ,t
Description:
Abit vector is avector theelement type of which is bit.
The typebit-vector is asubtype oftypevector , forbit-vector means(vector bit) .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(bit-vector [ size])
Compound Type Speciﬁer Arguments:
size|a non-negative xnum , or the symbol*.
Compound Type Speciﬁer Description:
This denotes the same type as the type(array bit ( size)); that is, the set of bit vectors of size size.
See Also:
Section 2.4.8.4 (Sharpsign Asterisk), Section 22.1.3.6 (Printing Bit Vectors), Section 15.1.2.2
(Required Kinds of Specialized Arrays)
simple-bit-vector Type
Supertypes:
simple-bit-vector ,bit-vector ,vector ,simple-array ,array ,sequence ,t
Description:
The type of a bit vector that is not displaced to another array , has no ll pointer , and is not
expressly adjustable is asubtype oftypesimple-bit-vector .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(simple-bit-vector [ size])
Arrays15–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compound Type Speciﬁer Arguments:
size|a non-negative xnum , or the symbol*. The default is the symbol*.
Compound Type Speciﬁer Description:
This denotes the same type as the type(simple-array bit ( size)); that is, the set of simple bit
vectors of size size.
make-array Function
Syntax:
make-array dimensions &key element-type
initial-element
initial-contents
adjustable
ll-pointer
displaced-to
displaced-index-oset
!new-array
Arguments and Values:
dimensions |adesignator for a listofvalid array dimensions .
element-type |atype specier . The default is t.
initial-element |an object .
initial-contents |an object .
adjustable |ageneralized boolean . The default is nil.
ll-pointer |avalid ll pointer for the array to be created, or tornil. The default is nil.
displaced-to |an array ornil. The default is nil. This option must not be supplied if either
initial-element orinitial-contents is supplied.
displaced-index-oset |avalid array row-major index fordisplaced-to . The default is 0. This option
must not be supplied unless a non-nil displaced-to is supplied.
new-array |an array .
15–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-array
Description:
Creates and returns an array constructed of the most specialized type that can accommodate
elements of type given by element-type . Ifdimensions isnilthen a zero-dimensional array is created.
Dimensions represents the dimensionality of the new array .
element-type indicates the type of the elements intended to be stored in the new-array . The
new-array can actually store any objects of the type which results from upgrading element-type ; see
Section 15.1.2.1 (Array Upgrading).
Ifinitial-element is supplied, it is used to initialize each element ofnew-array . If initial-element is
supplied, it must be of the type given by element-type .initial-element cannot be supplied if either
the:initial-contents option is supplied or displaced-to isnon-nil . Ifinitial-element is not supplied,
the consequences of later reading an uninitialized element ofnew-array are undened unless either
initial-contents is supplied or displaced-to isnon-nil .
initial-contents is used to initialize the contents of array . For example:
(make-array ’(4 2 3) :initial-contents
’(((a b c) (1 2 3))
((d e f) (3 1 2))
((g h i) (2 3 1))
((j k l) (0 0 0))))
initial-contents is composed of a nested structure of sequences . The numbers of levels in the
structure must equal the rank of array . Each leaf of the nested structure must be of the type given
byelement-type . If array is zero-dimensional, then initial-contents species the single element .
Otherwise, initial-contents must be a sequence whose length is equal to the rst dimension; each
element must be a nested structure for an array whose dimensions are the remaining dimensions,
and so on. Initial-contents cannot be supplied if either initial-element is supplied or displaced-to is
non-nil . Ifinitial-contents is not supplied, the consequences of later reading an uninitialized element
ofnew-array are undened unless either initial-element is supplied or displaced-to isnon-nil .
Ifadjustable isnon-nil , the array is expressly adjustable (and so actually adjustable ); otherwise, the
array is not expressly adjustable (and it is implementation-dependent whether the array is actually
adjustable ).
Ifll-pointer isnon-nil , the array must be one-dimensional; that is, the array must be a vector .
Ifll-pointer ist, the length of the vector is used to initialize the ll pointer . If ll-pointer is an
integer , it becomes the initial ll pointer for the vector .
Ifdisplaced-to isnon-nil ,make-array will create a displaced array and displaced-to is the target of
that displaced array . In that case, the consequences are undened if the actual array element type
ofdisplaced-to is not type equivalent to the actual array element type of the array being created. If
displaced-to isnil, the array is not a displaced array .
The displaced-index-oset is made to be the index oset of the array . When an array A is given
as the:displaced-to argument tomake-array when creating array B, then array B is said to be
Arrays15–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-array
displaced to array A. The total number of elements in an array , called the total size of the array , is
calculated as the product of all the dimensions. It is required that the total size of A be no smaller
than the sum of the total size of B plus the oset nsupplied by the displaced-index-oset . The
eect of displacing is that array B does not have any elements of its own, but instead maps accesses
to itself into accesses to array A. The mapping treats both arrays as if they were one-dimensional
by taking the elements in row-major order, and then maps an access to element kof array B to an
access to element k+nof array A.
Ifmake-array is called with adjustable ,ll-pointer , and displaced-to eachnil, then the result is a
simple array . Ifmake-array is called with one or more of adjustable ,ll-pointer , or displaced-to
being true, whether the resulting array is asimple array isimplementation-dependent .
When an array A is given as the :displaced-to argument tomake-array when creating array B,
then array B is said to be displaced to array A. The total number of elements in an array , called
the total size of the array , is calculated as the product of all the dimensions. The consequences
are unspecied if the total size of A is smaller than the sum of the total size of B plus the oset
nsupplied by the displaced-index-oset . The eect of displacing is that array B does not have any
elements of its own, but instead maps accesses to itself into accesses to array A. The mapping
treats both arrays as if they were one-dimensional by taking the elements in row-major order, and
then maps an access to element kof array B to an access toelement k+nof array A.
Examples:
(make-array 5) ;; Creates a one-dimensional array of five elements.
(make-array ’(3 4) :element-type ’(mod 16)) ;; Creates a
;;two-dimensional array, 3 by 4, with four-bit elements.
(make-array 5 :element-type ’single-float) ;; Creates an array of single-floats.
(make-array nil :initial-element nil) !#0ANIL
(make-array 4 :initial-element nil) !#(NIL NIL NIL NIL)
(make-array ’(2 4)
:element-type ’(unsigned-byte 2)
:initial-contents ’((0 1 2 3) (3 2 1 0)))
!#2A((0 1 2 3) (3 2 1 0))
(make-array 6
:element-type ’character
:initial-element #\a
:fill-pointer 3) !"aaa"
The following is an example of making a displaced array .
(setq a (make-array ’(4 3)))
!#<ARRAY 4x3 simple 32546632>
(dotimes (i 4)
(dotimes (j 3)
(setf (aref a i j) (list i ’x j ’= (* i j)))))
!NIL
15–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setq b (make-array 8 :displaced-to a
:displaced-index-offset 2))
!#<ARRAY 8 indirect 32550757>
(dotimes (i 8)
(print (list i (aref b i))))
.(0 (0 X 2 = 0))
.(1 (1 X 0 = 0))
.(2 (1 X 1 = 1))
.(3 (1 X 2 = 2))
.(4 (2 X 0 = 0))
.(5 (2 X 1 = 2))
.(6 (2 X 2 = 4))
.(7 (3 X 0 = 0))
!NIL
The last example depends on the fact that arrays are, in eect, stored in row-major order.
(setq a1 (make-array 50))
!#<ARRAY 50 simple 32562043>
(setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))
!#<ARRAY 20 indirect 32563346>
(length b1)!20
(setq a2 (make-array 50 :fill-pointer 10))
!#<ARRAY 50 fill-pointer 10 46100216>
(setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))
!#<ARRAY 20 indirect 46104010>
(length a2)!10
(length b2)!20
(setq a3 (make-array 50 :fill-pointer 10))
!#<ARRAY 50 fill-pointer 10 46105663>
(setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10
:fill-pointer 5))
!#<ARRAY 20 indirect, fill-pointer 5 46107432>
(length a3)!10
(length b3)!5
See Also:
adjustable-array-p ,aref,arrayp ,array-element-type ,array-rank-limit ,array-dimension-limit ,
ﬁll-pointer ,upgraded-array-element-type
Notes:
There is no specied way to create an array for which adjustable-array-p denitely returns false.
There is no specied way to create an array that is not a simple array .
Arrays15–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
adjust-array
adjust-array Function
Syntax:
adjust-array array new-dimensions &key element-type
initial-element
initial-contents
ll-pointer
displaced-to
displaced-index-oset
!adjusted-array
Arguments and Values:
array |an array .
new-dimensions |avalid array dimension or a listofvalid array dimensions .
element-type |atype specier .
initial-element |an object .Initial-element must not be supplied if either initial-contents ordisplaced-to
is supplied.
initial-contents |an object . Ifarray has rank greater than zero, then initial-contents is composed
of nested sequences , the depth of which must equal the rank of array . Otherwise, array is
zero-dimensional and initial-contents supplies the single element. initial-contents must not be
supplied if either initial-element ordisplaced-to is given.
ll-pointer |avalid ll pointer for the array to be created, or t, ornil. The default is nil.
displaced-to |an array ornil.initial-elements and initial-contents must not be supplied if displaced-to
is supplied.
displaced-index-oset |an object oftype(fixnum 0 n)where nis(array-total-size displaced-to ).
displaced-index-oset may be supplied only if displaced-to is supplied.
adjusted-array |an array .
Description:
adjust-array changes the dimensions or elements of array . The result is an array of the same type
and rank as array , that is either the modied array , or a newly created array to which array can be
displaced, and that has the given new-dimensions .
New-dimensions specify the size of each dimension ofarray .
Element-type species the type of the elements of the resulting array . If element-type is supplied,
the consequences are unspecied if the upgraded array element type ofelement-type is not the same
as the actual array element type ofarray .
15–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
adjust-array
Ifinitial-contents is supplied, it is treated as for make-array . In this case none of the original
contents of array appears in the resulting array .
Ifll-pointer is an integer , it becomes the ll pointer for the resulting array . If ll-pointer is the
symbolt, it indicates that the size of the resulting array should be used as the ll pointer . If
ll-pointer isnil, it indicates that the ll pointer should be left as it is.
Ifdisplaced-to non-nil , adisplaced array is created. The resulting array shares its contents with
thearray given by displaced-to . The resulting array cannot contain more elements than the array
it is displaced to. If displaced-to is not supplied or nil, the resulting array is not a displaced array .
If arrayAis created displaced to array Band subsequently array Bis given to adjust-array ,
arrayAwill still be displaced to array B. Although array might be a displaced array , the resulting
array is not a displaced array unless displaced-to is supplied and not nil. The interaction between
adjust-array and displaced arrays is as follows given three arrays ,A,B, andC:
Ais not displaced before or after the call
(adjust-array A ...)
The dimensions of Aare altered, and the contents rearranged as appropriate. Additional
elements of Aare taken from initial-element . The use of initial-contents causes all old
contents to be discarded.
Ais not displaced before, but is displaced to Cafter the call
(adjust-array A ... :displaced-to C)
None of the original contents of Aappears in Aafterwards; Anow contains the contents of
C, without any rearrangement of C.
Ais displaced to Bbefore the call, and is displaced to Cafter the call
(adjust-array A ... :displaced-to B)
(adjust-array A ... :displaced-to C)
BandCmight be the same. The contents of Bdo not appear in Aafterward unless such
contents also happen to be in CIfdisplaced-index-oset is not supplied in the adjust-array
call, it defaults to zero; the old oset into Bis not retained.
Ais displaced to Bbefore the call, but not displaced afterward.
(adjust-array A ... :displaced-to B)
(adjust-array A ... :displaced-to nil)
Agets a new \data region," and contents of Bare copied into it as appropriate to maintain
the existing old contents; additional elements of Aare taken from initial-element if supplied.
However, the use of initial-contents causes all old contents to be discarded.
Arrays15–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
adjust-array
Ifdisplaced-index-oset is supplied, it species the oset of the resulting array from the beginning
of the array that it is displaced to. If displaced-index-oset is not supplied, the oset is 0. The size
of the resulting array plus the oset value cannot exceed the size of the array that it is displaced
to.
If only new-dimensions and an initial-element argument are supplied, those elements of array that
are still in bounds appear in the resulting array . The elements of the resulting array that are
not in the bounds of array are initialized to initial-element ; ifinitial-element is not provided, the
consequences of later reading any such new element ofnew-array before it has been initialized are
undened.
Ifinitial-contents ordisplaced-to is supplied, then none of the original contents of array appears in
the new array .
The consequences are unspecied if array is adjusted to a size smaller than its ll pointer without
supplying the ll-pointer argument so that its ll-pointer is properly adjusted in the process.
IfAis displaced to B, the consequences are unspecied if Bis adjusted in such a way that it no
longer has enough elements to satisfy A.
Ifadjust-array is applied to an array that is actually adjustable , the array returned is identical
toarray . If the array returned by adjust-array isdistinct from array , then the argument array is
unchanged.
Note that if an arrayAis displaced to another arrayB, andBis displaced to another arrayC,
andBis altered by adjust-array ,Amust now refer to the adjust contents of B. This means that
an implementation cannot collapse the chain to make Arefer toCdirectly and forget that the
chain of reference passes through B. However, caching techniques are permitted as long as they
preserve the semantics specied here.
Examples:
(adjustable-array-p
(setq ada (adjust-array
(make-array ’(2 3)
:adjustable t
:initial-contents ’((a b c) (1 2 3)))
’(4 6))))!T
(array-dimensions ada) !(4 6)
(aref ada 1 1)!2
(setq beta (make-array ’(2 3) :adjustable t))
!#2A((NIL NIL NIL) (NIL NIL NIL))
(adjust-array beta ’(4 6) :displaced-to ada)
!#2A((A B C NIL NIL NIL)
(1 2 3 NIL NIL NIL)
(NIL NIL NIL NIL NIL NIL)
(NIL NIL NIL NIL NIL NIL))
15–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(array-dimensions beta) !(4 6)
(aref beta 1 1) !2
Suppose that the 4-by-4 array in mlooks like this:
#2A(( alpha beta gamma delta )
( epsilon zeta eta theta )
( iota kappa lambda mu )
( nu xi omicron pi ))
Then the result of
(adjust-array m ’(3 5) :initial-element ’baz)
is a 3-by-5 array with contents
#2A(( alpha beta gamma delta baz )
( epsilon zeta eta theta baz )
( iota kappa lambda mu baz ))
Exceptional Situations:
An error of typeerror is signaled if ll-pointer is supplied and non-nil but array has no ll pointer .
See Also:
adjustable-array-p ,make-array ,array-dimension-limit ,array-total-size-limit ,array
adjustable-array-p Function
Syntax:
adjustable-array-p array!generalized-boolean
Arguments and Values:
array |an array .
generalized-boolean |ageneralized boolean .
Description:
Returns true if and only if adjust-array could return a value which is identical toarray when given
that array as its rst argument .
Examples:
(adjustable-array-p
(make-array 5
:element-type ’character
Arrays15–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
:adjustable t
:fill-pointer 3)) !true
(adjustable-array-p (make-array 4)) !implementation-dependent
Exceptional Situations:
Should signal an error of typetype-error if its argument is not an array .
See Also:
adjust-array ,make-array
aref Accessor
Syntax:
aref array&rest subscripts!element
(setf (aref array&rest subscripts )new-element )
Arguments and Values:
array |an array .
subscripts |alistofvalid array indices for the array .
element ,new-element |an object .
Description:
Accesses thearray element specied by the subscripts . If no subscripts are supplied and array is
zero rank, aref accesses the sole element of array .
aref ignores ll pointers . It is permissible to use aref toaccess any array element , whether active
or not.
Examples:
If the variable foonames a 3-by-5 array, then the rst index could be 0, 1, or 2, and then second
index could be 0, 1, 2, 3, or 4. The array elements can be referred to by using the function aref;
for example, (aref foo 2 1) refers to element (2, 1) of the array.
(aref (setq alpha (make-array 4)) 3) !implementation-dependent
(setf (aref alpha 3) ’sirens) !SIRENS
(aref alpha 3)!SIRENS
(aref (setq beta (make-array ’(2 4)
:element-type ’(unsigned-byte 2)
:initial-contents ’((0 1 2 3) (3 2 1 0))))
1 2)!1
15–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setq gamma ’(0 2))
(apply #’aref beta gamma) !2
(setf (apply #’aref beta gamma) 3) !3
(apply #’aref beta gamma) !3
(aref beta 0 2) !3
See Also:
bit,char,elt,row-major-aref ,svref , Section 3.2.1 (Compiler Terminology)
array-dimension Function
Syntax:
array-dimension array axis-number !dimension
Arguments and Values:
array |an array .
axis-number |an integer greater than or equal to zero and less than the rank of the array .
dimension |a non-negative integer .
Description:
array-dimension returns the axis-number dimension 1ofarray . (Any ll pointer is ignored.)
Examples:
(array-dimension (make-array 4) 0) !4
(array-dimension (make-array ’(2 3)) 1) !3
Aﬀected By:
None.
See Also:
array-dimensions ,length
Notes:
(array-dimension array n) (nth n (array-dimensions array))
Arrays15–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
array-dimensions Function
Syntax:
array-dimensions array!dimensions
Arguments and Values:
array |an array .
dimensions |alistofintegers .
Description:
Returns a listof the dimensions ofarray . (If array is avector with a ll pointer , that ll pointer is
ignored.)
Examples:
(array-dimensions (make-array 4)) !(4)
(array-dimensions (make-array ’(2 3))) !(2 3)
(array-dimensions (make-array 4 :fill-pointer 2)) !(4)
Exceptional Situations:
Should signal an error of typetype-error if its argument is not an array .
See Also:
array-dimension
array-element-type Function
Syntax:
array-element-type array!typespec
Arguments and Values:
array |an array .
typespec |atype specier .
Description:
Returns a type specier which represents the actual array element type of the array, which is the
set of objects that such an array can hold. (Because of array upgrading , this type specier can in
some cases denote a supertype of the expressed array element type of the array .)
15–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(array-element-type (make-array 4)) !T
(array-element-type (make-array 12 :element-type ’(unsigned-byte 8)))
!implementation-dependent
(array-element-type (make-array 12 :element-type ’(unsigned-byte 5)))
!implementation-dependent
(array-element-type (make-array 5 :element-type ’(mod 5)))
could be (mod 5) ,(mod 8) ,fixnum ,t, or any other type of which (mod 5) is asubtype .
Aﬀected By:
The implementation .
Exceptional Situations:
Should signal an error of typetype-error if its argument is not an array .
See Also:
array ,make-array ,subtypep ,upgraded-array-element-type
array-has-ﬁll-pointer-p Function
Syntax:
array-has-ﬁll-pointer-p array!generalized-boolean
Arguments and Values:
array |an array .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifarray has a ll pointer ; otherwise returns false.
Examples:
(array-has-fill-pointer-p (make-array 4)) !implementation-dependent
(array-has-fill-pointer-p (make-array ’(2 3))) !false
(array-has-fill-pointer-p
(make-array 8
:fill-pointer 2
:initial-element ’filler)) !true
Arrays15–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Should signal an error of typetype-error if its argument is not an array .
See Also:
make-array ,ﬁll-pointer
Notes:
Since arrays ofrank other than one cannot have a ll pointer ,array-has-ﬁll-pointer-p always
returnsnilwhen its argument is such an array.
array-displacement Function
Syntax:
array-displacement array!displaced-to, displaced-index-oset
Arguments and Values:
array |an array .
displaced-to |an array ornil.
displaced-index-oset |a non-negative xnum .
Description:
If the array is adisplaced array , returns the values of the:displaced-to and:displaced-index-offset
options for the array (see the functions make-array andadjust-array ). If the array is not a
displaced array ,niland0are returned.
Ifarray-displacement is called on an array for which a non-nil object was provided as the
:displaced-to argument tomake-array oradjust-array , it must return that object as its rst
value. It is implementation-dependent whetherarray-displacement returns a non-nil primary
value for any other array .
Examples:
(setq a1 (make-array 5)) !#<ARRAY 5 simple 46115576>
(setq a2 (make-array 4 :displaced-to a1
:displaced-index-offset 1))
!#<ARRAY 4 indirect 46117134>
(array-displacement a2)
!#<ARRAY 5 simple 46115576>, 1
(setq a3 (make-array 2 :displaced-to a2
:displaced-index-offset 2))
!#<ARRAY 2 indirect 46122527>
15–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(array-displacement a3)
!#<ARRAY 4 indirect 46117134>, 2
Exceptional Situations:
Should signal an error of typetype-error ifarray is not an array .
See Also:
make-array
array-in-bounds-p Function
Syntax:
array-in-bounds-p array&rest subscripts!generalized-boolean
Arguments and Values:
array |an array .
subscripts |a list of integers of length equal to the rank of the array .
generalized-boolean |ageneralized boolean .
Description:
Returns true if the subscripts are all in bounds for array ; otherwise returns false. (If array is a
vector with a ll pointer , that ll pointer is ignored.)
Examples:
(setq a (make-array ’(7 11) :element-type ’string-char))
(array-in-bounds-p a 0 0) !true
(array-in-bounds-p a 6 10) !true
(array-in-bounds-p a 0 -1) !false
(array-in-bounds-p a 0 11) !false
(array-in-bounds-p a 7 0) !false
See Also:
array-dimensions
Notes:
(array-in-bounds-p array subscripts)
(and (not (some #’minusp (list subscripts)))
(every #’< (list subscripts) (array-dimensions array)))
Arrays15–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
array-rank Function
Syntax:
array-rank array!rank
Arguments and Values:
array |an array .
rank|a non-negative integer .
Description:
Returns the number of dimensions ofarray .
Examples:
(array-rank (make-array ’())) !0
(array-rank (make-array 4)) !1
(array-rank (make-array ’(4))) !1
(array-rank (make-array ’(2 3))) !2
Exceptional Situations:
Should signal an error of typetype-error if its argument is not an array .
See Also:
array-rank-limit ,make-array
array-row-major-index Function
Syntax:
array-row-major-index array&rest subscripts!index
Arguments and Values:
array |an array .
subscripts |alistofvalid array indices for the array .
index |avalid array row-major index for the array .
15–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Computes the position according to the row-major ordering of array for the element that is specied
bysubscripts , and returns the oset of the element in the computed position from the beginning of
array .
For a one-dimensional array , the result of array-row-major-index equals subscript .
array-row-major-index ignores ll pointers .
Examples:
(setq a (make-array ’(4 7) :element-type ’(unsigned-byte 8)))
(array-row-major-index a 1 2) !9
(array-row-major-index
(make-array ’(2 3 4)
:element-type ’(unsigned-byte 8)
:displaced-to a
:displaced-index-offset 4)
0 2 1)!9
Notes:
A possible denition of array-row-major-index , with no error-checking, is
(defun array-row-major-index (a &rest subscripts)
(apply #’+ (maplist #’(lambda (x y)
(* (car x) (apply #’* (cdr y))))
subscripts
(array-dimensions a))))
array-total-size Function
Syntax:
array-total-size array!size
Arguments and Values:
array |an array .
size|a non-negative integer .
Description:
Returns the array total size of the array .
Arrays15–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(array-total-size (make-array 4)) !4
(array-total-size (make-array 4 :fill-pointer 2)) !4
(array-total-size (make-array 0)) !0
(array-total-size (make-array ’(4 2))) !8
(array-total-size (make-array ’(4 0))) !0
(array-total-size (make-array ’())) !1
Exceptional Situations:
Should signal an error of typetype-error if its argument is not an array .
See Also:
make-array ,array-dimensions
Notes:
If the array is avector with a ll pointer , the ll pointer is ignored when calculating the array total
size.
Since the product of no arguments is one, the array total size of a zero-dimensional array is one.
(array-total-size x)
(apply #’* (array-dimensions x))
(reduce #’* (array-dimensions x))
arrayp Function
Syntax:
arrayp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typearray ; otherwise, returns false.
Examples:
(arrayp (make-array ’(2 3 4) :adjustable t)) !true
(arrayp (make-array 6)) !true
(arrayp #*1011) !true
15–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(arrayp "hi")!true
(arrayp ’hi)!false
(arrayp 12)!false
See Also:
typep
Notes:
(arrayp object)(typep object’array)
ﬁll-pointer Accessor
Syntax:
ﬁll-pointer vector!ll-pointer
(setf (ﬁll-pointer vector)new-ll-pointer )
Arguments and Values:
vector |avector with a ll pointer .
ll-pointer ,new-ll-pointer |avalid ll pointer for the vector .
Description:
Accesses thell pointer ofvector .
Examples:
(setq a (make-array 8 :fill-pointer 4)) !#(NIL NIL NIL NIL)
(fill-pointer a) !4
(dotimes (i (length a)) (setf (aref a i) (* i i))) !NIL
a!#(0 1 4 9)
(setf (fill-pointer a) 3) !3
(fill-pointer a) !3
a!#(0 1 4)
(setf (fill-pointer a) 8) !8
a!#(0 1 4 9 NIL NIL NIL NIL)
Exceptional Situations:
Should signal an error of typetype-error ifvector is not a vector with a ll pointer .
Arrays15–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
make-array ,length
Notes:
There is no operator that will remove a vector 'sll pointer .
row-major-aref Accessor
Syntax:
row-major-aref array index!element
(setf (row-major-aref array index )new-element )
Arguments and Values:
array |an array .
index |avalid array row-major index for the array .
element ,new-element |an object .
Description:
Considers array as a vector by viewing its elements in row-major order, and returns the element
of that vector which is referred to by the given index .
row-major-aref is valid for use with setf.
See Also:
aref,array-row-major-index
Notes:
(row-major-aref array index) 
(aref (make-array (array-total-size array)
:displaced-to array
:element-type (array-element-type array))
index)
(aref array i1 i2 ...) 
(row-major-aref array (array-row-major-index array i1 i2))
15–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
upgraded-array-element-type Function
Syntax:
upgraded-array-element-type typespec &optional environment!upgraded-typespec
Arguments and Values:
typespec |atype specier .
environment |an environment object . The default is nil, denoting the null lexical environment and
the current global environment .
upgraded-typespec |atype specier .
Description:
Returns the element type of the most specialized array representation capable of holding items of
thetype denoted by typespec .
The typespec is asubtype of (and possibly type equivalent to) the upgraded-typespec .
Iftypespec isbit, the result is type equivalent tobit. If typespec isbase-char , the result is type
equivalent tobase-char . Iftypespec ischaracter , the result is type equivalent tocharacter .
The purpose of upgraded-array-element-type is to reveal how an implementation does its
upgrading .
The environment is used to expand any derived type speciers that are mentioned in the typespec .
See Also:
array-element-type ,make-array
Notes:
Except for storage allocation consequences and dealing correctly with the optional environment
argument ,upgraded-array-element-type could be dened as:
(defun upgraded-array-element-type (type &optional environment)
(array-element-type (make-array 0 :element-type type)))
Arrays15–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
array-dimension-limit Constant Variable
Constant Value:
A positive xnum , the exact magnitude of which is implementation-dependent , but which is not
less than 1024.
Description:
The upper exclusive bound on each individual dimension of an array .
See Also:
make-array
array-rank-limit Constant Variable
Constant Value:
A positive xnum , the exact magnitude of which is implementation-dependent , but which is not
less than 8.
Description:
The upper exclusive bound on the rank of an array .
See Also:
make-array
array-total-size-limit Constant Variable
Constant Value:
A positive xnum , the exact magnitude of which is implementation-dependent , but which is not
less than 1024.
Description:
The upper exclusive bound on the array total size of an array .
The actual limit on the array total size imposed by the implementation might vary according the
element type of the array ; in this case, the value of array-total-size-limit will be the smallest of
these possible limits.
See Also:
make-array ,array-element-type
15–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
simple-vector-p Function
Syntax:
simple-vector-p object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typesimple-vector ; otherwise, returns false..
Examples:
(simple-vector-p (make-array 6)) !true
(simple-vector-p "aaaaaa") !false
(simple-vector-p (make-array 6 :fill-pointer t)) !false
See Also:
simple-vector
Notes:
(simple-vector-p object)(typep object’simple-vector)
svref Accessor
Syntax:
svref simple-vector index !element
(setf (svref simple-vector index )new-element )
Arguments and Values:
simple-vector |asimple vector .
index |avalid array index for the simple-vector .
Arrays15–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
element ,new-element |an object (whose type is a subtype of the array element type of the
simple-vector ).
Description:
Accesses theelement ofsimple-vector specied by index .
Examples:
(simple-vector-p (setq v (vector 1 2 ’sirens))) !true
(svref v 0)!1
(svref v 2)!SIRENS
(setf (svref v 1) ’newcomer) !NEWCOMER
v!#(1 NEWCOMER SIRENS)
See Also:
aref,sbit,schar ,vector , Section 3.2.1 (Compiler Terminology)
Notes:
svref is identical to aref except that it requires its rst argument to be a simple vector .
(svref v i)(aref (the simple-vector v)i)
vector Function
Syntax:
vector&rest objects!vector
Arguments and Values:
object |an object .
vector |avector oftype(vector t *) .
Description:
Creates a fresh simple general vector whose size corresponds to the number of objects .
The vector is initialized to contain the objects .
Examples:
(arrayp (setq v (vector 1 2 ’sirens))) !true
(vectorp v)!true
(simple-vector-p v) !true
(length v)!3
15–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
make-array
Notes:
vector is analogous to list.
(vector a 1a2... a n)
(make-array (list n) :element-type t
:initial-contents
(list a 1a2... a n))
vector-pop Function
Syntax:
vector-pop vector!element
Arguments and Values:
vector |avector with a ll pointer .
element |an object .
Description:
Decreases the ll pointer ofvector by one, and retrieves the element ofvector that is designated
by the new ll pointer .
Examples:
(vector-push (setq fable (list ’fable))
(setq fa (make-array 8
:fill-pointer 2
:initial-element ’sisyphus))) !2
(fill-pointer fa) !3
(eq (vector-pop fa) fable) !true
(vector-pop fa) !SISYPHUS
(fill-pointer fa) !1
Side Eﬀects:
The ll pointer is decreased by one.
Aﬀected By:
The value of the ll pointer .
Arrays15–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
An error of typetype-error is signaled if vector does not have a ll pointer .
If the ll pointer is zero,vector-pop signals an error of typeerror .
See Also:
vector-push ,vector-push-extend ,ﬁll-pointer
vector-push,vector-push-extend Function
Syntax:
vector-push new-element vector !new-index-p
vector-push-extend new-element vector &optional extension!new-index
Arguments and Values:
new-element |an object .
vector |avector with a ll pointer .
extension |a positive integer . The default is implementation-dependent .
new-index-p |avalid array index forvector , ornil.
new-index |avalid array index forvector .
Description:
vector-push andvector-push-extend store new-element invector .vector-push attempts to store
new-element in the element of vector designated by the ll pointer , and to increase the ll pointer
by one. If the (>= (fill-pointer vector) (array-dimension vector0)), neither vector nor its ll
pointer are aected. Otherwise, the store and increment take place and vector-push returns the
former value of the ll pointer which is one less than the one it leaves in vector .
vector-push-extend is just like vector-push except that if the ll pointer gets too large, vector
is extended using adjust-array so that it can contain more elements. Extension is the minimum
number of elements to be added to vector if it must be extended.
vector-push andvector-push-extend return the index of new-element invector . If
(>= (fill-pointer vector) (array-dimension vector0)),vector-push returnsnil.
Examples:
(vector-push (setq fable (list ’fable))
(setq fa (make-array 8
:fill-pointer 2
15–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
:initial-element ’first-one))) !2
(fill-pointer fa) !3
(eq (aref fa 2) fable) !true
(vector-push-extend #\X
(setq aa
(make-array 5
:element-type ’character
:adjustable t
:fill-pointer 3))) !3
(fill-pointer aa) !4
(vector-push-extend #\Y aa 4) !4
(array-total-size aa) !at least 5
(vector-push-extend #\Z aa 4) !5
(array-total-size aa) !9 ;(or more)
Aﬀected By:
The value of the ll pointer .
How vector was created.
Exceptional Situations:
An error of typeerror is signaled by vector-push-extend if it tries to extend vector and vector is
notactually adjustable .
An error of typeerror is signaled if vector does not have a ll pointer .
See Also:
adjustable-array-p ,ﬁll-pointer ,vector-pop
vectorp Function
Syntax:
vectorp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typevector ; otherwise, returns false.
Arrays15–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(vectorp "aaaaaa") !true
(vectorp (make-array 6 :fill-pointer t)) !true
(vectorp (make-array ’(2 3 4))) !false
(vectorp #*11)!true
(vectorp #b11)!false
Notes:
(vectorp object)(typep object’vector)
bit,sbit Accessor
Syntax:
bitbit-array &rest subscripts!bit
sbit bit-array &rest subscripts!bit
(setf (bit bit-array &rest subscripts )new-bit)
(setf (sbit bit-array &rest subscripts )new-bit)
Arguments and Values:
bit-array |forbit, abit array ; forsbit, asimple bit array .
subscripts |alistofvalid array indices for the bit-array .
bit|abit.
Description:
bitandsbit access thebit-array element specied by subscripts .
These functions ignore the ll pointer when accessing elements .
Examples:
(bit (setq ba (make-array 8
:element-type ’bit
:initial-element 1))
3)!1
(setf (bit ba 3) 0) !0
(bit ba 3)!0
(sbit ba 5)!1
(setf (sbit ba 5) 1) !1
15–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(sbit ba 5)!1
See Also:
aref, Section 3.2.1 (Compiler Terminology)
Notes:
bitandsbitare likearef except that they require arrays to be a bit array and a simple bit array ,
respectively.
bitandsbit, unlikechar andschar , allow the rst argument to be an array of any rank.
bit-and,bit-andc1,bit-andc2,bit-eqv,bit-ior,bit-
nand,bit-nor,bit-not,bit-orc1,bit-orc2,bit-xor
Function
Syntax:
bit-and bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-andc1 bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-andc2 bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-eqv bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-ior bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-nand bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-nor bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-orc1 bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-orc2 bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-xor bit-array1 bit-array2 &optional opt-arg!resulting-bit-array
bit-not bit-array &optional opt-arg!resulting-bit-array
Arguments and Values:
bit-array ,bit-array1 ,bit-array2 |abit array .
Opt-arg |abit array , ort, ornil. The default is nil.
Bit-array ,bit-array1 ,bit-array2 , and opt-arg (if an array ) must all be of the same rank and
dimensions .
resulting-bit-array |abit array .
Description:
These functions perform bit-wise logical operations on bit-array1 and bit-array2 and return an array
of matching rank and dimensions , such that any given bit of the result is produced by operating
on corresponding bits from each of the arguments.
Arrays15–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
In the case of bit-not , anarray ofrank anddimensions matching bit-array is returned that contains
a copy of bit-array with all the bits inverted.
Ifopt-arg is of type (array bit) the contents of the result are destructively placed into opt-arg .
Ifopt-arg is the symbol t,bit-array orbit-array1 is replaced with the result; if opt-arg isnilor
omitted, a new array is created to contain the result.
Figure 15{4 indicates the logical operation performed by each of the functions .
Function Operation
bit-and and
bit-eqv equivalence (exclusive nor)
bit-not complement
bit-ior inclusive or
bit-xor exclusive or
bit-nand complement of bit-array1 and bit-array2
bit-nor complement of bit-array1 orbit-array2
bit-andc1 and complement of bit-array1 with bit-array2
bit-andc2 and bit-array1 with complement of bit-array2
bit-orc1 or complement of bit-array1 with bit-array2
bit-orc2 orbit-array1 with complement of bit-array2
Figure 15–4. Bit-wise Logical Operations on Bit Arrays
Examples:
(bit-and (setq ba #*11101010) #*01101011) !#*01101010
(bit-and #*1100 #*1010) !#*1000
(bit-andc1 #*1100 #*1010) !#*0010
(setq rba (bit-andc2 ba #*00110011 t)) !#*11001000
(eq rba ba)!true
(bit-not (setq ba #*11101010)) !#*00010101
(setq rba (bit-not ba
(setq tba (make-array 8
:element-type ’bit))))
!#*00010101
(equal rba tba) !true
(bit-xor #*1100 #*1010) !#*0110
See Also:
lognot ,logand
15–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
bit-vector-p Function
Syntax:
bit-vector-p object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typebit-vector ; otherwise, returns false.
Examples:
(bit-vector-p (make-array 6
:element-type ’bit
:fill-pointer t)) !true
(bit-vector-p #*) !true
(bit-vector-p (make-array 6)) !false
See Also:
typep
Notes:
(bit-vector-p object)(typep object’bit-vector)
simple-bit-vector-p Function
Syntax:
simple-bit-vector-p object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typesimple-bit-vector ; otherwise, returns false.
Arrays15–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
simple-bit-vector-p
Examples:
(simple-bit-vector-p (make-array 6)) !false
(simple-bit-vector-p #*) !true
See Also:
simple-vector-p
Notes:
(simple-bit-vector-p object)(typep object’simple-bit-vector)
15–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
16. Strings
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Stringsiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
16.1 String Concepts
16.1.1 Implications of Strings Being Arrays
Since all strings arearrays , all rules which apply generally to arrays also apply to strings . See
Section 15.1 (Array Concepts).
For example, strings can have ll pointers , and strings are also subject to the rules of element type
upgrading that apply to arrays .
16.1.2 Subtypes of STRING
All functions that operate on strings will operate on subtypes ofstring as well.
However, the consequences are undened if a character is inserted into a string for which the
element type of the string does not include that character .
Strings16–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
string System Class
Class Precedence List:
string ,vector ,array ,sequence ,t
Description:
Astring is aspecialized vector whose elements are of typecharacter or a subtype oftypecharacter .
When used as a type specier for object creation, string means(vector character) .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(string [ size])
Compound Type Speciﬁer Arguments:
size|a non-negative xnum , or the symbol*.
Compound Type Speciﬁer Description:
This denotes the union of all types(array c(size))for all subtypes c ofcharacter ; that is, the set
ofstrings of size size.
See Also:
Section 16.1 (String Concepts), Section 2.4.5 (Double-Quote), Section 22.1.3.4 (Printing Strings)
base-string Type
Supertypes:
base-string ,string ,vector ,array ,sequence ,t
Description:
The typebase-string is equivalent to (vector base-char) . The base string representation is the
most ecient string representation that can hold an arbitrary sequence of standard characters .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(base-string [ size])
16–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Compound Type Speciﬁer Arguments:
size|a non-negative xnum , or the symbol*.
Compound Type Speciﬁer Description:
This is equivalent to the type (vector base-char size); that is, the set of base strings of size size.
simple-string Type
Supertypes:
simple-string ,string ,vector ,simple-array ,array ,sequence ,t
Description:
Asimple string is a specialized one-dimensional simple array whose elements are of typecharacter
or a subtype oftypecharacter . When used as a type specier for object creation, simple-string
means(simple-array character ( size)).
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(simple-string [ size])
Compound Type Speciﬁer Arguments:
size|a non-negative xnum , or the symbol*.
Compound Type Speciﬁer Description:
This denotes the union of all types(simple-array c(size))for all subtypes c ofcharacter ; that is,
the set of simple strings of size size.
Strings16–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
simple-base-string Type
Supertypes:
simple-base-string ,base-string ,simple-string ,string ,vector ,simple-array ,array ,sequence ,t
Description:
The typesimple-base-string is equivalent to (simple-array base-char (*)) .
Compound Type Speciﬁer Kind:
Abbreviating.
Compound Type Speciﬁer Syntax:
(simple-base-string [ size])
Compound Type Speciﬁer Arguments:
size|a non-negative xnum , or the symbol*.
Compound Type Speciﬁer Description:
This is equivalent to the type (simple-array base-char ( size)); that is, the set of simple base
strings of size size.
simple-string-p Function
Syntax:
simple-string-p object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typesimple-string ; otherwise, returns false.
Examples:
(simple-string-p "aaaaaa") !true
(simple-string-p (make-array 6
:element-type ’character
:fill-pointer t)) !false
16–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(simple-string-p object)(typep object’simple-string)
char,schar Accessor
Syntax:
char string index!character
schar string index!character
(setf (char string index )new-character )
(setf (schar string index )new-character )
Arguments and Values:
string |forchar, astring ; forschar , asimple string .
index |avalid array index for the string .
character ,new-character |acharacter .
Description:
char andschar access theelement ofstring specied by index .
char ignores ll pointers when accessing elements .
Examples:
(setq my-simple-string (make-string 6 :initial-element #\A)) !"AAAAAA"
(schar my-simple-string 4) !#\A
(setf (schar my-simple-string 4) #\B) !#\B
my-simple-string !"AAAABA"
(setq my-filled-string
(make-array 6 :element-type ’character
:fill-pointer 5
:initial-contents my-simple-string))
!"AAAAB"
(char my-filled-string 4) !#\B
(char my-filled-string 5) !#\A
(setf (char my-filled-string 3) #\C) !#\C
(setf (char my-filled-string 5) #\D) !#\D
(setf (fill-pointer my-filled-string) 6) !6
my-filled-string !"AAACBD"
Strings16–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
aref,elt, Section 3.2.1 (Compiler Terminology)
Notes:
(char s j)(aref (the string s) j)
string Function
Syntax:
string x!string
Arguments and Values:
x|astring , asymbol , or a character .
string |astring .
Description:
Returns a string described by x; specically:
Ifxis astring , it is returned.
Ifxis asymbol , its name is returned.
Ifxis acharacter , then a string containing that one character is returned.
string might perform additional, implementation-dened conversions.
Examples:
(string "already a string") !"already a string"
(string ’elm)!"ELM"
(string #\c)!"c"
Exceptional Situations:
In the case where a conversion is dened neither by this specication nor by the implementation ,
an error of typetype-error is signaled.
See Also:
coerce ,string (type).
Notes:
coerce can be used to convert a sequence ofcharacters to a string .
16–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
prin1-to-string ,princ-to-string ,write-to-string , orformat (with a rst argument of nil) can be
used to get a string representation of a number or any other object .
string-upcase,string-downcase,string-capitalize,
nstring-upcase,nstring-downcase,nstring-
capitalize Function
Syntax:
string-upcase string&key start end!cased-string
string-downcase string&key start end!cased-string
string-capitalize string&key start end!cased-string
nstring-upcase string&key start end!string
nstring-downcase string&key start end!string
nstring-capitalize string&key start end!string
Arguments and Values:
string |astring designator . Fornstring-upcase ,nstring-downcase , andnstring-capitalize , the
string designator must be a string .
start,end|bounding index designators ofstring . The defaults for start and endare0andnil,
respectively.
cased-string |astring .
Description:
string-upcase ,string-downcase ,string-capitalize ,nstring-upcase ,nstring-downcase ,
nstring-capitalize change the case of the subsequence of string bounded bystart and end
as follows:
string-upcase
string-upcase returns a string just like string with all lowercase characters replaced by the
corresponding uppercase characters. More precisely, each character of the result string is
produced by applying the functionchar-upcase to the corresponding character of string .
string-downcase
string-downcase is likestring-upcase except that all uppercase characters are replaced by
the corresponding lowercase characters (using char-downcase ).
Strings16–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
string-upcase, string-downcase, string-capitalize, :::
string-capitalize
string-capitalize produces a copy of string such that, for every word in the copy, the rst
character of the \word," if it has case, isuppercase and any other characters with case in
the word are lowercase . For the purposes of string-capitalize , a \word" is dened to be
a consecutive subsequence consisting of alphanumeric characters , delimited at each end
either by a non- alphanumeric character or by an end of the string .
nstring-upcase, nstring-downcase, nstring-capitalize
nstring-upcase ,nstring-downcase , andnstring-capitalize are identical to string-upcase ,
string-downcase , andstring-capitalize respectively except that they modify string .
Forstring-upcase ,string-downcase , andstring-capitalize ,string is not modied. However, if
no characters in string require conversion, the result may be either string or a copy of it, at the
implementation's discretion.
Examples:
(string-upcase "abcde") !"ABCDE"
(string-upcase "Dr. Livingston, I presume?")
!"DR. LIVINGSTON, I PRESUME?"
(string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)
!"Dr. LiVINGston, I presume?"
(string-downcase "Dr. Livingston, I presume?")
!"dr. livingston, i presume?"
(string-capitalize "elm 13c arthur;fig don’t") !"Elm 13c Arthur;Fig Don’T"
(string-capitalize " hello ") !" Hello "
(string-capitalize "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")
!"Occluded Casements Forestall Inadvertent Defenestration"
(string-capitalize ’kludgy-hash-search) !"Kludgy-Hash-Search"
(string-capitalize "DON’T!") !"Don’T!" ;not "Don’t!"
(string-capitalize "pipe 13a, foo16c") !"Pipe 13a, Foo16c"
(setq str (copy-seq "0123ABCD890a")) !"0123ABCD890a"
(nstring-downcase str :start 5 :end 7) !"0123AbcD890a"
str!"0123AbcD890a"
Side Eﬀects:
nstring-upcase ,nstring-downcase , andnstring-capitalize modify string as appropriate rather
than constructing a new string .
See Also:
char-upcase ,char-downcase
16–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
The result is always of the same length as string .
string-trim,string-left-trim,string-right-trim Func-
tion
Syntax:
string-trim character-bag string !trimmed-string
string-left-trim character-bag string !trimmed-string
string-right-trim character-bag string !trimmed-string
Arguments and Values:
character-bag |asequence containing characters .
string |astring designator .
trimmed-string |astring .
Description:
string-trim returns a substring of string , with all characters in character-bag stripped o the
beginning and end. string-left-trim is similar but strips characters o only the beginning;
string-right-trim strips o only the end.
If no characters need to be trimmed from the string , then either string itself or a copy of it may be
returned, at the discretion of the implementation.
All of these functions observe the ll pointer .
Examples:
(string-trim "abc" "abcaakaaakabcaaa") !"kaaak"
(string-trim ’(#\Space #\Tab #\Newline) " garbanzo beans
")!"garbanzo beans"
(string-trim " (*)" " ( *three (silly) words* ) ")
!"three (silly) words"
(string-left-trim "abc" "labcabcabc") !"labcabcabc"
(string-left-trim " (*)" " ( *three (silly) words* ) ")
!"three (silly) words* ) "
(string-right-trim " (*)" " ( *three (silly) words* ) ")
!" ( *three (silly) words"
Strings16–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Aﬀected By:
The implementation .
string=,string/=,string <,string>,string<=,
string>=,string-equal,string-not-equal,string-
lessp,string-greaterp,string-not-greaterp,string-
not-lessp Function
Syntax:
string =string1 string2 &key start1 end1 start2 end2 !generalized-boolean
string/ =string1 string2 &key start1 end1 start2 end2 !mismatch-index
string <string1 string2 &key start1 end1 start2 end2 !mismatch-index
string >string1 string2 &key start1 end1 start2 end2 !mismatch-index
string <=string1 string2 &key start1 end1 start2 end2 !mismatch-index
string >=string1 string2 &key start1 end1 start2 end2 !mismatch-index
string-equal string1 string2 &key start1 end1 start2 end2 !generalized-boolean
string-not-equal string1 string2 &key start1 end1 start2 end2 !mismatch-index
string-lessp string1 string2 &key start1 end1 start2 end2 !mismatch-index
string-greaterp string1 string2 &key start1 end1 start2 end2 !mismatch-index
string-not-greaterp string1 string2 &key start1 end1 start2 end2 !mismatch-index
string-not-lessp string1 string2 &key start1 end1 start2 end2 !mismatch-index
Arguments and Values:
string1 |astring designator .
string2 |astring designator .
start1 ,end1 |bounding index designators ofstring1 . The defaults for start and endare0andnil,
respectively.
start2 ,end2 |bounding index designators ofstring2 . The defaults for start and endare0andnil,
respectively.
generalized-boolean |ageneralized boolean .
mismatch-index |abounding index ofstring1 , ornil.
Description:
These functions perform lexicographic comparisons on string1 and string2 .string= and
string-equal are called equality functions; the others are called inequality functions. The
16–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
string=, string/=, string <, string>, string<=,:::
comparison operations these functions perform are restricted to the subsequence of string1 bounded
bystart1 and end1 and to the subsequence of string2 bounded bystart2 and end2 .
A string ais equal to a string bif it contains the same number of characters, and the corresponding
characters are the same underchar= orchar-equal , as appropriate.
A string ais less than a string bif in the rst position in which they dier the character of ais less
than the corresponding character of baccording to char <orchar-lessp as appropriate, or if string
ais a proper prex of string b(of shorter length and matching in all the characters of a).
The equality functions return a generalized boolean that is true if the strings are equal, or false
otherwise.
The inequality functions return a mismatch-index that is true if the strings are not equal, or
false otherwise. When the mismatch-index istrue, it is an integer representing the rst character
position at which the two substrings dier, as an oset from the beginning of string1 .
The comparison has one of the following results:
string=
string= istrue if the supplied substrings are of the same length and contain the same
characters in corresponding positions; otherwise it is false.
string/=
string/= istrue if the supplied substrings are dierent; otherwise it is false.
string-equal
string-equal is just like string= except that dierences in case are ignored; two characters
are considered to be the same if char-equal istrue of them.
string <
string <istrue if substring1 is less than substring2; otherwise it is false.
string >
string >istrue if substring1 is greater than substring2; otherwise it is false.
string-lessp ,string-greaterp
string-lessp andstring-greaterp are exactly like string <andstring >, respectively, except
that distinctions between uppercase and lowercase letters are ignored. It is as if char-lessp
were used instead of char <for comparing characters.
string <=
string <=istrue if substring1 is less than or equal to substring2; otherwise it is false.
Strings16–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
string >=
string >=istrue if substring1 is greater than or equal to substring2; otherwise it is false.
string-not-greaterp ,string-not-lessp
string-not-greaterp andstring-not-lessp are exactly like string <=andstring >=,
respectively, except that distinctions between uppercase and lowercase letters are ignored.
It is as if char-lessp were used instead of char <for comparing characters.
Examples:
(string= "foo" "foo") !true
(string= "foo" "Foo") !false
(string= "foo" "bar") !false
(string= "together" "frog" :start1 1 :end1 3 :start2 2) !true
(string-equal "foo" "Foo") !true
(string= "abcd" "01234abcd9012" :start2 5 :end2 9) !true
(string< "aaaa" "aaab") !3
(string>= "aaaaa" "aaaa") !4
(string-not-greaterp "Abcde" "abcdE") !5
(string-lessp "012AAAA789" "01aaab6" :start1 3 :end1 7
:start2 2 :end2 6) !6
(string-not-equal "AAAA" "aaaA") !false
See Also:
char=
Notes:
equal callsstring= if applied to two strings .
stringp Function
Syntax:
stringp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typestring ; otherwise, returns false.
16–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(stringp "aaaaaa") !true
(stringp #\a)!false
See Also:
typep ,string (type)
Notes:
(stringp object)(typep object’string)
make-string Function
Syntax:
make-string size&key initial-element element-type !string
Arguments and Values:
size|avalid array dimension .
initial-element |acharacter . The default is implementation-dependent .
element-type |atype specier . The default is character .
string |asimple string .
Description:
make-string returns a simple string of length sizewhose elements have been initialized to
initial-element .
The element-type names the type of the elements of the string ; astring is constructed of the most
specialized type that can accommodate elements of the given type.
Examples:
(make-string 10 :initial-element #\5) !"5555555555"
(length (make-string 10)) !10
Aﬀected By:
The implementation .
Strings16–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
16–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
17. Sequences
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Sequences iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
17.1 Sequence Concepts
Asequence is an ordered collection of elements , implemented as either a vector or a list.
Sequences can be created by the function make-sequence , as well as other functions that create
objects oftypes that are subtypes ofsequence (e.g.,list,make-list ,mapcar , andvector ).
Asequence function is afunction dened by this specication or added as an extension by the
implementation that operates on one or more sequences . Whenever a sequence function must
construct and return a new vector , it always returns a simple vector . Similarly, any strings
constructed will be simple strings .
concatenate length remove
copy-seq map remove-duplicates
count map-into remove-if
count-if merge remove-if-not
count-if-not mismatch replace
delete notany reverse
delete-duplicates notevery search
delete-if nreverse some
delete-if-not nsubstitute sort
elt nsubstitute-if stable-sort
every nsubstitute-if-not subseq
ﬁll position substitute
ﬁnd position-if substitute-if
ﬁnd-if position-if-not substitute-if-not
ﬁnd-if-not reduce
Figure 17–1. Standardized Sequence Functions
17.1.1 General Restrictions on Parameters that must be
Sequences
In general, lists (including association lists and property lists ) that are treated as sequences must
beproper lists .
Sequences 17–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
17.2 Rules about Test Functions
17.2.1 Satisfying a Two-Argument Test
When an objectOis being considered iteratively against each elementEiof a sequenceSby an
operatorFlisted in Figure 17{2, it is sometimes useful to control the way in which the presence of
Ois tested in Sis tested by F. This control is oered on the basis of a function designated with
either a :test or:test-not argument .
adjoin nset-exclusive-or search
assoc nsublis set-diﬀerence
count nsubst set-exclusive-or
delete nsubstitute sublis
ﬁnd nunion subsetp
intersection position subst
member pushnew substitute
mismatch rassoc tree-equal
nintersection remove union
nset-diﬀerence remove-duplicates
Figure 17–2. Operators that have Two-Argument Tests to be Satisﬁed
The object Omight not be compared directly to Ei. If a:key argument is provided, it is a
designator for a function of one argument to be called with each Eias an argument , and yielding
anobjectZito be used for comparison. (If there is no :key argument ,ZiisEi.)
The function designated by the :key argument is never called on Oitself. However, if the function
operates on multiple sequences ( e.g., as happens in set-diﬀerence ),Owill be the result of calling
the:key function on an element of the other sequence.
A:test argument , if supplied to F, is a designator for a function of two arguments ,OandZi.
AnEiis said (or, sometimes, an Oand anEiare said) to satisfy the test if this:test function
returns a generalized boolean representing true.
A:test-not argument , if supplied to F, isdesignator for a function of two arguments ,Oand
Zi. AnEiis said (or, sometimes, an Oand anEiare said) to satisfy the test if this:test-not
function returns a generalized boolean representing false.
If neither a :test nor a:test-not argument is supplied, it is as if a :test argument of #’eql was
supplied.
The consequences are unspecied if both a :test and a:test-not argument are supplied in the
same calltoF.
17–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
17.2.1.1 Examples of Satisfying a Two-Argument Test
(remove "FOO" ’(foo bar "FOO" "BAR" "foo" "bar") :test #’equal)
!(foo bar "BAR" "foo" "bar")
(remove "FOO" ’(foo bar "FOO" "BAR" "foo" "bar") :test #’equalp)
!(foo bar "BAR" "bar")
(remove "FOO" ’(foo bar "FOO" "BAR" "foo" "bar") :test #’string-equal)
!(bar "BAR" "bar")
(remove "FOO" ’(foo bar "FOO" "BAR" "foo" "bar") :test #’string=)
!(BAR "BAR" "foo" "bar")
(remove 1 ’(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #’eql)
!(1)
(remove 1 ’(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #’=)
!(1 1.0 #C(1.0 0.0))
(remove 1 ’(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test (complement #’=))
!(1 1.0 #C(1.0 0.0))
(count 1 ’((one 1) (uno 1) (two 2) (dos 2)) :key #’cadr) !2
(count 2.0 ’(1 2 3) :test #’eql :key #’float) !1
(count "FOO" (list (make-pathname :name "FOO" :type "X")
(make-pathname :name "FOO" :type "Y"))
:key #’pathname-name
:test #’equal)
!2
17.2.2 Satisfying a One-Argument Test
When using one of the functions in Figure 17{3, the elements Eof a sequenceSare ltered not on
the basis of the presence or absence of an object Ounder a two argument predicate , as with the
functions described in Section 17.2.1 (Satisfying a Two-Argument Test), but rather on the basis of
a one argument predicate .
Sequences 17–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
assoc-if member-if rassoc-if
assoc-if-not member-if-not rassoc-if-not
count-if nsubst-if remove-if
count-if-not nsubst-if-not remove-if-not
delete-if nsubstitute-if subst-if
delete-if-not nsubstitute-if-not subst-if-not
ﬁnd-if position-if substitute-if
ﬁnd-if-not position-if-not substitute-if-not
Figure 17–3. Operators that have One-Argument Tests to be Satisﬁed
The element Eimight not be considered directly. If a :key argument is provided, it is a designator
for a function of one argument to be called with each Eias an argument , and yielding anobjectZi
to be used for comparison. (If there is no :key argument ,ZiisEi.)
Functions dened in this specication and having a name that ends in \ -if" accept a rst argument
that is a designator for a function of one argument ,Zi. AnEiis said to satisfy the test if this
:test function returns a generalized boolean representing true.
Functions dened in this specication and having a name that ends in \ -if-not " accept a rst
argument that is a designator for a function of one argument ,Zi. AnEiis said to satisfy the
test if this:test function returns a generalized boolean representing false.
17.2.2.1 Examples of Satisfying a One-Argument Test
(count-if #’zerop ’(1 #C(0.0 0.0) 0 0.0d0 0.0s0 3)) !4
(remove-if-not #’symbolp ’(0 1 2 3 4 5 6 7 8 9 A B C D E F))
!(A B C D E F)
(remove-if (complement #’symbolp) ’(0 1 2 3 4 5 6 7 8 9 A B C D E F))
!(A B C D E F)
(count-if #’zerop ’("foo" "" "bar" "" "" "baz" "quux") :key #’length)
!3
17–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
sequence System Class
Class Precedence List:
sequence ,t
Description:
Sequences are ordered collections of objects , called the elements of the sequence .
The typesvector and the typelistaredisjoint subtypes oftypesequence , but are not necessarily
anexhaustive partition ofsequence .
When viewing a vector as a sequence , only the active elements of that vector are considered
elements of the sequence ; that is, sequence operations respect the ll pointer when given sequences
represented as vectors .
copy-seq Function
Syntax:
copy-seq sequence!copied-sequence
Arguments and Values:
sequence |aproper sequence .
copied-sequence |aproper sequence .
Description:
Creates a copy of sequence . The elements of the new sequence are the same as the corresponding
elements of the given sequence .
Ifsequence is avector , the result is a fresh simple array ofrank one that has the same actual array
element type assequence . Ifsequence is alist, the result is a fresh list .
Examples:
(setq str "a string") !"a string"
(equalp str (copy-seq str)) !true
(eql str (copy-seq str)) !false
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
copy-list
Sequences 17–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
From a functional standpoint, (copy-seq x)(subseq x 0)
However, the programmer intent is typically very dierent in these two cases.
elt Accessor
Syntax:
eltsequence index!object
(setf (elt sequence index )new-object )
Arguments and Values:
sequence |aproper sequence .
index |avalid sequence index forsequence .
object |an object .
new-object |an object .
Description:
Accesses theelement ofsequence specied by index .
Examples:
(setq str (copy-seq "0123456789")) !"0123456789"
(elt str 6)!#\6
(setf (elt str 0) #\#) !#\#
str!"#123456789"
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
Should signal an error of typetype-error ifindex is not a valid sequence index forsequence .
See Also:
aref,nth, Section 3.2.1 (Compiler Terminology)
Notes:
aref may be used to access vector elements that are beyond the vector 'sll pointer .
17–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬁll Function
Syntax:
ﬁllsequence item &key start end!sequence
Arguments and Values:
sequence |aproper sequence .
item|asequence .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
Description:
Replaces the elements ofsequence bounded bystart and endwith item.
Examples:
(fill (list 0 1 2 3 4 5) ’(444)) !((444) (444) (444) (444) (444) (444))
(fill (copy-seq "01234") #\e :start 3) !"012ee"
(setq x (vector ’a ’b ’c ’d ’e)) !#(A B C D E)
(fill x ’z :start 1 :end 3) !#(A Z Z D E)
x!#(A Z Z D E)
(fill x ’p)!#(P P P P P)
x!#(P P P P P)
Side Eﬀects:
Sequence is destructively modied.
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
Should signal an error of typetype-error ifstart is not a non-negative integer . Should signal an
error of typetype-error ifendis not a non-negative integer ornil.
See Also:
replace ,nsubstitute
Notes:
(fill sequence item )(nsubstitute-if item(constantly t) sequence )
Sequences 17–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-sequence
make-sequence Function
Syntax:
make-sequence result-type size &key initial-element!sequence
Arguments and Values:
result-type |asequence type specier .
size|a non-negative integer .
initial-element |an object . The default is implementation-dependent .
sequence |aproper sequence .
Description:
Returns a sequence of the type result-type and of length size, each of the elements of which has
been initialized to initial-element .
If the result-type is asubtype oflist, the result will be a list.
If the result-type is asubtype ofvector , then if the implementation can determine the element type
specied for the result-type , the element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element type is unspecied (or *),
the element type of the resulting array is t; otherwise, an error is signaled.
Examples:
(make-sequence ’list 0) !()
(make-sequence ’string 26 :initial-element #\.)
!".........................."
(make-sequence ’(vector double-float) 2
:initial-element 1d0)
!#(1.0d0 1.0d0)
(make-sequence ’(vector * 2) 3) should signal an error
(make-sequence ’(vector * 4) 3) should signal an error
Aﬀected By:
The implementation .
Exceptional Situations:
The consequences are unspecied if initial-element is not an object which can be stored in the
resulting sequence .
17–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
An error of typetype-error must be signaled if the result-type is neither a recognizable subtype of
list, nor a recognizable subtype ofvector .
An error of typetype-error should be signaled if result-type species the number of elements and
sizeis dierent from that number.
See Also:
make-array ,make-list
Notes:
(make-sequence ’string 5) (make-string 5)
subseq Accessor
Syntax:
subseq sequence start &optional end!subsequence
(setf (subseq sequence start &optional end)new-subsequence )
Arguments and Values:
sequence |aproper sequence .
start,end|bounding index designators ofsequence . The default for endisnil.
subsequence |aproper sequence .
new-subsequence |aproper sequence .
Description:
subseq creates a sequence that is a copy of the subsequence of sequence bounded bystart and end.
Start species an oset into the original sequence and marks the beginning position of the
subsequence. endmarks the position following the last element of the subsequence.
subseq always allocates a new sequence for a result; it never shares storage with an old sequence .
The result subsequence is always of the same type assequence .
Ifsequence is avector , the result is a fresh simple array ofrank one that has the same actual array
element type assequence . Ifsequence is alist, the result is a fresh list .
setf may be used with subseq to destructively replace elements of a subsequence with elements
taken from a sequence of new values. If the subsequence and the new sequence are not of equal
Sequences 17–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
length, the shorter length determines the number of elements that are replaced. The remaining
elements at the end of the longer sequence are not modied in the operation.
Examples:
(setq str "012345") !"012345"
(subseq str 2)!"2345"
(subseq str 3 5) !"34"
(setf (subseq str 4) "abc") !"abc"
str!"0123ab"
(setf (subseq str 0 2) "A") !"A"
str!"A123ab"
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
Should be prepared to signal an error of typetype-error ifnew-subsequence is not a proper
sequence .
See Also:
replace
map Function
Syntax:
map result-type function &rest sequences+!result
Arguments and Values:
result-type { asequence type specier , ornil.
function |afunction designator .function must take as many arguments as there are sequences .
sequence |aproper sequence .
result |if result-type is a type specier other than nil, then a sequence of the type it denotes;
otherwise (if the result-type isnil),nil.
Description:
Applies function to successive sets of arguments in which one argument is obtained from each
sequence . The function is called rst on all the elements with index 0, then on all those with index
1, and so on. The result-type species the type of the resulting sequence .
map returnsnilifresult-type isnil. Otherwise, map returns a sequence such that element jis the
result of applying function to element jof each of the sequences . The result sequence is as long as
the shortest of the sequences . The consequences are undened if the result of applying function to
17–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
the successive elements of the sequences cannot be contained in a sequence of the type given by
result-type .
If the result-type is asubtype oflist, the result will be a list.
If the result-type is asubtype ofvector , then if the implementation can determine the element type
specied for the result-type , the element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element type is unspecied (or *),
the element type of the resulting array is t; otherwise, an error is signaled.
Examples:
(map ’string #’(lambda (x y)
(char "01234567890ABCDEF" (mod (+ x y) 16)))
’(1 2 3 4)
’(10 9 8 7))!"AAAA"
(setq seq ’("lower" "UPPER" "" "123")) !("lower" "UPPER" "" "123")
(map nil #’nstring-upcase seq) !NIL
seq!("LOWER" "UPPER" "" "123")
(map ’list #’- ’(1 2 3 4)) !(-1 -2 -3 -4)
(map ’string
#’(lambda (x) (if (oddp x) #\1 #\0))
’(1 2 3 4))!"1010"
(map ’(vector * 4) #’cons "abc" "de") should signal an error
Exceptional Situations:
An error of typetype-error must be signaled if the result-type is not a recognizable subtype oflist,
not a recognizable subtype ofvector , and not nil.
Should be prepared to signal an error of typetype-error if any sequence is not a proper sequence .
An error of typetype-error should be signaled if result-type species the number of elements and
the minimum length of the sequences is dierent from that number.
See Also:
Section 3.6 (Traversal Rules and Side Eects)
Sequences 17–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
map-into
map-into Function
Syntax:
map-into result-sequence function &rest sequences!result-sequence
Arguments and Values:
result-sequence |aproper sequence .
function |adesignator for a function of as many arguments as there are sequences .
sequence |aproper sequence .
Description:
Destructively modies result-sequence to contain the results of applying function to each element in
the argument sequences in turn.
result-sequence and each element of sequences can each be either a listor a vector . Ifresult-sequence
and each element of sequences are not all the same length, the iteration terminates when the
shortest sequence (of any of the sequences or the result-sequence ) is exhausted. If result-sequence
is a vector with a ll pointer , the ll pointer is ignored when deciding how many iterations to
perform, and afterwards the ll pointer is set to the number of times function was applied. If
result-sequence is longer than the shortest element of sequences , extra elements at the end of
result-sequence are left unchanged. If result-sequence isnil,map-into immediately returns nil, since
nilis asequence of length zero.
Iffunction has side eects, it can count on being called rst on all of the elements with index 0,
then on all of those numbered 1, and so on.
Examples:
(setq a (list 1 2 3 4) b (list 10 10 10 10)) !(10 10 10 10)
(map-into a #’+ a b) !(11 12 13 14)
a!(11 12 13 14)
b!(10 10 10 10)
(setq k ’(one two three)) !(ONE TWO THREE)
(map-into a #’cons k a) !((ONE . 11) (TWO . 12) (THREE . 13) 14)
(map-into a #’gensym) !(#:G9090 #:G9091 #:G9092 #:G9093)
a!(#:G9090 #:G9091 #:G9092 #:G9093)
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifresult-sequence is not a proper sequence .
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
Notes:
map-into diers from map in that it modies an existing sequence rather than creating a new one.
In addition, map-into can be called with only two arguments, while map requires at least three
17–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
arguments.
map-into could be dened by:
(defun map-into (result-sequence function &rest sequences)
(loop for index below (apply #’min
(length result-sequence)
(mapcar #’length sequences))
do (setf (elt result-sequence index)
(apply function
(mapcar #’(lambda (seq) (elt seq index))
sequences))))
result-sequence)
reduce Function
Syntax:
reduce function sequence &key key from-end start end initial-value !result
Arguments and Values:
function |adesignator for a function that might be called with either zero or two arguments .
sequence |aproper sequence .
key|adesignator for a function of one argument, or nil.
from-end |ageneralized boolean . The default is false.
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
initial-value |an object .
result |an object .
Description:
reduce uses a binary operation, function , to combine the elements ofsequence bounded bystart
and end.
The function must accept as arguments two elements ofsequence or the results from combining
those elements . The function must also be able to accept no arguments.
Ifkeyis supplied, it is used is used to extract the values to reduce. The keyfunction is applied
exactly once to each element of sequence in the order implied by the reduction order but not to
Sequences 17–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
the value of initial-value , if supplied. The keyfunction typically returns part of the element of
sequence . Ifkeyis not supplied or is nil, the sequence element itself is used.
The reduction is left-associative, unless from-end istrue in which case it is right-associative.
Ifinitial-value is supplied, it is logically placed before the subsequence (or after it if from-end is
true) and included in the reduction operation.
In the normal case, the result of reduce is the combined result of function 's being applied to
successive pairs of elements ofsequence . If the subsequence contains exactly one element and no
initial-value is given, then that element is returned and function is not called. If the subsequence is
empty and an initial-value is given, then the initial-value is returned and function is not called. If the
subsequence is empty and no initial-value is given, then the function is called with zero arguments,
andreduce returns whatever function does. This is the only case where the function is called with
other than two arguments.
Examples:
(reduce #’* ’(1 2 3 4 5)) !120
(reduce #’append ’((1) (2)) :initial-value ’(i n i t)) !(I N I T 1 2)
(reduce #’append ’((1) (2)) :from-end t
:initial-value ’(i n i t)) !(1 2 I N I T)
(reduce #’- ’(1 2 3 4)) (- (- (- 1 2) 3) 4) !-8
(reduce #’- ’(1 2 3 4) :from-end t) ;Alternating sum.
(- 1 (- 2 (- 3 4))) !-2
(reduce #’+ ’()) !0
(reduce #’+ ’(3)) !3
(reduce #’+ ’(foo)) !FOO
(reduce #’list ’(1 2 3 4)) !(((1 2) 3) 4)
(reduce #’list ’(1 2 3 4) :from-end t) !(1 (2 (3 4)))
(reduce #’list ’(1 2 3 4) :initial-value ’foo) !((((foo 1) 2) 3) 4)
(reduce #’list ’(1 2 3 4)
:from-end t :initial-value ’foo) !(1 (2 (3 (4 foo))))
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
Section 3.6 (Traversal Rules and Side Eects)
17–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
count, count-if, count-if-not
count,count-if,count-if-not Function
Syntax:
count item sequence &key from-end start end key test test-not !n
count-if predicate sequence &key from-end start end key !n
count-if-not predicate sequence &key from-end start end key !n
Arguments and Values:
item|an object .
sequence |aproper sequence .
predicate |adesignator for a function of one argument that returns a generalized boolean .
from-end |ageneralized boolean . The default is false.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
key|adesignator for a function of one argument, or nil.
n|a non-negative integer less than or equal to the length ofsequence .
Description:
count ,count-if , andcount-if-not count and return the number of elements in the sequence
bounded bystart and endthat satisfy the test .
The from-end has no direct eect on the result. However, if from-end istrue, the elements of
sequence will be supplied as arguments to the test,test-not , and keyin reverse order, which may
change the side-eects, if any, of those functions.
Examples:
(count #\a "how many A’s are there in here?") !2
(count-if-not #’oddp ’((1) (2) (3) (4)) :key #’car) !2
(count-if #’upper-case-p "The Crying of Lot 49" :start 4) !2
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
Sequences 17–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
Section 17.2 (Rules about Test Functions), Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not argument is deprecated.
The functioncount-if-not is deprecated.
length Function
Syntax:
length sequence!n
Arguments and Values:
sequence |aproper sequence .
n|a non-negative integer .
Description:
Returns the number of elements insequence .
Ifsequence is a vector with a ll pointer , the active length as specied by the ll pointer is
returned.
Examples:
(length "abc")!3
(setq str (make-array ’(3) :element-type ’character
:initial-contents "abc"
:fill-pointer t)) !"abc"
(length str)!3
(setf (fill-pointer str) 2) !2
(length str)!2
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
list-length ,sequence
17–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
reverse, nreverse
reverse,nreverse Function
Syntax:
reverse sequence!reversed-sequence
nreverse sequence!reversed-sequence
Arguments and Values:
sequence |aproper sequence .
reversed-sequence |asequence .
Description:
reverse andnreverse return a new sequence of the same kind as sequence , containing the same
elements , but in reverse order.
reverse andnreverse dier in that reverse always creates and returns a new sequence , whereas
nreverse might modify and return the given sequence .reverse never modies the given sequence .
Forreverse , ifsequence is avector , the result is a fresh simple array ofrank one that has the same
actual array element type assequence . Ifsequence is alist, the result is a fresh list .
Fornreverse , ifsequence is avector , the result is a vector that has the same actual array element
type assequence . Ifsequence is alist, the result is a list.
Fornreverse ,sequence might be destroyed and re-used to produce the result. The result might or
might not be identical tosequence . Specically, when sequence is alist,nreverse is permitted to
setf any part, carorcdr, of any cons that is part of the list structure ofsequence . When sequence
is a vector ,nreverse is permitted to re-order the elements of sequence in order to produce the
resulting vector .
Examples:
(setq str "abc") !"abc"
(reverse str)!"cba"
str!"abc"
(setq str (copy-seq str)) !"abc"
(nreverse str)!"cba"
str!implementation-dependent
(setq l (list 1 2 3)) !(1 2 3)
(nreverse l)!(3 2 1)
l!implementation-dependent
Side Eﬀects:
nreverse might either create a new sequence , modify the argument sequence , or both. ( reverse
does not modify sequence .)
Sequences 17–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
sort,stable-sort Function
Syntax:
sort sequence predicate &key key!sorted-sequence
stable-sort sequence predicate &key key!sorted-sequence
Arguments and Values:
sequence |aproper sequence .
predicate |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
sorted-sequence |asequence .
Description:
sort andstable-sort destructively sort sequences according to the order determined by the predicate
function.
Ifsequence is a vector , the result is a vector that has the same actual array element type as
sequence . Ifsequence is alist, the result is a list.
sort determines the relationship between two elements by giving keys extracted from the elements
to the predicate . The rst argument to the predicate function is the part of one element of sequence
extracted by the keyfunction (if supplied); the second argument is the part of another element of
sequence extracted by the keyfunction (if supplied). Predicate should return true if and only if the
rst argument is strictly less than the second (in some appropriate sense). If the rst argument is
greater than or equal to the second (in the appropriate sense), then the predicate should return
false.
The argument to the keyfunction is the sequence element. The return value of the keyfunction
becomes an argument to predicate . Ifkeyis not supplied or nil, the sequence element itself is used.
There is no guarantee on the number of times the keywill be called.
If the keyand predicate always return, then the sorting operation will always terminate, producing
asequence containing the same elements assequence (that is, the result is a permutation of
sequence ). This is guaranteed even if the predicate does not really consistently represent a total
order (in which case the elements will be scrambled in some unpredictable way, but no element
will be lost). If the keyconsistently returns meaningful keys, and the predicate does reect some
total ordering criterion on those keys, then the elements of the sorted-sequence will be properly
sorted according to that ordering.
17–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
sort, stable-sort
The sorting operation performed by sort is not guaranteed stable. Elements considered equal by
thepredicate might or might not stay in their original order. The predicate is assumed to consider
two elements xandyto be equal if (funcall predicate x y )and(funcall predicate y x )are both
false.stable-sort guarantees stability.
The sorting operation can be destructive in all cases. In the case of a vector argument, this is
accomplished by permuting the elements in place. In the case of a list, the listis destructively
reordered in the same manner as for nreverse .
Examples:
(setq tester (copy-seq "lkjashd")) !"lkjashd"
(sort tester #’char-lessp) !"adhjkls"
(setq tester (list ’(1 2 3) ’(4 5 6) ’(7 8 9))) !((1 2 3) (4 5 6) (7 8 9))
(sort tester #’> :key #’car) !((7 8 9) (4 5 6) (1 2 3))
(setq tester (list 1 2 3 4 5 6 7 8 9 0)) !(1 2 3 4 5 6 7 8 9 0)
(stable-sort tester #’(lambda (x y) (and (oddp x) (evenp y))))
!(1 3 5 7 9 2 4 6 8 0)
(sort (setq committee-data
(vector (list (list "JonL" "White") "Iteration")
(list (list "Dick" "Waters") "Iteration")
(list (list "Dick" "Gabriel") "Objects")
(list (list "Kent" "Pitman") "Conditions")
(list (list "Gregor" "Kiczales") "Objects")
(list (list "David" "Moon") "Objects")
(list (list "Kathy" "Chapman") "Editorial")
(list (list "Larry" "Masinter") "Cleanup")
(list (list "Sandra" "Loosemore") "Compiler")))
#’string-lessp :key #’cadar)
!#((("Kathy" "Chapman") "Editorial")
(("Dick" "Gabriel") "Objects")
(("Gregor" "Kiczales") "Objects")
(("Sandra" "Loosemore") "Compiler")
(("Larry" "Masinter") "Cleanup")
(("David" "Moon") "Objects")
(("Kent" "Pitman") "Conditions")
(("Dick" "Waters") "Iteration")
(("JonL" "White") "Iteration"))
;; Note that individual alphabetical order within ‘committees’
;; is preserved.
(setq committee-data
(stable-sort committee-data #’string-lessp :key #’cadr))
!#((("Larry" "Masinter") "Cleanup")
(("Sandra" "Loosemore") "Compiler")
(("Kent" "Pitman") "Conditions")
(("Kathy" "Chapman") "Editorial")
Sequences 17–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(("Dick" "Waters") "Iteration")
(("JonL" "White") "Iteration")
(("Dick" "Gabriel") "Objects")
(("Gregor" "Kiczales") "Objects")
(("David" "Moon") "Objects"))
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
merge , Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects),
Section 3.7 (Destructive Operations)
Notes:
Ifsequence is avector , the result might or might not be simple, and might or might not be identical
tosequence .
ﬁnd,ﬁnd-if,ﬁnd-if-not Function
Syntax:
ﬁnd item sequence &key from-end test test-not start end key !element
ﬁnd-if predicate sequence &key from-end start end key !element
ﬁnd-if-not predicate sequence &key from-end start end key !element
Arguments and Values:
item|an object .
sequence |aproper sequence .
predicate |adesignator for a function of one argument that returns a generalized boolean .
from-end |ageneralized boolean . The default is false.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
key|adesignator for a function of one argument, or nil.
element |an element of the sequence , ornil.
17–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
ﬁnd,ﬁnd-if , andﬁnd-if-not each search for an element of the sequence bounded bystart and end
that satises the predicate predicate or that satises the test testortest-not , as appropriate.
Iffrom-end istrue, then the result is the rightmost element that satises the test .
If the sequence contains an element that satises the test , then the leftmost or rightmost sequence
element, depending on from-end , is returned; otherwise nilis returned.
Examples:
(find #\d "here are some letters that can be looked at" :test #’char>)
!#\Space
(find-if #’oddp ’(1 2 3 4 5) :end 3 :from-end t) !3
(find-if-not #’complexp
’#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))
:start 2)!NIL
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
position , Section 17.2 (Rules about Test Functions), Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not argument is deprecated.
The functionﬁnd-if-not is deprecated.
position,position-if,position-if-not Function
Syntax:
position item sequence &key from-end test test-not start end key !position
position-if predicate sequence &key from-end start end key !position
position-if-not predicate sequence &key from-end start end key !position
Arguments and Values:
item|an object .
sequence |aproper sequence .
predicate |adesignator for a function of one argument that returns a generalized boolean .
Sequences 17–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
from-end |ageneralized boolean . The default is false.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
key|adesignator for a function of one argument, or nil.
position |abounding index ofsequence , ornil.
Description:
position ,position-if , andposition-if-not each search sequence for an element that satises the
test.
The position returned is the index within sequence of the leftmost (if from-end istrue) or of the
rightmost (if from-end isfalse)element that satises the test ; otherwise nilis returned. The index
returned is relative to the left-hand end of the entire sequence , regardless of the value of start ,end,
orfrom-end .
Examples:
(position #\a "baobab" :from-end t) !4
(position-if #’oddp ’((1) (2) (3) (4)) :start 1 :key #’car) !2
(position 595 ’()) !NIL
(position-if-not #’integerp ’(1 2 3 4 5.0)) !4
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
ﬁnd, Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not argument is deprecated.
The functionposition-if-not is deprecated.
17–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
search
search Function
Syntax:
search sequence-1 sequence-2 &key from-end test test-not
key start1 start2
end1 end2
!position
Arguments and Values:
Sequence-1 |asequence .
Sequence-2 |asequence .
from-end |ageneralized boolean . The default is false.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
start1 ,end1 |bounding index designators ofsequence-1 . The defaults for start1 and end1 are0and
nil, respectively.
start2 ,end2 |bounding index designators ofsequence-2 . The defaults for start2 and end2 are0and
nil, respectively.
position |abounding index ofsequence-2 , ornil.
Description:
Searches sequence-2 for a subsequence that matches sequence-1 .
The implementation may choose to search sequence-2 in any order; there is no guarantee on the
number of times the test is made. For example, when start-end istrue, the sequence might actually
be searched from left to right instead of from right to left (but in either case would return the
rightmost matching subsequence). If the search succeeds, search returns the oset into sequence-2
of the rst element of the leftmost or rightmost matching subsequence, depending on from-end ;
otherwise search returnsnil.
Iffrom-end istrue, the index of the leftmost element of the rightmost matching subsequence is
returned.
Examples:
(search "dog" "it’s a dog’s life") !7
(search ’(0 1) ’(2 4 6 1 3 5) :key #’oddp) !2
Sequences 17–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not argument is deprecated.
mismatch Function
Syntax:
mismatch sequence-1 sequence-2 &key from-end test test-not key start1 start2 end1 end2
!position
Arguments and Values:
Sequence-1 |asequence .
Sequence-2 |asequence .
from-end |ageneralized boolean . The default is false.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
start1 ,end1 |bounding index designators ofsequence-1 . The defaults for start1 and end1 are0and
nil, respectively.
start2 ,end2 |bounding index designators ofsequence-2 . The defaults for start2 and end2 are0and
nil, respectively.
key|adesignator for a function of one argument, or nil.
position |abounding index ofsequence-1 , ornil.
Description:
The specied subsequences of sequence-1 and sequence-2 are compared element-wise.
The keyargument is used for both the sequence-1 and the sequence-2 .
Ifsequence-1 and sequence-2 are of equal length and match in every element, the result is false.
Otherwise, the result is a non-negative integer , the index within sequence-1 of the leftmost or
rightmost position, depending on from-end , at which the two subsequences fail to match. If one
subsequence is shorter than and a matching prex of the other, the result is the index relative to
sequence-1 beyond the last position tested.
17–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Iffrom-end istrue, then one plus the index of the rightmost position in which the sequences dier
is returned. In eect, the subsequences are aligned at their right-hand ends; then, the last elements
are compared, the penultimate elements, and so on. The index returned is an index relative to
sequence-1 .
Examples:
(mismatch "abcd" "ABCDE" :test #’char-equal) !4
(mismatch ’(3 2 1 1 2 3) ’(1 2 3) :from-end t) !3
(mismatch ’(1 2 3) ’(2 3 4) :test-not #’eq :key #’oddp) !NIL
(mismatch ’(1 2 3 4 5 6) ’(3 4 5 6 7) :start1 2 :end2 4) !NIL
See Also:
Section 3.6 (Traversal Rules and Side Eects)
Notes:
The:test-not argument is deprecated.
replace Function
Syntax:
replace sequence-1 sequence-2 &key start1 end1 start2 end2 !sequence-1
Arguments and Values:
sequence-1 |asequence .
sequence-2 |asequence .
start1 ,end1 |bounding index designators ofsequence-1 . The defaults for start1 and end1 are0and
nil, respectively.
start2 ,end2 |bounding index designators ofsequence-2 . The defaults for start2 and end2 are0and
nil, respectively.
Description:
Destructively modies sequence-1 by replacing the elements ofsubsequence-1 bounded bystart1
and end1 with the elements ofsubsequence-2 bounded bystart2 and end2 .
Sequence-1 is destructively modied by copying successive elements into it from sequence-2 .
Elements of the subsequence of sequence-2 bounded bystart2 and end2 are copied into the
subsequence of sequence-1 bounded bystart1 and end1 . If these subsequences are not of the same
length, then the shorter length determines how many elements are copied; the extra elements near
the end of the longer subsequence are not involved in the operation. The number of elements
copied can be expressed as:
Sequences 17–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(min (- end1 start1 ) (- end2 start2 ))
Ifsequence-1 and sequence-2 are the same object and the region being modied overlaps the region
being copied from, then it is as if the entire source region were copied to another place and only
then copied back into the target region. However, if sequence-1 and sequence-2 are not the same,
but the region being modied overlaps the region being copied from (perhaps because of shared
list structure or displaced arrays ), then after the replace operation the subsequence of sequence-1
being modied will have unpredictable contents. It is an error if the elements of sequence-2 are not
of a type that can be stored into sequence-1 .
Examples:
(replace "abcdefghij" "0123456789" :start1 4 :end1 7 :start2 4)
!"abcd456hij"
(setq lst "012345678") !"012345678"
(replace lst lst :start1 2 :start2 0) !"010123456"
lst!"010123456"
Side Eﬀects:
The sequence-1 is modied.
See Also:
ﬁll
substitute,substitute-if,substitute-if-not,nsubsti-
tute,nsubstitute-if,nsubstitute-if-not Function
Syntax:
substitute newitem olditem sequence &key from-end test
test-not start
end count key
!result-sequence
substitute-if newitem predicate sequence &key from-end start end count key
!result-sequence
substitute-if-not newitem predicate sequence &key from-end start end count key
!result-sequence
nsubstitute newitem olditem sequence &key from-end test test-not start end count key
!sequence
17–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
substitute, substitute-if, substitute-if-not, :::
nsubstitute-if newitem predicate sequence &key from-end start end count key
!sequence
nsubstitute-if-not newitem predicate sequence &key from-end start end count key
!sequence
Arguments and Values:
newitem |an object .
olditem |an object .
sequence |aproper sequence .
predicate |adesignator for a function of one argument that returns a generalized boolean .
from-end |ageneralized boolean . The default is false.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
count |an integer ornil. The default is nil.
key|adesignator for a function of one argument, or nil.
result-sequence |asequence .
Description:
substitute ,substitute-if , andsubstitute-if-not return a copy of sequence in which each element
that satises the test has been replaced with newitem .
nsubstitute ,nsubstitute-if , andnsubstitute-if-not are likesubstitute ,substitute-if , and
substitute-if-not respectively, but they may modify sequence .
Ifsequence is a vector , the result is a vector that has the same actual array element type as
sequence . Ifsequence is alist, the result is a list.
Count , if supplied, limits the number of elements altered; if more than count elements satisfy the
test, then of these elements only the leftmost or rightmost, depending on from-end , are replaced,
as many as specied by count . Ifcount is supplied and negative, the behavior is as if zero had been
supplied instead. If count isnil, all matching items are aected.
Supplying a from-end oftrue matters only when the count is provided (and non-nil ); in that case,
only the rightmost count elements satisfying the test are removed (instead of the leftmost).
predicate ,test, and test-not might be called more than once for each sequence element , and their
side eects can happen in any order.
Sequences 17–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
substitute, substitute-if, substitute-if-not, :::
The result of all these functions is a sequence of the same type assequence that has the same
elements except that those in the subsequence bounded bystart and endand satisfying the test
have been replaced by newitem .
substitute ,substitute-if , andsubstitute-if-not return a sequence which can share with sequence
or may be identical to the input sequence if no elements need to be changed.
nsubstitute andnsubstitute-if are required to setf anycar(ifsequence is a list) oraref (if
sequence is avector ) of sequence that is required to be replaced with newitem . Ifsequence is alist,
none of the cdrs of the top-level listcan be modied.
Examples:
(substitute #\. #\SPACE "0 2 4 6") !"0.2.4.6"
(substitute 9 4 ’(1 2 4 1 3 4 5)) !(1 2 9 1 3 9 5)
(substitute 9 4 ’(1 2 4 1 3 4 5) :count 1) !(1 2 9 1 3 4 5)
(substitute 9 4 ’(1 2 4 1 3 4 5) :count 1 :from-end t)
!(1 2 4 1 3 9 5)
(substitute 9 3 ’(1 2 4 1 3 4 5) :test #’>) !(9 9 4 9 3 4 5)
(substitute-if 0 #’evenp ’((1) (2) (3) (4)) :start 2 :key #’car)
!((1) (2) (3) 0)
(substitute-if 9 #’oddp ’(1 2 4 1 3 4 5)) !(9 2 4 9 9 4 9)
(substitute-if 9 #’evenp ’(1 2 4 1 3 4 5) :count 1 :from-end t)
!(1 2 4 1 3 9 5)
(setq some-things (list ’a ’car ’b ’cdr ’c)) !(A CAR B CDR C)
(nsubstitute-if "function was here" #’fboundp some-things
:count 1 :from-end t) !(A CAR B "function was here" C)
some-things!(A CAR B "function was here" C)
(setq alpha-tester (copy-seq "ab ")) !"ab "
(nsubstitute-if-not #\z #’alpha-char-p alpha-tester) !"abz"
alpha-tester!"abz"
Side Eﬀects:
nsubstitute ,nsubstitute-if , andnsubstitute-if-not modify sequence .
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
subst ,nsubst , Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects)
Notes:
Ifsequence is avector , the result might or might not be simple, and might or might not be identical
17–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
tosequence .
The:test-not argument is deprecated.
The functions substitute-if-not andnsubstitute-if-not are deprecated.
nsubstitute andnsubstitute-if can be used in for-eect-only positions in code.
Because the side-eecting variants ( e.g.,nsubstitute ) potentially change the path that is being
traversed, their eects in the presence of shared or circular structure may vary in surprising
ways when compared to their non-side-eecting alternatives. To see this, consider the following
side-eect behavior, which might be exhibited by some implementations:
(defun test-it (fn)
(let ((x (cons ’b nil)))
(rplacd x x)
(funcall fn ’a ’b x :count 1)))
(test-it #’substitute) !(A . #1=(B . #1#))
(test-it #’nsubstitute) !(A . #1#)
concatenate Function
Syntax:
concatenate result-type &rest sequences!result-sequence
Arguments and Values:
result-type |asequence type specier .
sequences |asequence .
result-sequence |aproper sequence oftype result-type .
Description:
concatenate returns a sequence that contains all the individual elements of all the sequences in the
order that they are supplied. The sequence is of type result-type , which must be a subtype oftype
sequence .
All of the sequences are copied from; the result does not share any structure with any of the
sequences . Therefore, if only one sequence is provided and it is of type result-type ,concatenate is
required to copy sequence rather than simply returning it.
It is an error if any element of the sequences cannot be an element of the sequence result.
If the result-type is asubtype oflist, the result will be a list.
Sequences 17–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If the result-type is asubtype ofvector , then if the implementation can determine the element type
specied for the result-type , the element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element type is unspecied (or *),
the element type of the resulting array is t; otherwise, an error is signaled.
Examples:
(concatenate ’string "all" " " "together" " " "now") !"all together now"
(concatenate ’list "ABC" ’(d e f) #(1 2 3) #*1011)
!(#\A #\B #\C D E F 1 2 3 1 0 1 1)
(concatenate ’list) !NIL
(concatenate ’(vector * 2) "a" "bc") should signal an error
Exceptional Situations:
An error is signaled if the result-type is neither a recognizable subtype oflist, nor a recognizable
subtype ofvector .
An error of typetype-error should be signaled if result-type species the number of elements and
the sum of sequences is dierent from that number.
See Also:
append
merge Function
Syntax:
merge result-type sequence-1 sequence-2 predicate &key key!result-sequence
Arguments and Values:
result-type |asequence type specier .
sequence-1 |asequence .
sequence-2 |asequence .
predicate |adesignator for a function of two arguments that returns a generalized boolean .
key|adesignator for a function of one argument, or nil.
result-sequence |aproper sequence oftype result-type .
17–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
merge
Description:
Destructively merges sequence-1 with sequence-2 according to an order determined by the
predicate .merge determines the relationship between two elements by giving keys extracted from
the sequence elements to the predicate .
The rst argument to the predicate function is an element of sequence-1 as returned by the key(if
supplied); the second argument is an element of sequence-2 as returned by the key(if supplied).
Predicate should return true if and only if its rst argument is strictly less than the second (in some
appropriate sense). If the rst argument is greater than or equal to the second (in the appropriate
sense), then predicate should return false.merge considers two elements xandyto be equal if
(funcall predicate x y) and(funcall predicate y x) both yield false .
The argument to the keyis the sequence element. Typically, the return value of the keybecomes
the argument to predicate . Ifkeyis not supplied or nil, the sequence element itself is used. The key
may be executed more than once for each sequence element , and its side eects may occur in any
order.
Ifkeyand predicate return, then the merging operation will terminate. The result of merging two
sequences xandyis a new sequence of type result-type z, such that the length of zis the sum of
the lengths of xandy, andzcontains all the elements of xandy. Ifx1andx2are two elements of
x, andx1precedes x2inx, thenx1precedes x2inz, and similarly for elements of y. In short, zis
an interleaving of xandy.
Ifxandywere correctly sorted according to the predicate , thenzwill also be correctly sorted. If x
oryis not so sorted, then zwill not be sorted, but will nevertheless be an interleaving of xandy.
The merging operation is guaranteed stable; if two or more elements are considered equal by the
predicate , then the elements from sequence-1 will precede those from sequence-2 in the result.
sequence-1 and/or sequence-2 may be destroyed.
If the result-type is asubtype oflist, the result will be a list.
If the result-type is asubtype ofvector , then if the implementation can determine the element type
specied for the result-type , the element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element type is unspecied (or *),
the element type of the resulting array is t; otherwise, an error is signaled.
Examples:
(setq test1 (list 1 3 4 6 7))
(setq test2 (list 2 5 8))
(merge ’list test1 test2 #’<) !(1 2 3 4 5 6 7 8)
(setq test1 (copy-seq "BOY"))
(setq test2 (copy-seq :nosy"))
(merge ’string test1 test2 #’char-lessp) !"BnOosYy"
(setq test1 (vector ((red . 1) (blue . 4))))
Sequences 17–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setq test2 (vector ((yellow . 2) (green . 7))))
(merge ’vector test1 test2 #’< :key #’cdr)
!#((RED . 1) (YELLOW . 2) (BLUE . 4) (GREEN . 7))
(merge ’(vector * 4) ’(1 5) ’(2 4 6) #’<) should signal an error
Exceptional Situations:
An error must be signaled if the result-type is neither a recognizable subtype oflist, nor a recognizable
subtype ofvector .
An error of typetype-error should be signaled if result-type species the number of elements and
the sum of the lengths of sequence-1 and sequence-2 is dierent from that number.
See Also:
sort,stable-sort , Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side
Eects)
remove,remove-if,remove-if-not,delete,delete-if,
delete-if-not Function
Syntax:
remove item sequence &key from-end test test-not start end count key !result-sequence
remove-if test sequence &key from-end start end count key !result-sequence
remove-if-not test sequence &key from-end start end count key !result-sequence
delete item sequence &key from-end test test-not start end count key !result-sequence
delete-if test sequence &key from-end start end count key !result-sequence
delete-if-not test sequence &key from-end start end count key !result-sequence
Arguments and Values:
item|an object .
sequence |aproper sequence .
test|adesignator for a function of one argument that returns a generalized boolean .
from-end |ageneralized boolean . The default is false.
test|adesignator for a function of two arguments that returns a generalized boolean .
17–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
remove, remove-if, remove-if-not, delete, delete-if, :::
test-not |adesignator for a function of two arguments that returns a generalized boolean .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
count |an integer ornil. The default is nil.
key|adesignator for a function of one argument, or nil.
result-sequence |asequence .
Description:
remove ,remove-if , andremove-if-not return a sequence from which the elements that satisfy the
testhave been removed.
delete ,delete-if , anddelete-if-not are likeremove ,remove-if , andremove-if-not respectively,
but they may modify sequence .
Ifsequence is a vector , the result is a vector that has the same actual array element type as
sequence . Ifsequence is alist, the result is a list.
Supplying a from-end oftrue matters only when the count is provided; in that case only the
rightmost count elements satisfying the test are deleted.
Count , if supplied, limits the number of elements removed or deleted; if more than count elements
satisfy the test , then of these elements only the leftmost or rightmost, depending on from-end , are
deleted or removed, as many as specied by count . Ifcount is supplied and negative, the behavior
is as if zero had been supplied instead. If count isnil, all matching items are aected.
For all these functions, elements not removed or deleted occur in the same order in the result as
they did in sequence .
remove ,remove-if ,remove-if-not return a sequence of the same type assequence that has the
same elements except that those in the subsequence bounded bystart and endand satisfying the
testhave been removed. This is a non-destructive operation. If any elements need to be removed,
the result will be a copy. The result of remove may share with sequence ; the result may be identical
to the input sequence if no elements need to be removed.
delete ,delete-if , anddelete-if-not return a sequence of the same type assequence that has the
same elements except that those in the subsequence bounded bystart and endand satisfying the
testhave been deleted. Sequence may be destroyed and used to construct the result; however, the
result might or might not be identical tosequence .
delete , when sequence is a list, is permitted to setf any part, carorcdr, of the top-level list
structure in that sequence . When sequence is avector ,delete is permitted to change the dimensions
of the vector and to slide its elements into new positions without permuting them to produce the
resulting vector .
delete-if is constrained to behave exactly as follows:
Sequences 17–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
remove, remove-if, remove-if-not, delete, delete-if, :::
(delete nil sequence
:test #’(lambda (ignore item) (funcall test item ))
...)
Examples:
(remove 4 ’(1 3 4 5 9)) !(1 3 5 9)
(remove 4 ’(1 2 4 1 3 4 5)) !(1 2 1 3 5)
(remove 4 ’(1 2 4 1 3 4 5) :count 1) !(1 2 1 3 4 5)
(remove 4 ’(1 2 4 1 3 4 5) :count 1 :from-end t) !(1 2 4 1 3 5)
(remove 3 ’(1 2 4 1 3 4 5) :test #’>) !(4 3 4 5)
(setq lst ’(list of four elements)) !(LIST OF FOUR ELEMENTS)
(setq lst2 (copy-seq lst)) !(LIST OF FOUR ELEMENTS)
(setq lst3 (delete ’four lst)) !(LIST OF ELEMENTS)
(equal lst lst2) !false
(remove-if #’oddp ’(1 2 4 1 3 4 5)) !(2 4 4)
(remove-if #’evenp ’(1 2 4 1 3 4 5) :count 1 :from-end t)
!(1 2 4 1 3 5)
(remove-if-not #’evenp ’(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)
!(1 2 3 4 5 6 8)
(setq tester (list 1 2 4 1 3 4 5)) !(1 2 4 1 3 4 5)
(delete 4 tester) !(1 2 1 3 5)
(setq tester (list 1 2 4 1 3 4 5)) !(1 2 4 1 3 4 5)
(delete 4 tester :count 1) !(1 2 1 3 4 5)
(setq tester (list 1 2 4 1 3 4 5)) !(1 2 4 1 3 4 5)
(delete 4 tester :count 1 :from-end t) !(1 2 4 1 3 5)
(setq tester (list 1 2 4 1 3 4 5)) !(1 2 4 1 3 4 5)
(delete 3 tester :test #’>) !(4 3 4 5)
(setq tester (list 1 2 4 1 3 4 5)) !(1 2 4 1 3 4 5)
(delete-if #’oddp tester) !(2 4 4)
(setq tester (list 1 2 4 1 3 4 5)) !(1 2 4 1 3 4 5)
(delete-if #’evenp tester :count 1 :from-end t) !(1 2 4 1 3 5)
(setq tester (list 1 2 3 4 5 6)) !(1 2 3 4 5 6)
(delete-if #’evenp tester) !(1 3 5)
tester!implementation-dependent
(setq foo (list ’a ’b ’c)) !(A B C)
(setq bar (cdr foo)) !(B C)
(setq foo (delete ’b foo)) !(A C)
bar!((C)) or ...
(eq (cdr foo) (car bar)) !T or ...
17–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Side Eﬀects:
Fordelete ,delete-if , anddelete-if-not ,sequence may be destroyed and used to construct the
result.
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects)
Notes:
Ifsequence is avector , the result might or might not be simple, and might or might not be identical
tosequence .
The:test-not argument is deprecated.
The functions delete-if-not andremove-if-not are deprecated.
remove-duplicates,delete-duplicates Function
Syntax:
remove-duplicates sequence &key from-end test test-not
start end key
!result-sequence
delete-duplicates sequence &key from-end test test-not
start end key
!result-sequence
Arguments and Values:
sequence |aproper sequence .
from-end |ageneralized boolean . The default is false.
test|adesignator for a function of two arguments that returns a generalized boolean .
test-not |adesignator for a function of two arguments that returns a generalized boolean .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
key|adesignator for a function of one argument, or nil.
Sequences 17–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
remove-duplicates, delete-duplicates
result-sequence |asequence .
Description:
remove-duplicates returns a modied copy of sequence from which any element that matches
another element occurring in sequence has been removed.
Ifsequence is a vector , the result is a vector that has the same actual array element type as
sequence . Ifsequence is alist, the result is a list.
delete-duplicates is likeremove-duplicates , butdelete-duplicates may modify sequence .
The elements of sequence are compared pairwise , and if any two match, then the one occurring
earlier in sequence is discarded, unless from-end istrue, in which case the one later in sequence is
discarded.
remove-duplicates anddelete-duplicates return a sequence of the same type assequence with
enough elements removed so that no two of the remaining elements match. The order of the
elements remaining in the result is the same as the order in which they appear in sequence .
remove-duplicates returns a sequence that may share with sequence or may be identical to
sequence if no elements need to be removed.
delete-duplicates , when sequence is alist, is permitted to setfany part, carorcdr, of the top-level
list structure in that sequence . When sequence is a vector ,delete-duplicates is permitted to
change the dimensions of the vector and to slide its elements into new positions without permuting
them to produce the resulting vector .
Examples:
(remove-duplicates "aBcDAbCd" :test #’char-equal :from-end t) !"aBcD"
(remove-duplicates ’(a b c b d d e)) !(A C B D E)
(remove-duplicates ’(a b c b d d e) :from-end t) !(A B C D E)
(remove-duplicates ’((foo #\a) (bar #\%) (baz #\A))
:test #’char-equal :key #’cadr) !((BAR #\%) (BAZ #\A))
(remove-duplicates ’((foo #\a) (bar #\%) (baz #\A))
:test #’char-equal :key #’cadr :from-end t) !((FOO #\a) (BAR #\%))
(setq tester (list 0 1 2 3 4 5 6))
(delete-duplicates tester :key #’oddp :start 1 :end 6) !(0 4 5 6)
Side Eﬀects:
delete-duplicates might destructively modify sequence .
Exceptional Situations:
Should signal an error of typetype-error ifsequence is not a proper sequence .
See Also:
Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Eects)
17–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
remove-duplicates, delete-duplicates
Notes:
Ifsequence is avector , the result might or might not be simple, and might or might not be identical
tosequence .
The:test-not argument is deprecated.
These functions are useful for converting sequence into a canonical form suitable for representing a
set.
Sequences 17–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
17–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
18. Hash Tables
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Hash Tables iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
18.1 Hash Table Concepts
18.1.1 Hash-Table Operations
Figure 18{1 lists some dened names that are applicable to hash tables . The following rules apply
tohash tables .
{ A hash table can only associate one value with a given key. If an attempt is made to add a
second value for a given key, the second value will replace the rst. Thus, adding a value
to a hash table is a destructive operation; the hash table is modied.
{ There are four kinds of hash tables : those whose keys are compared with eq, those whose
keys are compared with eql, those whose keys are compared with equal , and those whose
keys are compared with equalp .
{Hash tables are created by make-hash-table .gethash is used to look up a key and nd the
associated value. New entries are added to hash tables usingsetf withgethash .remhash
is used to remove an entry. For example:
(setq a (make-hash-table)) !#<HASH-TABLE EQL 0/120 32536573>
(setf (gethash ’color a) ’brown) !BROWN
(setf (gethash ’name a) ’fred) !FRED
(gethash ’color a) !BROWN, true
(gethash ’name a) !FRED, true
(gethash ’pointy a) !NIL, false
In this example, the symbols color andname are being used as keys, and the symbols brown
andfred are being used as the associated values. The hash table has two items in it, one of
which associates from color tobrown , and the other of which associates from name tofred.
{ A key or a value may be any object .
{ The existence of an entry in the hash table can be determined from the secondary value
returned by gethash .
clrhash hash-table-p remhash
gethash make-hash-table sxhash
hash-table-count maphash
Figure 18–1. Hash-table deﬁned names
Hash Tables 18–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
18.1.2 Modifying Hash Table Keys
The function supplied as the :test argument to make-hash-table species the `equivalence test'
for the hash table it creates.
Anobject is `visibly modied' with regard to an equivalence test if there exists some set of objects
(or potential objects ) which are equivalent to the object before the modication but are no longer
equivalent afterwards.
If an objectO1is used as a key in a hash tableHand is then visibly modied with regard to the
equivalence test of H, then the consequences are unspecied if O1, or any objectO2equivalent to
O1under the equivalence test (either before or after the modication), is used as a key in further
operations on H. The consequences of using O1as a key are unspecied even if O1is visibly
modied and then later modied again in such a way as to undo the visible modication.
Following are specications of the modications which are visible to the equivalence tests which
must be supported by hash tables . The modications are described in terms of modication of
components, and are dened recursively. Visible modications of components of the object are
visible modications of the object .
18.1.2.1 Visible Modiﬁcation of Objects with respect to EQ and EQL
Nostandardized function is provided that is capable of visibly modifying an object with regard to
eqoreql.
18.1.2.2 Visible Modiﬁcation of Objects with respect to EQUAL
As a consequence of the behavior for equal , the rules for visible modication of objects not explicitly
mentioned in this section are inherited from those in Section 18.1.2.1 (Visible Modication of
Objects with respect to EQ and EQL).
18.1.2.2.1 Visible Modiﬁcation of Conses with respect to EQUAL
Any visible change to the caror the cdrof a cons is considered a visible modication with regard
toequal .
18.1.2.2.2 Visible Modiﬁcation of Bit Vectors and Strings with respect to EQUAL
For a vector oftypebit-vector or of typestring , any visible change to an active element of the
vector , or to the length of the vector (if it is actually adjustable or has a ll pointer ) is considered
a visible modication with regard to equal .
18.1.2.3 Visible Modiﬁcation of Objects with respect to EQUALP
As a consequence of the behavior for equalp , the rules for visible modication of objects not
explicitly mentioned in this section are inherited from those in Section 18.1.2.2 (Visible Modication
of Objects with respect to EQUAL).
18–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
18.1.2.3.1 Visible Modiﬁcation of Structures with respect to EQUALP
Any visible change to a slotof a structure is considered a visible modication with regard to
equalp .
18.1.2.3.2 Visible Modiﬁcation of Arrays with respect to EQUALP
In an array , any visible change to an active element , to the ll pointer (if the array can and
does have one), or to the dimensions (if the array isactually adjustable ) is considered a visible
modication with regard to equalp .
18.1.2.3.3 Visible Modiﬁcation of Hash Tables with respect to EQUALP
In a hash table , any visible change to the count of entries in the hash table , to the keys, or to the
values associated with the keys is considered a visible modication with regard to equalp .
Note that the visibility of modications to the keys depends on the equivalence test of the hash
table , not on the specication of equalp .
18.1.2.4 Visible Modiﬁcations by Language Extensions
Implementations that extend the language by providing additional mutator functions (or additional
behavior for existing mutator functions) must document how the use of these extensions interacts
with equivalence tests and hash table searches.
Implementations that extend the language by dening additional acceptable equivalence tests
forhash tables (allowing additional values for the :test argument to make-hash-table ) must
document the visible components of these tests.
Hash Tables 18–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
hash-table System Class
Class Precedence List:
hash-table ,t
Description:
Hash tables provide a way of mapping any object (akey) to an associated object (avalue ).
See Also:
Section 18.1 (Hash Table Concepts), Section 22.1.3.13 (Printing Other Objects)
Notes:
The intent is that this mapping be implemented by a hashing mechanism, such as that described
in Section 6.4 \Hashing" of The Art of Computer Programming, Volume 3 (pp506-549). In spite of
this intent, no conforming implementation is required to use any particular technique to implement
the mapping.
make-hash-table Function
Syntax:
make-hash-table &key test size rehash-size rehash-threshold !hash-table
Arguments and Values:
test|adesignator for one of the functions eq,eql,equal , orequalp . The default is eql.
size|a non-negative integer . The default is implementation-dependent .
rehash-size |arealoftype(or (integer 1 *) (float (1.0) *)) . The default is implementation-
dependent .
rehash-threshold |arealoftype(real 0 1) . The default is implementation-dependent .
hash-table |ahash table .
Description:
Creates and returns a new hash table .
testdetermines how keys are compared. An object is said to be present in the hash-table if that
object is the same under the testas the keyfor some entry in the hash-table .
sizeis a hint to the implementation about how much initial space to allocate in the hash-table .
This information, taken together with the rehash-threshold , controls the approximate number of
entries which it should be possible to insert before the table has to grow. The actual size might be
18–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
rounded up from sizeto the next `good' size; for example, some implementations might round to
the next prime number.
rehash-size species a minimum amount to increase the size of the hash-table when it becomes full
enough to require rehashing; see rehash-theshold below. If rehash-size is an integer , the expected
growth rate for the table is additive and the integer is the number of entries to add; if it is a oat,
the expected growth rate for the table is multiplicative and the oat is the ratio of the new size to
the old size. As with size, the actual size of the increase might be rounded up.
rehash-threshold species how full the hash-table can get before it must grow. It species the
maximum desired hash-table occupancy level.
The values ofrehash-size and rehash-threshold do not constrain the implementation to use any
particular method for computing when and by how much the size of hash-table should be enlarged.
Such decisions are implementation-dependent , and these values only hints from the programmer to
theimplementation , and the implementation is permitted to ignore them.
Examples:
(setq table (make-hash-table)) !#<HASH-TABLE EQL 0/120 46142754>
(setf (gethash "one" table) 1) !1
(gethash "one" table) !NIL, false
(setq table (make-hash-table :test ’equal)) !#<HASH-TABLE EQUAL 0/139 46145547>
(setf (gethash "one" table) 1) !1
(gethash "one" table) !1, T
(make-hash-table :rehash-size 1.5 :rehash-threshold 0.7)
!#<HASH-TABLE EQL 0/120 46156620>
See Also:
gethash ,hash-table
hash-table-p Function
Syntax:
hash-table-p object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typehash-table ; otherwise, returns false.
Hash Tables 18–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(setq table (make-hash-table)) !#<HASH-TABLE EQL 0/120 32511220>
(hash-table-p table) !true
(hash-table-p 37) !false
(hash-table-p ’((a . 1) (b . 2))) !false
Notes:
(hash-table-p object)(typep object’hash-table)
hash-table-count Function
Syntax:
hash-table-count hash-table!count
Arguments and Values:
hash-table |ahash table .
count |a non-negative integer .
Description:
Returns the number of entries in the hash-table . Ifhash-table has just been created or newly cleared
(seeclrhash ) the entry count is 0.
Examples:
(setq table (make-hash-table)) !#<HASH-TABLE EQL 0/120 32115135>
(hash-table-count table) !0
(setf (gethash 57 table) "fifty-seven") !"fifty-seven"
(hash-table-count table) !1
(dotimes (i 100) (setf (gethash i table) i)) !NIL
(hash-table-count table) !100
Aﬀected By:
clrhash ,remhash ,setf ofgethash
See Also:
hash-table-size
18–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
The following relationships are functionally correct, although in practice using hash-table-count is
probably much faster:
(hash-table-count table)
(loop for value being the hash-values of tablecount t)
(let ((total 0))
(maphash #’(lambda (key value)
(declare (ignore key value))
(incf total))
table)
total)
hash-table-rehash-size Function
Syntax:
hash-table-rehash-size hash-table!rehash-size
Arguments and Values:
hash-table |ahash table .
rehash-size |arealoftype(or (integer 1 *) (float (1.0) *)) .
Description:
Returns the current rehash size of hash-table , suitable for use in a call to make-hash-table in order
to produce a hash table with state corresponding to the current state of the hash-table .
Examples:
(setq table (make-hash-table :size 100 :rehash-size 1.4))
!#<HASH-TABLE EQL 0/100 2556371>
(hash-table-rehash-size table) !1.4
Exceptional Situations:
Should signal an error of typetype-error ifhash-table is not a hash table .
See Also:
make-hash-table ,hash-table-rehash-threshold
Notes:
If the hash table was created with an integer rehash size, the result is an integer , indicating that
the rate of growth of the hash-table when rehashed is intended to be additive; otherwise, the result
Hash Tables 18–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
is a oat, indicating that the rate of growth of the hash-table when rehashed is intended to be
multiplicative. However, this value is only advice to the implementation ; the actual amount by
which the hash-table will grow upon rehash is implementation-dependent .
hash-table-rehash-threshold Function
Syntax:
hash-table-rehash-threshold hash-table!rehash-threshold
Arguments and Values:
hash-table |ahash table .
rehash-threshold |arealoftype(real 0 1) .
Description:
Returns the current rehash threshold of hash-table , which is suitable for use in a call to
make-hash-table in order to produce a hash table with state corresponding to the current state of
thehash-table .
Examples:
(setq table (make-hash-table :size 100 :rehash-threshold 0.5))
!#<HASH-TABLE EQL 0/100 2562446>
(hash-table-rehash-threshold table) !0.5
Exceptional Situations:
Should signal an error of typetype-error ifhash-table is not a hash table .
See Also:
make-hash-table ,hash-table-rehash-size
18–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
hash-table-size Function
Syntax:
hash-table-size hash-table!size
Arguments and Values:
hash-table |ahash table .
size|a non-negative integer .
Description:
Returns the current size of hash-table , which is suitable for use in a call to make-hash-table in
order to produce a hash table with state corresponding to the current state of the hash-table .
Exceptional Situations:
Should signal an error of typetype-error ifhash-table is not a hash table .
See Also:
hash-table-count ,make-hash-table
hash-table-test Function
Syntax:
hash-table-test hash-table!test
Arguments and Values:
hash-table |ahash table .
test|a function designator . For the four standardized hash table test functions (see
make-hash-table ), the testvalue returned is always a symbol . If an implementation per-
mits additional tests, it is implementation-dependent whether such tests are returned as function
objects orfunction names .
Description:
Returns the test used for comparing keys inhash-table .
Exceptional Situations:
Should signal an error of typetype-error ifhash-table is not a hash table .
See Also:
make-hash-table
Hash Tables 18–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
gethash Accessor
Syntax:
gethash key hash-table &optional default!value, present-p
(setf (gethash key hash-table &optional default)new-value )
Arguments and Values:
key|an object .
hash-table |ahash table .
default |an object . The default is nil.
value |an object .
present-p |ageneralized boolean .
Description:
Value is the object inhash-table whose keyis the same askeyunder the hash-table 's equivalence
test. If there is no such entry, value is the default .
Present-p istrue if an entry is found; otherwise, it is false.
setf may be used with gethash to modify the value associated with a given key, or to add a new
entry. When a gethash form is used as a setf place , any default which is supplied is evaluated
according to normal left-to-right evaluation rules, but its value is ignored.
Examples:
(setq table (make-hash-table)) !#<HASH-TABLE EQL 0/120 32206334>
(gethash 1 table) !NIL, false
(gethash 1 table 2) !2,false
(setf (gethash 1 table) "one") !"one"
(setf (gethash 2 table "two") "two") !"two"
(gethash 1 table) !"one", true
(gethash 2 table) !"two", true
(gethash nil table) !NIL, false
(setf (gethash nil table) nil) !NIL
(gethash nil table) !NIL, true
(defvar *counters* (make-hash-table)) !*COUNTERS*
(gethash ’foo *counters*) !NIL, false
(gethash ’foo *counters* 0) !0,false
18–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defmacro how-many (obj) ‘(values (gethash ,obj *counters* 0))) !HOW-MANY
(defun count-it (obj) (incf (how-many obj))) !COUNT-IT
(dolist (x ’(bar foo foo bar bar baz)) (count-it x))
(how-many ’foo) !2
(how-many ’bar) !3
(how-many ’quux) !0
See Also:
remhash
Notes:
The secondary value ,present-p , can be used to distinguish the absence of an entry from the
presence of an entry that has a value of default .
remhash Function
Syntax:
remhash key hash-table!generalized-boolean
Arguments and Values:
key|an object .
hash-table |ahash table .
generalized-boolean |ageneralized boolean .
Description:
Removes the entry for keyinhash-table , if any. Returns true if there was such an entry, or false
otherwise.
Examples:
(setq table (make-hash-table)) !#<HASH-TABLE EQL 0/120 32115666>
(setf (gethash 100 table) "C") !"C"
(gethash 100 table) !"C", true
(remhash 100 table) !true
(gethash 100 table) !NIL, false
(remhash 100 table) !false
Side Eﬀects:
The hash-table is modied.
Hash Tables 18–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
maphash
maphash Function
Syntax:
maphash function hash-table !nil
Arguments and Values:
function |adesignator for a function of two arguments , the keyand the value .
hash-table |ahash table .
Description:
Iterates over all entries in the hash-table . For each entry, the function is called with two
arguments {the keyand the value of that entry.
The consequences are unspecied if any attempt is made to add or remove an entry from the
hash-table while amaphash is in progress, with two exceptions: the function can use can use setf
ofgethash to change the value part of the entry currently being processed, or it can use remhash
to remove that entry.
Examples:
(setq table (make-hash-table)) !#<HASH-TABLE EQL 0/120 32304110>
(dotimes (i 10) (setf (gethash i table) i)) !NIL
(let ((sum-of-squares 0))
(maphash #’(lambda (key val)
(let ((square (* val val)))
(incf sum-of-squares square)
(setf (gethash key table) square)))
table)
sum-of-squares) !285
(hash-table-count table) !10
(maphash #’(lambda (key val)
(when (oddp val) (remhash key table)))
table)!NIL
(hash-table-count table) !5
(maphash #’(lambda (k v) (print (list k v))) table)
(0 0)
(8 64)
(2 4)
(6 36)
(4 16)
!NIL
Side Eﬀects:
None, other than any which might be done by the function .
18–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
loop,with-hash-table-iterator , Section 3.6 (Traversal Rules and Side Eects)
with-hash-table-iterator Macro
Syntax:
with-hash-table-iterator (name hash-table )fdeclarationg*fformg*!f resultg*
Arguments and Values:
name |a name suitable for the rst argument to macrolet .
hash-table |aform , evaluated once, that should produce a hash table .
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values returned by forms .
Description:
Within the lexical scope of the body, name is dened via macrolet such that successive invocations
of(name)return the items, one by one, from the hash table that is obtained by evaluating
hash-table only once.
An invocation (name)returns three values as follows:
1. A generalized boolean that is true if an entry is returned.
2. The key from the hash-table entry.
3. The value from the hash-table entry.
After all entries have been returned by successive invocations of (name), then only one value is
returned, namely nil.
It is unspecied what happens if any of the implicit interior state of an iteration is returned outside
the dynamic extent of the with-hash-table-iterator form such as by returning some closure over
the invocation form .
Any number of invocations of with-hash-table-iterator can be nested, and the body of the
innermost one can invoke all of the locally established macros , provided all of those macros have
distinct names.
Examples:
The following function should return ton any hash table , and signal an error if the usage of
with-hash-table-iterator does not agree with the corresponding usage of maphash .
Hash Tables 18–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(defun test-hash-table-iterator (hash-table)
(let ((all-entries ’())
(generated-entries ’())
(unique (list nil)))
(maphash #’(lambda (key value) (push (list key value) all-entries))
hash-table)
(with-hash-table-iterator (generator-fn hash-table)
(loop
(multiple-value-bind (more? key value) (generator-fn)
(unless more? (return))
(unless (eql value (gethash key hash-table unique))
(error "Key ~S not found for value ~S" key value))
(push (list key value) generated-entries))))
(unless (= (length all-entries)
(length generated-entries)
(length (union all-entries generated-entries
:key #’car :test (hash-table-test hash-table))))
(error "Generated entries and Maphash entries don’t correspond"))
t))
The following could be an acceptable denition of maphash , implemented by
with-hash-table-iterator .
(defun maphash (function hash-table)
(with-hash-table-iterator (next-entry hash-table)
(loop (multiple-value-bind (more key value) (next-entry)
(unless more (return nil))
(funcall function key value)))))
Exceptional Situations:
The consequences are undened if the local function named name established by
with-hash-table-iterator is called after it has returned false as its primary value .
See Also:
Section 3.6 (Traversal Rules and Side Eects)
clrhash Function
Syntax:
clrhash hash-table!hash-table
Arguments and Values:
hash-table |ahash table .
18–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Removes all entries from hash-table , and then returns that empty hash table .
Examples:
(setq table (make-hash-table)) !#<HASH-TABLE EQL 0/120 32004073>
(dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) !NIL
(hash-table-count table) !100
(gethash 57 table) !"fifty-seven", true
(clrhash table) !#<HASH-TABLE EQL 0/120 32004073>
(hash-table-count table) !0
(gethash 57 table) !NIL, false
Side Eﬀects:
The hash-table is modied.
sxhash Function
Syntax:
sxhash object!hash-code
Arguments and Values:
object |an object .
hash-code |a non-negative xnum .
Description:
sxhash returns a hash code for object .
The manner in which the hash code is computed is implementation-dependent , but subject to
certain constraints:
1.(equal x y)implies(= (sxhash x) (sxhash y)).
2. For any two objects ,xand y, both of which are bit vectors ,characters ,conses ,numbers ,
pathnames ,strings , orsymbols , and which are similar ,(sxhash x)and(sxhash y)yield
the same mathematical value even if xand yexist in dierent Lisp images of the same
implementation . See Section 3.2.4 (Literal Objects in Compiled Files).
3. The hash-code for an object is always the same within a single session provided that the
object is not visibly modied with regard to the equivalence test equal . See Section 18.1.2
(Modifying Hash Table Keys).
Hash Tables 18–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
sxhash
4. The hash-code is intended for hashing. This places no veriable constraint on a conforming
implementation , but the intent is that an implementation should make a good-faith eort
to produce hash-codes that are well distributed within the range of non-negative xnums .
5. Computation of the hash-code must terminate, even if the object contains circularities.
Examples:
(= (sxhash (list ’list "ab")) (sxhash (list ’list "ab"))) !true
(= (sxhash "a") (sxhash (make-string 1 :initial-element #\a))) !true
(let ((r (make-random-state)))
(= (sxhash r) (sxhash (make-random-state r))))
!implementation-dependent
Aﬀected By:
The implementation .
Notes:
Many common hashing needs are satised by make-hash-table and the related functions on hash
tables .sxhash is intended for use where the pre-dened abstractions are insucient. Its main
intent is to allow the user a convenient means of implementing more complicated hashing paradigms
than are provided through hash tables .
The hash codes returned by sxhash are not necessarily related to any hashing strategy used by any
other function in Common Lisp.
Forobjects oftypes thatequal compares with eq, item 3 requires that the hash-code be based on
some immutable quality of the identity of the object. Another legitimate implementation technique
would be to have sxhash assign (and cache) a random hash code for these objects , since there is no
requirement that similar but non-eqobjects have the same hash code.
Although similarity is dened for symbols in terms of both the symbol 'sname and the packages in
which the symbol isaccessible , item 3 disallows using package information to compute the hash
code, since changes to the package status of a symbol are not visible to equal .
18–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
19. Filenames
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Filenames iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.1 Overview of Filenames
There are many kinds of le systems , varying widely both in their supercial syntactic details, and
in their underlying power and structure. The facilities provided by Common Lisp for referring to
and manipulating les has been chosen to be compatible with many kinds of le systems , while at
the same time minimizing the program-visible dierences between kinds of le systems .
Since le systems vary in their conventions for naming les, there are two distinct ways to represent
lenames : as namestrings and as pathnames .
19.1.1 Namestrings as Filenames
Anamestring is astring that represents a lename .
In general, the syntax of namestrings involves the use of implementation-dened conventions,
usually those customary for the le system in which the named leresides. The only exception
is the syntax of a logical pathname namestring , which is dened in this specication; see Section
19.3.1 (Syntax of Logical Pathname Namestrings).
Aconforming program must never unconditionally use a literal namestring other than a logical
pathname namestring because Common Lisp does not dene any namestring syntax other than
that for logical pathnames that would be guaranteed to be portable. However, a conforming
program can, if it is careful, successfully manipulate user-supplied data which contains or refers to
non-portable namestrings .
Anamestring can be coerced to a pathname by the functions pathname orparse-namestring .
19.1.2 Pathnames as Filenames
Pathnames are structured objects that can represent, in an implementation-independent way, the
lenames that are used natively by an underlying le system .
In addition, pathnames can also represent certain partially composed lenames for which an
underlying le system might not have a specic namestring representation.
Apathname need not correspond to any le that actually exists, and more than one pathname can
refer to the same le. For example, the pathname with a version of :newest might refer to the same
le as a pathname with the same components except a certain number as the version. Indeed, a
pathname with version :newest might refer to dierent les as time passes, because the meaning of
such a pathname depends on the state of the le system.
Some le systems naturally use a structural model for their lenames , while others do not. Within
the Common Lisp pathname model, all lenames are seen as having a particular structure, even if
that structure is not reected in the underlying le system . The nature of the mapping between
structure imposed by pathnames and the structure, if any, that is used by the underlying le
system isimplementation-dened .
Filenames 19–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Every pathname has six components: a host, a device, a directory, a name, a type, and a version.
By naming les with pathnames , Common Lisp programs can work in essentially the same way
even in le systems that seem supercially quite dierent. For a detailed description of these
components, see Section 19.2.1 (Pathname Components).
The mapping of the pathname components into the concepts peculiar to each le system is
implementation-dened . There exist conceivable pathnames for which there is no mapping to a
syntactically valid lename in a particular implementation . An implementation may use various
strategies in an attempt to nd a mapping; for example, an implementation may quietly truncate
lenames that exceed length limitations imposed by the underlying le system , or ignore certain
pathname components for which the le system provides no support. If such a mapping cannot be
found, an error of typeﬁle-error is signaled.
The time at which this mapping and associated error signaling occurs is implementation-dependent .
Specically, it may occur at the time the pathname is constructed, when coercing a pathname to
anamestring , or when an attempt is made to open or otherwise access the ledesignated by the
pathname .
Figure 19{1 lists some dened names that are applicable to pathnames .
*default-pathname-defaults* namestring pathname-name
directory-namestring open pathname-type
enough-namestring parse-namestring pathname-version
ﬁle-namestring pathname pathnamep
ﬁle-string-length pathname-device translate-pathname
host-namestring pathname-directory truename
make-pathname pathname-host user-homedir-pathname
merge-pathnames pathname-match-p wild-pathname-p
Figure 19–1. Pathname Operations
19.1.3 Parsing Namestrings Into Pathnames
Parsing is the operation used to convert a namestring into a pathname . Except in the case of
parsing logical pathname namestrings , this operation is implementation-dependent , because the
format of namestrings isimplementation-dependent .
Aconforming implementation is free to accommodate other le system features in its pathname
representation and provides a parser that can process such specications in namestrings .
Conforming programs must not depend on any such features, since those features will not be
portable.
19–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.2 Pathnames
19.2.1 Pathname Components
Apathname has six components: a host, a device, a directory, a name, a type, and a version.
19.2.1.1 The Pathname Host Component
The name of the le system on which the le resides, or the name of a logical host .
19.2.1.2 The Pathname Device Component
Corresponds to the \device" or \le structure" concept in many host le systems: the name of a
logical or physical device containing les.
19.2.1.3 The Pathname Directory Component
Corresponds to the \directory" concept in many host le systems: the name of a group of related
les.
19.2.1.4 The Pathname Name Component
The \name" part of a group of les that can be thought of as conceptually related.
19.2.1.5 The Pathname Type Component
Corresponds to the \letype" or \extension" concept in many host le systems. This says what
kind of le this is. This component is always a string ,nil,:wild , or:unspecific .
19.2.1.6 The Pathname Version Component
Corresponds to the \version number" concept in many host le systems.
The version is either a positive integer or a symbol from the following list: nil,:wild ,:unspecific ,
or:newest (refers to the largest version number that already exists in the le system when reading
a le, or to a version number greater than any already existing in the le system when writing a
new le). Implementations can dene other special version symbols .
19.2.2 Interpreting Pathname Component Values
Filenames 19–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.2.2.1 Strings in Component Values
19.2.2.1.1 Special Characters in Pathname Components
Strings inpathname component values never contain special characters that represent separation
between pathname elds, such as slash in Unix lenames . Whether separator characters are
permitted as part of a string in a pathname component is implementation-dened ; however, if
theimplementation does permit it, it must arrange to properly \quote" the character for the le
system when constructing a namestring . For example,
;; In a TOPS-20 implementation, which uses^V to quote
(NAMESTRING (MAKE-PATHNAME :HOST "OZ" :NAME "<TEST>"))
!#P"OZ:PS:^V<TEST^V>"
not!#P"OZ:PS:<TEST>"
19.2.2.1.2 Case in Pathname Components
Namestrings always use local le system case conventions, but Common Lisp functions that
manipulate pathname components allow the caller to select either of two conventions for representing
case in component values by supplying a value for the :case keyword argument. Figure 19{2 lists
the functions relating to pathnames that permit a :case argument:
make-pathname pathname-directory pathname-name
pathname-device pathname-host pathname-type
Figure 19–2. Pathname functions using a :CASE argument
19.2.2.1.2.1 Local Case in Pathname Components
For the functions in Figure 19{2, a value of :local for the:case argument (the default for these
functions) indicates that the functions should receive and yield strings in component values as if
they were already represented according to the host le system 's convention for case.
If the le system supports both cases ,strings given or received as pathname component values
under this protocol are to be used exactly as written. If the le system only supports one case, the
strings will be translated to that case.
19–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.2.2.1.2.2 Common Case in Pathname Components
For the functions in Figure 19{2, a value of :common for the:case argument that these functions
should receive and yield strings in component values according to the following conventions:
Alluppercase means to use a le system's customary case.
Alllowercase means to use the opposite of the customary case.
Mixed case represents itself.
Note that these conventions have been chosen in such a way that translation from :local to:common
and back to :local is information-preserving.
19.2.2.2 Special Pathname Component Values
19.2.2.2.1 NIL as a Component Value
As a pathname component value, nilrepresents that the component is \unlled"; see Section 19.2.3
(Merging Pathnames).
The value of any pathname component can be nil.
When constructing a pathname ,nilin the host component might mean a default host rather than
an actual nilin some implementations .
19.2.2.2.2 :WILD as a Component Value
If:wild is the value of a pathname component, that component is considered to be a wildcard,
which matches anything.
Aconforming program must be prepared to encounter a value of :wild as the value of any pathname
component, or as an element of a listthat is the value of the directory component.
When constructing a pathname , aconforming program may use :wild as the value of any or all of
the directory, name, type, or version component, but must not use :wild as the value of the host,
or device component.
If:wild is used as the value of the directory component in the construction of a pathname , the eect
is equivalent to specifying the list (:absolute :wild-inferiors) , or the same as (:absolute :wild)
in a le system that does not support :wild-inferiors .
Filenames 19–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.2.2.2.3 :UNSPECIFIC as a Component Value
If:unspecific is the value of a pathname component, the component is considered to be \absent"
or to \have no meaning" in the lename being represented by the pathname .
Whether a value of :unspecific is permitted for any component on any given le system
accessible to the implementation isimplementation-dened . A conforming program must never
unconditionally use a :unspecific as the value of a pathname component because such a value is
not guaranteed to be permissible in all implementations. However, a conforming program can, if
it is careful, successfully manipulate user-supplied data which contains or refers to non-portable
pathname components. And certainly a conforming program should be prepared for the possibility
that any components of a pathname could be :unspecific .
When reading 1the value of any pathname component, conforming programs should be prepared
for the value to be :unspecific .
When writing 1the value of any pathname component, the consequences are undened if :unspecific
is given for a pathname in a le system for which it does not make sense.
19.2.2.2.3.1 Relation between component values NIL and :UNSPECIFIC
If apathname is converted to a namestring , the symbolsniland:unspecific cause the eld to be
treated as if it were empty. That is, both niland:unspecific cause the component not to appear
in the namestring .
However, when merging a pathname with a set of defaults, only a nilvalue for a component will be
replaced with the default for that component, while a value of :unspecific will be left alone as if the
eld were \lled"; see the functionmerge-pathnames and Section 19.2.3 (Merging Pathnames).
19.2.2.3 Restrictions on Wildcard Pathnames
Wildcard pathnames can be used with directory but not with open , and return true from
wild-pathname-p . When examining wildcard components of a wildcard pathname , conforming
programs must be prepared to encounter any of the following additional values in any component
or any element of a listthat is the directory component:
The symbol:wild , which matches anything.
Astring containing implementation-dependent special wildcard characters .
Any object , representing an implementation-dependent wildcard pattern.
19–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.2.2.4 Restrictions on Examining Pathname Components
The space of possible objects that a conforming program must be prepared to read 1as the value of
apathname component is substantially larger than the space of possible objects that a conforming
program is permitted to write 1into such a component.
While the values discussed in the subsections of this section, in Section 19.2.2.2 (Special Pathname
Component Values), and in Section 19.2.2.3 (Restrictions on Wildcard Pathnames) apply to values
that might be seen when reading the component values, substantially more restrictive rules apply
to constructing pathnames; see Section 19.2.2.5 (Restrictions on Constructing Pathnames).
When examining pathname components, conforming programs should be aware of the following
restrictions.
19.2.2.4.1 Restrictions on Examining a Pathname Host Component
It is implementation-dependent what object is used to represent the host.
19.2.2.4.2 Restrictions on Examining a Pathname Device Component
The device might be a string ,:wild ,:unspecific , ornil.
Note that :wild might result from an attempt to read 1thepathname component, even though
portable programs are restricted from writing 1such a component value; see Section 19.2.2.3
(Restrictions on Wildcard Pathnames) and Section 19.2.2.5 (Restrictions on Constructing
Pathnames).
19.2.2.4.3 Restrictions on Examining a Pathname Directory Component
The directory might be a string ,:wild ,:unspecific , ornil.
The directory can be a listofstrings and symbols . The carof the listis one of the symbols
:absolute or:relative , meaning:
:absolute
Alistwhose caris the symbol :absolute represents a directory path starting from the root direc-
tory. The list (:absolute) represents the root directory. The list (:absolute "foo" "bar" "baz")
represents the directory called "/foo/bar/baz" in Unix (except possibly for case).
:relative
Alistwhose caris the symbol :relative represents a directory path starting from a default
directory. The list (:relative) has the same meaning as niland hence is not used. The list
(:relative "foo" "bar") represents the directory named "bar" in the directory named "foo"
in the default directory.
Each remaining element of the listis astring or a symbol .
Filenames 19–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Each string names a single level of directory structure. The strings should contain only the
directory names themselves|no punctuation characters.
In place of a string , at any point in the list,symbols can occur to indicate special le notations.
Figure 19{3 lists the symbols that have standard meanings. Implementations are permitted to add
additional objects of any type that is disjoint from string if necessary to represent features of their
le systems that cannot be represented with the standard strings and symbols .
Supplying any non- string , including any of the symbols listed below, to a le system for which
it does not make sense signals an error of typeﬁle-error . For example, Unix does not support
:wild-inferiors in most implementations.
Symbol Meaning
:wild Wildcard match of one level of directory structure
:wild-inferiors Wildcard match of any number of directory levels
:up Go upward in directory structure (semantic)
:back Go upward in directory structure (syntactic)
Figure 19–3. Special Markers In Directory Component
The following notes apply to the previous gure:
Invalid Combinations
Using:absolute or:wild-inferiors immediately followed by :upor:back signals an error of
typeﬁle-error .
Syntactic vs Semantic
\Syntactic" means that the action of :back depends only on the pathname and not on the
contents of the le system.
\Semantic" means that the action of :updepends on the contents of the le system; to resolve
apathname containing :upto a pathname whose directory component contains only :absolute
and strings requires probing the le system.
:updiers from :back only in le systems that support multiple names for directories, perhaps
via symbolic links. For example, suppose that there is a directory (:absolute "X" "Y" "Z")
linked to (:absolute "A" "B" "C") and there also exist directories (:absolute "A" "B" "Q")
and(:absolute "X" "Y" "Q") . Then (:absolute "X" "Y" "Z" :up "Q") desig-
nates(:absolute "A" "B" "Q") while(:absolute "X" "Y" "Z" :back "Q") designates
(:absolute "X" "Y" "Q")
19–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.2.2.4.3.1 Directory Components in Non-Hierarchical File Systems
In non-hierarchical le systems , the only valid listvalues for the directory component of a
pathname are(:absolute string)and(:absolute :wild) .:relative directories and the keywords
:wild-inferiors ,:up, and:back are not used in non-hierarchical le systems .
19.2.2.4.4 Restrictions on Examining a Pathname Name Component
The name might be a string ,:wild ,:unspecific , ornil.
19.2.2.4.5 Restrictions on Examining a Pathname Type Component
The type might be a string ,:wild ,:unspecific , ornil.
19.2.2.4.6 Restrictions on Examining a Pathname Version Component
The version can be any symbol or any integer .
The symbol :newest refers to the largest version number that already exists in the le system when
reading, overwriting, appending, superseding, or directory listing an existing le. The symbol
:newest refers to the smallest version number greater than any existing version number when
creating a new le.
The symbols nil,:unspecific , and:wild have special meanings and restrictions; see Section
19.2.2.2 (Special Pathname Component Values) and Section 19.2.2.5 (Restrictions on Constructing
Pathnames).
Other symbols and integers have implementation-dened meaning.
19.2.2.4.7 Notes about the Pathname Version Component
It is suggested, but not required, that implementations do the following:
Use positive integers starting at 1 as version numbers.
Recognize the symbol :oldest to designate the smallest existing version number.
Use keywords for other special versions.
Filenames 19–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.2.2.5 Restrictions on Constructing Pathnames
When constructing a pathname from components, conforming programs must follow these rules:
Any component can be nil.nilin the host might mean a default host rather than an actual
nilin some implementations.
The host, device, directory, name, and type can be strings . There are implementation-
dependent limits on the number and type of characters in these strings .
The directory can be a listofstrings and symbols . There are implementation-dependent
limits on the list's length and contents.
The version can be :newest .
Any component can be taken from the corresponding component of another pathname .
When the two pathnames are for dierent le systems (in implementations that support
multiple le systems), an appropriate translation occurs. If no meaningful translation
is possible, an error is signaled. The denitions of \appropriate" and \meaningful" are
implementation-dependent .
An implementation might support other values for some components, but a portable
program cannot use those values. A conforming program can use implementation-dependent
values but this can make it non-portable; for example, it might work only with Unix le
systems.
19.2.3 Merging Pathnames
Merging takes a pathname with unlled components and supplies values for those components from
a source of defaults.
If a component's value is nil, that component is considered to be unlled. If a component's value
is any non-nil object , including :unspecific , that component is considered to be lled.
Except as explicitly specied otherwise, for functions that manipulate or inquire about lesin the le
system , the pathname argument to such a function is merged with *default-pathname-defaults*
before accessing the le system (as if bymerge-pathnames ).
19–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.2.3.1 Examples of Merging Pathnames
Although the following examples are possible to execute only in implementations which permit
:unspecific in the indicated position andwhich permit four-letter type components, they serve to
illustrate the basic concept of pathname merging.
(pathname-type
(merge-pathnames (make-pathname :type "LISP")
(make-pathname :type "TEXT")))
!"LISP"
(pathname-type
(merge-pathnames (make-pathname :type nil)
(make-pathname :type "LISP")))
!"LISP"
(pathname-type
(merge-pathnames (make-pathname :type :unspecific)
(make-pathname :type "LISP")))
!:UNSPECIFIC
Filenames 19–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.3 Logical Pathnames
19.3.1 Syntax of Logical Pathname Namestrings
The syntax of a logical pathname namestring is as follows. (Note that unlike many notational
descriptions in this document, this is a syntactic description of character sequences, not a structural
description of objects .)
logical-pathname:: =[#host host-marker ]
[#relative-directory-marker ]f#directory directory-marker g*
[#name ] [type-marker#type [version-marker#version ]]
host:: =#word
directory:: =#wordj#wildcard-wordj#wild-inferiors-word
name:: =#wordj#wildcard-word
type:: =#wordj#wildcard-word
version:: =#pos-intjnewest-wordjwildcard-version
host-marker |acolon .
relative-directory-marker |asemicolon .
directory-marker |asemicolon .
type-marker |adot.
version-marker |adot.
wild-inferiors-word |The two character sequence \ **" (two asterisks ).
newest-word |The six character sequence \ newest " or the six character sequence \ NEWEST ".
wildcard-version |an asterisk .
wildcard-word |one or more asterisks , uppercase letters, digits, and hyphens, including at least one
asterisk , with no two asterisks adjacent.
word|one or more uppercase letters, digits, and hyphens.
pos-int |a positive integer .
19–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings
19.3.1.1.1 The Host part of a Logical Pathname Namestring
The host must have been dened as a logical pathname host; this can be done by using setf of
logical-pathname-translations .
The logical pathname host name "SYS" is reserved for the implementation. The existence and
meaning of SYS: logical pathnames isimplementation-dened .
19.3.1.1.2 The Device part of a Logical Pathname Namestring
There is no syntax for a logical pathname device since the device component of a logical pathname
is always :unspecific ; see Section 19.3.2.1 (Unspecic Components of a Logical Pathname).
19.3.1.1.3 The Directory part of a Logical Pathname Namestring
If a relative-directory-marker precedes the directories , the directory component parsed is as relative ;
otherwise, the directory component is parsed as absolute .
If a wild-inferiors-marker is specied, it parses into :wild-inferiors .
19.3.1.1.4 The Type part of a Logical Pathname Namestring
The type of a logical pathname for a source le is"LISP" . This should be translated into whatever
type is appropriate in a physical pathname.
19.3.1.1.5 The Version part of a Logical Pathname Namestring
Some le systems do not have versions .Logical pathname translation to such a le system ignores
theversion . This implies that a program cannot rely on being able to store more than one version
of a le named by a logical pathname .
If a wildcard-version is specied, it parses into :wild .
19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring
Each asterisk in a wildcard-word matches a sequence of zero or more characters. The wildcard-word
\*" parses into :wild ; other wildcard-words parse into strings .
19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring
When parsing words and wildcard-words , lowercase letters are translated to uppercase.
Filenames 19–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
19.3.1.1.8 Other Syntax in a Logical Pathname Namestring
The consequences of using characters other than those specied here in a logical pathname
namestring are unspecied.
The consequences of using any value not specied here as a logical pathname component are
unspecied.
19.3.2 Logical Pathname Components
19.3.2.1 Unspeciﬁc Components of a Logical Pathname
The device component of a logical pathname is always :unspecific ; no other component of a logical
pathname can be:unspecific .
19.3.2.2 Null Strings as Components of a Logical Pathname
The null string, "", is not a valid value for any component of a logical pathname .
19–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pathname System Class
Class Precedence List:
pathname ,t
Description:
Apathname is a structured object which represents a lename .
There are two kinds of pathnames |physical pathnames and logical pathnames .
logical-pathname System Class
Class Precedence List:
logical-pathname ,pathname ,t
Description:
Apathname that uses a namestring syntax that is implementation-independent , and that has
component values that are implementation-independent .Logical pathnames do not refer directly to
lenames
See Also:
Section 20.1 (File System Concepts), Section 2.4.8.14 (Sharpsign P), Section 22.1.3.11 (Printing
Pathnames)
pathname Function
Syntax:
pathname pathspec!pathname
Arguments and Values:
pathspec |apathname designator .
pathname |apathname .
Description:
Returns the pathname denoted by pathspec .
Filenames 19–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pathname
If the pathspec designator is astream , the stream can be either open or closed; in both cases, the
pathname returned corresponds to the lename used to open the le.pathname returns the same
pathname for a le stream after it is closed as it did when it was open.
If the pathspec designator is ale stream created by opening a logical pathname , alogical pathname
is returned.
Examples:
;; There is a great degree of variability permitted here. The next
;; several examples are intended to illustrate just a few of the many
;; possibilities. Whether the name is canonicalized to a particular
;; case (either upper or lower) depends on both the file system and the
;; implementation since two different implementations using the same
;; file system might differ on many issues. How information is stored
;; internally (and possibly presented in #S notation) might vary,
;; possibly requiring ‘accessors’ such as PATHNAME-NAME to perform case
;; conversion upon access. The format of a namestring is dependent both
;; on the file system and the implementation since, for example, one
;; implementation might include the host name in a namestring, and
;; another might not. #S notation would generally only be used in a
;; situation where no appropriate namestring could be constructed for use
;; with #P.
(setq p1 (pathname "test"))
!#P"CHOCOLATE:TEST" ; with case canonicalization (e.g., VMS)
or!#P"VANILLA:test" ; without case canonicalization (e.g., Unix)
or!#P"test"or!#S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")or!#S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
(setq p2 (pathname "test"))
!#P"CHOCOLATE:TEST"or!#P"VANILLA:test"or!#P"test"or!#S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")or!#S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
(pathnamep p1)!true
(eq p1 (pathname p1)) !true
(eq p1 p2)
!trueor!false
(with-open-file (stream "test" :direction :output)
(pathname stream))
!#P"ORANGE-CHOCOLATE:>Gus>test.lisp.newest"
See Also:
pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as
19–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Filenames)
make-pathname Function
Syntax:
make-pathname &key host device directory name type version defaults case
!pathname
Arguments and Values:
host|avalid physical pathname host . Complicated defaulting behavior; see below.
device |avalid pathname device . Complicated defaulting behavior; see below.
directory |avalid pathname directory . Complicated defaulting behavior; see below.
name |avalid pathname name . Complicated defaulting behavior; see below.
type|avalid pathname type . Complicated defaulting behavior; see below.
version |avalid pathname version . Complicated defaulting behavior; see below.
defaults |apathname designator . The default is a pathname whose host component is the same as
the host component of the value of*default-pathname-defaults* , and whose other components
are allnil.
case|one of :common or:local . The default is :local .
pathname |apathname .
Description:
Constructs and returns a pathname from the supplied keyword arguments.
After the components supplied explicitly by host,device ,directory ,name ,type, and version are lled
in, the merging rules used by merge-pathnames are used to ll in any unsupplied components
from the defaults supplied by defaults .
Whenever a pathname is constructed the components may be canonicalized if appropriate. For
the explanation of the arguments that can be supplied for each component, see Section 19.2.1
(Pathname Components).
Ifcase is supplied, it is treated as described in Section 19.2.2.1.2 (Case in Pathname Components).
The resulting pathname is alogical pathname if and only its host component is a logical host or a
string that names a dened logical host .
Filenames 19–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-pathname
If the directory is a string , it should be the name of a top level directory, and should not
contain any punctuation characters; that is, specifying a string ,str, is equivalent to specifying
the list (:absolute str). Specifying the symbol :wild is equivalent to specifying the list
(:absolute :wild-inferiors) , or(:absolute :wild) in a le system that does not support
:wild-inferiors .
Examples:
;; Implementation A – an implementation with access to a single
;; Unix file system. This implementation happens to never display
;; the ‘host’ information in a namestring, since there is only one host.
(make-pathname :directory ’(:absolute "public" "games")
:name "chess" :type "db")
!#P"/public/games/chess.db"
;; Implementation B – an implementation with access to one or more
;; VMS file systems. This implementation displays ‘host’ information
;; in the namestring only when the host is not the local host.
;; It uses a double colon to separate a host name from the host’s local
;; file name.
(make-pathname :directory ’(:absolute "PUBLIC" "GAMES")
:name "CHESS" :type "DB")
!#P"SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
(make-pathname :host "BOBBY"
:directory ’(:absolute "PUBLIC" "GAMES")
:name "CHESS" :type "DB")
!#P"BOBBY::SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
;; Implementation C – an implementation with simultaneous access to
;; multiple file systems from the same Lisp image. In this
;; implementation, there is a convention that any text preceding the
;; first colon in a pathname namestring is a host name.
(dolist (case ’(:common :local))
(dolist (host ’("MY-LISPM" "MY-VAX" "MY-UNIX"))
(print (make-pathname :host host :case case
:directory ’(:absolute "PUBLIC" "GAMES")
:name "CHESS" :type "DB"))))
.#P"MY-LISPM:>public>games>chess.db"
.#P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
.#P"MY-UNIX:/public/games/chess.db"
.#P"MY-LISPM:>public>games>chess.db"
.#P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
19–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.#P"MY-UNIX:/PUBLIC/GAMES/CHESS.DB"
!NIL
Aﬀected By:
The le system .
See Also:
merge-pathnames ,pathname ,logical-pathname , Section 20.1 (File System Concepts), Section
19.1.2 (Pathnames as Filenames)
Notes:
Portable programs should not supply :unspecific for any component. See Section 19.2.2.2.3
(:UNSPECIFIC as a Component Value).
pathnamep Function
Syntax:
pathnamep object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typepathname ; otherwise, returns false.
Examples:
(setq q "test") !"test"
(pathnamep q)!false
(setq q (pathname "test"))
!#S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test" :TYPE NIL
:VERSION NIL)
(pathnamep q)!true
(setq q (logical-pathname "SYS:SITE;FOO.SYSTEM"))
!#P"SYS:SITE;FOO.SYSTEM"
(pathnamep q)!true
Notes:
(pathnamep object)(typep object’pathname)
Filenames 19–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pathname-host,pathname-device,pathname-
directory,pathname-name,pathname-type,
pathname-version Function
Syntax:
pathname-host pathname &key case!host
pathname-device pathname &key case!device
pathname-directory pathname &key case!directory
pathname-name pathname &key case!name
pathname-type pathname &key case!type
pathname-version pathname!version
Arguments and Values:
pathname |apathname designator .
case|one of :local or:common . The default is :local .
host|avalid pathname host .
device |avalid pathname device .
directory |avalid pathname directory .
name |avalid pathname name .
type|avalid pathname type .
version |avalid pathname version .
Description:
These functions return the components of pathname .
If the pathname designator is apathname , it represents the name used to open the le. This may
be, but is not required to be, the actual name of the le.
Ifcase is supplied, it is treated as described in Section 19.2.2.1.2 (Case in Pathname Components).
Examples:
19–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pathname-host, pathname-device, :::
(setq q (make-pathname :host "KATHY"
:directory "CHAPMAN"
:name "LOGIN" :type "COM"))
!#P"KATHY::[CHAPMAN]LOGIN.COM"
(pathname-host q) !"KATHY"
(pathname-name q) !"LOGIN"
(pathname-type q) !"COM"
;; Because namestrings are used, the results shown in the remaining
;; examples are not necessarily the only possible results. Mappings
;; from namestring representation to pathname representation are
;; dependent both on the file system involved and on the implementation
;; (since there may be several implementations which can manipulate the
;; the same file system, and those implementations are not constrained
;; to agree on all details). Consult the documentation for each
;; implementation for specific information on how namestrings are treated
;; that implementation.
;; VMS
(pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP"))
!(:ABSOLUTE "FOO" "BAR")
(pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP") :case :common)
!(:ABSOLUTE "FOO" "BAR")
;; Unix
(pathname-directory "foo.l") !NIL
(pathname-device "foo.l") !:UNSPECIFIC
(pathname-name "foo.l") !"foo"
(pathname-name "foo.l" :case :local) !"foo"
(pathname-name "foo.l" :case :common) !"FOO"
(pathname-type "foo.l") !"l"
(pathname-type "foo.l" :case :local) !"l"
(pathname-type "foo.l" :case :common) !"L"
(pathname-type "foo") !:UNSPECIFIC
(pathname-type "foo" :case :common) !:UNSPECIFIC
(pathname-type "foo.") !""
(pathname-type "foo." :case :common) !""
(pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
!(:ABSOLUTE "foo" "bar")
(pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
!(:ABSOLUTE "FOO" "BAR")
(pathname-directory (parse-namestring "../baz.lisp"))
!(:RELATIVE :UP)
(PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz"))
!(:ABSOLUTE "foo" "BAR" :UP "Mum")
Filenames 19–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz") :case :common)
!(:ABSOLUTE "FOO" "bar" :UP "Mum")
(PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l"))
!(:ABSOLUTE "foo" :WILD "bar")
(PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l") :case :common)
!(:ABSOLUTE "FOO" :WILD "BAR")
;; Symbolics LMFS
(pathname-directory (parse-namestring ">foo>**>bar>baz.lisp"))
!(:ABSOLUTE "foo" :WILD-INFERIORS "bar")
(pathname-directory (parse-namestring ">foo>*>bar>baz.lisp"))
!(:ABSOLUTE "foo" :WILD "bar")
(pathname-directory (parse-namestring ">foo>*>bar>baz.lisp") :case :common)
!(:ABSOLUTE "FOO" :WILD "BAR")
(pathname-device (parse-namestring ">foo>baz.lisp")) !:UNSPECIFIC
Aﬀected By:
The implementation and the host le system .
Exceptional Situations:
Should signal an error of typetype-error if its rst argument is not a pathname .
See Also:
pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as
Filenames)
load-logical-pathname-translations Function
Syntax:
load-logical-pathname-translations host!just-loaded
Arguments and Values:
host|astring .
just-loaded |ageneralized boolean .
Description:
Searches for and loads the denition of a logical host named host, if it is not already dened. The
specic nature of the search is implementation-dened .
19–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If the host is already dened, no attempt to nd or load a denition is attempted, and false is
returned. If the host is not already dened, but a denition is successfully found and loaded, true
is returned. Otherwise, an error is signaled.
Examples:
(translate-logical-pathname "hacks:weather;barometer.lisp.newest")
.Error: The logical host HACKS is not defined.
(load-logical-pathname-translations "HACKS")
.;; Loading SYS:SITE;HACKS.TRANSLATIONS
.;; Loading done.
!true
(translate-logical-pathname "hacks:weather;barometer.lisp.newest")
!#P"HELIUM:[SHARED.HACKS.WEATHER]BAROMETER.LSP;0"
(load-logical-pathname-translations "HACKS")
!false
Exceptional Situations:
If no denition is found, an error of typeerror is signaled.
See Also:
logical-pathname
Notes:
Logical pathname denitions will be created not just by implementors but also by programmers .
As such, it is important that the search strategy be documented. For example, an implementation
might dene that the denition of a host is to be found in a le called \ host.translations" in some
specically named directory.
logical-pathname-translations Accessor
Syntax:
logical-pathname-translations host!translations
(setf (logical-pathname-translations host)new-translations )
Arguments and Values:
host{alogical host designator .
translations ,new-translations |alist.
Filenames 19–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
logical-pathname-translations
Description:
Returns the host's listof translations. Each translation is a listof at least two elements:
from-wildcard and to-wildcard . Any additional elements are implementation-dened .From-wildcard
is alogical pathname whose host is host.To-wildcard is apathname .
(setf (logical-pathname-translations host)translations )sets a logical pathname host's listof
translations . If host is a string that has not been previously used as a logical pathname host, a
new logical pathname host is dened; otherwise an existing host's translations are replaced. logical
pathname host names are compared with string-equal .
When setting the translations list, each from-wildcard can be a logical pathname whose host is
host or a logical pathname namestring parseable by (parse-namestring string host ), where host
represents the appropriate object as dened by parse-namestring . Each to-wildcard can be
anything coercible to a pathname by(pathname to-wildcard ). If to-wildcard coerces to a logical
pathname ,translate-logical-pathname will perform repeated translation steps when it uses it.
host is either the host component of a logical pathname or a string that has been dened as a
logical pathname host name by setf oflogical-pathname-translations .
Examples:
;;;A very simple example of setting up a logical pathname host. No
;;;translations are necessary to get around file system restrictions, so
;;;all that is necessary is to specify the root of the physical directory
;;;tree that contains the logical file system.
;;;The namestring syntax on the right-hand side is implementation-dependent.
(setf (logical-pathname-translations "foo")
’(("**;*.*.*" "MY-LISPM:>library>foo>**>")))
;;;Sample use of that logical pathname. The return value
;;;is implementation-dependent.
(translate-logical-pathname "foo:bar;baz;mum.quux.3")
!#P"MY-LISPM:>library>foo>bar>baz>mum.quux.3"
;;;A more complex example, dividing the files among two file servers
;;;and several different directories. This Unix doesn’t support
;;;:WILD-INFERIORS in the directory, so each directory level must
;;;be translated individually. No file name or type translations
;;;are required except for .MAIL to .MBX.
;;;The namestring syntax on the right-hand side is implementation-dependent.
(setf (logical-pathname-translations "prog")
’(("RELEASED;*.*.*" "MY-UNIX:/sys/bin/my-prog/")
("RELEASED;*;*.*.*" "MY-UNIX:/sys/bin/my-prog/*/")
("EXPERIMENTAL;*.*.*" "MY-UNIX:/usr/Joe/development/prog/")
19–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
logical-pathname-translations
("EXPERIMENTAL;DOCUMENTATION;*.*.*"
"MY-VAX:SYS$DISK:[JOE.DOC]")
("EXPERIMENTAL;*;*.*.*" "MY-UNIX:/usr/Joe/development/prog/*/")
("MAIL;**;*.MAIL" "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))
;;;Sample use of that logical pathname. The return value
;;;is implementation-dependent.
(translate-logical-pathname "prog:mail;save;ideas.mail.3")
!#P"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3"
;;;Example translations for a program that uses three files main.lisp,
;;;auxiliary.lisp, and documentation.lisp. These translations might be
;;;supplied by a software supplier as examples.
;;;For Unix with long file names
(setf (logical-pathname-translations "prog")
’(("CODE;*.*.*" "/lib/prog/")))
;;;Sample use of that logical pathname. The return value
;;;is implementation-dependent.
(translate-logical-pathname "prog:code;documentation.lisp")
!#P"/lib/prog/documentation.lisp"
;;;For Unix with 14-character file names, using .lisp as the type
(setf (logical-pathname-translations "prog")
’(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")
("CODE;*.*.*" "/lib/prog/")))
;;;Sample use of that logical pathname. The return value
;;;is implementation-dependent.
(translate-logical-pathname "prog:code;documentation.lisp")
!#P"/lib/prog/docum.lisp"
;;;For Unix with 14-character file names, using .l as the type
;;;The second translation shortens the compiled file type to .b
(setf (logical-pathname-translations "prog")
‘(("**;*.LISP.*" ,(logical-pathname "PROG:**;*.L.*"))
(,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))
Filenames 19–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
logical-pathname-translations
,(logical-pathname "PROG:**;*.B.*"))
("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")
("CODE;*.*.*" "/lib/prog/")))
;;;Sample use of that logical pathname. The return value
;;;is implementation-dependent.
(translate-logical-pathname "prog:code;documentation.lisp")
!#P"/lib/prog/documentatio.l"
;;;For a Cray with 6 character names and no directories, types, or versions.
(setf (logical-pathname-translations "prog")
(let ((l ’(("MAIN" "PGMN")
("AUXILIARY" "PGAUX")
("DOCUMENTATION" "PGDOC")))
(logpath (logical-pathname "prog:code;"))
(phypath (pathname "XXX")))
(append
;; Translations for source files
(mapcar #’(lambda (x)
(let ((log (first x))
(phy (second x)))
(list (make-pathname :name log
:type "LISP"
:version :wild
:defaults logpath)
(make-pathname :name phy
:defaults phypath))))
l)
;; Translations for compiled files
(mapcar #’(lambda (x)
(let* ((log (first x))
(phy (second x))
(com (compile-file-pathname
(make-pathname :name log
:type "LISP"
:version :wild
:defaults logpath))))
(setq phy (concatenate ’string phy "B"))
(list com
(make-pathname :name phy
:defaults phypath))))
l))))
19–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;;;Sample use of that logical pathname. The return value
;;;is implementation-dependent.
(translate-logical-pathname "prog:code;documentation.lisp")
!#P"PGDOC"
Exceptional Situations:
Ifhost is incorrectly supplied, an error of typetype-error is signaled.
See Also:
logical-pathname , Section 19.1.2 (Pathnames as Filenames)
Notes:
Implementations can dene additional functions that operate on logical pathname hosts, for
example to specify additional translation rules or options.
logical-pathname Function
Syntax:
logical-pathname pathspec!logical-pathname
Arguments and Values:
pathspec |alogical pathname , alogical pathname namestring , or a stream .
logical-pathname |alogical pathname .
Description:
logical-pathname converts pathspec to a logical pathname and returns the new logical pathname .
Ifpathspec is alogical pathname namestring , it should contain a host component and its following
colon . Ifpathspec is astream , it should be one for which pathname returns a logical pathname .
Ifpathspec is astream , the stream can be either open or closed. logical-pathname returns the same
logical pathname after a le is closed as it did when the le was open. It is an error if pathspec is a
stream that is created with make-two-way-stream ,make-echo-stream ,make-broadcast-stream ,
make-concatenated-stream ,make-string-input-stream , ormake-string-output-stream .
Exceptional Situations:
Signals an error of typetype-error ifpathspec isn't supplied correctly.
See Also:
logical-pathname ,translate-logical-pathname , Section 19.3 (Logical Pathnames)
Filenames 19–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
default-pathname-defaults  Variable
Value Type:
apathname object .
Initial Value:
Animplementation-dependent pathname , typically in the working directory that was current when
Common Lisp was started up.
Description:
apathname , used as the default whenever a function needs a default pathname and one is not
supplied.
Examples:
;; This example illustrates a possible usage for a hypothetical Lisp running on a
;; DEC TOPS-20 file system. Since pathname conventions vary between Lisp
;; implementations and host file system types, it is not possible to provide a
;; general-purpose, conforming example.
*default-pathname-defaults* !#P"PS:<FRED>"
(merge-pathnames (make-pathname :name "CALENDAR"))
!#P"PS:<FRED>CALENDAR"
(let ((*default-pathname-defaults* (pathname "<MARY>")))
(merge-pathnames (make-pathname :name "CALENDAR")))
!#P"<MARY>CALENDAR"
Aﬀected By:
The implementation .
namestring,ﬁle-namestring,directory-namestring,
host-namestring,enough-namestring Function
Syntax:
namestring pathname!namestring
ﬁle-namestring pathname!namestring
directory-namestring pathname!namestring
host-namestring pathname!namestring
enough-namestring pathname &optional defaults!namestring
19–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
namestring, ﬁle-namestring, directory-namestring, :::
Arguments and Values:
pathname |apathname designator .
defaults |apathname designator . The default is the value of*default-pathname-defaults* .
namestring |astring ornil.
Description:
These functions convert pathname into a namestring. The name represented by pathname is
returned as a namestring in an implementation-dependent canonical form.
namestring returns the full form of pathname .
ﬁle-namestring returns just the name, type, and version components of pathname .
directory-namestring returns the directory name portion.
host-namestring returns the host name.
enough-namestring returns an abbreviated namestring that is just sucient to identify the le
named by pathname when considered relative to the defaults . It is required that
(merge-pathnames (enough-namestring pathname defaults) defaults)
(merge-pathnames (parse-namestring pathname nil defaults) defaults)
in all cases, and the result of enough-namestring is the shortest reasonable string that will satisfy
this criterion.
It is not necessarily possible to construct a valid namestring by concatenating some of the three
shorter namestrings in some order.
Examples:
(namestring "getty")
!"getty"
(setq q (make-pathname :host "kathy"
:directory
(pathname-directory *default-pathname-defaults*)
:name "getty"))
!#S(PATHNAME :HOST "kathy" :DEVICE NIL :DIRECTORY directory-name
:NAME "getty" :TYPE NIL :VERSION NIL)
(file-namestring q) !"getty"
(directory-namestring q) !directory-name
(host-namestring q) !"kathy"
;;;Using Unix syntax and the wildcard conventions used by the
;;;particular version of Unix on which this example was created:
Filenames 19–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(namestring
(translate-pathname "/usr/dmr/hacks/frob.l"
"/usr/d*/hacks/*.l"
"/usr/d*/backup/hacks/backup-*.*"))
!"/usr/dmr/backup/hacks/backup-frob.l"
(namestring
(translate-pathname "/usr/dmr/hacks/frob.l"
"/usr/d*/hacks/fr*.l"
"/usr/d*/backup/hacks/backup-*.*"))
!"/usr/dmr/backup/hacks/backup-ob.l"
;;;This is similar to the above example but uses two different hosts,
;;;U: which is a Unix and V: which is a VMS. Note the translation
;;;of file type and alphabetic case conventions.
(namestring
(translate-pathname "U:/usr/dmr/hacks/frob.l"
"U:/usr/d*/hacks/*.l"
"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
!"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP"
(namestring
(translate-pathname "U:/usr/dmr/hacks/frob.l"
"U:/usr/d*/hacks/fr*.l"
"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
!"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP"
See Also:
truename ,merge-pathnames ,pathname ,logical-pathname , Section 20.1 (File System Concepts),
Section 19.1.2 (Pathnames as Filenames)
parse-namestring Function
Syntax:
parse-namestring thing&optional host default-pathname &key start end junk-allowed
!pathname, position
Arguments and Values:
thing |astring , apathname , or a stream associated with a le .
host|avalid pathname host , alogical host , ornil.
default-pathname |a pathname designator . The default is the value of
*default-pathname-defaults* .
19–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
parse-namestring
start,end|bounding index designators ofthing . The defaults for start and endare0andnil,
respectively.
junk-allowed |ageneralized boolean . The default is false.
pathname |apathname , ornil.
position |abounding index designator forthing .
Description:
Converts thing into a pathname .
The host supplies a host name with respect to which the parsing occurs.
Ifthing is astream associated with a le , processing proceeds as if the pathname used to open that
lehad been supplied instead.
Ifthing is apathname , the host and the host component of thing are compared. If they match,
two values are immediately returned: thing and start; otherwise (if they do not match), an error is
signaled.
Otherwise (if thing is astring ),parse-namestring parses the name of a lewithin the substring of
thing bounded by start and end.
Ifthing is astring then the substring of thing bounded bystart and endis parsed into a pathname
as follows:
Ifhost is alogical host then thing is parsed as a logical pathname namestring on the host.
Ifhost isniland thing is a syntactically valid logical pathname namestring containing an
explicit host, then it is parsed as a logical pathname namestring .
Ifhost isnil,default-pathname is a logical pathname , and thing is a syntactically valid
logical pathname namestring without an explicit host, then it is parsed as a logical
pathname namestring on the host that is the host component of default-pathname .
Otherwise, the parsing of thing isimplementation-dened .
In the rst of these cases, the host portion of the logical pathname namestring and its following
colon are optional.
If the host portion of the namestring and host are both present and do not match, an error is
signaled.
Ifjunk-allowed istrue, then the primary value is the pathname parsed or, if no syntactically correct
pathname was seen, nil. If junk-allowed isfalse, then the entire substring is scanned, and the
primary value is the pathname parsed.
In either case, the secondary value is the index into thing of the delimiter that terminated the
Filenames 19–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
parse, or the index beyond the substring if the parse terminated at the end of the substring (as will
always be the case if junk-allowed isfalse).
Parsing a null string always succeeds, producing a pathname with all components (except the host)
equal tonil.
Ifthing contains an explicit host name and no explicit device name, then it is implementation-
dened whetherparse-namestring will supply the standard default device for that host as the
device component of the resulting pathname .
Examples:
(setq q (parse-namestring "test"))
!#S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
:TYPE NIL :VERSION NIL)
(pathnamep q)!true
(parse-namestring "test")
!#S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
:TYPE NIL :VERSION NIL), 4
(setq s (open xxx))!#<Input File Stream...>
(parse-namestring s)
!#S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME xxx
:TYPE NIL :VERSION NIL), 0
(parse-namestring "test" nil nil :start 2 :end 4 )
!#S(PATHNAME ...), 15
(parse-namestring "foo.lisp")
!#P"foo.lisp"
Exceptional Situations:
Ifjunk-allowed isfalse, an error of typeparse-error is signaled if thing does not consist entirely of
the representation of a pathname , possibly surrounded on either side by whitespace 1characters if
that is appropriate to the cultural conventions of the implementation.
Ifhost is supplied and not nil, and thing contains a manifest host name, an error of typeerror is
signaled if the hosts do not match.
Ifthing is alogical pathname namestring and if the host portion of the namestring and host are
both present and do not match, an error of typeerror is signaled.
See Also:
pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.2.2.2.3 (:UNSPE-
CIFIC as a Component Value), Section 19.1.2 (Pathnames as Filenames)
19–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
wild-pathname-p
wild-pathname-p Function
Syntax:
wild-pathname-p pathname &optional eld-key!generalized-boolean
Arguments and Values:
pathname |apathname designator .
Field-key |one of :host ,:device :directory ,:name ,:type ,:version , ornil.
generalized-boolean |ageneralized boolean .
Description:
wild-pathname-p tests pathname for the presence of wildcard components.
Ifpathname is apathname (as returned by pathname ) it represents the name used to open the le.
This may be, but is not required to be, the actual name of the le.
Ifeld-key is not supplied or nil,wild-pathname-p returns true if pathname has any wildcard
components, nilifpathname has none. If eld-key isnon-nil ,wild-pathname-p returns true if the
indicated component of pathname is a wildcard, nilif the component is not a wildcard.
Examples:
;;;The following examples are not portable. They are written to run
;;;with particular file systems and particular wildcard conventions.
;;;Other implementations will behave differently. These examples are
;;;intended to be illustrative, not to be prescriptive.
(wild-pathname-p (make-pathname :name :wild)) !true
(wild-pathname-p (make-pathname :name :wild) :name) !true
(wild-pathname-p (make-pathname :name :wild) :type) !false
(wild-pathname-p (pathname "s:>foo>**>")) !true;Lispm
(wild-pathname-p (pathname :name "F*O")) !true;Most places
Exceptional Situations:
Ifpathname is not a pathname , astring , or a stream associated with a le an error of type
type-error is signaled.
See Also:
pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as
Filenames)
Notes:
Not all implementations support wildcards in all elds. See Section 19.2.2.2.2 (:WILD as a
Filenames 19–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Component Value) and Section 19.2.2.3 (Restrictions on Wildcard Pathnames).
pathname-match-p Function
Syntax:
pathname-match-p pathname wildcard !generalized-boolean
Arguments and Values:
pathname |apathname designator .
wildcard |adesignator for a wild pathname .
generalized-boolean |ageneralized boolean .
Description:
pathname-match-p returns true if pathname matches wildcard , otherwise nil. The matching
rules are implementation-dened but should be consistent with directory . Missing components of
wildcard default to :wild .
It is valid for pathname to be a wild pathname ; a wildcard eld in pathname only matches a
wildcard eld in wildcard (i.e.,pathname-match-p is not commutative). It is valid for wildcard to
be a non-wild pathname .
Exceptional Situations:
Ifpathname orwildcard is not a pathname ,string , orstream associated with a le an error of type
type-error is signaled.
See Also:
directory ,pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2
(Pathnames as Filenames)
19–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
translate-logical-pathname
translate-logical-pathname Function
Syntax:
translate-logical-pathname pathname &key!physical-pathname
Arguments and Values:
pathname |apathname designator , or a logical pathname namestring .
physical-pathname |aphysical pathname .
Description:
Translates pathname to a physical pathname , which it returns.
Ifpathname is a stream , the stream can be either open or closed. translate-logical-pathname
returns the same physical pathname after a le is closed as it did when the le was open. It is an er-
ror if pathname is a stream that is created with make-two-way-stream ,make-echo-stream ,
make-broadcast-stream ,make-concatenated-stream ,make-string-input-stream ,
make-string-output-stream .
Ifpathname is alogical pathname namestring, the host portion of the logical pathname namestring
and its following colon are required.
Pathname is rst coerced to a pathname . If the coerced pathname is a physical pathname, it is
returned. If the coerced pathname is alogical pathname , the rst matching translation (according to
pathname-match-p ) of the logical pathname host is applied, as if by calling translate-pathname .
If the result is a logical pathname , this process is repeated. When the result is nally a physical
pathname, it is returned. If no translation matches, an error is signaled.
translate-logical-pathname might perform additional translations, typically to provide translation
of le types to local naming conventions, to accomodate physical le systems with limited length
names, or to deal with special character requirements such as translating hyphens to underscores
or uppercase letters to lowercase. Any such additional translations are implementation-dened .
Some implementations do no additional translations.
There are no specied keyword arguments for translate-logical-pathname , but implementations
are permitted to extend it by adding keyword arguments.
Examples:
Seelogical-pathname-translations .
Exceptional Situations:
Ifpathname is incorrectly supplied, an error of typetype-error is signaled.
If no translation matches, an error of typeﬁle-error is signaled.
Filenames 19–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
logical-pathname ,logical-pathname-translations ,logical-pathname , Section 20.1 (File System
Concepts), Section 19.1.2 (Pathnames as Filenames)
translate-pathname Function
Syntax:
translate-pathname source from-wildcard to-wildcard &key
!translated-pathname
Arguments and Values:
source |apathname designator .
from-wildcard |apathname designator .
to-wildcard |apathname designator .
translated-pathname |apathname .
Description:
translate-pathname translates source (that matches from-wildcard ) into a corresponding pathname
that matches to-wildcard , and returns the corresponding pathname .
The resulting pathname isto-wildcard with each wildcard or missing eld replaced by a portion
ofsource . A \wildcard eld" is a pathname component with a value of :wild , a:wild element
of a list-valued directory component, or an implementation-dened portion of a component, such
as the"*"in the complex wildcard string "foo*bar" that some implementations support. An
implementation that adds other wildcard features, such as regular expressions, must dene how
translate-pathname extends to those features. A \missing eld" is a pathname component with a
value ofnil.
The portion of source that is copied into the resulting pathname isimplementation-dened .
Typically it is determined by the user interface conventions of the le systems involved. Usually it
is the portion of source that matches a wildcard eld of from-wildcard that is in the same position
as the wildcard or missing eld of to-wildcard . If there is no wildcard eld in from-wildcard at that
position, then usually it is the entire corresponding pathname component of source , or in the case
of a list-valued directory component, the entire corresponding listelement.
During the copying of a portion of source into the resulting pathname , additional implementation-
dened translations of case or le naming conventions might occur, especially when from-wildcard
and to-wildcard are for dierent hosts.
It is valid for source to be a wild pathname ; in general this will produce a wild result. It is valid
forfrom-wildcard and/or to-wildcard to be non-wild pathnames .
19–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
translate-pathname
There are no specied keyword arguments for translate-pathname , but implementations are
permitted to extend it by adding keyword arguments.
translate-pathname maps customary case in source into customary case in the output pathname .
Examples:
;; The results of the following five forms are all implementation-dependent.
;; The second item in particular is shown with multiple results just to
;; emphasize one of many particular variations which commonly occurs.
(pathname-name (translate-pathname "foobar" "foo*" "*baz")) !"barbaz"
(pathname-name (translate-pathname "foobar" "foo*" "*"))
!"foobar"or!"bar"
(pathname-name (translate-pathname "foobar" "*" "foo*")) !"foofoobar"
(pathname-name (translate-pathname "bar" "*" "foo*")) !"foobar"
(pathname-name (translate-pathname "foobar" "foo*" "baz*")) !"bazbar"
(defun translate-logical-pathname-1 (pathname rules)
(let ((rule (assoc pathname rules :test #’pathname-match-p)))
(unless rule (error "No translation rule for ~A" pathname))
(translate-pathname pathname (first rule) (second rule))))
(translate-logical-pathname-1 "FOO:CODE;BASIC.LISP"
’(("FOO:DOCUMENTATION;" "MY-UNIX:/doc/foo/")
("FOO:CODE;" "MY-UNIX:/lib/foo/")
("FOO:PATCHES;*;" "MY-UNIX:/lib/foo/patch/*/")))
!#P"MY-UNIX:/lib/foo/basic.l"
;;;This example assumes one particular set of wildcard conventions
;;;Not all file systems will run this example exactly as written
(defun rename-files (from to)
(dolist (file (directory from))
(rename-file file (translate-pathname file from to))))
(rename-files "/usr/me/*.lisp" "/dev/her/*.l")
;Renames /usr/me/init.lisp to /dev/her/init.l
(rename-files "/usr/me/pcl*/*" "/sys/pcl/*/")
;Renames /usr/me/pcl-5-may/low.lisp to /sys/pcl/pcl-5-may/low.lisp
;In some file systems the result might be /sys/pcl/5-may/low.lisp
(rename-files "/usr/me/pcl*/*" "/sys/library/*/")
;Renames /usr/me/pcl-5-may/low.lisp to /sys/library/pcl-5-may/low.lisp
;In some file systems the result might be /sys/library/5-may/low.lisp
(rename-files "/usr/me/foo.bar" "/usr/me2/")
;Renames /usr/me/foo.bar to /usr/me2/foo.bar
(rename-files "/usr/joe/*-recipes.text" "/usr/jim/cookbook/joe’s-*-rec.text")
;Renames /usr/joe/lamb-recipes.text to /usr/jim/cookbook/joe’s-lamb-rec.text
;Renames /usr/joe/pork-recipes.text to /usr/jim/cookbook/joe’s-pork-rec.text
Filenames 19–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;Renames /usr/joe/veg-recipes.text to /usr/jim/cookbook/joe’s-veg-rec.text
Exceptional Situations:
If any of source ,from-wildcard , or to-wildcard is not a pathname , astring , or a stream associated
with a le an error of typetype-error is signaled.
(pathname-match-p source from-wildcard )must be true or an error of typeerror is signaled.
See Also:
namestring ,pathname-host ,pathname ,logical-pathname , Section 20.1 (File System Concepts),
Section 19.1.2 (Pathnames as Filenames)
Notes:
The exact behavior of translate-pathname cannot be dictated by the Common Lisp language and
must be allowed to vary, depending on the user interface conventions of the le systems involved.
The following is an implementation guideline. One le system performs this operation by examining
each piece of the three pathnames in turn, where a piece is a pathname component or a listelement
of a structured component such as a hierarchical directory. Hierarchical directory elements in
from-wildcard and to-wildcard are matched by whether they are wildcards, not by depth in the
directory hierarchy. If the piece in to-wildcard is present and not wild, it is copied into the result. If
the piece in to-wildcard is:wild ornil, the piece in source is copied into the result. Otherwise, the
piece in to-wildcard might be a complex wildcard such as "foo*bar" and the piece in from-wildcard
should be wild; the portion of the piece in source that matches the wildcard portion of the piece
infrom-wildcard replaces the wildcard portion of the piece in to-wildcard and the value produced is
used in the result.
merge-pathnames Function
Syntax:
merge-pathnames pathname &optional default-pathname default-version
!merged-pathname
Arguments and Values:
pathname |apathname designator .
default-pathname |a pathname designator . The default is the value of
*default-pathname-defaults* .
default-version |avalid pathname version . The default is :newest .
merged-pathname |apathname .
19–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
merge-pathnames
Description:
Constructs a pathname from pathname by lling in any unsupplied components with the
corresponding values from default-pathname and default-version .
Defaulting of pathname components is done by lling in components taken from another pathname .
This is especially useful for cases such as a program that has an input le and an output le.
Unspecied components of the output pathname will come from the input pathname, except that
the type should not default to the type of the input pathname but rather to the appropriate default
type for output from the program; for example, see the functioncompile-ﬁle-pathname .
If no version is supplied, default-version is used. If default-version isnil, the version component will
remain unchanged.
Ifpathname explicitly species a host and not a device, and if the host component of
default-pathname matches the host component of pathname , then the device is taken from the
default-pathname ; otherwise the device will be the default le device for that host. If pathname
does not specify a host, device, directory, name, or type, each such component is copied from
default-pathname . If pathname does not specify a name, then the version, if not provided, will
come from default-pathname , just like the other components. If pathname does specify a name,
then the version is not aected by default-pathname . If this process leaves the version missing, the
default-version is used. If the host's le name syntax provides a way to input a version without a
name or type, the user can let the name and type default but supply a version dierent from the
one in default-pathname .
Ifpathname is astream ,pathname eectively becomes (pathname pathname ).merge-pathnames
can be used on either an open or a closed stream .
Ifpathname is apathname it represents the name used to open the le. This may be, but is not
required to be, the actual name of the le.
merge-pathnames recognizes a logical pathname namestring when default-pathname is a logical
pathname , or when the namestring begins with the name of a dened logical host followed by a
colon . In the rst of these two cases, the host portion of the logical pathname namestring and its
following colon are optional.
merge-pathnames returns a logical pathname if and only if its rst argument is a logical pathname ,
or its rst argument is a logical pathname namestring with an explicit host, or its rst argument
does not specify a host and the default-pathname is alogical pathname .
Pathname merging treats a relative directory specially. If (pathname-directory pathname )is a
listwhose caris:relative , and(pathname-directory default-pathname )is alist, then the merged
directory is the value of
(append (pathname-directory default-pathname )
(cdr ;remove :relative from the front
(pathname-directory pathname )))
except that if the resulting listcontains a string or:wild immediately followed by :back ,
Filenames 19–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
merge-pathnames
both of them are removed. This removal of redundant :back keywords is repeated
as many times as possible. If (pathname-directory default-pathname )is not a listor
(pathname-directory pathname )is not a listwhose caris:relative , the merged directory
is(or (pathname-directory pathname ) (pathname-directory default-pathname ))
merge-pathnames maps customary case in pathname into customary case in the output pathname .
Examples:
(merge-pathnames "CMUC::FORMAT"
"CMUC::PS:<LISPIO>.FASL")
!#P"CMUC::PS:<LISPIO>FORMAT.FASL.0"
See Also:
*default-pathname-defaults* ,pathname ,logical-pathname , Section 20.1 (File System Concepts),
Section 19.1.2 (Pathnames as Filenames)
Notes:
The net eect is that if just a name is supplied, the host, device, directory, and type will come
from default-pathname , but the version will come from default-version . If nothing or just a directory
is supplied, the name, type, and version will come from default-pathname together.
19–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
20. Files
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Filesiii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
20.1 File System Concepts
This section describes the Common Lisp interface to le systems. The model used by this interface
assumes that les are named by lenames , that a lename can be represented by a pathname
object , and that given a pathname astream can be constructed that connects to a lewhose
lename it represents.
For information about opening and closing les, and manipulating their contents, see Chapter 21
(Streams).
Figure 20{1 lists some operators that are applicable to les and directories.
compile-ﬁle ﬁle-length open
delete-ﬁle ﬁle-position probe-ﬁle
directory ﬁle-write-date rename-ﬁle
ﬁle-author load with-open-ﬁle
Figure 20–1. File and Directory Operations
20.1.1 Coercion of Streams to Pathnames
Astream associated with a le is either a le stream or a synonym stream whose target is a
stream associated with a le . Such streams can be used as pathname designators .
Normally, when a stream associated with a le is used as a pathname designator , it denotes the
pathname used to open the le; this may be, but is not required to be, the actual name of the le.
Some functions, such as truename anddelete-ﬁle , coerce streams topathnames in a dierent way
that involves referring to the actual lethat is open, which might or might not be the le whose
name was opened originally. Such special situations are always notated specically and are not the
default.
20.1.2 File Operations on Open and Closed Streams
Many functions that perform leoperations accept either open orclosed streams asarguments ;
see Section 21.1.3 (Stream Arguments to Standardized Functions).
Of these, the functions in Figure 20{2 treat open and closed streams dierently.
delete-ﬁle ﬁle-author probe-ﬁle
directory ﬁle-write-date truename
Figure 20–2. File Functions that Treat Open and Closed Streams Diﬀerently
Files20–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Since treatment of open streams by the le system may vary considerably between implementations ,
however, a closed stream might be the most reliable kind of argument for some of these functions|in
particular, those in Figure 20{3. For example, in some le systems ,open les are written under
temporary names and not renamed until closed and/or are held invisible until closed . In general,
any code that is intended to be portable should use such functions carefully.
directory probe-ﬁle truename
Figure 20–3. File Functions where Closed Streams Might Work Best
20.1.3 Truenames
Many le systems permit more than one lename to designate a particular le.
Even where multiple names are possible, most le systems have a convention for generating a
canonical lename in such situations. Such a canonical lename (or the pathname representing
such a lename ) is called a truename .
The truename of a lemay dier from other lenames for the le because of symbolic links,
version numbers, logical device translations in the le system ,logical pathname translations within
Common Lisp, or other artifacts of the le system .
The truename for a leis often, but not necessarily, unique for each le. For instance, a Unix le
with multiple hard links could have several truenames .
20.1.3.1 Examples of Truenames
For example, a DEC TOPS-20 system with lesPS:<JOE>FOO.TXT.1 andPS:<JOE>FOO.TXT.2
might permit the second leto be referred to as PS:<JOE>FOO.TXT.0 , since the \ .0" notation
denotes \newest" version of several les. In the same le system , a \logical device" \ JOE:"
might be taken to refer to PS:<JOE> " and so the names JOE:FOO.TXT.2 orJOE:FOO.TXT.0 might
refer to PS:<JOE>FOO.TXT.2 . In all of these cases, the truename of the le would probably be
PS:<JOE>FOO.TXT.2 .
If aleis a symbolic link to another le(in a le system permitting such a thing), it is conventional
for the truename to be the canonical name of the leafter any symbolic links have been followed;
that is, it is the canonical name of the lewhose contents would become available if an input
stream to that lewere opened.
In the case of a lestill being created (that is, of an output stream open to such a le), the exact
truename of the le might not be known until the stream is closed. In this case, the function
truename might return dierent values for such a stream before and after it was closed. In fact,
before it is closed, the name returned might not even be a valid name in the le system |for
example, while a le is being written, it might have version :newest and might only take on a
specic numeric value later when the le is closed even in a le system where all les have numeric
versions.
20–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
directory Function
Syntax:
directory pathspec &key!pathnames
Arguments and Values:
pathspec |apathname designator , which may contain wild components.
pathnames |alistofphysical pathnames .
Description:
Determines which, if any, les that are present in the le system have names matching pathspec ,
and returns a fresh list ofpathnames corresponding to the truenames of those les.
Animplementation may be extended to accept implementation-dened keyword arguments to
directory .
Aﬀected By:
The host computer's le system.
Exceptional Situations:
If the attempt to obtain a directory listing is not successful, an error of typeﬁle-error is signaled.
See Also:
pathname ,logical-pathname ,ensure-directories-exist , Section 20.1 (File System Concepts),
Section 21.1.1.1.2 (Open and Closed Streams), Section 19.1.2 (Pathnames as Filenames)
Notes:
If the pathspec is not wild, the resulting list will contain either zero or one elements.
Common Lisp species \ &key" in the argument list to directory even though no standardized
keyword arguments to directory are dened. \ :allow-other-keys t " may be used in conforming
programs in order to quietly ignore any additional keywords which are passed by the program but
not supported by the implementation .
probe-ﬁle Function
Syntax:
probe-ﬁle pathspec!truename
Arguments and Values:
pathspec |apathname designator .
Files20–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
truename |aphysical pathname ornil.
Description:
probe-ﬁle tests whether a le exists.
probe-ﬁle returns false if there is no le named pathspec , and otherwise returns the truename of
pathspec .
If the pathspec designator is an open stream , thenprobe-ﬁle produces the truename of its
associated le. Ifpathspec is astream , whether open or closed, it is coerced to a pathname as if by
thefunctionpathname .
Aﬀected By:
The host computer's le system.
Exceptional Situations:
An error of typeﬁle-error is signaled if pathspec iswild.
An error of typeﬁle-error is signaled if the le system cannot perform the requested operation.
See Also:
truename ,open ,ensure-directories-exist ,pathname ,logical-pathname , Section 20.1 (File
System Concepts), Section 21.1.1.1.2 (Open and Closed Streams), Section 19.1.2 (Pathnames as
Filenames)
ensure-directories-exist Function
Syntax:
ensure-directories-exist pathspec &key verbose!pathspec, created
Arguments and Values:
pathspec |apathname designator .
verbose |ageneralized boolean .
created |ageneralized boolean .
Description:
Tests whether the directories containing the specied leactually exist, and attempts to create
them if they do not.
If the containing directories do not exist and if verbose istrue, then the implementation is
permitted (but not required) to perform output to standard output saying what directories were
created. If the containing directories exist, or if verbose isfalse, this function performs no output.
20–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The primary value is the given pathspec so that this operation can be straightforwardly composed
with other le manipulation expressions. The secondary value ,created , istrue if any directories
were created.
Aﬀected By:
The host computer's le system.
Exceptional Situations:
An error of typeﬁle-error is signaled if the host, device, or directory part of pathspec iswild.
If the directory creation attempt is not successful, an error of typeﬁle-error is signaled; if this
occurs, it might be the case that none, some, or all of the requested creations have actually occurred
within the le system .
See Also:
probe-ﬁle ,open , Section 19.1.2 (Pathnames as Filenames)
truename Function
Syntax:
truename lespec!truename
Arguments and Values:
lespec |apathname designator .
truename |aphysical pathname .
Description:
truename tries to nd the leindicated by lespec and returns its truename . If the lespec
designator is an open stream , its associated leis used. If lespec is astream ,truename can be
used whether the stream is open or closed. It is permissible for truename to return more specic
information after the stream is closed than when the stream was open. If lespec is apathname it
represents the name used to open the le. This may be, but is not required to be, the actual name
of the le.
Examples:
;; An example involving version numbers. Note that the precise nature of
;; the truename is implementation-dependent while the file is still open.
(with-open-file (stream ">vistor>test.text.newest")
(values (pathname stream)
Files20–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(truename stream)))
!#P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"or!#P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.newest"or!#P"S:>vistor>test.text.newest", #P"S:>vistor> temp.temp.1"
;; In this case, the file is closed when the truename is tried, so the
;; truename information is reliable.
(with-open-file (stream ">vistor>test.text.newest")
(close stream)
(values (pathname stream)
(truename stream)))
!#P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"
;; An example involving TOP-20’s implementation-dependent concept
;; of logical devices – in this case, "DOC:" is shorthand for
;; "PS:<DOCUMENTATION>" ...
(with-open-file (stream "CMUC::DOC:DUMPER.HLP")
(values (pathname stream)
(truename stream)))
!#P"CMUC::DOC:DUMPER.HLP", #P"CMUC::PS:<DOCUMENTATION>DUMPER.HLP.13"
Exceptional Situations:
An error of typeﬁle-error is signaled if an appropriate lecannot be located within the le system
for the given lespec , or if the le system cannot perform the requested operation.
An error of typeﬁle-error is signaled if pathname iswild.
See Also:
pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as
Filenames)
Notes:
truename may be used to account for any lename translations performed by the le system .
ﬁle-author Function
Syntax:
ﬁle-author pathspec!author
Arguments and Values:
pathspec |apathname designator .
author |astring ornil.
20–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returns a string naming the author of the lespecied by pathspec , ornilif the author's name
cannot be determined.
Examples:
(with-open-file (stream ">relativity>general.text")
(file-author s))
!"albert"
Aﬀected By:
The host computer's le system.
Other users of the lenamed by pathspec .
Exceptional Situations:
An error of typeﬁle-error is signaled if pathspec iswild.
An error of typeﬁle-error is signaled if the le system cannot perform the requested operation.
See Also:
pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as
Filenames)
ﬁle-write-date Function
Syntax:
ﬁle-write-date pathspec!date
Arguments and Values:
pathspec |apathname designator .
date|auniversal time ornil.
Description:
Returns a universal time representing the time at which the lespecied by pathspec was last
written (or created), or returns nilif such a time cannot be determined.
Examples:
(with-open-file (s "noel.text"
:direction :output :if-exists :error)
(format s "~&Dear Santa,~2%I was good this year. ~
Please leave lots of toys.~2%Love, Sue~
Files20–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
~2%attachments: milk, cookies~%")
(truename s))
!#P"CUPID:/susan/noel.text"
(with-open-file (s "noel.text")
(file-write-date s))
!2902600800
Aﬀected By:
The host computer's le system.
Exceptional Situations:
An error of typeﬁle-error is signaled if pathspec iswild.
An error of typeﬁle-error is signaled if the le system cannot perform the requested operation.
See Also:
Section 25.1.4.2 (Universal Time), Section 19.1.2 (Pathnames as Filenames)
rename-ﬁle Function
Syntax:
rename-ﬁle lespec new-name !defaulted-new-name, old-truename, new-truename
Arguments and Values:
lespec |apathname designator .
new-name |apathname designator other than a stream .
defaulted-new-name |apathname
old-truename |aphysical pathname .
new-truename |aphysical pathname .
Description:
rename-ﬁle modies the le system in such a way that the le indicated by lespec is renamed to
defaulted-new-name .
It is an error to specify a lename containing a wild component, for lespec to contain a nil
component where the le system does not permit a nilcomponent, or for the result of defaulting
missing components of new-name from lespec to contain a nilcomponent where the le system
does not permit a nilcomponent.
Ifnew-name is alogical pathname ,rename-ﬁle returns a logical pathname as its primary value .
20–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
rename-ﬁle returns three values if successful. The primary value ,defaulted-new-name , is the
resulting name which is composed of new-name with any missing components lled in by performing
amerge-pathnames operation using lespec as the defaults. The secondary value ,old-truename , is
thetruename of the lebefore it was renamed. The tertiary value ,new-truename , is the truename
of the leafter it was renamed.
If the lespec designator is an open stream , then the stream itself and the le associated with it
are aected (if the le system permits).
Examples:
;; An example involving logical pathnames.
(with-open-file (stream "sys:chemistry;lead.text"
:direction :output :if-exists :error)
(princ "eureka" stream)
(values (pathname stream) (truename stream)))
!#P"SYS:CHEMISTRY;LEAD.TEXT.NEWEST", #P"Q:>sys>chem>lead.text.1"
(rename-file "sys:chemistry;lead.text" "gold.text")
!#P"SYS:CHEMISTRY;GOLD.TEXT.NEWEST",
#P"Q:>sys>chem>lead.text.1",
#P"Q:>sys>chem>gold.text.1"
Exceptional Situations:
If the renaming operation is not successful, an error of typeﬁle-error is signaled.
An error of typeﬁle-error might be signaled if lespec iswild.
See Also:
truename ,pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2
(Pathnames as Filenames)
delete-ﬁle Function
Syntax:
delete-ﬁle lespec!t
Arguments and Values:
lespec |apathname designator .
Description:
Deletes the lespecied by lespec .
If the lespec designator is an open stream , then lespec and the le associated with it are aected
(if the le system permits), in which case lespec might be closed immediately, and the deletion
Files20–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
might be immediate or delayed until lespec is explicitly closed, depending on the requirements of
the le system.
It is implementation-dependent whether an attempt to delete a nonexistent le is considered to be
successful.
delete-ﬁle returns true if it succeeds, or signals an error of typeﬁle-error if it does not.
The consequences are undened if lespec has a wild component, or if lespec has anilcomponent
and the le system does not permit a nilcomponent.
Examples:
(with-open-file (s "delete-me.text" :direction :output :if-exists :error))
!NIL
(setq p (probe-file "delete-me.text")) !#P"R:>fred>delete-me.text.1"
(delete-file p) !T
(probe-file "delete-me.text") !false
(with-open-file (s "delete-me.text" :direction :output :if-exists :error)
(delete-file s))
!T
(probe-file "delete-me.text") !false
Exceptional Situations:
If the deletion operation is not successful, an error of typeﬁle-error is signaled.
An error of typeﬁle-error might be signaled if lespec iswild.
See Also:
pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as
Filenames)
ﬁle-error Condition Type
Class Precedence List:
ﬁle-error ,error ,serious-condition ,condition ,t
Description:
The typeﬁle-error consists of error conditions that occur during an attempt to open or close a le,
or during some low-level transactions with a le system. The \oending pathname" is initialized
by the:pathname initialization argument to make-condition , and is accessed by the function
ﬁle-error-pathname .
20–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
ﬁle-error-pathname, open, probe-ﬁle, directory, ensure-directories-exist
ﬁle-error-pathname Function
Syntax:
ﬁle-error-pathname condition!pathspec
Arguments and Values:
condition |acondition oftypeﬁle-error .
pathspec |apathname designator .
Description:
Returns the \oending pathname" of a condition oftypeﬁle-error .
Exceptional Situations:
See Also:
ﬁle-error , Chapter 9 (Conditions)
Files20–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
20–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
21. Streams
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Streams iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
21.1 Stream Concepts
21.1.1 Introduction to Streams
Astream is an object that can be used with an input or output function to identify an appropriate
source or sink of characters orbytes for that operation. A character stream is a source or sink
ofcharacters . Abinary stream is a source or sink of bytes .
Some operations may be performed on any kind of stream ; Figure 21{1 provides a list of
standardized operations that are potentially useful with any kind of stream .
close stream-element-type
input-stream-p streamp
interactive-stream-p with-open-stream
output-stream-p
Figure 21–1. Some General-Purpose Stream Operations
Other operations are only meaningful on certain stream types . For example, read-char is only
dened for character streams andread-byte is only dened for binary streams .
21.1.1.1 Abstract Classiﬁcations of Streams
21.1.1.1.1 Input, Output, and Bidirectional Streams
Astream , whether a character stream or a binary stream , can be an input stream (source of
data), an output stream (sink for data), both, or ( e.g., when \ :direction :probe " is given to
open ) neither.
Figure 21{2 shows operators relating to input streams .
clear-input read-byte read-from-string
listen read-char read-line
peek-char read-char-no-hang read-preserving-whitespace
read read-delimited-list unread-char
Figure 21–2. Operators relating to Input Streams.
Streams 21–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Figure 21{3 shows operators relating to output streams .
clear-output prin1 write
ﬁnish-output prin1-to-string write-byte
force-output princ write-char
format princ-to-string write-line
fresh-line print write-string
pprint terpri write-to-string
Figure 21–3. Operators relating to Output Streams.
Astream that is both an input stream and an output stream is called a bidirectional stream .
See the functions input-stream-p andoutput-stream-p .
Any of the operators listed in Figure 21{2 or Figure 21{3 can be used with bidirectional streams .
In addition, Figure 21{4 shows a list of operators that relate specicaly to bidirectional streams .
y-or-n-p yes-or-no-p
Figure 21–4. Operators relating to Bidirectional Streams.
21.1.1.1.2 Open and Closed Streams
Streams are either open orclosed .
Except as explicitly specied otherwise, operations that create and return streams return open
streams .
The action of closing astream marks the end of its use as a source or sink of data, permitting the
implementation to reclaim its internal data structures, and to free any external resources which
might have been locked by the stream when it was opened.
Except as explicitly specied otherwise, the consequences are undened when a closed stream is
used where a stream is called for.
Coercion of streams topathnames is permissible for closed streams ; in some situations, such as for
atruename computation, the result might be dierent for an open stream and for that same stream
once it has been closed .
21.1.1.1.3 Interactive Streams
Aninteractive stream is one on which it makes sense to perform interactive querying.
The precise meaning of an interactive stream isimplementation-dened , and may depend on the
underlying operating system. Some examples of the things that an implementation might choose
to use as identifying characteristics of an interactive stream include:
21–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The stream is connected to a person (or equivalent) in such a way that the program can
prompt for information and expect to receive dierent input depending on the prompt.
The program is expected to prompt for input and support \normal input editing".
read-char might wait for the user to type something before returning instead of immediately
returning a character or end-of-le.
The general intent of having some streams be classied as interactive streams is to allow them to
be distinguished from streams containing batch (or background or command-le) input. Output
to batch streams is typically discarded or saved for later viewing, so interactive queries to such
streams might not have the expected eect.
Terminal I/O might or might not be an interactive stream .
21.1.1.2 Abstract Classiﬁcations of Streams
21.1.1.2.1 File Streams
Some streams , called le streams , provide access to les. An object ofclassﬁle-stream is used
to represent a le stream .
The basic operation for opening a leisopen , which typically returns a le stream (see its
dictionary entry for details). The basic operation for closing a stream isclose . The macro
with-open-ﬁle is useful to express the common idiom of opening a lefor the duration of a given
body of code, and assuring that the resulting stream is closed upon exit from that body.
21.1.1.3 Other Subclasses of Stream
The classstream has a number of subclasses dened by this specication. Figure 21{5 shows some
information about these subclasses.
Streams 21–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Class Related Operators
broadcast-stream make-broadcast-stream
broadcast-stream-streams
concatenated-stream make-concatenated-stream
concatenated-stream-streams
echo-stream make-echo-stream
echo-stream-input-stream
echo-stream-output-stream
string-stream make-string-input-stream
with-input-from-string
make-string-output-stream
with-output-to-string
get-output-stream-string
synonym-stream make-synonym-stream
synonym-stream-symbol
two-way-stream make-two-way-stream
two-way-stream-input-stream
two-way-stream-output-stream
Figure 21–5. Deﬁned Names related to Specialized Streams
21.1.2 Stream Variables
Variables whose values must be streams are sometimes called stream variables .
Certain stream variables are dened by this specication to be the proper source of input or output
in various situations where no specic stream has been specied instead. A complete list of such
standardized stream variables appears in Figure 21{6. The consequences are undened if at any
time the value of any of these variables is not an open stream .
Glossary Term Variable Name
debug I/O *debug-io*
error output *error-output*
query I/O *query-io*
standard input *standard-input*
standard output *standard-output*
terminal I/O *terminal-io*
trace output *trace-output*
Figure 21–6. Standardized Stream Variables
Note that, by convention, standardized stream variables have names ending in \ -input* " if they
21–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
must be input streams , ending in \ -output* " if they must be output streams , or ending in \ -io*"
if they must be bidirectional streams .
User programs may assign orbind anystandardized stream variable except*terminal-io* .
21.1.3 Stream Arguments to Standardized Functions
The operators in Figure 21{7 accept stream arguments that might be either open orclosed streams .
broadcast-stream-streams ﬁle-author pathnamep
close ﬁle-namestring probe-ﬁle
compile-ﬁle ﬁle-write-date rename-ﬁle
compile-ﬁle-pathname host-namestring streamp
concatenated-stream-streams load synonym-stream-symbol
delete-ﬁle logical-pathname translate-logical-pathname
directory merge-pathnames translate-pathname
directory-namestring namestring truename
dribble open two-way-stream-input-stream
echo-stream-input-stream open-stream-p two-way-stream-output-stream
echo-stream-ouput-stream parse-namestring wild-pathname-p
ed pathname with-open-ﬁle
enough-namestring pathname-match-p
Figure 21–7. Operators that accept either Open or Closed Streams
The operators in Figure 21{8 accept stream arguments that must be open streams .
Streams 21–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
clear-input output-stream-p read-char-no-hang
clear-output peek-char read-delimited-list
ﬁle-length pprint read-line
ﬁle-position pprint-ﬁll read-preserving-whitespace
ﬁle-string-length pprint-indent stream-element-type
ﬁnish-output pprint-linear stream-external-format
force-output pprint-logical-block terpri
format pprint-newline unread-char
fresh-line pprint-tab with-open-stream
get-output-stream-string pprint-tabular write
input-stream-p prin1 write-byte
interactive-stream-p princ write-char
listen print write-line
make-broadcast-stream print-object write-string
make-concatenated-stream print-unreadable-object y-or-n-p
make-echo-stream read yes-or-no-p
make-synonym-stream read-byte
make-two-way-stream read-char
Figure 21–8. Operators that accept Open Streams only
21.1.4 Restrictions on Composite Streams
The consequences are undened if any component of a composite stream isclosed before the
composite stream isclosed .
The consequences are undened if the synonym stream symbol is not bound to an open stream from
the time of the synonym stream 's creation until the time it is closed .
21–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
stream System Class
Class Precedence List:
stream ,t
Description:
Astream is an object that can be used with an input or output function to identify an appropriate
source or sink of characters orbytes for that operation.
For more complete information, see Section 21.1 (Stream Concepts).
See Also:
Section 21.1 (Stream Concepts), Section 22.1.3.13 (Printing Other Objects), Chapter 22 (Printer),
Chapter 23 (Reader)
broadcast-stream System Class
Class Precedence List:
broadcast-stream ,stream ,t
Description:
Abroadcast stream is an output stream which has associated with it a set of zero or more output
streams such that any output sent to the broadcast stream gets passed on as output to each of the
associated output streams . (If a broadcast stream has no component streams , then all output to the
broadcast stream is discarded.)
The set of operations that may be performed on a broadcast stream is the intersection of those for
its associated output streams .
Some output operations ( e.g.,fresh-line ) return values based on the state of the stream at the time
of the operation. Since these values might dier for each of the component streams , it is necessary
to describe their return value specically:
stream-element-type returns the value from the last component stream, or tif there are
no component streams.
fresh-line returns the value from the last component stream, or nilif there are no
component streams.
Streams 21–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The functions ﬁle-length ,ﬁle-position ,ﬁle-string-length , andstream-external-format
return the value from the last component stream; if there are no component
streams, ﬁle-length andﬁle-position return0,ﬁle-string-length returns 1, and
stream-external-format returns:default .
The functions streamp andoutput-stream-p always return true forbroadcast streams .
The functions open-stream-p tests whether the broadcast stream isopen 2, not whether its
component streams are open.
The functions input-stream-p and interactive-stream-p return an implementation-dened ,
generalized boolean value.
For the input operations clear-input listen ,peek-char ,read-byte ,read-char-no-hang ,
read-char ,read-line , andunread-char , the consequences are undened if the indicated
operation is performed. However, an implementation is permitted to dene such a behavior
as an implementation-dependent extension.
For any output operations not having their return values explicitly specied above or elsewhere
in this document, it is dened that the values returned by such an operation are the values
resulting from performing the operation on the last of its component streams ; the values resulting
from performing the operation on all preceding streams are discarded. If there are no component
streams , the value is implementation-dependent .
See Also:
broadcast-stream-streams ,make-broadcast-stream
concatenated-stream System Class
Class Precedence List:
concatenated-stream ,stream ,t
Description:
Aconcatenated stream is an input stream which is a composite stream of zero or more other input
streams , such that the sequence of data which can be read from the concatenated stream is the
same as the concatenation of the sequences of data which could be read from each of the constituent
streams .
Input from a concatenated stream is taken from the rst of the associated input streams until it
reaches end of le 1; then that stream is discarded, and subsequent input is taken from the next
input stream , and so on. An end of le on the associated input streams is always managed invisibly
by the concatenated stream |the only time a client of a concatenated stream sees an end of le is
21–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
when an attempt is made to obtain data from the concatenated stream but it has no remaining
input streams from which to obtain such data.
See Also:
concatenated-stream-streams ,make-concatenated-stream
echo-stream System Class
Class Precedence List:
echo-stream ,stream ,t
Description:
Anecho stream is abidirectional stream that gets its input from an associated input stream and
sends its output to an associated output stream .
All input taken from the input stream is echoed to the output stream . Whether the input is
echoed immediately after it is encountered, or after it has been read from the input stream is
implementation-dependent .
See Also:
echo-stream-input-stream ,echo-stream-output-stream ,make-echo-stream
ﬁle-stream System Class
Class Precedence List:
ﬁle-stream ,stream ,t
Description:
Anobject oftypeﬁle-stream is astream the direct source or sink of which is a le. Such a stream
is created explicitly by open andwith-open-ﬁle , and implicitly by functions such asload that
process les.
See Also:
load,open ,with-open-ﬁle
Streams 21–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
string-stream System Class
Class Precedence List:
string-stream ,stream ,t
Description:
Astring stream is astream which reads input from or writes output to an associated string .
The stream element type of a string stream is always a subtype oftypecharacter .
See Also:
make-string-input-stream ,make-string-output-stream ,with-input-from-string ,
with-output-to-string
synonym-stream System Class
Class Precedence List:
synonym-stream ,stream ,t
Description:
Astream that is an alias for another stream , which is the value of a dynamic variable whose name
is the synonym stream symbol of the synonym stream .
Any operations on a synonym stream will be performed on the stream that is then the value of
thedynamic variable named by the synonym stream symbol . If the value of the variable should
change, or if the variable should be bound , then the stream will operate on the new value of the
variable .
See Also:
make-synonym-stream ,synonym-stream-symbol
21–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
two-way-stream System Class
Class Precedence List:
two-way-stream ,stream ,t
Description:
Abidirectional composite stream that receives its input from an associated input stream and sends
its output to an associated output stream .
See Also:
make-two-way-stream ,two-way-stream-input-stream ,two-way-stream-output-stream
input-stream-p,output-stream-p Function
Syntax:
input-stream-p stream!generalized-boolean
output-stream-p stream!generalized-boolean
Arguments and Values:
stream |astream .
generalized-boolean |ageneralized boolean .
Description:
input-stream-p returns true ifstream is an input stream ; otherwise, returns false.
output-stream-p returns true ifstream is an output stream ; otherwise, returns false.
Examples:
(input-stream-p *standard-input*) !true
(input-stream-p *terminal-io*) !true
(input-stream-p (make-string-output-stream)) !false
(output-stream-p *standard-output*) !true
(output-stream-p *terminal-io*) !true
(output-stream-p (make-string-input-stream "jr")) !false
Exceptional Situations:
Should signal an error of typetype-error ifstream is not a stream .
Streams 21–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
interactive-stream-p Function
Syntax:
interactive-stream-p stream!generalized-boolean
Arguments and Values:
stream |astream .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifstream is an interactive stream ; otherwise, returns false.
Examples:
(when (> measured limit)
(let ((error (round (* (- measured limit) 100)
limit)))
(unless (if (interactive-stream-p *query-io*)
(yes-or-no-p "The frammis is out of tolerance by ~D%.~@
Is it safe to proceed? " error)
(< error 15)) ;15% is acceptable
(error "The frammis is out of tolerance by ~D%." error))))
Exceptional Situations:
Should signal an error of typetype-error ifstream is not a stream .
See Also:
Section 21.1 (Stream Concepts)
open-stream-p Function
Syntax:
open-stream-p stream!generalized-boolean
Arguments and Values:
stream |astream .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifstream is an open stream ; otherwise, returns false.
21–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Streams are open until they have been explicitly closed with close , or until they are implicitly
closed due to exit from a with-output-to-string ,with-open-ﬁle ,with-input-from-string , or
with-open-stream form .
Examples:
(open-stream-p *standard-input*) !true
Aﬀected By:
close .
Exceptional Situations:
Should signal an error of typetype-error ifstream is not a stream .
stream-element-type Function
Syntax:
stream-element-type stream!typespec
Arguments and Values:
stream |astream .
typespec |atype specier .
Description:
stream-element-type returns a type specier that indicates the types ofobjects that may be read
from or written to stream .
Streams created by open have an element type restricted to integer or a subtype oftypecharacter .
Examples:
;; Note that the stream must accomodate at least the specified type,
;; but might accomodate other types. Further note that even if it does
;; accomodate exactly the specified type, the type might be specified in
;; any of several ways.
(with-open-file (s "test" :element-type ’(integer 0 1)
:if-exists :error
:direction :output)
Streams 21–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(stream-element-type s))
!INTEGERor!(UNSIGNED-BYTE 16)or!(UNSIGNED-BYTE 8)or!BITor!(UNSIGNED-BYTE 1)or!(INTEGER 0 1)or!(INTEGER 0 (2))
Exceptional Situations:
Should signal an error of typetype-error ifstream is not a stream .
streamp Function
Syntax:
streamp object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typestream ; otherwise, returns false.
streamp is unaected by whether object , if it is a stream , isopen or closed.
Examples:
(streamp *terminal-io*) !true
(streamp 1)!false
Notes:
(streamp object)(typep object’stream)
21–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
read-byte Function
Syntax:
read-byte stream&optional eof-error-p eof-value !byte
Arguments and Values:
stream |abinary input stream .
eof-error-p |ageneralized boolean . The default is true.
eof-value |an object . The default is nil.
byte|an integer , or the eof-value .
Description:
read-byte reads and returns one byte from stream .
If an end of le 2occurs and eof-error-p isfalse, the eof-value is returned.
Examples:
(with-open-file (s "temp-bytes"
:direction :output
:element-type ’unsigned-byte)
(write-byte 101 s)) !101
(with-open-file (s "temp-bytes" :element-type ’unsigned-byte)
(format t "~S ~S" (read-byte s) (read-byte s nil ’eof)))
.101 EOF
!NIL
Side Eﬀects:
Modies stream .
Exceptional Situations:
Should signal an error of typetype-error ifstream is not a stream .
Should signal an error of typeerror ifstream is not a binary input stream .
If there are no bytes remaining in the stream and eof-error-p istrue, an error of typeend-of-ﬁle is
signaled.
See Also:
read-char ,read-sequence ,write-byte
Streams 21–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
write-byte Function
Syntax:
write-byte byte stream!byte
Arguments and Values:
byte|an integer of the stream element type ofstream .
stream |abinary output stream .
Description:
write-byte writes one byte, byte, to stream .
Examples:
(with-open-file (s "temp-bytes"
:direction :output
:element-type ’unsigned-byte)
(write-byte 101 s)) !101
Side Eﬀects:
stream is modied.
Aﬀected By:
The element type of the stream .
Exceptional Situations:
Should signal an error of typetype-error ifstream is not a stream . Should signal an error of type
error ifstream is not a binary output stream .
Might signal an error of typetype-error ifbyte is not an integer of the stream element type of
stream .
See Also:
read-byte ,write-char ,write-sequence
21–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
peek-char
peek-char Function
Syntax:
peek-char &optional peek-type input-stream eof-error-p
eof-value recursive-p!char
Arguments and Values:
peek-type |acharacter ortornil.
input-stream |input stream designator . The default is standard input .
eof-error-p |ageneralized boolean . The default is true.
eof-value |an object . The default is nil.
recursive-p |ageneralized boolean . The default is false.
char|acharacter or the eof-value .
Description:
peek-char obtains the next character in input-stream without actually reading it, thus leaving
the character to be read at a later time. It can also be used to skip over and discard intervening
characters in the input-stream until a particular character is found.
Ifpeek-type is not supplied or nil,peek-char returns the next character to be read from input-stream ,
without actually removing it from input-stream . The next time input is done from input-stream , the
character will still be there. If peek-type ist, thenpeek-char skips over whitespace 2characters ,
but not comments, and then performs the peeking operation on the next character. The last
character examined, the one that starts an object , is not removed from input-stream . If peek-type
is acharacter , thenpeek-char skips over input characters until a character that is char= to that
character is found; that character is left in input-stream .
If an end of le 2occurs and eof-error-p isfalse,eof-value is returned.
Ifrecursive-p istrue, this call is expected to be embedded in a higher-level call to read or a similar
function used by the Lisp reader .
When input-stream is an echo stream , characters that are only peeked at are not echoed. In the
case that peek-type is notnil, the characters that are passed by peek-char are treated as if by
read-char , and so are echoed unless they have been marked otherwise by unread-char .
Examples:
(with-input-from-string (input-stream " 1 2 3 4 5")
(format t "~S ~S ~S"
(peek-char t input-stream)
Streams 21–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(peek-char #\4 input-stream)
(peek-char nil input-stream)))
.#\1 #\4 #\4
!NIL
Aﬀected By:
*readtable* ,*standard-input* ,*terminal-io* .
Exceptional Situations:
Ifeof-error-p istrue and an end of le 2occurs an error of typeend-of-ﬁle is signaled.
Ifpeek-type is acharacter , an end of le 2occurs, and eof-error-p istrue, an error of typeend-of-ﬁle
is signaled.
Ifrecursive-p istrue and an end of le 2occurs, an error of typeend-of-ﬁle is signaled.
read-char Function
Syntax:
read-char &optional input-stream eof-error-p eof-value recursive-p !char
Arguments and Values:
input-stream |an input stream designator . The default is standard input .
eof-error-p |ageneralized boolean . The default is true.
eof-value |an object . The default is nil.
recursive-p |ageneralized boolean . The default is false.
char|acharacter or the eof-value .
Description:
read-char returns the next character from input-stream .
When input-stream is an echo stream , the character is echoed on input-stream the rst time the
character is seen. Characters that are not echoed by read-char are those that were put there by
unread-char and hence are assumed to have been echoed already by a previous call to read-char .
Ifrecursive-p istrue, this call is expected to be embedded in a higher-level call to read or a similar
function used by the Lisp reader .
If an end of le 2occurs and eof-error-p isfalse,eof-value is returned.
21–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(with-input-from-string (is "0123")
(do ((c (read-char is) (read-char is nil ’the-end)))
((not (characterp c)))
(format t "~S " c)))
.#\0 #\1 #\2 #\3
!NIL
Aﬀected By:
*standard-input* ,*terminal-io* .
Exceptional Situations:
If an end of le 2occurs before a character can be read, and eof-error-p istrue, an error of type
end-of-ﬁle is signaled.
See Also:
read-byte ,read-sequence ,write-char ,read
Notes:
The corresponding output function is write-char .
read-char-no-hang Function
Syntax:
read-char-no-hang &optional input-stream eof-error-p
eof-value recursive-p!char
Arguments and Values:
input-stream { an input stream designator . The default is standard input .
eof-error-p |ageneralized boolean . The default is true.
eof-value |an object . The default is nil.
recursive-p |ageneralized boolean . The default is false.
char|acharacter ornilor the eof-value .
Description:
read-char-no-hang returns a character from input-stream if such a character is available. If no
character is available, read-char-no-hang returnsnil.
Streams 21–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Ifrecursive-p istrue, this call is expected to be embedded in a higher-level call to read or a similar
function used by the Lisp reader .
If an end of le 2occurs and eof-error-p isfalse,eof-value is returned.
Examples:
;; This code assumes an implementation in which a newline is not
;; required to terminate input from the console.
(defun test-it ()
(unread-char (read-char))
(list (read-char-no-hang)
(read-char-no-hang)
(read-char-no-hang)))
!TEST-IT
;; Implementation A, where a Newline is not required to terminate
;; interactive input on the console.
(test-it)
.a
!(#\a NIL NIL)
;; Implementation B, where a Newline is required to terminate
;; interactive input on the console, and where that Newline remains
;; on the input stream.
(test-it)
.a -
!(#\a #\Newline NIL)
Aﬀected By:
*standard-input* ,*terminal-io* .
Exceptional Situations:
If an end of le 2occurs when eof-error-p istrue, an error of typeend-of-ﬁle is signaled .
See Also:
listen
Notes:
read-char-no-hang is exactly like read-char , except that if it would be necessary to wait in order
to get a character (as from a keyboard), nilis immediately returned without waiting.
21–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
terpri, fresh-line
terpri,fresh-line Function
Syntax:
terpri&optional output-stream!nil
fresh-line &optional output-stream!generalized-boolean
Arguments and Values:
output-stream { an output stream designator . The default is standard output .
generalized-boolean |ageneralized boolean .
Description:
terpri outputs a newline tooutput-stream .
fresh-line is similar to terpri but outputs a newline only if the output-stream is not already at the
start of a line. If for some reason this cannot be determined, then a newline is output anyway.
fresh-line returns true if it outputs a newline ; otherwise it returns false.
Examples:
(with-output-to-string (s)
(write-string "some text" s)
(terpri s)
(terpri s)
(write-string "more text" s))
!"some text
more text"
(with-output-to-string (s)
(write-string "some text" s)
(fresh-line s)
(fresh-line s)
(write-string "more text" s))
!"some text
more text"
Side Eﬀects:
The output-stream is modied.
Aﬀected By:
*standard-output* ,*terminal-io* .
Exceptional Situations:
None.
Streams 21–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
terpri is identical in eect to
(write-char #\Newline output-stream)
unread-char Function
Syntax:
unread-char character &optional input-stream!nil
Arguments and Values:
character |acharacter ; must be the last character that was read from input-stream .
input-stream |an input stream designator . The default is standard input .
Description:
unread-char places character back onto the front of input-stream so that it will again be the next
character in input-stream .
When input-stream is an echo stream , no attempt is made to undo any echoing of the character
that might already have been done on input-stream . However, characters placed on input-stream by
unread-char are marked in such a way as to inhibit later re-echo by read-char .
It is an error to invoke unread-char twice consecutively on the same stream without an intervening
call toread-char (or some other input operation which implicitly reads characters) on that stream .
Invoking peek-char orread-char commits all previous characters. The consequences of invoking
unread-char on any character preceding that which is returned by peek-char (including those
passed over by peek-char that has a non-nil peek-type ) are unspecied. In particular, the
consequences of invoking unread-char afterpeek-char are unspecied.
Examples:
(with-input-from-string (is "0123")
(dotimes (i 6)
(let ((c (read-char is)))
(if (evenp i) (format t "~&~S ~S~%" i c) (unread-char c is)))))
.0 #\0
.2 #\1
.4 #\2
!NIL
21–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Aﬀected By:
*standard-input* ,*terminal-io* .
See Also:
peek-char ,read-char , Section 21.1 (Stream Concepts)
Notes:
unread-char is intended to be an ecient mechanism for allowing the Lisp reader and other parsers
to perform one-character lookahead in input-stream .
write-char Function
Syntax:
write-char character &optional output-stream!character
Arguments and Values:
character |acharacter .
output-stream { an output stream designator . The default is standard output .
Description:
write-char outputs character tooutput-stream .
Examples:
(write-char #\a)
.a
!#\a
(with-output-to-string (s)
(write-char #\a s)
(write-char #\Space s)
(write-char #\b s))
!"a b"
Side Eﬀects:
The output-stream is modied.
Aﬀected By:
*standard-output* ,*terminal-io* .
See Also:
read-char ,write-byte ,write-sequence
Streams 21–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
read-line
read-line Function
Syntax:
read-line &optional input-stream eof-error-p eof-value recursive-p
!line, missing-newline-p
Arguments and Values:
input-stream |an input stream designator . The default is standard input .
eof-error-p |ageneralized boolean . The default is true.
eof-value |an object . The default is nil.
recursive-p |ageneralized boolean . The default is false.
line|astring or the eof-value .
missing-newline-p |ageneralized boolean .
Description:
Reads from input-stream a line of text that is terminated by a newline orend of le .
Ifrecursive-p istrue, this call is expected to be embedded in a higher-level call to read or a similar
function used by the Lisp reader .
The primary value ,line, is the line that is read, represented as a string (without the trailing
newline , if any). If eof-error-p isfalse and the end of le forinput-stream is reached before any
characters are read, eof-value is returned as the line.
The secondary value ,missing-newline-p , is a generalized boolean that is false if the linewas
terminated by a newline , ortrue if the linewas terminated by the end of le forinput-stream (or if
thelineis the eof-value ).
Examples:
(setq a "line 1
line2")
!"line 1
line2"
(read-line (setq input-stream (make-string-input-stream a)))
!"line 1", false
(read-line input-stream)
!"line2", true
(read-line input-stream nil nil)
!NIL, true
21–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Aﬀected By:
*standard-input* ,*terminal-io* .
Exceptional Situations:
If an end of le 2occurs before any characters are read in the line, an error is signaled if eof-error-p
istrue.
See Also:
read
Notes:
The corresponding output function is write-line .
write-string,write-line Function
Syntax:
write-string string&optional output-stream &key start end!string
write-line string&optional output-stream &key start end!string
Arguments and Values:
string |astring .
output-stream { an output stream designator . The default is standard output .
start,end|bounding index designators ofstring . The defaults for start and endare0andnil,
respectively.
Description:
write-string writes the characters of the subsequence of string bounded bystart and endto
output-stream .write-line does the same thing, but then outputs a newline afterwards.
Examples:
(prog1 (write-string "books" nil :end 4) (write-string "worms"))
.bookworms
!"books"
(progn (write-char #\*)
(write-line "test12" *standard-output* :end 5)
(write-line "*test2")
(write-char #\*)
nil)
.*test1
Streams 21–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.*test2
.*
!NIL
Aﬀected By:
*standard-output* ,*terminal-io* .
See Also:
read-line ,write-char
Notes:
write-line andwrite-string return string , not the substring bounded bystart and end.
(write-string string)
(dotimes (i (length string)
(write-char (char string i)))
(write-line string)
(prog1 (write-string string) (terpri))
read-sequence Function
Syntax:
read-sequence sequence stream &key start end!position
sequence |asequence .
stream |an input stream .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
position |an integer greater than or equal to zero, and less than or equal to the length of the
sequence .
Description:
Destructively modies sequence by replacing the elements ofsequence bounded bystart and end
with elements read from stream .
Sequence is destructively modied by copying successive elements into it from stream . If the end of
leforstream is reached before copying all elements of the subsequence, then the extra elements
near the end of sequence are not updated.
21–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Position is the index of the rst element ofsequence that was not updated, which might be less
than endbecause the end of le was reached.
Examples:
(defvar *data* (make-array 15 :initial-element nil))
(values (read-sequence *data* (make-string-input-stream "test string")) *data*)
!11, #(#\t #\e #\s #\t #\Space #\s #\t #\r #\i #\n #\g NIL NIL NIL NIL)
Side Eﬀects:
Modies stream and sequence .
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
Should signal an error of typetype-error ifstart is not a non-negative integer . Should signal an
error of typetype-error ifendis not a non-negative integer ornil.
Might signal an error of typetype-error if an element read from the stream is not a member of the
element type of the sequence .
See Also:
Section 3.2.1 (Compiler Terminology), write-sequence ,read-line
Notes:
read-sequence is identical in eect to iterating over the indicated subsequence and reading one
element at a time from stream and storing it into sequence , but may be more ecient than the
equivalent loop. An ecient implementation is more likely to exist for the case where the sequence
is avector with the same element type as the stream .
write-sequence Function
Syntax:
write-sequence sequence stream &key start end!sequence
sequence |asequence .
stream |an output stream .
start,end|bounding index designators ofsequence . The defaults for start and endare0andnil,
respectively.
Description:
write-sequence writes the elements of the subsequence of sequence bounded bystart and endto
stream .
Streams 21–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(write-sequence "bookworms" *standard-output* :end 4)
.book
!"bookworms"
Side Eﬀects:
Modies stream .
Exceptional Situations:
Should be prepared to signal an error of typetype-error ifsequence is not a proper sequence .
Should signal an error of typetype-error ifstart is not a non-negative integer . Should signal an
error of typetype-error ifendis not a non-negative integer ornil.
Might signal an error of typetype-error if an element of the bounded sequence is not a member of
thestream element type of the stream .
See Also:
Section 3.2.1 (Compiler Terminology), read-sequence ,write-string ,write-line
Notes:
write-sequence is identical in eect to iterating over the indicated subsequence and writing one
element at a time to stream , but may be more ecient than the equivalent loop. An ecient
implementation is more likely to exist for the case where the sequence is avector with the same
element type as the stream .
ﬁle-length Function
Syntax:
ﬁle-length stream!length
Arguments and Values:
stream |astream associated with a le .
length |a non-negative integer ornil.
Description:
ﬁle-length returns the length of stream , ornilif the length cannot be determined.
For a binary le, the length is measured in units of the element type of the stream .
Examples:
(with-open-file (s "decimal-digits.text"
21–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
:direction :output :if-exists :error)
(princ "0123456789" s)
(truename s))
!#P"A:>Joe>decimal-digits.text.1"
(with-open-file (s "decimal-digits.text")
(file-length s))
!10
Exceptional Situations:
Should signal an error of typetype-error ifstream is not a stream associated with a le .
See Also:
open
ﬁle-position Function
Syntax:
ﬁle-position stream!position
ﬁle-position stream position-spec !success-p
Arguments and Values:
stream |astream .
position-spec |ale position designator .
position |ale position ornil.
success-p |ageneralized boolean .
Description:
Returns or changes the current position within a stream .
When position-spec is not supplied, ﬁle-position returns the current le position in the stream , or
nilif this cannot be determined.
When position-spec is supplied, the le position instream is set to that le position (if possible).
ﬁle-position returns true if the repositioning is performed successfully, or false if it is not.
Aninteger returned by ﬁle-position of one argument should be acceptable as position-spec for use
with the same le.
For a character le, performing a single read-char orwrite-char operation may cause the le
position to be increased by more than 1 because of character-set translations (such as translating
between the Common Lisp #\Newline character and an external ASCII carriage-return/line-feed
Streams 21–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬁle-position
sequence) and other aspects of the implementation. For a binary le, every read-byte orwrite-byte
operation increases the le position by 1.
Examples:
(defun tester ()
(let ((noticed ’()) file-written)
(flet ((notice (x) (push x noticed) x))
(with-open-file (s "test.bin"
:element-type ’(unsigned-byte 8)
:direction :output
:if-exists :error)
(notice (file-position s)) ;1
(write-byte 5 s)
(write-byte 6 s)
(let ((p (file-position s)))
(notice p) ;2
(notice (when p (file-position s (1- p))))) ;3
(write-byte 7 s)
(notice (file-position s)) ;4
(setq file-written (truename s)))
(with-open-file (s file-written
:element-type ’(unsigned-byte 8)
:direction :input)
(notice (file-position s)) ;5
(let ((length (file-length s)))
(notice length) ;6
(when length
(dotimes (i length)
(notice (read-byte s)))))) ;7,...
(nreverse noticed))))
!tester
(tester)
!(0 2 T 2 0 2 5 7)or!(0 2 NIL 3 0 3 5 6 7)or!(NIL NIL NIL NIL NIL NIL)
Side Eﬀects:
When the position-spec argument is supplied, the le position in the stream might be moved.
Aﬀected By:
The value returned by ﬁle-position increases monotonically as input or output operations are
performed.
21–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
Ifposition-spec is supplied, but is too large or otherwise inappropriate, an error is signaled.
See Also:
ﬁle-length ,ﬁle-string-length ,open
Notes:
Implementations that have character les represented as a sequence of records of bounded
size might choose to encode the le position as, for example, hhrecord-numberii*hhmax-record-
sizeii+hhcharacter-within-record ii. This is a valid encoding because it increases monotonically as
each character is read or written, though not necessarily by 1 at each step. An integer might
then be considered \inappropriate" as position-spec toﬁle-position if, when decoded into record
number and character number, it turned out that the supplied record was too short for the specied
character number.
ﬁle-string-length Function
Syntax:
ﬁle-string-length stream object!length
Arguments and Values:
stream |an output character le stream .
object |astring or a character .
length |a non-negative integer , ornil.
Description:
ﬁle-string-length returns the dierence between what (file-position stream)would be after
writing object and its current value, or nilif this cannot be determined.
The returned value corresponds to the current state of stream at the time of the call and might not
be the same if it is called again when the state of the stream has changed.
Streams 21–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
open
open Function
Syntax:
open lespec&key direction element-type
if-exists if-does-not-exist external-format
!stream
Arguments and Values:
lespec |apathname designator .
direction |one of :input ,:output ,:io, or:probe . The default is :input .
element-type |atype specier forrecognizable subtype ofcharacter ; or a type specier for a nite
recognizable subtype ofinteger ; or one of the symbolssigned-byte ,unsigned-byte , or:default .
The default is character .
if-exists |one of :error ,:new-version ,:rename ,:rename-and-delete ,:overwrite ,:append ,
:supersede , ornil. The default is :new-version if the version component of lespec is:newest , or
:error otherwise.
if-does-not-exist |one of :error ,:create , ornil. The default is :error ifdirection is:input or
if-exists is:overwrite or:append ;:create ifdirection is:output or:io, and if-exists is neither
:overwrite nor:append ; ornilwhen direction is:probe .
external-format |an external le format designator . The default is :default .
stream |ale stream ornil.
Description:
open creates, opens, and returns a le stream that is connected to the le specied by lespec .
Filespec is the name of the le to be opened. If the lespec designator is astream , that stream is
not closed rst or otherwise aected.
The keyword arguments to open specify the characteristics of the le stream that is returned, and
how to handle errors.
Ifdirection is:input or:probe , or if if-exists is not:new-version and the version component of the
lespec is:newest , then the le opened is that le already existing in the le system that has a
version greater than that of any other le in the le system whose other pathname components are
the same as those of lespec .
An implementation is required to recognize all of the open keyword options and to do something
reasonable in the context of the host operating system. For example, if a le system does not
support distinct le versions and does not distinguish the notions of deletion and expunging,
:new-version might be treated the same as :rename or:supersede , and:rename-and-delete might
be treated the same as :supersede .
21–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
open
:direction
These are the possible values for direction , and how they aect the nature of the stream
that is created:
:input
Causes the creation of an input le stream .
:output
Causes the creation of an output le stream .
:io
Causes the creation of a bidirectional le stream .
:probe
Causes the creation of a \no-directional" le stream ; in eect, the le stream is
created and then closed prior to being returned by open .
:element-type
The element-type species the unit of transaction for the le stream . If it is :default , the
unit is determined by le system , possibly based on the le.
:if-exists
if-exists species the action to be taken if direction is:output or:ioand a le of the name
lespec already exists. If direction is:input , not supplied, or :probe ,if-exists is ignored.
These are the results of open as modied by if-exists :
:error
An error of typeﬁle-error is signaled.
:new-version
A new le is created with a larger version number.
:rename
The existing le is renamed to some other name and then a new le is created.
:rename-and-delete
The existing le is renamed to some other name, then it is deleted but not
expunged, and then a new le is created.
Streams 21–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
open
:overwrite
Output operations on the stream destructively modify the existing le. If direction
is:iothe le is opened in a bidirectional mode that allows both reading and
writing. The le pointer is initially positioned at the beginning of the le; however,
the le is not truncated back to length zero when it is opened.
:append
Output operations on the stream destructively modify the existing le. The le
pointer is initially positioned at the end of the le.
Ifdirection is:io, the le is opened in a bidirectional mode that allows both
reading and writing.
:supersede
The existing le is superseded; that is, a new le with the same name as the old
one is created. If possible, the implementation should not destroy the old le until
the new stream is closed.
nil
No le or stream is created; instead, nilis returned to indicate failure.
:if-does-not-exist
if-does-not-exist species the action to be taken if a le of name lespec does not already
exist. These are the results of open as modied by if-does-not-exist :
:error
An error of typeﬁle-error is signaled.
:create
An empty le is created. Processing continues as if the le had already existed but
no processing as directed by if-exists is performed.
nil
No le or stream is created; instead, nilis returned to indicate failure.
:external-format
This option selects an external le format for the le: The only standardized value for this
option is :default , although implementations are permitted to dene additional external
le formats and implementation-dependent values returned by stream-external-format
can also be used by conforming programs .
21–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
open
The external-format is meaningful for any kind of le stream whose element type is a
subtype ofcharacter . This option is ignored for streams for which it is not meaningful;
however, implementations may dene other element types for which it is meaningful. The
consequences are unspecied if a character is written that cannot be represented by the
given external le format .
When a le is opened, a le stream is constructed to serve as the le system's ambassador to the
Lisp environment; operations on the le stream are reected by operations on the le in the le
system.
A le can be deleted, renamed, or destructively modied by open .
For information about opening relative pathnames, see Section 19.2.3 (Merging Pathnames).
Examples:
(open lespec:direction :probe) !#<Closed Probe File Stream...>
(setq q (merge-pathnames (user-homedir-pathname) "test"))
!#<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
:NAME "test" :TYPE NIL :VERSION :NEWEST>
(open lespec:if-does-not-exist :create) !#<Input File Stream...>
(setq s (open lespec:direction :probe)) !#<Closed Probe File Stream...>
(truename s)!#<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY
directory-name :NAME lespec:TYPE extension :VERSION 1>
(open s :direction :output :if-exists nil) !NIL
Aﬀected By:
The nature and state of the host computer's le system .
Exceptional Situations:
Ifif-exists is:error , (subject to the constraints on the meaning of if-exists listed above), an error
oftypeﬁle-error is signaled.
Ifif-does-not-exist is:error (subject to the constraints on the meaning of if-does-not-exist listed
above), an error of typeﬁle-error is signaled.
If it is impossible for an implementation to handle some option in a manner close to what is
specied here, an error of typeerror might be signaled.
An error of typeﬁle-error is signaled if (wild-pathname-p lespec)returns true.
An error of typeerror is signaled if the external-format is not understood by the implementation .
The various le systems in existence today have widely diering capabilities, and some aspects of
thele system are beyond the scope of this specication to dene. A given implementation might
not be able to support all of these options in exactly the manner stated. An implementation is
required to recognize all of these option keywords and to try to do something \reasonable" in the
context of the host le system . Where necessary to accomodate the le system , an implementation
Streams 21–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
deviate slightly from the semantics specied here without being disqualied for consideration as
aconforming implementation . If it is utterly impossible for an implementation to handle some
option in a manner similar to what is specied here, it may simply signal an error.
With regard to the :element-type option, if a type is requested that is not supported by the le
system , a substitution of types such as that which goes on in upgrading is permissible. As a
minimum requirement, it should be the case that opening an output stream to a lein a given
element type and later opening an input stream to the same lein the same element type should
work compatibly.
See Also:
with-open-ﬁle ,close ,pathname ,logical-pathname , Section 19.2.3 (Merging Pathnames), Section
19.1.2 (Pathnames as Filenames)
Notes:
open does not automatically close the le when an abnormal exit occurs.
When element-type is a subtype ofcharacter ,read-char and/orwrite-char can be used on the
resulting le stream .
When element-type is a subtype ofinteger ,read-byte and/orwrite-byte can be used on the
resulting le stream .
When element-type is:default , the type can be determined by using stream-element-type .
stream-external-format Function
Syntax:
stream-external-format stream!format
Arguments and Values:
stream |ale stream .
format |an external le format .
Description:
Returns an external le format designator for the stream .
Examples:
(with-open-file (stream "test" :direction :output)
21–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(stream-external-format stream))
!:DEFAULTor!:ISO8859/1-1987or!(:ASCII :SAIL)or!ACME::PROPRIETARY-FILE-FORMAT-17or!#<FILE-FORMAT :ISO646-1983 2343673>
See Also:
the:external-format argument to the functionopen and thewith-open-ﬁle macro .
Notes:
The format returned is not necessarily meaningful to other implementations .
with-open-ﬁle macro
Syntax:
with-open-ﬁle (stream lespecfoptionsg*)fdeclarationg*fformg*
!results
Arguments and Values:
stream { a variable.
lespec |apathname designator .
options {forms ; evaluated.
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values returned by the forms .
Description:
with-open-ﬁle usesopen to create a le stream tolenamed by lespec .Filespec is the name of
the le to be opened. Options are used as keyword arguments to open .
The stream object to which the stream variable isbound hasdynamic extent ; its extent ends when
theform is exited.
with-open-ﬁle evaluates the forms as an implicit progn with stream bound to the value returned
byopen .
When control leaves the body, either normally or abnormally (such as by use of throw ), the le is
automatically closed. If a new output le is being written, and control leaves abnormally, the le
is aborted and the le system is left, so far as possible, as if the le had never been opened.
Streams 21–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-open-ﬁle
It is possible by the use of :if-exists nil or:if-does-not-exist nil forstream to be bound to
nil. Users of :if-does-not-exist nil should check for a valid stream .
The consequences are undened if an attempt is made to assign thestream variable . The compiler
may choose to issue a warning if such an attempt is detected.
Examples:
(setq p (merge-pathnames "test"))
!#<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
:NAME "test" :TYPE NIL :VERSION :NEWEST>
(with-open-file (s p :direction :output :if-exists :supersede)
(format s "Here are a couple~%of test data lines~%")) !NIL
(with-open-file (s p)
(do ((l (read-line s) (read-line s nil ’eof)))
((eq l ’eof) "Reached end of file.")
(format t "~&*** ~A~%" l)))
.*** Here are a couple
.*** of test data lines
!"Reached end of file."
;; Normally one would not do this intentionally because it is
;; not perspicuous, but beware when using :IF-DOES-NOT-EXIST NIL
;; that this doesn’t happen to you accidentally...
(with-open-file (foo "no-such-file" :if-does-not-exist nil)
(read foo))
.hello?
!HELLO? ;This value was read from the terminal, not a file!
;; Here’s another bug to avoid...
(with-open-file (foo "no-such-file" :direction :output :if-does-not-exist nil)
(format foo "Hello"))
!"Hello" ;FORMAT got an argument of NIL!
Side Eﬀects:
Creates a stream to the lenamed by lename (upon entry), and closes the stream (upon exit). In
some implementations , the lemight be locked in some way while it is open. If the stream is an
output stream , alemight be created.
Aﬀected By:
The host computer's le system.
Exceptional Situations:
See the functionopen .
21–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
open ,close ,pathname ,logical-pathname , Section 19.1.2 (Pathnames as Filenames)
close Function
Syntax:
close stream&key abort!result
Arguments and Values:
stream |astream (either open orclosed ).
abort |ageneralized boolean . The default is false.
result |tif the stream was open at the time it was received as an argument , orimplementation-
dependent otherwise.
Description:
close closes stream . Closing a stream means that it may no longer be used in input or output
operations. The act of closing ale stream ends the association between the stream and its
associated le; the transaction with the le system is terminated, and input/output may no longer
be performed on the stream .
Ifabort istrue, an attempt is made to clean up any side eects of having created stream . Ifstream
performs output to a le that was created when the stream was created, the le is deleted and any
previously existing le is not superseded.
It is permissible to close an already closed stream , but in that case the result isimplementation-
dependent .
After stream is closed, it is still possible to perform the following query operations upon
it:streamp ,pathname ,truename ,merge-pathnames ,pathname-host ,pathname-device ,
pathname-directory ,pathname-name ,pathname-type ,pathname-version ,namestring ,
ﬁle-namestring ,directory-namestring ,host-namestring ,enough-namestring ,open ,probe-ﬁle ,
anddirectory .
The eect of close on a constructed stream is to close the argument stream only. There is no eect
on the constituents ofcomposite streams .
For a stream created with make-string-output-stream , the result of get-output-stream-string is
unspecied after close .
Streams 21–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(setq s (make-broadcast-stream)) !#<BROADCAST-STREAM>
(close s)!T
(output-stream-p s) !true
Side Eﬀects:
The stream isclosed (if necessary). If abort istrue and the stream is an output le stream , its
associated lemight be deleted.
See Also:
open
with-open-stream Macro
Syntax:
with-open-stream (var stream )fdeclarationg*fformg*
!f resultg*
Arguments and Values:
var|avariable name .
stream |aform ; evaluated to produce a stream .
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |the values returned by the forms .
Description:
with-open-stream performs a series of operations on stream , returns a value, and then closes the
stream .
Varis bound to the value of stream , and then forms are executed as an implicit progn .stream
is automatically closed on exit from with-open-stream , no matter whether the exit is normal or
abnormal. The stream hasdynamic extent ; its extent ends when the form is exited.
The consequences are undened if an attempt is made to assign the the variable varwith the
forms .
Examples:
(with-open-stream (s (make-string-input-stream "1 2 3 4"))
(+ (read s) (read s) (read s))) !6
21–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Side Eﬀects:
The stream is closed (upon exit).
See Also:
close
listen Function
Syntax:
listen&optional input-stream!generalized-boolean
Arguments and Values:
input-stream |an input stream designator . The default is standard input .
generalized-boolean |ageneralized boolean .
Description:
Returns true if there is a character immediately available from input-stream ; otherwise, returns
false. On a non-interactive input-stream ,listen returns true except when at end of le 1. If an end
of le is encountered, listen returns false.listen is intended to be used when input-stream obtains
characters from an interactive device such as a keyboard.
Examples:
(progn (unread-char (read-char)) (list (listen) (read-char)))
.1
!(T #\1)
(progn (clear-input) (listen))
!NIL ;Unless you’re a very fast typist!
Aﬀected By:
*standard-input*
See Also:
interactive-stream-p ,read-char-no-hang
Streams 21–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
clear-input
clear-input Function
Syntax:
clear-input &optional input-stream!nil
Arguments and Values:
input-stream |an input stream designator . The default is standard input .
Description:
Clears any available input from input-stream .
Ifclear-input does not make sense for input-stream , thenclear-input does nothing.
Examples:
;; The exact I/O behavior of this example might vary from implementation
;; to implementation depending on the kind of interactive buffering that
;; occurs. (The call to SLEEP here is intended to help even out the
;; differences in implementations which do not do line-at-a-time buffering.)
(defun read-sleepily (&optional (clear-p nil) (zzz 0))
(list (progn (print ’>) (read))
;; Note that input typed within the first ZZZ seconds
;; will be discarded.
(progn (print ’>)
(if zzz (sleep zzz))
(print ’»)
(if clear-p (clear-input))
(read))))
(read-sleepily)
.> 10
.>
.» 20
!(10 20)
(read-sleepily t)
.> 10
.>
.» 20
!(10 20)
(read-sleepily t 10)
.> 10
.> 20; Some implementations won’t echo typeahead here.
21–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.» 30
!(10 30)
Side Eﬀects:
The input-stream is modied.
Aﬀected By:
*standard-input*
Exceptional Situations:
Should signal an error of typetype-error ifinput-stream is not a stream designator .
See Also:
clear-output
ﬁnish-output,force-output,clear-output Function
Syntax:
ﬁnish-output &optional output-stream!nil
force-output &optional output-stream!nil
clear-output &optional output-stream!nil
Arguments and Values:
output-stream |an output stream designator . The default is standard output .
Description:
ﬁnish-output ,force-output , andclear-output exercise control over the internal handling of
buered stream output.
ﬁnish-output attempts to ensure that any buered output sent to output-stream has reached its
destination, and then returns.
force-output initiates the emptying of any internal buers but does not wait for completion or
acknowledgment to return.
clear-output attempts to abort any outstanding output operation in progress in order to allow as
little output as possible to continue to the destination.
If any of these operations does not make sense for output-stream , then it does nothing. The precise
actions of these functions areimplementation-dependent .
Streams 21–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
;; Implementation A
(progn (princ "am i seen?") (clear-output))
!NIL
;; Implementation B
(progn (princ "am i seen?") (clear-output))
.am i seen?
!NIL
Aﬀected By:
*standard-output*
Exceptional Situations:
Should signal an error of typetype-error ifoutput-stream is not a stream designator .
See Also:
clear-input
y-or-n-p,yes-or-no-p Function
Syntax:
y-or-n-p &optional control&rest arguments!generalized-boolean
yes-or-no-p &optional control&rest arguments!generalized-boolean
Arguments and Values:
control |aformat control .
arguments |format arguments forcontrol .
generalized-boolean |ageneralized boolean .
Description:
These functions ask a question and parse a response from the user. They return true if the answer
is armative, or false if the answer is negative.
y-or-n-p is for asking the user a question whose answer is either \yes" or \no." It is intended that
the reply require the user to answer a yes-or-no question with a single character. yes-or-no-p is
also for asking the user a question whose answer is either \Yes" or \No." It is intended that the
reply require the user to take more action than just a single keystroke, such as typing the full word
yesornofollowed by a newline.
21–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
y-or-n-p types out a message (if supplied), reads an answer in some implementation-dependent
manner (intended to be short and simple, such as reading a single character such as YorN).
yes-or-no-p types out a message (if supplied), attracts the user's attention (for example, by ringing
the terminal's bell), and reads an answer in some implementation-dependent manner (intended to
be multiple characters, such as YESorNO).
Ifformat-control is supplied and not nil, then afresh-line operation is performed; then a message
is printed as if format-control and arguments were given to format . In any case, yes-or-no-p and
y-or-n-p will provide a prompt such as \ (Y or N) " or \(Yes or No) " if appropriate.
All input and output are performed using query I/O .
Examples:
(y-or-n-p "(t or nil) given by")
.(t or nil) given by (Y or N) Y
!true
(yes-or-no-p "a ~S message" ’frightening)
.a FRIGHTENING message (Yes or No) no
!false
(y-or-n-p "Produce listing file?")
.Produce listing file?
.Please respond with Y or N. n
!false
Side Eﬀects:
Output to and input from query I/O will occur.
Aﬀected By:
*query-io* .
See Also:
format
Notes:
yes-or-no-p andyes-or-no-p do not add question marks to the end of the prompt string, so any
desired question mark or other punctuation should be explicitly included in the text query.
Streams 21–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-synonym-stream Function
Syntax:
make-synonym-stream symbol!synonym-stream
Arguments and Values:
symbol |asymbol that names a dynamic variable .
synonym-stream |asynonym stream .
Description:
Returns a synonym stream whose synonym stream symbol issymbol .
Examples:
(setq a-stream (make-string-input-stream "a-stream")
b-stream (make-string-input-stream "b-stream"))
!#<String Input Stream>
(setq s-stream (make-synonym-stream ’c-stream))
!#<SYNONYM-STREAM for C-STREAM>
(setq c-stream a-stream)
!#<String Input Stream>
(read s-stream) !A-STREAM
(setq c-stream b-stream)
!#<String Input Stream>
(read s-stream) !B-STREAM
Exceptional Situations:
Should signal type-error if its argument is not a symbol .
See Also:
Section 21.1 (Stream Concepts)
synonym-stream-symbol Function
Syntax:
synonym-stream-symbol synonym-stream !symbol
Arguments and Values:
synonym-stream |asynonym stream .
symbol |asymbol .
21–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returns the symbol whosesymbol-value thesynonym-stream is using.
See Also:
make-synonym-stream
broadcast-stream-streams Function
Syntax:
broadcast-stream-streams broadcast-stream !streams
Arguments and Values:
broadcast-stream |abroadcast stream .
streams |alistofstreams .
Description:
Returns a listof output streams that constitute all the streams to which the broadcast-stream is
broadcasting.
make-broadcast-stream Function
Syntax:
make-broadcast-stream &rest streams!broadcast-stream
Arguments and Values:
stream |an output stream .
broadcast-stream |abroadcast stream .
Description:
Returns a broadcast stream .
Examples:
(setq a-stream (make-string-output-stream)
b-stream (make-string-output-stream)) !#<String Output Stream>
(format (make-broadcast-stream a-stream b-stream)
"this will go to both streams") !NIL
(get-output-stream-string a-stream) !"this will go to both streams"
Streams 21–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(get-output-stream-string b-stream) !"this will go to both streams"
Exceptional Situations:
Should signal an error of typetype-error if any stream is not an output stream .
See Also:
broadcast-stream-streams
make-two-way-stream Function
Syntax:
make-two-way-stream input-stream output-stream !two-way-stream
Arguments and Values:
input-stream |astream .
output-stream |astream .
two-way-stream |atwo-way stream .
Description:
Returns a two-way stream that gets its input from input-stream and sends its output to
output-stream .
Examples:
(with-output-to-string (out)
(with-input-from-string (in "input...")
(let ((two (make-two-way-stream in out)))
(format two "output...")
(setq what-is-read (read two))))) !"output..."
what-is-read!INPUT...
Exceptional Situations:
Should signal an error of typetype-error ifinput-stream is not an input stream . Should signal an
error of typetype-error ifoutput-stream is not an output stream .
21–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
two-way-stream-input-stream,two-way-stream-
output-stream Function
Syntax:
two-way-stream-input-stream two-way-stream !input-stream
two-way-stream-output-stream two-way-stream !output-stream
Arguments and Values:
two-way-stream |atwo-way stream .
input-stream |an input stream .
output-stream |an output stream .
Description:
two-way-stream-input-stream returns the stream from which two-way-stream receives input.
two-way-stream-output-stream returns the stream to which two-way-stream sends output.
echo-stream-input-stream,echo-stream-output-
stream Function
Syntax:
echo-stream-input-stream echo-stream!input-stream
echo-stream-output-stream echo-stream!output-stream
Arguments and Values:
echo-stream |an echo stream .
input-stream |an input stream .
output-stream |an output stream .
Description:
echo-stream-input-stream returns the input stream from which echo-stream receives input.
echo-stream-output-stream returns the output stream to which echo-stream sends output.
Streams 21–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-echo-stream Function
Syntax:
make-echo-stream input-stream output-stream !echo-stream
Arguments and Values:
input-stream |an input stream .
output-stream |an output stream .
echo-stream |an echo stream .
Description:
Creates and returns an echo stream that takes input from input-stream and sends output to
output-stream .
Examples:
(let ((out (make-string-output-stream)))
(with-open-stream
(s (make-echo-stream
(make-string-input-stream "this-is-read-and-echoed")
out))
(read s)
(format s " * this-is-direct-output")
(get-output-stream-string out)))
!"this-is-read-and-echoed * this-is-direct-output"
See Also:
echo-stream-input-stream ,echo-stream-output-stream ,make-two-way-stream
concatenated-stream-streams Function
Syntax:
concatenated-stream-streams concatenated-stream !streams
Arguments and Values:
concatenated-stream { aconcatenated stream .
streams |alistofinput streams .
21–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returns a listofinput streams that constitute the ordered set of streams theconcatenated-stream
still has to read from, starting with the current one it is reading from. The list may be empty if no
more streams remain to be read.
The consequences are undened if the list structure of the streams is ever modied.
make-concatenated-stream Function
Syntax:
make-concatenated-stream &rest input-streams!concatenated-stream
Arguments and Values:
input-stream |an input stream .
concatenated-stream |aconcatenated stream .
Description:
Returns a concatenated stream that has the indicated input-streams initially associated with it.
Examples:
(read (make-concatenated-stream
(make-string-input-stream "1")
(make-string-input-stream "2"))) !12
Exceptional Situations:
Should signal type-error if any argument is not an input stream .
See Also:
concatenated-stream-streams
Streams 21–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
get-output-stream-string Function
Syntax:
get-output-stream-string string-output-stream !string
Arguments and Values:
string-output-stream |astream .
string |astring .
Description:
Returns a string containing, in order, all the characters that have been output to string-output-
stream . This operation clears any characters onstring-output-stream , so the string contains only
those characters which have been output since the last call to get-output-stream-string or since
the creation of the string-output-stream , whichever occurred most recently.
Examples:
(setq a-stream (make-string-output-stream)
a-string "abcdefghijklm") !"abcdefghijklm"
(write-string a-string a-stream) !"abcdefghijklm"
(get-output-stream-string a-stream) !"abcdefghijklm"
(get-output-stream-string a-stream) !""
Side Eﬀects:
The string-output-stream is cleared.
Exceptional Situations:
The consequences are undened if stream-output-string isclosed .
The consequences are undened if string-output-stream is a stream that was not produced by
make-string-output-stream . The consequences are undened if string-output-stream was created
implicitly by with-output-to-string orformat .
See Also:
make-string-output-stream
21–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
make-string-input-stream Function
Syntax:
make-string-input-stream string&optional start end!string-stream
Arguments and Values:
string |astring .
start,end|bounding index designators ofstring . The defaults for start and endare0andnil,
respectively.
string-stream |an input string stream .
Description:
Returns an input string stream . This stream will supply, in order, the characters in the substring
ofstring bounded bystart and end. After the last character has been supplied, the string stream
will then be at end of le .
Examples:
(let ((string-stream (make-string-input-stream "1 one ")))
(list (read string-stream nil nil)
(read string-stream nil nil)
(read string-stream nil nil)))
!(1 ONE NIL)
(read (make-string-input-stream "prefixtargetsuffix" 6 12)) !TARGET
See Also:
with-input-from-string
make-string-output-stream Function
Syntax:
make-string-output-stream &key element-type!string-stream
Arguments and Values:
element-type |atype specier . The default is character .
string-stream |an output string stream .
Streams 21–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Returns an output string stream that accepts characters and makes available (via
get-output-stream-string ) astring that contains the characters that were actually output.
The element-type names the type of the elements of the string ; astring is constructed of the most
specialized type that can accommodate elements of that element-type .
Examples:
(let ((s (make-string-output-stream)))
(write-string "testing... " s)
(prin1 1234 s)
(get-output-stream-string s))
!"testing... 1234"
None..
See Also:
get-output-stream-string ,with-output-to-string
with-input-from-string Macro
Syntax:
with-input-from-string (var string &key index start end )fdeclarationg*fformg*
!f resultg*
Arguments and Values:
var|avariable name .
string |aform ; evaluated to produce a string .
index |aplace .
start,end|bounding index designators ofstring . The defaults for start and endare0andnil,
respectively.
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
result |the values returned by the forms .
Description:
Creates an input string stream , provides an opportunity to perform operations on the stream
(returning zero or more values ), and then closes the string stream .
21–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
String is evaluated rst, and varis bound to a character input string stream that supplies characters
from the subsequence of the resulting string bounded bystart and end. The body is executed as an
implicit progn .
The input string stream is automatically closed on exit from with-input-from-string , no matter
whether the exit is normal or abnormal. The input string stream to which the variable varisbound
hasdynamic extent ; its extent ends when the form is exited.
The index is a pointer within the string to be advanced. If with-input-from-string is exited
normally, then index will have as its value the index into the string indicating the rst character
not read which is (length string)if all characters were used. The place specied by index is not
updated as reading progresses, but only at the end of the operation.
start and index may both specify the same variable, which is a pointer within the string to be
advanced, perhaps repeatedly by some containing loop.
The consequences are undened if an attempt is made to assign thevariable var.
Examples:
(with-input-from-string (s "XXX1 2 3 4xxx"
:index ind
:start 3 :end 10)
(+ (read s) (read s) (read s))) !6
ind!9
(with-input-from-string (s "Animal Crackers" :index j :start 6)
(read s))!CRACKERS
The variable jis set to 15.
Side Eﬀects:
The value of the place named by index , if any, is modied.
See Also:
make-string-input-stream , Section 3.6 (Traversal Rules and Side Eects)
with-output-to-string Macro
Syntax:
with-output-to-string (var&optional string-form &key element-type )fdeclarationg*fformg*
!f resultg*
Arguments and Values:
var|avariable name .
Streams 21–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
with-output-to-string
string-form |aform ornil; ifnon-nil , evaluated to produce string .
string |astring that has a ll pointer .
element-type |atype specier ; evaluated. The default is character .
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
results |If a string-form is not supplied or nil, astring ; otherwise, the values returned by the forms .
Description:
with-output-to-string creates a character output stream , performs a series of operations that may
send results to this stream , and then closes the stream .
The element-type names the type of the elements of the stream ; astream is constructed of the most
specialized type that can accommodate elements of the given type.
The body is executed as an implicit progn with varbound to an output string stream . All output
to that string stream is saved in a string .
Ifstring is supplied, element-type is ignored, and the output is incrementally appended to string as
if by use of vector-push-extend .
The output stream is automatically closed on exit from with-output-from-string , no matter
whether the exit is normal or abnormal. The output string stream to which the variable varis
bound hasdynamic extent ; its extent ends when the form is exited.
If no string is provided, then with-output-from-string produces a stream that accepts characters
and returns a string of the indicated element-type . If string is provided, with-output-to-string
returns the results of evaluating the last form.
The consequences are undened if an attempt is made to assign thevariable var.
Examples:
(setq fstr (make-array ’(0) :element-type ’base-char
:fill-pointer 0 :adjustable t)) !""
(with-output-to-string (s fstr)
(format s "here’s some output")
(input-stream-p s)) !false
fstr!"here’s some output"
Side Eﬀects:
The string is modied.
Exceptional Situations:
21–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The consequences are undened if destructive modications are performed directly on the string
during the dynamic extent of the call.
See Also:
make-string-output-stream ,vector-push-extend , Section 3.6 (Traversal Rules and Side Eects)
debug-io,error-output,query-io,standard-
input,standard-output ,trace-output Variable
Value Type:
For*standard-input* : an input stream
For*error-output* ,*standard-output* , and*trace-output* : an output stream .
For*debug-io* ,*query-io* : abidirectional stream .
Initial Value:
implementation-dependent , but it must be an open stream that is not a generalized synonym stream
to an I/O customization variables but that might be a generalized synonym stream to the value of
some I/O customization variable . The initial value might also be a generalized synonym stream to
either the symbol*terminal-io* or to the stream that is its value .
Description:
These variables are collectively called the standardized I/O customization variables . They can be
bound orassigned in order to change the default destinations for input and/or output used by
various standardized operators and facilities.
The value of*debug-io* , called debug I/O , is a stream to be used for interactive debugging
purposes.
The value of*error-output* , called error output , is a stream to which warnings and non-interactive
error messages should be sent.
The value of*query-io* , called query I/O , is a bidirectional stream to be used when asking
questions of the user. The question should be output to this stream , and the answer read from it.
The value of*standard-input* , called standard input , is a stream that is used by many operators
as a default source of input when no specic input stream is explicitly supplied.
The value of*standard-output* , called standard output , is a stream that is used by many
operators as a default destination for output when no specic output stream is explicitly supplied.
The value of*trace-output* , called trace output , is the stream on which traced functions (see
trace ) and the time macro print their output.
Streams 21–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
debug-io,error-output,query-io,:::
Examples:
(with-output-to-string (*error-output*)
(warn "this string is sent to *error-output*"))
!"Warning: this string is sent to *error-output*
" ;The exact format of this string is implementation-dependent .
(with-input-from-string (*standard-input* "1001")
(+ 990 (read))) !1991
(progn (setq out (with-output-to-string (*standard-output*)
(print "print and format t send things to")
(format t "*standard-output* now going to a string")))
:done)
!:DONE
out
!"
\"print and format t send things to\" *standard-output* now going to a string"
(defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))
!FACT
(trace fact)
!(FACT)
;; Of course, the format of traced output is implementation-dependent.
(with-output-to-string (*trace-output*)
(fact 3))
!"
1 Enter FACT 3
| 2 Enter FACT 2
| 3 Enter FACT 1
| 3 Exit FACT 1
| 2 Exit FACT 2
1 Exit FACT 6"
See Also:
*terminal-io* ,synonym-stream ,time ,trace , Chapter 9 (Conditions), Chapter 23 (Reader),
Chapter 22 (Printer)
Notes:
The intent of the constraints on the initial value of the I/O customization variables is to ensure
that it is always safe to bind orassign such a variable to the value of another I/O customization
21–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
variable , without unduly restricting implementation exibility.
It is common for an implementation to make the initial values of*debug-io* and*query-io* be
thesame stream , and to make the initial values of*error-output* and*standard-output* be the
same stream .
The functions y-or-n-p andyes-or-no-p usequery I/O for their input and output.
In the normal Lisp read-eval-print loop , input is read from standard input . Many input functions,
including read andread-char , take a stream argument that defaults to standard input .
In the normal Lisp read-eval-print loop , output is sent to standard output . Many output functions,
including print andwrite-char , take a stream argument that defaults to standard output .
A program that wants, for example, to divert output to a le should do so by binding
*standard-output* ; that way error messages sent to *error-output* can still get to the user by
going through *terminal-io* (if*error-output* is bound to *terminal-io* ), which is usually what
is desired.
terminal-io Variable
Value Type:
abidirectional stream .
Initial Value:
implementation-dependent , but it must be an open stream that is not a generalized synonym stream
to an I/O customization variables but that might be a generalized synonym stream to the value of
some I/O customization variable .
Description:
The value of*terminal-io* , called terminal I/O , is ordinarily a bidirectional stream that connects
to the user's console. Typically, writing to this stream would cause the output to appear on a
display screen, for example, and reading from the stream would accept input from a keyboard.
It is intended that standard input functions such as read andread-char , when used with this
stream , cause echoing of the input into the output side of the stream . The means by which this is
accomplished are implementation-dependent .
The eect of changing the value of*terminal-io* , either by binding orassignment , is
implementation-dened .
Examples:
(progn (prin1 ’foo) (prin1 ’bar *terminal-io*))
Streams 21–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.FOOBAR
!BAR
(with-output-to-string (*standard-output*)
(prin1 ’foo)
(prin1 ’bar *terminal-io*))
.BAR
!"FOO"
See Also:
*debug-io* ,*error-output* ,*query-io* ,*standard-input* ,*standard-output* ,*trace-output*
stream-error Condition Type
Class Precedence List:
stream-error ,error ,serious-condition ,condition ,t
Description:
The typestream-error consists of error conditions that are related to receiving input from or
sending output to a stream . The \oending stream" is initialized by the :stream initialization
argument to make-condition , and is accessed by the functionstream-error-stream .
See Also:
stream-error-stream
stream-error-stream Function
Syntax:
stream-error-stream condition!stream
Arguments and Values:
condition |acondition oftypestream-error .
stream |astream .
Description:
Returns the oending stream of a condition oftypestream-error .
Examples:
(with-input-from-string (s "(FOO")
(handler-case (read s)
21–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(end-of-file (c)
(format nil "~&End of file on ~S." (stream-error-stream c)))))
"End of file on #<String Stream>."
See Also:
stream-error , Chapter 9 (Conditions)
end-of-ﬁle Condition Type
Class Precedence List:
end-of-ﬁle ,stream-error ,error ,serious-condition ,condition ,t
Description:
The typeend-of-ﬁle consists of error conditions related to read operations that are done on streams
that have no more data.
See Also:
stream-error-stream
Streams 21–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
21–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
22. Printer
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Printeriii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.1 The Lisp Printer
22.1.1 Overview of The Lisp Printer
Common Lisp provides a representation of most objects in the form of printed text called the
printed representation. Functions such as print take an object and send the characters of its printed
representation to a stream . The collection of routines that does this is known as the (Common
Lisp) printer.
Reading a printed representation typically produces an object that isequal to the originally printed
object .
22.1.1.1 Multiple Possible Textual Representations
Most objects have more than one possible textual representation. For example, the positive integer
with a magnitude of twenty-seven can be textually expressed in any of these ways:
27 27. #o33 #x1B #b11011 #.(* 3 3 3) 81/3
A list containing the two symbols AandBcan also be textually expressed in a variety of ways:
(A B) (a b) ( a b ) (\A |B|)
(|\A|
B
)
In general, from the point of view of the Lisp reader , wherever whitespace is permissible in a
textual representation, any number of spaces and newlines can appear in standard syntax .
When a function such as print produces a printed representation, it must choose from among many
possible textual representations. In most cases, it chooses a program readable representation, but
in certain cases it might use a more compact notation that is not program-readable.
A number of option variables, called printer control variables , are provided to permit control
of individual aspects of the printed representation of objects . Figure 22{1 shows the standardized
printer control variables ; there might also be implementation-dened printer control variables .
*print-array* *print-gensym* *print-pprint-dispatch*
*print-base* *print-length* *print-pretty*
*print-case* *print-level* *print-radix*
*print-circle* *print-lines* *print-readably*
*print-escape* *print-miser-width* *print-right-margin*
Figure 22–1. Standardized Printer Control Variables
Printer22–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
In addition to the printer control variables , the following additional dened names relate to or
aect the behavior of the Lisp printer :
*package* *read-eval* readtable-case
*read-default-ﬂoat-format* *readtable*
Figure 22–2. Additional Inﬂuences on the Lisp printer.
22.1.1.1.1 Printer Escaping
The variable*print-escape* controls whether the Lisp printer tries to produce notations such as
escape characters and package prexes.
The variable*print-readably* can be used to override many of the individual aspects controlled
by the other printer control variables when program-readable output is especially important.
One of the many eects of making the value of*print-readably* betrue is that the Lisp printer
behaves as if *print-escape* were also true. For notational convenience, we say that if the value of
either*print-readably* or*print-escape* istrue, then printer escaping is \enabled"; and we
say that if the values of both *print-readably* and*print-escape* arefalse, then printer escaping
is \disabled".
22.1.2 Printer Dispatching
The Lisp printer makes its determination of how to print an object as follows:
If the value of*print-pretty* istrue, printing is controlled by the current pprint dispatch table ;
see Section 22.2.1.4 (Pretty Print Dispatch Tables).
Otherwise (if the value of*print-pretty* isfalse), the object's print-object method is used; see
Section 22.1.3 (Default Print-Object Methods).
22.1.3 Default Print-Object Methods
This section describes the default behavior of print-object methods for the standardized types .
22.1.3.1 Printing Numbers
22–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.1.3.1.1 Printing Integers
Integers are printed in the radix specied by the current output base in positional notation, most
signicant digit rst. If appropriate, a radix specier can be printed; see *print-radix* . If an
integer is negative, a minus sign is printed and then the absolute value of the integer is printed.
The integer zero is represented by the single digit 0and never has a sign. A decimal point might
be printed, depending on the value of*print-radix* .
For related information about the syntax of an integer , see Section 2.3.2.1.1 (Syntax of an Integer).
22.1.3.1.2 Printing Ratios
Ratios are printed as follows: the absolute value of the numerator is printed, as for an integer ; then
a/; then the denominator. The numerator and denominator are both printed in the radix specied
by the current output base ; they are obtained as if by numerator anddenominator , and so ratios
are printed in reduced form (lowest terms). If appropriate, a radix specier can be printed; see
*print-radix* . If the ratio is negative, a minus sign is printed before the numerator.
For related information about the syntax of a ratio , see Section 2.3.2.1.2 (Syntax of a Ratio).
22.1.3.1.3 Printing Floats
If the magnitude of the oat is either zero or between 10 3(inclusive) and 107(exclusive), it is
printed as the integer part of the number, then a decimal point, followed by the fractional part of
the number; there is always at least one digit on each side of the decimal point. If the sign of the
number (as determined by ﬂoat-sign ) is negative, then a minus sign is printed before the number.
If the format of the number does not match that specied by *read-default-ﬂoat-format* , then
theexponent marker for that format and the digit 0are also printed. For example, the base of the
natural logarithms as a short oat might be printed as 2.71828S0 .
For non-zero magnitudes outside of the range 10 3to107, aoat is printed in computerized
scientic notation. The representation of the number is scaled to be between 1 (inclusive) and 10
(exclusive) and then printed, with one digit before the decimal point and at least one digit after
the decimal point. Next the exponent marker for the format is printed, except that if the format
of the number matches that specied by *read-default-ﬂoat-format* , then the exponent marker
Eis used. Finally, the power of ten by which the fraction must be multiplied to equal the original
number is printed as a decimal integer. For example, Avogadro's number as a short oat is printed
as6.02S23 .
For related information about the syntax of a oat, see Section 2.3.2.2 (Syntax of a Float).
22.1.3.1.4 Printing Complexes
Acomplex is printed as #C, an open parenthesis, the printed representation of its real part, a space,
the printed representation of its imaginary part, and nally a close parenthesis.
For related information about the syntax of a complex , see Section 2.3.2.3 (Syntax of a Complex)
and Section 2.4.8.11 (Sharpsign C).
Printer22–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.1.3.1.5 Note about Printing Numbers
The printed representation of a number must not contain escape characters ; see Section 2.3.1.1.1
(Escape Characters and Potential Numbers).
22.1.3.2 Printing Characters
When printer escaping is disabled, a character prints as itself; it is sent directly to the output
stream . When printer escaping is enabled, then #\syntax is used.
When the printer types out the name of a character , it uses the same table as the #\reader
macro would use; therefore any character name that is typed out is acceptable as input (in that
implementation ). If a non-graphic character has a standardized name 5, that name is preferred
over non-standard names for printing in #\notation. For the graphic standard characters , the
character itself is always used for printing in #\notation|even if the character also has a name 5.
For details about the #\reader macro , see Section 2.4.8.1 (Sharpsign Backslash).
22.1.3.3 Printing Symbols
When printer escaping is disabled, only the characters of the symbol 'sname are output (but the
case in which to print characters in the name is controlled by *print-case* ; see Section 22.1.3.3.2
(Eect of Readtable Case on the Lisp Printer)).
The remainder of this section applies only when printer escaping is enabled.
When printing a symbol , the printer inserts enough single escape and/or multiple escape characters
(backslashes and/or vertical-bars ) so that if read were called with the same *readtable* and
with*read-base* bound to the current output base , it would return the same symbol (if it is not
apparently uninterned ) or an uninterned symbol with the same print name (otherwise).
For example, if the value of*print-base* were16when printing the symbol face, it would have to
be printed as \FACE or\Face or|FACE| , because the token face would be read as a hexadecimal
number (decimal value 64206) if the value of*read-base* were16.
For additional restrictions concerning characters with nonstandard syntax types in the current
readtable , see the variable*print-readably*
For information about how the Lisp reader parses symbols , see Section 2.3.4 (Symbols as Tokens)
and Section 2.4.8.5 (Sharpsign Colon).
nilmight be printed as ()when*print-pretty* istrue and printer escaping is enabled.
22–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.1.3.3.1 Package Preﬁxes for Symbols
Package prexes are printed if necessary. The rules for package prexes are as follows. When the
symbol is printed, if it is in the KEYWORD package , then it is printed with a preceding colon ; otherwise,
if it is accessible in the current package , it is printed without any package prex ; otherwise, it is
printed with a package prex .
Asymbol that is apparently uninterned is printed preceded by \ #:" if*print-gensym* istrue and
printer escaping is enabled; if *print-gensym* isfalse orprinter escaping is disabled, then the
symbol is printed without a prex, as if it were in the current package .
Because the #:syntax does not intern the following symbol, it is necessary to use circular-list
syntax if *print-circle* istrue and the same uninterned symbol appears several times in an
expression to be printed. For example, the result of
(let ((x (make-symbol "FOO"))) (list x x))
would be printed as (#:foo #:foo) if*print-circle* were false, but as (#1=#:foo #1#) if
*print-circle* were true.
A summary of the preceding package prex rules follows:
foo:bar
foo:bar is printed when symbolbaris external in its home package fooand is not accessible
in the current package .
foo::bar
foo::bar is printed when baris internal in its home package fooand is not accessible in
thecurrent package .
:bar
:bar is printed when the home package of baris theKEYWORD package .
#:bar
#:bar is printed when barisapparently uninterned , even in the pathological case that bar
has no home package but is nevertheless somehow accessible in the current package .
22.1.3.3.2 Eﬀect of Readtable Case on the Lisp Printer
When printer escaping is disabled, or the characters under consideration are not already quoted
specically by single escape ormultiple escape syntax, the readtable case of the current readtable
aects the way the Lisp printer writes symbols in the following ways:
:upcase
When the readtable case is:upcase ,uppercase characters are printed in the case specied
by*print-case* , and lowercase characters are printed in their own case.
Printer22–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
:downcase
When the readtable case is:downcase ,uppercase characters are printed in their own case,
and lowercase characters are printed in the case specied by *print-case* .
:preserve
When the readtable case is:preserve , all alphabetic characters are printed in their own
case.
:invert
When the readtable case is:invert , the case of all alphabetic characters in single case
symbol names is inverted. Mixed-case symbol names are printed as is.
The rules for escaping alphabetic characters in symbol names are aected by the readtable-case if
printer escaping is enabled. Alphabetic characters are escaped as follows:
:upcase
When the readtable case is:upcase , all lowercase characters must be escaped.
:downcase
When the readtable case is:downcase , all uppercase characters must be escaped.
:preserve
When the readtable case is:preserve , no alphabetic characters need be escaped.
:invert
When the readtable case is:invert , no alphabetic characters need be escaped.
22.1.3.3.2.1 Examples of Eﬀect of Readtable Case on the Lisp Printer
(defun test-readtable-case-printing ()
(let ((*readtable* (copy-readtable nil))
(*print-case* *print-case*))
(format t "READTABLE-CASE *PRINT-CASE* Symbol-name Output~
~%–––––––––––––––––––––––––~
~%")
(dolist (readtable-case ’(:upcase :downcase :preserve :invert))
(setf (readtable-case *readtable*) readtable-case)
(dolist (print-case ’(:upcase :downcase :capitalize))
(dolist (symbol ’(|ZEBRA| |Zebra| |zebra|))
(setq *print-case* print-case)
(format t "~&:~A~15T:~A~29T~A~42T~A"
22–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(string-upcase readtable-case)
(string-upcase print-case)
(symbol-name symbol)
(prin1-to-string symbol)))))))
The output from (test-readtable-case-printing) should be as follows:
READTABLE-CASE *PRINT-CASE* Symbol-name Output
–––––––––––––––––––––––––
:UPCASE :UPCASE ZEBRA ZEBRA
:UPCASE :UPCASE Zebra |Zebra|
:UPCASE :UPCASE zebra |zebra|
:UPCASE :DOWNCASE ZEBRA zebra
:UPCASE :DOWNCASE Zebra |Zebra|
:UPCASE :DOWNCASE zebra |zebra|
:UPCASE :CAPITALIZE ZEBRA Zebra
:UPCASE :CAPITALIZE Zebra |Zebra|
:UPCASE :CAPITALIZE zebra |zebra|
:DOWNCASE :UPCASE ZEBRA |ZEBRA|
:DOWNCASE :UPCASE Zebra |Zebra|
:DOWNCASE :UPCASE zebra ZEBRA
:DOWNCASE :DOWNCASE ZEBRA |ZEBRA|
:DOWNCASE :DOWNCASE Zebra |Zebra|
:DOWNCASE :DOWNCASE zebra zebra
:DOWNCASE :CAPITALIZE ZEBRA |ZEBRA|
:DOWNCASE :CAPITALIZE Zebra |Zebra|
:DOWNCASE :CAPITALIZE zebra Zebra
:PRESERVE :UPCASE ZEBRA ZEBRA
:PRESERVE :UPCASE Zebra Zebra
:PRESERVE :UPCASE zebra zebra
:PRESERVE :DOWNCASE ZEBRA ZEBRA
:PRESERVE :DOWNCASE Zebra Zebra
:PRESERVE :DOWNCASE zebra zebra
:PRESERVE :CAPITALIZE ZEBRA ZEBRA
:PRESERVE :CAPITALIZE Zebra Zebra
:PRESERVE :CAPITALIZE zebra zebra
:INVERT :UPCASE ZEBRA zebra
:INVERT :UPCASE Zebra Zebra
:INVERT :UPCASE zebra ZEBRA
:INVERT :DOWNCASE ZEBRA zebra
:INVERT :DOWNCASE Zebra Zebra
:INVERT :DOWNCASE zebra ZEBRA
:INVERT :CAPITALIZE ZEBRA zebra
:INVERT :CAPITALIZE Zebra Zebra
:INVERT :CAPITALIZE zebra ZEBRA
Printer22–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.1.3.4 Printing Strings
The characters of the string are output in order. If printer escaping is enabled, a double-quote is
output before and after, and all double-quotes and single escapes are preceded by backslash . The
printing of strings is not aected by *print-array* . Only the active elements of the string are
printed.
For information on how the Lisp reader parses strings , see Section 2.4.5 (Double-Quote).
22.1.3.5 Printing Lists and Conses
Wherever possible, list notation is preferred over dot notation. Therefore the following algorithm
is used to print a consx:
1. A left-parenthesis is printed.
2. The carofxis printed.
3. If the cdrofxis itself a cons, it is made to be the current cons (i.e.,xbecomes that cons), a
space is printed, and step 2 is re-entered.
4. If the cdrofxis not null, aspace , adot, aspace , and the cdrofxare printed.
5. A right-parenthesis is printed.
Actually, the above algorithm is only used when *print-pretty* isfalse. When*print-pretty* is
true (or when pprint is used), additional whitespace 1may replace the use of a single space , and a
more elaborate algorithm with similar goals but more presentational exibility is used; see Section
22.1.2 (Printer Dispatching).
Although the two expressions below are equivalent, and the reader accepts either one and produces
the same cons, the printer always prints such a cons in the second form.
(a . (b . ((c . (d . nil)) . (e . nil))))
(a b (c d) e)
The printing of conses is aected by *print-level* ,*print-length* , and*print-circle* .
Following are examples of printed representations of lists:
(a . b) ;A dotted pair of a and b
(a.b) ;A list of one element, the symbol named a.b
(a. b) ;A list of two elements a. and b
(a .b) ;A list of two elements a and .b
22–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(a b . c) ;A dotted list of a and b with c at the end; two conses
.iot ;The symbol whose name is .iot
(. b) ;Invalid – an error is signaled if an attempt is made to read
;this syntax.
(a .) ;Invalid – an error is signaled.
(a .. b) ;Invalid – an error is signaled.
(a . . b) ;Invalid – an error is signaled.
(a b c ...) ;Invalid – an error is signaled.
(a \. b) ;A list of three elements a, ., and b
(a |.| b) ;A list of three elements a, ., and b
(a \... b) ;A list of three elements a, ..., and b
(a |...| b) ;A list of three elements a, ..., and b
For information on how the Lisp reader parses listsandconses , see Section 2.4.1 (Left-Parenthesis).
22.1.3.6 Printing Bit Vectors
Abit vector is printed as #*followed by the bits of the bit vector in order. If *print-array* is
false, then the bit vector is printed in a format (using #<) that is concise but not readable. Only
theactive elements of the bit vector are printed.
For information on Lisp reader parsing of bit vectors , see Section 2.4.8.4 (Sharpsign Asterisk).
22.1.3.7 Printing Other Vectors
If*print-array* istrue and*print-readably* isfalse, any vector other than a string orbit
vector is printed using general-vector syntax; this means that information about specialized vector
representations does not appear. The printed representation of a zero-length vector is#(). The
printed representation of a non-zero-length vector begins with #(. Following that, the rst element
of the vector is printed. If there are any other elements, they are printed in turn, with each such
additional element preceded by a space if*print-pretty* isfalse, orwhitespace 1if*print-pretty*
istrue. A right-parenthesis after the last element terminates the printed representation of the
vector . The printing of vectors is aected by *print-level* and*print-length* . If the vector has a
ll pointer , then only those elements below the ll pointer are printed.
If both*print-array* and*print-readably* arefalse, the vector is not printed as described above,
but in a format (using #<) that is concise but not readable.
If*print-readably* istrue, the vector prints in an implementation-dened manner; see the variable
*print-readably* .
For information on how the Lisp reader parses these \other vectors ," see Section 2.4.8.3 (Sharpsign
Left-Parenthesis).
Printer22–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.1.3.8 Printing Other Arrays
If*print-array* istrue and*print-readably* isfalse, any array other than a vector is printed
using#nAformat. Let nbe the rank of the array . Then#is printed, then nas a decimal integer,
thenA, thennopen parentheses. Next the elements are scanned in row-major order, using write on
each element , and separating elements from each other with whitespace 1. The array's dimensions
are numbered 0 to n-1 from left to right, and are enumerated with the rightmost index changing
fastest. Every time the index for dimension jis incremented, the following actions are taken:
Ifj<n-1, then a close parenthesis is printed.
If incrementing the index for dimension jcaused it to equal dimension j, that index is
reset to zero and the index for dimension j-1 is incremented (thereby performing these
three steps recursively), unless j=0, in which case the entire algorithm is terminated. If
incrementing the index for dimension jdid not cause it to equal dimension j, then a space
is printed.
Ifj<n-1, then an open parenthesis is printed.
This causes the contents to be printed in a format suitable for :initial-contents tomake-array .
The lists eectively printed by this procedure are subject to truncation by *print-level* and
*print-length* .
If the array is of a specialized type, containing bits or characters, then the innermost lists generated
by the algorithm given above can instead be printed using bit-vector or string syntax, provided
that these innermost lists would not be subject to truncation by *print-length* .
If both*print-array* and*print-readably* arefalse, then the array is printed in a format (using
#<) that is concise but not readable.
If*print-readably* istrue, the array prints in an implementation-dened manner; see the variable
*print-readably* . In particular, this may be important for arrays having some dimension 0.
For information on how the Lisp reader parses these \other arrays ," see Section 2.4.8.12 (Sharpsign
A).
22.1.3.9 Examples of Printing Arrays
(let ((a (make-array ’(3 3)))
(*print-pretty* t)
(*print-array* t))
(dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j))))
(print a)
(print (make-array 9 :displaced-to a)))
.#2A(("<0,0>" "<0,1>" "<0,2>")
.("<1,0>" "<1,1>" "<1,2>")
22–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.("<2,0>" "<2,1>" "<2,2>"))
.#("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>")
!#<ARRAY 9 indirect 36363476>
22.1.3.10 Printing Random States
A specic syntax for printing objects oftyperandom-state is not specied. However, every
implementation must arrange to print a random state object in such a way that, within the same
implementation, read can construct from the printed representation a copy of the random state
object as if the copy had been made by make-random-state .
If the type random state is eectively implemented by using the machinery for defstruct , the usual
structure syntax can then be used for printing random state objects; one might look something like
#S(RANDOM-STATE :DATA #(14 49 98436589 786345 8734658324 ... ))
where the components are implementation-dependent .
22.1.3.11 Printing Pathnames
When printer escaping is enabled, the syntax #P"..." is how a pathname is printed by write and
the other functions herein described. The "..." is the namestring representation of the pathname.
When printer escaping is disabled, write writes a pathname P by writing (namestring P)instead.
For information on how the Lisp reader parses pathnames , see Section 2.4.8.14 (Sharpsign P).
22.1.3.12 Printing Structures
By default, a structure of typeSis printed using #Ssyntax. This behavior can be customized by
specifying a :print-function or:print-object option to the defstruct form that denes S, or by
writing a print-object method that is specialized forobjects of typeS.
Dierent structures might print out in dierent ways; the default notation for structures is:
#S(structure-namefslot-key slot-value g*)
where#Sindicates structure syntax, structure-name is a structure name , each slot-key is an
initialization argument name for a slotin the structure , and each corresponding slot-value is a
representation of the object in that slot.
For information on how the Lisp reader parses structures , see Section 2.4.8.13 (Sharpsign S).
Printer22–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.1.3.13 Printing Other Objects
Other objects are printed in an implementation-dependent manner. It is not required that an
implementation print those objects readably .
For example, hash tables ,readtables ,packages ,streams , and functions might not print readably .
A common notation to use in this circumstance is #<...> . Since#<is not readable by the Lisp
reader , the precise format of the text which follows is not important, but a common format to use
is that provided by the print-unreadable-object macro .
For information on how the Lisp reader treats this notation, see Section 2.4.8.20 (Sharpsign
Less-Than-Sign). For information on how to notate objects that cannot be printed readably , see
Section 2.4.8.6 (Sharpsign Dot).
22.1.4 Examples of Printer Behavior
(let ((*print-escape* t)) (fresh-line) (write #\a))
.#\a
!#\a
(let ((*print-escape* nil) (*print-readably* nil))
(fresh-line)
(write #\a))
.a
!#\a
(progn (fresh-line) (prin1 #\a))
.#\a
!#\a
(progn (fresh-line) (print #\a))
.
.#\a
!#\a
(progn (fresh-line) (princ #\a))
.a
!#\a
(dolist (val ’(t nil))
(let ((*print-escape* val) (*print-readably* val))
(print ’#\a)
(prin1 #\a) (write-char #\Space)
(princ #\a) (write-char #\Space)
(write #\a)))
.#\a #\a a #\a
22–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.#\a #\a a a
!NIL
(progn (fresh-line) (write ’(let ((a 1) (b 2)) (+ a b))))
.(LET ((A 1) (B 2)) (+ A B))
!(LET ((A 1) (B 2)) (+ A B))
(progn (fresh-line) (pprint ’(let ((a 1) (b 2)) (+ a b))))
.(LET ((A 1)
. (B 2))
.(+ A B))
!(LET ((A 1) (B 2)) (+ A B))
(progn (fresh-line)
(write ’(let ((a 1) (b 2)) (+ a b)) :pretty t))
.(LET ((A 1)
. (B 2))
.(+ A B))
!(LET ((A 1) (B 2)) (+ A B))
(with-output-to-string (s)
(write ’write :stream s)
(prin1 ’prin1 s))
!"WRITEPRIN1"
Printer22–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.2 The Lisp Pretty Printer
22.2.1 Pretty Printer Concepts
The facilities provided by the pretty printer permit programs to redene the way in which code
is displayed, and allow the full power of pretty printing to be applied to complex combinations of
data structures.
Whether any given style of output is in fact \pretty" is inherently a somewhat subjective issue.
However, since the eect of the pretty printer can be customized by conforming programs , the
necessary exibility is provided for individual programs to achieve an arbitrary degree of aesthetic
control.
By providing direct access to the mechanisms within the pretty printer that make dynamic decisions
about layout, the macros and functions pprint-logical-block ,pprint-newline , andpprint-indent
make it possible to specify pretty printing layout rules as a part of any function that produces
output. They also make it very easy for the detection of circularity and sharing, and abbreviation
based on length and nesting depth to be supported by the function.
The pretty printer is driven entirely by dispatch based on the value of*print-pprint-dispatch* .
The function set-pprint-dispatch makes it possible for conforming programs to associate new
pretty printing functions with a type.
22.2.1.1 Dynamic Control of the Arrangement of Output
The actions of the pretty printer when a piece of output is too large to t in the space available can
be precisely controlled. Three concepts underlie the way these operations work| logical blocks ,
conditional newlines , and sections . Before proceeding further, it is important to dene these
terms.
The rst line of Figure 22{3 shows a schematic piece of output. Each of the characters in the
output is represented by \ -". The positions of conditional newlines are indicated by digits. The
beginnings and ends of logical blocks are indicated by \ <" and \>" respectively.
The output as a whole is a logical block and the outermost section. This section is indicated by
the0's on the second line of Figure 1. Logical blocks nested within the output are specied by the
macropprint-logical-block . Conditional newline positions are specied by calls to pprint-newline .
Each conditional newline denes two sections (one before it and one after it) and is associated with
a third (the section immediately containing it).
The section after a conditional newline consists of: all the output up to, but not including, (a) the
next conditional newline immediately contained in the same logical block; or if (a) is not applicable,
(b) the next newline that is at a lesser level of nesting in logical blocks; or if (b) is not applicable,
(c) the end of the output.
The section before a conditional newline consists of: all the output back to, but not including, (a)
the previous conditional newline that is immediately contained in the same logical block; or if (a)
22–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
is not applicable, (b) the beginning of the immediately containing logical block. The last four lines
in Figure 1 indicate the sections before and after the four conditional newlines.
The section immediately containing a conditional newline is the shortest section that contains
the conditional newline in question. In Figure 22{3, the rst conditional newline is immediately
contained in the section marked with 0's, the second and third conditional newlines are immediately
contained in the section before the fourth conditional newline, and the fourth conditional newline
is immediately contained in the section after the rst conditional newline.
<-1–-<–<–2–-3->–4–>->
000000000000000000000000000
11 111111111111111111111111
22 222
333 3333
44444444444444 44444
Figure 22–3. Example of Logical Blocks, Conditional Newlines, and Sections
Whenever possible, the pretty printer displays the entire contents of a section on a single line.
However, if the section is too long to t in the space available, line breaks are inserted at conditional
newline positions within the section.
22.2.1.2 Format Directive Interface
The primary interface to operations for dynamically determining the arrangement of output is
provided through the functions and macros of the pretty printer. Figure 22{4 shows the dened
names related to pretty printing .
*print-lines* pprint-dispatch pprint-pop
*print-miser-width* pprint-exit-if-list-exhausted pprint-tab
*print-pprint-dispatch* pprint-ﬁll pprint-tabular
*print-right-margin* pprint-indent set-pprint-dispatch
copy-pprint-dispatch pprint-linear write
format pprint-logical-block
formatter pprint-newline
Figure 22–4. Deﬁned names related to pretty printing.
Figure 22{5 identies a set of format directives which serve as an alternate interface to the same
pretty printing operations in a more textually compact form.
~I ~W ~<...~:>
~:T ~/.../ ~
Figure 22–5. Format directives related to Pretty Printing
Printer22–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.2.1.3 Compiling Format Strings
Aformat string is essentially a program in a special-purpose language that performs printing, and
that is interpreted by the functionformat . Theformatter macro provides the eciency of using a
compiled function to do that same printing but without losing the textual compactness of format
strings .
Aformat control is either a format string or a function that was returned by the the formatter
macro .
22.2.1.4 Pretty Print Dispatch Tables
Apprint dispatch table is a mapping from keys to pairs of values. Each key is a type specier .
The values associated with a key are a \function" (specically, a function designator ornil) and a
\numerical priority" (specically, a real). Basic insertion and retrieval is done based on the keys
with the equality of keys being tested by equal .
When*print-pretty* istrue, thecurrent pprint dispatch table (in*print-pprint-dispatch* )
controls how objects are printed. The information in this table takes precedence over all other
mechanisms for specifying how to print objects . In particular, it has priority over user-dened
print-object methods because the current pprint dispatch table is consulted rst.
The function is chosen from the current pprint dispatch table by nding the highest priority
function that is associated with a type specier that matches the object ; if there is more than one
such function, it is implementation-dependent which is used.
However, if there is no information in the table about how to pretty print a particular kind of object ,
afunction is invoked which uses print-object to print the object . The value of *print-pretty* is
still true when this function is called , and individual methods for print-object might still elect to
produce output in a special format conditional on the value of*print-pretty* .
22.2.1.5 Pretty Printer Margins
A primary goal of pretty printing is to keep the output between a pair of margins. The column
where the output begins is taken as the left margin. If the current column cannot be determined
at the time output begins, the left margin is assumed to be zero. The right margin is controlled by
*print-right-margin* .
22.2.2 Examples of using the Pretty Printer
As an example of the interaction of logical blocks, conditional newlines, and indentation, consider
the function simple-pprint-defun below. This function prints out lists whose cars aredefun in the
standard way assuming that the list has exactly length 4.
(defun simple-pprint-defun (*standard-output* list)
(pprint-logical-block (*standard-output* list :prefix "(" :suffix ")")
(write (first list))
22–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(write-char #\Space)
(pprint-newline :miser)
(pprint-indent :current 0)
(write (second list))
(write-char #\Space)
(pprint-newline :fill)
(write (third list))
(pprint-indent :block 1)
(write-char #\Space)
(pprint-newline :linear)
(write (fourth list))))
Suppose that one evaluates the following:
(simple-pprint-defun *standard-output* ’(defun prod (x y) (* x y)))
If the line width available is greater than or equal to 26, then all of the output appears on one line.
If the line width available is reduced to 25, a line break is inserted at the linear-style conditional
newline before the expression (* x y) , producing the output shown. The (pprint-indent :block 1)
causes(* x y) to be printed at a relative indentation of 1in the logical block.
(DEFUN PROD (X Y)
(* X Y))
If the line width available is 15, a line break is also inserted at the ll style conditional newline
before the argument list. The call on (pprint-indent :current 0) causes the argument list to line
up under the function name.
(DEFUN PROD
(X Y)
(* X Y))
If*print-miser-width* were greater than or equal to 14, the example output above would have
been as follows, because all indentation changes are ignored in miser mode and line breaks are
inserted at miser-style conditional newlines.
(DEFUN
PROD
(X Y)
(* X Y))
As an example of a per-line prex, consider that evaluating the following produces the output
shown with a line width of 20and*print-miser-width* ofnil.
(pprint-logical-block (*standard-output* nil :per-line-prefix ";;; ")
(simple-pprint-defun *standard-output* ’(defun prod (x y) (* x y))))
;;; (DEFUN PROD
Printer22–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;;; (X Y)
;;; (* X Y))
As a more complex (and realistic) example, consider the function pprint-let below. This species
how to print a letform in the traditional style. It is more complex than the example above, because
it has to deal with nested structure. Also, unlike the example above it contains complete code to
readably print any possible list that begins with the symbollet. The outermost pprint-logical-block
form handles the printing of the input list as a whole and species that parentheses should be
printed in the output. The second pprint-logical-block form handles the list of binding pairs.
Each pair in the list is itself printed by the innermost pprint-logical-block . (Aloop form is used
instead of merely decomposing the pair into two objects so that readable output will be produced
no matter whether the list corresponding to the pair has one element, two elements, or (being
malformed) has more than two elements.) A space and a ll-style conditional newline are placed
after each pair except the last. The loop at the end of the topmost pprint-logical-block form
prints out the forms in the body of the letform separated by spaces and linear-style conditional
newlines.
(defun pprint-let (*standard-output* list)
(pprint-logical-block (nil list :prefix "(" :suffix ")")
(write (pprint-pop))
(pprint-exit-if-list-exhausted)
(write-char #\Space)
(pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
(pprint-exit-if-list-exhausted)
(loop (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
(pprint-exit-if-list-exhausted)
(loop (write (pprint-pop))
(pprint-exit-if-list-exhausted)
(write-char #\Space)
(pprint-newline :linear)))
(pprint-exit-if-list-exhausted)
(write-char #\Space)
(pprint-newline :fill)))
(pprint-indent :block 1)
(loop (pprint-exit-if-list-exhausted)
(write-char #\Space)
(pprint-newline :linear)
(write (pprint-pop)))))
Suppose that one evaluates the following with *print-level* being 4, and *print-circle* being true.
(pprint-let *standard-output*
’#1=(let (x (*print-length* (f (g 3)))
(z . 2) (k (car y)))
(setq x (sqrt z)) #1#))
If the line length is greater than or equal to 77, the output produced appears on one line. However,
22–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
if the line length is 76, line breaks are inserted at the linear-style conditional newlines separating
the forms in the body and the output below is produced. Note that, the degenerate binding pair
xis printed readably even though it fails to be a list; a depth abbreviation marker is printed in
place of (g 3) ; the binding pair (z . 2) is printed readably even though it is not a proper list;
and appropriate circularity markers are printed.
#1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))
(SETQ X (SQRT Z))
#1#)
If the line length is reduced to 35, a line break is inserted at one of the ll-style conditional newlines
separating the binding pairs.
#1=(LET (X (*PRINT-PRETTY* (F #))
(Z . 2) (K (CAR Y)))
(SETQ X (SQRT Z))
#1#)
Suppose that the line length is further reduced to 22and*print-length* is set to 3. In this
situation, line breaks are inserted after both the rst and second binding pairs. In addition, the
second binding pair is itself broken across two lines. Clause (b) of the description of ll-style
conditional newlines (see the function pprint-newline ) prevents the binding pair (z . 2) from
being printed at the end of the third line. Note that the length abbreviation hides the circularity
from view and therefore the printing of circularity markers disappears.
(LET (X
(*PRINT-LENGTH*
(F #))
(Z . 2) ...)
(SETQ X (SQRT Z))
...)
The next function prints a vector using \ #(...) " notation.
(defun pprint-vector (*standard-output* v)
(pprint-logical-block (nil nil :prefix "#(" :suffix ")")
(let ((end (length v)) (i 0))
(when (plusp end)
(loop (pprint-pop)
(write (aref v i))
(if (= (incf i) end) (return nil))
(write-char #\Space)
(pprint-newline :fill))))))
Evaluating the following with a line length of 15 produces the output shown.
(pprint-vector *standard-output* ’#(12 34 567 8 9012 34 567 89 0 1 23))
Printer22–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
#(12 34 567 8
9012 34 567
89 0 1 23)
As examples of the convenience of specifying pretty printing with format strings , consider that the
functions simple-pprint-defun andpprint-let used as examples above can be compactly dened
as follows. (The function pprint-vector cannot be dened using format because the data structure
it traverses is not a list.)
(defun simple-pprint-defun (*standard-output* list)
(format T "~:<~W ~@ ~:I~W ~: ~W~1I ~ ~W~:>" list))
(defun pprint-let (*standard-output* list)
(format T "~:<~W~^~:<~@{~:<~@{~W~^~~}~:>~^~:~}~:>~1I~@{~^~~W~}~:>" list))
In the following example, the rst form restores*print-pprint-dispatch* to the equivalent of its
initial value. The next two forms then set up a special way to pretty print ratios. Note that the
more specic type specier has to be associated with a higher priority.
(setq *print-pprint-dispatch* (copy-pprint-dispatch nil))
(set-pprint-dispatch ’ratio
#’(lambda (s obj)
(format s "#.(/ ~W ~W)"
(numerator obj) (denominator obj))))
(set-pprint-dispatch ’(and ratio (satisfies minusp))
#’(lambda (s obj)
(format s "#.(- (/ ~W ~W))"
(- (numerator obj)) (denominator obj)))
5)
(pprint ’(1/3 -2/3))
(#.(/ 1 3) #.(- (/ 2 3)))
The following two forms illustrate the denition of pretty printing functions for types of code.
The rst form illustrates how to specify the traditional method for printing quoted objects using
single-quote . Note the care taken to ensure that data lists that happen to begin with quote will
be printed readably. The second form species that lists beginning with the symbol my-let should
print the same way that lists beginning with letprint when the initial pprint dispatch table is in
eect.
(set-pprint-dispatch ’(cons (member quote)) ()
#’(lambda (s list)
(if (and (consp (cdr list)) (null (cddr list)))
(funcall (formatter "’~W") s (cadr list))
(pprint-fill s list))))
22–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(set-pprint-dispatch ’(cons (member my-let))
(pprint-dispatch ’(let) nil))
The next example species a default method for printing lists that do not correspond to function
calls. Note that the functions pprint-linear ,pprint-ﬁll , andpprint-tabular are all dened with
optional colon-p and at-sign-p arguments so that they can be used as pprint dispatch functions as
well as~/.../ functions.
(set-pprint-dispatch ’(cons (not (and symbol (satisfies fboundp))))
#’pprint-fill -5)
;; Assume a line length of 9
(pprint ’(0 b c d e f g h i j k))
(0 b c d
e f g h
i j k)
This nal example shows how to dene a pretty printing function for a user dened data structure.
(defstruct family mom kids)
(set-pprint-dispatch ’family
#’(lambda (s f)
(funcall (formatter "~@<#<~;~W and ~2I~ ~/pprint-fill/~;>~:>")
s (family-mom f) (family-kids f))))
The pretty printing function for the structure family species how to adjust the layout of the
output so that it can t aesthetically into a variety of line widths. In addition, it obeys the printer
control variables *print-level* ,*print-length* ,*print-lines* ,*print-circle* and*print-escape* ,
and can tolerate several dierent kinds of malformity in the data structure. The output below
shows what is printed out with a right margin of 25,*print-pretty* being true,*print-escape*
being false, and a malformed kids list.
(write (list ’principal-family
(make-family :mom "Lucy"
:kids ’("Mark" "Bob" . "Dan")))
:right-margin 25 :pretty T :escape nil :miser-width nil)
(PRINCIPAL-FAMILY
#<Lucy and
Mark Bob . Dan>)
Note that a pretty printing function for a structure is dierent from the structure's print-object
method . Whileprint-object methods are permanently associated with a structure, pretty printing
functions are stored in pprint dispatch tables and can be rapidly changed to reect dierent printing
needs. If there is no pretty printing function for a structure in the current pprint dispatch table , its
print-object method is used instead.
Printer22–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.2.3 Notes about the Pretty Printer’s Background
For a background reference to the abstract concepts detailed in this section, see XP: A Common
Lisp Pretty Printing System . The details of that paper are not binding on this document, but may
be helpful in establishing a conceptual basis for understanding this material.
22–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3 Formatted Output
format is useful for producing nicely formatted text, producing good-looking messages, and so on.
format can generate and return a string or output to destination .
The control-string argument to format is actually a format control . That is, it can be either a
format string or a function , for example a function returned by the formatter macro .
If it is a function , the function is called with the appropriate output stream as its rst argument
and the data arguments to format as its remaining arguments. The function should perform
whatever output is necessary and return the unused tail of the arguments (if any).
The compilation process performed by formatter produces a function that would do with its
arguments as theformat interpreter would do with those arguments .
The remainder of this section describes what happens if the control-string is aformat string .
Control-string is composed of simple text ( characters ) and embedded directives.
format writes the simple text as is; each embedded directive species further text output that
is to appear at the corresponding point within the simple text. Most directives use one or more
elements of args to create their output.
A directive consists of a tilde, optional prex parameters separated by commas, optional colon
and at-sign modiers, and a single character indicating what kind of directive this is. There is
no required ordering between the at-sign and colon modier. The case of the directive character
is ignored. Prex parameters are notated as signed (sign is optional) decimal numbers, or as
asingle-quote followed by a character. For example, ~5,’0d can be used to print an integer in
decimal radix in ve columns with leading zeros, or ~5,’*d to get leading asterisks.
In place of a prex parameter to a directive, V(orv) can be used. In this case, format takes
an argument from args as a parameter to the directive. The argument should be an integer or
character . If the argused by a Vparameter is nil, the eect is as if the parameter had been
omitted. #can be used in place of a prex parameter; it represents the number of args remaining
to be processed. When used within a recursive format, in the context of ~?or~{, the#prex
parameter represents the number of format arguments remaining within the recursive call.
Examples of format strings :
"~S" ;This is an S directive with no parameters or modiers.
"~3,-4:@s" ;This is an S directive with two parameters, 3and-4,
; and both the colon and at-sign ags.
"~,+4S" ;Here the rst prex parameter is omitted and takes
; on its default value, while the second parameter is 4.
Figure 22–6. Examples of format control strings
format sends the output to destination . If destination isnil,format creates and returns a string
Printer22–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
containing the output from control-string . If destination isnon-nil , it must be a string with a ll
pointer , astream , or the symbol t. Ifdestination is astring with a ll pointer , the output is added
to the end of the string . Ifdestination is astream , the output is sent to that stream . Ifdestination
ist, the output is sent to standard output .
In the description of the directives that follows, the term argin general refers to the next item of the
set of argsto be processed. The word or phrase at the beginning of each description is a mnemonic
for the directive. format directives do not bind any of the printer control variables ( *print-...* )
except as specied in the following descriptions. Implementations may specify the binding of new,
implementation-specic printer control variables for each format directive, but they may neither
bind any standard printer control variables not specied in description of a format directive nor
fail to bind any standard printer control variables as specied in the description.
22.3.1 FORMAT Basic Output
22.3.1.1 Tilde C: Character
The next argshould be a character ; it is printed according to the modier ags.
~Cprints the character as if by using write-char if it is a simple character .Characters
that are not simple are not necessarily printed as if by write-char , but are displayed in an
implementation-dened , abbreviated format. For example,
(format nil "~C" #\A) !"A"
(format nil "~C" #\Space) !" "
~:Cis the same as ~Cforprinting characters , but other characters are \spelled out." The intent is
that this is a \pretty" format for printing characters. For simple characters that are not printing ,
what is spelled out is the name of the character (seechar-name ). For characters that are not
simple and not printing , what is spelled out is implementation-dened . For example,
(format nil "~:C" #\A) !"A"
(format nil "~:C" #\Space) !"Space"
;; This next example assumes an implementation-defined "Control" attribute.
(format nil "~:C" #\Control-Space)
!"Control-Space"
or!"c-Space"
~:@C prints what ~:Cwould, and then if the character requires unusual shift keys on the keyboard
to type it, this fact is mentioned. For example,
(format nil "~:@C" #\Control-Partial) !"Control-@(Top-F)"
This is the format used for telling the user about a key he is expected to type, in prompts, for
instance. The precise output may depend not only on the implementation, but on the particular
I/O devices in use.
22–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
~@Cprints the character in a way that the Lisp reader can understand, using #\syntax.
~@Cbinds*print-escape* tot.
22.3.1.2 Tilde Percent: Newline
This outputs a #\Newline character, thereby terminating the current output line and beginning a
new one. ~n%outputs nnewlines. No argis used.
22.3.1.3 Tilde Ampersand: Fresh-Line
Unless it can be determined that the output stream is already at the beginning of a line, this
outputs a newline. ~n&callsfresh-line and then outputs n 1 newlines. ~0&does nothing.
22.3.1.4 Tilde Vertical-Bar: Page
This outputs a page separator character, if possible. ~n|does this ntimes.
22.3.1.5 Tilde Tilde: Tilde
This outputs a tilde.~n~outputs ntildes.
22.3.2 FORMAT Radix Control
22.3.2.1 Tilde R: Radix
~nRprints argin radix n. The modier ags and any remaining parameters
are used as for the ~Ddirective. ~Dis the same as ~10R. The full form is
~radix,mincol,padchar,commachar ,comma-interval R.
If no prex parameters are given to ~R, then a dierent interpretation is given. The argument
should be an integer . For example, if argis 4:
~Rprints argas a cardinal English number: four.
~:Rprints argas an ordinal English number: fourth .
~@Rprints argas a Roman numeral: IV.
Printer22–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
~:@R prints argas an old Roman numeral: IIII.
For example:
(format nil "~„’ ,4:B" 13) !"1101"
(format nil "~„’ ,4:B" 17) !"1 0001"
(format nil "~19,0,’ ,4:B" 3333) !"0000 1101 0000 0101"
(format nil "~3„,’ ,2:R" 17) !"1 22"
(format nil "~„’|,2:D" #xFFFF) !"6|55|35"
If and only if the rst parameter, n, is supplied, ~Rbinds*print-escape* tofalse,*print-radix*
tofalse,*print-base* ton, and*print-readably* tofalse.
If and only if no parameters are supplied, ~Rbinds*print-base* to10.
22.3.2.2 Tilde D: Decimal
Anarg, which should be an integer , is printed in decimal radix. ~Dwill never put a decimal point
after the number.
~mincolDuses a column width of mincol ; spaces are inserted on the left if the number requires
fewer than mincol columns for its digits and sign. If the number doesn't t in mincol columns,
additional columns are used as needed.
~mincol,padcharDuses padchar as the pad character instead of space.
Ifargis not an integer , it is printed in ~Aformat and decimal base.
The@modier causes the number's sign to be printed always; the default is to print it only if
the number is negative. The :modier causes commas to be printed between groups of digits;
commachar may be used to change the character used as the comma. comma-interval must be an
integer and defaults to 3. When the :modier is given to any of these directives, the commachar
is printed between groups of comma-interval digits.
Thus the most general form of ~Dis~mincol,padchar,commachar ,comma-interval D.
~Dbinds*print-escape* tofalse,*print-radix* tofalse,*print-base* to10, and*print-readably*
tofalse.
22.3.2.3 Tilde B: Binary
This is just like ~Dbut prints in binary radix (radix 2) instead of decimal. The full form is therefore
~mincol,padchar,commachar ,comma-interval B.
~Bbinds*print-escape* tofalse,*print-radix* tofalse,*print-base* to2, and*print-readably*
tofalse.
22–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3.2.4 Tilde O: Octal
This is just like ~Dbut prints in octal radix (radix 8) instead of decimal. The full form is therefore
~mincol,padchar,commachar ,comma-interval O.
~Obinds*print-escape* tofalse,*print-radix* tofalse,*print-base* to8, and*print-readably*
tofalse.
22.3.2.5 Tilde X: Hexadecimal
This is just like ~Dbut prints in hexadecimal radix (radix 16) instead of decimal. The full form is
therefore ~mincol,padchar,commachar ,comma-interval X.
~Xbinds*print-escape* tofalse,*print-radix* tofalse,*print-base* to16, and*print-readably*
tofalse.
22.3.3 FORMAT Floating-Point Printers
22.3.3.1 Tilde F: Fixed-Format Floating-Point
The next argis printed as a oat.
The full form is ~w,d,k,overowchar ,padcharF. The parameter wis the width of the eld to be
printed; dis the number of digits to print after the decimal point; kis a scale factor that defaults
to zero.
Exactly wcharacters will be output. First, leading copies of the character padchar (which defaults
to a space) are printed, if necessary, to pad the eld on the left. If the argis negative, then a minus
sign is printed; if the argis not negative, then a plus sign is printed if and only if the @modier
was supplied. Then a sequence of digits, containing a single embedded decimal point, is printed;
this represents the magnitude of the value of argtimes 10k, rounded to dfractional digits. When
rounding up and rounding down would produce printed values equidistant from the scaled value of
arg, then the implementation is free to use either one. For example, printing the argument 6.375
using the format ~4,2F may correctly produce either 6.37 or6.38. Leading zeros are not permitted,
except that a single zero digit is output before the decimal point if the printed value is less than
one, and this single zero digit is not output at all if w=d+1.
If it is impossible to print the value in the required format in a eld of width w, then one of two
actions is taken. If the parameter overowchar is supplied, then wcopies of that parameter are
printed instead of the scaled value of arg. If the overowchar parameter is omitted, then the scaled
value is printed using more than wcharacters, as many more as may be needed.
If the wparameter is omitted, then the eld is of variable width. In eect, a value is chosen for
win such a way that no leading pad characters need to be printed and exactly dcharacters will
follow the decimal point. For example, the directive ~,2F will print exactly two digits after the
decimal point and as many as necessary before the decimal point.
Printer22–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If the parameter dis omitted, then there is no constraint on the number of digits to appear after
the decimal point. A value is chosen for din such a way that as many digits as possible may be
printed subject to the width constraint imposed by the parameter wand the constraint that no
trailing zero digits may appear in the fraction, except that if the fraction to be printed is zero, then
a single zero digit should appear after the decimal point if permitted by the width constraint.
If both wanddare omitted, then the eect is to print the value using ordinary free-format output;
prin1 uses this format for any number whose magnitude is either zero or between 10 3(inclusive)
and107(exclusive).
Ifwis omitted, then if the magnitude of argis so large (or, if dis also omitted, so small) that more
than 100 digits would have to be printed, then an implementation is free, at its discretion, to print
the number using exponential notation instead, as if by the directive ~E(with all parameters to ~E
defaulted, not taking their values from the ~Fdirective).
Ifargis arational number, then it is coerced to be a single oat and then printed. Alternatively, an
implementation is permitted to process a rational number by any other method that has essentially
the same behavior but avoids loss of precision or overow because of the coercion. If wand dare
not supplied and the number has no exact decimal representation, for example 1/3, some precision
cuto must be chosen by the implementation since only a nite number of digits may be printed.
Ifargis acomplex number or some non-numeric object , then it is printed using the format directive
~wD, thereby printing it in decimal radix and a minimum eld width of w.
~Fbinds*print-escape* tofalse and*print-readably* tofalse.
22.3.3.2 Tilde E: Exponential Floating-Point
The next argis printed as a oat in exponential notation.
The full form is ~w,d,e,k,overowchar ,padchar,exponentchar E. The parameter wis the width of
the eld to be printed; dis the number of digits to print after the decimal point; eis the number
of digits to use when printing the exponent; kis a scale factor that defaults to one (not zero).
Exactly wcharacters will be output. First, leading copies of the character padchar (which defaults
to a space) are printed, if necessary, to pad the eld on the left. If the argis negative, then a minus
sign is printed; if the argis not negative, then a plus sign is printed if and only if the @modier
was supplied. Then a sequence of digits containing a single embedded decimal point is printed.
The form of this sequence of digits depends on the scale factor k. Ifkis zero, then ddigits are
printed after the decimal point, and a single zero digit appears before the decimal point if the total
eld width will permit it. If kis positive, then it must be strictly less than d+2;ksignicant digits
are printed before the decimal point, and d k+1 digits are printed after the decimal point. If kis
negative, then it must be strictly greater than  d; a single zero digit appears before the decimal
point if the total eld width will permit it, and after the decimal point are printed rst  kzeros
and then d+ksignicant digits. The printed fraction must be properly rounded. When rounding
up and rounding down would produce printed values equidistant from the scaled value of arg, then
the implementation is free to use either one. For example, printing the argument 637.5 using the
format~8,2E may correctly produce either 6.37E+2 or6.38E+2 .
22–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Following the digit sequence, the exponent is printed. First the character parameter exponentchar
is printed; if this parameter is omitted, then the exponent marker thatprin1 would use is printed,
as determined from the type of the oat and the current value of *read-default-ﬂoat-format* .
Next, either a plus sign or a minus sign is printed, followed by edigits representing the power of
ten by which the printed fraction must be multiplied to properly represent the rounded value of
arg.
If it is impossible to print the value in the required format in a eld of width w, possibly because
kis too large or too small or because the exponent cannot be printed in echaracter positions,
then one of two actions is taken. If the parameter overowchar is supplied, then wcopies of that
parameter are printed instead of the scaled value of arg. If the overowchar parameter is omitted,
then the scaled value is printed using more than wcharacters, as many more as may be needed; if
the problem is that dis too small for the supplied kor that eis too small, then a larger value is
used for doreas may be needed.
If the wparameter is omitted, then the eld is of variable width. In eect a value is chosen for w
in such a way that no leading pad characters need to be printed.
If the parameter dis omitted, then there is no constraint on the number of digits to appear. A
value is chosen for din such a way that as many digits as possible may be printed subject to
the width constraint imposed by the parameter w, the constraint of the scale factor k, and the
constraint that no trailing zero digits may appear in the fraction, except that if the fraction to be
printed is zero then a single zero digit should appear after the decimal point.
If the parameter eis omitted, then the exponent is printed using the smallest number of digits
necessary to represent its value.
If all of w,d, and eare omitted, then the eect is to print the value using ordinary free-format
exponential-notation output; prin1 uses a similar format for any non-zero number whose magnitude
is less than 10 3or greater than or equal to 107. The only dierence is that the ~Edirective always
prints a plus or minus sign in front of the exponent, while prin1 omits the plus sign if the exponent
is non-negative.
Ifargis arational number, then it is coerced to be a single oat and then printed. Alternatively, an
implementation is permitted to process a rational number by any other method that has essentially
the same behavior but avoids loss of precision or overow because of the coercion. If wand dare
unsupplied and the number has no exact decimal representation, for example 1/3, some precision
cuto must be chosen by the implementation since only a nite number of digits may be printed.
Ifargis acomplex number or some non-numeric object , then it is printed using the format directive
~wD, thereby printing it in decimal radix and a minimum eld width of w.
~Ebinds*print-escape* tofalse and*print-readably* tofalse.
22.3.3.3 Tilde G: General Floating-Point
The next argis printed as a oat in either xed-format or exponential notation as appropriate.
Printer22–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The full form is ~w,d,e,k,overowchar ,padchar,exponentchar G. The format in which to print
argdepends on the magnitude (absolute value) of the arg. Let nbe an integer such that 10n 1
jargj<10n. Let eeequal e+2, or 4 if eis omitted. Let wwequal w ee, ornilifwis omitted. If d
is omitted, rst let qbe the number of digits needed to print argwith no loss of information and
without leading or trailing zeros; then let dequal(max q(min n7)). Let ddequal d n.
If 0ddd, then argis printed as if by the format directives
~ww,dd„overowchar ,padcharF~ee@T
Note that the scale factor kis not passed to the ~Fdirective. For all other values of dd,argis
printed as if by the format directive
~w,d,e,k,overowchar ,padchar,exponentchar E
In either case, an @modier is supplied to the ~For~Edirective if and only if one was supplied to
the~Gdirective.
~Gbinds*print-escape* tofalse and*print-readably* tofalse.
22.3.3.4 Tilde Dollarsign: Monetary Floating-Point
The next argis printed as a oat in xed-format notation.
The full form is ~d,n,w,padchar$. The parameter dis the number of digits to print after the
decimal point (default value 2); nis the minimum number of digits to print before the decimal
point (default value 1); wis the minimum total width of the eld to be printed (default value 0).
First padding and the sign are output. If the argis negative, then a minus sign is printed; if the
argis not negative, then a plus sign is printed if and only if the @modier was supplied. If the
:modier is used, the sign appears before any padding, and otherwise after the padding. If wis
supplied and the number of other characters to be output is less than w, then copies of padchar
(which defaults to a space) are output to make the total eld width equal w. Then ndigits are
printed for the integer part of arg, with leading zeros if necessary; then a decimal point; then d
digits of fraction, properly rounded.
If the magnitude of argis so large that more than mdigits would have to be printed, where m
is the larger of wand 100, then an implementation is free, at its discretion, to print the number
using exponential notation instead, as if by the directive ~w,q„„padcharE, where wand padchar
are present or omitted according to whether they were present or omitted in the ~$directive, and
where q=d+n 1, where dand nare the (possibly default) values given to the ~$directive.
Ifargis arational number, then it is coerced to be a single oat and then printed. Alternatively,
an implementation is permitted to process a rational number by any other method that has
essentially the same behavior but avoids loss of precision or overow because of the coercion.
Ifargis acomplex number or some non-numeric object , then it is printed using the format directive
~wD, thereby printing it in decimal radix and a minimum eld width of w.
22–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
~$binds*print-escape* tofalse and*print-readably* tofalse.
22.3.4 FORMAT Printer Operations
22.3.4.1 Tilde A: Aesthetic
Anarg, any object , is printed without escape characters (as by princ ). If argis a string , its
characters will be output verbatim. If argisnilit will be printed as nil; the colon modier ( ~:A)
will cause an argofnilto be printed as (), but if argis a composite structure, such as a listor
vector , any contained occurrences of nilwill still be printed as nil.
~mincolAinserts spaces on the right, if necessary, to make the width at least mincol columns. The
@modier causes the spaces to be inserted on the left rather than the right.
~mincol,colinc,minpad,padcharAis the full form of ~A, which allows control of the padding. The
string is padded on the right (or on the left if the @modier is used) with at least minpad copies
ofpadchar ; padding characters are then inserted colinc characters at a time until the total width
is at least mincol . The defaults are 0formincol and minpad ,1forcolinc , and the space character
forpadchar .
~Abinds*print-escape* tofalse, and*print-readably* tofalse.
22.3.4.2 Tilde S: Standard
This is just like ~A, but argis printed with escape characters (as by prin1 rather than princ ). The
output is therefore suitable for input to read.~Saccepts all the arguments and modiers that ~A
does.
~Sbinds*print-escape* tot.
22.3.4.3 Tilde W: Write
An argument, any object , is printed obeying every printer control variable (as by write ). In
addition, ~Winteracts correctly with depth abbreviation, by not resetting the depth counter to zero.
~Wdoes not accept parameters. If given the colon modier, ~Wbinds*print-pretty* totrue. If
given the at-sign modier, ~Wbinds*print-level* and*print-length* tonil.
~Wprovides automatic support for the detection of circularity and sharing. If the value of
*print-circle* is notniland~Wis applied to an argument that is a circular (or shared) reference,
an appropriate #n#marker is inserted in the output instead of printing the argument.
22.3.5 FORMAT Pretty Printer Operations
The following constructs provide access to the pretty printer :
Printer22–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3.5.1 Tilde Underscore: Conditional Newline
Without any modiers, ~is the same as (pprint-newline :linear) .~@is the same as
(pprint-newline :miser) .~:is the same as (pprint-newline :fill) .~:@ is the same as
(pprint-newline :mandatory) .
22.3.5.2 Tilde Less-Than-Sign: Logical Block
~<...~:>
If~:>is used to terminate a ~<...~> , the directive is equivalent to a call to pprint-logical-block .
The argument corresponding to the ~<...~:> directive is treated in the same way as the list
argument to pprint-logical-block , thereby providing automatic support for non- listarguments
and the detection of circularity, sharing, and depth abbreviation. The portion of the control-string
nested within the ~<...~:> species the :prefix (or:per-line-prefix ),:suffix , and body of the
pprint-logical-block .
The control-string portion enclosed by ~<...~:> can be divided into segments
~<prex~;body~;sux~:>by~;directives. If the rst section is terminated by ~@;, it speci-
es a per-line prex rather than a simple prex. The prex and sux cannot contain format
directives. An error is signaled if either the prex or sux fails to be a constant string or if the
enclosed portion is divided into more than three segments.
If the enclosed portion is divided into only two segments, the sux defaults to the null string. If
the enclosed portion consists of only a single segment, both the prex and the sux default to the
null string. If the colon modier is used ( i.e.,~:<...~:> ), the prex and sux default to "("and
")"(respectively) instead of the null string.
The body segment can be any arbitrary format string . This format string is applied to the
elements of the list corresponding to the ~<...~:> directive as a whole. Elements are extracted
from this list using pprint-pop , thereby providing automatic support for malformed lists, and the
detection of circularity, sharing, and length abbreviation. Within the body segment, ~^acts like
pprint-exit-if-list-exhausted .
~<...~:> supports a feature not supported by pprint-logical-block . If~:@> is used to terminate the
directive ( i.e.,~<...~:@> ), then a ll-style conditional newline is automatically inserted after each
group of blanks immediately contained in the body (except for blanks after a hNewlineidirective).
This makes it easy to achieve the equivalent of paragraph lling.
If the at-sign modier is used with ~<...~:> , the entire remaining argument list is passed to the
directive as its argument. All of the remaining arguments are always consumed by ~@<...~:> , even
if they are not all used by the format string nested in the directive. Other than the dierence in
its argument, ~@<...~:> is exactly the same as ~<...~:> except that circularity detection is not
applied if ~@<...~:> is encountered at top level in a format string . This ensures that circularity
detection is applied only to data lists, not to format argument lists .
" . # n#"is printed if circularity or sharing has to be indicated for its argument as a whole.
22–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
To a considerable extent, the basic form of the directive ~<...~> is incompatible with the dynamic
control of the arrangement of output by ~W,~,~<...~:> ,~I, and~:T. As a result, an error is
signaled if any of these directives is nested within ~<...~> . Beyond this, an error is also signaled if
the~<...~:;...~> form of ~<...~> is used in the same format string with~W,~,~<...~:> ,~I, or
~:T.
See also Section 22.3.6.2 (Tilde Less-Than-Sign: Justication).
22.3.5.3 Tilde I: Indent
~nIis the same as (pprint-indent :block n) .
~n:Iis the same as (pprint-indent :current n) . In both cases, ndefaults to zero, if it is omitted.
22.3.5.4 Tilde Slash: Call Function
~/name/
User dened functions can be called from within a format string by using the directive ~/name/.
The colon modier, the at-sign modier, and arbitrarily many parameters can be specied with
the~/name/directive. name can be any arbitrary string that does not contain a "/". All of the
characters in name are treated as if they were upper case. If name contains a single colon (:) or
double colon (::), then everything up to but not including the rst ":"or"::" is taken to be a
string that names a package . Everything after the rst ":"or"::" (if any) is taken to be a string
that names a symbol . The function corresponding to a ~/name/ directive is obtained by looking up
thesymbol that has the indicated name in the indicated package . Ifname does not contain a ":"
or"::", then the whole name string is looked up in the COMMON-LISP-USER package .
When a ~/name/ directive is encountered, the indicated function is called with four or more
arguments. The rst four arguments are: the output stream, the format argument corresponding
to the directive, a generalized boolean that is true if the colon modier was used, and a generalized
boolean that is true if the at-sign modier was used. The remaining arguments consist of any
parameters specied with the directive. The function should print the argument appropriately.
Any values returned by the function are ignored.
The three functions pprint-linear ,pprint-ﬁll , andpprint-tabular are specically designed so that
they can be called by ~/.../ (i.e.,~/pprint-linear/ ,~/pprint-fill/ , and~/pprint-tabular/ ). In
particular they take colon and at-sign arguments.
22.3.6 FORMAT Layout Control
Printer22–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3.6.1 Tilde T: Tabulate
This spaces over to a given column. ~colnum,colincTwill output sucient spaces to move the
cursor to column colnum . If the cursor is already at or beyond column colnum , it will output
spaces to move it to column colnum +k*colinc for the smallest positive integer kpossible, unless
colinc is zero, in which case no spaces are output if the cursor is already at or beyond column
colnum .colnum and colinc default to 1.
If for some reason the current absolute column position cannot be determined by direct inquiry,
format may be able to deduce the current column position by noting that certain directives (such
as~%, or~&, or~Awith the argument being a string containing a newline) cause the column
position to be reset to zero, and counting the number of characters emitted since that point. If
that fails, format may attempt a similar deduction on the riskier assumption that the destination
was at column zero when format was invoked. If even this heuristic fails or is implementationally
inconvenient, at worst the ~Toperation will simply output two spaces.
~@Tperforms relative tabulation. ~colrel,colinc@Toutputs colrel spaces and then outputs the
smallest non-negative number of additional spaces necessary to move the cursor to a column that
is a multiple of colinc . For example, the directive ~3,8@T outputs three spaces and then moves the
cursor to a \standard multiple-of-eight tab stop" if not at one already. If the current output column
cannot be determined, however, then colinc is ignored, and exactly colrel spaces are output.
If the colon modier is used with the ~Tdirective, the tabbing computation is done relative to the
horizontal position where the section immediately containing the directive begins, rather than with
respect to a horizontal position of zero. The numerical parameters are both interpreted as being in
units of ems and both default to 1.~n,m:Tis the same as (pprint-tab :section n m).~n,m:@T
is the same as (pprint-tab :section-relative n m).
22.3.6.2 Tilde Less-Than-Sign: Justiﬁcation
~mincol,colinc,minpad,padchar<str~>
This justies the text produced by processing strwithin a eld at least mincol columns wide. str
may be divided up into segments with ~;, in which case the spacing is evenly divided between the
text segments.
With no modiers, the leftmost text segment is left justied in the eld, and the rightmost text
segment is right justied. If there is only one text element, as a special case, it is right justied.
The:modier causes spacing to be introduced before the rst text segment; the @modier causes
spacing to be added after the last. The minpad parameter (default 0) is the minimum number
of padding characters to be output between each segment. The padding character is supplied
bypadchar , which defaults to the space character. If the total width needed to satisfy these
constraints is greater than mincol , then the width used is mincol +k*colinc for the smallest possible
non-negative integer value k.colinc defaults to 1, and mincol defaults to 0.
Note that strmay include format directives. All the clauses in strare processed in order; it is the
resulting pieces of text that are justied.
22–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The~^directive may be used to terminate processing of the clauses prematurely, in which case
only the completely processed clauses are justied.
If the rst clause of a ~<is terminated with ~:;instead of ~;, then it is used in a special way. All
of the clauses are processed (subject to ~^, of course), but the rst one is not used in performing
the spacing and padding. When the padded result has been determined, then if it will t on the
current line of output, it is output, and the text for the rst clause is discarded. If, however, the
padded text will not t on the current line, then the text segment for the rst clause is output
before the padded text. The rst clause ought to contain a newline (such as a ~%directive). The
rst clause is always processed, and so any arguments it refers to will be used; the decision is
whether to use the resulting segment of text, not whether to process the rst clause. If the ~:;has
a prex parameter n, then the padded text must t on the current line with ncharacter positions
to spare to avoid outputting the rst clause's text. For example, the control string
"~%;; ~{~<~%;; ~1:; ~S~>~^,~}.~%"
can be used to print a list of items separated by commas without breaking items over line
boundaries, beginning each line with ;;. The prex parameter 1in~1:; accounts for the width of
the comma that will follow the justied item if it is not the last element in the list, or the period if
it is. If~:;has a second prex parameter, then it is used as the width of the line, thus overriding
the natural line width of the output stream. To make the preceding example use a line width of
50, one would write
"~%;; ~{~<~%;; ~1,50:; ~S~>~^,~} .~%"
If the second argument is not supplied, then format uses the line width of the destination output
stream. If this cannot be determined (for example, when producing a string result), then format
uses72as the line length.
See also Section 22.3.5.2 (Tilde Less-Than-Sign: Logical Block).
22.3.6.3 Tilde Greater-Than-Sign: End of Justiﬁcation
~>terminates a ~<. The consequences of using it elsewhere are undened.
22.3.7 FORMAT Control-Flow Operations
22.3.7.1 Tilde Asterisk: Go-To
The next argis ignored. ~n*ignores the next narguments.
~:*backs up in the list of arguments so that the argument last processed will be processed again.
~n:*backs up narguments.
When within a ~{construct (see below), the ignoring (in either direction) is relative to the list of
arguments being processed by the iteration.
Printer22–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
~n@*goes to the ntharg, where 0 means the rst one; ndefaults to 0, so ~@*goes back to the
rst arg. Directives after a ~n@*will take arguments in sequence beginning with the one gone to.
When within a ~{construct, the \goto" is relative to the list of arguments being processed by the
iteration.
22.3.7.2 Tilde Left-Bracket: Conditional Expression
~[str0~;str1~;...~;strn~]
This is a set of control strings, called clauses , one of which is chosen and used. The clauses are
separated by ~;and the construct is terminated by ~]. For example,
"~[Siamese~;Manx~;Persian~] Cat"
The argth clause is selected, where the rst clause is number 0. If a prex parameter is given (as
~n[), then the parameter is used instead of an argument. If argis out of range then no clause is
selected and no error is signaled. After the selected alternative has been processed, the control
string continues after the ~].
~[str0~;str1~;...~;strn~:;default~]has a default case. If the last~;used to separate clauses is ~:;
instead, then the last clause is an else clause that is performed if no other clause is selected. For
example:
"~[Siamese~;Manx~;Persian~:;Alley~] Cat"
~:[alternative ~;consequent ~]selects the alternative control string if argisfalse, and selects the
consequent control string otherwise.
~@[consequent ~]tests the argument. If it is true, then the argument is not used up by the ~[
command but remains as the next one to be processed, and the one clause consequent is processed.
If the argisfalse, then the argument is used up, and the clause is not processed. The clause
therefore should normally use exactly one argument, and may expect it to be non-nil . For example:
(setq *print-level* nil *print-length* 5)
(format nil
"~@[ print level = ~D~]~@[ print length = ~D~]"
*print-level* *print-length*)
!" print length = 5"
Note also that
(format stream"...~@[ str~]..." ...)
(format stream"...~:[~;~:* str~]..." ...)
The combination of ~[and#is useful, for example, for dealing with English conventions for printing
lists:
(setq foo "Items:~#[ none~; ~S~; ~S and ~S~
~:;~@{~#[~; and~] ~S~^,~}~].")
22–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(format nil foo) !"Items: none."
(format nil foo ’foo) !"Items: FOO."
(format nil foo ’foo ’bar) !"Items: FOO and BAR."
(format nil foo ’foo ’bar ’baz) !"Items: FOO, BAR, and BAZ."
(format nil foo ’foo ’bar ’baz ’quux) !"Items: FOO, BAR, BAZ, and QUUX."
22.3.7.3 Tilde Right-Bracket: End of Conditional Expression
~]terminates a ~[. The consequences of using it elsewhere are undened.
22.3.7.4 Tilde Left-Brace: Iteration
~{str~}
This is an iteration construct. The argument should be a list, which is used as a set of arguments
as if for a recursive call to format . The string str is used repeatedly as the control string. Each
iteration can absorb as many elements of the listas it likes as arguments; if struses up two
arguments by itself, then two elements of the listwill get used up each time around the loop.
If before any iteration step the listis empty, then the iteration is terminated. Also, if a prex
parameter nis given, then there will be at most nrepetitions of processing of str. Finally, the ~^
directive can be used to terminate the iteration prematurely.
For example:
(format nil "The winners are:~{ ~S~}."
’(fred harry jill))
!"The winners are: FRED HARRY JILL."
(format nil "Pairs:~{ <~S,~S>~}."
’(a 1 b 2 c 3))
!"Pairs: <A,1> <B,2> <C,3>."
~:{str~}is similar, but the argument should be a listof sublists. At each repetition step, one
sublist is used as the set of arguments for processing str; on the next repetition, a new sublist is
used, whether or not all of the last sublist had been processed. For example:
(format nil "Pairs:~:{ <~S,~S>~}."
’((a 1) (b 2) (c 3)))
!"Pairs: <A,1> <B,2> <C,3>."
~@{str~}is similar to ~{str~}, but instead of using one argument that is a list, all the remaining
arguments are used as the list of arguments for the iteration. Example:
(format nil "Pairs:~@{ <~S,~S>~}." ’a 1 ’b 2 ’c 3)
!"Pairs: <A,1> <B,2> <C,3>."
If the iteration is terminated before all the remaining arguments are consumed, then any arguments
not processed by the iteration remain to be processed by any directives following the iteration
construct.
Printer22–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
~:@{str~}combines the features of ~:{str~}and~@{str~}. All the remaining arguments are used,
and each one must be a list. On each iteration, the next argument is used as a listof arguments to
str. Example:
(format nil "Pairs:~:@{ <~S,~S>~}."
’(a 1) ’(b 2) ’(c 3))
!"Pairs: <A,1> <B,2> <C,3>."
Terminating the repetition construct with ~:}instead of ~}forces strto be processed at least
once, even if the initial list of arguments is null. However, this will not override an explicit prex
parameter of zero.
Ifstris empty, then an argument is used as str. It must be a format control and precede any
arguments processed by the iteration. As an example, the following are equivalent:
(apply #’format stream string arguments)
(format stream "~1{~:}" string arguments)
This will use string as a formatting string. The ~1{says it will be processed at most once, and the
~:}says it will be processed at least once. Therefore it is processed exactly once, using arguments
as the arguments. This case may be handled more clearly by the ~?directive, but this general
feature of ~{is more powerful than ~?.
22.3.7.5 Tilde Right-Brace: End of Iteration
~}terminates a ~{. The consequences of using it elsewhere are undened.
22.3.7.6 Tilde Question-Mark: Recursive Processing
The next argmust be a format control , and the one after it a list; both are consumed by the ~?
directive. The two are processed as a control-string , with the elements of the listas the arguments.
Once the recursive processing has been nished, the processing of the control string containing the
~?directive is resumed. Example:
(format nil "~? ~D" "<~A ~D>" ’("Foo" 5) 7) !"<Foo 5> 7"
(format nil "~? ~D" "<~A ~D>" ’("Foo" 5 14) 7) !"<Foo 5> 7"
Note that in the second example three arguments are supplied to the format string "<~A ~D>" , but
only two are processed and the third is therefore ignored.
With the @modier, only one argis directly consumed. The argmust be a string ; it is processed
as part of the control string as if it had appeared in place of the ~@?construct, and any directives
in the recursively processed control string may consume arguments of the control string containing
the~@?directive. Example:
(format nil "~@? ~D" "<~A ~D>" "Foo" 5 7) !"<Foo 5> 7"
(format nil "~@? ~D" "<~A ~D>" "Foo" 5 14 7) !"<Foo 5> 14"
22–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3.8 FORMAT Miscellaneous Operations
22.3.8.1 Tilde Left-Paren: Case Conversion
~(str~)
The contained control string stris processed, and what it produces is subject to case conversion.
With no ags, every uppercase character is converted to the corresponding lowercase character .
~:(capitalizes all words, as if by string-capitalize .
~@(capitalizes just the rst word and forces the rest to lower case.
~:@( converts every lowercase character to the corresponding uppercase character.
In this example ~@(is used to cause the rst word produced by ~@Rto be capitalized:
(format nil "~@R ~(~@R~)" 14 14)
!"XIV xiv"
(defun f (n) (format nil "~@(~R~) error~:P detected." n)) !F
(f 0)!"Zero errors detected."
(f 1)!"One error detected."
(f 23)!"Twenty-three errors detected."
When case conversions appear nested, the outer conversion dominates, as illustrated in the
following example:
(format nil "~@(how is ~:(BOB SMITH~)?~)")
!"How is bob smith?"not!"How is Bob Smith?"
22.3.8.2 Tilde Right-Paren: End of Case Conversion
~)terminates a ~(. The consequences of using it elsewhere are undened.
22.3.8.3 Tilde P: Plural
Ifargis noteqlto the integer 1, a lowercase sis printed; if argiseqlto1, nothing is printed. If
argis a oating-point 1.0, thesis printed.
~:Pdoes the same thing, after doing a ~:*to back up one argument; that is, it prints a lowercase s
if the previous argument was not 1.
~@Pprintsyif the argument is 1, oriesif it is not. ~:@P does the same thing, but backs up rst.
(format nil "~D tr~:@P/~D win~:P" 7 1) !"7 tries/1 win"
Printer22–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(format nil "~D tr~:@P/~D win~:P" 1 0) !"1 try/0 wins"
(format nil "~D tr~:@P/~D win~:P" 1 3) !"1 try/3 wins"
22.3.9 FORMAT Miscellaneous Pseudo-Operations
22.3.9.1 Tilde Semicolon: Clause Separator
This separates clauses in ~[and~<constructs. The consequences of using it elsewhere are
undened.
22.3.9.2 Tilde Circumﬂex: Escape Upward
~^
This is an escape construct. If there are no more arguments remaining to be processed, then the
immediately enclosing ~{or~<construct is terminated. If there is no such enclosing construct,
then the entire formatting operation is terminated. In the ~<case, the formatting is performed,
but no more segments are processed before doing the justication. ~^may appear anywhere in a
~{construct.
(setq donestr "Done.~^~D warning~:P.~^~D error~:P.")
!"Done.~^~D warning~:P.~^~D error~:P."
(format nil donestr) !"Done."
(format nil donestr 3) !"Done. 3 warnings."
(format nil donestr 1 5) !"Done. 1 warning. 5 errors."
If a prex parameter is given, then termination occurs if the parameter is zero. (Hence ~^is
equivalent to ~#^.) If two parameters are given, termination occurs if they are equal. If three
parameters are given, termination occurs if the rst is less than or equal to the second and the
second is less than or equal to the third. Of course, this is useless if all the prex parameters are
constants; at least one of them should be a #or aVparameter.
If~^is used within a ~:{construct, then it terminates the current iteration step because in the
standard case it tests for remaining arguments of the current step only; the next iteration step
commences immediately. ~:^is used to terminate the iteration process. ~:^may be used only if
the command it would terminate is ~:{or~:@{. The entire iteration process is terminated if and
only if the sublist that is supplying the arguments for the current iteration step is the last sublist in
the case of ~:{, or the last format argument in the case of ~:@{.~:^is not equivalent to ~#:^; the
latter terminates the entire iteration if and only if no arguments remain for the current iteration
step. For example:
(format nil "~:{~@?~:^...~}" ’(("a") ("b"))) !"a...b"
If~^appears within a control string being processed under the control of a ~?directive, but
not within any ~{or~<construct within that string, then the string being processed will be
22–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
terminated, thereby ending processing of the ~?directive. Processing then continues within the
string containing the ~?directive at the point following that directive.
If~^appears within a ~[or~(construct, then all the commands up to the ~^are properly selected
or case-converted, the ~[or~(processing is terminated, and the outward search continues for a ~{
or~<construct to be terminated. For example:
(setq tellstr "~@(~@[~R~]~^~A!~)")
!"~@(~@[~R~]~^~A!~)"
(format nil tellstr 23) !"Twenty-three!"
(format nil tellstr nil "losers") !" Losers!"
(format nil tellstr 23 "losers") !"Twenty-three losers!"
Following are examples of the use of ~^within a ~<construct.
(format nil "~15<~S~;~^~S~;~^~S~>" ’foo)
!" FOO"
(format nil "~15<~S~;~^~S~;~^~S~>" ’foo ’bar)
!"FOO BAR"
(format nil "~15<~S~;~^~S~;~^~S~>" ’foo ’bar ’baz)
!"FOO BAR BAZ"
22.3.9.3 Tilde Newline: Ignored Newline
Tilde immediately followed by a newline ignores the newline and any following non-newline
whitespace 1characters. With a :, the newline is ignored, but any following whitespace 1is left
in place. With an @, the newline is left in place, but any following whitespace 1is ignored. For
example:
(defun type-clash-error (fn nargs argnum right-type wrong-type)
(format *error-output*
"~&~S requires its ~:[~:R~;~*~]~
argument to be of type ~S,~%but it was called ~
with an argument of type ~S.~%"
fn (eql nargs 1) argnum right-type wrong-type))
(type-clash-error ’aref nil 2 ’integer ’vector) prints:
AREF requires its second argument to be of type INTEGER,
but it was called with an argument of type VECTOR.
NIL
(type-clash-error ’car 1 1 ’list ’short-float) prints:
CAR requires its argument to be of type LIST,
but it was called with an argument of type SHORT-FLOAT.
NIL
Note that in this example newlines appear in the output only as specied by the ~&and~%
directives; the actual newline characters in the control string are suppressed because each is
preceded by a tilde.
Printer22–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3.10 Additional Information about FORMAT Operations
22.3.10.1 Nesting of FORMAT Operations
The case-conversion, conditional, iteration, and justication constructs can contain other formatting
constructs by bracketing them. These constructs must nest properly with respect to each other.
For example, it is not legitimate to put the start of a case-conversion construct in each arm of a
conditional and the end of the case-conversion construct outside the conditional:
(format nil "~:[abc~:@(def~;ghi~
:@(jkl~]mno~)" x) ;Invalid!
This notation is invalid because the ~[...~;...~] and~(...~) constructs are not properly nested.
The processing indirection caused by the ~?directive is also a kind of nesting for the purposes
of this rule of proper nesting. It is not permitted to start a bracketing construct within a string
processed under control of a ~?directive and end the construct at some point after the ~?construct
in the string containing that construct, or vice versa. For example, this situation is invalid:
(format nil "~@?ghi~)" "abc~@(def") ;Invalid!
This notation is invalid because the ~?and~(...~) constructs are not properly nested.
22.3.10.2 Missing and Additional FORMAT Arguments
The consequences are undened if no argremains for a directive requiring an argument. However,
it is permissible for one or more args to remain unprocessed by a directive; such args are ignored.
22.3.10.3 Additional FORMAT Parameters
The consequences are undened if a format directive is given more parameters than it is described
here as accepting.
22.3.10.4 Undeﬁned FORMAT Modiﬁer Combinations
The consequences are undened if colon orat-sign modiers are given to a directive in a
combination not specically described here as being meaningful.
22–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3.11 Examples of FORMAT
(format nil "foo") !"foo"
(setq x 5)!5
(format nil "The answer is ~D." x) !"The answer is 5."
(format nil "The answer is ~3D." x) !"The answer is 5."
(format nil "The answer is ~3,’0D." x) !"The answer is 005."
(format nil "The answer is ~:D." (expt 47 x))
!"The answer is 229,345,007."
(setq y "elephant") !"elephant"
(format nil "Look at the ~A!" y) !"Look at the elephant!"
(setq n 3)!3
(format nil "~D item~:P found." n) !"3 items found."
(format nil "~R dog~:[s are~; is~] here." n (= n 1))
!"three dogs are here."
(format nil "~R dog~:*~[s are~; is~:;s are~] here." n)
!"three dogs are here."
(format nil "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." n)
!"Here are three puppies."
(defun foo (x)
(format nil "~6,2F|~6,2,1,’*F|~6,2„’?F|~6F|~,2F|~F"
x x x x x x))!FOO
(foo 3.14159)!" 3.14| 31.42| 3.14|3.1416|3.14|3.14159"
(foo -3.14159)!" -3.14|-31.42| -3.14|-3.142|-3.14|-3.14159"
(foo 100.0)!"100.00|******|100.00| 100.0|100.00|100.0"
(foo 1234.0)!"1234.00|******|??????|1234.0|1234.00|1234.0"
(foo 0.006)!" 0.01| 0.06| 0.01| 0.006|0.01|0.006"
(defun foo (x)
(format nil
"~9,2,1„’*E|~10,3,2,2,’?„’$E|~
~9,3,2,-2,’%@E|~9,2E"
x x x x))
(foo 3.14159)!" 3.14E+0| 31.42$-01|+.003E+03| 3.14E+0"
(foo -3.14159)!" -3.14E+0|-31.42$-01|-.003E+03| -3.14E+0"
(foo 1100.0)!" 1.10E+3| 11.00$+02|+.001E+06| 1.10E+3"
(foo 1100.0L0)!" 1.10L+3| 11.00$+02|+.001L+06| 1.10L+3"
(foo 1.1E13)!"*********| 11.00$+12|+.001E+16| 1.10E+13"
(foo 1.1L120)!"*********|??????????|%%%%%%%%%|1.10L+120"
(foo 1.1L1200)!"*********|??????????|%%%%%%%%%|1.10L+1200"
As an example of the eects of varying the scale factor, the code
(dotimes (k 13)
(format t "~%Scale factor ~2D: |~13,6,2,VE|"
Printer22–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(- k 5) (- k 5) 3.14159))
produces the following output:
Scale factor -5: | 0.000003E+06|
Scale factor -4: | 0.000031E+05|
Scale factor -3: | 0.000314E+04|
Scale factor -2: | 0.003142E+03|
Scale factor -1: | 0.031416E+02|
Scale factor 0: | 0.314159E+01|
Scale factor 1: | 3.141590E+00|
Scale factor 2: | 31.41590E-01|
Scale factor 3: | 314.1590E-02|
Scale factor 4: | 3141.590E-03|
Scale factor 5: | 31415.90E-04|
Scale factor 6: | 314159.0E-05|
Scale factor 7: | 3141590.E-06|
(defun foo (x)
(format nil "~9,2,1„’*G|~9,3,2,3,’?„’$G|~9,3,2,0,’%G|~9,2G"
x x x x))
(foo 0.0314159) !" 3.14E-2|314.2$-04|0.314E-01| 3.14E-2"
(foo 0.314159) !" 0.31 |0.314 |0.314 | 0.31 "
(foo 3.14159) !" 3.1 | 3.14 | 3.14 | 3.1 "
(foo 31.4159) !" 31. | 31.4 | 31.4 | 31. "
(foo 314.159) !" 3.14E+2| 314. | 314. | 3.14E+2"
(foo 3141.59) !" 3.14E+3|314.2$+01|0.314E+04| 3.14E+3"
(foo 3141.59L0) !" 3.14L+3|314.2$+01|0.314L+04| 3.14L+3"
(foo 3.14E12) !"*********|314.0$+10|0.314E+13| 3.14E+12"
(foo 3.14L120) !"*********|?????????|%%%%%%%%%|3.14L+120"
(foo 3.14L1200) !"*********|?????????|%%%%%%%%%|3.14L+1200"
(format nil "~10<foo~;bar~>") !"foo bar"
(format nil "~10:<foo~;bar~>") !" foo bar"
(format nil "~10<foobar~>") !" foobar"
(format nil "~10:<foobar~>") !" foobar"
(format nil "~10:@<foo~;bar~>") !" foo bar "
(format nil "~10@<foobar~>") !"foobar "
(format nil "~10:@<foobar~>") !" foobar "
(FORMAT NIL "Written to ~A." #P"foo.bin")
!"Written to foo.bin."
22–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
22.3.12 Notes about FORMAT
Formatted output is performed not only by format , but by certain other functions that accept a
format control the wayformat does. For example, error-signaling functions such as cerror accept
format controls .
Note that the meaning of nilandtas destinations to format are dierent than those of nilandt
asstream designators .
The~^should appear only at the beginning of a ~<clause, because it aborts the entire clause in
which it appears (as well as all following clauses).
Printer22–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
copy-pprint-dispatch Function
Syntax:
copy-pprint-dispatch &optional table!new-table
Arguments and Values:
table |apprint dispatch table , ornil.
new-table |afresh pprint dispatch table .
Description:
Creates and returns a copy of the specied table , or of the value of*print-pprint-dispatch* if no
table is specied, or of the initial value of*print-pprint-dispatch* ifnilis specied.
Exceptional Situations:
Should signal an error of typetype-error iftable is not a pprint dispatch table .
formatter Macro
Syntax:
formatter control-string!function
Arguments and Values:
control-string |aformat string ; not evaluated.
function |afunction .
Description:
Returns a function which has behavior equivalent to:
#’(lambda (*standard-output* &rest arguments)
(apply #’format t control-string arguments)
arguments-tail )
where arguments-tail is either the tail of arguments which has as its carthe argument that would
be processed next if there were more format directives in the control-string , or elsenilif no more
arguments follow the most recently processed argument.
Examples:
(funcall (formatter "~&~A~A") *standard-output* ’a ’b ’c)
.AB
!(C)
22–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(format t (formatter "~&~A~A") ’a ’b ’c)
.AB
!NIL
Exceptional Situations:
Might signal an error (at macro expansion time or at run time) if the argument is not a valid
format string .
See Also:
format
pprint-dispatch Function
Syntax:
pprint-dispatch object&optional table!function, found-p
Arguments and Values:
object |an object .
table |apprint dispatch table , ornil. The default is the value of*print-pprint-dispatch* .
function |afunction designator .
found-p |ageneralized boolean .
Description:
Retrieves the highest priority function in table that is associated with a type specier that matches
object . The function is chosen by nding all of the type speciers intable that match the object
and selecting the highest priority function associated with any of these type speciers . If there is
more than one highest priority function, an arbitrary choice is made. If no type speciers match
theobject , a function is returned that prints object usingprint-object .
The secondary value ,found-p , istrue if a matching type specier was found in table , or false
otherwise.
Iftable isnil, retrieval is done in the initial pprint dispatch table .
Aﬀected By:
The state of the table .
Exceptional Situations:
Should signal an error of typetype-error iftable is neither a pprint-dispatch-table nornil.
Printer22–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
(let ((*print-pretty* t))
(write object :stream s))
(funcall (pprint-dispatch object) s object)
pprint-exit-if-list-exhausted Local Macro
Syntax:
pprint-exit-if-list-exhausted hno argumentsi !nil
Description:
Tests whether or not the listpassed to the lexically current logical block has been exhausted; see
Section 22.2.1.1 (Dynamic Control of the Arrangement of Output). If this listhas been reduced
tonil,pprint-exit-if-list-exhausted terminates the execution of the lexically current logical block
except for the printing of the sux. Otherwise pprint-exit-if-list-exhausted returnsnil.
Whether or not pprint-exit-if-list-exhausted isfbound in the global environment isimplementation-
dependent ; however, the restrictions on redenition and shadowing ofpprint-exit-if-list-exhausted
are the same as for symbols in theCOMMON-LISP package which are fbound in the global environment .
The consequences of attempting to use pprint-exit-if-list-exhausted outside of pprint-logical-block
are undened.
Exceptional Situations:
An error is signaled (at macro expansion time or at run time) if pprint-exit-if-list-exhausted is
used anywhere other than lexically within a call on pprint-logical-block . Also, the consequences
of executing pprint-if-list-exhausted outside of the dynamic extent of the pprint-logical-block
which lexically contains it are undened.
See Also:
pprint-logical-block ,pprint-pop .
22–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pprint-ﬁll, pprint-linear, pprint-tabular
pprint-ﬁll,pprint-linear,pprint-tabular Function
Syntax:
pprint-ﬁll stream object &optional colon-p at-sign-p !nil
pprint-linear stream object &optional colon-p at-sign-p !nil
pprint-tabular stream object &optional colon-p at-sign-p tabsize !nil
Arguments and Values:
stream |an output stream designator .
object |an object .
colon-p |ageneralized boolean . The default is true.
at-sign-p |ageneralized boolean . The default is implementation-dependent .
tabsize |a non-negative integer . The default is 16.
Description:
The functions pprint-ﬁll ,pprint-linear , andpprint-tabular specify particular ways of pretty
printing alisttostream . Each function prints parentheses around the output if and only if colon-p
istrue. Each function ignores its at-sign-p argument. (Both arguments are included even though
only one is needed so that these functions can be used via ~/.../ and asset-pprint-dispatch
functions, as well as directly.) Each function handles abbreviation and the detection of circularity
and sharing correctly, and uses write to print object when it is a non-list .
Ifobject is alistand if the value of*print-pretty* isfalse, each of these functions prints object
using a minimum of whitespace , as described in Section 22.1.3.5 (Printing Lists and Conses).
Otherwise (if object is alistand if the value of*print-pretty* istrue):
The function pprint-linear prints a listeither all on one line, or with each element on a
separate line.
The functionpprint-ﬁll prints a listwith as many elements as possible on each line.
The function pprint-tabular is the same as pprint-ﬁll except that it prints the elements
so that they line up in columns. The tabsize species the column spacing in ems, which is
the total spacing from the leading edge of one column to the leading edge of the next.
Examples:
Evaluating the following with a line length of 25produces the output shown.
(progn (princ "Roads ")
Printer22–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(pprint-tabular *standard-output* ’(elm main maple center) nil nil 8))
Roads ELM MAIN
MAPLE CENTER
Side Eﬀects:
Performs output to the indicated stream .
Aﬀected By:
The cursor position on the indicated stream , if it can be determined.
Notes:
The functionpprint-tabular could be dened as follows:
(defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))
(declare (ignore at-sign-p))
(when (null tabsize) (setq tabsize 16))
(pprint-logical-block (s list :prefix (if colon-p "(" "")
:suffix (if colon-p ")" ""))
(pprint-exit-if-list-exhausted)
(loop (write (pprint-pop) :stream s)
(pprint-exit-if-list-exhausted)
(write-char #\Space s)
(pprint-tab :section-relative 0 tabsize s)
(pprint-newline :fill s))))
Note that it would have been inconvenient to specify this function using format , because of the
need to pass its tabsize argument through to a ~:Tformat directive nested within an iteration over
a list.
pprint-indent Function
Syntax:
pprint-indent relative-to n &optional stream!nil
Arguments and Values:
relative-to |either :block or:current .
n|areal.
stream |an output stream designator . The default is standard output .
22–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
pprint-indent species the indentation to use in a logical block on stream . If stream is a pretty
printing stream and the value of*print-pretty* istrue,pprint-indent sets the indentation in the
innermost dynamically enclosing logical block; otherwise, pprint-indent has no eect.
Nspecies the indentation in ems. Ifrelative-to is:block , the indentation is set to the horizontal
position of the rst character in the dynamically current logical block plus nems. If relative-to is
:current , the indentation is set to the current output position plus nems. (For robustness in the
face of variable-width fonts, it is advisable to use :current with an nof zero whenever possible.)
Ncan be negative; however, the total indentation cannot be moved left of the beginning of the
line or left of the end of the rightmost per-line prex|an attempt to move beyond one of these
limits is treated the same as an attempt to move to that limit. Changes in indentation caused by
pprint-indent do not take eect until after the next line break. In addition, in miser mode all calls
topprint-indent are ignored, forcing the lines corresponding to the logical block to line up under
the rst character in the block.
Exceptional Situations:
An error is signaled if relative-to is any object other than :block or:current .
See Also:
Section 22.3.5.3 (Tilde I: Indent)
pprint-logical-block Macro
Syntax:
pprint-logical-block (stream-symbol object &key prex per-line-prex sux )
fdeclarationg*fformg*
!nil
Arguments and Values:
stream-symbol |astream variable designator .
object |an object ; evaluated.
:prefix |astring ; evaluated. Complicated defaulting behavior; see below.
:per-line-prefix |astring ; evaluated. Complicated defaulting behavior; see below.
:suffix |astring ; evaluated. The default is the null string .
declaration |adeclare expression ; not evaluated.
forms |an implicit progn .
Printer22–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pprint-logical-block
Description:
Causes printing to be grouped into a logical block.
The logical block is printed to the stream that is the value of the variable denoted by stream-symbol .
During the execution of the forms , that variable isbound to a pretty printing stream that supports
decisions about the arrangement of output and then forwards the output to the destination stream.
All the standard printing functions ( e.g.,write ,princ , andterpri ) can be used to print output to
thepretty printing stream . All and only the output sent to this pretty printing stream is treated as
being in the logical block.
The prex species a prex to be printed before the beginning of the logical block. The per-line-prex
species a prex that is printed before the block and at the beginning of each new line in the
block. The :prefix and:pre-line-prefix arguments are mutually exclusive. If neither :prefix nor
:per-line-prefix is specied, a prex of the null string is assumed.
The sux species a sux that is printed just after the logical block.
The object is normally a listthat the body forms are responsible for printing. If object is not a list,
it is printed using write . (This makes it easier to write printing functions that are robust in the face
of malformed arguments.) If *print-circle* isnon-nil and object is a circular (or shared) reference
to a cons, then an appropriate \ #n#" marker is printed. (This makes it easy to write printing
functions that provide full support for circularity and sharing abbreviation.) If *print-level* is
notniland the logical block is at a dynamic nesting depth of greater than *print-level* in logical
blocks, \ #" is printed. (This makes easy to write printing functions that provide full support for
depth abbreviation.)
If either of the three conditions above occurs, the indicated output is printed on stream-symbol
and the body forms are skipped along with the printing of the :prefix and:suffix . (If the body
forms are not to be responsible for printing a list, then the rst two tests above can be turned o
by supplying nilfor the object argument.)
In addition to the object argument of pprint-logical-block , the arguments of the standard printing
functions (such as write ,print ,prin1 , andpprint , as well as the arguments of the standard format
directives such as ~A,~S, (and~W) are all checked (when necessary) for circularity and sharing.
However, such checking is not applied to the arguments of the functions write-line ,write-string ,
andwrite-char or to the literal text output by format . A consequence of this is that you must use
one of the latter functions if you want to print some literal text in the output that is not supposed
to be checked for circularity or sharing.
The body forms of apprint-logical-block form must not perform any side-eects on the
surrounding environment; for example, no variables must be assigned which have not been bound
within its scope.
Thepprint-logical-block macro may be used regardless of the value of*print-pretty* .
Aﬀected By:
*print-circle* ,*print-level* .
22–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Exceptional Situations:
An error of typetype-error is signaled if any of the :suffix ,:prefix , or:per-line-prefix is
supplied but does not evaluate to a string .
An error is signaled if :prefix and:pre-line-prefix are both used.
pprint-logical-block and the pretty printing stream it creates have dynamic extent . The
consequences are undened if, outside of this extent, output is attempted to the pretty printing
stream it creates.
It is also unspecied what happens if, within this extent, any output is sent directly to the
underlying destination stream.
See Also:
pprint-pop ,pprint-exit-if-list-exhausted , Section 22.3.5.2 (Tilde Less-Than-Sign: Logical Block)
Notes:
One reason for using the pprint-logical-block macro when the value of*print-pretty* isnilwould
be to allow it to perform checking for dotted lists , as well as (in conjunction with pprint-pop )
checking for *print-level* or*print-length* being exceeded.
Detection of circularity and sharing is supported by the pretty printer by in essence performing
requested output twice. On the rst pass, circularities and sharing are detected and the actual
outputting of characters is suppressed. On the second pass, the appropriate \ #n=" and \#n#"
markers are inserted and characters are output. This is why the restriction on side-eects is
necessary. Obeying this restriction is facilitated by using pprint-pop , instead of an ordinary pop
when traversing a list being printed by the body forms of thepprint-logical-block form .)
pprint-newline Function
Syntax:
pprint-newline kind&optional stream!nil
Arguments and Values:
kind|one of :linear ,:fill ,:miser , or:mandatory .
stream |astream designator . The default is standard output .
Description:
Ifstream is apretty printing stream and the value of*print-pretty* istrue, a line break is inserted
in the output when the appropriate condition below is satised; otherwise, pprint-newline has no
eect.
Kind species the style of conditional newline. This parameter is treated as follows:
Printer22–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pprint-newline
:linear
This species a \linear-style" conditional newline . A line break is inserted if and only if the
immediately containing section cannot be printed on one line. The eect of this is that line
breaks are either inserted at every linear-style conditional newline in a logical block or at none
of them.
:miser
This species a \miser-style" conditional newline . A line break is inserted if and only if the
immediately containing section cannot be printed on one line and miser style is in eect in the
immediately containing logical block. The eect of this is that miser-style conditional newlines
act like linear-style conditional newlines, but only when miser style is in eect. Miser style is
in eect for a logical block if and only if the starting position of the logical block is less than
or equal to *print-miser-width* ems from the right margin.
:fill
This species a \ll-style" conditional newline . A line break is inserted if and only if either (a)
the following section cannot be printed on the end of the current line, (b) the preceding section
was not printed on a single line, or (c) the immediately containing section cannot be printed
on one line and miser style is in eect in the immediately containing logical block. If a logical
block is broken up into a number of subsections by ll-style conditional newlines, the basic
eect is that the logical block is printed with as many subsections as possible on each line.
However, if miser style is in eect, ll-style conditional newlines act like linear-style conditional
newlines.
:mandatory
This species a \mandatory-style" conditional newline . A line break is always inserted. This
implies that none of the containing sections can be printed on a single line and will therefore
trigger the insertion of line breaks at linear-style conditional newlines in these sections .
When a line break is inserted by any type of conditional newline, any blanks that immediately
precede the conditional newline are omitted from the output and indentation is introduced at the
beginning of the next line. By default, the indentation causes the following line to begin in the
same horizontal position as the rst character in the immediately containing logical block. (The
indentation can be changed via pprint-indent .)
There are a variety of ways unconditional newlines can be introduced into the output ( i.e., via
terpri or by printing a string containing a newline character). As with mandatory conditional
newlines, this prevents any of the containing sections from being printed on one line. In general,
when an unconditional newline is encountered, it is printed out without suppression of the preceding
blanks and without any indentation following it. However, if a per-line prex has been specied
(seepprint-logical-block ), this prex will always be printed no matter how a newline originates.
22–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
See Section 22.2.2 (Examples of using the Pretty Printer).
Side Eﬀects:
Output to stream .
Aﬀected By:
*print-pretty* ,*print-miser* . The presence of containing logical blocks. The placement of
newlines and conditional newlines.
Exceptional Situations:
An error of typetype-error is signaled if kind is not one of :linear ,:fill ,:miser , or:mandatory .
See Also:
Section 22.3.5.1 (Tilde Underscore: Conditional Newline), Section 22.2.2 (Examples of using the
Pretty Printer)
pprint-pop Local Macro
Syntax:
pprint-pophno argumentsi ! object
Arguments and Values:
object |an element of the listbeing printed in the lexically current logical block , ornil.
Description:
Pops one element from the listbeing printed in the lexically current logical block , obeying
*print-length* and*print-circle* as described below.
Each time pprint-pop is called, it pops the next value o the listpassed to the lexically current
logical block and returns it. However, before doing this, it performs three tests:
If the remaining `list' is not a list, \." is printed followed by the remaining `list.' (This makes
it easier to write printing functions that are robust in the face of malformed arguments.)
If*print-length* isnon-nil , andpprint-pop has already been called *print-length* times
within the immediately containing logical block, \ ..." is printed. (This makes it easy to write
printing functions that properly handle *print-length* .)
Printer22–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
If*print-circle* isnon-nil , and the remaining list is a circular (or shared) reference, then
\." is printed followed by an appropriate \ #n#" marker. (This catches instances of cdr
circularity and sharing in lists.)
If either of the three conditions above occurs, the indicated output is printed on the pretty printing
stream created by the immediately containing pprint-logical-block and the execution of the
immediately containing pprint-logical-block is terminated except for the printing of the sux.
Ifpprint-logical-block is given a `list' argument of nil|because it is not processing a list|
pprint-pop can still be used to obtain support for *print-length* . In this situation, the rst and
third tests above are disabled and pprint-pop always returns nil. See Section 22.2.2 (Examples of
using the Pretty Printer)|specically, the pprint-vector example.
Whether or not pprint-pop isfbound in the global environment isimplementation-dependent ;
however, the restrictions on redenition and shadowing ofpprint-pop are the same as for symbols
in theCOMMON-LISP package which are fbound in the global environment . The consequences of
attempting to use pprint-pop outside of pprint-logical-block are undened.
Side Eﬀects:
Might cause output to the pretty printing stream associated with the lexically current logical block.
Aﬀected By:
*print-length* ,*print-circle* .
Exceptional Situations:
An error is signaled (either at macro expansion time or at run time) if a usage of pprint-pop
occurs where there is no lexically containing pprint-logical-block form .
The consequences are undened if pprint-pop is executed outside of the dynamic extent of this
pprint-logical-block .
See Also:
pprint-exit-if-list-exhausted ,pprint-logical-block .
Notes:
It is frequently a good idea to call pprint-exit-if-list-exhausted before calling pprint-pop .
pprint-tab Function
Syntax:
pprint-tab kind colnum colinc &optional stream!nil
22–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments and Values:
kind|one of :line ,:section ,:line-relative , or:section-relative .
colnum |a non-negative integer .
colinc |a non-negative integer .
stream |an output stream designator .
Description:
Species tabbing to stream as performed by the standard ~Tformat directive. If stream is a
pretty printing stream and the value of*print-pretty* istrue, tabbing is performed; otherwise,
pprint-tab has no eect.
The arguments colnum and colinc correspond to the two parameters to~Tand are in terms of ems.
The kind argument species the style of tabbing. It must be one of :line (tab as by ~T),:section
(tab as by ~:T, but measuring horizontal positions relative to the start of the dynamically enclosing
section), :line-relative (tab as by ~@T), or:section-relative (tab as by ~:@T, but measuring
horizontal positions relative to the start of the dynamically enclosing section).
Exceptional Situations:
An error is signaled if kind is not one of :line ,:section ,:line-relative , or:section-relative .
See Also:
pprint-logical-block
print-object Standard Generic Function
Syntax:
print-object object stream!object
Method Signatures:
print-object (object standard-object )stream
print-object (object structure-object )stream
Arguments and Values:
object |an object .
stream |astream .
Printer22–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
print-object
Description:
The generic function print-object writes the printed representation of object tostream . The
functionprint-object is called by the Lisp printer ; it should not be called by the user.
Each implementation is required to provide a method on the classstandard-object and on the
classstructure-object . In addition, each implementation must provide methods on enough other
classes so as to ensure that there is always an applicable method . Implementations are free to add
methods for other classes . Users may write methods forprint-object for their own classes if they
do not wish to inherit an implementation-dependent method .
The method on the classstructure-object prints the object in the default #Snotation; see Section
22.1.3.12 (Printing Structures).
Methods onprint-object are responsible for implementing their part of the semantics of the printer
control variables , as follows:
*print-readably*
All methods for print-object must obey *print-readably* . This includes both user-dened
methods and implementation-dened methods. Readable printing of structures and standard
objects is controlled by their print-object method, not by their make-load-form method .
Similarity for these objects is application dependent and hence is dened to be whatever these
methods do; see Section 3.2.4.2 (Similarity of Literal Objects).
*print-escape*
Each method must implement *print-escape* .
*print-pretty*
The method may wish to perform specialized line breaking or other output conditional on the
value of*print-pretty* . For further information, see (for example) the macropprint-ﬁll . See
also Section 22.2.1.4 (Pretty Print Dispatch Tables) and Section 22.2.2 (Examples of using the
Pretty Printer).
*print-length*
Methods that produce output of indenite length must obey *print-length* . For further
information, see (for example) the macrospprint-logical-block andpprint-pop . See also
Section 22.2.1.4 (Pretty Print Dispatch Tables) and Section 22.2.2 (Examples of using the
Pretty Printer).
*print-level*
The printer takes care of *print-level* automatically, provided that each method handles
exactly one level of structure and calls write (or an equivalent function ) recursively if there
are more structural levels. The printer's decision of whether an object has components (and
22–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
therefore should not be printed when the printing depth is not less than *print-level* ) is
implementation-dependent . In some implementations its print-object method is not called; in
others the method is called, and the determination that the object has components is based on
what it tries to write to the stream .
*print-circle*
When the value of*print-circle* istrue, a user-dened print-object method can print objects
to the supplied stream usingwrite ,prin1 ,princ , orformat and expect circularities to be
detected and printed using the #n#syntax. If a user-dened print-object method prints to a
stream other than the one that was supplied, then circularity detection starts over for that
stream . See*print-circle* .
*print-base* ,*print-radix* ,*print-case* ,*print-gensym* , and*print-array*
These printer control variables apply to specic types of objects and are handled by the
methods for those objects .
If these rules are not obeyed, the results are undened.
In general, the printer and the print-object methods should not rebind the print control variables
as they operate recursively through the structure, but this is implementation-dependent .
In some implementations the stream argument passed to a print-object method is not the original
stream , but is an intermediate stream that implements part of the printer. methods should therefore
not depend on the identity of this stream .
See Also:
pprint-ﬁll ,pprint-logical-block ,pprint-pop ,write ,*print-readably* ,*print-escape* ,
*print-pretty* ,*print-length* , Section 22.1.3 (Default Print-Object Methods), Section 22.1.3.12
(Printing Structures), Section 22.2.1.4 (Pretty Print Dispatch Tables), Section 22.2.2 (Examples of
using the Pretty Printer)
print-unreadable-object Macro
Syntax:
print-unreadable-object (object stream &key type identity )fformg*!nil
Arguments and Values:
object |an object ; evaluated.
stream |astream designator ; evaluated.
type|ageneralized boolean ; evaluated.
Printer22–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
identity |ageneralized boolean ; evaluated.
forms |an implicit progn .
Description:
Outputs a printed representation of object onstream , beginning with \ #<" and ending with \ >".
Everything output to stream by the body forms is enclosed in the the angle brackets. If type istrue,
the output from forms is preceded by a brief description of the object 'stype and a space character.
Ifidentity istrue, the output from forms is followed by a space character and a representation of
theobject 's identity, typically a storage address.
If either type oridentity is not supplied, its value is false. It is valid to omit the body forms . If
type and identity are both true and there are no body forms , only one space character separates
the type and the identity.
Examples:
;; Note that in this example, the precise form of the output ;; is implementation-dependent .
(defmethod print-object ((obj airplane) stream)
(print-unreadable-object (obj stream :type t :identity t)
(princ (tail-number obj) stream)))
(prin1-to-string my-airplane)
!"#<Airplane NW0773 36000123135>"
or!"#<FAA:AIRPLANE NW0773 17>"
Exceptional Situations:
If*print-readably* istrue,print-unreadable-object signals an error of typeprint-not-readable
without printing anything.
set-pprint-dispatch Function
Syntax:
set-pprint-dispatch type-specier function &optional priority table!nil
Arguments and Values:
type-specier |atype specier .
function |afunction , afunction name , ornil.
priority |areal. The default is 0.
table |apprint dispatch table . The default is the value of*print-pprint-dispatch* .
22–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Installs an entry into the pprint dispatch table which is table .
Type-specier is the keyof the entry. The rst action of set-pprint-dispatch is to remove any
pre-existing entry associated with type-specier . This guarantees that there will never be two
entries associated with the same type specier in a given pprint dispatch table . Equality of type
speciers is tested by equal .
Two values are associated with each type specier in a pprint dispatch table : afunction and a
priority . The function must accept two arguments: the stream to which output is sent and the object
to be printed. The function should pretty print theobject to the stream . The function can assume
that object satises the type given by type-specier . The function must obey *print-readably* .
Any values returned by the function are ignored.
Priority is a priority to resolve conicts when an object matches more than one entry.
It is permissible for function to benil. In this situation, there will be no type-specier entry in table
afterset-pprint-dispatch returns.
Exceptional Situations:
An error is signaled if priority is not a real.
Notes:
Since pprint dispatch tables are often used to control the pretty printing of Lisp code, it is common
for the type-specier to be an expression of the form
(cons car-type cdr-type )
This signies that the corresponding object must be a cons cell whose carmatches the type specier
car-type and whose cdrmatches the type specier cdr-type . The cdr-type can be omitted in which
case it defaults to t.
write,prin1,print,pprint,princ Function
Syntax:
write object&key array base case circle escape gensym
length level lines miser-width pprint-dispatch
pretty radix readably right-margin stream
!object
prin1 object&optional output-stream!object
princ object&optional output-stream!object
Printer22–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
write, prin1, print, pprint, princ
print object&optional output-stream!object
pprint object&optional output-stream!hno valuesi
Arguments and Values:
object |an object .
output-stream |an output stream designator . The default is standard output .
array |ageneralized boolean .
base|aradix .
case|asymbol oftype(member :upcase :downcase :capitalize) .
circle |ageneralized boolean .
escape |ageneralized boolean .
gensym |ageneralized boolean .
length |a non-negative integer , ornil.
level|a non-negative integer , ornil.
lines|a non-negative integer , ornil.
miser-width |a non-negative integer , ornil.
pprint-dispatch |apprint dispatch table .
pretty |ageneralized boolean .
radix |ageneralized boolean .
readably |ageneralized boolean .
right-margin |a non-negative integer , ornil.
stream |an output stream designator . The default is standard output .
Description:
write ,prin1 ,princ ,print , andpprint write the printed representation of object tooutput-stream .
write is the general entry point to the Lisp printer . For each explicitly supplied keyword parameter
named in Figure 22{7, the corresponding printer control variable is dynamically bound to its value
while printing goes on; for each keyword parameter in Figure 22{7 that is not explicitly supplied,
the value of the corresponding printer control variable is the same as it was at the time write was
invoked. Once the appropriate bindings areestablished , the object is output by the Lisp printer .
22–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
write, prin1, print, pprint, princ
Parameter Corresponding Dynamic Variable
array *print-array*
base *print-base*
case *print-case*
circle *print-circle*
escape *print-escape*
gensym *print-gensym*
length *print-length*
level *print-level*
lines *print-lines*
miser-width *print-miser-width*
pprint-dispatch *print-pprint-dispatch*
pretty *print-pretty*
radix *print-radix*
readably *print-readably*
right-margin *print-right-margin*
Figure 22–7. Argument correspondences for the WRITE function.
prin1 ,princ ,print , andpprint implicitly bind certain print parameters to particu-
lar values. The remaining parameter values are taken from *print-array* ,*print-base* ,
*print-case* ,*print-circle* ,*print-escape* ,*print-gensym* ,*print-length* ,*print-level* ,
*print-lines* ,*print-miser-width* ,*print-pprint-dispatch* ,*print-pretty* ,*print-radix* , and
*print-right-margin* .
prin1 produces output suitable for input to read. It binds *print-escape* totrue.
princ is just like prin1 except that the output has no escape characters . It binds *print-escape*
tofalse and*print-readably* tofalse. The general rule is that output from princ is intended to
look good to people, while output from prin1 is intended to be acceptable to read.
print is just like prin1 except that the printed representation of object is preceded by a newline
and followed by a space.
pprint is just like print except that the trailing space is omitted and object is printed with the
*print-pretty* agnon-nil to produce pretty output.
Output-stream species the stream to which output is to be sent.
Aﬀected By:
*standard-output* ,*terminal-io* ,*print-escape* ,*print-radix* ,*print-base* ,*print-circle* ,
*print-pretty* ,*print-level* ,*print-length* ,*print-case* ,*print-gensym* ,*print-array* ,
*read-default-ﬂoat-format* .
Printer22–63
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
readtable-case , Section 22.3.4 (FORMAT Printer Operations)
Notes:
The functions prin1 andprint do not bind *print-readably* .
(prin1 object output-stream)
(write object :stream output-stream :escape t)
(princ object output-stream)
(write object stream output-stream :escape nil :readably nil)
(print object output-stream)
(progn (terpri output-stream)
(write object :stream output-stream
:escape t)
(write-char #\space output-stream))
(pprint object output-stream)
(write object :stream output-stream :escape t :pretty t)
write-to-string,prin1-to-string,princ-to-string
Function
Syntax:
write-to-string object&key array base case circle escape gensym
length level lines miser-width pprint-dispatch
pretty radix readably right-margin
!string
prin1-to-string object!string
princ-to-string object!string
Arguments and Values:
object |an object .
array |ageneralized boolean .
base|aradix .
22–64 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
write-to-string, prin1-to-string, princ-to-string
case|asymbol oftype(member :upcase :downcase :capitalize) .
circle |ageneralized boolean .
escape |ageneralized boolean .
gensym |ageneralized boolean .
length |a non-negative integer , ornil.
level|a non-negative integer , ornil.
lines|a non-negative integer , ornil.
miser-width |a non-negative integer , ornil.
pprint-dispatch |apprint dispatch table .
pretty |ageneralized boolean .
radix |ageneralized boolean .
readably |ageneralized boolean .
right-margin |a non-negative integer , ornil.
string |astring .
Description:
write-to-string ,prin1-to-string , andprinc-to-string are used to create a string consisting of
the printed representation of object .Object is eectively printed as if by write ,prin1 , orprinc ,
respectively, and the characters that would be output are made into a string .
write-to-string is the general output function. It has the ability to specify all the parameters
applicable to the printing of object .
prin1-to-string acts like write-to-string with:escape t , that is, escape characters are written
where appropriate.
princ-to-string acts like write-to-string with:escape nil :readably nil . Thus no escape
characters are written.
All other keywords that would be specied to write-to-string are default values when
prin1-to-string orprinc-to-string is invoked.
The meanings and defaults for the keyword arguments to write-to-string are the same as those for
write .
Examples:
(prin1-to-string "abc") !"\"abc\""
Printer22–65
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(princ-to-string "abc") !"abc"
Aﬀected By:
*print-escape* ,*print-radix* ,*print-base* ,*print-circle* ,*print-pretty* ,*print-level* ,
*print-length* ,*print-case* ,*print-gensym* ,*print-array* ,*read-default-ﬂoat-format* .
See Also:
write
Notes:
(write-to-string objectfkey argumentg*)
(with-output-to-string (#1=#:string-stream)
(write object :stream #1# fkey argumentg*))
(princ-to-string object)
(with-output-to-string (string-stream)
(princ objectstring-stream))
(prin1-to-string object)
(with-output-to-string (string-stream)
(prin1 objectstring-stream))
print-array Variable
Value Type:
ageneralized boolean .
Initial Value:
implementation-dependent .
Description:
Controls the format in which arrays are printed. If it is false, the contents of arrays other than
strings are never printed. Instead, arrays are printed in a concise form using #<that gives enough
information for the user to be able to identify the array , but does not include the entire array
contents. If it is true, non- string arrays are printed using #(...) ,#*, or#nAsyntax.
Aﬀected By:
The implementation .
22–66 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
Section 2.4.8.3 (Sharpsign Left-Parenthesis), Section 2.4.8.20 (Sharpsign Less-Than-Sign)
print-base,print-radix Variable
Value Type:
*print-base* |aradix .*print-radix* |ageneralized boolean .
Initial Value:
The initial value of*print-base* is10. The initial value of*print-radix* isfalse.
Description:
*print-base* and*print-radix* control the printing of rationals . The value of*print-base* is
called the current output base .
The value of*print-base* is the radix in which the printer will print rationals . For radices above
10, letters of the alphabet are used to represent digits above 9.
If the value of*print-radix* istrue, the printer will print a radix specier to indicate the radix
in which it is printing a rational number. The radix specier is always printed using lowercase
letters. If *print-base* is2,8, or16, then the radix specier used is #b,#o, or#x, respectively. For
integers , base ten is indicated by a trailing decimal point instead of a leading radix specier; for
ratios ,#10r is used.
Examples:
(let ((*print-base* 24.) (*print-radix* t))
(print 23.))
.#24rN
!23
(setq *print-base* 10) !10
(setq *print-radix* nil) !NIL
(dotimes (i 35)
(let ((*print-base* (+ i 2))) ;print the decimal number 40
(write 40) ;in each base from 2 to 36
(if (zerop (mod i 10)) (terpri) (format t " "))))
.101000
.1111 220 130 104 55 50 44 40 37 34
.31 2C 2A 28 26 24 22 20 1J 1I
.1H 1G 1F 1E 1D 1C 1B 1A 19 18
.17 16 15 14
!NIL
(dolist (pb ’(2 3 8 10 16))
Printer22–67
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(let ((*print-radix* t) ;print the integer 10 and
(*print-base* pb)) ;the ratio 1/10 in bases 2,
(format t "~&~S ~S~%" 10 1/10))) ;3, 8, 10, 16
.#b1010 #b1/1010
.#3r101 #3r1/101
.#o12 #o1/12
.10. #10r1/10
.#xA #x1/A
!NIL
Aﬀected By:
Might be bound byformat , andwrite ,write-to-string .
See Also:
format ,write ,write-to-string
print-case Variable
Value Type:
One of the symbols :upcase ,:downcase , or:capitalize .
Initial Value:
The symbol:upcase .
Description:
The value of*print-case* controls the case (upper, lower, or mixed) in which to print any
uppercase characters in the names of symbols when vertical-bar syntax is not used.
*print-case* has an eect at all times when the value of*print-escape* isfalse.*print-case* also
has an eect when the value of*print-escape* istrue unless inside an escape context ( i.e., unless
between vertical-bars or after a slash ).
Examples:
(defun test-print-case ()
(dolist (*print-case* ’(:upcase :downcase :capitalize))
(format t "~&~S ~S~%" ’this-and-that ’|And-something-elSE|)))
!TEST-PC
;; Although the choice of which characters to escape is specified by
;; *PRINT-CASE*, the choice of how to escape those characters
;; (i.e., whether single escapes or multiple escapes are used)
;; is implementation-dependent. The examples here show two of the
;; many valid ways in which escaping might appear.
22–68 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(test-print-case) ;Implementation A
.THIS-AND-THAT |And-something-elSE|
.this-and-that a\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
.This-And-That A\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
!NIL
(test-print-case) ;Implementation B
.THIS-AND-THAT |And-something-elSE|
.this-and-that a|nd-something-el|se
.This-And-That A|nd-something-el|se
!NIL
See Also:
write
Notes:
read normally converts lowercase characters appearing in symbols to corresponding uppercase
characters, so that internally print names normally contain only uppercase characters.
If*print-escape* istrue, lowercase characters in the name of a symbol are always printed in
lowercase, and are preceded by a single escape character or enclosed by multiple escape characters;
uppercase characters in the name of a symbol are printed in upper case, in lower case, or in mixed
case so as to capitalize words, according to the value of *print-case* . The convention for what
constitutes a \word" is the same as for string-capitalize .
print-circle Variable
Value Type:
ageneralized boolean .
Initial Value:
false.
Description:
Controls the attempt to detect circularity and sharing in an object being printed.
Iffalse, the printing process merely proceeds by recursive descent without attempting to detect
circularity and sharing.
Iftrue, the printer will endeavor to detect cycles and sharing in the structure to be printed, and to
use#n=and#n#syntax to indicate the circularities or shared components.
Iftrue, a user-dened print-object method can print objects to the supplied stream usingwrite ,
prin1 ,princ , orformat and expect circularities and sharing to be detected and printed using the
Printer22–69
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
#n#syntax. If a user-dened print-object method prints to a stream other than the one that was
supplied, then circularity detection starts over for that stream .
Note that implementations should not use #n#notation when the Lisp reader would automatically
assure sharing without it ( e.g., as happens with interned symbols ).
Examples:
(let ((a (list 1 2 3)))
(setf (cdddr a) a)
(let ((*print-circle* t))
(write a)
:done))
.#1=(1 2 3 . #1#)
!:DONE
See Also:
write
Notes:
An attempt to print a circular structure with *print-circle* set tonilmay lead to looping behavior
and failure to terminate.
print-escape Variable
Value Type:
ageneralized boolean .
Initial Value:
true.
Description:
Iffalse, escape characters and package prexes are not output when an expression is printed.
Iftrue, an attempt is made to print an expression in such a way that it can be read again to
produce an equal expression . (This is only a guideline; not a requirement. See *print-readably* .)
For more specic details of how the value of*print-escape* aects the printing of certain types ,
see Section 22.1.3 (Default Print-Object Methods).
Examples:
(let ((*print-escape* t)) (write #\a))
22–70 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.#\a
!#\a
(let ((*print-escape* nil)) (write #\a))
.a
!#\a
Aﬀected By:
princ ,prin1 ,format
See Also:
write ,readtable-case
Notes:
princ eectively binds *print-escape* tofalse.prin1 eectively binds *print-escape* totrue.
print-gensym Variable
Value Type:
ageneralized boolean .
Initial Value:
true.
Description:
Controls whether the prex \ #:" is printed before apparently uninterned symbols . The prex is
printed before such symbols if and only if the value of*print-gensym* istrue.
Examples:
(let ((*print-gensym* nil))
(print (gensym)))
.G6040
!#:G6040
See Also:
write ,*print-escape*
Printer22–71
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
print-level,print-length
print-level,print-length Variable
Value Type:
a non-negative integer , ornil.
Initial Value:
nil.
Description:
*print-level* controls how many levels deep a nested object will print. If it is false, then no control
is exercised. Otherwise, it is an integer indicating the maximum level to be printed. An object to
be printed is at level 0; its components (as of a listorvector ) are at level 1; and so on. If an object
to be recursively printed has components and is at a level equal to or greater than the value of
*print-level* , then the object is printed as \ #".
*print-length* controls how many elements at a given level are printed. If it is false, there is no
limit to the number of components printed. Otherwise, it is an integer indicating the maximum
number of elements of an object to be printed. If exceeded, the printer will print \ ..." in place of
the other elements . In the case of a dotted list , if the listcontains exactly as many elements as the
value of*print-length* , the terminating atom is printed rather than printing \ ..."
*print-level* and*print-length* aect the printing of an any object printed with a list-like syntax.
They do not aect the printing of symbols ,strings , and bit vectors .
Examples:
(setq a ’(1 (2 (3 (4 (5 (6))))))) !(1 (2 (3 (4 (5 (6))))))
(dotimes (i 8)
(let ((*print-level* i))
(format t "~&~D – ~S~%" i a)))
.0 – #
.1 – (1 #)
.2 – (1 (2 #))
.3 – (1 (2 (3 #)))
.4 – (1 (2 (3 (4 #))))
.5 – (1 (2 (3 (4 (5 #)))))
.6 – (1 (2 (3 (4 (5 (6))))))
.7 – (1 (2 (3 (4 (5 (6))))))
!NIL
(setq a ’(1 2 3 4 5 6)) !(1 2 3 4 5 6)
(dotimes (i 7)
(let ((*print-length* i))
22–72 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(format t "~&~D – ~S~%" i a)))
.0 – (...)
.1 – (1 ...)
.2 – (1 2 ...)
.3 – (1 2 3 ...)
.4 – (1 2 3 4 ...)
.5 – (1 2 3 4 5 6)
.6 – (1 2 3 4 5 6)
!NIL
(dolist (level-length ’((0 1) (1 1) (1 2) (1 3) (1 4)
(2 1) (2 2) (2 3) (3 2) (3 3) (3 4)))
(let ((*print-level* (first level-length))
(*print-length* (second level-length)))
(format t "~&~D ~D – ~S~%"
*print-level* *print-length*
’(if (member x y) (+ (car x) 3) ’(foo . #(a b c d "Baz"))))))
.0 1 – #
.1 1 – (IF ...)
.1 2 – (IF # ...)
.1 3 – (IF # # ...)
.1 4 – (IF # # #)
.2 1 – (IF ...)
.2 2 – (IF (MEMBER X ...) ...)
.2 3 – (IF (MEMBER X Y) (+ # 3) ...)
.3 2 – (IF (MEMBER X ...) ...)
.3 3 – (IF (MEMBER X Y) (+ (CAR X) 3) ...)
.3 4 – (IF (MEMBER X Y) (+ (CAR X) 3) ’(FOO . #(A B C D ...)))
!NIL
See Also:
write
print-lines Variable
Value Type:
a non-negative integer , ornil.
Initial Value:
nil.
Printer22–73
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
When the value of*print-lines* is other than nil, it is a limit on the number of output lines
produced when something is pretty printed. If an attempt is made to go beyond that many lines,
\.." is printed at the end of the last line followed by all of the suxes (closing delimiters) that are
pending to be printed.
Examples:
(let ((*print-right-margin* 25) (*print-lines* 3))
(pprint ’(progn (setq a 1 b 2 c 3 d 4))))
.(PROGN (SETQ A 1
. B 2
. C 3 ..))
!hno valuesi
Notes:
The \.." notation is intentionally dierent than the \ ..." notation used for level abbreviation, so
that the two dierent situations can be visually distinguished.
This notation is used to increase the likelihood that the Lisp reader will signal an error if an
attempt is later made to read the abbreviated output. Note however that if the truncation occurs
in a string , as in"This string has been trunc.." , the problem situation cannot be detected later
and no such error will be signaled.
print-miser-width  Variable
Value Type:
a non-negative integer , ornil.
Initial Value:
implementation-dependent
Description:
If it is not nil, the pretty printer switches to a compact style of output (called miser style) whenever
the width available for printing a substructure is less than or equal to this many ems.
22–74 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
print-pprint-dispatch  Variable
Value Type:
apprint dispatch table .
Initial Value:
implementation-dependent , but the initial entries all use a special class of priorities that have the
property that they are less than every priority that can be specied using set-pprint-dispatch , so
that the initial contents of any entry can be overridden.
Description:
The pprint dispatch table which currently controls the pretty printer .
See Also:
*print-pretty* , Section 22.2.1.4 (Pretty Print Dispatch Tables)
Notes:
The intent is that the initial value of this variable should cause `traditional' pretty printing ofcode.
In general, however, you can put a value in *print-pprint-dispatch* that makes pretty-printed
output look exactly like non-pretty-printed output. Setting *print-pretty* totrue just causes the
functions contained in the current pprint dispatch table to have priority over normal print-object
methods; it has no magic way of enforcing that those functions actually produce pretty output.
For details, see Section 22.2.1.4 (Pretty Print Dispatch Tables).
print-pretty Variable
Value Type:
ageneralized boolean .
Initial Value:
implementation-dependent .
Description:
Controls whether the Lisp printer calls the pretty printer .
If it is false, the pretty printer is not used and a minimum of whitespace 1is output when printing
an expression.
If it is true, the pretty printer is used, and the Lisp printer will endeavor to insert extra whitespace 1
where appropriate to make expressions more readable.
*print-pretty* has an eect even when the value of*print-escape* isfalse.
Printer22–75
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(setq *print-pretty* ’nil) !NIL
(progn (write ’(let ((a 1) (b 2) (c 3)) (+ a b c))) nil)
.(LET ((A 1) (B 2) (C 3)) (+ A B C))
!NIL
(let ((*print-pretty* t))
(progn (write ’(let ((a 1) (b 2) (c 3)) (+ a b c))) nil))
.(LET ((A 1)
. (B 2)
. (C 3))
.(+ A B C))
!NIL
;; Note that the first two expressions printed by this next form
;; differ from the second two only in whether escape characters are printed.
;; In all four cases, extra whitespace is inserted by the pretty printer.
(flet ((test (x)
(let ((*print-pretty* t))
(print x)
(format t "~%~S " x)
(terpri) (princ x) (princ " ")
(format t "~%~A " x))))
(test ’#’(lambda () (list "a" # ’c #’d))))
.#’(LAMBDA ()
.(LIST "a" # ’C #’D))
.#’(LAMBDA ()
.(LIST "a" # ’C #’D))
.#’(LAMBDA ()
.(LIST a b ’C #’D))
.#’(LAMBDA ()
.(LIST a b ’C #’D))
!NIL
See Also:
write
print-readably Variable
Value Type:
ageneralized boolean .
22–76 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
print-readably
Initial Value:
false.
Description:
If*print-readably* istrue, some special rules for printing objects go into eect. Specically,
printing any objectO1produces a printed representation that, when seen by the Lisp reader while
thestandard readtable is in eect, will produce an objectO2that is similar toO1. The printed
representation produced might or might not be the same as the printed representation produced
when*print-readably* isfalse. If printing an object readably is not possible, an error of type
print-not-readable is signaled rather than using a syntax ( e.g., the \#<" syntax) that would not
be readable by the same implementation . If the value of some other printer control variable is such
that these requirements would be violated, the value of that other variable is ignored.
Specically, if *print-readably* istrue, printing proceeds as if *print-escape* ,*print-array* ,
and*print-gensym* were also true, and as if *print-length* ,*print-level* , and*print-lines*
were false.
If*print-readably* isfalse, the normal rules for printing and the normal interpretations of other
printer control variables are in eect.
Individual methods forprint-object , including user-dened methods , are responsible for
implementing these requirements.
If*read-eval* isfalse and*print-readably* istrue, any such method that would output a
reference to the \ #."reader macro will either output something else or will signal an error (as
described above).
Examples:
(let ((x (list "a" ’\a (gensym) ’((a (b (c))) d e f g)))
(*print-escape* nil)
(*print-gensym* nil)
(*print-level* 3)
(*print-length* 3))
(write x)
(let ((*print-readably* t))
(terpri)
(write x)
:done))
.(a a G4581 ((A #) D E ...))
.("a" |a| #:G4581 ((A (B (C))) D E F G))
!:DONE
;; This is setup code is shared between the examples
;; of three hypothetical implementations which follow.
(setq table (make-hash-table)) !#<HASH-TABLE EQL 0/120 32005763>
Printer22–77
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setf (gethash table 1) ’one) !ONE
(setf (gethash table 2) ’two) !TWO
;; Implementation A
(let ((*print-readably* t)) (print table))
Error: Can’t print #<HASH-TABLE EQL 0/120 32005763> readably.
;; Implementation B
;; No standardized #S notation for hash tables is defined,
;; but there might be an implementation-defined notation.
(let ((*print-readably* t)) (print table))
.#S(HASH-TABLE :TEST EQL :SIZE 120 :CONTENTS (1 ONE 2 TWO))
!#<HASH-TABLE EQL 0/120 32005763>
;; Implementation C
;; Note that #. notation can only be used if *READ-EVAL* is true.
;; If *READ-EVAL* were false, this same implementation might have to
;; signal an error unless it had yet another printing strategy to fall
;; back on.
(let ((*print-readably* t)) (print table))
.#.(LET ((HASH-TABLE (MAKE-HASH-TABLE)))
.(SETF (GETHASH 1 HASH-TABLE) ONE)
.(SETF (GETHASH 2 HASH-TABLE) TWO)
.HASH-TABLE)
!#<HASH-TABLE EQL 0/120 32005763>
See Also:
write ,print-unreadable-object
Notes:
The rules for \ similarity " imply that #Aor#(syntax cannot be used for arrays ofelement type
other than t. An implementation will have to use another syntax or signal an error of type
print-not-readable .
print-right-margin  Variable
Value Type:
a non-negative integer , ornil.
Initial Value:
nil.
22–78 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
If it is non-nil , it species the right margin (as integer number of ems) to use when the pretty
printer is making layout decisions.
If it isnil, the right margin is taken to be the maximum line length such that output can be displayed
without wraparound or truncation. If this cannot be determined, an implementation-dependent
value is used.
Notes:
This measure is in units of ems in order to be compatible with implementation-dened
variable-width fonts while still not requiring the language to provide support for fonts.
print-not-readable Condition Type
Class Precedence List:
print-not-readable ,error ,serious-condition ,condition ,t
Description:
The typeprint-not-readable consists of error conditions that occur during output while
*print-readably* istrue, as a result of attempting to write a printed representation with the Lisp
printer that would not be correctly read back with the Lisp reader . The object which could not
be printed is initialized by the :object initialization argument to make-condition , and is accessed
by the functionprint-not-readable-object .
See Also:
print-not-readable-object
print-not-readable-object Function
Syntax:
print-not-readable-object condition!object
Arguments and Values:
condition |acondition oftypeprint-not-readable .
object |an object .
Description:
Returns the object that could not be printed readably in the situation represented by condition .
Printer22–79
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
print-not-readable , Chapter 9 (Conditions)
format Function
Syntax:
format destination control-string &rest args!result
Arguments and Values:
destination |nil,t, astream , or a string with a ll pointer .
control-string |aformat control .
args|format arguments forcontrol-string .
result |if destination isnon-nil , thennil; otherwise, a string .
Description:
format produces formatted output by outputting the characters of control-string and observing
that a tilde introduces a directive. The character after the tilde, possibly preceded by prex
parameters and modiers, species what kind of formatting is desired. Most directives use one or
more elements of args to create their output.
Ifdestination is a string , astream , ort, then the result isnil. Otherwise, the result is a string
containing the `output.'
format is useful for producing nicely formatted text, producing good-looking messages, and so on.
format can generate and return a string or output to destination .
For details on how the control-string is interpreted, see Section 22.3 (Formatted Output).
Aﬀected By:
*standard-output* ,*print-escape* ,*print-radix* ,*print-base* ,*print-circle* ,*print-pretty* ,
*print-level* ,*print-length* ,*print-case* ,*print-gensym* ,*print-array* .
Exceptional Situations:
Ifdestination is a string with a ll pointer , the consequences are undened if destructive
modications are performed directly on the string during the dynamic extent of the call.
See Also:
write , Section 13.1.10 (Documentation of Implementation-Dened Scripts)
22–80 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
23. Reader
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Readeriii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
23.1 Reader Concepts
23.1.1 Dynamic Control of the Lisp Reader
Various aspects of the Lisp reader can be controlled dynamically. See Section 2.1.1 (Readtables)
and Section 2.1.2 (Variables that aect the Lisp Reader).
23.1.2 Eﬀect of Readtable Case on the Lisp Reader
The readtable case of the current readtable aects the Lisp reader in the following ways:
:upcase
When the readtable case is:upcase , unescaped constituent characters are converted to
uppercase , as specied in Section 2.2 (Reader Algorithm).
:downcase
When the readtable case is:downcase , unescaped constituent characters are converted to
lowercase .
:preserve
When the readtable case is:preserve , the case of all characters remains unchanged.
:invert
When the readtable case is:invert , then if all of the unescaped letters in the extended
token are of the same case, those (unescaped) letters are converted to the opposite case.
23.1.2.1 Examples of Eﬀect of Readtable Case on the Lisp Reader
(defun test-readtable-case-reading ()
(let ((*readtable* (copy-readtable nil)))
(format t "READTABLE-CASE Input Symbol-name~
~%–––––––––––––––––-~
~%")
(dolist (readtable-case ’(:upcase :downcase :preserve :invert))
(setf (readtable-case *readtable*) readtable-case)
(dolist (input ’("ZEBRA" "Zebra" "zebra"))
(format t "~&:~A~16T~A~24T~A"
(string-upcase readtable-case)
input
Reader23–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(symbol-name (read-from-string input)))))))
The output from (test-readtable-case-reading) should be as follows:
READTABLE-CASE Input Symbol-name
––––––––––––––––––-
:UPCASE ZEBRA ZEBRA
:UPCASE Zebra ZEBRA
:UPCASE zebra ZEBRA
:DOWNCASE ZEBRA zebra
:DOWNCASE Zebra zebra
:DOWNCASE zebra zebra
:PRESERVE ZEBRA ZEBRA
:PRESERVE Zebra Zebra
:PRESERVE zebra zebra
:INVERT ZEBRA zebra
:INVERT Zebra Zebra
:INVERT zebra ZEBRA
23.1.3 Argument Conventions of Some Reader Functions
23.1.3.1 The EOF-ERROR-P argument
Eof-error-p in input function calls controls what happens if input is from a le (or any other input
source that has a denite end) and the end of the le is reached. If eof-error-p istrue (the default),
an error of typeend-of-ﬁle is signaled at end of le. If it is false, then no error is signaled, and
instead the function returns eof-value .
Functions such as read that read the representation of an object rather than a single character
always signals an error, regardless of eof-error-p , if the le ends in the middle of an object
representation. For example, if a le does not contain enough right parentheses to balance the
left parentheses in it, read signals an error. If a le ends in a symbol or a number immediately
followed by end-of-le, read reads the symbol ornumber successfully and when called again will
act according to eof-error-p . Similarly, the function read-line successfully reads the last line of a
le even if that line is terminated by end-of-le rather than the newline character. Ignorable text,
such as lines containing only whitespace 2or comments, are not considered to begin an object ; if
read begins to read an expression but sees only such ignorable text, it does not consider the le to
end in the middle of an object . Thus an eof-error-p argument controls what happens when the le
ends between objects .
23–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
23.1.3.2 The RECURSIVE-P argument
Ifrecursive-p is supplied and not nil, it species that this function call is not an outermost call to
read but an embedded call, typically from a reader macro function . It is important to distinguish
such recursive calls for three reasons.
1. An outermost call establishes the context within which the #n=and#n#syntax is scoped.
Consider, for example, the expression
(cons ’#3=(p q r) ’(x y . #3#))
If the single-quote reader macro were dened in this way:
(set-macro-character #\’ ;incorrect
#’(lambda (stream char)
(declare (ignore char))
(list ’quote (read stream))))
then each call to the single-quote reader macro function would establish independent
contexts for the scope of read information, including the scope of identications between
markers like \ #3=" and \#3#". However, for this expression, the scope was clearly intended
to be determined by the outer set of parentheses, so such a denition would be incorrect.
The correct way to dene the single-quote reader macro uses recursive-p :
(set-macro-character #\’ ;correct
#’(lambda (stream char)
(declare (ignore char))
(list ’quote (read stream t nil t))))
2. A recursive call does not alter whether the reading process is to preserve whitespace 2or not
(as determined by whether the outermost call was to read orread-preserving-whitespace ).
Suppose again that single-quote were to be dened as shown above in the incorrect
denition. Then a call to read-preserving-whitespace that read the expression
’foohSpaceiwould fail to preserve the space character following the symbol foobecause the
single-quote reader macro function callsread, notread-preserving-whitespace , to read
the following expression (in this case foo). The correct denition, which passes the value
true forrecursive-p toread, allows the outermost call to determine whether whitespace 2is
preserved.
3. When end-of-le is encountered and the eof-error-p argument is not nil, the kind of error
that is signaled may depend on the value of recursive-p . If recursive-p istrue, then the
end-of-le is deemed to have occurred within the middle of a printed representation; if
recursive-p isfalse, then the end-of-le may be deemed to have occurred between objects
rather than within the middle of one.
Reader23–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
readtable System Class
Class Precedence List:
readtable ,t
Description:
Areadtable maps characters into syntax types for the Lisp reader ; see Chapter 2 (Syntax). A
readtable also contains associations between macro characters and their reader macro functions ,
and records information about the case conversion rules to be used by the Lisp reader when parsing
symbols .
Each simple character must be representable in the readtable . It is implementation-dened whether
non-simple characters can have syntax descriptions in the readtable .
See Also:
Section 2.1.1 (Readtables), Section 22.1.3.13 (Printing Other Objects)
copy-readtable Function
Syntax:
copy-readtable &optional from-readtable to-readtable !readtable
Arguments and Values:
from-readtable |areadtable designator . The default is the current readtable .
to-readtable |areadtable ornil. The default is nil.
readtable |the to-readtable if it is non-nil , or else a fresh readtable .
Description:
copy-readtable copies from-readtable .
Ifto-readtable isnil, a new readtable is created and returned. Otherwise the readtable specied by
to-readtable is modied and returned.
copy-readtable copies the setting of readtable-case .
Examples:
(setq zvar 123) !123
(set-syntax-from-char #\z #\’ (setq table2 (copy-readtable))) !T
zvar!123
(copy-readtable table2 *readtable*) !#<READTABLE 614000277>
23–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
zvar!VAR
(setq *readtable* (copy-readtable)) !#<READTABLE 46210223>
zvar!VAR
(setq *readtable* (copy-readtable nil)) !#<READTABLE 46302670>
zvar!123
See Also:
readtable ,*readtable*
Notes:
(setq *readtable* (copy-readtable nil))
restores the input syntax to standard Common Lisp syntax, even if the initial readtable has been
clobbered (assuming it is not so badly clobbered that you cannot type in the above expression).
On the other hand,
(setq *readtable* (copy-readtable))
replaces the current readtable with a copy of itself. This is useful if you want to save a copy of a
readtable for later use, protected from alteration in the meantime. It is also useful if you want to
locally bind the readtable to a copy of itself, as in:
(let ((*readtable* (copy-readtable))) ...)
make-dispatch-macro-character Function
Syntax:
make-dispatch-macro-character char&optional non-terminating-p readtable !t
Arguments and Values:
char|acharacter .
non-terminating-p |ageneralized boolean . The default is false.
readtable |areadtable . The default is the current readtable .
Description:
make-dispatch-macro-character makes char be a dispatching macro character inreadtable .
Initially, every character in the dispatch table associated with the char has an associated function
that signals an error of typereader-error .
Reader23–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Ifnon-terminating-p istrue, the dispatching macro character is made a non-terminating macro
character ; ifnon-terminating-p isfalse, the dispatching macro character is made a terminating
macro character .
Examples:
(get-macro-character #\{) !NIL, false
(make-dispatch-macro-character #\{) !T
(not (get-macro-character #\{)) !false
The readtable is altered.
See Also:
*readtable* ,set-dispatch-macro-character
read,read-preserving-whitespace Function
Syntax:
read&optional input-stream eof-error-p eof-value recursive-p !object
read-preserving-whitespace &optional input-stream eof-error-p
eof-value recursive-p
!object
Arguments and Values:
input-stream |an input stream designator .
eof-error-p |ageneralized boolean . The default is true.
eof-value |an object . The default is nil.
recursive-p |ageneralized boolean . The default is false.
object |an object (parsed by the Lisp reader ) or the eof-value .
Description:
read parses the printed representation of an object from input-stream and builds such an object .
read-preserving-whitespace is likeread but preserves any whitespace 2character that delimits the
printed representation of the object .read-preserving-whitespace is exactly like read when the
recursive-p argument toread-preserving-whitespace istrue.
23–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
read, read-preserving-whitespace
When*read-suppress* isfalse,read throws away the delimiting character required by certain
printed representations if it is a whitespace 2character ; butread preserves the character (using
unread-char ) if it is syntactically meaningful, because it could be the start of the next expression.
If a le ends in a symbol or a number immediately followed by an end of le 1,read reads the symbol
ornumber successfully; when called again, it sees the end of le 1and only then acts according to
eof-error-p . If a le contains ignorable text at the end, such as blank lines and comments, read
does not consider it to end in the middle of an object .
Ifrecursive-p istrue, the call to read is expected to be made from within some function that itself
has been called from read or from a similar input function, rather than from the top level.
Both functions return the object read from input-stream .Eof-value is returned if eof-error-p isfalse
and end of le is reached before the beginning of an object .
Examples:
(read)
.’a
!(QUOTE A)
(with-input-from-string (is " ") (read is nil ’the-end)) !THE-END
(defun skip-then-read-char (s c n)
(if (char= c #\{) (read s t nil t) (read-preserving-whitespace s))
(read-char-no-hang s)) !SKIP-THEN-READ-CHAR
(let ((*readtable* (copy-readtable nil)))
(set-dispatch-macro-character #\# #\{ #’skip-then-read-char)
(set-dispatch-macro-character #\# #\} #’skip-then-read-char)
(with-input-from-string (is "#{123 x #}123 y")
(format t "~S ~S" (read is) (read is)))) !#\x, #\Space, NIL
As an example, consider this reader macro denition:
(defun slash-reader (stream char)
(declare (ignore char))
‘(path . ,(loop for dir = (read-preserving-whitespace stream t nil t)
then (progn (read-char stream t nil t)
(read-preserving-whitespace stream t nil t))
collect dir
while (eql (peek-char nil stream nil nil t) #\/))))
(set-macro-character #\/ #’slash-reader)
Consider now calling read on this expression:
(zyedh /usr/games/zork /usr/games/boggle)
The/macro reads objects separated by more /characters; thus /usr/games/zork is intended to
read as(path usr games zork) . The entire example expression should therefore be read as
Reader23–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(zyedh (path usr games zork) (path usr games boggle))
However, if read had been used instead of read-preserving-whitespace , then after the reading of
the symbol zork, the following space would be discarded; the next call to peek-char would see the
following /, and the loop would continue, producing this interpretation:
(zyedh (path usr games zork usr games boggle))
There are times when whitespace 2should be discarded. If a command interpreter takes single-
character commands, but occasionally reads an object then if the whitespace 2after a symbol is not
discarded it might be interpreted as a command some time later after the symbol had been read.
Aﬀected By:
*standard-input* ,*terminal-io* ,*readtable* ,*read-default-ﬂoat-format* ,*read-base* ,
*read-suppress* ,*package* ,*read-eval* .
Exceptional Situations:
read signals an error of typeend-of-ﬁle , regardless of eof-error-p , if the le ends in the middle
of an object representation. For example, if a le does not contain enough right parentheses
to balance the left parentheses in it, read signals an error. This is detected when read or
read-preserving-whitespace is called with recursive-p and eof-error-p non-nil , and end-of-le is
reached before the beginning of an object .
Ifeof-error-p istrue, an error of typeend-of-ﬁle is signaled at the end of le.
See Also:
peek-char ,read-char ,unread-char ,read-from-string ,read-delimited-list ,parse-integer ,
Chapter 2 (Syntax), Section 23.1 (Reader Concepts)
read-delimited-list Function
Syntax:
read-delimited-list char&optional input-stream recursive-p !list
Arguments and Values:
char|acharacter .
input-stream |an input stream designator . The default is standard input .
recursive-p |ageneralized boolean . The default is false.
list|alistof the objects read.
23–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
read-delimited-list
Description:
read-delimited-list reads objects from input-stream until the next character after an object 's
representation (ignoring whitespace 2characters and comments) is char.
read-delimited-list looks ahead at each step for the next non- whitespace 2character and peeks
at it as if with peek-char . If it is char, then the character is consumed and the listofobjects is
returned. If it is a constituent orescape character , thenread is used to read an object , which is
added to the end of the list. If it is a macro character , its reader macro function is called; if the
function returns a value , that value is added to the list. The peek-ahead process is then repeated.
Ifrecursive-p istrue, this call is expected to be embedded in a higher-level call to read or a similar
function.
It is an error to reach end-of-le during the operation of read-delimited-list .
The consequences are undened if char has a syntax type ofwhitespace 2in the current readtable .
Examples:
(read-delimited-list #\ ]) 1 2 3 4 5 6 ]
!(1 2 3 4 5 6)
Suppose you wanted #{a b c:::z}to read as a list of all pairs of the elements a,b,c,:::,z, for
example.
#{p q z a} reads as ((p q) (p z) (p a) (q z) (q a) (z a))
This can be done by specifying a macro-character denition for #{that does two things: reads in
all the items up to the }, and constructs the pairs. read-delimited-list performs the rst task.
(defun |#{-reader| (stream char arg)
(declare (ignore char arg))
(mapcon #’(lambda (x)
(mapcar #’(lambda (y) (list (car x) y)) (cdr x)))
(read-delimited-list #\} stream t))) !|#{-reader|
(set-dispatch-macro-character #\# #\{ #’|#{-reader|) !T
(set-macro-character #\} (get-macro-character #\) nil))
Note that true is supplied for the recursive-p argument.
It is necessary here to give a denition to the character }as well to prevent it from being a
constituent. If the line
(set-macro-character #\} (get-macro-character #\) nil))
shown above were not included, then the }in
#{ p q z a}
Reader23–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
would be considered a constituent character, part of the symbol named a}. This could be corrected
by putting a space before the }, but it is better to call set-macro-character .
Giving}the same denition as the standard denition of the character )has the twin benet of
making it terminate tokens for use with read-delimited-list and also making it invalid for use in
any other context. Attempting to read a stray }will signal an error.
Aﬀected By:
*standard-input* ,*readtable* ,*terminal-io* .
See Also:
read,peek-char ,read-char ,unread-char .
Notes:
read-delimited-list is intended for use in implementing reader macros . Usually it is desirable
forchar to be a terminating macro character so that it can be used to delimit tokens; however,
read-delimited-list makes no attempt to alter the syntax specied for char by the current
readtable. The caller must make any necessary changes to the readtable syntax explicitly.
read-from-string Function
Syntax:
read-from-string string&optional eof-error-p eof-value
&key start end preserve-whitespace
!object, position
Arguments and Values:
string |astring .
eof-error-p |ageneralized boolean . The default is true.
eof-value |an object . The default is nil.
start,end|bounding index designators ofstring . The defaults for start and endare0andnil,
respectively.
preserve-whitespace |ageneralized boolean . The default is false.
object |an object (parsed by the Lisp reader ) or the eof-value .
position |an integer greater than or equal to zero, and less than or equal to one more than the
length of the string .
23–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Parses the printed representation of an object from the subsequence of string bounded bystart and
end, as ifread had been called on an input stream containing those same characters .
Ifpreserve-whitespace istrue, the operation will preserve whitespace 2asread-preserving-whitespace
would do.
If an object is successfully parsed, the primary value ,object , is the object that was parsed. If
eof-error-p isfalse and if the end of the substring is reached, eof-value is returned.
The secondary value ,position , is the index of the rst character in the bounded string that was not
read. The position may depend upon the value of preserve-whitespace . If the entire string was read,
theposition returned is either the length of the string or one greater than the length of the string .
Examples:
(read-from-string " 1 3 5" t nil :start 2) !3, 5
(read-from-string "(a b c)") !(A B C), 7
Exceptional Situations:
If the end of the supplied substring occurs before an object can be read, an error is signaled if
eof-error-p istrue. An error is signaled if the end of the substring occurs in the middle of an
incomplete object .
See Also:
read,read-preserving-whitespace
Notes:
The reason that position is allowed to be beyond the length of the string is to permit (but not
require) the implementation to work by simulating the eect of a trailing delimiter at the end of the
bounded string . When preserve-whitespace istrue, the position might count the simulated delimiter.
readtable-case Accessor
Syntax:
readtable-case readtable!mode
(setf (readtable-case readtable)mode)
Arguments and Values:
readtable |areadtable .
mode |acase sensitivity mode .
Reader23–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Accesses thereadtable case ofreadtable , which aects the way in which the Lisp Reader reads
symbols and the way in which the Lisp Printer writes symbols .
Examples:
See Section 23.1.2.1 (Examples of Eect of Readtable Case on the Lisp Reader) and Section
22.1.3.3.2.1 (Examples of Eect of Readtable Case on the Lisp Printer).
Exceptional Situations:
Should signal an error of typetype-error ifreadtable is not a readtable . Should signal an error of
typetype-error ifmode is not a case sensitivity mode .
See Also:
*readtable* ,*print-escape* , Section 2.2 (Reader Algorithm), Section 23.1.2 (Eect of Readtable
Case on the Lisp Reader), Section 22.1.3.3.2 (Eect of Readtable Case on the Lisp Printer)
Notes:
copy-readtable copies the readtable case of the readtable .
readtablep Function
Syntax:
readtablep object!generalized-boolean
Arguments and Values:
object |an object .
generalized-boolean |ageneralized boolean .
Description:
Returns true ifobject is of typereadtable ; otherwise, returns false.
Examples:
(readtablep *readtable*) !true
(readtablep (copy-readtable)) !true
(readtablep ’*readtable*) !false
Notes:
(readtablep object)(typep object’readtable)
23–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
set-dispatch-macro-character, :::
set-dispatch-macro-character,get-dispatch-macro-
character Function
Syntax:
get-dispatch-macro-character disp-char sub-char &optional readtable!function
set-dispatch-macro-character disp-char sub-char new-function &optional readtable!t
Arguments and Values:
disp-char |acharacter .
sub-char |acharacter .
readtable |areadtable designator . The default is the current readtable .
function |afunction designator ornil.
new-function |afunction designator .
Description:
set-dispatch-macro-character causes new-function to be called when disp-char followed by sub-char
is read. If sub-char is a lowercase letter, it is converted to its uppercase equivalent. It is an error if
sub-char is one of the ten decimal digits.
set-dispatch-macro-character installs a new-function to be called when a particular dispatching
macro character pair is read. New-function is installed as the dispatch function to be called when
readtable is in use and when disp-char is followed by sub-char .
For more information about how the new-function is invoked, see Section 2.1.4.4 (Macro Characters).
get-dispatch-macro-character retrieves the dispatch function associated with disp-char and
sub-char inreadtable .
get-dispatch-macro-character returns the macro-character function for sub-char under disp-
char, ornilif there is no function associated with sub-char . If sub-char is a decimal digit,
get-dispatch-macro-character returnsnil.
Examples:
(get-dispatch-macro-character #\# #\{) !NIL
(set-dispatch-macro-character #\# #\{ ;dispatch on #{
#’(lambda(s c n)
(let ((list (read s nil (values) t))) ;list is object after #n{
(when (consp list) ;return nth element of list
(unless (and n (< 0 n (length list))) (setq n 0))
(setq list (nth n list)))
Reader23–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
list)))!T
#{(1 2 3 4)!1
#3{(0 1 2 3)!3
#{123!123
If it is desired that #$foo: as if it were (dollars foo).
(defun |#$-reader| (stream subchar arg)
(declare (ignore subchar arg))
(list ’dollars (read stream t nil t))) !|#$-reader|
(set-dispatch-macro-character #\# #\$ #’|#$-reader|) !T
See Also:
Section 2.1.4.4 (Macro Characters)
Side Eﬀects:
The readtable is modied.
Aﬀected By:
*readtable* .
Exceptional Situations:
For either function, an error is signaled if disp-char is not a dispatching macro character in
readtable .
See Also:
*readtable*
Notes:
It is necessary to use make-dispatch-macro-character to set up the dispatch character before
specifying its sub-characters.
set-macro-character,get-macro-character Function
Syntax:
get-macro-character char&optional readtable!function, non-terminating-p
set-macro-character char new-function &optional non-terminating-p readtable !t
Arguments and Values:
char|acharacter .
non-terminating-p |ageneralized boolean . The default is false.
23–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
set-macro-character, get-macro-character
readtable |areadtable designator . The default is the current readtable .
function |nil, or a designator for a function of two arguments .
new-function |afunction designator .
Description:
get-macro-character returns as its primary value ,function , the reader macro function associated
with char inreadtable (if any), or else nilifchar is not a macro character inreadtable . The
secondary value ,non-terminating-p , istrue ifchar is anon-terminating macro character ; otherwise,
it is false.
set-macro-character causes char to be a macro character associated with the reader macro
function new-function (or the designator fornew-function ) in readtable . If non-terminating-p is
true,char becomes a non-terminating macro character ; otherwise it becomes a terminating macro
character .
Examples:
(get-macro-character #\{) !NIL, false
(not (get-macro-character #\;)) !false
The following is a possible denition for the single-quote reader macro instandard syntax :
(defun single-quote-reader (stream char)
(declare (ignore char))
(list ’quote (read stream t nil t))) !SINGLE-QUOTE-READER
(set-macro-character #\’ #’single-quote-reader) !T
Heresingle-quote-reader reads an object following the single-quote and returns a listofquote
and that object . The char argument is ignored.
The following is a possible denition for the semicolon reader macro instandard syntax :
(defun semicolon-reader (stream char)
(declare (ignore char))
;; First swallow the rest of the current input line.
;; End-of-file is acceptable for terminating the comment.
(do () ((char= (read-char stream nil #\Newline t) #\Newline)))
;; Return zero values.
(values))!SEMICOLON-READER
(set-macro-character #\; #’semicolon-reader) !T
Side Eﬀects:
The readtable is modied.
See Also:
*readtable*
Reader23–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
set-syntax-from-char Function
Syntax:
set-syntax-from-char to-char from-char &optional to-readtable from-readtable !t
Arguments and Values:
to-char |acharacter .
from-char |acharacter .
to-readtable |areadtable . The default is the current readtable .
from-readtable |areadtable designator . The default is the standard readtable .
Description:
set-syntax-from-char makes the syntax of to-char into-readtable be the same as the syntax of
from-char infrom-readtable .
set-syntax-from-char copies the syntax types offrom-char . If from-char is amacro character , its
reader macro function is copied also. If the character is a dispatching macro character , its entire
dispatch table of reader macro functions is copied. The constituent traits offrom-char are not
copied.
A macro denition from a character such as "can be copied to another character; the standard
denition for "looks for another character that is the same as the character that invoked it. The
denition of (can not be meaningfully copied to {, on the other hand. The result is that lists are
of the form {a b c) , not{a b c} , because the denition always looks for a closing parenthesis, not
a closing brace.
Examples:
(set-syntax-from-char #\7 #\;) !T
123579!1235
Side Eﬀects:
The to-readtable is modied.
Aﬀected By:
The existing values in the from-readtable .
See Also:
set-macro-character ,make-dispatch-macro-character , Section 2.1.4 (Character Syntax Types)
23–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Notes:
The constituent traits of a character are \hard wired" into the parser for extended tokens . For
example, if the denition of Sis copied to *, then*will become a constituent that is alphabetic 2
but that cannot be used as a short oat exponent marker . For further information, see Section
2.1.4.2 (Constituent Traits).
with-standard-io-syntax Macro
Syntax:
with-standard-io-syntax fformg*!f resultg*
Arguments and Values:
forms |an implicit progn .
results |the values returned by the forms .
Description:
Within the dynamic extent of the body of forms , all reader/printer control variables, including
anyimplementation-dened ones not specied by this standard, are bound to values that produce
standard read/print behavior. The values for the variables specied by this standard are listed in
Figure 23{1.
Reader23–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Variable Value
*package* TheCL-USER package
*print-array* t
*print-base* 10
*print-case* :upcase
*print-circle* nil
*print-escape* t
*print-gensym* t
*print-length* nil
*print-level* nil
*print-lines* nil
*print-miser-width* nil
*print-pprint-dispatch* The standard pprint dispatch table
*print-pretty* nil
*print-radix* nil
*print-readably* t
*print-right-margin* nil
*read-base* 10
*read-default-ﬂoat-format* single-ﬂoat
*read-eval* t
*read-suppress* nil
*readtable* The standard readtable
Figure 23–1. Values of standard control variables
Examples:
(with-open-file (file pathname :direction :output)
(with-standard-io-syntax
(print data file)))
;;; ... Later, in another Lisp:
(with-open-file (file pathname :direction :input)
(with-standard-io-syntax
(setq data (read file))))
23–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
read-base Variable
Value Type:
aradix .
Initial Value:
10.
Description:
Controls the interpretation of tokens by read as being integers orratios .
The value of*read-base* , called the current input base , is the radix in which integers and
ratios are to be read by the Lisp reader . The parsing of other numeric types (e.g.,oats ) is not
aected by this option.
The eect of *read-base* on the reading of any particular rational number can be locally
overridden by explicit use of the #O,#X,#B, or#nRsyntax or by a trailing decimal point.
Examples:
(dotimes (i 6)
(let ((*read-base* (+ 10. i)))
(let ((object (read-from-string "(\\DAD DAD |BEE| BEE 123. 123)")))
(print (list *read-base* object)))))
.(10 (DAD DAD BEE BEE 123 123))
.(11 (DAD DAD BEE BEE 123 146))
.(12 (DAD DAD BEE BEE 123 171))
.(13 (DAD DAD BEE BEE 123 198))
.(14 (DAD 2701 BEE BEE 123 227))
.(15 (DAD 3088 BEE 2699 123 258))
!NIL
Notes:
Altering the input radix can be useful when reading data les in special formats.
read-default-ﬂoat-format  Variable
Value Type:
one of the atomic type speciers short-ﬂoat ,single-ﬂoat ,double-ﬂoat , orlong-ﬂoat , or else some
other type specier dened by the implementation to be acceptable.
Reader23–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Initial Value:
The symbolsingle-ﬂoat .
Description:
Controls the oating-point format that is to be used when reading a oating-point number that has
noexponent marker or that has eorEfor an exponent marker . Other exponent markers explicitly
prescribe the oating-point format to be used.
The printer uses *read-default-ﬂoat-format* to guide the choice of exponent markers when
printing oating-point numbers.
Examples:
(let ((*read-default-float-format* ’double-float))
(read-from-string "(1.0 1.0e0 1.0s0 1.0f0 1.0d0 1.0L0)"))
!(1.0 1.0 1.0 1.0 1.0 1.0) ;Implementation has float format F.
!(1.0 1.0 1.0s0 1.0 1.0 1.0) ;Implementation has float formats S and F.
!(1.0d0 1.0d0 1.0 1.0 1.0d0 1.0d0) ;Implementation has float formats F and D.
!(1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0d0) ;Implementation has float formats S, F, D.
!(1.0d0 1.0d0 1.0 1.0 1.0d0 1.0L0) ;Implementation has float formats F, D, L.
!(1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0L0) ;Implementation has formats S, F, D, L.
read-eval Variable
Value Type:
ageneralized boolean .
Initial Value:
true.
Description:
If it is true, the#.reader macro has its normal eect. Otherwise, that reader macro signals an
error of typereader-error .
See Also:
*print-readably*
Notes:
If*read-eval* isfalse and*print-readably* istrue, any method forprint-object that would
output a reference to the #.reader macro either outputs something dierent or signals an error of
typeprint-not-readable .
23–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
read-suppress Variable
Value Type:
ageneralized boolean .
Initial Value:
false.
Description:
This variable is intended primarily to support the operation of the read-time conditional notations
#+and#-. It is important for the reader macros which implement these notations to be able to
skip over the printed representation of an expression despite the possibility that the syntax of the
skipped expression may not be entirely valid for the current implementation, since #+and#-exist
in order to allow the same program to be shared among several Lisp implementations (including
dialects other than Common Lisp) despite small incompatibilities of syntax.
If it is false, the Lisp reader operates normally.
If the value of*read-suppress* istrue,read,read-preserving-whitespace ,read-delimited-list ,
andread-from-string all return a primary value ofnilwhen they complete successfully; however,
they continue to parse the representation of an object in the normal way, in order to skip over
theobject , and continue to indicate end of le in the normal way. Except as noted below, any
standardized reader macro 2that is dened to read 2a following object ortoken will do so, but
not signal an error if the object read is not of an appropriate type or syntax. The standard
syntax and its associated reader macros will not construct any new objects (e.g., when reading the
representation of a symbol , no symbol will be constructed or interned).
Extended tokens
All extended tokens are completely uninterpreted. Errors such as those that might
otherwise be signaled due to detection of invalid potential numbers , invalid patterns of
package markers , and invalid uses of the dotcharacter are suppressed.
Dispatching macro characters (including sharpsign )
Dispatching macro characters continue to parse an inx numerical argument, and invoke
the dispatch function. The standardized sharpsign reader macros do not enforce any
constraints on either the presence of or the value of the numerical argument.
#=
The#=notation is totally ignored. It does not read a following object . It produces no
object , but is treated as whitespace 2.
Reader23–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
##
The##notation always produces nil.
No matter what the value of*read-suppress* , parentheses still continue to delimit and construct
lists; the#(notation continues to delimit vectors ; and comments, strings , and the single-quote and
backquote notations continue to be interpreted properly. Such situations as ’),#<,#), and#hSpacei
continue to signal errors.
Examples:
(let ((*read-suppress* t))
(mapcar #’read-from-string
’("#(foo bar baz)" "#P(:type :lisp)" "#c1.2"
"#.(PRINT ’FOO)" "#3AHELLO" "#S(INTEGER)"
"#*ABC" "#\GARBAGE" "#RALPHA" "#3R444")))
!(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)
See Also:
read, Chapter 2 (Syntax)
Notes:
Programmers andimplementations that dene additional macro characters are strongly encouraged
to make them respect *read-suppress* just as standardized macro characters do. That is, when
thevalue of*read-suppress* istrue, they should ignore type errors when reading a following
object and the functions that implement dispatching macro characters should tolerate nilas their
inx parameter value even if a numeric value would ordinarily be required.
readtable Variable
Value Type:
areadtable .
Initial Value:
Areadtable that conforms to the description of Common Lisp syntax in Chapter 2 (Syntax).
Description:
The value of*readtable* is called the current readtable . It controls the parsing behavior of the
Lisp reader , and can also inuence the Lisp printer (e.g., see the functionreadtable-case ).
Examples:
(readtablep *readtable*) !true
23–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(setq zvar 123) !123
(set-syntax-from-char #\z #\’ (setq table2 (copy-readtable))) !T
zvar!123
(setq *readtable* table2) !#<READTABLE>
zvar!VAR
(setq *readtable* (copy-readtable nil)) !#<READTABLE>
zvar!123
Aﬀected By:
compile-ﬁle ,load
See Also:
compile-ﬁle ,load,readtable , Section 2.1.1.1 (The Current Readtable)
reader-error Condition Type
Class Precedence List:
reader-error ,parse-error ,stream-error ,error ,serious-condition ,condition ,t
Description:
The typereader-error consists of error conditions that are related to tokenization and parsing
done by the Lisp reader .
See Also:
read,stream-error-stream , Section 23.1 (Reader Concepts)
Reader23–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
23–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
24. System Construction
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
System Construction iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
24.1 System Construction Concepts
24.1.1 Loading
Toload aleis to treat its contents as code and execute that code. The lemay contain source
code orcompiled code .
Alecontaining source code is called a source le .Loading asource le is accomplished
essentially by sequentially reading 2theforms in the le, evaluating each immediately after it is
read.
Alecontaining compiled code is called a compiled le .Loading acompiled le is similar to
loading asource le , except that the ledoes not contain text but rather an implementation-
dependent representation of pre-digested expressions created by the compiler . Often, a compiled
lecan be loaded more quickly than a source le . See Section 3.2 (Compilation).
The way in which a source le is distinguished from a compiled le isimplementation-dependent .
24.1.2 Features
Afeature is an aspect or attribute of Common Lisp, of the implementation , or of the environment .
Afeature is identied by a symbol .
Afeature is said to be present in a Lisp image if and only if the symbol naming it is an element
of the listheld by the variable*features* , which is called the features list .
24.1.2.1 Feature Expressions
Boolean combinations of features , called feature expressions , are used by the #+and#-reader
macros in order to direct conditional reading ofexpressions by the Lisp reader .
The rules for interpreting a feature expression are as follows:
feature
If asymbol naming a feature is used as a feature expression , the feature expression succeeds
if that feature ispresent ; otherwise it fails.
(not feature-conditional )
Anot feature expression succeeds if its argument feature-conditional fails; otherwise, it
succeeds.
(andffeature-conditional g*)
Anand feature expression succeeds if all of its argument feature-conditionals succeed;
otherwise, it fails.
System Construction 24–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
(orffeature-conditional g*)
Anorfeature expression succeeds if any of its argument feature-conditionals succeed;
otherwise, it fails.
24.1.2.1.1 Examples of Feature Expressions
For example, suppose that in implementation A, the features spice andperq arepresent , but the
featurelispm is not present ; inimplementation B, the feature lispm ispresent , but the features
spice andperq are not present ; and in implementation C, none of the features spice ,lispm , or
perq arepresent . Figure 24{1 shows some sample expressions , and how they would be read 2in
these implementations .
(cons #+spice "Spice" #-spice "Lispm" x)
inimplementation A::: (CONS "Spice" X)
inimplementation B::: (CONS "Lispm" X)
inimplementation C::: (CONS "Lispm" X)
(cons #+spice "Spice" #+LispM "Lispm" x)
inimplementation A::: (CONS "Spice" X)
inimplementation B::: (CONS "Lispm" X)
inimplementation C::: (CONS X)
(setq a ’(1 2 #+perq 43 #+(not perq) 27))
inimplementation A::: (SETQ A ’(1 2 43))
inimplementation B::: (SETQ A ’(1 2 27))
inimplementation C::: (SETQ A ’(1 2 27))
(let ((a 3) #+(or spice lispm) (b 3)) (foo a))
inimplementation A::: (LET ((A 3) (B 3)) (FOO A))
inimplementation B::: (LET ((A 3) (B 3)) (FOO A))
inimplementation C::: (LET ((A 3)) (FOO A))
(cons #+Lispm "#+Spice" #+Spice "foo" #-(or Lispm Spice) 7 x)
inimplementation A::: (CONS "foo" X)
inimplementation B::: (CONS "#+Spice" X)
inimplementation C::: (CONS 7 X)
Figure 24–1. Features examples
24–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
compile-ﬁle Function
Syntax:
compile-ﬁle input-le &key output-le verbose
print external-format
!output-truename, warnings-p, failure-p
Arguments and Values:
input-le |apathname designator . (Default llers for unspecied components are taken from
*default-pathname-defaults* .)
output-le |apathname designator . The default is implementation-dened .
verbose |ageneralized boolean . The default is the value of*compile-verbose* .
print|ageneralized boolean . The default is the value of*compile-print* .
external-format |an external le format designator . The default is :default .
output-truename |apathname (thetruename of the output le), ornil.
warnings-p |ageneralized boolean .
failure-p |ageneralized boolean .
Description:
compile-ﬁle transforms the contents of the le specied by input-le into implementation-dependent
binary data which are placed in the le specied by output-le .
The leto which input-le refers should be a source le .output-le can be used to specify an
output pathname ; the actual pathname of the compiled le to which compiled code will be output
is computed as if by calling compile-ﬁle-pathname .
Ifinput-le oroutput-le is alogical pathname , it is translated into a physical pathname as if by
callingtranslate-logical-pathname .
Ifverbose istrue,compile-ﬁle prints a message in the form of a comment ( i.e., with a leading
semicolon ) to standard output indicating what leis being compiled and other useful information.
Ifverbose isfalse,compile-ﬁle does not print this information.
Ifprint istrue, information about top level forms in the le being compiled is printed to standard
output . Exactly what is printed is implementation-dependent , but nevertheless some information is
printed. If print isnil, no information is printed.
The external-format species the external le format to be used when opening the le; see the
System Construction 24–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
compile-ﬁle
functionopen .compile-ﬁle andload must cooperate in such a way that the resulting compiled le
can be loaded without specifying an external le format anew; see the functionload.
compile-ﬁle binds*readtable* and*package* to the values they held before processing the le.
*compile-ﬁle-truename* is bound by compile-ﬁle to hold the truename of the pathname of the
le being compiled.
*compile-ﬁle-pathname* is bound by compile-ﬁle to hold a pathname denoted by the rst argu-
ment tocompile-ﬁle , merged against the defaults; that is, (pathname (merge-pathnames input-le )).
The compiled functions contained in the compiled le become available for use when the compiled
leisloaded into Lisp. Any function denition that is processed by the compiler, including
#’(lambda ...) forms and local function denitions made by ﬂet,labels anddefun forms, result in
anobject oftypecompiled-function .
The primary value returned by compile-ﬁle ,output-truename , is thetruename of the output le,
ornilif the le could not be created.
The secondary value ,warnings-p , isfalse if no conditions oftypeerror orwarning were detected
by the compiler, and true otherwise.
The tertiary value ,failure-p , isfalse if no conditions oftypeerror orwarning (other than
style-warning ) were detected by the compiler, and true otherwise.
For general information about how les are processed by the le compiler , see Section 3.2.3 (File
Compilation).
Programs to be compiled by the le compiler must only contain externalizable objects ; for details
on such objects , see Section 3.2.4 (Literal Objects in Compiled Files). For information on how
to extend the set of externalizable objects , see the function make-load-form and Section 3.2.4.4
(Additional Constraints on Externalizable Objects).
Aﬀected By:
*error-output* ,*standard-output* ,*compile-verbose* ,*compile-print*
The computer's le system.
Exceptional Situations:
For information about errors detected during the compilation process, see Section 3.2.5 (Exceptional
Situations in the Compiler).
An error of typeﬁle-error might be signaled if (wild-pathname-p input-le )returns true.
If either the attempt to open the source le for input or the attempt to open the compiled le for
output fails, an error of typeﬁle-error is signaled.
24–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
compile ,declare ,eval-when ,pathname ,logical-pathname , Section 20.1 (File System Concepts),
Section 19.1.2 (Pathnames as Filenames)
compile-ﬁle-pathname Function
Syntax:
compile-ﬁle-pathname input-le &key output-le &allow-other-keys !pathname
Arguments and Values:
input-le |apathname designator . (Default llers for unspecied components are taken from
*default-pathname-defaults* .)
output-le |apathname designator . The default is implementation-dened .
pathname |apathname .
Description:
Returns the pathname thatcompile-ﬁle would write into, if given the same arguments.
The defaults for the output-le are taken from the pathname that results from merging the input-le
with the value of*default-pathname-defaults* , except that the type component should default to
the appropriate implementation-dened default type for compiled les .
Ifinput-le is a logical pathname and output-le is unsupplied, the result is a logical
pathname . If input-le is a logical pathname , it is translated into a physical pathname
as if by calling translate-logical-pathname . If input-le is a stream , the stream can
be either open or closed. compile-ﬁle-pathname returns the same pathname after a
le is closed as it did when the le was open. It is an error if input-le is a stream
that is created with make-two-way-stream ,make-echo-stream ,make-broadcast-stream ,
make-concatenated-stream ,make-string-input-stream ,make-string-output-stream .
If an implementation supports additional keyword arguments to compile-ﬁle ,
compile-ﬁle-pathname must accept the same arguments.
Examples:
Seelogical-pathname-translations .
Exceptional Situations:
An error of typeﬁle-error might be signaled if either input-le oroutput-le iswild.
See Also:
System Construction 24–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
compile-ﬁle ,pathname ,logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2
(Pathnames as Filenames)
load Function
Syntax:
load lespec&key verbose print
if-does-not-exist external-format
!generalized-boolean
Arguments and Values:
lespec |a stream , or a pathname designator . The default is taken from
*default-pathname-defaults* .
verbose |ageneralized boolean . The default is the value of*load-verbose* .
print|ageneralized boolean . The default is the value of*load-print* .
if-does-not-exist |ageneralized boolean . The default is true.
external-format |an external le format designator . The default is :default .
generalized-boolean |ageneralized boolean .
Description:
load loads thelenamed by lespec into the Lisp environment.
The manner in which a source le is distinguished from a compiled le isimplementation-dependent .
If the le specication is not complete and both a source le and a compiled le exist which might
match, then which of those les load selects is implementation-dependent .
Iflespec is a stream ,load determines what kind of stream it is and loads directly from the
stream . If lespec is alogical pathname , it is translated into a physical pathname as if by calling
translate-logical-pathname .
load sequentially executes each form it encounters in the lenamed by lespec . If the leis a
source le and the implementation chooses to perform implicit compilation ,load must recognize
top level forms as described in Section 3.2.3.1 (Processing of Top Level Forms) and arrange for each
top level form to be executed before beginning implicit compilation of the next. (Note, however,
that processing of eval-when forms byload is controlled by the :execute situation.)
24–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
load
Ifverbose istrue,load prints a message in the form of a comment ( i.e., with a leading semicolon )
tostandard output indicating what leis being loaded and other useful information. If verbose is
false,load does not print this information.
Ifprint istrue,load incrementally prints information to standard output showing the progress of
theloading process. For a source le , this information might mean printing the values yielded by
each form in the leas soon as those values are returned. For a compiled le , what is printed
might not reect precisely the contents of the source le , but some information is generally printed.
Ifprint isfalse,load does not print this information.
If the le named by lespec is successfully loaded, load returns true.
If the le does not exist, the specic action taken depends on if-does-not-exist : if it isnil,load
returnsnil; otherwise, load signals an error.
The external-format species the external le format to be used when opening the le(see the
function open ), except that when the lenamed by lespec is acompiled le , the external-format
is ignored. compile-ﬁle andload cooperate in an implementation-dependent way to assure the
preservation of the similarity ofcharacters referred to in the source le at the time the source le
was processed by the le compiler under a given external le format , regardless of the value of
external-format at the time the compiled le isloaded .
load binds*readtable* and*package* to the values they held before loading the le.
*load-truename* isbound byload to hold the truename of the pathname of the le being loaded .
*load-pathname* isbound byload to hold a pathname that represents lespec merged against the
defaults. That is, (pathname (merge-pathnames lespec)).
Examples:
;Establish a data file...
(with-open-file (str "data.in" :direction :output :if-exists :error)
(print 1 str) (print ’(setq a 888) str) t)
!T
(load "data.in") !true
a!888
(load (setq p (merge-pathnames "data.in")) :verbose t)
; Loading contents of file /fred/data.in
; Finished loading /fred/data.in
!true
(load p :print t)
; Loading contents of file /fred/data.in
; 1
; 888
; Finished loading /fred/data.in
!true
System Construction 24–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
;––[Begin file SETUP]––
(in-package "MY-STUFF")
(defmacro compile-truename () ‘’,*compile-file-truename*)
(defvar *my-compile-truename* (compile-truename) "Just for debugging.")
(defvar *my-load-pathname* *load-pathname*)
(defun load-my-system ()
(dolist (module-name ’("FOO" "BAR" "BAZ"))
(load (merge-pathnames module-name *my-load-pathname*))))
;––[End of file SETUP]––
(load "SETUP")
(load-my-system)
Aﬀected By:
The implementation, and the host computer's le system.
Exceptional Situations:
If:if-does-not-exist is supplied and is true, or is not supplied, load signals an error of type
ﬁle-error if the le named by lespec does not exist, or if the le system cannot perform the
requested operation.
An error of typeﬁle-error might be signaled if (wild-pathname-p lespec)returns true.
See Also:
error ,merge-pathnames ,*load-verbose* ,*default-pathname-defaults* ,pathname ,
logical-pathname , Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as File-
names)
with-compilation-unit Macro
Syntax:
with-compilation-unit ([ [#option ] ])fformg*!f resultg*
option:: =:override override
Arguments and Values:
override |ageneralized boolean ; evaluated. The default is nil.
forms |an implicit progn .
results |the values returned by the forms .
24–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Executes forms from left to right. Within the dynamic environment ofwith-compilation-unit ,
actions deferred by the compiler until the end of compilation will be deferred until the end of the
outermost call to with-compilation-unit .
The set of options permitted may be extended by the implementation, but the only standardized
keyword is :override .
If nested dynamically only the outer call to with-compilation-unit has any eect unless the value
associated with :override istrue, in which case warnings are deferred only to the end of the
innermost call for which override istrue.
The function compile-ﬁle provides the eect of
(with-compilation-unit (:override nil) ...)
around its code.
Any implementation-dependent extensions can only be provided as the result of an explicit
programmer request by use of an implementation-dependent keyword. Implementations are
forbidden from attaching additional meaning to a use of this macro which involves either no
keywords or just the keyword :override .
Examples:
If an implementation would normally defer certain kinds of warnings, such as warnings about
undened functions, to the end of a compilation unit (such as a le), the following example shows
how to cause those warnings to be deferred to the end of the compilation of several les.
(defun compile-files (&rest files)
(with-compilation-unit ()
(mapcar #’(lambda (file) (compile-file file)) files)))
(compile-files "A" "B" "C")
Note however that if the implementation does not normally defer any warnings, use of
with-compilation-unit might not have any eect.
See Also:
compile ,compile-ﬁle
System Construction 24–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
features
features Variable
Value Type:
aproper list .
Initial Value:
implementation-dependent .
Description:
The value of*features* is called the features list . It is a listofsymbols , called features , that
correspond to some aspect of the implementation orenvironment .
Most features have implementation-dependent meanings; The following meanings have been
assigned to feature names:
:cltl1
If present, indicates that the LISP package purports to conform to the 1984 specication
Common Lisp: The Language . It is possible, but not required, for a conforming
implementation to have this feature because this specication species that its symbols are
to be in the COMMON-LISP package , not the LISP package.
:cltl2
If present, indicates that the implementation purports to conform toCommon Lisp:
The Language, Second Edition . This feature must not be present in any conforming
implementation , since conformance to that document is not compatible with conformance
to this specication. The name, however, is reserved by this specication in order
to help programs distinguish implementations which conform to that document from
implementations which conform to this specication.
:ieee-floating-point
If present, indicates that the implementation purports to conform to the requirements of
IEEE Standard for Binary Floating-Point Arithmetic .
:x3j13
If present, indicates that the implementation conforms to some particular working draft of
this specication, or to some subset of features that approximates a belief about what this
specication might turn out to contain. A conforming implementation might or might not
contain such a feature. (This feature is intended primarily as a stopgap in order to provide
implementors something to use prior to the availability of a draft standard, in order to
discourage them from introducing the :draft-ansi-cl and:ansi-cl features prematurely.)
:draft-ansi-cl
24–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
features
If present, indicates that the implementation purports to conform to the rst full draft
of this specication, which went to public review in 1992. A conforming implementation
which has the :draft-ansi-cl-2 or:ansi-cl feature is not permitted to retain the
:draft-ansi-cl feature since incompatible changes were made subsequent to the rst draft.
:draft-ansi-cl-2
If present, indicates that a second full draft of this specication has gone to public review,
and that the implementation purports to conform to that specication. (If additional
public review drafts are produced, this keyword will continue to refer to the second draft,
and additional keywords will be added to identify conformance with such later drafts.
As such, the meaning of this keyword can be relied upon not to change over time.) A
conforming implementation which has the :ansi-cl feature is only permitted to retain the
:draft-ansi-cl feature if the nally approved standard is not incompatible with the draft
standard.
:ansi-cl
If present, indicates that this specication has been adopted by ANSI as an ocial
standard, and that the implementation purports to conform .
:common-lisp
This feature must appear in *features* for any implementation that has one or more of
the features :x3j13 ,:draft-ansi-cl , or:ansi-cl . It is intended that it should also appear
in implementations which have the features :cltl1 or:cltl2 , but this specication cannot
force such behavior. The intent is that this feature should identify the language family
named \Common Lisp," rather than some specic dialect within that family.
See Also:
Section 1.5.2.1.1 (Use of Read-Time Conditionals), Section 2.4 (Standard Macro Characters)
Notes:
The value of*features* is used by the #+and#-reader syntax.
Symbols in the features list may be in any package , but in practice they are generally in the KEYWORD
package . This is because KEYWORD is the package used by default when reading 2feature expressions
in the#+and#-reader macros .Code that needs to name a feature 2in a packageP(other than
KEYWORD ) can do so by making explicit use of a package prex forP, but note that such code must
also assure that the packagePexists in order for the feature expression to be read 2|even in cases
where the feature expression is expected to fail.
It is generally considered wise for an implementation to include one or more features identifying
the specic implementation , so that conditional expressions can be written which distinguish
idiosyncrasies of one implementation from those of another. Since features are normally symbols
in theKEYWORD package where name collisions might easily result, and since no uniquely dened
System Construction 24–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
mechanism is designated for deciding who has the right to use which symbol for what reason, a
conservative strategy is to prefer names derived from one's own company or product name, since
those names are often trademarked and are hence less likely to be used unwittingly by another
implementation .
compile-ﬁle-pathname ,compile-ﬁle-truename 
Variable
Value Type:
The value of*compile-ﬁle-pathname* must always be a pathname ornil. The value of
*compile-ﬁle-truename* must always be a physical pathname ornil.
Initial Value:
nil.
Description:
During a call to compile-ﬁle ,*compile-ﬁle-pathname* isbound to the pathname denoted
by the rst argument to compile-ﬁle , merged against the defaults; that is, it is bound to
(pathname (merge-pathnames input-le )). During the same time interval, *compile-ﬁle-truename*
isbound to the truename of the lebeing compiled .
At other times, the value of these variables isnil.
If a break loop is entered while compile-ﬁle is ongoing, it is implementation-dependent whether
these variables retain the values they had just prior to entering the break loop or whether they are
bound tonil.
The consequences are unspecied if an attempt is made to assign orbind either of these variables .
Aﬀected By:
The le system .
See Also:
compile-ﬁle
24–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
load-pathname,load-truename Variable
Value Type:
The value of*load-pathname* must always be a pathname ornil. The value of*load-truename*
must always be a physical pathname ornil.
Initial Value:
nil.
Description:
During a call to load,*load-pathname* isbound to the pathname denoted by the the rst argument
toload, merged against the defaults; that is, it is bound to(pathname (merge-pathnames lespec)).
During the same time interval, *load-truename* isbound to the truename of the lebeing loaded.
At other times, the value of these variables isnil.
If a break loop is entered while load is ongoing, it is implementation-dependent whether these
variables retain the values they had just prior to entering the break loop or whether they are bound
tonil.
The consequences are unspecied if an attempt is made to assign orbind either of these variables .
Aﬀected By:
The le system .
See Also:
load
compile-print,compile-verbose  Variable
Value Type:
ageneralized boolean .
Initial Value:
implementation-dependent .
Description:
The value of*compile-print* is the default value of the :print argument tocompile-ﬁle . The
value of*compile-verbose* is the default value of the :verbose argument tocompile-ﬁle .
See Also:
compile-ﬁle
System Construction 24–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
load-print,load-verbose Variable
Value Type:
ageneralized boolean .
Initial Value:
The initial value of*load-print* isfalse. The initial value of*load-verbose* isimplementation-
dependent .
Description:
The value of*load-print* is the default value of the :print argument toload. The value of
*load-verbose* is the default value of the :verbose argument toload.
See Also:
load
modules Variable
Value Type:
alistofstrings .
Initial Value:
implementation-dependent .
Description:
The value of*modules* is a list of names of the modules that have been loaded into the current
Lisp image .
Aﬀected By:
provide
See Also:
provide ,require
Notes:
The variable *modules* is deprecated.
24–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
provide, require
provide,require Function
Syntax:
provide module-name!implementation-dependent
require module-name &optional pathname-list!implementation-dependent
Arguments and Values:
module-name |astring designator .
pathname-list |nil, or a designator for a non-empty list ofpathname designators . The default is
nil.
Description:
provide adds the module-name to the listheld by*modules* , if such a name is not already present.
require tests for the presence of the module-name in the listheld by*modules* . If it is present,
require immediately returns. Otherwise, an attempt is made to load an appropriate set of les as
follows: The pathname-list argument, if non-nil , species a list of pathnames to be loaded in order,
from left to right. If the pathname-list isnil, an implementation-dependent mechanism will be
invoked in an attempt to load the module named module-name ; if no such module can be loaded,
an error of typeerror is signaled.
Both functions use string= to test for the presence of a module-name .
Examples:
;;; This illustrates a nonportable use of REQUIRE, because it
;;; depends on the implementation-dependent file-loading mechanism.
(require "CALCULUS")
;;; This use of REQUIRE is nonportable because of the literal
;;; physical pathname.
(require "CALCULUS" "/usr/lib/lisp/calculus")
;;; One form of portable usage involves supplying a logical pathname,
;;; with appropriate translations defined elsewhere.
(require "CALCULUS" "lib:calculus")
;;; Another form of portable usage involves using a variable or
;;; table lookup function to determine the pathname, which again
System Construction 24–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
provide, require
;;; must be initialized elsewhere.
(require "CALCULUS" *calculus-module-pathname*)
Side Eﬀects:
provide modies*modules* .
Aﬀected By:
The specic action taken by require is aected by calls to provide (or, in general, any changes to
thevalue of*modules* ).
Exceptional Situations:
Should signal an error of typetype-error ifmodule-name is not a string designator .
Ifrequire fails to perform the requested operation due to a problem while interacting with the le
system , an error of typeﬁle-error is signaled.
An error of typeﬁle-error might be signaled if any pathname inpathname-list is adesignator for a
wild pathname .
See Also:
*modules* , Section 19.1.2 (Pathnames as Filenames)
Notes:
The functions provide andrequire are deprecated.
If a module consists of a single package , it is customary for the package and module names to be
the same.
24–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
25. Environment
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Environment iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
25.1 The External Environment
25.1.1 Top level loop
The top level loop is the Common Lisp mechanism by which the user normally interacts with the
Common Lisp system. This loop is sometimes referred to as the Lisp read-eval-print loop because
it typically consists of an endless loop that reads an expression, evaluates it and prints the results.
The top level loop is not completely specied; thus the user interface is implementation-dened .
The top level loop prints all values resulting from the evaluation of a form . Figure 25{1 lists
variables that are maintained by the Lisp read-eval-print loop .
* + / -
** ++ //
*** +++ ///
Figure 25–1. Variables maintained by the Read-Eval-Print Loop
25.1.2 Debugging Utilities
Figure 25{2 shows dened names relating to debugging.
*debugger-hook* documentation step
apropos dribble time
apropos-list ed trace
break inspect untrace
describe invoke-debugger
Figure 25–2. Deﬁned names relating to debugging
25.1.3 Environment Inquiry
Environment inquiry dened names provide information about the hardware and software
conguration on which a Common Lisp program is being executed.
Figure 25{3 shows dened names relating to environment inquiry.
Environment 25–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
*features* machine-instance short-site-name
lisp-implementation-type machine-type software-type
lisp-implementation-version machine-version software-version
long-site-name room
Figure 25–3. Deﬁned names relating to environment inquiry.
25.1.4 Time
Time is represented in four dierent ways in Common Lisp: decoded time ,universal time ,internal
time, and seconds. Decoded time and universal time are used primarily to represent calendar time,
and are precise only to one second. Internal time is used primarily to represent measurements of
computer time (such as run time) and is precise to some implementation-dependent fraction of a
second called an internal time unit , as specied by internal-time-units-per-second . An internal
time can be used for either absolute and relative time measurements. Both a universal time and a
decoded time can be used only for absolute time measurements. In the case of one function, sleep ,
time intervals are represented as a non-negative realnumber of seconds.
Figure 25{4 shows dened names relating to time.
decode-universal-time get-internal-run-time
encode-universal-time get-universal-time
get-decoded-time internal-time-units-per-second
get-internal-real-time sleep
Figure 25–4. Deﬁned names involving Time.
25.1.4.1 Decoded Time
Adecoded time is an ordered series of nine values that, taken together, represent a point in
calendar time (ignoring leap seconds ):
Second
Aninteger between 0 and 59, inclusive.
Minute
Aninteger between 0 and 59, inclusive.
Hour
Aninteger between 0 and 23, inclusive.
25–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Date
Aninteger between 1 and 31, inclusive (the upper limit actually depends on the month
and year, of course).
Month
Aninteger between 1 and 12, inclusive; 1 means January, 2 means February, and so on;
12 means December.
Year
Aninteger indicating the year A.D. However, if this integer is between 0 and 99, the
\obvious" year is used; more precisely, that year is assumed that is equal to the integer
modulo 100 and within fty years of the current year (inclusive backwards and exclusive
forwards). Thus, in the year 1978, year 28 is 1928 but year 27 is 2027. (Functions that
return time in this format always return a full year number.)
Day of week
Aninteger between 0 and 6, inclusive; 0 means Monday, 1 means Tuesday, and so on;
6 means Sunday.
Daylight saving time ﬂag
Ageneralized boolean that, if true, indicates that daylight saving time is in eect.
Time zone
Atime zone .
Figure 25{5 shows dened names relating to decoded time .
decode-universal-time get-decoded-time
Figure 25–5. Deﬁned names involving time in Decoded Time.
25.1.4.2 Universal Time
Universal time is an absolute time represented as a single non-negative integer |the number of
seconds since midnight, January 1, 1900 GMT (ignoring leap seconds ). Thus the time 1 is 00:00:01
(that is, 12:00:01 a.m.) on January 1, 1900 GMT. Similarly, the time 2398291201 corresponds to
time 00:00:01 on January 1, 1976 GMT. Recall that the year 1900 was not a leap year; for the
purposes of Common Lisp, a year is a leap year if and only if its number is divisible by 4, except
that years divisible by 100 are not leap years, except that years divisible by 400 are leap years.
Environment 25–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Therefore the year 2000 will be a leap year. Because universal time must be a non-negative integer ,
times before the base time of midnight, January 1, 1900 GMT cannot be processed by Common
Lisp.
decode-universal-time get-universal-time
encode-universal-time
Figure 25–6. Deﬁned names involving time in Universal Time.
25.1.4.3 Internal Time
Internal time represents time as a single integer , in terms of an implementation-dependent unit
called an internal time unit . Relative time is measured as a number of these units. Absolute time
is relative to an arbitrary time base.
Figure 25{7 shows dened names related to internal time .
get-internal-real-time internal-time-units-per-second
get-internal-run-time
Figure 25–7. Deﬁned names involving time in Internal Time.
25.1.4.4 Seconds
One function, sleep , takes its argument as a non-negative realnumber of seconds. Informally, it
may be useful to think of this as a relative universal time , but it diers in one important way:
universal times are always non-negative integers , whereas the argument to sleep can be any kind
of non-negative real, in order to allow for the possibility of fractional seconds.
sleep
Figure 25–8. Deﬁned names involving time in Seconds.
25–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
decode-universal-time Function
Syntax:
decode-universal-time universal-time &optional time-zone
!second, minute, hour, date, month, year, day, daylight-p, zone
Arguments and Values:
universal-time |auniversal time .
time-zone |atime zone .
second ,minute ,hour,date,month ,year,day,daylight-p ,zone|adecoded time .
Description:
Returns the decoded time represented by the given universal time .
Iftime-zone is not supplied, it defaults to the current time zone adjusted for daylight saving time.
Iftime-zone is supplied, daylight saving time information is ignored. The daylight saving time ag
isniliftime-zone is supplied.
Examples:
(decode-universal-time 0 0) !0, 0, 0, 1, 1, 1900, 0, false, 0
;; The next two examples assume Eastern Daylight Time.
(decode-universal-time 2414296800 5) !0, 0, 1, 4, 7, 1976, 6, false, 5
(decode-universal-time 2414293200) !0, 0, 1, 4, 7, 1976, 6, true, 5
;; This example assumes that the time zone is Eastern Daylight Time
;; (and that the time zone is constant throughout the example).
(let* ((here (nth 8 (multiple-value-list (get-decoded-time)))) ;Time zone
(recently (get-universal-time))
(a (nthcdr 7 (multiple-value-list (decode-universal-time recently))))
(b (nthcdr 7 (multiple-value-list (decode-universal-time recently here)))))
(list a b (equal a b))) !((T 5) (NIL 5) NIL)
Aﬀected By:
Implementation-dependent mechanisms for calculating when or if daylight savings time is in eect
for any given session.
See Also:
encode-universal-time ,get-universal-time , Section 25.1.4 (Time)
Environment 25–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
encode-universal-time function
Syntax:
encode-universal-time second minute hour date month year
&optional time-zone
!universal-time
Arguments and Values:
second ,minute ,hour,date,month ,year,time-zone |the corresponding parts of a decoded time .
(Note that some of the nine values in a full decoded time are redundant, and so are not used as
inputs to this function.)
universal-time |auniversal time .
Description:
encode-universal-time converts a time from Decoded Time format to a universal time .
Iftime-zone is supplied, no adjustment for daylight savings time is performed.
Examples:
(encode-universal-time 0 0 0 1 1 1900 0) !0
(encode-universal-time 0 0 1 4 7 1976 5) !2414296800
;; The next example assumes Eastern Daylight Time.
(encode-universal-time 0 0 1 4 7 1976) !2414293200
See Also:
decode-universal-time ,get-decoded-time
get-universal-time,get-decoded-time Function
Syntax:
get-universal-time hno argumentsi ! universal-time
get-decoded-time hno argumentsi
!second, minute, hour, date, month, year, day, daylight-p, zone
Arguments and Values:
universal-time |auniversal time .
second ,minute ,hour,date,month ,year,day,daylight-p ,zone|adecoded time .
25–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
get-universal-time returns the current time, represented as a universal time .
get-decoded-time returns the current time, represented as a decoded time .
Examples:
;; At noon on July 4, 1976 in Eastern Daylight Time.
(get-decoded-time) !0, 0, 12, 4, 7, 1976, 6, true, 5
;; At exactly the same instant.
(get-universal-time) !2414332800
;; Exactly five minutes later.
(get-universal-time) !2414333100
;; The difference is 300 seconds (five minutes)
(- * **)!300
Aﬀected By:
The time of day ( i.e., the passage of time), the system clock's ability to keep accurate time, and
the accuracy of the system clock's initial setting.
Exceptional Situations:
An error of typeerror might be signaled if the current time cannot be determined.
See Also:
decode-universal-time ,encode-universal-time , Section 25.1.4 (Time)
Notes:
(get-decoded-time) (decode-universal-time (get-universal-time))
Noimplementation is required to have a way to verify that the time returned is correct. However,
if an implementation provides a validity check ( e.g., the failure to have properly initialized the
system clock can be reliably detected) and that validity check fails, the implementation is strongly
encouraged (but not required) to signal an error of typeerror (rather than, for example, returning
a known-to-be-wrong value) that is correctable by allowing the user to interactively set the correct
time.
sleep Function
Syntax:
sleep seconds!nil
Arguments and Values:
seconds |a non-negative real.
Environment 25–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Causes execution to cease and become dormant for approximately the seconds of real time indicated
byseconds , whereupon execution is resumed.
Examples:
(sleep 1)!NIL
;; Actually, since SLEEP is permitted to use approximate timing,
;; this might not always yield true, but it will often enough that
;; we felt it to be a productive example of the intent.
(let ((then (get-universal-time))
(now (progn (sleep 10) (get-universal-time))))
(>= (- now then) 10))
!true
Side Eﬀects:
Causes processing to pause.
Aﬀected By:
The granularity of the scheduler.
Exceptional Situations:
Should signal an error of typetype-error ifseconds is not a non-negative real.
apropos,apropos-list Function
Syntax:
apropos string&optional package!hno valuesi
apropos-list string&optional package!symbols
Arguments and Values:
string |astring designator .
package |apackage designator ornil. The default is nil.
symbols |alistofsymbols .
Description:
These functions search for interned symbols whose names contain the substring string .
25–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Forapropos , as each such symbol is found, its name is printed on standard output . In addition,
if such a symbol is dened as a function ordynamic variable , information about those denitions
might also be printed.
Forapropos-list , no output occurs as the search proceeds; instead a list of the matching symbols
is returned when the search is complete.
Ifpackage isnon-nil , only the symbols accessible in that package are searched; otherwise all symbols
accessible in any package are searched.
Because a symbol might be available by way of more than one inheritance path, apropos might
print information about the same symbol more than once, or apropos-list might return a list
containing duplicate symbols .
Whether or not the search is case-sensitive is implementation-dened .
Aﬀected By:
The set of symbols which are currently interned in any packages being searched.
apropos is also aected by *standard-output* .
describe Function
Syntax:
describe object&optional stream!hno valuesi
Arguments and Values:
object |an object .
stream |an output stream designator . The default is standard output .
Description:
describe displays information about object tostream .
For example, describe of a symbol might show the symbol 's value, its denition, and each of its
properties. describe of a oat might show the number's internal representation in a way that
is useful for tracking down round-o errors. In all cases, however, the nature and format of the
output of describe isimplementation-dependent .
describe can describe something that it nds inside the object ; in such cases, a notational device
such as increased indentation or positioning in a table is typically used in order to visually
distinguish such recursive descriptions from descriptions of the argument object .
Environment 25–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
The actual act of describing the object is implemented by describe-object .describe exists as an
interface primarily to manage argument defaulting (including conversion of arguments tandnil
into stream objects ) and to inhibit any return values from describe-object .
describe is not intended to be an interactive function. In a conforming implementation ,describe
must not, by default, prompt for user input. User-dened methods for describe-object are likewise
restricted.
Side Eﬀects:
Output to standard output orterminal I/O .
Aﬀected By:
*standard-output* and*terminal-io* , methods on describe-object andprint-object forobjects
having user-dened classes .
See Also:
inspect ,describe-object
describe-object Standard Generic Function
Syntax:
describe-object object stream!implementation-dependent
Method Signatures:
describe-object (object standard-object) stream
Arguments and Values:
object |an object .
stream |astream .
Description:
The generic function describe-object prints a description of object to a stream .describe-object is
called by describe ; it must not be called by the user.
Each implementation is required to provide a method on the classstandard-object andmethods on
enough other classes so as to ensure that there is always an applicable method . Implementations
are free to add methods for other classes . Users can write methods fordescribe-object for their
own classes if they do not wish to inherit an implementation-supplied method .
Methods ondescribe-object can recursively call describe . Indentation, depth limits, and circularity
detection are all taken care of automatically, provided that each method handles exactly one level
of structure and calls describe recursively if there are more structural levels. The consequences are
undened if this rule is not obeyed.
25–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
In some implementations the stream argument passed to a describe-object method is not the
original stream , but is an intermediate stream that implements parts of describe .Methods should
therefore not depend on the identity of this stream .
Examples:
(defclass spaceship ()
((captain :initarg :captain :accessor spaceship-captain)
(serial# :initarg :serial-number :accessor spaceship-serial-number)))
(defclass federation-starship (spaceship) ())
(defmethod describe-object ((s spaceship) stream)
(with-slots (captain serial#) s
(format stream "~&~S is a spaceship of type ~S,~
~%with ~A at the helm ~
and with serial number ~D.~%"
s (type-of s) captain serial#)))
(make-instance ’federation-starship
:captain "Rachel Garrett"
:serial-number "NCC-1701-C")
!#<FEDERATION-STARSHIP 26312465>
(describe *)
.#<FEDERATION-STARSHIP 26312465> is a spaceship of type FEDERATION-STARSHIP,
.with Rachel Garrett at the helm and with serial number NCC-1701-C.
!hno valuesi
See Also:
describe
Notes:
The same implementation techniques that are applicable to print-object are applicable to
describe-object .
The reason for making the return values for describe-object unspecied is to avoid forcing users
to include explicit (values) in all of their methods .describe takes care of that.
Environment 25–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
trace, untrace
trace,untrace Macro
Syntax:
traceffunction-nameg*!trace-result
untraceffunction-nameg*!untrace-result
Arguments and Values:
function-name |afunction name .
trace-result |implementation-dependent , unless no function-names are supplied, in which case
trace-result is alistoffunction names .
untrace-result |implementation-dependent .
Description:
trace anduntrace control the invocation of the trace facility.
Invoking trace with one or more function-names causes the denoted functions to be \traced."
Whenever a traced function is invoked, information about the call, about the arguments passed,
and about any eventually returned values is printed to trace output . Iftrace is used with no
function-names , no tracing action is performed; instead, a list of the functions currently being
traced is returned.
Invoking untrace with one or more function names causes those functions to be \untraced" ( i.e.,
no longer traced). If untrace is used with no function-names , all functions currently being traced
are untraced.
If afunction to be traced has been open-coded ( e.g., because it was declared inline ), a call to that
function might not produce trace output.
Examples:
(defun fact (n) (if (zerop n) 1 (* n (fact (- n 1)))))
!FACT
(trace fact)
!(FACT)
;; Of course, the format of traced output is implementation-dependent.
(fact 3)
.1 Enter FACT 3
.| 2 Enter FACT 2
.| 3 Enter FACT 1
.| | 4 Enter FACT 0
.| | 4 Exit FACT 1
.| 3 Exit FACT 1
.| 2 Exit FACT 2
25–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
.1 Exit FACT 6
!6
Side Eﬀects:
Might change the denitions of the functions named by function-names .
Aﬀected By:
Whether the functions named are dened or already being traced.
Exceptional Situations:
Tracing an already traced function, or untracing a function not currently being traced, should
produce no harmful eects, but might signal a warning.
See Also:
*trace-output* ,step
Notes:
trace anduntrace may also accept additional implementation-dependent argument formats. The
format of the trace output is implementation-dependent .
Although trace can be extended to permit non-standard options, implementations are nevertheless
encouraged (but not required) to warn about the use of syntax or options that are neither
specied by this standard nor added as an extension by the implementation , since they could be
symptomatic of typographical errors or of reliance on features supported in implementations other
than the current implementation .
step Macro
Syntax:
step form!f resultg*
Arguments and Values:
form|aform ; evaluated as described below.
results |the values returned by the form.
Description:
step implements a debugging paradigm wherein the programmer is allowed to step through the
evaluation of a form . The specic nature of the interaction, including which I/O streams are used
and whether the stepping has lexical or dynamic scope, is implementation-dened .
Environment 25–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
step evaluates form in the current environment . A call to step can be compiled, but it is acceptable
for an implementation to interactively step through only those parts of the computation that are
interpreted.
It is technically permissible for a conforming implementation to take no action at all other than
normal execution of the form. In such a situation, (step form)is equivalent to, for example,
(let () form). In implementations where this is the case, the associated documentation should
mention that fact.
See Also:
trace
Notes:
Implementations are encouraged to respond to the typing of ?or the pressing of a \help key" by
providing help including a list of commands.
time Macro
Syntax:
time form!f resultg*
Arguments and Values:
form|aform ; evaluated as described below.
results |the values returned by the form.
Description:
time evaluates form in the current environment (lexical and dynamic). A call to time can be
compiled.
time prints various timing data and other information to trace output . The nature and format
of the printed information is implementation-dened . Implementations are encouraged to provide
such information as elapsed real time, machine run time, and storage management statistics.
Aﬀected By:
The accuracy of the results depends, among other things, on the accuracy of the corresponding
functions provided by the underlying operating system.
The magnitude of the results may depend on the hardware, the operating system, the lisp
implementation, and the state of the global environment. Some specic issues which frequently
aect the outcome are hardware speed, nature of the scheduler (if any), number of competing
processes (if any), system paging, whether the call is interpreted or compiled, whether functions
called are compiled, the kind of garbage collector involved and whether it runs, whether internal
data structures (e.g., hash tables) are implicitly reorganized, etc.
25–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
get-internal-real-time ,get-internal-run-time
Notes:
In general, these timings are not guaranteed to be reliable enough for marketing comparisons.
Their value is primarily heuristic, for tuning purposes.
For useful background information on the complicated issues involved in interpreting timing results,
seePerformance and Evaluation of Lisp Programs .
internal-time-units-per-second Constant Variable
Constant Value:
A positive integer , the magnitude of which is implementation-dependent .
Description:
The number of internal time units in one second.
See Also:
get-internal-run-time ,get-internal-real-time
Notes:
These units form the basis of the Internal Time format representation.
get-internal-real-time Function
Syntax:
get-internal-real-time hno argumentsi ! internal-time
Arguments and Values:
internal-time |a non-negative integer .
Description:
get-internal-real-time returns as an integer the current time in internal time units , relative to an
arbitrary time base. The dierence between the values of two calls to this function is the amount
of elapsed real time ( i.e., clock time) between the two calls.
Aﬀected By:
Time of day ( i.e., the passage of time). The time base aects the result magnitude.
Environment 25–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
internal-time-units-per-second
get-internal-run-time Function
Syntax:
get-internal-run-time hno argumentsi ! internal-time
Arguments and Values:
internal-time |a non-negative integer .
Description:
Returns as an integer the current run time in internal time units . The precise meaning of this
quantity is implementation-dened ; it may measure real time, run time, CPU cycles, or some other
quantity. The intent is that the dierence between the values of two calls to this function be the
amount of time between the two calls during which computational eort was expended on behalf
of the executing program.
Aﬀected By:
The implementation , the time of day ( i.e., the passage of time).
See Also:
internal-time-units-per-second
Notes:
Depending on the implementation , paging time and garbage collection time might be included in
this measurement. Also, in a multitasking environment, it might not be possible to show the time
for just the running process, so in some implementations , time taken by other processes during the
same time interval might be included in this measurement as well.
25–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
disassemble Function
Syntax:
disassemble fn!nil
Arguments and Values:
fn|an extended function designator or a lambda expression .
Description:
The functiondisassemble is a debugging aid that composes symbolic instructions or expressions in
some implementation-dependent language which represent the code used to produce the function
which is or is named by the argument fn. The result is displayed to standard output in an
implementation-dependent format.
Iffnis alambda expression orinterpreted function , it is compiled rst and the result is disassembled.
If the fndesignator is a function name , the function that it names is disassembled. (If that
function is an interpreted function , it is rst compiled but the result of this implicit compilation is
not installed.)
Examples:
(defun f (a) (1+ a)) !F
(eq (symbol-function ’f)
(progn (disassemble ’f)
(symbol-function ’f))) !true
Aﬀected By:
*standard-output* .
Exceptional Situations:
Should signal an error of typetype-error iffnis not an extended function designator or a lambda
expression .
documentation,(setfdocumentation) Standard Generic
Function
Syntax:
documentation x doc-type!documentation
(setf documentation) new-value x doc-type !new-value
Environment 25–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
documentation, (setf documentation)
Argument Precedence Order:
doc-type ,object
Method Signatures:
Functions, Macros, and Special Forms:
documentation (xfunction ) (doc-type (eql ’t) )
documentation (xfunction ) (doc-type (eql ’function) )
documentation (xlist) (doc-type (eql ’function) )
documentation (xlist) (doc-type (eql ’compiler-macro) )
documentation (xsymbol ) (doc-type (eql ’function) )
documentation (xsymbol ) (doc-type (eql ’compiler-macro) )
documentation (xsymbol ) (doc-type (eql ’setf) )
(setf documentation) new-value (xfunction ) (doc-type (eql ’t) )
(setf documentation) new-value (xfunction ) (doc-type (eql ’function) )
(setf documentation) new-value (xlist) (doc-type (eql ’function) )
(setf documentation) new-value (xlist) (doc-type (eql ’compiler-macro) )
(setf documentation) new-value (xsymbol ) (doc-type (eql ’function) )
(setf documentation) new-value (xsymbol ) (doc-type (eql ’compiler-macro) )
(setf documentation) new-value (xsymbol ) (doc-type (eql ’setf) )
Method Combinations:
documentation (xmethod-combination ) (doc-type (eql ’t) )
documentation (xmethod-combination ) (doc-type (eql ’method-combination) )
documentation (xsymbol ) (doc-type (eql ’method-combination) )
(setf documentation) new-value (xmethod-combination ) (doc-type (eql ’t) )
(setf documentation) new-value (xmethod-combination ) (doc-type (eql ’method-combination) )
(setf documentation) new-value (xsymbol ) (doc-type (eql ’method-combination) )
Methods:
25–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
documentation, (setf documentation)
documentation (xstandard-method ) (doc-type (eql ’t) )
(setf documentation) new-value (xstandard-method ) (doc-type (eql ’t) )
Packages:
documentation (xpackage ) (doc-type (eql ’t) )
(setf documentation) new-value (xpackage ) (doc-type (eql ’t) )
Types, Classes, and Structure Names:
documentation (xstandard-class ) (doc-type (eql ’t) )
documentation (xstandard-class ) (doc-type (eql ’type) )
documentation (xstructure-class ) (doc-type (eql ’t) )
documentation (xstructure-class ) (doc-type (eql ’type) )
documentation (xsymbol ) (doc-type (eql ’type) )
documentation (xsymbol ) (doc-type (eql ’structure) )
(setf documentation) new-value (xstandard-class ) (doc-type (eql ’t) )
(setf documentation) new-value (xstandard-class ) (doc-type (eql ’type) )
(setf documentation) new-value (xstructure-class ) (doc-type (eql ’t) )
(setf documentation) new-value (xstructure-class ) (doc-type (eql ’type) )
(setf documentation) new-value (xsymbol ) (doc-type (eql ’type) )
(setf documentation) new-value (xsymbol ) (doc-type (eql ’structure) )
Variables:
documentation (xsymbol ) (doc-type (eql ’variable) )
(setf documentation) new-value (xsymbol ) (doc-type (eql ’variable) )
Arguments and Values:
x|an object .
doc-type |asymbol .
documentation |astring , ornil.
new-value |astring .
Environment 25–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
documentation, (setf documentation)
Description:
The generic function documentation returns the documentation string associated with the given
object if it is available; otherwise it returns nil.
The generic function (setf documentation) updates the documentation string associated with xto
new-value . Ifxis alist, it must be of the form (setf symbol).
Documentation strings are made available for debugging purposes. Conforming programs are
permitted to use documentation strings when they are present, but should not depend for their
correct behavior on the presence of those documentation strings . An implementation is permitted
to discard documentation strings at any time for implementation-dened reasons.
The nature of the documentation string returned depends on the doc-type , as follows:
compiler-macro
Returns the documentation string of the compiler macro whose name is the function name
x.
function
Ifxis afunction name , returns the documentation string of the function ,macro , orspecial
operator whose name isx.
Ifxis afunction , returns the documentation string associated with x.
method-combination
Ifxis asymbol , returns the documentation string of the method combination whose name
isx.
Ifxis amethod combination , returns the documentation string associated with x.
setf
Returns the documentation string of the setf expander whose name is the symbol x.
structure
Returns the documentation string associated with the structure name x.
t
Returns a documentation string specialized on the class of the argument xitself. For
example, if xis a function , the documentation string associated with the function xis
returned.
type
25–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Ifxis asymbol , returns the documentation string of the class whose name is the symbol
x, if there is such a class . Otherwise, it returns the documentation string of the type which
is the type specier symbol x.
Ifxis astructure class orstandard class , returns the documentation string associated with
theclass x.
variable
Returns the documentation string of the dynamic variable orconstant variable whose
name is the symbol x.
Aconforming implementation or a conforming program may extend the set of symbols that are
acceptable as the doc-type .
Notes:
This standard prescribes no means to retrieve the documentation strings for individual slots
specied in a defclass form, but implementations might still provide debugging tools and/or
programming language extensions which manipulate this information. Implementors wishing to
provide such support are encouraged to consult the Metaobject Protocol for suggestions about how
this might be done.
room Function
Syntax:
room&optional x!implementation-dependent
Arguments and Values:
x|one oft,nil, or:default .
Description:
room prints, to standard output , information about the state of internal storage and its
management. This might include descriptions of the amount of memory in use and the degree of
memory compaction, possibly broken down by internal data type if that is appropriate. The nature
and format of the printed information is implementation-dependent . The intent is to provide
information that a programmer might use to tune a program for a particular implementation .
(room nil) prints out a minimal amount of information. (room t) prints out a maximal amount of
information. (room) or(room :default) prints out an intermediate amount of information that is
likely to be useful.
Side Eﬀects:
Output to standard output .
Environment 25–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Aﬀected By:
*standard-output* .
ed Function
Syntax:
ed&optional x!implementation-dependent
Arguments and Values:
x|nil, apathname , astring , or a function name . The default is nil.
Description:
edinvokes the editor if the implementation provides a resident editor.
Ifxisnil, the editor is entered. If the editor had been previously entered, its prior state is resumed,
if possible.
Ifxis apathname orstring , it is taken as the pathname designator for a leto be edited.
Ifxis afunction name , the text of its denition is edited. The means by which the function text
is obtained is implementation-dened .
Exceptional Situations:
The consequences are undened if the implementation does not provide a resident editor.
Might signal type-error if its argument is supplied but is not a symbol , apathname , ornil.
If a failure occurs when performing some operation on the le system while attempting to edit a
le, an error of typeﬁle-error is signaled.
An error of typeﬁle-error might be signaled if xis adesignator for a wild pathname .
Implementation-dependent additional conditions might be signaled as well.
See Also:
pathname ,logical-pathname ,compile-ﬁle ,load, Section 19.1.2 (Pathnames as Filenames)
25–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
inspect Function
Syntax:
inspect object!implementation-dependent
Arguments and Values:
object |an object .
Description:
inspect is an interactive version of describe . The nature of the interaction is implementation-
dependent , but the purpose of inspect is to make it easy to wander through a data structure,
examining and modifying parts of it.
Side Eﬀects:
implementation-dependent .
Aﬀected By:
implementation-dependent .
Exceptional Situations:
implementation-dependent .
See Also:
describe
Notes:
Implementations are encouraged to respond to the typing of ?or a \help key" by providing help,
including a list of commands.
dribble Function
Syntax:
dribble &optional pathname!implementation-dependent
Arguments and Values:
pathname |apathname designator .
Environment 25–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
Either binds*standard-input* and*standard-output* or takes other appropriate action, so as to
send a record of the input/output interaction to a le named by pathname .dribble is intended to
create a readable record of an interactive session.
Ifpathname is a logical pathname , it is translated into a physical pathname as if by calling
translate-logical-pathname .
(dribble) terminates the recording of input and output and closes the dribble le.
Ifdribble iscalled while a stream to a \dribble le" is still open from a previous calltodribble ,
the eect is implementation-dened . For example, the already- open stream might be closed , or
dribbling might occur both to the old stream and to a new one, or the old stream might stay open
but not receive any further output, or the new request might be ignored, or some other action
might be taken.
Aﬀected By:
The implementation .
Exceptional Situations:
If a failure occurs when performing some operation on the le system while creating the dribble
le, an error of typeﬁle-error is signaled.
An error of typeﬁle-error might be signaled if pathname is adesignator for a wild pathname .
See Also:
Section 19.1.2 (Pathnames as Filenames)
Notes:
dribble can return before subsequent forms are executed. It also can enter a recursive interaction
loop, returning only when (dribble) is done.
dribble is intended primarily for interactive debugging; its eect cannot be relied upon when used
in a program.
  Variable
Value Type:
aform .
Initial Value:
implementation-dependent .
25–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Description:
The value of-is the form that is currently being evaluated by the Lisp read-eval-print loop .
Examples:
(format t "~&Evaluating ~S~%" -)
.Evaluating (FORMAT T "~&Evaluating ~S~%" -)
!NIL
Aﬀected By:
Lisp read-eval-print loop .
See Also:
+(variable ),*(variable ),/(variable ), Section 25.1.1 (Top level loop)
+,++,+++ Variable
Value Type:
anobject .
Initial Value:
implementation-dependent .
Description:
The variables +,++, and+++ are maintained by the Lisp read-eval-print loop to save forms
that were recently evaluated .
The value of+is the last form that was evaluated , the value of++is the previous value of +,
and the value of+++ is the previous value of ++.
Examples:
(+ 0 1)!1
(- 4 2)!2
(/ 9 3)!3
(list + ++ +++) !((/ 9 3) (- 4 2) (+ 0 1))
(setq a 1 b 2 c 3 d (list a b c)) !(1 2 3)
(setq a 4 b 5 c 6 d (list a b c)) !(4 5 6)
(list a b c)!(4 5 6)
(eval +++)!(1 2 3)
#.‘(,@++ d)!(1 2 3 (1 2 3))
Environment 25–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Aﬀected By:
Lisp read-eval-print loop .
See Also:
-(variable ),*(variable ),/(variable ), Section 25.1.1 (Top level loop)
,, Variable
Value Type:
anobject .
Initial Value:
implementation-dependent .
Description:
The variables *,**, and***are maintained by the Lisp read-eval-print loop to save the values of
results that are printed each time through the loop.
The value of*is the most recent primary value that was printed, the value of**is the previous
value of*, and the value of***is the previous value of **.
If several values are produced, *contains the rst value only; *containsnilif zero values are
produced.
The values of*,**, and***are updated immediately prior to printing the return value of a
top-level form by the Lisp read-eval-print loop . If the evaluation of such a form is aborted prior to
its normal return, the values of *,**, and***are not updated.
Examples:
(values ’a1 ’a2) !A1, A2
’b!B
(values ’c1 ’c2 ’c3) !C1, C2, C3
(list * ** ***) !(C1 B A1)
(defun cube-root (x) (expt x 1/3)) !CUBE-ROOT
(compile *)!CUBE-ROOT
(setq a (cube-root 27.0)) !3.0
(* * 9.0)!27.0
Aﬀected By:
Lisp read-eval-print loop .
25–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
-(variable ),+(variable ),/(variable ), Section 25.1.1 (Top level loop)
Notes:
*(car /)
**(car //)
***(car ///)
/,//,/// Variable
Value Type:
aproper list .
Initial Value:
implementation-dependent .
Description:
The variables /,//, and///are maintained by the Lisp read-eval-print loop to save the values of
results that were printed at the end of the loop.
The value of/is alistof the most recent values that were printed, the value of//is the previous
value of/, and the value of///is the previous value of //.
The values of/,//, and///are updated immediately prior to printing the return value of a
top-level form by the Lisp read-eval-print loop . If the evaluation of such a form is aborted prior to
its normal return, the values of /,//, and///are not updated.
Examples:
(floor 22 7)!3, 1
(+ (* (car /) 7) (cadr /)) !22
Aﬀected By:
Lisp read-eval-print loop .
See Also:
-(variable ),+(variable ),*(variable ), Section 25.1.1 (Top level loop)
Environment 25–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
lisp-implementation-type,lisp-implementation-
version Function
Syntax:
lisp-implementation-type hno argumentsi ! description
lisp-implementation-version hno argumentsi ! description
Arguments and Values:
description |astring ornil.
Description:
lisp-implementation-type andlisp-implementation-version identify the current implementation
of Common Lisp.
lisp-implementation-type returns a string that identies the generic name of the particular
Common Lisp implementation.
lisp-implementation-version returns a string that identies the version of the particular Common
Lisp implementation.
If no appropriate and relevant result can be produced, nilis returned instead of a string .
Examples:
(lisp-implementation-type)
!"ACME Lisp"
or!"Joe’s Common Lisp"
(lisp-implementation-version)
!"1.3a"
!"V2"or!"Release 17.3, ECO #6"
short-site-name,long-site-name Function
Syntax:
short-site-name hno argumentsi ! description
long-site-namehno argumentsi ! description
25–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Arguments and Values:
description |astring ornil.
Description:
short-site-name andlong-site-name return a string that identies the physical location of the
computer hardware, or nilif no appropriate description can be produced.
Examples:
(short-site-name)
!"MIT AI Lab"or!"CMU-CSD"
(long-site-name)
!"MIT Artificial Intelligence Laboratory"
or!"CMU Computer Science Department"
Aﬀected By:
The implementation, the location of the computer hardware, and the installation/conguration
process.
machine-instance Function
Syntax:
machine-instance hno argumentsi ! description
Arguments and Values:
description |astring ornil.
Description:
Returns a string that identies the particular instance of the computer hardware on which Common
Lisp is running, or nilif no such string can be computed.
Examples:
(machine-instance)
!"ACME.COM"or!"S/N 123231"or!"18.26.0.179"or!"AA-00-04-00-A7-A4"
Aﬀected By:
The machine instance, and the implementation .
Environment 25–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
See Also:
machine-type ,machine-version
machine-type Function
Syntax:
machine-typehno argumentsi ! description
Arguments and Values:
description |astring ornil.
Description:
Returns a string that identies the generic name of the computer hardware on which Common
Lisp is running.
Examples:
(machine-type)
!"DEC PDP-10"or!"Symbolics LM-2"
Aﬀected By:
The machine type. The implementation.
See Also:
machine-version
machine-version Function
Syntax:
machine-version hno argumentsi ! description
Arguments and Values:
description |astring ornil.
Description:
Returns a string that identies the version of the computer hardware on which Common Lisp is
running, or nilif no such value can be computed.
25–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Examples:
(machine-version) !"KL-10, microcode 9"
Aﬀected By:
The machine version, and the implementation .
See Also:
machine-type ,machine-instance
software-type,software-version Function
Syntax:
software-typehno argumentsi ! description
software-version hno argumentsi ! description
Arguments and Values:
description |astring ornil.
Description:
software-type returns a string that identies the generic name of any relevant supporting software,
ornilif no appropriate or relevant result can be produced.
software-version returns a string that identies the version of any relevant supporting software,
ornilif no appropriate or relevant result can be produced.
Examples:
(software-type) !"Multics"
(software-version) !"1.3x"
Aﬀected By:
Operating system environment.
Notes:
This information should be of use to maintainers of the implementation .
Environment 25–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
user-homedir-pathname
user-homedir-pathname Function
Syntax:
user-homedir-pathname &optional host!pathname
Arguments and Values:
host|astring , alistofstrings , or:unspecific .
pathname |apathname , ornil.
Description:
user-homedir-pathname determines the pathname that corresponds to the user's home directory
onhost. If host is not supplied, its value is implementation-dependent . For a description of
:unspecific , see Section 19.2.1 (Pathname Components).
The denition of home directory is implementation-dependent , but dened in Common Lisp to
mean the directory where the user keeps personal les such as initialization les and mail.
user-homedir-pathname returns a pathname without any name, type, or version component
(those components are all nil) for the user's home directory on host.
If it is impossible to determine the user's home directory on host, thennilis returned.
user-homedir-pathname never returns nilifhost is not supplied.
Examples:
(pathnamep (user-homedir-pathname)) !true
Aﬀected By:
The host computer's le system, and the implementation .
25–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
26. Glossary
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Glossary iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
26.1 Glossary
Each entry in this glossary has the following parts:
the term being dened, set in boldface.
optional pronunciation, enclosed in square brackets and set in boldface, as in the following
example: [alist]. The pronunciation key follows Webster's Third New International
Dictionary the English Language, Unabridged , except that \ " is used to notate the schwa
(upside-down \e") character.
the part or parts of speech, set in italics. If a term can be used as several parts of speech, there
is a separate denition for each part of speech.
one or more denitions, organized as follows:
{ an optional number, present if there are several denitions. Lowercase letters might also
be used in cases where subdenitions of a numbered denition are necessary.
{ an optional part of speech, set in italics, present if the term is one of several parts of
speech.
{ an optional discipline, set in italics, present if the term has a standard denition being
repeated. For example, \ Math. "
{ an optional context, present if this denition is meaningful only in that context. For
example, \(of a symbol )".
{ the denition.
{ an optional example sentence. For example, \This is an example of an example."
{ optional cross references.
In addition, some terms have idiomatic usage in the Common Lisp community which is not shared
by other communities, or which is not technically correct. Denitions labeled \ Idiom. " represent
such idiomatic usage; these denitions are sometimes followed by an explanatory note.
Words in this font are words with entries in the glossary. Words in example sentences do not follow
this convention.
When an ambiguity arises, the longest matching substring has precedence. For example, \ complex
oat" refers to a single glossary entry for \ complex oat " rather than the combined meaning of the
glossary terms \ complex " and \ oat."
Glossary 26–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Subscript notation, as in \ something n" means that the nth denition of \ something " is intended.
This notation is used only in situations where the context might be insucient to disambiguate.
The following are abbreviations used in the glossary:
Abbreviation Meaning
adj. adjective
adv. adverb
ANSI compatible with one or more ANSI standards
Comp. computers
Idiom. idiomatic
IEEE compatible with one or more IEEE standards
ISO compatible with one or more ISO standards
Math. mathematics
Trad. traditional
n. noun
v. verb
v.t. transitive verb
Non-alphabetic
()[nil],n.an alternative notation for writing the symbol nil, used to emphasize the
use of nilas an empty list .
A
absolute adj.1. (of a time) representing a specic point in time. 2. (of a pathname )
representing a specic position in a directory hierarchy. See relative .
access n.,v.t.1.v.t.(aplace , orarray ) toread 1orwrite 1thevalue of the place or an
element of the array . 2. n.(of a place ) an attempt to access 1thevalue of the place .
accessibility n.the state of being accessible .
accessible adj.1. (of an object ) capable of being referenced . 2. (of shared slots or
local slots in an instance of a class ) having been dened by the class of the instance
orinherited from a superclass of that class . 3. (of a symbol in a package ) capable of
being referenced without a package prex when that package is current, regardless of
whether the symbol ispresent in that package or is inherited .
accessor n.anoperator that performs an access . See reader and writer .
26–2 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
active adj.1. (of a handler , arestart , or a catch tag ) having been established but not
yetdisestablished . 2. (of an element of an array ) having an index that is greater than
or equal to zero, but less than the ll pointer (if any). For an array that has no ll
pointer , all elements are considered active .
actual adjustability n.(of an array ) ageneralized boolean that is associated with
thearray , representing whether the array isactually adjustable . See also expressed
adjustability andadjustable-array-p .
actual argument n. Trad. anargument .
actual array element type n.(of an array ) the type for which the array is actually
specialized, which is the upgraded array element type of the expressed array element
type of the array . See the functionarray-element-type .
actual complex part type n.(of a complex ) the typein which the real and imaginary
parts of the complex are actually represented, which is the upgraded complex part type
of the expressed complex part type of the complex .
actual parameter n. Trad. anargument .
actually adjustable adj. (of an array ) such that adjust-array can adjust its
characteristics by direct modication. A conforming program may depend on an array
being actually adjustable only if either that array is known to have been expressly
adjustable or if that array has been explicitly tested by adjustable-array-p .
adjustability n.(of an array ) 1. expressed adjustability . 2. actual adjustability .
adjustable adj.(of an array ) 1. expressly adjustable . 2. actually adjustable .
after method n.amethod having the qualier :after .
alist [—alist],n.anassociation list .
alphabetic n.,adj.1.adj.(of a character ) being one of the standard characters A
through Zorathrough z, or being any implementation-dened character that has case,
or being some other graphic character dened by the implementation to be alphabetic 1.
2. a. n.one of several possible constituent traits of acharacter . For details, see Section
2.1.4.1 (Constituent Characters) and Section 2.2 (Reader Algorithm). b. adj.(of a
character ) being a character that has syntax type constituent in the current readtable
and that has the constituent trait alphabetic 2a. See Figure 2{8.
alphanumeric adj.(of a character ) being either an alphabetic 1character or a numeric
character.
Glossary 26–3
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ampersand n.thestandard character that is called \ampersand" ( &). See Figure 2{5.
anonymous adj.1. (of a class orfunction ) having no name 2. (of a restart ) having a
name ofnil.
apparently uninterned adj. having a home package ofnil. (An apparently
uninterned symbol might or might not be an uninterned symbol .Uninterned symbols
have a home package ofnil, but symbols which have been uninterned from their home
package also have a home package ofnil, even though they might still be interned in
some other package .)
applicable adj.1. (of a handler ) being an applicable handler . 2. (of a method ) being
anapplicable method . 3. (of a restart ) being an applicable restart .
applicable handler n.(for a condition being signaled ) an active handler for which
the associated type contains the condition .
applicable method n.(of a generic function called with arguments ) amethod of the
generic function for which the arguments satisfy the parameter specializers of that
method . See Section 7.6.6.1.1 (Selecting the Applicable Methods).
applicable restart n.1. (for a condition ) an active handler for which the associated
test returns true when given the condition as an argument. 2. (for no particular
condition ) an active handler for which the associated test returns true when given nil
as an argument.
apply v.t.(afunction to a list) to callthefunction with arguments that are the
elements of the list. \Applying the function +to a list of integers returns the sum of
the elements of that list."
argument n.1. (of a function ) an object which is oered as data to the function
when it is called . 2. (of a format control ) aformat argument .
argument evaluation order n.the order in which arguments are evaluated in a
function call. \The argument evaluation order for Common Lisp is left to right." See
Section 3.1 (Evaluation).
argument precedence order n.the order in which the arguments to a generic
function are considered when sorting the applicable methods into precedence order.
around method n.amethod having the qualier :around .
array n.anobject oftypearray , which serves as a container for other objects arranged
in a Cartesian coordinate system.
26–4 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
array element type n.(of an array ) 1. a type associated with the array , and of
which all elements of the array are constrained to be members. 2. the actual array
element type of the array . 3. the expressed array element type of the array .
array total size n.the total number of elements in an array , computed by taking
the product of the dimensions of the array . (The size of a zero-dimensional array is
therefore one.)
assign v.t.(avariable ) to change the value of the variable in a binding that has
already been established . See the special operator setq.
association list n.alistofconses representing an association of keys with values ,
where the carof each cons is the keyand the cdris the value associated with that key.
asterisk n.thestandard character that is variously called \asterisk" or \star" ( *).
See Figure 2{5.
at-sign n.thestandard character that is variously called \commercial at" or \at sign"
(@). See Figure 2{5.
atom n.anyobject that is not a cons. \A vector is an atom."
atomic adj.being an atom . \The number 3, the symbol foo, andnilare atomic."
atomic type speciﬁer n.atype specier that is atomic . For every atomic type
specier ,x, there is an equivalent compound type specier with no arguments supplied,
(x).
attribute n.(of a character ) a program-visible aspect of the character . The only
standardized attribute of a character is its code 2, but implementations are permitted
to have additional implementation-dened attributes . See Section 13.1.3 (Character
Attributes). \An implementation that support fonts might make font information an
attribute of a character, while others might represent font information separately from
characters."
aux variable n.avariable that occurs in the part of a lambda list that was introduced
by&aux . Unlike all other variables introduced by a lambda-list ,aux variables are not
parameters .
auxiliary method n.a member of one of two sets of methods (the set of primary
methods is the other) that form an exhaustive partition of the set of methods on the
method 'sgeneric function . How these sets are determined is dependent on the method
combination type; see Section 7.6.2 (Introduction to Methods).
Glossary 26–5
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
B
backquote n.thestandard character that is variously called \grave accent" or
\backquote" ( ‘). See Figure 2{5.
backslash n.thestandard character that is variously called \reverse solidus" or
\backslash" ( \). See Figure 2{5.
base character n.acharacter oftypebase-char .
base string n.astring oftypebase-string .
before method n.amethod having the qualier :before .
bidirectional adj.(of a stream ) being both an input stream and an output stream .
binary adj.1. (of a stream ) being a stream that has an element type that is a
subtype oftypeinteger . The most fundamental operation on a binary input stream
isread-byte and on a binary output stream iswrite-byte . See character . 2. (of a
le) having been created by opening a binary stream . (It is implementation-dependent
whether this is an detectable aspect of the le, or whether any given character le can
be treated as a binary le .)
bind v.t.(avariable ) to establish a binding for the variable .
binding n.an association between a name and that which the name denotes. \A
lexical binding is a lexical association between a name and its value." When the term
binding is qualied by the name of a namespace , such as \variable" or \function,"
it restricts the binding to the indicated namespace, as in: \ letestablishes variable
bindings." or \ letestablishes bindings of variables."
bitn.anobject oftypebit; that is, the integer0or the integer1.
bit array n.a specialized array that is of type(array bit) , and whose elements are
oftypebit.
bit vector n.a specialized vector that is of typebit-vector , and whose elements are
oftypebit.
bit-wise logical operation speciﬁer n.anobject which names one of the sixteen
possible bit-wise logical operations that can be performed by the boole function,
and which is the value of exactly one of the constant variables boole-clr ,boole-set ,
boole-1 ,boole-2 ,boole-c1 ,boole-c2 ,boole-and ,boole-ior ,boole-xor ,boole-eqv ,
boole-nand ,boole-nor ,boole-andc1 ,boole-andc2 ,boole-orc1 , orboole-orc2 .
26–6 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
block n.a named lexical exit point ,established explicitly by block or implicitly by
operators such asloop,doandprog , to which control and values may be transfered
by using a return-from form with the name of the block .
block tag n.thesymbol that, within the lexical scope of ablock form , names the
block established by thatblock form . Seereturn orreturn-from .
boa lambda list n.alambda list that is syntactically like an ordinary lambda list ,
but that is processed in \ byorder ofargument" style. See Section 3.4.6 (Boa Lambda
Lists).
body parameter n.aparameter available in certain lambda lists which from the
point of view of conforming programs is like a rest parameter in every way except
that it is introduced by &body instead of &rest . (Implementations are permitted to
provide extensions which distinguish body parameters and rest parameters |e.g., the
forms foroperators which were dened using a body parameter might be pretty printed
slightly dierently than forms foroperators which were dened using rest parameters .)
boolean n.anobject oftypeboolean ; that is, one of the following objects : the
symbolt(representing true), or the symbol nil(representing false). See generalized
boolean .
boolean equivalent n.(of an objectO1) any objectO2that has the same truth value
asO1when both O1andO2are viewed as generalized booleans .
bound adj.,v.t.1.adj.having an associated denotation in a binding . \The variables
named by a letare bound within its body." See unbound . 2. adj.having a local
binding which shadows 2another. \The variable *print-escape* is bound while in the
princ function." 3. v.t.the past tense of bind.
bound declaration n.adeclaration that refers to or is associated with a variable
orfunction and that appears within the special form that establishes thevariable or
function , but before the body of that special form (specically, at the head of that
form 's body). (If a bound declaration refers to a function binding or a lexical variable
binding , the scope of the declaration is exactly the scope of that binding . If the
declaration refers to a dynamic variable binding , the scope of the declaration is what
thescope of the binding would have been if it were lexical rather than dynamic.)
bounded adj.(of a sequenceS, by an ordered pair of bounding indices istart andiend)
restricted to a subrange of the elements ofSthat includes each element beginning
with (and including) the one indexed by istart and continuing up to (but not including)
the one indexed by iend.
bounding index n.(of a sequence with lengthn) either of a conceptual pair of
integers ,istart andiend, respectively called the \lower bounding index" and \upper
Glossary 26–7
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
bounding index", such that 0istartiendn, and which therefore delimit a
subrange of the sequence bounded byistart andiend.
bounding index designator (for a sequence ) one of two objects that, taken together
as an ordered pair, behave as a designator forbounding indices of the sequence ; that
is, they denote bounding indices of the sequence , and are either: an integer (denoting
itself) and nil(denoting the length of the sequence ), or two integers (each denoting
themselves).
break loop n.A variant of the normal Lisp read-eval-print loop that is recursively
entered, usually because the ongoing evaluation of some other form has been suspended
for the purpose of debugging. Often, a break loop provides the ability to exit in such a
way as to continue the suspended computation. See the functionbreak .
broadcast stream n.anoutput stream oftypebroadcast-stream .
built-in class n.aclass that is a generalized instance ofclassbuilt-in-class .
built-in type n.one of the types in Figure 4{2.
byte n.1. adjacent bits within an integer . (The specic number of bits can vary from
point to point in the program; see the function byte.) 2. an integer in a specied
range. (The specic range can vary from point to point in the program; see the
functions open andwrite-byte .)
byte speciﬁer n.Anobject ofimplementation-dependent nature that is returned by
thefunctionbyte and that species the range of bits in an integer to be used as a byte
byfunctions such asldb.
C
cadr [kadr],n.(of an object ) the carof the cdrof that object .
call v.t.,n.1.v.t.(afunction with arguments ) to cause the code represented by
that function to be executed in an environment where bindings for the values of its
parameters have been established based on the arguments . \Calling the function +
with the arguments 5and1yields a value of 6." 2. n.asituation in which a function
is called.
captured initialization form n.aninitialization form along with the lexical
environment in which the form that dened the initialization form was evaluated .
\Each newly added shared slot is set to the result of evaluating the captured
initialization form for the slot that was specied in the defclass form for the new
class."
26–8 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
carn.1. a. (of a cons) the component of a cons corresponding to the rst argument
tocons; the other component is the cdr. \The function rplaca modies the car of a
cons." b. (of a list) the rst element of the list, ornilif the listis the empty list . 2.
theobject that is held in the car1. \The function carreturns the car of a cons."
case n.(of a character ) the property of being either uppercase orlowercase . Not all
characters have case. \The characters #\Aand#\ahave case, but the character #\$has
no case." See Section 13.1.4.3 (Characters With Case) and the functionboth-case-p .
case sensitivity mode n.one of the symbols :upcase ,:downcase ,:preserve , or
:invert .
catch n.anexit point which is established by acatch form within the dynamic scope
of its body, which is named by a catch tag , and to which control and values may be
thrown .
catch tag n.anobject which names an active catch . (If more than one catch is active
with the same catch tag , it is only possible to throw to the innermost such catch
because the outer one is shadowed 2.)
cddr [k_uddr]or[kd_udr],n.(of an object ) the cdrof the cdrof that object .
cdr[k_udr],n.1. a. (of a cons) the component of a cons corresponding to the
second argument tocons; the other component is the car. \The function rplacd
modies the cdr of a cons." b. (of a listL1) either the listL2that contains the
elements ofL1that follow after the rst, or else nilifL1is the empty list . 2. the
object that is held in the cdr1. \The function cdrreturns the cdr of a cons."
cell n. Trad. (of an object ) a conceptual slotof that object . The dynamic variable and
global function bindings of a symbol are sometimes referred to as its value cell and
function cell , respectively.
character n.,adj.1.n.anobject oftypecharacter ; that is, an object that represents a
unitary token in an aggregate quantity of text; see Section 13.1 (Character Concepts).
2.adj.a. (of a stream ) having an element type that is a subtype oftypecharacter .
The most fundamental operation on a character input stream isread-char and on a
character output stream iswrite-char . See binary . b. (of a le) having been created
by opening a character stream . (It is implementation-dependent whether this is an
inspectable aspect of the le, or whether any given binary le can be treated as a
character le .)
character code n.1. one of possibly several attributes of a character . 2. a
non-negative integer less than the value ofchar-code-limit that is suitable for use as
acharacter code 1.
Glossary 26–9
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
character designator n.adesignator for a character ; that is, an object that denotes
acharacter and that is one of: a designator for a string oflength one (denoting the
character that is its only element ), or a character (denoting itself).
circular adj.1. (of a list) acircular list . 2. (of an arbitrary object ) having a
component ,element ,constituent 2, or subexpression (as appropriate to the context)
that is the object itself.
circular list n.a chain of conses that has no termination because some cons in the
chain is the cdrof a later cons.
class n.1. an object that uniquely determines the structure and behavior of a set of
other objects called its direct instances , that contributes structure and behavior to a
set of other objects called its indirect instances , and that acts as a type specier for a
set of objects called its generalized instances . \The class integer is a subclass of the
classnumber ." (Note that the phrase \the classfoo" is often substituted for the more
precise phrase \the class namedfoo"|in both cases, a class object (not a symbol )
is denoted.) 2. (of an object ) the uniquely determined class of which the object is
adirect instance . See the function class-of . \The class of the object returned by
gensym issymbol ." (Note that with this usage a phrase such as \its class isfoo" is
often substituted for the more precise phrase \its class is the class namedfoo"|in
both cases, a class object (not a symbol ) is denoted.)
class designator n.adesignator for a class ; that is, an object that denotes a class
and that is one of: a symbol (denoting the class named by that symbol ; see the function
ﬁnd-class ) or a class (denoting itself).
class precedence list n.a unique total ordering on a class and its superclasses that
is consistent with the local precedence orders for the class and its superclasses . For
detailed information, see Section 4.3.5 (Determining the Class Precedence List).
close v.t.(astream ) to terminate usage of the stream as a source or sink of data,
permitting the implementation to reclaim its internal data structures, and to free any
external resources which might have been locked by the stream when it was opened.
closed adj.(of a stream ) having been closed (see close). Some (but not all) operations
that are valid on open streams are not valid on closed streams . See Section 21.1.1.1.2
(Open and Closed Streams).
closure n.alexical closure .
coalesce v.t.(literal objects that are similar ) to consolidate the identity of those
objects , such that they become the same object . See Section 3.2.1 (Compiler
Terminology).
26–10 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
code n.1.Trad. any representation of actions to be performed, whether conceptual
or as an actual object , such as forms ,lambda expressions ,objects oftype function ,
text in a source le , or instruction sequences in a compiled le . This is a generic term;
the specic nature of the representation depends on its context. 2. (of a character ) a
character code .
coerce v.t.(anobject to a type) to produce an object from the given object , without
modifying that object , by following some set of coercion rules that must be specically
stated for any context in which this term is used. The resulting object is necessarily of
the indicated type, except when that type is a subtype oftypecomplex ; in that case, if
acomplex rational with an imaginary part of zero would result, the result is a rational
rather than a complex |see Section 12.1.5.3 (Rule of Canonical Representation for
Complex Rationals).
colon n.thestandard character that is called \colon" ( :). See Figure 2{5.
comma n.thestandard character that is called \comma" ( ,). See Figure 2{5.
compilation n.the process of compiling code by the compiler .
compilation environment n.1. An environment that represents information known
by the compiler about a form that is being compiled . See Section 3.2.1 (Compiler
Terminology). 2. An object that represents the compilation environment 1and that
is used as a second argument to a macro function (which supplies a value for any
&environment parameter in the macro function 's denition).
compilation unit n.an interval during which a single unit of compilation is occurring.
See the macrowith-compilation-unit .
compile v.t.1. ( code) to perform semantic preprocessing of the code, usually
optimizing one or more qualities of the code, such as run-time speed of execution or
run-time storage usage. The minimum semantic requirements of compilation are that
it must remove all macro calls and arrange for all load time values to be resolved
prior to run time. 2. (a function ) to produce a new object oftypecompiled-function
which represents the result of compiling thecode represented by the function . See the
function compile . 3. (a source le ) to produce a compiled le from a source le . See
thefunctioncompile-ﬁle .
compile time n.the duration of time that the compiler is processing source code .
compile-time deﬁnition n.a denition in the compilation environment .
compiled code n.1.compiled functions . 2. code that represents compiled functions ,
such as the contents of a compiled le .
Glossary 26–11
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
compiled ﬁle n.alewhich represents the results of compiling theforms which
appeared in a corresponding source le , and which can be loaded . See the function
compile-ﬁle .
compiled function n.anobject oftypecompiled-function , which is a function that
has been compiled , which contains no references to macros that must be expanded at
run time, and which contains no unresolved references to load time values .
compiler n.a facility that is part of Lisp and that translates code into an
implementation-dependent form that might be represented or executed eciently. The
functions compile andcompile-ﬁle permit programs to invoke the compiler .
compiler macro n.an auxiliary macro denition for a globally dened function or
macro which might or might not be called by any given conforming implementation
and which must preserve the semantics of the globally dened function ormacro but
which might perform some additional optimizations. (Unlike a macro , acompiler
macro does not extend the syntax of Common Lisp; rather, it provides an alternate
implementation strategy for some existing syntax or functionality.)
compiler macro expansion n.1. the process of translating a form into another
form by a compiler macro . 2. the form resulting from this process.
compiler macro form n.afunction form ormacro form whose operator has a
denition as a compiler macro , or afuncall form whose rst argument is afunction
form whose argument is the name of a function that has a denition as a compiler
macro .
compiler macro function n.afunction of two arguments, a form and an
environment , that implements compiler macro expansion by producing either a form
to be used in place of the original argument form or elsenil, indicating that the
original form should not be replaced. See Section 3.2.2.1 (Compiler Macros).
complex n.anobject oftypecomplex .
complex ﬂoat n.anobject oftypecomplex which has a complex part type that is a
subtype ofﬂoat. Acomplex oat is acomplex , but it is not a oat.
complex part type n.(of a complex ) 1. the type which is used to represent both the
real part and the imaginary part of the complex . 2. the actual complex part type of
thecomplex . 3. the expressed complex part type of the complex .
complex rational n.anobject oftypecomplex which has a complex part type that
is a subtype ofrational . A complex rational is a complex , but it is not a rational .
Nocomplex rational has an imaginary part of zero because such a number is always
represented by Common Lisp as an object oftyperational ; see Section 12.1.5.3 (Rule
of Canonical Representation for Complex Rationals).
26–12 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
complex single ﬂoat n.anobject oftypecomplex which has a complex part type
that is a subtype ofsingle-ﬂoat . A complex single oat is acomplex , but it is not a
single oat .
composite stream n.astream that is composed of one or more other streams .
\make-synonym-stream creates a composite stream."
compound form n.anon-empty list which is a form : aspecial form , alambda form ,
amacro form , or a function form .
compound type speciﬁer n.atype specier that is a cons;i.e., atype specier that
is not an atomic type specier . \(vector single-float) is a compound type specier."
concatenated stream n.aninput stream oftypeconcatenated-stream .
condition n.1. an object which represents a situation |usually, but not necessarily,
during signaling . 2. an object oftypecondition .
condition designator n.one or more objects that, taken together, denote either an
existing condition object or a condition object to be implicitly created. For details, see
Section 9.1.2.1 (Condition Designators).
condition handler n.afunction that might be invoked by the act of signaling , that
receives the condition being signaled as its only argument, and that is permitted to
handle thecondition or to decline . See Section 9.1.4.1 (Signaling).
condition reporter n.afunction that describes how a condition is to be printed
when the Lisp printer is invoked while *print-escape* isfalse. See Section 9.1.3
(Printing Conditions).
conditional newline n.a point in output where a newline might be inserted at the
discretion of the pretty printer . There are four kinds of conditional newlines , called
\linear-style," \ll-style," \miser-style," and \mandatory-style." See the function
pprint-newline and Section 22.2.1.1 (Dynamic Control of the Arrangement of Output).
conformance n.a state achieved by proper and complete adherence to the
requirements of this specication. See Section 1.5 (Conformance).
conforming code n. code that is all of part of a conforming program .
conforming implementation n.animplementation , used to emphasize complete
and correct adherance to all conformance criteria. A conforming implementation
is capable of accepting a conforming program as input, preparing that program for
execution , and executing the prepared program in accordance with this specication.
Animplementation which has been extended may still be a conforming implementation
Glossary 26–13
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
provided that no extension interferes with the correct function of any conforming
program .
conforming processor n. ANSI aconforming implementation .
conforming program n.aprogram , used to emphasize the fact that the program
depends for its correctness only upon documented aspects of Common Lisp, and can
therefore be expected to run correctly in any conforming implementation .
congruent n.conforming to the rules of lambda list congruency, as detailed in Section
7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function).
cons n.v.1.n.a compound data object having two components called the carand the
cdr. 2. v.to create such an object . 3. v. Idiom. to create any object , or to allocate
storage.
constant n.1. a constant form . 2. a constant variable . 3. a constant object . 4. a
self-evaluating object .
constant form n.anyform for which evaluation always yields the same value , that
neither aects nor is aected by the environment in which it is evaluated (except that
it is permitted to refer to the names of constant variables dened in the environment ),
and that neither aects nor is aected by the state of any object except those objects
that are otherwise inaccessible parts ofobjects created by the form itself. \A carform
in which the argument is a quote form is a constant form."
constant object n.anobject that is constrained ( e.g., by its context in a program or
by the source from which it was obtained) to be immutable . \A literal object that has
been processed by compile-ﬁle is a constant object."
constant variable n.avariable , the value of which can never change; that
is, a keyword 1or a named constant . \The symbols t,nil,:direction , and
most-positive-ﬁxnum are constant variables."
constituent n.,adj.1. a. n.thesyntax type of acharacter that is part of a token . For
details, see Section 2.1.4.1 (Constituent Characters). b. adj.(of a character ) having
theconstituent 1asyntax type 2. c. n.aconstituent 1bcharacter . 2. n.(of a composite
stream ) one of possibly several objects that collectively comprise the source or sink of
that stream .
constituent trait n.(of a character ) one of several classications of a constituent
character in a readtable . See Section 2.1.4.1 (Constituent Characters).
constructed stream n.astream whose source or sink is a Lisp object . Note that
since a stream is another Lisp object ,composite streams are considered constructed
streams . \A string stream is a constructed stream."
26–14 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
contagion n.a process whereby operations on objects of diering types (e.g.,
arithmetic on mixed types ofnumbers ) produce a result whose type is controlled by the
dominance of one argument 'stype over the types of the other arguments . See Section
12.1.1.2 (Contagion in Numeric Operations).
continuable n.(of an error ) an error that is correctable by thecontinue restart.
control form n.1. a form that establishes one or more places to which control can
be transferred. 2. a form that transfers control.
copy n.1. (of a consC) afresh cons with the same car and cdrasC. 2. (of a listL)
afresh list with the same elements asL. (Only the list structure isfresh ; the elements
are the same .) See the function copy-list . 3. (of an association list Awith elements
Ai) afresh listBwith elementsBi, each of which is nilifAiisnil, or else a copy of
theconsAi. See the function copy-alist . 4. (of a treeT) afresh tree with the same
leaves asT. See the function copy-tree . 5. (of a random state R) afresh random
state that, if used as an argument to to the functionrandom would produce the same
series of \random" values as Rwould produce. 6. (of a structureS) afresh structure
that has the same type asS, and that has slot values, each of which is the same as
the corresponding slot value of S. (Note that since the dierence between a cons, a
list, and a treeis a matter of \view" or \intention," there can be no general-purpose
function which, based solely on the type of an object , can determine which of these
distinct meanings is intended. The distinction rests solely on the basis of the text
description within this document. For example, phrases like \a copy of the given list"
or \copy of the listx" imply the second denition.)
correctable adj.(of an error ) 1. (by a restart other than abort that has been
associated with the error ) capable of being corrected by invoking that restart . \The
functioncerror signals an error that is correctable by the continue restart ." (Note that
correctability is not a property of an error object , but rather a property of the dynamic
environment that is in eect when the error issignaled . Specically, the restart is
\associated with" the error condition object . See Section 9.1.4.2.4 (Associating a
Restart with a Condition).) 2. (when no specic restart is mentioned) correctable 1by
at least one restart . \import signals a correctable error of typepackage-error if any
of the imported symbols has the same name as some distinct symbol already accessible
in the package."
current input base n.(in a dynamic environment ) the radix that is the value of
*read-base* in that environment , and that is the default radix employed by the Lisp
reader and its related functions .
current logical block n.the context of the innermost lexically enclosing use of
pprint-logical-block .
current output base n.(in a dynamic environment ) the radix that is the value of
Glossary 26–15
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
*print-base* in that environment , and that is the default radix employed by the Lisp
printer and its related functions .
current package n.(in a dynamic environment ) the package that is the value of
*package* in that environment , and that is the default package employed by the Lisp
reader and Lisp printer , and their related functions .
current pprint dispatch table n.(in a dynamic environment ) the pprint dispatch
table that is the value of*print-pprint-dispatch* in that environment , and that is
the default pprint dispatch table employed by the pretty printer .
current random state n.(in a dynamic environment ) the random state that is the
value of*random-state* in that environment , and that is the default random state
employed by random .
current readtable n.(in a dynamic environment ) the readtable that is the value of
*readtable* in that environment , and that aects the way in which expressions 2are
parsed into objects by the Lisp reader .
D
data type n. Trad. atype.
debug I/O n.thebidirectional stream that is the value of the variable*debug-io* .
debugger n.a facility that allows the user to handle a condition interactively. For
example, the debugger might permit interactive selection of a restart from among the
active restarts , and it might perform additional implementation-dened services for
the purposes of debugging.
declaration n.aglobal declaration orlocal declaration .
declaration identiﬁer n.one of the symbolsdeclaration ,dynamic-extent ,ftype ,
function ,ignore ,inline ,notinline ,optimize ,special , ortype; or a symbol which is
thename of a type; or a symbol which has been declared to be a declaration identier
by using a declaration declaration .
declaration speciﬁer n.anexpression that can appear at top level of a declare
expression or a declaim form, or as the argument to proclaim , and which has a car
which is a declaration identier , and which has a cdrthat is data interpreted according
to rules specic to the declaration identier .
declare v.toestablish adeclaration . Seedeclare ,declaim , orproclaim .
26–16 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
decline v.(of a handler ) to return normally without having handled thecondition
being signaled , permitting the signaling process to continue as if the handler had not
been present.
decoded time n. absolute time , represented as an ordered series of nine objects which,
taken together, form a description of a point in calendar time, accurate to the nearest
second (except that leap seconds are ignored). See Section 25.1.4.1 (Decoded Time).
default method n.amethod having no parameter specializers other than the class
t. Such a method is always an applicable method but might be shadowed 2by a more
specic method .
defaulted initialization argument list n.alistof alternating initialization
argument names and values in which unsupplied initialization arguments are
defaulted, used in the protocol for initializing and reinitializing instances ofclasses .
deﬁne-method-combination arguments lambda list n.alambda list used
by the:arguments option to deﬁne-method-combination . See Section 3.4.10
(Dene-method-combination Arguments Lambda Lists).
deﬁne-modify-macro lambda list n.alambda list used bydeﬁne-modify-macro .
See Section 3.4.9 (Dene-modify-macro Lambda Lists).
deﬁned name n.asymbol the meaning of which is dened by Common Lisp.
deﬁning form n.aform that has the side-eect of establishing a denition. \ defun
anddefparameter are dening forms."
defsetf lambda list n.alambda list that is like an ordinary lambda list except that
it does not permit &aux and that it permits use of &environment . See Section 3.4.7
(Defsetf Lambda Lists).
deftype lambda list n.alambda list that is like a macro lambda list except that
the default value for unsupplied optional parameters and keyword parameters is the
symbol*(rather than nil). See Section 3.4.8 (Deftype Lambda Lists).
denormalized adj.,ANSI ,IEEE (of a oat) conforming to the description of
\denormalized" as described by IEEE Standard for Binary Floating-Point Arithmetic .
For example, in an implementation where the minimum possible exponent was -7
but where 0.001 was a valid mantissa, the number 1.0e-10 might be representable
as0.001e-7 internally even if the normalized representation would call for it to
be represented instead as 1.0e-10 or0.1e-9 . By their nature, denormalized oats
generally have less precision than normalized oats .
Glossary 26–17
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
derived type n.atype specier which is dened in terms of an expansion into
another type specier .deftype denes derived types , and there may be other
implementation-dened operators which do so as well.
derived type speciﬁer n.atype specier for a derived type .
designator n.anobject that denotes another object . In the dictionary entry for an
operator if aparameter is described as a designator for a type, the description of the
operator is written in a way that assumes that appropriate coercion to that type has
already occurred; that is, that the parameter is already of the denoted type. For more
detailed information, see Section 1.4.1.5 (Designators).
destructive adj.(of an operator ) capable of modifying some program-visible aspect
of one or more objects that are either explicit arguments to the operator or that can
be obtained directly or indirectly from the global environment by the operator .
destructuring lambda list n.anextended lambda list used indestructuring-bind
and nested within macro lambda lists . See Section 3.4.5 (Destructuring Lambda Lists).
diﬀerent adj.not the same \The strings "FOO" and"foo" are dierent under equal
but not under equalp ."
digit n.(in a radix ) acharacter that is among the possible digits ( 0to9,AtoZ, anda
toz) and that is dened to have an associated numeric weight as a digit in that radix .
See Section 13.1.4.6 (Digits in a Radix).
dimension n.1. a non-negative integer indicating the number of objects anarray
can hold along one axis. If the array is avector with a ll pointer , the ll pointer is
ignored. \The second dimension of that array is 7." 2. an axis of an array. \This
array has six dimensions."
direct instance n.(of a classC) an object whose class isCitself, rather than some
subclass ofC. \The function make-instance always returns a direct instance of the
class which is (or is named by) its rst argument."
direct subclass n.(of a classC1) aclassC2, such that C1is adirect superclass of
C2.
direct superclass n.(of a classC1) aclassC2which was explicitly designated as a
superclass ofC1in the denition of C1.
disestablish v.t.to withdraw the establishment of an object , abinding , an exit point ,
atag, ahandler , arestart , or an environment .
disjoint n.(oftypes ) having no elements in common.
26–18 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
dispatching macro character n.amacro character that has an associated table
that species the function to be called for each character that is seen following the
dispatching macro character . See the functionmake-dispatch-macro-character .
displaced array n.anarray which has no storage of its own, but which is instead
indirected to the storage of another array , called its target , at a specied oset, in
such a way that any attempt to access thedisplaced array implicitly references the
target array .
distinct adj.notidentical .
documentation string n.(in a dening form ) Aliteral string which because of the
context in which it appears (rather than because of some intrinsically observable aspect
of the string ) is taken as documentation. In some cases, the documentation string is
saved in such a way that it can later be obtained by supplying either an object , or by
supplying a name and a \kind" to the function documentation . \The body of code
in adefmacro form can be preceded by a documentation string of kind function ."
dot n.thestandard character that is variously called \full stop," \period," or \dot"
(.). See Figure 2{5.
dotted list n.alistwhich has a terminating atom that is not nil. (An atom by itself
is not a dotted list , however.)
dotted pair n.1. a cons whose cdris anon-list . 2. any cons, used to emphasize the
use of the cons as a symmetric data pair.
double ﬂoat n.anobject oftypedouble-ﬂoat .
double-quote n.thestandard character that is variously called \quotation mark" or
\double quote" ( "). See Figure 2{5.
dynamic binding n.abinding in a dynamic environment .
dynamic environment n.that part of an environment that contains bindings
with dynamic extent . A dynamic environment contains, among other things: exit
points established by unwind-protect , and bindings ofdynamic variables ,exit points
established by catch ,condition handlers , and restarts .
dynamic extent n.anextent whose duration is bounded by points of establishment
and disestablishment within the execution of a particular form . See indenite extent .
\Dynamic variable bindings have dynamic extent."
dynamic scope n. indenite scope along with dynamic extent .
Glossary 26–19
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
dynamic variable n.avariable thebinding for which is in the dynamic environment .
Seespecial .
E
echo stream n.astream oftypeecho-stream .
eﬀective method n.the combination of applicable methods that are executed when a
generic function is invoked with a particular sequence of arguments .
element n.1. (of a list) an object that is the carof one of the conses that comprise
thelist. 2. (of an array ) an object that is stored in the array . 3. (of a sequence ) an
object that is an element of the listorarray that is the sequence . 4. (of a type) an
object that is a member of the set of objects designated by the type. 5. (of an input
stream ) acharacter ornumber (as appropriate to the element type of the stream )
that is among the ordered series of objects that can be read from the stream (using
read-char orread-byte , as appropriate to the stream ). 6. (of an output stream ) a
character ornumber (as appropriate to the element type of the stream ) that is among
the ordered series of objects that has been or will be written to the stream (using
write-char orwrite-byte , as appropriate to the stream ). 7. (of a class ) ageneralized
instance of the class .
element type n.1. (of an array ) the array element type of the array . 2. (of a stream )
thestream element type of the stream .
emn. Trad. a context-dependent unit of measure commonly used in typesetting,
equal to the displayed width of of a letter \M" in the current font. (The letter \M"
is traditionally chosen because it is typically represented by the widest glyph in the
font, and other characters' widths are typically fractions of an em. In implementations
providing non-Roman characters with wider characters than \M," it is permissible
for another character to be the implementation-dened reference character for this
measure, and for \M" to be only a fraction of an emwide.) In a xed width font, a
line with ncharacters is n ems wide; in a variable width font, n ems is the expected
upper bound on the width of such a line.
empty list n.thelistcontaining no elements . See ().
empty type n.thetype that contains no elements , and that is a subtype of all types
(including itself). See nil.
end of ﬁle n.1. the point in an input stream beyond which there is no further data.
Whether or not there is such a point on an interactive stream isimplementation-
dened . 2. a situation that occurs upon an attempt to obtain data from an input
stream that is at the end of le 1.
26–20 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
environment n.1. a set of bindings . See Section 3.1.1 (Introduction to Environments).
2. an environment object . \macroexpand takes an optional environment argument."
environment object n.anobject representing a set of lexical bindings , used in the
processing of a form to provide meanings for names within that form . \macroexpand
takes an optional environment argument." (The objectnilwhen used as an environment
object denotes the null lexical environment ; the values ofenvironment parameters to
macro functions areobjects ofimplementation-dependent nature which represent the
environment 1in which the corresponding macro form is to be expanded.) See Section
3.1.1.4 (Environment Objects).
environment parameter n.Aparameter in a dening form ffor which there is no
corresponding argument ; instead, this parameter receives as its value an environment
object which corresponds to the lexical environment in which the dening form f
appeared.
error n.1. (only in the phrase \is an error") a situation in which the semantics of a
program are not specied, and in which the consequences are undened. 2. a condition
which represents an error situation . See Section 1.4.2 (Error Terminology). 3. an
object oftypeerror .
error output n.theoutput stream which is the value of the dynamic variable
*error-output* .
escape n.,adj.1.n.asingle escape or a multiple escape . 2. adj. single escape or
multiple escape .
establish v.t.to build or bring into being a binding , adeclaration , an exit point , a
tag, ahandler , arestart , or an environment . \letestablishes lexical bindings."
evaluate v.t.(aform or an implicit progn ) to execute thecode represented by the
form (or the series of forms making up the implicit progn ) by applying the rules of
evaluation , returning zero or more values.
evaluation n.a model whereby forms areexecuted , returning zero or more values.
Such execution might be implemented directly in one step by an interpreter or in two
steps by rst compiling theform and then executing thecompiled code ; this choice is
dependent both on context and the nature of the implementation , but in any case is
not in general detectable by any program. The evaluation model is designed in such
a way that a conforming implementation might legitimately have only a compiler and
no interpreter, or vice versa. See Section 3.1.2 (The Evaluation Model).
evaluation environment n.arun-time environment in which macro expanders and
code specied by eval-when to be evaluated are evaluated. All evaluations initiated
by the compiler take place in the evaluation environment .
Glossary 26–21
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
execute v.t. Trad. (code) to perform the imperative actions represented by the code.
execution time n.the duration of time that compiled code is being executed .
exhaustive partition n.(of a type) a set of pairwise disjoint types that form an
exhaustive union .
exhaustive union n.(of a type) a set of subtypes of the type, whose union contains
allelements of that type.
exit point n.a point in a control form from which ( e.g.,block ), through which ( e.g.,
unwind-protect ), or to which ( e.g.,tagbody ) control and possibly values can be
transferred both actively by using another control form and passively through the
normal control and data ow of evaluation . \catch andblock establish bindings for
exit points to which throw andreturn-from , respectively, can transfer control and
values;tagbody establishes a binding for an exit point with lexical extent to which
gocan transfer control; and unwind-protect establishes an exit point through which
control might be transferred by operators such as throw ,return-from , andgo."
explicit return n.the act of transferring control (and possibly values ) to a block by
usingreturn-from (orreturn ).
explicit use n.(of a variableVin aformF) a reference to Vthat is directly apparent
in the normal semantics of F;i.e., that does not expose any undocumented details
of the macro expansion of the form itself. References to Vexposed by expanding
subforms ofFare, however, considered to be explicit uses ofV.
exponent marker n.a character that is used in the textual notation for a oat to
separate the mantissa from the exponent. The characters dened as exponent markers
in the standard readtable are shown in Figure 26{1. For more information, see Section
2.1 (Character Syntax). \The exponent marker `d' in `3.0d7' indicates that this
number is to be represented as a double oat."
Marker Meaning
Dord double-ﬂoat
Eore ﬂoat (see*read-default-ﬂoat-format* )
Forf single-ﬂoat
Lorl long-ﬂoat
Sors short-ﬂoat
Figure 26–1. Exponent Markers
export v.t.(asymbol in a package ) to add the symbol to the list of external symbols
of the package .
26–22 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
exported adj.(of a symbol in a package ) being an external symbol of the package .
expressed adjustability n.(of an array ) ageneralized boolean that is conceptually
(but not necessarily actually) associated with the array , representing whether the
array isexpressly adjustable . See also actual adjustability .
expressed array element type n.(of an array ) the type which is the array element
type implied by a type declaration for the array , or which is the requested array
element type at its time of creation, prior to any selection of an upgraded array element
type. (Common Lisp does not provide a way of detecting this type directly at run time,
but an implementation is permitted to make assumptions about the array 's contents
and the operations which may be performed on the array when this type is noted
during code analysis, even if those assumptions would not be valid in general for the
upgraded array element type of the expressed array element type .)
expressed complex part type n.(of a complex ) the type which is implied as the
complex part type by a type declaration for the complex , or which is the requested
complex part type at its time of creation, prior to any selection of an upgraded complex
part type . (Common Lisp does not provide a way of detecting this type directly at run
time, but an implementation is permitted to make assumptions about the operations
which may be performed on the complex when this type is noted during code analysis,
even if those assumptions would not be valid in general for the upgraded complex part
type of the expressed complex part type .)
expression n.1. an object , often used to emphasize the use of the object to encode
or represent information in a specialized format, such as program text. \The second
expression in a letform is a list of bindings." 2. the textual notation used to notate
anobject in a source le. \The expression ’sample is equivalent to (quote sample) ."
expressly adjustable adj.(of an array ) being actually adjustable by virtue of an
explicit request for this characteristic having been made at the time of its creation. All
arrays that are expressly adjustable areactually adjustable , but not necessarily vice
versa.
extended character n.acharacter oftypeextended-char : acharacter that is not a
base character .
extended function designator n.adesignator for a function ; that is, an object
that denotes a function and that is one of: a function name (denoting the function it
names in the global environment ), or a function (denoting itself). The consequences
are undened if a function name is used as an extended function designator but it
does not have a global denition as a function , or if it is a symbol that has a global
denition as a macro or a special form . See also function designator .
extended lambda list n.a list resembling an ordinary lambda list in form and
Glossary 26–23
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
purpose, but oering additional syntax or functionality not available in an ordinary
lambda list . \defmacro uses extended lambda lists."
extension n.a facility in an implementation of Common Lisp that is not specied by
this standard.
extent n.the interval of time during which a reference to an object , abinding , an exit
point , atag, ahandler , arestart , or an environment is dened.
external ﬁle format n.anobject ofimplementation-dependent nature which
determines one of possibly several implementation-dependent ways in which characters
are encoded externally in a character le .
external ﬁle format designator n.adesignator for an external le format ; that
is, an object that denotes an external le format and that is one of: the symbol
:default (denoting an implementation-dependent default external le format that
can accomodate at least the base characters ), some other object dened by the
implementation to be an external le format designator (denoting an implementation-
dened external le format ), or some other object dened by the implementation to
be an external le format (denoting itself).
external symbol n.(of a package ) asymbol that is part of the `external interface' to
thepackage and that are inherited 3by any other package that uses thepackage . When
using the Lisp reader , if a package prex is used, the name of an external symbol is
separated from the package name by a single package marker while the name of an
internal symbol is separated from the package name by a double package marker ; see
Section 2.3.4 (Symbols as Tokens).
externalizable object n.anobject that can be used as a literal object incode to be
processed by the le compiler .
F
false n.thesymbolnil, used to represent the failure of a predicate test.
fbound [efba_und]adj.(of a function name )bound in the function namespace .
(The names ofmacros and special operators arefbound , but the nature and type of
theobject which is their value isimplementation-dependent . Further, dening a setf
expander Fdoes not cause the setf function (setf F)to become dened; as such, if
there is a such a denition of a setf expander F, the function (setf F)can be fbound
if and only if, by design or coincidence, a function binding for (setf F)has been
independently established.) See the functions fboundp andsymbol-function .
feature n.1. an aspect or attribute of Common Lisp, of the implementation , or of the
environment . 2. a symbol that names a feature 1. See Section 24.1.2 (Features). \The
:ansi-cl feature is present in all conforming implementations."
26–24 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
feature expression n.A boolean combination of features used by the #+and#-
reader macros in order to direct conditional reading ofexpressions by the Lisp reader .
See Section 24.1.2.1 (Feature Expressions).
features list n.thelistthat is the value of*features* .
ﬁlen.a named entry in a le system , having an implementation-dened nature.
ﬁle compiler n.anycompiler which compiles source code contained in a le, producing
acompiled le as output. The compile-ﬁle function is the only interface to such a
compiler provided by Common Lisp, but there might be other, implementation-dened
mechanisms for invoking the le compiler .
ﬁle position n.(in a stream ) a non-negative integer that represents a position in
thestream . Not all streams are able to represent the notion of le position ; in the
description of any operator which manipulates le positions , the behavior for streams
that don't have this notion must be explicitly stated. For binary streams , the le
position represents the number of preceding bytes in the stream . For character streams ,
the constraint is more relaxed: le positions must increase monotonically, the amount
of the increase between le positions corresponding to any two successive characters in
thestream isimplementation-dependent .
ﬁle position designator n.(in a stream ) adesignator for a le position in that
stream ; that is, the symbol :start (denoting 0, the rst le position in that stream ),
the symbol :end (denoting the last le position in that stream ;i.e., the position
following the last element of the stream ), or a le position (denoting itself).
ﬁle stream n.anobject oftypeﬁle-stream .
ﬁle system n.a facility which permits aggregations of data to be stored in named
les on some medium that is external to the Lisp image and that therefore persists
from session tosession .
ﬁlename n.a handle, not necessarily ever directly represented as an object , that can
be used to refer to a lein a le system .Pathnames and namestrings are two kinds
ofobjects that substitute for lenames in Common Lisp.
ﬁll pointer n.(of a vector ) an integer associated with a vector that represents the
index above which no elements areactive . (A ll pointer is a non-negative integer
no larger than the total number of elements in the vector . Not all vectors have ll
pointers .)
ﬁnite adj.(of a type) having a nite number of elements . \The type specier
(integer 0 5) denotes a nite type, but the type speciers integer and(integer 0)
do not."
Glossary 26–25
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ﬁxnum n.aninteger oftypeﬁxnum .
ﬂoat n.anobject oftypeﬂoat.
for-value adj.(of a reference to a binding ) being a reference that reads 1thevalue of
thebinding .
form n.1. any object meant to be evaluated . 2. a symbol , acompound form , or a
self-evaluating object . 3. (for an operator , as in \hhoperatoriiform ") a compound form
having that operator as its rst element. \A quote form is a constant form."
formal argument n. Trad. aparameter .
formal parameter n. Trad. aparameter .
format v.t.(aformat control and format arguments ) to perform output as if by
format , using the format string and format arguments .
format argument n.anobject which is used as data by functions such as format
which interpret format controls .
format control n.aformat string , or a function that obeys the argument conventions
for a function returned by the formatter macro . See Section 22.2.1.3 (Compiling
Format Strings).
format directive n.1. a sequence of characters in aformat string which is introduced
by a tilde, and which is specially interpreted by code which processes format strings
to mean that some special operation should be performed, possibly involving data
supplied by the format arguments that accompanied the format string . See the
function format . \In"~D base 10 = ~8R" , the character sequences ` ~D' and `~8R' are
format directives." 2. the conceptual category of all format directives 1which use the
same dispatch character. \Both "~3d" and"~3,’0D" are valid uses of the ` ~D' format
directive."
format string n.astring which can contain both ordinary text and format directives ,
and which is used in conjunction with format arguments to describe how text output
should be formatted by certain functions, such as format .
free declaration n.a declaration that is not a bound declaration . Seedeclare .
fresh adj.1. (of an object yielded by a function ) having been newly-allocated by that
function . (The caller of a function that returns a fresh object may freely modify the
object without fear that such modication will compromise the future correct behavior
of that function .) 2. (of a binding for a name ) newly-allocated; not shared with other
bindings for that name .
26–26 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
freshline n.a conceptual operation on a stream , implemented by the function
fresh-line and by the format directive ~&, which advances the display position to the
beginning of the next line (as if a newline had been typed, or the functionterpri had
been called) unless the stream is already known to be positioned at the beginning of a
line. Unlike newline ,freshline is not a character .
funbound [efunba_und]n.(of a function name ) not fbound .
function n.1. an object representing code, which can be called with zero or more
arguments , and which produces zero or more values . 2. an object oftypefunction .
function block name n.(of a function name ) The symbol that would be used as the
name of an implicit block which surrounds the body of a function having that function
name . If the function name is asymbol , its function block name is the function name
itself. If the function name is a listwhose carissetf and whose cadr is a symbol ,
itsfunction block name is the symbol that is the cadr of the function name . An
implementation which supports additional kinds of function names must specify for
each how the corresponding function block name is computed.
function cell n. Trad. (of a symbol ) The place which holds the denition of the
global function binding , if any, named by that symbol , and which is accessed by
symbol-function . See cell.
function designator n.adesignator for a function ; that is, an object that denotes
afunction and that is one of: a symbol (denoting the function named by that symbol
in the global environment ), or a function (denoting itself). The consequences are
undened if a symbol is used as a function designator but it does not have a global
denition as a function , or it has a global denition as a macro or a special form . See
also extended function designator .
function form n.aform that is a listand that has a rst element which is the name
of a function to be called on arguments which are the result of evaluating subsequent
elements of the function form .
function name n.1. (in an environment ) Asymbol or a list(setf symbol)that is
thename of a function in that environment . 2. A symbol or a list(setf symbol).
functional evaluation n.the process of extracting a functional value from a function
name or a lambda expression . The evaluator performs functional evaluation implicitly
when it encounters a function name or a lambda expression in the carof a compound
form , or explicitly when it encounters a function special form . Neither a use of a
symbol as a function designator nor a use of the function symbol-function to extract
thefunctional value of a symbol is considered a functional evaluation .
functional value n.1. (of a function name Nin an environment E) The value of
thebinding namedNin the function namespace forenvironment E; that is, the
Glossary 26–27
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
contents of the function cell namedNinenvironment E. 2. (of an fbound symbol
S) the contents of the symbol 'sfunction cell ; that is, the value of the binding named
Sin the function namespace of the global environment . (A name that is a macro
name in the global environment or is a special operator might or might not be fbound .
But ifSis such a name and is fbound , the specic nature of its functional value is
implementation-dependent ; in particular, it might or might not be a function .)
further compilation n. implementation-dependent compilation beyond minimal
compilation . Further compilation is permitted to take place at run time . \Block
compilation and generation of machine-specic instructions are examples of further
compilation."
G
general adj.(of an array ) having element type t, and consequently able to have any
object as an element .
generalized boolean n.anobject used as a truth value, where the symbol nil
represents false and all other objects represent true. See boolean .
generalized instance n.(of a class ) an object theclass of which is either that
class itself, or some subclass of that class . (Because of the correspondence between
types and classes, the term \generalized instance of X" implies \object of type X"
and in cases where Xis aclass (orclass name ) the reverse is also true. The former
terminology emphasizes the view of Xas a class while the latter emphasizes the view
ofXas a type specier .)
generalized reference n.a reference to a location storing an object as if to a
variable . (Such a reference can be either to read orwrite the location.) See Section
5.1 (Generalized Reference). See also place .
generalized synonym stream n.(with a synonym stream symbol ) 1. (to a stream )
asynonym stream to the stream , or a composite stream which has as a target a
generalized synonym stream to the stream . 2. (to a symbol ) asynonym stream to the
symbol , or a composite stream which has as a target a generalized synonym stream to
thesymbol .
generic function n.afunction whose behavior depends on the classes or identities
of the arguments supplied to it and whose parts include, among other things, a set of
methods , alambda list , and a method combination type.
generic function lambda list n.Alambda list that is used to describe data ow
into a generic function . See Section 3.4.2 (Generic Function Lambda Lists).
gensym n. Trad. anuninterned symbol . See the functiongensym .
26–28 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
global declaration n.aform that makes certain kinds of information about code
globally available; that is, a proclaim form or adeclaim form .
global environment n.that part of an environment that contains bindings with
indenite scope and indenite extent .
global variable n.adynamic variable or a constant variable .
glyph n.a visual representation. \Graphic characters have associated glyphs."
gov.to transfer control to a go point . See the special operator go.
go point one of possibly several exit points that are established bytagbody (or other
abstractions, such as prog , which are built from tagbody ).
go tag n.thesymbol orinteger that, within the lexical scope of atagbody form ,
names an exit point established by thattagbody form .
graphic adj.(of a character ) being a \printing" or \displayable" character that has a
standard visual representation as a single glyph , such as Aor*or=.Space is dened to
begraphic . Of the standard characters , all but newline aregraphic . See non-graphic .
H
handle v.(of a condition being signaled ) to perform a non-local transfer of control,
terminating the ongoing signaling of the condition .
handler n.acondition handler .
hash table n.anobject oftypehash-table , which provides a mapping from keys to
values .
home package n.(of a symbol ) the package , if any, which is contents of the package
cellof the symbol , and which dictates how the Lisp printer prints the symbol when it
is not accessible in the current package . (Symbols which have nilin their package cell
are said to have no home package , and also to be apparently uninterned .)
I
I/O customization variable n.one of the stream variables in Figure 26{2, or some
other ( implementation-dened )stream variable that is dened by the implementation
to be an I/O customization variable .
Glossary 26–29
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
*debug-io* *error-io* query-io*
*standard-input* *standard-output* *trace-output*
Figure 26–2. Standardized I/O Customization Variables
identical adj.thesame undereq.
identiﬁer n.1. a symbol used to identify or to distinguish names . 2. a string used
the same way.
immutable adj.not subject to change, either because no operator is provided which is
capable of eecting such change or because some constraint exists which prohibits the
use of an operator that might otherwise be capable of eecting such a change. Except
as explicitly indicated otherwise, implementations are not required to detect attempts
to modify immutable objects orcells; the consequences of attempting to make such
modication are undened. \Numbers are immutable."
implementation n.a system, mechanism, or body of code that implements the
semantics of Common Lisp.
implementation limit n.a restriction imposed by an implementation .
implementation-deﬁned adj. implementation-dependent , but required by this
specication to be dened by each conforming implementation and to be documented
by the corresponding implementor.
implementation-dependent adj.describing a behavior or aspect of Common
Lisp which has been deliberately left unspecied, that might be dened in some
conforming implementations but not in others, and whose details may dier between
implementations . A conforming implementation is encouraged (but not required)
to document its treatment of each item in this specication which is marked
implementation-dependent , although in some cases such documentation might simply
identify the item as \undened."
implementation-independent adj.used to identify or emphasize a behavior or
aspect of Common Lisp which does not vary between conforming implementations .
implicit block n.ablock introduced by a macro form rather than by an explicit
block form .
implicit compilation n. compilation performed during evaluation .
implicit progn n.an ordered set of adjacent forms appearing in another form , and
dened by their context in that form to be executed as if within a progn .
26–30 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
implicit tagbody n.an ordered set of adjacent forms and/or tags appearing in
another form , and dened by their context in that form to be executed as if within a
tagbody .
import v.t.(asymbol into a package ) to make the symbol bepresent in the package .
improper list n.alistwhich is not a proper list : acircular list or a dotted list .
inaccessible adj.notaccessible .
indeﬁnite extent n.anextent whose duration is unlimited. \Most Common Lisp
objects have indenite extent."
indeﬁnite scope n. scope that is unlimited.
indicator n.aproperty indicator .
indirect instance n.(of a classC1) an object ofclassC2, whereC2is asubclass of
C1. \An integer is an indirect instance of the class number ."
inherit v.t.1. to receive or acquire a quality, trait, or characteristic; to gain access
to a feature dened elsewhere. 2. (a class ) to acquire the structure and behavior
dened by a superclass . 3. (a package ) to make symbols exported by another package
accessible by using use-package .
initial pprint dispatch table n.thevalue of*print-pprint-dispatch* at the time
theLisp image is started.
initial readtable n.thevalue of*readtable* at the time the Lisp image is started.
initialization argument list n.aproperty list of initialization argument names and
values used in the protocol for initializing and reinitializing instances ofclasses . See
Section 7.1 (Object Creation and Initialization).
initialization form n.aform used to supply the initial value for a slotorvariable .
\The initialization form for a slot in a defclass form is introduced by the keyword
:initform ."
input adj.(of a stream ) supporting input operations ( i.e., being a \data source"). An
input stream might also be an output stream , in which case it is sometimes called a
bidirectional stream . See the functioninput-stream-p .
instance n.1. a direct instance . 2. a generalized instance . 3. an indirect instance .
integer n.anobject oftypeinteger , which represents a mathematical integer.
Glossary 26–31
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
interactive stream n.astream on which it makes sense to perform interactive
querying. See Section 21.1.1.1.3 (Interactive Streams).
intern v.t.1. (a string in a package ) to look up the string in the package , returning
either a symbol with that name which was already accessible in the package or a newly
created internal symbol of the package with that name . 2. Idiom. generally, to observe
a protocol whereby objects which are equivalent or have equivalent names under some
predicate dened by the protocol are mapped to a single canonical object.
internal symbol n.(of a package ) a symbol which is accessible in the package , but
which is not an external symbol of the package .
internal time n. time , represented as an integer number of internal time units .
Absolute internal time is measured as an oset from an arbitrarily chosen,
implementation-dependent base. See Section 25.1.4.3 (Internal Time).
internal time unit n.a unit of time equal to 1=nof a second, for some implementation-
dened integer value ofn. See the variableinternal-time-units-per-second .
interned adj. Trad. 1. (of a symbol )accessible 3in any package . 2. (of a symbol in a
specic package )present in that package .
interpreted function n.afunction that is not a compiled function . (It is possible
for there to be a conforming implementation which has no interpreted functions , but a
conforming program must not assume that all functions arecompiled functions .)
interpreted implementation n.animplementation that uses an execution strategy
forinterpreted functions that does not involve a one-time semantic analysis pre-pass,
and instead uses \lazy" (and sometimes repetitious) semantic analysis of forms as they
are encountered during execution.
interval designator n.(oftypeT) an ordered pair of objects that describe a subtype
ofTby delimiting an interval on the real number line. See Section 12.1.6 (Interval
Designators).
invalid n.,adj.1.n.a possible constituent trait of a character which if present
signies that the character cannot ever appear in a token except under the control of
asingle escape character . For details, see Section 2.1.4.1 (Constituent Characters). 2.
adj.(of a character ) being a character that has syntax type constituent in the current
readtable and that has the constituent trait invalid 1. See Figure 2{8.
iteration form n.acompound form whose operator is named in Figure 26{3, or a
compound form that has an implementation-dened operator and that is dened by
theimplementation to be an iteration form .
26–32 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
do do-external-symbols dotimes
do* do-symbols loop
do-all-symbols dolist
Figure 26–3. Standardized Iteration Forms
iteration variable n.avariableV, the binding for which was created by an explicit
useofVin an iteration form .
K
key n.anobject used for selection during retrieval. See association list ,property list ,
and hash table . Also, see Section 17.1 (Sequence Concepts).
keyword n.1. a symbol thehome package of which is the KEYWORD package . 2.
any symbol , usually but not necessarily in the KEYWORD package , that is used as an
identifying marker in keyword-style argument passing. See lambda . 3. Idiom. a
lambda list keyword .
keyword parameter n.Aparameter for which a corresponding keyword argument is
optional. (There is no such thing as a required keyword argument .) If the argument is
not supplied, a default value is used. See also supplied-p parameter .
keyword/value pair n.two successive elements (akeyword and a value , respectively)
of a property list .
L
lambda combination n. Trad. alambda form .
lambda expression n.alistwhich can be used in place of a function name in certain
contexts to denote a function by directly describing its behavior rather than indirectly
by referring to the name of an established function ; its name derives from the fact that
its rst element is the symbollambda . Seelambda .
lambda form n.aform that is a listand that has a rst element which is a lambda
expression representing a function to be called on arguments which are the result of
evaluating subsequent elements of the lambda form .
lambda list n.alistthat species a set of parameters (sometimes called lambda
variables ) and a protocol for receiving values for those parameters ; that is, an ordinary
lambda list , an extended lambda list , or a modied lambda list .
Glossary 26–33
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
lambda list keyword n.asymbol whose name begins with ampersand and that is
specially recognized in a lambda list . Note that no standardized lambda list keyword is
in theKEYWORD package .
lambda variable n.aformal parameter , used to emphasize the variable 's relation to
thelambda list that established it.
leaf n.1. an atom in a tree1. 2. a terminal node of a tree2.
leap seconds n.additional one-second intervals of time that are occasionally inserted
into the true calendar by ocial timekeepers as a correction similar to \leap years."
All Common Lisp time representations ignore leap seconds ; every day is assumed to be
exactly 86400 seconds long.
left-parenthesis n.thestandard character \(", that is variously called \left
parenthesis" or \open parenthesis" See Figure 2{5.
length n.(of a sequence ) the number of elements in the sequence . (Note that if the
sequence is avector with a ll pointer , its length is the same as the ll pointer even
though the total allocated size of the vector might be larger.)
lexical binding n.abinding in a lexical environment .
lexical closure n.afunction that, when invoked on arguments , executes the body of
alambda expression in the lexical environment that was captured at the time of the
creation of the lexical closure , augmented by bindings of the function 'sparameters to
the corresponding arguments .
lexical environment n.that part of the environment that contains bindings whose
names have lexical scope . A lexical environment contains, among other things:
ordinary bindings ofvariable names tovalues , lexically established bindings offunction
names tofunctions ,macros ,symbol macros ,blocks ,tags, and local declarations (see
declare ).
lexical scope n. scope that is limited to a spatial or textual region within the
establishing form . \The names of parameters to a function normally are lexically
scoped."
lexical variable n.avariable thebinding for which is in the lexical environment .
Lisp image n.a running instantiation of a Common Lisp implementation . A Lisp
image is characterized by a single address space in which any object can directly refer
to any another in conformance with this specication, and by a single, common, global
environment . (External operating systems sometimes call this a \core image," \fork,"
\incarnation," \job," or \process." Note however, that the issue of a \process" in such
26–34 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
an operating system is technically orthogonal to the issue of a Lisp image being dened
here. Depending on the operating system, a single \process" might have multiple Lisp
images , and multiple \processes" might reside in a single Lisp image . Hence, it is the
idea of a fully shared address space for direct reference among all objects which is the
dening characteristic. Note, too, that two \processes" which have a communication
area that permits the sharing of some but not all objects are considered to be distinct
Lisp images .)
Lisp printer n. Trad. the procedure that prints the character representation of an
object onto a stream . (This procedure is implemented by the functionwrite .)
Lisp read-eval-print loop n. Trad. an endless loop that reads 2aform ,evaluates it,
and prints ( i.e.,writes 2) the results. In many implementations , the default mode of
interaction with Common Lisp during program development is through such a loop.
Lisp reader n. Trad. the procedure that parses character representations of objects
from a stream , producing objects . (This procedure is implemented by the function
read.)
listn.1. a chain of conses in which the carof each cons is an element of the list, and
thecdrof each cons is either the next link in the chain or a terminating atom . See also
proper list ,dotted list , orcircular list . 2. the type that is the union of nullandcons.
list designator n.adesignator for a listofobjects ; that is, an object that denotes a
listand that is one of: a non-nil atom (denoting a singleton list whose element is that
non-nil atom ) or a proper list (denoting itself).
list structure n.(of a list) the set of conses that make up the list. Note that while
thecar1bcomponent of each such cons is part of the list structure , the objects that are
elements of the list(i.e., the objects that are the cars 2of each cons in the list) are not
themselves part of its list structure , even if they are conses , except in the ( circular 2)
case where the listactually contains one of its tails as an element . (The list structure
of a listis sometimes redundantly referred to as its \top-level list structure" in order
to emphasize that any conses that are elements of the listare not involved.)
literal adj.(of an object ) referenced directly in a program rather than being computed
by the program; that is, appearing as data in a quote form , or, if the object is aself-
evaluating object , appearing as unquoted data. \In the form (cons "one" ’("two")) ,
the expressions "one" ,("two") , and"two" are literal objects."
load v.t.(ale) to cause the code contained in the leto be executed . See the function
load.
load time n.the duration of time that the loader is loading compiled code .
Glossary 26–35
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
load time value n.anobject referred to in code by aload-time-value form . The
value of such a form is some specic object which can only be computed in the
run-time environment . In the case of le compilation , the value is computed once as
part of the process of loading thecompiled le , and not again. See the special operator
load-time-value .
loader n.a facility that is part of Lisp and that loads ale. See the functionload.
local declaration n.anexpression which may appear only in specially designated
positions of certain forms , and which provides information about the code contained
within the containing form ; that is, a declare expression .
local precedence order n.(of a class ) alistconsisting of the class followed by its
direct superclasses in the order mentioned in the dening form for the class .
local slot n.(of a class ) aslot accessible in only one instance , namely the instance in
which the slotis allocated.
logical block n.a conceptual grouping of related output used by the pretty printer .
See the macropprint-logical-block and Section 22.2.1.1 (Dynamic Control of the
Arrangement of Output).
logical host n.anobject ofimplementation-dependent nature that is used as the
representation of a \host" in a logical pathname , and that has an associated set of
translation rules for converting logical pathnames belonging to that host into physical
pathnames . See Section 19.3 (Logical Pathnames).
logical host designator n.adesignator for a logical host ; that is, an object that
denotes a logical host and that is one of: a string (denoting the logical host that it
names), or a logical host (denoting itself). (Note that because the representation of a
logical host isimplementation-dependent , it is possible that an implementation might
represent a logical host as the string that names it.)
logical pathname n.anobject oftypelogical-pathname .
long ﬂoat n.anobject oftypelong-ﬂoat .
loop keyword n. Trad. a symbol that is a specially recognized part of the syntax of
an extended loop form . Such symbols are recognized by their name (usingstring= ),
not by their identity; as such, they may be in any package. A loop keyword is not a
keyword .
lowercase adj.(of a character ) being among standard characters corresponding to the
small letters athrough z, or being some other implementation-dened character that
26–36 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
is dened by the implementation to be lowercase . See Section 13.1.4.3 (Characters
With Case).
M
macro n.1. a macro form 2. a macro function . 3. a macro name .
macro character n.acharacter which, when encountered by the Lisp reader in its
main dispatch loop, introduces a reader macro 1. (Macro characters have nothing to
do with macros .)
macro expansion n.1. the process of translating a macro form into another form .
2. the form resulting from this process.
macro form n.aform that stands for another form (e.g., for the purposes of
abstraction, information hiding, or syntactic convenience); that is, either a compound
form whose rst element is a macro name , or a form that is a symbol that names a
symbol macro .
macro function n.afunction of two arguments, a form and an environment , that
implements macro expansion by producing a form to be evaluated in place of the
original argument form .
macro lambda list n.anextended lambda list used in forms that establish macro
denitions, such as defmacro andmacrolet . See Section 3.4.4 (Macro Lambda Lists).
macro name n.aname for which macro-function returns true and which when used
as the rst element of a compound form identies that form as a macro form .
macroexpand hook n.thefunction that is the value of*macroexpand-hook* .
mapping n.1. a type of iteration in which a function is successively applied to objects
taken from corresponding entries in collections such as sequences orhash tables . 2.
Math. a relation between two sets in which each element of the rst set (the \domain")
is assigned one element of the second set (the \range").
metaclass n.1. a class whose instances are classes . 2. (of an object ) the class of the
class of the object .
Metaobject Protocol n.one of many possible descriptions of how a conforming
implementation might implement various aspects of the object system. This description
is beyond the scope of this document, and no conforming implementation is required to
adhere to it except as noted explicitly in this specication. Nevertheless, its existence
helps to establish normative practice, and implementors with no reason to diverge
from it are encouraged to consider making their implementation adhere to it where
possible. It is described in detail in The Art of the Metaobject Protocol .
Glossary 26–37
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
method n.anobject that is part of a generic function and which provides information
about how that generic function should behave when its arguments areobjects of
certain classes or with certain identities.
method combination n.1. generally, the composition of a set of methods to produce
aneective method for a generic function . 2. an object of typemethod-combination ,
which represents the details of how the method combination 1for one or more specic
generic functions is to be performed.
method-deﬁning form n.aform that denes a method for a generic function ,
whether explicitly or implicitly. See Section 7.6.1 (Introduction to Generic Functions).
method-deﬁning operator n.anoperator corresponding to a method-dening form .
See Figure 7{1.
minimal compilation n.actions the compiler must take at compile time. See Section
3.2.2 (Compilation Semantics).
modiﬁed lambda list n.a list resembling an ordinary lambda list in form and
purpose, but which deviates in syntax or functionality from the denition of an
ordinary lambda list . See ordinary lambda list . \deftype uses a modied lambda list."
most recent adj. innermost; that is, having been established (and not yet
disestablished ) more recently than any other of its kind.
multiple escape n.,adj.1.n.thesyntax type of a character that is used in pairs to
indicate that the enclosed characters are to be treated as alphabetic 2characters with
their case preserved. For details, see Section 2.1.4.5 (Multiple Escape Characters). 2.
adj.(of a character ) having the multiple escape syntax type . 3. n.amultiple escape 2
character . (In the standard readtable ,vertical-bar is amultiple escape character .)
multiple values n.1. more than one value . \The function truncate returns multiple
values." 2. a variable number of values , possibly including zero or one. \The function
values returns multiple values." 3. a xed number of values other than one. \The
macromultiple-value-bind is among the few operators in Common Lisp which can
detect and manipulate multiple values."
N
name n.,v.t.1.n.anidentier by which an object , abinding , or an exit point is
referred to by association using a binding . 2. v.t.to give a name to. 3. n.(of an
object having a name component) the object which is that component. \The string
which is a symbol's name is returned by symbol-name ." 4. n.(of a pathname ) a. the
name component, returned by pathname-name . b. the entire namestring, returned
bynamestring . 5. n.(of a character ) astring that names the character and that
26–38 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
haslength greater than one. (All non-graphic characters are required to have names
unless they have some implementation-dened attribute which is not null. Whether or
not other characters have names isimplementation-dependent .)
named constant n.avariable that is dened by Common Lisp, by the implementation ,
or by user code (see the macrodefconstant ) to always yield the same value when
evaluated . \The value of a named constant may not be changed by assignment or by
binding."
namespace n.1.bindings whose denotations are restricted to a particular kind. \The
bindings of names to tags is the tag namespace." 2. any mapping whose domain is a
set of names . \A package denes a namespace."
namestring n.astring that represents a lename using either the standardized
notation for naming logical pathnames described in Section 19.3.1 (Syntax of Logical
Pathname Namestrings), or some implementation-dened notation for naming a
physical pathname .
newline n.thestandard character hNewlinei, notated for the Lisp reader as#\Newline .
next method n.the next method to be invoked with respect to a given method for
a particular set of arguments or argument classes . See Section 7.6.6.1.3 (Applying
method combination to the sorted list of applicable methods).
nickname n.(of a package ) one of possibly several names that can be used to refer to
thepackage but that is not the primary name of the package .
niln.theobject that is at once the symbol named"NIL" in theCOMMON-LISP package ,
theempty list , the boolean (orgeneralized boolean ) representing false, and the name of
theempty type .
non-atomic adj.being other than an atom ;i.e., being a cons.
non-constant variable n.avariable that is not a constant variable .
non-correctable adj.(of an error ) not intentionally correctable . (Because of the
dynamic nature of restarts , it is neither possible nor generally useful to completely
prohibit an error from being correctable . This term is used in order to express an
intent that no special eort should be made by code signaling an error to make that
error correctable ; however, there is no actual requirement on conforming programs or
conforming implementations imposed by this term.)
non-empty adj.having at least one element .
non-generic function n.afunction that is not a generic function .
Glossary 26–39
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
non-graphic adj.(of a character ) not graphic . See Section 13.1.4.1 (Graphic
Characters).
non-list n.,adj.other than a list;i.e., anon-nil atom .
non-local exit n.a transfer of control (and sometimes values ) to an exit point for
reasons other than a normal return . \The operators go,throw , andreturn-from
cause a non-local exit."
non-nil n.,adj.notnil. Technically, any object which is not nilcan be referred to
astrue, but that would tend to imply a unique view of the object as a generalized
boolean . Referring to such an object asnon-nil avoids this implication.
non-null lexical environment n.alexical environment that has additional
information not present in the global environment , such as one or more bindings .
non-simple adj.notsimple .
non-terminating adj.(of a macro character ) being such that it is treated as a
constituent character when it appears in the middle of an extended token. See Section
2.2 (Reader Algorithm).
non-top-level form n.aform that, by virtue of its position as a subform of another
form , is not a top level form . See Section 3.2.3.1 (Processing of Top Level Forms).
normal return n.the natural transfer of control and values which occurs after the
complete execution of a form .
normalized adj.,ANSI ,IEEE (of a oat) conforming to the description of
\normalized" as described by IEEE Standard for Binary Floating-Point Arithmetic .
Seedenormalized .
null adj.,n.1.adj.a. (of a list) having no elements : empty. See empty list . b. (of
astring ) having a length of zero. (It is common, both within this document and in
observed spoken behavior, to refer to an empty string by an apparent denite reference,
as in \the null string " even though no attempt is made to intern 2null strings. The
phrase \a null string " is technically more correct, but is generally considered awkward
by most Lisp programmers. As such, the phrase \the null string " should be treated
as an indenite reference in all cases except for anaphoric references.) c. (of an
implementation-dened attribute of a character ) An object to which the value of that
attribute defaults if no specic value was requested. 2. n.anobject oftypenull (the
only such object beingnil).
null lexical environment n.thelexical environment which has no bindings .
26–40 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
number n.anobject oftypenumber .
numeric adj.(of a character ) being one of the standard characters 0through 9, or
being some other graphic character dened by the implementation to be numeric .
O
object n.1. any Lisp datum. \The function cons creates an object which refers to
two other objects." 2. (immediately following the name of a type) an object which is
of that type, used to emphasize that the object is not just a name for an object of
that type but really an element of the type in cases where objects of that type (such as
function orclass ) are commonly referred to by name . \The function symbol-function
takes a function name and returns a function object."
object-traversing adj. operating in succession on components of an object .
\The operators mapcar ,maphash ,with-package-iterator andcount perform
object-traversing operations."
open adj.,v.t.(ale) 1. v.t.to create and return a stream to the le. 2. adj.(of a
stream ) having been opened 1, but not yet closed .
operator n.1. a function ,macro , orspecial operator . 2. a symbol that names such a
function ,macro , orspecial operator . 3. (in a function special form ) the cadr of the
function special form , which might be either an operator 2or a lambda expression .
4. (of a compound form ) the carof the compound form , which might be either an
operator 2or a lambda expression , and which is never (setf symbol).
optimize quality n.one of several aspects of a program that might be optimizable
by certain compilers. Since optimizing one such quality might conict with optimizing
another, relative priorities for qualities can be established in an optimize declaration .
The standardized optimize qualities arecompilation-speed (speed of the compilation
process), debug (ease of debugging), safety (run-time error checking), space (both code
size and run-time space), and speed (of the object code). Implementations may dene
additional optimize qualities .
optional parameter n.Aparameter for which a corresponding positional argument
is optional. If the argument is not supplied, a default value is used. See also supplied-p
parameter .
ordinary function n.afunction that is not a generic function .
ordinary lambda list n.the kind of lambda list used bylambda . See modied
lambda list and extended lambda list . \defun uses an ordinary lambda list."
Glossary 26–41
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
otherwise inaccessible part n.(of an object ,O1) an object ,O2, which would
be made inaccessible ifO1were made inaccessible . (Every object is an otherwise
inaccessible part of itself.)
output adj.(of a stream ) supporting output operations ( i.e., being a \data sink").
Anoutput stream might also be an input stream , in which case it is sometimes called
abidirectional stream . See the functionoutput-stream-p .
P
package n.anobject oftypepackage .
package cell n. Trad. (of a symbol ) The place in a symbol that holds one of possibly
several packages in which the symbol isinterned , called the home package , or which
holdsnilif no such package exists or is known. See the functionsymbol-package .
package designator n.adesignator for a package ; that is, an object that denotes
apackage and that is one of: a string designator (denoting the package that has
thestring that it designates as its name or as one of its nicknames ), or a package
(denoting itself).
package marker n.a character which is used in the textual notation for a symbol to
separate the package name from the symbol name, and which is colon in the standard
readtable . See Section 2.1 (Character Syntax).
package preﬁx n.a notation preceding the name of asymbol in text that is processed
by the Lisp reader , which uses a package name followed by one or more package
markers , and which indicates that the symbol is looked up in the indicated package .
package registry n.A mapping of names topackage objects . It is possible for there
to be a package object which is not in this mapping; such a package is called an
unregistered package .Operators such asﬁnd-package consult this mapping in order
to nd a package from its name .Operators such asdo-all-symbols ,ﬁnd-all-symbols ,
andlist-all-packages operate only on packages that exist in the package registry .
pairwise adv. (of an adjective on a set) applying individually to all possible pairings
of elements of the set. \The types A,B, andCare pairwise disjoint if AandBare
disjoint,BandCare disjoint, and AandCare disjoint."
parallel adj. Trad. (ofbinding orassignment ) done in the style of psetq ,let, ordo;
that is, rst evaluating all of the forms that produce values , and only then assigning
orbinding thevariables (orplaces ). Note that this does not imply traditional
computational \parallelism" since the forms that produce values are evaluated
sequentially . See sequential .
26–42 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
parameter n.1. (of a function ) avariable in the denition of a function which takes
on the value of a corresponding argument (or of a listof corresponding arguments) to
that function when it is called, or which in some cases is given a default value because
there is no corresponding argument . 2. (of a format directive ) an object received as
data ow by a format directive due to a prex notation within the format string at the
format directive 's point of use. See Section 22.3 (Formatted Output). \In "~3,’0D" ,
the number 3and the character #\0are parameters to the ~Dformat directive."
parameter specializer n.1. (of a method ) an expression which constrains the
method to be applicable only to argument sequences in which the corresponding
argument matches the parameter specializer . 2. a class , or a list(eql object).
parameter specializer name n.1. (of a method denition) an expression used in
code to name a parameter specializer . See Section 7.6.2 (Introduction to Methods). 2.
aclass , asymbol naming a class , or a list(eql form).
pathname n.anobject oftypepathname , which is a structured representation of the
name of a le. Apathname has six components: a \host," a \device," a \directory," a
\name," a \type," and a \version."
pathname designator n.adesignator for a pathname ; that is, an object that denotes
apathname and that is one of: a pathname namestring (denoting the corresponding
pathname ), astream associated with a le (denoting the pathname used to open the
le; this may be, but is not required to be, the actual name of the le), or a pathname
(denoting itself). See Section 21.1.1.1.2 (Open and Closed Streams).
physical pathname n.apathname that is not a logical pathname .
place n.1. a form which is suitable for use as a generalized reference . 2. the
conceptual location referred to by such a place 1.
plist [p—elist]n.aproperty list .
portable adj.(ofcode) required to produce equivalent results and observable side
eects in all conforming implementations .
potential copy n.(of an objectO1subject to constriants) an objectO2that if the
specied constraints are satised by O1without any modication might or might not
beidentical toO1, or else that must be a fresh object that resembles a copy ofO1
except that it has been modied as necessary to satisfy the constraints.
potential number n.A textual notation that might be parsed by the Lisp reader in
some conforming implementation as a number but is not required to be parsed as a
number . No object is apotential number |either an object is anumber or it is not.
See Section 2.3.1.1 (Potential Numbers as Tokens).
Glossary 26–43
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
pprint dispatch table n.anobject that can be the value of*print-pprint-dispatch*
and hence can control how objects are printed when *print-pretty* istrue. See
Section 22.2.1.4 (Pretty Print Dispatch Tables).
predicate n.afunction that returns a generalized boolean as its rst value.
present n.1. (of a feature in a Lisp image ) a state of being that is in eect if and
only if the symbol naming the feature is an element of the features list . 2. (of a symbol
in a package ) being accessible in that package directly, rather than being inherited
from another package .
pretty print v.t.(anobject ) to invoke the pretty printer on the object .
pretty printer n.the procedure that prints the character representation of an
object onto a stream when the value of*print-pretty* istrue, and that uses layout
techniques ( e.g., indentation) that tend to highlight the structure of the object in
a way that makes it easier for human readers to parse visually. See the variable
*print-pprint-dispatch* and Section 22.2 (The Lisp Pretty Printer).
pretty printing stream n.astream that does pretty printing. Such streams are
created by the functionpprint-logical-block as a link between the output stream and
the logical block.
primary method n.a member of one of two sets of methods (the set of auxiliary
methods is the other) that form an exhaustive partition of the set of methods on the
method 'sgeneric function . How these sets are determined is dependent on the method
combination type; see Section 7.6.2 (Introduction to Methods).
primary value n.(ofvalues resulting from the evaluation of a form ) the rst value ,
if any, or else nilif there are no values . \The primary value returned by truncate is
an integer quotient, truncated toward zero."
principal adj.(of a value returned by a Common Lisp function that implements a
mathematically irrational or transcendental function dened in the complex domain) of
possibly many (sometimes an innite number of) correct values for the mathematical
function, being the particular value which the corresponding Common Lisp function
has been dened to return.
print name n. Trad. (usually of a symbol ) aname 3.
printer control variable n.avariable whose specic purpose is to control some
action of the Lisp printer ; that is, one of the variables in Figure 22{1, or else some
implementation-dened variable which is dened by the implementation to be a printer
control variable .
26–44 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
printer escaping n.The combined state of the printer control variables
*print-escape* and*print-readably* . If the value of either *print-readably*
or*print-escape* istrue, then printer escaping is \enabled"; otherwise (if the
values of both *print-readably* and*print-escape* arefalse), then printer escaping
is \disabled".
printing adj.(of a character ) being a graphic character other than space .
process v.t.(aform by the compiler ) to perform minimal compilation , determining
the time of evaluation for a form , and possibly evaluating that form (if required).
processor n.,ANSI animplementation .
proclaim v.t.(aproclamation ) to establish that proclamation .
proclamation n.aglobal declaration .
prog tag n. Trad. ago tag .
program n. Trad. Common Lisp code.
programmer n.an active entity, typically a human, that writes a program , and that
might or might not also be a user of the program .
programmer code n. code that is supplied by the programmer; that is, code that is
notsystem code .
proper list n.Alistterminated by the empty list . (The empty list is aproper list .)
Seeimproper list .
proper name n.(of a class ) asymbol that names theclass whose name is that
symbol . See the functions class-name andﬁnd-class .
proper sequence n.asequence which is not an improper list ; that is, a vector or a
proper list .
proper subtype n.(of a type) asubtype of the type which is not the same type as the
type (i.e., its elements are a \proper subset" of the type).
property n.(of a property list ) 1. a conceptual pairing of a property indicator and its
associated property value on a property list . 2. a property value .
property indicator n.(of a property list ) the name part of a property , used as a key
when looking up a property value on a property list .
Glossary 26–45
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
property list n.1. a listcontaining an even number of elements that are alternating
names (sometimes called indicators orkeys) and values (sometimes called properties ).
When there is more than one name and value pair with the identical name in
aproperty list , the rst such pair determines the property . 2. (of a symbol ) the
component of the symbol containing a property list .
property value n.(of a property indicator on a property list ) the object associated
with the property indicator on the property list .
purports to conform v.makes a good-faith claim of conformance. This term
expresses intention to conform, regardless of whether the goal of that intention is
realized in practice. For example, language implementations have been known to
have bugs, and while an implementation of this specication with bugs might not be
aconforming implementation , it can still purport to conform . This is an important
distinction in certain specic cases; e.g., see the variable*features* .
Q
qualiﬁed method n.amethod that has one or more qualiers .
qualiﬁer n.(of a method for a generic function ) one of possibly several objects used
to annotate the method in a way that identies its role in the method combination .
The method combination type determines how many qualiers are permitted for each
method , which qualiers are permitted, and the semantics of those qualiers .
query I/O n.thebidirectional stream that is the value of the variable*query-io* .
quoted object n.anobject which is the second element of a quote form .
R
radix n.aninteger between 2 and 36, inclusive, which can be used to designate a base
with respect to which certain kinds of numeric input or output are performed. (There
arenvalid digit characters for any given radixn, and those digits are the rst ndigits
in the sequence 0,1,:::,9,A,B,:::,Z, which have the weights 0,1,:::,9,10,11,:::,
35, respectively. Case is not signicant in parsing numbers of radix greater than 10, so
\9b8a" and \9B8A" denote the same radix16number.)
random state n.anobject oftyperandom-state .
rank n.a non-negative integer indicating the number of dimensions of an array .
ratio n.anobject oftyperatio .
26–46 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
ratio marker n.a character which is used in the textual notation for a ratio to
separate the numerator from the denominator, and which is slash in the standard
readtable . See Section 2.1 (Character Syntax).
rational n.anobject oftyperational .
read v.t.1. (a binding orslotor component) to obtain the value of the binding orslot.
2. (an object from a stream ) to parse an object from its representation on the stream .
readably adv. (of a manner of printing an objectO1) in such a way as to permit the
Lisp Reader to later parse the printed output into an objectO2that is similar toO1.
reader n.1. a function that reads 1avariable orslot. 2. the Lisp reader .
reader macro n.1. a textual notation introduced by dispatch on one or two
characters that denes special-purpose syntax for use by the Lisp reader , and that is
implemented by a reader macro function . See Section 2.2 (Reader Algorithm). 2. the
character orcharacters that introduce a reader macro 1; that is, a macro character or
the conceptual pairing of a dispatching macro character and the character that follows
it. (A reader macro is not a kind of macro .)
reader macro function n.afunction designator that denotes a function
that implements a reader macro 2. See the functions set-macro-character and
set-dispatch-macro-character .
readtable n.anobject oftypereadtable .
readtable case n.an attribute of a readtable whose value is a case sensitivity mode ,
and that selects the manner in which characters in a symbol 'sname are to be treated
by the Lisp reader and the Lisp printer . See Section 23.1.2 (Eect of Readtable Case
on the Lisp Reader) and Section 22.1.3.3.2 (Eect of Readtable Case on the Lisp
Printer).
readtable designator n.adesignator for a readtable ; that is, an object that denotes
areadtable and that is one of: nil(denoting the standard readtable ), or a readtable
(denoting itself).
recognizable subtype n.(of a type) asubtype of the type which can be reliably
detected to be such by the implementation . See the functionsubtypep .
reference n.,v.t.1.n.an act or occurrence of referring to an object , abinding , an
exit point , atag, or an environment . 2. v.t.to refer to an object , abinding , an exit
point , atag, or an environment , usually by name .
Glossary 26–47
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
registered package n.apackage object that is installed in the package registry .
(Every registered package has a name that is a string , as well as zero or more string
nicknames. All packages that are initially specied by Common Lisp or created by
make-package ordefpackage areregistered packages .Registered packages can be
turned into unregistered packages bydelete-package .)
relative adj.1. (of a time) representing an oset from an absolute time in the
units appropriate to that time. For example, a relative internal time is the dierence
between two absolute internal times , and is measured in internal time units . 2. (of a
pathname ) representing a position in a directory hierarchy by motion from a position
other than the root, which might therefore vary. \The notation #P"../foo.text"
denotes a relative pathname if the host le system is Unix." See absolute .
repertoire n.,ISO asubtype ofcharacter . See Section 13.1.2.2 (Character
Repertoires).
report n.(of a condition ) to callthefunction print-object on the condition in an
environment where the value of*print-escape* isfalse.
report message n.the text that is output by a condition reporter .
required parameter n.Aparameter for which a corresponding positional argument
must be supplied when calling thefunction .
rest list n.(of a function having a rest parameter ) The listto which the rest parameter
isbound on some particular callto the function .
rest parameter n.Aparameter which was introduced by &rest .
restart n.anobject oftyperestart .
restart designator n.adesignator for a restart ; that is, an object that denotes a
restart and that is one of: a non-nil symbol (denoting the most recently established
active restart whose name is that symbol ), or a restart (denoting itself).
restart function n.afunction that invokes a restart , as if by invoke-restart .
The primary purpose of a restart function is to provide an alternate interface. By
convention, a restart function usually has the same name as the restart which it
invokes. Figure 26{4 shows a list of the standardized restart functions .
abort muﬄe-warning use-value
continue store-value
Figure 26–4. Standardized Restart Functions
26–48 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
return v.t.(ofvalues ) 1. (from a block ) to transfer control and values from the block ;
that is, to cause the block toyield thevalues immediately without doing any further
evaluation of the forms in its body. 2. (from a form ) to yield thevalues .
return value n. Trad. avalue 1
right-parenthesis n.thestandard character \)", that is variously called \right
parenthesis" or \close parenthesis" See Figure 2{5.
run time n.1.load time 2.execution time
run-time compiler n.refers to the compile function or to implicit compilation , for
which the compilation and run-time environments are maintained in the same Lisp
image .
run-time deﬁnition n.a denition in the run-time environment .
run-time environment n.theenvironment in which a program is executed .
S
safe adj.1. (of code) processed in a lexical environment where the the highest safety
level (3) was in eect. See optimize . 2. (of a call) asafe call .
safe call n.acallin which the call, the function being called , and the point of
functional evaluation are all safe 1code. For more detailed information, see Section
3.5.1.1 (Safe and Unsafe Calls).
same adj.1. (of objects under a specied predicate ) indistinguishable by that
predicate . \The symbol car, the string "car" , and the string "CAR" are thesame under
string-equal ". 2. (of objects if no predicate is implied by context) indistinguishable
byeql. Note that eqmight be capable of distinguishing some numbers and characters
whicheqlcannot distinguish, but the nature of such, if any, is implementation-
dependent . Sinceeqis used only rarely in this specication, eqlis the default predicate
when none is mentioned explicitly. \The conses returned by two successive calls to cons
are never the same." 3. (of types ) having the same set of elements ; that is, each type
is asubtype of the others. \The types specied by (integer 0 1) ,(unsigned-byte 1) ,
andbitare the same."
satisfy the test v.(of an object being considered by a sequence function ) 1. (for a one
argument test) to be in a state such that the function which is the predicate argument
to the sequence function returns true when given a single argument that is the result
of calling the sequence function 'skeyargument on the object being considered. See
Section 17.2.2 (Satisfying a One-Argument Test). 2. (for a two argument test) to
be in a state such that the two-place predicate which is the sequence function 'stest
Glossary 26–49
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
argument returns true when given a rst argument that is the object being considered,
and when given a second argument that is the result of calling the sequence function 's
keyargument on an element of the sequence function 'ssequence argument which is
being tested for equality; or to be in a state such that the test-not function returns
false given the same arguments . See Section 17.2.1 (Satisfying a Two-Argument Test).
scope n.the structural or textual region of code in which references to an object , a
binding , an exit point , atag, or an environment (usually by name ) can occur.
script n. ISO one of possibly several sets that form an exhaustive partition of the type
character . See Section 13.1.2.1 (Character Scripts).
secondary value n.(ofvalues resulting from the evaluation of a form ) the second
value , if any, or else nilif there are fewer than two values . \The secondary value
returned by truncate is a remainder."
section n.a partitioning of output by a conditional newline on a pretty printing
stream . See Section 22.2.1.1 (Dynamic Control of the Arrangement of Output).
self-evaluating object n.anobject that is neither a symbol nor a cons. If a
self-evaluating object isevaluated , ityields itself as its only value . \Strings are
self-evaluating objects."
semi-standard adj.(of a language feature) not required to be implemented by any
conforming implementation , but nevertheless recommended as the canonical approach
in situations where an implementation does plan to support such a feature. The
presence of semi-standard aspects in the language is intended to lessen portability
problems and reduce the risk of gratuitous divergence among implementations that
might stand in the way of future standardization.
semicolon n.thestandard character that is called \semicolon" ( ;). See Figure 2{5.
sequence n.1. an ordered collection of elements 2. a vector or a list.
sequence function n.one of the functions in Figure 17{1, or an implementation-
dened function that operates on one or more sequences . and that is dened by the
implementation to be a sequence function .
sequential adj. Trad. (ofbinding orassignment ) done in the style of setq,let*, or
do*; that is, interleaving the evaluation of the forms that produce values with the
assignments orbindings of the variables (orplaces ). See parallel .
sequentially adv. in a sequential way.
26–50 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
serious condition n.acondition oftypeserious-condition , which represents a
situation that is generally suciently severe that entry into the debugger should be
expected if the condition issignaled but not handled .
session n.the conceptual aggregation of events in a Lisp image from the time it is
started to the time it is terminated.
setv.t. Trad. (any variable or a symbol that is the name of a dynamic variable ) to
assign thevariable .
setf expander n.a function used by setf to compute the setf expansion of a place .
setf expansion n.a set of ve expressions 1that, taken together, describe how to
store into a place and which subforms of the macro call associated with the place are
evaluated. See Section 5.1.1.2 (Setf Expansions).
setf function n.afunction whose name is(setf symbol).
setf function name n.(of a symbol S) the list(setf S).
shadow v.t.1. to override the meaning of. \That binding of Xshadows an outer one."
2. to hide the presence of. \That macrolet ofFshadows the outer ﬂetofF." 3. to
replace. \That package shadows the symbol cl:car with its own symbol car."
shadowing symbol n.(in a package ) an element of the package 'sshadowing symbols
list.
shadowing symbols list n.(of a package ) alist, associated with the package , of
symbols that are to be exempted from `symbol conict errors' detected when packages
areused. See the functionpackage-shadowing-symbols .
shared slot n.(of a class ) aslot accessible in more than one instance of a class ;
specically, such a slotisaccessible in all direct instances of the class and in those
indirect instances whose class does not shadow 1theslot.
sharpsign n.thestandard character that is variously called \number sign," \sharp,"
or \sharp sign" ( #). See Figure 2{5.
short ﬂoat n.anobject oftypeshort-ﬂoat .
sign n.one of the standard characters \+" or \-".
signal v.to announce, using a standard protocol, that a particular situation,
represented by a condition , has been detected. See Section 9.1 (Condition System
Concepts).
Glossary 26–51
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
signature n.(of a method ) a description of the parameters and parameter specializers
for the method which determines the method 's applicability for a given set of
required arguments , and which also describes the argument conventions for its other,
non-required arguments .
similar adj.(of two objects ) dened to be equivalent under the similarity relationship.
similarity n.a two-place conceptual equivalence predicate, which is independent of
theLisp image so that two objects in dierent Lisp images can be understood to be
equivalent under this predicate. See Section 3.2.4 (Literal Objects in Compiled Files).
simple adj.1. (of an array ) being of typesimple-array . 2. (of a character ) having
noimplementation-dened attributes , or else having implementation-dened attributes
each of which has the null value for that attribute .
simple array n.anarray oftypesimple-array .
simple bit array n.abit array that is a simple array ; that is, an object oftype
(simple-array bit) .
simple bit vector n.abit vector oftypesimple-bit-vector .
simple condition n.acondition oftypesimple-condition .
simple general vector n.asimple vector .
simple string n.astring oftypesimple-string .
simple vector n.avector oftypesimple-vector , sometimes called a \ simple general
vector ." Not all vectors that are simple aresimple vectors |only those that have
element type t.
single escape n.,adj.1.n.thesyntax type of a character that indicates that the
next character is to be treated as an alphabetic 2character with its case preserved.
For details, see Section 2.1.4.6 (Single Escape Character). 2. adj.(of a character )
having the single escape syntax type . 3. n.asingle escape 2character . (In the standard
readtable ,slash is the only single escape .)
single ﬂoat n.anobject oftypesingle-ﬂoat .
single-quote n.thestandard character that is variously called \apostrophe," \acute
accent," \quote," or \single quote" ( ’). See Figure 2{5.
singleton adj.(of a sequence ) having only one element . \(list ’hello) returns a
singleton list."
26–52 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
situation n.theevaluation of a form in a specic environment .
slash n.thestandard character that is variously called \solidus" or \slash" ( /). See
Figure 2{5.
slot n.a component of an object that can store a value .
slot speciﬁer n.a representation of a slotthat includes the name of the slotand zero
or more slotoptions. A slotoption pertains only to a single slot.
source code n. code representing objects suitable for evaluation (e.g.,objects created
byread, by macro expansion , or by compiler macro expansion ).
source ﬁle n.alewhich contains a textual representation of source code , that can
be edited, loaded , orcompiled .
space n.thestandard character hSpacei, notated for the Lisp reader as#\Space .
special form n.alist, other than a macro form , which is a form with special syntax
or special evaluation rules or both, possibly manipulating the evaluation environment
or control ow or both. The rst element of a special form is aspecial operator .
special operator n.one of a xed set of symbols , enumerated in Figure 3{2, that
may appear in the carof a form in order to identify the form as a special form .
special variable n. Trad. adynamic variable .
specialize v.t.(ageneric function ) to dene a method for the generic function , or
in other words, to rene the behavior of the generic function by giving it a specic
meaning for a particular set of classes orarguments .
specialized adj.1. (of a generic function ) having methods which specialize thegeneric
function . 2. (of an array ) having an actual array element type that is a proper subtype
of the typet; see Section 15.1.1 (Array Elements). \ (make-array 5 :element-type ’bit)
makes an array of length ve that is specialized for bits."
specialized lambda list n.anextended lambda list used in forms that establish
method denitions, such as defmethod . See Section 3.4.3 (Specialized Lambda Lists).
spreadable argument list designator n.adesignator for a listofobjects ; that is,
anobject that denotes a listand that is a non-null list L1of lengthn, whose last
element is a listL2of lengthm(denoting a list L3of lengthm+n 1whose elements
areL1ifori<n 1followed by L2jforj<m). \The list (1 2 (3 4 5)) is a spreadable
argument list designator for the list (1 2 3 4 5)."
Glossary 26–53
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
stack allocate v.t. Trad. to allocate in a non-permanent way, such as on a stack.
Stack-allocation is an optimization technique used in some implementations for
allocating certain kinds of objects that have dynamic extent . Such objects are allocated
on the stack rather than in the heap so that their storage can be freed as part of
unwinding the stack rather than taking up space in the heap until the next garbage
collection. What types (if any) can have dynamic extent can vary from implementation
toimplementation . No implementation is ever required to perform stack-allocation.
stack-allocated adj. Trad. having been stack allocated .
standard character n.acharacter oftypestandard-char , which is one of a xed set
of 96 such characters required to be present in all conforming implementations . See
Section 2.1.3 (Standard Characters).
standard class n.aclass that is a generalized instance ofclassstandard-class .
standard generic function afunction oftypestandard-generic-function .
standard input n.theinput stream which is the value of the dynamic variable
*standard-input* .
standard method combination n.themethod combination namedstandard .
standard object n.anobject that is a generalized instance ofclassstandard-object .
standard output n.theoutput stream which is the value of the dynamic variable
*standard-output* .
standard pprint dispatch table n.Apprint dispatch table that is dierent from
theinitial pprint dispatch table , that implements pretty printing as described in this
specication, and that, unlike other pprint dispatch tables , must never be modied by
any program. (Although the denite reference \the standard pprint dispatch table " is
generally used within this document, it is actually implementation-dependent whether
a single object lls the role of the standard pprint dispatch table , or whether there
might be multiple such objects, any one of which could be used on any given occasion
where \the standard pprint dispatch table " is called for. As such, this phrase should be
seen as an indenite reference in all cases except for anaphoric references.)
standard readtable n.Areadtable that is dierent from the initial readtable , that
implements the expression syntax dened in this specication, and that, unlike
other readtables , must never be modied by any program. (Although the denite
reference \the standard readtable " is generally used within this document, it is
actually implementation-dependent whether a single object lls the role of the standard
readtable , or whether there might be multiple such objects, any one of which could
be used on any given occasion where \the standard readtable " is called for. As such,
26–54 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
this phrase should be seen as an indenite reference in all cases except for anaphoric
references.)
standard syntax n.the syntax represented by the standard readtable and used as a
reference syntax throughout this document. See Section 2.1 (Character Syntax).
standardized adj.(of a name ,object , or denition) having been dened by Common
Lisp. \All standardized variables that are required to hold bidirectional streams have
\-io*" in their name."
startup environment n.theglobal environment of the running Lisp image from
which the compiler was invoked.
step v.t.,n.1.v.t.(an iteration variable ) toassign thevariable a new value at the end
of an iteration, in preparation for a new iteration. 2. n.thecode that identies how
the next value in an iteration is to be computed. 3. v.t.(code) to specially execute
thecode, pausing at intervals to allow user conrmation or intervention, usually for
debugging.
stream n.anobject that can be used with an input or output function to identify an
appropriate source or sink of characters orbytes for that operation.
stream associated with a ﬁle n.ale stream , or a synonym stream
the target of which is a stream associated with a le . Such a stream
cannot be created with make-two-way-stream ,make-echo-stream ,
make-broadcast-stream ,make-concatenated-stream ,make-string-input-stream , or
make-string-output-stream .
stream designator n.adesignator for a stream ; that is, an object that denotes a
stream and that is one of: t(denoting the value of*terminal-io* ),nil(denoting
thevalue of*standard-input* forinput stream designators or denoting the value of
*standard-output* foroutput stream designators ), or a stream (denoting itself).
stream element type n.(of a stream ) the type of data for which the stream is
specialized.
stream variable n.avariable whose value must be a stream .
stream variable designator n.adesignator for a stream variable ; that is, a symbol
that denotes a stream variable and that is one of: t(denoting *terminal-io* ),
nil(denoting *standard-input* forinput stream variable designators or denoting
*standard-output* foroutput stream variable designators ), or some other symbol
(denoting itself).
string n.a specialized vector that is of typestring , and whose elements are of type
character or a subtype oftypecharacter .
Glossary 26–55
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
string designator n.adesignator for a string ; that is, an object that denotes a string
and that is one of: a character (denoting a singleton string that has the character
as its only element ), a symbol (denoting the string that is its name ), or a string
(denoting itself). The intent is that this term be consistent with the behavior of
string ;implementations that extend string must extend the meaning of this term in a
compatible way.
string equal adj.thesame understring-equal .
string stream n.astream oftypestring-stream .
structure n.anobject oftypestructure-object .
structure class n.aclass that is a generalized instance ofclassstructure-class .
structure name n.aname dened with defstruct . Usually, such a type is also a
structure class , but there may be implementation-dependent situations in which this is
not so, if the :type option to defstruct is used.
style warning n.acondition oftypestyle-warning .
subclass n.aclass that inherits from another class , called a superclass . (No class is
asubclass of itself.)
subexpression n.(of an expression ) an expression that is contained within the
expression . (In fact, the state of being a subexpression is not an attribute of the
subexpression , but really an attribute of the containing expression since the same
object can at once be a subexpression in one context, and not in another.)
subform n.(of a form ) an expression that is a subexpression of the form , and which
by virtue of its position in that form is also a form . \(f x) andx, but not exit, are
subforms of (return-from exit (f x)) ."
subrepertoire n.a subset of a repertoire .
subtype n.atype whose membership is the same as or a proper subset of the
membership of another type, called a supertype . (Every type is asubtype of itself.)
superclass n.aclass from which another class (called a subclass )inherits . (No class
is asuperclass of itself.) See subclass .
supertype n.atype whose membership is the same as or a proper superset of the
membership of another type, called a subtype . (Every type is asupertype of itself.) See
subtype .
26–56 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
supplied-p parameter n.aparameter which recieves its generalized boolean value
implicitly due to the presence or absence of an argument corresponding to another
parameter (such as an optional parameter or a rest parameter ). See Section 3.4.1
(Ordinary Lambda Lists).
symbol n.anobject oftypesymbol .
symbol macro n.asymbol that stands for another form . See the macro
symbol-macrolet .
synonym stream n.1. a stream oftypesynonym-stream , which is consequently a
stream that is an alias for another stream , which is the value of a dynamic variable
whose name is the synonym stream symbol of the synonym stream . See the function
make-synonym-stream . 2. (to a stream ) asynonym stream which has the stream as
thevalue of its synonym stream symbol . 3. (to a symbol ) asynonym stream which has
thesymbol as its synonym stream symbol .
synonym stream symbol n.(of a synonym stream ) the symbol which names the
dynamic variable which has as its value another stream for which the synonym stream
is an alias.
syntax type n.(of a character ) one of several classications, enumerated in Figure 2{
6, that are used for dispatch during parsing by the Lisp reader . See Section 2.1.4
(Character Syntax Types).
system class n.aclass that may be of typebuilt-in-class in a conforming
implementation and hence cannot be inherited by classes dened by conforming
programs .
system code n. code supplied by the implementation to implement this specication
(e.g., the denition of mapcar ) or generated automatically in support of this
specication ( e.g., during method combination); that is, code that is not programmer
code.
T
tn.1. a. the boolean representing true. b. the canonical generalized boolean
representing true. (Although any object other than nilis considered true as a
generalized boolean ,tis generally used when there is no special reason to prefer one
such object over another.) 2. the name of the type to which all objects belong|the
supertype of all types (including itself). 3. the name of the superclass of all classes
except itself.
tagn.1. a catch tag . 2. a go tag .
Glossary 26–57
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
tail n.(of a list) an object that is the same as either some cons which makes up that
listor the atom (if any) which terminates the list. \The empty list is a tail of every
proper list."
target n.1. (of a constructed stream ) aconstituent of the constructed stream . \The
target of a synonym stream is the value of its synonym stream symbol." 2. (of a
displaced array ) the array to which the displaced array is displaced. (In the case of a
chain of constructed streams ordisplaced arrays , the unqualied term \ target " always
refers to the immediate target of the rst item in the chain, not the immediate target
of the last item.)
terminal I/O n.thebidirectional stream that is the value of the variable
*terminal-io* .
terminating n.(of a macro character ) being such that, if it appears while parsing a
token, it terminates that token. See Section 2.2 (Reader Algorithm).
tertiary value n.(ofvalues resulting from the evaluation of a form ) the third value ,
if any, or else nilif there are fewer than three values .
throw v.to transfer control and values to a catch . See the special operator throw .
tilde n.thestandard character that is called \tilde" ( ~). See Figure 2{5.
time a representation of a point ( absolute time ) or an interval ( relative time ) on a
time line. See decoded time ,internal time , and universal time .
time zone n.arational multiple of 1/3600 between -24(inclusive) and 24(inclusive)
that represents a time zone as a number of hours oset from Greenwich Mean Time.
Time zone values increase with motion to the west, so Massachusetts, U.S.A. is in time
zone5, California, U.S.A. is time zone 8, and Moscow, Russia is time zone -3. (When
\daylight savings time" is separately represented as an argument orreturn value , the
time zone that accompanies it does not depend on whether daylight savings time is in
eect.)
token n.a textual representation for a number or a symbol . See Section 2.3
(Interpretation of Tokens).
top level form n.aform which is processed specially by compile-ﬁle for the purposes
of enabling compile time evaluation of that form .Top level forms include those forms
which are not subforms of any other form , and certain other cases. See Section 3.2.3.1
(Processing of Top Level Forms).
trace output n.theoutput stream which is the value of the dynamic variable
*trace-output* .
26–58 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
tree n.1. a binary recursive data structure made up of conses and atoms : the conses
are themselves also trees (sometimes called \subtrees" or \branches"), and the atoms
are terminal nodes (sometimes called leaves ). Typically, the leaves represent data
while the branches establish some relationship among that data. 2. in general, any
recursive data structure that has some notion of \branches" and leaves .
tree structure n.(of a tree1) the set of conses that make up the tree. Note that
while the car1bcomponent of each such cons is part of the tree structure , the objects
that are the cars 2of each cons in the treeare not themselves part of its tree structure
unless they are also conses .
true n.any object that is not false and that is used to represent the success of a
predicate test. See t1.
truename n.1. the canonical lename of a lein the le system . See Section 20.1.3
(Truenames). 2. a pathname representing a truename 1.
two-way stream n.astream oftypetwo-way-stream , which is a bidirectional
composite stream that receives its input from an associated input stream and sends its
output to an associated output stream .
type n.1. a set of objects , usually with common structure, behavior, or purpose.
(Note that the expression \ Xis of type Sa" naturally implies that \ Xis of type Sb" if
Sais asubtype ofSb.) 2. (immediately following the name of a type) asubtype of that
type. \The type vector is an array type."
type declaration n.adeclaration that asserts that every reference to a specied
binding within the scope of the declaration results in some object of the specied type.
type equivalent adj.(of two typesXandY) having the same elements ; that is,Xis
asubtype ofYandYis asubtype ofX.
type expand n.to fully expand a type specier , removing any references to derived
types . (Common Lisp provides no program interface to cause this to occur, but the
semantics of Common Lisp are such that every implementation must be able to do
this internally, and some situations involving type speciers are most easily described
in terms of a fully expanded type specier .)
type speciﬁer n.anexpression that denotes a type. \The symbol random-state , the
list(integer 3 5) , the list (and list (not null)) , and the class named standard-class
are type speciers."
U
unbound adj.not having an associated denotation in a binding . See bound .
Glossary 26–59
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
unbound variable n.aname that is syntactically plausible as the name of a variable
but which is not bound in the variable namespace .
undeﬁned function n.aname that is syntactically plausible as the name of a
function but which is not bound in the function namespace .
unintern v.t.(asymbol in a package ) to make the symbol not be present in that
package . (The symbol might continue to be accessible by inheritance.)
uninterned adj.(of a symbol ) not accessible in any package ;i.e., not interned 1.
universal time n. time , represented as a non-negative integer number of seconds.
Absolute universal time is measured as an oset from the beginning of the year 1900
(ignoring leap seconds ). See Section 25.1.4.2 (Universal Time).
unqualiﬁed method n.amethod with no qualiers .
unregistered package n.apackage object that is not present in the package
registry . An unregistered package has no name ;i.e., its name isnil. See the function
delete-package .
unsafe adj.(ofcode) not safe. (Note that, unless explicitly specied otherwise, if
a particular kind of error checking is guaranteed only in a safe context, the same
checking might or might not occur in that context if it were unsafe ; describing a
context as unsafe means that certain kinds of error checking are not reliably enabled
but does not guarantee that error checking is denitely disabled.)
unsafe call n.acallthat is not a safe call . For more detailed information, see Section
3.5.1.1 (Safe and Unsafe Calls).
upgrade v.t.(a declared type to an actual type) 1. (when creating an array )
to substitute an actual array element type for an expressed array element type
when choosing an appropriately specialized array representation. See the function
upgraded-array-element-type . 2. (when creating a complex ) to substitute an actual
complex part type for an expressed complex part type when choosing an appropriately
specialized complex representation. See the functionupgraded-complex-part-type .
upgraded array element type n.(of a type) atype that is a supertype of the type
and that is used instead of the type whenever the type is used as an array element type
for object creation or type discrimination. See Section 15.1.2.1 (Array Upgrading).
upgraded complex part type n.(of a type) atype that is a supertype of the type
and that is used instead of the type whenever the type is used as a complex part type for
object creation or type discrimination. See the functionupgraded-complex-part-type .
26–60 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
uppercase adj.(of a character ) being among standard characters corresponding to
the capital letters Athrough Z, or being some other implementation-dened character
that is dened by the implementation to be uppercase . See Section 13.1.4.3 (Characters
With Case).
use v.t.(apackageP1) to inherit theexternal symbols ofP1. (If a package P2uses
P1, the external symbols ofP1become internal symbols ofP2unless they are explicitly
exported .) \The package CL-USER uses the package CL."
use list n.(of a package ) a (possibly empty) listassociated with each package which
determines what other packages are currently being used by that package .
user n.an active entity, typically a human, that invokes or interacts with a program
at run time, but that is not necessarily a programmer .
V
valid array dimension n.axnum suitable for use as an array dimension .
Such a xnum must be greater than or equal to zero, and less than the value of
array-dimension-limit . When multiple array dimensions are to be used together to
specify a multi-dimensional array , there is also an implied constraint that the product
of all of the dimensions be less than the value ofarray-total-size-limit .
valid array index n.(of an array ) axnum suitable for use as one of possibly several
indices needed to name an element of the array according to a multi-dimensional
Cartesian coordinate system. Such a xnum must be greater than or equal to zero,
and must be less than the corresponding dimension 1of the array . (Unless otherwise
explicitly specied, the phrase \a listofvalid array indices " further implies that the
length of the listmust be the same as the rank of the array .) \For a 2by3array, valid
array indices for the rst dimension are 0and1, and valid array indices for the second
dimension are 0,1and2."
valid array row-major index n.(of an array , which might have any number of
dimensions 2) a single xnum suitable for use in naming any element of the array , by
viewing the array's storage as a linear series of elements in row-major order. Such a
xnum must be greater than or equal to zero, and less than the array total size of the
array .
valid ﬁll pointer n.(of an array ) axnum suitable for use as a ll pointer for the
array . Such a xnum must be greater than or equal to zero, and less than or equal to
thearray total size of the array .
valid logical pathname host n.astring that has been dened as the name of a
logical host . See the functionload-logical-pathname-translations .
Glossary 26–61
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
valid pathname device n.astring ,nil,:unspecific , or some other object dened
by the implementation to be a valid pathname device .
valid pathname directory n.astring , alistofstrings ,nil,:wild ,:unspecific , or
some other object dened by the implementation to be a valid directory component .
valid pathname host n.avalid physical pathname host or a valid logical pathname
host.
valid pathname name n.astring ,nil,:wild ,:unspecific , or some other object
dened by the implementation to be a valid pathname name .
valid pathname type n.astring ,nil,:wild ,:unspecific .
valid pathname version n.a non-negative integer , or one of :wild ,:newest ,
:unspecific , ornil. The symbols :oldest ,:previous , and:installed aresemi-
standard special version symbols.
valid physical pathname host n.any of a string , alistofstrings , or the symbol
:unspecific , that is recognized by the implementation as the name of a host.
valid sequence index n.(of a sequence ) an integer suitable for use to name an
element of the sequence . Such an integer must be greater than or equal to zero, and
must be less than the length of the sequence . (If the sequence is an array , the valid
sequence index is further constrained to be a xnum .)
value n.1. a. one of possibly several objects that are the result of an evaluation . b.
(in a situation where exactly one value is expected from the evaluation of a form ) the
primary value returned by the form . c. (of forms in an implicit progn ) one of possibly
several objects that result from the evaluation of the last form , ornilif there are no
forms . 2. an object associated with a name in a binding . 3. (of a symbol ) the value of
thedynamic variable named by that symbol. 4. an object associated with a keyin an
association list , aproperty list , or a hash table .
value cell n. Trad. (of a symbol ) The place which holds the value , if any, of the
dynamic variable named by that symbol , and which is accessed bysymbol-value . See
cell.
variable n.abinding in the \variable" namespace . See Section 3.1.2.1.1 (Symbols as
Forms).
vector n.a one-dimensional array .
vertical-bar n.thestandard character that is called \vertical bar" ( |). See Figure 2{5.
26–62 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
W
whitespace n.1. one or more characters that are either the graphic character #\Space
or else non-graphic characters such as #\Newline that only move the print position. 2.
a.n.thesyntax type of a character that is a token separator. For details, see Section
2.1.4.7 (Whitespace Characters). b. adj.(of a character ) having the whitespace 2a
syntax type 2. c.n.awhitespace 2bcharacter .
wild adj.1. (of a namestring ) using an implementation-dened syntax for naming
les, which might \match" any of possibly several possible lenames , and which can
therefore be used to refer to the aggregate of the les named by those lenames . 2.
(of a pathname ) a structured representation of a name which might \match" any of
possibly several pathnames , and which can therefore be used to refer to the aggregate
of the les named by those pathnames . The set of wild pathnames includes, but is
not restricted to, pathnames which have a component which is :wild , or which have
a directory component which contains :wild or:wild-inferors . See the function
wild-pathname-p .
write v.t.1. (a binding orslotor component) to change the value of the binding or
slot. 2. (an object to a stream ) to output a representation of the object to the stream .
writer n.afunction that writes 1avariable orslot.
Y
yield v.t.(values ) to produce the values as the result of evaluation . \The form (+ 2 3)
yields5."
Glossary 26–63
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
26–64 Programming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Programming Language—Common Lisp
A. Appendix
iiProgramming Language|Common Lisp
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
Appendix iii
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
A.1 Removed Language Features
A.1.1 Requirements for removed and deprecated features
For this standard, some features from the language described in Common Lisp: The Language
have been removed, and others have been deprecated (and will most likely not appear in future
Common Lisp standards). Which features were removed and which were deprecated was decided
on a case-by-case basis by the X3J13 committee.
Conforming implementations that wish to retain any removed features for compatibility must
assure that such compatibility does not interfere with the correct function of conforming programs .
For example, symbols corresponding to the names of removed functions may not appear in the the
COMMON-LISP package . (Note, however, that this specication has been devised in such a way that
there can be a package named LISP which can contain such symbols.)
Conforming implementations must implement all deprecated features. For a list of deprecated
features, see Section 1.8 (Deprecated Language Features).
A.1.2 Removed Types
The typestring-char was removed.
A.1.3 Removed Operators
The functions int-char ,char-bits ,char-font ,make-char ,char-bit ,set-char-bit ,string-char-p ,
andcommonp were removed.
The special operator compiler-let was removed.
A.1.4 Removed Argument Conventions
The font argument to digit-char was removed. The bitsand font arguments to code-char were
removed.
A.1.5 Removed Variables
The variables char-font-limit ,char-bits-limit ,char-control-bit ,char-meta-bit ,char-super-bit ,
char-hyper-bit , and*break-on-warnings* were removed.
A.1.6 Removed Reader Syntax
The \#,"reader macro instandard syntax was removed.
A.1.7 Packages No Longer Required
The packages LISP,USER, andSYSTEM are no longer required. It is valid for packages with one or
more of these names to be provided by a conforming implementation as extensions.
Appendix A–1
Version 15.17R, X3J13/94-101R.
Fri 12-Aug-1994 6:35pm EDT
A–2 Programming Language|Common Lisp

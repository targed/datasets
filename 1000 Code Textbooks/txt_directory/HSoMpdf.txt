The Haskell School of Music
— From Signals to Symphonies —
Paul Hudak
Yale University
Department of Computer Science
Version 2.4 (February 22, 2012)
i
The Haskell School of Music
— From Signals to Symphonies —
Paul Hudak
Yale University
Department of Computer Science
New Haven, CT, USA
Version 2.4 (February 22, 2012)
Copyright c/circlecopyrtPaul Hudak
January 2011
All rights reserved. No part of this publication may be reproduced or
distributed in any form or by any means, or stored in a data base or
retrieval system, without the prior written permission of the author.
Cover image: Euterpe, the Greek Muse of Music
(attribution unknown)

Contents
Preface xiv
1 Overview of Computer Music, Euterpea, and Haskell 1
1.1 The Note vs. Signal Dichotomy ................. 2
1.2 Basic Principles of Programming ................ 3
1.3 Computation by Calculation ................... 4
1.4 Expressions and Values ..................... 8
1.5 Types ............................... 1 0
1.6 Function Types and Type Signatures .............. 1 1
1.7 Abstraction, Abstraction, Abstraction ............. 1 3
1.7.1 Naming .......................... 1 3
1.7.2 Functional Abstraction .................. 1 6
1.7.3 Data Abstraction ..................... 1 9
1.8 Haskell Equality vs. Euterpean Equality ............ 2 2
1.9 Code Reuse and Modularity ................... 2 3
1.10 [Advanced] Programming with Numbers ............ 2 4
2 Simple Music 28
2.1 Preliminaries ........................... 2 8
2.2 Notes, Music, and Polymorphism ................ 3 0
2.3 Convenient Auxiliary Functions ................. 3 3
2.3.1 A Simple Example .................... 3 5
2.4 Absolute Pitches ......................... 3 9
ii
CONTENTS iii
3 Polymorphic & Higher-Order Functions 43
3.1 Polymorphic Types ........................ 4 4
3.2 Abstraction Over Recursive Deﬁnitions ............. 4 5
3.2.1 Map is Polymorphic ................... 4 7
3.2.2 Using map ........................ 4 8
3.3 Append .............................. 4 9
3.3.1 [Advanced] The Eﬃciency and Fixity of Append ... 5 0
3.4 Fold ................................ 5 1
3.4.1 Haskell’s Folds ...................... 5 3
3.4.2 [Advanced] Why Two Folds? .............. 5 4
3.4.3 Fold for Non-empty Lists ................ 5 5
3.5 [Advanced] A Final Example: Reverse ............. 5 6
3.6 Currying .............................. 5 7
3.6.1 Currying Simpliﬁcation ................. 5 9
3.6.2 [Advanced] Simpliﬁcation of reverse .......... 6 0
3.7 Errors ............................... 6 1
4 A Musical Interlude 64
4.1 Modules .............................. 6 4
4.2 Transcribing an Existing Score ................. 6 5
4.2.1 Auxiliary Functions ................... 6 7
4.2.2 Bass Line ......................... 6 8
4.2.3 Main Voice ........................ 6 9
4.2.4 Putting It All Together ................. 6 9
4.3 Simple Algorithmic Composition ................ 7 1
5 Syntactic Magic 72
5.1 Sections .............................. 7 2
5.2 Anonymous Functions ...................... 7 4
5.3 List Comprehensions ....................... 7 5
5.3.1 Arithmetic Sequences .................. 7 7
5.4 Function Composition ...................... 7 8
CONTENTS iv
5.5 Higher-Order Thinking ...................... 7 9
5.6 Inﬁx Function Application .................... 8 0
6 More Music 82
6.1 Delay and Repeat ......................... 8 2
6.2 Inversion and Retrograde .................... 8 3
6.3 Polyrhythms ........................... 8 4
6.4 Symbolic Meter Changes ..................... 8 6
6.5 Computing Duration ....................... 8 6
6.6 Super-retrograde ......................... 8 7
6.7 Truncating Parallel Composition ................ 8 8
6.8 Trills ................................ 8 9
6.9 Grace Notes ............................ 9 0
6.10 Percussion ............................. 9 1
6.11 A Map for Music ......................... 9 3
6.12 A Fold for Music ......................... 9 4
6.13 Crazy Recursion ......................... 9 5
7 Qualiﬁed Types and Type Classes 98
7.1 Motivation ............................ 9 8
7.2 Equality ..............................1 0 0
7.3 Deﬁning Your Own Type Classes ................1 0 2
7.4 Inheritance ............................1 0 6
7.5 Haskell’s Standard Type Classes ................1 0 7
7.5.1 The NumClass......................1 0 8
7.5.2 The ShowClass.....................1 1 1
7.6 Derived Instances .........................1 1 2
7.7 Reasoning With Type Classes ..................1 1 5
8 Interpretation and Performance 118
8.1 Abstract Performance ......................1 1 8
8.2 Players ...............................1 2 4
CONTENTS v
8.2.1 Example of Player Construction ............1 2 6
8.2.2 Deriving New Players From Old Ones .........1 2 8
8.2.3 A Fancy Player ......................1 2 9
8.3 Putting it all Together ......................1 2 9
9 Self-Similar Music 133
9.1 Self-Similar Melody ........................1 3 3
9.1.1 Sample Compositions ..................1 3 6
9.2 Self-Similar Harmony .......................1 3 7
9.3 Other Self-Similar Structures ..................1 3 8
10 Proof by Induction 141
10.1 Induction and Recursion .....................1 4 1
10.2 Examples of List Induction ...................1 4 2
10.3 Proving Function Equivalences .................1 4 4
10.3.1 [Advanced] Reverse ....................1 4 5
10.4 Useful Properties on Lists ....................1 4 7
10.4.1 [Advanced] Function Strictness .............1 5 0
10.5 Induction on the Music Data Type ...............1 5 1
10.5.1 The Need for Musical Equivalence ...........1 5 6
10.6 [Advanced] Induction on Other Data Types ..........1 5 6
10.6.1 A More Eﬃcient Exponentiation Function .......1 5 8
11 An Algebra of Music 163
11.1 Musical Equivalance .......................1 6 3
11.2 Some Simple Axioms .......................1 6 5
11.3 The Axiom Set ..........................1 6 8
11.4 Soundness and Completeness ..................1 6 9
12 Musical L-Systems 170
12.1 Generative Grammars ......................1 7 0
12.2 A Simple Implementation ....................1 7 1
12.3 Grammars in Haskell .......................1 7 3
CONTENTS vi
12.4 An L-System Grammar for Music ................1 7 5
12.5 Examples .............................1 7 6
13 Random Numbers ... and Markov Chains 179
13.1 Random Numbers ........................1 7 9
13.2 Probability Distributions .....................1 8 2
13.2.1 Random Melodies and Random Walks .........1 8 6
13.3 Markov Chains ..........................1 8 8
13.3.1 Training Data .......................1 8 9
14 From Performance to Midi 192
14.1 An Introduction to Midi .....................1 9 2
14.1.1 General Midi .......................1 9 3
14.1.2 Channels and Patch Maps ................1 9 4
14.1.3 Standard Midi Files ...................1 9 6
14.2 Converting a Performance into Midi ..............1 9 8
14.3 Putting It All Together .....................2 0 1
15 Basic Input/Output 202
15.1 IO in Haskell ...........................2 0 2
15.2doSyntax.............................2 0 4
15.3 Actions are Just Values .....................2 0 5
15.4 Reading and Writing Midi Files .................2 0 7
16 Musical User Interface 208
16.1 Signals ...............................2 0 9
16.1.1 Numeric Signals .....................2 1 0
16.1.2 Time ............................2 1 1
16.1.3 Musical Signals ......................2 1 2
16.1.4 Useful Signal Operators .................2 1 3
16.1.5 Stateful Signals ......................2 1 3
16.2 Events and Reactivity ......................2 1 4
16.2.1 Manipulating Event Streams ..............2 1 4
CONTENTS vii
16.2.2 Turning Signals into Events ...............2 1 5
16.2.3 Signal Samplers ......................2 1 6
16.2.4 Switches and Reactivity .................2 1 6
16.3 The UI Level ...........................2 1 7
16.3.1 Input Widgets ......................2 1 7
16.3.2 UI Transformers .....................2 2 0
16.3.3 MIDI Input and Output .................2 2 1
16.3.4 Midi Device IDs .....................2 2 2
16.3.5 Timer Widgets ......................2 2 4
16.4 Putting It All Together .....................2 2 5
16.5 Musical Examples ........................2 2 5
16.5.1 Chord Builder ......................2 2 5
16.5.2 Bifurcate Me, Baby! ...................2 2 7
16.5.3 MIDI Echo Eﬀect .....................2 2 9
17 Sound and Signals 231
17.1 The Nature of Sound .......................2 3 1
17.1.1 Frequency and Period ..................2 3 4
17.1.2 Amplitude and Loudness ................2 3 5
17.1.3 Frequency Spectrum ...................2 3 9
17.2 Digital Audio ...........................2 4 1
17.2.1 From Continuous to Discrete ..............2 4 3
17.2.2 Fixed-Waveform Table-Lookup Synthesis .......2 4 5
17.2.3 Aliasing ..........................2 4 6
17.2.4 Quantization Error ....................2 4 9
17.2.5 Dynamic Range ......................2 5 1
18 Euterpea’s Signal Functions 253
18.1 Signals and Signal Functions ..................2 5 4
18.1.1 The Type of a Signal Function .............2 5 6
18.1.2 Four Useful Functions ..................2 5 8
18.1.3 Some Simple Examples .................2 5 9
CONTENTS viii
18.2 Generating Sound ........................2 6 4
18.3 Instruments ............................2 6 6
18.3.1 Turning a Signal Function into an Instruement ....2 6 6
18.3.2 Envelopes .........................2 6 9
19 Spectrum Analysis 273
19.1 Fourier’s Theorem ........................2 7 3
19.1.1 The Fourier Transform ..................2 7 5
19.1.2 Examples .........................2 7 6
19.2 The Discrete Fourier Transform .................2 7 7
19.2.1 Interpreting the Frequency Spectrum ..........2 8 0
19.2.2 Amplitude and Power of Spectrum ...........2 8 2
19.2.3 A Haskell Implementation of the DFT .........2 8 4
19.3 The Fast Fourier Transform ...................2 9 0
19.4 Further Pragmatics ........................2 9 1
19.5 References .............................2 9 2
20 Additive Synthesis and Amplitude Modulation 294
20.1 Preliminaries ...........................2 9 4
20.2 A Bell Sound ...........................2 9 5
20.3 Amplitude Modulation ......................2 9 8
20.3.1 AM Sound Synthesis ...................2 9 9
20.4 What do Tremolo and AM Radio Have in Common? .....3 0 0
A The PreludeList Module 302
A.1 The PreludeList Module .....................3 0 3
A.2 Simple List Selector Functions .................3 0 3
A.3 Index-Based Selector Functions .................3 0 4
A.4 Predicate-Based Selector Functions ...............3 0 6
A.5 Fold-like Functions ........................3 0 6
A.6 List Generators ..........................3 0 8
A.7 String-Based Functions ......................3 0 8
CONTENTS ix
A.8 Boolean List Functions ......................3 0 9
A.9 List Membership Functions ...................3 1 0
A.10 Arithmetic on Lists ........................3 1 0
A.11 List Combining Functions ....................3 1 1
B Haskell’s Standard Type Classes 313
B.1 The Ordered Class ........................3 1 3
B.2 The Enumeration Class .....................3 1 4
B.3 The Bounded Class ........................3 1 5
B.4 The Show Class ..........................3 1 6
B.5 The Read Class ..........................3 1 9
B.6 The Index Class .........................3 2 2
B.7 The Numeric Classes .......................3 2 3
C Built-in Types Are Not Special 325
D Pattern-Matching Details 328
List of Figures
1.1 Polyphonic vs. Contrapuntal Interpretation .......... 2 3
2.1 General MIDI Instrument Names ................ 3 4
2.2 Convenient Note Names ..................... 3 6
2.3 Convenient Duration and Rest Names ............. 3 7
2.4 Converting Pitch Classes to Integers .............. 4 1
4.1 Excerpt from Chick Corea’s Child Song No. 6 ......... 6 6
4.2 Bars 7-28 ............................. 7 0
5.1 Gluing Two Functions Together ................. 7 8
6.1 Nested Polyrhythms (top: pr1; bottom: pr2)......... 8 5
6.2 Trills in Stars and Stripes Forever ............... 9 0
6.3 General MIDI Percussion Names ................ 9 2
7.1 Common Type Classes and Their Instances ..........1 0 8
7.2 Numeric Class Hierarchy .....................1 1 0
7.3 Standard Numeric Types ....................1 1 1
7.4 Euterpea’s Data Types with Deriving Clauses .........1 1 4
8.1 An abstract perform function ..................1 2 1
8.2 A more eﬃcient perform function ................1 2 3
8.3 Phrase Attributes .........................1 2 5
8.4 Deﬁnition of default player defPlayer ..............1 2 7
x
LIST OF FIGURES xi
8.5 Deﬁnition of Player fancyPlayer .................1 3 2
9.1 An Example of Self-Similar Music ...............1 3 4
10.1 Proof that fxn∗fxn=f(x∗x)n..............1 6 1
13.1 Various Probability Density Functions .............1 8 3
14.1 Partial Deﬁnition of the MidiData Type ...........1 9 7
16.1 Several Simple MUIs .......................2 1 9
16.2 A Chord Builder MUI ......................2 2 6
17.1 A Sine Wave ...........................2 3 2
17.2 RMS Amplitude for Diﬀerent Signals ..............2 3 6
17.3 Fletcher-Munson Equal Loudness Contour ...........2 3 8
17.4 Spectral Plots of Diﬀerent Signals ................2 4 0
17.5 Time-Varying Spectral Plots ...................2 4 2
17.6 Choice of Sampling Rate .....................2 4 4
17.7 Aliasing 1 .............................2 4 7
17.8 Aliasing 2 .............................2 4 8
17.9 A Properly Sampled Signal ...................2 5 0
17.10Block Diagram of Typical Digital Audio System ........2 5 0
18.1 Eutperea’s Oscillators ......................2 6 0
18.2 Table Generating Functions ...................2 6 2
18.3 A Simple Melody .........................2 6 9
18.4 A Complete Example of a Signal-Function Based Instrument 270
18.5 Envelopes .............................2 7 1
19.1 Examples of Fourier Transforms .................2 7 8
19.2 Generating a Square Wave from Odd Harmonics .......2 7 9
19.3 Complex and Polar Coordinates .................2 8 3
19.4 Helper Code for Pretty-Printing DFT Results .........2 8 6
19.5 A Real-Time Display of FFT Results ..............2 9 2
LIST OF FIGURES xii
20.1 Working With Lists of Signal Sources .............2 9 5
20.2 A Bell Instrument ........................2 9 6
20.3 A More Sophisticated Bell Instrument .............2 9 7
B.1 Standard Numeric Classes ....................3 2 4
List of Tables
10.1 Some Useful Properties of mapandfold.............1 4 8
10.2 Useful Properties of Other Functions Over Lists ........1 4 9
13.1 Second-Order Markov Chain ..................1 8 9
14.1 General Midi Instrument Families ................1 9 4
16.1 Signal Samplers ..........................2 1 6
16.2 MUI Input Widgets .......................2 1 7
16.3 MUI Layout Widget Transformers ...............2 2 0
xiii
Preface
In the year 2000 I wrote a book called The Haskell School of Expression
– Learning Functional Programming through Multimedia [Hud00]. In that
book I used graphics, animation, music, and robotics as a way to motivatelearning how to program, and speciﬁcally how to learn functional program-
mingusing Haskell, a purely functional programming language. Haskell
[P
+03]isquiteabitdiﬀerentfromconventional imperativeorobject-oriented
languages suchasC,C++,Java, C#,andsoon. Ittakes adiﬀerentmind-setto program in such a language, and appeals to the mathematically inclinedand to those who seek purity and elegance in their programs. AlthoughHaskell was designed over twenty years ago, it has only recently begun to
catch on in a signiﬁcant way, not just because of its purity and elegance,
but because with it you can solve real-world problems quickly and eﬃciently,and with great economy of code.
I have also had a long, informal, yet passionate interest in music, being
an amateur jazz pianist and having played in several bands over the years.About ﬁfteen years ago, in an eﬀort to combine work with play, I and mystudents wrote a Haskell library called Haskore for expressing high-level
computer music concepts in a purely functional way [ HMGW96 ,Hud96,
Hud03]. Indeed, three of the chapters in The Haskell School of Expression
summarize the basic ideas of this work. Soon after that, with the help ofanother student, Matt Zamec, I designed a Haskell library called HasSound
that was, essentially, a Haskell interface to csound[Ver86] for doing sound
synthesis and instrument design.
Thus, when I recently became responsible for the Music Track in the
newComputing and the Arts major at Yale, and became responsible for
teaching not one, but two computer music courses in the new curriculum, itwas natural to base the course material on Haskell. This current book is arewrite of The Haskell School of Expression with a focus on computer music,
based on, and greatly improving upon, the ideas in Haskore and HasSound.
xiv
PREFACE xv
The new Haskell library that incorporates all of this is called Euterpea .
Haskell was named after the logician Haskell B. Curry who, along with
Alonzo Church, helped establish the theoretical foundations of functionalprogrammingin the 1940’s, whendigital computerswere mostlyjusta gleamin researchers’ eyes. A curious historical fact is that Haskell Curry’s father,Samuel Silas Curry, helped found and direct a school in Boston called theSchool of Expression . (Thisschooleventually evolved intowhatisnow Curry
College.) Since pure functional programming is centered around the notion
of anexpression , I thought that The Haskell School of Expression would be
a good title for my ﬁrst book. And it was thus quite natural to choose The
Haskell School of Music for my second!
How To Read This Book
As mentioned earlier, there is a certain mind-set, a certain viewpoint of the
world, and a certain approach to problem solving that collectively work bestwhen programming in Haskell (this is true for any programming paradigm).If you teach only Haskell language details to a C programmer, he or she islikely to write ugly, incomprehensible functional programs. But if you teachhow to think diﬀerently, how to see problems in a diﬀerent light, functionalsolutions will come easily, and elegant Haskell programs will result. AsSamuel Silas Curry once said:
All expression comes from within outward , from the center to
the surface, from a hidden source to outward manifestation. Thestudy of expression as a natural process brings you into contactwith cause and makes you feel the source of reality.
What is especially beautiful about this quote is that music is also a form
of expression, although Curry was more likely talking about writing and
speech. In addition, as has been noted by many, music has many ties tomathematics. So for me, combining the elegant mathematical nature ofHaskell with that of music is as natural as singing a nursery tune.
Using a high-level language to express musical ideas is, of course, not
new. But Haskell is unique in its insistence on purity (no side eﬀects), andthis alone makes it particularly suitable for expressing musical ideas. Byfocusingon whata musical entity is rather than on howto create it, we allow
musical ideas to take their natural form as Haskell expressions. Haskell’smany abstraction mechanisms allow us to write computer music programs
PREFACE xvi
that are elegant, concise, yet powerful. We will consistently attempt to let
the music expressitself as naturally as possible, without encodingit in termsof irrelevant language details.
Ofcourse, myultimate goal isnot justto teach computer musicconcepts.
Along the way you will also learn Haskell. There is no limit to what onemight wish to do with computer music, and therefore the better you areat programming, the more success you will have. This is why I think thatmany languages designed speciﬁcally for computer music—although fun to
work with, easy to use, and cute in concept—face the danger of being too
limited in expressiveness.
You do not need to know much, if any, music theory to read this book,
and you do not need to play an instrument. Of course, the more you knowabout music, the more you will be able to apply the concepts learned in thistext in musically creative ways.
My general approach to introducing computer music concepts is to ﬁrst
provide an intuitive explanation, then a mathematically rigorous deﬁnition,and ﬁnally fully executable Haskell code. In the process I introduce Haskellfeatures as they are needed, rather than all at once. I believe that thisinterleaving of concepts and applications makes the material easier to digest.
Anothercharacteristic ofmyapproachisthatIdonothideanydetails—I
want Euterpea to be as transparent as possible! There are no magical built-in operations, no special computer music commands or values. This worksout well for several reasons. First, there is in fact nothing ugly or diﬃcultto hide—so why hide anything at all? Second, by reading the code, you willbetter and more quickly understand Haskell. Finally, by stepping throughthe design process with me, you may decide that you prefer a diﬀerentapproach—there is, after all, no One True Way to express computer musicideas. I expect that this process will position you well to write rich, creativemusical applications on your own.
I encourage the seasoned programmer having experience only with con-
ventional imperative and/or object-oriented languages to read this text with
an open mind. Many things will be diﬀerent, and will likely feel awkward.
There will be a tendency to rely on old habits when writing new programs,and to ignore suggestions about how to approach things diﬀerently. If youcan manage to resist those tendencies I am conﬁdent that you will have anenjoyable learning experience. Those who succeed in this process often ﬁndthat many ideas about functional programming can be applied to impera-tive and object-oriented languages as well, and that their imperative coding
PREFACE xvii
style changes for the better.
I also ask the experienced programmer to be patient while in the earlier
chapters I explain things like “syntax,” “operator precedence,” etc., since itis my goal that this text should be readable by someone having only modestprior programming experience. With patience the more advanced ideas willappear soon enough.
If you are a novice programmer, I suggest taking your time with the
book; work through the exercises, and don’t rush things. If, however, you
don’t fully grasp an idea, feel free to move on, but try to re-read diﬃcult
material at a later time when you have seen more examples of the conceptsin action. For the most part this is a “show by example” textbook, andyou should try to execute as many of the programs in this text as you can,as well as every program that you write. Learn-by-doing is the corollary toshow-by-example.
Finally, Inotethatsomesection titles areprefacedwiththeparenthetical
phrase, “ [Advanced] ”. These sections may be skipped upon ﬁrst reading,
especially if the focus is on learning computer music concepts, as opposedto programming concepts.
Haskell Implementations
There are several good implementations of Haskell, all available free onthe Internet through the Haskell users’ website at http://haskell.org .
One that I especially recommend is GHC, an easy-to-use and easy-to-install
Haskell compiler and interpreter (see http://haskell.org/ghc ). GHC
runs on a variety of platforms, including PC’s (Windows 7, XP, and Vista),various ﬂavors of Unix (Linux, FreeBSD, etc.), and Mac OS X. Thepreferredway to install GHC is through the Haskell Platform
(http://hackage.haskell.org/platform/ ). Any text editor can be used
to create source ﬁles, but I prefer to use emacs (seehttp://www.gnu.org/software/emacs ), along with its Haskell mode (see
http://projects.haskell.org/haskellmode-emacs/ ). TheentireEuterpea
library is available on the community Haskell server, including all of thesource code from this textbook. Instructions on how to install Euterpeacan be found at http://haskell.cs.yale.edu . Feel free to email me at
mailto:paul.hudak@yale.edu with any comments, suggestions, or ques-
tions.
PREFACE xviii
Acknowledgements
I wish to thank my funding agencies—the National Science Foundation, the
Defense Advanced Research Projects Agency, and Microsoft Research—fortheir generous support of research that contributed to the foundations ofEuterpea. Yale University has provided me a stimulating and ﬂexible envi-ronment to pursue my dreams for almost thirty years, and I am especiallythankful for its recent support of the Computing and the Arts initiative.
Tom Makucevich, a talented computer music practitioner and composer
in New Haven, was the original motivator, and ﬁrst user, of Haskore, which
preceded Euterpea. Watching him toil endlessly with low-level csound pro-
grams was simply too much for me to bear! Several undergraduate studentsat Yale contributed to the original design and implementation of Haskore. Iwould like to thank in particular the contributions of Syam Gadde and BoWhong, who co-authored the original paper on Haskore. Additionally, MattZamec helped me greatly in the creation of HasSound.
I wish to thank my more recent graduate students, in particular Hai
(Paul) Liu, Eric Cheng, Donya Quick, and Daniel Winograd-Cort for theirhelp in writing much of the code that constitutes the current Euterpea li-brary. In addition, many students in my computer music classes at Yaleprovided valuable feedback through earlier drafts of the manuscript.
Finally, I wish to thank my wife, Cathy Van Dyke, my best friend and
ardent supporter, whose love, patience, and understanding have helped meget through some bad times, and enjoy the good.
Happy Haskell Music Making!Paul Hudak
New HavenJanuary 2012
Chapter 1
Overview of Computer
Music, Euterpea, and Haskell
Computers are everywhere. And so is music! Although some might think
of the two as being at best distant relatives, in fact they share many deepproperties. Music comes from the soul, and is inspired by the heart, yet ithas the mathematical rigor of computers. Computers have mathematicalrigor of course, yet the most creative ideas in mathematics and computerscience come from the soul, just like music. Both disciplines demand bothleft-brain and right-brain skills. It a lways surprises me how many computer
scientists and mathematicians have a serious interest in music. It seems
that those with a strong aﬃnity or acuity in one of these disciplines is oftenstrong in the other as well.
It is quite natural then to consider how the two might interact. In
fact there is a long history of interactions between music and mathematics,dating backto theGreeks’construction ofmusical scales basedon arithmeticrelationships, and including many classical composers use of mathematicalstructures, the formal harmonic analysis of music, and many modern musiccomposition techniques. Advanced music theory uses ideas from diversebranches of mathematics such as number theory, abstract algebra, topology,category theory, calculus, and so on.
There is also a long history of eﬀorts to combine computers and music.
Most consumer electronics today are digital, as are most forms of audio pro-cessing and recording. But in addition, digital musical instruments providenew modes of expression, notation software and sequencers have becomestandard tools for the working musician, and those with the most computer
1
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 2
science savvy use computers to explore new modes of composition, transfor-
mation, performance, and analysis.
This textbook explores the fundamentals of computer music using a
language-centric approach. In particular, the functional programming lan-guageHaskellis used to express all of the computer music concepts. Thus
a by-product of learning computer music concepts will be learning how toprogram in Haskell. The core musical ideas are collected into a Haskell li-brary called Euterpea . The name “Euterpea” is derived from “Euterpe,”
who was one of the nine Greek muses, or goddesses of the arts, speciﬁcally
the muse of music. A hypothetical picture of Euterpe graces the cover ofthis textbook.
1.1 The Note vs. Signal Dichotomy
The ﬁeld of computer music has grown astronomically over the past severaldecades, and the material can be structured and organized along several
dimensions. A dimension that proves particulary useful with respect to a
programminglanguageisonethatseparates high-level musicalconcernsfrom
low-level musical concerns. Since a “high-level” programming language—
namely Haskell—is used to program at both of these musical levels, to avoidconfusion the terms note level andsignal level will be used in the musical
dimension.
At thenote level ,anote(i.e. pitch and duration) is the lowest musical
entity that is considered, and everything else is built up from there. At thislevel, in addition to conventional representations of music, one can studyinteresting aspects of so-called algorithmic composition , including the use
of fractals, grammar-based systems, stochastic processes, and so on. Fromthis basis one can also study the harmonic and rhythmic analysis of mu-
sic, although that is not currently an emphasis in this textbook. Haskell
facilitates programming at this level through its powerful data abstractionfacilities, higher-order functions, and declarative semantics.
In contrast, at the signal level the focus is on the actual sound generated
in a computer music application, and thus a signalis the lowest entity that
is considered. Sound is concretely represented in a digital computer by adiscrete sampling of the continuous audio signal, at a high enough rate thathuman ears cannot distinguish the discrete from the continuous, usually44,100 samples per second (the standard sampling rate used for CDs, mp3ﬁles, and so on). But in Euterpea, these details are hidden: signals are
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 3
treated abstractly as continuous quantities. This greatly eases the burden of
programming with sequences of discrete values. At the signal level, one canstudy sound synthesis techniques (to simulate the sound of a conventionalinstrument, say, or something completely artiﬁcial), audio processing (e.g.determining the frequency spectrum of a signal), and special eﬀects (reverb,panning, distortion, and so on).
Suppose for a moment that one is playing music using a metronome set
at 96, which corresponds to 96 beats per minute. That means that one beat
takes
60/96= 0.625 seconds. At a stereo sampling rate of 44,100 samples per
second, that in turn translates into 2 ×0.625×44,100 = 55,125 samples, and
each sample typically occupies several bytes of computer memory. This istypical of the minimum memory requirements of a computation at the signallevel. In contrast, at the note level, one only needs some kind of operatoror data structure that says “play this note,” which requires a total of onlya small handful of bytes. This dramatic diﬀerence highlights one of the keycomputational diﬀerences between programming at the note level versus thesignal level.
Of course, many computer music applications involve both the note level
andthe signal level, and indeed there needs to be a mechanism to mediate
between the two. Although such mediation can take many forms, it is for
the most part straightforward. Which is another reason why the distinctionbetween the note level and the signal level is so natural.
This textbook begins with a treatment of the note level (Chapters 1-16)
and follows with a treatment of the signal level (Chapters 17-20). If the
reader is interested only in the signal level, one could skip Chapters 8-16.
1.2 Basic Principles of Programming
Programming, in its broadest sense, is problem solving . It begins by rec-
ognizing problems that can and should be solved using a digital computer.Thus the ﬁrst step in programming is answering the question, “What prob-l e ma mIt r y i n gt os o l v e ? ”
Once the problem is understood, a solution must be found. This may
not be easy, of course, and in fact one may discover several solutions, so away to measure success is needed. There are various dimensions in which todo this, including correctness (“Will I get the right answer?”) and eﬃciency(“Will itrunfastenough, orusetoomuchmemory?”). Butthedistinction ofwhich solution is better is not always clear, since the number of dimensions
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 4
can be large, and programs will often excel in one dimension and do poorly
in others. For example, there may be one solution that is fastest, one thatuses the least amount of memory, and one that is easiest to understand.Deciding which to choose can be diﬃcult, and is one of the more interestingchallenges in programming.
The last measure of success mentioned above—clarity of a program—
is somewhat elusive: diﬃcult to quantify and measure. Nevertheless, inlarge software systems clarity is an especially important goal, since such
systems are worked on by many people over long periods of time, and evolve
considerablyastheymature. Havingeasy-to-understandcodemakesitmucheasier to modify.
In the area of computer music, there is another reason why clarity is
important: namely, that the code often represents the author’s thoughtprocess, musical intent, and artistic choices. A conventional musical scoredoes not say much about what the composer thought as she wrote the music,but a program often does. So when you write your programs, write them forothers to see, and aim for elegance and beauty, just like the musical resultthat you desire.
Programming is itself a creative process. Sometimes programming so-
lutions (or artistic creations) come to mind all at once, with little eﬀort.
More often, however, they are discovered only after lots of hard work! Onemay write a program, modify it, throw it away and start over, give up, startagain, and so on. It’s important to realize that such hard work and rework-ing of programs is the norm, and in fact you are encouraged to get into thehabit of doing so. Don’t always be satisﬁed with your ﬁrst solution, andalways be prepared to go back and change or even throw away those partsof your program that you’re not happy with.
1.3 Computation by Calculation
It’s helpful when learning a new programming language to have a goodgrasp of how programs in that language are executed—in other words, anunderstandingof whataprogram means. Theexecution of Haskell programs
is perhaps best understood as computation by calculation . Programs in
Haskell can be viewed as functions whose input is that of the problem being
solved, andwhoseoutputisthedesiredresult—andthebehavioroffunctionscan be eﬀectively understood as computation by calculation.
An example involving numbers might help to demonstrate these ideas.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 5
Numbersareusedinmanyapplications, andcomputermusicisnoexception.
For example, integers might be used to represent pitch, and ﬂoating-pointnumbers might be used to perform calculations involving frequency or am-plitude.
Suppose onne wishes to perform an arithmetic calculation such as 3 ×
(9+5). In Haskell this would be written as 3 ∗(9+5), since most standard
computer keyboards and text editors do not recognize the special symbol ×.
The result can be calculated as follows:
3∗(9+5)
⇒3∗14
⇒42
It turns out that this is not the only way to compute the result, as evidenced
by this alternative calculation:
1
3∗(9+5)
⇒3∗9+3∗5
⇒27+3∗5
⇒27+15
⇒42
Even though this calculation takes two extra steps, it at least gives the
same, correct answer. Indeed, an important property of each and every
program written in Haskell is that it will always yield the same answerwhen given the same inputs, regardless of the order chosen to perform thecalculations.
2This is precisely the mathematical deﬁnition of a function:
for the same inputs, it always yields the same output.
On the other hand, the ﬁrst calculation above required fewer steps than
the second, and thus it is said to be more eﬃcient. Eﬃciency in both space
(amount of memory used) and time (number of steps executed) is importantwhen searching for solutions to problems. Of course, if the computationreturns the wrong answer, eﬃciency is a moot point. In general it is bestto search ﬁrst for an elegant (and correct!) solution to a problem, and laterreﬁne it for better performance. This strategy is sometimes summarized as,
“Get it right ﬁrst!”
The above calculations are fairly trivial, but much more sophisticated
computations will be introduced soon enough. For starters—and to intro-
1This assumes that multiplication distributes overaddition in thenumbersystem being
used, a point that will be returned to later in the text.
2Thisistrueaslongasanon-terminatingsequenceofcalculations isnotchosen, another
issue that will be addressed later.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 6
duce the idea of a Haskell function—the arithmetic operations performed in
the previous example can be generalized by deﬁning a function to perform
them for any numbers x,y,a n dz:
simple x y z =x∗(y+z)
This equation deﬁnes simpleas a function of three arguments ,x,y,a n dz.
In mathematical notation this deﬁnition might be written diﬀerently, suchas one of the following:
simple(x,y,z)=x×(y+z)
simple(x,y,z)=x·(y+z)
simple(x,y,z)=x(y+z)
In any case, it should be clear that “ simple3 9 5” is the same as “3 ∗(9+5).”
In fact the proper way to calculate the result is:
simple395
⇒3∗(9+5)
⇒3∗14
⇒42
The ﬁrst step in this calculation is an example of unfolding a function
deﬁnition: 3 is substituted for x,9f o ry,a n d5f o r zon the right-hand side
of the deﬁnition of simple. This is an entirely mechanical process, not unlike
what the computer actually does to execute the program.
simple395i ss a i dt o evaluate
to 42. To express the fact that an
expression eevaluates (via zero, one, or possibly many more steps) to the
valuev,o n ew r i t e s e=⇒v(this arrow is longer than that used earlier). So
one can say directly, for example, that simple395=⇒42, which should be
read “simple3 9 5 evaluates to 42.”
Withsimplenow suitably deﬁned, one can repeat the sequence of arith-
metic calculations as often as one likes, using diﬀerent values for the argu-
ments to simple. For example, simple432=⇒20.
One can also use calculation to prove properties about programs. For
example, it should be clear that for any a,b,a n dc,simple a b c should
yield the same result as simple a c b . For a proof of this, one calculates
symbolically ; that is, using the symbols a,b,a n dcrather than concrete
n u m b e r ss u c ha s3 ,5 ,a n d9 :
simple a b c
⇒a∗(b+c)
⇒a∗(c+b)
⇒simple a c b
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 7
Note that the same notation is used for these symbolic steps as for concrete
ones. In particular, the arrow in the notation reﬂects the direction of formalreasoning, and nothing more. In general, if e
1⇒e2, then it’s also true that
e2⇒e1.
These symbolic steps are also referred to as as “calculations,” even
though the computer will not typically perform them when executing a pro-gram (although it might perform them beforea program is run if it thinks
that it might make the program run faster). The second step in the calcu-
lation above relies on the commutativity of addition (namely that, for any
numbers xandy,x+y=y+x). The third step is the reverse of an unfold
step, and is appropriately called a foldcalculation. It would be particu-
larly strange if a computer performed this step while executing a program,since it does not seem to be headed toward a ﬁnal answer. But for provingproperties about programs, such “backward reasoning” is quite important.
When one wishes to make the justiﬁcation for each step clearer, whether
symbolic or concrete, a calculation can be annotated with more detail, asin:
simple a b c
⇒{unfold}
a∗(b+c)
⇒{commutativity }
a∗(c+b)
⇒{fold}
simple a c b
In most cases, however, this will not be necessary.
Proving properties of programs is another theme that will be repeated
often in this text. Computer music applications often have some kind ofa mathematical basis, and that mathematics must be reﬂected somewherein your program. But how do you know that you got it right? Proof bycalculation isoneway toconnect theproblemspeciﬁcation withtheprogramsolution.
More broadly speaking, as the world begins to rely more and more on
computers to accomplish not just ordinary tasks such as writing term pa-pers, sending email, and social networking, but also life-critical tasks suchas controlling medical procedures and guiding spacecraft, then the correct-ness of programs gains in importance. Proving complex properties of large,complex programs is not easy—and rarely if ever done in practice—but thatshould not deter you from proving simpler properties of the whole system,
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 8
or complex properties of parts of the system, since such proofs may uncover
errors, and if not, at least give you conﬁdence in your eﬀort.
If you are someone who is already an experienced programmer, the idea
of computing everything by calculation may seem odd at best, and na¨ ıve at
worst. How does one write to a ﬁle, play a sound, draw a picture, or respondto mouse-clicks? If you are wondering about these things, it is hoped thatyou have patience reading the early chapters, and that you ﬁnd delight inreading the later chapters where the full power of this approach begins to
shine.
In many ways this ﬁrst chapter is the most diﬃcult, since it contains the
highest density of new concepts. If the reader has trouble with some of theconcepts in this overview chapter, keep in mind that most of them will berevisited in later chapters. And don’t hesitate to return to this chapter laterto re-read diﬃcult sections; they will likely be much easier to grasp at thattime.
Details: In the remainder of this textbook the need will often arise to explain
some aspect of Haskell in more detail, without distracting too much from theprimary line of discourse. In those circumstances the explanations will be oﬀset in
a box such as this one, proceeded with the word “Details.”
Exercise 1.1 Write out all of the steps in the calculation of the value of
simple(simple234 )56
Exercise 1.2 Prove by calculation that simple(a−b)ab=⇒a2−b2.
1.4 Expressions and Values
InHaskell, theentities onwhich calculations areperformedarecalled expres-
sions, and the entities that result from a calculation—i.e. “the answers”—
are called values. It is helpful to think of a value just as an expression on
which no more calculation can be carried out—every value is an expression,but not the other way around.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 9
Examples of expressions include atomic(meaning, indivisible) values
such as the integer 42 and the character ’a’,w h i c ha r ee x a m p l e so ft w o
primitive atomic values. The next chapter introduces examples of user-
deﬁnedatomic values, such as the musical note names C,Cs,Df,e t c . ,
which in music notation are written C, C /sharp,D/flat, etc. (In music theory, note
names are called pitch classes .)
In addition, there are structured expressions (i.e., made from smaller
pieces) such as the listof pitches [ C,Cs,Df], the character/number pair
(’b’,4) (lists and pairs are diﬀerent in a subtle way, to be described later),
and the string "Euterpea" . Each of these structured expressions is also a
value, since by themselves there is no further calculation that can be carriedout. As another example, 1+2 is an expression, and one step of calculationyields the expression 3, which is a value, since no more calculations canbe performed. As a ﬁnal example, as was expained earlier, the expressionsimple3 9 5 evaluates to the value 42.
Sometimes, however, an expression has only a never-ending sequence of
calculations. For example, if xis deﬁned as:
x=x+1
then here is what happens when trying to calculate the value of x:
x
⇒x+1
⇒(x+1)+1
⇒((x+1)+1)+1
⇒(((x+1)+1)+1)+1
...
Similarly, if a function fis deﬁned as:
fx=f(x−1)
then an expression such as f42 runs into a similar problem:
f42
⇒f41
⇒f40
⇒f39
...
Both of these clearly result in a never-ending sequence of calculations. Such
expressions are said to not terminate, or diverge.I ns u c hc a s e st h es y m b o l
⊥, pronounced “bottom,” is used to denote the value of the expression.
This means that every diverging computation in Haskell denotes the same
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 10
⊥value,3reﬂecting the fact that, from an observer’s point of view, there is
nothing to distinguish one diverging computation from another.
1.5 Types
Everyexpression(andthereforeeveryvalue)alsohasanassociated type.O n e
c a nt h i n ko ft y p e sa ss e t so fe x p r e s s i o n s( o rv a l u e s ) ,i nw h i c hm e m b e r so fthe same set have much in common. Examples include the primitive atomictypesInteger(the set of all integers) and Char(the set of all characters),
the user-deﬁned atomic type PitchClass (the set of all pitch classes, i.e. note
names), as well as the structured types [ Integer]a n d[PitchClass ] (the sets
of all lists of integers and lists of pitch classes, respectively), and String(the
set of all Haskell strings).
The association of an expression or value with its type is very important,
and there is a special way of expressing it in Haskell. Using the examples ofvalues and types above:
Cs ::PitchClass
42 :: Integer
’a’ ::Char
"Euterpea" ::String
[C,Cs,Df]: : [PitchClass ]
(’b’,4) ::( Char,Integer)
Each association of an expression with its type is called a type signature .
Details: Note that the names of speciﬁc types are capitalized, such as Integer
andChar, but the names of values are not, such as simpleandx.T h i si sn o tj u s t
a convention: it is required when programming in Haskell. In addition, the caseof the other characters matters, too. For example, test,teSt,a n dtESTare all
distinct names for values, as are Test,TeST,a n dTESTfor types.
3Technically, each type has its own version of ⊥.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 11
Details: Literal characters are written enclosed in single forward quotes (apos-
trophes), as in ’a’,’A’,’b’,’,’,’!’,’’(a space), and so on. (There are
some exceptions, however; see the Haskell Report for details.) Strings are written
enclosed in double quote characters, as in "Euterpea" above. The connection
between characters and strings will be explained in a later chapter.
The “::” should be read “has type,” as in “42 has type Integer.” Note that square
braces are used both to construct a list value (the left-hand side of (::)above), and
to describe its type (the right-hand side above). Analogously, the round bracesused for pairs are used in the same way. But also note that all of the elements ina list, however long, must have the same type, whereas the elements of a pair can
have diﬀerent types.
Haskell’s type system ensures that Haskell programs are well-typed ;t h a t
is, that the programmer has not mismatched types in some way. For ex-
ample, it does not make much sense to add together two characters, so the
expression ’a’+’b’isill-typed. The best news is that Haskell’s type system
will tell you if your program is well-typed before you run it . This is a big
advantage, since most programming errors are manifested as type errors.
1.6 Function Types and Type Signatures
What should the type of a function be? It seems that it should at least
convey the fact that a function takes values of one type— T1, say—as input,
and returns values of (possibly) some other type— T2, say—as output. In
H a s k e l lt h i si sw r i t t e n T1→T2, and such a function is said to “map values
of typeT1to values of type T2.” If there is more than one argument,
the notation is extended with more arrows. For example, if the intent isthat the function simpledeﬁned in the previous section has type Integer→
Integer→Integer→Integer, one can include a type signature with the
deﬁnition of simple:
simple ::Integer→Integer→Integer→Integer
simple x y z =x∗(y+z)
Details: When writingHaskellprogramsusinga typicaltext editor, there typically
will not be nice fonts and arrows as in Integer→Integer. Rather, you will have
to type Integer -> Integer .
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 12
Haskell’s type system also ensures that user-supplied type signatures
such as this one are correct. Actually, Haskell’s type system is powerfulenough to allow one to avoid writing any type signatures at all, in whichcase the type system is said to inferthe correct types.
4Nevertheless, judi-
cious placement of type signatures, as was done for simple, is a good habit,
since type signatures are an eﬀective form of documentation and help bringprogramming errors to light. In fact, it is a good habit to ﬁrst write downthe type of each function you are planning to deﬁne, as a ﬁrst approxima-
tion to its full speciﬁcation—a way to grasp its overall functionality before
delving into its details.
The normal use of a function is referred to as function application .F o r
example, simple3 9 5 is the application of the function simpleto the ar-
guments 3, 9, and 5. Some functions, such as (+), are applied using whatis known as inﬁx syntax ; that is, the function is written between the two
arguments rather than in front of them (compare x+ytofxy).
Details: Inﬁx functions are often called operators , and are distinguished by the
fact that they do not contain any numbers or letters of the alphabet. Thus ˆ!and
∗#:are inﬁx operators, whereas thisIsAFunction andf9gare not (but are still
valid names for functions or other values). The only exception to this is that the
symbol ’is considered to be alphanumeric; thus f/primeandone/primesare valid names, but
not operators.
In Haskell, when referring to an inﬁx operator as a value, it is enclosed in paren-
theses, such as when declaring its type, as in:
(+)::Integer→Integer→Integer
Also, when trying to understand an expression such as fx+gy,t h e r ei sa
simple rule to remember: function application alwayshas “higher precedence”
than operator application, so that fx+gyi st h es a m ea s (fx)+(gy).
Despite all ofthese syntactic diﬀerences, however, operators are still just functions.
Exercise 1.3 Identify the well-typed expressions in the following, and, for
each, give its proper type:
4There are a few exceptions to this rule, and in the case of simplethe inferred type is
actually a bit more general than that written above. Both of these points will be returned
to later.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 13
[(2,3),(4,5)]
[Cs,42]
(Df,−42)
simple ’a’ ’b’ ’c’
(simple123,simple)
["hello","world" ]
1.7 Abstraction, Abstraction, Abstraction
The title of this section is the answer to the question: “What are the three
mostimportantideasinprogramming?” Websterdeﬁnestheverb“abstract”
as follows:
abstract ,vt(1) remove, separate (2) to consider apart from
application to a particular instance.
In programming this is done when a repeating pattern of some sort occurs,
and one wishes to “separate” that pattern from the “particular instances”
in which it appears. In this textbook this process is called the abstrac-
tion principle . The following sections introduce several diﬀerent kinds of
abstraction, using examples involving both simple numbers and arithmetic(things everyone should be familiar with) as well as musical examples (thatare speciﬁc to Euterpea).
1.7.1 Naming
One of the most basic ideas in programming—for that matter, in every daylife—is to namethings. For example, one may wish to give a name to the
value of π, since it is inconvenient to retype (or remember) the value of π
beyond a small number of digits. In mathematics the greek letter πin fact
isthe name for this value, but unfortunately one doesn’t have the luxury of
using greek letters on standard computer keyboards and text editors. So inHaskell one writes:
pi::Double
pi=3.141592653589793
to associate the name piwith the number 3.141592653589793. The type
signature in the ﬁrst line declares pito be a double-precision ﬂoating-point
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 14
number, which mathematically and in Haskell is distinct from an integer.5
Now the name pic a nb eu s e di ne x p r e s s i o n sw h e n e v e ri ti si ns c o p e ;i ti s
an abstract representation, if you will, of the number 3.141592653589793.Furthermore, ifthereiseveraneedtochangeanamedvalue(whichhopefullywon’t ever happen for pi, but could certainly happen for other values), one
would only have to change it in one place, instead of in the possibly largenumber of places where it is used.
For a simple musical example, note ﬁrst that in music theory, a pitch
consists of a pitch class and anoctave. For example, in Euterpea one sim-
ply writes ( A,4) to represent the pitch class Ain the fourth octave. This
particular note is called “concert A” (because it is often used as the note towhich an orchestra tunes its instruments) or “A440” (because its frequencyis 440 cycles per second). Because this particular pitch is so common, itmay be desirable to give it a name, which is easily done in Haskell, as wasdone above for π:
concertA ,a440::(PitchClass ,Octave)
concertA =(A,4) -- concert A
a440 =(A,4) -- A440
Details: This example demonstrates the use of program comments .A n y t e x t
to the right of “ --”t i l lt h ee n do ft h el i n ei sc o n s i d e r e dt ob eap r o g r a m m e r
comment, and is eﬀectively ignored. Haskell also permits nestedcomments that
have the form {-this is a comment - }and can appear anywhere in a program,
including across multiple lines.
This example demonstrates the (perhaps obvious) fact that several dif-
ferent names can be given to the same value—just as your brother John
might have the nickname “Moose.” Also note that the name concertA re-
quires more typing than ( A,4); nevertheless, it has more mnemonic value,
and, ifmistyped, willmore likely resultinasyntax error. For example, ifyoutype “concrtA” by mistake, you will likely get an error saying, “Undeﬁned
variable,” whereas if you type “( A,5)” you will not.
5We will have more to say about ﬂoating-point numbers later.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 15
Details: This example also demonstrates that two names having the same type
canbe combinedintothesametype signature, separatedbyacomma. Noteﬁnally,
as a reminder, that these are names of values, and thus they both begin with alowercase letter.
Consider now a problem whose solution requires writing some larger
expression more than once. For example:
x::Float
x=f(pi∗r∗∗2)+g(pi∗r∗∗2)
Details: (∗∗)is Haskell’s ﬂoating-point exponentiation operator. Thus pi∗r∗∗2
is analogous to πr2in mathematics. (∗∗)has higher precedence than (∗)and the
other binary arithmetic operators in Haskell.
Note in the deﬁnition of xthat the expression pi∗r∗∗2 (presum-
ably representing the area of a circle whose radius is r) is repeated—it
has two instances—and thus, applying the abstraction principle, it can beseparated from these instances. From the previous examples, doing thisis straightforward—it’s called naming—so one might choose to rewrite the
single equation above as two:
area=pi∗r∗∗2
x=fa r e a+ga r e a
If, however, the deﬁnition of areais not intended for use elsewhere in the
program, then it is advantageous to “hide” it within the deﬁnition of x.T h i s
willavoid cluttering upthenamespace, andprevents areafromclashing with
some other value named area. To achieve this, one could simply use a let
expression:
x=letarea=pi∗r∗∗2
infa r e a+ga r e a
Aletexpression restricts the visibility of the names that it creates to the
internal workings of the letexpression itself. For example, if one writes:
area=4 2
x=letarea=pi∗r∗∗2
infa r e a+ga r e a
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 16
then there is no conﬂict of names—the “outer” areais completely diﬀerent
from the “inner” one enclosed in the letexpression. Think of the inner
areaas analogous to the ﬁrst name of someone in your household. If your
brother’s name is “John” he will not be confused with John Thompson wholives down the street when you say, “John spilled the milk.”
So you can see that naming—using either top-level equations or equa-
tions within a letexpression—is an example of the abstraction principle in
action.
Details: An equation such as c=4 2is called a binding. A simple rule to
remember when programming in Haskell is never to give more than one bindingfor the same name in a context where the names can be confused, whether at the
top level of your program or nestled within a letexpression. For example, this is
not allowed:
a=4 2
a=4 3
nor is this:
a=4 2
b=4 3
a=4 4
1.7.2 Functional Abstraction
The design of functions such as simplecan be viewed as the abstraction
principle in action. To see this using the example above involving the areaof a circle, suppose the original program looked like this:
x::Float
x=f(pi∗r
1∗∗2)+g(pi∗r2∗∗2)
Note that there are now two areas involved—one of a circle whose radius is
r1, the other r2. Now the expressions in parentheses have a repeating pattern
of operations . In discerning the nature of a repeating pattern it’s sometimes
helpful to ﬁrst identify those things that are notrepeating, i.e. those things
that are changing . In the case above, it is the radius that is changing. A
repeating pattern of operations can be abstracted as a function that takes
the changing values asarguments. Using thefunction name areaF(for “area
function”) one can write:
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 17
x=letareaF r=pi∗r∗∗2
inf(areaF r 1)+g(areaF r 2)
This is a simple generalization of the previous example, where the function
now takes the “variable quantity”—in this case the radius—as an argument.A very simple proof by calculation, in which areaFis unfolded where it is
used, can be given to demonstrate that this program is equivalent to theold.
This application of the abstraction principle is called functional abstrac-
tion, sinceasequenceofoperationsisabstracted asa function suchasareaF.
For a musical example, a few more concepts from Euterpea are ﬁrst
introduced, concepts that are addressed more formally in the next chapter:
1. Recall that in music theory a noteis a pitch combined with a duration.
Duration is measured in beats, and in Euterpea has type Dur.An o t e
whose duration is one beat is called a whole note; one with duration
1/2is called a half note; and so on. A note in Euterpea is the smallest
entity, besidesa rest, that is actually a performable piece of music, and
its type is Music Pitch (other variations of this type will be introduced
in later chapters).
2. In Euterpea there are functions:
note::Dur→Pitch→Music Pitch
rest::Dur→Music Pitch
such that note d p is a note whose duration is dand pitch is p,a n d
rest dis a rest with duration d. For example, note(1/4) (A,4) is a
quarter note concert A.
3. InEuterpeathe following inﬁxoperatorscombine smaller Musicvalues
into larger ones:
(:+:) ::Music Pitch →Music Pitch →Music Pitch
(:=:)::Music Pitch →Music Pitch →Music Pitch
Intuitively:
•m1:+:m2is the music value that represents the playing of m1
followed by m2.
•m1:=:m2is the music value that represents the playing of m1
andm2simultaneously.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 18
4. Finally, Eutperepa has a function trans::Int→Pitch→Pitchsuch
thattrans i p is a pitch that is isemitones (half steps, or steps on a
piano) higher than p.
Now for the example. Consider the simple melody:
note qn p 1:+:note qn p 2:+:note qn p 3
whereqnis a quarter note:
qn=1/4
Supposeone wishes to harmonize each note with a note played a minor third
lower. In music theory, a minor third corresponds to three semitones, andthus the harmonized melody can be written as:
mel=(note qn p
1:=:note qn(trans(−3)p1)) :+:
(note qn p 2:=:note qn(trans(−3)p2)) :+:
(note qn p 3:=:note qn(trans(−3)p3))
Note as in the previous example a repeating pattern of operations—
namely, the operations that harmonize a single note with a note three semi-tones below it. As before, to abstract a sequence of operations such as this,
a function can be deﬁned that takes the “variable quantities”—in this case
the pitch—as arguments. One could take this one step further, however, bynoting that in some other context one might wish to vary the duration. Rec-ognizing this is to anticipate the need for abstraction. Calling this functionhNote(for “harmonize note”) one can then write:
hNote ::Dur→Pitch→Music Pitch
hNote d p =note d p :=:note d(trans(−3)p)
Therearethreeinstancesofthepatternin mel, each ofwhichcanbereplaced
with an application of hNote. This leads to:
mel::Music Pitch
mel=hNote qn p
1:+:hNote qn p 2:+:hNote qn p 3
Again using the idea of unfolding described earlier in this chapter, it is easy
to prove that this deﬁnition is equivalent to the previous one.
As withareaF,t h i su s eo f hNoteis an example of functional abstraction.
In a sense, functional abstraction can be seen as a generalization of naming.That is, area r
1is just a name for pi∗r1∗∗2,hNote d p 1is just a name
fornote d p 1:=:note d(trans(−3)p1), and so on. Stated another way,
named quantities such as area,pi,concertA ,a n da440deﬁned earlier can
be thought of as functions with no arguments.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 19
Of course, the deﬁnition of hNotecould also be hidden within melusing
aletexpression as was done in the previous example:
mel::Music Pitch
mel=lethNote d p =note d p :=:note d(trans(−3)p)
inhNote qn p 1:+:hNote qn p 2:+:hNote qn p 3
1.7.3 Data Abstraction
The value of melis the sequential composition of three harmonized notes.
But what if in another situation one must compose together ﬁve harmonizednotes, or in other situations even more? In situations where the number ofvalues is uncertain, it is useful to represent them in a data structure .F o rt h e
example at hand, a good choice of data structure is a list, brieﬂy introduced
earlier, that can have any length. The use of a data structure motivated by
the abstraction principle is one form of data abstraction .
Imagine now an entire list of pitches, whose length isn’t known at the
time the program is written. What now? It seems that a function is neededto convert alist ofpitches into asequential composition ofharmonized notes.Before deﬁning such a function, however, there is a bit more to say aboutlists.
Earlier the example [ C,Cs,Df] was given, a list of pitch classes whose
type is thus [ PitchClass ]. A list with noelements is—not surprisingly—
written [], and is called the empty list .
To add a single element xto the front of a list xs,o n ew r i t e s x:xs
in Haskell. (Note the naming convention used here; xsis the plural of x,
and should be read that way.) For example, C:[Cs,Df]i st h es a m ea s
[C,Cs,Df]. In fact, this list is equivalent to C:(Cs:(Df:[])), which can
also be written C:Cs:Df:[] since the inﬁx operator (:) is right associative.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 20
Details: In mathematics one rarely worries about whether the notation a+b+c
stands for (a+b)+c(in which case +wouldbe “left associative”)or a+(b+c)(in
which case +would “right associative”). This is because in situations where the
parentheses are left out it’s usually the case that the operator is mathematically
associative, meaning that it doesn’t matter which interpretation is chosen. If theinterpretation doesmatter, mathematicians will include parentheses to make it
clear. Furthermore, in mathematics there is an implicit assumption that some
operators have higher precedence than others; for example, 2×a+bis interpreted
as(2×a)+b,n o t2×(a+b).
In many programming languages, including Haskell, each operator is deﬁned to
have a particular precedence level and to be left associative, right associative, orto have no associativity at all. For arithmetic operators, mathematical conventionis usually followed; for example, 2∗a+bis interpreted as (2∗a)+bin Haskell.
The predeﬁned list-forming operator (:)is deﬁned to be right associative. Just as
in mathematics, this associativity can be overridden by using parentheses: thus(a:b):cis a valid Haskell expression (assuming that it is well-typed; it must be
a list of lists), and is very diﬀerent from a:b:c. A way to specify the precedence
and associativity of user-deﬁned operators will be discussed in a later chapter.
Returning now to the problem of deﬁning a function (call it hList)t o
turn a list of pitches into a sequential composition of harmonized notes, one
should ﬁrst express what its type should be:
hList::Dur→[Pitch]→Music Pitch
Todeﬁneitsproperbehavior, itishelpfultoconsider, onebyone, allpossible
casesthatcouldariseontheinput. Firstoﬀ,thelistcouldbeempty, inwhichcase the sequential composition should be a Music Pitch value that has zero
duration. So:
hList d[]=rest0
The other possibility is that the list isn’tempty—i.e. it contains at least
one element, say p, followed by the rest of the elements, say ps.I n t h i s
case the result should be the harmonization of pfollowed by the sequential
composition of the harmonization of ps.T h u s :
hList d(p:ps)=hNote d p :+:hList d ps
Note that this part of the deﬁnition of hListisrecursive —it refers to itself!
But the original problem—the harmonization of p:ps—has been reduced to
the harmonization of p(previously captured in the function hNote)a n dt h e
harmonization of ps(a slightly smaller problem than the original one).
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 21
Combining these two equations with the type signature yields the com-
plete deﬁnition of the function hList:
hList::Dur→[Pitch]→Music Pitch
hList d[] = rest0
hList d(p:ps)=hNote d p :+:hList d ps
Recursion is a powerful technique that will be used many times in this
textbook. It is also an example of a general problem-solving technique where
a large problem is broken down into several smaller but similar problems;
solving these smaller problems one-by-one leads to a solution to the largerproblem.
Details: Although intuitive, this example highlights an important aspect of
Haskell: pattern matching . The left-hand sides of the equations contain pat-
ternssuch as[]andx:xs. When a function is applied, these patterns are matched
against the argument values in a fairly intuitive way ( []only matches the empty
list, and p:pswill successfully match any list with at least one element, while
naming the ﬁrst element pand the rest of the list ps). If the match succeeds,
the right-hand side is evaluated and returned as the result of the application. If
it fails, the next equation is tried, and if all equations fail, an error results. All of
the equations that deﬁne a particular function must appear together, one after the
other.
Deﬁningfunctionsbypatternmatchingis quitecommonin Haskell,and youshould
eventually become familiar with the various kinds of patterns that are allowed; see
Appendix Dfor a concise summary.
Given this deﬁnition of hListthe deﬁnition of melcan be rewritten as:
mel=hList qn [p1,p2,p3]
One can prove that this deﬁnition is equivalent to theold via calculation:
mel=hList qn [p1,p2,p3]
⇒hList qn (p1:p2:p3:[])
⇒hNote qn p 1:+:hList qn (p2:p3:[])
⇒hNote qn p 1:+:hNote qn p 2:+:hList qn (p3:[])
⇒hNote qn p 1:+:hNote qn p 2:+:hNote qn p 3:+:hList qn []
⇒hNote qn p 1:+:hNote qn p 2:+:hNote qn p 3:+:rest0
The ﬁrst step above is not really a calculation, but rather a rewriting of the
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 22
list syntax. The remaining calculations each represent an unfoldingof hList.
Lists are perhaps the most commonly used data structure in Haskell,
and there is a rich library of functions that operate on them. In subse-quent chapters lists will be used in a variety of interesting computer musicapplications.
Exercise 1.4 Modify the deﬁnitions of hNoteandhListso that they each
take an extra argument that speciﬁes the interval of harmonization (ratherthan being ﬁxed at -3). Rewrite the deﬁnition of melto take these changes
into account.
1.8 Haskell Equality vs. Euterpean Equality
The astute reader will have objected to the proof just completed, arguingthat the original version of mel:
hNote qn p
1:+:hNote qn p 2:+:hNote qn p 3
is not the same as the terminus of the above proof:
hNote qn p 1:+:hNote qn p 2:+:hNote qn p 3:+:rest0
Indeed, that reader would be right! As Haskell values, these expressions are
notequal, and if you printed each of them you would get diﬀerent results.
So what happened? Did proof by calculation fail?
No, proof by calcultation did not fail, since, as just pointed out, as
Haskell values these two expressions are not the same, and proof by cal-culation is based on the equality of Haskell values. The problem is that a“deeper” notion of equivalence is needed, one based on the notion of musical
equality. Adding a rest of zero duration to the beginning or end of any piece
of music should not change what one hears, and therefore it seems that the
above two expressions are musically equivalent. But it is unreasonable to
expect Haskell to ﬁgure this out for the programmer!
As an analogy, consider the use of an ordered list to represent a set
(which is unordered). The Haskell values [ x
1,x2]a n d[x2,x1]a r en o te q u a l ,
yet in a program that “interprets” them as sets, they areequal.
The way this problem is approached in Euterpea is to formally deﬁne a
notion of musical interpretation ,f r o mw h i c ht h en o t i o n musical equivalence
is deﬁned. This leads to a kind of “algebra of music” that includes, amongothers, the following axiom:
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 23
Figure 1.1: Polyphonic vs. Contrapuntal Interpretation
m:+:rest0≡m
The operator ( ≡) should be read, “is musically equivalent to.” With this
axiom it is easy to see that the original two expressions above arein fact
musically equivalent.
For a more extreme example of this idea, and to entice the reader to
learn more about musical equivalence in later chapters, note that mel,g i v e n
pitchesp1=Ef,p2=F,p3=G, and duration d=1/4, generates the
harmonized melody shown in Figure 1.1. One can write this concretely in
Euterpea as:
mel1=(note(1/4) (Ef,4):=:note(1/4) (C,4)) :+:
(note(1/4) (F,4):=:note(1/4) (D,4)) :+:
(note(1/4) (G,4):=:note(1/4) (E,4))
The deﬁnition of mel1can then be seen as a polyphonic interpretation of the
musical phrase in Figure 1.1, where each pair of notes is seen as a harmonic
unit. In contrast, a contrapuntal interpretation sees two independent lines
of notes, in this case the line /angbracketleftE/flat,F,G/angbracketrightand the line /angbracketleftC,D,E/angbracketright.I nE u t e r p e a
one can write this as:
mel2=(note(1/4) (Ef,4):+:note(1/4) (F,4) :+:note(1/4) (G,4))
:=:
(note(1/4) (C,4):+:note(1/4) (D,4):+:note(1/4) (E,4))
mel1andmel2are clearly not equal as Haskell values. Yet if they are played,
they will soundthe same—they are, in the sense described earlier, musically
equivalent. But proving these two phrases musically equivalent will requirefar more than a simple axiom involving rest0. In fact this can be done in
an elegant way, using the algebra of music developed in Chapter 11.
1.9 Code Reuse and Modularity
There doesn’t seem to be much repetition in the last deﬁnition of hList,
so perhaps the end of the abstraction process has been reached. In fact,it’s worth considering how much progress has been made. The original
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 24
deﬁnition:
mel=(note qn p 1:=:note qn(trans(−3)p1)) :+:
(note qn p 2:=:note qn(trans(−3)p2)) :+:
(note qn p 3:=:note qn(trans(−3)p3))
was replaced with:
mel=hList qn [p1,p2,p3]
Butadditionally, deﬁnitionsfortheauxiliary functions hNoteandhListwere
introduced:
hNote ::Dur→Pitch→Music Pitch
hNote d p =note d p :=:note d(trans(−3)p)
hList ::Dur→[Pitch]→Music Pitch
hList d[] = rest0
hList d(p:ps)=hNote d p :+:hList d ps
In terms of code size, the ﬁnal program is actually larger than the original!
So has the program improved in any way?
Things have certainly gotten better from the standpoint of “removing re-
peating patterns,” and one could argue that the resulting program thereforeis easier to understand. But there is more. Now that auxiliary functions
such ashNoteandhListhave been deﬁned, one can reusethem in other
contexts. Being able to reuse code is also called modularity , since the reused
components arelike little modules,orbricks, thatcan formthefoundationofmany applications.
6In a later chapter, techniques will be introduced—most
notably, higher-order functions andpolymorphism —for improving the mod-
ularity of this example even more, and substantially increasing the abilityto reuse code.
1.10 [Advanced] Programming with Numbers
In computer music programming, it is often necessary to program with num-bers. For example, it is often convenient to represent pitch on a simple ab-solute scale using integer values. And when computing with analog signalsthat represent a particular sound wave, it is necessary to use ﬂoating pointnumbers as an approximation to the reals. So it is a good idea to under-stand precisely how numbers are represented inside a computer, and withina particular language such as Haskell.
6“Code reuse” and “modularity” are important software engineering principles.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 25
In mathematics there are many diﬀerent kinds of number systems. For
example, there are integers, natural numbers (i.e. non-negative integers),real numbers, rational numbers, and complex numbers. These number sys-tems possessmanyusefulproperties, such as thefact thatmultiplication andaddition are commutative, and that multiplication distributes over addition.You have undoubtedlylearned many of these properties in your studies, andhave used them often in algebra, geometry, trigonometry, physics, and soon.
Unfortunately, each of these number systems places great demands on
computer systems. In particular, a number can in general require an arbi-
trary amount of memory to represent it. Clearly, for example, an irrational
number such as πcannot be represented exactly; the best one can do is
approximate it, or possibly write a program that computes it to whatever(ﬁnite) precision is needed in a given application. But even integers (andtherefore rational numbers) present problems, since any given integer canbe arbitrarily large.
Most programming languages do not deal with these problems very well.
In fact, most programming languages do not have exact forms of many ofthese number systems. Haskell does s lightly better than most, in that it has
exact forms of integers (the type Integer) as well as rational numbers (the
typeRational,d e ﬁ n e di nt h eR a t i oL i b r a r y ) .B u ti nH a s k e l la n dm o s to t h e r
languages there is no exact form of real numbers, for example, which are in-stead approximated by ﬂoating-point numbers with either single-word preci-
sion (Floatin Haskell) or double-word precision ( Double). What’s worse, the
behavior of arithmetic operations on ﬂoating-point numbers can vary some-what depending on what kind of computer is being used, although hardwarestandardization in recent years has reduced the degree of this problem.
The bottom line is that, as simple as they may seem, great care must be
taken when programming with numbers. Many computer errors, some quiteserious and renowned, were rooted in numerical incongruities. The ﬁeld ofmathematics known as numerical analysis is concerned precisely with these
problems, and programming with ﬂoating-point numbers in sophisticated
applications often requires a good understanding of numerical analysis todevise proper algorithms and write correct programs.
As a simple example of this problem, consider the distributive law, ex-
pressed here as a calculation in Haskell, and used earlier in this chapter incalculations involving the function simple:
a∗(b+c)⇒a∗b+a∗c
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 26
For most ﬂoating-point numbers, this law is perfectly valid. For example,
in the GHC implementation of Haskell, the expressions pi∗(3+4):: Float
andpi∗3+pi∗4::Floatboth yield the same result: 21.99115. But funny
things can happen when the magnitude of b+cdiﬀers signiﬁcantly from the
magnitude of either borc. For example, the following two calculations are
from GHC:
5∗(−0.123456 +0 .123457) :: Float⇒4.991889e−6
5∗(−0.123456)+5 ∗(0.123457):: Float⇒5.00679e−6
Although the error here is small, its very existence is worrisome, and in
certain situations it could be disastrous. The precise behavior of ﬂoating-point numberswill not be discussed furtherin this textbook. Just rememberthat they are approximations to the real numbers. If real-number accuracy
isimportant to your application, furtherstudyofthe natureof ﬂoating-pointnumbers is probably warranted.
On the other hand, the distributive law (and many others) is valid in
Haskell for the exact data types IntegerandRatio Integer (i.e. rationals).
However, another problem arises: although the representation of an Integer
in Haskell is not normally something to be concerned about, it should beclear that the representation must be allowed to grow to an arbitrary size.
For example, Haskell has no problem with the following number:
veryBigNumber ::Integer
veryBigNumber = 43208345720348593219876512372134059
and such numbers can be added, multiplied, etc. without any loss of ac-
curacy. However, such numbers cannot ﬁt into a single word of computermemory, most of which are limited to 32 bits. Worse, since the computersystem does not know ahead of time exactly how many words will be re-quired, it must devise a dynamic scheme to allow just the right numberof words to be used in each case. The overhead of implementing this ideaunfortunately causes programs to run slower.
For this reason, Haskell (and most other languages) provides another
integer data type called Intthat has maximum and minimum values that
depend on the word-size of the particular computer being used. In other
words, everyvalueoftype Intﬁtsintoonewordofmemory, andtheprimitive
machine instructions for binary numbers can be used to manipulate themeﬃciently.
7Unfortunately, this means that overﬂow orunderﬂow errors
7The Haskell Report requires that every implementation support Intsa tl e a s ti nt h e
range−229to 229−1, inclusive. The GHC implementation running on a Pentium proces-
sor, for example, supports the range −231to 231−1.
CHAPTER 1. OVERVIEW OF COMPUTER MUSIC, EUTERPEA, AND HASKELL 27
could occur when an Intvalue exceeds either the maximum or minimum
values. However, most implementations of Haskell (as well as most otherlanguages) do not tell you when this happens. For example, in GHC, thefollowing Intvalue:
i::Int
i= 1234567890
works just ﬁne, but if you multiply it by two, GHC returns the value
−1825831516! This is because twice iexceeds the maximum allowed value,
so the resulting bits become nonsensical,
8and are interpreted in this case
as a negative number of the given magnitude.
Thisisalarming! Indeed, whyshouldanyone ever use IntwhenIntegeris
available? Theanswer,asimpliedearlier, iseﬃciency, butclearlycareshouldbetakenwhenmakingthischoice. Ifyouareindexingintoalist,forexample,and you are conﬁdent that you are not performing index calculations thatmight result in the above kind of error, then Intshould work just ﬁne,
since a list longer than 2
31w i l ln o tﬁ ti n t om e m o r ya n y w a y ! B u ti fy o u
are calculating the number of microseconds in some large time interval, orcounting the number of people living on earth, then Integerwould most
likely be a better choice. Choose your number data types wisely!
In this textbook the numeric data types Integer,Int,Float,Double,
Rational ,a n dComplex will beused for a variety ofdiﬀerent applications; for
a discussion of the other number types, consult the Haskell Report. As thesedata types are used, there will be little discussion about their properties—this is not, after all, a book on numerical analysis—but a warning will becast whenever reasoning about, for example, ﬂoating-point numbers, in away that might not be technically sound.
8Actually, these bits are perfectly sensible in the following way: the 32-bit bi-
nary representation of iis 01001001100101100000001011010010, and twice that is
10010011001011000000010110100100. But the latter number is seen as negative be-
cause the 32nd bit (the highest-order bit on the CPU on which this was run) is a one,
which means it is a negative number in “twos-complement” representation. The twos-complement of this number is in turn 01101100110100111111101001011100, whose decimal
representation is 1825831516.
Chapter 2
Simple Music
module Euterpea .Music.Note.Music where
inﬁxr5:+:,:=:
The previous chapters introduced some of the fundamental ideas of func-
tional programming in Haskell. Also introduced were several of Euterpea’sfunctions and operators, such as note,rest,( : + : ) ,( : = : ) ,a n d trans.T h i s
chapter will reveal the actual deﬁnitions of these functions and operators,thus exposingEuterpea’s underlyingstructureand overall design at thenotelevel. In addition, a number of other musical ideas will be developed, andin the process more Haskell features will be introduced as well.
2.1 Preliminaries
Sometimes itisusefultouseabuilt-inHaskell datatypetodirectlyrepresentsome concept of interest. For example, one may wish to use Intto represent
octaves, where by convention octave 4 corresponds to the octave containing
middleConthepiano. OnecanexpressthisinHaskellusinga type synonym :
typeOctave=Int
A type synonym does not create a new data type—it just gives a new name
to an existing type. Type synonyms can be deﬁned not just for atomictypes such as Int, but also for structured types such as pairs. For example,
as discussed in the last chapter, in music theory a pitch is deﬁned as a pair,
consisting of a pitch class and anoctave. Assuming the existence of a data
type called PitchClass (which will be returned to shortly), one can write the
following type synonym:
28
CHAPTER 2. SIMPLE MUSIC 29
typePitch=(PitchClass ,Octave)
For example, concert A (i.e. A440) corresponds to the pitch ( A,4), and
the lowest and highest notes on a piano correspond to ( A,0) and ( C,8),
respectively.
Another important musical concept is duration. Rather than use either
integersorﬂoating-pointnumbers,Euterpeauses rationalnumberstodenote
duration:
typeDur=Rational
Rational is the data type of rational numbers expressed as ratios of Integers
in Haskell. The choice of Rational is somewhat subjective, but is justiﬁed
by three observations: (1) many durations are expressed as ratios in musictheory (5:4 rhythm, quarter notes, dotted notes, and so on), (2) Rational
numbers are exact (unlike ﬂoating point numbers), which is important inmany computer music applications, and (3) irrational durations are rarelyneeded.
Rational numbers in Haskell are printed by GHC in the form n%d,
wherenis the numerator, and dis the denominator. Even a whole number,
say the number 42, will print as 42%1 if it is a Rational number. To create
aRational number in a program, however, once it is given the proper type,
one can use the normal division operator, as in the following deﬁnition of a
quarter note:
qn::Dur
qn=1/4 -- quarter note
So far so good. But what about PitchClass ? One might try to use inte-
gers to represent pitch classes as well, but this is not very elegant—ideallyone would like to write something that looks more like the conventional pitchclass names C, C /sharp,D/flat, D, etc. The solution is to use an algebraic data type
in Haskell:
dataPitchClass =Cﬀ|Cf|C|Dﬀ|Cs|Df|Css|D|Eﬀ|Ds
|Ef
|Fﬀ|Dss|E|Es|Ff|F|Gﬀ|Ess|Fs
|Gf|Fss|G|Aﬀ|Gs|Af|Gss|A|Bﬀ|As
|Bf|Ass|B|Bs|Bss
CHAPTER 2. SIMPLE MUSIC 30
Details: All of the names to the right of the equal sign in a datadeclaration
are called constructors , and must be capitalized. In this way they are syntactically
distinguishedfromordinaryvalues. Thisdistinctionisusefulsinceonlyconstructors
can be used in the pattern matching that is part of a function deﬁnition, as will
be described shortly.
ThePitchClass data type declaration essentially enumerates 35 pitch
class names (ﬁve for each of the note names A through G). Note that both
double-sharps and double-ﬂats are included, resulting in many enharmonics(i.e., two notes that “sound the same,” such as G /sharpand A/flat).
Keep in mind that PitchClass is a completely new, user-deﬁned data
type that is not equal to any other. This is what distinguishes a data
declaration from a typedeclaration. As another example of the use of a
datadeclaration to deﬁne a simple enumerated type, Haskell’s Boolean data
type, called Bool, is predeﬁned in Haskell simply as:
dataBool=False|True
2.2 Notes, Music, and Polymorphism
One can of course deﬁne other data types for other purposes. For example,
one will want to deﬁne the notion of a noteand arest.B o t ho ft h e s ec a n
be thought of as “primitive” musical values, and thus as a ﬁrst attempt onemight write:
dataPrimitive =Note Dur Pitch
|Rest Dur
For example, Note qn a440 would be concert A played as a quarter note,
andRest1i saw h o l e - n o t er e s t .
This deﬁnition is not completely satisfactory, however, because one may
wish to attach other information to a note, such as its loudness, or someother annotation or articulation. Furthermore, the pitch itself may actuallybe a percussive sound, having no true pitch at all. To resolve this, Euterpeauses an important concept in Haskell, namely polymorphism —the ability
to parameterize, or abstract, over types ( polymeansmanyandmorphism
refers to the structure, or form, of objects). Primitive can be redeﬁned as a
polymorphic data type as follows.
Instead of ﬁxing the type of the pitch of a note, it is left unspeciﬁed
CHAPTER 2. SIMPLE MUSIC 31
through the use of a type variable :
dataPrimitive a =Note Dur a
|Rest Dur
Note that the type variable ais used as an argument to Primitive ,a n d
then used in the body of the declaration—just like a variable in a function.This version of Primitive is more general than the previous version—indeed,
note that Primitive Pitch is the same as (or, technically, is isomorphic to )
the previous version of Primitive . But additionally, Primitive is now more
ﬂexible than the previous version, since, for example, one can add loudness
by pairing loudness with pitch, as in Primitive (Pitch,Loudness ). Other
concrete instances of this idea will be introduced later.
Another way to interpret this data declaration is to say that for any type
a, this declaration declares the types of its constructors to be:
Note::Dur→a→Primitive a
Rest::Dur→Primitive a
Even though NoteandRestare called data constructors, they are still func-
tions, and they have a type. Since they both have type variables in theirtype signatures, they are examples of polymorphic functions .
Note that one can think of polymorphism as applying the abstraction
principle at the type level—indeed it is often called type abstraction .M a n y
more examples of both polymorphic functions and polymorphic data typeswill be explored in detail in Chapter 3.
So far Euterpea’s primitive notes and rests have been introuced—but
how does one combine many notes and rests into a larger composition? Toachieve this, Euterpea deﬁnes another polymorphic data type, perhaps themost important data type used in this textbook, which deﬁnes the funda-mental structure of a note-level musical entity:
dataMusic a =
Prim(Primitive a )- - p r i m i t i v e v a l u e
|Music a :+:Music a -- sequential composition
|Music a :=:Music a -- parallel composition
|Modify Control (Music a)- - m o d i ﬁ e r
Following the reasoning above, the types of these constructors are:
Prim::Primitive a →Music a
(:+:) :: Music a →
Music a →Music a
(:=:) :: Music a →Music a →Music a
Modify::Control→Music a →Music a
CHAPTER 2. SIMPLE MUSIC 32
These four constructors then are also polymorphic functions.
Details: Note the use of the inﬁx constructors (:+:)and(:=:).I n ﬁ xc o n s t r u c -
tors are just like inﬁx operators in Haskell, but they must begin with a colon. This
syntactic distinction makes it clear when one is pattern matching, and is analogousto the distinction between ordinary names (which must begin with a lower-case
character) and constructor names (which must begin with an upper-case charac-
ter).
The observant reader will also recall that at the very beginning of this chapter—
corresponding to the module containing all the code in this chapter—the following
line appeared:
inﬁxr5:+:,:=:
This is called a ﬁxity declaration .T h e“r”a f t e rt h ew o r d“ inﬁx” means that the
speciﬁed operators—in this case (:+:)and(:=:)—are to have rightassociativity,
and the “5” speciﬁes their precedence level (these operators will bind more tightly
than an operator with a lower precedence).
TheMusicdata type declaration essentially says that a value of type
Music a has one of four possible forms:
•Prim p,w h e r epis a primitive value of type Primitive a ,f o rs o m e
typea. For example:
a440m::Music Pitch
a440m=Prim(Note qn a440 )
is the musical value corresponding to a quarter-note rendition of con-
cert A.
•m1:+:m2is thesequential composition ofm1andm2; i.e.m1andm2
are played in sequence.
•m1:=:m2is theparallel composition ofm1andm2; i.e.m1andm2are
played simultaneously. The duration of the result is the duration of
the longer of m1andm2.
(Recall that these last two operators were introduced in the last chap-
ter. Youcan seenowthattheyareactually constructorsofanalgebraic
data type.)
•Modify cntrl m is an “annotated” version of min which the control
parameter cntrlspeciﬁes some way in which mis to be modiﬁed.
CHAPTER 2. SIMPLE MUSIC 33
Details: Note that Music a is deﬁned in terms of Music a, and thus the data
type is said to be recursive (analogous to a recursive function). It is also often
called an inductive data type, since it is, in essence, an inductive deﬁnition of an
inﬁnite number of values, each of which can be arbitrarily complex.
It is convenient to represent these musical ideas as a recursive datatype
because it allows one to not only construct musical values, but also take
them apart, analyze their structure, print them in a structure-preserving
way, transform them, interpret them for performance purposes, and so on.Many examples of these kinds of processes will be seen in this textbook.
TheControl data type is used by the Modifyconsructor to allow one
to annotate a Musicvalue with a tempo change ,atransposition ,aphrase
attribute,aplayer name ,o ra ninstrument . This data type is unimportant
at the moment, but for completeness here is its full deﬁnition:
dataControl=
Tempo Rational -- scale the tempo
|Transpose AbsPitch -- transposition
|Instrument InstrumentName -- instrument label
|Phrase [PhraseAttribute ] -- phrase attributes
|Player PlayerName -- player label
typePlayerName =String
AbsPitch (“absolute pitch,” deﬁned in Section 2.4) is just a type synonym
forInt. Instrument names are borrowed from the General MIDI standard,
and are captured as an algebraic data type in Figure 2.1. Phrase attributes
and the concept of a “player” are closely related, but a full explanation isdeferred until Chapter 8.
2.3 Convenient Auxiliary Functions
For convenience, and in anticipation of their frequent use, a number of func-
tions are deﬁned in Euterpea to make it easier to write certain kinds ofmusical values. For starters:
note ::Dur→a→Music a
note d p =Prim(Note d p )
rest ::Dur→Music a
CHAPTER 2. SIMPLE MUSIC 34
dataInstrumentName =
AcousticGrandPiano |BrightAcousticPiano |ElectricGrandPiano
|HonkyTonkPiano |RhodesPiano |ChorusedPiano
|Harpsichord |Clavinet |Celesta
|Glockenspiel |MusicBox |Vibraphone
|Marimba |Xylophone |TubularBells
|Dulcimer |HammondOrgan |PercussiveOrgan
|RockOrgan |ChurchOrgan |ReedOrgan
|Accordion |Harmonica |TangoAccordion
|AcousticGuitarNylon |AcousticGuitarSteel |ElectricGuitarJazz
|ElectricGuitarClean |ElectricGuitarMuted |OverdrivenGuitar
|DistortionGuitar |GuitarHarmonics |AcousticBass
|ElectricBassFingered |ElectricBassPicked |FretlessBass
|SlapBass1 |SlapBass2 |SynthBass1
|SynthBass2 |Violin |Viola
|Cello |Contrabass |TremoloStrings
|PizzicatoStrings |OrchestralHarp |Timpani
|StringEnsemble1 |StringEnsemble2 |SynthStrings1
|SynthStrings2 |ChoirAahs |VoiceOohs
|SynthVoice |OrchestraHit |Trumpet
|Trombone |Tuba |MutedTrumpet
|FrenchHorn |BrassSection |SynthBrass1
|SynthBrass2 |SopranoSax |AltoSax
|TenorSax |BaritoneSax |Oboe
|Bassoon |EnglishHorn |Clarinet
|Piccolo |Flute |Recorder
|PanFlute |BlownBottle |Shakuhachi
|Whistle |Ocarina |Lead1Square
|Lead2Sawtooth |Lead3Calliope |Lead4Chiﬀ
|Lead5Charang |Lead6Voice |Lead7Fifths
|Lead8BassLead |Pad1NewAge |Pad2Warm
|Pad3Polysynth |Pad4Choir |Pad5Bowed
|Pad6Metallic |Pad7Halo |Pad8Sweep
|FX1Train |FX2Soundtrack |FX3Crystal
|FX4Atmosphere |FX5Brightness |FX6Goblins
|FX7Echoes |FX8SciFi |Sitar
|Banjo |Shamisen |Koto
|Kalimba |Bagpipe |Fiddle
|Shanai |TinkleBell |Agogo
|SteelDrums |Woodblock |TaikoDrum
|MelodicDrum |SynthDrum |ReverseCymbal
|GuitarFretNoise |BreathNoise |Seashore
|BirdTweet |TelephoneRing |Helicopter
|Applause |Gunshot |Percussion
|Custom String
Figure 2.1: General MIDI Instrument Names
CHAPTER 2. SIMPLE MUSIC 35
rest d =Prim(Rest d)
tempo ::Dur→Music a →Music a
tempo r m =Modify(Tempo r )m
transpose ::AbsPitch →Music a →Music a
transpose i m =Modify(Transpose i )m
instrument ::InstrumentName →Music a →Music a
instrument i m =Modify(Instrument i )m
phrase ::[PhraseAttribute ]→Music a →Music a
phrase pa m =Modify(Phrase pa )m
player ::PlayerName →Music a →Music a
player pn m =Modify(Player pn )m
Note that each of these functions is poymorphic, a trait inherited from the
data types that it uses. Also recall that the ﬁrst two of these functions were
used in an example in the last chapter.
One can also create simple names for familiar notes, durations, and rests,
as shown in Figures 2.2and2.3. Despite the large number of them, these
names are suﬃciently “unusual” that name clashes are unlikely.
Details: Figures2.2and2.3demonstrate that at the top level of a program,
more than one equation can be placed on one line, as long as they are separatedby a semicolon. This allows one to save vertical space on the page, and is useful
whenever each line is relatively short. The semicolon is not needed at the end of
a single equation, or at the end of the last equation on a line. This convenient
feature is part of Haskell’s layoutrule, and will be explained in more detail later.
More than one equation can also be placed on one line in a letexpression, as
demonstrated below:
letx=1 ;y=2
inx+y
2.3.1 A Simple Example
As a simple example, suppose one wishes to generate a ii-V-I chord progres-
sion in a particular key. In music theory, such a chord progression beginswith a minor chord on the second degree of a major scale, followed by amajor chord on the ﬁfth degree, and ending in a major chord on the ﬁrst
CHAPTER 2. SIMPLE MUSIC 36
cﬀ,cf,c,cs,css,dﬀ,df,d,ds,dss,eﬀ,ef,e,es,ess,ﬀf,ﬀ,f,
fs,fss,gﬀ,gf,g,gs,gss,aﬀ,af,a,as,ass,bﬀ,bf,b,bs,bss::
Octave→Dur→Music Pitch
cﬀ o d=note d(Cﬀ,o);cf o d=note d(Cf,o)
co d=note d(C,o);cs o d=note d(Cs,o)
css o d=note d(Css,o);dﬀ o d=note d(Dﬀ,o)
df o d=note d(Df,o);do d=note d(D,o)
ds o d=note d(Ds,o);dss o d=note d(Dss,o)
eﬀ o d=note d(Eﬀ,o);ef o d=note d(Ef,o)
eo d=note d(E,o);es o d=note d(Es,o)
ess o d=note d(Ess,o);ﬀf o d=note d(Fﬀ,o)
ﬀo d=note d(Ff,o);fo d=note d(F,o)
fs o d=note d(Fs,o);fss o d=note d(Fss,o)
gﬀ o d=note d(Gﬀ,o);gf o d=note d(Gf,o)
go d=note d(G,o);gs o d=note d(Gs,o)
gss o d=note d(Gss,o);aﬀ o d=note d(Aﬀ,o)
af o d=note d(Af,o);ao d=note d(A,o)
as o d=note d(As,o);ass o d=note d(Ass,o)
bﬀ o d=note d(Bﬀ,o);bf o d=note d(Bf,o)
bo d=note d(B,o);bs o d=note d(Bs,o)
bss o d=note d(Bss,o)
Figure 2.2: Convenient Note Names
CHAPTER 2. SIMPLE MUSIC 37
bn,wn,hn,qn,en,sn,tn,sfn,dwn,dhn,
dqn,den,dsn,dtn,ddhn,ddqn,dden::Dur
bnr,wnr,hnr,qnr,enr,snr,tnr,dwnr,dhnr,
dqnr,denr,dsnr,dtnr,ddhnr,ddqnr,ddenr::Music Pitch
bn=2 ;bnr=rest bn -- brevis rest
wn=1 ;wnr=rest wn -- whole note rest
hn=1/2;hnr=rest hn -- half note rest
qn=1/4;qnr=rest qn -- quarter note rest
en=1/8;enr=rest en -- eighth note rest
sn=1/16;snr=rest sn -- sixteenth note rest
tn=1/32;tnr=rest tn -- thirty-second note rest
sfn=1/64;sfnr=rest sfn -- sixty-fourth note rest
dwn=3/2;dwnr=rest dwn -- dotted whole note rest
dhn=3/4;dhnr=rest dhn -- dotted half note rest
dqn=3/8;dqnr=rest dqn -- dotted quarter note rest
den=3/16;denr=rest den -- dotted eighth note rest
dsn=3/32;dsnr=rest dsn -- dotted sixteenth note rest
dtn=3/64;dtnr=rest dtn -- dotted thirty-second note rest
ddhn=7/8;ddhnr=rest ddhn -- double-dotted half note rest
ddqn=7/16;ddqnr=rest ddqn -- double-dotted quarter note rest
dden=7/32;ddenr=rest dden -- double-dotted eighth note rest
Figure 2.3: Convenient Duration and Rest Names
CHAPTER 2. SIMPLE MUSIC 38
degree. One can write this in Euterpea, using triads in the key of C major,
as follows:
t251::Music Pitch
t251=letdMinor=d4wn:=:f4wn:=:a4wn
gMajor=g4wn:=:b4wn:=:d5wn
cMajor=c4bn:=:e4bn:=:g4bn
indMinor:+:gMajor:+:cMajor
Details: Note that more than one equation is allowedin a letexpression, just like
at the top level of a program. The ﬁrst characters of each equation, however, mustline up vertically, and if an equation takes more than one line then the subsequent
lines must be to the right of the ﬁrst characters. For example, this is legal:
leta=aLongName
+anEvenLongerName
b=5 6
in...
but neither of these are:
leta=aLongName
+anEvenLongerName
b=5 6
in...
leta=aLongName
+anEvenLongerName
b=5 6
in...
(The second line in the ﬁrst example is too far to the left, as is the third line in
the second example.)
CHAPTER 2. SIMPLE MUSIC 39
Details: Althoughthisrule, calledthe layout rule , mayseemabit ad hoc,i ta v oi d s
having to use special syntax to denote the end of one equation and the beginning
of the next (such as a semicolon), thus enhancing readability. In practice, use of
layout is rather intuitive. Just remember two things:
First, the ﬁrst character following let(and a few other keywords that will be
introduced later) is what determines the starting column for the set of equationsbeing written. Thus one can begin the equations on the same line as the keyword,
the next line, or whatever.
Second, be sure that the starting column is further to the right than the start-
ing column associated with any immediately surrounding letclause (otherwise it
would be ambiguous). The “termination”of an equation happens when somethingappears at or to the left of the starting column associated with that equation.
In order to play this simple example, one can use Euterpea’s playfunc-
tion and simply type:
play t251
at the GHCi command line. Default instruments and tempos are used to
convertt251into MIDI and then play the result through your computer’s
standard sound card.
Exercise 2.1 The above example is fairly concrete, in that, for one, it is
rooted in C major, and furthermore it has a ﬁxed tempo. Deﬁne a functiontwoFiveOne ::Pitch→Dur→Music Pitch such that twoFiveOne p d con-
structs a ii-V-I chord progression starting on the pitch p(which is assumed
to be the second degree of the major scale on which the progression is beingconstructed), where the duration of the ﬁrst two chords is each d,a n dt h e
duration of the last chord is 2 ∗d.
To verify your code, prove by calculation that twoFiveOne (D,4)wn=
t251.
2.4 Absolute Pitches
Treating pitches simply as integers is useful in many settings, so Euterpea
uses a type synonym to deﬁne the concept of an “absolute pitch:”
typeAbsPitch =Int
CHAPTER 2. SIMPLE MUSIC 40
The absolute pitch of a (relative) pitch can be deﬁned mathematically as 12
times the octave, plus the index of the pitch class. One can express this inHaskell as follows:
absPitch ::Pitch→AbsPitch
absPitch (pc,oct)=1 2∗oct+pcToInt pc
Details: Note the use of pattern matching to match the argument of absPitch
to a pair.
pcToInt is a function that converts a particular pitch class to an index,
easilybuttediouslyexpressedasshowninFigure 2.4. Butthereisasubtlety:
according to music theory convention, pitches are assigned integers in therange 0 to 11, i.e. modulo 12, starting on pitch class C. In other words, theindexof C is 0, C /flatis 11, and B /sharpis 0. However, that would mean the absolute
pitch of ( C,4), say, would be 48, whereas ( Cf,4) would be 59. Somehow the
latter does not seem right—47 would be a more logical choice. Thereforethe deﬁnition in Figure 2.4is written in such a way that the wrap-round
does not happen, i.e. numbers outside the range 0 to 11 are used. With thisdeﬁnition, absPitch (Cf,4) yields 47, as desired.
CHAPTER 2. SIMPLE MUSIC 41
pcToInt::PitchClass →Int
pcToInt Cﬀ =−2;pcToInt Dﬀ =0 ;pcToInt Eﬀ =2
pcToInt Cf =−1;pcToInt Df =1 ;pcToInt Ef =3
pcToInt C =0 ;pcToInt D =2 ;pcToInt E =4
pcToInt Cs =1 ;pcToInt Ds =3 ;pcToInt Es =5
pcToInt Css =2 ;pcToInt Dss =4 ;pcToInt Ess =6
pcToInt Fﬀ =3 ;pcToInt Gﬀ =5 ;pcToInt Aﬀ =7
pcToInt Ff =4 ;pcToInt Gf =6 ;pcToInt Af =8
pcToInt F =5 ;pcToInt G =7 ;pcToInt A =9
pcToInt Fs =6 ;pcToInt Gs =8 ;pcToInt As =1 0
pcToInt Fss =7 ;pcToInt Gss =9 ;pcToInt Ass =1 1
pcToInt Bﬀ =9
pcToInt Bf =1 0
pcToInt B =1 1
pcToInt Bs =1 2
pcToInt Bss =1 3
Figure 2.4: Converting Pitch Classes to Integers
Details: The repetition of “ pcToInt” above can be avoided by using a Haskell
caseexpression, resulting in a more compact deﬁnition:
pcToInt ::PitchClass →Int
pcToInt pc =casepcof
Cﬀ→−2;Cf→−1;C→0;Cs→1;Css→2;
Dﬀ→0;Df→1;D→2;Ds→3;Dss→4;
Eﬀ→2;Ef→3;E→4;Es→5;Ess→6;
Fﬀ→3;Ff→4;F→5;Fs→6;Fss→7;
Gﬀ→5;Gf→6;G→7;Gs→8;Gss→9;
Aﬀ→7;Af→8;A→9;As→10;Ass→11;
Bﬀ→9;Bf→10;B→11;Bs→12;Bss→13
As youcansee, a caseexpressionallowsmultiplepa ttern-matchesonanexpression
without using equations. Note that layout applies to the body of a case expression,and can be overriden as before using a semicolon. (As in a function type signature,
the right-pointing arrow in a caseexpression must be typed as “ ->”o ny o u r
computer keyboard.)
The body of a caseexpression observes layout just as a letexpression, including
the fact that semicolons can be used, as above, to place more than one patternmatch on the same line.
CHAPTER 2. SIMPLE MUSIC 42
Converting an absolute pitch to a pitch is a bit more tricky, because of
enharmonic equivalences. For example, the absolute pitch 15 might corre-s p o n dt oe i t h e r( Ds,1) or (Ef,1). Euterpea takes the approach of always
returning a sharp in such ambiguous cases:
pitch ::AbsPitch →Pitch
pitch ap =
let(oct,n)=divMod ap 12
in([C,Cs,D,Ds,E,F,Fs,G,Gs,A,As,B]!!n,oct)
Details: (!!)is Haskell’s zero-based list-indexing function; list!!nreturns the
(n+1)th element in list.divMod x n returns a pair (q,r),w h e r eqis the integer
quotient of xdivided by n,a n dris the value of xmodulon.
GivenpitchandabsPitch, it is now easy to deﬁne a function transthat
transposes pitches:
trans ::Int→Pitch→Pitch
trans i p =pitch(absPitch p +i)
With this deﬁnition, all of the operators and functions introduced in the
previous chapter have been covered.
Exercise 2.2 Show that abspitch (pitch ap)=ap, and, up to enharmonic
equivalences, pitch(abspitch p )=p.
Exercise 2.3 Show that trans i(trans j p )=trans(i+j)p.

Chapter 3
Polymorphic and
Higher-Order Functions
Several examples of polymorphic data types were introduced in the last
couple of chapters. In this chapter the focus is on polymorphic functions ,
which are most commonly functions deﬁned over polymorphic data types.
The already familiar listis the most common example of a polymorphic
data type, and it will be studied in depth in this chapter. Although listshave no direct musical connection, they are perhaps the most commonlyused data type in Haskell, and have many applications in computer music
programming. But in addition the Musicdata type is polymorphic, and sev-
eral new functions that operate on it polymorphiccally will also be deﬁned,
(A more detailed discussion of predeﬁned polymorphic functions that
operate on lists can be found in Appendix A.)
This chapter also introduces higher-order functions , which are functions
that take one or more functions as arguments or return a function as aresult (functions can also be placed in data structures). Higher-order func-tions permit the elegant and concise expression of many musical concepts.Together with polymorphism, higher-order functions substantially increasethe programmer’s expressive power and ability to reuse code.
Both of these new ideas naturally follow the foundations that have al-
ready been established.
43
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 44
3.1 Polymorphic Types
In previous chapters, examples of lists containing several diﬀerent kinds of
elements—integers, characters, pitch classes, and so on—were introduced,and one can well imagine situations requiring lists of other element types.Sometimes, however, it isn’t necessary to be so particular about the type ofthe elements. For example, suppose one wishes to deﬁne a function length
that determines the number of elements in a list. It doesn’t really matterwhether the list contains integers, pitch classes, or even other lists—one canimagine computing the length in exactly the same way in each case. The
obvious deﬁnition is:
length[] =0
length(x:xs)=1+length xs
This recursive deﬁnition is self-explanatory. One can read the equations as
saying: “The length of the empty list is 0, and the length of a list whoseﬁrst element is xand remainder is xsis 1 plus the length of xs.”
But what should the type of lengthbe? Intuitively, one would like to say
that, for anytypea,t h et y p eo f lengthis [a]→Integer.I nm a t h e m a t i c s
one might write:
length::(∀a)[a]→Integer
But in Haskell this is written simply as:
length::[a]→Integer
In other words, the universal quantiﬁcation of the type variable ais implicit.
Details: Generic names for types, such as aabove, are called type variables ,a n d
are uncapitalized to distinguish them from concrete types such as Integer.
Solengthcan be applied to a list containing elements of anytype. For
example:
length[1,2,3] = ⇒3
length[C,Cs,Df]=⇒3
length[[1],[],[2,3,4]]=⇒3
Note that the type of the argument to lengthin the last example is
[[Integer]]; that is, a list of lists of integers.
Here are two other examples of polymorphiclist functions, which happen
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 45
to be predeﬁned in Haskell:
head ::[a]→a
head(x:
)=x
tail ::[a]→[a]
tail(
:xs)=xs
Details: The
on the left-hand side of these equations is called a wildcard
pattern. It matches any value, and binds no variables. It is useful as a way ofdocumenting the fact that one does not care about the value in that part of thepattern. Note that one could (perhaps should) have used a wildcard in place ofthe variable xin the deﬁnition of length.
These two functions take the “head” and “tail,” respectively, of any
non-empty list. For example:
head[1,2,3]⇒1
head[C,Cs,Df]⇒C
tail[1,2,3]⇒[2,3]
tail[C,Cs,Df]⇒[Cs,Df]
Note that, for any non-empty list xs,headandtailobey the following law:
head xs:tail xs=xs
Functions such as length,head,a n dtailare said to be polymorphic .
Polymorphic functions arise naturally when deﬁning functions on lists andother polymorphic data types, including the Musicdata type deﬁned in the
last chapter.
3.2 Abstraction Over Recursive Deﬁnitions
Given a list of pitches, suppose one wishes to convert each pitch into anabsolute pitch. One might write a function:
toAbsPitches ::[Pitch]→[AbsPitch ]
toAbsPitches [] =[]
toAbsPitches (p:ps)=absPitch p :toAbsPitches ps
One might also want to convert a list of absolute pitches to a list of
pitches:
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 46
toPitches ::[AbsPitch ]→[Pitch]
toPitches [] =[]
toPitches (a:as)=pitch a:toPitches as
These two functionsare diﬀerent, butshare something in common: there
is a repeating pattern of operations. But the pattern is not quite like anyof the examples studied earlier, and therefore it is unclear how to apply theabstraction principle. What distinguishes this situation is that there is arepeating pattern of recursion .
In discerning the nature of a repeating pattern, recall that it’s sometimes
helpful to ﬁrst identify those things that are notrepeating—i.e. those things
that arechanging —since these will be the sources of parameterization :t h o s e
values that must be passed as arguments to the abstracted function. Inthe case above, these changing values are the functions absPitch andpitch;
consider them instances of a new name, f. Rewriting either of the above
functions as a new function—call it map—that takes an extra argument f,
yields:
map f[] =[]
map f(x:xs)=fx:map f xs
This recursive pattern of operations is so common that mapis predeﬁned in
Haskell (and is why the name mapwas chosen in the ﬁrst place).
Withmap, one can now redeﬁne toAbsPitches andtoPitches as:
toAbsPitches ::[Pitch]→[AbsPitch ]
toAbsPitches ps =map absPitch ps
toPitches ::[AbsPitch ]→[Pitch]
toPitches as =map pitch as
Note that these deﬁnitions are non-recursive; the common pattern of recur-
sion has been abstracted away and isolated in the deﬁnition of map.T h e y
are also very succinct; so much so, that it seems unnecessary to create newnames for these functions at all! One of the powers of higher-order functions
is that they permit concise yet easy-to-understand deﬁnitions such as this,
and you will see many similar examples throughout the remainder of the
text.
A proof that the new versions of these two functions are equivalent to
the old ones can be done via calculation, but requires a proof techniquecalledinduction , because of the recursive nature of the original function
deﬁnitions. Inductive proofs are discussed in detail, including for these twoexamples, in Chapter 10.
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 47
3.2.1 Map is Polymorphic
What should the type of mapbe? Looking ﬁrst at its use in toAbsPitches ,
note that it takes the function absPitch ::Pitch→AbsPitch as its ﬁrst
argument and a list of Pitchs as its second argument, returning a list of
AbsPitch sa si t sr e s u l t .S oi t st y p em u s tb e :
map::(Pitch→AbsPitch )→[Pitch]→[AbsPitch ]
Yet a similar analysis of its use in toPitches reveals that map’s type should
be:
map::(AbsPitch →Pitch)→[AbsPitch ]→[Pitch]
Thisapparentanomalycanberesolvedbynotingthat map, likelength,head,
andtail, does not really care what its list element types are, as long as its
functional argument can be applied to them . Indeed, mapispolymorphic ,
and its most general type is:
map::(a→b)→[a]→[b]
This can be read: “ mapis a function that takes a function from any type a
to any type b, and a list of a’s, and returns a list of b’s.” The correspon-
dence between the two a’s and between the two b’s is important: a function
that converts Int’s toChar’s, for example, cannot be mapped over a list of
Char’s. It is easy to see that in the case of toAbsPitches ,ais instantiated
asPitchandbasAbsPitch ,w h e r e a si n toPitches ,aandbare instantiated
asAbsPitch andPitch, respectively.
Note, by the way, that the above reasoning can be viewed as the abstrac-
tion principle at work at the type level.
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 48
Details: In Chapter 1it was mentioned that every expression in Haskell has an
associated type. But with polymorphism, one might wonder if there is just one
type for every expression. For example, mapcould have any of these types:
(a→b)→[a]→[b]
(Integer→b)→[Integer]→[b]
(a→Float)→[a]→[Float]
(Char→Char)→[Char]→[Char]
and so on, depending on how it will be used. However, notice that the ﬁrst of
these types is in some fundamental sense more general than the other three. Infact, every expression in Haskell has a unique type known as its principal type :
the least general type that captures all valid uses of the expression. The ﬁrst typeabove is the principal type of map, since it captures all valid uses of map,y e ti s
less general than, for example, the type a→b→c. As another example, the
principal type of headis[a]→a;t h et y p e s [b]→a,b→a,o re v e n aare
too general, whereas something like [Integer]
→Integeris too speciﬁc. (The
existence of unique principal types is the hallmark feature of the Hindley-Milner
type system [Hin69,Mil78] that forms the basis of the type systems of Haskell,
ML [MTH90] and several other functional languages [ Hud89].)
3.2.2 Using map
For a musical example involving the use of map, consider the task of gener-
ating a six-note whole-tone scale starting at a given pitch:1
wts::Pitch→[Music Pitch ]
wts p=letfa p=note qn(pitch(absPitch p +ap))
inmap f[0,2,4,6,8]
For example:
wts a440
=⇒[note qn(A,4),note qn(B,4),note qn(C#,4),
note qn(D#,4),note qn(F,4),note qn(G,4)]
[To do: Add exercises involving map. ]
1A whole-tone scale is a sequence of six ascending notes, with each adjacent pair of
notes separated by two semitones, i.e. a whole note.
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 49
3.3 Append
Consider now the problem of concatenating orappending two lists together;
that is, creating a third list that consists of all of the elements from the ﬁrstlist followed by all of the elements of the second. Once again the type oflist elements does not matter, so one can deﬁne this as a polymorphic inﬁxoperator (+ +):
(++)::[a]→[a]→[a]
For example, here are two uses of (+ +) on diﬀerent types:
[1,2,3]++[4,5,6] =⇒[1,2,3,4,5,6]
[C,E,G]++[D,F,A]=⇒[C,E,G,D,F,A]
As usual, one can approach this problem by considering the various
possibilities that could arise as input. But in the case of (+ +) there are two
inputs—so which should be considered ﬁrst? In general this is not an easyquestion to answer, so one could just try the ﬁrst list ﬁrst: it could be empty,or non-empty. If it is empty the answer is easy:
[]++ys=ys
and if it is not empty the answer is also straightforward:
(x:xs)++ys=x:(xs++ys)
Note the recursive use of (+ +). The full deﬁnition is thus:
(++) ::[
a]→[a]→[a]
[] ++ys=ys
(x:xs)++ys=x:(xs++ys)
Details: Note that an inﬁx operator can be deﬁned just as any other function,
including pattern-matching, except that on the left-hand-side it is written using
its inﬁx syntax.
Also be aware that this textbook takes liberty in typesetting by displaying the
append operator as ++. When you type your code, however, you will need to write
++. Recall that inﬁx operators in Haskell must not contain any numbers or letters
of the alphabet, and also must not begin with a colon (because those are reservedto be inﬁx constructors).
If one were to have considered instead the second list ﬁrst, then the ﬁrst
equation would still be easy:
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 50
xs++[]=xs
but the second is not so obvious:
xs++(y:ys)=? ?
So it seems that the right choice was made to begin with.
Likemap, the concatenation operator (+ +) is used so often that it is
predeﬁned in Haskell.
3.3.1 [Advanced] The Eﬃciency and Fixity of Append
In Chapter 10the following simple property about (+ +) will be proved:
(xs++ys)++zs=xs++(ys++zs)
That is, (+ +) isassociative .
But what about the eﬃciency of the left-hand and right-hand sides of
this equation? It is easy to see via calculation that appending two lists
together takes a number of steps proportional to the length of the ﬁrst list(indeed the second list is not evaluated at all). For example:
[1,2,3]++xs
⇒1:([2,3]++xs)
⇒1:2:([3]+ +xs)
⇒1:2:3:([]+ +xs)
⇒1:2:3:xs
Therefore the evaluation of xs++(ys++zs) takes a number of steps propor-
tional to the length of xsplus the length of ys. But what about ( xs++ys)++
zs? The leftmost append will take a number of steps proportional to the
length of xs, but then the rightmost append will require a number of steps
proportional to the length of xsplus the length of ys, for a total cost of:
2∗length xs +length ys
Thusxs++(ys++zs) is more eﬃcient than ( xs+
+ys)++zs.T h i si sw h yt h e
Standard Prelude deﬁnes the ﬁxity of (+ +) as:
inﬁxr5++
In other words, if you just write xs++ys++zs, you will get the most eﬃcient
association, namely the right association xs++(ys++zs). In the next section
a more dramatic example of this property will be introduced.
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 51
3.4 Fold
Supposeone wishesto take alist of notes (each of type Music a) and convert
them into a line,o rmelody. One can deﬁne a recursive function to do this:
line ::[Music a]→Music a
line[] = rest0
line(m:ms)=m:+:line ms
Note that this function is polymorphic—the ﬁrst example so far, in fact, of
a polymorphic function involving the Musicdata type.
One might also wish to have a function chordthat operates in an anal-
ogous way, but using (:=:) instead of (:+:):
chord ::[Music a]→Music a
chord[] = rest0
chord(m:ms)=m:=:chord ms
This function is also polymorphic.
[To do: Consider alternative to maxPitch , since it is more properly
deﬁned with fold1.]
In a completely diﬀerent context one might wish to compute the highest
pitch in a list of pitches, which one might capture in the following way:
maxPitch ::[Pitch]→Pitch
maxPitch [] = pitch0
maxPitch (p:ps)=p!!!maxPitch ps
where (!!!) is deﬁned as:
p1!!!p2=ifabsPitch p 1>absPitch p 2thenp1elsep2
Details: An expression ifpredthenconselsealtis called a conditional expres-
sion.I fpred(called the predicate ) is true, then cons(called the consequence )i s
the result; if predis false, then alt(called the alternative )i st h er e s u l t .
Once again this is a situation where several deﬁnitions share something
in common: a repeating recursive pattern. Using the process used earlier todiscover map, one ﬁrst identiﬁes those things that are changing. There are
two situations: the rest0a n dpitch0 values (for which the generic name
init, for “initial value,” will be used), and the (:+:), (:=:), and (!!!) operators
(for which the generic name op, for “operator,” will be used). Now rewriting
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 52
any of the above three functions as a new function—call it fold—that takes
extra arguments opandinit, one arrives at:2
fold op init [] = init
fold op init (x:xs)=x‘op‘fold op init xs
Details: Any normal binary function name can be used as an inﬁx operator by
enclosing it in backquotes; x‘f‘yis equivalent to fxy. Using inﬁx application
here for opbetter reﬂects the structure of the repeating pattern that is being
abstracted, but could also have been written op x(fold op init xs ).
With this deﬁnition of foldone can now rewrite the deﬁnitions of line,
chord,a n dmaxPitch as:
line,chord::[Music a]→Music a
line ms =fold(:+:) (rest0)ms
chord ms =fold(:=:) (rest0)ms
maxPitch ::[Pitch]→Pitch
maxPitch ps =fold(!!!) (pitch0)ps
Details: Just as one can turn a function into an operator by enclosing it in
backquotes, onecan turnan operatorintoa functionbyenclosingit inparentheses.
This is required in order to pass an operator as a value to another function, as
in the examples above. (If one wrote fold!!! 0psinstead of fold(!!!) 0psit
would look like one were trying to compare foldto0ps, which is nonsensical and
ill-typed.)
In Chapter 10, induction is used to prove that these new deﬁnitions are
equivalent to the old ones.
fold, likemap, is a highly useful—reusable—function, as will be seen
through several other examples later in the text. Indeed, it too is polymor-phic, for note that it does not depend on the type of the list elements. Itsmost general type—somewhat trickier than that for map—is:
2The use of the name “ fold” for this function is historical, and has nothing to do with
the use of “fold” and “unfold” in Chapter 1to describe steps in a calculation.
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 53
fold::(a→b→b)→b→[a]→b
Thisallowsonetouse foldwheneveroneneedsto“collapse” alistofelements
using a binary (i.e. two-argument) operator.
As a ﬁnal example, recall the deﬁnition of hListfrom Chapter 1:
hList ::Dur→[Pitch]→Music Pitch
hList d[] = rest0
hList d(p:ps)=hNote d p :+:hList d ps
A little thought should convince the reader that this can be rewritten as:
hList d ps =letfp=hNote d p
inline(map f ps )
One could argue that this is more modular, since it avoids explicit recursion,
and is instead built up from smaller buildingblocks, namely line(which uses
fold)a n dmap.
3.4.1 Haskell’s Folds
Haskell actually deﬁnes two versions of foldin the Standard Prelude. The
ﬁrst is called foldr(“fold-from-the-right”) whose deﬁnition is the same as
that offoldgiven earlier:
foldr ::(a→b→b)→b→[a]→b
foldr op init [] = init
foldr op init (x:xs)=x‘op‘foldr op init xs
A good way to think about foldris that it replaces all occurrences of the
list operator (:) with its ﬁrst argument (a function), and replaces [] with itssecond argument. In other words:
foldr op init (x
1:x2:...:xn:[])
=⇒x1‘op‘(x2‘op‘(...(xn‘op‘init)...))
This might help in better understanding the type of foldr, and also explains
its name: the list is “folded from the right.” Stated another way, for anylistxs, the following always holds:
3
foldr(:) []xs=⇒xs
Haskell’s second version of foldis called foldl:
foldl ::(b→a→b)→b→[a]→b
foldl op init [] = init
foldl op init (x:xs)=foldl op(init‘op‘x)xs
3This will be formally proved in Chapter 10.
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 54
A good way to think about foldlis to imagine “folding the list from the
left:”
foldl op init (x1:x2:...:xn:[])
=⇒(...((init‘op‘x1)‘op‘x2)...)‘op‘xn
3.4.2 [Advanced] Why Two Folds?
Note that if one had used foldlinstead of foldrin the deﬁnitions given earlier
then not much would change; foldrandfoldlwould give the same result.
Indeed, judging from their types, it looks like the only diﬀerence betweenfoldrandfoldlis that the operator takes its arguments in a diﬀerent order.
So why does Haskell deﬁne two versions of fold? It turns out that there
are situations whereusingoneis moreeﬃcient, and possibly“more deﬁned,”
than the other (that is, the function terminates on more values of its input
domain) .
Probably the simplest example of this is a generalization of the asso-
ciativity of (+ +) discussed in the last section. Suppose that one wishes to
collapse a list of lists into one list. The Standard Prelude deﬁnes the poly-morphic function concatfor this purpose:
concat ::[[a]]→[a]
concat xss =foldr(++) []xss
For example:
concat[[1],[3,4],[],[5,6]]
=⇒[1,3,4,5,6]
More importantly, from the earlier discussion it should be clear that this
property holds:
concat[xs
1,xs2,...,xsn]
⇒foldr(++) [] [xs1,xs2,...,xsn]
=⇒xs1++(xs2++(...(xn++[]))...)
The total cost of this computation is proportional to the sum of the lengths
of all of the lists. If each list has the same length len,a n dt h e r ea r e nlists,
then this cost is ( n−1)∗len.
On the other hand, if one had deﬁned concatthis way:
slowConcat xss =foldl(++) []xss
then:
slowConcat [xs1,xs2,...,xsn]
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 55
⇒foldl(++) [] [xs1,xs2,...,xsn]
=⇒(...(([]++x1)++x2)...)++xn
If each list has the same length len, then the cost of this computation will
be:
len+(len+len)+(len+len+len)+...+(n−1)∗len
=n∗(n−1)∗len/2
which is considerably worse than ( n−1)∗len. Thus the choice of foldrin
the deﬁnition of concatis quite important.
Similar examples can be given to demonstrate that foldlis sometimes
more eﬃcient than foldr. On the other hand, in many cases the choice does
not matter at all (consider, for example, (+)). The moral of all this is thatcare must be taken in the choice between foldrandfoldlif eﬃciency is a
concern.
3.4.3 Fold for Non-empty Lists
In certain contexts it may be understood that the functions lineandchord
should not be applied to an empty list. For such situations the StandardPreludeprovidesfunctions foldr1andfoldl1, whichreturnanerrorifapplied
to an empty list. And thus one may desire to deﬁne versions of lineand
chordthat adopt this behavior:
line1,chord1::[Music a]→Music a
line1 ms =foldr1(:+:)ms
chord1 ms =foldr1(:=:)ms
Note that foldr1andfoldl1do not take an initargument.
I nt h ec a s eo f maxPitch one could go a step further and say that the
previous deﬁnition is in fact ﬂawed, for who is to say what the maximumpitch of an empty list is? The choice of 0 was indeed arbitrary, and in away it is nonsensical—how can 0 be the maximum if it is not even in thelist? In such situations one might wish to deﬁne only one function, and tohave that function return an error when presented with an empty list. Forconsistency with lineandchord, however, that function is deﬁned here with
an e wn a m e :
maxPitch1 ::[Pitch]→Pitch
maxPitch1 ps =foldr1(!!!)ps
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 56
3.5 [Advanced] A Final Example: Reverse
As a ﬁnal example of a useful list function, consider the problem of reversing
a list, which will be captured in a function called reverse. This could be use-
ful, for example, when constructing the retrograde of a musical passage, i.e.
the music as if it were played backwards. For example, reverse[C,Cs,Df]
is [Df,Cs,C].
Thusreversetakes a single list argument, whose possibilities are the
normal ones for a list: it is either empty, or it is not. And thus:
reverse ::[a]→[a]
reverse[] =[]
reverse(x:xs)=reverse xs ++[x]
This, in fact, is a perfectly good deﬁnition for reverse—it is certainly clear—
except for one small problem: it is terribly ineﬃcient! To see why, ﬁrst recallthat the number of steps needed to compute xs++ysis proportional to the
length of xs. Now suppose that the list argument to reversehas length n.
T h er e c u r s i v ec a l lt o reversewill return a list of length n−1, which is the
ﬁrst argument to (+ +). Thus the cost to reverse a list of length of nwill be
proportional to n−1 plus the cost to reverse a list of length n−1. So the
total cost is proportional to ( n−1)+(n−2)+···+1=n(n−1)/2, which
in turn is proportional to the square of n.
Can one do better than this? In fact, yes.
There is another algorithm for reversing a list, which can be described
intuitively as follows: take the ﬁrst element, and put it at the front of anempty auxiliary list; then take the next element and add it to the front of theauxiliary list (thus the auxiliary list n ow consists of the ﬁrst two elements
in the original list, but in reverse order); then do this again and again untilthe end of the original list is reached. At that point the auxiliary list willbe the reverse of the original one.
Thisalgorithm can beexpressed recursively, butthe auxiliary list implies
that one needsa function that takes twoarguments—the original list and the
auxiliary one—yet reverseonly takes one. This can be solved by creating
an auxiliary function rev:
reverse xs =letrev acc[] = acc
rev acc(x:xs)=rev(x:acc)xs
inrev[]xs
The auxiliary list is the ﬁrst argument to rev, and is called accsince it
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 57
behaves as an “accumulator” of the intermediate results. Note how it is
returned as the ﬁnal result once the end of the original list is reached.
A little thought should convince the reader that this function does not
have the quadratic ( n2) behavior of the ﬁrst algorithm, and indeed can be
shown to execute a number of steps that is directly proportional to thelength of the list, which one can hardly expect to improve upon.
But now, compare the deﬁnition of revwith the deﬁnition of foldl:
foldl op init [] = init
foldl op init (x:xs)=foldl op(init‘op‘x)xs
They are somewhat similar. In fact, suppose one were to slightly rewrite
rev, yielding:
rev op acc [] = acc
rev op acc (x:xs)=rev op(acc‘op‘x)xs
Nowrevlooks strongly like foldl, and the question becomes whether or not
there is a function that can be substituted for opthat would make the latter
deﬁnition of revequivalent to the former one. Indeed there is:
revOp a b =b:a
For note that:
acc‘revOp‘x
⇒revOp acc x
⇒x:acc
Soreversecan be rewritten as:
reverse xs =letrev op acc [] = acc
rev op acc (x:xs)=rev op(acc‘op‘x)xs
inrev revOp []
xs
which is the same as:
reverse xs =foldl revOp []xs
If all of this seems like magic, well, you are starting to see the beauty of
functional programming!
3.6 Currying
One can improve further upon some of the deﬁnitions given in this chapterusing a technique called currying simpliﬁcation . To understand this idea,
ﬁrst look closer at the notation used to write function applications, such as
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 58
simple x y z . Although, as noted earlier, this is similar to the mathematical
notation simple(x,y,z), in fact there is an important diﬀerence, namely that
simple x y z is actually shorthand for ((( simple x )y)z). In other words,
function application is left associative , taking one argument at a time.
Now look at the expression ((( simple x )y)z)ab i tc l o s e r :t h e r ei sa n
application of simpletox, the result of which is applied to y;s o(simple x)
must be a function! The result of this application, (( simple x )y), is then
applied to z,s o( (simple x)y) must also be a function!
Since each of these intermediate applications yields a function, it seems
perfectly reasonable to deﬁne a function such as:
multSumByFive =simple5
What is simple5? From the above argument it is clear that it must be a
function. Andfromthedeﬁnitionof simplein Section 1onemight guessthat
this function takes two arguments, and returns 5 times their sum. Indeed,one cancalculate this result as follows:
multSumByFive a b
⇒(simple5)ab
⇒simple5ab
⇒5∗(a+b)
The intermediate step with parentheses is included just for clarity. This
method of applying functions to one argument at a time, yielding interme-diate functions along the way, is called currying, after the logician Haskell
B. Curry who popularized the idea.
4It is helpful to look at the types of the
intermediate functions as arguments are applied:
simple ::Float→Float→Float→Float
simple5: :Float→Float→Float
simple5a::Float→Float
simple5ab::Float
For a musical example of this idea, recall the function note::Dur→
Pitch→Music Pitch .S onote qnis a function that, given a pitch, yields a
quarter noterendition ofthat pitch. Acommon useofthisidea issimplifying
something like:
note qn p 1:+:note qn p 2:+:...:+:note qn pn
to:
4It was actually Sch¨ onﬁnkelwho ﬁrst called attention to this idea [ Sch24], but the word
“sch¨onﬁnkellin g” is rather a mouthful!
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 59
line(map(note qn)[p1,p2,...,pn])
Indeed,thisideaisusedextentivelyinthelargerexampleinthenextchapter.
3.6.1 Currying Simpliﬁcation
One can also use currying to improve some of the previous function deﬁni-
tions as follows. Suppose that the expressions fxandgxare the same,
for all values of x. Then it seems clear that the functions fandgare
equivalent.5So, if one wishes to deﬁne fin terms of g, instead of writing:
fx=gx
one could instead simply write:
f=g
One can Apply this reasoning to the deﬁnitions of lineandchordfrom
Section3.4:
line ms =fold(:+:) (rest0)ms
chord ms =fold(:=:) (rest0)ms
Since function application is left associative, one can rewrite these as:
line ms =(fold(:+:) (rest0))ms
chord ms =(fold(:=:) (rest0))ms
But now applying the same reasoning here as was used for fandgabove
means that one can write these simply as:
line=fold(:+:) (rest0)
chord=fold(:=:) (rest0)
Similarly, the deﬁnitions of toAbsPitches andtoPitches from Section 3.2:
toAbsPitches ps =map absPitch ps
toPitches as =map pitch as
can be rewritten as:
toAbsPitches =map absPitch
toPitches =map pitch
Furthermore, the deﬁnition hList, most recently deﬁned as:
hList d ps =letfp=hNote d p
inline(map f ps )
can be rewritten as:
5In mathematics, one would say that the two functions are extensionally equivalent.
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 60
hList d ps =letf=hNote d
inline(map f ps )
and since the deﬁnition of fis now so simple, one might as well in-line it:
hList d ps =line(map(hNote d)ps)
This kind of simpliﬁcation will be referred to as “currying simpliﬁcation”
or just “currying.”6
Details: Some care should be taken when using this simpliﬁcation idea. In
particular, note that an equation such as fx=gxyx cannot be simpliﬁed
tof=gxy, since then the remaining xon the right-hand side would become
undeﬁned!
3.6.2 [Advanced] Simpliﬁcation of reverse
Here is a more interesting example, in which currying simpliﬁcation is used
three times. Recall from Section 3.5the deﬁnition of reverseusingfoldl:
reverse xs =letrevOp acc x =x:acc
infoldl revOp []xs
Usingthepolymorphicfunction ﬂipwhichisdeﬁnedintheStandardPrelude
as:
ﬂip ::(a→b→c)→(b→a→c)
ﬂip f x y =fyx
it should be clear that revOpcan be rewritten as:
revOp acc x =ﬂip(:)acc x
But now currying simpliﬁcation can be used twice to reveal that:
revOp=ﬂip(:)
This, along with a third use of currying, allows one to rewrite the deﬁnition
ofreversesimply as:
reverse=foldl(ﬂip(:)) []
This is in fact the way reverseis deﬁned in the Standard Prelude.
Exercise 3.1 Show that ﬂip(ﬂip f)i st h es a m ea s f.
6In the Lambda Calculus this is called “eta contraction.”
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 61
Exercise 3.2 What is the type of ysin:
xs=[1,2,3]::[Integer]
ys=map(+)xs
Exercise 3.3 Deﬁne a function applyEach that, given a list of functions,
applies each to some given value. For example:
applyEach [simple22,(+3)] 5 = ⇒[14,8]
wheresimpleis as deﬁned in Chapter 1.
Exercise 3.4 Deﬁne a function applyAll that, given a list of functions
[f1,f2,...,fn] and a value v, returns the result f1(f2(...(fn v)...)). For exam-
ple:
applyAll [simple22,(+3)] 5 = ⇒20
Exercise 3.5 Recall the discussion about the eﬃciency of (+ +) andconcat
in Chapter 3. Which of the following functions is more eﬃcient, and why?
appendr,appendl::[[a]]→[a]
appendr =foldr(ﬂip(++)) []
appendl =foldl(ﬂip(++)) []
3.7 Errors
The last section suggested the idea of “returning an error” when the argu-
ment to foldr1is the empty list. As you might imagine, there are other
situations where an error result is also warranted.
There are many ways to deal with such situations, depending on the ap-
plication, but sometimes one wishes to literally stop the program, signallingto the user that some kind of an errorhas occurred. In Haskell this is done
with the Standard Prelude function error::String→a.N o t et h a t erroris
polymorphic, meaning that it can be used with any data type. The value ofthe expression error sis⊥, the completely undeﬁned, or “bottom” value.
As an example of its use, here is the deﬁnition of foldr1from the Standard
Prelude:
foldr1 ::(a→a→a)→[a]→a
foldr1 f[x]=x
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 62
foldr1 f(x:xs)=fx(foldr1 f xs )
foldr1 f[] = error "Prelude.foldr1: empty list"
Thus if the anomalous situation arises, the program will terminate immedi-
ately, and the string "Prelude.foldr1: empty list" will be printed.
Exercise 3.6 Rewrite the deﬁnition of lengthnon-recursively.
Exercise 3.7 Deﬁne a function that behaves as each of the following:
a) Doubles each number in a list. For example:
doubleEach [1,2,3]=⇒[2,4,6]
b) Pairs each element in a list with that number and one plus that number.
For example:
pairAndOne [1,2,3]=⇒[(1,2),(2,3),(3,4)]
c) Adds together each pair of numbers in a list. For example:
addEachPair [(1,2),(3,4),(5,6)] =⇒[3,7,11]
d) Adds “pointwise” the elements of a list of pairs. For example:
addPairsPointwise [(1,2),(3,4),(5,6)] =⇒(9,12)
In the next two exercises, give both recursive and (if possible) non-
recursive deﬁnitions, and be sure to include type signatures.
Exercise 3.8 Deﬁne a function maxAbsPitch that determines the maxi-
mum absolute pitch of a list of absolute pitches. Deﬁne minAbsPitch anal-
ogously. Both functions should return an error if applied to the empty list.
Exercise 3.9 Deﬁneafunction chrom::Pitch→Pitch→Music Pitch such
thatchrom p 1p2is a chromatic scale of quarter-notes whose ﬁrst pitch is
p1and last pitch is p2.I fp1>p2, the scale should be descending, otherwise
it should be ascending. If p1==p2, then the scale should contain just one
note. (A chromatic scale is one whose successive pitches are separated byone absolute pitch (i.e. one semitone)).
Exercise 3.10 Abstractly, ascalecan bedescribedbytheintervalsbetween
successive notes. For example, the 7-note major scale can be deﬁned as the
CHAPTER 3. POLYMORPHIC & HIGHER-ORDER FUNCTIONS 63
sequence of 6 intervals [2 ,2,1,2,2,2], and the 12-note chromatic scale by the
11 intervals [1 ,1,1,1,1,1,1,1,1,1,1]. Deﬁne a function mkScale ::Pitch→
[Int]→Music Pitch such that mkScale p ints is thescale beginningat pitch
pand having the intervallic structure ints.
Exercise 3.11 Deﬁne an enumerated data type that captures each of the
standard major scale modes: Ionian, Dorian, Phrygian, Lydian, Mixolydian,Aeolian, and Locrian. Then deﬁne a function genScale that, given one
of these contructors, generates a scale in the intervalic form described inExercise 3.10.
Exercise 3.12 Write the melody of “Fr` ere Jacques” (or, “Are You Sleep-
ing”) in Euterpea. Try to make it as succinct as possible. Then, using
functions already deﬁned, generate a traditional four-part round, i.e. four
identical voices, each delayed successively by two measures. Use a diﬀerentinstrument to realize each voice.
Exercise 3.13 Freddie the Frog wants to communicate privately with his
girlfriend Francine by encrypting messages sent to her. Frog brains are
not that large, so they agree on this simple strategy: each character inthe text shall be converted to the character “one greater” than it, based
on the representation described below (with wrap-around from 255 to 0).
Deﬁne functions encryptanddecryptthat will allow Freddie and Francine
to communicate using this strategy.
Characters are often represented inside a computer as some kind of an
integer; in the case of Haskell, a 16-bit unicode representation is used. How-ever, the standard keyboard is adequately represented by a standard byte(eight bits), and thus one only needs to consider the ﬁrst 256 codes in theunicode representation. For this exercise, you will want to use two Haskellfunctions, toEnum andfromEnum . The ﬁrst will convert an integer into a
character, the second will convert a character into an integer.
Chapter 4
A Musical Interlude
At this point enough detail about Haskell and Euterpea has been covered
that itisworth developing asmallbutfullapplication ortwo. Inthischapteran existing composition will be transcri bedinto Euterpea, thus exemplifying
how to express conventional musical ideas in Euterpea. Then a simple formof algorithmic composition will be presented, where it will become apparentthat more exotic things can easily be expressed as well.
But before tackling either of these, Haskell’s modules will be described
in more detail.
4.1 Modules
Haskell programs are partitioned into modules that capture common types,
functions, etc. that naturally comprise an application. The ﬁrst part of amodule is called the module header, and in it one declares what the name of
the moduleis, and whatother modules it might import. For this chapter the
module’s name is Interlude , into which the module Euterpea is imported:
module Euterpea .Examples .Interlude where
importEuterpea
Details: Module names must always be capitalized (just like type names).
64
CHAPTER 4. A MUSICAL INTERLUDE 65
If one wishes to use this module in another module M,i tm a yb ei m -
portedinto M, just as was done above in importing Euterpea intoInterlude :
module Mwhere
importInterlude
This will make available in Mall of the names of functions, types, and so
on that were deﬁned at the top-level of Interlude .
But this isn’t always what the programmer would like. Another purpose
of a module is to manage the overall name space of an application. Modules
allow one to structure an application in such a way that only the functional-
ity intended for the end user is visible—everything else needed to implementthe system is eﬀectively hidden. In the case of Interlude , there are only a
few names whose visibillity is desirable: childSong6 , ..., and .... This can be
achieved by writing the module header as follows:
module Interlude (childSong6 ,...)where
importEuterpea
This set of visible names is sometimes called the export list of the module.
And if type signatures are included, as in:
module Interlude (childSong6 ::Music Pitch )where
importEuterpea
the list of names is sometimes called the interface to the module. If the list
is omitted, as was done initially, then allnames deﬁned at the top-level of
the module are exported.
There are many other rules concerning the import and export of names
to and from modules. Rather than introduce them all at once, they will beintroduced as needed in future chapter.
4.2 Transcribing an Existing Score
Figure4.1shows the ﬁrst28 bars of Chick Corea’s Child Song No. 6 , written
for electric piano. Analyzing this tune explores several basic issues that arisein the transcription of an existing score into Euterpea, including repeatingphrases, grace notes, triplets, tempo, and specifying an instrument. Tobegin, however, a couple of auxiliary functions are deﬁned to make the jobeasier.
CHAPTER 4. A MUSICAL INTERLUDE 66
Figure 4.1: Excerpt from Chick Corea’s Child Song No. 6
CHAPTER 4. A MUSICAL INTERLUDE 67
4.2.1 Auxiliary Functions
For starters, note that there are several repeating patterns of notes in this
composition, each enclosed in a rectangle in Figure 4.1. In fact, the bass
line consists entirelyof three repeating phrases. In anticipation of this, a
function can be deﬁned that repeats a phrase a particular number of times:
timesM ::Int→Music a →Music a
timesM0m=rest0
timesM n m =m:+:timesM(n−1)m
Details: Note that pattern-matching can be used on numbers. As mentioned
earlier, when there is more than one equation that deﬁnes a function, the ﬁrstequation is tried ﬁrst. If it fails, the second equation is tried, and so on. In thecase above, if the ﬁrst argument to timesM is not 0, the ﬁrst equation will fail.
The second equation is then tried, which always succeeds.
So, for example, timesM3b1will repeat the baseline b1(to be deﬁned
shortly) three times.
To motivate the second auxiliary function, note in Figure 4.1that there
are many melodic lines that consist of a sequence of consecutive notes havingthe same duration (for example eighth notes in the melody, and dottedquarter notes in the bass). To avoid having to write each of these durationsexplicitly, a function that speciﬁes them just once is deﬁned. To do this,
recall that a4qnis a concert A quarter note. Then note that, because of
currying, a4 is a function that can be applied to any duration—i.e. its type
isDur→Music a. In other words, it’s a note whose duration hasn’t been
speciﬁed yet.
With this thought in mind, one can return to the original problem and
deﬁne a function that takes a duration and a listof notes with the afore-
mentioned type, returning a Musicvalue with the duration attached to each
note appropriately. In Haskell:
addDur ::Dur→[Dur→Music a]→Music a
addDur d ns =letfn=nd
inline(map f ns )
Finally, a function to add a grace note to a note is deﬁned. Grace notes
can approach the principal note from above or below; sometimes starting a
CHAPTER 4. A MUSICAL INTERLUDE 68
half-step away, and sometimes a whole step; and having a rhythmic inter-
pretation that is to a large extent up to the performer. In the case of thesix uses of grace notes in Child Song No. 6 , the assumption will be that the
grace note begins on the downbeat of the principal note, and thus its dura-tion will subtract from that of the principal note. It will also be assumedthat the grace note duration is 1/8 of that of the principal note. Thus thegoal is to deﬁne a function:
graceNote ::Int→Music Pitch →Music Pitch
such that graceNote n (note d p )i saMusicvalue consisting of two notes,
the ﬁrst being the grace note whose duration is d/8 and whose pitch is n
semitones higher (or lower if nis negative) than p, and the second being the
principal note at pitch pbut now with duration 7 d/8. In Haskell:
graceNote n (Prim(Note d p )) =
note(d/8) (trans n p ): + :note(7∗d/8)p
graceNote n
=
error "Can only add a grace note to a note."
Note that pattern-matching is performed against the nested constructors of
PrimandNote—one cannot match against the application of a function
such asnote. Also note the error message—programs are not expected to
ever apply graceNote to something other than a single note.
(In Chapter 6a slightly more general form of graceNote will be deﬁned.)
The only special cases that will not be handled using auxiliary functions
are the single staccato on note four of bar ﬁfteen, and the single portamentoon note three of bar sixteen. These situations will be addressed diﬀerentlyin a later chapter.
4.2.2 Bass Line
With these auxilary functions now deﬁned, the base line in Figure 4.1can be
deﬁned by ﬁrst noting the three repeating phrases (enclosed in rectangularb o x e s ) ,w h i c hc a nb ec a p t u r e da sf o l l o w s :
b
1=addDur dqn [b3,fs4,g4,fs4]
b2=addDur dqn [b3,es4,fs4,es4]
b3=addDur dqn [as3,fs4,g4,fs4]
UsingtimesMit is then easy to deﬁne the entire 28 bars of the base line:
bassLine =timesM3b1:+:timesM2b2:+:
timesM4b3:+:timesM5b1
CHAPTER 4. A MUSICAL INTERLUDE 69
4.2.3 Main Voice
The upper voice of this composition is a bit more tedious to deﬁne, but is
still straightforward. At the highest level, it consists of the phrase v1in the
ﬁrst two bars (in the rectangular box) repeated three times, followed by theremaining melody, which will be named v
2:
mainVoice =timesM3v1:+:v2
The repeating phrase v1is deﬁned by:
v1=v1a:+:graceNote (−1) (d5qn): + :v1b-- bars 1-2
v1a=addDur en [a5,e5,d5,fs5,cs5,b4,e5,b4]
v1b=addDur en [cs5,b4]
Note the treatment of the grace note.
The remainder of the main voice, v2, is deﬁned in seven pieces:
v2=v2a:+:v2b:+:v2c:+:v2d:+:v2e:+:v2f:+:v2g
with each of the pieces deﬁned in Figure 4.2.N o t et h a t :
•The phrases are divided so as to (for the most part) line up with bar
lines, for convenience. But it may be that this is not the best way toorganize the music—for example, one could argue that the last twonotes in bar 20 form a pick-up to the phrase that follows, and thusmore logically fall with that following phrase. The organization of theEuterpea code in this way is at the discretion of the composer.
•The stacatto is treated by playing the qurater note as an eighth note;
theportamento isignored. Asmentioned earlier, theseornamentationswill be addressed diﬀerently in a later chapter.
•The triplet of eighth notes in bar 25 is addressed by scaling the tempo
by a factor of 3 /2.
4.2.4 Putting It All Together
In the Preface to Children’s Songs – 20 Pieces for Keyboard [Cor94], Chick
Coreanotesthat,“Songs1through15werecomposedfortheFenderRhodes.”Therefore the MIDI instrument RhodesPiano is a logical choice for the
transcription of his composition. Furthermore, note that a dotted half-note is speciﬁed to have a metronome value of 69. By default, the play
function in Euterpea uses a tempo equivalent to a quarter note having a
CHAPTER 4. A MUSICAL INTERLUDE 70
v2a=line[cs5(dhn+dhn),d5dhn,
f5hn,gs5qn,fs5(hn+en),g5en]- - b a r s 7 - 1 1
v2b=addDur en [fs5,e5,cs5,as4]:+:a4dqn:+:
addDur en [as4,cs5,fs5,e5,fs5] -- bars 12-13
v2c=line[g5en,as5en,cs6(hn+en),d6en,cs6en]: + :
e5en:+:enr:+:
line[as5en,a5en,g5en,d5qn,c5en,cs5en]
-- bars 14-16
v2d=addDur en [fs5,cs5,e5,cs5,
a4,as4,d5,e5,fs5] -- bars 17-18.5
v2e=line[graceNote 2(e5qn),d5en,graceNote 2(d5qn),cs5en,
graceNote 1(cs5qn),b4(en+hn),cs5en,b4en]
-- bars 18.5-20
v2f=line[fs5en,a5en,b5(hn+qn),a5en,fs5en,e5qn,
d5en,fs5en,e5hn,d5hn,fs5qn] -- bars 21-23
v2g=tempo(3/2) (line[cs5en,d5en,cs5en]):+:
b4( 3∗dhn+hn) -- bars 24-28
Figure 4.2: Bars 7-28
metronome value of 120. Therefore the tempo should be scaled by a factor
of (dhn/qn)∗(69/120).
These two observations lead to the ﬁnal deﬁnition of the transcription
ofChildren’s Song No. 6 into Euterpea:
childSong6 ::Music Pitch
childSong6 =lett=(dhn/qn)∗(69/120)
ininstrument RhodesPiano
(tempo t(bassLine :=:mainVoice ))
Theintent isthat thisistheonly value thatwill beof interest to usersof this
module, and thus childSong6 is the only name exported from this section of
the module, as discussed in Section 4.1.
This example can be played through the command play childSong6 .
Exercise 4.1 Find a simple piece of music written by your favorite com-
poser, and transcribe it into Euterpea. In doing so, look for repeating pat-terns, transposed phrases, etc. and reﬂect this in your code, thus revealingdeeper structural aspects of the music than that found in common practicenotation.
CHAPTER 4. A MUSICAL INTERLUDE 71
4.3 Simple Algorithmic Composition
TBD
Chapter 5
Syntactic Magic
This chapter introduces several more of Haskell’s syntactic devices that fa-
ciliate writing concise and intuitive programs. These devices will be usedfrequently in the remainder of the text.
5.1 Sections
The use of currying was introduced in Chapter 3as a way to simplify pro-
grams. Thisisasyntactic devicethatreliesontheway thatnormalfunctionsare applied, and how those applications are parsed.
With a bit more syntax, one can also curryapplications of inﬁxoperators
such as (+). This syntax is called a section, and the idea is that, in an
expression such as ( x+y), one can omit either the xor they, and the result
(with the parentheses still intact) is a function of that missing argument.Ifbothvariables are omitted, it is a function of twoarguments. In other
words, the expressions ( x+), (+y) and (+) are equivalent, respectively, to
the functions:
f
1y=x+y
f2x=x+y
f3xy=x+y
For example, suppose one wishes to remove all absolute pitches greater
than 99 from a list, perhaps because everything above that value is assumedto be unplayable. There is a pre-deﬁned function in Haskell that can helpto achieve this:
72
CHAPTER 5. SYNTACTIC MAGIC 73
ﬁlter::(a→Bool)→[a]→[a]
ﬁlter p xs returns a list for which each element xsatisﬁes the predicate p;
i.e.pxisTrue.
Usingﬁlter, one can then write:
playable ::[AbsPitch ]→[AbsPitch ]
playable xs =lettest ap=ap<100
inﬁlter test xs
But using a section, one can write this more succinctly as:
playable ::[AbsPitch ]→[AbsPitch ]
playable xs =ﬁlter(<100)xs
which can be further simpliﬁed using currying:
playable::[AbsPitch ]→[AbsPitch ]
playable =ﬁlter(<100)
This is an extremely concise deﬁnition. As you gain experience with
higher-order functions you will not only be able to start writing deﬁnitionssuch as this directly, but you will also start thinking in “higher-order” terms.
Many more examples of this kind of reasoning will appear throughout thetext.
Exercise 5.1 Deﬁne a function twicethat, given a function f, returns a
function that applies ftwice to its argument. For example:
(twice(+1)) 2⇒4
What is the principal type of twice? Describe what twice twice does, and
give an example of its use. Also consider the functions twice twice twice and
twice(twice twice )?
Exercise 5.2 Generalize twicedeﬁned in the previous exercise by deﬁning
a function powerthat takes a function fand an integer n, and returns a
function that applies the function fto its argument ntimes. For example:
power(+2) 5 1 = ⇒11
Usepoweri nam u s i c a lc o n t e x tt od e ﬁ n es o m e t h i n gu s e f u l .

CHAPTER 5. SYNTACTIC MAGIC 74
5.2 Anonymous Functions
Another way to deﬁne a function in Haskell is in some sense the most funda-
mental: it is called an anonymous function ,o rlambda expression (since the
concept is drawn directly from Church’slambda calculus [ Chu41]). The idea
is that functions are values, just like numbers and characters and strings,and therefore there should be a way to create them without having to givethem a name. As a simple example, an anonymous function that incre-ments its numeric argument by one can be written λx→x+1. Anonymous
functions are most useful in situations where you don’t wish to name them,
which is why they are called “anonymous.” Anonymity is a property also
shared by sections, but sections can only be derived from an existing inﬁxoperator.
Details: The typesetting used in this textbook prints an actual Greek lambda
character, but in writing λx→x+1in your programs you will have to type
“\x -> x+1 ”i n s t e a d .
As another example, to raise the pitch ofevery element in a list of pitches
psby an octave, one could write:
map(λp→pitch(absPitch p +12))ps
An even better example is an anonymous function that pattern-matches its
argument, as in the following, which doubles the duration of every note ina list of notes ns:
map(λ(Note d p )→Note(2∗d)p)ns
Details: Anonymous functions can only perform one match against an argument.
That is, you cannot stack together several anonymous functions to deﬁne onefunction, as you can with equations.
Anonymous functions are considered most fundamental because deﬁni-
t i o n ss u c ha st h a tf o r simplegiven in Chapter 1:
simple x y z =x∗(y+z)
can be written instead as:
CHAPTER 5. SYNTACTIC MAGIC 75
simple=λxyz→x∗(y+z)
Details: λxyz→expis shorthand for λx→λy→λz→exp.
One can also use anonymous functions to explain precisely the behavior
of sections. In particular, note that:
(x+)⇒λy→x+y
(+y)⇒λx→x+y
(+)⇒λxy→x+y
Exercise 5.3 Suppose one deﬁnes a function ﬁxas:
ﬁx f=f(ﬁx f)
What is the principal type of ﬁx? (This is tricky!) Suppose further that one
has a recursive function:
remainder ::Integer→Integer→Integer
remainder a b =ifa<bthena
elseremainder (a−b)b
Rewrite this function using ﬁxso that it is not recursive. (Also tricky!) Do
you think that this process can be applied to anyrecursive function?
5.3 List Comprehensions
Haskell has a convenient and intuitive way to deﬁne a list in such a way that
it resembles the deﬁnition of a setin mathematics. For example, recall in
the last chapter the deﬁnition of the function addDur:
addDur ::Dur→[Dur→Music a]→Music a
addDur d ns =letfn=nd
inline(map f ns )
Herensis a list of notes, each of which does nothave a duration yet assigned
to it. If one thinks of this as a set, one might be led to write the followingsolution in mathematical notation:
{nd|n∈ns}
CHAPTER 5. SYNTACTIC MAGIC 76
which can be read, “the set of all notes ndsuch that nis an element of ns.”
Indeed, using a Haskell list comprehension one can write almost exactly the
same thing:
[nd|n←ns]
Thediﬀerence, of course, is that the above expression generates an (ordered)
list in Haskell, not an (unordered) set in mathematics.
List comprehensions allow one to rewrite the deﬁnition of addDurmuch
more succinctly and elegantly:
addDur ::Dur→[Dur→Music a]→Music a
addDur d ns =line[nd|n←ns]
Details: Liberty is again taken in type-setting by using the symbol ←to mean “is
an element of.” When writing your programs, you will have to type “ <-”i n s t e a d .
The expression [exp|x←xs]is actually shorthand for the expression map(λx→
exp)xs.T h ef o r m x←xsis called a generator , and in general more than one is
allowed, as in:
[(x,y)|x←[0,1,2],y←[’a’,’b’]]
which evaluates to the list:
[(0,’a’),(0,’b’),(1,’a’),(1,’b’),(2,’a’),(2,’b’)]
The order here is important; that is, note that the left-most generator changes
least quickly.
It is also possible to ﬁltervalues as they are generated; for example, one can
modify the above example to eliminate the odd integers in the ﬁrst list:
[(x,y)|x←[0,1,2],even x,y←[’a’,’b’]]
whereeven nreturnsTrueifnis even. This example evaluates to:
[(0,’a’),(0,’b’),(2,’a’),(2,’b’)]
CHAPTER 5. SYNTACTIC MAGIC 77
Details: When reasoning about list comprehensions (e.g. when doing proof by
calculation), one can use the following syntactic translation into pure functions:
[e|True]= [ e]
[e|q]= [ e|q,True]
[e|b,qs]= ifbthen[e|qs]else[]
[e|p←xs,qs]=letok p=[e|qs]
ok
=[]
inconcatMap ok xs
[e|letdecls,qs]=letdecls in[e|qs]
whereqis asinglequaliﬁer, qsis asequenceofqualiﬁers, bis a Boolean, pis a pat-
tern, and declsis a sequence of variable bindings (a feature of list comprehensions
not explained earlier).
5.3.1 Arithmetic Sequences
Another convenient syntax for lists whose elements can be enumerated is
called an arithmetic sequence . For example, the arithmetic sequence [1 ..10]
is equivalent to the list:
[1,2,3,4,5,6,7,8,9,10]
There are actually four diﬀerent versions of arithmetic sequences, some of
which generate inﬁnitelists (whose use will be discussed in a later chapter).
In the following, let a=n/prime−n:
[n..] -- inﬁnite list n,n+1,n+2, ...
[n,n/prime..] -- inﬁnite list n,n+a,n+2∗a, ...
[n..m] -- ﬁnite list n,n+1,n+2, ...,m
[n,n/prime..m] -- ﬁnite list n,n+a,n+2∗a, ...,m
Arithmetic sequences are discussed in greater detail in Appendix B.
Exercise 5.4 Using list comprehensions, deﬁne a function:
apPairs::[AbsPitch ]→[AbsPitch ]→[(AbsPitch ,AbsPitch )]
such that apPairs aps1aps2is a list of all combinations of the absolute
pitches in aps1andaps2. Furthermore, for each pair ( ap1,ap2)i nt h er e s u l t ,
the absolute value of ap1−ap2must be greater than two and less than eight.
Finally, write a function to turn the result of apPairsinto aMusic Pitch
value by playing each pair of pitches in parallel, and stringing them alltogether sequentially. Try varying the rhythm by, for example, using an
CHAPTER 5. SYNTACTIC MAGIC 78
g f
y = f (g x) = (f ƕg) xxy
Figure 5.1: Gluing Two Functions Together
eighth note when the ﬁrst absolute pitch is odd, and a sixteenth note when
it is even, or some other criterion.
Test your functions by using arithemtic sequences to generate the two
lists of arguments given to apPairs.
5.4 Function Composition
An example of polymorphism that has nothing to do with data structures
arises from the desire to take two functions fandgand “glue them to-
gether,” yielding another function hthat ﬁrst applies gto its argument, and
then applies fto that result. This is called function composition (just as in
mathematics), and Haskell pre-deﬁnes a simple inﬁx operator ( ◦)t oa c h i e v e
it, as follows:
(◦): : ( b→c)→(a→b)→a→c
(f◦g)x=f(gx)
Details: The symbol for function composition is typeset in this textbook as ◦,
which is consistent with mathematical convention. When writing your programs,however, you will have to use a period, as in “ f.g”.
Note the type of the operator ( ◦); it is completely polymorphic. Note
alsothattheresultof theﬁrstfunctiontobeapplied—sometype b—mustbe
the same as the type of the argument to the second function to be applied.Pictorially, if one thinks of a function as a black box that takes input atone end and returns some output at the other, function composition is likeconnecting two boxes together, end to end, as shown in Figure 5.1.
The ability to compose functions using ( ◦) is quite handy. For example,
recall the last version of hList:
CHAPTER 5. SYNTACTIC MAGIC 79
hList d ps =line(map(hNote d)ps)
One can do two simpliﬁcations here. First, rewrite the right-hand side using
function composition:
hList d ps =(line◦map(hNote d))ps
Then, use currying simpliﬁcation:
hList d=line◦map(hNote d)
5.5 Higher-Order Thinking
It’s worth taking a deep breath here and contemplating what has been done
withhList, which has gone through quite a few transformations. Here is the
original deﬁnition given in Chapter 1:
hList d[] = rest0
hList d(p:ps)=hNote d p :+:hList d ps
Compare this to the deﬁnition above. You may be distressed to think that
you have to go through all of these transformations just to write a relativelysimple function! There are two points to make about this: First, you don’t
have to make anyof these transformations if you don’t want to. All of these
versions of hListare correct, and they all run about equally fast. They are
explained here for pedagogical purposes, so that you understand the full
power of Haskell. Second, with practice, you will ﬁnd that you can writethe concise higher-order versions of many functions straight away, withoutgoing through all of the steps presented here.
As mentioned earlier, one thing that helps is to start thinking in “higher-
order” terms. To facilitate thisway ofthinkingone can writetype signaturesthat reﬂect more closely their higher-order nature. For example, recall thesetype signatures for map,ﬁlter,a n d(◦):
map::(a→b)→[a]→[b]
ﬁlter::(a→Bool)→[a]→[a]
(◦): : (b→c)→(a→b)→a→c
Also recall that the arrow in function types is right associative. Therefore,
another completely equivalent way to write the above type signatures is:
map::(a→b)→([a]→[b
])
ﬁlter::(a→Bool)→([a]→[a])
(◦): : (b→c)→(a→b)→(a→c)
Although equivalent, these versions emphasize the fact that each of these
CHAPTER 5. SYNTACTIC MAGIC 80
functions returns a function as its result. mapessentially “lifts” a function
on elements to a function on lists of elements. ﬁlterconverts a predicate
into a function on lists. And ( ◦) returns a function that is the composition
of its two functional arguments.
So for example, using higher-order thinking, map(+12) is a function
that transposes a list of absolute pitches by one octave. ﬁlter(<100) is a
function that removes all absolute pitches greater than or equal to 100 (asdiscussed earlier). And therefore map(+12)◦ﬁlter(<100) ﬁrst does the
ﬁltering, and then does the transposition. All very consise and very natural
using higher-order thinking.
In the remainder of this textbook deﬁnitions such as this will be written
directly, using a small set of rich polymorphic functions such as foldl,map,
ﬁlter,(◦), and a few other functions drawn from the Standard Prelude and
other standard libraries.
5.6 Inﬁx Function Application
Haskell predeﬁnes an inﬁx operator to apply a function to a value:
f$x=fx
At ﬁrst this doesn’t seem very useful—after all, why wouldn’t one simply
writefxinstead of f$x?
But in fact this operator has a very useful purpose: eliminating paren-
theses! IntheStandardPrelude, ($) right associative, andto have thelowestprecedence level, via the ﬁxity declaration:
inﬁxr0$
Therefore, note that f(gx)i st h es a m ea s f$gx(remember that normal
function application always has higher precedence than inﬁx operator ap-plication), and f(x+1)isthesameas f$x+1. This “trick” is especially
useful when there is a sequence of nested, parenthesized expresssions. For
example, recall the following deﬁnition from the last chapter:
childSong6 =lett=(dhn/qn)∗(69/120)
ininstrument RhodesPiano
(tempo t(bassLine :=:mainVoice ))
One can write the last few lines a bit more clearly as follows:
childSong6 =lett=(dhn/qn)∗(69/120)
ininstrument RhodesPiano $
CHAPTER 5. SYNTACTIC MAGIC 81
tempo t $
bassLine :=:mainVoice
Or, on a single line, instead of:
instrument RhodesPiano (tempo t(bassLine :=:mainVoice ))
one can write:
instrument RhodesPiano $tempo t$bassLine :=:mainVoice
Exercise 5.5 The last deﬁnition of hListstill has an argument don the
left-hand side, and one occurence of don the right-hand side. Is there some
way to eliminate it using currying simpliﬁcation? (Hint: the answer is yes,
but the solution is a bit perverse, and is not recommended as a way to write
your code!)
Exercise 5.6 Useline,mapand ($) to give a concise deﬁnition of addDur.
Exercise 5.7 Rewrite this example:
map(λx→(x+1)/2)xs
using a composition of sections.
Exercise 5.8 Consider the expression:
map f(map g xs )
Rewrite this using function composition and a single call to map.T h e n
rewrite the earlier example:
map(λx→(x+1)/2)xs
a sa“ m a po fam a p ”( i . e .u s i n gt w om a p s ) .
Exercise 5.9 Go back to any exercises prior to this chapter, and simplify
your solutions using ideas learned here.
Exercise 5.10 Using higher-order functions introduced in this chapter, ﬁll
in the two missing functions, f1andf2, in the evaluation below so that it is
valid:
f1(f2(∗)[1,2,3,4])5⇒[5,10,15,20]

Chapter 6
More Music
module Euterpea .Music.Note.MoreMusic where
importEuterpea .Music.Note.Music
This chapter explores a number of simple musical ideas, and contributes
to a growing collection of Euterpea functions for expressing those ideas.
6.1 Delay and Repeat
One can delay the start of a music value simply by inserting a rest in frontof it, which can be packaged in a function as follows:
delayM ::Dur→Music a →Music a
delayM d m =rest d:+:m
WithdelayMitiseasytowritecanon-like structuressuchas m:=:delayM d m ,
a song written in rounds (see Exercise 3.12), and so on.
Recall fromChapter 4thefunction timesMthatrepeatsamusical phrase
a certain number of times:
timesM ::Int→Music a →Music a
timesM0m=rest0
timesM n m =m:+:timesM(n−1)m
More interestingly, Haskell’s non-strict semantics allows one to deﬁne
inﬁnitemusical values. For example, a musical value may be repeated ad
nauseam using this simple function:
repeatM ::Music a →Music a
82
CHAPTER 6. MORE MUSIC 83
repeatM m =m:+:repeatM m
Thus,forexample, aninﬁniteostinatocanbeexpressedinthisway, andthen
used in diﬀerent contexts that automatically extract only the portion thatis actually needed. Functions that create such contexts will be describedshortly.
6.2 Inversion and Retrograde
The notions of inversion, retrograde, retrograde inversion, etc. as used intwelve-tone theory are also easily captured in Euterpea. These terms areusually applied only to “lines” of notes, i.e. a melody (in twelve-tone theoryit is called a “row”). The retrograde of a line is simply its reverse—i.e. the
notes played in the reverse order. The inversion of a line is with respect
to a given pitch (by convention usually the ﬁrst pitch), where the intervalsbetween successive pitches are inverted, i.e. negated. If the absolute pitchof the ﬁrst note is ap,t h e ne a c hp i t c h pis converted into an absolute pitch
ap−(absPitch p −ap), in other words 2 ∗ap−absPitch p .
[To do: Put in an example. ]
To do all this in Haskell, a transformation from a line created by lineto
a list is deﬁned:
lineToList ::Music a →[Music a]
lineToList (Prim(Rest0)) = []
lineToList (n:+:ns)= n:lineToList ns
lineToList
=
error "lineToList: argument not created by function line"
Using this function it is then straightforward to deﬁne invert:
invert::Music Pitch →Music Pitch
invert m =
letl@(Prim(Note
r):
)=lineToList m
inv(Prim(Note d p )) =
note d(pitch(2∗absPitch r −absPitch p ))
inv(Prim(Rest d)) =rest d
inline(map inv l )
CHAPTER 6. MORE MUSIC 84
Details: The pattern l@(Prim(Note
r):
)is called an as pattern . It behaves
just like the pattern Prim(Note
r):
but additionally binds lto the value of a
successful match to that pattern. lcan then be used wherever it is in scope, such
as in the last line of the function deﬁnition.
WithlineToList andinvertit is then easy to deﬁne the remaining func-
tions via composition:
retro,retroInvert ,invertRetro ::Music Pitch →Music Pitch
retro =line◦reverse◦lineToList
retroInvert =retro◦invert
invertRetro =invert◦retro
Exercise 6.1 Show that retro◦retro,invert◦invert,a n dretroInvert ◦
invertRetro are the identity on values created by line.
Exercise 6.2 Deﬁne a function properRow ::Music Pitch →Boolthat de-
termines whether or not its argument is a “proper” twelve-tone row, mean-ing that: (a) it must have exactly twelve notes, and (b) each unique pitchclass is used exactly once (regardless of the octave). Enharmonically equiv-alent pitch classes are notconsidered unique. You may assume that the
Music Pitch value is generated by the function line, but note that rests are
allowed.
Exercise 6.3 Deﬁne a function retroPitches ::Music Pitch →Music Pitch
that reverses the pitches in a line, but maintains the durations in the sameorder from beginning to end. For example:
retroPitches (line[c4en,d4qn])
=⇒(line[d4en,c4qn])
6.3 Polyrhythms
For some rhythmical ideas, ﬁrst note that if mis a line of three eighth notes,
thentempo(3/2)mis atripletof eighth notes (recall that this idea was used
in Chapter 4). In fact tempocan be used to create quite complex rhythmical
patterns. For example, consider the “nested polyrhythms” shown in Figure
CHAPTER 6. MORE MUSIC 85
35 : 6 
4 : 3 
3
5 35 57 : 6 
3 3
Figure 6.1: Nested Polyrhythms (top: pr1; bottom: pr2)
6.1. They can be expressed naturally in Euterpea as follows (note the use
of aletclause in pr2to capture recurring phrases):
pr1,pr2::Pitch→Music Pitch
pr1p=tempo(5/6)
(tempo(4/3) (mkLn1pq n:+:
tempo(3/2) (mkLn3pe n:+:
mkLn2ps n:+:
mkLn1pq n): + :
mkLn1pq n): + :
tempo(3/2) (mkLn6pe n))
pr2p=
letm1=tempo(5/4) (tempo(3/2)m2:+:m2)
m2=mkLn3pe n
intempo(7/6) (m1:+:
tempo(5/4) (mkLn5pe n): + :
m1:+:
tempo(3/2)m2)
m k L nnpd =line$take n$repeat$note d p
CHAPTER 6. MORE MUSIC 86
Details: take n lst is the ﬁrst nelements of the list lst. For example:
take3[C,Cs,Df,D,Ds]=⇒[C,Cs,Df]
repeat x is the inﬁnite list of the same value x. For example:
take3(repeat42) =⇒[42,42,42]
To play polyrhythms pr1andpr2in parallel using middle C and middle
G, respectively, one can write:
pr12::Music Pitch
pr12=pr1(C,4):=:pr2(G,4)
6.4 Symbolic Meter Changes
One can implement the notion of “symbolic meter changes” of the form
“oldnote=newnote”(quarternote=dottedeighth, forexample)bydeﬁningan inﬁx function:
(=:=) :: Dur→Dur→Music a →Music a
old=:=new=tempo(new/old)
Of course, using the new function is not much shorter than using tempo
directly, but it may have mnemonic value.
6.5 Computing Duration
It is often desirable to compute the duration, in whole notes, of a musical
value; one can do so as follows:
dur ::Music a →Dur
dur(Prim(Note d
 )) = d
dur(Prim(Rest d)) = d
dur(m1:+:m2)= dur m 1+dur m 2
dur(m1:=:m2)= dur m 1‘max‘dur m 2
dur(Modify(Tempo r )m)=dur m/r
dur(Modify
 m)= dur m
The duration of a primitive value is obvious. The duration of m1:+:m2is the
sum of the two, and the duration of m1:=:m2is the maximum of the two.
The only tricky case is the duration of a music value that is modiﬁed by the
CHAPTER 6. MORE MUSIC 87
Tempoatttribute—in this case the duration must be scaled appropriately.
Note that the duration of a music value that is conceptually inﬁnite in
duration will be ⊥,s i n c edurwill not terminate. (Similary, taking the length
of an inﬁnite list is ⊥.) For example:
dur(repeatM (a4qn))
⇒dur(a4qn:+:repeatM (a4qn))
⇒dur(a4qn)+dur(repeatM (a4qn))
⇒qn+dur(repeatM (a4qn))
⇒qn+qn+dur(repeatM (a4qn))
⇒...
⇒⊥
6.6 Super-retrograde
Usingdurone can deﬁne a function revMthat reverses any Musicvalue
whose duration is ﬁnite (and is thus considerably more useful than retro
deﬁned earlier):
revM ::Music a →Music a
revM n@(Prim
)=n
revM(Modify c m )=Modify c (revM m)
revM(m1:+:m2)=revM m 2:+:revM m 1
revM(m1:=:m2)=
letd1=dur m 1
d2=dur m 2
in ifd1>d2thenrevM m 1:=:(rest(d1−d2): + :revM m 2)
else(rest(d2−d1): + :revM m 1):=:revM m 2
The ﬁrst three cases are easy, but the last case is a bit tricky. The
parallel constructor (:=:) implicitly begins each of its music values at the
same time. But if one is shorter than the other, then, when reversed, a rest
must be inserted before the shorter one, to account for the diﬀerence.
Note that revMof aMusicvalue whose duration is inﬁnite is ⊥.( S i m i -
lary, reversing an inﬁnite list is ⊥.)
CHAPTER 6. MORE MUSIC 88
6.7 Truncating Parallel Composition
Note that the duration of m1:=:m2is the maximum of the durations of m1
andm2(and thus if one is inﬁnite, so is the result). Sometimes one would
rather have the result be of duration equal to the shorter of the two. Thisis not as easy as it sounds, since it may require truncating the longer one inthe middle of a note (or notes).
The goal is to deﬁne a “truncating parallel composition” operator ( /=:),
but ﬁrst an auxiliary function cutwill be deﬁned such that cut d m is the
musical value m“cut short” to have at most duration d:
cut::Dur→Music a →Music a
cut d m |d/lessorequalslant0= rest0
cut d(Prim(Note oldD p )) =note(min oldD d )p
cut d(Prim(Rest oldD )) =rest(min oldD d )
cut d(m
1:=:m2)= cut d m 1:=:cut d m 2
cut d(m1:+:m2)= letm/prime1=cut d m 1
m/prime2=cut(d−dur m/prime1)m2
inm/prime1:+:m/prime2
cut d(Modify(Tempo r )m)=tempo r(cut(d∗r)m)
cut d(Modify c m )= Modify c (cut d m)
Note that cutis equipped to handle a Musicvalue of inﬁnite duration.
Withcut, the deﬁnition of ( /=:) is now straightforward:
(/=:) :: Music a →Music a →Music a
m1/=:m2=cut(min(dur m 1)(dur m 2)) (m1:=:m2)
Unfortunately, whereas cutcan handle inﬁnite-duration music values,
(/=:) cannot. This is because ( /=:) computes the duration of both of
its arguments, but if mhas inﬁnite duration, then dur m⇒⊥.I f , i n a
particular context, you know that only one of the two arguments is inﬁnite,and you know which one (say m
1), it is always possible to do the following:
cut(dur m 2)m1:=:m2
Exercise 6.4 Deﬁne a version of ( /=:) that shortens correctly when either
one or the other of its arguments is inﬁnite in duration. Assume that it is
not known ahead of time which one is inﬁnite.
Exercise 6.5 Deﬁne a version of ( /=:) that shortens correctly when either
one or the other or bothof its arguments are inﬁnite in duration. When
CHAPTER 6. MORE MUSIC 89
they are both inﬁnite, an inﬁnite-duration result is returned. (This is much
harder than the previous exercise.)
6.8 Trills
Atrillis an ornament that alternates rapidlybetween two (usuallyadjacent)
pitches. Two versions of a trill function will be deﬁned, both of whichtake the starting note and an interval for the trill note as arguments (theinterval is usually one or two, but can actually be anything). One versionwill additionally have an argument that speciﬁes how long each trill noteshould be, whereas the other will have an argument that speciﬁes how manytrills should occur. In both cases the total duration will be the same as theduration of the original note.
Here is the ﬁrst trill function:
trill::Int→Dur→Music Pitch →Music Pitch
trill i sDur (Prim(Note tDur p )) =
ifsDur/greaterorequalslanttDur thennote tDur p
elsenote sDur p :+:
trill(negate i)sDur
(note(tDur−sDur)(trans i p ))
trill i d(Modify(Tempo r )m)=tempo r(trill i(d∗r)m)
trill i d(Modify c m )= Modify c (trill i d m )
trill
=
error "trill: input must be a single note."
Using this function it is simple to deﬁne a version that starts on the trill
note rather than the start note:
trill/prime::Int→Dur→Music Pitch →Music Pitch
trill/primeis D u rm =trill(negate i)sDur(transpose i m )
The second way to deﬁne a trill is in terms of the number of subdivided
notes to be included in the trill. One can use the ﬁrst trill function to deﬁnethis new one:
trilln::Int→Int→Music Pitch →Music Pitch
trilln i nTimes m =trill i(dur m/fromIntegral nTimes )m
This, too, can be made to start on the other note.
trilln
/prime::Int→Int→Music Pitch →Music Pitch
trilln/primein T i m e sm =trilln(negate i)nTimes(transpose i m )
CHAPTER 6. MORE MUSIC 90
ssfMel::Music Pitch
ssfMel=line(l1++l2++l3++l4)
wherel1=[trilln25(bf6en),ef7en,ef6en,ef7en]
l2=[bf6sn,c7sn,bf6sn,g6sn,ef6en,bf5en]
l3=[ef6sn,f6sn,g6sn,af6sn,bf6en,ef7en]
l4=[trill2tn(bf6qn),bf6sn,denr]
starsAndStripes ::Music Pitch
starsAndStripes =instrument Flute ssfMel
Figure 6.2: Trills in Stars and Stripes Forever
Finally, a rollcan be implemented as a trill whose interval is zero. This
feature is particularly useful for percussion.
roll::Dur→Music Pitch →Music Pitch
rolln::Int→Music Pitch →Music Pitch
roll dur m =trill0dur m
r o l l nn T i m e sm =trilln0nTimes m
Figure6.2shows a nice use of the trill functions in encoding the opening
lines of John Philip Sousa’s Stars and Stripes Forever .
6.9 Grace Notes
Recall from Chapter 4the function graceNote to generate grace notes. A
more general version is deﬁned below, which takes a Rational argument
that speciﬁes that fraction of the principal note’s duration to be used for
the grace note’s duration:
grace::Int→Rational →Music Pitch →Music Pitch
grace n r (Prim(Note d p )) =
note(r∗d)(trans n p ): + :note((1−r)∗d)p
grace n r
 =
error "grace: can only add a grace note to a note"
Thusgrace n r (note d p)i saMusicvalue consisting of two notes, the ﬁrst
being the grace note whose duration is r∗dand whose pitch is nsemitones
higher (or lower if nis negative) than p, and the second being the principal
note at pitch pbut now with duration (1 −r)∗d.
Note that graceplaces the downbeat of the grace note at the point
written for the principal note. Sometimes the interpretation of a grace note
CHAPTER 6. MORE MUSIC 91
is such that the downbeat of the principal note is to be unchanged. In that
case, the grace note reduces the duration of the previous note. One can
deﬁne a function grace2that takes two notes as arguments, and places the
grace note appropriately:
grace2::Int→Rational →
Music Pitch →Music Pitch →Music Pitch
grace2 n r (Prim(Note d 1p1)) (Prim(Note d 2p2)) =
note(d1−r∗d2)p1:+:note(r∗d2)(trans n p 2): + :note d 2p2
grace2
 =
error "grace2: can only add a grace note to a note"
6.10 Percussion
Percussion is a diﬃcult notion to represent in the abstract. On one hand,
a percussion instrument is just another instrument, so why should it betreated diﬀerently? On the other hand, even common practice notation
treats it specially, although it has much in common with non-percussive
notation. The MIDI standard is equally ambiguous about the treatmentof percussion: on one hand, percussion sounds are chosen by specifying anoctave and pitch, just like any other instrument; on the other hand thesepitches have no tonal meaning whatsoever: they are just a convenient way toselect from a large numberof percussionsounds. Indeed, part of the GeneralMIDI Standard is a set of names for commonly used percussion sounds.
Since MIDI is such a popular platform, it is worth deﬁning some handy
functions for using the General MIDI Standard. In Figure 6.3ad a t at y p e
is deﬁned that borrows its constructor names from the General MIDI stan-dard. The comments reﬂecting the “MIDI Key” numbers will be explainedlater, but basically a MIDI Key is the equivalent of an absolute pitch in
Euterpea terminology. So all that remains to be done is a way to convert
these percussion sound names into a Musicvalue; i.e. a Note:
perc::PercussionSound →Dur→Music Pitch
perc ps dur =note dur (pitch(fromEnum ps +35))
CHAPTER 6. MORE MUSIC 92
dataPercussionSound =
AcousticBassDrum -- MIDI Key 35
|BassDrum1 -- MIDI Key 36
|SideStick -- ...
|AcousticSnare |HandClap |ElectricSnare |LowFloorTom
|ClosedHiHat |HighFloorTom |PedalHiHat |LowTom
|OpenHiHat |LowMidTom |HiMidTom |CrashCymbal1
|HighTom |RideCymbal1 |ChineseCymbal |RideBell
|Tambourine |SplashCymbal |Cowbell |CrashCymbal2
|Vibraslap |RideCymbal2 |HiBongo |LowBongo
|MuteHiConga |OpenHiConga |LowConga |HighTimbale
|LowTimbale |HighAgogo |LowAgogo |Cabasa
|Maracas |ShortWhistle |LongWhistle |ShortGuiro
|LongGuiro |Claves |HiWoodBlock |LowWoodBlock
|MuteCuica |OpenCuica |MuteTriangle
|OpenTriangle -- MIDI Key 82
deriving (Show,Eq,Ord,Enum)
Figure 6.3: General MIDI Percussion Names
Details: fromEnum is an operator in the Enumclass, which is all about enu-
merations, and will be discussed in more detail in Chapter 7. A data type that is a
member of this class can be enumerated —i.e. the elements of the data type can
be listed in order. fromEnum maps each value to its index in this enumeration.
ThusfromEnum AcousticBassDrum is 0,fromEnum BassDrum1 is 1, and so
on.
Recall the InstrumentName data type from Chapter 2.I faMusicvalue
returned from percis played using, say, the AcousticGrandPiano instru-
ment, then you will hear an acounstic grand piano sound at the appropriatepitch. But if you specify the Percussion instrument, then you will here the
percussion sound that was speciﬁed as an argument to perc.
For example, here are eight bars of a simple rock or “funk groove” that
usespercandroll:
funkGroove
=letp
1=perc LowTom qn
p2=perc AcousticSnare en
intempo3$instrument Percussion $cut8$repeatM
((p1:+:qnr:+:p2:+:qnr:+:p2:+:
CHAPTER 6. MORE MUSIC 93
p1:+:p1:+:qnr:+:p2:+:enr)
:=:roll en(perc ClosedHiHat 2))
Exercise 6.6 Write a program that generates all of the General MIDI per-
cussion sounds, playing through each of them one at a time.
Exercise 6.7 Find a drum beat that you like, and express it in Euterpea.
Then use repeatM,cut,a n d( : = : )t oa d das i m p l em e l o d yt oi t .
6.11 A Map for Music
Recall from Chapter 3the deﬁnition of map:
map ::(a→b)→[a]→[b]
map f[] =[]
map f(x:xs)=fx:map f xs
This function is deﬁned on the list data type. Is there something analogous
forMusic? I.e. a function:1
mMap::(a→b)→Music a →Music b
Suchafunctionisindeedstraightforward todeﬁne, butithelpstoﬁrstdeﬁne
a map-like function for the Primitive type:
pMap ::(a→b)→Primitive a →Primitive b
pMap f(Note d x )=Note d(fx)
pMap f(Rest d)=Rest d
WithpMapin hand one can now deﬁne mMap:
mMap ::(a→b)→Music a →Music b
mMap f (Prim p)=Prim(pMap f p )
mMap f (m1:+:m2)=mMap f m 1:+:mMap f m 2
mMap f (m1:=:m2)=mMap f m 1:=:mMap f m 2
mMap f (Modify c m )=Modify c (mMap f m )
Just asmap f xs for lists replaces each polymorphic element xinxswith
fx,mMap f m forMusicreplaces each polymorphic element pinmwith
fp.
1The name mapMwould perhaps have been a better choice here, to be consistent with
previous names. However, mapMis a predeﬁned function in Haskell, and thus mMapis
used instead. Similarly, Haskell’s Monadlibrary deﬁnes a function foldM, and thus in the
next section the name mFoldis used instead.
CHAPTER 6. MORE MUSIC 94
As an example of how mMapcan be used, suppose that one introduces
aVolumetype for a note:
typeVolume=Int
The goal is to convert a value of type Music Pitch into a value of type
Music(Pitch,Volume)—that is, to pair each pitch with a volume attribute.
One can deﬁne a function to do so as follows:
addVolume ::Volume→Music Pitch →Music(Pitch,Volume)
addVolume v =mMap(λp→(p,v))
Exercise 6.8 UsingmMap, deﬁne a function:
scaleVolume ::Rational →Music(Pitch,Volume)
→Music(Pitch,Volume)
such that scaleVolume s m scales the volume of each note in mby a factor
ofs.
6.12 A Fold for Music
One can also deﬁne a fold-like operator for Music. But whereas the list data
type has only two constructors (the nullary constructor [] and the binaryconstructor (:)), Musichasfourconstructors. Thus the following function
takes four arguments in addition to the Musicvalue it is transforming, in-
stead of two:
mFold::(Primitive a →b)→(b→b→b)→(b→b→b)→
(Control→b→b)→Music a →b
mFold f (+:) (=:) gm=
letrec=mFold f (+:) (=:) g
in casemof
Prim p →fp
m
1:+:m2→rec m 1+:rec m 2
m1:=:m2→rec m 1=:rec m 2
Modify c m →gc(rec m)
This somewhat unwieldy function basically takes apart a Musicvalue and
puts it back together with diﬀerent constructors. Indeed, note that:
mFold Prim (:+:) (:=:) Modify m ==m
Although intuitive, proving this property requires induction, a proof tech-
nique discussed in Chapter 10.
CHAPTER 6. MORE MUSIC 95
To see how mFoldmight be used, note ﬁrst of all that it is more general
thanmMap—indeed, mMapcan be deﬁned in terms of mFoldlike this:
mMap ::(a→b)→Music a →Music b
mMap f =mFold g (:+:) (:=:) Modify where
g(Note d x )=note d(fx)
g(Rest d)=rest d
More interestingly, onecan use mFoldtomoresuccinctlydeﬁnefunctions
such asdurfrom Section 6.5:
dur::Music a →Dur
dur=mFold getDur (+)max modDur where
getDur(Note d
 )=d
getDur(Rest d)= d
modDur (Tempo r )d=d/r
modDur
 d =d
Exercise 6.9 Redeﬁne revMfrom Section 6.6usingmFold.
Exercise 6.10 Deﬁne a function insideOut that inverts the role of serial
and parallel composition in a Musicvalue. Using insideOut ,s e ei fy o uc a n
(a) ﬁnd a non-trivial value m::Music Pitch such that m==insideOut m
and (b) ﬁnd a value m::Music Pitch such that:
m:+:insideOut m :+:m
soundsinteresting. (Youarefreetodeﬁnewhat“soundsinteresting”means.)
6.13 Crazy Recursion
With all the functions and data types that have been deﬁned, and the power
of recursion and higher-order functions well understood, one can start to dosome wild and crazy things. Here is just one such idea.
The goal is to Deﬁne a function to recursively apply transformations f
(to elements in a sequence) and g(to accumulated phrases) some speciﬁed
number of times:
rep::(Music a →Music a)→(Music a →Music a)→Int
→Music a →Music a
rep f g0m=rest0
rep f g n m =m:=:g(rep f g(n−1) (fm))
CHAPTER 6. MORE MUSIC 96
With this simple function one can create some interesting phrases of music
with very little code. For example, repcan be used three times, nested
together, to create a “cascade” of sounds:
run =rep(transpose 5) (delayM tn )8(c4tn)
cascade =rep(transpose 4) (delayM en )8run
cascades =rep id(delayM sn )2cascade
One can then make the cascade run up, and then down:
ﬁnal=cascades :+:revM cascades
What happens if the fandgarguments are reversed?
run/prime=rep(delayM tn )(transpose 5) 8 (c4tn)
cascade/prime=rep(delayM en )(transpose 4) 8run/prime
cascades/prime=rep(delayM sn )id2cascade/prime
ﬁnal/prime=cascades/prime:+:revM cascades/prime
Exercise 6.11 Consider this sequence of 8 numbers:
s1=[1,5,3,6,5,0,1,1]
One might interpret this as a sequence of pitches, i.e. a melody. Another
way to represent this sequence is as a sequence of 7 intervals:
s2=[4,−2,3,−1,−5,1,0]
Together with the starting pitch (i.e. 1), this sequence of intervals can be
used to reconstruct the original melody. But, with a suitable transposition
to eliminate negative numbers, it can also be viewed as another melody.
Indeed, one can repeat the process: s2can be represented by this sequence
of 6 intervals:
s3=[−6,5,−4,−4,6,−1]
Together with the starting number (i.e. 4), s3can be used to reconstruct s2.
Continuing the process:
s4=[1 1,−9,0,10,−7]
s5=[−20,9,10,−17]
s6=[2 9,1,−27]
s7=[−28,−28]
s8=[0]
Now, if one takes the ﬁrst element of each of these sequences to form this
8-number sequence:
ic=[0,−28,29,−20,11,−6,4,1]
CHAPTER 6. MORE MUSIC 97
then it alone can be used to re-create the original 8-number sequence in its
entirety. Of course, it can also be used as the original melody was used, andone could derive another 8-note sequence from it—and so on. The list ic
will be referred to as the “interval closure” of the original list s
1.
Your job is to:
a) Deﬁneafunction toIntervals that takes a listof nnumbers,and generates
a list ofnlists, such that the ithlist is the sequence sias deﬁned above.
b) Deﬁne a function getHeads that takes a list of nlists and returns a list
ofnnumbers such that the ithelement is the head of the ithlist.
c) Compose the above two functions in a suitable way to deﬁne a func-
tionintervalClosure that takes an n-element list and returns its interval
closure.
d) Deﬁne a function intervalClosures that takes an n-element list and re-
turns an inﬁnite sequence of interval closures.
e) Now for the open-ended part of this exercise: Interpret the outputs of
any of the functions above to create some “interesting” music.
Exercise 6.12 Do something wild and crazy with Euterpea.

Chapter 7
Qualiﬁed Types and Type
Classes
Thischapter introducesthenotions of qualiﬁed types andtype classes .T h e s e
concepts can be viewed as a reﬁnement of the notion of polymorphism, andincrease the ability to write modular programs.
7.1 Motivation
Apolymorphictypesuchas( a→a)canbeviewedasshorthandfor ∀(a)a→
a, which can be read “ for alltypesa, functions mapping elements of type
ato elements of type a.” Note the emphasis on “ for all.”
In practice, however, there are times when one would prefer to limit a
polymorphic type to a smaller numbe r of possibilities. A good example is
a function such as (+). It’s probably not a good idea to limit (+) to asingle(that is, monomorphic )t y p es u c ha s Integer→Integer→Integer,
since there are other kinds of numbers—such as rational and ﬂoating-pointnumbers—that one would like to perform addition on as well. Nor is it
a good idea to have a diﬀerent addition function for each number type,
since that would require giving each a diﬀerent name, such as addInteger ,
addRational ,addFloat , etc. And, unfortunately, giving (+) a type such as
a→a→awill not work, since this would imply that one could add things
other thannumbers, such as characters, pitch classes, lists, tuples, functions,and any type that you might deﬁne on your own!
Haskell provides a solution to this problem through the use of qualiﬁed
98
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 99
types. Conceptually, one can think of a qualiﬁed type just as a polymorphic
type, except that in place of “ for alltypesa” it will be possible to say “for
all types a that are members of the type class C ,” where the type class C
can be thought of as a set of types. For example, suppose there is a typeclassNumwith members Integer,Rational ,a n dFloat. Then an accurate
type for (+) would be ∀(a∈Num)a→a→a. But in Haskell, instead of
writing∀(a∈Num)···, the notation Num a⇒···is used. So the proper
type signature for (+) is:
(+)::Num a⇒a→a→a
which should be read: “for all types athat are members of the type class
Num,( + )h a st y p e a→a→a.” Members of a type class are also called
instances of the class, and these two terms will be used interchangeably in
the remainder of the text. The Num a⇒···part of the type signature is
often called a context,o rconstraint .
Details: It is important not to confuse Numwith a data type or a constructor
within a data type, even though the same syntax (“ Num a”) is used. Numis
atype class , and the context of its use (namely, to the left of a ⇒)i sa l w a y s
suﬃcient to determine this fact.
Recall now the type signature given for the function simplein Chapter 1:
simple ::Integer→Integer→Integer→Integer
simple x y z =x∗(y+z)
Note that simpleuses the operator (+) discussed above. It also uses ( ∗),
whose type is the same as that for (+):
(∗)::Num a⇒a→a→a
This suggests that a more general type for simpleis:
simple ::Num a⇒a→a→a→a
simple x y z =x∗(y+z)
Indeed, this is the preferred, most general type that can be given for simple.
It can now be used with any type that is a member of the Numclass, which
includes Integer,Int,Rational ,FloatandDouble, among others.
The ability to qualify polymorphic types is a unique feature of Haskell,
and, as you will soon see, provides great expressiveness. In the followingsections the idea is explored much more thoroughly, and in particular it is
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 100
shown how a programmer can deﬁne his or her own type classes and their
instances. To begin, a closer look is taken of one of the pre-deﬁned typeclasses in Haskell, having to do with equality.
7.2 Equality
Equality between two expressions e1ande2in Haskell means that the value
ofe1i st h es a m ea st h ev a l u eo f e2. Another way to view equality is that you
should be able to substitute e1fore2, or vice versa, wherever they appear
in a program, without aﬀecting the result of that program.
In general, however, it is not possible for a program to determine the
equality of two expressions—consider, for example, determining the equal-ity of two inﬁnite lists, two inﬁnite Musicvalues, or two functions of type
Integer→Integer.
1The ability to compute the equality of two values is
calledcomputational equality . Even though by the above simple examples it
is clear that computational equality is strictly weaker than full equality, it
is still an operation that one would like to use in many ordinary programs.
Haskell’s operator for computational equality is (==). Partly because
of the problem mentioned above, there are many types for which one wouldlike equality deﬁned, but some for which it might not make sense. Forexample, it is common to compare two characters, two integers, two ﬂoating-point numbers, etc. On the other hand, comparing the equality of inﬁnitedata structures, or functions, is diﬃcult, and in general not possible. ThusHaskell has a type class called Eq, so that the equality operator (==) can
be given the qualiﬁed type:
(==)::Eq a⇒a→a→Bool
In other words, (==) is a function that, for any type ain the class Eq,
tests two values of type afor equality, returning a Boolean ( Bool) value as
a result. Amongst Eq’s instances are the types CharandInteger,s ot h a t
the following calculations hold:
42 == 42 ⇒True
42 == 43 ⇒False
’a’==’a’⇒True
’a’==’b’⇒False
Furthermore, the expression 42 == ’a’isill-typed; Haskell is clever enough
1This is the same as determining program equivalence , a well-known example of an
undecideable problem in the theory of algoriithms.
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 101
to know when qualiﬁed types are ill-formed.
One of the nice things about qualiﬁed types is that they work in the
presence of ordinary polymorphism. In particular, the type constraints canbe made to propagate through polymorphic data types. For example, be-causeIntegerandFloatare membersof Eq,s oa r et h et y pe s( Integer,Char),
[Integer], [Float], etc. Thus:
[42,43] == [42 ,43]⇒True
[4.2,4.3] ==[4 .3,4.2]⇒False
(42,’a’)= =( 4 2 ,’a’)⇒True
This will be elaborated upon in a later section.
Type constraints also propagate through function deﬁnitions. For exam-
ple, consider this deﬁnition of the function ∈that tests for membership in
a list:
x∈[] = False
x∈(y:ys)=x==y∨x∈ys
Details: (∈)is actually written elemin Haskell; i.e. it is a normal function, not
an inﬁx operator. Of course it can be used in an inﬁx manner (and it often is) byenclosing it in backquotes.
Note the use of (==) on the right-hand side of the second equation. The
principal type for ( ∈)i st h u s :
∈::Eq a⇒a→[a]→Bool
This should be read, “For every type athat is an instance of the class Eq,
(∈)ha st ype a→[a]→Bool.” Thisis exactly whatone would hopefort—it
expresses the fact that ( ∈) is not deﬁned on all types, just those for which
computational equality is deﬁned.
The above type for ( ∈) is also its principal type, and Haskell will infer
this type if no signature is given. Indeed, if one were to write the typesignature:
(∈)::a→[a]→Bool
a type error would result, because this type is fundamentally too general ,
and the Haskell type system will complain.
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 102
Details: On the other hand, you could write:
(∈)::Integer→[Integer]→Bool
if you expect to use (∈)only on lists of integers. In other words, using a type
signature to constrain a value to be less general than its principal type is Ok.
As another example of this idea, a function that squares its argument:
square x =x∗x
has principal type Num a⇒a→a,s i n c e(∗), like (+), has type
Num a⇒a→a→a.T h u s :
square42⇒1764
square4.2⇒17.64
TheNumclass will be discusssed in greater detail shortly.
7.3 Deﬁning Your Own Type Classes
Haskell provides a mechanism whereby you can create your own qualiﬁed
types, by deﬁning a new type class and specifying which types are members,or “instances” of it. Indeed, the type classes NumandEqare not built-in
as primitives in Haskell, but rather are simply predeﬁned in the StandardPrelude.
To see how this is done, consider the Eqclass. It is created by the
following type class declaration :
classEq a where
(==)::a→a→Bool
The connection between (==) and Eqis important: the above declaration
should be read, “a type ais an instance of the class Eqonly if there is an
operation (==):: a→a→Booldeﬁned on it.” (==) is called an operation
in the class Eq, and in general more than one operation is allowed in a class.
More examples of this will be introduced shortly.
So far so good. But how does one specify which types are instances of
the class Eq, and the actual behavior of (==) on each of those types? This
is done with an instance declaration . For example:
instance Eq Integer where
x==y=integereq x y
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 103
The deﬁnition of (==) is called a method. The function integerEq hap-
pens to be the primitive function that compares integers for equality, butin general any valid expression is allowed on the right-hand side, just as forany other function deﬁnition. The overall instance declaration is essentiallysaying: “The type Integeris an instance of the class Eq, and here is the
method corresponding to the operation (==).” Given this declaration, onecan now compare ﬁxed-precision intege rs for equality using (==). Similarly:
instance Eq Float where
x==y=ﬂoatEq x y
allows one to compare ﬂoating-point numbers using (==).
More importantly, datatypes that you have deﬁned on your own can also
be made instances of the class Eq. Consider, for example, the PitchClass
data type deﬁned in Chapter 2:
dataPitchClass =Cﬀ|Cf|C|Dﬀ|Cs|Df|Css|D|Eﬀ|Ds
|Ef|Fﬀ|Dss|E|Es|Ff|F|Gﬀ|Ess|Fs
|Gf|Fss|G|Aﬀ|Gs|Af|Gss|A|Bﬀ|As
|Bf|Ass|B|Bs
|Bss
One can declare PitchClass to be an instance of Eqas follows:
instance Eq PitchClass where
Cﬀ==Cﬀ=True
Cf==Cf=True
C==C=True
...
Bs==Bs=True
Bss==Bss=True
==
=False
where...refers to the other thirty equations to make this deﬁnition of (==
) complete. Indeed, this is rather tedious! It is not only tedious, it isalso dead obvious how (==) should be deﬁned. Therefore Haskell providesac o n v e n i e n tw a yt o automatically derive such instance declarations from
data type declarations, for certain predeﬁned type classes, using a deriving
clause. For example, in the case of PitchClass one simply writes:
dataPitchClass =Cﬀ|Cf|C|Dﬀ|Cs|Df|Css|D|Eﬀ|Ds
|Ef|Fﬀ|Dss|E|Es|Ff|F|Gﬀ|Ess|Fs
|Gf|Fss|G|Aﬀ|Gs|Af|Gss|A|Bﬀ|As
|Bf|Ass|B|Bs|Bss
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 104
deriving Eq
With this declaration, Haskell will automatically derive the instance decla-
ration given above, so that (==) behaves in the way one would expect itto.
Considernowapolymorphictype, suchasthe Primitive typefromChap-
ter2:
dataPrimitive a =Note Dur a
|Rest Dur
What should an instance for this type in the class Eqlook like? Here’s a
ﬁrst attempt:
instance Eq(Primitive a )where
Note d
1x1==Note d 2x2=(d1==d2)∧(x1==x2)
Rest d 1==Rest d 2=d1==d2
==
 =False
Note the use of (==) on the right-hand side, in several places. Two of those
places involve Dur, which a type synonym for Rational .T h eRational type
is in fact a predeﬁned instance of Eq, so all is well there. (If it were not an
instance of Eq, a type error would result.)
B u tw h a ta b o u tt h et e r m x1==x2?x1andx2are values of the poly-
morphic type a, but how does one know that equality is deﬁned on a, i.e.
that the type ais an instance of Eq? In fact this is not known in general.
The simple ﬁx is to add a constraint to the instance declaration, as follows:
instance Eq a⇒Eq(Primitive a )where
Note d 1x1==Note d 2x2=(d1==d2)∧(x1==x2)
Rest d 1==Rest d 2=d1==d2
==
 =False
This can be read, “For any type ain the class Eq,t h et y p e Primitive a
is also in the class Eq, and here is the deﬁnition of (==) for that type.”
Indeed, if one had written the original type declaration like this:
dataPrimitive a =Note Dur a
|Rest Dur
deriving Eq
then Haskell would have derived the above correct instance declaration au-
tomatically.
So, for example, (==) is deﬁned on the type Primitive Pitch , because
Pitchis a type synonym for ( PitchClass ,Octave), and (a) PitchClass is an
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 105
instance of Eqby the eﬀort above, (b) Octaveis a synonym for Int,w h i c hi s
a predeﬁned instance of Eq, and (c) as mentioned earlier the pair type is a
predeﬁned instance of Eq. Indeed, now that an instance for a polymorphic
type has been seen, one can understand what the predeﬁned instance forpolymorphic pairs must look like, namely:
instance (Eq a,Eq b)⇒Eq(a,b)where
(x
1,y1)= =(x2,y2)=(x1==x2)∧(y1==y2)
About the only thing not considered is a recursive data type. For exam-
ple, recall the Musicdata type, also from Chapter 2:
dataMusic a =Prim(Primitive a )
|Music a :+:Music a
|Music a :=:Music a
|Modify Control (Music a)
Its instance declaration for Eqseems obvious:
instance Eq a⇒Eq(Music a)where
Prim p 1==Prim p 2=p1==p2
(m1:+:m2)= = (m3:+:m4)= (m1==m3)∧(m2==m4)
(m1:=:m2)= = (m3:=:m4)= (m1==m3)∧(m2==m4)
Modify c 1m1==Modify c 2m2=(c1==c2)∧(m1==m2)
Indeed, assuming that Control is an instance of Eq, this is just what is
expected, and can be automatically derived by adding a deriving clause to
the data type declaration for Music.
In reality, the class Eqas deﬁned in Haskell’s Standard Prelude is slightly
richer than what is deﬁned above. Here is its exact form:
classEq a where
(==),(/negationslash=)::a→a→Bool
x/negationslash=y=¬(x==y)
x==y=¬(x/negationslash=y)
This is an example of a class with two operations, one for equality, the
other for inequality. It also demonstrates the use of a default method ,o n e
for each operator. If a method for a particular operation is omitted in an
instance declaration, then the default one deﬁned in the class declaration,if it exists, is used instead. For example, all of the instances of Eqdeﬁned
earlier will work perfectly well with the above class declaration, yielding justthe right deﬁnition of inequality that one would want: the logical negationof equality.
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 106
Details: Both the inequality and the logical negation operators are shown here
usingthemathematicalnotation, /negationslash=and¬, respectively. WhenwritingyourHaskell
programs, you instead will have to use the operator /=and the function name not,
respectively.
A useful slogan that helps to distinguish type classes from ordinary poly-
morphism is this: “polymorphism captures similar structure over diﬀerentvalues, while type classes capture similar operations over diﬀerent struc-tures.” For example, a sequences of integers, sequence of characters, etc.
can be captured as a polymorphic List, whereas equality of integers, equal-
ity of trees, etc. can be captured by a type class such as Eq.
7.4 Inheritance
Haskell also supports a notion called inheritance . For example, one may
wish to deﬁne a class Ordthat “inherits” all of the operations in Eq, but
in addition has a set of comparison operations and minimum and maximum
functions (a fuller deﬁnition of Ord, as taken from the Standard Prelude, is
given in Appendix B):
classEq a⇒Ord a where
(<),(/lessorequalslant),(/greaterorequalslant),(>)::a→a→Bool
max,min ::a→a→a
Note the constraint Eq a⇒in the classdeclaration. Eqis asuperclass
ofOrd(conversely, Ordis asubclass ofEq), and any type that is an instance
ofOrdmust also be an instance of Eq. The reason that this extra constraint
makes sense is that to perform comparisons such as a/lessorequalslantbanda/greaterorequalslantbimplies
that one knows how to compute a==b.
For example, following the strategy used for Eq, one could declare Music
an instance of Ordas follows (note the constraint Ord a⇒...):
instance Ord a⇒Ord(Music a)where
Prim p 1<Prim p 2=p1<p2
(m1:+:m2)<(m3:+:m4)= (m1<m3)∧(m2<m4)
(m1:=:m2)<(m3:=:m4)= (m1<m3)∧(m2<m4)
Modify c 1m1<Modify c 2m2=(c1<c2)∧(m1<m2)
...
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 107
Although this is a perfectly well-deﬁned deﬁnition for <, it is not clear that
it exhibits the desired behavior, an issue that will be returned to in Section7.7.
Another beneﬁt of inheritance is shorter constraints. For example, the
type of a function that uses operations from both the EqandOrdclasses
can use just the constraint ( Ord a) rather than ( Eq a,Ord a), sinceOrd
“implies” Eq.
As an example of the use of Ord,ag e n e r i c sortfunction should be able
to sort lists of any type that is an instance of Ord, and thus its most general
type should be:
sort::Ord a⇒[a]→[a]
This typing for sortwould naturally arise through the use of comparison
operators such as <and/greaterorequalslantin its deﬁnition.
Details: Haskell also permits multiple inheritance , since classes may have more
than one superclass. Name conﬂicts are avoided by the constraint that a particular
operation can be a member of at most one class in any given scope. For example,
the declaration
class(Eq a,Show a)⇒Cawhere...
creates a class Cthat inherits operations from both EqandShow.
Finally, class methods may have additional class constraints on any type variable
except the one deﬁning the current class. For example, in this class:
classCawhere
m::Eq b⇒a→b
the method mrequires that type bis in class Eq. However, additional class
constraints on type aare not allowed in the method m; these would instead have
to be part of the overall constraint in the class declaration.
7.5 Haskell’s Standard Type Classes
The Standard Prelude deﬁnes many useful type classes, including Eqand
Ord. They are described in detail in Appendix B. In addition, the Haskell
Report and the Library Report contain useful examples and discussions oftype classes; you should feel encouraged to read through them.
Most of the standard type classes in Haskell are shown in Figure 7.1,
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 108
Type
 Key
 Key
Class
 functions
 instances
Num
 (+),(−),(∗)::Num a⇒a→a→a
Integer,Int,Float,Double,
negate::Num a⇒a→a
 Rational
Eq
 (==),(/negationslash=)::Eq a⇒a→a→Bool
Integer,Int,Float,Double,
Rational ,Char,Bool,...
Ord
 (>),(<),(/greaterorequalslant),(/lessorequalslant)::
 Integer,Int,Float,Double,
Ord a⇒a→a→Bool
 Rational ,Char,Bool,...
max,min::Ord a⇒a→a→Bool
Enum
 succ,pred::Enum a ⇒a→a
 Integer,Int,Float,Double,
also enables arithmetic sequences
 Rational ,Char,Bool,...
fromEnum ::Enum a ⇒a→Int
toEnum::Enum a ⇒Int→a
Show
 show::Show a⇒a→String
 Almost every type except
for functions
Read
 read::Read a⇒String→a
 Almost every type except
for functions
Figure 7.1: Common Type Classes and Their Instances
along with their key instances.
TheNumclass, which has been used implicitly throughout much of the
text, is described in more detail below. With this explanation a few moreof Haskell’s secrets will be revealed.
7.5.1 The NumClass
As you know, Haskell provides several kinds of numbers, some of which have
already been introduced: Int,Integer,Rational ,a n dFloat.T h e s en u m b e r s
are instances of various type classes arranged in a rather complicated hi-erarchy. The reason for this is that there are many operations, such as(+),abs,a n dsin, that are common amongst some of these number types.
For example, one would expect (+) to be deﬁned on every kind of number,whereas sinmight only be applicable to either single precision ( Float)o r
double-precision ( Double) ﬂoating-point numbers.
Control over which numerical operations are allowed and which aren’t is
the purpose of the numeric type class hierarchy. At the top of the hierarchy,and therefore containing operations that are valid for all numbers, is theclassNum. It is deﬁned as:
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 109
class(Eq a,Show a)⇒Num a where
(+),(−),(∗)::a→a→a
negate ::a→a
abs,signum::a→a
fromInteger ::Integer→a
Note that( /)isnotanoperation inthisclass. negateisthenegation function;
absis the absolute value function; and signumis the sign function, which
returns−1 if its argument is negative, 0 if it is 0, and 1 if it is positive.
fromInteger converts an Integerinto a value of type Num a⇒a,w h i c hi s
useful for certain coercion tasks.
Details: Haskell also has a negation operator, which is Haskell’s only preﬁx
operator. However, it is just shorthand for negate.T h a t i s , −ein Haskell is
shorthand for negate e.
The operation fromInteger also has a special purpose. one might wonder how it
is that one can write the constant 42, say, both in a context requiring an Intand
in one requiring a Float(say). Somehow Haskell “knows” which version of 42is
required in a given context. But, what is the type of 42itself? The answer is
that it has type Num a⇒a,f o rs o m e ato be determined by its context. (If this
seems strange, remember that []by itself is also somewhat ambiguous; it is a list,
but a list of what? The most one can say about its type is that it is [a]for some
ayet to be determined.)
The way this is achieved in Haskell is that literal numbers such as 42are actu-
ally considered to be shorthand for fromInteger 42.S i n c efromInteger has type
Num a⇒Integer→a,t h e nfromInteger 42has type Num a⇒a.
The complete hierarchy of numeric classes is shown in Figure 7.2;n o t e
thatsomeoftheclasses aresubclassesofcertain non-numericclasses, suchasEqandShow. The comments below each class name refer to the Standard
Prelude types that are instances of that class. See Appendix Bfor more
detail.
TheStandardPreludeactuallydeﬁnesonlythemostbasicnumerictypes:
Int,Integer,FloatandDouble. Other numeric types such as rational num-
bers (Ratio a) and complex numbers ( Complex a ) are deﬁned in libraries.
The connection between these types and the numeric classes is given in Fig-ure7.3. The instance declarations implied by this table can be found in the
Haskell Report.
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 110
Figure 7.2: Numeric Class Hierarchy
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 111
Numeric Type Type Class Description
Int Integral Fixed-precision integers
Integer Integral Arbitrary-precision integers
Integral a ⇒
Ratio a RealFrac Rational numbers
Float RealFloat Real ﬂoating-point, single precision
Double RealFloat Real ﬂoating-point, double precision
RealFloat a ⇒
Complex a Floating Complex ﬂoating-point
Figure 7.3: Standard Numeric Types
7.5.2 The ShowClass
It is very common to want to convert a data type value into a string. In
fact, it happens all the time when one interacts with GHCi at the commandprompt, and GHCi will complain if it does not “know” how to “show” avalue. The type of anything that GHCi prints must be an instance of theShowclass.
Not all of the operations in the Showclass will be discussed here, in fact
the only one of interest is show:
classShow a where
show::a→String
...
Instances of Showcan be derived, so normally one doesn’t have to worry
about the details of the deﬁnition of show.
Lists also have a Showinstance, but it is not derived, since, after all, lists
have special syntax. Also, when showis applied to a string such as "Hello",
it should generate a string that, when printed, will look like "Hello".T h i s
means that it must include characters for the quotation marks themselves,which in Haskell is achieved by preﬁxing the quotation mark with the “es-cape” character \. Given the following data declaration:
dataHello=Hello
deriving Show
it is then instructive to ponder over the following calculations:
show Hello =⇒"Hello"
show(show Hello )= ⇒show "Hello" =⇒"\"Hello\""
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 112
show(show(show Hello )) =⇒"\"\\\"Hello\\\"\""
Details: To refer to the escape character itself, it must also be escaped; thus
"\\"prints as \.
For further pondering, consider the following program. See if you can
ﬁgure out what it does, and why!2
main=putStr(quine q)
quine s=s++show s
q="main = putStr (quine q)\nquine s = s ++ show s\nq = "
Derived Showinstances are possible for all types whose component types
also have Showinstances. Showinstances for most of the standard types
are provided in the Standard Prelude.
7.6 Derived Instances
In addition to EqandOrd, instances of Enum,Bounded,Ix,Read,a n dShow
(see Appendix B) can also be generated by the deriving clause. These
type classes are widely used in Haskell programming, making the deriving
mechanism very useful.
The textual representation deﬁned by a derived Showinstance is consis-
tent with the appearance of constant Haskell expressions (i.e. values) of thetype involved. For example, from:
dataColor=Red|Orange|Yellow|Green|Blue|Indigo|Violet
deriving (Eq,Enum,Show)
one can expect that:
show[Red..]
=⇒"[Red,Orange,Yellow,Green,Blue,Indigo,Violet]"
Further details about derived instances can be found in the Haskell Report.
Many of the predeﬁned data types in Haskell have deriving clauses,
even ones with special syntax. For example, if one could write a data type
2The essence of this idea is due to Willard Van Orman Quine [ Qui66], and its use in a
computer program is discussed by Hofstadter [ Hof79]. It was adapted to Haskell by J´ on
Fairbairn.
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 113
declaration for lists (the reason one cannot do this is that lists have special
syntax, both at the value and type level) it would look something like this:
data[a]=[]
|a:[a]
deriving (Eq,Ord)
The derived EqandOrdinstances for lists are the usual ones; in particular,
character strings, as lists of characters, are ordered as determined by theunderlying Chartype, with an initial sub-string being less than a longer
string; for example, "cat"<"catalog" isTrue.
In practice, EqandOrdinstances are almost always derived, rather than
user-deﬁned. Infact, you shouldprovideyourowndeﬁnitionsofequality andordering predicates only with some trepidation, being careful to maintainthe expected algebraic properties of equivalence relations and total orders,respectively (more on this later). An intransitive (==) predicate, for ex-ample, would be problematic, confusing readers of the program who expect(==) to be transitive. Nevertheless, it is sometimes necessary to provide Eq
orOrdinstances diﬀerent from those that would be derived.
The data type declarations for PitchClass ,Primitive ,MusicandControl
given in Chapter 1are not the ones actually used in Eutperpea. The actual
deﬁnitions use a deriving clause, and are shown in Figure 7.4.
Note that with single and double sharpsand ﬂats, there are many enhar-
monic equivalences. Thus in the data declaration for PitchClass , the con-
structors are ordered such that, if pc
1<pc2,t h e npcToInt pc1<pcToInt pc2.
Details: When instances of more than one type class are derived for the same
data type, they appear grouped in parentheses as in Figure 7.4. Also, in this case
Eqmustappear if Orddoes (unless an explicit instance for Eqis given), since Eq
is a superclass of Ord.
For example, the Showclass allows one to convert values to strings:
show Cs =⇒"Cs"
show concertA =⇒"(A,4)"
TheReadclass allows one to go the other way around:
read "Cs" =⇒Cs
read "(A,4)" =⇒(A,4)
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 114
dataPitchClass =Cﬀ|Cf|C|Dﬀ|Cs|Df|Css|D|Eﬀ|Ds
|Ef|Fﬀ|Dss|E|Ff|Es|F|Gﬀ|Ess|Fs
|Gf|Fss|G|Aﬀ|Gs|Af|Gss|A|Bﬀ|As
|Bf|Ass|B|Bs|Bss
deriving (Eq,Ord,Show,Read,Enum)
dataPrimitive a =Note Dur a
|Rest Dur
deriving (Show,Eq,Ord)
dataMusic a =
Prim(Primitive a )- - p r i m i t i v e v a l u e
|Music a :+:Music a -- sequential composition
|Music a :=:Music a -- parallel composition
|Modify Control (Music a)- - m o d i ﬁ e r
deriving (Show,Eq,Ord)
dataControl=
Tempo Rational -- scale the tempo
|Transpose AbsPitch -- transposition
|Instrument InstrumentName -- instrument label
|Phrase [PhraseAttribute ] -- phrase attributes
|Player PlayerName -- player label
deriving (Show,Eq,Ord)
Figure 7.4: Euterpea’s Data Types with Deriving Clauses
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 115
TheEqclass allows testing values for equality:
concertA ==a440=⇒True
concertA == (A,5) =⇒False
And the Ordclass has relational operators for types whose values can be
ordered:
C<G=⇒True
max C G =⇒G
TheEnumclass allows one to use arithmetic sequences , which will be ex-
plained in a later chapter.
7.7 Reasoning With Type Classes
Type classes often imply a set of lawsthat govern the use of the operators
in the class. For example, for the Eqclass, one can expect the following
laws to hold for every instance of the class:
x==x
x==y ⊇y==x
(x==y)∧(y==z)⊇x==z
(x/negationslash=y) ⊇¬(x==y)
where⊇should be read “implies that.”3
However, there is no way to guarantee these laws. A user may create
an instance of Eqthat violates them, and in general Haskell has no way to
enforce them. Nevertheless, it is useful to state the laws of interest for aparticular class, and to state the expectation that all instances of the classbe “law-abiding.” Then as a diligent functional programmer, one shouldensure that every instance that is deﬁned, whether for one’s own class orsomeone else’s, is in fact law-abiding.
Asanotherexample, considerthe Ordclass, whoseinstancesareintended
to betotally ordered , which means that the following laws should hold, for
alla,b,a n dc:
a/lessorequalslanta
(a/lessorequalslantb)∧(b/lessorequalslantc)⊇(a/lessorequalslantc)
(a/lessorequalslantb)∧(b/lessorequalslanta)⊇(a==b)
(a/negationslash=b) ⊇(a<b)∨(b<a)
3Mathematically, the ﬁrst three of these laws are the same as those for an equivalence
relation.
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 116
Similar laws should hold for ( >).
But alas, the instance of Musicin the class Ordgiven in Section 7.4does
not satisfy all of these laws! To see why, consider two Primitive valuesp1
andp2such that p1<p2. Now consider these two Musicvalues:
m1=Prim p 1:+:Prim p 2
m2=Prim p 2:+:Prim p 1
Clearlym1==m2is false, but the problem is, so are m1<m2andm2<m1,
thus violating the last law above.
To ﬁx the problem, a lexicographic ordering should be used on the Music
type, such as used in a dictionary. For example, “polygon” comes before“polymorphic,” using a left-to-right comparison of the letters. The newinstance declaration looks like this:
instance Ord a⇒Ord(Music a)where
Prim p
1<Prim p 2=p1<p2
Prim p 1<
 =True
(m1:+:m2)<Prim
 =False
(m1:+:m2)<(m3:+:m4)= (m1<m3)∨
(m1==m3)∧(m2<m4)
(m1:+:m2)<
 =True
(m1:=:m2)<Prim
 =False
(m1:=:m2)<(m3:+:m4)=False
(m1:=:m2)<(m3:=:m4)= (m1<m3)∨
(m1==m3)∧(m2<m4)
(m1:=:m2)<
 =True
Modify c 1m1<Modify c 2m2=(c1<c2)∨
(c1==c2)∧(m1<m2)
Modify c 1m1<
 =False
This example shows the value of checking to be sure that each instance
obeys the laws of its class. Of course, that check should come in the way ofa proof. This example also highlights the utility of derived instances, sincethe derived instance of Musicfor the class Ordis equivalent to that above,
yet is done automatically.
Exercise 7.1 Prove that the instance of Musicin the class Eqsatisﬁes the
laws of its class. Also prove that the modiﬁed instance of Musicin the class
Ordsatisﬁes the laws of its class.
Exercise 7.2 Write out appropriate instance declarations for the Color
CHAPTER 7. QUALIFIED TYPES AND TYPE CLASSES 117
type in the classes Eq,Ord,a n dEnum.

Chapter 8
Interpretation and
Performance
{-# LANGUAGE FlexibleInstances, TypeSynonymInstances #- }
module Euterpea .Music.Note.Performance
where
importEuterpea .Music.Note.Music
importEuterpea .Music.Note.MoreMusic
instance Show(a→b)where
showsPrec p f =showString "<<function>>"
8.1 Abstract Performance
So far, our presentation of musical values in Haskell has been entirely struc-
tural, i.e. syntactic . But what do these musical values actually mean, i.e.
what is their semantics ,o rinterpretation ? The formal process of giving a
semantic interpretation to syntactic constructs is very common in computerscience, especially in programming language theory. But it is obviously alsocommon in music: the interpretation of music is the very essence of musicalperformance. However, in conventional music this process is usually infor-mal, appealing to aesthetic judgments and values. What we would like todo is make the process formal in Euterpea—but still ﬂexible, so that morethan one interpretation is possible, just as in music.
To begin, we need to say exactly what an abstract performance is. Our
approach is to consider a performance to be a time-ordered sequence of
118
CHAPTER 8. INTERPRETATION AND PERFORMANCE 119
musical events, where each event captures the playing of one individual
note. In Haskell:
typePerformance =[Event]
dataEvent=Event{eTime ::PTime,
eInst ::InstrumentName ,
ePitch ::AbsPitch ,
eDur ::DurT,
eVol ::Volume,
eParams ::[Double]}
deriving (Eq,Ord,Show)
typePTime=Rational
typeDurT=Rational
typeVolume=Integer
Details: The data declaration for Eventuses Haskell’s ﬁeld label syntax, also
called recordsyntax, and is equivalent to:
dataEvent=Event PTime InstrumentName
AbsPitch DurT Volume [Float]
deriving (Eq,Ord,Show)
except that the former also deﬁnes “ﬁeld labels” eTime,eInst,ePitch,eDur,
eVol,a n deParams , which can be used to create, update, and select from Event
values. For example, this equation:
e=Event0Cello27 (1/4) 50 []
is equivalent to:
e=Event{eTime=0,ePitch=2 7,eDur=1/4,
eInst=Cello,eVol=5 0,eParams =[]}
Although more verbose, the latter is als o more descriptive, and the order of the
ﬁelds does not matter (indeed the order here is not the same as above).
CHAPTER 8. INTERPRETATION AND PERFORMANCE 120
Details: Fieldlabelscanbeusedto selectﬁeldsfroman Eventvalue; forexample,
using the value of eabove,eInst e⇒Cello,eDur e⇒1/4, and so on. They can
also be used to selectively updateﬁelds of an existing Eventvalue. For example:
e{eInst=Flute}⇒Event0Flute27 (1/4) 50 []
Finally, they can be used selectively in pattern matching:
f(Event{eDur=d,ePitch=p})=...d...p...
Field labels do not change the basic nature of a data type; they are simply a
convenient syntax for referring to the components of a data type by name ratherthan by position.
An event Event{eTime=s,eInst=i,ePitch=p,eDur=d,eVol=
v}captures the fact that at start time s, instrument isounds pitch pwith
volumevfor a duration d(where now duration is measured in seconds,
rather than beats). (The pFieldof an event is for special instruments that
require extra parameters, and will not be discussed much further in thischapter.)
An abstract performance is the lowest of our music representations not
yet committed to MIDI, csound, or some other low-level computer musicrepresentation. In Chapter 14we will discuss how to map a performance
into MIDI.
To generate a complete performance of, i.e. give an interpretation to, a
musical value, we must know the time to begin the performance, and theproper instrument, volume, key and tempo. In addition, to give ﬂexibility toour interpretations, we must also know what playerto use; that is, we need
a mapping from the PlayerName si naMusicvalue to the actual players
to be used.
1We capture these ideas in Haskell as a “context” and “player
map,” respectively:
dataContext a =Context {cTime::PTime,
cPlayer::Player a ,
cInst::InstrumentName ,
cDur::DurT,
cKey::Key,
cVol::Volume}
deriving Show
1Wedon’t need a mapping from InstrumentNames to instruments, since this is handled
in the translation from a performance into MIDI, which is discussed in Chapter 14.
CHAPTER 8. INTERPRETATION AND PERFORMANCE 121
perform::PMap a →Context a →Music a →Performance
perform pm
c@Context{cTime=t,cPlayer=pl,cDur=dt,cKey=k}m=
casemof
Prim(Note d p ) →playNote pl c d p
Prim(Rest d) →[]
m1:+:m2 →
letc/prime=c{cTime=t+dur m 1∗dt}
inperform pm c m 1++perform pm c/primem2
m1:=:m2 →merge(perform pm c m 1)
(perform pm c m 2)
Modify(Tempo r )m→perform pm (c{cDur=dt/r})m
Modify(Transpose p )m→perform pm (c{cKey=k+p})m
Modify(Instrument i )m→perform pm (c{cInst=i})m
Modify(Player pn )m→perform pm (c{cPlayer=pm pn})m
Modify(Phrase pa )m→interpPhrase pl pm c pa m
Figure 8.1: An abstract perform function
typePMap a =PlayerName →Player a
typeKey =AbsPitch
Finally, we are ready to give an interpretation to a piece of music, which
we do by deﬁning a function perform, which is conceptually perhaps the
most important function deﬁned in this book, and is shown in Figure 8.1.
Some things to note about perform:
1. TheContext is the running “state” of the performance, and gets up-
dated in several diﬀerent ways. For example, the interpretation of theTempoconstructor involves scaling dtappropriately and updating the
DurTﬁeld of the context.
2. The interpretation of notes and phrases is player dependent. Ulti-
mately a single note is played by the playNote function, which takes
the player as an argument. Similarly, phrase interpretation is alsoplayer dependent, reﬂected in the use of interpPhrase . Precisely how
these two functions work is described in Section 8.2.
3. TheDurTcomponent of the context is the duration, in seconds,
of one whole note. To make it easier to compute, we can deﬁne a“metronome” function that, given a standard metronome marking (in
CHAPTER 8. INTERPRETATION AND PERFORMANCE 122
beats per minute) and the note type associated with one beat (quarter
note, eighth note, etc.) generates the duration of one whole note:
metro ::Int→Dur→DurT
metro setting dur =6 0/(fromIntegral setting ∗dur)
Thus, for example, metro96qncreates a tempo of 96 quarter notes
per minute.
Details: fromIntegral :: (Integral a ,Num b)⇒a→bcoerces a value whose
type is a member of the Integralclass to a value whose type is a member of the
Numclass. As used here, it is eﬀectively converting the Intvaluesettingto a
Rational value, because duris aRational value,Rational is a member of the
Numclass, and multiplication has type (∗)::Num a⇒a→a→a.
4. In the treatment of (:+:), note that the sub-sequences are appended
together, with the start time of the second argument delayed by theduration of the ﬁrst. The function dur( d e ﬁ n e di nS e c t i o n 6.5)i su s e d
to compute this duration. However, this results in a quadratic timecomplexity for perform. A more eﬃcient solution is to have perform
compute the duration directly, returning it as part of its result. Thisversion of perform is shown in Figure 8.2.
5. The sub-sequences derived from the arguments to (:=:) are merged
into a time-ordered stream. The deﬁnition of mergeis given below.
merge::Performance →Performance →Performance
merge a@(e
1:es1)b@(e2:es2)=ife1<e2
thene1:merge es 1b
elsee2:merge a es 2
merge[] es2 =es2
merge es 1 [] = es1
Note that mergecompares entire events rather than just start times.
This is to ensure that it is commutative, a desirable condition for some
of the proofs used later in the text.
CHAPTER 8. INTERPRETATION AND PERFORMANCE 123
perform::PMap a →Context a →Music a →Performance
perform pm c m =fst(perf pm c m )
perf::PMap a →Context a →Music a →(Performance ,DurT)
perf pm
c@Context{cTime=t,cPlayer=pl,cDur=dt,cKey=k}m=
casemof
Prim(Note d p ) →(playNote pl c d p ,d∗dt)
Prim(Rest d) →([],d∗dt)
m1:+:m2 →
let(pf1,d1)=perf pm c m 1
(pf2,d2)=perf pm (c{cTime=t+d1})m2
in(pf1++pf2,d1+d2)
m1:=:m2 →
let(pf1,d1)=perf pm c m 1
(pf2,d2)=perf pm c m 2
in(merge pf1pf2,max d 1d2)
Modify(Tempo r )m→perf pm (c{cDur=dt/r})m
Modify(Transpose p )m→perf pm (c{cKey=k+p})m
Modify(Instrument i )m→perf pm (c{cInst=i})m
Modify(Player pn )m→perf pm (c{cPlayer=pm pn})m
Modify(Phrase pas )m→interpPhrase pl pm c pas m
Figure 8.2: A more eﬃcient perform function
Here is a more eﬃcient version of mergethat will work just as well in
practice:
merge a@(e1:es1)b@(e2:es2)=ifeTime e 1<eTime e 2
thene1:merge es 1b
elsee2:merge a es 2
merge[] es2 =es2
merge es 1 [] = es1
CHAPTER 8. INTERPRETATION AND PERFORMANCE 124
8.2 Players
Recall from Section 2.2the deﬁnition of the Controldata type:
dataControl=
Tempo Rational -- scale the tempo
|Transpose AbsPitch -- transposition
|Instrument InstrumentName -- intrument label
|Phrase [PhraseAttribute ] -- phrase attributes
|Player PlayerName -- player label
deriving (Show,Eq,Ord)
typePlayerName =String
We mentioned, but did not deﬁne, the PhraseAttribute data type, shown
now fully in Figure 8.3. These attributes give us great ﬂexibility in the in-
terpretation process, because they can be interpreted by diﬀerent players indiﬀerent ways. For example, how should “legato” be interpreted in a per-formance? Or “diminuendo?” Diﬀerent players interpret things in diﬀerentways, of course, but even more fundamental is the fact that a pianist, forexample, realizes legato in a way fundamentally diﬀerent from the way aviolinist does, because of diﬀerences in their instruments. Similarly, dimin-
uendo on a piano and diminuendo on a harpsichord are diﬀerent concepts.
Withaslightstretchoftheimagination, wecanevenconsidera“notator”
of a score as a kind of player: exactly how the music is rendered on thewritten page may be a personal, stylized process. For example, how many,and which staves should be used to notate a particular instrument?
In any case, to handle these issues, Euterpea has a notion of a player
that “knows” about diﬀerences with respect to performance and notation.A Euterpea player is a 4-tuple consisting of a name and three functions:one for interpreting notes, one for phrases, and one for producing a properlynotated score.
dataPlayer a =MkPlayer {pName ::PlayerName ,
playNote ::NoteFun a ,
interpPhrase ::PhraseFun a ,
notatePlayer ::NotateFun a }
deriving Show
typeNoteFun a =Context a →Dur→a→Performance
typePhraseFun a =PMap a →Context a →[PhraseAttribute ]
→Music a →(Performance ,DurT)
type
NotateFun a =( )
CHAPTER 8. INTERPRETATION AND PERFORMANCE 125
dataPhraseAttribute =Dyn Dynamic
|Tmp Tempo
|Art Articulation
|Orn Ornament
deriving (Eq,Ord,Show)
dataDynamic =Accent Rational |Crescendo Rational
|Diminuendo Rational |StdLoudness StdLoudness
|Loudness Rational
deriving (Eq,Ord,Show)
dataStdLoudness =PPP|PP|P|MP|SF|MF|NF|FF|FFF
deriving (Eq,Ord,Show,Enum)
dataTempo=Ritardando Rational |Accelerando Rational
deriving (Eq,Ord,Show)
dataArticulation =Staccato Rational |Legato Rational
|Slurred Rational |Tenuto|Marcato |Pedal
|Fermata |FermataDown |Breath|DownBow
|UpBow|Harmonic |Pizzicato |LeftPizz
|BartokPizz |Swell|Wedge|Thumb|Stopped
deriving (Eq,Ord,Show)
dataOrnament =Trill|Mordent |InvMordent |DoubleMordent
|Turn|TrilledTurn |ShortTrill
|Arpeggio |ArpeggioUp |ArpeggioDown
|Instruction String |Head NoteHead
deriving (Eq,Ord,Show)
dataNoteHead =DiamondHead |SquareHead |XHead|TriangleHead
|TremoloHead |SlashHead |ArtHarmonic |NoHead
deriving (Eq,Ord,Show)
Figure 8.3: Phrase Attributes
CHAPTER 8. INTERPRETATION AND PERFORMANCE 126
Note that NotateFun is just the unit type; this is because notation is cur-
rently not implemented in Euterpea.
8.2.1 Example of Player Construction
In this section we deﬁne a “default player” called defPlayer (not to be con-
fused with a “deaf player”!) for use when none other is speciﬁed in a score;it also functions as a basis from which other players can be derived.
Inorderto provide themost ﬂexibility, we exploit poymorphismto deﬁne
a version of Musicthat in addition to pitch, carries a list of “note attributes”
for each individual note:
dataNoteAttribute =
Volume Int -- MIDI convention: 0=min, 127=max
|Fingering Integer
|Dynamics String
|Params[Double]
deriving (Eq,Show)
Our goal then is to deﬁne a player for music values of type:
typeMusic1=Music Note1
typeNote1=(Pitch,[NoteAttribute ])
At the upper-most level, defPlayer is deﬁned as a four-tuple:
defPlayer ::Player Note1
defPlayer =MkPlayer
{pName ="Default" ,
playNote =defPlayNote defNasHandler ,
interpPhrase =defInterpPhrase defPasHandler ,
notatePlayer =( )}
The remaining functions are deﬁned in Figure 8.4. Before reading this
code, ﬁrst review how players are invoked by the performfunction deﬁned in
the last section; in particular, note the calls to playNote andinterpPhrase .
We will deﬁne defPlayer to respond only to the Volumenote attribute and
to theAccent,Staccato,a n dLegatophrase attributes.
Then note:
1.defPlayNote is the only function (even in the deﬁnition of perform)
that actually generates an event. It also modiﬁes that event based onaninterpretationofeachnoteattributebythefunction defNasHandler .
CHAPTER 8. INTERPRETATION AND PERFORMANCE 127
defPlayNote ::(Context (Pitch,[a])→a→Event→Event)
→NoteFun (Pitch,[a])
defPlayNote nasHandler
c@(Context cTime cPlayer cInst cDur cKey cVol )d(p,nas)=
letinitEv=Event{eTime =cTime,eInst=cInst,
ePitch =absPitch p +cKey,
eDur =d∗cDur,eVol=cVol,
eParams =[]}
in[foldr(nasHandler c )initEv nas ]
defNasHandler ::Context a →NoteAttribute →Event→Event
defNasHandler c (Volume v )ev=ev{eVol=v}
defNasHandler c (Params pms )ev=ev{eParams =pms}
defNasHandler
 ev=ev
defInterpPhrase ::
(PhraseAttribute →Performance →Performance )→PhraseFun a
defInterpPhrase pasHandler pm context pas m =
let(pf,dur)=perf pm context m
in(foldr pasHandler pf pas ,dur)
defPasHandler ::PhraseAttribute →Performance →Performance
defPasHandler (Dyn(Accent x )) =
map(λe→e{eVol=round(x∗fromIntegral (eVol e))})
defPasHandler (Art(Staccato x )) =
map(λe→e{eDur=x∗eDur e})
defPasHandler (Art(Legato x)) =
map(λe→e{eDur=x∗eDur e})
defPasHandler
 =id
Figure 8.4: Deﬁnition of default player defPlayer .
CHAPTER 8. INTERPRETATION AND PERFORMANCE 128
2.defNasHandler only recognizes the Volumeattribute, which it uses to
set the event volume accordingly.
3.defInterpPhrase calls (mutually recursively) perform to interpret a
phrase, and then modiﬁes the result based on an interpretation ofeach phrase attribute by the function defPasHandler .
4.defPasHandler onlyrecognizesthe Accent,Staccato,andLegatophrase
attributes. For each of these it uses the numeric argument as a “scal-ing” factor of the volume (for Accent) and duration (for Staccato and
Legato). ThusModify(Phrase[Legato(5/4)])meﬀectively increases
the duration of each note in mby 25% (without changing the tempo).
8.2.2 Deriving New Players From Old Ones
It should be clear that much of the code in Figure 8.4can be re-used in
deﬁning a new player. For example, to deﬁne a player newPlayer that
interprets note attributes just like defPlayer but behaves diﬀerently with
respect to certain phrase attributes, we could write:
newPlayer ::Player(Pitch,[NoteAttribute ])
newPlayer =MkPlayer
{pName ="NewPlayer" ,
playNote =defPlayNote defNasHandler ,
interpPhrase =defInterpPhrase myPasHandler ,
notatePlayer =( )}
and then supplya suitabledeﬁnition of myPasHandler . Better yet, we could
just do this:
newPlayer ::Player(Pitch,[NoteAttribute ])
newPlayer =defPlayer
{pName ="NewPlayer" ,
interpPhrase =defInterpPhrase myPasHandler }
This version uses the “record update” syntax to directly derive the new
player from defPlayer .
The deﬁnition of myPasHandler can also re-use code, in the following
sense: supposewewishtoaddaninterpretation for Crescendo ,butotherwise
havemyPasHandler behave just like defPasHandler .
myPasHandler ::PhraseAttribute →Performance →Performance
myPasHandler (Dyn(Crescendo x ))pf=...
myPasHandler pa pf =defPasHandler pa pf
CHAPTER 8. INTERPRETATION AND PERFORMANCE 129
[To do: Expain more... in particular, how “inheritance” works. ]
8.2.3 A Fancy Player
Figure8.5deﬁnes a relatively sophisticated player called fancyPlayer that
knows all that defPlayer knows, and more. Note that Slurredis diﬀerent
fromLegatoin that it doesn’t extend the duration of the lastnote(s). The
behavior of Ritardando x can be explained as follows. We’d like to “stretch”
the time of each event by a factor from 0 to x, linearly interpolated based on
how far along the musical phrase the event occurs. I.e., given a start time
t0for the ﬁrst event in the phrase, total phrase duration D, and event time
t, the new event time t/primeis given by:
t/prime=( 1+t−t0
Dx)(t−t0)+t0
Further, if dis the duration of the event, then the end of the event t+dgets
s t r e t c h e dt oan e wt i m e t/prime
dgiven by:
t/prime
d=( 1+t+d−t0
Dx)(t+d−t0)+t0
The diﬀerence t/prime
d−t/primegives us the new, stretched duration d/prime,w h i c ha f t e r
simpliﬁcation is:
d/prime=( 1+2(t−t0)+d
Dx)d
Accelerando behaves in exactly the same way, except that it shortens event
times rather than lengthening them. And a similar but simpler strategyexplains the behaviors of Crescendo andDiminuendo .
8.3 Putting it all Together
Theplayfunction in Euterpea ueses a default player map and a default
context that are deﬁned as follows:
defPMap ::PMap Note1 -- = PlayerName -¿ Player Note1
defPMap "Fancy" =fancyPlayer
defPMap "Default" =defPlayer
defPMap n =defPlayer {pName=n}
defCon::Context Note1
CHAPTER 8. INTERPRETATION AND PERFORMANCE 130
defCon=Context {cTime=0,
cPlayer=fancyPlayer ,
cInst=AcousticGrandPiano ,
cDur=metro120qn,
cKey=0,
cVol= 127}
Note that if anything other than a "Fancy" player is speciﬁed in the Music
value, such as player "Strange" m, then the default player defPlayer is
used.
If instead one wishes to use her own player, say newPlayer deﬁned in
Section8.2.2, then a new player map can be deﬁned, such as:
myPMap ::PlayerName →Player Note1
myPMap "NewPlayer" =newPlayer
myPMap p =defPMap p
Similarly, diﬀerent versions of the context can be deﬁned based on a
user’s needs.
Onecould, then, usetheseversions of player mapsandcontexts toinvoke
theperform function to generate an abstract Performance .O fc o u r s e ,w e
ultimately want to hear our music, not just see an abstract Performance .
Recall that play’s type signature is:
play::Performable a ⇒Music a →IO()
To allow using diﬀerent player maps and contexts, Eutperpea also has a
version of playcalledplayAwhose type signature is:
playA::Performable a ⇒
PMap Note1 →Context Note1 →Music a →IO()
For example, to play a MusicvaluemusingmyPMap deﬁned above and the
default context defCon,o n ec a nd o :
playA myPMap defCon m
In later chapters we will learn more about play, and how it converts
aPerformance into MIDI events that eventually are heard through your
computer’s sound card.
Exercise 8.1 Fill in the ...in the deﬁnition of myPasHandler according
to the following strategy: Gradually scale the volume of each event in theperformance by a factor of 1 through 1+ x, using linear interpolation.
CHAPTER 8. INTERPRETATION AND PERFORMANCE 131
Exercise 8.2 Choose some of the other phrase attributes and provide in-
terpretations for them.
Exercise 8.3 Deﬁneaplayer myPlayer thatappropriatelyhandlesthe Pedal
articulation and both the ArpeggioUp andArpeggioDown ornamentations.
You should deﬁne myPlayer as a derivative of defPlayer .
Exercise 8.4 Deﬁne a player jazzMan (orjazzWoman if you prefer) that
plays a melody using a jazz “swing” feel. Since there are diﬀerent kinds anddegrees of swing, we can be more speciﬁc as follows: whenever there is asequence of two eighth notes, they should be interpreted instead as a quarternote followed by an eighth note, but with tempo 3/2. So in essence, the ﬁrstnote is lengthened, and the second note is shortened, so that the ﬁrst note
is twice as long as the second, but they still take up the same amount of
overall time.
To do this at the Playerlevel, some assumptions need to be made, such
as what is an eighth note, where is the downbeat, etc.

CHAPTER 8. INTERPRETATION AND PERFORMANCE 132
[To do: This code has errors and needs to be ﬁxed. ]
fancyPlayer ::Player(Pitch,[NoteAttribute ])
fancyPlayer =MkPlayer {pName ="Fancy",
playNote =defPlayNote defNasHandler ,
interpPhrase =fancyInterpPhrase ,
notatePlayer =( )}
fancyInterpPhrase ::PhraseFun a
fancyInterpPhrase pm c []m=perf pm c m
fancyInterpPhrase pm
c@Context{cTime=t,cPlayer=pl,cInst=i,
cDur=dt,cKey=k,cVol=v}
(pa:pas)m=
letpfd@(pf,dur)=fancyInterpPhrase pm c pas m
loud x =fancyInterpPhrase pm c (Dyn(Loudness x ):pas)m
stretch x =lett0=eTime(head pf);r=x/dur
upd(e@Event{eTime=t,eDur=d})=
letdt=t−t0
t/prime=( 1+dt∗r)∗dt+t0
d/prime=( 1+( 2 ∗dt+d)∗r)∗d
ine{eTime=t/prime,eDur=d/prime}
in(map upd pf ,(1+x)∗dur)
inﬂate x =lett0=eTime(head pf);
r=x/dur
upd(e@Event{eTime=t,eVol=v})=
e{eVol=round((1+(t−t0)∗r)∗
fromIntegral v )}
in(map upd pf ,dur)
in casepaof
Dyn(Accent x )→
(map(λe→e{eVol=round(x∗fromIntegral (eVol e))})pf,dur)
Dyn(StdLoudness l )→
caselof
PPP→loud40;PP→loud50;P→loud60
MP→loud70;SF→loud80;MF→loud90
NF→loud100;FF→loud110;FFF→loud120
Dyn(Loudness x )→fancyInterpPhrase pm c
{cVol=(round◦fromRational )x}pas m
Dyn(Crescendo x )→inﬂate x ;Dyn(Diminuendo x )→inﬂate(−x)
Tmp(Ritardando x )→stretch x ;Tmp(Accelerando x )→stretch(−x)
Art(Staccato x )→(map(λe→e{eDur=x∗eDur e})pf,dur)
Art(Legato x)→(map(λe→e{eDur=x∗eDur e})pf,dur)
Art(Slurred x )→
letlastStartTime =foldr(λet→max(eTime e)t)0pf
setDur e =ifeTime e <lastStartTime
thene{eDur=x∗eDur e}
elsee
in(map setDur pf ,dur)
Art
 →pfd
Orn
 →pfd
[To do: Design Bug: To do things right we need to keep the key signature
around to determine, for example, what the trill note is. Alternatively,provide an argument to Trill to carry this info. ]
Figure 8.5: Deﬁnition of Player fancyPlayer .
Chapter 9
Self-Similar Music
module Euterpea .Examples .SelfSimilar where
importEuterpea
In this chapter we will explore the notion of self-similar music—i.e. mu-
sical structures that have patterns that repeat themselves recursively in in-teresting ways. There are many approaches to generating self-similar struc-tures, the most general being fractals, which have been used to generate not
just music, but also graphical images. We will delay a general treatment
of fractals, however, and will instead focus on more specialized notions ofself-similarity, notions that we conceive of musically, and then manifest asHaskell programs.
9.1 Self-Similar Melody
Here is the ﬁrst notion of self-similar music that we will consider: Begin
with a very simple melody of nnotes. Now duplicate this melody ntimes,
playing each in succession, but ﬁrst perform the following transformations:transpose the ith melody by an amount proportional to the pitch of the ith
note in the original melody, and scale its tempo by a factor proportional tothe duration of the ith note. For example, Figure 9.1shows the result of
applying this process once to a four-note melody. Now imagine that thisprocess is repeated inﬁnitely often. For a melody whose notes are all shorterthan a whole note, it yields an inﬁnitely dense melody of inﬁnitesimallyshorter notes. To make the result playable, however, we will stop the processat some pre-determined level.
133
CHAPTER 9. SELF-SIMILAR MUSIC 134
1
 
/G57/G56/G381 
/G113/G99/G113/G99/G113 /G113 /G113/G113/G113/G113
/G382 
/G113/G113/G113/G35 /G113/G35 /G113/G99/G113/G99/G113 /G113
Figure 9.1: An Example of Self-Similar Music
How can this be represented in Haskell? A treeseems like it would be a
logical choice; let’s call it a Cluster:
dataCluster=Cluster SNote [Cluster]
typeSNote=(Dur,AbsPitch )
This particular kind of tree happens to be called a rose tree []. AnSNoteis
just a “simple note,” a duration paired with an absolute pitch. We preferto stick with absolute pitches in creating the self-similar structure, and willconvert the result into a normal Musicv a l u eo n l ya f t e rw ea r ed o n e .
The sequence of SNotes at each level of the cluster is the melodic frag-
ment for that level. The very top cluster will contain a “dummy” note,whereas the next level will contain the original melody, the next level willcontain one iteration of the process described above (e.g. the melody inFigure9.1) ,a n ds of o r t h .
To achieve this we will deﬁne a function selfSimthat takes the initial
melody as argument and generates an inﬁnitely deep cluster:
selfSim ::[SNote]→Cluster
selfSim pat =Cluster(0,0) (map mkCluster pat )
wheremkCluster note =
Cluster note (map(mkCluster ◦addMult note )pat)
addMult ::SNote→SNote→SNote
addMult (d
0,p0)(d1,p1)=(d0∗d1,p0+p1)
Note that selfSimitself is not recursive, but mkCluster is. This code should
be studied carefully. In particualr, the recursion in mkCluster is diﬀer-
ent from what we have seen before, as it is not a direct invocation of
CHAPTER 9. SELF-SIMILAR MUSIC 135
mkCluster , but rather it is a high-order argument to map (which in turn
invokesmkCluster an aribtrary number of times).
Next, we deﬁne a function to skim oﬀ the notes at the nth level, or nth
“fringe,” of a cluster:
fringe ::Int→Cluster→[SNote]
fringe0(Cluster note cls )=[note]
fringe n (Cluster note cls )=concatMap (fringe(n−1))cls
Details: concatMap is deﬁned in the Standard Prelude as:
concatMap ::(a→[b])→[a]→[b]
concatMap f =concat◦map f
Recall that concatappends together a list of lists, and is deﬁned in the Prelude
as:
concat::[[a]]→[a]
concat=foldr(++) []
All that is left to do is convert this into a Musicv a l u et h a tw ec a np l a y :
simToMusic ::[SNote]→Music Pitch
simToMusic ss =letmkNote(d,ap)=note d(pitch ap)
inline(map mkNote ss )
We can deﬁne this with a bit more elegance as follows:
simToMusic ::[SNote]→Music Pitch
simToMusic =line◦map mkNote
mkNote ::(Dur,AbsPitch )→Music Pitch
mkNote(d,ap)=note d(pitch ap)
The increased modularity will allow us to reuse mkNotelater in the chapter.
Putting it all together, we can deﬁne a function that takes an initial
pattern, a level, a number of pitches to transpose the result, and a temposcaling factor, to yield a ﬁnal result:
ss pat n tr te =
transpose tr $tempo te $simToMusic $fringe n$selfSim pat
CHAPTER 9. SELF-SIMILAR MUSIC 136
9.1.1 Sample Compositions
Let’s start with a melody with no rhythmic variation.
m0::[SNote]
m0=[( 1,2),(1,0),(1,5),(1,7)]
tm0=instrument Vibraphone (ss m 045 02 0 )
One fun thing to do with music like this is to combine it with variations of
itself. For example:
ttm0=tm0:=:transpose (12) (revM tm 0)
We could also try the opposite: a simple percussion instrument with no
melodic variation, i.e. all rhythm:
m1::[SNote]
m1=[( 1,0),(0.5,0),(0.5,0)]
tm1=instrument Percussion (ss m 144 32 )
Note that the pitch is transposed by 43, which is the MIDI Key number for a
“high ﬂoor tom” (i.e. percussion sound HighFloorTom —recall the discussion
in Section 6.10).
Here is a very simple melody, two diﬀerent pitches and two diﬀerent
durations:
m2::[SNote]
m2=[(dqn,0),(qn,4)]
tm2=ss m 265 0( 1/50)
Here are some more exotic compositions, combining both melody and
rhythm:
m3::[SNote]
m3=[(hn,3),(qn,4),(qn,0),(hn,6)]
tm3=ss m 345 0( 1/4)
ttm3=letl1=instrument Flute tm 3
l2=instrument AcousticBass $
transpose (−9) (revM tm 3)
inl1:=:l2
m4::[SNote]
m4=[(hn,3),(hn,8),(hn,22),(qn,4),(qn,7),(qn,21),
(qn,0),(qn,5),(qn,15),(wn,6),(wn,9),(wn,19)]
tm4=ss m 435 08
CHAPTER 9. SELF-SIMILAR MUSIC 137
Exercise 9.1 Experiment with this idea futher, using other melodic seeds,
exploring diﬀerent depths of the clusters, and so on.
Exercise 9.2 Note that concatis deﬁnedas foldr(++) [], which means that
it takes a number of steps proportional to the sum of the lengths of the listsbeing concatenated; we cannot do any better than this. (If foldlwere used
instead, the number of steps would be proportional to the number of lists
times their average length.)
However, fringeis not very eﬃcient, for the following reason: concatis
being used over and over again, like this:
concat[concat[...],concat[...],concat[...]]
This causes a number of steps proportional to the depth of the tree times
the length of the sub-lists; clearly not optimal.
Deﬁne a version of fringethat is linear in the total length of the ﬁnal
list.
9.2 Self-Similar Harmony
In the last section we used a melody as a seed, and created longer melodiesfromit. Anotherideaistostackthemelodiesvertically. Speciﬁcally, supposewe redeﬁne fringein suchaway thatit doesnotconcatenate thesub-clusters
together:
fringe
/prime::Int→Cluster→[[SNote]]
fringe/prime0(Cluster note cls )=[[note]]
fringe/primen(Cluster note cls )=map(fringe(n−1))cls
Note that this strategy is only applied to the top level—below that we use
fringe. Thus the type of the result is [[ SNote]], i.e. a list of lists of notes.
We can convert the individual lists into melodies, and play the melodies
all together, like this:
simToMusic/prime::[[SNote]]→Music Pitch
simToMusic/prime=chord◦map(line◦map mkNote )
Finally, we can deﬁne a function akin to ssdeﬁned earlier:
ss/primepat n tr te =
transpose tr $tempo te $simToMusic/prime$fringe/primen$selfSim pat
CHAPTER 9. SELF-SIMILAR MUSIC 138
Using some of the same patterns used earlier, here are some sample
compositions (with not necessarily a great outcome...):
ss1=ss/primem245 0( 1/8)
ss2=ss/primem345 0( 1/2)
ss3=ss/primem435 02
Here is a new one, based on a major triad:
m5=[(en,4),(sn,7),(en,0)]
ss5=ss m 544 5( 1/500)
ss6=ss/primem544 5( 1/1000)
Note the need to scale the tempo back drastically, due to the short durations
of the starting notes.
9.3 Other Self-Similar Structures
The reader will observe that our notion of “self-similar harmony” does notinvolve changing the structure of the Clusterdata type, nor the algorithm
for computing the sub-structures (as captured in selfSim). All that we
do is interpret the result diﬀerently. This is a common characteristic ofalgorithmic music composition—the same mathematical or computationalstructure is interpreted in diﬀerent ways to yield musically diﬀerent results.
For example, instead of the above strategy for playing melodies in paral-
lel, we could play entire levels of the Clusterin parallel, where the number
of levels that we choose is given as a parameter. If alligned properly in timethere will be a harmonic relationship between the levels, which could yieldpleasing results.
TheClusterdata type is conceptually useful in that is represents the
inﬁnite solution space of self-simlar melodies. And it is computationally
useful in that it is computed to a desired depth only once, and thus can be
inspected and reused without recomputing each level of the tree. This ideamight be useful in the application mentioned above, namely combining twoor more levels of the result in interesting ways.
However, the Clusterdata type is strictly unnecessary, in that, for ex-
ample, if we are interested in computing a speciﬁc level, we could deﬁnea function that recursed to that level and gave the result directly, withoutsaving the intermediate levels.
CHAPTER 9. SELF-SIMILAR MUSIC 139
A ﬁnal point about the notion of self-similarity captured in this chapter
is that the initial pattern is used as the basis with which to transform eachsuccessive level. Another strategy would be to use the entirety of eachnew level as the seed for transforming itself into the next level. This willresult in an exponential blow-up in the size of each level, but may be worthpursuing—in some sense it is a simpler notion of self-similarity than whatwe have used in this chapter.
All of the ideas in this section, and others, we leave as exercises for the
reader.
Exercise 9.3 Experiment with the self-similar programs in this chapter.
Compose an interesting piece of music through a judicious choice of startingmelody, depth of recursion, instrumentation, etc.
Exercise 9.4 Devise an interpretation of a Clusterthat plays multiple lev-
els of the Clusterin parallel. Try to get the levels to align properly in time
so that each level has the same duration. You may choose to play all the
levels up to a certain depth in parallel, or levels within a certain range, say
levels 3 through 5.
Exercise 9.5 Deﬁne an alternative version of simToMusic that interprets
the music diﬀerently. For example:
•Interpret the pitch as an index into a scale—e.g., as an index into the
C major scale, so that 0 corresponds to C, 1 to D, 2 to E, 3 to F, ...,6 to B, 7 to C in the next octave, and so on.
•Interpret the pitch as duration, and the duration as pitch.
Exercise 9.6 Modify the self-similar code in the following ways:
•AddaVolumecomponentto SNote(inotherwords,deﬁneitasatriple
instead of a pair), and redeﬁne addmult so that it takes two of these
triples and combines them in a suitable way. Then modify the rest ofthecodesothattheresultisa Music1value. Withthesemodiﬁcations,
compose something interesting that highlights the changes in volume.
•Change the Pitchﬁeld inSNoteto be a list of Pitch,t ob ei n t e r -
preted ultimately as a chord. Figure out some way to combine theminaddmult, and compose something interesting.
CHAPTER 9. SELF-SIMILAR MUSIC 140
Exercise 9.7 Devise some other variant of self-similar music, and encode
it in Haskell. In particular, consider structures that are diﬀerent from thosegenerated by the selfSimfunction.
Exercise 9.8 Deﬁneafunctionthatgives thesameresultas ss, butwithout
using a data type such as Cluster.
Exercise 9.9 Deﬁne a version of self-similarity similar to that deﬁned in
this chapter, but that uses the entire melody generated at one level to trans-form itself into the next level (rather than using the original seed pattern).

Chapter 10
Proof by Induction
In this chapter we will study a powerful proof technique based on mathemat-
ical induction . With it we will beable to prove complex and important prop-
erties of programs that cannot be accomplished with proof-by-calculationalone. The inductive proof method is one of the most powerful and commonmethods for proving program properties.
10.1 Induction and Recursion
Induction is very closely related to recursion . In fact, in certain contexts
the terms are used interchangeably; in others, one is preferred over the otherprimarilyforhistorical reasons. Thinkofthemasbeingdualsofoneanother:inductionisusedtodescribetheprocessofstartingwithsomethingsmallandsimple, and building up from there, whereas recursion describes the processof starting with something large and complex, and working backward to the
simplest case.
For example, although we have previously used the phrase recursive data
type, in fact data types are often described inductively , such as a list:
Alistis either empty, or it is a pair consisting of a value and
another list.
On the other hand, we usually describe functions that manipulate lists,
such asmapandfoldr, as being recursive. This is because when you apply
a function such as map, you apply it initially to the whole list, and work
backwards toward [].
141
CHAPTER 10. PROOF BY INDUCTION 142
But these diﬀerences between induction and recursion run no deeper:
they are really just two sides of the same coin.
This chapter is about inductive properties of programs (but based on
the above argument could just as rightly be called recursive properties )t h a t
are not usually proven via calculation alone. Proving inductive propertiesusually involves the inductive nature of data types and the recursive natureof functions deﬁned on the data types.
As an example, suppose that pis an inductive property of a list. In
other words, p(l) for some list lis either true or false (no middle ground!).
To prove this property inductively, we do so based on the length of the list:starting with length 0, we ﬁrst prove p([]) (using our standard method of
proof-by-calculation).
Now for the key step: assume for the moment that p(xs) is true for any
listxswhose length is less than or equal to n. Then if we can prove (via
calculation) that p(x:xs) is true for any x—i.e. that pis true for lists of
lengthn+1—then the claim is that pis true for lists of any(ﬁnite) length.
Why is this so? Well, from the ﬁrst step above we know that pis true
for length 0, so the second step tells us that it’s also true for length 1. Butif it’s true for length 1 then it must also be true for length 2; similarly for
l e n g t h s3 ,4 ,e t c .S o pis true for lists of any length!
(It it important to realize, however, that a property being true for every
ﬁnite list does not necessarily imply that it is true for every inﬁnite list. Theproperty “the list is ﬁnite” is a perfect example of this! We will see how toprove properties of inﬁnite lists in Chapter ??.)
To summarize, to prove a property pby induction on the length of a list,
we proceed in two steps:
1. Prove p([]) (this is called the base step ).
2. Assume that p(xs) is true (this is called the induction hypothesis ,a n d
prove that p(x:xs) is true (this is called the induction step ).
10.2 Examples of List Induction
Ok, enough talk, let’s see this idea in action. Recall in Section 3.1the
following property about foldr:
CHAPTER 10. PROOF BY INDUCTION 143
(∀xs)foldr(:) []xs=⇒xs
We will prove this by induction on the length of xs. Following the ideas
above, we begin with the base step by proving the property for length 0; i.e.forxs=[] :
foldr(:) [] []⇒[]
This step is immediate from the deﬁnition of foldr. Now for the induction
step: we ﬁrst assumethat the property is true for all lists xsof length n,
and then prove the property for list x:xs. Again proceeding by calculation:
foldr(:) [] (x:xs)
⇒x:foldr(:) []xs
⇒x:xs
And we are done; the induction hypothesis is what justiﬁes the second step.
Now let’s do something a bit harder. Suppose we are interested in prov-
ing the following property:
(∀xs,ys)length(xs++ys)=length xs +length ys
Our ﬁrst problem is to decide which list to perform the induction over.
A little thought (in particular, a look at how the deﬁnitions of lengthand
(++) are structured) should convince you that xsis the right choice. (If you
do not see this, you are encouraged to try the proof by induction over thelength of ys!) Again following the ideas above, we begin with the base step
by proving the property for length 0; i.e. for xs=[] :
length([]++ys)
⇒length ys
⇒0+length ys
⇒length[]+length ys
For the induction step, we ﬁrst assume that the property is true for all lists
xsof length n, and then prove the property for list x:xs. Again proceeding
by calculation:
length((x:xs)++ys)
⇒length(x:(xs++ys))
⇒1+length(xs++ys)
⇒1+(length xs +length ys )
CHAPTER 10. PROOF BY INDUCTION 144
⇒(1+length xs )+length ys
⇒length(x:xs)+length ys
And we are done. The transition from the 3rd line to the 4th is where we
used the induction hypothesis.
10.3 Proving Function Equivalences
At this point it is a simple matter to return to Chapter 3and supply the
proofs that functions deﬁned using mapandfoldare equivalent to the re-
cursively deﬁned versions. In particular, let’s prove ﬁrst that:
toAbsPitches =map absPitch
wheretoAbsPitch is the original recursively deﬁned function:
toAbsPitches [] =[]
toAbsPitches (p:ps)=absPitch p :toAbsPitches ps
To prove this, we ﬁrst use the extensionality principle (brieﬂy discussed
in Section 3.6.1), which says that two functions are equal if, when applied
to the same value, they always yield the same result. We can change the
speciﬁcation slightly to reﬂect this. For any ﬁnite list ps,w ew a n tt op r o v e :
toAbsPitches ps =map absPitch ps
We proceed by i nduction, starting with the base case ps=[] :
toAbsPitches []
⇒[]
⇒map absPitch []
Next we assume that toAbsPitches ps =map absPitch ps holds, and try to
prove that toAbsPitches (p:ps)=map absPitch (p:ps) (note the use of the
induction hypothesis in the second step):
toAbsPitches (p:ps)
⇒absPitch p :toAbsPitches ps
⇒absPitch p :map absPitch ps
⇒map absPitch (p:ps)
The proof that toPitches aps =map pitch aps is very similar, and is left as
an exercise.
For a proof involving foldr, recall from Section 3.4this recursive deﬁni-
tion ofline:
line[] = rest0
CHAPTER 10. PROOF BY INDUCTION 145
line(m:ms)=m:+:line ms
and this non-recursive version:
line=foldr(:+:) (rest0)
We can prove that these deﬁnitions are equivalent by induction. First the
base case:
line[]
⇒rest0
⇒foldr(:+:) (rest0) []
Then the induction step:
line(m:ms)
⇒m:+:line ms
⇒m:+:foldr(:+:) (rest0)ms
⇒foldr(:+:) (rest0) (m:ms)
Theproofsofequivalenceofthedeﬁnitionsof toPitches ,chord,maxPitch ,
andhListfrom Section 3.4are similar, and left as an exercise.
Exercise 10.1 From Chapter 3, prove that the original recursive versions
of the following functions are equivalent to the versions using maporfold:
toPitches ,chord,maxPitch ,a n dhList.
10.3.1 [Advanced] Reverse
The proofs of function equivalence in the last section were fairly straight-
forward. For something more challenging, consider the deﬁnition of reverse
given in Section 3.5:
reverse1 [] =[]
reverse1 (x:xs)=reverse1 xs ++[x]
and the version given in Section 3.6:
reverse2 xs =foldl(ﬂip(:)) []xs
We would like to show that these are the same; i.e. that reverse1 xs =
reverse2 xs for any ﬁnite list xs. In carrying out this proof two new ideas
will be demonstrated, the ﬁrst being that induction can be used to provethe equivalence of two programs. The second is the need for an auxiliary
property which is proved independently of the main result.
The base case is easy, as it often is:
reverse1 []
CHAPTER 10. PROOF BY INDUCTION 146
⇒[]
⇒foldl(ﬂip(:)) [] []
⇒reverse2 []
Assume now that reverse1 xs =reverse2 xs . The induction step proceeds
as follows:
reverse1 (x:xs)
⇒reverse1 xs ++[x]
⇒reverse2 xs ++[x]
⇒foldl(ﬂip(:)) []xs++[x]
⇒???
But now what do we do? Intuitively, it seems that the following property,
which we will call property (1), should hold:
foldl(ﬂip(:)) []xs++[x]
⇒foldl(ﬂip(:)) [] (x:xs)
in which case we could complete the proof as follows:
...
⇒foldl(ﬂip(:)) []xs++[x]
⇒foldl(ﬂip(:)) [] (x:xs)
⇒reverse2 (x:xs)
The ability to see that if we could just prove one thing, then perhaps
we could prove another, is a useful skill in conducting proofs. In this case
we have reduced the overall problem to one of proving property (1), whichsimpliﬁes the structure of the proof, although not necessarily the diﬃculty.These auxiliary properties are often called lemmas
in mathematics, and in
many cases their proofs become the most important contributions, sincethey are often at the heart of a problem.
In fact if you try to prove property (1) directly, you will run into a
problem, namely that it is not generalenough. So ﬁrst let’s generalize
property (1) (while renaming xtoy), as follows:
foldl(ﬂip(:))ys xs++[y]
⇒foldl(ﬂip(:)) (ys++[y])xs
Let’s call this property (2). If (2) is true for any ﬁnite xsandys,t h e n
property (1) is also true, because:
foldl(ﬂip(:)) []xs++[x]
⇒{property (2)}
foldl(ﬂip(:)) ([]++[x])xs
CHAPTER 10. PROOF BY INDUCTION 147
⇒{unfold(++)}
foldl(ﬂip(:)) [x]xs
⇒{fold(ﬂip(:))}
foldl(ﬂip(:)) (ﬂip(:) []x)xs
⇒{fold foldl }
foldl(ﬂip(:)) [] (x:xs)
You are encouraged to try proving property (1) directly, in which case
you will likely come to the same conclusion, namely that the property needs
to be generalized. This is not always easy to see, but is sometimes an
important step is constructing a proof, because, despite being somewhatcounterintuitive, it is often the case that making a property more general(and therefore more powerful) makes it easier to prove.
In any case, how do we prove property (2)? Using induction, of course!
Settingxsto [], the base case is easy:
foldl(ﬂip(:))ys[]++[y]
⇒{unfold foldl }
ys++[y]
⇒{fold foldl }
foldl(ﬂip(:)) (ys++[y]) []
and the inducti on step proceeds as follows:
foldl(ﬂip(:))ys(x:xs)++[y]
⇒{unfold foldl }
foldl(ﬂip(:)) (ﬂip(:)
ys x)xs++[y]
⇒{unfold ﬂip }
foldl(ﬂip(:)) (x:ys)xs++[y]
⇒{induction hypothesis }
foldl(ﬂip(:)) ((x:ys)++[y])xs
⇒{unfold(++)}
foldl(ﬂip(:)) (x:(ys++[y]))xs
⇒{fold foldl }
foldl(ﬂip(:)) (ys++[y]) (x:xs)
10.4 Useful Properties on Lists
There are many useful properties of functions on lists that require inductive
proofs. Tables 10.1and10.2list a number of them involving functions used
in this text, but their proofs are left as exercises (except for one; see below).
CHAPTER 10. PROOF BY INDUCTION 148
Properties of map:
map(λx→x)=λx→x
map(f◦g)= map f◦map g
map f◦tail =tail◦map f
map f◦reverse =reverse◦map f
map f◦concat =concat◦map(map f)
map f(xs++ys)=map f xs ++map f ys
For all strict f:
f◦head=head◦map f
Properties of the foldfunctions:
1. Ifopis associative, and e‘op‘x=xandx‘op‘e=xfor allx,t h e n
for all ﬁnite xs:
foldr op e xs =foldl op e xs
2. If the following are true:
x‘op1‘(y‘op2‘z)=(x‘op1‘y)‘op2‘z
x‘op1‘e =e‘op2‘x
then for all ﬁnite xs:
foldr op1 e xs =foldl op2 e xs
3. For all ﬁnite xs:
foldr op e xs =foldl(ﬂip op)e(reverse xs )
Table 10.1: Some Useful Properties of mapandfold.
You may assume that these properties are true, and use them freely in
proving other properties of your programs. In fact, some of these propertiescan be used to simplify the proof that reverse1 andreverse2 are the same;
see if you can ﬁnd them!
1
(Note, by the way, that in the ﬁrst rule for mapin Figure 10.1,t h et y p e
ofλx→xon the left-hand side is a→b, whereas on the right-hand side it
is [a]→[b]; i.e. these are really two diﬀerent functions.)
1Morethoroughdiscussionsofthesepropertiesandtheirproofsmaybefoundin[ BW88,
Bir98].
CHAPTER 10. PROOF BY INDUCTION 149
Properties of (++):
For allxs,ys,a n dzs:
(xs++ys)++zs=xs++(ys++zs)
xs++[] =[]+ +xs=xs
Properties of takeanddrop:
For all ﬁnite non-negative mandn, and ﬁnite xs:
take n xs ++drop n xs =xs
take m◦take n =take(min m n )
drop m◦drop n =drop(m+n)
take m◦drop n =drop n◦take(m+n)
For all ﬁnite non-negative mandnsuch that n/greaterorequalslantm:
drop m◦take n=take(n−m)◦drop m
Properties of reverse :
For all ﬁnite xs:
reverse(reverse xs )=xs
head(reverse xs )=last xs
last(reverse xs )=head xs
Table 10.2: Useful Properties of Other Functions Over Lists
CHAPTER 10. PROOF BY INDUCTION 150
10.4.1 [Advanced] Function Strictness
Notethatthelastrulefor mapinFigure 10.1isonlyvalidfor strictfunctions.
A function fis said to be strict if f⊥=⊥. Recall from Section 1.4that
⊥is the value associated with a non-terminating computation. So another
way to think about a strict function is that it is one that, when applied to
a non-terminating computation, results in a non-terminating computation.
For example, the successor function (+1) is strict, because (+1) ⊥=⊥+1
=⊥. In other words, if you apply (+1) to a non-terminating computation,
you end up with a non-terminating computation.
Not all functions in Haskell are strict, and we have to be careful to say
on which argument a function is strict. For example, (+) is strict on bothof its arguments, which is why the section (+1) is also strict. On the otherhand, the constant function:
const x y =x
is strict on its ﬁrst argument (why?), but not its second, because const x⊥
=x, for any x.
Details: Understanding strictness requires a careful understanding of Haskell’s
pattern-matching rules. For example, consider the deﬁnition of (∧)from the
Standard Prelude:
(∧): : Bool→Bool→Bool
True∧x=x
False∧
=False
When choosing a pattern to match, Haskell starts with the top, left-most pattern,
and works to the right and downward. So in the above, (∧)ﬁrst evaluates its left
argument. If that value is True, then the ﬁrst equation succeeds, and the second
argument gets evaluated because that is the value that is returned. But if the ﬁrst
argument is False, the second equation succeeds. In particular, it does not bother
to evaluate the second argument at all , and simply returns Falseas the answer.
This means that (∧)is strict in its ﬁrst argument, but not its second.
A more detailed discussion of pattern matching is found in Appendix D.
Let’s now look more closely at the last law for map,w h i c hs a y st h a tf o r
all strict f:
f◦head=head◦map f
Let’s try to prove this property, starting with the base case, but ignoring
CHAPTER 10. PROOF BY INDUCTION 151
for now the strictness constraint on f:
f(head[])
⇒f⊥
head[] is an error, which you will recall has value ⊥. So you can see imme-
diately that the issue of strictness might play a role in the proof, becausewithoutknowinganything about f, thereis nofurthercalculation to bedone
here. Similarly, if we start with the right-hand side:
head(map f[])
⇒head[]
⇒⊥
It should be clear that for the base case to be true, it must be that f⊥=⊥;
i.e.,fmust be strict. Thus we have essentially “discovered” the constraint
on the theorem through the process of trying to prove it! (This is not anuncommon phenomenon.)
The induction step is less problematic:
f(head(x:xs))
⇒fx
⇒head(fx:map f xs )
⇒head(map f(x:xs))
and we are done.
Exercise 10.2 Prove as many of the properties in Tables 10.1and10.2as
you can.
Exercise 10.3 Which of the following functions are strict (if the function
takes more than one argument, specify on which arguments it is strict):reverse,simple,map,tail,dur,revM,(∧), (True∧), (False∧), and the
following function:
ifFun ::Bool→a→a→a
ifFun pred cons alt =ifpredthenconselsealt
10.5 Induction on the Music Data Type
Proof by induction is not limited to lists. In particular, we can use it to
reason about Musicvalues.
CHAPTER 10. PROOF BY INDUCTION 152
For example, we will show that:
mFold(:+:) (:=:) Prim Modify =id
To prove this, we again use the extensionality principle, and then proceed
by induction. But what is the base case? Recall that the Musicdata type
is deﬁned as:
CHAPTER 10. PROOF BY INDUCTION 153
dataMusic a =
Prim(Primitive a )
|Music a :+:Music a
|Music a :=:Music a
|Modify Control (Music a)
The only constructor that does not take a Musicvalue as an argument is
Prim, so that in fact is the only base case.
So, starting with this base case:
mFold(:+:) (:=:) Prim Modify (Prim p)
⇒Prim p
⇒id(Prim p)
That was easy! Next, we develop an induction step for each of the three
non-base cases:
mFold(:+:) (:=:) Prim Modify (m1:+:m2)
⇒mFold(:+:) (:=:) Prim Modify m 1:+:
mFold(:+:) (:=:) Prim Modify m 2
⇒m1:+:m2
⇒id(m1:+:m2)
mFold(:+:) (:=:) Prim Modify (m1:=:m2)
⇒mFold(:+:) (:=:) Prim Modify m 1:=:
mFold(:+:) (:=:) Prim Modify m 2
⇒m1:=:m2
⇒id(m1:=:m2)
mFold(:+:) (:=:) Prim Modify (Modify c m )
⇒Modify c (mFold(:+:) (:=:) Prim Modify m )
⇒Modify c m
⇒id(Modify c m )
These three steps were quite easy as well, but is not something we could
have done without induction.
For something more challenging, let’s consider the following:
dur(revM m)=dur m
Again we proceed by i nduction, start ing with the base case:
dur(revM(Prim p))
⇒dur(Prim p)
Sequential composition is straightforward:
CHAPTER 10. PROOF BY INDUCTION 154
dur(revM(m1:+:m2))
⇒dur(revM m 2:+:revM m 1)
⇒dur(revM m 2)+dur(revM m 1)
⇒dur m 2+dur m 1
⇒dur m 1+dur m 2
⇒dur(m1:+:m2)
But things get more complex with parallel composition:
dur(revM(m1:=:m2))
⇒dur(letd1=dur m 1
d2=dur m 2
in ifd1>d2thenrevM m 1:=:(rest(d1−d2): + :revM m 2)
else(rest(d2−d1): + :revM m 1):=:revM m 2)
⇒letd1=dur m 1
d2=dur m 2
in ifd1>d2thendur(revM m 1:=:(rest(d1−d2): + :revM m 2))
elsedur((rest(d2−d1): + :revM m 1):=:revM m 2)
...
At this point, to make things easier to understand, we will consider each
branch of the conditional in turn. First the consequent branch:
dur(revM m 1:=:(rest(d1−d2): + :revM m 2))
⇒max(dur(revM m 1)) (dur(rest(d1−d2): + :revM m 2))
⇒max(dur m 1)(dur(rest(d1−d2): + :revM m 2))
⇒max(dur m 1)(dur(rest(d1−d2))+dur(revM m 2))
⇒max(dur m 1)( (d1−d2)+dur m 2)
⇒max(dur m 1)(dur m 1)
⇒dur m 1
A n dt h e nt h ea l t e r n a t i v e :
dur((rest(d2−d1): + :revM m 1):=:revM m 2)
⇒max(dur((rest(d2−d1): + :revM m 1)) (dur(revM m 2))
⇒max(dur((rest(d2−d1): + :revM m 1)) (dur m 2)
⇒max(dur(rest(d2−d1))+dur(revM m 1)) (dur m 2)
⇒max((d2−d1)+dur m 1)(dur m 2)
⇒max(dur m 2)(dur m 2)
⇒dur m 2
Now we can continue the proof from above:
...
⇒letd1=dur m 1
CHAPTER 10. PROOF BY INDUCTION 155
d2=dur m 2
in ifd1>d2thendur m 1
elsedur m 2
⇒max(dur m 1)(dur m 2)
⇒dur(m1:=:m2)
The ﬁnal inductive step involves the Modifyconstructor, but recall that
durtreats aTempomodiﬁcation specially, and thus we treat it specially as
well:
dur(revM(Modify(Tempo r )m))
⇒dur(Modify(Tempo r )(revM m))
⇒dur(revM m)/r
⇒dur m/r
⇒dur(Modify(Tempo r )m)
Finally, we consider the case that c/negationslash=Tempo r :
dur(revM(Modify c m ))
⇒dur(Modify c (revM m))
⇒Modify c (dur(revM m))
⇒Modify c (dur m)
⇒dur(Modify c m )
And we are done.
Exercise 10.4 Recall Exercises 3.9and3.10.P r o v et h a t ,i f p2/greaterorequalslantp1:
chrom p 1p2=mkScale p 1(take(absPitch p 2−absPitch p 1)
(repeat1))
using the lemma:
[m..n]=scanl(+)m(take(n−m)(repeat1))
Exercise 10.5 Prove the following facts involving dur:
dur(timesM n m )=n∗dur m
dur(cut d m)=d,ifd/lessorequalslantdur m
Exercise 10.6 Prove the following facts involving mMap:
mMap id m =m
mMap f (mMap g m )=mMap(f◦g)m
Exercise 10.7 For that, for all pmap,c,a n dm2:
CHAPTER 10. PROOF BY INDUCTION 156
perf pmap c m 2=(perform pmap c m 2,dur m 2)
whereperform is the function deﬁned in Figure 8.1.
10.5.1 The Need for Musical Equivalence
In Chapter 1we discussed the need for a notion of musical equivalence ,
noting that, for example, m:+:rest0 “sounds the same” as m,e v e ni ft h e
twoMusicvalues are not equal as Haskell values. That same issue can strike
us here as we try to prove intuitively natural properties such as:
revM(revM m)=m
To see why this property cannot be proved without a notion of musical
equivalence, note that:
revM(c4en:=:d4qn)
⇒(rest en:+:c4en):=:d4qn
and therefore:
revM(revM(c4en:=:d4qn))
⇒(rest0: + :c4en:+:rest en):=:d4qn
Clearlythelastlineaboveisnotequal, asaHaskellvalue, to c4en:=:d4qn.
But somehow we need to show that these two values “sound the same” asmusical values. In the next chapter we will formally develop the notion of
musical equivalence, andwithitbeabletoprovethevalidity ofourintuitions
regarding revM, as well as many other important musical properties.
10.6 [Advanced] Induction on Other Data Types
Proof by induction can be used to reason about many data types. For
example, we can use it to reason about natural numbers.2Suppose we
deﬁne an exponentiation function as follows:
(ˆ) ::Integer→Integer→Integer
xˆ0 = 1
xˆn=x∗xˆ(n−1)
2Indeed, one could argue that a proof byinduction over ﬁnitelists is really an induction
over natural numbers, since it is an induction over the lengthof the list, which is a natural
number.
CHAPTER 10. PROOF BY INDUCTION 157
Details: (∗)is deﬁned in the Standard Prelude to have precedence level 7, and
recall that if no inﬁxdeclaration is given for an operator it defaults to precedence
level 9, which means that (ˆ)has precedence level 9, which is higher than that
for(∗). Therefore no parentheses are needed to disambiguate the last line in the
deﬁnition above, which corresponds nicely to mathematical convention.
Now suppose that we want to prove that:
(∀x,n/greaterorequalslant0,m/greaterorequalslant0)xˆ(n+m)=xˆn∗xˆm
We proceed by induction on n, beginning with n=0 :
xˆ(0+m)
⇒xˆm
⇒1∗(xˆm)
⇒xˆ0∗xˆm
Next we assume that the property is true for numbers less than or equal
ton, and prove it for n+1:
xˆ((n+1)+m)
⇒x∗xˆ(n+m)
⇒x∗(xˆn∗xˆm)
⇒(x∗xˆn)∗xˆm
⇒xˆ(n+1)∗xˆm
and we are done.
Or are we? What if, in the deﬁnition of (ˆ), xornisnegative?S i n c ea
negative integer isnotanaturalnumber,wecoulddispensewiththeproblemby saying that these situations fall beyond the boundsof the propertywe are
trying to prove. But let’s look a little closer. If xis negative, the property
we are trying to prove still holds (why?). But if nis negative, xˆnwill not
terminate (why?). As diligent programmers we may wish to defend againstthe latter situation by writing:
(ˆ) :: Integer→Integer→Integer
xˆ0 = 1
xˆn|n<0=error "negative exponent"
|otherwise =x∗xˆ(n−1)
If we consider non-terminating computations andones that producean error
to both have the same value, namely ⊥, then these two versions of (ˆ) are
CHAPTER 10. PROOF BY INDUCTION 158
equivalent. Pragmatically, however, the latter is clearly superior.
Note that the above deﬁnition will test for n<0 on every recursive call,
when actually the only call in which it could happen is the ﬁrst. Thereforea slightly more eﬃcient version of this program would be:
(ˆ)::Integer→Integer→Integer
xˆn|n<0=error "negative exponent"
|otherwise =fxn
wherefx0=1
fxn=x∗fx(n−1)
Provingthepropertystated earlier forthisversion oftheprogramisstraight-
forward, with one minor distinction: what we really need to prove is thatthe property is true for f;t h a ti s :
(∀x,n/greaterorequalslant0,m/greaterorequalslant0)fx(n+m)=fxn∗fxm
from which the proof for the whole function follows trivially.
10.6.1 A More Eﬃcient Exponentiation Function
But in fact there is a more serious ineﬃciency in our exponentiation func-
tion: we are not taking advantage of the fact that, for any even number n,
xn=(x∗x)n/2. Using this fact, here is a more clever way to accomplish
the exponentiation task, using the names (ˆ!) and ﬀfor our functions to
distinguish them from the previous versions:
(ˆ!)::Integer→Integer→Integer
xˆ!n|n<0=error "negative exponent"
|otherwise =ﬀxn
whereﬀxn|n== 0 = 1
|even n =ﬀ(x∗x)(n‘quot‘2)
|otherwise =x∗ﬀx(n−1)
Details: quotis Haskell’s quotient operator, which returns the integer quotient
of the ﬁrst argument divided by the second, rounded toward zero.
You should convince yourself that, intuitively at least, this version of
exponentiation is not only correct, but also more eﬃcient. More precisely,
CHAPTER 10. PROOF BY INDUCTION 159
(ˆ) executes a number of steps proportional to n, whereas (ˆ!) executes a
number of steps proportional to the log2ofn. The Standard Prelude deﬁnes
(ˆ) similarly to the way in which (ˆ!) is deﬁned here.
Since intuition is not always reliable, let’s provethat this version is
equivalent to the old. That is, we wish to prove that xˆn=xˆ!nfor allx
andn.
A quick look at the two deﬁnitions reveals that what we really need
to prove is that fxn=ﬀxn, from which it follows immediately that
xˆn=xˆ!n. We do this by induction on n, beginning with the base case
n=0 :
fx0⇒1⇒ﬀx0
so the base step holds trivially. The induction step, however, is considerably
more complicated. We must consider two cases: n+1 is either even, or it
is odd. If it is odd, we can show that:
fx(n+1)
⇒x∗fxn
⇒x∗ﬀxn
⇒ﬀx(n+1)
and we are done (note the use of the induction hypothesis in the second
step).
Ifn+1 is even, we might try proceeding in a similar way:
fx(n+1)
⇒x∗fxn
⇒x∗ﬀxn
But now what shall we do? Since nis odd, we might try unfolding the call
toﬀ:
x∗ﬀxn
⇒x∗(x∗ﬀx(n−1))
but this doesn’t seem to be getting us anywhere. Furthermore, foldingthe
call toﬀ(as we did in the odd case) would involve doubling n and taking
the square root of x, neither of which seems like a good idea!
We could also try going in the other direction:
ﬀx(n+1)
⇒ﬀ(x∗x)( (n+1)‘quot‘2)
⇒f(x∗x)( (n+1)‘quot‘2)
CHAPTER 10. PROOF BY INDUCTION 160
The use of the induction hypothesis in the second step needs to be justiﬁed,
because the ﬁrst argument to fhas changed from xtox∗x. But recall
that the induction hypothesis states that for allvaluesx, and all natural
numbers up to n,fxnis the same as ﬀxn. So this is OK.
But even allowing this, we seem to be stuck again!Instead of pushing this line of reasoning further, let’s pursue a diﬀerent
tact based on the (valid) assumption that if mis even, then:
m=m‘quot‘2+m‘quot‘2
Let’s use this fact together with the property that we proved in the last
section:
fx(n+1)
⇒fx((n+1)‘quot‘2+(n+1)‘quot‘2)
⇒fx((n+1)‘quot‘2)∗fx((n+1)‘quot‘2)
Next, as with the proof in the last section involving reverse,l e t ’ sm a k ea n
assumption about a property that will help us along. Speciﬁcally, what ifwe could prove that fxn∗fxnis equal to f(x∗x)n?I fs o ,w ec o u l d
proceed as follows:
fx((n+1)‘quot‘2)∗fx((n+1)‘quot‘2)
⇒f
(x∗x)( (n+1)‘quot‘2)
⇒ﬀ(x∗x)( (n+1)‘quot‘2)
⇒ﬀx(n+1)
and we are ﬁnally done. Note the use of the induction hypothesis in the
second step, as justiﬁed earlier. The proof of the auxiliary property is notdiﬃcult, but also requires induction; it is shown in Figure 10.1.
Aside from improving eﬃciency, one of the pleasant outcomes of proving
that (ˆ) and (ˆ!) are equivalent is that anything that we prove about one
function will be true for the other . For example, the validity of the property
that we proved earlier:
xˆ(n+m)=xˆn∗xˆm
immediately implies the validity of:
xˆ!(n+m)=xˆ!n∗xˆ!m
CHAPTER 10. PROOF BY INDUCTION 161
Base case ( n=0 ) :
fx0∗fx0
⇒1∗1
⇒1
⇒f(x∗x)0
Induction step ( n+1):
fx(n+1)∗fx(n+1)
⇒(x∗fxn)∗(x∗fxn)
⇒(x∗x)∗(fxn∗fxn)
⇒(x∗x)∗f(x∗x)n
⇒f(x∗x)(n+1)
Figure 10.1: Proof that fxn∗fxn=f(x∗x)n.
Although (ˆ!) is more eﬃcient than (ˆ), it is also more complicated, so
it makes sense to try proving new properties for (ˆ), since the proofs willlikely be easier.
The moral of this story is that you shouldn’t throw away old code that
is simpler but less eﬃcient than a newer version. That old code can serve
at least two good purposes: First, if it is simpler, it is likely to be easierto understand, and thus serves a useful role in documenting your eﬀort.Second, as we have just discussed, if it is provably equivalent to the newcode, then it can be used to simplify the task of proving properties aboutthe new code.
Exercise 10.8 The function (ˆ!) can be made more eﬃcient by noting that
in the last line of the deﬁnition of ﬀ,nis odd, and therefore n−1m u s t
be even, so the test for nbeing even on the next recursive call could be
avoided. Redeﬁne (ˆ!) so that it avoids this (minor) ineﬃciency.
Exercise 10.9 Consider this deﬁnition of the factorial function:3
fac1::Integer→Integer
fac10=1
fac1n=n∗fac1(n−1)
3The factorial function is deﬁned mathematically as:
factorial (n)=/braceleftbigg1i f n=0
n∗factorial (n−1) otherwise
CHAPTER 10. PROOF BY INDUCTION 162
and this alternative deﬁnition:
fac2::Integer→Integer
fac2n=fac/primen1
wherefac/prime0x=x
fac/primenx=fac/prime(n−1) (n∗x)
Prove that fac1n=fac2nfor all non-negative integers n.

Chapter 11
An Algebra of Music
In this chapter we will explore a number of properties of the Musicdata
type and functions deﬁned on it, properties that collectively form an algebra
of music. With this algebra we can reason about, transform, and optimize
computer music programs in a meaning preserving way.
11.1 Musical Equivalance
Suppose we have two values m1::Music Pitch andm2::Music Pitch ,a n dw e
want to know if they are equal. If we treat them simply as Haskell values,we could easily write a function that compares their structures recursivelyt os e ei ft h e ya r et h es a m ea te v e r yl e v e l ,a l lt h ew a yd o w nt ot h e Primitive
rests and notes. This is in fact what the Haskell function (==) does. Forexample, if:
m
1=c4en:+:d4qn
m2=revM(revM m 1)
Thenm1==m2isTrue.
Unfortunately, as we saw in the last chapter, if we reverse a parallel
composition, things don’t work out as well. For example:
revM(revM(c4en:=:d4qn))
⇒(rest0: + :c4en:+:rest en):=:d4qn
In addition, as we discussed brieﬂy in Chapter 1, there are musical prop-
erties for which standard Haskell equivalence is insuﬃcient to capture. Forexample, we would expect the following two musical values to soundthe
163
CHAPTER 11. AN ALGEBRA OF MUSIC 164
same, regardless of the actual values of m1,m2,a n dm3:
(m1:+:m2): + :m3
m1:+: (m2:+:m3)
In other words, we expect the operator (:+:) to be associative .
The problem is that, as data structures, these two values are notequal
in general, in fact there are no ﬁnite values that can be assigned to m1,m2,
andm3to make them equal.1
The obvious way out of this dilemma is to deﬁnea new notion of equality
that captures the fact that the performances are the same—i.e. if two things
soundthe same, they must be musically equivalent. And thus we deﬁne a
formal notion of musical equivalence:
Deﬁnition: Two musical values m1andm2areequivalent , written
m1≡m2, if and only if:
(∀pm,c)perf pm c m 1=perf pm c m 2
We will study a number of properties in this chapter that capture musi-
cal equivalences, similar in spirit to the associativity of (:+:) above. Each ofthem can be thought of as an axiom, and the set of valid axioms collectively
forms an algebra of music . By proving the validity of each axiom we not
only conﬁrm our intuitions about how music is interpreted, but also gain
conﬁdence that our perform function actually does the right thing. Fur-
thermore, with these axioms in hand, we can transform musical values in
meaning-preserving ways.
Speaking of the perform function, recall from Chapter 8that we deﬁned
twoversions of perform, and the deﬁnition above uses the function perf,
which includes the duration of a musical value in its result. The followingLemma captures the connection between these functions:
Lemma 11.1.1 For allpm,c,a n dm:
perf pm c m =(perform pm c m ,dur m∗cDur c)
whereperform is the function deﬁned in Figure 8.1.
To see the importance of including duration in the deﬁnition of equiv-
alence, we ﬁrst note that if two musical values are equivalent, we should
1Ifm1=m1:+:m2and m3=m2:+:m3then the two expressions are equal, but these
are inﬁnite values that cannot be reversed or even performed.
CHAPTER 11. AN ALGEBRA OF MUSIC 165
be able to substitute one for the other in any valid musical context. But
if duration is not taken into account, then all rests are equivalent (becausetheir performances are just the empty list). This means that, for example,m
1:+:rest1: + :m2is equivalent to m1:+:rest2: + :m2, which is surely not
what we want.
Note that we could have deﬁned perfas above, i.e. in terms of perform
anddur,butasmentioned inSection 8.1itwouldhavebeencomputationally
ineﬃcient to do so. On the other hand, if the Lemma above is true, then
our proofs might be simpler if we ﬁrst proved the property using perform,
a n dt h e nu s i n g dur. That is, to prove m1≡m2we need to prove:
perf pm c m 1=perf pm c m 2
Instead of doing this directly using the deﬁnition of perf, we could instead
prove both of the following:
perform pm c m 1=perform pm c m 2
dur m 1=dur m 2
11.2 Some Simple Axioms
Let’s look at a few simple axioms, and see how we can prove each of them
using the proof techniques that we have developed so far.
(Note: In the remainder of this chapter we will use the functions tempo r
andtrans p to represent their unfolded versions, Modify(Tempo r )a n d
Modify(Transpose t ), respectively. In the proofs we will not bother with
the intermediate steps of unfolding these functions.)
Here is the ﬁrst axiom that we will consider:
Axiom 11.2.1 For anyr1,r2,a n dm:
tempo r 1(tempo r 2m)≡tempo(r1∗r2)m
In other words, tempo scaling is multiplicative .
We can prove this by calculation, starting with the deﬁnition of musical
equivalence. For clarity we will ﬁrst prove the property for perform,a n d
then for dur, as suggested in the last section:
letdt=cDur c
perform pm c (tempo r 1(tempo r 2m))
⇒{unfold perform }
perform pm (c{cDur=dt/r1})(tempo r 2m)
CHAPTER 11. AN ALGEBRA OF MUSIC 166
⇒{unfold perform }
perform pm (c{cDur=(dt/r1)/r2})m
⇒{arithmetic }
perform pm (c{cDur=dt/(r1∗r2)})m
⇒{fold perform }
perform pm c (tempo(r1∗r2)m)
dur(tempo r 1(tempo r 2m))
⇒{unfold dur }
dur(tempo r 2m)/r1
⇒{unfold dur }
(dur m/r2)/r1
⇒{arithmetic }
dur m/(r1∗r2)
⇒{fold dur}
dur(tempo(r1∗r2)m)
Here is another useful axiom and its proof:
Axiom 11.2.2 For anyr,m1,a n dm2:
tempo r(m1:+:m2)≡tempo r m 1:+:tempo r m 2
In other words, tempo scaling distributes over sequential composition .
Proof:
lett=cTime c;dt=cDur c
t1=t+dur m 1∗(dt/r)
t2=t+(dur m 1/r)∗dt
t3=t+dur(tempo r m 1)∗dt
perform pm c (tempo r(m1:+:m2))
⇒{unfold perform }
perform pm (c{cDur=dt/r})(m1:+:m2)
⇒{unfold perform }
perform pm (c{cDur=dt/r})m1
++perform pm (c{cTime=t1,cDur=dt/r})m2
⇒{fold perform }
perform pm c (tempo r m 1)
++perform pm (c{cTime=t1})(tempo r m 2)
⇒{arithmetic }
perform pm c (tempo r m 1)
++perform pm (c{cTime=t2})(tempo r m 2)
CHAPTER 11. AN ALGEBRA OF MUSIC 167
⇒{fold dur}
perform pm c (tempo r m 1)
++perform pm (c{cTime=t3})(tempo r m 2)
⇒{fold perform }
perform pm c (tempo r m 1:+:tempo r m 2)
dur(tempo r(m1:+:m2))
⇒dur(m1:+:m2)/r
⇒(dur m 1+dur m 2)/r
⇒dur m 1/r+dur m 2/r
⇒dur(tempo r m 1)+dur(tempo r m 2)
⇒dur(tempo r m 1:+:tempo r m 2)
An even simpler axiom is given by:
Axiom 11.2.3 For anym,tempo1)m≡m.
In other words, unit tempo scaling is the identity function for type Music .
Proof:
letdt=cDur c
perform pm c (tempo1)m)
⇒{unfold perform }
perform pm (c{cDur=dt/1})m
⇒{arithmetic }
perform pm c m
dur(tempo1)m)
⇒dur m/1
⇒dur m
Note that the above three proofs, being used to establish axioms, all
involve the deﬁnitions of performanddur. In contrast, we can also establish
theorems whose proofs involve only the axioms. For example, Axioms 1, 2,
and 3 are all needed to prove the following:
Theorem 11.2.1 For anyr,m1,a n dm2:
tempo r m 1:+:m2≡tempo r(m1:+:tempo(1/r)m2)
Proof:
tempo r m 1:+:m2
⇒{Axiom3}
CHAPTER 11. AN ALGEBRA OF MUSIC 168
tempo r m 1:+:tempo1)m2
⇒{arithmetic }
tempo r m 1:+:tempo(r∗(1/r))m2
⇒{Axiom1}
tempo r m 1:+:tempo r(tempo(1/r)m2)
⇒{Axiom2}
tempo r(m1:+:tempo(1/r)m2)
11.3 The Axiom Set
There are many other useful axioms, but we do not have room to include all
of their proofs here. They are listed below, which include the axioms fromthe previous section as special cases, and the proofs are left as exercises.
Axiom 11.3.1 Tempoismultiplicative andTranspose isadditive.T h a ti s ,
for anyr
1,r2,p1,p2,a n dm:
tempo r 1(tempo r 2m)≡tempo(r1∗r2)m
trans p 1(trans p 2m)≡trans(p1+p2)m
Axiom 11.3.2 Function composition is commutative with respect to both
tempo scaling and transposition. That is, for any r1,r2,p1andp2:
tempo r 1◦tempo r 2≡tempo r 2◦tempo r 1
trans p 1◦trans p 2≡trans p 2◦trans p 1
tempo r 1◦trans p 1≡trans p 1◦tempo r 1
Axiom 11.3.3 Tempo scaling and transposition are distributive over both
sequential and parallel composition. That is, for any r,p,m1,a n dm2:
tempo r(m1:+:m2)≡tempo r m 1:+:tempo r m 2
tempo r(m1:=:m2)≡tempo r m 1:=:tempo r m 2
trans p(m1:+:m2)≡trans p m 1:+:trans p m 2
trans p(m1:=:m2)≡trans p m 1:=:trans p m 2
Axiom 11.3.4 Sequential and parallel composition are associative .T h a t
is, for any m0,m1,a n dm2:
m0:+: (m1:+:m2)≡(m0:+:m1): + :m2
m0:=:(m1:=:m2)≡(m0:=:m1):=:m2
CHAPTER 11. AN ALGEBRA OF MUSIC 169
Axiom 11.3.5 Parallel composition is commutative .T h a t i s , f o r a n y m0
andm1:
m0:=:m1≡m1:=:m0
Axiom 11.3.6 rest0i saunitfortempoandtrans,a n dazerofor sequential
and parallel composition. That is, for any r,p,a n dm:
tempo r(rest0)≡rest0
trans p(rest0)≡rest0
m:+:rest0≡m≡rest0: + :m
m:=:rest0≡m≡rest0:=:m
Axiom 11.3.7 A rest can be used to “pad” a parallel composition. That is,
for anym1,m2, such that dur m 1>dur m 2,a n da n y d/lessorequalslantdur m 1−dur m 2:
m1:=:m2≡m1:=:(m2:+:rest d)
Axiom 11.3.8 There is a duality between (:+:) and (:=:), namely that, for
anym0,m1,m2,a n dm3such that dur m 0=dur m 2:
(m0:+:m1):=:(m2:+:m3)≡(m0:=:m2): + :(m1:=:m3)
Exercise 11.1 Prove Lemma 11.1.1.
Exercise 11.2 Establish the validity of each of the above axioms.
Exercise 11.3 Recall the function revMdeﬁned in Chapter 2, and note
that, in general, revM(revM m)i sn o te q u a lt o m. However, the following
is true:
revM(revM m)≡m
Prove this fact by calculation.
Exercise 11.4 Prove that timesM a m :+:timesM b m ≡timesM (a+
b)m.
11.4 Soundness and Completeness
TBD
Chapter 12
Musical L-Systems
module Euterpea .Examples .LSystems where
importData.List
importSystem.Random
importEuterpea
12.1 Generative Grammars
Agrammar describes a formal language . One can either design a recognizer
(orparser) for that language, or design a generator that generates sentences
in that language. We are interested in using grammars to generate music,and thus we are only interested in generative grammars.
A generative grammar is a four-tuple ( N,T,n,P ), where:
•Nis the set of non-terminal symbols .
•Tis the set of terminal symbols .
•nis theinitial symbol .
•Pis a set of production rules , where each production rule is a pair
(X,Y), often written X→Y,w h e r e XandYare words over the
alphabet N∪T,a n dXcontains at least one non-terminal.
ALindenmayer system ,o rL-system , is an example of a generative gram-
mer, but is diﬀerent in two ways:
170
CHAPTER 12. MUSICAL L-SYSTEMS 171
1. Thesequence of sentences is as important as the individual sentences,
and
2. Anewsentenceisgeneratedfromthepreviousonebyapplyingasmany
productions as possible on each step—a kind of “parallel production.”
Lindenmayer was a biologist and mathematician, and he used L-systems
to describe the growth of certain biological organisms (such as plants, andin particular algae).
We will limit our discussion to L-systems that have the following addi-
tional characteristics:
1. They are context-free : the left-hand side of each production (i.e. X
above) is a single non-terminal.
2. No distinction is made between terminals and non-terminals (with no
loss of expressive power—why?).
We will consider both deterministic andnon-deterministic grammars.
A deterministic grammar has exactly one production corresponding to each
non-terminal symbol in the alphabet, whereas a non-deterministic grammar
may have more than one, and thus we will need some way to choose betweenthem.
12.2 A Simple Implementation
A very simple context-free, deterministic grammar can be designed as fol-lows. We represent the set of productions as a list of symbol/list-of-symbol
pairs:
dataDetGrammar a =DetGrammar a -- start symbol
[(a,[a])] -- productions
deriving Show
To generate a succession of “sentential forms,” we need to deﬁne a function
that, given a grammar, returns a list of lists of symbols:
detGenerate ::Eq a⇒DetGrammar a →[[a]]
detGenerate (DetGrammar st ps )=iterate(concatMap f )[st]
wherefa=maybe[a]id(lookup a ps )
CHAPTER 12. MUSICAL L-SYSTEMS 172
Details: maybeis a convenient function for conditionally giving a result based
on the structure of a value of type Maybe a. It is deﬁned in the Standard Prelude
as:
maybe ::b→(a→b)→Maybe a →b
maybe
 f(Just x)=fx
maybe z
 Nothing =z
lookup::Eq a⇒a→[(a,b)]→Maybe b is a convenient function for ﬁnding the
value associated with a given key in an association list. For example:
lookup ’b’[(’a’,0),(’b’,1),(’c’,2)]⇒Just1
lookup ’d’[(’a’,0),(’b’,1),(’c’,2)]⇒Nothing
Note that we expand each symbol “in parallel” at each step, using
concatMap . The repetition of this process at each step is achieved using
iterate. Note also that a list of productions is essentially an association list ,
and thus the library function lookupworks quite well in ﬁnding the produc-
tion rule that we seek. Finally, note once again how the use of higher-orderfunctions makes this deﬁnition concise yet eﬃcient.
Asanexampleoftheuseofthissimpleprogram,aLindenmayergrammer
for red algae (taken from []) is given by:
redAlgae =DetGrammar ’a’
[(’a’,"b|c"),
(’b’,"b"),
(’c’,"b|d"),
(’d’,"e\\d"),
(’e’,"f"),
(’f’,"g"),
(’g’,"h(a)"),
(’h’,"h"),
(’|’,"|"),
(’(’,"("),
(’)’,")"),
(’/’,"\\"),
(’\\’,"/")
]
ThendetGenerate redAlgae givesustheresultthatwewant—or, tomake
it look nicer, we could do:
CHAPTER 12. MUSICAL L-SYSTEMS 173
tng=sequence
 (map putStrLn (take n(detGenerate g )))
For example, the 10th element of t10redAlgae is:
"b|b|h(b|b|e\d)\h(b|b|d)/h(b|c)\h(a)/g\f/e\d"
Exercise 12.1 Design a function testDet::Grammar a →Boolsuch that
testDet g isTrueifghas exactly one rule for each of its symbols; i.e. it is
deterministic. Then modify the generate function above so that it returns
an error if a grammer not satisfying this constraint is given as argument.
12.3 Grammars in Haskell
The design given in the last section only captures deterministic context-free grammars. We would also like to consider non-deterministic grammars,where a user can specify the probability that a particular rule is selected, aswell as possibly non-context free (i.e. context sensitive) grammars. Thus wewillrepresentagenerativegrammarabitmoreabstractly, asadatastructurethat has a starting sentence in an (implicit, polymorphic) alphabet, and a
list of production rules:
dataGrammar a =Grammar a -- start sentence
(Rules a) -- production rules
deriving Show
The production rules are instructions for converting sentences in the alpha-
bet to other sentences in the alphabet. A rule set is either a set of uniformlydistributed rules (meaning that those with the same left-hand side have anequal probability of being chosen), or a set of stochastic rules (each of whichis paired with a probabilty). A speciﬁc rule consists of a left-hand side andar i g h t - h a n ds i d e .
dataRules a=Uni[Rule a]
|Sto[(Rule a,Prob)]
deriving (Eq,Ord,Show)
dataRule a=Rule{lhs::a,rhs::a}
deriving (Eq,Ord,Show)
typeProb=Float
One of the key sub-problems that we will have to solve is how to prob-
abilistically select a rule from a set of rules, and use that rule to expand a
CHAPTER 12. MUSICAL L-SYSTEMS 174
non-terminal. We deﬁne the following type to capture this process:
typeReplFun a =[[(Rule a,Prob)]]→(a,[Rand])→(a,[Rand])
typeRand =Float
The idea here is that a function f::ReplFun a is such that fr u l e s(s,rands)
will return a new sentence s/primein which each symbol in shas been replaced
according to some rule in rules(which are grouped by common left-hand
side). Each rule is chosen probabilitically based on the random numbers inrands, and thus the result also includes a new list of random numbers to
account for those “consumed” by the replacement process.
With such a function in hand, we can now deﬁne a function that, given
a grammar, generates an inﬁnite list of the sentences produced by this re-placement process. Because the process is non-deterministic, we also pass aseed (an integer) to generate the initial pseudo-random number sequence togive us repeatable results.
gen::Ord a⇒ReplFun a →Grammar a →Int→[a]
gen f(Grammar s rules )seed=
letSto newRules =toStoRules rules
rands =randomRs (0.0,1.0) (mkStdGen seed )
in ifcheckProbs newRules
thengenerate f newRules (s,rands)
else(error "Stochastic rule-set is malformed." )
toStoRules converts a list of uniformly distributed rules to an equivalent
list of stochastic rules. Each set of uniform rules with the same LHS isconverted to a set of stochastic rules in which the probability of each rule isone over the number of uniform rules.
toStoRules ::(Ord a,Eq a)⇒Rules a→Rules a
toStoRules (Sto rs)=Sto rs
toStoRules (Uni rs)=
letrs
/prime=groupBy (λr1r2→lhs r 1==lhs r 2)(sort rs)
inSto(concatMap insertProb rs/prime)
insertProb ::[a]→[(a,Prob)]
insertProb rules =letprb=1.0/fromIntegral (length rules )
inzip rules (repeat prb )
checkProbs takes a list of production rules and checks whether, for every
rule with the same LHS, the probabilities sum to one (plus or minus someepsilon, currenty set to 0 .001).
checkProbs ::(Ord a,Eq a)⇒[(Rule a,Prob)]→Bool
CHAPTER 12. MUSICAL L-SYSTEMS 175
checkProbs rs =and(map checkSum (groupBy sameLHS (sort rs)))
eps=0.001
checkSum ::[(Rule a,Prob)]→Bool
checkSum rules =letmySum=sum(map snd rules )
inabs(1.0−mySum)/lessorequalslanteps
sameLHS ::Eq a⇒(Rule a,Prob)→(Rule a,Prob)→Bool
sameLHS (r1,f1)(r2,f2)=lhs r 1==lhs r 2
generate takes a list of rules, a replacement function, a starting sentence,
and a source of random numbers. It returns an inﬁnite list of sentences.
generate ::Eq a⇒
ReplFun a →[(Rule a,Prob)]→(a,[Rand])→[a]
generate f rules xs =
letnewRules =map probDist (groupBy sameLHS rules )
probDist rrs =let(rs,ps)=unzip rrs
inzip rs(tail(scanl(+) 0ps))
inmap fst(iterate(fn e w R u l e s )xs)
12.4 An L-System Grammar for Music
The above is all for a generic grammar. For a musical L-system we will
deﬁne a speciﬁc grammar, whose sentences are deﬁned as follows. A musicalL-system sentence is either:
•A non-terminal symbol ( Na).
•A sequential composition s
1:+s2.
•A functional composition s1:.s2.
•The symbol Id, which will eventually interpeted as the identity func-
tion.
We capture this in the LSysdata type:
dataLSys a=Na
|LSys a:+LSys a
|LSys a:.LSys a
|Id
deriving (Eq,Ord,Show)
CHAPTER 12. MUSICAL L-SYSTEMS 176
We also need to deﬁne a replacement function for this grammar. We
treat (:+) and (: .) as binary branches, and recursively traverse each of their
arguments. We treat Idas a constant that never gets replaced. Most impor-
tantly, each non-terminal of the form Nxcould each be the left-hand side
of a rule, so we call the function getNewRHS to generate the replacement
term for it.
replFun::Eq a⇒ReplFun (LSys a)
replFun rules (s,rands)=
casesof
a:+b→let(a/prime,rands/prime)=replFun rules (a,rands)
(b/prime,rands/prime/prime)=replFun rules (b,rands/prime)
in(a/prime:+b/prime,rands/prime/prime)
a:.b→let(a/prime,rands/prime)=replFun rules (a,rands)
(b/prime,rands/prime/prime)=replFun rules (b,rands/prime)
in(a/prime:.b/prime,rands/prime/prime)
Id→(Id,rands)
Nx→(getNewRHS rules (Nx)(head rands ),tail rands )
Note the useof ﬁlterto select onlytheruleswhoseleft-hand sidematches
the non-terminal. A key aspect ofthe algorithm isto generate the probability
densityof the successive rules, which is basically the sum of its probability
plus the probabilities of all rules that precede it. This modiﬁed rule-set isthen given to getNewRHS as an argument. getNewRHS is deﬁned as:
getNewRHS ::Eq a⇒[[(Rule a,Prob)]]→a→Rand→a
getNewRHS rrs ls rand =
letloop((r,p):rs)=ifrand/lessorequalslantpthenrhs r elseloop rs
loop[] = error "getNewRHS anomaly"
in case(ﬁnd(λ((r,p):
)→lhs r==ls)rrs)of
Just rs →loop rs
Nothing →error "No rule match"
12.5 Examples
The ﬁnal step is to interpret the resulting sentence (i.e. a value of type
LSys a) as music. Theintent of the LSysdesign is that a value is interpreted
as afunction that is applied to a single note (or, more generally, a single
Musicvalue). The speciﬁc constructors are interpreted as follows:
typeIR a b=[(a,Music b →Music b)] -- “interpetation rules”
CHAPTER 12. MUSICAL L-SYSTEMS 177
interpret ::(Eq a)⇒LSys a→IR a b→Music b→Music b
interpret (a:.b)rm=interpret a r (interpret b r m )
interpret (a:+b)rm=interpret a r m :+:interpret b r m
interpret Id r m =m
interpret (Nx)rm=case(lookup x r )of
Just f →fm
Nothing →error "No interpetation rule"
For example, we could deﬁne the following interpretation rules:
dataLFun=Inc|Dec|Same
deriving (Eq,Ord,Show)
ir::IR LFun Pitch
ir=[(Inc,Euterpea .transpose 1),
(Dec,Euterpea .transpose (−1)),
(Same,id)]
inc,dec,same::LSys LFun
inc=NI n c
dec=ND e c
same=NS a m e
In other words, inctransposes the music up by one semitone, dectransposes
it down by a semitone, and samedoes nothing.
Now let’s build an actual grammar. scincrements a note followed by its
decrement—the two notes are one whole tone apart:
sc=inc:+dec
Now let’s deﬁne a bunch of rules as follows:
r1a=Rule inc (sc:.sc)
r1b=Rule inc sc
r2a=Rule dec (sc:.sc)
r2b=Rule dec sc
r3a=Rule same inc
r3b=Rule same dec
r3c=Rule same same
and the corresponding grammar:
g1=Grammar same (Uni[r1b,r1a,r2b,r2a,r3a,r3b])
Finally, we generate a sentence at some particular level, and interpret it
as music:
CHAPTER 12. MUSICAL L-SYSTEMS 178
t1n=instrument Vibraphone $
interpret (gen replFun g1 42!!n)ir(c5tn)
Try “play(t13)” or “play(t14)” to hear the result.
Exercise 12.2 Play with the L-System grammar deﬁned above. Change
the production rules. Add probabilities to the rules, i.e. change it into a Sto
grammar. Change the random number seed. Change the depth of recursion.And also try changing the “musical seed” (i.e. the note c5tn).
Exercise 12.3 Deﬁne a new L-System structure. In particular, (a) deﬁne
an e wv e r s i o no f LSys(for example, add a parallel constructor) and its asso-
ciated interpretation, and/or (b) deﬁne a new version of LFun(perhaps add
something to control the volume) and its associated interpretation. Thendeﬁne some grammars with the new design to generate interesting music.

Chapter 13
Random Numbers,
Probability Distributions,and Markov Chains
module Euterpea .Examples .RandomMusic where
importEuterpea
importSystem.Random
importSystem.Random.Distributions
importqualiﬁed Data .MarkovChain as M
The use of randomness in composition can be justiﬁed by the somewhat
random, exploratory nature of the creative mind, and indeed it has beenused in computer music composition for many years. In this chapter wewill explore several sources of random numbers and how to use them ingenerating simple melodies. With this foundation you will hopefully be ableto use randomness in more sophisticated ways in your compositions. Musicrelying at least to some degree on randomness is said to be stochastic ,o r
aleatoric.
13.1 Random Numbers
This section describes the bas ic functionality of Haskell’s System.Random
module, which is a library for random numbers. The library presents afairly abstract interface that is structured in two layers of type classes: one
179
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 180
that captures the notion of a random generator , and one for using a random
generator to create random sequences .
We can create a random number generator using the built-in mkStdGen
function:
mkStdGen ::Int→StdGen
which takes an Intseed as argument, and returns a “standard generator” of
typeStdGen. For example, we can deﬁne:
sGen::StdGen
sGen=mkStdGen 42
We will use this single random generator quite extensively in the remainder
of this chapter.
StdGenis an instance of Show, and thus its values can be printed—but
they appear in a rather strange way, basically as two integers. Try typingsGento the GHCi prompt.
More importantly, StdGenis an instance of the RandomGen class:
classRandomGen g where
genRange ::g→(Int,Int)
next ::g→(Int,g)
split ::g→(g,g)
The reason that Ints are used here is that essentially all pseudo-random
number generator algorithms are based on a ﬁxed-precision binary number,
such asInt. We will see later how this can be coerced into other number
types.
For now, try applying the operators in the above class to the sGenvalue
above. The nextfunction is particularly important, as it generates the next
random number in a sequence as well as a new random number generator,which in turn can be used to generate the next number, and so on. It shouldbe clear that we can then create an inﬁnite list of random Ints like this:
randInts ::StdGen→[Int]
randInts g =let(x
,g/prime)=next g
inx:randInts g/prime
Look at the value take10 (randInts sGen ) to see a sample output.
To support other number types, the Random library deﬁnes this type
class:
classRandom a where
randomR ::RandomGen g ⇒(a,a)→g→(a,g)
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 181
random ::RandomGen g ⇒g→(a,g)
randomRs ::RandomGen g ⇒(a,a)→g→[a]
randoms ::RandomGen g ⇒g→[a]
randomRIO ::(a,a)→IO a
randomIO ::IO a
Built-in instances of Random are provided for Int,Integer,Float,Double,
Bool,a n dChar.
The set of operators in the Random class is rather daunting, so let’s
focus on just one of them for now, namely the third one, RandomRs ,w h i c h
is also perhaps the most useful one. This function takes a random numbergenerator (such as sGen), along with a range of values, and generates an
inﬁnite list of random numberswithin the given range (the pair representingthe range is treated as a closed interval). Here are several examples of thisidea:
randFloats ::[Float]
randFloats =randomRs (−1,1)sGen
randIntegers ::[Integer]
randIntegers =randomRs (0,100)sGen
randString ::String
randString
=randomRs (’a’,’z’)sGen
Recall that a string is a list of characters, so we choose here to use the name
randString for our inﬁnite list of characters. If you believe the story about
a monkey typing a novel, then you might believe that randString contains
something interesting to read.
So far we have used a seed to initialize our random number generators,
and this is good in the sense that it allows us to generate repeatable, and
therefore more easily testable, results. If instead you prefer a non-repeatableresult, in which you can think of the seed as being the time of day whenthe program is executed, then you need to use a function that is in the IOmonad. The last two operators in the Random class serve this purpose. For
example, consider:
randIO::IO Float
randIO=randomRIO (0,1)
If you repeatedly type randIOat the GHCi prompt, it will return a diﬀerent
random number every time. This is clearly not purely “functional,” and iswhy it is in the IO monad. As another example:
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 182
randIO/prime::IO()
randIO/prime=dor1←randomRIO (0,1) ::IO Float
r2←randomRIO (0,1) ::IO Float
print(r1==r2)
will almost always return False, because the chance of two randomly gener-
ated ﬂoating point numbers being the same is exceedingly small. (The typesignature is needed to ensure that the value generated has an unambigoustype.)
Details: print::Show a⇒a→IO()converts any showable value into a string,
and displays the result in the standard output area.
13.2 Probability Distributions
The random number generators described in the previous section are as-
sumed to be uniform, meaning that the probability of generating a number
within a given interval is the same everywhere in the range of the generator.For example, in the case of Float(that purportedly represents continuous
real numbers), suppose we are generating numbers in the range 0 to 10.Then we would expect the probability of a number appearing in the range
2.3-2.4 to be the same as the probability of a number appearing in the range
7.6-7.7, namely 0 .01, or 1% (i.e. 0 .1/10). In the case of Int(adiscrete or
integralnumber type), we would expect the probability of generating a 5
to be the same as generating an 8. In both cases, we say that we have auniform distribution .
Butwedon’talways wantauniformdistribution. Ingenerating music, in
fact, it’softenthecasethatwewantsomekindofanon-uniformdistribution.Mathematically, the best way to describe a distribution is by plotting howthe probability changes over the range of values that it produces. In thecase of continuous numbers, this is called the probability density function ,
which has the property that its integral over the full range of values is equal
to 1.
TheSystem.Random.Distributions libraryprovides a numberof diﬀerent
probability distributions, which are described below. Figure 13.1shows the
probability density functions for each of othem.
Here is a list and brief description of each random number generator:
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 183
 0 0.5 1 1.5 2
 0  1f(x)
x
(a) Linearλ
 01/λf(x)
x
(b) Exponential
 0λ/2
-1/λ 01/λf(x)
x
(c) Bilateral exponential 0 0.5 1
-1  0f(x)
xμ = 0,
σ = 1.0
μ = -1,
σ = 0.5
(d) Gaussian
1/(α*π)
-α 0 αf(x)
x
(e) Cauchy 0 0.1 0.2 0.3 0.4
 0  4  8  12  16  20f(x)
xλ = 1
λ = 5
λ = 10
(f) Poisson
Figure 13.1: Various Probability Density Functions
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 184
linearGenerates a linearlydistributed random variable between 0 and 1.
The probability density function is given by:
f(x)=/braceleftbigg2(1−x)i f 0 /lessorequalslantx/lessorequalslant1
0o t h e r w i s e
The type signature is:
linear::(RandomGen g ,Floating a ,Random a ,Ord a)⇒
g→(a,g)
The mean value of the linear distribution is 1 /3.
exponential Generates an exponentially distributed random variable given
a spread parameter λ. A larger spread increases the probability of
generating a small number. The mean of the distribution is 1 /λ.T h e
range of the generated number is conceptually 0 to ∞, although the
chance of getting a very large number is very small. The probabilitydensity function is given by:
f(x)=λe
−λx
The type signature is:
exponential ::(RandomGen g ,Floating a ,Random a )⇒
a→g→(a,g)
The ﬁrst argument is the parameter λ.
bilateral exponential Generates a random number with a bilateral expo-
nentialdistribution. It is similar to exponential, but the mean of the
distribution is 0 and 50% of the results fall between −1/λand 1/λ.
The probability density function is given by:
f(x)=1
2λe−λ|x|
The type signature is:
bilExp::(Floating a ,Ord a,Random a ,RandomGen g )⇒
a→g→(a,g)
Gaussian Generatesarandomnumberwitha Gaussian , alsocalled normal,
distribution, given mathematically by:
f(x)=1
σ√
2πe−(x−μ)2
2σ2
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 185
whereσis thestandard deviation ,a n dμis themean. The type signa-
ture is:
gaussian ::(Floating a ,Random a ,RandomGen g )⇒
a→a→g→(a,g)
The ﬁrst argument is the standard deviation σand the second is the
meanμ. Probabilistically, about 68.27% of the numbers in a Gaussian
distribution fall within ±σof the mean; about 95 .45% are within ±2σ,
and 99.73% are within ±3σ.
Cauchy Generates a Cauchy-distributed random variable. The distribu-
tion is symmetric with a mean of 0. The density function is givenby:
f(x)=α
π(α2+x2)
As with the Gaussian distribution, it is unbounded both above and
below the mean, but at its extremes it approaches 0 more slowly than
the Gaussian. The type signature is:
cauchy::(Floating a ,Random a ,RandomGen g )⇒
a→g→(a,g)
The ﬁrst argument corresponds to αabove, and is called the density.
Poisson Generates a Poisson-distributed random variable. The Poisson
distribution is discrete, and generates only non-negative numbers. λ
is the mean of the distribution. If λis an integer, the probability that
the result is j=λ−1 is the same as that of j=λ. The probability of
generating the number jis given by:
P{X=j}=λj
j!e−λ
The type signature is:
poisson::(Num t,Ord a,Floating a ,Random a
RandomGen g )⇒
a→g→(t,g)
Custom Sometimes it is useful to deﬁne one’s own discrete probability dis-
tribution function, and to generate random numbers based on it. Thefunction frequency does this—given a list of weight-value pairs, it gen-
erates a value randomly picked from the list, weighting the probabilityof choosing each value by the given weight.
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 186
frequency ::(Floating w ,Ord w,Random w ,RandomGen g )⇒
[(w,a)]→g→(a,g)
13.2.1 Random Melodies and Random Walks
Note that each of the non-uniform distribution random number generators
described in the last section takes zero or more parameters as arguments,along with a uniform random number generator, and returns a pair consist-ing of the next random number and a new generator. In other words, thetail end of each type signature has the form:
...→g→(a,g)
wheregis the type of the random number generator, and ai st h et y p eo f
the next value generated.
Given such a function, we can generate an inﬁnite sequence of random
numbers with the given distribution in a way similar to what we did earlierforrandInts. In fact the following function is deﬁned in the Distributions
library to make this easy:
rands ::(RandomGen g ,Random a )⇒
(g→(a,g))→g→[a]
rands f g =x:rands f g
/primewhere(x,g/prime)=fg
Let’s work through a few musical examples. One thing we will need to
do is convert a ﬂoating point number to an absolute pitch:
toAbsP 1::Float→AbsPitch
toAbsP 1x=round(40∗x+30)
This function converts a number in the range 0 to 1 into an absolute pitch
in the range 30 to 70.
And as we have often done, we will also need to convert an absolute
pitch into a note, and a sequence of absolute pitches into a melody:
mkNote 1::AbsPitch →Music Pitch
mkNote 1=note tn◦pitch
mkLine 1::[AbsPitch ]→Music Pitch
mkLine 1rands=line(take32 (map mkNote 1rands))
With these functions in hand, we can now generate sequences of random
numbers with a variety of distributions, and convert each of them into a
melody. For example:
-- uniform distribution
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 187
m1::Music Pitch
m1=mkLine 1(randomRs (30,70)sGen)
-- linear distribution
m2::Music Pitch
m2=letrs1=rands linear sGen
inmkLine 1(map toAbsP 1rs1)
-- exponential distribution
m3::Float→Music Pitch
m3lam=letrs1=rands(exponential lam )sGen
inmkLine 1(map toAbsP 1rs1)
-- Gaussian distribution
m4 ::Float→Float→Music Pitch
m4sig mu=letrs1=rands(gaussian sig mu )sGen
inmkLine 1(map toAbsP 1rs1)
Exercise 13.1 Try playing each of the above melodies, and listen to the
musical diﬀerences. For lam,t r yv a l u e so f0 .1, 1, 5, and 10. For mu,av a l u e
of 0.5 will put the melody in the central part of the scale range—then try
values of 0 .01, 0.05, and 0 .1f o rsig.
Exercise 13.2 Do the following:
•Try using some of the other probability distributions to generate a
melody.
•Instead of using a chromatic scale, try using a diatonic or pentatonic
scale.
•Try using randomness to control parameters other than pitch—in par-
ticular, duration and/or volume.
Another approach to generating a melody is sometimes called a random
walk. The idea is to start on a particular note, and treat the sequence of
random numbersas intervals, rather than as pitches. To prevent the melody
from wandering too far from the starting pitch, one should use a probabilitydistribution whose mean is zero. This comes for free with something like thebilateral exponential, and is easily obtained with a distribution that takesthe mean as a parameter (such as the Gaussian), but is also easily achieved
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 188
for other distributions by simply subtracting the mean. To see these two
situations, here are random melodic walks using ﬁrst a Gaussian and thenan exponential distribution:
-- Gaussian distribution with mean set to 0
m
5::Float→Music Pitch
m5sig=letrs1=rands(gaussian sig 0)sGen
inmkLine 250 (map toAbsP 2rs1)
-- exponential distribution with mean adjusted to 0
m6::Float→Music Pitch
m6lam=letrs1=rands(exponential lam )sGen
inmkLine 250 (map(toAbsP 2◦subtract (1/lam))rs1)
toAbsP 2::Float→AbsPitch
toAbsP 2x=round(5∗x)
mkLine 2::AbsPitch →[AbsPitch ]→Music Pitch
mkLine 2start rands =
line(take64 (map mkNote 1(scanl(+)start rands )))
Note that toAbsP 2does something reasonable to interpret a ﬂoating-point
number as an interval, and mkLine 2usesscanlto generate a “running sum”
that represents the melody line.
13.3 Markov Chains
Each number in the random number sequences that we have described thus
far isindependent of any previous values in the sequence. This is like ﬂip-
ping a coin—each ﬂip has a 50% chance of being heads or tails, i.e. it isindependent of any previous ﬂips, even if the last ten ﬂips were all heads.
Sometimes, however, we would like the probability of a new choice to
depend upon some number of previous choices. This is called a conditional
probability . In a discrete system, if we look only at the previous value to help
determine the next value, then these conditional probabilities can be con-veniently represented in a matrix. For example, if we are choosing betweenthe pitches C,D,E,a n dF,t h e nT a b l e 13.1might represent the conditional
probabilities of each possible outcome. The previous pitch is found in theleft column—thus note that the sum of each row is 1 .0. So, for example,
the probability of choosing a Dgiven that the previous pitch was an Eis
0.6, and the probability of an Foccurring twice in succession is 0 .2. The
resulting stochastic system is called a Markov Chain .
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 189
C
D
E
F
C
0.4
0.2
0.2
0.2
D
0.3
0.2
0.0
0.5
E
0.1
0.6
0.1
0.2
F
0.2
0.3
0.3
0.2
Table 13.1: Second-Order Markov Chain
This idea can of course be generalized to arbitrary numbers of previous
events, and in general an ( n+1)-dimensional array can be used to store the
various conditional probabilities. The number of previous values observedis called the orderof the Markov Chain.
[TO DO: write the Haskell code to implement this]
13.3.1 Training Data
Instead of generating the conditional probability table ourselves, another
approach is to use training data from which the conditional probabilities
can beinferred. This is handy for music, because it means that we can
feed in a bunch of melodies that we like, including melodies written by themasters, and use that as a stochastic basis for generating new melodies.
[TO DO: Give some pointers to the literatue, in particular David Cope’s
work.]
TheData.MarkovChain library provides this functionality through a
function called run, whose type signature is:
run::(Ord a,RandomGen g )⇒
Int -- order of Markov Chain
→[a] -- training sequence (treated as circular list)
→Int-- index to start within the training sequence
→g-- random number generator
→[a]
TherunMulti function is similar, except that it takes a list of training se-
quences as input, and returns a list of lists as its result, each being an in-dependent random walk whose probabilities are based on the training data.The following examples demonstrate how to use these functions.
-- some sample training sequences
ps
0,ps1,ps2::[Pitch]
CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 190
ps0=[(C,4),(D,4),(E,4)]
ps1=[(C,4),(D,4),(E,4),(F,4),(G,4),(A,4),(B,4)]
ps2=[(C,4),(E,4),(G,4),(E,4),(F,4),(A,4),(G,4),(E,4),
(C,4),(E,4),(G,4),(E,4),(F,4),(D,4),(C,4)]
-- functions to package up runandrunMulti
mc ps n =mkLine 3(M.r u nnp s 0(mkStdGen 42))
mcm pss n =mkLine 3(concat(M.runMulti n pss 0
(mkStdGen 42)))
-- music-making functions
mkNote 3::Pitch→Music Pitch
mkNote 3=note tn
mkLine 3::[Pitch]→Music Pitch
mkLine 3ps=line(take64 (map mkNote 3ps))
Here are some things to try with the above deﬁnitions:
•mc ps00 will generate a completely random sequence, since it is a
“zeroth-order” Markov Chain that does not look at any previous out-put.
•mc ps
01 looks back one value, which is enough in the case of this
simple training sequence to generate an endless sequence of notes thatsounds just like the training data. Using any order higher than 1
generates the same result.
•mc ps
11 also generates a result that sounds just like its training data.
•mc ps21, on the other hand, has some (random) variety to it, because
the training data has more than one occurrence of most of the notes. Ifwe increase the order, however, the output will sound more and more
like the training data.
•mcm[ps
0,ps2]1a n d mcm[ps1,ps2] 1 generate perhaps the most
interesting results yet, in which you can hear aspects of both the as-cending melodic nature of ps
0andps1, and the harmonic structure of
ps2.
•mcm[ps1,reverse ps1] 1 has, not suprisingly, both ascending and
descending lines in it, as reﬂected in the training data.

CHAPTER 13. RANDOM NUMBERS ... AND MARKOV CHAINS 191
Exercise 13.3 Play with Markov Chains. Use them to generate more
melodies, or to control other aspects of the music, such as rhythm. Alsoconsiderother kindsoftrainingdataratherthansimplysequencesofpitches.

Chapter 14
From Performance to Midi
module Euterpea .IO.MIDI.ToMidi(toMidi,UserPatchMap ,defST,
defUpm,testMidi,testMidiA ,
test,testA,play,playM,playA,
makeMidi ,mToMF,gmUpm,gmTest)where
importEuterpea .Music.Note.Music
importEuterpea .Music.Note.MoreMusic
importEuterpea .Music.Note.Performance
importEuterpea .IO.MIDI.GeneralMidi
importEuterpea .IO.MIDI.MidiIO
importSound.PortMidi
importData.List(partition )
importData.Char(toLower,toUpper)
importCodec.Midi
Midi is shorthand for “Musical Instrument Digital Interface,” and is a
standard protocol for controlling electronic musical instruments. This chap-
ter describes how to convert an abstract performance as deﬁned in Chapter
8into astandard Midi ﬁle t h a tc a nb ep l a y e do na n ym o d e r nP Cw i t ha
standard sound card.
14.1 An Introduction to Midi
Midi is a standard adopted by most, if not all, manufacturers of electronic
instruments and personal computers. At its core is a protocol for commu-
nicating musical events (note on, note oﬀ, etc.) and so-called meta events
192
CHAPTER 14. FROM PERFORMANCE TO MIDI 193
(select synthesizer patch, change tempo, etc.). Beyond the logical protocol,
the Midi standard also speciﬁes electrical signal characteristics and cablingdetails, as well as a standard Midi ﬁle which any Midi-compatible software
package should be able to recognize.
Most “sound-blaster”-like sound cards on conventional PC’s know about
Midi. However, the sound generated by such modules, and the sound pro-duced from the typically-scrawny speakers on most PC’s, is often quite poor.It is best to use an outboard keyboard or tone generator, which are attached
to a computer via a Midi interface and cables. It is possible to connect sev-
eralMidiinstrumentstothesamecomputer,witheach assignedtoadiﬀerentchannel. Modern keyboards and tone generators are quite good. Not only
is the sound excellent (when played on a good stereo system), but they arealsomulti-timbral , which means they are able to generate many diﬀerent
sounds simultaneously, as well as polyphonic , meaning that simultaneous
instantiations of the same sound are possible.
14.1.1 General Midi
Over the years musicians and manufacturers decided that they also wanted astandard way to refer to commonly used instrument sounds, such as “acous-tic grand piano,” “electric piano,” “violin,” and “acoustic bass,” as well asmore exotic sounds such as “chorus aahs,” “voice oohs,” “bird tweet,” and“helicopter.” A simple standard known as General Midi was developed to
ﬁll this role. The General Midi standard establishes standard names for 128common instrument sounds (also called “patches”) and assigns an integercalled the program number (also called “program change number”), to each
of them. The instrument names and their program numbers are groupedinto “familes” of instrument sounds, as shown in Table 14.1.
Now recall that in Chapter 2we deﬁned a set of instruments via the
InstrumentName data type (see Figure 2.1). All of the names chosen for
thatdata typecome directlyfromtheGeneralMidistandard, exceptfortwo,Percussion andCustom, which were added for convenience and extensibil-
ity. By listing the constructors in the order that reﬂects this assignment, wecan derive an Enuminstance for InstrumentName that deﬁnes the method
toEnum that essentially does the conversion from instrument name to pro-
gram number for us. We can then deﬁne a function:
toGM::InstrumentName →ProgNum
toGM Percussion =0
toGM(Custom name )=0
CHAPTER 14. FROM PERFORMANCE TO MIDI 194
Family
 Program #
 Family
 Program #
Piano
 1-8
 Reed
 65-72
Chromatic Percussion
 9-16
 Pipe
 73-80
Organ
 17-24
 Synth Lead
 81-88
Guitar
 25-32
 Synth Pad
 89-96
Bass
 33-40
 Synth Eﬀects
 97-104
Strings
 41-48
 Ethnic
 105-112
Ensemble
 49-56
 Percussive
 113-120
Brass
 57-64
 Sound Eﬀects
 121-128
Table 14.1: General Midi Instrument Families
toGM in=fromEnum in
typeProgNum =Int
that takes care of the two extra cases, which are simply assigned to program
number 0.
The derived Enuminstance also deﬁnes a function fromEnum that con-
verts program numbers to instrument names. We can then deﬁne:
fromGM ::ProgNum →InstrumentName
fromGM pn |pn/greaterorequalslant0∧pn/lessorequalslant127 =fromEnum pn
fromGM pn =error("fromGM: " ++show pn ++
" is not a valid General Midi program number" )
Details: Design bug: Because the IntrumentName data type contains a non-
nullary constructor, namely Custom,t h eEnuminstance cannot be derived. For
now it is deﬁned in the module GeneralMidi , but a better solution is to redeﬁne
InstrumentName in such a way as to avoid this.
14.1.2 Channels and Patch Maps
AM i d ichannel is in essence a programmable instrument. You can have
up to 16 channels, numbered 0 through 15, each assigned a diﬀerent pro-gram number (corresponding to an instrument sound, see above). All ofthe dynamic “Note On” and “Note Oﬀ” messages (to be deﬁned shortly)are tagged with a channel number, so up to 16 diﬀerent instruments can becontrolled independently and simultaneously.
CHAPTER 14. FROM PERFORMANCE TO MIDI 195
The assignment of Midi channels to instrument names is called a patch
map, and we deﬁne a simple association list to capture its structure:
typeUserPatchMap =[(InstrumentName ,Channel)]
typeChannel =Int
The only thing odd about Midi Channels is that General Midi speci-
ﬁes that Channel 10 (9 in Euterpea’s 0-based numbering) is dedicated topercussion (which is diﬀerent from the “perc ussive instruments” described
in Table 14.1). When Channel 10 is used, any program number to which
it is assigned is ignored, and instead each note corresponds to a diﬀerent
percussion sound. In particular, General Midi speciﬁes that the notes cor-responding to Midi Keys 35 through 82 correspond to speciﬁc percussivesounds. Indeed, recall that in Chapter 6we in fact captured these percus-
sion sounds through the PercussionSound data type, and we deﬁned a way
to convert such a sound into an absolute pitch (i.e. AbsPitch ). Euterpea’s
absolute pitches, by the way, are in one-to-one correspondence with MidiKey nunmbers.
Except for percussion, the Midi Channel used to represent a particular
instrument is completely arbitrary. Indeed, it is tedious to explicitly deﬁnea new patch map every time the instrumentation of a piece of music is
changed. Therefore it is convenient to deﬁne a function that automatically
creates a UserPatchMap from a list of instrument names:
makeGMMap ::[InstrumentName ]→UserPatchMap
makeGMMap ins =mkGMMap 0ins
wheremkGMMap
[]=[]
mkGMMap n
 |n/greaterorequalslant15 =
error "MakeGMMap: Too many instruments."
mkGMMap n (Percussion :ins)=
(Percussion ,9):mkGMMap n ins
mkGMMap n (i:ins)=
(i,chanList !!n):mkGMMap (n+1)ins
chanList =[0..8]++[10..15] -- channel 9 is for percussion
Note that, since there are only 15 Midi channels plus percussion, we can
handle only 15 diﬀerent instruments, and an error is signaled if this limit isexceeded.
1
1It is conceivable to deﬁneafunction to test whetheror not two tracks can becombined
with a Program Change (tracks can be combined if they don’t overlap), but this remains
for future work.
CHAPTER 14. FROM PERFORMANCE TO MIDI 196
Finally, we deﬁne a function to look up an InstrumentName in a
UserPatchMap , and return the associated channel as well as its program
number:
upmLookup ::UserPatchMap →InstrumentName
→(Channel,ProgNum )
upmLookup upm iName =(chan,toGM iName )
wherechan=maybe(error("instrument " ++show iName ++
" not in patch map" ))
id(lookup iName upm )
14.1.3 Standard Midi Files
The Midi standard deﬁnes the precise format of a standard Midi ﬁle .A tt h e
time when the Midi standard was ﬁrst created, disk space was at a premium,and thus a compact ﬁle structure was important. Standard Midi ﬁles arethus deﬁned at the bit and byte level, and are quite compact. We are notinterested in this low-level representation (any more than we are interested
in the signals that run on Midi cables), and thus in Euterpea we take a more
abstract approach: We deﬁne an algebraic data type called Midito capture
the abstract structure of a standard Midi ﬁle, and then deﬁne functions toconvert valuesofthisdatatypetoandfromactualMidiﬁles. Thisseparationof concerns makes the structure of the Midi ﬁle clearer, makes debuggingeasier, and provides a natural path for extending Euterpea’s functionalitywith direct Midi capability.
We will not discuss the details of the functions that read and write
the actual Midi ﬁles; the interested reader may ﬁnd them in the modulesReadMidi andOutputMidi , respectively. Instead, we will focus on the Midi
data type, which is deﬁned in the module Codec.Midi. We do not need all
of its functionality, and thus we show in Figure 14.1only those parts of the
module that we need for this chapter. Here are the salient points about thisdata type and the structure of Midi ﬁles:
1. There are three types of Midi ﬁles:
•AF o r m a t0 ,o r SingleTrack , Midi ﬁle stores its information in
a single track of events, and is best used only for monophonicmusic.
•AF o r m a t1 ,o r MultiTrack , Midi ﬁle stores its information in
multiple tracks that are played simultaneously, where each tracknormally corresponds to a single Midi Channel.
CHAPTER 14. FROM PERFORMANCE TO MIDI 197
-- From the Codec.Midimodule
dataMidi=Midi{ﬁleType::FileType ,
timeDiv ::TimeDiv
tracks::[Track Ticks ]}
deriving (Eq,Show)
dataFileType =SingleTrack |MultiTrack |MultiPattern
deriving (Eq,Show)
typeTrack a=[(a,Message)]
dataTimeDiv =TicksPerBeat Int -- 1 through (215-1 )
|...
deriving (Show,Eq)
typeTicks =Int-- 0 through (228-1 )
typeTime =Double
typeChannel =Int-- 0 through 15
typeKey =Int-- 0 through 127
typeVelocity =Int-- 0 through 127
typePressure =Int-- 0 through 127
typePreset =Int-- 0 through 127
typeTempo =Int-- microseconds per beat, 1 through (224-1 )
dataMessage =
-- Channel MessagesNoteOﬀ {channel::!Channel,key::!Key,velocity::!Velocity}
|NoteOn {channel::!Channel,key::!Key,velocity::!Velocity}
|ProgramChange {channel::!Channel,preset::!Preset}
|...
-- Meta Messages
|TempoChange !Tempo|
|...
deriving (Show,Eq)
fromAbsTime ::(Num a)⇒Track a→Track a
fromAbsTime trk =zip ts
/primems
where(ts,ms)=unzip trk
(
,ts/prime)=mapAccumL (λacc t→(t,t−acc)) 0ts
Figure 14.1: Partial Deﬁnition of the MidiData Type
CHAPTER 14. FROM PERFORMANCE TO MIDI 198
•AF o r m a t2 ,o r MultiPattern , Midi ﬁle also has multiple tracks,
but they are temporally independent.
In this chapter we only use SingleTrack andMultiTrack Midi ﬁles,
depending on how many Channels we need.
2. TheTimeDiv ﬁeld refers to the time-code division used by the Midi
ﬁle. We will always use 96 time divisions, or “ticks,” per quarternote,and thus this ﬁeld will always be TicksPerBeat 96.
3. The main body of a Midi ﬁle is a list of Tracks, each of which in turn
is a list of time-stamped (in number of ticks) Messages (or “events”).
4. There are two kinds of Messages:channel messages andmeta mes-
sages.F i g u r e 14.1shows just those messages that we are interested
in:
(a)NoteOn ch k v turns on key (pitch) kwith velocity (volume) v
on Midi channel ch. The velocity is an integer in the range 0 to
127.
(b)NoteOﬀ ch k v performs a similar function in turning the note
oﬀ.
(c)ProgChange ch pr sets the program number for channel chtopr.
This is how an instrument is selected.
(d)TempoChange t sets the tempo to t, which is the time, in mi-
croseconds, of one whole note. Using 120 beats per minute as thenorm, or 2 beats per second, that works out to 500,000 microsec-
onds per beat, which is the default value that we will use.
14.2 Converting a Performance into Midi
Our goal is to convert a value of type Performance into a value of type Midi.
We can summarize the situation pictorially as follows ...
Given a UserPatchMap ,aPerformance is converted into a Midivalue
by thetoMidifunction. If the given UserPatchMap is invalid, it creates a
new one using makeGMMap described earlier.
toMidi::Performance →UserPatchMap →Midi
toMidi pf upm =
letsplit=splitByInst pf
CHAPTER 14. FROM PERFORMANCE TO MIDI 199
insts =map fst split
rightMap =if(allValid upm insts )thenupm
else(makeGMMap insts )
inMidi(iflength split == 1 thenSingleTrack
elseMultiTrack )
(TicksPerBeat division )
(map(fromAbsTime ◦performToMEvs rightMap )split)
division=9 6: :Int
The following function is used to test whether or not every instrument
in a list is found in a UserPatchMap :
allValid::UserPatchMap →[InstrumentName ]→Bool
allValid upm =and◦map(lookupB upm )
lookupB ::UserPatchMap →InstrumentName →Bool
lookupB upm x =or(map((==x)◦fst)upm)
The strategy is to associate each channel with a separate track. Thus
we ﬁrst partition the event list into separate lists for each instrument, andsignal an error if there are more than 16:
splitByInst ::Performance →[(InstrumentName ,Performance )]
splitByInst []=[]
splitByInst pf =(i,
pf1):splitByInst pf2
wherei=eInst(head pf)
(pf1,pf2)=partition (λe→eInst e==i)pf
Note how partition is used to group into pf1those events that use the same
instrument as the ﬁrst event in the performance. The rest of the events arecollected into pf
2, which is passed recursively to splitByInst .
Details: partition takes a predicate and a list and returns a pair of lists: those
elements that satisfy the predicate, and those that do not, respectively. partition
is deﬁned in the ListLibrary as:
partition ::(a→Bool)→[a]→([a],[a])
partition p xs =
foldr select ([],[])xs
whereselect x(ts,fs)|px=(x:ts,fs)
|otherwise =(ts,x:fs)
CHAPTER 14. FROM PERFORMANCE TO MIDI 200
The crux of the conversion process is in performToMEvs , which converts
aPerformance into a stream of time-stamped messages, i.e. a stream of
(Tick,Message)p a i r s :
typeMEvent =(Ticks,Message)
defST= 500000
performToMEvs ::UserPatchMap
→(InstrumentName ,Performance )
→[MEvent]
performToMEvs upm (inm,pf)=
let(chan,progNum )=upmLookup upm inm
setupInst =( 0,ProgramChange chan progNum )
setTempo =( 0,TempoChange defST )
loop[] =[]
loop(e:es)=let(mev1,mev2)=mkMEvents chan e
inmev1:insertMEvent mev2 (loop es)
insetupInst :setTempo :loop pf
A source of incompatibilty between Euterpea and Midi is that Euterpea
representsnoteswith an onsetandaduration, whileMidirepresentsthem astwo separate events, a note-on event and a note-oﬀ event. Thus MkMEvents
turns a Euterpea Eventinto two MEvents ,aNoteOn and aNoteOﬀ.
mkMEvents ::Channel
→Event→(MEvent,MEvent)
mkMEvents mChan (Event{eTime=t,ePitch=p,
eDur=d,eVol=v})
=( (toDelta t ,NoteOn mChan p v/prime),
(toDelta(t+d),NoteOﬀ mChan p v/prime))
wherev/prime=max0(min127 (fromIntegral v ))
toDelta t =round(t∗2.0∗fromIntegral division )
The time-stamp associated with an event in Midi is called a delta-time ,
and is the time at which the event should occur expressed in time-codedivisions since the beginning of the performance. Since there are 96 time-code divisions per quarter note, there are 4 times that many in a whole note;multiplying that by the time-stamp on one of our Eventsg i v e su st h ep r o pe r
delta-time.
I nt h ec o d ef o r performToMEvs , note that the location of the ﬁrst event
returned from mkMEvents is obvious; it belongs just where it was created.
However, the second event must be inserted into the proper place in the restof the stream of events; there is no way to know of its proper position ahead
CHAPTER 14. FROM PERFORMANCE TO MIDI 201
of time. The function insertMEvent is thus used to insert an MEvent into
an already time-ordered sequence of MEvents.
insertMEvent ::MEvent →[MEvent]→[MEvent]
insertMEvent mev1 []=[mev1]
insertMEvent mev1 @(t1,
)mevs@(mev2@(t2,
):mevs/prime)=
ift1/lessorequalslantt2thenmev1:mevs
elsemev2:insertMEvent mev1 mevs/prime
14.3 Putting It All Together
[To do: Move the code for the PerformanceDefault type class, the family
ofplayfunctions, and so on, to this section. ]
Chapter 15
Basic Input/Output
So far the only input/output (IO) that we have seen in Euterpea is
the use of the playfunction to generate the Midi output corresponding to
aMusicvalue. But we’ve said very little about the playfunction itself.
What is its type? How does it work? How does one do IO in a purelyfunctional language such as Haskell? Our goal in this chapter is to answer
these questions. Then in the next chapter we will describe an elegant way
to do IO involving a “musical user interface,” or MUI.
15.1 IO in Haskell
The Haskell Report deﬁnes the result of a program to be the value of the
variablemainin themodule Main. Thisisameretechnicality, however, only
having relevance when you compile a program as a stone-alone executable
(see the GHC documentation for a discussion of how to do that).
The way most people run Haskell programs, especially during program
development, is through the GHCi command prompt. As you know, theGHCi implementation of Haskell allows you to type whatever expressionyou wish to the command prompt, and it will evaluate it for you.
In both cases, the Haskell system “executes a program” by evaluating
an expression, which (for a well-behaved program) eventually yields a value.The system must then display that value on your computer screen in someway thatmakes sensetoyou. GHC doesthis byinsistingthatthetypeof thevalue be an instance of the Showclass—in which case it “shows” the result
202
CHAPTER 15. BASIC INPUT/OUTPUT 203
by converting it to a string using the showfunction (recall the discussion in
Section7.1). So an integer is printed as an integer, a string as a string, a list
as a list, and so on. We will refer to the area of the computer screen wherethis result is printed as the standard output area , which may vary from one
implementation to another.
But what if a program is intended to write to a ﬁle? Or print a ﬁle on
a printer? Or, the main topic of this book, to play some music through thecomputer’s sound card, or an external Midi device? These are examples of
output, and there are related questions about input: for example, how does
a program receive input from the computer ke yboard or mouse, or receive
input from a Midi keyboard?
In general, how doesHaskell’s “expression-oriented” notion of “computa-
tion by calculation” accommodate these various kinds of input and output?
The answer is fairly simple: in Haskell there is a special kind of value
called an action. When a Haskell system evaluates an expression that yields
an action, it knows not to try to display the result in the standard out-put area, but rather to “take the appropriate action.” There are primitiveactions—such as writing a single character to a ﬁle or receiving a singlecharacter from a Midi keyboard—as well as compound actions—such as
printing an entire string to a ﬁle or playing an entire piece of music. Haskell
expressions that evaluate to actions are commonly called commands .
Some commands return a value for subsequent use by the program: a
character from the keyboard, for instance. A command that returns a valueof typeThas type IO T. If no useful value is returned, the command has
typeIO(). The simplest example of a command is return x,w h i c hf o ra
valuex::Timmediately returns xand has type IO T.
Details: The type ()is called the unit type , and has exactly one value, which
is also written (). Thusreturn()has type IO(), and is often called a “noop”
because it is an operation that does nothing and returns no useful result. Despitethe negative connotation, it is used quite often!
Remember that all expressions in Haskell must be well-typed before a
programisrun, soaHaskell implementation knowsahead oftime, bylookingat the type, that it is evaluating a command, and is thus ready to “takeaction.”
CHAPTER 15. BASIC INPUT/OUTPUT 204
15.2 do Syntax
To make these ideas clearer, let’s consider a few examples. One useful IO
command is putStr, which prints a string argument to the standard output
area, and has type String→IO(). The () simply indicates that there is
no useful result returned from this action; its sole purpose is to print itsargument to the standard output area. So the program:
module Main where
main=putStr "Hello World\n"
is the canonical “Hello World” program that is often the ﬁrst program that
people write in a new language.
Suppose now that we want to perform twoactions, such as ﬁrst writing
to a ﬁle named "testFile.txt" , then printing to the standard output area.
Haskell has a special keyword, do, to denote the beginning of a sequence of
commands such as this, and so we can write:
dowriteFile "testFile.txt" "Hello File System"
putStr "Hello World\n"
where the ﬁle-writing function writeFile has type:
writeFile ::FilePath →String→IO()
typeFilePath =String
Details: Adoexpression allows one to sequence an arbitrary number of com-
mands, each of type IO(), using layout to distinguish them (just as in a letor
whereexpression). When used in this way, the result of a doexpression also has
typeIO().
So far we have only used actions having type IO(); i.e. output actions.
But what about input? As above, we will consider input from both the userand the ﬁle system.
To receive a line o f input from the user (which will be typed in the
standard input area of the computer screen, usually the same as the standard
output area) we can use the function:
getLine::IO String
Suppose, for example, that we wish to read a line of input using this func-
tion, and then write that line (a string) to a ﬁle. To do this we write the
CHAPTER 15. BASIC INPUT/OUTPUT 205
compound command:
dos←getLine
writeFile "testFile.txt" s
Details: Note the syntax for binding sto the result of executing the getLine
command—when doing this in your program, you will have to type <-.S i n c et h e
type ofgetLineisIO String ,t h et y p eo f sisString.I t sv a l u ei st h e nu s e di nt h e
next line as an argument to the writeFile command.
Similarly, we can read the entire contents of a ﬁle using the command
readFile ::FilePath →IO String , and then print the result to standard
output:
dos←readFile "testFile.txt"
putStr s
Details: Any type that is an instance of the Monadtype class can be used with
thedosyntax to sequence actions. The Monadclass is discussed in detail in
Chapter ??. It suﬃces to say for now that the IOtype is an instance of the
Monadclass, as is the UItype to be described in the next chapter, which is part
of Eutperpea’s MUI design.
15.3 Actions are Just Values
There are many other commands available for ﬁle, system, and user IO,
some in the Standard Prelude, and some in various libararies (such as IO,
Directory ,System,a n dTime). We will not discuss any of these here; rather,
in the next chapter will concentrate on Midi input and output as well as acollection of graphical input widgets (such as sliders and pushbuttons) thatwe collectively refer to as Euterpea’s musical user interface (MUI).
Before that, however, we wish to emphasize that, despite the special do
syntax, Haskell’s IO commands are no diﬀerent in status from any otherHaskell function or value. For example, it is possible to create a listof
actions, such as:
CHAPTER 15. BASIC INPUT/OUTPUT 206
actionList =[putStr "Hello World\n" ,
writeFile "testFile.txt" "Hello File System" ,
putStr "File successfully written." ]
However, a list of actions is just a list of values: they actually don’t do
anything until they are sequenced appropriately using a doexpression, and
then returned as the value of the overall program (either as the variablemainin the module Main, or typed at the GHCi prompt). Still, it is often
convenient to place actions into a list as above, and the Haskell Report and
Libraries have some useful functions for turning them into single commands.
In particular, the function sequence
in the Standard Prelude, when used
with IO, has type:
sequence
 ::[IO a]→IO()
a ndc a nt h usbea ppl i e dt ot he actionList above to yield thesingle command:
main::IO()
main=sequence
 actionList
For a more interesting example of this idea, we ﬁrst note that Haskell’s
strings are really just lists of characters . Indeed, Stringis a type synonym
for a list of characters:
typeString=[Char]
Because strings are used so often, Haskell allows you to write "Hello" in-
stead of[ ’H’,’e’,’l’,’l’,’o’]. But keep inmindthat thisisjustsyntax—
strings really are just lists of characters, and these two ways of writing themare identical from Haskell’s perspective.
(Earlier the type synonym FilePath was deﬁned for String. This shows
that type synonyms can be created using other type synonyms.)
Now back to the example. From the function putChar ::Char→IO(),
which prints a single character to the standard output area, we can deﬁnethe function putStrused earlier, which prints an entire string. To do this,
let’s ﬁrst deﬁne a function that converts a list of characters (i.e. a string)into a list of IO actions:
putCharList ::String→[IO()]
putCharList =map putChar
With this, putStris easily deﬁned:
putStr::String→IO()
putStr=sequence
◦putCharList
Or, more succinctly:
CHAPTER 15. BASIC INPUT/OUTPUT 207
putStr::String→IO()
putStr=sequence
 ◦map putStr
Of course, putStrcan also be deﬁned directly as a recursive function,
which we do here just to emphasize that actions are just values, so we canuse all of the functional programming skills that we normally use:
putStr ::String→IO()
putStr[] = return()
putStr(c:cs)=doputChar c
putStr cs
IO processing in Haskell is consistent with everything we have learned
about programming with expressions and reasoning through calculation, al-though that may not be completely obvious yet. Indeed, it turns out that adoexpression is just syntax for a more primitive way of combining actions
using functions, namely a monad,t ob er e v e a l e di nf u l li nC h a p t e r ??.
15.4 Reading and Writing Midi Files
[TODO: Explain Midi-ﬁle IO functions deﬁned in Codec.Midi,a sw e l la st h e
Euterpea functions for writing Midi ﬁles.]
Chapter 16
Musical User Interface
module Euterpea .Examples .MUI where
importEuterpea
importEuterpea .IO.MUI
importData.Maybe
importEuterpea .IO.MIDI.MidiIO
importqualiﬁed Codec .Midi as Midi
(This module is not part of the Euterpea module hierarchy, but can be
found in the Examples folder in the Euterpea distribution.)
Mostmusicsoftwarepackageshaveagraphicaluserinterface(aka“GUI”)
that provides varying degrees of functionality to the user. In Euterpea a ba-sic set of widgets is provided that are collectively referred to as the musical
user interface , or MUI. This interface has two levels of abstraction: At the
user interface (UI) level , basic IO-like commands are provided for creating
graphical sliders, pushbuttons, and so on for input, and textual displays andgraphic images for output (in the future, other kinds of graphic input andoutput, including virtual keyboards, plots, and so on, will be provided). Inaddition to these graphical widgets, the UI level also provides an interface
to standard MIDI input and output devices.
The second level of abstraction of the MUI is the signal level .Asignal
is a time-varying quantity that nicely captures the behavior of many MUIwidgets. A special case of a signal is an event, and a special case of an event
is aMIDI event ,s u c ha sa Note−OnorNote−Oﬀmessage.
We begin our discussion with a description of signals and events.
208
CHAPTER 16. MUSICAL USER INTERFACE 209
16.1 Signals
A value of type Signal T is a time-varying value of type T. For example,
Signal Float is a time-varying ﬂoating-point number, Signal AbsPitch is a
time-varing absolute pitch, and so on. Abstractly, one can think of a signalas a function:
Signal a =Time→a
whereTimeis some suitable representation of time (currently Doublein
Euterpea).
However, this is not how signals are actually implemented in Euterpea,
indeed the above is not even valid Haskell syntax. Nevertheless it is helpful
to think of signals in this way. Indeed, for pedagogical purposes, we can goone step further and write the above as a Haskell data declaration:
dataSignal a =Sig(Time→a)
and then describe in more detail how signals are manipulated once this
concrete representation is in hand.
First of all, the following functions can be used to “lift” static values and
functions to the time-varying domain of signals:
lift0::a→Signal a
lift0 x=Sig(λt→x)
lift1::(a→b)→(Signal a →Signal b)
lift1 f=λ(Sig g)→Sig(λt→f(gt))
lift2::(a→b→c)→(Signal a →Signal b →Signal c)
lift2 f=λ(Sig g)
λ(Sig h)→Sig(λt→f(gt)(ht))
...
For example, lift042 is a “constant signal” that, at every point in time,
returns the value 42:
lift042
⇒Sig(λt→42)
Andlift1 sin is a function that converts one signal into another signal that,
at every point in time, is the sine of the value of the ﬁrst signal:
lift1 sin
⇒λ(Sig g)→Sig(λt→sin(gt))
So, for example, lift1 sin (lift042) is the constant signal that returns the
sine of 42, and in that sense is the same as lift0(sin42):
CHAPTER 16. MUSICAL USER INTERFACE 210
lift1 sin (lift042)
⇒(λ(Sig g)→Sig(λt→sin(gt))) (Sig(λt→42))
⇒Sig(λt→sin((λt→42)t))
⇒Sig(λt→sin42)
⇒lift0(sin42)
16.1.1 Numeric Signals
It is inconvenient to write “lifts” everywhere when we want to work at the
signal level. One solution to this would be to deﬁne new function names,such assinSfor a signal-level version of the sine function, and so on. Better
yet, we can take advantage of Haskell’s overloaded numeric system, throughthe useof type classes. For example, we’d like toadd, subtract, and multiplysignals, as well as apply transcendental functions such as sine, cosine, andexponentiation. Haskell’s numeric classes provide a delightfully convenientway to do this.
(Keep in mind while reading this section that signals aren’t actually
implemented in this way, but conceptually this should give you a good idea
of the desired behavior.)
For starters, we can declare Signalto be an instance of the class Num:
instance Num a⇒Num(Signal a)where
Sig f
1+Sig f 2=Sig(λt→f1t+f2t)
Sig f 1∗Sig f 2=Sig(λt→f1t∗f2t)
Sig f 1−Sig f 2=Sig(λt→f1t−f2t)
negate(Sig f)=Sig(λt→negate f)
fromInteger i =Sig(λt→fromInteger i )
...
Better yet, we can write this using the lifting functions deﬁned above:
instance Num a⇒Num(Signal a)where
(+) = lift2(+)
(∗)= lift2(∗)
(−)= lift2(−)
negate =lift1 negate
fromInteger i =lift0(fromInteger i )
...
(See Section 7.5.1for a full list of the operators in this class.)
Euterpea also deﬁnes instances of Signalfor the classes Fractional and
Floating. Using our pedagogical representation:
CHAPTER 16. MUSICAL USER INTERFACE 211
instance Num a⇒Fractional (Signal a)where
(/)= lift2(/)
fromRational r =lift0(fromRational r )
...
instance Fractional a ⇒Floating (Signal a)where
pi=lift0 pi
sin=lift1 sin
exp=lift1 exp
...
(See the Haskell Report for the full list of operators in these classes.)
With these deﬁnitions in place, we can now write, for example, sin42
instead of lift1 sin (lift042). Of course, the type of sin42 by itself is
ambiguous, butin acontext wherea Signalisexpected, it will beinterpreted
properly.
16.1.2 Time
It is convenient to have a signal that represents the current time. Usingour pedagogical representation of signals, we can think of the time tbeing
deﬁned as follows:
t::Signal Time
t=Sig id
For example, in physics a sine wave is described by the following math-
ematical formula:
x(t)=s i n (ωt+φ)
whereωis the angular frequency (in radians) and φis the phase angle. We
can write this using the overloaded operators from the last section, and the
timetas deﬁned above, quite succinctly:
x::Signal Double
x=sin(omega∗t+phi)
To see how this works, let’s proceed by calculation, with the assumption
thatomegaandphiare constants. We will work from the inner expressions
outward—ﬁrst omega∗t:
omega∗t
⇒lift2(∗)(lift0 omega )(Sig id)
⇒(λ(Sig g)λ(Sig h)→Sig(λt→gt∗ht))
CHAPTER 16. MUSICAL USER INTERFACE 212
(λt→omega)(Sig id)
⇒Sig(λt→(λt→omega)t∗id t))
⇒Sig(λt→omega∗t)
Nowomega∗t+phi:
|omega∗t+phi|
⇒lift2(+) (Sig(λt→omega∗t)) (lift0 phi)
⇒(λ(Sig g)λ(Sig h)→Sig(λt→gt+ht))
(Sig(λt→omega∗t)) (Sig(λt→phi))
⇒Sig(λt→(λt→omega∗t)t+(λt→phi)t)
⇒Sig(λt→omega∗t+phi)
And ﬁnally the whole thing:
sin(omega∗t+phi)
⇒lift1 sin (Sig(λt→omega∗t+phi))
⇒(λ(Sig g)→Sig(λt→sin(gt))) (Sig(λt→omega∗t+phi))
⇒Sig(λt→sin((λt→omega∗t+phi)t))
⇒Sig(λt→sin(omega∗t+phi))
16.1.3 Musical Signals
Of course, any function can be lifted. For example, consider the pitchfunc-
tion from Chapter 2.I t st y p ei s AbsPitch →Pitch, therefore the function
lift1 pitch must have type
Signal AbsPitch →Signal Pitch . Since functions such as this are not
members of a type class, we cannot overload them, and thus may decide to
use new function names, such as:
pitchS ::Signal AbsPitch →Signal Pitch
pitchS =lift1 pitch
absPitchS ::Signal Pitch →Signal AbsPitch
absPitchS =lift1 absPitch
We will see a larger example using this idea shortly.
CHAPTER 16. MUSICAL USER INTERFACE 213
16.1.4 Useful Signal Operators
Sometimes we need to zip and unzip values at the signal level. The following
functions facilitate this:
join::Signal a →Signal b →Signal(a,b)
split::Signal(a,b)→(Signal a,Signal b)
fstS::Signal(a,b)→Signal a
sndS::Signal(a,b)→Signal b
The behavior of these functions should be clear from their type signatures.
For example, jointakes two signals and zips their values together pointwise;
splittakes a signal of pairs and returns a pair of signals; and so on.
We would also like to compare signals, but it is not as easy to overload
the relational operators as we did the arithmetic operators, since they donot have a uniform type structure, and are not members of a convenienttype class. Therefore the following special operators are deﬁned:
(<∗),(>∗),(/lessorequalslant∗),(/greaterorequalslant∗)::Ord a⇒Signal a →Signal a →Signal Bool
(==∗),(/negationslash=∗): : Eq a⇒Signal a →Signal a →Signal Bool
(&&∗),
(||∗): : Signal Bool →Signal Bool →Signal Bool
notS ::Signal Bool →Signal Bool
For example, if s1,s2::Signal AbsPitch aretwo signalsofabsolutepitches,
thens1==∗s2is a signal of Boolean values that represents the pointwise
equality comparison of the two signals.
16.1.5 Stateful Signals
Some signals are stateful, meaning that they depend on past values in some
way. A particularly important example of a stateful signal is the integralof
a signal, which can be computed with the following function:
integral::Signal Time →Signal Double →Signal Double
The ﬁrst argument to integralis a signal that represents the current time.
We will say more about this in the next section, but conceptually you canthink of integral t s as the integral of swith respect to t.
Another kind of stateful signal can be generated with the functions:
initS,initS
/prime::a→Signal a →Signal a
initSconceptually introduces an inﬁnitesimally small delay in a signal by
“initializing” it with a given value. In other words, the signal initS v s
behaves just like s, but it has the value vat time 0, and takes on the values
CHAPTER 16. MUSICAL USER INTERFACE 214
ofshenceforth. initS/primevsbehaves similarly, except that it replaces the
initial value in swithv. In the limit, these are mathematically the same,
but in practice, there is sometimes reason to choose one over the other.
As an example of the use of initS, suppose we have a signal
s::Signal AbsPitch , and we wish to know when its value changes—i.e. we
would like a value of type Signal Bool that isTruejust at those moments
whenshas changed.1UsinginitSwe can compute the desired result by
comparing the value of the signal to its values an inﬁnitesimally short time
in the past; that is:
s/negationslash=∗initS0s
F romthet ypeof /negationslash=∗itiseasytoseethatthetypeofthisresultis Signal Bool .
16.2 Events and Reactivity
Although signals are a nice abstraction of time-varying entities, and the
world is arguably full of such entities, there are some things that happen at
discrete points in time, like a mouse click, or a MIDI keyboard press, and so
on. We call these events. To represent events, and have them coexist with
signals, recall the Maybetype deﬁned in the Standard Prelude:
dataMaybe a =Nothing |Just a
We deﬁne an event simply as a value of type Signal(Maybe a ), and in
this sense events in Euterpea are really event streams, since more than one
may occur over time. We say that the value associated with an event is“attached to” or “carried by” that event. For clarity we deﬁne EventSas a
type synonym:
typeEventS a =Signal(Maybe a)
“EventS” can be read either as “event stream” or “event signal,” although
we will often just write “event.”
16.2.1 Manipulating Event Streams
There are many things that we would like to do with events. For example,
it is convenient to be able to apply a function to each value attached to an
1Mathematically, if swere truly a continuous numeric function of time, this would be
the same as asking when the derivative is non-zero. But we would also like to compute
this result for integral types such as AsbPitch ,a sw e l la sf o rn o n - n u m e r i ct y p e s .
CHAPTER 16. MUSICAL USER INTERFACE 215
event, just like mapdoes for a list. In the context of events, however, we
prefer to use an inﬁx operator:
(=/greatermuch)::EventS a →(a→b)→EventS b
Mnemonically, an expression of the form e=/greatermuchfcan be read as “send the
event stream ethrough the function f.” For examnple, if s::Event AbsPitch
is a stream of absolute pitch events, then s=/greatermuchpitchi sas t r e a mo fp i t c h
events, with type Event Pitch .
For convenience we also deﬁne a version of (= /greatermuch) that ignores its input
value:
(−/greatermuch): :EventS a →b→EventS b
s1−/greatermuchv=s=/greatermuch(\
→v)
We can merge two event streams using:
(.|.)::EventS a →EventS a →EventS a
If two events happen at the same time, preference is given to the one in the
ﬁrst argument.
16.2.2 Turning Signals into Events
It is sometimes useful to turn a Boolean signal into an event stream, whichc a nb ed o n ei nt w od i ﬀ e r e n tw a y s :
edge,when::Signal Bool →EventS()
edge sgenerates an event whenever the Boolean signal schanges from False
toTrue—in signal processing this is called an “edge detector,” and thus the
name chosen here. when sis also an edge detector, but it generates an event
whenever schanges either from FalsetoTrueor fromTruetoFalse.
A related operation is:
unique::Eq a⇒Signal a →EventS a
which generates an event whenever the signal argument changes, and at-
taches the value of the signal at that time to the event. For example, ifap::Signal AbsPitch changes its pitch once every second, starting with abso-
lute pitch 0 and incrementally moving upward, then unique ap will generate
an event stream whose attached values are successively 0, 1, 2, and so on.Furthermore, the signal:
unique ap =/greatermuchpitch
generates events once per second, with the attached values being the pitches
CHAPTER 16. MUSICAL USER INTERFACE 216
snapshot ::EventS a →Signal b →EventS(a,b)
snapshot
 ::EventS a →Signal b →EventS b
hold ::a→EventS a →Signal a
accum ::a→EventS(a→a)→Signal a
Table 16.1: Signal Samplers
(C,0), (Cs,0), (D,0), and so on.
16.2.3 Signal Samplers
The useful collection of functions shown in Table 16.1can be thought of as
“signal samplers.” For example, if ticks::EventS() generates unit events
at some sampling rate, then snapshot
 ticks ap is a stream of events at the
same rate, but the value attached to each event is the value of the absolute
pitchapat that time. snapshot behaves similarly, but pairs the sampled
value with the original event value.
hold v e is a signal whose initial value is v, which it “holds” until the
ﬁrst event in ehappens, at which point it changes to the value attached to
that event, which it then “holds” until the next event, and so on. accum
is a bit like scan. The signal accum v e starts with the value v, but then
applies the function attached to the ﬁrst event to that value to get the nextv a l u e ,a n ds oo n .
16.2.4 Switches and Reactivity
Moregenerally, perhapsthemostfundamentalsetofoperationsoneventsarethe ones that introduce reactivity : the ability to change a signal’s behavior
in response to an event. There are two operations for this purpose:
switch,untilS::Signal a →EventS(Signal a)→Signal a
The signal s‘untilS‘einitially behaves just like s, until the ﬁrst event in
eoccurs. It then behaves forever after like the behavior attached to that
event.s‘switch‘ebehaves similarly, except that each subsequent event after
the ﬁrst will change the behavior to the event’s new attached signal value.
It is important to note that the second argument to these functions,
whose type is EventS(Signal a ), reﬂects a kind of “higher-order” signal,
that is, a signal of signals. Nothing like this can appear in an electricalcircuit, for example, since it it not possible carry entire circuits as values on
CHAPTER 16. MUSICAL USER INTERFACE 217
label ::String→UI()
display ::Signal String →UI()
button ::String→UI(Signal Bool )
checkbox ::String→Bool→UI(Signal Bool )
radio ::[String]→Int→UI(Signal Int )
hSlider,vSlider ::(RealFrac a )⇒(a,a)→a→UI(Signal a)
hiSlider,viSlider::(Integral a )⇒a→(a,a)→a→UI(Signal a)
canvas ::Dimension →EventS Graphic →UI()
Table 16.2: MUI Input Widgets
aw i r e .
[To do: Insert example or two here ]
16.3 The UI Level
It is at the UI level that “graphical widgets” are actually created, using a
style very similar to the way we did IO in Chapter 15. But instead of values
of typeIO T, which we referred to as IO actions , we will use values of
typeUI T,w h i c hw er e f e rt oa s UI actions . Just like IO,t h eUItype is
fully abstract (meaning its implementation is hidden), and is an instance oftheMonadclass, which means that it can be used with the dosyntax to
sequence UI actions.
16.3.1 Input Widgets
Euterpea’s basic input widgets are shown in Table 16.2. Note that each of
them returns, ultimately, a value of type UI T,f o rs o m e T, and therefore
must be used with the dosyntax to properly sequence their execution. The
names and type signatures of these functions suggest their functionality,which we elaborate on more below:
•A simple (static) text string can be displayed using:
label::String→UI()
•Alternatively, a time-varying string can be be displayed using:
display::Signal String →UI()
CHAPTER 16. MUSICAL USER INTERFACE 218
For convenience, Euterpea deﬁnes the following useful variations of
display:
displaySig ::Show a⇒Signal a →UI()
displaySig =display◦lift1 show
withDisplay ::Show a⇒UI(Signal a)→UI(Signal a)
withDisplay widget =dow←widget
displaySig wreturn w
•button,checkbox ,a n dradioare three kinds of “pushbuttons.” A
button(orcheckbox ) is pressed and unpressed (or checked and
unchecked) independently of others. In contrast, a radiobutton is de-
pendent upon other radio buttons—speciﬁcally, only one can be “on”at a time, so pressing one will turn oﬀ the others. The string argumentto these functions is the label attached to the button. radiotakes a list
of strings, each being the label of one of the buttons in the mutually-exclusive group; indeed the length of the list determines how manybuttons are in the group.
•hSlider,vSlider,hiSlider andviSlider are four kinds of sliders—the
ﬁrst two yield ﬂoating-point numbers in a given range, oriented hor-izontally and vertically, respectively, whereas the latter two returnintegral numbers. For the integral sliders, the ﬁrst argument is thesize of the step taken when the slider is clicked at any point on eitherside of the slider “handle.” In each of the four cases, the other twoarguments are the range and initial setting of the slider, respectively.
•canvasis a graphical canvas on which images can be drawn. More will
be said boit ut later.
As a very simple example, let’s combine our runningexample of absolute
pitches with a slider. We will deﬁne a MUI program that has a single sliderrepresenting the absolute pitch, and a display widget that displays the pitchcorresponding to the current setting of the slider:
ui0::UI()
ui0=doap←hiSlider1( 0,100) 0
displaySig (pitchS ap )
Note how the use of signals makes this dynamic MUI trivial to write.
We can execute this example using the function:
CHAPTER 16. MUSICAL USER INTERFACE 219
runUI::String→UI a→IO()
where the string argument is a title displayed in the window holding the
widget. So our ﬁrst running example of a MUI is:
mui0=runUI "Simple MUI" ui0
The resulting MUI, once the slider has been moved a bit, is shown in Figure
16.1(a).
(a) Very Simple
 (b) With Titles and Sizing
(c) With Alternate (left-to-right) Lay-
out
Figure 16.1: Several Simple MUIs
CHAPTER 16. MUSICAL USER INTERFACE 220
title::String→UI a→UI a
setSize::Dimension →UI a→UI a
pad::(Int,Int,Int,Int)→UI a→UI a
topDown ,bottomUp ,leftRight ,rightLeft ::UI a→UI a
typeDimension =(Int,Int)
Table 16.3: MUI Layout Widget Transformers
16.3.2 UI Transformers
Table16.3shows a set of “UI transformers”–functions that take UI values
as input, and return modiﬁed UI values as output.
titlesimply attaches a title (a string) to a UI, and setSizeestablishes
a ﬁxed size (in pixels that represent two sides of a rectangle) for a UI. Fore x a m p l ew ec a nm o d i f yt h ep r e v i o u se x a m p l e :
ui
1::UI()
ui1=setSize(150,150)$
doap←title "Absolute Pitch" (hiSlider1( 0,100) 0)
title "Pitch" (displaySig (pitchS ap ))
mui 1=runUI "Simple MUI (sized and titled)" ui1
This MUI is shown in Figure 16.1(b).
pad(w,n,e,s)uiaddswpixels of space to the “west” of the UI ui,
andn,e,a n dspixels of space to the north, east, and south, respectively.
The remaining four functions are used to control the relative layout of thewidgets within a UI. By default widgets are arranged top-to-bottom, but,for example, we could modify the previous UI program to arrange the two
widgets left-to-right:
ui
2::UI()
ui2=leftRight $
doap←title "Absolute Pitch" (hiSlider1( 0,100) 0)
title "Pitch" (display(lift1(show◦pitch)ap))
mui 2=runUI "Simple MUI (left-to-right layout)" ui2
T h i sM U Ii ss h o w ni nF i g u r e 16.1(c). Layout transformers can be nested
(as demonstrated in some later exampl es), so a fair amount of ﬂexibility is
available.
CHAPTER 16. MUSICAL USER INTERFACE 221
16.3.3 MIDI Input and Output
There are two widgets for MIDI, one for input and the other for output, but
neither of them displays anything graphically:
midiIn ::Signal DeviceID →UI(EventS[MidiMessage ])
midiOut ::Signal DeviceID →EventS[MidiMessage ]→UI()
Except for the DeviceID (about which more will be said shortly), these
functions are fairly straigtforward: midiOut takes a stream of MidiMessage
events and sends them to the MIDI output device, whereas midiIngenerates
as t r e a mo f MidiMessage events corresponding to the messages sent by the
MIDI input device. The MidiMessage data type is deﬁned as:
dataMidiMessage =ANote{channel::Channel,key::Key,
velocity::Velocity,duration ::Time}
|Std Message
deriving Show
AMidiMessage is either an ANote, which allows one to specify a note with
duration, or is a standard MIDI Message. Recall that MIDI does not have
a notion of duration, but rather has separate NoteOn andNoteOﬀ events.
WithANote, the design above is a bit more convenient, although what hap-
pens “behind-the-scenes” is that each ANoteis transformed into a NoteOn
andNoteOﬀ event.
TheMessage data type was described in Chapter 14, and is deﬁned in
theCodec.Midimodule. Its most important functionality is summarized
here:
dataMessage =
-- Channel Messages
NoteOﬀ {channel::!Channel,key::!Key,velocity::!Velocity}
|NoteOn {channel::!Channel,key::!Key,velocity::!Velocity}
|ProgramChange {channel::!Channel,preset::!Preset}
|...
-- Meta Messages
|TempoChange !Tempo|
|...
deriving (Show,Eq)
As an example of the use of midiOut, we will modify our previous MUI
program to output an ANotemessage every time the absolute pitch changes:
ui3=doap←title "Absolute Pitch" (hiSlider1( 0,100) 0)
CHAPTER 16. MUSICAL USER INTERFACE 222
title "Pitch" (displaySig (pitchS ap ))
letns=unique ap =/greatermuch(λk→[ANote0k100 0.1])
midiOut 0ns
mui 3=runUI "Pitch Player" ui3
Note the use of uniqueto generate an event when the pitch changes, and
the use of (= /greatermuch) to convert those events into ANotes.
16.3.4 Midi Device IDs
Note in the previous example that the DeviceID argument to midiOut is
set to 0. The MIDI device ID is a system-dependent concept that providesan operating system with a simple way to uniquely identify various MIDI
devices that may be attached to a computer. Indeed, as devices are dynam-
ically connected and disconnected from a computer, the mapping of theseIDs to a particular device may change. If you try to run the above code,it may or may not work, depending on whether the MIDI device with ID 0corresponds to the preferred MIDI output device on your machine.
To overcome this problem, most MIDI software programs allow the user
to select the preferred MIDI input and output devices. The user usuallyhas the best knowledge of which devices are connected, and which devicesto use. In Euterpea, the easiest way to do this is using the UI widgets:
selectInput ,selectOutput ::UI(Signal DeviceID )
Each of these widgets automatically queries the operating system to obtain
a list of connected MIDI devices, and then displays the list as a set of radio
buttons, thus allowing the user to select one of them. Note that the resultis a signal, and the DeviceID arguments to midiInandmidiOut are also
signals. This makes wiring up the user choice very easy. For example, wecan modify the previous program to look like this:
ui
4::UI()
ui4=dodevid←selectOutput
ap←title "Absolute Pitch" (hiSlider1( 0,100) 0)
title "Pitch" (displaySig (pitchS ap ))
letns=unique ap =/greatermuch(λk→[ANote0k100 0.1])
midiOut devid ns
mui 4=runUI "Pitch Player with MIDI Device Select" ui4
We suggest that this approach is always taken when dealing with MIDI,
even if you think you know the exact device ID.
CHAPTER 16. MUSICAL USER INTERFACE 223
For an example using MIDI input as well, here is a simple program that
copies each MIDI message verbatim from the selected input device to theselected output device:
CHAPTER 16. MUSICAL USER INTERFACE 224
ui5::UI()
ui5=domi←selectInput
mo←selectOutput
m←midiIn mi
midiOut mo m
mui 5=runUI "MIDI Input / Output UI" ui5
16.3.5 Timer Widgets
Remember that there is no “hidden” time in the MUI—anything that de-
pends on the notion of time (such as integraldiscussed earlier) takes a time
signal explicitly as an argument. For this purpose, the following function
generates a signal corresponding to the current time:
time::UI(Signal Time )
Besidesintegral, another function that depends explicitly on time is the
following, which creates a timer:
timer::Signal Time →Signal Double →EventS()
timer t i takes a time source tand a signal ithat represents the timer
interval (in seconds), and generates a stream of events, with each pair ofconsecutive events separated by the timer interval. Note that the timerinterval is itself a signal, so the timer output can have varying frequency.
As an example of this, let’s modify our previous UI so that, instead of
playing a note everytime the absolute pitch changes, we will output a note
continuously, at a rate controlled by a second slider:
ui
6::UI()
ui6=dodevid←selectOutput
ap←title "Absolute Pitch" (hiSlider1( 0,100) 0)
title "Pitch" (displaySig (pitchS ap ))
t←time
f←title "Tempo" (hSlider(1,10) 1)
letticks=timer t(1/f)
letns=snapshot
 ticks ap=/greatermuch
(λk→[ANote0k100 0.1])
midiOut devid ns
mui 6=runUI "Pitch Player with Timer" ui6
Note that:
CHAPTER 16. MUSICAL USER INTERFACE 225
•The time tis needed solely to drive the timer.
•Therateof ticksiscontrolled bytheslider. Ahigherslidervaluecauses
a lower time between ticks, and thus a higher frequency, or tempo.
•snapshot
 uses the timer output to control the sample rate of the
absolute pitch.
Finally, an event stream can be delayed by a given (variable) amount of
time using the following function:
delayt::Signal Time →Signal Double →EventS a →EventS a
The second argument speciﬁes the amount of delay to be applied to the
third argument.
16.4 Putting It All Together
Recall that a Haskell program must eventually be a value of type IO(),
and thus we need a function to turn a UIvalue into a IOvalue—i.e. the UI
needs to be “run.” We can do this using one of the following two functions,the ﬁrst of which we have already been using:
runUI :: String→UI a→IO()
runUIEx ::Dimension →String→UI a→IO()
Both of these functions take a string argument that is displayed in the title
bar of the graphical window that is generated. runUIEx additionally takes
the dimensions of the window as an argument. Executing runUI s ui or
runUIEx d s ui will create a single MUI window whose behavior is governed
by the argument ui::UI a.
16.5 Musical Examples
In this section we work through three larger musical examples that use
Euterpea’s MUI in interesting ways.
16.5.1 Chord Builder
This MUI will display a collection of chord types (Maj, Maj7, Maj9, min,min7, min9, and so on), one of which is selectable via a radio button. Then
CHAPTER 16. MUSICAL USER INTERFACE 226
when a key is pressed on a MIDI keyboard, the selected chord is built and
played using that key as the root.
To begin, we deﬁne a mapping between chord types and their intervals
starting with the root note:
chordIntervals ::[(String,[Int])]
chordIntervals =[("Maj",[4,3,5]),("Maj7",[4,3,4,1]),
("Maj9",[4,3,4,3]),("Maj6",[4,3,2,3]),
("min",[3,4,5]),("min7",[3,4,3,2]),
("min9",[3,4,3,4]),("min7b5" ,[3,3,4,2]),
("mMaj7",[3,4,4,1]),("dim",[3,3,3]),
("dim7",[3,3,3,3]),("Dom7",[4,3,3,2]),
("Dom9",[4,3,3,4]),("Dom7b9" ,[4,3,3,3])]
We will display the list of extensions on the screen as radio buttons for the
user to click on.
Figure 16.2: A Chord Builder MUI
ThetoChord function takes an input MIDI message as the root note
and the index of the selected chord extension, and outputs the notes of theselected chord based on the root note. For simplicity, we only process thehead of the message list and ignore everything else.
toChord ::([MidiMessage ],Int)→[MidiMessage ]
toChord (ms@(m:
),i)=
casemof
Std(Midi.NoteOn c k v )→fM i d i.NoteOn c k v
Std(Midi.NoteOﬀ c k v )→fM i d i.NoteOﬀ c k v
CHAPTER 16. MUSICAL USER INTERFACE 227
→ms
wherefgckv =map(λk/prime→Std(gck/primev))
(scanl(+)k(snd(chordIntervals !!i)))
The MUI is arranged in the following way. On the left side, the list of
input and output devices are displayed top-down. On the right is the list ofchord types. We take the name of each chord type from the chordIntervals
list to create the radio buttons.
When a MIDI input event occurs, the input message and the currently
selected index to the list of chords is sent to the toChord function, and the
resulting chord is then sent to the Midi output device.
buildChord ::UI()
buildChord =leftRight $
do(mi,mo)←topDown $
domi←selectInput
mo←selectOutput
return(mi,mo)
m ←midiIn mi
i ←topDown $title "Chord Type" $
radio(fst(unzip chordIntervals )) 0
midiOut mo (snapshot m i =/greatermuchtoChord)
chordBuilder =runUIEx (600,400) "Chord Builder" buildChord
Figure16.2s h o w st h i sM U Ii na c t i o n .
16.5.2 Bifurcate Me, Baby!
Here is an example with some ideas borrowed from Gary Lee Nelson’s com-
position ”Bifurcate Me, Baby!”
The basic idea is to evaluate the logistic growth function at diﬀerent
points and convert the value to a musical note. The growth function isgiven by the equation:
x
n+1=rxn(1−xn)
Mathematically, we start with an initial population x0and iteratively
apply the growth function to it, where ris the growth rate. For certain
values of r, the population stablizes to a certain value, but as rincreases,
CHAPTER 16. MUSICAL USER INTERFACE 228
the period doubles, quadruples, and eventually leads to chaos. It is one of
the classic examples in chaos theory.
First we deﬁne the growth function in Haskell, which, given a rate rand
current population x, generates the next population.
grow ::Double→Double→Double
grow r x =r∗x∗(1−x)
Then we deﬁne a signal ticksthat pulsates at a given frequency speciﬁed
by slider f. This is the signal that will drive the simulation.
The next thing we need is a time-varying population. This is where
accumcomes in handy. accumtakes an initial value and an event signal
carrying a modifying function, and updates the current value by applyingthe function to it. Since we want the growth rate to be time-varying, we liftthe growth function to the signal level and pass in the growth rate signal r.
This gives us a value of type Signal(Double→Double), that is, a signal of
functions that will update a population at the current growth rate. Then,at every tick, we take a snapshot of this signal, producing values of typeEventS(Double→Double). This is given to accumwith an initial value of
0.1, and we get back our population signal popdriven by the clock ticks.
We can now write a simple function that maps a population value to a
musical note:
popToNote ::Double→[MidiMessage ]
popToNote x =[ANote0n64 0.05]
wheren=truncate (x∗127)
Finally, to play the note at every tick, we again take a snapshot of the
current population at every tick and send the result to popToNote .T h e
resulting event signal is played through the selected MIDI output device.
bifurcateUI ::UI()
bifurcateUI =do
t←time
mo←
selectOutput
f←title "Frequency" $withDisplay (hSlider(1,10) 1)
r←title "Growth rate" $withDisplay (hSlider(2.4,4.0) 2.4)
letticks::EventS()
ticks=timer t(1.0/f)
pop::Signal Double
pop=accum0.1(snapshot
 ticks(lift1 grow r ))
CHAPTER 16. MUSICAL USER INTERFACE 229
title "Population" $displaySig pop
midiOut mo (snapshot
 ticks pop =/greatermuchpopToNote )
bifurcate =runUIEx (300,500) "Bifurcate!" $bifurcateUI
16.5.3 MIDI Echo Eﬀect
As a ﬁnal example we present a program that receives a MIDI event stream
and, in addition to playing each not e received from the i nput device, it also
echoes the note at a given rate, while playing each successive note moresoftly until the velocity reduces to 0.
The key component we need for this problem is a delay function that
can delay a given event signal for a certain amount of time. Recall that
the function delayttakes a time signal, the amount of time to delay, and an
input signal, and returns a delayed version of the input signal.
There are two signals we want to attenuate, or “decay.” One is the signal
comingfromtheinputdevice, andtheotheristhedelayedanddecayedsignalcontaining the echoes. In the code shown below, they are denoted as mand
s, respectively. First we merge the two event streams into one, and then
remove events with empty MIDI messages by replacing them with Nothing.The resulting signal m
/primeis then processed further as follows.
Whenever thereisan event in m/prime, we take asnapshotofthecurrentdecay
rate speciﬁed by a slider r. The MIDI messages and the current decay rate
are passed to a function k, which softens each note in the list of messages.
We deﬁne a function called decaythat reduces the velocity of each note by
the given rate. If the velocity drops to 0, the note is removed. The resultingsignal is then delayed by the amount of time determined by another sliderf, producing signal s.si st h e nf e db a c kt ot h e mergeM function, closing
the loop of the recursive signal. At the same time, m
/primeis sent to the output
device.
echoUI::UI()
echoUI=do
mi←selectInput
mo←selectOutput
m←midiIn mi
t←time
r←title "Decay rate" $withDisplay $hSlider(0,0.9) 0.5
f←title "Echoing frequency" $withDisplay $
hSlider(1,10) 10
CHAPTER 16. MUSICAL USER INTERFACE 230
letm/prime=lift1 removeNull $lift2 mergeM m s
s =delayt t(1.0/f)(snapshot m/primer=/greatermuchk)
k(ns,r)=mapMaybe (decay0.1r)ns
midiOut mo m/prime
echo=runUIEx (500,500) "Echo"echoUI
mergeM ::Maybe[MidiMessage ]→Maybe[MidiMessage ]→
Maybe[MidiMessage ]
mergeM (Just ns 1)(Just ns 2)=Just(ns1++ns2)
mergeM n 1 Nothing =n1
mergeM Nothing n 2 =n2
removeNull ::Maybe[MidiMessage ]→Maybe[MidiMessage ]
removeNull (Just[])=Nothing
removeNull mm =mm
decay::Time→Double→MidiMessage →Maybe MidiMessage
decay dur r m =
letfckvd =ifv>0
then let v/prime=truncate (fromIntegral v ∗r)
inJust(ANote c k v/primed)
elseNothing
in casemof
ANote c k v d →fckvd
Std(Midi.NoteOn c k v )→fckvd u r
→Nothing
Chapter 17
Sound and Signals
In this chapter we study the fundamental nature of sound and its basic
mathematical representation as a signal. We also discuss discrete digitalrepresentations of a signal, which form the basis of modern sound synthesisand audio processing.
17.1 The Nature of Sound
Before studying digital audio, it’s important that we ﬁrst know what sound
is. In essence, sound is the rapid compression and relaxation of air, whichtravels as a wavethrough the air from the physical source of the sound to,
ultimately, our ears. Thephysical source of the sound could be the vibrationof ourvocal chords(resultingin speech or singing), thevibration ofa speakercone, the vibration of a car engine, the vibration of a string in a piano orviolin, the vibration of the reed in a saxophone or of the lips when playing
a trumpet, or even the (brief and chaotic) vibrations that result when our
handscome together asweclap. The“compression andrelaxation” oftheair(or of a coiled spring) is called a longitudinal wave, in which the vibrations
occur parallel to the direction of travel of the wave. In contrast, a ropethat is ﬁxed at one end and being shaken at the other, and a wave in theocean, are examples of a transverse wave, in which the rope’s and water’s
movement is perpendicular to the direction the wave is traveling.
[Note: There are some great animations of these two kinds of waves at:
http://www.computermusicresource.com/what.is.sound.html .]
If the rate and amplitude of the sound are within a suitable range, we
231
CHAPTER 17. SOUND AND SIGNALS 232
canhearthe sound—i.e. it is audible sound . “Hearing” results when the
vibrating air waves cause our ear drumto vibrate, in turn stimulating nervesthat enter our brain. Sound above our hearing range (i.e. vibration that istoo quicktoinduceanynerveimpulses)iscalled ultrasonic sound , andsound
below our hearing range is said to be infrasonic .
Staying within the analog world, sound can also be turned into an elec-
tricalsignal using a microphone (or “mic” for short). Several common kinds
of microphones are:
1. Carbon microphone. Based on the resistance of a pocket of carbon
particles that are compressed and relaxed by the sound waves hittinga diaphram.
2. Condenser microphone. Based on the capacitance between two di-
aphrams, one being vibrated by the sound.
3. Dynamic microphone. Based on the inductance of a coil of wire sus-
pended in a magnetic ﬁeld (the inverse of a speaker).
4. Piezoelectric microphone. Based on the property of certain crystals to
induce current when they are bent.
-1-0.5 0 0.5 1
 0  0.002  0.004  0.006  0.008  0.01Amplitude
Time (seconds)Sinewave at 1000Hz
Signal
Figure 17.1: A Sine Wave
Perhaps the most common and natural way to represent a wave dia-
grammatically, whether it be a sound wave or electrical wave, longitudinal
CHAPTER 17. SOUND AND SIGNALS 233
or transverse, is as a graphof its amplitude vs. time. For example, Figure
17.1shows a sinusiodal wave of 1000 cycles per second, with an amplitude
that varies beween +1 and -1. A sinusoidal wave follows precisely the deﬁni-tion of the mathematical sine function, but also relates strongly, as we shallsoon see, to the vibration of sound produced by most musical instruments.In the remainder of this text, we will refer to a sinusoidal wave simply as asine wave.
Acoustics is the study of the properties, in particular the propagation
and reﬂection, of sound. Psychoacoustics is the study of the mind’s inter-
pretation of sound, which is not always as tidy as the physical propertiesthat are manifest in acoustics. Obviously both of these are important ar-eas of study for music in general, and therefore play an important role ingenerating or simulating music with a computer.
The speed of sound can vary considerably, depending on the material,
the temperature, the humidity, and so on. For example, in dry air at roomtemperature (68 degrees Farenheit), sound travels at a rate of 1,125 feet(343 meters) per second, or 768 miles (1,236 kilometers) per hour. Perhapssurprisingly, the speed of sound varies little with respect to air pressure,
although it does vary with temperature.
The reﬂection and absorbtion of sound is a much more diﬃcult topic,
since it depends so much on the material, the shape and thickness of thematerial, and the frequency of the sound. Modeling well the acoustics of aconcerthall,forexample,isquitechallenging. Tounderstandhowmuchsuchreﬂections can aﬀect the overall sound that we hear, consider a concert hallthat is 200 feet long and 100 feet wide. Based on the speed of sound givenabove, it will take a sound wave
2×200/1125=0.355 seconds to travel from
the front of the room to the back of the room and back to the front again.That
1/3of a second, if loud enough, would result in a signiﬁcant distortion
of the music, and corresponds to about one beat with a metronome set at168.
With respect to our interpretation of music, sound has (at least) three
key properties:
1.Frequency (perceived as pitch).
2.Amplitude (perceived as loudness).
3.Spectrum (perceived as timbre).
We discuss each of these in the sections that follow.
CHAPTER 17. SOUND AND SIGNALS 234
17.1.1 Frequency and Period
Thefrequency fissimplytherate ofthe vibrations(or repetitions, orcycles)
of the sound, and is the inverse of the period(or duration, or wavelength) p
of each of the vibrations:
f=1
p
Frequency is measured in Hertz(abbreviated Hz), where 1 Hz is deﬁned as
one cycle per second. For example, the sound wave in Figure 17.1has a
frequency of 1000 Hz (i.e. 1 kHz) and a period of 1/1000second (i.e. 1 ms).
In trigonometry, functions like sine and cosine are typically applied to
angles that range from 0 to 360 degrees. In audio processing (and signal
processing in general) angles are instead usually measured in radians,w h e r e
2πradians is equal to 360◦. Since the sine function has a period of 2 πand
a frequency of 1/2π, it repeats itself every 2 πradians:
sin(2πk+θ)=s i nθ
for any integer k.
But for our purposes it is better to parameterize these functions over
frequency as follows. Since sin(2 πt) covers one full cycle in one second, i.e.
has a frequency of 1 Hz, it makes sense that sin(2 πft)c o v e r sfcycles in one
second, i.e. has a frequency of f. Indeed, in signal processing the quantity
ωis deﬁned as:
ω=2πf
That is, a pure sine wave as a function of time behaves as sin( ωt).
Finally, it is convenient to add a phase(orphase angle ) to our formula,
which eﬀectively shifts the sine wave in time. The phase is usually rep-resented by φ. Adding a multiplicative factor Afor amplitude (see next
section), we arrive at our ﬁnal formula for a sine wave as a function of time:
s(t)=Asin(ωt+φ)
A negative value for φhas the eﬀect of “delaying” the sine wave, whereas a
positive value has the eﬀect of “starting early.” Note also that this equationholds for negative values of t.
All of the above can be related to cosine by recalling the following iden-
tity:
sin(ωt+π
2)=c o s (ωt)
CHAPTER 17. SOUND AND SIGNALS 235
More generally:
Asin(ωt+φ)=acos(ωt)+bsin(ωt)
Givenaandbwe can solve for Aandφ:
A=√
a2+b2
φ=t a n−1b
a
GivenAandφwe can also solve for aandb:
a=Acos(φ)
b=Asin(φ)
17.1.2 Amplitude and Loudness
Amplitude can be measured in several ways. The peak amplitude of a signal
is its maximum deviation from zero; for example our sine wave in Figure17.1has a peak amplitude of 1. But diﬀerent signals having the same peak
amplitude have more or less “energy,” depending on their “shape.” For
example, Figure 17.2shows four kinds of signals: a sine wave, a square
wave, a sawtooth wave, and a triangular wave (whose names are suitablydescriptive). Each of them has a peak amplitude of 1. But, intuitively,one would expect the square wave, for example, to have more “energy,”or “power,” than a sine wave, because it is “fatter.” In fact, it’s value iseverywhere either +1 or -1.
To measure this characteristic of a signal, scientists and engineers often
refer to the root-mean-square amplitude, or RMS. Mathematically, the root-
mean-square is the square root of the mean of the squared values of a givenquantity. If xis a discrete quantity given by the values x
1,x2,...,xn,t h e
f o r m u l af o rR M Si s :
xRMS=/radicalbigg
x2
1+x2
2+...+x2n
n
And iffis continuous function, its RMS value over the interval T1/lessorequalslant
t/lessorequalslantT2is given by:
/radicalBigg
1
T2−T1/integraldisplayT2
−T1f(t)2dt
CHAPTER 17. SOUND AND SIGNALS 236
-1-0.5 0 0.5 1
 0  0.002  0.004  0.006  0.008  0.01Amplitude
Time (seconds)Sine Wave at 1000Hz
0.707  
Signal RMS
-1-0.5 0 0.5 1
 0  0.002  0.004  0.006  0.008  0.01Amplitude
Time (seconds)Square Wave at 1000Hz
Signal RMS
-1-0.5 0 0.5 1
 0  0.002  0.004  0.006  0.008  0.01Amplitude
Time (seconds)Sawtooth Wave at 1000Hz
0.577  
RMS
-1-0.5 0 0.5 1
 0  0.002  0.004  0.006  0.008  0.01Amplitude
Time (seconds)Triangular Wave at 1000Hz
0.577  
Signal RMS
Figure 17.2: RMS Amplitude for Diﬀerent Signals
CHAPTER 17. SOUND AND SIGNALS 237
For a sine wave, it can be shown that the RMS value is approximately
0.707 of thepeakvalue. For asquarewave, itis1.0. And forboth asawtoothwave and a triangular wave, it is approximately 0.577. Figure 17.2shows
these RMS values superimposed on each of the four signals.
Another way to measure amplitude is to use a relative logarithmic scale
that more aptly reﬂects how we hear sound. This is usually done by measur-ing the sound level (usually in RMS) with respect to some reference level.The number of decibels(dB) of sound is given by:
S
dB=1 0l o g10S
R
whereSis the RMS sound level, and Ris the RMS reference level. The
accepted reference level for the human ear is 10−12watts per square meter,
which is roughly the threshold of hearing.
A related concept is the measure of how much useful information is in a
signal relative to the “noise.” The signal-to-noise ratio ,o rSNR, is deﬁned
as the ratio of the powerof each of these signals, which is the square of the
RMS value:
SNR=/parenleftbiggS
N/parenrightbigg2
whereSandNare the RMS values of the signal and noise, respectively.
As is often the case, it is better to express this on a logarithmic scale, asfollows:
SNR
dB=1 0 l o g10/parenleftbiggS
N/parenrightbigg2
=2 0 l o g10S
N
Thedynamic range of a system is the diﬀerence between the smallest
and largest values that it can process. Because this range is often very large,it is usually measured in decibels, which is a logarithmic quantity. The ear,for example, has a truly remarkable dynamic range—about 130 dB. To getsomefeelforthis,silenceshouldbeconsidered0dB,awhisper30dB,normalconversation about 60 dB, loud music 80 dB, a subway train 90 dB, and ajet plane taking oﬀ or a very loud rock concert 120 dB or higher.
Note that if you double the sound level, the decibels increase by about
3 dB, whereas a million-fold increase corresponds to 60 dB:
10log
102= 1 0 ×0.301029996 ∼=3
10log10106=1 0×6= 6 0
CHAPTER 17. SOUND AND SIGNALS 238
So the ear is truly adaptive! (The eye also has a large dynamic range with
respect to light intensity, but not quite as much as the ear, and its responsetime is much slower.)
Figure 17.3: Fletcher-Munson Equal Loudness Contour
Loudnessistheperceivedmeasureofamplitude,orvolume, ofsound,and
is thus subjective. It is most closely aligned with RMS amplitude, with oneimportant exception: loudness depends somewhat on frequency! Of coursethat’s obvious for really high and really low frequencies (since at some pointwe can’t hear them at all), but in between things aren’t constant either.Furthermore, no two humans are the same. Figure 17.3shows the Fletcher-
Munson Equal-Loudness Contour , which reﬂects the perceived equality of
sound intensity by the average human ear with respect to frequency. Note
from this ﬁgure that:
•The human ear is less sensitive to low frequencies.
•The maximum sensitivity is around 3-4 kHz, which roughly corre-
CHAPTER 17. SOUND AND SIGNALS 239
sponds to the resonance of the auditory canal.
Another important psychoacoustical property is captured in the Weber-
Fechner Law , which states that the just noticeable diﬀerence (jnd) in a
quantity—i.e. the minimal change necessary for humans to notice somethinginacognitive sense—isarelative constant, independentoftheabsolutelevel.
That is, the ratio of the change to the absolute measure of that quantity is
constant:
Δq
q=k
The jnd for loudness happens to be about 1 db, which is another reason
why the decibel scale is so convenient. 1 db corresponds to a sound levelratio of 1.25892541. So, in order for a person to “just notice” an increase inloudness, one has to increase the sound level by about 25%. If that seemshigh to you, it’s because your ear is so adaptive that you are not even awareof it.
17.1.3 Frequency Spectrum
Humans can hear sound approximately in the range 20 Hz to 20,000 Hz =20 kHz. This is a dynamic range in frequency of a factor of 1000, or 30 dB.Diﬀerent people can hear diﬀerent degrees of this range (I can hear very lowtones well, but not very high ones). On a piano, the fundamental frequencyof the lowest note is 27.5 Hz, middle (concert) A is 440 hz, and the top-most note is about 4 kHz. Later we will learn that these notes also contain
overtones —multiples of the fundamental frequency—that contribute to the
timbre, or sound quality, that distinguishes one instrument from another.
(Overtones are also called harmonics orpartials.)
Thephase, or time delay, of a signal is important too, and comes into
play when we start mixing signals together, which can happen naturally,deliberately, from reverberations (room acoustics), and so on. Recall thata pure sine wave can be expressed as sin( ωt+φ), where φis thephase
angle. Manipulating the phase angle is common in additive synthesis and
amplitude modulation, topics to be covered in later chapters.
A key point is that most sounds do not consist of a single, pure sine
wave—rather, they are a combination of many frequencies, and at varying
CHAPTER 17. SOUND AND SIGNALS 240
 0 0.2 0.4 0.6 0.8 1 1.2
 100  1000  10000Signal Strength
FrequencyFrequency Spectrum of a Sine Wave at 1000Hz
(a) Spectral plot of pure sine wave
 0 0.2 0.4 0.6 0.8 1 1.2
 100  1000  10000Signal Strength
FrequencyFrequency Spectrum of a a 1000Hz Signal
(b) Spectral plot of a noisy sine wave
 0 0.2 0.4 0.6 0.8 1 1.2
 100  1000  10000Signal Strength
FrequencyFrequency Spectrum of a a 1000Hz Signal and Overtones
(c) Spectral plot of a musical tone
Figure 17.4: Spectral Plots of Diﬀerent Signals
CHAPTER 17. SOUND AND SIGNALS 241
phases relative to one another. Thus it is helpful to talk of a signal’s fre-
quency spectrum , or spectral content. If we have a regular repetitive sound
(called a periodic signal ) we can plot its spectral content instead of its time-
varying graph. For a pure sine wave, this looks like an impulse function, ass h o w ni nF i g u r e 17.4a.
But for a richer sound, it gets more complicated. First, the distribution
of the energy is not typically a pure impulse, meaning that the signal mightvary slightly above and below a particular frequency, and thus its frequency
spectrum typically looks more like Figure 17.4b.
In addition, a typical sound has many diﬀerent frequencies associated
with it, not just one. Even for an instrument playing a single note, thiswill include not just the perceived pitch, which is called the fundamental
frequency , but also many overtones (or harmonics) which are multiples of
the fundamental, as shown in Figure 17.4c. Thenatural harmonic series is
one that is approximated often in nature, and has a harmonically decayingseries of overtones.
What’s more, the articulation of a note by a performer on an instrument
causes these overtones to vary in relative size over time. There are severalways to visualize this graphically, and Figure 17.5shows two of them. In
17.5a, shading is used to show the varying amplitude over time. And in
17.5b, a 3D projection is used.
The precise blend of the overtones, their phases, and how they vary over
time, is primarily what distinguishes a particular note, say concert A, on apiano from the same note on a guitar, a violin, a saxophone, and so on. Wewill have much more to say about these issues in later chapters.
[See pictures at:
http://www.computermusicresource.com/spectrum.html .]
17.2 Digital Audio
The preceding discussion has assumed that sound is a continuous quantity,
which of course it is, and thus we represent it usingcontinuous mathematicalfunctions. If we were using an analog computer, we could continue with thisrepresentation, and create electronic music accordingly. Indeed, the earliestelectronic synthesizers, such as the Moog synthesizer of the 1960’s, were
completely analog.
However, most computers today are digital, which require representing
CHAPTER 17. SOUND AND SIGNALS 242
Frequency Spectrum of a a 1000Hz Signal
 1000  10000
Frequency 0 0.2 0.4 0.6 0.8 1 1.2Time
 0 0.2 0.4 0.6 0.8 1
(a) Using shading
 1000
 10000  0 0.2 0.4 0.6 0.8 1 1.2
 0 0.2 0.4 0.6 0.8 1
Signal StrengthFrequency Spectrum of a a 1000Hz Signal
FrequencyTimeSignal Strength
(b) Using 3D projection
Figure 17.5: Time-Varying Spectral Plots
CHAPTER 17. SOUND AND SIGNALS 243
sound (or signals in general) using digital values. The simplest way to do
this is to represent a continuous signal as a sequence of discrete samples of
the signal of interest. An analog-to-digital converter , or ADC, is a device
that converts an instantaneous sample of a continuous signal into a binaryvalue. The microphone input on a computer, for example, connects to anADC.
Normally the discrete samples are taken at a ﬁxed sampling rate .C h o o s -
ing a proper sampling rate is quite important. If it is too low, we will not
acquire suﬃcient samples to adequately represent the signal of interest. And
if the rate is too high, it may be an overkill, thus wasting precious comput-ing resources (in both time and memory consumption). Intuitively, it seemsthat the highest frequency signal that we could represent using a samplingraterwould have a frequency of
r/2, in which case the result would have
the appearance of a square wave, as shown in Figure 17.6a. Indeed, it is
easy to see that problems could arise if we sampled at a rate signiﬁcantlylower than the frequency of the signal, as shown in Figures 17.6ba n d17.6c
for sampling rates equal to, and one-half, of the frequency of the signal ofinterest—in both cases the result is a sampled signal of 0 Hz!
Indeed, this observation is captured in what is known as the Nyquist-
Shannon Sampling Theorm that, stated informally, says that the accurate
reproduction of an analog signal (no matter how complicated) requires asampling rate that is at least twice the highest frequency of the signal ofinterest.
For example, for audio signals, if the highest frequency humans can hear
is 20 kHz, then we need to sample at a rate of at least 40 kHz for a faithfulreproduction of sound. In fact, CD’s are recorded at 44.1 kHz. But manypeople feel that this rate is too low, as some people can hear beyond 20 kHz.Another recording studio standard is 48 kHz. Interestingly, a good analogtape recorder from generations ago was able to record signals with frequencycontent even higher than this—perhaps digital is not always better!
17.2.1 From Continuous to Discrete
Recall the deﬁnition of a sine wave from Section 17.1.1:
s(t)=Asin(ωt+φ)
We can easily and intuitively convert this to the discrete domain by replac-
ing the time twith the quantity n/r,w h e r enis the integer index into the
CHAPTER 17. SOUND AND SIGNALS 244
-1-0.5 0 0.5 1
 0  0.001  0.002  0.003  0.004  0.005Amplitude
Time (seconds)Sampling Rate Equal to Twice Signal Frequency
Sampled signal
Sample pointsOriginal signal (f=1000Hz)
(a)
-1-0.5 0 0.5 1
 0  0.002  0.004  0.006  0.008  0.01Amplitude
Time (seconds)Sampling Rate Equal to Signal Frequency
Sampled signal
Sample pointsOriginal signal (f=1000Hz)
(b)
-1-0.5 0 0.5 1
 0  0.002  0.004  0.006  0.008  0.01Amplitude
Time (seconds)Sampling Rate Equal to One Half Signal Frequency
Sampled signal
Sample pointsOriginal signal (f=1000Hz)
(c)
Figure 17.6: Choice of Sampling Rate
CHAPTER 17. SOUND AND SIGNALS 245
sequence of discrete samples, and ris the sampling rate discussed above. If
we uses[n]t od e n o t et h e( n+1)thsample of the signal, we have:
s[n]=Asin/parenleftBigωn
r+φ/parenrightBig
,n =0,1,...,∞
Thuss[n] corresponds to the signal’s value at time n/r.
17.2.2 Fixed-Waveform Table-Lookup Synthesis
One of the most fundamental questions in digital audio is how to generate
a sine wave as eﬃciently as possible, or, in general, how to generate a ﬁxedperiodic signal of any form (sine wave, square wave, sawtooth wave, evena sampled sound bite). A common and eﬃcient way to generate a periodicsignal is through ﬁxed-waveform table-lookup synthesis . The idea is very
simple: store in a table the samples of a desired periodic signal, and thenindex through the table at a suitable rate to reproduce that signal at somedesired frequency. The table is often called a wavetable .
In general, if we let:
L= table length
f= resulting frequency
i= indexing increment
r= sample rate
then we have:
f=ir
L
For example, suppose the table contains 8196 samples. If the sample
rate is 44.1 kHz, how do we generate a tone of, say, 440 Hz? Plugging inthe numbers and solving the above equation for i,w eg e t :
440 =i×44.1kHz
8196
i=440×8196
44.1kHz
=8 1.77
So, if we were to sample approximately every 81.77thvalue in the table, we
would generate a signal of 440 Hz.
CHAPTER 17. SOUND AND SIGNALS 246
Now suppose the table Tis a vector, and T[n]i st h enth element. Let’s
call the exact index increment iinto a continuous signal the phase,a n dt h e
actual index into the corresponding table the phase index p. The compu-
tation of successive values of the phase index and output signal sis then
captured by these equations:
po=⌊φ0+0.5⌋
pn+1=(pn+i)m o dL
sn=T[⌊pn+0.5⌋]
⌊a+0.5⌋denotes the ﬂoorof a+0.5, which eﬀectively rounds ato the nearest
integer. φ0is the initial phase angle (recall earlier discussion), so p0is the
initial index into the table that speciﬁes where the ﬁxed waveform should
begin.
Instead of rounding the index, one could do better by interpolating be-
tween values in the table, at the expense of eﬃciency. In practice, roundingthe index is often good enough. Another way to increase accuracy is tosimply increase the size of the table.
17.2.3 Aliasing
Earlier wesaw examples ofproblemsthat can ariseifthe samplingrate isnothigh enough. We saw that if we sample a sine wave at twice its frequency, wecan suitably capture that frequency. If we sample at exactly its frequency,we get 0 Hz. But what happens in between? Consider a sampling rate ever-so-slightly higher or lower than the sine wave’s fundamental frequency--inboth cases, thiswillresultin afrequencymuch lower thanthe original signal,as shown in Figures 17.7and17.8. This is analogous to the eﬀect of seeing
spinning objects under ﬂuorescent or LED light, or old motion pictures of
the spokes in the wheels of horse-drawn carriages.
These ﬁgures suggest the following. Suppose that mis one-half the
sampling rate. Then:
Original signal Reproduced signal
0−m 0−m
m−2mm −0
2m−3m 0−m
3m−4mm −0
··· ···

CHAPTER 17. SOUND AND SIGNALS 247
-1-0.5 0 0.5 1
 0  0.005  0.01  0.015  0.02  0.025  0.03Amplitude
Time (seconds)Sampling Rate of 1.1 Signal Frequency
Sampled signal
Sample pointsOriginal signal (f=1000Hz)
-1-0.5 0 0.5 1
 0  0.005  0.01  0.015  0.02  0.025  0.03Amplitude
Time (seconds)Sampling Rate of 0.9 Signal Frequency
Sampled signal
Sample pointsOriginal signal (f=1000Hz)
Figure 17.7: Aliasing 1
CHAPTER 17. SOUND AND SIGNALS 248
-1-0.5 0 0.5 1
 0  0.01  0.02  0.03  0.04  0.05Amplitude
Time (seconds)Sampling Rate of 1.02 Signal Frequency
Sampled signal
Sample pointsOriginal signal (f=1000Hz)
-1-0.5 0 0.5 1
 0  0.01  0.02  0.03  0.04  0.05Amplitude
Time (seconds)Sampling Rate of 0.98 Signal Frequency
Sampled signal
Sample pointsOriginal signal (f=1000Hz)
Figure 17.8: Aliasing 2
CHAPTER 17. SOUND AND SIGNALS 249
This phenomenon is called aliasing,o rfoldover of the signal onto itself.
This is not good! In particular, it means that audio signals in the ultra-
sonic range will get “folded” into the audible range. To solve this problem,we can add an analog low-pass ﬁlter in front of the ADC–usually called
ananti-aliasing ﬁlter—to eliminate all but the audible sound before it is
digitized. In practice, however, this can be tricky. For example, a steepanalog ﬁlter introduces phase distortion (i.e. frequency-dependent time de-
lays), and early digital recordings were notorious in the “harsh sound” that
resulted. This can beﬁxed byusinga ﬁlter with less steepness (butresulting
in more aliasing), or using a time correlation ﬁlter to compensate, or usinga technique called oversampling , which is beyond the scope of this text.
A similar problem occurs at the other end of the digital audio process—
i.e. whenwereconstructan analog signal fromadigital signalusinga digital-
to-analog converter , or DAC. The digital representation of a signal can be
viewed mathematically as a stepwise approximation to the real signal, ass h o w ni nF i g u r e 17.9, where the sampling rate is ten times the frequency
of interest. As discussed earlier, at the highest frequency (i.e. at one-halfthe sampling rate), we get a square wave. As we will see in Chapter 19,
a square wave can be represented mathematically as the sum of an inﬁnite
sequence of sine waves, consisting of the fundamental frequencyand all of its
odd harmonics. These harmonics can enter the ultrasonic region, causingpotential havoc in the analog circuitry, or in a dog’s ear (dogs can hearfrequencies much higher than humans). The solution is to add yet anotherlow-pass ﬁlter, called an anti-imaging orsmoothing ﬁlter to the output of
the DAC. In eﬀect, this ﬁlter “connects the dots,” or interpolates, betweensuccessive values of the stepwise approximation.
Inanycase, abasicblockdiagramofatypical digital audiosystem—from
sound input to sound output—is shown in Figure 17.10.
17.2.4 Quantization Error
In terms of amplitude, remember that we are using digital numbers to repre-
sent an analog signal. For conventional CD’s, 16 bits of precision are used.If we were to compute and then “listen to” the round-oﬀ errors that areinduced, we would hear subtle imperfections, called quantization error ,o r
more commonly, “noise.”
One might compare this to “hiss” on a tape recorder (which is due to
the molecular disarray of the magnetic recording medium), but there are
CHAPTER 17. SOUND AND SIGNALS 250
-1-0.5 0 0.5 1
 0  0.001  0.002  0.003  0.004  0.005Amplitude
Time (seconds)Sampling Rate of 10 Times Signal Frequency
0.707  
Sampled Signal
Sample PointsOriginal signal (f=1000Hz)
Figure 17.9: A Properly Sampled Signal
ADC 
(analog-to-digital 
converter) low-pass  
(anti-aliasing) 
filter 
computer DAC 
(digital-to-analog 
converter) low-pass 
(anti-imaging) 
filter 
amplifier
Figure 17.10: Block Diagram of Typical Digital Audio System
CHAPTER 17. SOUND AND SIGNALS 251
important diﬀerences. First of all, when there is no sound, there is no
quantization error in a digital signal, but there is still hiss on a tape. Also,when the signal is very low and regular, the quantization error becomessomewhat regular as well, and is thus audible as something diﬀerent fromhiss. Indeed, it’s only when the signal is loud and complex that quantizationerror compares favorably to tape hiss.
One solution to the problem of low signal levels mentioned above is to
purposelyintroducenoiseintothesystemtomakethesignallesspredictable.
This fortuitous use of noise deserves a better name, and indeed it is called
dither.
17.2.5 Dynamic Range
What is the dynamic range of an n-bit digital audio system? If we think of
quantization error as noise, it makes sense to use the equation for SNRdB
given in Section 17.1.2:
SNRdB=2 0l o g10S
N
But what should Nbe, i.e. the quantization error? Given a signal am-
plitude range of ±a,w i t hnbits of resolution it is divided into 2a/2npoints.
Therefore the dynamic range is:
20log10/parenleftbigg2a
2a/2n/parenrightbigg
=2 0×log10(2n)
=2 0×n×log10(2)
≈20×n×(0.3)
=6n
For example, a 16-bit digital audio system results in a dynamic range of 96
dB, which is pretty good, although a 20-bit system yields 120 dB, corre-sponding to the dynamic range of the human ear.
Exercise 17.1 For each of the following, say whether it is a longitudinal
wave or a transverse wave:
•A vibrating violin string.
•Stop-and-go traﬃc on a highway.
CHAPTER 17. SOUND AND SIGNALS 252
•”The wave” in a crowd at a stadium.
•”Water hammer” in the plumbing of your house.
•The wave caused by a stone falling in a pond.
•Ar a d i ow a v e .
Exercise 17.2 You see a lightning strike, and 5 seconds later you hear the
thunder. How far away is the lightning?
Exercise 17.3 You clap your hands in a canyon, and 2 seconds later you
hear an echo. How far away is the canyon wall?
Exercise 17.4 By what factor must one increase the RMS level of a signal
to yield a 10 dB increase in sound level?
Exercise 17.5 A dog can hear in the range 60-45,000 Hz, and a bat 2,000-
110,000 Hz. In terms of the frequency response, what are the correspondingdynamic ranges for these two animals, and how do they compare to that ofhumans?
Exercise 17.6 What is the maximum number of audible overtones in a
note whose fundamental frequency is 100 Hz? 500 Hz? 1500 Hz? 5 kHz?
Exercise 17.7 Consider a continuous input signal whose frequency is f.
Devise a formula for the frequency r of the reproduced signal given a samplerate s.
Exercise 17.8 How much memory is needed to record 3 minutes of stereo
sound using 16-bit samples taken at a rate of 44.1 kHz?
Exercise 17.9 If we want the best possible sound, how large should the
table be using ﬁxed-waveform table-lookup synthesis, in order to cover the
audible frequency range?
Exercise 17.10 The Doppler eﬀect occurs when a sound source is in mo-
tion. For example, as a police car moves toward you its siren sounds higherthan it really is, and as it goes past you, it gets lower. How fast would
a police car have to go to change a siren whose frequency is the same as
concert A, to a pitch an octave higher? (i.e. twice the frequency) At thatspeed, what frequency would we hear after the police car passes us?

Chapter 18
Euterpea’s Signal Functions
{-# LANGUAGE Arrows #- }
module Euterpea .Music.Signal.SigFuns where
importEuterpea
importControl.Arrow((>>>),(<<<),arr)
Details: The ﬁrst line in the module header above is a compiler pragma ,a m d
in this case is telling GHC to accept arrow syntax , which will be explained in
Section18.1.
In this chapter we show how the theoretical concepts involving sound
and signals studied in the last chapter are manifested in Euterpea. Thetechniques learned will lay the groundwork for doing two broad kinds ofactivities: sound synthesis andaudio processing . Sound synthesis might
include creating the sound of a footstep on dry leaves, simulating a con-
ventional musical instrument, creating an entirely new instrument sound,or composing a single “soundscape” that stands alone as a musical com-position. Audio processing includes such things as equalization, ﬁltering,reverb, special eﬀects, and so on. In future chapters we will study varioustechniques for achieving these goals.
253
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 254
18.1 Signals and Signal Functions
As we saw in Chapter 16, it would seem natural to represent a signal as
an abstract type, say Signal T in Haskell, and then deﬁne functions to
add, multiply, take the sine of, and so on, signals represented in this way.For example, Signal Float would be the type of a time-varying ﬂoating-
point number, Signal AbsPitch would be the type of a time-varing absolute
pitch, and so on. Then given s
1,s2::Signal Float we might simply write
s1+s2,s1∗s2,a n dsin s 1as examples of applying the above operations.
Haskell’s numeric type class hierarchy would make this particularly easy to
do. Indeed, several domain-speciﬁc languages based on this approach have
been deﬁned before, beginning with the language Fran[EH97]t h a tw a s
designed for writing computer animation programs.
But years of experience and theoretical study have revealed that such an
approach leads to a language with subtle time- and space-leaks,1for reasons
that are beyond the scopeof thistextbook [ LH07]. Therefore Euterpeatakes
a somewhat diﬀerent approach, as described below.
Perhaps the simplest way to understand Euterpea’s approach to pro-
gramming with signals is to think of it as a language for expressing signal
processing diagrams (or equivalently, electrical circuits). We refer to the
lines in a typical signal processing diagram as signals, and the boxes that
convert one signal into another as signal functions . For example, this very
simple diagram has two signals, xandy, and one signal function, sigfun:
sigfun x y
Using Haskell’s arrow syntax [Hug00,Pat01], this diagram can be expressed
as a code fragment in Euterpea simply as:
y←sigfun−≺x
Details: The syntax ←and−≺is typeset here in an attractive way, but the user
will have to type <-and-<, respectively, in her source ﬁle.
1A time-leak in a real-time system occurs whenever a time-dependent computation falls
behind the current time because its value or eﬀect is not needed yet, but then requires
“catching up” at a later point in time. This catching up process can take an arbitrarilylong time, and may consume additional space as well. It can destroy any hope for real-time
behavior if not managed properly.
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 255
Arrows and arrow syntax will be described in much more detail in Chap-
ter??. For now, keep in mind that ←and−≺are part of the syntax,a n d
are not simply binary operators. Indeed, we can’t just write the above codefragment anywhere. It has to be within an enclosing procconstruct whose
result type is that of a signal function. The procconstruct begins with the
keyword procalong with an argument, analogous to an anonymous function.
For example, a signal function that takes a signal of type Doubleand adds
1 to every signal sample, and then applies sigfunto the resulting signal, can
be written:
proc y→do
x←sigfun−≺y+1
outA−≺x
Details: Thedokeyword in arrow syntax introduces layout, just as it does in
monad syntax.
Note the analogy of this code to the following snippet involving an ordi-
nary anonymous function:
λy→
letx=sigfun(y+1)
inx
The important diﬀerence, however, is that sigfunworks on a signal, which
we can think of as a stream of values, whose representative values at the“point” level are the variables xandyabove. So in reality we would have
to write something like this:
λys→
letxs=sigfun(map(+1)ys)
inxs
to achieve the eﬀect of the arrow code above. The arrow syntax allows us to
avoid worrying about the streams themselves. It also has other importantadvantages that are beyond the scope of the current discussion.
Arrow syntax is just that--syntactic sugar that is expanded into a set of
conventional functions that work just as well, but are more cumbersome toprogram with (just as with monad syntax). This syntactic expansion willbe described in more detail in Chapter ??. To use the arrow syntax within
a◦lhsﬁle, one must declare a compiler ﬂag in GHC at the very beginning
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 256
of the ﬁle, as follows:
{-# LANGUAGE Arrows #- }
18.1.1 The Type of a Signal Function
Polymorphically speaking, a signal function has type:
Clock c⇒SigFun c a b
which should be read, “for some clock type (i.e. sampling rate) c,t h i si st h e
type of signal functions that convert signals of type ainto signals of type
b.”
The type variable cindicates what clock rate is being used, and for our
purposes will always be one of two types: AudRate orCtrRate (foraudio
rateandcontrol rate , respectively). Being able to express the sampling rate
of a signal function is what we call clock polymorphism . Although we like to
think of signals as continuous, time-varying quantities, in practice we knowthat they are sampled representations of continous quantities, as discussedin the last chapter. However, some signals need to be sampled at a veryhigh rate—say, an audio signal—whereas other signals need not be sampledat such a high rate—say, a signal representing the setting of a slider. Theproblem is, we often want to mix signals sampled at diﬀerent rates; forexample, the slider might control the volume of the audio signal.
Onesolutiontothisproblemwouldbetosimplysampleeverythingatthe
very highest rate, but this is computationally ineﬃcient. A better approachis to sample signals at their most appropriate rate, and to perform coercions
to “upsample”or “downsample” asignalwhenitneedstobecombined with
a signal sampled at a diﬀerent rate. This is the approach used in Euterpea.
More speciﬁcally, the base type of each signal into and out of a signal
function must satisfy the type class constraint Clock c,w h e r ecis aclock
type.T h eClockedclass is deﬁned as:
classClock c where
rate::c→Double
The single method rateallows the user to extract the sampling rate from
the type. In Euterpea, the AudRate is pre-deﬁned to be 44.1 kHz, and the
CtrRate is set at 4.41 kHz. Here are the deﬁnitions of AudRate andCtrRate,
along with their instance declarations in the Clockclass, to achieve this:
dataAudRate
dataCtrRate
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 257
instance Clock AudRate where
rate
= 44100
instance Clock CtrRate where
rate
= 4410
Because these two clock types are so often used, it is helpful to deﬁne a
couple of type synonyms:
typeAudSF a b =SigFun AudRate a b
typeCtrSF a b =SigFun CtrRate a b
From these deﬁnitions it should be clear how to deﬁne your own clock
type.
Details: Note that AudRate andCtrRate have no constructors—they are called
emptydata types. More precisely, they are each inhabited by exactly one value,
namely⊥.
The sampling rate can be determined from a given clock type. In this
way, a coercion function can be written to change a signal sampled at onerate to a signal sampled at some other rate. In Euterpea, there are two suchfunctions that are pre-deﬁned:
coerce,upsample ::(Clock c
1,Clock c 2)⇒
SigFun c 1ab→SigFun c 2ab
The function coercelooks up the sampling rates of the input and output
signals from the type variables c1andc2. It then either stretches the input
stream by duplicating the same element or contracts it by skippingelements.(It is also possible to deﬁne a more accurate coercion function that performsinterpolation, at the expense of performance.)
For simpler programs, the overhead of calling coercemight not be worth
the time saved by generating signals with lower resolution. (Haskells frac-tional number implementation is relatively slow.) The specialized coercionfunction upsample avoids this overhead, but only works properly when the
output rate is an integral multiple of the input rate (which is true in thecase ofAudRate andCtrRate).
Keep in mind that one does not have to commit a signal function to a
particular clock rate—it can be left polymorphic . Then that signal function
will adapt its sampling rate to whatever is needed in the context in which
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 258
it is used.
Also keep in mind that a signal function is an abstract function. You
cannot just apply it to an argument like an ordinary function—that is thepurpose of the arrow syntax. There are no values that directly representsignalsin Euterpea—there are only signal functions .
The arrow syntax provides a convenient way to compose signal functions
together—i.e. to wire together the boxes that make up a signal processingdiagram. By not giving the user direct access to signals, and providing a
disciplined way to compose signal functions (namely arrow syntax), time-
and space-leaks are avoided. In fact, the resulting framwework is highlyamenable to optimization, although this requires using special features inHaskell, as described in Chapter ??.
A signal function whose type is of the form Clock c ⇒SigFun c ()b
essentially takes no input, but produces some output of type b. Because of
this we often refer to such a signal function as a signal source .
18.1.2 Four Useful Functions
There are four useful auxiliary functions that will make writing signal func-
tions a bit easier. The ﬁrst two essentially “lift” constants and functionsfrom the Haskell level to the arrow (signal function) level:
arr::Clock c⇒(a→b)→SigFun c a b
constA::Clock c⇒ b→SigFun c ()b
For example, a signal function that adds one to every sample of its input
c a nb ew r i t t e ns i m p l ya s arr(+1), and a signal function that returns the
constant 440 as its result can be written constA440 (and is a signal source,
as deﬁned earlier).
The other two functions allow us to compose signal functions:
(>>>)::Clock clk ⇒
SigFun clk a b →SigFun clk b c →SigFun clk a c
(<<<)::Clock clk ⇒
SigFun clk b c →SigFun clk a b →SigFun clk a c
(<<<) is analogous to Haskell’s standard composition operator ( ◦), whereas
(>>>) is like “reverse composition.”
As an example that combines both of the ideas above, recall the very
ﬁrst example given in this chapter:
proc y→do
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 259
x←sigfun−≺y+1
outA−≺x
which essentially applies sigfunto one plus the input. This signal function
can be written more succinctly as either arr(+1)>>>sigfunorsigfun<<<
arr(+1).
The functions ( >>>), (<<<), andarrare actually generic operators on
arrows, and thus to use them one must import them from the Arrowlibrary,
as follows:
importControl.Arrow((>>>),(<<<),arr)
18.1.3 Some Simple Examples
Let’s now work through a few examples that focus on the behavior of signal
functions, so that we can get a feel for how they are used in practice. Eu-
terpea has many pre-deﬁned signal functions, including ones for sine waves,numeric computations, transcendental functions, delay lines, ﬁltering, noisegeneration, integration, and so on. Many of these signal functions are in-spired by csound [ Ver86], where they are called unit generators .S o m e o f
them are not signal functions per se, but take a few ﬁxed arguments to yield
a signal function, and it is important to understand this distinction.
For example, there are several pre-deﬁned functions for generating sine
waves and periodic waveforms in Euterpea. Collectively these are called os-
cillators, a name taken from electronic circuit design. They are summarized
in Figure 18.1.
The two most common oscillators in Euterpea are:
osc ::Clock c⇒
Table→Double→SigFun c Double Double
oscFixed ::Clock c⇒
Double→SigFun c ()Double
oscusesﬁxed-waveformtable-lookup synthesisasdescribedinSection 17.2.2.
The ﬁrst argument is the ﬁxed wavetable; we will see shortly how such atable can be generated. The second argument is the initial phase angle, rep-resented as a fraction between 0 and 1. The resulting signal function thenconverts a signal representing the desired output frequency to a signal thathas that output frequency.
oscFixed uses an eﬃcient recurrence relation to compute a pure sinu-
soidal wave; the mathematics of this are described in Section ??. In contrast
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 260
osc,oscI::Clock c⇒
Table→Double→SigFun p Double Double
osc tab ph is a signal function whose input is a frequency, and output is a
signal having that frequency. The output is generated using ﬁxed-waveformtable-lookup, using the table tab, starting with initial oﬀset (phase angle)
phexpressed as a fraction of a cycle (0 to 1). oscIis the same, but uses
linear interpolation between points.
oscFixed ::Clock c⇒
Double→SigFun c ()Double
oscFixed freq is a signal source whose sinusoidal output frequency is freq.
Uses a recurrence relation that requires only one multiply and two addoperations for each sample of output.
oscDur,oscDurI ::Clock c⇒
Table→Double→Double→SigFun()Double
oscDur tab del dur samples just once through the table tabat a rate deter-
mined by dur.F o rt h eﬁ r s t delseconds, the point of scan will reside at the
ﬁrst location of the table; it will then move through the table at a constantrate, reaching the end in another durseconds; from that time on (i.e. after
del+durseconds) it will remain pointing at the last location. oscDurI is
similar but uses linear interpolation between points.
oscPartials ::Clock c⇒
Table→Double→SigFun c (Double,Int)Double
oscPartials tab ph is a signal function whose pair of inputs determines the
frequency (as with osc), as well as the number of harmonics of that fre-
quency, of the output. tabis the table that is cycled through, and phis the
phase angle (as with osc).
Figure 18.1: Eutperea’s Oscillators
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 261
withosc, its single argument is the desired output frequency. The resulting
signal function is therefore a sign al source (i.e. i ts input ty pe is ()).
[To do: Discuss recurrence relations here or perhaps in the last chapter
where the ﬁxed-waveform table-lookup method is described. ]
The key point here is that the frequency that is output by oscis an
input to the signal function , and therefore can vary with time, whereas the
frequency output by oscFixed is aﬁxed argument , and cannot vary with
time. To see this concretely, let’s deﬁne a signal source that generates a
pure sine wave using oscFixed at a ﬁxed frequency, say 440 Hz:
s1::Clock c⇒SigFun c ()Double
s1=proc()→do
s←oscFixed 440−≺()
outA−≺s
Since the resulting signal sis directly returned through outA,t h i se x a m p l e
can also be written:
s1=proc()→do
oscFixed 440−≺()
Alternatively, we could simply write oscFixed 440.
To useoscinstead, we ﬁrst need to generate a wavetable that represents
one full cycle of a sine wave. We can do this using one of Eutperpea’s table
generating functions, which are summarized in Figure 18.2. For example,
using Euterpea’s tableSinesN function, we can deﬁne:
tab1::Table
tab1=tableSinesN 4096 [1]
Thiswill generate a table of 4096 elements, consisting ofone sinewave whose
peak amplitude is 1.0. Then we can deﬁne the following signal source:
s2::Clock c⇒SigFun c ()Double
s2=proc()→do
osc tab 10−≺440
Alternatively, we could use the constand compostion operators to write
eitherconstA440>>>osc tab 10o rosc tab 20<<<constA440.s1ands2
should be compared closely.
Keep in mind that oscFixed only generates a sine wave, whereas osc
generates whatever is stored in the wavetable. Indeed, tableSinesN actually
creates a table that is the sum of a series of overtones, i.e. multiples of thefundmental frequency (recall the discussion in Section 17.1.3). For example:
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 262
typeTableSize =Int
typePartialNum =Double
typePartialStrength =Double
typePhaseOﬀset =Double
typeStartPt =Double
typeSegLength =Double
typeEndPt =Double
tableLinear ,tableLinearN ::
TableSize →StartPt→[(SegLength ,EndPt)]→Table
tableLinear size sp pts is a table of size sizewhose starting point is (0 ,sp)
and that uses straight lines to move from that point to, successively, each ofthe points in pts, which are segment-length/endpoint pairs (segment lengths
are projections along the x-axis). tableLinearN is a normalized version of
the result.
tableExpon ,tableExponN ::
TableSize →StartPt→[(SegLength ,EndPt)]→Table
Justlike tableLinear andtableLinearN , respectively, except thatexponential
curves are used to connect the points.
tableSines3 ,tableSines3N ::
TableSize →[(PartialNum ,PartialStrength ,PhaseOﬀset )]→Table
tableSines3 size triples isatableofsize sizethatrepresentsasinusoidalwave
and an arbitrary number of partials, whose relationship to the fundamentalfrequency, amplitude, and phase are determined by each of the triples intriples.
tableSines3N is a normalized version of the result.
tableSines ,tableSinesN ::
TableSize →[PartialStrength ]→Table
LiketableSines3 andtableSines3N , respectively, except that the second ar-
gument is an ordered list of the strengths of each partial, starting with thefundamental.
tableBesselN ::
TableSize →Double→Table
tableBesselN size x is a table representing the log of a modiﬁed Bessel
function of thesecond kind, order0, suitableforuseinamplitude-modulatedFM.xis the x-interval (0 to x) over which the function is deﬁned.
Figure 18.2: Table Generating Functions
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 263
tab2=tableSinesN 4096 [1.0,0.5,0.33]
generates a waveform consisting of the fundamental frequency with ampli-
tude 1.0, the ﬁrst overtone at amplitude 0.5, and the second overtone atamplitude 0.33. So a more complex sound can be synthesized just by chang-ing the wavetable:
s
3::Clock c⇒SigFun c ()Double
s3=proc()→do
osc tab 20−≺440
To get the same eﬀect using oscFixed we would have to write:
s4::Clock c⇒SigFun c ()Double
s4=proc()→do
f0←oscFixed 440−≺()
f1←oscFixed 880−≺()
f2←oscFixed 1320−≺()
outA−≺(f0+0.5∗f1+0.33∗f2)/1.83
Not only is this more complex, it is less eﬃcient. (The division by 1.83 is
to normalize the result—if the peaks of the three signals f0,f1,a n df2align
properly, the peak amplitude will be 1.83 (or -1.83), which is outside therange±1.0 and may cause clipping (see discussion in Section 18.2).
So far in these examples we have generated a signal whose fundamental
frequency is 440 Hz. But as mentioned, in the case of osc, the input to the
oscillator is a signal, and can therefore itself be time-varying. As an ex-ample of this idea, let’s implement vibrato—the performance eﬀect whereby
a musician slightly varies the frequency of a note in a pulsating rhythm.On a string instrument this is typically achieved by wiggling the ﬁnger onthe ﬁngerboard, on a reed instrument by an adjustment of the breath andemboucher to compress and relax the reed in a suitable way, and so on.
Speciﬁcally, let’s deﬁne a function:
vibrato::Clock c⇒
Double→Double→SigFun c Double Double
such that vibrato f d is a signal function that takes a frequency argument
(this is not a signal of a given frequency, it is the frequency itself), and
generates a signal at that frequency, but with vibrato added, where fis the
vibrato frequency, and dis the vibrato depth. We will consider “depth” to
be a measure of how many Hz the input frequency is modulated.
Intuitively, it seems as if we need twooscillators, one to generate the
fundamental frequency of interest, and the other to generate the vibrato
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 264
(much lower in frequency). Here is a solution:
vibrato::Clock c⇒
Double→Double→SigFun c Double Double
vibrato vfrq dep =proc afrq →do
vib←osc tab 10−≺vfrq
aud←osc tab 20−≺afrq+vib∗dep
outA−≺aud
Note that a pure sine wave is used for the vibrato signal, whereas tab2,a
sum of three sine waves, is chosen for the signal itself.
For example, to play a 1000 Hz tone with a vibrato frequency of 5 Hz
and a depth of 20 Hz, we could write:
s5::AudSF()Double
s5=constA1000>>>vibrato52 0
Vibrato is actually an example of a more general sound synthesis tech-
nique called frequency modulation (since one signal is being used to vary, or
modulate, the frequency of another signal), and will be explained in moredetail in Chapter ??. Other chapters include synthesis techniques such as
additive and subtractive synthesis, plucked instruments using waveguides,physical modeling, granular synthesis, as well as audio processingtechniques
such as ﬁlter design, reverb, and other eﬀects. Now that we have a basic
understanding of signal functions, these techniques will be straighforwardto express in Euterpea.
18.2 Generating Sound
Euterpea can execute some programs in real-time, but suﬃciently complexprograms require writing the result to a ﬁle. The function for achieving thisis:
outFile::(AudioSample a ,Clock c)⇒
String→Double→SigFun c ()a→IO()
Theﬁrstargument isthenameof theWAVﬁletowhich theresultiswritten.
Thesecondargumentisthedurationoftheresult,inseconds(rememberthatsignals are conceptually inﬁnite). The third argument is a signal functionthat takes no input and generates a signal of type aas output (i.e. a signal
source), where ais required to be an instance of the AudioSample type class,
which allows one to choose between mono, stereo, etc.
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 265
For example, the IO command outﬁle "test.wav" 5sfgenerates 5 sec-
onds of output from the signal function sf, and writes the result to the ﬁle
"test.wav" .I fsfhastype SigFun AudRate ()Doublethentheresultwillbe
monophonic; if the type is SigFun AudRate () (Double,Double)t h er e s u l t
will be stereophonic; SigFun AudRate () (Double,Double,Double,Double)
yields quadraphonic sound, and so on.
One might think that outFileshould berestricted to AudRate . However,
b ya l l o w i n gas i g n a lo fa n yc l o c kr a t et ob ew r i t t e nt oaﬁ l e ,o n ec a nu s e
external tools to analyze the result of control signals or other signals of
interest as well.
An important detail in writing WAV ﬁles with outFileis that care must
be taken to ensure that each sample falls in the range ±1.0. If this range is
exceeded, the output sound will be harshly distorted, a phenomenon knownasclipping. The reason that clipping sounds especially bad is that once the
maximum limit is exceeded, the subsequent samples are interpreted as thenegation of their intended value—and thus the signal swings abruptly from
its largest possible value to its smallest possible value. Of course, signalswithin your program may be well outside this range—it is only when youare ready to write the result to a ﬁle that clipping needs to be avoided.
Onecaneasilywritesignalfunctionsthatdealwithclippinginonewayor
another. Forexamplehere’sonethatsimplyreturnsthemaximum(positive)or mininum (negative) value if they are exceeded. thus avoiding the abruptchange in magnitude described above, and degenerating in the worst caset oas q u a r ew a v e :
simpleClip ::Clock c⇒SigFun c Double Double
simpleClip =arr f where
fx=ifabs x/lessorequalslant1.0thenxelsesignum x
Details: absis the absolute value function in Haskell, and signumreturns -1 for
negative numbers, 0 for zero, and 1 for positive numbers.
[To do: Deﬁne some signal functions to deal with time—for example
one that “takes” the ﬁrst tseconds of a signal function, returning zero for
all times beyond that. We could write a special function to do this, butusing Occam’s Razor suppose we have a signal function time::Clock c⇒
SigFun c ()Doublethat returns the current time. Then we could write:
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 266
takeSF::Clock c⇒Double→SigFun c Double Double
takeSF t =proc x do
now←time−≺()
outA−≺ifnow<tthenxelse0
Indeed, time can be deﬁned by:
time::Clock c⇒SigFun c ()Double
time=integral<<<constA1
Or, we could take a Yampa-like approach and use a “switcher,” but
then we’d need some switcher signal functions. There is a collection-based
switcher deﬁned in Euterpea .Audio.RendercalledpSwitch, but we might
want something simpler.
Even with all this, it seems desirable to have a “debug” function that
takes a time and a signal function, and returns a Boolean indicating whetheror not the signal function clipped or not during that period of time. Againusing Occam’s razor, it seems best to deﬁne a function sfToList that returns
the inﬁnite list underlying a signal source. If we know the clock rate, then“take”ing a suitable preﬁx of this list will return the desired result. Then,for example, max(take44100 (sfToList ss )) yields the maximum value of
the ﬁrst 44100 samples of the signal source ss. One could then use this to
normalize the ss.
Note that sfToList is not something that can be deﬁned using Euterpea
as a library—it would have to be deﬁned within Euterpea’s implementationof signal functions. ]
18.3 Instruments
So far we have only considered signal functions as stand-alone values whose
output we can write to a WAV ﬁle. But how do we connect the ideas in
previous chapters about Musicvalues,Performance s ,a n ds oo n ,t ot h ei d e a s
presented in this chapter? This section presents a bridge between the twoworlds.
18.3.1 Turning a Signal Function into an Instruement
Suppose that we have a Musicvalue that, previously, we would have played
using a MIDI instrument, and now we want to play using an instrumentthat we have designed using signal functions. To do this, ﬁrst recall from
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 267
Chapter 2that the InstrumentName data type has a special constructor
calledCustom:
dataInstrumentName =
AcousticGrandPiano
|BrightAcousticPiano
|...
|Custom String
deriving (Show,Eq,Ord)
With this constructor, names (represented as strings) can be given to in-
struments that we have designed using signal functions. For example:
simpleInstr ::InstrumentName
simpleInstr =Custom "Simple Instrument"
Now we need to deﬁne the instrument itself. Euterpea deﬁnes the fol-
lowing type synonym:
typeInstr a=Dur→AbsPitch →Volume→[Double]→a
Although Instris polymorphic, by far its most common instantiation is the
typeInstr(AufSF()Double). An instrument of this type is a function
that takes a duration, absolute pitch, volume, and a list of parameters, andreturns a signal source that generates the resulting sound.
Thelistof parameters (similar tothe“pﬁelds”incsound)arenotusedby
MIDI instruments, and thus have not been discussed until now. They aﬀord
us unlimited expressiveness in controlling the sound of our signal-functionbased instruments. Recall from Chapter 8the types:
typeMusic1=Music Note1
typeNote1=(Pitch,[NoteAttribute ])
dataNoteAttribute =
Volume Int
|Fingering Integer
|Dynamics String
|Params[Double]
deriving (Eq,Show)
Using the
Paramsconstructor, each individual note in a Music1value can
be given a diﬀerent list of parameters. It is up to the instrument designerto decide how these parameters are used.
There are three steps to playing a Musicvalue using a user-deﬁned in-
strument. First, we must coerce our signal function into an instrument hav-
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 268
ing the proper type Instras described above. For example, let’s turn the
vibratofunction from the last section into a (rather primitive) instrument:
myInstr::Instr(AudSF()Double)
--Dur→AbsPitch →Volume→[Double]→(AudSF()Double)
myInstr dur ap vol [vfrq,dep]=
proc()→do
vib←osc tab 10−≺vfrq
aud←osc tab 20−≺apToHz ap +vib∗dep
outA−≺aud
Asidefromthere-shuﬄingofarguments, notetheuseofthefunction apToHz,
which converts an absolute pitch into its corresponding frequency:
apToHz::Floating a ⇒AbsPitch →a
Next, we must connect our instrument name (used in the Musicvalue)
to the instrument itself (such as deﬁned above). This is achieved using asimple association list, or instrument map :
typeInstrMap a =[(InstrumentName ,Instr a)]
Continuing the example started above:
myInstrMap ::InstrMap (AudSF()Double)
myInstrMap =[(simpleInstr ,myInstr)]
Finally, we need a function that is analogous to perform from Chapter 8,
except that instead of generating a Performance , it creates a single signal
function that will “play” our Musicvalue for us. In Euterpea that function
is called renderSF :
renderSF ::(Performable a ,AudioSample b ,Clock c)⇒
Music a →
InstrMap (SigFun p ()b)→
(Double,SigFun p ()b)
The ﬁrst element of the pair that is returned is the duration of the Music
value, just as is returned by perform. That way we know how much of the
signal function to render in order to hear the entire composition.
Using the simple melody melin Figure 18.3, and the simple vibrato
instrument deﬁned above, we can generate our result and write it to a ﬁle,
as follows:
(dr,sf)=renderSF mel myInstrMap
main=outFile "simple.wav" dr sf
For clarity we show in Figure 18.4all of the pieces of th is running example
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 269
mel::Music1
mel=
letm=Euterpea .line[na1(c4en),na1(ef4en),na1(f4en),
na2(af4qn),na1(f4en),na1(af4en),
na2(bf4qn),na1(af4en),na1(bf4en),
na1(c5en),na1(ef5en),na1(f5en),
na3(af5wn)]
na1(Prim(Note d p )) =Prim(Note d(p,[Params[0,0]]))
na2(Prim(Note d p )) =Prim(Note d(p,[Params[5,10]]))
na3(Prim(Note d p )) =Prim(Note d(p,[Params[5,20]]))
ininstrument simpleInstr m
Figure 18.3: A Simple Melody
as one program.
18.3.2 Envelopes
Most instruments played by humans have a distinctive sound that is par-
tially dependenton how the performer plays a particular note. For example,whenawindinstrumentisplayed (whetheritbeaﬂute, saxophone, or trum-pet), the note does not begin instantaneously—it depends on how quicklyand forcibly the performer blows into the instrument. This is called the“attack.” Indeed, it is not uncommon for the initial pulse of energey togenerate a sound that is louder than the “sustained” portion of the sound.
And when the note ends, the airﬂow does not stop instantaneously, so there
is variability in the “release” of the note.
The overall variability in the loudness of a note can be simulated by
multiplying the output of a signal function by an envelope, which is a time-
varying signal that captures the desired behavior. For example, ...
Euterpea provides several evelope-generating functions: see Figure 18.5.
Fifth arg to envCSEnvplx : A value greater than 1 causes exponential
growth; a value less than 1 causes exponential decay; a value = 1 will main-tain a true steady state at the last rise value. The attenuation is not by aﬁxed rate (as in a piano), but is sensitive to a note’s duration. However, ifthis argument is less than 0 (or if steady state is less than 4 k-periods) a
ﬁxed attenuation rate of abs atss per second will be used. 0 is illegal.
Sixth arg to envCSEnvplx : Must be positive and is normally of the order
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 270
simpleInstr ::InstrumentName
simpleInstr =Custom "Simple Instrument"
myInstr::Instr(AudSF()Double)
myInstr dur ap vol [vfrq,dep]=
proc()→do
vib←osc tab 10−≺vfrq
aud←osc tab 20−≺apToHz ap +vib∗dep
outA−≺aud
myInstrMap ::InstrMap (AudSF()Double)
myInstrMap =[(simpleInstr ,myInstr)]
(d,sf)=renderSF mel myInstrMap
main=outFile "simple.wav" ds f
Figure 18.4: A Complete Example of a Signal-Function Based Instrument
of 0.01. A large or excessively small value is apt to produce a cutoﬀ that is
not audible. Values less than or equal to 0 are disallowed.
Exercise 18.1 Using the Euterpea function osc, create a simple sinusoidal
wave, but using diﬀerent table sizes, and diﬀerent frequencies, and see if youcan hear the diﬀerences(reporton whatyou hear). Use outFileto writeyour
results to a ﬁle, and be sure to use a d ecent set of speake rs or headphones.
Exercise 18.2 Thevibratofunction varies a signals frequency at a given
rate and depth. Deﬁne an analogous function tremolothat varies the volume
at a given rate and depth. However, in a sense, tremolois a kind of envelope
(inﬁnite in duration), so deﬁneit as a signal source, with which you can thenshape whatever signal you wish. Consider the “depth” to be the fractionalchange to the volume; that is, a value of 0 would result in no tremolo, avalue of 0.1 would vary the amplitude from 0.9 to 1.1, and so on. Test yourresult.
Exercise 18.3 Deﬁne an ADSR (“attack/decay/sustain/release”) envelope
generator (i.e. a signal source) called envADSR ,w i t ht y p e :
typeDPair=(Double,Double) -- pair of duration and amplitude
envADSR ::DPair→DPair→DPair→Double→AudSF()Double
The three DPairarguments are the duration and amplitude of the attack,
decay, and release “phases,” respectively, of the envelope. The sustain phase
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 271
envLine ::Clock p⇒
Double →-- starting value
Double →-- duration in seconds
Double →-- value after dur seconds
SigFun p ()Double
envExpon ::Clock p⇒
Double →-- starting value; zero is illegal for exponentials
Double →-- duration in seconds
Double →-- value after dur seconds (must be non-zero
-- and agree in sign with ﬁrst argument)
SigFun p ()Double
envLineSeg ::Clock p⇒
[Double]→-- list of points to trace through
[Double]→-- list of durations for each line segment
-- (one element fewer than previous argument)
SigFun p ()Double
envExponSeg ::Clock p⇒
[Double]→-- list of points to trace through
[Double]→-- list of durations for each line segment
-- (one element fewer than previous argument)
SigFun p ()Double
envASR ::Clock p⇒
Double →-- rise time in seconds
Double →-- overall duration in seconds
Double →-- decay time in seconds
SigFun p ()Double
envCSEnvlpx ::Clock p⇒
Double →-- rise time in seconds
Double →-- overall duration in seconds
Double →-- decay time in seconds
Table →-- table of stored rise shape
Double →-- attenuation factor, by which the last value
-- of the envlpx rise is modiﬁed during the-- note’s pseudo steady state
Double →-- attenuation factor by which the closing
-- steady state value is reduced exponentially-- over the decay period
SigFun p ()Double
Figure 18.5: Envelopes
CHAPTER 18. EUTERPEA’S SIGNAL FUNCTIONS 272
should hold the last value of the decay phase. The fourth argument is the
duration of the entire envelope, and thus the duration of the sustain phaseshould be that value minus the sum of the durations of the other threephases. (Hint: use Euterpeas envLineSeg function.) Test your result.
Exercise 18.4 Generate a signal that causes clipping, and listen to the
result. Then use simpleClip to “clean it up” somewhat—can you hear the
diﬀerence? Now write a more ambitious clipping function. In particular,one that uses some kind of non-linear reduction in the signal amplitude asit approaches plus or minus one (rather than abruptly “sticking” at plus orminus one, as in simpleClip ).
Exercise 18.5 Deﬁnetwoinstruments,eachoftype Instr(AudSF()Double).
These can be as simple as you like, but each must take at least two Params.
Deﬁne an InstrMap that uses these, and then use renderSF to “drive” your
instruments from a Music1value. Test your result.

Chapter 19
Spectrum Analysis
{-# LANGUAGE Arrows #- }
module Euterpea .Music.Signal.SpectrumAnalysis where
importEuterpea hiding (Event)
importEuterpea .IO.MUI
importEuterpea .IO.MUI.SOE(Color(..))
importData.Complex
importData.Maybe(listToMaybe ,catMaybes )
importControl.SF.AuxFunctions (ﬀtA,FFTData ,Event)
There are many situations where it is desirable to take an existing sound
signal—in particular one that is recorded by a microphone—and analyze itfor its spectral content. If one can do this eﬀectively, it is then possible (atleast in theory) to recreate the original sound, or to create novel variationsof it. The theprybehind this approach is based on Fourier’s Theorem ,w h i c h
states that any periodic signal can be decomposed into a weighted sum of(a potentially inﬁnite number of) sine waves. In this chapter we discuss thetheory as well as the pragmatics for doing spectrum analysis in Euterpea.
19.1 Fourier’s Theorem
Aperiodic signal is a signal that repeats itself inﬁnitely often. Mathemati-
cally, a signal xis periodic if there exists a real number Tsuch that for all
integersn:
x(t)=x(t+nT)
273
CHAPTER 19. SPECTRUM ANALYSIS 274
Tis called the period, which may be just a few microseconds, a few seconds,
or perhaps days—the only thing that matters is that the signal repeatsitself. Usually we want to ﬁnd the smallest value of Tthat satisﬁes the
above property. For example, a sine wave is surely periodic; indeed, recallfrom Section 17.1.1that:
sin(2πk+θ)=s i nθ
for any integer k.I n t h i s c a s e , T=2π, and it is the smallest value that
satisﬁes this property.
But in what sense is, for example, a single musical note periodic? Indeed
it is not, unless it is repeated inﬁnitely often, which would not be veryinteresting musically. Yet something we would like to know is the spectralcontent of that single note, or even of a small portion of that note, within
an entire composition. This is one of the practical problems that we will
address later in the chapter.
Recall fromSection 17.1.1that a sine wave can berepresented by: x(t)=
Asin(ωt+φ), where Ais the amplitude, ωis the radian frequency, and φ
is the phase angle. Joseph Fourier, a french mathematician and physicist,showed the following result. Any periodic signal x(t) with period Tcan be
represented as:
x(t)=C
0+∞/summationdisplay
n=1Cncos(ω0nt+φn) (19.1)
This is called Fourier’s Theorem .ω0=2π/Tis called the fundamental fre-
quency. Note that the frequency of each cosine wave in the series is an
integer multiple of the fundamental frequency. The above equation is alsocalled the Fourier series orharmonic series (related, but not to be confused
with, the mathematical deﬁnition of harmonic series, which has the preciseform 1+
1/2+1/3+1/4+···).
The trick, of course, is determining what the coeﬃcients C0,...,Cnand
phase angles φ1,...,φnare. Determining the above equation for a particular
periodic signal is called Fourier analysis , and synthesizing a sound based
on the above equation is called Fourier synthesis . Theoretically, at least,
we should be able to use Fourier analysis to decompose a sound of interestintoitscompositesinewaves, andthenregenerateitbyartiﬁcially generatingthosecompositesinewaves andaddingthemtogether(i.e.additivesynthesis,to be described in Chapter 20) .O fc o u r s e ,w ea l s oh a v et od e a lw i t ht h e
fact that the representation may involve an inﬁnitenumber of composite
signals.
CHAPTER 19. SPECTRUM ANALYSIS 275
As discussed somewhat in Chapter 17, many naturally occurring vibra-
tions in nature—including the resonances of most musical instruments—arecharacterized as having a fundamental frequency (the perceived pitch) andsome combination of multiples of that frequency, which are often called har-
monics,overtones orpartials. So Fourier’s Theorem seems to be a good
match for this musical application.
19.1.1 The Fourier Transform
When studying Fourier analysis, it is more convenient, mathematically, tousecomplex exponentials . We can relate working with complex exponentials
back to sines and cosines using Euler’s Formula :
e
jθ=cos(θ)+jsin(θ)
cos(θ)=1
2(ejθ+e−jθ)
sin(θ)=1
2(ejθ−e−jθ)
For a periodic signal x(t), which we consider to be a function of time, we
denote its Fourier transform by ˆx(f), which is a function of frequency. Each
point in ˆxis a complex number that represents the magnitude and phase of
the frequency f’s presence in x(t). Using complex exponentials, the formula
for ˆx(f)i nt e r m so f x(t)i s :
ˆx(f)=/integraldisplay∞
−∞x(t)e−jωtdt
whereω=2πf,a n djis the same as the imaginary unit iused in math-
ematics.1Intuitively, the Fourier transform at a particular frequency fis
the integral of the product of the original signal and a pure sinusiodal wavee
−jωt. This latter process is related to the convolution of the two signals,
and intuitively will be non-zero only when the signal has some content of
that pure signal in it.
The above equation describes ˆ xin terms of x. We can also go the other
way around—deﬁning xin terms of ˆ x:
x(t)=/integraldisplay∞
−∞ˆx(f)ejˆωfdf
1Historically, engineers prefer to use the symbol jrather than i,b e c a u s e iis generally
used to represent current in an electrical circuit.
CHAPTER 19. SPECTRUM ANALYSIS 276
where ˆω=2πt.T h i si sc a l l e dt h e inverseFourier transform.
If we expand the deﬁnitions of ωand ˆωwe can see how similar these two
equations are:
ˆx(f)=/integraldisplay∞
−∞x(t)e−j2πftdt (19.2)
x(t)=/integraldisplay∞
−∞ˆx(f)ej2πftdf (19.3)
These two equations, for the Fourier transform and its inverse, are remark-
able in their simplicity and power. They are also remarkable in the following
sense:no information is lost when converting from one to the other .I no t h e r
words, a signal can be represented in terms of its time-varying behavior orits spectral content—they are equivalent!
A function that has the property that f(x)=f(−x) is called an even
function; if f(x)=−f(−x)i ti ss a i dt ob e odd. It turns out that, perhaps
surprisingly, anyfunction can be expressed as the sum of a single even func-
tion and a single odd function. This may help provide some intuition aboutthe equations for the Fourier transform, because the complex exponentiale
j2πftseparates the waveform by which it is being multiplied into its even
and odd parts (recall Euler’s formula). The real (cosine) part aﬀects only
the even part of the input, and the imaginary (sine) part aﬀects only the
odd part of the input.
19.1.2 Examples
Let’s consider some examples, which are illustrated in Figure 19.1:
•Intuitively, the Fourier transform of a pure cosine wave should be an
impulse function—that is, the spectral content of a cosine wave should
be concentrated completely at the frequency of the cosine wave. Theonly catch is that, when working in the complex domain, the Fouriertransform also yields the mirror image of the spectral content, at afrequency that is the negation of the cosine wave’s frequency, as shownin Figure 19.1a. In other words, in this case, ˆ x(f)=ˆx(−f), i.e. ˆxis
even. So the spectral content is the realpart of the complex number
returned from the Fourier transform (recall Euler’s formula).
•In the case of a pure sine wave, we should expect a similar result. The
only catch now is that the spectral content is contained in the imagi-
narypart of the complex number returned from the Fourier transform
CHAPTER 19. SPECTRUM ANALYSIS 277
(recall Euler’s formula), and the mirror image is negated. That is,
ˆx(f)=−ˆx(−f), i.e. ˆxis odd. This is illustrated in Figure 19.1b.
•Conversely, consider what the spectral content of an impulse function
should be. Because an impulse functi on is inﬁni tely “sharp,” it would
seem that its spectrum should contain energy at every point in the fre-quency domain. Indeed, the Fourier transform of an impulse functioncentered at zero is a constant, as shown in Figure 19.1c.
•Consider now the spectral content of a square wave. It can be shown
that theFourier series representation ofa squarewave isthe sumof the
square wave’s fundamental frequency plus its harmonically decreasing(in magnitude) odd harmonics. Speciﬁcally:
sq(t)=
∞/summationdisplay
k=11
ksinkωt,for oddk (19.4)
The spectral content of this signal in shown in Figure 19.1d. Fig-
ure19.2also shows partial reconstruction of the square wave from a
ﬁnite number of its composite signals.
It is worth noting that the diagrams in Figure 19.1make no assumptions
about time or frequency. Therefore, because the Fourier transform and itsinverse are true mathematical inverses, we can read the diagrams as timedomain / frequency domain pairs, or the other way around; i.e. as frequencydomain / time domain pairs. For example, interpreting the diagram on theleft of Figure 19.1a in the frequency domain, is to say that it is the Fourier
transform of the signal on the right (interpreted in the time domain).
19.2 The Discrete Fourier Transform
Recall from Section 17.2.1that we can move from the continuous signal
domain to the discrete domain by replacing the time twith the quantity n/r,
wherenis the integer index into the sequence of discrete samples, and ris
the sampling rate. Let us assume that we have done this for x, and we will
use square brackets to denote the diﬀerence. That is, x[n] denotes the nth
sample of the continuous signal x(t), corresponding to the value x(n/r).
We would now like to compute the Discrete Fourier Transform (DFT)
of our discrete signal. But instead of being concerned about the samplingrate (which can introduce aliasing, for example), our concern turns to the
CHAPTER 19. SPECTRUM ANALYSIS 278
-1-0.5 0 0.5 1
-0.5  0  0.5Amplitude
Time (multiples of 1/f)-1-0.5 0 0.5 1
-1.5 -1 -0.5  0  0.5  1  1.5Amplitude
Frequency (multiples of f)
(a) Cosine wave
-1-0.5 0 0.5 1
-0.5  0  0.5Amplitude
Time (multiples of 1/f)-1-0.5 0 0.5 1
-1.5 -1 -0.5  0  0.5  1  1.5Amplitude
Frequency (multiples of f)
(b) Sine wave
-1-0.5 0 0.5 1
-0.5  0  0.5Amplitude
Time (multiples of 1/f)-1-0.5 0 0.5 1
-1.5 -1 -0.5  0  0.5  1  1.5Amplitude
Frequency (multiples of f)
(c) Impulse function
-1.5-1-0.5 0 0.5 1 1.5
-0.5  0  0.5Amplitude
Time (multiples of 1/f)-1.5-1-0.5 0 0.5 1 1.5
-6 -5 -4 -3 -2 -1  0  1  2  3  4  5  6Amplitude
Frequency (multiples of f)
(d) Square wave
Figure 19.1: Examples of Fourier Transforms
CHAPTER 19. SPECTRUM ANALYSIS 279
-1-0.5 0 0.5 1
 0  0.5  1  1.5Amplitude
Time (multiples of 1/f)
(a) Sine wave
-1-0.5 0 0.5 1
 0  0.5  1  1.5Amplitude
Time (multiples of 1/f)
(b) Sine wave + third harmonic
-1-0.5 0 0.5 1
 0  0.5  1  1.5Amplitude
Time (multiples of 1/f)
( c )S i n c ew a v e+t h i r da n dﬁ f t hh a r m o n i c s
-1-0.5 0 0.5 1
 0  0.5  1  1.5Amplitude
Time (multiples of 1/f)
(d) Sum of ﬁrst eight terms of the Fourier series of a square wave
Figure 19.2: Generating a Square Wave from Odd Harmonics
CHAPTER 19. SPECTRUM ANALYSIS 280
number of samples that we use in computing the DFT—let’s call this N.
Intuitively, the integrals used in our equations for the Fourier transform andits inverse should become sums over the range 0 ...N−1. This leads to a
reformulation of our two equations ( 19.2and19.3) as follows:
2
ˆx[k]=1
NN−1/summationdisplay
n=0x[n]e−j2πkn
N,k=0,1,...,N−1 (19.5)
x[n]=N−1/summationdisplay
k=0ˆx[k]ej2πkn
N,n=0,1,...,N−1 (19.6)
Despite all of the mathematics up to this point, the reader may now
realize that the discrete Fourier transform as expressed above is amenableto implementation—for example it should not be diﬃcult to write Haskellfunctions that realize each of the above equations. But before addressing
implementation issues, let’s discuss a bit more what the results actually
mean.
19.2.1 Interpreting the Frequency Spectrum
Just asx[n] represents a sampled version of the continuous input signal, ˆ x[k]
represents a sampled version of the continous frequency spectrum. Care
must be taken when interpreting either of these results, keeping in mindthe Nyquist-Shannon Sampling Theorem (recall Section 17.2) and aliasing
(Section 17.2.3).
Also recall that the result of a Fourier transform of a periodic signal
is a Fourier series (see Section 19.1), in which the signal being analyzed is
expressed as multiples of a fundamental frequency. In equation 19.5above,
that fundamental frequency is the inverse of the duration of the Nsamples,
i.e. the inverse of
N/r,o rr/N. For example, if the sampling rate is 44.1 kHz
(the CD standard), then:
•If we take N= 441 samples, then the fundamental frequency will be
r/N= 100 Hz.
2The purpose of the factor1/Nin Equation 19.5is to ensure that the DFT and the
inverse DFT are in fact inverses of each other. But it is just by convention that oneequation has this factor and the other does not—it would be suﬃcient if it were done the
other way around. In fact, all that matters is that the product of the two coeﬃcients be
1/N, and thus it would also be suﬃcient for each equation to have the same coeﬃcient,
namely1/√
N. Similarly, the negative exponent in one equation and positive in the other
is also by convention—it would be suﬃcient to do it the other way around.
CHAPTER 19. SPECTRUM ANALYSIS 281
•If we take N= 4410 samples, then the f undamental frequency will be
r/N=1 0H z .
•If we take N= 44100 samples, then the f undamental frequency will
ber/N=1H z .
Thus, as would be expected, taking more samples yields a ﬁnerresolution
of the frequency spectrum. On the other hand, note that if we increasethe sampling rate and keep the number of samples ﬁxed, we get a courser
resolution of the spectrum—this also should be expected, because if weincrease the sampling rate we would expect to have to look at more samplesto get the same accuracy.
AnalogoustotheNyquist-ShannonSamplingTheorem, therepresentable
points in the resulting frequency spectrum lie in the range ±
r/2, i.e. between
plus and minus one-half of the sampling rate. For the above three cases,
respectively, that means the points are:
•-22.0 kHz, -21.9 kHz, ..., -0.1 kHz, 0, 0.1 kHz, ..., 21.9 kHz, 22.0 kHz
•-22.05 kHz, -22.04 kHz, ..., -10 Hz, 0, 10 Hz, ..., 22.04 kHz, 22.05 kHz
•-22.05 kHz, -22.049 kHz, ..., -1 Hz, 0, 1 Hz, ..., 22.049 kHz, 22.05 kHz
For practical purposes, the ﬁrst of these is usually too course, the third is
too ﬁne, and the middle one is useful for many applications.
Note that the ﬁrst range of frequencies above does not quite cover the
range±r/2. But remember that this is a discrete representation of the ac-
tual frequency spectrum, and the proper interpretation would include thefrequences +
r/2and−r/2.
Also note that there are N+1 points in each of the above ranges, not N.
Indeed, the more general question is, how do these points in the frequencyspectrum correspond to the indices i=0,1,...,N−1i nˆx[i]? If we denote
each of these frequencies as f, the answer is that:
f=ir
N,i=0,1,...,N−1 (19.7)
But note that this range of frequencies extends from 0 to ( N−1)(r/N),
which exceeds the Nyquist-Shannon sampling limit of r/2. The way out
of this dilemma is to realize that the DFT assumes that the input signalis periodic in time, and therefore the DFT is periodic in frequency. In
CHAPTER 19. SPECTRUM ANALYSIS 282
other words, values of ffor indices igreater than N/2can be interpreted
as frequencies that are the negation of the frequency given by the formula
above. Assuming even N, we can revise formula 19.7as follows:
f=⎧
⎪⎨
⎪⎩ir
N,i =0,1,...,N
2
(i−N)r
Ni=N
2,N
2+1,...,N−1(19.8)
Note that when i=N/2, both equations apply, yielding f=r/2in the ﬁrst
case, and f=−r/2inthesecond. Indeed,themagnitudeoftheDFT foreach
of these frequencies isthe same (see discussion in the nextsection), reﬂecting
the periodicity of the DFT, and thus is simply a form of redundancy.
The above discussion has assumed a periodic signal whose fundamen-
tal frequency is known, thus allowing us to parameterize the DFT withthe same fundamental frequency. In practice this rarely happens. That is,the fundamental frequency of the DFT typically has no integral relation-ship to the period of the periodic signal. This raises the question, whathappens to the frequencies that “fall in the gaps” between the frequenciesdiscussed above? The answer is that the energy of that frequency compo-nent will be distributed amongst neighboring points in a way that makessense mathematically, although the result may look a little funny compared
to the ideal result (where every frequency component is an integer multiple
of the fundamental). The important thing to remember is that these aredigital representations of the exact spectra, just as a digitized signal is rep-resentative of an exact signal. Two digitized signals can look very diﬀerent(depending on sample rate, phase angle, and so on), yet represent the sameunderlying signal—the same is true of a digitized spectrum.
Inpractice, forreasonsofcomputationaleﬃciency, Nisusuallychosen to
beapoweroftwo. We willreturnto thisissuewhenwediscussimplementingthe DFT.
19.2.2 Amplitude and Power of Spectrum
We discussedabove howeach sampleintheresultofaDFT relates toapointin the frequency spectrum of the input signal. But how do we determinethe amplitude and phase angle of each of those frequency components? Ingeneral each sample in the result of a DFT is a complex number, thus
having both a real and imaginary part, of the form a+jb. We can visualize
this number as a point in the complex Cartesian plane, where the abscissa
CHAPTER 19. SPECTRUM ANALYSIS 283
(x-axis) represents the real part, and the ordinate (y-axis) represents the
imaginary part, as shown in Figure 19.3. It is easy to see that the line from
the origin to the point of interest is a vector A, whoselength is the amplitude
of the frequency component in the spectrum:
A=/radicalbig
a2+b2 (19.9)
The angle θis thephase, and it is easily deﬁned from the ﬁgure as:
θ=tan−1b
a(19.10)
(This amplitude / phase pair is often called the polarrepresentation of a
complex number.)
Imaginary
Realθ
ab(a,b)
A
Figure 19.3: Complex and Polar Coordinates
Recall from Section 17.1.2that power is proportional to the square of
the amplitude. Since taking a square root adds computational expense,the square root is often omitted from Equation 19.9, thus yielding a power
spectrum instead of an amplitude spectrum .
One subtle aspect of the resulting DFT is how to interpret negative fre-
quencies. In the case of having an input whose samples are all real numbers(i.e. there are no imaginary components), which is true for audio applica-tions, the negative spectrum is a mirror image of the positive spectrum, andthe amplitude/power is distributed evenly between the two.
CHAPTER 19. SPECTRUM ANALYSIS 284
19.2.3 A Haskell Implementation of the DFT
From equation 19.5, which deﬁnes the DFT mathematically, we can write a
Haskell program that implements the DFT.
The ﬁrst thing we need to do is understand how complex numbers are
handled in Haskell. They are captured in the Complex library, which must
be imported into any program that uses them. The type Complex T is
the type of complex numbers whose underlying numeric type is T. We will
use, for example, Complex Double f o rt e s t i n go u rD F T .Ac o m p l e xn u m b e r
a+jbis represented in Haskell as a:+b, and since (:+) is a constructor,
such values can be pattern matched.
Details: Complex numbers in Haskell are captured in the Complex library, in
which complex numbers are deﬁned as a polymorphic data type:
inﬁx6: +
data(RealFloat a )⇒Complex a =!a:+ !a
The “!” in front of the type variables declares that the constructor (:+)is strict in
its arguments. For example, the complex number a+jbis represented by a:+b
in Haskell. One can pattern match on complex number values to extract the realand imaginary parts, or use one of the predeﬁned selectors deﬁned in the Complex
library:
realPart,imagPart ::RealFloat a ⇒Complex a →a
TheComplex library also deﬁnes the following functions:
conjugate ::RealFloat a ⇒Complex a →Complex a
mkPolar ::RealFloat a ⇒a→a→Complex a
cis ::RealFloat a ⇒a→Complex a
polar ::RealFloat a ⇒Complex a →(a,a)
magnitude ,phase::RealFloat a ⇒Complex a →a
Thelibraryalsodeclaresinstancesof Complex forthetypeclasses Num,Fractional ,
andFloating.
Although not as eﬃcient as arrays, for simplicity we choose to use lists to
represent the vectors that are the inputand output of the DFT. Thusif xsis
the list that represents the signal x,t h e nxs!!nis then+1thsample of that
signal, and is equivalent to x[n]. Furthermore, using list comprehensions, we
can make the Haskell code look very much like the mathematical deﬁnitioncaptured in Equation 19.5. Finally, we adopt the convention that the length
CHAPTER 19. SPECTRUM ANALYSIS 285
of the input signal is the number of samples that we will use for the DFT.
Probably the trickiest part of writing a Haskell program for the DFT is
dealing with thetypes! Inparticular, ifyou look closely at Equation 19.5you
will see that Nis used in three diﬀerent ways—as an integer (for indexing),
as a real number (in the exponent of e), and as a complex number (in the
expression 1/N).
Here is a Haskell program that implements the DFT:
dft::RealFloat a ⇒[Complex a ]→[Complex a ]
dft xs=
letlenI=length xs
lenR=fromIntegral lenI
lenC=lenR:+ 0
in[leti=−2∗pi∗fromIntegral k /lenR
in(1/lenC)∗sum[(xs!!n)∗exp(0:+i∗fromIntegral n )
|n←[0,1..lenI−1]]
|k←[0,1..lenI−1]]
Note that lenI,lenR,a n dlenCare the integer, real, and complex versions,
respectively, of N. Otherwise the code is fairly straightforward—note in
particular how list comprehensions are used to implement the ranges of n
andkin Equation 19.5.
To test our program, let’s ﬁrst create a couple of waveforms. For exam-
ple, recall that Equation 19.4deﬁnes the Fourier series for a square wave.
We can implement the ﬁrst, ﬁrst two, and ﬁrst three terms of this series, cor-responding respectively to Figures 19.2
a,19.2b, and19.2c, by the following
Haskell code:
mkTerm ::Int→Double→[Complex Double ]
mkTerm num n =letf=2∗pi/fromIntegral num
in[sin(n∗f∗fromIntegral i )/n:+ 0
|i←[0,1..num−1]]
mkxa,mkxb,mkxc::Int→[Complex Double ]
mkxa num =mkTerm num 1
mkxb num =zipWith(+) (mkxa num )(mkTerm num 3)
mkxc num =zipWith(+) (mkxb num )(mkTerm num 5)
ThusmkTerm num n is thenthterm in the series, using numsamples.
Using the helper function printComplexL deﬁned in Figure 19.4,w h i c h
“pretty prints” a list of complex numbers, we can look at the result of our
CHAPTER 19. SPECTRUM ANALYSIS 286
printComplexL ::[Complex Double ]→IO()
printComplexL xs =
letf(i,rl:+im)=
doputStr(spaces(3−length(show i)))
putStr(show i++": (" )
putStr(niceNum rl ++", " )
putStr(niceNum im ++")\n" )
inmapM
f(zip[0..length xs −1]xs)
niceNum ::Double→String
niceNum d =
letd/prime=fromIntegral (round(1e10∗d))/1e10
(dec,fra)=break(== ’.’)(show d/prime)
(fra/prime,exp)=break(== ’e’)fra
inspaces(3−length dec )++dec++take11fra/prime
++exp++spaces(12−length fra/prime−length exp )
spaces::Int→String
spaces n =take n(repeat ’’)
Figure 19.4: Helper Code for Pretty-Printing DFT Results
DFT in a more readable form.3
For example, suppose we want to take the DFT of a 16-sample represen-
tation of the ﬁrstthree terms of the squarewave series. Typing the followingat the GHCi prompt:
printComplexL (dft(mkxc16))
will yield the result of the DFT, pretty-printing each number as a pair, along
with its index:
0: ( 0.0 , 0.0 )
1: ( 0.0 , -0.5 )2: ( 0.0 , 0.0 )
3: ( 0.0 , -0.1666666667 )
4: ( 0.0 , 0.0 )5: ( 0.0 , -0.1 )
6: ( 0.0 , 0.0 )
3“Pretty-printing” real numbers is a subtle task. The code in Figure 19.4rounds the
numnber to 10 decimal places of accuracy, and inserts spaces before and after to line up
the decimal points and give a consistent string length. The fractional part is not padded
with zeros, since that would give a false impression of its accuracy. (It is not necessary tounderstand this code in order to understand the concepts in this chapter.)
CHAPTER 19. SPECTRUM ANALYSIS 287
7: ( 0.0 , 0.0 )
8: ( 0.0 , 0.0 )
9: ( 0.0 , 0.0 )
10: ( 0.0 , 0.0 )11: ( 0.0 , 0.1 )
12: ( 0.0 , 0.0 )
13: ( 0.0 , 0.1666666667 )14: ( 0.0 , 0.0 )
15: ( 0.0 , 0.5 )
Let’s study this result more closely. For sake of argument, assume a
sample rate of 1.6 KHz. Then by construction using mkxc, our square-wave
input’sfundamentalfrequencyis100Hz. Similarly, recallthattheresolutionof the DFT is r/N, which is also 100 Hz.
Now compare the overall result to Figure 19.1b. Recalling also Equation
19.8, we note that the above DFT results are non-zero precisely at 100,
300, 500, -500, -300, and -100 Hz. This is just what we would expect.Furthermore, the amplitudes are one-half of the corresponding harmonicallydecreasing weights dictated by Equation 19.4, namely the values 1,
1/6,a n d
1/10(recall the discussion in Section 19.2.2).
Let’s do another example. We can create an impulse function as follows:
mkPulse ::Int→[Complex Double ]
mkPulse n = 100:take(n−1) (repeat0)
and print its DFT with the command:
printComplexL (dft(mkPulse 16))
whose eﬀect is:
0: ( 6.25 , 0.0 )
1: ( 6.25 , 0.0 )
2: ( 6.25 , 0.0 )
3: ( 6.25 , 0.0 )
4: ( 6.25 , 0.0 )5: ( 6.25 , 0.0 )
6: ( 6.25 , 0.0 )
7: ( 6.25 , 0.0 )8: ( 6.25 , 0.0 )
9: ( 6.25 , 0.0 )
10: ( 6.25 , 0.0 )
11: ( 6.25 , 0.0 )
12: ( 6.25 , 0.0 )13: ( 6.25 , 0.0 )
CHAPTER 19. SPECTRUM ANALYSIS 288
14: ( 6.25 , 0.0 )
15: ( 6.25 , 0.0 )
Compare this to Figure 19.1c, and note how the original magnitude of
the impulse (100) is distributed evenly among the 16 points in the DFT(100/16 = 6.25).
So far we have considered only input signals whose frequency compo-
nents are integral multiples of the DFT’s resolution. This rarely happensin practice, however, because music is simply too complex, and noisy. Asmentioned in 19.2.1, the energy of the signals that “fall in the gaps” is dis-
tributed among neighboring points, although not in as simple a way as youmight think. To get some perspective on this, let’s do one other example.We deﬁne a function to generate a signal whose frequeny is πtimes the
fundamental frequency:
x
1num=letf=pi∗2∗pi/fromIntegral num
inmap(:+0) [sin(f∗fromIntegral i )
|i←[0,1..num−1]]
πis an irrational number, but any number that “falls in the gaps” between
indices would do. We can see the result by typing the command:
printComplexL (dft x 1)
which yields:
0: ( -7.9582433e-3 , 0.0 )
1: ( -5.8639942e-3 , -1.56630897e-2)
2: ( 4.7412105e-3 , -4.56112124e-2)
3: ( 0.1860052232 , -0.4318552865 )4: ( -5.72962095e-2, 7.33993364e-2)
5: ( -3.95845728e-2, 3.14378088e-2)
6: ( -3.47994673e-2, 1.65400768e-2)
7: ( -3.29813518e-2, 7.4048103e-3 )
8: ( -3.24834325e-2, 0.0 )9: ( -3.29813518e-2, -7.4048103e-3 )
10: ( -3.47994673e-2, -1.65400768e-2)
11: ( -3.95845728e-2, -3.14378088e-2)12: ( -5.72962095e-2, -7.33993364e-2)
13: ( 0.1860052232 , 0.4318552865 )
14: ( 4.7412105e-3 , 4.56112124e-2)
15: ( -5.8639942e-3 , 1.56630897e-2)
This is much more complicated than the previous examples! Not only do
the pointsin the spectrumseemto have varying amountsof energy, theyalso
CHAPTER 19. SPECTRUM ANALYSIS 289
have both non-zero real and non-zero imaginary components, meaning that
the magnitude and phase vary at each point. We can deﬁne a function thatconverts a list of complex numbers into a list of their polar representationsas follows:
mkPolars ::[Complex Double ]→[Complex Double ]
mkPolars =map((λ(m,p)→m:+p)◦polar)
which we can then use to reprint our result:
printComplexL (mkPolars (dft x
1))
0: ( 7.9582433e-3 , 3.1415926536 )
1: ( 1.67247961e-2, -1.9290259418 )2: ( 4.58569709e-2, -1.4672199604 )
3: ( 0.470209455 , -1.1640975898 )
4: ( 9.31145435e-2, 2.2336013741 )
5: ( 5.05497204e-2, 2.4704023271 )
6: ( 3.85302097e-2, 2.6979021519 )7: ( 3.38023784e-2, 2.9207398294 )
8: ( 3.24834325e-2, -3.1415926536 )
9: ( 3.38023784e-2, -2.9207398294 )
10: ( 3.85302097e-2, -2.6979021519 )
11: ( 5.05497204e-2, -2.4704023271 )
12: ( 9.31145435e-2, -2.2336013741 )
13: ( 0.470209455 , 1.1640975898 )
14: ( 4.58569709e-2, 1.4672199604 )15: ( 1.67247961e-2, 1.9290259418 )
If we focus on the magnitude (the ﬁrst column), we can see that there is
a peak near index 3 (corresponding roughly to the frequency π), with small
amounts of energy elsewhere.
Exercise 19.1 Write a Haskell function idftthat implements the inverse
D F Ta sc a p t u r e di nE q u a t i o n 19.3. Test your code by applying idftto one
of the signals used earlier in this section. In other words, show empirically
that, up to round-oﬀ errors, idft(dft xs)= =xs.
Exercise 19.2 Usedftto analyze some of the signals generated usingsignal
functions deﬁned in Chapter 18.
[To do: To do the above exercise we need to provide a function that
extracts Nsamples from a sigfun, and somehow keeps it in the sigfun world.
Perhaps something like:
CHAPTER 19. SPECTRUM ANALYSIS 290
sample::Rate→Int→Signal c a (Event(Table a))
such that sample r n is a sigfun that generates an event every 1 /rseconds,
each event being a table containing nsamples of the input. These tables
may or may not overlap, depending on the relationship between r,n,a n d
the sampling rate. ]
Exercise 19.3 Deﬁneafunction mkSqWave ::Int→Int→[Complex Double ]
such that mkSqWave num n is the sum of the ﬁrst nterms of the Fourier
series of a square wave, having numsamples in the result.
Exercise 19.4 Prove mathematically that xand ˆxareinverses. Alsoprove,
using equational reasoning, that dftandidftare inverses. (For the latter
you may assume that Haskell numeric types obey the standard axioms of
real arithmetic.)
19.3 The Fast Fourier Transform
In the last section a DFT program was developed in Haskell that was easy tounderstand, being a faithful translation of Equation 19.5. For pedogogical
purposes, this eﬀort served us well. However, for practical purposes, theprogram is inherently ineﬃcient.
To see why, think of x[n]a n dˆx[k] as vectors. Thus, for example, each
element of ˆ xis the sum of Nmultiplications of a vector by a complex
exponential (which can be represented as a pair, the real and imaginaryparts). And this overall process must be repeated for each value of k,a l s o
Ntimes. Therefore the overall time c omplexity of the implied algorithm
is O(N
2). For even moderate values of N, this can be computationally
intractable. (Our choice of lists for the implementation of vectors makes thecomplexity even worse, because of the linear-time complexity of indexing,
but the discussion below makes this a moot point.)
Fortunately, there exists a much faster algorithm called the Fast Fourier
Transform , or FFT, that reduces the complexity to O( NlogN). This diﬀer-
ence is quite signiﬁcant for large values of N, and is the standard algorithm
used in most signal processing applications. We will not go into the detailsof the FFT algorithm, other than to note that it is a divide-and-conqueralgorithm that depends on the vector size being a power of two.
4
4The basic FFT algorithm was invented by James Cooley and John Tukey in 1965.
CHAPTER 19. SPECTRUM ANALYSIS 291
Rather than developing our own program for the FFT, we will instead
use the Haskell library Numeric .FFTto import a function that will do the
job for us. Speciﬁcally:
ﬀt::...
With this function we could explore the use of the FFT on speciﬁc iinput
vectors, as we did earlier with dft.
However, our ultimate goal is to have a version of FFT that works on
signals. We would like tobeableto specifythenumberofsamplesasapower
of two (which we can think of as the “window size”), the clock rate, and
how often we would like to take a snapshot of the current window (and thussuccessive windows may or may not overlap). The resulting signal functiontakes a signal as input, and outputs eventsat the speciﬁed rate. Events are
discussed in more detail in Chapter 16.
Indeed, Euterpea provide this functionality for us in a function called
ﬀtA:
ﬀtA::Int→Double→Int→SF Double (Event FFTData )
typeFFTData =Map Double Double
SFis a signal function type similar to SigFun,e x c e p tt h a ti ti st a r g e t e df o r
use in the Musical User Interface (MUI) discussed in detail in Chapter ??,
and thus, for example, does not have a clock rate. Map T
1T2is an abstract
type that maps values of type T1to values of type T2, and is imported from
Data.Map.
ﬀtA winInt rate size is a signal function that, every winIntsamples of
the input, creates a window of size 2ˆ size, and computes the FFT of that
window. For every such result, it issues an Eventthat maps from frequency
to magnitude (using the clock rate rateto determine the proper mapping).
Combining ﬀtAwith the MUI widgets discussed in Chapter ??,w ec a n
write a simple program that generates a sine wave whose frequency is con-trolledd by a slider, and whose real-time graph as well as its FFT are dis-played. The program to do this is shown in Figure 19.5.
19.4 Further Pragmatics
[To do: Discuss windowing. ]
Exercise 19.5 Modify the program in Figure 19.5in the following ways:
CHAPTER 19. SPECTRUM ANALYSIS 292
ﬀtEx::UISF() ()
ﬀtEx=proc
→do
f←hSlider(1,2000) 440 −≺()
(d,
)←convertToUISF 100simpleSig −≺f
let(s,ﬀt)=unzip d
←histogram (500,150) 20−≺listToMaybe (catMaybes ﬀt )
←realtimeGraph/prime(500,150) 200 20 Black−≺s
outA−≺()
where
simpleSig ::SigFun CtrRate Double (Double,Event FFTData )
simpleSig =proc f→do
s←osc(tableSinesN 4096 [1]) 0 −≺f
ﬀt←ﬀtA100 (rate(⊥::CtrRate)) 8−≺s
outA−≺(s,ﬀt)
t0=runUIEx (500,600) "fft Test" ﬀtEx
Figure 19.5: A Real-Time Display of FFT Results
1. Add a second slider, and use it to control the frequency of a second
oscillator.
2. Lets1ands2be the names of the signals whose frequencies are con-
trolled by the ﬁrst and second sliders, respectively. Instead of display-ing the FFT of just s
1, try a variety of combinations of s1ands2,s u c h
ass1+s2,s1−s2,s1∗s2,1/s1+1/s2,a n ds1/s2. Comment on the
results.
3. Uses2to control the frequency of s1(as was done with vibratoin
Chapter 18). Plot the ﬀt of s1and comment on the result.
4. Instead of using oscto generate a pure sine wave, try using other
oscillators and/or table generators to create more complex tones, and
plot their FFT’s. Comment on the results.
19.5 References
Most of the ideas in this chapter can be found in any good textbook onsignal processing, such as []. The particular arrangement of the materialhere, in particular Figure 19.1and the development and demonstration of a
CHAPTER 19. SPECTRUM ANALYSIS 293
program for the DFT, is borrowed from the excellent text Computer Music
by Moore [ ?].
Chapter 20
Additive Synthesis and
Amplitude Modulation
{-# LANGUAGE Arrows #- }
module Euterpea .Music.Signal.Additive where
importEuterpea
importControl.Arrow((>>>),(<<<),arr)
Additive synthesis is, conceptually at least, the simplest of many sound
synthesis techniques. Simply put, the idea is to add signals (usually sinewaves of diﬀering amplitudes, frequencies and phases) together to form asound of interest. It is based on Fourier’s theorem as discussed in the pre-vious chapter, and indeed is sometimes called Fourier synthesis .
20.1 Preliminaries
When doing pure additive synthesis it is often convenient to work with a list
of signal sources whose elements are eventually summed together to form a
result. To facilitate this, we deﬁne a few auxiliary functions, as shown inFigure20.1.
constSF s sf simply lifts the value sto the signal function level, and
composes that with sf, thus yielding a signal source.
foldSF f b sfs is analogous to foldrfor lists: it returns the signal source
constA b if the list is empty, and otherwise uses fto combine the results,
pointwise, from the right. In other words, if sfshas the form:
294
CHAPTER 20. ADDITIVE SYNTHE SIS AND AMPLITUDE MODULATION 295
constSF ::Clock c⇒a→SigFun c a b →SigFun c ()b
constSF s sf =constA s >>>sf
foldSF::Clock c⇒
(a→b→b)→b→[SigFun c ()a]→SigFun c ()b
foldSF f b sfs =
foldr g(constA b )sfswhere
gs f as f b =
proc()→do
s1←sfa−≺()
s2←sfb−≺()
outA−≺fs1s2
Figure 20.1: Working With Lists of Signal Sources
sf1:sf2:...:sfn:[]
then the result will be:
proc()→do
s1←sf1−≺()
s2←sf2−≺()
...
sn←sfn−≺()
outA−≺fs1(fs2(...(fs nb)))
20.2 A Bell Sound
A bell, or gong, sound is a good example of the use of “brute force” additive
synthesis. Physically, a bell or gong can be thought of as a bunch of concen-
tric rings, each having a diﬀerent resonant frequency because they diﬀer in
diameter depending on the shape of the bell. Some of the rings will be moredominantthan others, buttheimportantthingto noteis thattheseresonantfrequencies often do not have an integral relationship with each other, andsometimes the higher frequencies can be quite strong, rather than rolling oﬀsigniﬁcantly as with many other instruments. Indeed, it is sometime diﬃcultto say exactly what the pitch of a particular bell is (especially large bells),so complex is its sound. Of course, the pitch of a bell can be controlled bymimimizing the taper of its shape (especially for small bells), thus giving itmore of a pitched sound.
CHAPTER 20. ADDITIVE SYNTHE SIS AND AMPLITUDE MODULATION 296
bell1::Instr(Mono AudRate )
-- Dur -¿ AbsPitch -¿ Volume -¿ AudSF () Double
bell1 dur ap vol []=
letf=apToHz ap
v=fromIntegral vol /100
d=fromRational dur
sfs=map(λp→constA(f∗p)>>>osc tab 10)
[4.07,3.76,3,2.74,2,1.71,1.19,0.92,0.56]
inproc()→do
aenv←envExponSeg [0,1,0.001] [0.003,d−0.003]−≺()
a1←foldSF(+) 0sfs−≺()
outA−≺a1∗aenv∗v/9
tab1=tableSinesN 4096 [1]
test1=outFile "bell1.wav" 6(bell16(absPitch (C,5)) 100 [])
Figure 20.2: A Bell Instrument
In any case, a pitched instrument representing a bell sound can be de-
signed using additive synthesis by using the instrument’s absolute pitch tocreate a series of partials that are conspicuouslynon-integral multiples of thefundamental. If this sound is then shapedby an envelope having a sharp risetime and a relatively slow, exponentially decreasing decay, we get a decentresult. A Euterpea program to achieve this is shown in Figure 20.2.N o t e
the use of mapto create the list of partials, and foldSFto add them to-
gether. Also note that some of the partials are expressed as fractions of the
fundamental—i.e. their frequencies are less than that of the fundamental.
The reader might wonder why we don’t just use one of Euterpea’s table
generating functions, such as:
tableSines3 ,tableSines3N ::
TableSize →[(PartialNum ,PartialStrength ,PhaseOﬀset )]→Table
to generate atablewithall thedesiredpartials. Theproblemis, even though
PartialNum isaDouble, theintentisthatthepartialnumbersallbeintegral.
Toseewhy, suppose1.5 wereoneof thepartialnumbers—then1.5 cycles of asine wave would be written into the table. But the whole point of wavetablelookup synthesis is that the wavetable be a periodic representation of thedesired sound—but that is certainly not true of 1.5 cycles of a sine wave.The situation gets worse with partials such as 4.07, 3.75, 2.74, 0.56, and soon.
CHAPTER 20. ADDITIVE SYNTHE SIS AND AMPLITUDE MODULATION 297
bell2::Instr(Mono AudRate )
-- Dur -¿ AbsPitch -¿ Volume -¿ AudSF () Double
bell2 dur ap vol []=
letf=apToHz ap
v=fromIntegral vol /100
d=fromRational dur
sfs=map(mySF f d )
[4.07,3.76,3,2.74,2,1.71,1.19,0.92,0.56]
inproc()→do
a1←foldSF(+) 0sfs−≺()
outA−≺a1∗v/9
mySF f d p =proc()→do
s←osc tab 10<<<constA(f∗p)−≺()
aenv←envExponSeg [0,1,0.001] [0.003,d/p−0.003]−≺()
outA−≺s∗aenv
test2=outFile "bell2.wav" 6(bell26(absPitch (C,5)) 100 [])
Figure 20.3: A More Sophisticated Bell Instrument
In any case, we can do even better than bell1. An important aspect of
a bell sound that is not captured by the program in Figure 20.2, is that the
higher frequency partials tend to decay more quickly than the lower ones.We can remedy this by giving each partial its own envelope, and making theduration of the envelope inversely proportional to the partial number. Sucha more sophisticated instrument is shown in Figure 20.3. This results in a
much more pleasing and realistic sound.
Exercise 20.1 A problem with the more sophisticated bell sound in Fig-
ure20.3is that the duration of the resulting sound exceeds the speciﬁed
duration of the note, because some of the partial numbers are less than one.Fix this.
Exercise 20.2 Neither of the bell sounds shown in Figures ??and20.3
actually contain the fundamental frequency—i.e. a partial number of 1.0.Yet they contain the partials at the integer multiples 2 and 3. How does
this aﬀect the result? What happens if you add in the fundamental?

CHAPTER 20. ADDITIVE SYNTHE SIS AND AMPLITUDE MODULATION 298
20.3 Amplitude Modulation
Technically speaking, whenever the amplitude of a signal is dynamically
changed, it is a form of amplitude modulation ,o rAMfor short; that is,
we are modulating the amplitude of a signal. So, for example, shaping asignal with an envelope, as well as adding tremolo, are both forms of AM.In this section more interesting forms of AM are explored, including theirmathematical basis. To help distinguish these forms of AM from others, wedeﬁne a few terms:
•The dynamically changing signal that is doing the modulation is called
themodulating signal
•The signal being modulated is sometimes called the carrier.
•Aunipolar signal is one that is always either positive or negative (usu-
ally positive).
•Abipolar signal is one that takes on both positive and negative values
(that are often symmetric and thus average out to zero).
So, shaping a signal using an envelope is an example of amplitude modu-
lation using a unipolar modulating signal whose frequency is very low (to beprecise,
1/dur,w h e r eduristhelength of thenote), andin factonlyonecyctle
of that signal is used. Likewise, tremolo is an example of amplitude mod-ulation with a unipolar modulating signal whose frequency is a bit higherthan with envelope shaping, but still quite low (typically 2-10 Hz). In bothcases, the modulating signal is infrasonic.
Note that a bipolar signal can be made unipolar (or the other way
around) by adding or subtracting an oﬀset (sometimes called a “DC oﬀ-set,” where DC is shorthand for “direct current”). This is readily seen if wetry to mathematically formalize the notion of tremolo. Speciﬁcally, tremolo
can be deﬁned as adding an oﬀset of 1 to an infrasonic sine wave whose
frequency is f
t(typically 2-10Hz), multiplying that by a “depth” argument
d(in the range 0 to 1), and using the result as the modulating signal; the
carrier frequency is f:
(1+d×sin(2πftt))×sin(2πft)
Based on this equation, here is a simple tremolo envelope generator writ-
ten in Euterpea, and deﬁned as a signal source (see Exercise 18.2):
CHAPTER 20. ADDITIVE SYNTHE SIS AND AMPLITUDE MODULATION 299
tremolo::Clock c⇒
Double→Double→SigFun c ()Double
tremolo tfrq dep =proc()→do
trem←osc tab 10−≺tfrq
outA−≺1+dep∗trem
tremolocan then be used to modulate an audible signal as follows:
...
20.3.1 AM Sound Synthesis
What happens when the modulating signal is audible, just like the carrier
signal? This is where things get interesting from a sound synthesis point ofview, and can result in a rich blend of sounds. To understand this mathe-matically, recall this trigonometric identity:
sin(C)×sin(M)=1
2(cos(C−M)−cos(C+M))
or, sticking entirely with cosines:
cos(C)×cos(M)=1
2(cos(C−M)+cos(C+M))
These equations demonstrate that AM is really just additive synthesis,
which is why the two topics are included in the same chapter. Indeed, theequations imply two ways to implement AM in Euterpea: We can directlymultiply the two outputs, as speciﬁed by the left-hand sides of the equationsabove, or we can add two signals as speciﬁed by the right-hand sides of theequations.
Note the following:
1. When the modulating frequency is the same as the carrier frequency,
theright-handsidesabovereduceto
1/2cos(2C). Thatis,weessentially
double the frequency.
2. Since multiplication is commutative, the following is also true:
cos(C)×cos(M)=1
2(cos(M−C)+cos(M+C))
CHAPTER 20. ADDITIVE SYNTHE SIS AND AMPLITUDE MODULATION 300
which is validated because cos( t)=c o s (−t).
3. Scaling the modulating signal or carrier just scales the entire signal,
since multiplication is associative.
Also note that adding a third modulating frequency yields the following:
cos(C)×cos(M1)×cos(M2)
=( 0.5×(cos(C−M1)×cos(C+M1)))×cos(M2)
=0.5×(cos(C−M1)×cos(M2)+cos( C+M1)×cos(M2))
=0.25×(cos(C−M1−M2)+cos( C−M1+M2)+
cos(C+M1−M2)+cos( C+M1+M2))
In general, combining nsignals using amplitude modulation results in
2n−1signals. AM used in this way for sound synthesis is sometimes called
ring modulation , because the analog circuit (of diodes) originally used to
implement this technique took the shape of a ring. Some nice bell-like tones
can be generated with this technique.
20.4 What do Tremolo and AM Radio Have in
Common?
Combining the previous two ideas, we can use a bipolar carrier in the elec-
tromagnetic spectrum (i.e. the radio spectrum) and a unipolar modulating
frequency in the audiblerange, which we can represent mathematically as:
cos(C)×(1+cos( M)) = cos( C)+0.5×(cos(C−M)+cos(C+M))
Indeed, this is how AM radio works. The above equation says that
AM Radio results in a carrier signal plus two sidebands. To completelycover the audible frequency range, the modulating frequency would need tobe as much as 20kHz, thus yielding sidebands of ±20kHz, thus requiring
station separation of at least 40 kHz. Yet, note that AM radio stations areseparated byonly 10kHz! (540 kHz, 550 kHz, ..., 1600 kHz). Thisis because,at the time Commercial AM Radio was developed, a ﬁdelity of 5KHz wasconsidered “good enough.”
Also note now that the amplitude of the modulating frequency does
matter:
CHAPTER 20. ADDITIVE SYNTHE SIS AND AMPLITUDE MODULATION 301
cos(C)×(1+A×cos(M)) =cos(C)+0.5×A×(cos(C−M)+cos(C+M))
A, called the modulation index , controls the size of the sidebands. Note
the similarity of this equation to that for tremolo.
Appendix A
The PreludeList Module
The use of lists is particularly common when programming in Haskell, and
thus, not surprisingly, there are many pre-deﬁned polymorphic functions forlists. The list data type itself, plus some of the most useful functions on it,are contained in the Standard Prelude’s PreludeList module, which we will
look at in detail in this chapter. There is also a Standard Library modulecalledListthat has additional useful functions. It is a good idea to become
familiar with both modules.
Although this chapter may feel like a long list of “Haskell features,” the
functions described here capture many common patterns of list usage thathave been discovered by functional programmers over many years of tri-als and tribulations. In many ways higher-order declarative programmingwith lists takes the place of lower-level imperative control structures in moreconventional languages. By becoming familiar with these list functions youwill be able to more quickly and conﬁdently develop your own applicationsusing lists. Furthermore, if all of us do this, we will have a common vocab-ulary with which to understand each others’ programs. Finally, by readingthrough the code in this module you will develop a good feel for how to
write proper function deﬁnitions in Haskell.
Itisnotnecessaryforyoutounderstandthedetails ofeveryfunction, but
you should try to get a sense for what is available so that you can returnlater when your programming needs demand it. In the long run you arewell-advised to read the rest of the Standard Prelude as well as the variousStandard Libraries, to discover a host of other functions and data types thatyou might someday ﬁnd useful in your own work.
302
APPENDIX A. THE PRELUDELIST MODULE 303
A.1 The PreludeList Module
To get a feel for the PreludeList module, let’s ﬁrst look at its module dec-
laration:
module PreludeList (
map,(++),ﬁlter,concat,
head,last,tail,init,null,length,(!!),
foldl,foldl1,scanl,scanl1,foldr,foldr1,scanr,scanr1,
iterate,repeat,replicate,cycle,
take,drop,splitAt,takeWhile ,dropWhile ,span,break,
lines,words,unlines,unwords,reverse,and,or,
any,all,elem,notElem,lookup,
sum,product,maximum ,minimum ,concatMap ,
zip,zip3,zipWith,zipWith3 ,unzip,unzip3)
where
importqualiﬁed Char (isSpace)
inﬁxl9! !
inﬁxr5++
inﬁx4∈,/∈
We will not discuss all of the functions listed above, but will cover most of
them (and some were discussed in previous chapters).
A.2 Simple List Selector Functions
headandtailextract the ﬁrst element and remaining elements, respectively,
from a list, which must be non-empty. lastandinitare the dual functions
that work from the end of a list, rather than from the beginning.
head ::[a]→a
head(x:
)=x
head[] = error "PreludeList.head: empty list"
last ::[a]→a
last[x]=x
last(
:xs)=last xs
last[] = error "PreludeList.last: empty list"
tail ::[a]→[a]
tail(
:xs)=xs
tail[] = error "PreludeList.tail: empty list"
APPENDIX A. THE PRELUDELIST MODULE 304
init ::[a]→[a]
init[x]= [ ]
init(x:xs)=x:init xs
init[] = error "PreludeList.init: empty list"
Although headandtailwere previously discussed in Section 3.1, the deﬁ-
nitions here include an equation describing their behaviors under erroneoussituations—such as selecting the head of an empty list—in which case theerrorfunction is called. It is a good idea to include such an equation for
any deﬁnition in which you have not covered every possible case in pattern-
matching; i.e. if it is possible that the pattern-matching could “run oﬀ theend” of the set of equations. The string argument that you supply to theerrorfunction should be detailed enough that you can easily track down the
precise location of the error in your program.
Details: If such an error equation is omitted, and then during pattern-matching
all equations fail, most Haskell systems will invoke the errorfunction anyway, but
most likely with a string that will be less informative than one you can supply onyour own.
Thenullfunction tests to see if a list is empty.
null ::[a]→Bool
null[] =True
null(
:
)=False
A.3 Index-Based Selector Functions
To select the nth element from a list, with the ﬁrst element being the 0th
element, we can use the indexing function (!!):
(!!) ::[ a]→Int→a
(x:
)!!0= x
(
:xs)!!n|n>0=xs!!(n−1)
(
:
)! !
= error "PreludeList.!!: negative index"
[] !!
 = error "PreludeList.!!: index too large"
APPENDIX A. THE PRELUDELIST MODULE 305
Details: Note the deﬁnition of two error conditions; be sure that you understand
under what conditions these two equations would succeed. In particular, recall
that equations are matched in top-down order: the ﬁrst to match is the one thatis chosen.
take n xs returns the preﬁx of xsof length n,o rxsitself ifn>length xs .
Similarly, drop n xs returns the suﬃx of xsafter the ﬁrst nelements, or []
ifn>length xs . Finally, splitAt n xs is equivalent to ( take n xs ,drop n xs ).
take ::Int→[a]→[a]
take0
 =[]
take
[] =[]
take n(x:xs)|n>0=x:take(n−1)xs
take
 =
error "PreludeList.take: negative argument"
drop ::Int→[a]→[a]
drop0xs =xs
drop
[] =[]
drop n(
:xs)|n>0=drop(n−1)xs
drop
 =
error "PreludeList.drop: negative argument"
splitAt ::Int→[a]→([a],[a])
splitAt0xs =( [],xs)
splitAt
 [] =([] ,[])
splitAt n (x:xs)|n>0= (x:xs/prime,xs/prime/prime)
where(xs/prime,xs/prime/prime)=splitAt(n−1)xs
splitAt
 =
error "PreludeList.splitAt: negative argument"
length ::[a]→Int
length[] =0
length(
:l)=1+length l
For example:
take3[0,1..5]⇒[0,1,2]
drop3[0,1..5]⇒[3,4,5]
splitAt3[0,1..5]⇒([0,1,2],[3,4,5])
APPENDIX A. THE PRELUDELIST MODULE 306
A.4 Predicate-Based Selector Functions
takeWhile p xs returnsthelongest (possiblyempty) preﬁxof xs, all of whose
elements satisfy the predicate p.dropWhile p xs returns the remaining
suﬃx. Finally, span p xs is equivalent to ( takeWhile p xs ,dropWhile p xs ),
whilebreak puses the negation of p.
takeWhile ::(a→Bool)→[a]→[a]
takeWhile p [] =[]
takeWhile p (x:xs)
|px =x:takeWhile p xs
|otherwise =[ ]
dropWhile ::(a→Bool)→[a]→[a]
dropWhile p []=[]
dropWhile p xs @(x:xs/prime)
|px =dropWhile p xs/prime
|otherwise =xs
span,break ::(a→Bool)→[a]→([a],[a])
span p[] =([] ,[])
span p xs @(x:xs/prime)
|px =(x:xs/prime,xs/prime/prime)where(xs/prime,xs/prime/prime)=span p xs
|otherwise =(xs,[])
break p =span(¬◦p)
ﬁlterremoves all elements not satisfying a predicate:
ﬁlter::(a→Bool)→[a]→[a]
ﬁlter p[]=[]
ﬁlter p(x:xs)|px=x:ﬁlter p xs
|otherwise =ﬁlter p xs
A.5 Fold-like Functions
foldl1andfoldr1are variants of foldlandfoldrthat have no starting value
argument, and thus must be applied to non-empty lists.
foldl ::(a→b→a)→a→[b]→a
foldl f z [] = z
foldl f z (x:xs)=foldl f(fzx)xs
foldl1 ::(a→a→a)→[a]→a
foldl1 f(x:xs)=foldl f x xs
APPENDIX A. THE PRELUDELIST MODULE 307
foldl1
[] = error "PreludeList.foldl1: empty list"
foldr ::(a→b→b)→b→[a]→b
foldr f z [] = z
foldr f z (x:xs)=fx(foldr f z xs )
foldr1 ::(a→a→a)→[a]→a
foldr1 f[x]=x
foldr1 f(x:xs)=fx(foldr1 f xs )
foldr1
 [] = error "PreludeList.foldr1: empty list"
foldl1andfoldr1are best used in cases where an empty list makes no sense
for the application. For example , computing the maximum or mimimum
element of a list does not make sense if the list is empty. Thus foldl1 max
is a proper function to compute the maximum element of a list.
scanlis similar to foldl, but returns a list of successive reduced values
from the left:
scanl f z [x1,x2,...]= =[z,z‘f‘x1,(z‘f‘x1)‘f‘x2,...]
For example:
scanl(+) 0 [1,2,3]⇒[0,1,3,6]
Note that last(scanl f z xs )=foldl f z xs .scanl1is similar, but without
the starting element:
scanl1 f [x1,x2,...]= =[x1,x1‘f‘x2,...]
Here are the full deﬁnitions:
scanl ::(a→b→a)→a→[b]→[a]
scanl f q xs =q:(casexsof
[]→[]
x:xs→scanl f(fqx)xs)
scanl1 ::(a→a→a)→[a]→[a]
scanl1 f (x:xs)=scanl f x xs
scanl1
 [] = error "PreludeList.scanl1: empty list"
scanr ::(a→b→b)→b→[a]→[b]
scanr f q0 []= [ q0]
scanr f q0 (x:xs)=fxq:qs
whereqs@(q:
)=scanr f q0 xs
scanr1 ::(a→a→a)→[a]→[a]
scanr1 f [x]= [x]
scanr1 f (x:xs)=fxq:qs
whereqs@(q:
)=scanr1 f xs
APPENDIX A. THE PRELUDELIST MODULE 308
scanr1
 [] = error "PreludeList.scanr1: empty list"
A.6 List Generators
There are some functions which are very useful for generating lists from
scratch in interesting ways. To start, iterate f x returns an inﬁnite list of
repeated applications of ftox.T h a ti s :
iterate f x ⇒[x,fx,f(fx),...]
The “inﬁnite” nature of this list may at ﬁrst seem alarming, but in fact is
one of the more powerful and useful features of Haskell.
[say more]
iterate ::(a→a)→a→[a]
iterate f x =x:iterate f (fx)
repeat x is an inﬁnite list, with x the value of every element. replicate n x is
a list of length nwithxthe value of every element. And cycleties a ﬁnite
list into a circular one, or equivalently, the inﬁnite repetition of the originallist.
repeat ::a→[a]
repeat x =xswherexs=x:xs
replicate ::Int→a→[a]
replicate n x =take n(repeat x)
cycle ::[a]→[a]
cycle[] = error
"Prelude.cycle: empty list"
cycle xs =xs/primewherexs/prime=xs++xs/prime
A.7 String-Based Functions
Recall that strings in Haskell are just lists of characters. Manipulating
strings (i.e. text) is a very common practice, so it makes sense that Haskellwould have a few pre-deﬁned functions to make this easier for you.
linesbreaks a string at every newline character (written as ’\n’in
Haskell), thus yielding a listof strings, each of which contains no newline
characters. Similary, wordsb r e a k sas t r i n gu pi n t oal i s to fw o r d s ,w h i c h
were delimited by white space. Finally, unlinesandunwords are the in-
verse operations: unlinesjoins lines with terminating newline characters,
andunwords joins words with separating spaces. (Because of the potential
APPENDIX A. THE PRELUDELIST MODULE 309
presence of multiple spaces and newline characters, however, these pairs of
functions are not true inverses of each other.)
lines ::String→[String]
lines ""=[]
lines s =let(l,s/prime)=break(== ’\n’)s
inl:cases/primeof
[]→[]
(
:s/prime/prime)→lines s/prime/prime
words ::String→[String]
words s =casedropWhile Char .isSpace s of
""→[]
s/prime→w:words s/prime/prime
where(w,s/prime/prime)=break Char .isSpace s/prime
unlines ::[String]→String
unlines =concatMap (++"\n")
unwords ::[String]→String
unwords [] = ""
unwords ws =foldr1(λws→w++’’:s)ws
reversereverses the elements in a ﬁnite list.
reverse::[a]−[a]
reverse=foldl(ﬂip(:)) []
A.8 Boolean List Functions
andandorcompute the logical “and” and “or,” respectively, of all of the
elements in a list of Boolean values.
and,or::[Bool]→Bool
and=foldr(∧)True
or=foldr(∨)False
Applied to a predicate and a list, anydetermines if any element of the list
satisﬁes the predicate. An analogous behavior holds for all.
any,all::(a→Bool)→[a]→Bool
any p=or◦map p
all p=and◦map p
APPENDIX A. THE PRELUDELIST MODULE 310
A.9 List Membership Functions
elemis the list membership predicate, usually written in inﬁx form, e.g.,
x∈xs(which is why it was given a ﬁxity declaration at the beginning of
the module). notElem is the negation of this function.
elem,notElem ::(Eq a)⇒a→[a]→Bool
elem x =any(==x)
notElem x =all(/negationslash=x)
It is common to store “key/value” pairs in a list, and to access the list
by ﬁnding the value associated with a given key (for this reason the list is
often called an association list ). The function lookuplooks up a key in an
association list, returning Nothing if it is not found, or Just yifyis the
value associated with the key.
lookup ::(Eq a)⇒a→[(a,b)]→Maybe b
lookup key [] =Nothing
lookup key ((x,y):xys)
|key==x=Just y
|otherwise =lookup key xys
A.10 Arithmetic on Lists
sumandproductcompute the sum and product, respectively, of a ﬁnite list
of numbers.
sum,product::(Num a)⇒[a]→a
sum =foldl(+) 0
product =foldl(∗)1
maximum andminimum return the maximum and minimum value, respec-
tively from a non-empty, ﬁnite list whose element type is ordered.
maximum ,minimum ::(Ord a)⇒[a]→a
maximum [] =error "Prelude.maximum: empty list"
maximum xs =foldl1 max xs
minimum [] =error "Prelude.minimum: empty list"
minimum xs =foldl1 min xs
Note that even though foldl1is used in the deﬁnition, a test is made for the
empty list to give an error message that more accurately reﬂects the sourceof the problem.
APPENDIX A. THE PRELUDELIST MODULE 311
A.11 List Combining Functions
mapand (++) were deﬁned in previous chapters, but are repeated here for
completeness:
map::(a→b)→[a]→[a]
map f[]=[]
map f(x:xs)=fx:map f xs
(++)::[a]→[a]→[a]
[]++ys=ys
(x:xs)++ys=x:(xs++ys)
concatappends together a list of lists:
concat::[[a]]→[a]
concat xss =foldr(++) []xss
concatMap does what it says: it concatenates the result of mapping a func-
tion down a list.
concatMap ::(a→[b])→[a]→[b]
concatMap f =concat◦map f
ziptakes two lists and returns a list of corresponding pairs. If one input list
is short, excess elements of the longer list are discarded. zip3takes three
lists and returns a list of triples. (“Zips” for larger tuples are contained in
the List Library.)
zip::[a]→[b]→[(a,b)]
zip=zipWith(,)
zip3::[a]→[b]→[c]→[(a,b,c)]
zip3=zipWith3 (,,)
Details: The functions (,)and (,,)are the pairing and tripling functions, respec-
tively:
(,)⇒λxy→(x,y)
(,,)⇒λxyz→(x,y,z)
ThezipWithfamily generalises the zipandmapfamilies (or, in a sense,
combines them) by applying a function (given as the ﬁrst argument) to eachpair (or triple, etc.) of values. For example, zipWith (+) is applied to two
lists to produce the list of corresponding sums.
APPENDIX A. THE PRELUDELIST MODULE 312
zipWith ::(a→b→c)→[a]→[b]→[c]
zipWith z (a:as)(b:bs)
=zab:zipWith z as bs
zipWith
 =[ ]
zipWith3 ::(a→b→c→d)→[a]→[b]→[c]→[d]
zipWith3 z (a:as)(b:bs)(c:cs)
=zabc:zipWith3 z as bs cs
zipWith3
 =[]
The following two functions perform the inverse operations of zipandzip3,
respectively.
unzip::[(a,b)]→([a],[b])
unzip=foldr(λ(a,b)∼(as,bs)→(a:as,b:bs)) ([],[])
unzip3::[(a,b,c)]→([a],[b],[c])
unzip3=foldr(λ(a,b,c)∼(as,bs,cs)→(a:as,b:bs,c:cs))
([],[],[])
Appendix B
Haskell’s Standard Type
Classes
This provides a “tour” through the predeﬁned standard type classes in
Haskell, as was done for lists in Chapter A. We have simpliﬁed these classes
somewhat by omitting some of the less interesting methods; the HaskellReport and Standard Library Report contain more complete descriptions.
B.1 The Ordered Class
The equality class Eqwas deﬁned precisely in Chapter 7,a l o n gw i t ha
simpliﬁed version of the class Ord. Here is its full speciﬁcation of class Ord;
note the many default methods.
class(Eq a)⇒Ord a where
compare ::a→a→Ordering
(<),(/lessorequalslant),(/greaterorequalslant),(>)::a→a→Bool
max,min::a→a→a
compare x y
|x==y=EQ
|x/lessorequalslanty=LT
|otherwise =GT
x/lessorequalslanty =compare x y /negationslash=GT
x<y =compare x y ==LT
x/greaterorequalslanty =compare x y /negationslash=LT
x>y =compare x y ==GT
313
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 314
max x y
|x/greaterorequalslanty=x
|otherwise =y
min x y
|x<y=x
|otherwise =y
dataOrdering =LT|EQ|GT
deriving (Eq,Ord,Enum,Read,Show,Bounded )
Note that the default method for compare is deﬁned in terms of ( /lessorequalslant), and
that the default method for ( /lessorequalslant)i sd e ﬁ n e di nt e r m so f compare. This means
that an instance of Ordshould contain a method for at least one of these
for everything to be well deﬁned. (Using compare c a nb em o r ee ﬃ c i e n tf o r
complex types.) This is a commo n idea in designing a type class.
B.2 The Enumeration Class
ClassEnumhas a set of operations that underlie the syntactic sugar of
arithmetic sequences ; for example, the arithmetic sequence [1 ,3..]i sa c t u -
ally shorthand for enumFromThen 1 3. If this is true, then we should be
able to generate arithmetic sequences for any type that is an instance ofEnum. This includes not only most numeric types, but also Char,s ot h a t ,
for instance, [ ’a’..’z’] denotes the list of lower-case letters in alphabetical
order. Furthermore, a user-deﬁned enumerated type such as Color:
dataColor=Red|Orange|Yellow|Green|Blue|Indigo|Violet
can easily be given an Enuminstance declaration, after which we can cal-
culate the following results:
[Red..Violet]=⇒[Red,Orange,Yellow,Green,
Blue,Indigo,Violet]
[Red,Yellow..]=⇒[Red,Yellow,Blue,Violet]
fromEnum Green =⇒3
toEnum 5::Color=⇒Indigo
Indeed,thederivedinstancewillgivethisresult. Notethatthesequences are
stillarithmetic in the sense that the increment between values is constant,
even though the values are not numbers.
The complete deﬁnition of the Enumclass is given below:
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 315
classEnum a where
succ,pred ::a→a
toEnum ::Int→a
fromEnum ::a→Int
enumFrom ::a→[a] -- [n..]
enumFromThen ::a→a→[a] -- [n,n’..]
enumFromTo ::a→a→[a] -- [n..m]
enumFromThenTo ::a→a→a→[a] -- [n,n’..m]
-- Minimal complete deﬁnition: toEnum, fromEnum
succ =toEnum◦(+1)◦fromEnum
pred =toEnum◦(subtract 1)◦fromEnum
enumFrom x =map toEnum [fromEnum x ..]
enumFromThen x y =map toEnum [fromEnum x ,fromEnum y ..]
enumFromTo x y =map toEnum [fromEnum x ..fromEnum y ]
enumFromThenTo x y z =
map toEnum [fromEnum x ,fromEnum y ..fromEnum z ]
The six default methods are suﬃcient for most applications, so when writing
your own instance declaration it is usuallysuﬃcient to onlyprovide methods
for the remaining two operations: toEnum andfromEnum .
In terms of arithmetic sequences, the expressions on the left below are
equivalent to those on the right:
enumFrom n [n..]
enumFromThen n n/prime[n,n/prime..]
enumFromTo n m [n..m]
enumFromThenTo n n/primem[n,n/prime..m]
B.3 The Bounded Class
The class Bounded captures data types that are linearly bounded in some
way; i.e. they have both a minimum value and a maximum value.
classBounded a where
minBound ::a
maxBound ::a
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 316
B.4 The Show Class
Instancesoftheclass Showarethosetypesthatcanbeconverted tocharacter
strings. This is useful, for example, when writing a representation of a valueto the standard output area or to a ﬁle. The class Readworks in the other
direction: it provides operations for parsing character strings to obtain thevalues that they represent. In this section we will look at the Showclass; in
the next we will look at Read.
For eﬃciency reasons the primitive op erations in these classes are some-
what esoteric, but they provide good lessons in both algorithm and software
design, so we will look at them in some detail.
First, let’s look at one of the higher-level functions that is deﬁned in
terms of the lower-level primitives:
show::(Show a)⇒a→String
Naturally enough, showtakes a value of any type that is a member of Show,
and returns its representation as a string. For example, show(2+2) yields
the string "4",a sd oe s show(6−2) andshowapplied to anyother expression
whose value is 4.
Furthermore, we can construct strings such as:
"The sum of " ++show x++" and " ++show y++"i s"
++show(x+y)++"."
withnodiﬃculty. Inparticular,because(+ +)isrightassociative, thenumber
of steps to construct this string is directly proportional to its total length,and we can’t expect to do any better than that. (Since (+ +) needs to recon-
struct its left argument, if it were left associative the above expression wouldrepeatedly reconstruct the same sub-string on each application of (+ +). If
the total string length were n, then in the worst case the number of steps
needed to do this would be proportional to n
2, instead of proportional to n
i nt h ec a s ew h e r e( + +) is right associative.)
Unfortunately, this strategy breaks down when construction of the list
is nested. A particularly nasty version of this problem arises for tree-shapeddata structures. Consider a function showTree that converts a value of type
Treeinto a string, as in:
showTree (Branch(Branch(Leaf2) (Leaf3)) (Leaf4))
=⇒"< <2|3>|4>"
We can deﬁne this behavior straightforwardly as follows:
showTree ::(Show a)⇒Tree a→String
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 317
showTree (Leaf x)
=show x
showTree (Branch l r )
="<"++showTree l ++"|"++showTree r ++">"
Each of the recursive calls to showTree introduces more applications of (+ +),
but since they are nested, a large amount of list reconstruction takes place(similar to the problem that would arise if (+ +) were left associative). If the
tree being converted has size n, then in the worst case the number of steps
needed to perform this conversion is proportional to n
2. This is no good!
To restore linear complexity, suppose we had a function shows:
shows::(Show a)⇒a→String→String
which takes a showable value and a string and returns that string with the
value’s representation concatenated at the front. For example, we wouldexpectshows(2 + 2) "hello" to return the string "4hello" . The string
argument should be thought of as an “accumulator” for the ﬁnal result.
Usingshowswe can deﬁne a more eﬃcient version of showTree which,
likeshows, has a string accumulator argument. Let’s call this function
showsTree :
showsTree ::(Show a)⇒Tree a→String→String
showsTree (Leaf x)s
=shows x s
showsTree (Branch l r )s
="<"++showsTree l ("|"++showsTree r (">"++s))
This function requires a number of steps directly proportional to the size of
the tree, thus solving our eﬃciency problem. To see why this is so, note thatthe accumulator argument sis never reconstructed. Itis simplypassed as an
argument in one recursive call to showsorshowsTree , and is incrementally
extended to its left using (+ +).
showTree can now be re-deﬁned in terms of showsTree using an empty
accumulator:
showTree t =showsTree t ""
Exercise B.1 Prove that this version of showTree is equivalent to the old.
Although thissolves oureﬃciency problem,thepresentation ofthisfunc-
tion (and others like it) can be improved somewhat. First, let’s create a type
synonym (part of the Standard Prelude):
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 318
typeShowS=String→String
Second, we can avoid carrying accumulators around, and also avoid
amassing parentheses at the right end of long sequences of concatenations,by using functional composition:
showsTree ::(Show a)⇒Tree a→ShowS
showsTree (Leaf x)
=shows x
showsTree (Branch l r )
=("<"++)◦showsTree l ◦("|"++)◦showsTree r ◦(">"++)
Details: This can be simpliﬁed slightly more by noting that ("c"++)is equivalent
to(’c’:)for any character c.
Somethingmoreimportantthan justtidyingupthecodehas comeabout
by this transformation: We have raised the presentation from an object level
(in this case, strings) to a function level . You can read the type signature
ofshowsTree as saying that showsTree maps a tree into a showing function .
Functions like ( "<"++) and ( "a string" ++) are primitive showing functions,
and we build up more complex ones by function composition.
The actual Showclass in Haskell has two additional levels of complexity
(and functionality): (1) the ability to specify the precedence of a string
being generated, which is important when showing a data type that has
inﬁx constructors, since it determines when parentheses are needed, and (2)a function for showing alistof values of the type under consideration, since
lists have special syntax in Haskell and are so commonly used that theydeserve special treatment. The full deﬁnition of the Showc l a s si sg i v e nb y :
classShow a where
showsPrec ::Int→a→ShowS
showList ::[a]→ShowS
showList [] = showString "[]"
showList (x:xs)=showChar ’[’◦shows x◦showl xs
whereshowl[] = showChar ’]’
showl(x:xs)=showString ", "◦shows x◦showl xs
Note the default method for showList , and its “function level” style of deﬁ-
nition.
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 319
In addition to this class declaration the Standard Prelude deﬁnes the
following functions, which return us to where we started our journey in thissection:
shows::(Show a)⇒a→ShowS
shows=showsPrec 0
show::(Show a)⇒a→String
show x=shows x ""
Some details about showsPrec can be found in the Haskell Report, but
if you are not displaying constructors in inﬁx notation, the precedence canbe ignored. Furthermore, the default method for showList is perfectly good
for most uses of lists that you will encounter. Thus, for example, we canﬁnish our Treeexample by declaring it to be an instance of the class Show
very simply as:
instance (Show a)⇒Show(Tree a)where
showsPrec n =showsTree
B.5 The Read Class
Now that we can convert trees into strings, let’s turn to the inverse problem:
converting stringsinto trees. Thebasic ideais todeﬁnea parserfor atype a,
which at ﬁrst glance seems as if it should be a function of type String→a.
This simple approach has two problems, however: (1) it’s possible that thestring is ambiguous, leading to more than one way to interpret it as a valueof typea, and (2) it’s possible that only a preﬁx of the string will parse
correctly. Thus we choose instead to return a list of ( a,String) pairs as the
result of a parse. If all goes well we will always get a singleton list such
as [(v,"")] as the result of a parse, but we cannot count on it (in fact,
when recursively parsing sub-strings, we will expect a singleton list with anon-empty trailing string).
The Standard Prelude provides a type synonym for parsers of the kind
just described:
typeReadS a =String→[(a,String)]
and also deﬁnes a function readsthat by analogy is similar to shows:
reads::(Read a)⇒ReadS a
We will return later to the precise deﬁnition of this function, but for now
let’s use it to deﬁne a parser for the Treedata type, whose string represen-
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 320
tation is as described in the previous section. List comprehensions give us
a convenient idiom for constructing such parsers:1
readsTree ::(Read a)⇒ReadS(Tree a)
readsTree (’<’:s)=[(Branch l r ,u)|(l,’|’:t)←readsTree s ,
(r,’>’:u)←readsTree t ]
readsTree s =[ ( Leaf x,t)|(x,t)←reads s]
Let’s take a moment to examine this function deﬁnition in detail. There
are two main cases to consider: If the string has the form ’<’:swe should
have the representation of a branch, in which case parsing sas a tree should
yield a left branch lfollowed by a string of the form ’|’:t;p a r s i n g tas a
tree should then yield the right branch rfollowed by a string of the form
’>’:u. The resulting tree Branch l r is then returned, along with the
trailing string u. Note the expressive power we get from the combination of
pattern matching and list comprehension.
If the initial string is not of the form ’<’:s, then we must have a leaf,
in which case the string is parsed using the generic readsfunction, and the
result is directly returned.
If we accept on faith for the moment that there is a Readinstance for
Intthat behaves as one would expect, e.g.:
(reads "5 golden rings" )::[(Int,String)]
=⇒[(5," golden rings" )]
then you should be able to verify the following calculations:
readsTree "< <1|2>|3>"
=⇒
There are a couple of shortcomings, however, in our deﬁnition of readsTree .
One is that the parser is quite rigid in that it allows no “white space” (suchas extra spaces, tabs, or line feeds) before or between the elements of thetree representation. The other is that the way we parse our punctuation
symbols ( ’<’,’|’,a n d ’>’) is quite diﬀerent from the way we parse leaf
values and sub-trees. This lack of uniformity makes the function deﬁnitionharder to read.
We can address both of these problems by using a lexical analyzer ,w h i c h
parses a string into primitive “lexemes” deﬁned by some rules about thestring construction. The Standard Prelude deﬁnes a lexical analyzer:
1Anevenmoreelegant approachtoparsingusesmonadsandparsercombinators. These
are part of a standard parsing library distributed with most Haskell systems.
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 321
lex::ReadS String
whose lexical rules are those of the Haskell language, which can be found in
the Haskell Report. For our purposes, an informal explanation is suﬃcient:
lexnormally returns a singleton list containing a pair of strings: the
ﬁrst string is the ﬁrst lexeme in the input string, and the second string isthe remainder of the input. White space – including Haskell comments – iscompletely ignored. If theinputstringis empty or contains only white-spaceand comments, lexreturns [( "","")]; if the input is not empty in this sense,
but also does not begin with a valid lexeme after any leading white-space,
lexreturns [].
Using this lexical analyzer, our tree parser can be rewritten as:
readsTree ::(Read a)⇒ReadS(Tree a)
readsTree s =[(Branch l r ,x)|("<",t)←lex s,
(l, u)←readsTree t ,
("|",v)←lex u,
(r, w)←readsTree v ,
(">",x)←lex w ]
++
[(Leaf x,t)|(x,t)←reads s]
This deﬁnition solves both problems mentioned earlier: white-space is suit-
ably ignored, and parsing of sub-strings has a more uniform structure.
To tie all of this together, let’s ﬁrst look at the deﬁnition of the class
Readin the Standard Prelude:
classRead a where
readsPrec
::Int→ReadS a
readList ::ReadS[a]
readList =readParen False (λr→[pr|("[",s)←lex r,
pr←readl s])
wherereadl s=[ ( [ ],t)|("]",t)←lex s]++
[(x:xs,u)|(x,t)←reads s,
(xs,u)←readl/primet]
readl/primes=[( [],t)|("]",t)←lex s]++
[(x:xs,v)|(",",t)←lex s,
(x,u)←reads t,
(xs,v)←readl/primeu]
readParen ::Bool→ReadS a →ReadS a
readParen b g =ifbthenmandatory elseoptional
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 322
whereoptional r =gr++mandatory r
mandatory r =[(x,u)|("(",s)←lex r,
sc (x,t)←optional s ,
(")",u)←lex t]
The default method for readList is rather tedious, but otherwise straight-
forward.
readscan now be deﬁned, along with an even higher-level function, read:
reads::(Read a)⇒ReadS a
reads=readsPrec 0
read::(Read a)⇒String→a
read s=case[x|(x,t)←reads s,("","")←lex t]of
[x]→x
[]→error "PreludeText.read: no parse"
→error "PreludeText.read: ambiguous parse"
The deﬁnition of reads(likeshows) should not be surprising. The deﬁnition
ofreadassumes that exactly one parse is expected, and thus causes a run-
time error if there is no unique parse or if the input contains anything morethan a representation of exactly one value of type a(and possibly comments
and white-space).
You can test that the ReadandShowinstances for a particular type are
working correctly by applying ( read◦show) to a value in that type, which
in most situations should be the identity function.
B.6 The Index Class
The Standard Prelude deﬁnes a type class of array indices:
class(Ord a)⇒Ix awhere
range ::(a,a)→[a]
index ::(a,a)→a→Int
inRange ::(a,a)→a→Bool
Arrays are deﬁned elsewhere, but the index class is useful for other things
besides arrays, so I will describe it here.
Instance declarations are provided for Int,Integer,Char,Bool,a n d
tuples of Ixtypes; in addition, instances may be automatically derived for
enumerated and tuple types. You should think of the primitive types asvector indices, and tuple types as indices of multidimensional rectangular
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 323
arrays. Note that the ﬁrst argument of each of the operations of class Ixis
a pair of indices; these are typically the bounds(ﬁrst and last indices) of an
array. For example, the bounds of a 10-element, zero-origin vector with Int
indices would be (0 ,9), while a 100 by 100 1-origin matrix might have the
bounds ((1 ,1),(100,100)). (In many other languages, such bounds would
be written in a form like 1 :100 ,1:100, but the present form ﬁts the type
system better, since each bound is of the same type as a general index.)
Therangeoperation takes a bounds pair and produces the list of indices
lying between those bounds, in index order. For example,
range(0,4) =⇒[0,1,2,3,4]
range((0,0),(1,2)) =⇒[(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
TheinRange predicate determines whether an index lies between a given
pair of bounds. (For a tuple type, this test is performed componentwise,and then combined with ( ∧).) Finally, the indexoperation determines the
(zero-based) position of an index within a bounded range; for example:
index(1,9) 2 =⇒1
index((0,0),(1,2)) (1,1) =⇒4
B.7 The Numeric Classes
TheNumclass and the numeric class hierarchy were brieﬂy described in
Section7.5.F i g u r e B.1gives the full class declarations.
APPENDIX B. HASKELL’S STANDARD TYPE CLASSES 324
class(Eq a,Show a)⇒Num a where
(+),(−),(∗)::a→a→a
negate::a→a
abs,signum::a→a
fromInteger ::Integer→a
class(Num a,Ord a)⇒Real a where
toRational ::a→Rational
class(Real a,Enum a)⇒Integral a where
quot,rem,div,mod::a→a→a
quotRem ,divMod::a→a→(a,a)
toInteger ::a→Integer
class(Num a)⇒Fractional a where
(/)::a→a→a
recip::a→a
fromRational ::Rational →a
class(Fractional a )⇒Floating a where
pi::a
exp,log,sqrt::a→a
(∗∗),logBase::a→a→a
sin,cos,tan::a→a
asin,acos,atan::a→a
sinh,cosh,tanh::a→a
asinh,acosh,atanh::a→a
class(Real a,Fractional a )⇒RealFrac a where
properFraction ::(Integral b )⇒a→(b,a)
truncate,round::(Integral b )⇒a→b
ceiling,ﬂoor::(Integral b )⇒a→b
class(RealFrac a ,Floating a )⇒RealFloat a where
ﬂoatRadix ::a→Integer
ﬂoatDigits ::a→Int
ﬂoatRange ::a→(Int,Int)
decodeFloat ::a→(Integer,Int)
encodeFloat ::Integer→Int→a
exponent ::a→Int
signiﬁcand ::a→a
scaleFloat ::Int→a→a
isNaN,isInﬁnite ,isDenormalized ,isNegativeZero ,isIEEE
::a→Bool
Figure B.1: Standard Numeric Classes
Appendix C
Built-in Types Are Not
Special
Throughoutthistext wehave introducedmany“built-in” typessuchaslists,
tuples, integers, and characters. We have also shown how new user-deﬁnedtypes can be deﬁned. Aside from special syntax, you might be wondering ifthe built-in types are in any way more special than the user-deﬁned ones.The answer is no. The special syntax is for convenience and for consistency
with historical convention, but has no semantic consequence.
We can emphasize this point by considering what the type declarations
would look like for these built-in types if in fact we were allowed to use
the special syntax in deﬁning them. For example, the Chartype might be
written as:
dataChar=’a’|’b’|’c’|...-- This is not valid
|’A’|’B’|’C’|...-- Haskell code!
|’1’|’2’|’3’|...
These constructor names are not syntactically valid; to ﬁx them we would
have to write something like:
dataChar=Ca|Cb|Cc|...
|CA|CB|CC|...
|C1|C2|C3|...
Even though these constructors are actually more concise, they are quite
unconventional for representing characters, and thus the special syntax isused instead.
In any case, writing “pseudo-Haskell” code in this way helps us to see
325
APPENDIX C. BUILT-IN TYPES ARE NOT SPECIAL 326
through the special syntax. We see now that Chari sj u s tad a t at y p e
consisting of a large number of nullary (meaning they take no arguments)constructors. Thinking of Charin this way makes it clear why, for example,
we can pattern-match against characters; i.e., we would expect to be ableto do so for any of a data type’s constructors.
Similarly, using pseudo-Haskell, we could deﬁne IntandIntegerby:
-- more pseudo-code:
dataInt=(−2ˆ29)|...|−1|0|1|...|(2ˆ29−1)
dataInteger=...−2|−1|0|1|2...
(Recall that −2
29to 229−1is the minimum range for the Intdata type.)
Intis clearly a much larger enumeration than Char, but it’s still ﬁnite!
In contrast, the pseudo-code for Integer(the type of arbitrary precision
i n t e g e r s )i si n t e n d e dt oc o n v e ya n inﬁniteenumeration (and in that sense
only, the Integerdata type issomewhat special).
Haskell has a data type called unitwhich has exactly one value: ().
The name of this data type is also written (). This is trivially expressed inHaskell pseudo-code:
data() = () -- more pseudo-code
Tuples are also easy to deﬁne playing this game:
data(a,b)= ( a,b) -- more pseudo-code
data(a,b,c)= (a,b,c)
data(a,b,c,d)=(a,b,c,d)
and so on. Each declaration above deﬁnes a tuple type of a particular
length, with parentheses playing a role in both the expression syntax (asdata constructor) and type-expression syntax (as type constructor). By“and so on” we mean that there are an inﬁnite number of such declarations,reﬂecting the fact that tuples of all ﬁnite lengths are allowed in Haskell.
The list data type is also easily handled in pseudo-Haskell, and more
interestingly, it is recursive:
data[a]=[]|a:[a] -- more pseudo-code
inﬁxr5:
We can now see clearly what we described about lists earlier: [] is the empty
list, and (:) is the inﬁx list constructor; thus [1 ,2,3] must be equivalent to
the list 1:2:3:[]. (Note that (:) is right associative.) The type of [] is [ a],
and the type of (:) is a→[a]→[a].
APPENDIX C. BUILT-IN TYPES ARE NOT SPECIAL 327
Details: The way (:)is deﬁned here is actually legal syntax—inﬁx constructors
are permitted in datadeclarations, and are distinguished from inﬁx operators (for
pattern-matching purposes) by the fact that they must begin with a colon (aproperty trivially satisﬁed by “ :”).
At this point the reader should note carefully the diﬀerences between
tuples and lists, which the above deﬁnitions make abundantly clear. Inparticular, note the recursive nature of the list type whose elements arehomogeneous and of arbitrary length, and the non-recursive nature of a(particular) tupletypewhoseelements areheterogeneousandofﬁxedlength.The typing rules for tuples and lists should now also be clear:
For (e
1,e2,...,en),n/greaterorequalslant2, ifTii st h et y p eo f ei, then the type of the
tuple is ( T1,T2,...,Tn).
For [e1,e2,...,en],n/greaterorequalslant0, eacheim u s th a v et h es a m et y p e T,a n dt h e
type of the list is [ T].
Appendix D
Pattern-Matching Details
In this chapter we will look at Haskell’s pattern-matching process in greater
detail.
Haskell deﬁnes a ﬁxed set of patterns for use in case expressions and
function deﬁnitions. Pattern matching is permitted using the constructorsof any type, whether user-deﬁned or pre-deﬁned in Haskell. This includestuples, strings, numbers, characters, etc. For example, here’s a contrived
function that matches against a tuple of “constants:”
contrived ::([a],Char,(Int,Float),String,Bool)→Bool
contrived ([],’b’,(1,2.0),"hi",True)=False
This example also demonstrates that nestingof patterns is permitted (to
arbitrary depth).
Technically speaking, formal parameters to functions are also patterns—
it’s just that they never fail to match a value . As a “side eﬀect” of a
successful match, the formal parameter is bound to the value it is beingmatched against. For this reason patterns in any one equation are notallowed to have more than one occurrence of the same formal parameter.
A pattern that may fail to match is said to be refutable; for example, the
empty list [] is refutable. Patterns such as formal parameters that never fail
to match are said to be irrefutable . There are three other kindsof irrefutable
patterns, which are summarized below.
As-Patterns Sometimes it is convenient to name a pattern for use on the
right-hand side of an equation. For example, a function that duplicates theﬁrst element in a list might be written as:
328
APPENDIX D. PATTERN-MATCHING DETAILS 329
f(x:xs)=x:x:xs
Note that x:xsappears both as a pattern on the left-hand side, and as an
expression on the right-hand side. To improve readability, we might preferto writex:xsjust once, which we can achieve using an as-pattern as follows:
1
fs@(x:xs)=x:s
Technically speaking, as-patterns always result in a successful match, al-
though the sub-pattern (in this case x:xs) could, of course, fail.
Wildcards Another common situation is matching against a value we
really care nothing about. For example, the functions headandtailcan be
written as:
head(x:
)=x
tail(
:xs)=xs
in which we have “advertised” the fact that we don’t care what a certain
part of the input is. Each wildcard will independently match anything, butin contrast to a formal parameter, each will bind nothing; for this reasonmore than one are allowed in an equation.
Lazy Patterns There is one other kind of pattern allowed in Haskell.
It is called a lazy pattern , and has the form ∼pat. Lazy patterns are ir-
refutable: matching a value vagainst∼patalways succeeds, regardless of
pat. Operationally speaking, if an identiﬁer in patis later “used” on the
right-hand-side, it will be bound to that portion of the value that wouldresult ifvwere to successfully match pat,a n d⊥otherwise.
Lazy patterns are useful in contexts where inﬁnite data structures are
being deﬁned recursively. For example, inﬁnite lists are an excellent vehicle
for writing simulation programs, and in this context the inﬁnite lists are
often called streams.
Pattern-Matching Semantics
So far we have discussed how individual patterns are matched, how some are
refutable, some are irrefutable, etc. But what drives the overall process? In
1Another advantage to doing this is that a naive implementation might otherwise com-
pletely reconstruct x:xsrather than re-use the value being matched against.
APPENDIX D. PATTERN-MATCHING DETAILS 330
what order are the matches attempted? What if none succeed? This section
addresses these questions.
Pattern matching can either fail,succeedordiverge. A successful match
binds the formal parameters in the pattern. Divergence occurs when a valueneeded by the pattern diverges (i.e. is non-terminating) or results in an error(⊥). The matching process itself occurs “top-down, left-to-right.” Failure of
a pattern anywhere in one equation results in failure of the whole equation,and the next equation is then tried. If all equations fail, the value of the
function application is ⊥, and results in a run-time error.
For example, if botis a divergent or erroneous computation, and if [1 ,2]
is matched against [0 ,bot], then 1 fails to match 0, so the result is a failed
match. But if [1 ,2] is matched against [ bot,0], then matching 1 against bot
causes divergence (i.e. ⊥).
The only other twist to this set of rules is that top-level patterns may
also have a boolean guard, as in this deﬁnition of a function that forms an
abstract version of a number’s sign:
sign x|x>0= 1
|x== 0 = 0
|x<0=−1
Note here that a sequence of guards is given for a single pattern; as with
patterns, these guards are evaluated top-down, and the ﬁrst that evaluatestoTrueresults in a successful match.
An Example The pattern-matching rules can have subtle eﬀects on the
meaning of functions. For example, consider this deﬁnition of take:
take0
=[]
take
[] =[]
take n(x:xs)=x:take(n−1)xs
and this slightly diﬀerent version (the ﬁrst 2 equations have been reversed):
take1
[] =[]
take10
 =[]
take1 n(x:xs)=x:take1(n−1)xs
APPENDIX D. PATTERN-MATCHING DETAILS 331
Now note the following:
take0bot =⇒[]
take10bot=⇒⊥
take bot[] = ⇒⊥
take1 bot [] =⇒[]
We see that takeis “more deﬁned” with respect to its second argument,
whereas take1is more deﬁned with respect to its ﬁrst. It is diﬃcult to
say in this case which deﬁnition is better. Just remember that in certainapplications, it may make a diﬀerence. (The Standard Prelude includes adeﬁnition corresponding to take.)
Case Expressions
Pattern matching provides a way to “dispatch control” based on structural
properties of a value. However, in many circumstances we don’t wish todeﬁne a function every time we need to do this. Haskell’s case expression
provides a way to solve this problem. Indeed, the meaning of pattern match-ing in function deﬁnitions is speciﬁed in the Haskell Report in terms of case
expressions, which are considered more primitive. In particular, a function
deﬁnition of the form:
fp
11...p1k=e1
...
fpn1...pnk=en
where each pijis a pattern, is semantically equivalent to:
fx1x2...xk=case(x1,...,xk)of(p11,...,p 1k)→e1
...
(pn1,...,pnk)→en
where the xiare new identiﬁers. For example, the deﬁnition of takegiven
earlier is equivalent to:
take m ys =case(m,ys)of
(0,
)→[]
(
,[])→[]
(n,x:xs)→x:take(n−1)xs
APPENDIX D. PATTERN-MATCHING DETAILS 332
For type correctness, the types of the right-hand sides of a case expression
or set of equations comprising a function deﬁnition must all be the same;more precisely, they must all share a common principal type.
The pattern-matching rules for case expressions are the same as we have
given for function deﬁnitions.
Bibliography
[Bir98] R. Bird. Introduction to Functional Programming using Haskell
(second edition) . Prentice Hall, London, 1998.
[BW88] R. Bird and P. Wadler. Introduction to Functional Program-
ming. Prentice Hall, New York, 1988.
[Chu41] A. Church. The Calculi of Lambda Conversion . Princeton Uni-
versity Press, Princeton, NJ, 1941.
[Cor94] Chick Corea. Children’s Songs – 20 Pieces for Keyboard (ED
7254). Schott, Mainz, 1994.
[EH97] C. Elliott and P. Hudak. Functional reactive animation. In In-
ternational Conference on Functional Programming , pages163–
173, June 1997.
[Hin69] R. Hindley. The principal type scheme of an object in combina-
tory logic. Transactions of the American Mathematical Society ,
146:29–60, December 1969.
[HMGW96] Paul Hudak, Tom Makucevich, Syam Gadde, and Bo Whong.
Haskore music notation – an algebra of music. Journal of Func-
tional Programming , 6(3):465–483, May 1996.
[Hof79] D.R. Hofstadter. G¨odel, Escher, Bach: an Eternal Golden
Braid. Vintage, New York, 1979.
[Hud89] P. Hudak. Conception, evolution, and application of functional
programming languages. ACM Computing Surveys , 21(3):359–
411, 1989.
[Hud96] Paul Hudak. Haskore music tutorial. In Second International
School on Advanced Functional Programming , pages 38–68.
Springer Verlag, LNCS 1129, August 1996.
333
BIBLIOGRAPHY 334
[Hud00] PaulHudak. The Haskell School of Expression – Learning Func-
tional Programming th rough Multimedia . Cambridge University
Press, New York, 2000.
[Hud03] Paul Hudak. Describing and interpreting music in Haskell. In
The Fun of Programming , chapter 4. Palgrave, 2003.
[Hug00] John Hughes. Generalising monads to arrows. Science of Com-
puter Programming , 37:67–111, May 2000.
[LH07] Paul Liu and Paul Hudak. Plugging a space leak with an arrow.
Electronic Notes in Theoretical Computer Science , 193:29–45,
November 2007.
[Mil78] R.A. Milner. A theory of type polymorphism in programming.
Journal of Computer and System Sciences , 17(3):348–375, De-
cember 1978.
[MTH90] R. Milner, M. Tofte, and R. Harper. The Deﬁnition of Standard
ML. The MIT Press, Cambridge, MA, 1990.
[P+03] Simon Peyton Jones et al. The Haskell 98 language and li-
braries: The revised report. Journal of Functional Program-
ming, 13(1):0–255, Jan 2003.
[Pat01] Ross Paterson. A new notation for arrows. In ICFP’01: Inter-
national Conference on Functional Programming , pages 229–
240, Firenze, Italy, 2001.
[Qui66] W.V.O. Quine. The Ways of Paradox, and Other Essays .R a n -
dom House, New York, 1966.
[Sch24] M. Sch¨ onﬁnkel. Uber die bausteine der mathematischen logik.
Mathematische Annalen , 92:305, 1924.
[Ver86] B. Vercoe. Csound: A manual for the audio processing system
and supporting programs. Technical report, MIT Media Lab,1986.
